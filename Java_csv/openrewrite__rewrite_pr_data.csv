metadata
"{""instance_id"": ""openrewrite__rewrite-5371"", ""pr_id"": 5371, ""issue_id"": 5357, ""repo"": ""openrewrite/rewrite"", ""problem_statement"": ""Support adding platform dependencies to Gradle project\n<!--\nThank you for suggesting an improvement to OpenRewrite!\nFeel free to delete any sections that don't apply to your request.\n-->\n## What problem are you trying to solve?\nIt would be useful to be able to add platform dependencies to a project.\n\nFollowing from this, with [RemoveRedundantDependencyVersions](https://docs.openrewrite.org/recipes/gradle/removeredundantdependencyversions)\n\n- #3290\n\nmay become possible via a declarative recipe?\n\n## Describe the solution you'd like\nImprove the `AddDependency` recipe to support adding platform dependencies\n\n## Are you interested in [contributing this feature to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#new-features)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\nYes"", ""issue_word_count"": 126, ""test_files_count"": 6, ""non_test_files_count"": 6, ""pr_changed_files"": [""rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/AddPlatformDependency.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleConfigurationFilter.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/internal/AddDependencyVisitor.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/JvmTestSuite.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/Traits.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/AddPlatformDependencyTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindJVMTestSuitesTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/trait/JvmTestSuiteTest.java""], ""pr_changed_test_files"": [""rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/JvmTestSuite.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/AddPlatformDependencyTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindJVMTestSuitesTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/trait/JvmTestSuiteTest.java""], ""base_commit"": ""982ad13ca1282bc9831864670f8bb800454c8e04"", ""head_commit"": ""d01c72117d37b9f2f2335139f9678f703a8b0fa6"", ""repo_url"": ""https://github.com/openrewrite/rewrite/pull/5371"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5371"", ""dockerfile"": """", ""pr_merged_at"": ""2025-06-09T23:56:44.000Z"", ""patch"": ""diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java\nindex e437684e928..55e8bad033e 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java\n@@ -19,9 +19,9 @@\n import lombok.Value;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n-import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n import org.openrewrite.gradle.search.FindJVMTestSuites;\n+import org.openrewrite.gradle.trait.JvmTestSuite;\n import org.openrewrite.internal.StringUtils;\n import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.marker.JavaProject;\n@@ -30,13 +30,12 @@\n import org.openrewrite.java.tree.J;\n import org.openrewrite.java.tree.JavaSourceFile;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n+import org.openrewrite.maven.tree.GroupArtifact;\n import org.openrewrite.semver.Semver;\n \n import java.util.*;\n-import java.util.function.Predicate;\n \n import static java.util.Collections.singletonList;\n-import static java.util.Objects.requireNonNull;\n \n @Value\n @EqualsAndHashCode(callSuper = false)\n@@ -144,7 +143,6 @@ public Validated<Object> validate() {\n     public static class Scanned {\n         Map<JavaProject, Boolean> usingType = new HashMap<>();\n         Map<JavaProject, Set<String>> configurationsByProject = new HashMap<>();\n-        Map<JavaProject, Set<String>> customJvmTestSuitesWithDependencies = new HashMap<>();\n     }\n \n     @Override\n@@ -177,9 +175,6 @@ private boolean usesType(SourceFile sourceFile, ExecutionContext ctx) {\n                 SourceFile sourceFile = (SourceFile) tree;\n                 sourceFile.getMarkers().findFirst(JavaProject.class).ifPresent(javaProject -> {\n                     acc.usingType.compute(javaProject, (jp, usingType) -> Boolean.TRUE.equals(usingType) || usesType(sourceFile, ctx));\n-                    acc.customJvmTestSuitesWithDependencies\n-                            .computeIfAbsent(javaProject, ignored -> new HashSet<>())\n-                            .addAll(FindJVMTestSuites.jvmTestSuiteNames(tree, true));\n \n                     Set<String> configurations = acc.configurationsByProject.computeIfAbsent(javaProject, ignored -> new HashSet<>());\n                     sourceFile.getMarkers().findFirst(JavaSourceSet.class).ifPresent(sourceSet ->\n@@ -202,20 +197,14 @@ public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {\n                         }\n                         JavaSourceFile s = (JavaSourceFile) tree;\n                         Optional<JavaProject> maybeJp = s.getMarkers().findFirst(JavaProject.class);\n-                        if (!maybeJp.isPresent()) {\n-                            return s;\n-                        }\n-\n-                        JavaProject jp = maybeJp.get();\n-                        if ((onlyIfUsing != null && !acc.usingType.getOrDefault(jp, false)) || !acc.configurationsByProject.containsKey(jp)) {\n-                            return s;\n-                        }\n-\n                         Optional<GradleProject> maybeGp = s.getMarkers().findFirst(GradleProject.class);\n-                        if (!maybeGp.isPresent()) {\n+                        if (!maybeJp.isPresent() ||\n+                                (onlyIfUsing != null && !acc.usingType.getOrDefault(maybeJp.get(), false)) || !acc.configurationsByProject.containsKey(maybeJp.get()) ||\n+                                !maybeGp.isPresent()) {\n                             return s;\n                         }\n \n+                        JavaProject jp = maybeJp.get();\n                         GradleProject gp = maybeGp.get();\n \n                         Set<String> resolvedConfigurations = StringUtils.isBlank(configuration) ?\n@@ -224,36 +213,26 @@ public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {\n                         if (resolvedConfigurations.isEmpty()) {\n                             resolvedConfigurations.add(\""implementation\"");\n                         }\n-                        Set<String> tmpConfigurations = new HashSet<>(resolvedConfigurations);\n-                        for (String tmpConfiguration : tmpConfigurations) {\n-                            GradleDependencyConfiguration gdc = gp.getConfiguration(tmpConfiguration);\n-                            if (gdc == null || gdc.findRequestedDependency(groupId, artifactId) != null) {\n-                                resolvedConfigurations.remove(tmpConfiguration);\n-                            }\n-                        }\n \n-                        tmpConfigurations = new HashSet<>(resolvedConfigurations);\n-                        for (String tmpConfiguration : tmpConfigurations) {\n-                            GradleDependencyConfiguration gdc = requireNonNull((gp.getConfiguration(tmpConfiguration)));\n-                            for (GradleDependencyConfiguration transitive : gp.configurationsExtendingFrom(gdc, true)) {\n-                                if (resolvedConfigurations.contains(transitive.getName()) ||\n-                                        (Boolean.TRUE.equals(acceptTransitive) && transitive.findResolvedDependency(groupId, artifactId) != null)) {\n-                                    resolvedConfigurations.remove(transitive.getName());\n-                                }\n-                            }\n-                        }\n+                        GradleConfigurationFilter gradleConfigurationFilter = new GradleConfigurationFilter(gp, resolvedConfigurations);\n+                        gradleConfigurationFilter.removeTransitiveConfigurations();\n+                        gradleConfigurationFilter.removeConfigurationsContainingDependency(new GroupArtifact(groupId, artifactId));\n+                        gradleConfigurationFilter.removeConfigurationsContainingTransitiveDependency(new GroupArtifact(groupId, artifactId));\n+                        resolvedConfigurations = gradleConfigurationFilter.getFilteredConfigurations();\n \n                         if (resolvedConfigurations.isEmpty()) {\n                             return s;\n                         }\n \n+                        Set<JvmTestSuite> jvmTestSuites = FindJVMTestSuites.jvmTestSuites(s);\n                         for (String resolvedConfiguration : resolvedConfigurations) {\n-                            if (targetsCustomJVMTestSuite(resolvedConfiguration, acc.customJvmTestSuitesWithDependencies.get(jp))) {\n-                                s = (JavaSourceFile) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, purgeSourceSet(configuration),\n-                                        classifier, extension, metadataFailures, isMatchingJVMTestSuite(resolvedConfiguration)).visitNonNull(s, ctx);\n+                            JvmTestSuite jvmTestSuite = maybeJvmTestSuite(resolvedConfiguration, jvmTestSuites);\n+                            if (jvmTestSuite != null) {\n+                                s = (JavaSourceFile) jvmTestSuite.addDependency(resolvedConfiguration, groupId, artifactId, version, versionPattern, classifier, extension, metadataFailures, null, ctx)\n+                                        .visitNonNull(s, ctx);\n                             } else {\n                                 s = (JavaSourceFile) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, resolvedConfiguration,\n-                                        classifier, extension, metadataFailures, this::isTopLevel).visitNonNull(s, ctx);\n+                                        classifier, extension, metadataFailures, this::isTopLevel, null).visitNonNull(s, ctx);\n                             }\n                         }\n \n@@ -264,59 +243,13 @@ private boolean isTopLevel(Cursor cursor) {\n                         return cursor.getParentOrThrow().firstEnclosing(J.MethodInvocation.class) == null;\n                     }\n \n-                    private Predicate<Cursor> isMatchingJVMTestSuite(String resolvedConfiguration) {\n-                        return cursor -> {\n-                            String sourceSet = purgeConfigurationSuffix(resolvedConfiguration);\n-                            J.MethodInvocation methodInvocation = cursor.getParentOrThrow().firstEnclosing(J.MethodInvocation.class);\n-                            return methodInvocation != null && sourceSet.equals(methodInvocation.getSimpleName());\n-                        };\n-                    }\n-\n-                    private final Set<String> gradleStandardConfigurations = new HashSet<>(Arrays.asList(\n-                            \""api\"",\n-                            \""implementation\"",\n-                            \""compileOnly\"",\n-                            \""compileOnlyApi\"",\n-                            \""runtimeOnly\"",\n-                            \""testImplementation\"",\n-                            \""testCompileOnly\"",\n-                            \""testRuntimeOnly\""));\n-\n-                    boolean targetsCustomJVMTestSuite(String configuration, Set<String> customJvmTestSuites) {\n-                        if (gradleStandardConfigurations.contains(configuration) || \""default\"".equals(configuration)) {\n-                            return false;\n-                        }\n-\n-                        String sourceSet = purgeConfigurationSuffix(configuration);\n-                        return customJvmTestSuites.contains(sourceSet);\n-                    }\n-\n-                    private String purgeConfigurationSuffix(String configuration) {\n-                        if (configuration.endsWith(\""Implementation\"")) {\n-                            return configuration.substring(0, configuration.length() - 14);\n-                        } else if (configuration.endsWith(\""CompileOnly\"")) {\n-                            return configuration.substring(0, configuration.length() - 11);\n-                        } else if (configuration.endsWith(\""RuntimeOnly\"")) {\n-                            return configuration.substring(0, configuration.length() - 11);\n-                        } else if (configuration.endsWith(\""AnnotationProcessor\"")) {\n-                            return configuration.substring(0, configuration.length() - 19);\n-                        } else {\n-                            return configuration;\n-                        }\n-                    }\n-\n-                    private String purgeSourceSet(@Nullable String configuration) {\n-                        if (StringUtils.isBlank(configuration) || configuration.endsWith(\""Implementation\"")) {\n-                            return \""implementation\"";\n-                        } else if (configuration.endsWith(\""CompileOnly\"")) {\n-                            return \""compileOnly\"";\n-                        } else if (configuration.endsWith(\""RuntimeOnly\"")) {\n-                            return \""runtimeOnly\"";\n-                        } else if (configuration.endsWith(\""AnnotationProcessor\"")) {\n-                            return \""annotationProcessor\"";\n-                        } else {\n-                            return configuration;\n+                    private @Nullable JvmTestSuite maybeJvmTestSuite(String configuration, Set<JvmTestSuite> jvmTestSuites) {\n+                        for (JvmTestSuite jvmTestSuite : jvmTestSuites) {\n+                            if (jvmTestSuite.isAcceptable(configuration)) {\n+                                return jvmTestSuite;\n+                            }\n                         }\n+                        return null;\n                     }\n                 })\n         );\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\nindex d07ceb664e8..be762ea59fe 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\n@@ -19,46 +19,23 @@\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.Cursor;\n import org.openrewrite.ExecutionContext;\n-import org.openrewrite.SourceFile;\n import org.openrewrite.Tree;\n-import org.openrewrite.gradle.internal.InsertDependencyComparator;\n import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n-import org.openrewrite.groovy.tree.G;\n-import org.openrewrite.internal.ListUtils;\n import org.openrewrite.internal.StringUtils;\n import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.MethodMatcher;\n import org.openrewrite.java.tree.J;\n import org.openrewrite.java.tree.JavaSourceFile;\n-import org.openrewrite.java.tree.Space;\n-import org.openrewrite.java.tree.Statement;\n import org.openrewrite.kotlin.tree.K;\n-import org.openrewrite.marker.Markup;\n import org.openrewrite.maven.MavenDownloadingException;\n-import org.openrewrite.maven.MavenDownloadingExceptions;\n-import org.openrewrite.maven.internal.MavenPomDownloader;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n-import org.openrewrite.maven.tree.*;\n-import org.openrewrite.tree.ParseError;\n+import org.openrewrite.maven.tree.GroupArtifact;\n+import org.openrewrite.maven.tree.GroupArtifactVersion;\n \n-import java.io.ByteArrayInputStream;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Paths;\n-import java.util.*;\n import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.util.Collections.emptyList;\n-import static java.util.Collections.singletonList;\n-import static java.util.Objects.requireNonNull;\n \n @RequiredArgsConstructor\n public class AddDependencyVisitor extends JavaIsoVisitor<ExecutionContext> {\n-    private static final MethodMatcher DEPENDENCIES_DSL_MATCHER = new MethodMatcher(\""RewriteGradleProject dependencies(..)\"");\n-    private static final GradleParser GRADLE_PARSER = GradleParser.builder().build();\n-\n     private final String groupId;\n     private final String artifactId;\n \n@@ -85,354 +62,63 @@ public class AddDependencyVisitor extends JavaIsoVisitor<ExecutionContext> {\n     @Nullable\n     private final Predicate<Cursor> insertPredicate;\n \n+    @Nullable\n+    private final DependencyModifier dependencyModifier;\n+\n+    @Nullable\n+    private transient GradleProject gradleProject;\n+\n+    private transient boolean isKotlinDsl;\n+\n     @Override\n     public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n         if (tree instanceof JavaSourceFile) {\n-            JavaSourceFile cu = (JavaSourceFile) super.visit(tree, ctx);\n-            Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);\n-            if (!maybeGp.isPresent()) {\n-                return cu;\n+            JavaSourceFile sourceFile = (JavaSourceFile) tree;\n+            gradleProject = sourceFile.getMarkers().findFirst(GradleProject.class).orElse(null);\n+            if (gradleProject == null) {\n+                return sourceFile;\n             }\n \n-            GradleProject gp = maybeGp.get();\n-            GradleDependencyConfiguration gdc = gp.getConfiguration(configuration);\n+            GradleDependencyConfiguration gdc = gradleProject.getConfiguration(configuration);\n             if (gdc == null || gdc.findRequestedDependency(groupId, artifactId) != null) {\n-                return cu;\n-            }\n-\n-            boolean dependenciesBlockMissing = true;\n-            if (cu instanceof G.CompilationUnit) {\n-                G.CompilationUnit g = (G.CompilationUnit) cu;\n-                for (Statement statement : g.getStatements()) {\n-                    if (statement instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) statement)) {\n-                        dependenciesBlockMissing = false;\n-                    }\n-                }\n-            } else if (cu instanceof K.CompilationUnit) {\n-                K.CompilationUnit k = (K.CompilationUnit) cu;\n-                for (Statement statement : ((J.Block) k.getStatements().get(0)).getStatements()) {\n-                    if (statement instanceof J.MethodInvocation && ((J.MethodInvocation) statement).getSimpleName().equals(\""dependencies\"")) {\n-                        dependenciesBlockMissing = false;\n-                    }\n-                }\n-            }\n-\n-            if (dependenciesBlockMissing) {\n-                if (cu instanceof G.CompilationUnit) {\n-                    G.CompilationUnit g = (G.CompilationUnit) cu;\n-                    Statement dependenciesInvocation = GRADLE_PARSER.parse(ctx, \""dependencies {}\"")\n-                            .findFirst()\n-                            .map(G.CompilationUnit.class::cast)\n-                            .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""))\n-                            .getStatements().get(0);\n-                    Cursor parent = getCursor();\n-                    setCursor(new Cursor(parent, g));\n-                    dependenciesInvocation = autoFormat(dependenciesInvocation, ctx, new Cursor(parent, g));\n-                    setCursor(parent);\n-                    cu = g.withStatements(ListUtils.concat(g.getStatements(),\n-                            g.getStatements().isEmpty() ?\n-                                    dependenciesInvocation :\n-                                    dependenciesInvocation.withPrefix(Space.format(\""\\n\\n\""))));\n-                } else {\n-                    K.CompilationUnit k = (K.CompilationUnit) cu;\n-                    J.MethodInvocation dependenciesInvocation = (J.MethodInvocation) ((J.Block) GRADLE_PARSER.parseInputs(Collections.singletonList(new GradleParser.Input(Paths.get(\""build.gradle.kts\""), () -> new ByteArrayInputStream(\""dependencies {}\"".getBytes(StandardCharsets.UTF_8)))), null, ctx)\n-                            .findFirst()\n-                            .map(K.CompilationUnit.class::cast)\n-                            .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""))\n-                            .getStatements().get(0)).getStatements().get(0);\n-                    Cursor parent = getCursor();\n-                    setCursor(new Cursor(parent, k));\n-                    dependenciesInvocation = autoFormat(dependenciesInvocation, ctx, new Cursor(getCursor(), k));\n-                    setCursor(parent);\n-                    dependenciesInvocation = dependenciesInvocation.withArguments(ListUtils.mapFirst(dependenciesInvocation.getArguments(), arg -> {\n-                        J.Lambda lambda = (J.Lambda) requireNonNull(arg);\n-                        J.Block block = (J.Block) lambda.getBody();\n-                        return lambda.withBody(block.withEnd(Space.format(\""\\n\"")));\n-                    }));\n-                    cu = k.withStatements(ListUtils.concat(k.getStatements(),\n-                            k.getStatements().isEmpty() ?\n-                                    dependenciesInvocation :\n-                                    dependenciesInvocation.withPrefix(Space.format(\""\\n\\n\""))));\n-                }\n-            }\n-\n-            cu = (JavaSourceFile) new InsertDependencyInOrder(configuration, gp)\n-                    .visitNonNull(cu, ctx);\n-\n-            if (cu != tree) {\n-                String versionWithPattern = StringUtils.isBlank(resolvedVersion) || resolvedVersion.startsWith(\""$\"") ? null : resolvedVersion;\n-                cu = addDependency(cu,\n-                        gdc,\n-                        new GroupArtifactVersion(groupId, artifactId, versionWithPattern),\n-                        classifier,\n-                        ctx);\n-            }\n-            return cu;\n-        }\n-        return super.visit(tree, ctx);\n-    }\n-\n-    /**\n-     * Update the dependency model, adding the specified dependency to the specified configuration and all configurations\n-     * which extend from it.\n-     *\n-     * @param buildScript   compilation unit owning the {@link GradleProject} marker\n-     * @param configuration the configuration to add the dependency to\n-     * @param gav           the group, artifact, and version of the dependency to add\n-     * @param classifier    the classifier of the dependency to add\n-     * @param ctx           context which will be used to download the pom for the dependency\n-     * @return a copy of buildScript with the dependency added\n-     */\n-    static JavaSourceFile addDependency(\n-            JavaSourceFile buildScript,\n-            @Nullable GradleDependencyConfiguration configuration,\n-            GroupArtifactVersion gav,\n-            @Nullable String classifier,\n-            ExecutionContext ctx) {\n-        if (gav.getGroupId() == null || gav.getArtifactId() == null || configuration == null) {\n-            return buildScript;\n-        }\n-        GradleProject gp = buildScript.getMarkers().findFirst(GradleProject.class)\n-                .orElseThrow(() -> new IllegalArgumentException(\""Could not find GradleProject\""));\n-\n-        try {\n-            ResolvedGroupArtifactVersion resolvedGav;\n-            List<ResolvedDependency> transitiveDependencies;\n-            if (gav.getVersion() == null) {\n-                resolvedGav = null;\n-                transitiveDependencies = Collections.emptyList();\n-            } else {\n-                MavenPomDownloader mpd = new MavenPomDownloader(ctx);\n-                Pom pom = mpd.download(gav, null, null, gp.getMavenRepositories());\n-                ResolvedPom resolvedPom = pom.resolve(emptyList(), mpd, gp.getMavenRepositories(), ctx);\n-                resolvedGav = resolvedPom.getGav();\n-                transitiveDependencies = resolvedPom.resolveDependencies(Scope.Runtime, mpd, ctx);\n-            }\n-            Map<String, GradleDependencyConfiguration> nameToConfiguration = gp.getNameToConfiguration();\n-            Map<String, GradleDependencyConfiguration> newNameToConfiguration = new HashMap<>(nameToConfiguration.size());\n-\n-            Set<GradleDependencyConfiguration> configurationsToAdd = Stream.concat(\n-                            Stream.of(configuration),\n-                            gp.configurationsExtendingFrom(configuration, true).stream())\n-                    .collect(Collectors.toSet());\n-\n-            for (GradleDependencyConfiguration gdc : nameToConfiguration.values()) {\n-                if (!configurationsToAdd.contains(gdc)) {\n-                    newNameToConfiguration.put(gdc.getName(), gdc);\n-                    continue;\n-                }\n-\n-                GradleDependencyConfiguration newGdc = gdc;\n-                org.openrewrite.maven.tree.Dependency newRequested = new org.openrewrite.maven.tree.Dependency(\n-                        gav, classifier, \""jar\"", gdc.getName(), emptyList(), null);\n-                newGdc = newGdc.withRequested(ListUtils.concat(\n-                        ListUtils.map(gdc.getRequested(), requested -> {\n-                            // Remove any existing dependency with the same group and artifact id\n-                            if (Objects.equals(requested.getGroupId(), gav.getGroupId()) && Objects.equals(requested.getArtifactId(), gav.getArtifactId())) {\n-                                return null;\n-                            }\n-                            return requested;\n-                        }),\n-                        newRequested));\n-                if (newGdc.isCanBeResolved() && resolvedGav != null) {\n-                    newGdc = newGdc.withDirectResolved(ListUtils.concat(\n-                            ListUtils.map(gdc.getDirectResolved(), resolved -> {\n-                                // Remove any existing dependency with the same group and artifact id\n-                                if (Objects.equals(resolved.getGroupId(), resolvedGav.getGroupId()) && Objects.equals(resolved.getArtifactId(), resolvedGav.getArtifactId())) {\n-                                    return null;\n-                                }\n-                                return resolved;\n-                            }),\n-                            new ResolvedDependency(null, resolvedGav, newRequested, transitiveDependencies,\n-                                    emptyList(), \""jar\"", classifier, null, 0, null)));\n-                }\n-                newNameToConfiguration.put(newGdc.getName(), newGdc);\n-            }\n-            gp = gp.withNameToConfiguration(newNameToConfiguration);\n-        } catch (MavenDownloadingException | MavenDownloadingExceptions | IllegalArgumentException e) {\n-            return Markup.warn(buildScript, e);\n-        }\n-        return buildScript.withMarkers(buildScript.getMarkers().setByType(gp));\n-    }\n-\n-    @RequiredArgsConstructor\n-    private class InsertDependencyInOrder extends JavaIsoVisitor<ExecutionContext> {\n-        private final String configuration;\n-\n-        private final GradleProject gp;\n-\n-        @Override\n-        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n-            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n-            boolean isKotlinDsl = getCursor().firstEnclosing(JavaSourceFile.class) instanceof K.CompilationUnit;\n-            if (!DEPENDENCIES_DSL_MATCHER.matches(m) && !(isKotlinDsl && m.getSimpleName().equals(\""dependencies\""))) {\n-                return m;\n-            }\n-\n-            if (insertPredicate != null && !insertPredicate.test(getCursor())) {\n-                return m;\n-            }\n-\n-            J.Lambda dependenciesBlock = (J.Lambda) m.getArguments().get(0);\n-            if (!(dependenciesBlock.getBody() instanceof J.Block)) {\n-                return m;\n+                return sourceFile;\n             }\n \n+            isKotlinDsl = sourceFile instanceof K.CompilationUnit;\n             if (version != null) {\n                 if (version.startsWith(\""$\"")) {\n                     resolvedVersion = version;\n                 } else {\n                     try {\n-                        resolvedVersion = new DependencyVersionSelector(metadataFailures, gp, null)\n+                        resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)\n                                 .select(new GroupArtifact(groupId, artifactId), configuration, version, versionPattern, ctx);\n                     } catch (MavenDownloadingException e) {\n-                        return e.warn(m);\n+                        return (J) e.warn(tree);\n                     }\n                 }\n             }\n \n-            J.Block body = (J.Block) dependenciesBlock.getBody();\n-\n-            String codeTemplate;\n-            DependencyStyle style = autodetectDependencyStyle(body.getStatements());\n-            if (style == DependencyStyle.String) {\n-                if (!isKotlinDsl) {\n-                    codeTemplate = \""dependencies {\\n\"" +\n-                                   escapeIfNecessary(configuration) + \"" \\\""\"" + groupId + \"":\"" + artifactId + (resolvedVersion == null ? \""\"" : \"":\"" + resolvedVersion) + (resolvedVersion == null || classifier == null ? \""\"" : \"":\"" + classifier) + (extension == null ? \""\"" : \""@\"" + extension) + \""\\\""\"" +\n-                                   \""\\n}\"";\n-                } else {\n-                    codeTemplate = \""dependencies {\\n\"" +\n-                                   configuration + \""(\\\""\"" + groupId + \"":\"" + artifactId + (resolvedVersion == null ? \""\"" : \"":\"" + resolvedVersion) + (resolvedVersion == null || classifier == null ? \""\"" : \"":\"" + classifier) + (extension == null ? \""\"" : \""@\"" + extension) + \""\\\"")\"" +\n-                                   \""\\n}\"";\n-                }\n-            } else {\n-                if (!isKotlinDsl) {\n-                    codeTemplate = \""dependencies {\\n\"" +\n-                                   escapeIfNecessary(configuration) + \"" group: \\\""\"" + groupId + \""\\\"", name: \\\""\"" + artifactId + \""\\\""\"" + (resolvedVersion == null ? \""\"" : \"", version: \\\""\"" + resolvedVersion + \""\\\""\"") + (classifier == null ? \""\"" : \"", classifier: \\\""\"" + classifier + \""\\\""\"") + (extension == null ? \""\"" : \"", ext: \\\""\"" + extension + \""\\\""\"") +\n-                                   \""\\n}\"";\n-                } else {\n-                    codeTemplate = \""dependencies {\\n\"" +\n-                                   configuration + \""(group = \\\""\"" + groupId + \""\\\"", name = \\\""\"" + artifactId + \""\\\""\"" + (resolvedVersion == null ? \""\"" : \"", version = \\\""\"" + resolvedVersion + \""\\\""\"") + (classifier == null ? \""\"" : \"", classifier = \\\""\"" + classifier + \""\\\""\"") + (extension == null ? \""\"" : \"", ext = \\\""\"" + extension + \""\\\""\"") + \"")\"" +\n-                                   \""\\n}\"";\n-                }\n-            }\n-\n-            Boolean requirePrintEqualsInput = ctx.getMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT);\n-            ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, false);\n-            SourceFile parsed;\n-            if (!isKotlinDsl) {\n-                parsed = GRADLE_PARSER.parse(ctx, codeTemplate)\n-                        .findFirst()\n-                        .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""));\n-            } else {\n-                parsed = GRADLE_PARSER.parseInputs(Collections.singletonList(new GradleParser.Input(Paths.get(\""build.gradle.kts\""), () -> new ByteArrayInputStream(codeTemplate.getBytes(StandardCharsets.UTF_8)))), null, ctx)\n-                        .findFirst()\n-                        .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""));\n-            }\n-            ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, requirePrintEqualsInput);\n-\n-            if (parsed instanceof ParseError) {\n-                throw ((ParseError) parsed).toException();\n-            }\n-\n-            J.MethodInvocation addDependencyInvocation;\n-            if (!isKotlinDsl) {\n-                addDependencyInvocation = requireNonNull((J.MethodInvocation) ((J.Return) (((J.Block) ((J.Lambda) ((J.MethodInvocation)\n-                        ((G.CompilationUnit) parsed).getStatements().get(0)).getArguments().get(0)).getBody()).getStatements().get(0))).getExpression());\n-            } else {\n-                addDependencyInvocation = requireNonNull((J.MethodInvocation) (((J.Block) ((J.Lambda) ((J.MethodInvocation)\n-                        ((J.Block) ((K.CompilationUnit) parsed).getStatements().get(0)).getStatements().get(0)).getArguments().get(0)).getBody()).getStatements().get(0)));\n-            }\n-            addDependencyInvocation = autoFormat(addDependencyInvocation, ctx, new Cursor(getCursor(), body));\n-            InsertDependencyComparator dependencyComparator = new InsertDependencyComparator(body.getStatements(), addDependencyInvocation);\n-\n-            List<Statement> statements = new ArrayList<>(body.getStatements());\n-            int i = 0;\n-            for (; i < body.getStatements().size(); i++) {\n-                Statement currentStatement = body.getStatements().get(i);\n-                if (dependencyComparator.compare(currentStatement, addDependencyInvocation) > 0) {\n-                    if (dependencyComparator.getBeforeDependency() != null) {\n-                        J.MethodInvocation beforeDependency = (J.MethodInvocation) (dependencyComparator.getBeforeDependency() instanceof J.Return ?\n-                                requireNonNull(((J.Return) dependencyComparator.getBeforeDependency()).getExpression()) :\n-                                dependencyComparator.getBeforeDependency());\n-                        if (i == 0) {\n-                            if (!addDependencyInvocation.getSimpleName().equals(beforeDependency.getSimpleName())) {\n-                                statements.set(i, currentStatement.withPrefix(Space.format(\""\\n\\n\"" + currentStatement.getPrefix().getIndent())));\n-                            }\n-                        } else {\n-                            Space originalPrefix = addDependencyInvocation.getPrefix();\n-                            addDependencyInvocation = addDependencyInvocation.withPrefix(currentStatement.getPrefix());\n+            sourceFile = (JavaSourceFile) new org.openrewrite.gradle.internal.AddDependencyVisitor(configuration, groupId, artifactId, resolvedVersion, classifier, extension, insertPredicate, dependencyModifier, isKotlinDsl)\n+                    .visitNonNull(sourceFile, ctx);\n \n-                            if (addDependencyInvocation.getSimpleName().equals(beforeDependency.getSimpleName())) {\n-                                if (!currentStatement.getPrefix().equals(originalPrefix)) {\n-                                    statements.set(i, currentStatement.withPrefix(originalPrefix));\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    statements.add(i, addDependencyInvocation);\n-                    break;\n-                }\n-            }\n-            if (body.getStatements().size() == i) {\n-                if (!body.getStatements().isEmpty()) {\n-                    Statement lastStatement;\n-                    if (statements.get(i - 1) instanceof J.Return) {\n-                        J.Return r = (J.Return) statements.remove(i - 1);\n-                        lastStatement = requireNonNull(r.getExpression()).withPrefix(r.getPrefix());\n-                        statements.add(lastStatement);\n-                    } else {\n-                        lastStatement = statements.get(i - 1);\n-                    }\n-                    if (lastStatement instanceof J.MethodInvocation && !((J.MethodInvocation) lastStatement).getSimpleName().equals(addDependencyInvocation.getSimpleName())) {\n-                        addDependencyInvocation = addDependencyInvocation.withPrefix(Space.format(\""\\n\\n\"" + addDependencyInvocation.getPrefix().getIndent()));\n-                    }\n-                }\n-                statements.add(addDependencyInvocation);\n+            if (sourceFile != tree) {\n+                String versionWithPattern = StringUtils.isBlank(resolvedVersion) || resolvedVersion.startsWith(\""$\"") ? null : resolvedVersion;\n+                sourceFile = org.openrewrite.gradle.internal.AddDependencyVisitor.addDependency(\n+                        sourceFile,\n+                        gradleProject.getConfiguration(configuration),\n+                        new GroupArtifactVersion(groupId, artifactId, versionWithPattern),\n+                        classifier,\n+                        ctx\n+                );\n             }\n-            body = body.withStatements(statements);\n-            m = m.withArguments(singletonList(dependenciesBlock.withBody(body)));\n \n-            return m;\n+            return sourceFile;\n         }\n+        return (J) tree;\n     }\n \n-    private String escapeIfNecessary(String configurationName) {\n-        // default is a gradle configuration created by the base plugin and a groovy keyword if\n-        // it is used it needs to be escaped\n-        return configurationName.equals(\""default\"") ? \""'\"" + configurationName + \""'\"" : configurationName;\n-    }\n-\n-    enum DependencyStyle {\n-        Map, String\n-    }\n-\n-    private DependencyStyle autodetectDependencyStyle(List<Statement> statements) {\n-        int string = 0;\n-        int map = 0;\n-        for (Statement statement : statements) {\n-            if (statement instanceof J.Return && ((J.Return) statement).getExpression() instanceof J.MethodInvocation) {\n-                J.MethodInvocation invocation = (J.MethodInvocation) ((J.Return) statement).getExpression();\n-                if (invocation.getArguments().get(0) instanceof J.Literal || invocation.getArguments().get(0) instanceof G.GString) {\n-                    string++;\n-                } else if (invocation.getArguments().get(0) instanceof G.MapEntry) {\n-                    map++;\n-                } else if (invocation.getArguments().get(0) instanceof J.Assignment) {\n-                    map++;\n-                }\n-            } else if (statement instanceof J.MethodInvocation) {\n-                J.MethodInvocation invocation = (J.MethodInvocation) statement;\n-                if (invocation.getArguments().get(0) instanceof J.Literal || invocation.getArguments().get(0) instanceof G.GString) {\n-                    string++;\n-                } else if (invocation.getArguments().get(0) instanceof G.MapEntry) {\n-                    map++;\n-                } else if (invocation.getArguments().get(0) instanceof J.Assignment) {\n-                    map++;\n-                }\n-            }\n-        }\n-\n-        return string >= map ? DependencyStyle.String : DependencyStyle.Map;\n+    public enum DependencyModifier {\n+        PLATFORM,\n+        ENFORCED_PLATFORM;\n     }\n }\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddPlatformDependency.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddPlatformDependency.java\nnew file mode 100644\nindex 00000000000..d4f72368f2e\n--- /dev/null\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddPlatformDependency.java\n@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.Value;\n+import org.jspecify.annotations.Nullable;\n+import org.openrewrite.*;\n+import org.openrewrite.gradle.marker.GradleProject;\n+import org.openrewrite.gradle.search.FindJVMTestSuites;\n+import org.openrewrite.gradle.trait.JvmTestSuite;\n+import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n+import org.openrewrite.java.marker.JavaProject;\n+import org.openrewrite.java.marker.JavaSourceSet;\n+import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaSourceFile;\n+import org.openrewrite.maven.table.MavenMetadataFailures;\n+import org.openrewrite.maven.tree.GroupArtifact;\n+import org.openrewrite.semver.Semver;\n+\n+import java.util.*;\n+\n+import static java.lang.Boolean.TRUE;\n+import static java.util.Collections.singletonList;\n+import static org.openrewrite.gradle.AddDependencyVisitor.DependencyModifier.ENFORCED_PLATFORM;\n+import static org.openrewrite.gradle.AddDependencyVisitor.DependencyModifier.PLATFORM;\n+\n+@Value\n+@EqualsAndHashCode(callSuper = false)\n+public class AddPlatformDependency extends ScanningRecipe<AddPlatformDependency.Scanned> {\n+\n+    @EqualsAndHashCode.Exclude\n+    MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);\n+\n+    @Option(displayName = \""Group\"",\n+            description = \""The first part of a dependency coordinate 'com.google.guava:guava:VERSION'.\"",\n+            example = \""com.google.guava\"")\n+    String groupId;\n+\n+    @Option(displayName = \""Artifact\"",\n+            description = \""The second part of a dependency coordinate 'com.google.guava:guava:VERSION'\"",\n+            example = \""guava\"")\n+    String artifactId;\n+\n+    @Option(displayName = \""Version\"",\n+            description = \""An exact version number or node-style semver selector used to select the version number. \"" +\n+                    \""You can also use `latest.release` for the latest available version and `latest.patch` if \"" +\n+                    \""the current version is a valid semantic version. For more details, you can look at the documentation \"" +\n+                    \""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors).\"",\n+            example = \""29.X\"",\n+            required = false)\n+    @Nullable\n+    String version;\n+\n+    @Option(displayName = \""Version pattern\"",\n+            description = \""Allows version selection to be extended beyond the original Node Semver semantics. So for example, \"" +\n+                    \""Setting 'version' to \\\""25-29\\\"" can be paired with a metadata pattern of \\\""-jre\\\"" to select Guava 29.0-jre\"",\n+            example = \""-jre\"",\n+            required = false)\n+    @Nullable\n+    String versionPattern;\n+\n+    @Option(displayName = \""Configuration\"",\n+            description = \""A configuration to use when it is not what can be inferred from usage. Most of the time this will be left empty, but \"" +\n+                    \""is used when adding a new as of yet unused dependency.\"",\n+            example = \""implementation\"",\n+            required = false)\n+    @Nullable\n+    String configuration;\n+\n+    @Option(displayName = \""Enforced\"",\n+            description = \""Used to determine whether the platform dependency should be enforcedPlatform.\"",\n+            example = \""true\"",\n+            required = false)\n+    @Nullable\n+    Boolean enforced;\n+\n+    @Override\n+    public String getDisplayName() {\n+        return \""Add Gradle platform dependency\"";\n+    }\n+\n+    @Override\n+    public String getInstanceNameSuffix() {\n+        return String.format(\""`%s:%s:%s`\"", groupId, artifactId, version);\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \""Add a gradle platform dependency to a `build.gradle` file in the correct configuration based on where it is used.\"";\n+    }\n+\n+    @Override\n+    public Validated<Object> validate() {\n+        Validated<Object> validated = super.validate();\n+        if (version != null) {\n+            validated = validated.and(Semver.validate(version, versionPattern));\n+        }\n+        return validated;\n+    }\n+\n+    public static class Scanned {\n+        Map<JavaProject, Set<String>> configurationsByProject = new HashMap<>();\n+    }\n+\n+    @Override\n+    public Scanned getInitialValue(ExecutionContext ctx) {\n+        return new Scanned();\n+    }\n+\n+    @Override\n+    public TreeVisitor<?, ExecutionContext> getScanner(Scanned acc) {\n+        return new TreeVisitor<Tree, ExecutionContext>() {\n+\n+            @Override\n+            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                if (!(tree instanceof SourceFile)) {\n+                    return tree;\n+                }\n+                SourceFile sourceFile = (SourceFile) tree;\n+                sourceFile.getMarkers().findFirst(JavaProject.class).ifPresent(javaProject -> {\n+                    Set<String> configurations = acc.configurationsByProject.computeIfAbsent(javaProject, ignored -> new HashSet<>());\n+                    sourceFile.getMarkers().findFirst(JavaSourceSet.class).ifPresent(sourceSet ->\n+                            configurations.add(\""main\"".equals(sourceSet.getName()) ? \""implementation\"" : sourceSet.getName() + \""Implementation\""));\n+                });\n+                return tree;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {\n+        return Preconditions.check(!acc.configurationsByProject.isEmpty(),\n+                Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {\n+\n+                    @Override\n+                    public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                        if (!(tree instanceof JavaSourceFile)) {\n+                            return (J) tree;\n+                        }\n+                        JavaSourceFile s = (JavaSourceFile) tree;\n+                        Optional<JavaProject> maybeJp = s.getMarkers().findFirst(JavaProject.class);\n+                        Optional<GradleProject> maybeGp = s.getMarkers().findFirst(GradleProject.class);\n+                        if (!maybeJp.isPresent() || !acc.configurationsByProject.containsKey(maybeJp.get()) || !maybeGp.isPresent()) {\n+                            return s;\n+                        }\n+\n+                        JavaProject jp = maybeJp.get();\n+                        GradleProject gp = maybeGp.get();\n+\n+                        Set<String> resolvedConfigurations = StringUtils.isBlank(configuration) ?\n+                                acc.configurationsByProject.getOrDefault(jp, new HashSet<>()) :\n+                                new HashSet<>(singletonList(configuration));\n+                        if (resolvedConfigurations.isEmpty()) {\n+                            resolvedConfigurations.add(\""implementation\"");\n+                        }\n+\n+                        GradleConfigurationFilter gradleConfigurationFilter = new GradleConfigurationFilter(gp, resolvedConfigurations);\n+                        gradleConfigurationFilter.removeTransitiveConfigurations();\n+                        gradleConfigurationFilter.removeConfigurationsContainingDependency(new GroupArtifact(groupId, artifactId));\n+                        resolvedConfigurations = gradleConfigurationFilter.getFilteredConfigurations();\n+\n+                        if (resolvedConfigurations.isEmpty()) {\n+                            return s;\n+                        }\n+\n+                        Set<JvmTestSuite> jvmTestSuites = FindJVMTestSuites.jvmTestSuites(s);\n+                        AddDependencyVisitor.DependencyModifier modifier = TRUE.equals(enforced) ? ENFORCED_PLATFORM : PLATFORM;\n+                        for (String resolvedConfiguration : resolvedConfigurations) {\n+                            JvmTestSuite jvmTestSuite = maybeJvmTestSuite(resolvedConfiguration, jvmTestSuites);\n+                            if (jvmTestSuite != null) {\n+                                s = (JavaSourceFile) jvmTestSuite.addDependency(resolvedConfiguration, groupId, artifactId, version, versionPattern,\n+                                                null, null, metadataFailures, modifier, ctx).visitNonNull(s, ctx);\n+                            } else {\n+                                s = (JavaSourceFile) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, resolvedConfiguration,\n+                                        null, null, metadataFailures, this::isTopLevel, modifier).visitNonNull(s, ctx);\n+                            }\n+                        }\n+\n+                        return s;\n+                    }\n+\n+                    private boolean isTopLevel(Cursor cursor) {\n+                        return cursor.getParentOrThrow().firstEnclosing(J.MethodInvocation.class) == null;\n+                    }\n+\n+                    private @Nullable JvmTestSuite maybeJvmTestSuite(String configuration, Set<JvmTestSuite> jvmTestSuites) {\n+                        for (JvmTestSuite jvmTestSuite : jvmTestSuites) {\n+                            if (jvmTestSuite.isAcceptable(configuration)) {\n+                                return jvmTestSuite;\n+                            }\n+                        }\n+                        return null;\n+                    }\n+                }));\n+    }\n+}\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleConfigurationFilter.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleConfigurationFilter.java\nnew file mode 100644\nindex 00000000000..44fa009684b\n--- /dev/null\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleConfigurationFilter.java\n@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Moderne Source Available License (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://docs.moderne.io/licensing/moderne-source-available-license\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle;\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n+import org.openrewrite.gradle.marker.GradleProject;\n+import org.openrewrite.maven.tree.GroupArtifact;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+@RequiredArgsConstructor\n+class GradleConfigurationFilter {\n+    private final GradleProject gradleProject;\n+\n+    @Getter\n+    private final Set<String> filteredConfigurations;\n+\n+    public void removeTransitiveConfigurations() {\n+        Set<String> tmpConfigurations = new HashSet<>(filteredConfigurations);\n+        for (String tmpConfiguration : tmpConfigurations) {\n+            GradleDependencyConfiguration gdc = requireNonNull((gradleProject.getConfiguration(tmpConfiguration)));\n+            for (GradleDependencyConfiguration transitive : gradleProject.configurationsExtendingFrom(gdc, true)) {\n+                filteredConfigurations.remove(transitive.getName());\n+            }\n+        }\n+    }\n+\n+    public void removeConfigurationsContainingDependency(GroupArtifact dependency) {\n+        Set<String> tmpConfigurations = new HashSet<>(filteredConfigurations);\n+        for (String tmpConfiguration : tmpConfigurations) {\n+            GradleDependencyConfiguration gdc = gradleProject.getConfiguration(tmpConfiguration);\n+            if (gdc == null || gdc.findRequestedDependency(dependency.getGroupId(), dependency.getArtifactId()) != null) {\n+                filteredConfigurations.remove(tmpConfiguration);\n+            }\n+        }\n+    }\n+\n+    public void removeConfigurationsContainingTransitiveDependency(GroupArtifact dependency) {\n+        Set<String> tmpConfigurations = new HashSet<>(filteredConfigurations);\n+        for (String tmpConfiguration : tmpConfigurations) {\n+            GradleDependencyConfiguration gdc = requireNonNull(gradleProject.getConfiguration(tmpConfiguration));\n+            for (GradleDependencyConfiguration transitive : gradleProject.configurationsExtendingFrom(gdc, true)) {\n+                if (transitive.findResolvedDependency(dependency.getGroupId(), dependency.getArtifactId()) != null) {\n+                    filteredConfigurations.remove(tmpConfiguration);\n+                }\n+            }\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/internal/AddDependencyVisitor.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/internal/AddDependencyVisitor.java\nnew file mode 100644\nindex 00000000000..b2c20174dfb\n--- /dev/null\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/internal/AddDependencyVisitor.java\n@@ -0,0 +1,459 @@\n+/*\n+ * Copyright 2022 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle.internal;\n+\n+import lombok.RequiredArgsConstructor;\n+import lombok.Value;\n+import org.jspecify.annotations.Nullable;\n+import org.openrewrite.Cursor;\n+import org.openrewrite.ExecutionContext;\n+import org.openrewrite.Tree;\n+import org.openrewrite.gradle.GradleParser;\n+import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n+import org.openrewrite.gradle.marker.GradleProject;\n+import org.openrewrite.gradle.trait.GradleDependency;\n+import org.openrewrite.groovy.tree.G;\n+import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n+import org.openrewrite.java.MethodMatcher;\n+import org.openrewrite.java.RandomizeIdVisitor;\n+import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaSourceFile;\n+import org.openrewrite.java.tree.Space;\n+import org.openrewrite.java.tree.Statement;\n+import org.openrewrite.kotlin.tree.K;\n+import org.openrewrite.marker.Markup;\n+import org.openrewrite.maven.MavenDownloadingException;\n+import org.openrewrite.maven.MavenDownloadingExceptions;\n+import org.openrewrite.maven.internal.MavenPomDownloader;\n+import org.openrewrite.maven.tree.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Objects.requireNonNull;\n+import static org.openrewrite.gradle.AddDependencyVisitor.DependencyModifier.ENFORCED_PLATFORM;\n+import static org.openrewrite.gradle.AddDependencyVisitor.DependencyModifier.PLATFORM;\n+import static org.openrewrite.gradle.trait.Traits.gradleDependency;\n+\n+@RequiredArgsConstructor\n+public class AddDependencyVisitor extends JavaIsoVisitor<ExecutionContext> {\n+    private static final MethodMatcher DEPENDENCIES_DSL_MATCHER = new MethodMatcher(\""* dependencies(..)\"");\n+    private static final GradleParser GRADLE_PARSER = GradleParser.builder().build();\n+    private static final String TEMPLATE_CACHE_MESSAGE_KEY = \""__org.openrewrite.gradle.internal.AddDependencyVisitor.cache__\"";\n+    public static final String KOTLIN_MAP_SEPARATOR = \"" = \"";\n+    public static final String GROOVY_MAP_SEPARATOR = \"": \"";\n+\n+    private final String configuration;\n+    private final String groupId;\n+    private final String artifactId;\n+\n+    @Nullable\n+    private final String version;\n+\n+    @Nullable\n+    private final String classifier;\n+\n+    @Nullable\n+    private final String extension;\n+\n+    @Nullable\n+    private final Predicate<Cursor> insertPredicate;\n+\n+    private final org.openrewrite.gradle.AddDependencyVisitor.@Nullable DependencyModifier dependencyModifier;\n+\n+    private final boolean isKotlinDsl;\n+\n+    @Override\n+    public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+        J j = super.visit(tree, ctx);\n+\n+        if (j instanceof JavaSourceFile) {\n+            JavaSourceFile cu = (JavaSourceFile) j;\n+\n+            if (j == tree && insertPredicate != null && insertPredicate.test(new Cursor(getCursor(), j))) {\n+                if (cu instanceof G.CompilationUnit) {\n+                    G.CompilationUnit g = (G.CompilationUnit) cu;\n+\n+                    if (!hasDependenciesBlock(g.getStatements())) {\n+                        Cursor parent = getCursor();\n+                        setCursor(new Cursor(parent, g));\n+                        J.MethodInvocation dependencies = dependenciesDeclaration(ctx)\n+                                .withPrefix(Space.format(\""\\n\\n\""));\n+                        cu = g.withStatements(ListUtils.concat(g.getStatements(), dependencies));\n+                        setCursor(parent);\n+                    }\n+                }\n+            }\n+\n+            return cu;\n+        }\n+        return j;\n+    }\n+\n+    @Override\n+    public J.Block visitBlock(J.Block block, ExecutionContext ctx) {\n+        J.Block b = super.visitBlock(block, ctx);\n+        if (b == block && insertPredicate != null && insertPredicate.test(getCursor())) {\n+            if (!hasDependenciesBlock(b.getStatements())) {\n+                Cursor parent = getCursor().dropParentUntil(value -> value instanceof J.MethodInvocation || value == Cursor.ROOT_VALUE);\n+                Space prefix = b.getStatements().isEmpty() ? Space.format(\""\\n\"") : Space.format(\""\\n\\n\"");\n+                Statement dependencies = parent.isRoot() ?\n+                        dependenciesDeclaration(ctx).withPrefix(prefix) :\n+                        autoFormat(dependenciesDeclaration(ctx).withPrefix(prefix), ctx, getCursor());\n+                return b.withStatements(ListUtils.concat(b.getStatements(), dependencies));\n+            }\n+        }\n+        return b;\n+    }\n+\n+    @Override\n+    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n+        J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n+        if (DEPENDENCIES_DSL_MATCHER.matches(m, true)) {\n+            if (insertPredicate != null && !insertPredicate.test(getCursor())) {\n+                return m;\n+            }\n+\n+            Optional<GradleDependency> maybeDependency = gradleDependency()\n+                    .configuration(configuration)\n+                    .groupId(groupId)\n+                    .artifactId(artifactId)\n+                    .lower(getCursor())\n+                    .findFirst();\n+            if (maybeDependency.isPresent()) {\n+                return m;\n+            }\n+\n+            return m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {\n+                if (arg instanceof J.Lambda) {\n+                    J.Lambda lambda = (J.Lambda) arg;\n+                    J.Block body = (J.Block) lambda.getBody();\n+                    J.MethodInvocation addDependencyInvocation = dependencyDeclaration(body, ctx, new Cursor(new Cursor(getCursor(), lambda), body));\n+                    InsertDependencyComparator dependencyComparator = new InsertDependencyComparator(body.getStatements(), addDependencyInvocation);\n+\n+                    List<Statement> statements = new ArrayList<>(body.getStatements());\n+                    int i = 0;\n+                    for (; i < body.getStatements().size(); i++) {\n+                        Statement currentStatement = body.getStatements().get(i);\n+                        if (dependencyComparator.compare(currentStatement, addDependencyInvocation) > 0) {\n+                            if (dependencyComparator.getBeforeDependency() != null) {\n+                                J.MethodInvocation beforeDependency = (J.MethodInvocation) (dependencyComparator.getBeforeDependency() instanceof J.Return ?\n+                                        requireNonNull(((J.Return) dependencyComparator.getBeforeDependency()).getExpression()) :\n+                                        dependencyComparator.getBeforeDependency());\n+                                if (i == 0) {\n+                                    if (!addDependencyInvocation.getSimpleName().equals(beforeDependency.getSimpleName())) {\n+                                        statements.set(i, currentStatement.withPrefix(Space.format(\""\\n\\n\"" + currentStatement.getPrefix().getIndent())));\n+                                    }\n+                                } else {\n+                                    Space originalPrefix = addDependencyInvocation.getPrefix();\n+                                    addDependencyInvocation = addDependencyInvocation.withPrefix(currentStatement.getPrefix());\n+\n+                                    if (addDependencyInvocation.getSimpleName().equals(beforeDependency.getSimpleName())) {\n+                                        if (!currentStatement.getPrefix().equals(originalPrefix)) {\n+                                            statements.set(i, currentStatement.withPrefix(originalPrefix));\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            statements.add(i, addDependencyInvocation);\n+                            break;\n+                        }\n+                    }\n+                    if (body.getStatements().size() == i) {\n+                        if (!body.getStatements().isEmpty()) {\n+                            Statement lastStatement;\n+                            if (statements.get(i - 1) instanceof J.Return) {\n+                                J.Return r = (J.Return) statements.remove(i - 1);\n+                                lastStatement = requireNonNull(r.getExpression()).withPrefix(r.getPrefix());\n+                                statements.add(lastStatement);\n+                            } else {\n+                                lastStatement = statements.get(i - 1);\n+                            }\n+                            if (lastStatement instanceof J.MethodInvocation && !((J.MethodInvocation) lastStatement).getSimpleName().equals(addDependencyInvocation.getSimpleName())) {\n+                                addDependencyInvocation = addDependencyInvocation.withPrefix(Space.format(\""\\n\\n\"" + addDependencyInvocation.getPrefix().getIndent()));\n+                            }\n+                        }\n+                        statements.add(addDependencyInvocation);\n+                    }\n+                    body = body.withStatements(statements);\n+                    return lambda.withBody(body.withStatements(statements));\n+                }\n+                return arg;\n+            }));\n+        }\n+        return m;\n+    }\n+\n+    /**\n+     * Update the dependency model, adding the specified dependency to the specified configuration and all configurations\n+     * which extend from it.\n+     *\n+     * @param buildScript   compilation unit owning the {@link GradleProject} marker\n+     * @param configuration the configuration to add the dependency to\n+     * @param gav           the group, artifact, and version of the dependency to add\n+     * @param classifier    the classifier of the dependency to add\n+     * @param ctx           context which will be used to download the pom for the dependency\n+     * @return a copy of buildScript with the dependency added\n+     */\n+    public static JavaSourceFile addDependency(\n+            JavaSourceFile buildScript,\n+            @Nullable GradleDependencyConfiguration configuration,\n+            GroupArtifactVersion gav,\n+            @Nullable String classifier,\n+            ExecutionContext ctx) {\n+        if (gav.getGroupId() == null || gav.getArtifactId() == null || configuration == null) {\n+            return buildScript;\n+        }\n+        GradleProject gp = buildScript.getMarkers().findFirst(GradleProject.class)\n+                .orElseThrow(() -> new IllegalArgumentException(\""Could not find GradleProject\""));\n+\n+        try {\n+            ResolvedGroupArtifactVersion resolvedGav;\n+            List<ResolvedDependency> transitiveDependencies;\n+            if (gav.getVersion() == null) {\n+                resolvedGav = null;\n+                transitiveDependencies = Collections.emptyList();\n+            } else {\n+                MavenPomDownloader mpd = new MavenPomDownloader(ctx);\n+                Pom pom = mpd.download(gav, null, null, gp.getMavenRepositories());\n+                ResolvedPom resolvedPom = pom.resolve(emptyList(), mpd, gp.getMavenRepositories(), ctx);\n+                resolvedGav = resolvedPom.getGav();\n+                transitiveDependencies = resolvedPom.resolveDependencies(Scope.Runtime, mpd, ctx);\n+            }\n+            Map<String, GradleDependencyConfiguration> nameToConfiguration = gp.getNameToConfiguration();\n+            Map<String, GradleDependencyConfiguration> newNameToConfiguration = new HashMap<>(nameToConfiguration.size());\n+\n+            Set<GradleDependencyConfiguration> configurationsToAdd = Stream.concat(\n+                            Stream.of(configuration),\n+                            gp.configurationsExtendingFrom(configuration, true).stream())\n+                    .collect(Collectors.toSet());\n+\n+            for (GradleDependencyConfiguration gdc : nameToConfiguration.values()) {\n+                if (!configurationsToAdd.contains(gdc)) {\n+                    newNameToConfiguration.put(gdc.getName(), gdc);\n+                    continue;\n+                }\n+\n+                GradleDependencyConfiguration newGdc = gdc;\n+                org.openrewrite.maven.tree.Dependency newRequested = new org.openrewrite.maven.tree.Dependency(\n+                        gav, classifier, \""jar\"", gdc.getName(), emptyList(), null);\n+                newGdc = newGdc.withRequested(ListUtils.concat(\n+                        ListUtils.map(gdc.getRequested(), requested -> {\n+                            // Remove any existing dependency with the same group and artifact id\n+                            if (Objects.equals(requested.getGroupId(), gav.getGroupId()) && Objects.equals(requested.getArtifactId(), gav.getArtifactId())) {\n+                                return null;\n+                            }\n+                            return requested;\n+                        }),\n+                        newRequested));\n+                if (newGdc.isCanBeResolved() && resolvedGav != null) {\n+                    newGdc = newGdc.withDirectResolved(ListUtils.concat(\n+                            ListUtils.map(gdc.getDirectResolved(), resolved -> {\n+                                // Remove any existing dependency with the same group and artifact id\n+                                if (Objects.equals(resolved.getGroupId(), resolvedGav.getGroupId()) && Objects.equals(resolved.getArtifactId(), resolvedGav.getArtifactId())) {\n+                                    return null;\n+                                }\n+                                return resolved;\n+                            }),\n+                            new ResolvedDependency(null, resolvedGav, newRequested, transitiveDependencies,\n+                                    emptyList(), \""jar\"", classifier, null, 0, null)));\n+                }\n+                newNameToConfiguration.put(newGdc.getName(), newGdc);\n+            }\n+            gp = gp.withNameToConfiguration(newNameToConfiguration);\n+        } catch (MavenDownloadingException | MavenDownloadingExceptions | IllegalArgumentException e) {\n+            return Markup.warn(buildScript, e);\n+        }\n+        return buildScript.withMarkers(buildScript.getMarkers().setByType(gp));\n+    }\n+\n+    enum DependencyStyle {\n+        Map, String\n+    }\n+\n+    @SuppressWarnings(\""unchecked\"")\n+    private <J2 extends J> List<J2> cache(Cursor cursor, Object key, Supplier<List<? extends J>> ifAbsent) {\n+        List<J2> js = null;\n+\n+        Cursor root = cursor.getRoot();\n+        Map<Object, List<J2>> cache = root.getMessage(TEMPLATE_CACHE_MESSAGE_KEY);\n+        if (cache == null) {\n+            cache = new HashMap<>();\n+            root.putMessage(TEMPLATE_CACHE_MESSAGE_KEY, cache);\n+        } else {\n+            js = cache.get(key);\n+        }\n+\n+        if (js == null) {\n+            js = (List<J2>) ifAbsent.get();\n+            cache.put(key, js);\n+        }\n+\n+        return ListUtils.map(js, j -> (J2) new RandomizeIdVisitor<Integer>().visit(j, 0));\n+    }\n+\n+    private boolean hasDependenciesBlock(List<Statement> statements) {\n+        for (Statement statement : statements) {\n+            if (statement instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) statement, true)) {\n+                return true;\n+            } else if (statement instanceof J.Return &&\n+                    ((J.Return) statement).getExpression() instanceof J.MethodInvocation &&\n+                    DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) ((J.Return) statement).getExpression(), true)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private J.MethodInvocation dependenciesDeclaration(ExecutionContext ctx) {\n+        String template = templateDependencies();\n+        return (J.MethodInvocation) cache(getCursor(), new ContextFreeCacheKey(template, isKotlinDsl, J.MethodInvocation.class), () -> {\n+            Boolean requirePrintEqualsInput = ctx.getMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT);\n+            try {\n+                J.MethodInvocation dependencies;\n+                ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, false);\n+                if (isKotlinDsl) {\n+                    dependencies = (J.MethodInvocation) ((J.Block) GRADLE_PARSER.parseInputs(Collections.singletonList(new GradleParser.Input(Paths.get(\""build.gradle.kts\""), () -> new ByteArrayInputStream(template.getBytes(StandardCharsets.UTF_8)))), null, ctx)\n+                            .findFirst()\n+                            .map(K.CompilationUnit.class::cast)\n+                            .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""))\n+                            .getStatements().get(0)).getStatements().get(0);\n+                } else {\n+                    dependencies = (J.MethodInvocation) GRADLE_PARSER.parse(ctx, template)\n+                            .findFirst()\n+                            .map(G.CompilationUnit.class::cast)\n+                            .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""))\n+                            .getStatements().get(0);\n+                }\n+                return Collections.singletonList(dependencies);\n+            } finally {\n+                ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, requirePrintEqualsInput);\n+            }\n+        }).get(0);\n+    }\n+\n+    private J.MethodInvocation dependencyDeclaration(J.Block body, ExecutionContext ctx, Cursor cursor) {\n+        String template = templateDependency(body);\n+        return (J.MethodInvocation) autoFormat(cache(cursor, new ContextFreeCacheKey(template, isKotlinDsl, J.MethodInvocation.class), () -> {\n+            Boolean requirePrintEqualsInput = ctx.getMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT);\n+            try {\n+                J.MethodInvocation dependency;\n+                ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, false);\n+                if (isKotlinDsl) {\n+                    dependency = (J.MethodInvocation) ((J.Block) GRADLE_PARSER.parseInputs(Collections.singletonList(new GradleParser.Input(Paths.get(\""build.gradle.kts\""), () -> new ByteArrayInputStream(template.getBytes(StandardCharsets.UTF_8)))), null, ctx)\n+                            .findFirst()\n+                            .map(K.CompilationUnit.class::cast)\n+                            .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""))\n+                            .getStatements().get(0)).getStatements().get(0);\n+                } else {\n+                    dependency = (J.MethodInvocation) GRADLE_PARSER.parse(ctx, template)\n+                            .findFirst()\n+                            .map(G.CompilationUnit.class::cast)\n+                            .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""))\n+                            .getStatements().get(0);\n+                }\n+                return Collections.singletonList(dependency.withPrefix(Space.format(\""\\n\"")));\n+            } finally {\n+                ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, requirePrintEqualsInput);\n+            }\n+        }).get(0), ctx, cursor);\n+    }\n+\n+    private String templateDependencies() {\n+        return \""dependencies {\\n    \"" + templateDependency(null) + \""\\n}\"";\n+    }\n+\n+    private String templateDependency(J.@Nullable Block body) {\n+        DependencyStyle style = autodetectDependencyStyle(body);\n+        if (isKotlinDsl) {\n+            return escapeIfNecessary(configuration) + \""(\"" + templatePlatform(templateDependencyNotation(KOTLIN_MAP_SEPARATOR, style)) + \"")\"";\n+        } else {\n+            return escapeIfNecessary(configuration) + \"" \"" + templatePlatform(templateDependencyNotation(GROOVY_MAP_SEPARATOR, style));\n+        }\n+    }\n+\n+    private String templatePlatform(String dependencyNotation) {\n+        if (dependencyModifier == PLATFORM) {\n+            return \""platform(\"" + dependencyNotation + \"")\"";\n+        } else if (dependencyModifier == ENFORCED_PLATFORM) {\n+            return \""enforcedPlatform(\"" + dependencyNotation + \"")\"";\n+        }\n+        return dependencyNotation;\n+    }\n+\n+    private String templateDependencyNotation(String mapSeparator, DependencyStyle style) {\n+        if (style == DependencyStyle.String) {\n+            return \""\\\""\"" + groupId + \"":\"" + artifactId + (version == null ? \""\"" : \"":\"" + version) + (version == null || classifier == null ? \""\"" : \"":\"" + classifier) + (extension == null ? \""\"" : \""@\"" + extension) + \""\\\""\"";\n+        } else {\n+            return \""group\"" + mapSeparator + \""\\\""\"" + groupId + \""\\\"", name\"" + mapSeparator + \""\\\""\"" + artifactId + \""\\\""\"" + (version == null ? \""\"" : \"", version\"" + mapSeparator + \""\\\""\"" + version + \""\\\""\"") + (classifier == null ? \""\"" : \"", classifier\"" + mapSeparator + \""\\\""\"" + classifier + \""\\\""\"") + (extension == null ? \""\"" : \"", ext\"" + mapSeparator + \""\\\""\"" + extension + \""\\\""\"");\n+        }\n+    }\n+\n+    private String escapeIfNecessary(String configurationName) {\n+        // default is a gradle configuration created by the base plugin and a groovy keyword if\n+        // it is used it needs to be escaped\n+        return configurationName.equals(\""default\"") ? \""'\"" + configurationName + \""'\"" : configurationName;\n+    }\n+\n+    private DependencyStyle autodetectDependencyStyle(J.@Nullable Block block) {\n+        if (block == null) {\n+            return DependencyStyle.String;\n+        }\n+\n+        List<Statement> statements = block.getStatements();\n+        int string = 0;\n+        int map = 0;\n+        for (Statement statement : statements) {\n+            if (statement instanceof J.Return && ((J.Return) statement).getExpression() instanceof J.MethodInvocation) {\n+                J.MethodInvocation invocation = (J.MethodInvocation) ((J.Return) statement).getExpression();\n+                if (invocation.getArguments().get(0) instanceof J.Literal || invocation.getArguments().get(0) instanceof G.GString) {\n+                    string++;\n+                } else if (invocation.getArguments().get(0) instanceof G.MapEntry) {\n+                    map++;\n+                } else if (invocation.getArguments().get(0) instanceof J.Assignment) {\n+                    map++;\n+                }\n+            } else if (statement instanceof J.MethodInvocation) {\n+                J.MethodInvocation invocation = (J.MethodInvocation) statement;\n+                if (invocation.getArguments().get(0) instanceof J.Literal || invocation.getArguments().get(0) instanceof G.GString) {\n+                    string++;\n+                } else if (invocation.getArguments().get(0) instanceof G.MapEntry) {\n+                    map++;\n+                } else if (invocation.getArguments().get(0) instanceof J.Assignment) {\n+                    map++;\n+                }\n+            }\n+        }\n+\n+        return string >= map ? DependencyStyle.String : DependencyStyle.Map;\n+    }\n+\n+    @Value\n+    private static class ContextFreeCacheKey {\n+        String template;\n+        boolean isKotlinDsl;\n+        Class<? extends J> expected;\n+    }\n+}\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/Traits.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/Traits.java\nindex 356c2d2dd68..16fa0f94e22 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/Traits.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/Traits.java\n@@ -22,4 +22,8 @@ private Traits() {\n     public static GradleDependency.Matcher gradleDependency() {\n         return new GradleDependency.Matcher();\n     }\n+\n+    public static JvmTestSuite.Matcher jvmTestSuite() {\n+        return new JvmTestSuite.Matcher();\n+    }\n }\n"", ""test_patch"": ""diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java\nindex 7d71d133e43..5bf805199ad 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java\n@@ -21,28 +21,21 @@\n import org.openrewrite.*;\n import org.openrewrite.gradle.IsBuildGradle;\n import org.openrewrite.gradle.table.JVMTestSuitesDefined;\n-import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.tree.Expression;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.Statement;\n+import org.openrewrite.gradle.trait.JvmTestSuite;\n import org.openrewrite.marker.SearchResult;\n \n-import java.util.HashSet;\n-import java.util.Iterator;\n+import java.util.Collections;\n import java.util.Set;\n import java.util.stream.Collectors;\n \n+import static org.openrewrite.gradle.trait.Traits.jvmTestSuite;\n+\n @Value\n @EqualsAndHashCode(callSuper = false)\n public class FindJVMTestSuites extends Recipe {\n \n     transient JVMTestSuitesDefined jvmTestSuitesDefined = new JVMTestSuitesDefined(this);\n \n-    @Option(displayName = \""Requires dependencies\"",\n-            description = \""Whether the test suite configuration defines dependencies to be resolved. Defaults to false.\"")\n-    @Nullable\n-    Boolean definesDependencies;\n-\n     @Option(displayName = \""Insert rows\"",\n             description = \""Whether to insert rows into the table. Defaults to true.\"")\n     @Nullable\n@@ -60,58 +53,21 @@ public String getDescription() {\n \n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        boolean requireDependencies = definesDependencies != null && definesDependencies;\n         boolean tableAvailable = this.insertRows == null || this.insertRows;\n-        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {\n-            private boolean isJVMTestSuitesBlock() {\n-                Cursor parent = getCursor().getParent();\n-                if (parent != null) {\n-                    Iterator<Object> path = parent.getPath(J.MethodInvocation.class::isInstance);\n-                    if (path.hasNext() && \""suites\"".equals(((J.MethodInvocation) path.next()).getSimpleName())) {\n-                        return path.hasNext() && \""testing\"".equals(((J.MethodInvocation) path.next()).getSimpleName());\n-                    }\n-                }\n-                return false;\n-            }\n-\n-            private boolean definesDependencies(J.MethodInvocation suite) {\n-                for (Expression suiteDefinition : suite.getArguments()) {\n-                    if (suiteDefinition instanceof J.Lambda) {\n-                        for (Statement statement : ((J.Block) ((J.Lambda) suiteDefinition).getBody()).getStatements()) {\n-                            if (statement instanceof J.Return) {\n-                                Expression expression = ((J.Return) statement).getExpression();\n-                                if (expression instanceof J.MethodInvocation) {\n-                                    if (\""dependencies\"".equals(((J.MethodInvocation) expression).getSimpleName())) {\n-                                        return true;\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                return false;\n-            }\n-\n-            @Override\n-            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n-                if (isJVMTestSuitesBlock()) {\n-                    if (tableAvailable) {\n-                        jvmTestSuitesDefined.insertRow(ctx, new JVMTestSuitesDefined.Row(method.getSimpleName()));\n-                    }\n-                    return !requireDependencies || definesDependencies(method) ? SearchResult.found(method) : method;\n-                }\n-                return super.visitMethodInvocation(method, ctx);\n+        return Preconditions.check(new IsBuildGradle<>(), jvmTestSuite().asVisitor((suite, ctx) -> {\n+            if (tableAvailable) {\n+                jvmTestSuitesDefined.insertRow(ctx, new JVMTestSuitesDefined.Row(suite.getName()));\n             }\n-        });\n+            return SearchResult.found(suite.getTree());\n+        }));\n     }\n \n-    public static Set<String> jvmTestSuiteNames(Tree tree, boolean definesDependencies) {\n-        return TreeVisitor.collect(new FindJVMTestSuites(definesDependencies, false).getVisitor(), tree, new HashSet<>())\n-                .stream()\n-                .filter(J.MethodInvocation.class::isInstance)\n-                .map(J.MethodInvocation.class::cast)\n-                .filter(m -> m.getMarkers().findFirst(SearchResult.class).isPresent())\n-                .map(J.MethodInvocation::getSimpleName)\n+    public static Set<JvmTestSuite> jvmTestSuites(SourceFile sourceFile) {\n+        if (!IsBuildGradle.matches(sourceFile.getSourcePath())) {\n+            return Collections.emptySet();\n+        }\n+\n+        return jvmTestSuite().lower(sourceFile)\n                 .collect(Collectors.toSet());\n     }\n }\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/JvmTestSuite.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/JvmTestSuite.java\nnew file mode 100644\nindex 00000000000..e9473f3f218\n--- /dev/null\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/JvmTestSuite.java\n@@ -0,0 +1,321 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle.trait;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import org.jspecify.annotations.Nullable;\n+import org.openrewrite.Cursor;\n+import org.openrewrite.ExecutionContext;\n+import org.openrewrite.Tree;\n+import org.openrewrite.TreeVisitor;\n+import org.openrewrite.gradle.DependencyVersionSelector;\n+import org.openrewrite.gradle.internal.AddDependencyVisitor;\n+import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n+import org.openrewrite.gradle.marker.GradleProject;\n+import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n+import org.openrewrite.java.JavaVisitor;\n+import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaSourceFile;\n+import org.openrewrite.java.tree.JavaType;\n+import org.openrewrite.java.tree.Statement;\n+import org.openrewrite.kotlin.tree.K;\n+import org.openrewrite.marker.SearchResult;\n+import org.openrewrite.maven.MavenDownloadingException;\n+import org.openrewrite.maven.table.MavenMetadataFailures;\n+import org.openrewrite.maven.tree.GroupArtifact;\n+import org.openrewrite.maven.tree.GroupArtifactVersion;\n+import org.openrewrite.trait.Trait;\n+import org.openrewrite.trait.VisitFunction2;\n+\n+import java.util.*;\n+\n+@AllArgsConstructor\n+public class JvmTestSuite implements Trait<Statement> {\n+    private static final String[] JVM_TEST_SUITE_SUFFIXES = new String[] {\n+            \""annotationProcessor\"",\n+            \""compileOnly\"",\n+            \""implementation\"",\n+            \""runtimeOnly\""\n+    };\n+\n+    @Getter\n+    Cursor cursor;\n+\n+    GradleProject gradleProject;\n+\n+    @Getter\n+    String name;\n+\n+    public TreeVisitor<J, ExecutionContext> addDependency(\n+            String configuration,\n+            String groupId,\n+            String artifactId,\n+            @Nullable String version,\n+            @Nullable String versionPattern,\n+            @Nullable String classifier,\n+            @Nullable String extension,\n+            MavenMetadataFailures metadataFailures,\n+            org.openrewrite.gradle.AddDependencyVisitor.@Nullable DependencyModifier dependencyModifier,\n+            ExecutionContext ctx\n+    ) {\n+        if (!isAcceptable(configuration)) {\n+            return TreeVisitor.noop();\n+        }\n+\n+        String resolvedConfiguration = configuration.startsWith(name) ?\n+                Character.toLowerCase(configuration.charAt(name.length())) + configuration.substring(name.length() + 1) :\n+                configuration;\n+\n+        String targetConfiguration = configuration.startsWith(name) ?\n+                configuration :\n+                name + Character.toUpperCase(configuration.charAt(0)) + configuration.substring(1);\n+\n+        boolean isKotlinDsl = isKotlinDsl();\n+        try {\n+            String resolvedVersion = resolveVersion(resolvedConfiguration, groupId, artifactId, version, versionPattern, metadataFailures, ctx);\n+\n+            return new JavaIsoVisitor<ExecutionContext>() {\n+                @Override\n+                public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                    J j = new AddDependencyVisitor(resolvedConfiguration, groupId, artifactId, version, classifier, extension, JvmTestSuite.this::isScope, dependencyModifier, isKotlinDsl)\n+                            .visit(tree, ctx, getCursor());\n+\n+                    if (j instanceof JavaSourceFile && j != tree) {\n+                        return AddDependencyVisitor.addDependency(\n+                                (JavaSourceFile) j,\n+                                gradleProject.getConfiguration(targetConfiguration),\n+                                new GroupArtifactVersion(groupId, artifactId, resolvedVersion),\n+                                classifier,\n+                                ctx\n+                        );\n+                    }\n+\n+                    return j;\n+                }\n+            };\n+        } catch (MavenDownloadingException e) {\n+            return new JavaVisitor<ExecutionContext>() {\n+                @Override\n+                public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                    if (tree == null) {\n+                        return null;\n+                    }\n+\n+                    return (J) e.warn(tree);\n+                }\n+            };\n+        }\n+    }\n+\n+    private @Nullable String resolveVersion(String configuration, String groupId, String artifactId, @Nullable String version, @Nullable String versionPattern, MavenMetadataFailures metadataFailures, ExecutionContext ctx) throws MavenDownloadingException{\n+        if (version == null) {\n+            return null;\n+        }\n+\n+        if (version.startsWith(\""$\"")) {\n+            return version;\n+        }\n+        return new DependencyVersionSelector(metadataFailures, gradleProject, null)\n+                .select(new GroupArtifact(groupId, artifactId), configuration, version, versionPattern, ctx);\n+    }\n+\n+    public boolean isAcceptable(String configuration) {\n+        for (String suffix : JVM_TEST_SUITE_SUFFIXES) {\n+            if (configuration.equals(suffix)) {\n+                return true;\n+            } else if (configuration.equals(name + Character.toUpperCase(suffix.charAt(0)) + suffix.substring(1))) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isKotlinDsl() {\n+        return getCursor().firstEnclosing(JavaSourceFile.class) instanceof K.CompilationUnit;\n+    }\n+\n+    private boolean isScope(Cursor cursor) {\n+        Statement statement = getTree();\n+        Cursor c = cursor.dropParentUntil(value -> (value instanceof J && statement.isScope((J) value)) || (value instanceof J.MethodInvocation && !\""registering\"".equals(((J.MethodInvocation) value).getSimpleName()) && !\""getting\"".equals(((J.MethodInvocation) value).getSimpleName())) || value == Cursor.ROOT_VALUE);\n+        return !c.isRoot() && statement.isScope(c.getValue());\n+    }\n+\n+    public static class Matcher extends GradleTraitMatcher<JvmTestSuite> {\n+        @Nullable\n+        protected String name;\n+\n+        private transient Map<GradleProject, Set<String>> sourceSets = new HashMap<>();\n+\n+        public Matcher name(@Nullable String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        @Override\n+        public <P> TreeVisitor<? extends Tree, P> asVisitor(VisitFunction2<JvmTestSuite, P> visitor) {\n+            return new JavaVisitor<P>() {\n+                @Override\n+                public J visitMethodInvocation(J.MethodInvocation method, P p) {\n+                    JvmTestSuite suite = test(getCursor());\n+                    return suite != null ?\n+                            (J) visitor.visit(suite, p) :\n+                            super.visitMethodInvocation(method, p);\n+                }\n+\n+                @Override\n+                public J visitVariableDeclarations(J.VariableDeclarations multiVariable, P p) {\n+                    JvmTestSuite suite = test(getCursor());\n+                    return suite != null ?\n+                            (J) visitor.visit(suite, p) :\n+                            super.visitVariableDeclarations(multiVariable, p);\n+                }\n+            };\n+        }\n+\n+        @Override\n+        protected @Nullable JvmTestSuite test(Cursor cursor) {\n+            if (!withinSuitesBlock(cursor)) {\n+                return null;\n+            }\n+\n+            if (cursor.getValue() instanceof J.MethodInvocation) {\n+                J.MethodInvocation m = cursor.getValue();\n+\n+                if (\""register\"".equals(m.getSimpleName())) {\n+                    if (!(m.getArguments().get(0) instanceof J.Literal)) {\n+                        return null;\n+                    }\n+\n+                    J.Literal literal = (J.Literal) m.getArguments().get(0);\n+                    if (literal.getType() != JavaType.Primitive.String) {\n+                        return null;\n+                    }\n+\n+                    if (literal.getValue() == null) {\n+                        return null;\n+                    }\n+\n+                    return maybeJvmTestSuite(cursor, (String) literal.getValue());\n+                } else {\n+                    return maybeJvmTestSuite(cursor, m.getSimpleName());\n+                }\n+            } else {\n+                J.VariableDeclarations variables = cursor.getValue();\n+                J.VariableDeclarations.NamedVariable variable = variables.getVariables().get(0);\n+\n+                if (!(variable.getInitializer() instanceof J.MethodInvocation)) {\n+                    return null;\n+                }\n+\n+                J.MethodInvocation initializer = (J.MethodInvocation) variable.getInitializer();\n+                if (!\""getting\"".equals(initializer.getSimpleName()) && !\""registering\"".equals(initializer.getSimpleName())) {\n+                    return null;\n+                }\n+\n+                return maybeJvmTestSuite(cursor, variable.getSimpleName());\n+            }\n+        }\n+\n+        private @Nullable JvmTestSuite maybeJvmTestSuite(Cursor cursor, String simpleName) {\n+            Set<String> sourceSets = getSourceSets(cursor);\n+            if (sourceSets.isEmpty()) {\n+                if (!hasDependenciesBlock(cursor)) {\n+                    return null;\n+                }\n+            } else if (!sourceSets.contains(simpleName)) {\n+                return null;\n+            }\n+\n+            if (!StringUtils.isBlank(name) && !name.equals(simpleName)) {\n+                return null;\n+            }\n+\n+            return new JvmTestSuite(cursor, getGradleProject(cursor), simpleName);\n+        }\n+\n+        private boolean withinBlock(Cursor cursor, String name) {\n+            Cursor parentCursor = cursor.getParent();\n+            while (parentCursor != null) {\n+                if (parentCursor.getValue() instanceof J.MethodInvocation) {\n+                    J.MethodInvocation m = parentCursor.getValue();\n+                    if (m.getSimpleName().equals(name)) {\n+                        return true;\n+                    }\n+                }\n+                parentCursor = parentCursor.getParent();\n+            }\n+\n+            return false;\n+        }\n+\n+        private boolean withinTestingBlock(Cursor cursor) {\n+            return withinBlock(cursor, \""testing\"");\n+        }\n+\n+        private boolean withinSuitesBlock(Cursor cursor) {\n+            return withinBlock(cursor, \""suites\"") && withinTestingBlock(cursor);\n+        }\n+\n+        private Set<String> getSourceSets(Cursor cursor) {\n+            GradleProject gp = getGradleProject(cursor);\n+            if (gp == null) {\n+                return Collections.emptySet();\n+            }\n+\n+            return sourceSets.computeIfAbsent(gp, key -> {\n+                Set<String> sourceSets = new HashSet<>();\n+                for (GradleDependencyConfiguration configuration : gp.getConfigurations()) {\n+                    String maybeSourceSet = removeSuffix(configuration.getName());\n+                    if (maybeSourceSet != null) {\n+                        sourceSets.add(maybeSourceSet);\n+                    }\n+                }\n+                return sourceSets;\n+            });\n+        }\n+\n+        private boolean hasDependenciesBlock(Cursor cursor) {\n+            Statement original = cursor.getValue();\n+            Statement updated = (Statement) new JavaIsoVisitor<Integer>() {\n+                @Override\n+                public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Integer ctx) {\n+                    J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n+                    if (m.getSimpleName().equals(\""dependencies\"")) {\n+                        return SearchResult.found(m);\n+                    }\n+                    return m;\n+                }\n+            }.visitNonNull(original, 0);\n+            return updated != original;\n+        }\n+\n+        /**\n+         * This gives us the best estimate to a project's source sets. This would be better coming from the GradleProject marker.\n+         */\n+        private static @Nullable String removeSuffix(String configuration) {\n+            for (String suffix : JVM_TEST_SUITE_SUFFIXES) {\n+                if (configuration.equals(suffix)) {\n+                    return \""main\"";\n+                } else if (configuration.endsWith(Character.toUpperCase(suffix.charAt(0)) + suffix.substring(1))) {\n+                    return configuration.substring(0, configuration.length() - suffix.length());\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java\nindex 75ede738f10..1caefd75297 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java\n@@ -1370,8 +1370,6 @@ void addToJVMSuite() {\n                     testing {\n                         suites {\n                             integrationTest(JvmTestSuite) {\n-                                dependencies {\n-                                }\n                             }\n                         }\n                     }\n@@ -1428,10 +1426,7 @@ void actNormalForDefaultTestWithoutSuiteDefinition() {\n                     \n                     testing {\n                         suites {\n-                            integrationTest(JvmTestSuite) {\n-                                dependencies {\n-                                }\n-                            }\n+                            integrationTest(JvmTestSuite)\n                         }\n                     }\n                     \""\""\"",\n@@ -1453,62 +1448,9 @@ void actNormalForDefaultTestWithoutSuiteDefinition() {\n                     \n                     testing {\n                         suites {\n-                            integrationTest(JvmTestSuite) {\n-                                dependencies {\n-                                }\n-                            }\n-                        }\n-                    }\n-                    \""\""\""\n-                )));\n-        }\n-\n-        @Test\n-        void actNormalForSuiteWithoutDependencyBlock() {\n-            rewriteRun(\n-              spec -> spec.recipe(addDependency(\""com.google.guava:guava:29.0-jre\"")),\n-              mavenProject(\""project\"",\n-                srcMainJava(\n-                  java(usingGuavaIntMath, sourceSpecs -> sourceSet(sourceSpecs, \""integrationTest\""))),\n-                buildGradle(\n-                  //language=groovy\n-                  \""\""\""\n-                    plugins {\n-                        id \""java-library\""\n-                        id 'jvm-test-suite'\n-                    }\n-                    \n-                    repositories {\n-                        mavenCentral()\n-                    }\n-                    \n-                    testing {\n-                        suites {\n-                            integrationTest(JvmTestSuite) {\n-                            }\n+                            integrationTest(JvmTestSuite)\n                         }\n                     }\n-                    \""\""\"",\n-                  \""\""\""\n-                    plugins {\n-                        id \""java-library\""\n-                        id 'jvm-test-suite'\n-                    }\n-                    \n-                    repositories {\n-                        mavenCentral()\n-                    }\n-                    \n-                    testing {\n-                        suites {\n-                            integrationTest(JvmTestSuite) {\n-                            }\n-                        }\n-                    }\n-                    \n-                    dependencies {\n-                        integrationTestImplementation \""com.google.guava:guava:29.0-jre\""\n-                    }\n                     \""\""\""\n                 )));\n         }\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddPlatformDependencyTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddPlatformDependencyTest.java\nnew file mode 100644\nindex 00000000000..a2f8076afce\n--- /dev/null\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddPlatformDependencyTest.java\n@@ -0,0 +1,402 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle;\n+\n+import org.intellij.lang.annotations.Language;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.openrewrite.java.JavaParser;\n+import org.openrewrite.test.RecipeSpec;\n+import org.openrewrite.test.RewriteTest;\n+import org.openrewrite.test.TypeValidation;\n+\n+import static org.openrewrite.gradle.Assertions.buildGradle;\n+import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n+import static org.openrewrite.java.Assertions.*;\n+\n+class AddPlatformDependencyTest implements RewriteTest {\n+    @Override\n+    public void defaults(RecipeSpec spec) {\n+        spec.beforeRecipe(withToolingApi())\n+          .parser(JavaParser.fromJavaVersion().classpath(\""junit-jupiter-api\"", \""guava\"", \""jackson-databind\"", \""jackson-core\"", \""lombok\""));\n+    }\n+\n+    @Language(\""java\"")\n+    private final String usingGuavaIntMath = \""\""\""\n+            import com.google.common.math.IntMath;\n+            public class A {\n+                boolean getMap() {\n+                    return IntMath.isPrime(5);\n+                }\n+            }\n+      \""\""\"";\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+      \""implementation\"",\n+      \""compileOnly\"",\n+      \""runtimeOnly\"",\n+      \""annotationProcessor\""})\n+    void addPlatformWithExplicitConfiguration(String configuration) {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\""org.springframework.boot\"", \""spring-boot-dependencies\"", \""3.2.4\"", null, configuration, null)),\n+          mavenProject(\""project\"",\n+            srcMainJava(java(usingGuavaIntMath)),\n+            buildGradle(\n+              //language=groovy\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \""\""\"",\n+              //language=groovy\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    %s platform(\""org.springframework.boot:spring-boot-dependencies:3.2.4\"")\n+                }\n+                \""\""\"".formatted(configuration)\n+            )));\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+      \""implementation\"",\n+      \""compileOnly\"",\n+      \""runtimeOnly\"",\n+      \""annotationProcessor\""})\n+    void addEnforcedPlatformWithExplicitConfiguration(String configuration) {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\""org.springframework.boot\"", \""spring-boot-dependencies\"", \""3.2.4\"", null, configuration, true)),\n+          mavenProject(\""project\"",\n+            srcMainJava(java(usingGuavaIntMath)),\n+            buildGradle(\n+              //language=groovy\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \""\""\"",\n+              //language=groovy\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    %s enforcedPlatform(\""org.springframework.boot:spring-boot-dependencies:3.2.4\"")\n+                }\n+                \""\""\"".formatted(configuration)\n+            )));\n+    }\n+\n+    @Test\n+    void addsToTestScopeWhenNoConfigurationSpecified() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\""org.springframework.boot\"", \""spring-boot-dependencies\"", \""3.2.4\"", null, null, null)),\n+          mavenProject(\""project\"",\n+            srcTestJava(java(usingGuavaIntMath)),\n+            buildGradle(\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \""\""\"",\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    testImplementation platform(\""org.springframework.boot:spring-boot-dependencies:3.2.4\"")\n+                }\n+                \""\""\""\n+            )\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addsToSmokeTestScopeWhenNoConfigurationSpecified() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\""org.springframework.boot\"", \""spring-boot-dependencies\"", \""3.2.4\"", null, null, null)),\n+          mavenProject(\""project\"",\n+            srcSmokeTestJava(java(usingGuavaIntMath)),\n+            buildGradle(\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                    id \""com.netflix.nebula.facet\"" version \""10.1.3\""\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                facets {\n+                    smokeTest {\n+                        parentSourceSet = \""test\""\n+                    }\n+                }\n+                \""\""\"",\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                    id \""com.netflix.nebula.facet\"" version \""10.1.3\""\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                facets {\n+                    smokeTest {\n+                        parentSourceSet = \""test\""\n+                    }\n+                }\n+                \n+                dependencies {\n+                    smokeTestImplementation platform(\""org.springframework.boot:spring-boot-dependencies:3.2.4\"")\n+                }\n+                \""\""\""\n+            )\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addsToImplementationScopeWhenNoConfigurationSpecified() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\""org.springframework.boot\"", \""spring-boot-dependencies\"", \""3.2.4\"", null, null, null))\n+            .typeValidationOptions(TypeValidation.none()),\n+          mavenProject(\""project\"",\n+            srcMainJava(java(usingGuavaIntMath)),\n+            buildGradle(\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \""\""\"",\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation platform(\""org.springframework.boot:spring-boot-dependencies:3.2.4\"")\n+                }\n+                \""\""\""\n+            )\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void onlyAddsToParentConfigurationWhenNoConfigurationSpecified() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\""org.springframework.boot\"", \""spring-boot-dependencies\"", \""3.2.4\"", null, null, null))\n+            .typeValidationOptions(TypeValidation.none()),\n+          mavenProject(\""project\"",\n+            srcMainJava(java(usingGuavaIntMath)),\n+            srcTestJava(java(usingGuavaIntMath)),\n+            buildGradle(\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \""\""\"",\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation platform(\""org.springframework.boot:spring-boot-dependencies:3.2.4\"")\n+                }\n+                \""\""\""\n+            )\n+          )\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+      \""integrationTestImplementation,implementation\"",\n+      \""integrationTestCompileOnly,compileOnly\"",\n+      \""integrationTestRuntimeOnly,runtimeOnly\"",\n+      \""integrationTestAnnotationProcessor,annotationProcessor\""})\n+    void addPlatformDependencyWithExplicitConfiguration(String recipeConfiguration, String gradleConfiguration) {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\""org.springframework.boot\"", \""spring-boot-dependencies\"", \""3.2.4\"", null, recipeConfiguration, null)),\n+          mavenProject(\""project\"",\n+            srcMainJava(java(usingGuavaIntMath, sourceSpecs -> sourceSet(sourceSpecs, \""integrationTest\""))),\n+            buildGradle(\n+              //language=groovy\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                    id 'jvm-test-suite'\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation \""org.apache.logging.log4j:log4j-core:2.22.1\""\n+                }\n+                \n+                testing {\n+                    suites {\n+                        integrationTest(JvmTestSuite) {\n+                        }\n+                    }\n+                }\n+                \""\""\"",\n+              //language=groovy\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                    id 'jvm-test-suite'\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation \""org.apache.logging.log4j:log4j-core:2.22.1\""\n+                }\n+                \n+                testing {\n+                    suites {\n+                        integrationTest(JvmTestSuite) {\n+                            dependencies {\n+                                %s platform(\""org.springframework.boot:spring-boot-dependencies:3.2.4\"")\n+                            }\n+                        }\n+                    }\n+                }\n+                \""\""\"".formatted(gradleConfiguration)\n+            )));\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+      \""integrationTestImplementation,implementation\"",\n+      \""integrationTestCompileOnly,compileOnly\"",\n+      \""integrationTestRuntimeOnly,runtimeOnly\"",\n+      \""integrationTestAnnotationProcessor,annotationProcessor\""})\n+    void addEnforcedPlatformDependencyWithExplicitConfiguration(String recipeConfiguration, String gradleConfiguration) {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\""org.springframework.boot\"", \""spring-boot-dependencies\"", \""3.2.4\"", null, recipeConfiguration, true)),\n+          mavenProject(\""project\"",\n+            srcMainJava(java(usingGuavaIntMath, sourceSpecs -> sourceSet(sourceSpecs, \""integrationTest\""))),\n+            buildGradle(\n+              //language=groovy\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                    id 'jvm-test-suite'\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation \""org.apache.logging.log4j:log4j-core:2.22.1\""\n+                }\n+                \n+                testing {\n+                    suites {\n+                        integrationTest(JvmTestSuite) {\n+                        }\n+                    }\n+                }\n+                \""\""\"",\n+              //language=groovy\n+              \""\""\""\n+                plugins {\n+                    id \""java-library\""\n+                    id 'jvm-test-suite'\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation \""org.apache.logging.log4j:log4j-core:2.22.1\""\n+                }\n+                \n+                testing {\n+                    suites {\n+                        integrationTest(JvmTestSuite) {\n+                            dependencies {\n+                                %s enforcedPlatform(\""org.springframework.boot:spring-boot-dependencies:3.2.4\"")\n+                            }\n+                        }\n+                    }\n+                }\n+                \""\""\"".formatted(gradleConfiguration)\n+            )));\n+    }\n+}\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindJVMTestSuitesTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindJVMTestSuitesTest.java\nindex f8e34ed5d69..401cd603e2b 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindJVMTestSuitesTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindJVMTestSuitesTest.java\n@@ -36,7 +36,7 @@ class NoDependency {\n         @Test\n         void configNull() {\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(null, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(\n                 withoutDependency,\n                 withoutDependencyFound\n@@ -47,21 +47,13 @@ void configNull() {\n         @Test\n         void configFalse() {\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(false, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(\n                 withoutDependency,\n                 withoutDependencyFound\n               )\n             );\n         }\n-\n-        @Test\n-        void configTrue() {\n-            rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(true, null)),\n-              buildGradle(withoutDependency)\n-            );\n-        }\n     }\n \n     @Nested\n@@ -69,7 +61,7 @@ class WithDependency {\n         @Test\n         void configNull() {\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(null, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(\n                 withDependency,\n                 withDependencyFound\n@@ -80,7 +72,7 @@ void configNull() {\n         @Test\n         void configFalse() {\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(false, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(\n                 withDependency,\n                 withDependencyFound\n@@ -91,7 +83,7 @@ void configFalse() {\n         @Test\n         void configTrue() {\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(true, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(\n                 withDependency,\n                 withDependencyFound\n@@ -105,15 +97,15 @@ class NoPlugin {\n         @Test\n         void noSuiteDefined() {\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(null, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(noSuiteDefined)\n             );\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(false, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(noSuiteDefined)\n             );\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(true, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(noSuiteDefined)\n             );\n         }\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/trait/JvmTestSuiteTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/trait/JvmTestSuiteTest.java\nnew file mode 100644\nindex 00000000000..4bc0444a537\n--- /dev/null\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/trait/JvmTestSuiteTest.java\n@@ -0,0 +1,412 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle.trait;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.DocumentExample;\n+import org.openrewrite.marker.SearchResult;\n+import org.openrewrite.maven.table.MavenMetadataFailures;\n+import org.openrewrite.test.RecipeSpec;\n+import org.openrewrite.test.RewriteTest;\n+\n+import static org.openrewrite.gradle.Assertions.buildGradle;\n+import static org.openrewrite.gradle.Assertions.buildGradleKts;\n+import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n+import static org.openrewrite.gradle.trait.Traits.jvmTestSuite;\n+\n+class JvmTestSuiteTest implements RewriteTest {\n+    @Override\n+    public void defaults(RecipeSpec spec) {\n+        spec.beforeRecipe(withToolingApi())\n+          .recipe(RewriteTest.toRecipe(() -> jvmTestSuite().asVisitor(suite ->\n+            SearchResult.found(suite.getTree()))));\n+    }\n+\n+    @Nested\n+    class GroovyDsl {\n+        @DocumentExample\n+        @Test\n+        void all() {\n+            rewriteRun(\n+              buildGradle(\n+                \""\""\""\n+                  plugins {\n+                      id \""java\""\n+                      id \""jvm-test-suite\""\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          test {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          integrationTest(JvmTestSuite) {\n+                              dependencies {\n+                                  implementation project()\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \""\""\"",\n+                \""\""\""\n+                  plugins {\n+                      id \""java\""\n+                      id \""jvm-test-suite\""\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          /*~~>*/test {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          /*~~>*/integrationTest(JvmTestSuite) {\n+                              dependencies {\n+                                  implementation project()\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \""\""\""\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void findByName() {\n+            rewriteRun(\n+              spec -> spec.recipe(RewriteTest.toRecipe(() -> jvmTestSuite().name(\""integrationTest\"").asVisitor(suite ->\n+                SearchResult.found(suite.getTree())))),\n+              buildGradle(\n+                \""\""\""\n+                  plugins {\n+                      id \""java\""\n+                      id \""jvm-test-suite\""\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          test {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          integrationTest(JvmTestSuite) {\n+                              dependencies {\n+                                  implementation project()\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \""\""\"",\n+                \""\""\""\n+                  plugins {\n+                      id \""java\""\n+                      id \""jvm-test-suite\""\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          test {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          /*~~>*/integrationTest(JvmTestSuite) {\n+                              dependencies {\n+                                  implementation project()\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \""\""\""\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void addDependency() {\n+            rewriteRun(\n+              spec -> spec.recipe(RewriteTest.toRecipe((recipe) -> jvmTestSuite().asVisitor((suite, ctx) ->\n+                suite.addDependency(\""implementation\"", \""com.google.guava\"", \""guava\"", \""29.0-jre\"", null, null, null, new MavenMetadataFailures(recipe), null, ctx).visitNonNull(suite.getTree(), ctx, suite.getCursor().getParentOrThrow())))),\n+              buildGradle(\n+                \""\""\""\n+                  plugins {\n+                      id \""java\""\n+                      id \""jvm-test-suite\""\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          test {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          integrationTest(JvmTestSuite) {\n+                              dependencies {\n+                                  implementation project()\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \""\""\"",\n+                \""\""\""\n+                  plugins {\n+                      id \""java\""\n+                      id \""jvm-test-suite\""\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          test {\n+                              useJUnitJupiter()\n+                  \n+                              dependencies {\n+                                  implementation \""com.google.guava:guava:29.0-jre\""\n+                              }\n+                          }\n+                  \n+                          integrationTest(JvmTestSuite) {\n+                              dependencies {\n+                                  implementation project()\n+                                  implementation \""com.google.guava:guava:29.0-jre\""\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \""\""\""\n+              )\n+            );\n+        }\n+    }\n+\n+    @Nested\n+    class KotlinDsl {\n+        @DocumentExample\n+        @Test\n+        void all() {\n+            rewriteRun(\n+              buildGradleKts(\n+                \""\""\""\n+                  plugins {\n+                      java\n+                      `jvm-test-suite`\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          val test by getting(JvmTestSuite::class) {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          register<JvmTestSuite>(\""integrationTest\"") {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                  \n+                          val functionalTest by registering(JvmTestSuite::class) {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \""\""\"",\n+                \""\""\""\n+                  plugins {\n+                      java\n+                      `jvm-test-suite`\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          /*~~>*/val test by getting(JvmTestSuite::class) {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          /*~~>*/register<JvmTestSuite>(\""integrationTest\"") {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                  \n+                          /*~~>*/val functionalTest by registering(JvmTestSuite::class) {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \""\""\""\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void findByName() {\n+            rewriteRun(\n+              spec -> spec.recipe(RewriteTest.toRecipe(() -> jvmTestSuite().name(\""integrationTest\"").asVisitor(suite ->\n+                SearchResult.found(suite.getTree())))),\n+              buildGradleKts(\n+                \""\""\""\n+                  plugins {\n+                      java\n+                      `jvm-test-suite`\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          val test by getting(JvmTestSuite::class) {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          register<JvmTestSuite>(\""integrationTest\"") {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \""\""\"",\n+                \""\""\""\n+                  plugins {\n+                      java\n+                      `jvm-test-suite`\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          val test by getting(JvmTestSuite::class) {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          /*~~>*/register<JvmTestSuite>(\""integrationTest\"") {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \""\""\""\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void addDependency() {\n+            rewriteRun(\n+              spec -> spec.recipe(RewriteTest.toRecipe((recipe) -> jvmTestSuite().asVisitor((suite, ctx) ->\n+                suite.addDependency(\""implementation\"", \""com.google.guava\"", \""guava\"", \""29.0-jre\"", null, null, null, new MavenMetadataFailures(recipe), null, ctx).visitNonNull(suite.getTree(), ctx, suite.getCursor().getParentOrThrow())))),\n+              buildGradleKts(\n+                \""\""\""\n+                  plugins {\n+                      java\n+                      `jvm-test-suite`\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          val test by getting(JvmTestSuite::class) {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          register<JvmTestSuite>(\""integrationTest\"") {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \""\""\"",\n+                \""\""\""\n+                  plugins {\n+                      java\n+                      `jvm-test-suite`\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          val test by getting(JvmTestSuite::class) {\n+                              useJUnitJupiter()\n+                  \n+                              dependencies {\n+                                  implementation(\""com.google.guava:guava:29.0-jre\"")\n+                              }\n+                          }\n+                  \n+                          register<JvmTestSuite>(\""integrationTest\"") {\n+                              dependencies {\n+                                  implementation(project())\n+                                  implementation(\""com.google.guava:guava:29.0-jre\"")\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \""\""\""\n+              )\n+            );\n+        }\n+    }\n+}\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""openrewrite__rewrite-5158"", ""pr_id"": 5158, ""issue_id"": 3291, ""repo"": ""openrewrite/rewrite"", ""problem_statement"": ""Dependency management support for Gradle Kotlin scripts (.kts)\n## What problem are you trying to solve?\r\nGradle supports Groovy and Kotlin as scripting languages for build files. We currently support editing Groovy-based build files. This should be extended to Kotiln.\r\n\r\n## Describe the solution you'd like\r\nFor each Gradle-groovy dependency management recipe there should be a Gradle-kotlin equivalent.\r\n\r\n## Additional context\r\nRequires some enhancements to rewrite-kotlin and rewrite-gradle. "", ""issue_word_count"": 71, ""test_files_count"": 6, ""non_test_files_count"": 12, ""pr_changed_files"": [""rewrite-core/src/main/java/org/openrewrite/TreeVisitor.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/ChangeDependency.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyConstraintToRule.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/IsBuildGradle.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/IsSettingsGradle.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/RemoveDependency.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java"", ""rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/GradleDependency.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/ChangeDependencyTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/RemoveDependencyTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java"", ""rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java""], ""pr_changed_test_files"": [""rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/ChangeDependencyTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/RemoveDependencyTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java"", ""rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java""], ""base_commit"": ""e0e86d8f520b69013ef69643de889bb1aa3a1a11"", ""head_commit"": ""c6d50c37203f04b24b376e6ba87b6a76ed6b5646"", ""repo_url"": ""https://github.com/openrewrite/rewrite/pull/5158"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5158"", ""dockerfile"": """", ""pr_merged_at"": ""2025-04-07T20:05:06.000Z"", ""patch"": ""diff --git a/rewrite-core/src/main/java/org/openrewrite/TreeVisitor.java b/rewrite-core/src/main/java/org/openrewrite/TreeVisitor.java\nindex 6c3b97126b1..eff307c309e 100644\n--- a/rewrite-core/src/main/java/org/openrewrite/TreeVisitor.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/TreeVisitor.java\n@@ -142,7 +142,8 @@ public final Cursor updateCursor(T currentValue) {\n     }\n \n     public @Nullable T visit(@Nullable Tree tree, P p, Cursor parent) {\n-        assert !(parent.getValue() instanceof Tree) ||\n+        assert parent.isRoot() ||\n+               !(parent.getValue() instanceof Tree) ||\n                !((Tree) parent.getValue()).isScope(tree) ||\n                !(p instanceof ExecutionContext) ||\n                !CursorValidatingExecutionContextView.view((ExecutionContext) p).getValidateCursorAcyclic() :\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java\nindex 8c6a97658fb..e437684e928 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java\n@@ -22,9 +22,8 @@\n import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n import org.openrewrite.gradle.search.FindJVMTestSuites;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n-import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.marker.JavaProject;\n import org.openrewrite.java.marker.JavaSourceSet;\n import org.openrewrite.java.search.UsesType;\n@@ -194,7 +193,7 @@ private boolean usesType(SourceFile sourceFile, ExecutionContext ctx) {\n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {\n         return Preconditions.check(!acc.configurationsByProject.isEmpty(),\n-                Preconditions.check(new IsBuildGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {\n+                Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {\n \n                     @Override\n                     public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n@@ -202,10 +201,6 @@ public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {\n                             return (J) tree;\n                         }\n                         JavaSourceFile s = (JavaSourceFile) tree;\n-                        if (!isAcceptable(s, ctx) || !s.getSourcePath().toString().endsWith(\"".gradle\"") || s.getSourcePath().getFileName().toString().equals(\""settings.gradle\"")) {\n-                            return s;\n-                        }\n-\n                         Optional<JavaProject> maybeJp = s.getMarkers().findFirst(JavaProject.class);\n                         if (!maybeJp.isPresent()) {\n                             return s;\n@@ -252,18 +247,17 @@ public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {\n                             return s;\n                         }\n \n-                        G.CompilationUnit g = (G.CompilationUnit) s;\n                         for (String resolvedConfiguration : resolvedConfigurations) {\n                             if (targetsCustomJVMTestSuite(resolvedConfiguration, acc.customJvmTestSuitesWithDependencies.get(jp))) {\n-                                g = (G.CompilationUnit) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, purgeSourceSet(configuration),\n-                                        classifier, extension, metadataFailures, isMatchingJVMTestSuite(resolvedConfiguration)).visitNonNull(g, ctx);\n+                                s = (JavaSourceFile) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, purgeSourceSet(configuration),\n+                                        classifier, extension, metadataFailures, isMatchingJVMTestSuite(resolvedConfiguration)).visitNonNull(s, ctx);\n                             } else {\n-                                g = (G.CompilationUnit) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, resolvedConfiguration,\n-                                        classifier, extension, metadataFailures, this::isTopLevel).visitNonNull(g, ctx);\n+                                s = (JavaSourceFile) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, resolvedConfiguration,\n+                                        classifier, extension, metadataFailures, this::isTopLevel).visitNonNull(s, ctx);\n                             }\n                         }\n \n-                        return g;\n+                        return s;\n                     }\n \n                     private boolean isTopLevel(Cursor cursor) {\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\nindex 737f55f5c8c..18530a0f95a 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\n@@ -17,20 +17,20 @@\n \n import lombok.RequiredArgsConstructor;\n import org.jspecify.annotations.Nullable;\n-import org.openrewrite.Cursor;\n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.SourceFile;\n+import org.openrewrite.*;\n import org.openrewrite.gradle.internal.InsertDependencyComparator;\n import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.MethodMatcher;\n import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaSourceFile;\n import org.openrewrite.java.tree.Space;\n import org.openrewrite.java.tree.Statement;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.marker.Markup;\n import org.openrewrite.maven.MavenDownloadingException;\n import org.openrewrite.maven.MavenDownloadingExceptions;\n@@ -39,6 +39,9 @@\n import org.openrewrite.maven.tree.*;\n import org.openrewrite.tree.ParseError;\n \n+import java.io.ByteArrayInputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n import java.util.*;\n import java.util.function.Predicate;\n import java.util.stream.Collectors;\n@@ -49,7 +52,7 @@\n import static java.util.Objects.requireNonNull;\n \n @RequiredArgsConstructor\n-public class AddDependencyVisitor extends GroovyIsoVisitor<ExecutionContext> {\n+public class AddDependencyVisitor extends JavaIsoVisitor<ExecutionContext> {\n     private static final MethodMatcher DEPENDENCIES_DSL_MATCHER = new MethodMatcher(\""RewriteGradleProject dependencies(..)\"");\n     private static final GradleParser GRADLE_PARSER = GradleParser.builder().build();\n \n@@ -80,51 +83,90 @@ public class AddDependencyVisitor extends GroovyIsoVisitor<ExecutionContext> {\n     private final Predicate<Cursor> insertPredicate;\n \n     @Override\n-    public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n-        Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);\n-        if (!maybeGp.isPresent()) {\n-            return cu;\n-        }\n+    public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+        if (tree instanceof JavaSourceFile) {\n+            JavaSourceFile cu = (JavaSourceFile) super.visit(tree, ctx);\n+            Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);\n+            if (!maybeGp.isPresent()) {\n+                return cu;\n+            }\n \n-        GradleProject gp = maybeGp.get();\n-        GradleDependencyConfiguration gdc = gp.getConfiguration(configuration);\n-        if (gdc == null || gdc.findRequestedDependency(groupId, artifactId) != null) {\n-            return cu;\n-        }\n+            GradleProject gp = maybeGp.get();\n+            GradleDependencyConfiguration gdc = gp.getConfiguration(configuration);\n+            if (gdc == null || gdc.findRequestedDependency(groupId, artifactId) != null) {\n+                return cu;\n+            }\n \n-        G.CompilationUnit g = cu;\n-        boolean dependenciesBlockMissing = true;\n-        for (Statement statement : g.getStatements()) {\n-            if (statement instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) statement)) {\n-                dependenciesBlockMissing = false;\n+            boolean dependenciesBlockMissing = true;\n+            if (cu instanceof G.CompilationUnit) {\n+                G.CompilationUnit g = (G.CompilationUnit) cu;\n+                for (Statement statement : g.getStatements()) {\n+                    if (statement instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) statement)) {\n+                        dependenciesBlockMissing = false;\n+                    }\n+                }\n+            } else if (cu instanceof K.CompilationUnit) {\n+                K.CompilationUnit k = (K.CompilationUnit) cu;\n+                for (Statement statement : ((J.Block) k.getStatements().get(0)).getStatements()) {\n+                    if (statement instanceof J.MethodInvocation && ((J.MethodInvocation) statement).getSimpleName().equals(\""dependencies\"")) {\n+                        dependenciesBlockMissing = false;\n+                    }\n+                }\n             }\n-        }\n \n-        if (dependenciesBlockMissing) {\n-            Statement dependenciesInvocation = GRADLE_PARSER.parse(ctx, \""dependencies {}\"")\n-                    .findFirst()\n-                    .map(G.CompilationUnit.class::cast)\n-                    .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""))\n-                    .getStatements().get(0);\n-            dependenciesInvocation = autoFormat(dependenciesInvocation, ctx, new Cursor(getCursor(), cu));\n-            g = g.withStatements(ListUtils.concat(g.getStatements(),\n-                    g.getStatements().isEmpty() ?\n-                            dependenciesInvocation :\n-                            dependenciesInvocation.withPrefix(Space.format(\""\\n\\n\""))));\n-        }\n+            if (dependenciesBlockMissing) {\n+                if (cu instanceof G.CompilationUnit) {\n+                    G.CompilationUnit g = (G.CompilationUnit) cu;\n+                    Statement dependenciesInvocation = GRADLE_PARSER.parse(ctx, \""dependencies {}\"")\n+                            .findFirst()\n+                            .map(G.CompilationUnit.class::cast)\n+                            .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""))\n+                            .getStatements().get(0);\n+                    Cursor parent = getCursor();\n+                    setCursor(new Cursor(parent, g));\n+                    dependenciesInvocation = autoFormat(dependenciesInvocation, ctx, new Cursor(parent, g));\n+                    setCursor(parent);\n+                    cu = g.withStatements(ListUtils.concat(g.getStatements(),\n+                            g.getStatements().isEmpty() ?\n+                                    dependenciesInvocation :\n+                                    dependenciesInvocation.withPrefix(Space.format(\""\\n\\n\""))));\n+                } else {\n+                    K.CompilationUnit k = (K.CompilationUnit) cu;\n+                    J.MethodInvocation dependenciesInvocation = (J.MethodInvocation) ((J.Block) GRADLE_PARSER.parseInputs(Collections.singletonList(new GradleParser.Input(Paths.get(\""build.gradle.kts\""), () -> new ByteArrayInputStream(\""dependencies {}\"".getBytes(StandardCharsets.UTF_8)))), null, ctx)\n+                            .findFirst()\n+                            .map(K.CompilationUnit.class::cast)\n+                            .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""))\n+                            .getStatements().get(0)).getStatements().get(0);\n+                    Cursor parent = getCursor();\n+                    setCursor(new Cursor(parent, k));\n+                    dependenciesInvocation = autoFormat(dependenciesInvocation, ctx, new Cursor(getCursor(), k));\n+                    setCursor(parent);\n+                    dependenciesInvocation = dependenciesInvocation.withArguments(ListUtils.mapFirst(dependenciesInvocation.getArguments(), arg -> {\n+                        J.Lambda lambda = (J.Lambda) requireNonNull(arg);\n+                        J.Block block = (J.Block) lambda.getBody();\n+                        return lambda.withBody(block.withEnd(Space.format(\""\\n\"")));\n+                    }));\n+                    cu = k.withStatements(ListUtils.concat(k.getStatements(),\n+                            k.getStatements().isEmpty() ?\n+                                    dependenciesInvocation :\n+                                    dependenciesInvocation.withPrefix(Space.format(\""\\n\\n\""))));\n+                }\n+            }\n \n-        g = (G.CompilationUnit) new InsertDependencyInOrder(configuration, gp)\n-                .visitNonNull(g, ctx, requireNonNull(getCursor().getParent()));\n+            cu = (JavaSourceFile) new InsertDependencyInOrder(configuration, gp)\n+                    .visitNonNull(cu, ctx);\n \n-        if (g != cu) {\n-            String versionWithPattern = StringUtils.isBlank(resolvedVersion) || resolvedVersion.startsWith(\""$\"") ? null : resolvedVersion;\n-            g = addDependency(g,\n-                    gdc,\n-                    new GroupArtifactVersion(groupId, artifactId, versionWithPattern),\n-                    classifier,\n-                    ctx);\n+            if (cu != tree) {\n+                String versionWithPattern = StringUtils.isBlank(resolvedVersion) || resolvedVersion.startsWith(\""$\"") ? null : resolvedVersion;\n+                cu = addDependency(cu,\n+                        gdc,\n+                        new GroupArtifactVersion(groupId, artifactId, versionWithPattern),\n+                        classifier,\n+                        ctx);\n+            }\n+            return cu;\n         }\n-        return g;\n+        return super.visit(tree, ctx);\n     }\n \n     /**\n@@ -138,8 +180,8 @@ public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionCon\n      * @param ctx           context which will be used to download the pom for the dependency\n      * @return a copy of buildScript with the dependency added\n      */\n-    static G.CompilationUnit addDependency(\n-            G.CompilationUnit buildScript,\n+    static JavaSourceFile addDependency(\n+            JavaSourceFile buildScript,\n             @Nullable GradleDependencyConfiguration configuration,\n             GroupArtifactVersion gav,\n             @Nullable String classifier,\n@@ -211,7 +253,7 @@ static G.CompilationUnit addDependency(\n     }\n \n     @RequiredArgsConstructor\n-    private class InsertDependencyInOrder extends GroovyIsoVisitor<ExecutionContext> {\n+    private class InsertDependencyInOrder extends JavaIsoVisitor<ExecutionContext> {\n         private final String configuration;\n \n         private final GradleProject gp;\n@@ -219,7 +261,8 @@ private class InsertDependencyInOrder extends GroovyIsoVisitor<ExecutionContext>\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n-            if (!DEPENDENCIES_DSL_MATCHER.matches(m)) {\n+            boolean isKotlinDsl = getCursor().firstEnclosing(JavaSourceFile.class) instanceof K.CompilationUnit;\n+            if (!DEPENDENCIES_DSL_MATCHER.matches(m) && !(isKotlinDsl && m.getSimpleName().equals(\""dependencies\""))) {\n                 return m;\n             }\n \n@@ -250,28 +293,53 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n             String codeTemplate;\n             DependencyStyle style = autodetectDependencyStyle(body.getStatements());\n             if (style == DependencyStyle.String) {\n-                codeTemplate = \""dependencies {\\n\"" +\n-                               escapeIfNecessary(configuration) + \"" \\\""\"" + groupId + \"":\"" + artifactId + (resolvedVersion == null ? \""\"" : \"":\"" + resolvedVersion) + (resolvedVersion == null || classifier == null ? \""\"" : \"":\"" + classifier) + (extension == null ? \""\"" : \""@\"" + extension) + \""\\\""\"" +\n-                               \""\\n}\"";\n+                if (!isKotlinDsl) {\n+                    codeTemplate = \""dependencies {\\n\"" +\n+                                   escapeIfNecessary(configuration) + \"" \\\""\"" + groupId + \"":\"" + artifactId + (resolvedVersion == null ? \""\"" : \"":\"" + resolvedVersion) + (resolvedVersion == null || classifier == null ? \""\"" : \"":\"" + classifier) + (extension == null ? \""\"" : \""@\"" + extension) + \""\\\""\"" +\n+                                   \""\\n}\"";\n+                } else {\n+                    codeTemplate = \""dependencies {\\n\"" +\n+                                   configuration + \""(\\\""\"" + groupId + \"":\"" + artifactId + (resolvedVersion == null ? \""\"" : \"":\"" + resolvedVersion) + (resolvedVersion == null || classifier == null ? \""\"" : \"":\"" + classifier) + (extension == null ? \""\"" : \""@\"" + extension) + \""\\\"")\"" +\n+                                   \""\\n}\"";\n+                }\n             } else {\n-                codeTemplate = \""dependencies {\\n\"" +\n-                               escapeIfNecessary(configuration) + \"" group: \\\""\"" + groupId + \""\\\"", name: \\\""\"" + artifactId + \""\\\""\"" + (resolvedVersion == null ? \""\"" : \"", version: \\\""\"" + resolvedVersion + \""\\\""\"") + (classifier == null ? \""\"" : \"", classifier: \\\""\"" + classifier + \""\\\""\"") + (extension == null ? \""\"" : \"", ext: \\\""\"" + extension + \""\\\""\"") +\n-                               \""\\n}\"";\n+                if (!isKotlinDsl) {\n+                    codeTemplate = \""dependencies {\\n\"" +\n+                                   escapeIfNecessary(configuration) + \"" group: \\\""\"" + groupId + \""\\\"", name: \\\""\"" + artifactId + \""\\\""\"" + (resolvedVersion == null ? \""\"" : \"", version: \\\""\"" + resolvedVersion + \""\\\""\"") + (classifier == null ? \""\"" : \"", classifier: \\\""\"" + classifier + \""\\\""\"") + (extension == null ? \""\"" : \"", ext: \\\""\"" + extension + \""\\\""\"") +\n+                                   \""\\n}\"";\n+                } else {\n+                    codeTemplate = \""dependencies {\\n\"" +\n+                                   configuration + \""(group = \\\""\"" + groupId + \""\\\"", name = \\\""\"" + artifactId + \""\\\""\"" + (resolvedVersion == null ? \""\"" : \"", version = \\\""\"" + resolvedVersion + \""\\\""\"") + (classifier == null ? \""\"" : \"", classifier = \\\""\"" + classifier + \""\\\""\"") + (extension == null ? \""\"" : \"", ext = \\\""\"" + extension + \""\\\""\"") + \"")\"" +\n+                                   \""\\n}\"";\n+                }\n             }\n \n             Boolean requirePrintEqualsInput = ctx.getMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT);\n             ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, false);\n-            SourceFile parsed = GRADLE_PARSER.parse(ctx, codeTemplate)\n-                    .findFirst()\n-                    .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""));\n+            SourceFile parsed;\n+            if (!isKotlinDsl) {\n+                parsed = GRADLE_PARSER.parse(ctx, codeTemplate)\n+                        .findFirst()\n+                        .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""));\n+            } else {\n+                parsed = GRADLE_PARSER.parseInputs(Collections.singletonList(new GradleParser.Input(Paths.get(\""build.gradle.kts\""), () -> new ByteArrayInputStream(codeTemplate.getBytes(StandardCharsets.UTF_8)))), null, ctx)\n+                        .findFirst()\n+                        .orElseThrow(() -> new IllegalArgumentException(\""Could not parse as Gradle\""));\n+            }\n             ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, requirePrintEqualsInput);\n \n             if (parsed instanceof ParseError) {\n                 throw ((ParseError) parsed).toException();\n             }\n \n-            J.MethodInvocation addDependencyInvocation = requireNonNull((J.MethodInvocation) ((J.Return) (((J.Block) ((J.Lambda) ((J.MethodInvocation)\n-                    ((G.CompilationUnit) parsed).getStatements().get(0)).getArguments().get(0)).getBody()).getStatements().get(0))).getExpression());\n+            J.MethodInvocation addDependencyInvocation;\n+            if (!isKotlinDsl) {\n+                addDependencyInvocation = requireNonNull((J.MethodInvocation) ((J.Return) (((J.Block) ((J.Lambda) ((J.MethodInvocation)\n+                        ((G.CompilationUnit) parsed).getStatements().get(0)).getArguments().get(0)).getBody()).getStatements().get(0))).getExpression());\n+            } else {\n+                addDependencyInvocation = requireNonNull((J.MethodInvocation) (((J.Block) ((J.Lambda) ((J.MethodInvocation)\n+                        ((J.Block) ((K.CompilationUnit) parsed).getStatements().get(0)).getStatements().get(0)).getArguments().get(0)).getBody()).getStatements().get(0)));\n+            }\n             addDependencyInvocation = autoFormat(addDependencyInvocation, ctx, new Cursor(getCursor(), body));\n             InsertDependencyComparator dependencyComparator = new InsertDependencyComparator(body.getStatements(), addDependencyInvocation);\n \n@@ -347,6 +415,8 @@ private DependencyStyle autodetectDependencyStyle(List<Statement> statements) {\n                     string++;\n                 } else if (invocation.getArguments().get(0) instanceof G.MapEntry) {\n                     map++;\n+                } else if (invocation.getArguments().get(0) instanceof J.Assignment) {\n+                    map++;\n                 }\n             } else if (statement instanceof J.MethodInvocation) {\n                 J.MethodInvocation invocation = (J.MethodInvocation) statement;\n@@ -354,6 +424,8 @@ private DependencyStyle autodetectDependencyStyle(List<Statement> statements) {\n                     string++;\n                 } else if (invocation.getArguments().get(0) instanceof G.MapEntry) {\n                     map++;\n+                } else if (invocation.getArguments().get(0) instanceof J.Assignment) {\n+                    map++;\n                 }\n             }\n         }\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/ChangeDependency.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/ChangeDependency.java\nindex 30c22441aed..ff070a4eaeb 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/ChangeDependency.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/ChangeDependency.java\n@@ -27,13 +27,16 @@\n import org.openrewrite.gradle.marker.GradleProject;\n import org.openrewrite.gradle.search.FindGradleProject;\n import org.openrewrite.gradle.trait.GradleDependency;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.tree.Expression;\n import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaSourceFile;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.maven.MavenDownloadingException;\n+import org.openrewrite.maven.table.MavenMetadataFailures;\n import org.openrewrite.maven.tree.GroupArtifact;\n import org.openrewrite.maven.tree.GroupArtifactVersion;\n import org.openrewrite.maven.tree.ResolvedGroupArtifactVersion;\n@@ -102,6 +105,7 @@ public class ChangeDependency extends Recipe {\n     // Minimize the number of allocations by caching the updated dependencies.\n     transient Map<org.openrewrite.maven.tree.Dependency, org.openrewrite.maven.tree.Dependency> updatedRequested = new HashMap<>();\n     transient Map<org.openrewrite.maven.tree.ResolvedDependency, org.openrewrite.maven.tree.ResolvedDependency> updatedResolved = new HashMap<>();\n+    transient MavenMetadataFailures mavenMetadataFailures = new MavenMetadataFailures(this);\n \n     @Override\n     public String getDisplayName() {\n@@ -140,25 +144,34 @@ public Validated<Object> validate() {\n \n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(new FindGradleProject(FindGradleProject.SearchCriteria.Marker).getVisitor(), new GroovyIsoVisitor<ExecutionContext>() {\n+        return Preconditions.check(new FindGradleProject(FindGradleProject.SearchCriteria.Marker).getVisitor(), new JavaIsoVisitor<ExecutionContext>() {\n             final DependencyMatcher depMatcher = requireNonNull(DependencyMatcher.build(oldGroupId + \"":\"" + oldArtifactId).getValue());\n \n             GradleProject gradleProject;\n \n             @Override\n-            public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n-                Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);\n-                if (!maybeGp.isPresent()) {\n-                    return cu;\n-                }\n+            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {\n+                return sourceFile instanceof G.CompilationUnit || sourceFile instanceof K.CompilationUnit;\n+            }\n \n-                gradleProject = maybeGp.get();\n+            @Override\n+            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                if (tree instanceof JavaSourceFile) {\n+                    JavaSourceFile sourceFile = (JavaSourceFile) tree;\n+                    Optional<GradleProject> maybeGp = sourceFile.getMarkers().findFirst(GradleProject.class);\n+                    if (!maybeGp.isPresent()) {\n+                        return sourceFile;\n+                    }\n \n-                G.CompilationUnit g = super.visitCompilationUnit(cu, ctx);\n-                if (g != cu) {\n-                    g = g.withMarkers(g.getMarkers().setByType(updateGradleModel(gradleProject)));\n+                    gradleProject = maybeGp.get();\n+\n+                    sourceFile = (JavaSourceFile) super.visit(sourceFile, ctx);\n+                    if (sourceFile != tree) {\n+                        sourceFile = sourceFile.withMarkers(sourceFile.getMarkers().setByType(updateGradleModel(gradleProject)));\n+                    }\n+                    return sourceFile;\n                 }\n-                return g;\n+                return super.visit(tree, ctx);\n             }\n \n             @Override\n@@ -174,7 +187,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                 }\n \n                 List<Expression> depArgs = m.getArguments();\n-                if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry || depArgs.get(0) instanceof G.MapLiteral) {\n+                if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry || depArgs.get(0) instanceof G.MapLiteral || depArgs.get(0) instanceof J.Assignment || depArgs.get(0) instanceof K.StringTemplate) {\n                     m = updateDependency(m, ctx);\n                 } else if (depArgs.get(0) instanceof J.MethodInvocation &&\n                            (((J.MethodInvocation) depArgs.get(0)).getSimpleName().equals(\""platform\"") ||\n@@ -425,6 +438,127 @@ private J.MethodInvocation updateDependency(J.MethodInvocation m, ExecutionConte\n                             }));\n                         }));\n                     }\n+                } else if (m.getArguments().get(0) instanceof J.Assignment) {\n+                    J.Assignment groupAssignment = null;\n+                    J.Assignment artifactAssignment = null;\n+                    J.Assignment versionAssignment = null;\n+                    String groupId = null;\n+                    String artifactId = null;\n+                    String version = null;\n+\n+                    for (Expression e : depArgs) {\n+                        if (!(e instanceof J.Assignment)) {\n+                            continue;\n+                        }\n+                        J.Assignment arg = (J.Assignment) e;\n+                        if (!(arg.getVariable() instanceof J.Identifier) || !(arg.getAssignment() instanceof J.Literal)) {\n+                            continue;\n+                        }\n+                        J.Identifier identifier = (J.Identifier) arg.getVariable();\n+                        J.Literal assignment = (J.Literal) arg.getAssignment();\n+                        if (!(assignment.getValue() instanceof String)) {\n+                            continue;\n+                        }\n+                        String valueValue = (String) assignment.getValue();\n+                        switch (identifier.getSimpleName()) {\n+                            case \""group\"":\n+                                groupAssignment = arg;\n+                                groupId = valueValue;\n+                                break;\n+                            case \""name\"":\n+                                artifactAssignment = arg;\n+                                artifactId = valueValue;\n+                                break;\n+                            case \""version\"":\n+                                versionAssignment = arg;\n+                                version = valueValue;\n+                                break;\n+                        }\n+                    }\n+                    if (groupId == null || artifactId == null) {\n+                        return m;\n+                    }\n+                    if (!depMatcher.matches(groupId, artifactId)) {\n+                        return m;\n+                    }\n+                    String updatedGroupId = groupId;\n+                    if (!StringUtils.isBlank(newGroupId) && !updatedGroupId.equals(newGroupId)) {\n+                        updatedGroupId = newGroupId;\n+                    }\n+                    String updatedArtifactId = artifactId;\n+                    if (!StringUtils.isBlank(newArtifactId) && !updatedArtifactId.equals(newArtifactId)) {\n+                        updatedArtifactId = newArtifactId;\n+                    }\n+                    String updatedVersion = version;\n+                    if (!StringUtils.isBlank(newVersion) && (!StringUtils.isBlank(version) || Boolean.TRUE.equals(overrideManagedVersion))) {\n+                        String resolvedVersion;\n+                        try {\n+                            resolvedVersion = new DependencyVersionSelector(mavenMetadataFailures, gradleProject, null)\n+                                    .select(new GroupArtifact(updatedGroupId, updatedArtifactId), m.getSimpleName(), newVersion, versionPattern, ctx);\n+                        } catch (MavenDownloadingException e) {\n+                            return e.warn(m);\n+                        }\n+                        if (resolvedVersion != null && !resolvedVersion.equals(updatedVersion)) {\n+                            updatedVersion = resolvedVersion;\n+                        }\n+                    }\n+\n+                    if (!updatedGroupId.equals(groupId) || !updatedArtifactId.equals(artifactId) || updatedVersion != null && !updatedVersion.equals(version)) {\n+                        J.Assignment finalGroup = groupAssignment;\n+                        String finalGroupIdValue = updatedGroupId;\n+                        J.Assignment finalArtifact = artifactAssignment;\n+                        String finalArtifactIdValue = updatedArtifactId;\n+                        J.Assignment finalVersion = versionAssignment;\n+                        String finalVersionValue = updatedVersion;\n+                        m = m.withArguments(ListUtils.map(m.getArguments(), arg -> {\n+                            if (arg == finalGroup) {\n+                                return finalGroup.withAssignment(ChangeStringLiteral.withStringValue((J.Literal) finalGroup.getAssignment(), finalGroupIdValue));\n+                            }\n+                            if (arg == finalArtifact) {\n+                                return finalArtifact.withAssignment(ChangeStringLiteral.withStringValue((J.Literal) finalArtifact.getAssignment(), finalArtifactIdValue));\n+                            }\n+                            if (arg == finalVersion) {\n+                                return finalVersion.withAssignment(ChangeStringLiteral.withStringValue((J.Literal) finalVersion.getAssignment(), finalVersionValue));\n+                            }\n+                            return arg;\n+                        }));\n+                    }\n+                } else if (depArgs.get(0) instanceof K.StringTemplate) {\n+                    K.StringTemplate template = (K.StringTemplate) depArgs.get(0);\n+                    List<J> strings = template.getStrings();\n+                    if (strings.size() >= 2 && strings.get(0) instanceof J.Literal &&\n+                            ((J.Literal) strings.get(0)).getValue() != null) {\n+\n+                        J.Literal literal = (J.Literal) strings.get(0);\n+                        Dependency original = DependencyStringNotationConverter.parse((String) requireNonNull(literal.getValue()));\n+                        if (original != null) {\n+                            Dependency updated = original;\n+                            if (!StringUtils.isBlank(newGroupId) && !updated.getGroupId().equals(newGroupId)) {\n+                                updated = updated.withGroupId(newGroupId);\n+                            }\n+                            if (!StringUtils.isBlank(newArtifactId) && !updated.getArtifactId().equals(newArtifactId)) {\n+                                updated = updated.withArtifactId(newArtifactId);\n+                            }\n+                            if (!StringUtils.isBlank(newVersion)) {\n+                                String resolvedVersion;\n+                                try {\n+                                    resolvedVersion = new DependencyVersionSelector(mavenMetadataFailures, gradleProject, null)\n+                                            .select(new GroupArtifact(updated.getGroupId(), updated.getArtifactId()), m.getSimpleName(), newVersion, versionPattern, ctx);\n+                                } catch (MavenDownloadingException e) {\n+                                    return e.warn(m);\n+                                }\n+                                if (resolvedVersion != null && !resolvedVersion.equals(updated.getVersion())) {\n+                                    updated = updated.withVersion(resolvedVersion);\n+                                }\n+                            }\n+                            if (original != updated) {\n+                                String replacement = updated.toStringNotation();\n+                                J.Literal newLiteral = literal.withValue(replacement)\n+                                        .withValueSource(template.getDelimiter() + replacement + template.getDelimiter());\n+                                m = m.withArguments(Collections.singletonList(newLiteral));\n+                            }\n+                        }\n+                    }\n                 }\n \n                 return m;\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyConstraintToRule.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyConstraintToRule.java\nindex cccdf2e63ba..58daf572f0d 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyConstraintToRule.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyConstraintToRule.java\n@@ -19,15 +19,21 @@\n import org.intellij.lang.annotations.Language;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n import org.openrewrite.groovy.GroovyParser;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.MethodMatcher;\n import org.openrewrite.java.tree.*;\n+import org.openrewrite.kotlin.KotlinParser;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.marker.Markers;\n \n+import java.io.ByteArrayInputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -59,18 +65,20 @@ public String getDescription() {\n \n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(new IsBuildGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {\n+        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {\n             @Override\n-            public G.CompilationUnit visitCompilationUnit(G.CompilationUnit compilationUnit, ExecutionContext ctx) {\n-                List<GroupArtifactVersionBecause> gavs = new ArrayList<>();\n-                Cursor parent = requireNonNull(getCursor().getParent());\n-                G.CompilationUnit cu = (G.CompilationUnit) new RemoveConstraints().visitNonNull(compilationUnit, gavs, parent);\n-                if (gavs.isEmpty()) {\n-                    return compilationUnit;\n+            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                if (tree instanceof JavaSourceFile) {\n+                    List<GroupArtifactVersionBecause> gavs = new ArrayList<>();\n+                    JavaSourceFile cu = (JavaSourceFile) new RemoveConstraints().visitNonNull(tree, gavs);\n+                    if (gavs.isEmpty()) {\n+                        return (J) tree;\n+                    }\n+                    cu = (JavaSourceFile) new MaybeAddEachDependency().visitNonNull(cu, ctx);\n+                    cu = (JavaSourceFile) new UpdateEachDependency(gavs, cu instanceof K.CompilationUnit).visitNonNull(cu, ctx);\n+                    return cu;\n                 }\n-                cu = (G.CompilationUnit) new MaybeAddEachDependency().visitNonNull(cu, ctx, parent);\n-                cu = (G.CompilationUnit) new UpdateEachDependency(gavs).visitNonNull(cu, ctx, parent);\n-                return cu;\n+                return super.visit(tree, ctx);\n             }\n         });\n     }\n@@ -89,7 +97,7 @@ static class GroupArtifactVersionBecause {\n         String because;\n     }\n \n-    static class RemoveConstraints extends GroovyIsoVisitor<List<GroupArtifactVersionBecause>> {\n+    static class RemoveConstraints extends JavaIsoVisitor<List<GroupArtifactVersionBecause>> {\n \n         @SuppressWarnings({\""DataFlowIssue\"", \""NullableProblems\""})\n         @Override\n@@ -122,7 +130,7 @@ static class RemoveConstraints extends GroovyIsoVisitor<List<GroupArtifactVersio\n                         return statement;\n                     }\n                     AtomicReference<String> because = new AtomicReference<>(null);\n-                    new GroovyIsoVisitor<Integer>() {\n+                    new JavaIsoVisitor<Integer>() {\n                         @Override\n                         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Integer integer) {\n                             J.MethodInvocation m1 = super.visitMethodInvocation(method, integer);\n@@ -149,16 +157,17 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Integ\n \n     @Value\n     @EqualsAndHashCode(callSuper = false)\n-    static class UpdateEachDependency extends GroovyIsoVisitor<ExecutionContext> {\n+    static class UpdateEachDependency extends JavaIsoVisitor<ExecutionContext> {\n         List<GroupArtifactVersionBecause> groupArtifactVersions;\n+        boolean isKotlinDsl;\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n             if (isEachDependency(m)) {\n                 Cursor parent = requireNonNull(getCursor().getParent());\n                 for (GroupArtifactVersionBecause gav : groupArtifactVersions) {\n-                    m = (J.MethodInvocation) new MaybeAddIf(gav).visitNonNull(m, ctx, parent);\n-                    m = (J.MethodInvocation) new UpdateIf(gav).visitNonNull(m, ctx, parent);\n+                    m = (J.MethodInvocation) new MaybeAddIf(gav, isKotlinDsl).visitNonNull(m, ctx, parent);\n+                    m = (J.MethodInvocation) new UpdateIf(gav, isKotlinDsl).visitNonNull(m, ctx, parent);\n                 }\n             }\n             return m;\n@@ -166,10 +175,12 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n     }\n \n     @RequiredArgsConstructor\n-    static class MaybeAddIf extends GroovyIsoVisitor<ExecutionContext> {\n+    static class MaybeAddIf extends JavaIsoVisitor<ExecutionContext> {\n         @NonNull\n         GroupArtifactVersionBecause groupArtifactVersion;\n \n+        final boolean isKotlinDsl;\n+\n         boolean containsAnyIfStatement;\n         boolean containsMatchingIfStatement;\n \n@@ -194,19 +205,33 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                 return m;\n             }\n             String p = ((J.VariableDeclarations) rawParam).getVariables().get(0).getSimpleName();\n-            @SuppressWarnings(\""GroovyEmptyStatementBody\"") @Language(\""groovy\"")\n-            String snippet = \""Object \"" + p + \"" = null\\n\"" +\n-                             \""if (\"" + p + \"".requested.group == '\"" + groupArtifactVersion.getGroupId() + \""' && \"" +\n-                             p + \"".requested.name == '\"" + groupArtifactVersion.getArtifactId() + \""') {\\n}\"";\n-            J.If newIf = GroovyParser.builder().build()\n-                    .parse(ctx, snippet)\n-                    .map(G.CompilationUnit.class::cast)\n-                    .map(cu -> cu.getStatements().get(1))\n-                    .map(J.If.class::cast)\n-                    .findFirst()\n-                    .orElseThrow(() -> new IllegalStateException(\""Unable to produce a new if statement\""));\n+            J.If newIf;\n+            if (!isKotlinDsl) {\n+                @SuppressWarnings(\""GroovyEmptyStatementBody\"") @Language(\""groovy\"")\n+                String snippet = \""Object \"" + p + \"" = null\\n\"" +\n+                                 \""if (\"" + p + \"".requested.group == '\"" + groupArtifactVersion.getGroupId() + \""' && \"" +\n+                                 p + \"".requested.name == '\"" + groupArtifactVersion.getArtifactId() + \""') {\\n}\"";\n+                newIf = GroovyParser.builder().build()\n+                        .parse(ctx, snippet)\n+                        .map(G.CompilationUnit.class::cast)\n+                        .map(cu -> cu.getStatements().get(1))\n+                        .map(J.If.class::cast)\n+                        .findFirst()\n+                        .orElseThrow(() -> new IllegalStateException(\""Unable to produce a new if statement\""));\n+            } else {\n+                String snippet = \""var \"" + p + \"": Any = null\\n\"" +\n+                                 \""if (\"" + p + \"".requested.group == \\\""\"" + groupArtifactVersion.getGroupId() + \""\\\"" && \"" +\n+                                 p + \"".requested.name == \\\""\"" + groupArtifactVersion.getArtifactId() + \""\\\"") {\\n}\"";\n+                newIf = KotlinParser.builder().isKotlinScript(true).build()\n+                        .parse(ctx, snippet)\n+                        .map(K.CompilationUnit.class::cast)\n+                        .map(cu -> (J.Block) cu.getStatements().get(0))\n+                        .map(block -> (J.If) block.getStatements().get(1))\n+                        .findFirst()\n+                        .orElseThrow(() -> new IllegalStateException(\""Unable to produce a new if statement\""));\n+            }\n             if (containsAnyIfStatement) {\n-                m = (J.MethodInvocation) new GroovyIsoVisitor<Integer>() {\n+                m = (J.MethodInvocation) new JavaIsoVisitor<Integer>() {\n                     boolean inserted;\n \n                     @Override\n@@ -253,8 +278,9 @@ public J.If visitIf(J.If iff, ExecutionContext ctx) {\n     }\n \n     @AllArgsConstructor\n-    static class UpdateIf extends GroovyIsoVisitor<ExecutionContext> {\n+    static class UpdateIf extends JavaIsoVisitor<ExecutionContext> {\n         GroupArtifactVersionBecause groupArtifactVersionBecause;\n+        boolean isKotlinDsl;\n \n         @Override\n         public J.If visitIf(J.If iff, ExecutionContext ctx) {\n@@ -262,7 +288,7 @@ public J.If visitIf(J.If iff, ExecutionContext ctx) {\n             if (predicateRelatesToGav(anIf, groupArtifactVersionBecause)) {\n                 // The predicate of the if condition will already contain the relevant variable name\n                 AtomicReference<String> variableName = new AtomicReference<>();\n-                new GroovyIsoVisitor<Integer>() {\n+                new JavaIsoVisitor<Integer>() {\n                     @Override\n                     public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, Integer integer) {\n                         // Comparison will involve \""<variable name>.requested.group\""\n@@ -273,18 +299,36 @@ public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, Integer integer\n                         return fieldAccess;\n                     }\n                 }.visit(anIf.getIfCondition(), 0);\n-                @Language(\""groovy\"")\n-                String snippet = variableName + \"".useVersion('\"" + groupArtifactVersionBecause.getVersion() + \""')\\n\"";\n-                if(groupArtifactVersionBecause.getBecause() != null) {\n-                    snippet += variableName + \"".because('\"" + groupArtifactVersionBecause.getBecause() + \""')\\n\"";\n+                List<Statement> newStatements;\n+                if (!isKotlinDsl) {\n+                    @Language(\""groovy\"")\n+                    String snippet = variableName + \"".useVersion('\"" + groupArtifactVersionBecause.getVersion() + \""')\\n\"";\n+                    if (groupArtifactVersionBecause.getBecause() != null) {\n+                        snippet += variableName + \"".because('\"" + groupArtifactVersionBecause.getBecause() + \""')\\n\"";\n+                    }\n+                    newStatements = GroovyParser.builder()\n+                            .build()\n+                            .parse(ctx, snippet)\n+                            .map(G.CompilationUnit.class::cast)\n+                            .map(G.CompilationUnit::getStatements)\n+                            .findFirst()\n+                            .orElseThrow(() -> new IllegalStateException(\""Unable to produce a new block statement\""));\n+                } else {\n+                    @Language(\""kotlin\"")\n+                    String snippet = variableName + \"".useVersion(\\\""\"" + groupArtifactVersionBecause.getVersion() + \""\\\"")\\n\"";\n+                    if (groupArtifactVersionBecause.getBecause() != null) {\n+                        snippet += variableName + \"".because(\\\""\"" + groupArtifactVersionBecause.getBecause() + \""\\\"")\\n\"";\n+                    }\n+                    newStatements = KotlinParser.builder()\n+                            .isKotlinScript(true)\n+                            .build()\n+                            .parse(ctx, snippet)\n+                            .map(K.CompilationUnit.class::cast)\n+                            .map(cu -> (J.Block) cu.getStatements().get(0))\n+                            .map(J.Block::getStatements)\n+                            .findFirst()\n+                            .orElseThrow(() -> new IllegalStateException(\""Unable to produce a new block statement\""));\n                 }\n-                List<Statement> newStatements = GroovyParser.builder()\n-                        .build()\n-                        .parse(ctx, snippet)\n-                        .map(G.CompilationUnit.class::cast)\n-                        .map(G.CompilationUnit::getStatements)\n-                        .findFirst()\n-                        .orElseThrow(() -> new IllegalStateException(\""Unable to produce a new block statement\""));\n                 J.Block block = (J.Block) anIf.getThenPart();\n                 block = block.withStatements(newStatements);\n                 block = autoFormat(block, ctx, getCursor());\n@@ -294,42 +338,9 @@ public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, Integer integer\n         }\n     }\n \n-    static class MaybeAddEachDependency extends GroovyIsoVisitor<ExecutionContext> {\n+    static class MaybeAddEachDependency extends JavaIsoVisitor<ExecutionContext> {\n         boolean alreadyExists;\n \n-        @Override\n-        public G.CompilationUnit visitCompilationUnit(G.CompilationUnit compilationUnit, ExecutionContext ctx) {\n-            G.CompilationUnit cu = super.visitCompilationUnit(compilationUnit, ctx);\n-            if (alreadyExists) {\n-                return cu;\n-            }\n-            // Prefer to insert before the dependencies block for readability\n-            int insertionIndex = 0;\n-            while (insertionIndex < cu.getStatements().size()) {\n-                Statement s = cu.getStatements().get(insertionIndex);\n-                if (s instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) s)) {\n-                    break;\n-                }\n-                insertionIndex++;\n-            }\n-            J.MethodInvocation m = GradleParser.builder()\n-                    .build()\n-                    .parse(ctx,\n-                           \""\\n\"" +\n-                           \""configurations.all {\\n\"" +\n-                           \""    resolutionStrategy.eachDependency { details ->\\n\"" +\n-                           \""    }\\n\"" +\n-                           \""}\"")\n-                    .map(G.CompilationUnit.class::cast)\n-                    .map(G.CompilationUnit::getStatements)\n-                    .map(it -> it.get(0))\n-                    .map(J.MethodInvocation.class::cast)\n-                    .findFirst()\n-                    .orElseThrow(() -> new IllegalStateException(\""Unable to create a new configurations.all block\""));\n-            cu = cu.withStatements(ListUtils.insert(cu.getStatements(), m, insertionIndex));\n-            return cu;\n-        }\n-\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n@@ -345,6 +356,88 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n             if (alreadyExists) {\n                 return (J) tree;\n             }\n+            if (tree instanceof JavaSourceFile) {\n+                JavaSourceFile sourceFile = (JavaSourceFile) super.visit(tree, ctx);\n+                if (alreadyExists) {\n+                    return sourceFile;\n+                }\n+                // Prefer to insert before the dependencies block for readability\n+                if (sourceFile instanceof G.CompilationUnit) {\n+                    G.CompilationUnit cu = (G.CompilationUnit) sourceFile;\n+                    int insertionIndex = 0;\n+                    while (insertionIndex < cu.getStatements().size()) {\n+                        Statement s = cu.getStatements().get(insertionIndex);\n+                        if (s instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) s)) {\n+                            break;\n+                        }\n+                        insertionIndex++;\n+                    }\n+                    J.MethodInvocation m = GradleParser.builder()\n+                            .build()\n+                            .parse(ctx,\n+                                    \""\\n\"" +\n+                                    \""configurations.all {\\n\"" +\n+                                    \""    resolutionStrategy.eachDependency { details ->\\n\"" +\n+                                    \""    }\\n\"" +\n+                                    \""}\"")\n+                            .map(G.CompilationUnit.class::cast)\n+                            .map(G.CompilationUnit::getStatements)\n+                            .map(it -> it.get(0))\n+                            .map(J.MethodInvocation.class::cast)\n+                            .findFirst()\n+                            .orElseThrow(() -> new IllegalStateException(\""Unable to create a new configurations.all block\""));\n+                    cu = cu.withStatements(ListUtils.insert(cu.getStatements(), m, insertionIndex));\n+                    return cu;\n+                } else {\n+                    K.CompilationUnit cu = (K.CompilationUnit) sourceFile;\n+                    J.Block block = (J.Block) cu.getStatements().get(0);\n+                    int insertionIndex = 0;\n+                    while (insertionIndex < block.getStatements().size()) {\n+                        Statement s = block.getStatements().get(insertionIndex);\n+                        if (s instanceof J.MethodInvocation && ((J.MethodInvocation) s).getSimpleName().equals(\""dependencies\"")) {\n+                            break;\n+                        }\n+                        insertionIndex++;\n+                    }\n+                    J.MethodInvocation m = GradleParser.builder()\n+                            .build()\n+                            .parseInputs(Collections.singletonList(\n+                                    new Parser.Input(\n+                                            Paths.get(\""build.gradle.kts\""),\n+                                            () -> new ByteArrayInputStream(\n+                                                    (\""\\n\"" +\n+                                                     \""configurations.all {\\n\"" +\n+                                                     \""    resolutionStrategy.eachDependency { details ->}\\n\"" +\n+                                                     \""}\"").getBytes(StandardCharsets.UTF_8)))\n+                                    ), null, ctx)\n+                            .map(K.CompilationUnit.class::cast)\n+                            .map(k -> (J.Block) k.getStatements().get(0))\n+                            .map(J.Block::getStatements)\n+                            .map(it -> it.get(0))\n+                            .map(J.MethodInvocation.class::cast)\n+                            .findFirst()\n+                            .map(m2 -> m2.withArguments(ListUtils.mapFirst(m2.getArguments(), arg -> {\n+                                J.Lambda lambda1 = (J.Lambda) arg;\n+                                J.Block block1 = (J.Block) lambda1.getBody();\n+                                return lambda1.withBody(block1.withStatements(ListUtils.mapFirst(block1.getStatements(), arg2 -> {\n+                                    J.MethodInvocation m3 = (J.MethodInvocation) arg2;\n+                                    return m3.withArguments(ListUtils.mapFirst(m3.getArguments(), arg3 -> {\n+                                        J.Lambda lambda2 = (J.Lambda) arg3;\n+                                        return lambda2.withBody(((J.Block) lambda2.getBody()).withEnd(Space.format(\""\\n\"")));\n+                                    }));\n+                                })));\n+                            })))\n+                            .orElseThrow(() -> new IllegalStateException(\""Unable to create a new configurations.all block\""));\n+                    final int finalInsertionIndex = insertionIndex;\n+                    cu = cu.withStatements(ListUtils.mapFirst(cu.getStatements(), arg -> {\n+                        if (arg == block) {\n+                            return block.withStatements(ListUtils.insert(block.getStatements(), m, finalInsertionIndex));\n+                        }\n+                        return arg;\n+                    }));\n+                    return cu;\n+                }\n+            }\n             return super.visit(tree, ctx);\n         }\n     }\n@@ -352,7 +445,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n     private static boolean isInDependenciesBlock(Cursor cursor) {\n         Cursor c = cursor.dropParentUntil(value ->\n                 value == Cursor.ROOT_VALUE ||\n-                (value instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) value)));\n+                (value instanceof J.MethodInvocation && ((J.MethodInvocation) value).getSimpleName().equals(\""dependencies\"")));\n         return c.getValue() instanceof J.MethodInvocation;\n     }\n \n@@ -375,7 +468,7 @@ private static boolean predicateRelatesToGav(J.If iff, GroupArtifactVersionBecau\n         // GroupId and artifactId might be compared in either order or this could be an unrelated comparison\n         AtomicBoolean groupIdCompared = new AtomicBoolean();\n         AtomicBoolean artifactIdCompared = new AtomicBoolean();\n-        new GroovyIsoVisitor<GroupArtifactVersionBecause>() {\n+        new JavaIsoVisitor<GroupArtifactVersionBecause>() {\n             @Override\n             public J.Binary visitBinary(J.Binary binary, GroupArtifactVersionBecause groupArtifactVersion) {\n                 J.Binary b = super.visitBinary(binary, groupArtifactVersion);\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsBuildGradle.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsBuildGradle.java\nindex 6ec3e360e14..ed636a77d3f 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsBuildGradle.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsBuildGradle.java\n@@ -15,6 +15,7 @@\n  */\n package org.openrewrite.gradle;\n \n+import org.jspecify.annotations.NonNull;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.Tree;\n import org.openrewrite.TreeVisitor;\n@@ -23,18 +24,17 @@\n \n import java.nio.file.Path;\n \n-import static java.util.Objects.requireNonNull;\n-\n public class IsBuildGradle<P> extends TreeVisitor<Tree, P> {\n     @Override\n-    public Tree visit(@Nullable Tree tree, P p) {\n+    public @Nullable Tree preVisit(@NonNull Tree tree, P p) {\n+        stopAfterPreVisit();\n         if (tree instanceof JavaSourceFile) {\n-            JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);\n-            if (matches(cu.getSourcePath())) {\n-                return SearchResult.found(cu);\n+            JavaSourceFile sourceFile = (JavaSourceFile) tree;\n+            if (matches(sourceFile.getSourcePath())) {\n+                return SearchResult.found(sourceFile);\n             }\n         }\n-        return super.visit(tree, p);\n+        return tree;\n     }\n \n     public static boolean matches(Path sourcePath) {\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsSettingsGradle.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsSettingsGradle.java\nindex 8bdf7f559c9..77172dac31f 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsSettingsGradle.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsSettingsGradle.java\n@@ -15,24 +15,24 @@\n  */\n package org.openrewrite.gradle;\n \n+import org.jspecify.annotations.NonNull;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.Tree;\n import org.openrewrite.TreeVisitor;\n import org.openrewrite.java.tree.JavaSourceFile;\n import org.openrewrite.marker.SearchResult;\n \n-import static java.util.Objects.requireNonNull;\n-\n public class IsSettingsGradle<P> extends TreeVisitor<Tree, P> {\n     @Override\n-    public Tree visit(@Nullable Tree tree, P p) {\n+    public @Nullable Tree preVisit(@NonNull Tree tree, P p) {\n+        stopAfterPreVisit();\n         if (tree instanceof JavaSourceFile) {\n-            JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);\n+            JavaSourceFile cu = (JavaSourceFile) tree;\n             if (cu.getSourcePath().toString().endsWith(\""settings.gradle\"") ||\n-                cu.getSourcePath().toString().endsWith(\""settings.gradle.kts\"")) {\n+                    cu.getSourcePath().toString().endsWith(\""settings.gradle.kts\"")) {\n                 return SearchResult.found(cu);\n             }\n         }\n-        return super.visit(tree, p);\n+        return tree;\n     }\n }\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/RemoveDependency.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/RemoveDependency.java\nindex b05ac29701b..d9fb94ca5e8 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/RemoveDependency.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/RemoveDependency.java\n@@ -22,11 +22,13 @@\n import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n import org.openrewrite.gradle.trait.GradleDependency;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaSourceFile;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.semver.DependencyMatcher;\n \n import java.util.HashMap;\n@@ -73,7 +75,7 @@ public String getDescription() {\n \n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(new IsBuildGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {\n+        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {\n             final GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher()\n                     .configuration(configuration)\n                     .groupId(groupId)\n@@ -83,19 +85,28 @@ public TreeVisitor<?, ExecutionContext> getVisitor() {\n             GradleProject gradleProject;\n \n             @Override\n-            public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n-                Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);\n-                if (!maybeGp.isPresent()) {\n-                    return cu;\n-                }\n+            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {\n+                return sourceFile instanceof G.CompilationUnit || sourceFile instanceof K.CompilationUnit;\n+            }\n+\n+            @Override\n+            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                if (tree instanceof JavaSourceFile) {\n+                    JavaSourceFile sourceFile = (JavaSourceFile) tree;\n+                    Optional<GradleProject> maybeGp = sourceFile.getMarkers().findFirst(GradleProject.class);\n+                    if (!maybeGp.isPresent()) {\n+                        return sourceFile;\n+                    }\n \n-                gradleProject = maybeGp.get();\n+                    gradleProject = maybeGp.get();\n \n-                G.CompilationUnit g = super.visitCompilationUnit(cu, ctx);\n-                if (g != cu) {\n-                    g = g.withMarkers(g.getMarkers().setByType(updateGradleModel(gradleProject)));\n+                    sourceFile = (JavaSourceFile) super.visit(sourceFile, ctx);\n+                    if (sourceFile != tree) {\n+                        sourceFile = sourceFile.withMarkers(sourceFile.getMarkers().setByType(updateGradleModel(gradleProject)));\n+                    }\n+                    return sourceFile;\n                 }\n-                return g;\n+                return super.visit(tree, ctx);\n             }\n \n             @Override\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java\nindex 30a6684577d..c6a16da0dc6 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java\n@@ -27,15 +27,16 @@\n import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n import org.openrewrite.gradle.trait.GradleDependency;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n-import org.openrewrite.groovy.GroovyVisitor;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n+import org.openrewrite.java.JavaVisitor;\n import org.openrewrite.java.tree.Expression;\n import org.openrewrite.java.tree.J;\n import org.openrewrite.java.tree.JavaSourceFile;\n import org.openrewrite.java.tree.JavaType;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.marker.Markup;\n import org.openrewrite.maven.MavenDownloadingException;\n import org.openrewrite.maven.MavenDownloadingExceptions;\n@@ -143,17 +144,23 @@ public DependencyVersionState getInitialValue(ExecutionContext ctx) {\n     public TreeVisitor<?, ExecutionContext> getScanner(DependencyVersionState acc) {\n \n         //noinspection BooleanMethodIsAlwaysInverted\n-        return new GroovyVisitor<ExecutionContext>() {\n+        return new JavaVisitor<ExecutionContext>() {\n             @Nullable\n             GradleProject gradleProject;\n \n             @Override\n-            public J visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n-                if (!cu.getSourcePath().toString().endsWith(\"".gradle\"")) {\n-                    return cu;\n+            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {\n+                return (sourceFile instanceof G.CompilationUnit && sourceFile.getSourcePath().toString().endsWith(\"".gradle\"")) ||\n+                        (sourceFile instanceof K.CompilationUnit && sourceFile.getSourcePath().toString().endsWith(\"".gradle.kts\""));\n+            }\n+\n+            @Override\n+            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                if (tree instanceof JavaSourceFile) {\n+                    gradleProject = tree.getMarkers().findFirst(GradleProject.class)\n+                            .orElse(null);\n                 }\n-                gradleProject = cu.getMarkers().findFirst(GradleProject.class).orElse(null);\n-                return super.visitCompilationUnit(cu, ctx);\n+                return super.visit(tree, ctx);\n             }\n \n             @Override\n@@ -215,6 +222,71 @@ public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx)\n                             return m;\n                         }\n \n+                        String versionVariableName = declaredVersion;\n+                        GroupArtifact ga = new GroupArtifact(declaredGroupId, declaredArtifactId);\n+                        if (acc.gaToNewVersion.containsKey(ga) || !shouldResolveVersion(declaredGroupId, declaredArtifactId)) {\n+                            return m;\n+                        }\n+                        try {\n+                            String resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)\n+                                    .select(new GroupArtifact(declaredGroupId, declaredArtifactId), m.getSimpleName(), newVersion, versionPattern, ctx);\n+                            acc.versionPropNameToGA.put(versionVariableName, ga);\n+                            // It is fine for this value to be null, record it in the map to avoid future lookups\n+                            //noinspection DataFlowIssue\n+                            acc.gaToNewVersion.put(ga, resolvedVersion);\n+                        } catch (MavenDownloadingException e) {\n+                            acc.gaToNewVersion.put(ga, e);\n+                            return m;\n+                        }\n+                    } else if (m.getArguments().get(0) instanceof J.Assignment) {\n+                        String declaredGroupId = null;\n+                        String declaredArtifactId = null;\n+                        String declaredVersion = null;\n+\n+                        for (Expression e : m.getArguments()) {\n+                            if (!(e instanceof G.MapEntry)) {\n+                                continue;\n+                            }\n+                            J.Assignment assignment = (J.Assignment) e;\n+                            if (!(assignment.getVariable() instanceof J.Identifier)) {\n+                                continue;\n+                            }\n+                            J.Identifier variable = (J.Identifier) assignment.getVariable();\n+                            String valueValue = null;\n+                            if (assignment.getAssignment() instanceof J.Literal) {\n+                                J.Literal value = (J.Literal) assignment.getAssignment();\n+                                if (value.getValue() instanceof String) {\n+                                    valueValue = (String) value.getValue();\n+                                }\n+                            } else if (assignment.getAssignment() instanceof J.Identifier) {\n+                                J.Identifier value = (J.Identifier) assignment.getAssignment();\n+                                valueValue = value.getSimpleName();\n+                            } else if (assignment.getAssignment() instanceof K.StringTemplate) {\n+                                K.StringTemplate value = (K.StringTemplate) assignment.getAssignment();\n+                                List<J> strings = value.getStrings();\n+                                if (!strings.isEmpty() && strings.get(0) instanceof K.StringTemplate.Expression) {\n+                                    K.StringTemplate.Expression versionTemplateValue = (K.StringTemplate.Expression) strings.get(0);\n+                                    if (versionTemplateValue.getTree() instanceof J.Identifier) {\n+                                        valueValue = ((J.Identifier) versionTemplateValue.getTree()).getSimpleName();\n+                                    }\n+                                }\n+                            }\n+                            switch (variable.getSimpleName()) {\n+                                case \""group\"":\n+                                    declaredGroupId = valueValue;\n+                                    break;\n+                                case \""name\"":\n+                                    declaredArtifactId = valueValue;\n+                                    break;\n+                                case \""version\"":\n+                                    declaredVersion = valueValue;\n+                                    break;\n+                            }\n+                        }\n+                        if (declaredGroupId == null || declaredArtifactId == null || declaredVersion == null) {\n+                            return m;\n+                        }\n+\n                         String versionVariableName = declaredVersion;\n                         GroupArtifact ga = new GroupArtifact(declaredGroupId, declaredArtifactId);\n                         if (acc.gaToNewVersion.containsKey(ga) || !shouldResolveVersion(declaredGroupId, declaredArtifactId)) {\n@@ -254,6 +326,19 @@ public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx)\n                                 }\n                                 dep = DependencyStringNotationConverter.parse((String) groupArtifact.getValue());\n                                 versionVariableName = ((J.Identifier) versionValue.getTree()).getSimpleName();\n+                            } else if (depArg instanceof K.StringTemplate) {\n+                                K.StringTemplate template = (K.StringTemplate) depArg;\n+                                List<J> strings = template.getStrings();\n+                                if (strings.size() != 2 || !(strings.get(0) instanceof J.Literal) || !(strings.get(1) instanceof K.StringTemplate.Expression)) {\n+                                    continue;\n+                                }\n+                                J.Literal groupArtifact = (J.Literal) strings.get(0);\n+                                K.StringTemplate.Expression versionValue = (K.StringTemplate.Expression) strings.get(1);\n+                                if (!(versionValue.getTree() instanceof J.Identifier) || !(groupArtifact.getValue() instanceof String)) {\n+                                    continue;\n+                                }\n+                                dep = DependencyStringNotationConverter.parse((String) groupArtifact.getValue());\n+                                versionVariableName = ((J.Identifier) versionValue.getTree()).getSimpleName();\n                             }\n                             if (dep == null || versionVariableName == null) {\n                                 continue;\n@@ -293,12 +378,12 @@ private boolean shouldResolveVersion(String declaredGroupId, String declaredArti\n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor(DependencyVersionState acc) {\n         return new TreeVisitor<Tree, ExecutionContext>() {\n-            private final UpdateGroovy updateGroovy = new UpdateGroovy(acc);\n+            private final UpdateGradle updateGradle = new UpdateGradle(acc);\n             private final UpdateProperties updateProperties = new UpdateProperties(acc);\n \n             @Override\n             public boolean isAcceptable(SourceFile sf, ExecutionContext ctx) {\n-                return updateProperties.isAcceptable(sf, ctx) || updateGroovy.isAcceptable(sf, ctx);\n+                return updateProperties.isAcceptable(sf, ctx) || updateGradle.isAcceptable(sf, ctx);\n             }\n \n             @Override\n@@ -307,8 +392,8 @@ public boolean isAcceptable(SourceFile sf, ExecutionContext ctx) {\n                     SourceFile sf = (SourceFile) t;\n                     if (updateProperties.isAcceptable(sf, ctx)) {\n                         t = updateProperties.visitNonNull(t, ctx);\n-                    } else if (updateGroovy.isAcceptable(sf, ctx)) {\n-                        t = updateGroovy.visitNonNull(t, ctx);\n+                    } else if (updateGradle.isAcceptable(sf, ctx)) {\n+                        t = updateGradle.visitNonNull(t, ctx);\n                     }\n                 }\n                 return t;\n@@ -352,7 +437,7 @@ public org.openrewrite.properties.tree.Properties visitEntry(Properties.Entry en\n     }\n \n     @RequiredArgsConstructor\n-    private class UpdateGroovy extends GroovyVisitor<ExecutionContext> {\n+    private class UpdateGradle extends JavaVisitor<ExecutionContext> {\n         final DependencyVersionState acc;\n \n         @Nullable\n@@ -361,10 +446,20 @@ private class UpdateGroovy extends GroovyVisitor<ExecutionContext> {\n         final DependencyMatcher dependencyMatcher = new DependencyMatcher(groupId, artifactId, null);\n \n         @Override\n-        public J visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n-            gradleProject = cu.getMarkers().findFirst(GradleProject.class)\n-                    .orElse(null);\n-            return super.visitCompilationUnit(cu, ctx);\n+        public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {\n+            return (sourceFile instanceof G.CompilationUnit && sourceFile.getSourcePath().toString().endsWith(\"".gradle\"")) ||\n+                    (sourceFile instanceof K.CompilationUnit && sourceFile.getSourcePath().toString().endsWith(\"".gradle.kts\""));\n+        }\n+\n+        @Override\n+        public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+            if (tree instanceof JavaSourceFile) {\n+                JavaSourceFile sourceFile = (JavaSourceFile) tree;\n+                gradleProject = sourceFile.getMarkers().findFirst(GradleProject.class)\n+                        .orElse(null);\n+                return super.visit(sourceFile, ctx);\n+            }\n+            return super.visit(tree, ctx);\n         }\n \n         @Override\n@@ -395,7 +490,7 @@ public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx)\n \n             if (gradleDependencyMatcher.get(getCursor()).isPresent()) {\n                 List<Expression> depArgs = m.getArguments();\n-                if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry) {\n+                if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry || depArgs.get(0) instanceof J.Assignment || depArgs.get(0) instanceof K.StringTemplate) {\n                     m = updateDependency(m, ctx);\n                 } else if (depArgs.get(0) instanceof J.MethodInvocation &&\n                            (((J.MethodInvocation) depArgs.get(0)).getSimpleName().equals(\""platform\"") ||\n@@ -428,6 +523,32 @@ private J.MethodInvocation updateDependency(J.MethodInvocation method, Execution\n                             return arg;\n                         }\n \n+                        String versionVariableName = ((J.Identifier) versionValue.getTree()).getSimpleName();\n+                        getCursor().dropParentUntil(p -> p instanceof SourceFile)\n+                                .computeMessageIfAbsent(VERSION_VARIABLE_KEY, v -> new HashMap<String, Map<GroupArtifact, Set<String>>>())\n+                                .computeIfAbsent(versionVariableName, it -> new HashMap<>())\n+                                .computeIfAbsent(new GroupArtifact(dep.getGroupId(), dep.getArtifactId()), it -> new HashSet<>())\n+                                .add(method.getSimpleName());\n+                    }\n+                } else if (arg instanceof K.StringTemplate) {\n+                    K.StringTemplate template = (K.StringTemplate) arg;\n+                    List<J> strings = template.getStrings();\n+                    if (strings.size() != 2 || !(strings.get(0) instanceof J.Literal) || !(strings.get(1) instanceof K.StringTemplate.Expression)) {\n+                        return arg;\n+                    }\n+                    J.Literal groupArtifact = (J.Literal) strings.get(0);\n+                    K.StringTemplate.Expression versionValue = (K.StringTemplate.Expression) strings.get(1);\n+                    if (!(versionValue.getTree() instanceof J.Identifier) || !(groupArtifact.getValue() instanceof String)) {\n+                        return arg;\n+                    }\n+                    Dependency dep = DependencyStringNotationConverter.parse((String) groupArtifact.getValue());\n+                    if (dep != null && dependencyMatcher.matches(dep.getGroupId(), dep.getArtifactId())) {\n+                        Object scanResult = acc.gaToNewVersion.get(new GroupArtifact(dep.getGroupId(), dep.getArtifactId()));\n+                        if (scanResult instanceof Exception) {\n+                            getCursor().putMessage(UPDATE_VERSION_ERROR_KEY, scanResult);\n+                            return arg;\n+                        }\n+\n                         String versionVariableName = ((J.Identifier) versionValue.getTree()).getSimpleName();\n                         getCursor().dropParentUntil(p -> p instanceof SourceFile)\n                                 .computeMessageIfAbsent(VERSION_VARIABLE_KEY, v -> new HashMap<String, Map<GroupArtifact, Set<String>>>())\n@@ -484,61 +605,119 @@ private J.MethodInvocation updateDependency(J.MethodInvocation method, Execution\n                 m = Markup.warn(m, err);\n             }\n             List<Expression> depArgs = m.getArguments();\n-            if (depArgs.size() >= 3 && depArgs.get(0) instanceof G.MapEntry &&\n-                depArgs.get(1) instanceof G.MapEntry &&\n-                depArgs.get(2) instanceof G.MapEntry) {\n-                Expression groupValue = ((G.MapEntry) depArgs.get(0)).getValue();\n-                Expression artifactValue = ((G.MapEntry) depArgs.get(1)).getValue();\n-                if (!(groupValue instanceof J.Literal) || !(artifactValue instanceof J.Literal)) {\n-                    return m;\n-                }\n-                J.Literal groupLiteral = (J.Literal) groupValue;\n-                J.Literal artifactLiteral = (J.Literal) artifactValue;\n-                if (groupLiteral.getValue() == null || artifactLiteral.getValue() == null || !dependencyMatcher.matches((String) groupLiteral.getValue(), (String) artifactLiteral.getValue())) {\n-                    return m;\n-                }\n-                Object scanResult = acc.gaToNewVersion.get(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()));\n-                if (scanResult instanceof Exception) {\n-                    return Markup.warn(m, (Exception) scanResult);\n-                }\n-                G.MapEntry versionEntry = (G.MapEntry) depArgs.get(2);\n-                Expression versionExp = versionEntry.getValue();\n-                if (versionExp instanceof J.Literal && ((J.Literal) versionExp).getValue() instanceof String) {\n-                    J.Literal versionLiteral = (J.Literal) versionExp;\n-                    String version = (String) versionLiteral.getValue();\n-                    if (version.startsWith(\""$\"")) {\n+            if (depArgs.size() >= 3) {\n+                if (depArgs.get(0) instanceof G.MapEntry &&\n+                        depArgs.get(1) instanceof G.MapEntry &&\n+                        depArgs.get(2) instanceof G.MapEntry) {\n+                    Expression groupValue = ((G.MapEntry) depArgs.get(0)).getValue();\n+                    Expression artifactValue = ((G.MapEntry) depArgs.get(1)).getValue();\n+                    if (!(groupValue instanceof J.Literal) || !(artifactValue instanceof J.Literal)) {\n+                        return m;\n+                    }\n+                    J.Literal groupLiteral = (J.Literal) groupValue;\n+                    J.Literal artifactLiteral = (J.Literal) artifactValue;\n+                    if (groupLiteral.getValue() == null || artifactLiteral.getValue() == null || !dependencyMatcher.matches((String) groupLiteral.getValue(), (String) artifactLiteral.getValue())) {\n                         return m;\n                     }\n-                    String selectedVersion;\n-                    try {\n-                        GroupArtifactVersion gav = new GroupArtifactVersion((String) groupLiteral.getValue(), (String) artifactLiteral.getValue(), version);\n-                        selectedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)\n-                                .select(gav, m.getSimpleName(), newVersion, versionPattern, ctx);\n-                    } catch (MavenDownloadingException e) {\n-                        return e.warn(m);\n+                    Object scanResult = acc.gaToNewVersion.get(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()));\n+                    if (scanResult instanceof Exception) {\n+                        return Markup.warn(m, (Exception) scanResult);\n+                    }\n+                    G.MapEntry versionEntry = (G.MapEntry) depArgs.get(2);\n+                    Expression versionExp = versionEntry.getValue();\n+                    if (versionExp instanceof J.Literal && ((J.Literal) versionExp).getValue() instanceof String) {\n+                        J.Literal versionLiteral = (J.Literal) versionExp;\n+                        String version = (String) versionLiteral.getValue();\n+                        if (version.startsWith(\""$\"")) {\n+                            return m;\n+                        }\n+                        String selectedVersion;\n+                        try {\n+                            GroupArtifactVersion gav = new GroupArtifactVersion((String) groupLiteral.getValue(), (String) artifactLiteral.getValue(), version);\n+                            selectedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)\n+                                    .select(gav, m.getSimpleName(), newVersion, versionPattern, ctx);\n+                        } catch (MavenDownloadingException e) {\n+                            return e.warn(m);\n+                        }\n+                        if (selectedVersion == null || version.equals(selectedVersion)) {\n+                            return m;\n+                        }\n+                        List<Expression> newArgs = new ArrayList<>(3);\n+                        newArgs.add(depArgs.get(0));\n+                        newArgs.add(depArgs.get(1));\n+                        newArgs.add(versionEntry.withValue(\n+                                versionLiteral\n+                                        .withValueSource(versionLiteral.getValueSource() == null ?\n+                                                selectedVersion :\n+                                                versionLiteral.getValueSource().replace(version, selectedVersion))\n+                                        .withValue(selectedVersion)));\n+                        newArgs.addAll(depArgs.subList(3, depArgs.size()));\n+\n+                        return m.withArguments(newArgs);\n+                    } else if (versionExp instanceof J.Identifier) {\n+                        String versionVariableName = ((J.Identifier) versionExp).getSimpleName();\n+                        getCursor().dropParentUntil(p -> p instanceof SourceFile)\n+                                .computeMessageIfAbsent(VERSION_VARIABLE_KEY, v -> new HashMap<String, Map<GroupArtifact, Set<String>>>())\n+                                .computeIfAbsent(versionVariableName, it -> new HashMap<>())\n+                                .computeIfAbsent(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()), it -> new HashSet<>())\n+                                .add(m.getSimpleName());\n                     }\n-                    if (selectedVersion == null || version.equals(selectedVersion)) {\n+                } else if (depArgs.get(0) instanceof J.Assignment &&\n+                        depArgs.get(1) instanceof J.Assignment &&\n+                        depArgs.get(2) instanceof J.Assignment) {\n+                    Expression groupValue = ((J.Assignment) depArgs.get(0)).getAssignment();\n+                    Expression artifactValue = ((J.Assignment) depArgs.get(1)).getAssignment();\n+                    if (!(groupValue instanceof J.Literal) || !(artifactValue instanceof J.Literal)) {\n                         return m;\n                     }\n-                    List<Expression> newArgs = new ArrayList<>(3);\n-                    newArgs.add(depArgs.get(0));\n-                    newArgs.add(depArgs.get(1));\n-                    newArgs.add(versionEntry.withValue(\n-                            versionLiteral\n-                                    .withValueSource(versionLiteral.getValueSource() == null ?\n-                                            selectedVersion :\n-                                            versionLiteral.getValueSource().replace(version, selectedVersion))\n-                                    .withValue(selectedVersion)));\n-                    newArgs.addAll(depArgs.subList(3, depArgs.size()));\n-\n-                    return m.withArguments(newArgs);\n-                } else if (versionExp instanceof J.Identifier) {\n-                    String versionVariableName = ((J.Identifier) versionExp).getSimpleName();\n-                    getCursor().dropParentUntil(p -> p instanceof SourceFile)\n-                            .computeMessageIfAbsent(VERSION_VARIABLE_KEY, v -> new HashMap<String, Map<GroupArtifact, Set<String>>>())\n-                            .computeIfAbsent(versionVariableName, it -> new HashMap<>())\n-                            .computeIfAbsent(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()), it -> new HashSet<>())\n-                            .add(m.getSimpleName());\n+                    J.Literal groupLiteral = (J.Literal) groupValue;\n+                    J.Literal artifactLiteral = (J.Literal) artifactValue;\n+                    if (groupLiteral.getValue() == null || artifactLiteral.getValue() == null || !dependencyMatcher.matches((String) groupLiteral.getValue(), (String) artifactLiteral.getValue())) {\n+                        return m;\n+                    }\n+                    Object scanResult = acc.gaToNewVersion.get(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()));\n+                    if (scanResult instanceof Exception) {\n+                        return Markup.warn(m, (Exception) scanResult);\n+                    }\n+                    K.Assignment versionEntry = (J.Assignment) depArgs.get(2);\n+                    Expression versionExp = versionEntry.getAssignment();\n+                    if (versionExp instanceof J.Literal && ((J.Literal) versionExp).getValue() instanceof String) {\n+                        J.Literal versionLiteral = (J.Literal) versionExp;\n+                        String version = (String) versionLiteral.getValue();\n+                        if (version.startsWith(\""$\"")) {\n+                            return m;\n+                        }\n+                        String selectedVersion;\n+                        try {\n+                            GroupArtifactVersion gav = new GroupArtifactVersion((String) groupLiteral.getValue(), (String) artifactLiteral.getValue(), version);\n+                            selectedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)\n+                                    .select(gav, m.getSimpleName(), newVersion, versionPattern, ctx);\n+                        } catch (MavenDownloadingException e) {\n+                            return e.warn(m);\n+                        }\n+                        if (selectedVersion == null || version.equals(selectedVersion)) {\n+                            return m;\n+                        }\n+                        List<Expression> newArgs = new ArrayList<>(3);\n+                        newArgs.add(depArgs.get(0));\n+                        newArgs.add(depArgs.get(1));\n+                        newArgs.add(versionEntry.withAssignment(\n+                                versionLiteral\n+                                        .withValueSource(versionLiteral.getValueSource() == null ?\n+                                                selectedVersion :\n+                                                versionLiteral.getValueSource().replace(version, selectedVersion))\n+                                        .withValue(selectedVersion)));\n+                        newArgs.addAll(depArgs.subList(3, depArgs.size()));\n+\n+                        return m.withArguments(newArgs);\n+                    } else if (versionExp instanceof J.Identifier) {\n+                        String versionVariableName = ((J.Identifier) versionExp).getSimpleName();\n+                        getCursor().dropParentUntil(p -> p instanceof SourceFile)\n+                                .computeMessageIfAbsent(VERSION_VARIABLE_KEY, v -> new HashMap<String, Map<GroupArtifact, Set<String>>>())\n+                                .computeIfAbsent(versionVariableName, it -> new HashMap<>())\n+                                .computeIfAbsent(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()), it -> new HashSet<>())\n+                                .add(m.getSimpleName());\n+                    }\n                 }\n             }\n \n@@ -547,7 +726,7 @@ private J.MethodInvocation updateDependency(J.MethodInvocation method, Execution\n     }\n \n     @AllArgsConstructor\n-    private class UpdateVariable extends GroovyIsoVisitor<ExecutionContext> {\n+    private class UpdateVariable extends JavaIsoVisitor<ExecutionContext> {\n         private final Map<String, Map<GroupArtifact, Set<String>>> versionVariableNames;\n \n         @Nullable\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\nindex 1745f52c328..7b2047e11c2 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\n@@ -20,22 +20,26 @@\n import lombok.Value;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n+import org.openrewrite.gradle.internal.ChangeStringLiteral;\n+import org.openrewrite.gradle.internal.DependencyStringNotationConverter;\n import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n import org.openrewrite.gradle.search.FindGradleProject;\n import org.openrewrite.groovy.GroovyIsoVisitor;\n-import org.openrewrite.groovy.GroovyVisitor;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n+import org.openrewrite.java.JavaVisitor;\n import org.openrewrite.java.MethodMatcher;\n import org.openrewrite.java.format.BlankLinesVisitor;\n import org.openrewrite.java.search.FindMethods;\n import org.openrewrite.java.search.UsesMethod;\n-import org.openrewrite.java.tree.Expression;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.Statement;\n+import org.openrewrite.java.tree.*;\n+import org.openrewrite.kotlin.KotlinIsoVisitor;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.marker.Markers;\n import org.openrewrite.marker.Markup;\n+import org.openrewrite.marker.SearchResult;\n import org.openrewrite.maven.MavenDownloadingException;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n import org.openrewrite.maven.tree.GroupArtifact;\n@@ -44,9 +48,11 @@\n import org.openrewrite.semver.DependencyMatcher;\n import org.openrewrite.semver.Semver;\n \n+import java.io.ByteArrayInputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n import java.util.*;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicReference;\n import java.util.stream.Collectors;\n \n import static java.util.Collections.singletonMap;\n@@ -116,15 +122,19 @@ public class UpgradeTransitiveDependencyVersion extends Recipe {\n      * it is much faster to produce these LST elements only once then manipulate their arguments.\n      * This largely mimics how caching works in JavaTemplate. If we create a Gradle/GroovyTemplate this could be refactored.\n      */\n-    private static Map<String, Optional<G.CompilationUnit>> snippetCache(ExecutionContext ctx) {\n+    private static Map<String, Optional<JavaSourceFile>> snippetCache(ExecutionContext ctx) {\n         //noinspection unchecked\n-        return (Map<String, Optional<G.CompilationUnit>>) ctx.getMessages()\n+        return (Map<String, Optional<JavaSourceFile>>) ctx.getMessages()\n                 .computeIfAbsent(UpgradeTransitiveDependencyVersion.class.getName() + \"".snippetCache\"", k -> new HashMap<String, Optional<G.CompilationUnit>>());\n     }\n \n-    private static Optional<G.CompilationUnit> parseAsGradle(String snippet, ExecutionContext ctx) {\n+    private static Optional<JavaSourceFile> parseAsGradle(String snippet, boolean isKotlinDsl, ExecutionContext ctx) {\n         return snippetCache(ctx)\n-                .computeIfAbsent(snippet, s -> GradleParser.builder().build().parse(ctx, snippet)\n+                .computeIfAbsent(snippet, s -> GradleParser.builder().build().parseInputs(Collections.singletonList(\n+                        new Parser.Input(\n+                                Paths.get(\""build.gradle\"" + (isKotlinDsl ? \"".kts\"" : \""\"")),\n+                                () -> new ByteArrayInputStream(snippet.getBytes(StandardCharsets.UTF_8))\n+                        )), null, ctx)\n                         .findFirst()\n                         .map(maybeCu -> {\n                             maybeCu.getMarkers()\n@@ -132,7 +142,7 @@ private static Optional<G.CompilationUnit> parseAsGradle(String snippet, Executi\n                                     .ifPresent(per -> {\n                                         throw new IllegalStateException(\""Encountered exception \"" + per.getExceptionType() + \"" with message \"" + per.getMessage() + \"" on snippet:\\n\"" + snippet);\n                                     });\n-                            return (G.CompilationUnit) maybeCu;\n+                            return (JavaSourceFile) maybeCu;\n                         }));\n     }\n \n@@ -162,100 +172,123 @@ public Validated<Object> validate() {\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n         DependencyMatcher dependencyMatcher = new DependencyMatcher(groupId, artifactId, null);\n \n-        return Preconditions.check(new FindGradleProject(FindGradleProject.SearchCriteria.Marker), new GroovyVisitor<ExecutionContext>() {\n+        return Preconditions.check(new FindGradleProject(FindGradleProject.SearchCriteria.Marker), new JavaVisitor<ExecutionContext>() {\n             @SuppressWarnings(\""NotNullFieldNotInitialized\"")\n             GradleProject gradleProject;\n \n             @Override\n-            public J visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n-                gradleProject = cu.getMarkers().findFirst(GradleProject.class)\n-                        .orElseThrow(() -> new IllegalStateException(\""Unable to find GradleProject marker.\""));\n-\n-                Map<GroupArtifact, Map<GradleDependencyConfiguration, String>> toUpdate = new LinkedHashMap<>();\n-\n-                DependencyVersionSelector versionSelector = new DependencyVersionSelector(metadataFailures, gradleProject, null);\n-                for (GradleDependencyConfiguration configuration : gradleProject.getConfigurations()) {\n-                    for (ResolvedDependency resolved : configuration.getResolved()) {\n-                        if (resolved.getDepth() > 0 && dependencyMatcher.matches(resolved.getGroupId(),\n-                                resolved.getArtifactId(), resolved.getVersion())) {\n-                            try {\n-                                String selected = versionSelector.select(resolved.getGav(), configuration.getName(),\n-                                        version, versionPattern, ctx);\n-                                if (selected == null || resolved.getVersion().equals(selected)) {\n-                                    continue;\n-                                }\n+            public J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                if (tree instanceof JavaSourceFile) {\n+                    JavaSourceFile cu = (JavaSourceFile) tree;\n+                    gradleProject = cu.getMarkers().findFirst(GradleProject.class)\n+                            .orElseThrow(() -> new IllegalStateException(\""Unable to find GradleProject marker.\""));\n+\n+                    Map<GroupArtifact, Map<GradleDependencyConfiguration, String>> toUpdate = new LinkedHashMap<>();\n+\n+                    DependencyVersionSelector versionSelector = new DependencyVersionSelector(metadataFailures, gradleProject, null);\n+                    for (GradleDependencyConfiguration configuration : gradleProject.getConfigurations()) {\n+                        for (ResolvedDependency resolved : configuration.getResolved()) {\n+                            if (resolved.getDepth() > 0 && dependencyMatcher.matches(resolved.getGroupId(),\n+                                    resolved.getArtifactId(), resolved.getVersion())) {\n+                                try {\n+                                    String selected = versionSelector.select(resolved.getGav(), configuration.getName(),\n+                                            version, versionPattern, ctx);\n+                                    if (selected == null || resolved.getVersion().equals(selected)) {\n+                                        continue;\n+                                    }\n \n-                                GradleDependencyConfiguration constraintConfig = constraintConfiguration(configuration);\n-                                if (constraintConfig == null) {\n-                                    continue;\n-                                }\n+                                    GradleDependencyConfiguration constraintConfig = constraintConfiguration(configuration);\n+                                    if (constraintConfig == null) {\n+                                        continue;\n+                                    }\n \n-                                toUpdate.merge(\n-                                        new GroupArtifact(resolved.getGroupId(), resolved.getArtifactId()),\n-                                        singletonMap(constraintConfig, selected),\n-                                        (existing, update) -> {\n-                                            Map<GradleDependencyConfiguration, String> all = new LinkedHashMap<>(existing);\n-                                            all.putAll(update);\n-                                            all.keySet().removeIf(c -> {\n-                                                if (c == null) {\n-                                                    return true; // TODO ?? how does this happen\n-                                                }\n-\n-                                                for (GradleDependencyConfiguration config : all.keySet()) {\n-                                                    if (c.allExtendsFrom().contains(config)) {\n-                                                        return true;\n+                                    toUpdate.merge(\n+                                            new GroupArtifact(resolved.getGroupId(), resolved.getArtifactId()),\n+                                            singletonMap(constraintConfig, selected),\n+                                            (existing, update) -> {\n+                                                Map<GradleDependencyConfiguration, String> all = new LinkedHashMap<>(existing);\n+                                                all.putAll(update);\n+                                                all.keySet().removeIf(c -> {\n+                                                    if (c == null) {\n+                                                        return true; // TODO ?? how does this happen\n                                                     }\n \n-                                                    // TODO there has to be a better way!\n-                                                    if (c.getName().equals(\""runtimeOnly\"")) {\n-                                                        if (config.getName().equals(\""implementation\"")) {\n+                                                    for (GradleDependencyConfiguration config : all.keySet()) {\n+                                                        if (c.allExtendsFrom().contains(config)) {\n                                                             return true;\n                                                         }\n-                                                    }\n-                                                    if (c.getName().equals(\""testRuntimeOnly\"")) {\n-                                                        if (config.getName().equals(\""testImplementation\"") ||\n-                                                            config.getName().equals(\""implementation\"")) {\n-                                                            return true;\n+\n+                                                        // TODO there has to be a better way!\n+                                                        if (c.getName().equals(\""runtimeOnly\"")) {\n+                                                            if (config.getName().equals(\""implementation\"")) {\n+                                                                return true;\n+                                                            }\n+                                                        }\n+                                                        if (c.getName().equals(\""testRuntimeOnly\"")) {\n+                                                            if (config.getName().equals(\""testImplementation\"") ||\n+                                                                    config.getName().equals(\""implementation\"")) {\n+                                                                return true;\n+                                                            }\n                                                         }\n                                                     }\n-                                                }\n-                                                return false;\n-                                            });\n-                                            return all;\n-                                        }\n-                                );\n-                            } catch (MavenDownloadingException e) {\n-                                return Markup.warn(cu, e);\n+                                                    return false;\n+                                                });\n+                                                return all;\n+                                            }\n+                                    );\n+                                } catch (MavenDownloadingException e) {\n+                                    return Markup.warn(cu, e);\n+                                }\n                             }\n                         }\n                     }\n-                }\n \n-                if (!toUpdate.isEmpty()) {\n-                    cu = (G.CompilationUnit) Preconditions.check(not(new UsesMethod<>(CONSTRAINTS_MATCHER)),\n-                            new AddConstraintsBlock()).visitNonNull(cu, ctx);\n+                    if (!toUpdate.isEmpty()) {\n+                        cu = (JavaSourceFile) Preconditions.check(\n+                                not(new JavaIsoVisitor<ExecutionContext>() {\n+                                    @Override\n+                                    public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                                        if (tree instanceof G.CompilationUnit) {\n+                                            return new UsesMethod<>(CONSTRAINTS_MATCHER).visit(tree, ctx);\n+                                        } else {\n+                                            // K is not type attributed, so do things more manually\n+                                            return super.visit(tree, ctx);\n+                                        }\n+                                    }\n \n-                    for (Map.Entry<GroupArtifact, Map<GradleDependencyConfiguration, String>> update : toUpdate.entrySet()) {\n-                        Map<GradleDependencyConfiguration, String> configs = update.getValue();\n-                        for (Map.Entry<GradleDependencyConfiguration, String> config : configs.entrySet()) {\n-                            cu = (G.CompilationUnit) new AddConstraint(config.getKey().getName(), new GroupArtifactVersion(update.getKey().getGroupId(),\n-                                    update.getKey().getArtifactId(), config.getValue()), because).visitNonNull(cu, ctx);\n+                                    @Override\n+                                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n+                                        J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n+                                        if (m.getSimpleName().equals(\""constraints\"") && withinBlock(getCursor(), \""dependencies\"")) {\n+                                            return SearchResult.found(m);\n+                                        }\n+                                        return m;\n+                                    }\n+                                }),\n+                                new AddConstraintsBlock(cu instanceof K.CompilationUnit)\n+                        ).visitNonNull(cu, ctx);\n+\n+                        for (Map.Entry<GroupArtifact, Map<GradleDependencyConfiguration, String>> update : toUpdate.entrySet()) {\n+                            Map<GradleDependencyConfiguration, String> configs = update.getValue();\n+                            for (Map.Entry<GradleDependencyConfiguration, String> config : configs.entrySet()) {\n+                                cu = (JavaSourceFile) new AddConstraint(cu instanceof K.CompilationUnit, config.getKey().getName(), new GroupArtifactVersion(update.getKey().getGroupId(),\n+                                        update.getKey().getArtifactId(), config.getValue()), because).visitNonNull(cu, ctx);\n+                            }\n                         }\n-                    }\n \n-                    // Update dependency model so chained recipes will have correct information on what dependencies are present\n-                    cu = cu.withMarkers(cu.getMarkers()\n-                            .removeByType(GradleProject.class)\n-                            .add(updatedModel(gradleProject, toUpdate, ctx)));\n+                        // Update dependency model so chained recipes will have correct information on what dependencies are present\n+                        cu = cu.withMarkers(cu.getMarkers().setByType(updatedModel(gradleProject, toUpdate, ctx)));\n \n-                    // Spring dependency management plugin stomps on constraints. Use an alternative mechanism it does not override\n-                    if (gradleProject.getPlugins().stream()\n-                            .anyMatch(plugin -> \""io.spring.dependency-management\"".equals(plugin.getId()))) {\n-                        cu = (G.CompilationUnit) new DependencyConstraintToRule().getVisitor().visitNonNull(cu, ctx);\n+                        // Spring dependency management plugin stomps on constraints. Use an alternative mechanism it does not override\n+                        if (gradleProject.getPlugins().stream()\n+                                .anyMatch(plugin -> \""io.spring.dependency-management\"".equals(plugin.getId()))) {\n+                            cu = (JavaSourceFile) new DependencyConstraintToRule().getVisitor().visitNonNull(cu, ctx);\n+                        }\n                     }\n-                }\n \n-                return cu;\n+                    return cu;\n+                }\n+                return super.visit(tree, ctx);\n             }\n \n             private GradleProject updatedModel(GradleProject gradleProject, Map<GroupArtifact, Map<GradleDependencyConfiguration, String>> toUpdate, ExecutionContext ctx) {\n@@ -345,19 +378,23 @@ private GradleProject updatedModel(GradleProject gradleProject, Map<GroupArtifac\n         });\n     }\n \n-    private static class AddConstraintsBlock extends GroovyIsoVisitor<ExecutionContext> {\n+    @Value\n+    @EqualsAndHashCode(callSuper = false)\n+    private static class AddConstraintsBlock extends JavaIsoVisitor<ExecutionContext> {\n+        boolean isKotlinDsl;\n+\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n \n             if (DEPENDENCIES_DSL_MATCHER.matches(method)) {\n-                G.CompilationUnit withConstraints = parseAsGradle(\n+                G.CompilationUnit withConstraints = (G.CompilationUnit) parseAsGradle(\n                         //language=groovy\n                         \""plugins { id 'java' }\\n\"" +\n                         \""dependencies {\\n\"" +\n                         \""    constraints {\\n\"" +\n                         \""    }\\n\"" +\n-                        \""}\\n\"", ctx)\n+                        \""}\\n\"", false, ctx)\n                         .orElseThrow(() -> new IllegalStateException(\""Unable to parse constraints block\""));\n \n                 Statement constraints = FindMethods.find(withConstraints, \""org.gradle.api.artifacts.dsl.DependencyHandler constraints(..)\"", true)\n@@ -384,6 +421,49 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                     return dependencies.withBody(body.withStatements(\n                             ListUtils.concat(constraints, statements)));\n                 })), constraints, ctx, getCursor().getParentOrThrow());\n+            } else if (isKotlinDsl && m.getSimpleName().equals(\""dependencies\"") && getCursor().getParent().firstEnclosing(J.MethodInvocation.class) == null) {\n+                K.CompilationUnit withConstraints = (K.CompilationUnit) parseAsGradle(\n+                        //language=kotlin\n+                        \""plugins { id(\\\""java\\\"") }\\n\"" +\n+                        \""dependencies {\\n\"" +\n+                        \""    constraints {}\\n\"" +\n+                        \""}\\n\"", true, ctx)\n+                        .orElseThrow(() -> new IllegalStateException(\""Unable to parse constraints block\""));\n+\n+                J.MethodInvocation constraints = withConstraints.getStatements()\n+                        .stream()\n+                        .map(J.Block.class::cast)\n+                        .flatMap(block -> block.getStatements().stream())\n+                        .filter(J.MethodInvocation.class::isInstance)\n+                        .map(J.MethodInvocation.class::cast)\n+                        .filter(m2 -> m2.getSimpleName().equals(\""dependencies\""))\n+                        .flatMap(dependencies -> ((J.Block) ((J.Lambda) dependencies.getArguments().get(0)).getBody()).getStatements().stream())\n+                        .filter(J.MethodInvocation.class::isInstance)\n+                        .map(J.MethodInvocation.class::cast)\n+                        .filter(m2 -> m2.getSimpleName().equals(\""constraints\""))\n+                        .findFirst()\n+                        .map(m2 -> m2.withArguments(ListUtils.mapFirst(m2.getArguments(), arg -> {\n+                            J.Lambda lambda = (J.Lambda) arg;\n+                            return lambda.withBody(((J.Block) lambda.getBody()).withEnd(Space.format(\""\\n\"")));\n+                        })))\n+                        .orElseThrow(() -> new IllegalStateException(\""Unable to find constraints block\""))\n+                        .withMarkers(Markers.EMPTY);\n+\n+                return m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {\n+                    if(!(arg instanceof J.Lambda)) {\n+                        return arg;\n+                    }\n+                    J.Lambda dependencies = (J.Lambda) arg;\n+                    if (!(dependencies.getBody() instanceof J.Block)) {\n+                        return m;\n+                    }\n+                    J.Block body = (J.Block) dependencies.getBody();\n+\n+                    List<Statement> statements = ListUtils.mapFirst(body.getStatements(), stat -> stat.withPrefix(stat.getPrefix().withWhitespace(\n+                            BlankLinesVisitor.minimumLines(stat.getPrefix().getWhitespace(), 1))));\n+                    return dependencies.withBody(body.withStatements(\n+                            ListUtils.concat(autoFormat(constraints, ctx, getCursor().getParentOrThrow()), statements)));\n+                }));\n             }\n \n             return m;\n@@ -393,7 +473,8 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n \n     @Value\n     @EqualsAndHashCode(callSuper = false)\n-    private static class AddConstraint extends GroovyIsoVisitor<ExecutionContext> {\n+    private static class AddConstraint extends JavaIsoVisitor<ExecutionContext> {\n+        boolean isKotlinDsl;\n         String config;\n         GroupArtifactVersion gav;\n \n@@ -403,45 +484,54 @@ private static class AddConstraint extends GroovyIsoVisitor<ExecutionContext> {\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n-            if(!CONSTRAINTS_MATCHER.matches(m)) {\n+            if(!CONSTRAINTS_MATCHER.matches(m) && !(isKotlinDsl && m.getSimpleName().equals(\""constraints\"") && withinBlock(getCursor(), \""dependencies\""))) {\n                 return m;\n             }\n             String ga = gav.getGroupId() + \"":\"" + gav.getArtifactId();\n-            AtomicReference<String> existingConstraintVersion = new AtomicReference<>();\n-            J.MethodInvocation existingConstraint = FindMethods.find(m, CONSTRAINT_MATCHER, true).stream()\n-                    .filter(J.MethodInvocation.class::isInstance)\n-                    .map(J.MethodInvocation.class::cast)\n-                    .filter(c -> c.getSimpleName().equals(config) && c.getArguments().stream()\n-                            .anyMatch(arg -> {\n-                                        if (!(arg instanceof J.Literal) || ((J.Literal) arg).getValue() == null) {\n-                                            return false;\n-                                        }\n-                                        String value = ((J.Literal) arg).getValue().toString();\n-                                        if (!value.startsWith(ga)) {\n-                                            return false;\n-                                        }\n-                                        existingConstraintVersion.set(value.substring(value.lastIndexOf(':') + 1));\n-                                        return true;\n-                                    }\n-                            )\n-                    ).findFirst()\n-                    .orElse(null);\n-            if (Objects.equals(gav.getVersion(), existingConstraintVersion.get())) {\n+            String existingConstraintVersion = null;\n+            J.MethodInvocation existingConstraint = null;\n+            MethodMatcher constraintMatcher = new MethodMatcher(CONSTRAINT_MATCHER, true);\n+            for (Statement statement : ((J.Block) ((J.Lambda) m.getArguments().get(0)).getBody()).getStatements()) {\n+                if (statement instanceof J.MethodInvocation || (statement instanceof J.Return && ((J.Return) statement).getExpression() instanceof J.MethodInvocation)) {\n+                    J.MethodInvocation m2 = (J.MethodInvocation) (statement instanceof J.Return ? ((J.Return) statement).getExpression() :  statement);\n+                    if (constraintMatcher.matches(m2)) {\n+                        if (m2.getSimpleName().equals(config) && matchesConstraint(m2, ga)) {\n+                            existingConstraint = m2;\n+                            existingConstraintVersion = DependencyStringNotationConverter.parse((String) requireNonNull(((J.Literal) m2.getArguments().get(0)).getValue())).getVersion();\n+                        }\n+                    } else if (isKotlinDsl && m.getSimpleName().equals(\""constraints\"")) {\n+                        if (m2.getSimpleName().equals(config) && matchesConstraint(m2, ga)) {\n+                            existingConstraint = m2;\n+                            existingConstraintVersion = DependencyStringNotationConverter.parse((String) requireNonNull(((J.Literal) m2.getArguments().get(0)).getValue())).getVersion();\n+                        }\n+                    }\n+                }\n+            }\n+            if (Objects.equals(gav.getVersion(), existingConstraintVersion)) {\n                 return m;\n             }\n             if(existingConstraint == null) {\n-                m = (J.MethodInvocation) new CreateConstraintVisitor(config, gav, because)\n+                m = (J.MethodInvocation) new CreateConstraintVisitor(config, gav, because, isKotlinDsl)\n                         .visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));\n             } else {\n-                m = (J.MethodInvocation) new UpdateConstraintVersionVisitor(gav, existingConstraint, because)\n+                m = (J.MethodInvocation) new UpdateConstraintVersionVisitor(gav, existingConstraint, because, isKotlinDsl)\n                         .visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));\n             }\n             return m;\n         }\n+\n+        private static boolean matchesConstraint(J.MethodInvocation m, String ga) {\n+            Expression arg = m.getArguments().get(0);\n+            if (!(arg instanceof J.Literal) || ((J.Literal) arg).getValue() == null) {\n+                return false;\n+            }\n+            String value = ((J.Literal) arg).getValue().toString();\n+            return value.startsWith(ga);\n+        }\n     }\n \n     //language=groovy\n-    private static final String INDIVIDUAL_CONSTRAINT_SNIPPET =\n+    private static final String INDIVIDUAL_CONSTRAINT_SNIPPET_GROOVY =\n             \""plugins {\\n\"" +\n             \""    id 'java'\\n\"" +\n             \""}\\n\"" +\n@@ -450,8 +540,18 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n             \""        implementation('foobar')\\n\"" +\n             \""    }\\n\"" +\n             \""}\"";\n+    //language=kotlin\n+    private static final String INDIVIDUAL_CONSTRAINT_SNIPPET_KOTLIN =\n+            \""plugins {\\n\"" +\n+            \""    id(\\\""java\\\"")\\n\"" +\n+            \""}\\n\"" +\n+            \""dependencies {\\n\"" +\n+            \""    constraints {\\n\"" +\n+            \""        implementation(\\\""foobar\\\"")\\n\"" +\n+            \""    }\\n\"" +\n+            \""}\"";\n     //language=groovy\n-    private static final String INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET =\n+    private static final String INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_GROOVY =\n             \""plugins {\\n\"" +\n             \""    id 'java'\\n\"" +\n             \""}\\n\"" +\n@@ -462,10 +562,22 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n             \""        }\\n\"" +\n             \""    }\\n\"" +\n             \""}\"";\n+    //language=kotlin\n+    private static final String INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_KOTLIN =\n+            \""plugins {\\n\"" +\n+            \""    id(\\\""java\\\"")\\n\"" +\n+            \""}\\n\"" +\n+            \""dependencies {\\n\"" +\n+            \""    constraints {\\n\"" +\n+            \""        implementation(\\\""foobar\\\"") {\\n\"" +\n+            \""            because(\\\""because\\\"")\\n\"" +\n+            \""        }\\n\"" +\n+            \""    }\\n\"" +\n+            \""}\"";\n \n     @Value\n     @EqualsAndHashCode(callSuper = false)\n-    private static class CreateConstraintVisitor extends GroovyIsoVisitor<ExecutionContext> {\n+    private static class CreateConstraintVisitor extends JavaIsoVisitor<ExecutionContext> {\n \n         String config;\n         GroupArtifactVersion gav;\n@@ -473,6 +585,8 @@ private static class CreateConstraintVisitor extends GroovyIsoVisitor<ExecutionC\n         @Nullable\n         String because;\n \n+        boolean isKotlinDsl;\n+\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             if (\""version\"".equals(method.getSimpleName())) {\n@@ -480,36 +594,68 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n             }\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n \n-            J.MethodInvocation constraint = parseAsGradle(because == null ? INDIVIDUAL_CONSTRAINT_SNIPPET : INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET, ctx)\n-                    .map(it -> (J.MethodInvocation) it.getStatements().get(1))\n-                    .map(dependenciesMethod -> (J.Lambda) dependenciesMethod.getArguments().get(0))\n-                    .map(dependenciesClosure -> (J.Block)dependenciesClosure.getBody())\n-                    .map(dependenciesBody -> (J.Return) dependenciesBody.getStatements().get(0))\n-                    .map(returnConstraints -> (J.MethodInvocation) returnConstraints.getExpression())\n-                    .map(constraintsInvocation -> (J.Lambda) constraintsInvocation.getArguments().get(0))\n-                    .map(constraintsLambda -> (J.Block) constraintsLambda.getBody())\n-                    .map(constraintsBlock -> (J.Return) constraintsBlock.getStatements().get(0))\n-                    .map(returnConfiguration -> (J.MethodInvocation) returnConfiguration.getExpression())\n-                    .map(it -> it.withName(it.getName().withSimpleName(config))\n-                            .withArguments(ListUtils.map(it.getArguments(), arg -> {\n-                                if (arg instanceof J.Literal) {\n-                                    return ((J.Literal) requireNonNull(arg))\n-                                            .withValue(gav.toString())\n-                                            .withValueSource(\""'\"" + gav + \""'\"");\n-                                } else if (arg instanceof J.Lambda && because != null) {\n-                                    return (Expression) new GroovyIsoVisitor<Integer>() {\n-                                        @Override\n-                                        public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n-                                            return literal.withValue(because)\n-                                                    .withValueSource(\""'\"" + because + \""'\"");\n-                                        }\n-                                    }.visitNonNull(arg, 0);\n-                                }\n-                                return arg;\n-                            })))\n-                    // Assign a unique ID so multiple constraints can be added\n-                    .map(it -> it.withId(Tree.randomId()))\n-                    .orElseThrow(() -> new IllegalStateException(\""Unable to find constraint\""));\n+            J.MethodInvocation constraint;\n+            if (!isKotlinDsl) {\n+                constraint = parseAsGradle(because == null ? INDIVIDUAL_CONSTRAINT_SNIPPET_GROOVY : INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_GROOVY, false, ctx)\n+                        .map(G.CompilationUnit.class::cast)\n+                        .map(it -> (J.MethodInvocation) it.getStatements().get(1))\n+                        .map(dependenciesMethod -> (J.Lambda) dependenciesMethod.getArguments().get(0))\n+                        .map(dependenciesClosure -> (J.Block) dependenciesClosure.getBody())\n+                        .map(dependenciesBody -> (J.Return) dependenciesBody.getStatements().get(0))\n+                        .map(returnConstraints -> (J.MethodInvocation) returnConstraints.getExpression())\n+                        .map(constraintsInvocation -> (J.Lambda) constraintsInvocation.getArguments().get(0))\n+                        .map(constraintsLambda -> (J.Block) constraintsLambda.getBody())\n+                        .map(constraintsBlock -> (J.Return) constraintsBlock.getStatements().get(0))\n+                        .map(returnConfiguration -> (J.MethodInvocation) returnConfiguration.getExpression())\n+                        .map(it -> it.withName(it.getName().withSimpleName(config))\n+                                .withArguments(ListUtils.map(it.getArguments(), arg -> {\n+                                    if (arg instanceof J.Literal) {\n+                                        return ((J.Literal) requireNonNull(arg))\n+                                                .withValue(gav.toString())\n+                                                .withValueSource(\""'\"" + gav + \""'\"");\n+                                    } else if (arg instanceof J.Lambda && because != null) {\n+                                        return (Expression) new GroovyIsoVisitor<Integer>() {\n+                                            @Override\n+                                            public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n+                                                return literal.withValue(because)\n+                                                        .withValueSource(\""'\"" + because + \""'\"");\n+                                            }\n+                                        }.visitNonNull(arg, 0);\n+                                    }\n+                                    return arg;\n+                                })))\n+                        // Assign a unique ID so multiple constraints can be added\n+                        .map(it -> it.withId(Tree.randomId()))\n+                        .orElseThrow(() -> new IllegalStateException(\""Unable to find constraint\""));\n+            } else {\n+                constraint = parseAsGradle(because == null ? INDIVIDUAL_CONSTRAINT_SNIPPET_KOTLIN : INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_KOTLIN, true, ctx)\n+                        .map(K.CompilationUnit.class::cast)\n+                        .map(it -> (J.Block) it.getStatements().get(0))\n+                        .map(it -> (J.MethodInvocation) it.getStatements().get(1))\n+                        .map(dependenciesMethod -> (J.Lambda) dependenciesMethod.getArguments().get(0))\n+                        .map(dependenciesClosure -> (J.Block) dependenciesClosure.getBody())\n+                        .map(dependenciesBody -> (J.MethodInvocation) dependenciesBody.getStatements().get(0))\n+                        .map(constraintsInvocation -> (J.Lambda) constraintsInvocation.getArguments().get(0))\n+                        .map(constraintsLambda -> (J.Block) constraintsLambda.getBody())\n+                        .map(constraintsBlock -> (J.MethodInvocation) constraintsBlock.getStatements().get(0))\n+                        .map(it -> it.withName(it.getName().withSimpleName(config))\n+                                .withArguments(ListUtils.map(it.getArguments(), arg -> {\n+                                    if (arg instanceof J.Literal) {\n+                                        return ChangeStringLiteral.withStringValue((J.Literal) requireNonNull(arg), gav.toString());\n+                                    } else if (arg instanceof J.Lambda && because != null) {\n+                                        return (Expression) new KotlinIsoVisitor<Integer>() {\n+                                            @Override\n+                                            public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n+                                                return ChangeStringLiteral.withStringValue(literal, because);\n+                                            }\n+                                        }.visitNonNull(arg, 0);\n+                                    }\n+                                    return arg;\n+                                })))\n+                        // Assign a unique ID so multiple constraints can be added\n+                        .map(it -> it.withId(Tree.randomId()))\n+                        .orElseThrow(() -> new IllegalStateException(\""Unable to find constraint\""));\n+            }\n \n             m = autoFormat(m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {\n                 if(!(arg instanceof J.Lambda)) {\n@@ -523,7 +669,7 @@ public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n \n                 return dependencies.withBody(body.withStatements(\n                         ListUtils.concat(constraint, body.getStatements())));\n-            })), constraint, ctx, getCursor().getParentOrThrow());\n+            })), ctx, getCursor().getParentOrThrow());\n             return m;\n         }\n     }\n@@ -537,6 +683,8 @@ private static class UpdateConstraintVersionVisitor extends GroovyIsoVisitor<Exe\n         @Nullable\n         String because;\n \n+        boolean isKotlinDsl;\n+\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             if (\""version\"".equals(method.getSimpleName())) {\n@@ -570,7 +718,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                     return arg;\n                 }));\n                 if(because != null && !updatedBecause.get()) {\n-                    m = (J.MethodInvocation) new CreateBecauseVisitor(because).visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));\n+                    m = (J.MethodInvocation) new CreateBecauseVisitor(because, isKotlinDsl).visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));\n                 }\n             }\n             return m;\n@@ -630,32 +778,74 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n     @EqualsAndHashCode(callSuper = false)\n     private static class CreateBecauseVisitor extends GroovyIsoVisitor<ExecutionContext> {\n         String because;\n+        boolean isKotlinDsl;\n+\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n-            J.Lambda becauseArg = parseAsGradle(INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET, ctx)\n-                    .map(cu -> (J.MethodInvocation) cu.getStatements().get(1))\n-                    .map(J.MethodInvocation.class::cast)\n-                    .map(dependencies -> (J.Lambda) dependencies.getArguments().get(0))\n-                    .map(dependenciesClosure -> ((J.Block)dependenciesClosure.getBody()).getStatements().get(0))\n-                    .map(J.Return.class::cast)\n-                    .map(returnConstraints -> ((J.MethodInvocation) requireNonNull(returnConstraints.getExpression())).getArguments().get(0))\n-                    .map(J.Lambda.class::cast)\n-                    .map(constraintsClosure -> ((J.Block)constraintsClosure.getBody()).getStatements().get(0))\n-                    .map(J.Return.class::cast)\n-                    .map(returnImplementation -> ((J.MethodInvocation) requireNonNull(returnImplementation.getExpression())).getArguments().get(1))\n-                    .map(J.Lambda.class::cast)\n-                    .map(it -> (J.Lambda) new GroovyIsoVisitor<Integer>() {\n-                        @Override\n-                        public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n-                            return literal.withValue(because)\n-                                    .withValueSource(\""'\"" + because + \""'\"");\n-                        }\n-                    }.visitNonNull(it, 0))\n-                    .orElseThrow(() -> new IllegalStateException(\""Unable to parse because text\""));\n+            J.Lambda becauseArg;\n+            if (!isKotlinDsl) {\n+                becauseArg = parseAsGradle(INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_GROOVY, false, ctx)\n+                        .map(G.CompilationUnit.class::cast)\n+                        .map(cu -> (J.MethodInvocation) cu.getStatements().get(1))\n+                        .map(dependencies -> (J.Lambda) dependencies.getArguments().get(0))\n+                        .map(dependenciesClosure -> ((J.Block) dependenciesClosure.getBody()).getStatements().get(0))\n+                        .map(J.Return.class::cast)\n+                        .map(returnConstraints -> ((J.MethodInvocation) requireNonNull(returnConstraints.getExpression())).getArguments().get(0))\n+                        .map(J.Lambda.class::cast)\n+                        .map(constraintsClosure -> ((J.Block) constraintsClosure.getBody()).getStatements().get(0))\n+                        .map(J.Return.class::cast)\n+                        .map(returnImplementation -> ((J.MethodInvocation) requireNonNull(returnImplementation.getExpression())).getArguments().get(1))\n+                        .map(J.Lambda.class::cast)\n+                        .map(it -> (J.Lambda) new GroovyIsoVisitor<Integer>() {\n+                            @Override\n+                            public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n+                                return literal.withValue(because)\n+                                        .withValueSource(\""'\"" + because + \""'\"");\n+                            }\n+                        }.visitNonNull(it, 0))\n+                        .orElseThrow(() -> new IllegalStateException(\""Unable to parse because text\""));\n+            } else {\n+                becauseArg = parseAsGradle(INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_GROOVY, true, ctx)\n+                        .map(K.CompilationUnit.class::cast)\n+                        .map(cu -> (J.Block) cu.getStatements().get(0))\n+                        .map(block -> (J.MethodInvocation) block.getStatements().get(1))\n+                        .map(dependencies -> (J.Lambda) dependencies.getArguments().get(0))\n+                        .map(dependenciesClosure -> ((J.Block) dependenciesClosure.getBody()).getStatements().get(0))\n+                        .map(J.Return.class::cast)\n+                        .map(returnConstraints -> ((J.MethodInvocation) requireNonNull(returnConstraints.getExpression())).getArguments().get(0))\n+                        .map(J.Lambda.class::cast)\n+                        .map(constraintsClosure -> ((J.Block) constraintsClosure.getBody()).getStatements().get(0))\n+                        .map(J.Return.class::cast)\n+                        .map(returnImplementation -> ((J.MethodInvocation) requireNonNull(returnImplementation.getExpression())).getArguments().get(1))\n+                        .map(J.Lambda.class::cast)\n+                        .map(it -> (J.Lambda) new GroovyIsoVisitor<Integer>() {\n+                            @Override\n+                            public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n+                                return literal.withValue(because)\n+                                        .withValueSource(\""'\"" + because + \""'\"");\n+                            }\n+                        }.visitNonNull(it, 0))\n+                        .orElseThrow(() -> new IllegalStateException(\""Unable to parse because text\""));\n+            }\n             m = m.withArguments(ListUtils.concat(m.getArguments().subList(0, 1), becauseArg));\n             m = autoFormat(m, ctx, getCursor().getParentOrThrow());\n             return m;\n         }\n     }\n+\n+    private static boolean withinBlock(Cursor cursor, String name) {\n+        Cursor parentCursor = cursor.getParent();\n+        while (parentCursor != null) {\n+            if (parentCursor.getValue() instanceof J.MethodInvocation) {\n+                J.MethodInvocation m = parentCursor.getValue();\n+                if (m.getSimpleName().equals(name)) {\n+                    return true;\n+                }\n+            }\n+            parentCursor = parentCursor.getParent();\n+        }\n+\n+        return false;\n+    }\n }\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/GradleDependency.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/GradleDependency.java\nindex 9d433d733a6..16fb59e63f2 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/GradleDependency.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/GradleDependency.java\n@@ -27,6 +27,7 @@\n import org.openrewrite.java.MethodMatcher;\n import org.openrewrite.java.tree.Expression;\n import org.openrewrite.java.tree.J;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.maven.tree.Dependency;\n import org.openrewrite.maven.tree.GroupArtifactVersion;\n import org.openrewrite.maven.tree.ResolvedDependency;\n@@ -99,7 +100,7 @@ public Matcher artifactId(@Nullable String artifactId) {\n \n                 org.openrewrite.gradle.internal.Dependency dependency = null;\n                 Expression argument = methodInvocation.getArguments().get(0);\n-                if (argument instanceof J.Literal || argument instanceof G.GString || argument instanceof G.MapEntry || argument instanceof G.MapLiteral) {\n+                if (argument instanceof J.Literal || argument instanceof G.GString || argument instanceof G.MapEntry || argument instanceof G.MapLiteral || argument instanceof J.Assignment || argument instanceof K.StringTemplate) {\n                     dependency = parseDependency(methodInvocation.getArguments());\n                 } else if (argument instanceof J.MethodInvocation) {\n                     if (((J.MethodInvocation) argument).getSimpleName().equals(\""platform\"") ||\n@@ -221,6 +222,42 @@ private boolean withinDependencyConstraintsBlock(Cursor cursor) {\n                 return getMapEntriesDependency(mapEntryExpressions);\n             } else if (argument instanceof G.MapEntry) {\n                 return getMapEntriesDependency(arguments);\n+            } else if (argument instanceof J.Assignment) {\n+                String group = null;\n+                String artifact = null;\n+\n+                for (Expression e : arguments) {\n+                    if (!(e instanceof J.Assignment)) {\n+                        continue;\n+                    }\n+                    J.Assignment arg = (J.Assignment) e;\n+                    if (!(arg.getVariable() instanceof J.Identifier) || !(arg.getAssignment() instanceof J.Literal)) {\n+                        continue;\n+                    }\n+                    J.Identifier identifier = (J.Identifier) arg.getVariable();\n+                    J.Literal value = (J.Literal) arg.getAssignment();\n+                    if (!(value.getValue() instanceof String)) {\n+                        continue;\n+                    }\n+                    String name = identifier.getSimpleName();\n+                    if (\""group\"".equals(name)) {\n+                        group = (String) value.getValue();\n+                    } else if (\""name\"".equals(name)) {\n+                        artifact = (String) value.getValue();\n+                    }\n+                }\n+\n+                if (group == null || artifact == null) {\n+                    return null;\n+                }\n+\n+                return new org.openrewrite.gradle.internal.Dependency(group, artifact, null, null, null);\n+            } else if (argument instanceof K.StringTemplate) {\n+                K.StringTemplate template = (K.StringTemplate) argument;\n+                List<J> strings = template.getStrings();\n+                if (strings.size() >= 2 && strings.get(0) instanceof J.Literal && ((J.Literal) strings.get(0)).getValue() != null) {\n+                    return DependencyStringNotationConverter.parse((String) ((J.Literal) strings.get(0)).getValue());\n+                }\n             }\n \n             return null;\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java b/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java\nindex 47b61432157..84daa94b20f 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java\n@@ -88,7 +88,10 @@ public <J2 extends J> J2 autoFormat(J2 j, P p, Cursor cursor) {\n \n     @SuppressWarnings({\""ConstantConditions\"", \""unchecked\""})\n     public <J2 extends J> J2 autoFormat(J2 j, @Nullable J stopAfter, P p, Cursor cursor) {\n-        AutoFormatService service = getCursor().firstEnclosingOrThrow(JavaSourceFile.class).service(AutoFormatService.class);\n+        JavaSourceFile cu = (j instanceof JavaSourceFile) ?\n+                (JavaSourceFile) j :\n+                getCursor().firstEnclosingOrThrow(JavaSourceFile.class);\n+        AutoFormatService service = cu.service(AutoFormatService.class);\n         return (J2) service.autoFormatVisitor(stopAfter).visit(j, p, cursor);\n     }\n \n"", ""test_patch"": ""diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java\nindex 4f76d21ed0c..7d71d133e43 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java\n@@ -19,8 +19,9 @@\n import lombok.Value;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n+import org.openrewrite.gradle.IsBuildGradle;\n import org.openrewrite.gradle.table.JVMTestSuitesDefined;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n+import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.tree.Expression;\n import org.openrewrite.java.tree.J;\n import org.openrewrite.java.tree.Statement;\n@@ -61,7 +62,7 @@ public String getDescription() {\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n         boolean requireDependencies = definesDependencies != null && definesDependencies;\n         boolean tableAvailable = this.insertRows == null || this.insertRows;\n-        return new GroovyIsoVisitor<ExecutionContext>() {\n+        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {\n             private boolean isJVMTestSuitesBlock() {\n                 Cursor parent = getCursor().getParent();\n                 if (parent != null) {\n@@ -101,7 +102,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                 }\n                 return super.visitMethodInvocation(method, ctx);\n             }\n-        };\n+        });\n     }\n \n     public static Set<String> jvmTestSuiteNames(Tree tree, boolean definesDependencies) {\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java\nindex 39488b41e95..75ede738f10 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java\n@@ -33,8 +33,7 @@\n import java.util.Optional;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.openrewrite.gradle.Assertions.buildGradle;\n-import static org.openrewrite.gradle.Assertions.settingsGradle;\n+import static org.openrewrite.gradle.Assertions.*;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n import static org.openrewrite.groovy.Assertions.groovy;\n import static org.openrewrite.groovy.Assertions.srcMainGroovy;\n@@ -1625,6 +1624,85 @@ void onlyNonDependenciesInDirectDependencyBlock() {\n         }\n     }\n \n+    @ParameterizedTest\n+    @ValueSource(strings = {\""com.google.common.math.*\"", \""com.google.common.math.IntMath\""})\n+    void kotlinDslOnlyIfUsingTestScope(String onlyIfUsing) {\n+        rewriteRun(\n+          spec -> spec.recipe(addDependency(\""com.google.guava:guava:29.0-jre\"", onlyIfUsing)),\n+          mavenProject(\""project\"",\n+            srcTestJava(\n+              java(usingGuavaIntMath)\n+            ),\n+            buildGradleKts(\n+              \""\""\""\n+                plugins {\n+                    `java-library`\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \""\""\"",\n+              \""\""\""\n+                plugins {\n+                    `java-library`\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    testImplementation(\""com.google.guava:guava:29.0-jre\"")\n+                }\n+                \""\""\""\n+            )\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslMatchesDependencyDeclarationStyle() {\n+        rewriteRun(\n+          spec -> spec.recipe(addDependency(\""com.google.guava:guava:29.0-jre\"", \""com.google.common.math.IntMath\"")),\n+          mavenProject(\""project\"",\n+            srcTestJava(\n+              java(usingGuavaIntMath)\n+            ),\n+            buildGradleKts(\n+              \""\""\""\n+                plugins {\n+                    `java-library`\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation(group = \""commons-lang\"", name = \""commons-lang\"", version = \""1.0\"")\n+                }\n+                \""\""\"",\n+              \""\""\""\n+                plugins {\n+                    `java-library`\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation(group = \""commons-lang\"", name = \""commons-lang\"", version = \""1.0\"")\n+                \n+                    testImplementation(group = \""com.google.guava\"", name = \""guava\"", version = \""29.0-jre\"")\n+                }\n+                \""\""\""\n+            )\n+          )\n+        );\n+    }\n+\n     private AddDependency addDependency(@SuppressWarnings(\""SameParameterValue\"") String gav) {\n         return addDependency(gav, null, null);\n     }\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/ChangeDependencyTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/ChangeDependencyTest.java\nindex decf3758ce9..c997e7b8688 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/ChangeDependencyTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/ChangeDependencyTest.java\n@@ -21,6 +21,7 @@\n import org.openrewrite.test.RewriteTest;\n \n import static org.openrewrite.gradle.Assertions.buildGradle;\n+import static org.openrewrite.gradle.Assertions.buildGradleKts;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n \n class ChangeDependencyTest implements RewriteTest {\n@@ -445,4 +446,78 @@ void relocateDependencyInJvmTestSuite() {\n             )\n         );\n     }\n+\n+    @Test\n+    void kotlinDsl() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependency(\""commons-lang\"", \""commons-lang\"", \""org.apache.commons\"", \""commons-lang3\"", \""3.11.x\"", null, null)),\n+          buildGradleKts(\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(\""commons-lang:commons-lang:2.6\"")\n+                  implementation(group = \""commons-lang\"", name = \""commons-lang\"", version = \""2.6\"")\n+              }\n+              \""\""\"",\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(\""org.apache.commons:commons-lang3:3.11\"")\n+                  implementation(group = \""org.apache.commons\"", name = \""commons-lang3\"", version = \""3.11\"")\n+              }\n+              \""\""\""\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslStringInterpolation() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependency(\""commons-lang\"", \""commons-lang\"", \""org.apache.commons\"", \""commons-lang3\"", \""3.11.x\"", null, null)),\n+          buildGradleKts(\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  val commonsLangVersion = \""2.6\""\n+                  implementation(\""commons-lang:commons-lang:${commonsLangVersion}\"")\n+              }\n+              \""\""\"",\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  val commonsLangVersion = \""2.6\""\n+                  implementation(\""org.apache.commons:commons-lang3:3.11\"")\n+              }\n+              \""\""\""\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/RemoveDependencyTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/RemoveDependencyTest.java\nindex e98dcb0fdd6..4d94fcd9fce 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/RemoveDependencyTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/RemoveDependencyTest.java\n@@ -26,8 +26,7 @@\n import java.util.Optional;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.openrewrite.gradle.Assertions.buildGradle;\n-import static org.openrewrite.gradle.Assertions.settingsGradle;\n+import static org.openrewrite.gradle.Assertions.*;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n import static org.openrewrite.java.Assertions.mavenProject;\n \n@@ -546,4 +545,74 @@ void dependenciesBlockInFreestandingScript() {\n           )\n         );\n     }\n+\n+    @Test\n+    void kotlinDslString() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(\""org.springframework.boot:spring-boot-starter-web:2.7.0\"")\n+                  testImplementation(\""org.junit.vintage:junit-vintage-engine:5.6.2\"")\n+              }\n+              \""\""\"",\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  testImplementation(\""org.junit.vintage:junit-vintage-engine:5.6.2\"")\n+              }\n+              \""\""\""\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslMap() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(group = \""org.springframework.boot\"", name = \""spring-boot-starter-web\"", version = \""2.7.0\"")\n+                  testImplementation(group = \""org.junit.vintage\"", name = \""junit-vintage-engine\"", version = \""5.6.2\"")\n+              }\n+              \""\""\"",\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  testImplementation(group = \""org.junit.vintage\"", name = \""junit-vintage-engine\"", version = \""5.6.2\"")\n+              }\n+              \""\""\""\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java\nindex 88d3f501e15..fdb3e35ae54 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java\n@@ -29,8 +29,7 @@\n import java.util.regex.Pattern;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.openrewrite.gradle.Assertions.buildGradle;\n-import static org.openrewrite.gradle.Assertions.settingsGradle;\n+import static org.openrewrite.gradle.Assertions.*;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n import static org.openrewrite.properties.Assertions.properties;\n \n@@ -1289,4 +1288,144 @@ void cannotDownloadMetaDataWhenNoRepositoriesAreDefined() {\n           )\n         );\n     }\n+\n+    @Test\n+    void kotlinDslString() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(\""com.google.guava:guava:29.0-jre\"")\n+              }\n+              \""\""\"",\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(\""com.google.guava:guava:30.1.1-jre\"")\n+              }\n+              \""\""\""\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslMap() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(group = \""com.google.guava\"", name = \""guava\"", version = \""29.0-jre\"")\n+              }\n+              \""\""\"",\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(group = \""com.google.guava\"", name = \""guava\"", version = \""30.1.1-jre\"")\n+              }\n+              \""\""\""\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslVariable() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  val guavaVersion = \""29.0-jre\""\n+                  implementation(group = \""com.google.guava\"", name = \""guava\"", version = guavaVersion)\n+              }\n+              \""\""\"",\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  val guavaVersion = \""30.1.1-jre\""\n+                  implementation(group = \""com.google.guava\"", name = \""guava\"", version = guavaVersion)\n+              }\n+              \""\""\""\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslStringInterpolation() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  val guavaVersion = \""29.0-jre\""\n+                  implementation(\""com.google.guava:guava:${guavaVersion}\"")\n+              }\n+              \""\""\"",\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  val guavaVersion = \""30.1.1-jre\""\n+                  implementation(\""com.google.guava:guava:${guavaVersion}\"")\n+              }\n+              \""\""\""\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java\nindex 80d0d357b4a..9f544c456c3 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java\n@@ -24,6 +24,7 @@\n import java.util.List;\n \n import static org.openrewrite.gradle.Assertions.buildGradle;\n+import static org.openrewrite.gradle.Assertions.buildGradleKts;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n \n class UpgradeTransitiveDependencyVersionTest implements RewriteTest {\n@@ -456,6 +457,7 @@ void addConstraintToNonTransitiveExtendingTransitiveConfiguration() {\n           )\n         );\n     }\n+\n     @Test\n     void constraintDoesNotGetAddedToNonTransitiveNonExtendingConfiguration() {\n         rewriteRun(\n@@ -479,7 +481,7 @@ void constraintDoesNotGetAddedToNonTransitiveNonExtendingConfiguration() {\n     void constraintDoesNotGetAddedInsideConstraint() {\n         rewriteRun(\n           spec -> spec\n-            .recipe(new UpgradeTransitiveDependencyVersion(\""com.fasterxml.jackson.core\"", \""jackson-core\"",\""2.12.5\"", null, \""CVE-2024-BAD\"", null)),\n+            .recipe(new UpgradeTransitiveDependencyVersion(\""com.fasterxml.jackson.core\"", \""jackson-core\"", \""2.12.5\"", null, \""CVE-2024-BAD\"", null)),\n           //language=groovy\n           buildGradle(\n             \""\""\""\n@@ -671,4 +673,114 @@ void useResolutionStrategyWhenSpringDependencyManagementPluginIsPresent() {\n           )\n         );\n     }\n+\n+    @Test\n+    void kotlinDslAddConstraint() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \""\""\""\n+              plugins {\n+                `java-library`\n+              }\n+              repositories { mavenCentral() }\n+              \n+              dependencies {\n+                  implementation(\""org.openrewrite:rewrite-java:7.0.0\"")\n+              }\n+              \""\""\"",\n+            \""\""\""\n+              plugins {\n+                `java-library`\n+              }\n+              repositories { mavenCentral() }\n+              \n+              dependencies {\n+                  constraints {\n+                      implementation(\""com.fasterxml.jackson.core:jackson-core:2.12.5\"") {\n+                          because(\""CVE-2024-BAD\"")\n+                      }\n+                  }\n+              \n+                  implementation(\""org.openrewrite:rewrite-java:7.0.0\"")\n+              }\n+              \""\""\""\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslUpdateConstraint() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \""\""\""\n+              plugins { id(\""java\"") }\n+              repositories { mavenCentral() }\n+              \n+              dependencies {\n+                  constraints {\n+                      implementation(\""com.fasterxml.jackson.core:jackson-core:2.12.0\"") {\n+                          because(\""some reason\"")\n+                      }\n+                  }\n+              \n+                  implementation(\""org.openrewrite:rewrite-java:7.0.0\"")\n+              }\n+              \""\""\"",\n+            \""\""\""\n+              plugins { id(\""java\"") }\n+              repositories { mavenCentral() }\n+              \n+              dependencies {\n+                  constraints {\n+                      implementation(\""com.fasterxml.jackson.core:jackson-core:2.12.5\"") {\n+                          because(\""CVE-2024-BAD\"")\n+                      }\n+                  }\n+              \n+                  implementation(\""org.openrewrite:rewrite-java:7.0.0\"")\n+              }\n+              \""\""\""\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslUseResolutionStrategyWhenSpringDependencyManagementPluginIsPresent() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+                  id(\""io.spring.dependency-management\"") version \""1.1.5\""\n+              }\n+              repositories { mavenCentral() }\n+              \n+              dependencies {\n+              \n+                  implementation(\""org.openrewrite:rewrite-java:7.0.0\"")\n+              }\n+              \""\""\"",\n+            \""\""\""\n+              plugins {\n+                  `java-library`\n+                  id(\""io.spring.dependency-management\"") version \""1.1.5\""\n+              }\n+              repositories { mavenCentral() }\n+              configurations.all {\n+                  resolutionStrategy.eachDependency { details ->\n+                      if (details.requested.group == \""com.fasterxml.jackson.core\"" && details.requested.name == \""jackson-core\"") {\n+                          details.useVersion(\""2.12.5\"")\n+                          details.because(\""CVE-2024-BAD\"")\n+                      }\n+                  }\n+              }\n+              \n+              dependencies {\n+              \n+                  implementation(\""org.openrewrite:rewrite-java:7.0.0\"")\n+              }\n+              \""\""\""\n+          )\n+        );\n+    }\n }\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""openrewrite__rewrite-4661"", ""pr_id"": 4661, ""issue_id"": 4660, ""repo"": ""openrewrite/rewrite"", ""problem_statement"": ""Support JEP-441: Pattern Matching for switch\n<!--\r\nThank you for suggesting an improvement to OpenRewrite!\r\nFeel free to delete any sections that don't apply to your request.\r\n-->\r\n## What problem are you trying to solve?\r\nTo support Java 21 recipes the parser need to be extended to ensure compatibility with JEP 440 (Record Patterns) and JEP 441 (Pattern Matching for switch).\r\n\r\n## Describe the solution you'd like\r\nParsing logic should recognize and handle record patterns and switch pattern matching, for different situations and edge cases, which have already been outlined in the proposal.\r\n\r\n## Additional context\r\n* https://openjdk.org/jeps/441"", ""issue_word_count"": 100, ""test_files_count"": 3, ""non_test_files_count"": 13, ""pr_changed_files"": [""rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java"", ""rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java"", ""rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java"", ""rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java"", ""rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java"", ""rewrite-java-tck/src/main/java/org/openrewrite/java/tree/RecordPatternMatchingTest.java"", ""rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java"", ""rewrite-java/src/main/java/org/openrewrite/java/Assertions.java"", ""rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java"", ""rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java"", ""rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java"", ""rewrite-java/src/main/java/org/openrewrite/java/tree/J.java"", ""rewrite-java/src/main/java/org/openrewrite/java/tree/JContainer.java"", ""rewrite-java/src/main/java/org/openrewrite/java/tree/JRightPadded.java"", ""rewrite-java/src/main/java/org/openrewrite/java/tree/Space.java"", ""rewrite-test/src/main/java/org/openrewrite/test/TypeValidation.java""], ""pr_changed_test_files"": [""rewrite-java-tck/src/main/java/org/openrewrite/java/tree/RecordPatternMatchingTest.java"", ""rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java"", ""rewrite-test/src/main/java/org/openrewrite/test/TypeValidation.java""], ""base_commit"": ""1fd511c3b31787ba6517b8b2db137d73fa05e6bb"", ""head_commit"": ""472082ffaa1a1ed5f8cc5a1fcfcf11b767011b2b"", ""repo_url"": ""https://github.com/openrewrite/rewrite/pull/4661"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4661"", ""dockerfile"": """", ""pr_merged_at"": ""2025-01-17T13:08:22.000Z"", ""patch"": ""diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex d38c154ef76..e36026b986a 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -650,7 +650,7 @@ public List<J.Annotation> visitAndGetAnnotations(AnnotatedNode node) {\n             for (AnnotationNode annotationNode : node.getAnnotations()) {\n                 // The groovy compiler can add or remove annotations for AST transformations.\n                 // Because @groovy.transform.Immutable is discarded in favour of other transform annotations, the removed annotation must be parsed by hand.\n-                if (sourceStartsWith(\""@\"" + Immutable.class.getSimpleName()) || sourceStartsWith(\""@\"" + Immutable.class.getCanonicalName()) ) {\n+                if (sourceStartsWith(\""@\"" + Immutable.class.getSimpleName()) || sourceStartsWith(\""@\"" + Immutable.class.getCanonicalName())) {\n                     visitAnnotation(new AnnotationNode(new ClassNode(Immutable.class)));\n                     paramAnnotations.add(pollQueue());\n                 }\n@@ -1135,10 +1135,12 @@ public void visitCaseStatement(CaseStatement statement) {\n                     J.Case.Type.Statement,\n                     null,\n                     JContainer.build(singletonList(JRightPadded.build(visit(statement.getExpression())))),\n+                    null,\n+                    null,\n                     statement.getCode() instanceof EmptyStatement ?\n                             JContainer.build(sourceBefore(\"":\""), convertStatements(emptyList()), Markers.EMPTY) :\n-                            JContainer.build(sourceBefore(\"":\""), convertStatements(((BlockStatement) statement.getCode()).getStatements()), Markers.EMPTY)\n-                    , null)\n+                            JContainer.build(sourceBefore(\"":\""), convertStatements(((BlockStatement) statement.getCode()).getStatements()), Markers.EMPTY),\n+                    null)\n             );\n         }\n \n@@ -1149,6 +1151,8 @@ private J.Case visitDefaultCaseStatement(BlockStatement statement) {\n                     J.Case.Type.Statement,\n                     null,\n                     JContainer.build(singletonList(JRightPadded.build(new J.Identifier(randomId(), EMPTY, Markers.EMPTY, emptyList(), skip(\""default\""), null, null)))),\n+                    null,\n+                    null,\n                     JContainer.build(sourceBefore(\"":\""), convertStatements(statement.getStatements()), Markers.EMPTY),\n                     null\n             );\n@@ -1609,7 +1613,7 @@ public void visitGStringExpression(GStringExpression gstring) {\n                 }\n             }\n \n-            queue.add(new G.GString(randomId(), fmt, Markers.EMPTY, delimiter, strings,typeMapping.type(gstring.getType())));\n+            queue.add(new G.GString(randomId(), fmt, Markers.EMPTY, delimiter, strings, typeMapping.type(gstring.getType())));\n             skip(delimiter); // Closing delim for GString\n         }\n \n@@ -2778,6 +2782,7 @@ private static ClassNode staticType(Parameter parameter) {\n     }\n \n     private static final Map<String, J.Modifier.Type> modifierNameToType;\n+\n     static {\n         modifierNameToType = new LinkedHashMap<>();\n         modifierNameToType.put(\""def\"", J.Modifier.Type.LanguageExtension);\n\ndiff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\nindex 8c434c84edd..22648604cd2 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n@@ -346,6 +346,8 @@ public J visitCase(CaseTree node, Space fmt) {\n                         ),\n                         Markers.EMPTY\n                 ),\n+                null,\n+                null,\n                 JContainer.build(sourceBefore(\"":\""), convertStatements(node.getStatements()), Markers.EMPTY),\n                 null\n         );\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex 7fbd874ed01..4cfa6f14764 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -355,6 +355,8 @@ public J visitCase(CaseTree node, Space fmt) {\n                                 convertAll(node.getExpressions(), commaDelim, t -> EMPTY),\n                         Markers.EMPTY\n                 ),\n+                null,\n+                null,\n                 JContainer.build(\n                         sourceBefore(type == J.Case.Type.Rule ? \""->\"" : \"":\""),\n                         convertStatements(node.getStatements()),\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex 4a6973da177..0614a13714f 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -348,13 +348,15 @@ public J visitCase(CaseTree node, Space fmt) {\n                 Markers.EMPTY,\n                 type,\n                 null,\n+                null,\n                 JContainer.build(\n-                        node.getExpressions().isEmpty() ? EMPTY : sourceBefore(\""case\""),\n-                        node.getExpressions().isEmpty() ?\n+                        node.getLabels().isEmpty() ? EMPTY : sourceBefore(\""case\""),\n+                        node.getLabels().isEmpty() || node.getLabels().getFirst() instanceof DefaultCaseLabelTree ?\n                                 List.of(JRightPadded.build(new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), skip(\""default\""), null, null))) :\n-                                convertAll(node.getExpressions(), commaDelim, t -> EMPTY),\n+                                convertAll(node.getLabels(), commaDelim, ignored -> node.getGuard() != null ? sourceBefore(\""when\"", '-') : EMPTY),\n                         Markers.EMPTY\n                 ),\n+                convert(node.getGuard()),\n                 JContainer.build(\n                         sourceBefore(type == J.Case.Type.Rule ? \""->\"" : \"":\""),\n                         convertStatements(node.getStatements()),\n@@ -779,12 +781,26 @@ public J visitInstanceOf(InstanceOfTree node, Space fmt) {\n         return new J.InstanceOf(randomId(), fmt, Markers.EMPTY,\n                 convert(node.getExpression(), t -> sourceBefore(\""instanceof\"")),\n                 convert(node.getType()),\n-                node.getPattern() instanceof JCBindingPattern b ?\n-                        new J.Identifier(randomId(), sourceBefore(b.getVariable().getName().toString()), Markers.EMPTY, emptyList(), b.getVariable().getName().toString(),\n-                                type, typeMapping.variableType(b.var.sym)) : null,\n+                getNodePattern(node.getPattern(), type),\n                 type);\n     }\n \n+    private @Nullable J getNodePattern(@Nullable PatternTree pattern, JavaType type) {\n+        if (pattern instanceof JCBindingPattern b) {\n+            return new J.Identifier(randomId(), sourceBefore(b.getVariable().getName().toString()), Markers.EMPTY, emptyList(), b.getVariable().getName().toString(),\n+                    type, typeMapping.variableType(b.var.sym));\n+        } else {\n+            if (pattern == null) {\n+                return null;\n+            }\n+            int saveCursor = cursor;\n+            int endCursor = max(endPos(pattern), cursor);\n+            cursor = endCursor;\n+            return new J.Unknown(randomId(), whitespace(), Markers.EMPTY, new J.Unknown.Source(randomId(), whitespace(), Markers.EMPTY, source.substring(saveCursor, endCursor)));\n+\n+        }\n+    }\n+\n     @Override\n     public J visitIntersectionType(IntersectionTypeTree node, Space fmt) {\n         JContainer<TypeTree> bounds = node.getBounds().isEmpty() ? null :\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\nindex 0d6cf8309fc..5d35ffcc46a 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n@@ -343,6 +343,8 @@ public J visitCase(CaseTree node, Space fmt) {\n                         ),\n                         Markers.EMPTY\n                 ),\n+                null,\n+                null,\n                 JContainer.build(sourceBefore(\"":\""), convertStatements(node.getStatements()), Markers.EMPTY),\n                 null\n         );\n@@ -1787,17 +1789,17 @@ private <J2 extends J> List<JRightPadded<J2>> convertAll(List<? extends Tree> tr\n \n     private Space statementDelim(@Nullable Tree t) {\n         if (t instanceof JCAssert ||\n-                t instanceof JCAssign ||\n-                t instanceof JCAssignOp ||\n-                t instanceof JCBreak ||\n-                t instanceof JCContinue ||\n-                t instanceof JCDoWhileLoop ||\n-                t instanceof JCImport ||\n-                t instanceof JCMethodInvocation ||\n-                t instanceof JCNewClass ||\n-                t instanceof JCReturn ||\n-                t instanceof JCThrow ||\n-                t instanceof JCUnary) {\n+            t instanceof JCAssign ||\n+            t instanceof JCAssignOp ||\n+            t instanceof JCBreak ||\n+            t instanceof JCContinue ||\n+            t instanceof JCDoWhileLoop ||\n+            t instanceof JCImport ||\n+            t instanceof JCMethodInvocation ||\n+            t instanceof JCNewClass ||\n+            t instanceof JCReturn ||\n+            t instanceof JCThrow ||\n+            t instanceof JCUnary) {\n             return sourceBefore(\"";\"");\n         }\n \n@@ -1808,7 +1810,7 @@ private Space statementDelim(@Nullable Tree t) {\n         if (t instanceof JCExpressionStatement) {\n             ExpressionTree expTree = ((ExpressionStatementTree) t).getExpression();\n             if (expTree instanceof ErroneousTree) {\n-                return Space.build(source.substring(((JCTree) expTree).getEndPosition(endPosTable),((JCTree) t).getEndPosition(endPosTable)), Collections.emptyList());\n+                return Space.build(source.substring(((JCTree) expTree).getEndPosition(endPosTable), ((JCTree) t).getEndPosition(endPosTable)), Collections.emptyList());\n             } else {\n                 return sourceBefore(\"";\"");\n             }\n@@ -1972,7 +1974,7 @@ private int positionOfNext(String untilDelim, @Nullable Character stop) {\n                     char c2 = source.charAt(delimIndex + 1);\n                     switch (c1) {\n                         case '/':\n-                            switch(c2) {\n+                            switch (c2) {\n                                 case '/':\n                                     inSingleLineComment = true;\n                                     delimIndex++;\n@@ -1984,7 +1986,7 @@ private int positionOfNext(String untilDelim, @Nullable Character stop) {\n                             }\n                             break;\n                         case '*':\n-                            if(c2 == '/') {\n+                            if (c2 == '/') {\n                                 inMultiLineComment = false;\n                                 delimIndex++;\n                                 continue;\n@@ -2051,7 +2053,7 @@ private List<String> listFlags(long flags) {\n                     try {\n                         // FIXME instanceof probably not right here...\n                         return field.get(null) instanceof Long &&\n-                                field.getName().matches(\""[A-Z_]+\"");\n+                               field.getName().matches(\""[A-Z_]+\"");\n                     } catch (IllegalAccessException e) {\n                         throw new RuntimeException(e);\n                     }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/Assertions.java b/rewrite-java/src/main/java/org/openrewrite/java/Assertions.java\nindex 1524c72188e..4d2196083ca 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/Assertions.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/Assertions.java\n@@ -74,13 +74,28 @@ public J.Erroneous visitErroneous(J.Erroneous erroneous, List<J.Erroneous> list)\n                             .collect(joining(\""\\n\\n\"")));\n                 }\n             }\n+            if (typeValidation.unknown()) {\n+                List<J.Unknown> allUnknown = new JavaIsoVisitor<List<J.Unknown>>() {\n+                    @Override\n+                    public J.Unknown visitUnknown(J.Unknown unknown, List<J.Unknown> list) {\n+                        J.Unknown err = super.visitUnknown(unknown, list);\n+                        list.add(err);\n+                        return err;\n+                    }\n+                }.reduce(source, new ArrayList<>());\n+                if (!allUnknown.isEmpty()) {\n+                    throw new IllegalStateException(\""LST contains erroneous nodes\\n\"" + allUnknown.stream()\n+                            .map(unknown -> unknown.getSource().getText())\n+                            .collect(joining(\""\\n\\n\"")));\n+                }\n+            }\n         }\n         return source;\n     }\n \n     private static void assertValidTypes(TypeValidation typeValidation, J sf) {\n         if (typeValidation.identifiers() || typeValidation.methodInvocations() || typeValidation.methodDeclarations() || typeValidation.classDeclarations() ||\n-                typeValidation.constructorInvocations()) {\n+            typeValidation.constructorInvocations()) {\n             List<FindMissingTypes.MissingTypeResult> missingTypeResults = FindMissingTypes.findMissingTypes(sf);\n             missingTypeResults = missingTypeResults.stream()\n                     .filter(missingType -> {\n@@ -108,7 +123,7 @@ private static void assertValidTypes(TypeValidation typeValidation, J sf) {\n                         .collect(joining(\""\\n\\n\""));\n                 throw new IllegalStateException(\n                         \""LST contains missing or invalid type information\\n\"" + missingTypes +\n-                                \""\\nhttps://docs.openrewrite.org/reference/faq#im-seeing-lst-contains-missing-or-invalid-type-information-in-my-recipe-unit-tests-how-to-resolve\"");\n+                        \""\\nhttps://docs.openrewrite.org/reference/faq#im-seeing-lst-contains-missing-or-invalid-type-information-in-my-recipe-unit-tests-how-to-resolve\"");\n             }\n         }\n     }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java b/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java\nindex 9743bb1abcd..38e6fc9715b 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java\n@@ -442,8 +442,8 @@ protected void printStatementTerminator(Statement s, PrintOutputCapture<P> p) {\n                         getCursor()\n                                 .dropParentUntil(\n                                         c -> c instanceof Switch ||\n-                                                c instanceof SwitchExpression ||\n-                                                c == Cursor.ROOT_VALUE\n+                                             c instanceof SwitchExpression ||\n+                                             c == Cursor.ROOT_VALUE\n                                 )\n                                 .getValue();\n                 if (aSwitch instanceof SwitchExpression) {\n@@ -484,11 +484,15 @@ public J visitBreak(Break breakStatement, PrintOutputCapture<P> p) {\n     @Override\n     public J visitCase(Case case_, PrintOutputCapture<P> p) {\n         beforeSyntax(case_, Space.Location.CASE_PREFIX, p);\n-        Expression elem = case_.getExpressions().get(0);\n+        J elem = case_.getCaseLabels().get(0);\n         if (!(elem instanceof Identifier) || !((Identifier) elem).getSimpleName().equals(\""default\"")) {\n             p.append(\""case\"");\n         }\n-        visitContainer(\""\"", case_.getPadding().getExpressions(), JContainer.Location.CASE_EXPRESSION, \"",\"", \""\"", p);\n+        visitContainer(\""\"", case_.getPadding().getCaseLabels(), JContainer.Location.CASE_LABEL, \"",\"", \""\"", p);\n+        if (case_.getGuard() != null) {\n+            p.append(\""when\"");\n+            visit(case_.getGuard(), p);\n+        }\n         visitSpace(case_.getPadding().getStatements().getBefore(), Space.Location.CASE, p);\n         p.append(case_.getType() == Case.Type.Statement ? \"":\"" : \""->\"");\n         visitStatements(case_.getPadding().getStatements().getPadding()\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java b/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java\nindex be5ca459848..8f8e05bb1bd 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java\n@@ -423,7 +423,8 @@ public J visitCase(J.Case case_, P p) {\n         } else {\n             c = (J.Case) temp;\n         }\n-        c = c.getPadding().withExpressions(visitContainer(c.getPadding().getExpressions(), JContainer.Location.CASE_EXPRESSION, p));\n+        c = c.getPadding().withCaseLabels(visitContainer(c.getPadding().getCaseLabels(), JContainer.Location.CASE_LABEL, p));\n+        c = c.withGuard(visitAndCast(c.getGuard(), p));\n         c = c.getPadding().withBody(visitRightPadded(c.getPadding().getBody(), JRightPadded.Location.CASE_BODY, p));\n         c = c.getPadding().withStatements(visitContainer(c.getPadding().getStatements(), JContainer.Location.CASE, p));\n         return c;\n@@ -1406,7 +1407,7 @@ public J visitYield(J.Yield yield, P p) {\n     }\n \n     public <J2 extends J> @Nullable JContainer<J2> visitContainer(@Nullable JContainer<J2> container,\n-                                                        JContainer.Location loc, P p) {\n+                                                                  JContainer.Location loc, P p) {\n         if (container == null) {\n             //noinspection ConstantConditions\n             return null;\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java b/rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java\nindex 6260ae2ec1a..3618a95f763 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java\n@@ -366,7 +366,13 @@ public J.Case visitCase(J.Case _case, J j) {\n                 J.Case compareTo = (J.Case) j;\n                 this.visitList(_case.getStatements(), compareTo.getStatements());\n                 visit(_case.getBody(), compareTo.getBody());\n-                this.visitList(_case.getExpressions(), compareTo.getExpressions());\n+                this.visitList(_case.getCaseLabels(), compareTo.getCaseLabels());\n+                if (_case.getGuard() != null && compareTo.getGuard() != null) {\n+                    visit(_case.getGuard(), compareTo.getGuard());\n+                } else if (nullMissMatch(_case.getGuard(), compareTo.getGuard())) {\n+                    isEqual.set(false);\n+                    return _case;\n+                }\n             }\n             return _case;\n         }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java\nindex 3c6f581bb8a..592e839a3e3 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java\n@@ -1027,14 +1027,36 @@ public Case withPattern(@Nullable Expression pattern) {\n             return withExpressions(ListUtils.mapFirst(getExpressions(), first -> pattern));\n         }\n \n-        JContainer<Expression> expressions;\n-\n+        /**\n+         * @deprecated As of Java 21 this is referred to as case labels and can be broader than just Expressions.\n+         * Use {@link #getCaseLabels} and {@link #withCaseLabels(List)} instead.\n+         */\n+        @Deprecated\n         public List<Expression> getExpressions() {\n-            return expressions.getElements();\n+            return caseLabels.getElements().stream().filter(Expression.class::isInstance).map(Expression.class::cast).collect(toList());\n         }\n \n+        /**\n+         * @deprecated As of Java 21 this is referred to as case labels and can be broader than just Expressions.\n+         * Use {@link #getCaseLabels} and {@link #withCaseLabels(List)} instead.\n+         */\n         public Case withExpressions(List<Expression> expressions) {\n-            return getPadding().withExpressions(requireNonNull(JContainer.withElementsNullable(this.expressions, expressions)));\n+            if (caseLabels.getElements().stream().allMatch(Expression.class::isInstance)) {\n+                //noinspection unchecked\n+                return getPadding().withCaseLabels(requireNonNull(JContainer.withElementsNullable(this.caseLabels, (List<J>) (List<?>) expressions)));\n+            } else {\n+                throw new IllegalStateException(\""caseLabels contains an entry that is not an Expression, use withCaseLabels instead.\"");\n+            }\n+        }\n+\n+        JContainer<J> caseLabels;\n+\n+        public List<J> getCaseLabels() {\n+            return caseLabels.getElements();\n+        }\n+\n+        public Case withCaseLabels(List<J> caseLabels) {\n+            return getPadding().withCaseLabels(requireNonNull(JContainer.withElementsNullable(this.caseLabels, caseLabels)));\n         }\n \n         /**\n@@ -1067,17 +1089,27 @@ public Case withBody(J body) {\n             return getPadding().withBody(JRightPadded.withElement(this.body, body));\n         }\n \n+        @Nullable\n+        @Getter\n+        @With\n+        Expression guard;\n+\n         @JsonCreator\n-        public Case(UUID id, Space prefix, Markers markers, Type type, @Deprecated @Nullable Expression pattern, JContainer<Expression> expressions, JContainer<Statement> statements, @Nullable JRightPadded<J> body) {\n+        public Case(UUID id, Space prefix, Markers markers, Type type, @Deprecated @Nullable Expression pattern, @Nullable JContainer<Expression> expressions, @Nullable JContainer<J> caseLabels, @Nullable Expression guard, JContainer<Statement> statements, @Nullable JRightPadded<J> body) {\n             this.id = id;\n             this.prefix = prefix;\n             this.markers = markers;\n             this.type = type;\n             if (pattern != null) {\n-                this.expressions = requireNonNull(JContainer.withElementsNullable(null, singletonList(pattern)));\n+                this.caseLabels = requireNonNull(JContainer.withElementsNullable(null, singletonList(pattern)));\n+            } else if (expressions != null) {\n+                this.caseLabels = JContainer.build(expressions.getBefore(), expressions.getElements().stream().map(J.class::cast).map(JRightPadded::build).collect(toList()), expressions.getMarkers());\n+            } else if (caseLabels != null) {\n+                this.caseLabels = caseLabels;\n             } else {\n-                this.expressions = expressions;\n+                this.caseLabels = JContainer.empty();\n             }\n+            this.guard = guard;\n             this.statements = statements;\n             this.body = body;\n         }\n@@ -1127,7 +1159,7 @@ public static class Padding {\n             }\n \n             public Case withBody(@Nullable JRightPadded<J> body) {\n-                return t.body == body ? t : new Case(t.id, t.prefix, t.markers, t.type, null, t.expressions, t.statements, body);\n+                return t.body == body ? t : new Case(t.id, t.prefix, t.markers, t.type, null, null, t.caseLabels, t.guard, t.statements, body);\n             }\n \n             public JContainer<Statement> getStatements() {\n@@ -1135,15 +1167,38 @@ public JContainer<Statement> getStatements() {\n             }\n \n             public Case withStatements(JContainer<Statement> statements) {\n-                return t.statements == statements ? t : new Case(t.id, t.prefix, t.markers, t.type, null, t.expressions, statements, t.body);\n+                return t.statements == statements ? t : new Case(t.id, t.prefix, t.markers, t.type, null, null, t.caseLabels, t.guard, statements, t.body);\n             }\n \n+            /**\n+             * @deprecated As of Java 21 this is referred to as case labels and can be broader than just Expressions.\n+             * Use {@link #getCaseLabels} and {@link #withCaseLabels(JContainer)} instead.\n+             */\n+            @Deprecated\n             public JContainer<Expression> getExpressions() {\n-                return t.expressions;\n+                return JContainer.build(t.caseLabels.getBefore(), t.caseLabels.getElements().stream().filter(Expression.class::isInstance).map(Expression.class::cast).map(JRightPadded::build).collect(toList()), t.caseLabels.getMarkers());\n             }\n \n+            /**\n+             * @deprecated As of Java 21 this is referred to as case labels and can be broader than just Expressions.\n+             * Use {@link #getCaseLabels} and {@link #withCaseLabels(JContainer)} instead.\n+             */\n+            @Deprecated\n             public Case withExpressions(JContainer<Expression> expressions) {\n-                return t.expressions == expressions ? t : new Case(t.id, t.prefix, t.markers, t.type, null, expressions, t.statements, t.body);\n+                if (t.getExpressions() == expressions) {\n+                    return t;\n+                } else if (t.caseLabels.getElements().stream().allMatch(Expression.class::isInstance)) {\n+                    return new Case(t.id, t.prefix, t.markers, t.type, null, expressions, null, t.guard, t.statements, t.body);\n+                }\n+                throw new IllegalStateException(\""caseLabels contains an entry that is not an Expression, use withCaseLabels instead.\"");\n+            }\n+\n+            public JContainer<J> getCaseLabels() {\n+                return t.caseLabels;\n+            }\n+\n+            public Case withCaseLabels(JContainer<J> caseLabels) {\n+                return t.caseLabels == caseLabels ? t : new Case(t.id, t.prefix, t.markers, t.type, null, null, caseLabels, t.guard, t.statements, t.body);\n             }\n         }\n     }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/JContainer.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/JContainer.java\nindex a299f98da67..c03505a05d2 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/JContainer.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/JContainer.java\n@@ -102,6 +102,7 @@ public enum Location {\n         ANNOTATION_ARGUMENTS(Space.Location.ANNOTATION_ARGUMENTS, JRightPadded.Location.ANNOTATION_ARGUMENT),\n         CASE(Space.Location.CASE, JRightPadded.Location.CASE),\n         CASE_EXPRESSION(Space.Location.CASE_EXPRESSION, JRightPadded.Location.CASE_EXPRESSION),\n+        CASE_LABEL(Space.Location.CASE_LABEL, JRightPadded.Location.CASE_LABEL),\n         IMPLEMENTS(Space.Location.IMPLEMENTS, JRightPadded.Location.IMPLEMENTS),\n         PERMITS(Space.Location.PERMITS, JRightPadded.Location.PERMITS),\n         LANGUAGE_EXTENSION(Space.Location.LANGUAGE_EXTENSION, JRightPadded.Location.LANGUAGE_EXTENSION),\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/JRightPadded.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/JRightPadded.java\nindex 78c65a04a14..b90a9abc19d 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/JRightPadded.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/JRightPadded.java\n@@ -47,6 +47,7 @@ public enum Location {\n         BLOCK_STATEMENT(Space.Location.BLOCK_STATEMENT_SUFFIX),\n         CASE(Space.Location.CASE_SUFFIX),\n         CASE_EXPRESSION(Space.Location.CASE_EXPRESSION),\n+        CASE_LABEL(Space.Location.CASE_LABEL),\n         CASE_BODY(Space.Location.CASE_BODY),\n         CATCH_ALTERNATIVE(Space.Location.CATCH_ALTERNATIVE_SUFFIX),\n         DIMENSION(Space.Location.DIMENSION_SUFFIX),\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/Space.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/Space.java\nindex a334eafa601..a18deff4ce0 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/Space.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/Space.java\n@@ -295,8 +295,8 @@ public String toString() {\n         String whitespaces = printedWs.toString();\n \n         return \""Space(\"" +\n-                \""comments=<\"" + (comments.size() == 1 ? \""1 comment\"" : comments.size() + \"" comments\"") + \"">, \"" +\n-                \""whitespace=\"" + (whitespaces.isEmpty() ? \""<empty>\"" : \""'\"" + whitespaces + \""'\"") + \"")\"";\n+               \""comments=<\"" + (comments.size() == 1 ? \""1 comment\"" : comments.size() + \"" comments\"") + \"">, \"" +\n+               \""whitespace=\"" + (whitespaces.isEmpty() ? \""<empty>\"" : \""'\"" + whitespaces + \""'\"") + \"")\"";\n     }\n \n     public enum Location {\n@@ -325,6 +325,7 @@ public enum Location {\n         CASE,\n         CASE_BODY,\n         CASE_EXPRESSION,\n+        CASE_LABEL,\n         CASE_PREFIX,\n         CASE_SUFFIX,\n         CATCH_ALTERNATIVE_SUFFIX,\n"", ""test_patch"": ""diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/RecordPatternMatchingTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/RecordPatternMatchingTest.java\nnew file mode 100644\nindex 00000000000..6af88fe84f1\n--- /dev/null\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/RecordPatternMatchingTest.java\n@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.tree;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.java.MinimumJava21;\n+import org.openrewrite.test.RecipeSpec;\n+import org.openrewrite.test.RewriteTest;\n+import org.openrewrite.test.TypeValidation;\n+\n+import static org.openrewrite.java.Assertions.java;\n+\n+@MinimumJava21\n+class RecordPatternMatchingTest implements RewriteTest {\n+\n+    @Override\n+    public void defaults(RecipeSpec spec) {\n+        spec.typeValidationOptions(TypeValidation.all().unknown(false));\n+    }\n+\n+    @Test\n+    void shouldParseJava21PatternMatchForRecords() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \""\""\""\n+              record Point(int x, int y) {}\n+              class Test {\n+                  void printSum(Object obj) {\n+                      if (obj instanceof Point(int x, int y)) {\n+                          System.out.println(x+y);\n+                      }\n+                  }\n+              }\n+              \""\""\""\n+          ));\n+    }\n+\n+    @Test\n+    void shouldParseJava21NestedPatternMatchForRecords() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \""\""\""\n+              record Point(int x, int y) {}\n+              enum Color { RED, GREEN, BLUE }\n+              record ColoredPoint(Point p, Color c) {}\n+              record Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}\n+              class Test {\n+                  void printColorOfUpperLeftPoint(Rectangle r) {\n+                      if (r instanceof Rectangle(ColoredPoint(Point p, Color c),\n+                                                 ColoredPoint lr)) {\n+                          System.out.println(c);\n+                      }\n+                  }\n+              }\n+              \""\""\""\n+          ));\n+    }\n+\n+}\n\ndiff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java\nnew file mode 100644\nindex 00000000000..30d89070966\n--- /dev/null\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java\n@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.tree;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.java.MinimumJava21;\n+import org.openrewrite.test.RewriteTest;\n+\n+import static org.openrewrite.java.Assertions.java;\n+\n+@MinimumJava21\n+class SwitchPatternMatchingTest implements RewriteTest {\n+\n+    @Test\n+    void shouldParseJava21PatternSwitch() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \""\""\""\n+              class Test {\n+                  String formatterPatternSwitch(Object obj) {\n+                      return switch (obj) {\n+                          case Integer i -> String.format(\""int %d\"", i);\n+                          case Long l    -> String.format(\""long %d\"", l);\n+                          case Double d  -> String.format(\""double %f\"", d);\n+                          case String s  -> String.format(\""String %s\"", s);\n+                          default        -> obj.toString();\n+                      };\n+                  }\n+              }\n+              \""\""\""\n+          ));\n+    }\n+\n+    @Test\n+    void shouldSupportParsingNullSwitch() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \""\""\""\n+              class Test {\n+                void fooBarWithNull(String s) {\n+                    switch (s) {\n+                        case null -> System.out.println(\""Oops\"");\n+                        case \""Foo\"", \""Bar\"" -> System.out.println(\""Great\"");\n+                        default -> System.out.println(\""Ok\"");\n+                    }\n+                }\n+              }\n+              \""\""\""\n+          ));\n+    }\n+\n+    @Test\n+    void shouldParseJava21EnumSupportInSwitch() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \""\""\""\n+              enum Coin  { HEADS, TAILS }\n+              \n+              class Test {\n+                  void switchEnum(Coin c) {\n+                      switch (c) {\n+                          case HEADS -> System.out.println(\""Heads\"");\n+                          case Coin.TAILS -> System.out.println(\""Tails\"");\n+                      }\n+                  }\n+              }\n+              \""\""\""\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void shouldParseJava21ImprovedEnumSupportInSwitch() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \""\""\""\n+              sealed interface I permits Foo, Bar {}\n+              public enum Foo implements I { A, B }\n+              final class Bar implements I {}\n+              \n+              class Test {\n+                  void switchEnumExtendedType(I c) {\n+                      switch (c) {\n+                          case Foo.A -> System.out.println(\""It's Foo A\"");\n+                          case Foo.B -> System.out.println(\""It's Foo B\"");\n+                          case Bar b -> System.out.println(\""It's Bar\"");\n+                      }\n+                  }\n+              }\n+              \""\""\""\n+          ));\n+    }\n+\n+    @Test\n+    void shouldParseJava21SwitchWithRelaxedTypeRestrictions() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \""\""\""\n+              record Point(int i, int j) {}\n+              enum Color { RED, GREEN, BLUE; }\n+              \n+              class Test {\n+                  void typeTester(Object obj) {\n+                       switch (obj) {\n+                           case null     -> System.out.println(\""null\"");\n+                           case String s -> System.out.println(\""String\"");\n+                           case Color c  -> System.out.println(\""Color: \"" + c.toString());\n+                           case Point p  -> System.out.println(\""Record class: \"" + p.toString());\n+                           case int[] ia -> System.out.println(\""Array of ints of length\"" + ia.length);\n+                           default       -> System.out.println(\""Something else\"");\n+                       }\n+                  }\n+              }\n+              \""\""\""\n+          ));\n+    }\n+\n+    @Test\n+    void shouldParseJava21SwitchWithSpecialCases() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \""\""\""\n+              class Test {\n+                  void integerTester(Integer i) {\n+                       switch (i) {\n+                           case -1, 1 -> System.out.println(\""special\"");\n+                           case Integer j when (j - 1) > -1 -> System.out.println(\""pos\"");\n+                           case Integer j -> System.out.println(\""others\"");\n+                       }\n+                  }\n+              }\n+              \""\""\""\n+          ));\n+    }\n+\n+}\n\ndiff --git a/rewrite-test/src/main/java/org/openrewrite/test/TypeValidation.java b/rewrite-test/src/main/java/org/openrewrite/test/TypeValidation.java\nindex e395db403da..81bbc478a61 100644\n--- a/rewrite-test/src/main/java/org/openrewrite/test/TypeValidation.java\n+++ b/rewrite-test/src/main/java/org/openrewrite/test/TypeValidation.java\n@@ -103,6 +103,12 @@ public class TypeValidation {\n     @Builder.Default\n     private boolean erroneous = true;\n \n+    /**\n+     * Controls whether the LST is validated not to contain any `J.Unknown` elements.\n+     */\n+    @Builder.Default\n+    private boolean unknown = true;\n+\n     /**\n      * Adding messages to execution context is a side effect which makes the recipe run itself stateful.\n      * Potentially allows recipes to interfere with each other in surprising and hard to debug ways.\n@@ -122,7 +128,7 @@ public static TypeValidation all() {\n      * Skip all invariant validation checks.\n      */\n     public static TypeValidation none() {\n-        return new TypeValidation(false, false, false, false, false, false, false, false, o -> false, false, false);\n+        return new TypeValidation(false, false, false, false, false, false, false, false, o -> false, false, false, false);\n     }\n \n     static TypeValidation before(RecipeSpec testMethodSpec, RecipeSpec testClassSpec) {\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
