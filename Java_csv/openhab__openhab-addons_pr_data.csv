metadata
"{""instance_id"": ""openhab__openhab-addons-18391"", ""pr_id"": 18391, ""issue_id"": 16279, ""repo"": ""openhab/openhab-addons"", ""problem_statement"": ""[boschshc] Use MAC address as default bridge thing ID\nAs discussed in https://github.com/openhab/openhab-addons/pull/16211#issuecomment-1890957072, the IP addresses of the Bosch Smart Home Controllers (bridges) should be configured to be static in the local network. But theoretically it is still possible that this IP changes. It is expected that this only happens rarely, in which case users can change the IP address in the configuration manually.\r\n\r\nHowever, we currently propose a thing ID for the bridges in the discovery which is derived from the IP address, e.g. `192-168-0-42`. If the IP changes later, the thing ID (and possibly also all child thing UIDs) would be \""out of sync\"", i.e. still contain the old IP address.\r\n\r\nTherefore it would be preferable if we proposed a unique identifier specific to the bridge (e.g. the MAC address) as thing ID.\r\n\r\nThis change would not affect already created things, only newly discovered/created bridges."", ""issue_word_count"": 163, ""test_files_count"": 3, ""non_test_files_count"": 4, ""pr_changed_files"": [""bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandler.java"", ""bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/dto/PublicInformation.java"", ""bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/discovery/BridgeDiscoveryParticipant.java"", ""bundles/org.openhab.binding.boschshc/src/main/resources/OH-INF/thing/thing-types.xml"", ""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandlerTest.java"", ""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/dto/PublicInformationTest.java"", ""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/discovery/BridgeDiscoveryParticipantTest.java""], ""pr_changed_test_files"": [""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandlerTest.java"", ""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/dto/PublicInformationTest.java"", ""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/discovery/BridgeDiscoveryParticipantTest.java""], ""base_commit"": ""81ea83bc02315d212f076f3308f3123ba23a3df2"", ""head_commit"": ""d1a9ccad23bb6a69511abcbf19e82ac5e856a30c"", ""repo_url"": ""https://github.com/openhab/openhab-addons/pull/18391"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/openhab__openhab-addons/18391"", ""dockerfile"": """", ""pr_merged_at"": ""2025-03-17T19:52:07.000Z"", ""patch"": ""diff --git a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandler.java b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandler.java\nindex d3fef358fcba0..dc9ea60782a6f 100644\n--- a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandler.java\n+++ b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandler.java\n@@ -21,7 +21,9 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n@@ -88,12 +90,16 @@\n @NonNullByDefault\n public class BridgeHandler extends BaseBridgeHandler {\n \n+    private final Logger logger = LoggerFactory.getLogger(BridgeHandler.class);\n+\n+    public static final String THING_PROPERTY_SHC_GENERATION = \""shcGeneration\"";\n+    public static final String THING_PROPERTY_API_VERSIONS = \""apiVersions\"";\n+    public static final String CONFIGURATION_PARAMETER_IP_ADDRESS = \""ipAddress\"";\n+\n     private static final String HTTP_CLIENT_NOT_INITIALIZED = \""HttpClient not initialized\"";\n \n     private static final Duration ROOM_CACHE_DURATION = Duration.ofMinutes(2);\n \n-    private final Logger logger = LoggerFactory.getLogger(BridgeHandler.class);\n-\n     /**\n      * Handler to do long polling.\n      */\n@@ -286,6 +292,8 @@ private void scheduleInitialAccess(BoschHttpClient httpClient) {\n                 return;\n             }\n \n+            updateThingProperties();\n+\n             // do thing discovery after pairing\n             final ThingDiscoveryService discovery = thingDiscoveryService;\n             if (discovery != null) {\n@@ -302,6 +310,23 @@ private void scheduleInitialAccess(BoschHttpClient httpClient) {\n         }\n     }\n \n+    private void updateThingProperties() {\n+        try {\n+            PublicInformation publicInformation = getPublicInformation();\n+            @Nullable\n+            Map<String, String> properties = new HashMap<>();\n+            properties.put(Thing.PROPERTY_MAC_ADDRESS, publicInformation.macAddress);\n+            properties.put(THING_PROPERTY_SHC_GENERATION, publicInformation.shcGeneration);\n+            properties.put(THING_PROPERTY_API_VERSIONS, publicInformation.getApiVersionsAsCommaSeparatedList());\n+            updateProperties(properties);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            logger.warn(\""Thread was interrupted while retrieving public information to update thing properties.\"", e);\n+        } catch (BoschSHCException | ExecutionException | TimeoutException e) {\n+            logger.warn(\""Error while retrieving public information to update thing properties.\"", e);\n+        }\n+    }\n+\n     private void startLongPolling(BoschHttpClient httpClient) {\n         try {\n             this.longPolling.start(httpClient);\n\ndiff --git a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/dto/PublicInformation.java b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/dto/PublicInformation.java\nindex f3162fba7adc4..e99b0e1d0f37f 100644\n--- a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/dto/PublicInformation.java\n+++ b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/dto/PublicInformation.java\n@@ -13,6 +13,7 @@\n package org.openhab.binding.boschshc.internal.devices.bridge.dto;\n \n import java.util.List;\n+import java.util.stream.Collectors;\n \n /**\n  * Public Information of the controller.\n@@ -20,32 +21,42 @@\n  *\n  * Currently, only the ipAddress is used for discovery. More fields can be added on demand.\n  * <p>\n- * Json example:\n+ * JSON example:\n  *\n  * <pre>\n  * {\n- * \""apiVersions\"":[\""1.2\"",\""2.1\""],\n- * ...\n- * \""shcIpAddress\"":\""192.168.1.2\"",\n- * ...\n+ *     \""apiVersions\"": [\""2.9\"",\""3.2\""],\n+ *     \""macAddress\"": \""64-da-a0-ab-cd-ef\"",\n+ *     \""shcIpAddress\"": \""192.168.0.123\"",\n+ *     ...\n+ *     \""shcGeneration\"": \""SHC_1\""\n  * }\n  * </pre>\n  *\n  * @author Gerd Zanker - Initial contribution\n  */\n public class PublicInformation {\n-    public PublicInformation() {\n-        this.shcIpAddress = \""\"";\n-        this.shcGeneration = \""\"";\n-    }\n-\n     public List<String> apiVersions;\n+    public String macAddress;\n     public String shcIpAddress;\n     public String shcGeneration;\n     public SoftwareUpdateState softwareUpdateState;\n \n     public static boolean isValid(PublicInformation obj) {\n-        return obj != null && obj.shcIpAddress != null && obj.shcGeneration != null && obj.apiVersions != null\n-                && SoftwareUpdateState.isValid(obj.softwareUpdateState);\n+        return obj != null && obj.macAddress != null && obj.shcIpAddress != null && obj.shcGeneration != null\n+                && obj.apiVersions != null && SoftwareUpdateState.isValid(obj.softwareUpdateState);\n+    }\n+\n+    /**\n+     * Returns the API versions as comma-separated list.\n+     * \n+     * @return a comma-separated list of API versions or <code>null</code> if {@link #apiVersions} is <code>null</code>.\n+     */\n+    public String getApiVersionsAsCommaSeparatedList() {\n+        if (apiVersions == null) {\n+            return null;\n+        }\n+\n+        return apiVersions.stream().collect(Collectors.joining(\"", \""));\n     }\n }\n\ndiff --git a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/discovery/BridgeDiscoveryParticipant.java b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/discovery/BridgeDiscoveryParticipant.java\nindex 735829146968e..9d811be0c3dad 100644\n--- a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/discovery/BridgeDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/discovery/BridgeDiscoveryParticipant.java\n@@ -30,12 +30,14 @@\n import org.eclipse.jetty.util.ssl.SslContextFactory;\n import org.openhab.binding.boschshc.internal.devices.BoschSHCBindingConstants;\n import org.openhab.binding.boschshc.internal.devices.bridge.BoschHttpClient;\n+import org.openhab.binding.boschshc.internal.devices.bridge.BridgeHandler;\n import org.openhab.binding.boschshc.internal.devices.bridge.dto.PublicInformation;\n import org.openhab.core.cache.ExpiringCacheMap;\n import org.openhab.core.config.discovery.DiscoveryResult;\n import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.ThingTypeUID;\n import org.openhab.core.thing.ThingUID;\n import org.osgi.service.component.annotations.Activate;\n@@ -145,9 +147,14 @@ public String getServiceType() {\n \n         return DiscoveryResultBuilder.create(uid)\n                 .withLabel(\""Bosch Smart Home Controller (\"" + publicInformation.shcIpAddress + \"")\"")\n-                .withProperty(\""ipAddress\"", publicInformation.shcIpAddress)\n-                .withProperty(\""shcGeneration\"", publicInformation.shcGeneration)\n-                .withProperty(\""apiVersions\"", publicInformation.apiVersions).withTTL(TTL_SECONDS).build();\n+                // note: the IP address will become a configuration parameter, not a thing property\n+                // refer to https://github.com/openhab/openhab-addons/pull/18391#discussion_r1997703718 for more details\n+                .withProperty(BridgeHandler.CONFIGURATION_PARAMETER_IP_ADDRESS, publicInformation.shcIpAddress)\n+                .withProperty(Thing.PROPERTY_MAC_ADDRESS, publicInformation.macAddress)\n+                .withProperty(BridgeHandler.THING_PROPERTY_SHC_GENERATION, publicInformation.shcGeneration)\n+                .withProperty(BridgeHandler.THING_PROPERTY_API_VERSIONS,\n+                        publicInformation.getApiVersionsAsCommaSeparatedList())\n+                .withRepresentationProperty(Thing.PROPERTY_MAC_ADDRESS).withTTL(TTL_SECONDS).build();\n     }\n \n     private @Nullable String getFirstIPAddress(ServiceInfo serviceInfo) {\n@@ -186,8 +193,11 @@ public String getServiceType() {\n             @Nullable\n             PublicInformation publicInformation = getOrComputePublicInformation(ipAddress);\n             if (publicInformation != null) {\n-                String resolvedIpAddress = publicInformation.shcIpAddress;\n-                return new ThingUID(BoschSHCBindingConstants.THING_TYPE_SHC, resolvedIpAddress.replace('.', '-'));\n+                String macAddress = publicInformation.macAddress;\n+                if (macAddress == null) {\n+                    return null;\n+                }\n+                return new ThingUID(BoschSHCBindingConstants.THING_TYPE_SHC, macAddress.replace(\""-\"", \""\""));\n             }\n         }\n         return null;\n\ndiff --git a/bundles/org.openhab.binding.boschshc/src/main/resources/OH-INF/thing/thing-types.xml b/bundles/org.openhab.binding.boschshc/src/main/resources/OH-INF/thing/thing-types.xml\nindex f61ce3cc00a90..b6463ccf2cffa 100644\n--- a/bundles/org.openhab.binding.boschshc/src/main/resources/OH-INF/thing/thing-types.xml\n+++ b/bundles/org.openhab.binding.boschshc/src/main/resources/OH-INF/thing/thing-types.xml\n@@ -18,6 +18,8 @@\n \t\t\t<property name=\""thingTypeVersion\"">1</property>\n \t\t</properties>\n \n+\t\t<representation-property>macAddress</representation-property>\n+\n \t\t<config-description-ref uri=\""thing-type:boschshc:bridge\""/>\n \t</bridge-type>\n \n"", ""test_patch"": ""diff --git a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandlerTest.java b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandlerTest.java\nindex 4e8d7a2b8c2ca..cf045bee8de5f 100644\n--- a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandlerTest.java\n+++ b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandlerTest.java\n@@ -12,28 +12,13 @@\n  */\n package org.openhab.binding.boschshc.internal.devices.bridge;\n \n-import static org.hamcrest.CoreMatchers.is;\n-import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.CoreMatchers.*;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.ArgumentMatchers.*;\n import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyString;\n-import static org.mockito.ArgumentMatchers.argThat;\n-import static org.mockito.ArgumentMatchers.contains;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.ArgumentMatchers.isNull;\n-import static org.mockito.ArgumentMatchers.same;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyNoInteractions;\n-import static org.mockito.Mockito.verifyNoMoreInteractions;\n-import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.*;\n \n import java.io.IOException;\n import java.nio.file.Files;\n@@ -235,6 +220,14 @@ void initialAccessAccessPossible()\n         when(devicesRequest.send()).thenReturn(devicesResponse);\n         when(httpClient.createRequest(contains(\""/devices\""), same(HttpMethod.GET))).thenReturn(devicesRequest);\n \n+        PublicInformation publicInformation = new PublicInformation();\n+        publicInformation.shcIpAddress = \""192.168.0.123\"";\n+        publicInformation.macAddress = \""64-da-a0-ab-cd-ef\"";\n+        publicInformation.shcGeneration = \""SHC_1\"";\n+        publicInformation.apiVersions = List.of(\""2.9\"", \""3.2\"");\n+        when(httpClient.sendRequest(any(), same(PublicInformation.class), any(), isNull()))\n+                .thenReturn(publicInformation);\n+\n         SubscribeResult subscribeResult = new SubscribeResult();\n         when(httpClient.sendRequest(any(), same(SubscribeResult.class), any(), any())).thenReturn(subscribeResult);\n \n@@ -249,6 +242,12 @@ void initialAccessAccessPossible()\n \n         verify(thingHandlerCallback).statusUpdated(any(),\n                 eq(ThingStatusInfoBuilder.create(ThingStatus.ONLINE, ThingStatusDetail.NONE).build()));\n+\n+        verify(thing).setProperty(Thing.PROPERTY_MAC_ADDRESS, \""64-da-a0-ab-cd-ef\"");\n+        verify(thing).setProperty(BridgeHandler.THING_PROPERTY_API_VERSIONS, \""2.9, 3.2\"");\n+\n+        verify(thingHandlerCallback).thingUpdated(thing);\n+\n         verify(thingDiscoveryListener).doScan();\n     }\n \n\ndiff --git a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/dto/PublicInformationTest.java b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/dto/PublicInformationTest.java\nnew file mode 100644\nindex 0000000000000..244152837db96\n--- /dev/null\n+++ b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/dto/PublicInformationTest.java\n@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2010-2025 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.boschshc.internal.devices.bridge.dto;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Unit tests for {@link PublicInformation}.\n+ * \n+ * @author David Pace - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+class PublicInformationTest {\n+\n+    private @NonNullByDefault({}) PublicInformation fixture;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        fixture = new PublicInformation();\n+        fixture.shcIpAddress = \""192.168.0.123\"";\n+        fixture.macAddress = \""64-da-a0-ab-cd-ef\"";\n+        fixture.shcGeneration = \""SHC_1\"";\n+        fixture.apiVersions = List.of(\""2.9\"", \""3.2\"");\n+    }\n+\n+    @Test\n+    void getApiVersionsAsCommaSeparatedList() {\n+        assertEquals(\""2.9, 3.2\"", fixture.getApiVersionsAsCommaSeparatedList());\n+        fixture.apiVersions = null;\n+        assertNull(fixture.getApiVersionsAsCommaSeparatedList());\n+    }\n+}\n\ndiff --git a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/discovery/BridgeDiscoveryParticipantTest.java b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/discovery/BridgeDiscoveryParticipantTest.java\nindex 00b938f079fb0..1a24f842973d5 100644\n--- a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/discovery/BridgeDiscoveryParticipantTest.java\n+++ b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/discovery/BridgeDiscoveryParticipantTest.java\n@@ -20,14 +20,13 @@\n import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertSame;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyLong;\n-import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.*;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import java.net.ConnectException;\n+import java.util.Map;\n import java.util.concurrent.ExecutionException;\n \n import javax.jmdns.ServiceInfo;\n@@ -48,9 +47,11 @@\n import org.mockito.junit.jupiter.MockitoSettings;\n import org.mockito.quality.Strictness;\n import org.openhab.binding.boschshc.internal.devices.BoschSHCBindingConstants;\n+import org.openhab.binding.boschshc.internal.devices.bridge.BridgeHandler;\n import org.openhab.binding.boschshc.internal.devices.bridge.dto.PublicInformation;\n import org.openhab.core.config.discovery.DiscoveryResult;\n import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.ThingUID;\n \n /**\n@@ -86,8 +87,14 @@ public void beforeEach() throws Exception {\n         when(otherDevice.getHostAddresses()).thenReturn(new String[] { \""192.168.0.1\"" });\n         when(otherDevice.getName()).thenReturn(\""Other Device\"");\n \n-        when(contentResponse.getContentAsString()).thenReturn(\n-                \""{\\\""apiVersions\\\"":[\\\""2.9\\\"",\\\""3.2\\\""], \\\""shcIpAddress\\\"":\\\""192.168.0.123\\\"", \\\""shcGeneration\\\"":\\\""SHC_1\\\""}\"");\n+        when(contentResponse.getContentAsString()).thenReturn(\""\""\""\n+                {\n+                    \""apiVersions\"": [\""2.9\"",\""3.2\""],\n+                    \""macAddress\"": \""64-da-a0-ab-cd-ef\"",\n+                    \""shcIpAddress\"": \""192.168.0.123\"",\n+                    \""shcGeneration\"": \""SHC_1\""\n+                }\n+                \""\""\"");\n         when(contentResponse.getStatus()).thenReturn(HttpStatus.OK_200);\n \n         Request mockRequest = mock(Request.class);\n@@ -124,30 +131,36 @@ void testGetSupportedThingTypeUIDs() {\n      *\n      */\n     @Test\n-    void testGetServiceType() throws Exception {\n+    void testGetServiceType() {\n         assertThat(fixture.getServiceType(), is(\""_http._tcp.local.\""));\n     }\n \n     @Test\n-    void testCreateResult() throws Exception {\n+    void testCreateResult() {\n         DiscoveryResult result = fixture.createResult(shcBridge);\n \n         assertNotNull(result);\n         assertThat(result.getBindingId(), is(BoschSHCBindingConstants.BINDING_ID));\n-        assertThat(result.getThingUID().getId(), is(\""192-168-0-123\""));\n+        assertThat(result.getThingUID().getId(), is(\""64daa0abcdef\""));\n         assertThat(result.getThingTypeUID().getId(), is(\""shc\""));\n         assertThat(result.getLabel(), is(\""Bosch Smart Home Controller (192.168.0.123)\""));\n+        Map<String, Object> properties = result.getProperties();\n+        assertThat(properties.get(BridgeHandler.CONFIGURATION_PARAMETER_IP_ADDRESS), is(\""192.168.0.123\""));\n+        assertThat(properties.get(Thing.PROPERTY_MAC_ADDRESS), is(\""64-da-a0-ab-cd-ef\""));\n+        assertThat(properties.get(BridgeHandler.THING_PROPERTY_SHC_GENERATION), is(\""SHC_1\""));\n+        assertThat(properties.get(BridgeHandler.THING_PROPERTY_API_VERSIONS), is(\""2.9, 3.2\""));\n+        assertThat(result.getRepresentationProperty(), is(Thing.PROPERTY_MAC_ADDRESS));\n     }\n \n     @Test\n-    void testCreateResultOtherDevice() throws Exception {\n+    void testCreateResultOtherDevice() {\n         DiscoveryResult result = fixture.createResult(otherDevice);\n \n         assertNull(result);\n     }\n \n     @Test\n-    void testCreateResultNoIPAddress() throws Exception {\n+    void testCreateResultNoIPAddress() {\n         when(shcBridge.getHostAddresses()).thenReturn(new String[] { \""\"" });\n \n         DiscoveryResult result = fixture.createResult(shcBridge);\n@@ -156,21 +169,21 @@ void testCreateResultNoIPAddress() throws Exception {\n     }\n \n     @Test\n-    void testGetThingUID() throws Exception {\n+    void testGetThingUID() {\n         ThingUID thingUID = fixture.getThingUID(shcBridge);\n \n         assertNotNull(thingUID);\n         assertThat(thingUID.getBindingId(), is(BoschSHCBindingConstants.BINDING_ID));\n-        assertThat(thingUID.getId(), is(\""192-168-0-123\""));\n+        assertThat(thingUID.getId(), is(\""64daa0abcdef\""));\n     }\n \n     @Test\n-    void testGetThingUIDOtherDevice() throws Exception {\n+    void testGetThingUIDOtherDevice() {\n         assertNull(fixture.getThingUID(otherDevice));\n     }\n \n     @Test\n-    void testGetBridgeAddress() throws Exception {\n+    void testGetBridgeAddress() {\n         @Nullable\n         PublicInformation bridgeInformation = fixture.discoverBridge(\""192.168.0.123\"");\n \n@@ -179,12 +192,12 @@ void testGetBridgeAddress() throws Exception {\n     }\n \n     @Test\n-    void testGetBridgeAddressOtherDevice() throws Exception {\n+    void testGetBridgeAddressOtherDevice() {\n         assertThat(fixture.discoverBridge(\""192.168.0.1\""), is(nullValue()));\n     }\n \n     @Test\n-    void testGetPublicInformationFromPossibleBridgeAddress() throws Exception {\n+    void testGetPublicInformationFromPossibleBridgeAddress() {\n         @Nullable\n         PublicInformation bridgeInformation = fixture.getPublicInformationFromPossibleBridgeAddress(\""192.168.0.123\"");\n \n@@ -193,7 +206,7 @@ void testGetPublicInformationFromPossibleBridgeAddress() throws Exception {\n     }\n \n     @Test\n-    void testGetPublicInformationFromPossibleBridgeAddressInvalidContent() throws Exception {\n+    void testGetPublicInformationFromPossibleBridgeAddressInvalidContent() {\n         when(contentResponse.getContentAsString()).thenReturn(\""{\\\""nothing\\\"":\\\""useful\\\""}\"");\n \n         fixture = new BridgeDiscoveryParticipant(mockHttpClient);\n@@ -202,7 +215,7 @@ void testGetPublicInformationFromPossibleBridgeAddressInvalidContent() throws Ex\n     }\n \n     @Test\n-    void testGetPublicInformationFromPossibleBridgeAddressInvalidStatus() throws Exception {\n+    void testGetPublicInformationFromPossibleBridgeAddressInvalidStatus() {\n         when(contentResponse.getStatus()).thenReturn(HttpStatus.BAD_REQUEST_400);\n \n         fixture = new BridgeDiscoveryParticipant(mockHttpClient);\n@@ -211,7 +224,7 @@ void testGetPublicInformationFromPossibleBridgeAddressInvalidStatus() throws Exc\n     }\n \n     @Test\n-    void testGetOrComputePublicInformation() throws Exception {\n+    void testGetOrComputePublicInformation() {\n         @Nullable\n         PublicInformation result = fixture.getOrComputePublicInformation(\""192.168.0.123\"");\n         assertNotNull(result);\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""openhab__openhab-addons-17893"", ""pr_id"": 17893, ""issue_id"": 16599, ""repo"": ""openhab/openhab-addons"", ""problem_statement"": ""[boschshc] Location properties are not updated\nIf devices are moved to a different room in the Bosch Smart Home app, the location change is not reflected in the corresponding thing properties. This was originally reported [here](https://github.com/openhab/openhab-addons/issues/16241#issuecomment-2029566111) by @mike-bike:\r\n\r\n> Minor observation: Dimmer Device shows the Bosch Room as Location property in the thing. Seems to be a new feature. However, it does not get any updates. In the Bosch app I have moved the device into a new room, but the change is not reflected in the Thing - even a OpenHAB restart does not force an update... I'd suggest removing that property if updates are not coming through.\r\n\r\n## Expected Behavior\r\nWhenever a device location is changed in the Bosch Smart Home app, the corresponding thing property should be changed as well.\r\n\r\n## Current Behavior\r\nOnce a thing is added, the location property does not change anymore.\r\n\r\n## Steps to Reproduce (for Bugs)\r\n1. Create a thing (bug was reported for a dimmer device)\r\n2. Inspect the location property of the thing\r\n3. Move the device to a different room using the Bosch Smart Home app\r\n4. Inspect the location property again. It did not change accordingly.\r\n\r\n## Context\r\nMinor issue, does not affect the actual thing / channel logics."", ""issue_word_count"": 216, ""test_files_count"": 4, ""non_test_files_count"": 4, ""pr_changed_files"": [""bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/BoschSHCBindingConstants.java"", ""bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/BoschSHCDeviceHandler.java"", ""bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandler.java"", ""bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/discovery/ThingDiscoveryService.java"", ""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/AbstractBoschSHCDeviceHandlerTest.java"", ""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandlerTest.java"", ""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/relay/RelayHandlerTest.java"", ""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/discovery/ThingDiscoveryServiceTest.java""], ""pr_changed_test_files"": [""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/AbstractBoschSHCDeviceHandlerTest.java"", ""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandlerTest.java"", ""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/relay/RelayHandlerTest.java"", ""bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/discovery/ThingDiscoveryServiceTest.java""], ""base_commit"": ""d7abc08cfd6d7bb60a4ffc558341746d395e631b"", ""head_commit"": ""a21e15bb35966f246d205968e6e29856a70d29da"", ""repo_url"": ""https://github.com/openhab/openhab-addons/pull/17893"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/openhab__openhab-addons/17893"", ""dockerfile"": """", ""pr_merged_at"": ""2025-02-20T21:01:19.000Z"", ""patch"": ""diff --git a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/BoschSHCBindingConstants.java b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/BoschSHCBindingConstants.java\nindex 7ce6cf44f0cd5..de8f267172361 100644\n--- a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/BoschSHCBindingConstants.java\n+++ b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/BoschSHCBindingConstants.java\n@@ -134,4 +134,8 @@ private BoschSHCBindingConstants() {\n \n     // static device/service names\n     public static final String SERVICE_INTRUSION_DETECTION = \""intrusionDetectionSystem\"";\n+\n+    // thing properties\n+    public static final String PROPERTY_LOCATION_LEGACY = \""Location\"";\n+    public static final String PROPERTY_LOCATION = \""location\"";\n }\n\ndiff --git a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/BoschSHCDeviceHandler.java b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/BoschSHCDeviceHandler.java\nindex e06f48aa17f68..d8d49ac19ebce 100644\n--- a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/BoschSHCDeviceHandler.java\n+++ b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/BoschSHCDeviceHandler.java\n@@ -12,6 +12,10 @@\n  */\n package org.openhab.binding.boschshc.internal.devices;\n \n+import static org.openhab.binding.boschshc.internal.devices.BoschSHCBindingConstants.PROPERTY_LOCATION;\n+import static org.openhab.binding.boschshc.internal.devices.BoschSHCBindingConstants.PROPERTY_LOCATION_LEGACY;\n+\n+import java.util.Map;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeoutException;\n \n@@ -83,9 +87,42 @@ public void initialize() {\n      *         otherwise\n      */\n     protected boolean processDeviceInfo(Device deviceInfo) {\n+        try {\n+            updateLocationPropertiesIfApplicable(deviceInfo);\n+        } catch (BoschSHCException e) {\n+            logger.warn(\""Error while updating location properties for thing {}.\"", getThing().getUID(), e);\n+        }\n+        // do not cancel thing initialization if location properties cannot be updated\n         return true;\n     }\n \n+    private void updateLocationPropertiesIfApplicable(Device deviceInfo) throws BoschSHCException {\n+        Map<String, String> thingProperties = getThing().getProperties();\n+        removeLegacyLocationPropertyIfApplicable(thingProperties);\n+        updateLocationPropertyIfApplicable(thingProperties, deviceInfo);\n+    }\n+\n+    private void updateLocationPropertyIfApplicable(Map<String, String> thingProperties, Device deviceInfo)\n+            throws BoschSHCException {\n+        String roomName = getBridgeHandler().resolveRoomId(deviceInfo.roomId);\n+        if (roomName != null) {\n+            String currentLocation = thingProperties.get(PROPERTY_LOCATION);\n+            if (!roomName.equals(currentLocation)) {\n+                logger.debug(\""Updating property '{}' of thing {} to '{}'.\"", PROPERTY_LOCATION, getThing().getUID(),\n+                        roomName);\n+                updateProperty(PROPERTY_LOCATION, roomName);\n+            }\n+        }\n+    }\n+\n+    private void removeLegacyLocationPropertyIfApplicable(Map<String, String> thingProperties) {\n+        if (thingProperties.containsKey(PROPERTY_LOCATION_LEGACY)) {\n+            logger.debug(\""Removing legacy property '{}' from thing {}.\"", PROPERTY_LOCATION_LEGACY, getThing().getUID());\n+            // null value indicates that the property should be removed\n+            updateProperty(PROPERTY_LOCATION_LEGACY, null);\n+        }\n+    }\n+\n     /**\n      * Attempts to obtain information about the device with the specified ID via a REST call.\n      * <p>\n\ndiff --git a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandler.java b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandler.java\nindex 1fc7e0ce27635..d3fef358fcba0 100644\n--- a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandler.java\n+++ b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandler.java\n@@ -17,6 +17,7 @@\n import static org.eclipse.jetty.http.HttpMethod.PUT;\n \n import java.lang.reflect.Type;\n+import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n@@ -54,6 +55,7 @@\n import org.openhab.binding.boschshc.internal.serialization.GsonUtils;\n import org.openhab.binding.boschshc.internal.services.dto.BoschSHCServiceState;\n import org.openhab.binding.boschshc.internal.services.dto.JsonRestExceptionResponse;\n+import org.openhab.core.cache.ExpiringCache;\n import org.openhab.core.library.types.StringType;\n import org.openhab.core.thing.Bridge;\n import org.openhab.core.thing.Channel;\n@@ -88,6 +90,8 @@ public class BridgeHandler extends BaseBridgeHandler {\n \n     private static final String HTTP_CLIENT_NOT_INITIALIZED = \""HttpClient not initialized\"";\n \n+    private static final Duration ROOM_CACHE_DURATION = Duration.ofMinutes(2);\n+\n     private final Logger logger = LoggerFactory.getLogger(BridgeHandler.class);\n \n     /**\n@@ -107,13 +111,22 @@ public class BridgeHandler extends BaseBridgeHandler {\n \n     /**\n      * SHC thing/device discovery service instance.\n-     * Registered and unregistered if service is actived/deactived.\n+     * Registered and unregistered if service is activated/deactivated.\n      * Used to scan for things after bridge is paired with SHC.\n      */\n     private @Nullable ThingDiscoveryService thingDiscoveryService;\n \n     private final ScenarioHandler scenarioHandler;\n \n+    private ExpiringCache<List<Room>> roomCache = new ExpiringCache<>(ROOM_CACHE_DURATION, () -> {\n+        try {\n+            return getRooms();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            return null;\n+        }\n+    });\n+\n     public BridgeHandler(Bridge bridge) {\n         super(bridge);\n         scenarioHandler = new ScenarioHandler();\n@@ -437,6 +450,24 @@ public List<Room> getRooms() throws InterruptedException {\n         }\n     }\n \n+    public @Nullable List<Room> getRoomsWithCache() {\n+        return roomCache.getValue();\n+    }\n+\n+    public @Nullable String resolveRoomId(@Nullable String roomId) {\n+        if (roomId == null) {\n+            return null;\n+        }\n+\n+        @Nullable\n+        List<Room> rooms = getRoomsWithCache();\n+        if (rooms != null) {\n+            return rooms.stream().filter(r -> r.id.equals(roomId)).map(r -> r.name).findAny().orElse(null);\n+        }\n+\n+        return null;\n+    }\n+\n     /**\n      * Get public information from Bosch SHC.\n      */\n\ndiff --git a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/discovery/ThingDiscoveryService.java b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/discovery/ThingDiscoveryService.java\nindex 0833c96ddb853..d1a1dd6a4c0c4 100644\n--- a/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/discovery/ThingDiscoveryService.java\n+++ b/bundles/org.openhab.binding.boschshc/src/main/java/org/openhab/binding/boschshc/internal/discovery/ThingDiscoveryService.java\n@@ -243,7 +243,7 @@ protected void addDevice(Device device, String roomName) {\n         discoveryResult.withBridge(thingHandler.getThing().getUID());\n \n         if (!roomName.isEmpty()) {\n-            discoveryResult.withProperty(\""Location\"", roomName);\n+            discoveryResult.withProperty(BoschSHCBindingConstants.PROPERTY_LOCATION, roomName);\n         }\n         thingDiscovered(discoveryResult.build());\n \n"", ""test_patch"": ""diff --git a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/AbstractBoschSHCDeviceHandlerTest.java b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/AbstractBoschSHCDeviceHandlerTest.java\nindex a9a527c825cdd..198efdae0ab14 100644\n--- a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/AbstractBoschSHCDeviceHandlerTest.java\n+++ b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/AbstractBoschSHCDeviceHandlerTest.java\n@@ -14,14 +14,20 @@\n \n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeoutException;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.MethodSource;\n import org.openhab.binding.boschshc.internal.devices.bridge.dto.Device;\n@@ -42,11 +48,34 @@\n public abstract class AbstractBoschSHCDeviceHandlerTest<T extends BoschSHCDeviceHandler>\n         extends AbstractBoschSHCHandlerTest<T> {\n \n+    protected static final String TAG_LEGACY_LOCATION_PROPERTY = \""LegacyLocationProperty\"";\n+    protected static final String TAG_LOCATION_PROPERTY = \""LocationProperty\"";\n+    protected static final String DEFAULT_ROOM_ID = \""hz_1\"";\n+\n     @Override\n     protected void configureDevice(Device device) {\n         super.configureDevice(device);\n \n         device.id = getDeviceID();\n+        device.roomId = DEFAULT_ROOM_ID;\n+    }\n+\n+    @Override\n+    protected void beforeHandlerInitialization(TestInfo testInfo) {\n+        super.beforeHandlerInitialization(testInfo);\n+        Set<String> tags = testInfo.getTags();\n+        if (tags.contains(TAG_LEGACY_LOCATION_PROPERTY) || tags.contains(TAG_LOCATION_PROPERTY)) {\n+            Map<String, String> properties = new HashMap<>();\n+            when(getThing().getProperties()).thenReturn(properties);\n+\n+            if (tags.contains(TAG_LEGACY_LOCATION_PROPERTY)) {\n+                properties.put(BoschSHCBindingConstants.PROPERTY_LOCATION_LEGACY, \""Living Room\"");\n+            }\n+\n+            if (tags.contains(TAG_LOCATION_PROPERTY)) {\n+                when(getBridgeHandler().resolveRoomId(DEFAULT_ROOM_ID)).thenReturn(\""Kitchen\"");\n+            }\n+        }\n     }\n \n     @Override\n@@ -80,4 +109,44 @@ void initializeHandleExceptionDuringDeviceInfoRestCall(Exception exception)\n                 argThat(status -> status.getStatus().equals(ThingStatus.OFFLINE)\n                         && status.getStatusDetail().equals(ThingStatusDetail.CONFIGURATION_ERROR)));\n     }\n+\n+    @Tag(TAG_LEGACY_LOCATION_PROPERTY)\n+    @Test\n+    protected void deleteLegacyLocationProperty() {\n+        verify(getThing()).setProperty(BoschSHCBindingConstants.PROPERTY_LOCATION_LEGACY, null);\n+        verify(getCallback()).thingUpdated(getThing());\n+    }\n+\n+    @Tag(TAG_LOCATION_PROPERTY)\n+    @Test\n+    protected void locationPropertyDidNotChange() {\n+        verify(getThing()).setProperty(BoschSHCBindingConstants.PROPERTY_LOCATION, \""Kitchen\"");\n+        verify(getCallback()).thingUpdated(getThing());\n+\n+        getThing().getProperties().put(BoschSHCBindingConstants.PROPERTY_LOCATION, \""Kitchen\"");\n+\n+        // re-initialize\n+        getFixture().initialize();\n+\n+        verify(getThing()).setProperty(BoschSHCBindingConstants.PROPERTY_LOCATION, \""Kitchen\"");\n+        verify(getCallback()).thingUpdated(getThing());\n+    }\n+\n+    @Tag(TAG_LOCATION_PROPERTY)\n+    @Test\n+    protected void locationPropertyDidChange() {\n+        verify(getThing()).setProperty(BoschSHCBindingConstants.PROPERTY_LOCATION, \""Kitchen\"");\n+        verify(getCallback()).thingUpdated(getThing());\n+\n+        getThing().getProperties().put(BoschSHCBindingConstants.PROPERTY_LOCATION, \""Kitchen\"");\n+\n+        getDevice().roomId = \""hz_2\"";\n+        when(getBridgeHandler().resolveRoomId(\""hz_2\"")).thenReturn(\""Dining Room\"");\n+\n+        // re-initialize\n+        getFixture().initialize();\n+\n+        verify(getThing()).setProperty(BoschSHCBindingConstants.PROPERTY_LOCATION, \""Dining Room\"");\n+        verify(getCallback(), times(2)).thingUpdated(getThing());\n+    }\n }\n\ndiff --git a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandlerTest.java b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandlerTest.java\nindex aa3597ddda429..4e8d7a2b8c2ca 100644\n--- a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandlerTest.java\n+++ b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/bridge/BridgeHandlerTest.java\n@@ -12,6 +12,8 @@\n  */\n package org.openhab.binding.boschshc.internal.devices.bridge;\n \n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.nullValue;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -1126,4 +1128,33 @@ void getPublicInformation() throws InterruptedException, BoschSHCException, Exec\n         verify(httpClient).createRequest(any(), same(HttpMethod.GET));\n         verify(httpClient).sendRequest(any(), same(PublicInformation.class), any(), isNull());\n     }\n+\n+    @Test\n+    void resolveRoomId() throws InterruptedException, TimeoutException, ExecutionException {\n+        Request request = mock(Request.class);\n+        when(httpClient.createRequest(any(), eq(HttpMethod.GET))).thenReturn(request);\n+        ContentResponse contentResponse = mock(ContentResponse.class);\n+        when(request.send()).thenReturn(contentResponse);\n+        when(contentResponse.getStatus()).thenReturn(200);\n+        String roomsJson = \""\""\""\n+                [\n+                    {\n+                        \""@type\"": \""room\"",\n+                        \""id\"": \""hz_1\"",\n+                        \""iconId\"": \""icon_room_living_room\"",\n+                        \""name\"": \""Living Room\""\n+                    },\n+                    {\n+                        \""@type\"": \""room\"",\n+                        \""id\"": \""hz_2\"",\n+                        \""iconId\"": \""icon_room_dining_room\"",\n+                        \""name\"": \""Dining Room\""\n+                    }\n+                ]\n+                \""\""\"";\n+        when(contentResponse.getContentAsString()).thenReturn(roomsJson);\n+        assertThat(fixture.resolveRoomId(\""hz_1\""), is(\""Living Room\""));\n+        assertThat(fixture.resolveRoomId(\""hz_2\""), is(\""Dining Room\""));\n+        assertThat(fixture.resolveRoomId(null), is(nullValue()));\n+    }\n }\n\ndiff --git a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/relay/RelayHandlerTest.java b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/relay/RelayHandlerTest.java\nindex fe60dcbacb122..644e38c7c4493 100644\n--- a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/relay/RelayHandlerTest.java\n+++ b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/devices/relay/RelayHandlerTest.java\n@@ -12,8 +12,11 @@\n  */\n package org.openhab.binding.boschshc.internal.devices.relay;\n \n+import static org.hamcrest.CoreMatchers.not;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n+import static org.hamcrest.collection.IsMapContaining.hasKey;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.ArgumentMatchers.eq;\n@@ -376,4 +379,55 @@ void testUpdateModePropertyIfApplicableImpulseSwitchMode() {\n         verify(getCallback(), times(2)).thingUpdated(argThat(t -> ImpulseSwitchService.IMPULSE_SWITCH_SERVICE_NAME\n                 .equals(t.getProperties().get(RelayHandler.PROPERTY_MODE))));\n     }\n+\n+    /**\n+     * This has to be tested differently for the RelayHandler because the thing mock\n+     * will be replaced by a real thing during the first initialization, which\n+     * modifies the channels.\n+     */\n+    @Test\n+    @Tag(TAG_LEGACY_LOCATION_PROPERTY)\n+    @Override\n+    protected void deleteLegacyLocationProperty() {\n+        ArgumentCaptor<Thing> thingCaptor = ArgumentCaptor.forClass(Thing.class);\n+        verify(getCallback(), times(3)).thingUpdated(thingCaptor.capture());\n+        List<Thing> allValues = thingCaptor.getAllValues();\n+        assertThat(allValues, hasSize(3));\n+        assertThat(allValues.get(2).getProperties(), not(hasKey(BoschSHCBindingConstants.PROPERTY_LOCATION_LEGACY)));\n+    }\n+\n+    /**\n+     * This has to be tested differently for the RelayHandler because the thing mock\n+     * will be replaced by a real thing during the first initialization, which\n+     * modifies the channels.\n+     */\n+    @Test\n+    @Tag(TAG_LOCATION_PROPERTY)\n+    @Override\n+    protected void locationPropertyDidNotChange() {\n+        // re-initialize\n+        getFixture().initialize();\n+\n+        verify(getCallback(), times(3)).thingUpdated(\n+                argThat(t -> t.getProperties().get(BoschSHCBindingConstants.PROPERTY_LOCATION).equals(\""Kitchen\"")));\n+    }\n+\n+    /**\n+     * This has to be tested differently for the RelayHandler because the thing mock\n+     * will be replaced by a real thing during the first initialization, which\n+     * modifies the channels.\n+     */\n+    @Test\n+    @Tag(TAG_LOCATION_PROPERTY)\n+    @Override\n+    protected void locationPropertyDidChange() {\n+        getDevice().roomId = \""hz_2\"";\n+        when(getBridgeHandler().resolveRoomId(\""hz_2\"")).thenReturn(\""Dining Room\"");\n+\n+        // re-initialize\n+        getFixture().initialize();\n+\n+        verify(getCallback(), times(4)).thingUpdated(\n+                argThat(t -> t.getProperties().get(BoschSHCBindingConstants.PROPERTY_LOCATION).equals(\""Dining Room\"")));\n+    }\n }\n\ndiff --git a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/discovery/ThingDiscoveryServiceTest.java b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/discovery/ThingDiscoveryServiceTest.java\nindex 3c2e7cc8b0765..4ba5425818fd5 100644\n--- a/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/discovery/ThingDiscoveryServiceTest.java\n+++ b/bundles/org.openhab.binding.boschshc/src/test/java/org/openhab/binding/boschshc/internal/discovery/ThingDiscoveryServiceTest.java\n@@ -194,7 +194,8 @@ void testAddDevice() {\n         assertThat(result.getThingUID().getId(), is(\""testDevice_ID\""));\n         assertThat(result.getBridgeUID().getId(), is(\""testSHC\""));\n         assertThat(result.getLabel(), is(\""Test Name\""));\n-        assertThat(String.valueOf(result.getProperties().get(\""Location\"")), is(\""TestRoom\""));\n+        assertThat(String.valueOf(result.getProperties().get(BoschSHCBindingConstants.PROPERTY_LOCATION)),\n+                is(\""TestRoom\""));\n     }\n \n     @Test\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""openhab__openhab-addons-17851"", ""pr_id"": 17851, ""issue_id"": 17182, ""repo"": ""openhab/openhab-addons"", ""problem_statement"": ""[mqtt.homeassistant] When a component disappears from MQTT, the channels remain on the Thing in openHAB\n## Expected Behavior\r\n\r\nIf I remove something in MQTT from Home Assistant discovery, I expect the channels for that component to disappear in openHAB, otherwise I'm left with cruft, especially if I'm say designing a new device in ESPHome and adding and removing components from it often. It should happen right away if the discovery topic receives a message explicitly deleting it (as opposed just not sending the discovery message again in the future, when not using retained discovery messages).\r\n\r\n## Current Behavior\r\nI believe the configuration topic gets removed from the Thing configuration, but the channels remain.\r\n\r\n## Possible Solution\r\nProbably set a time after a thing initializes, and go through all the channels to ensure their component still exists. Can be triggered right away if a topic is removed from the thing config.\r\n\r\n## Steps to Reproduce (for Bugs)\r\n1. Have a Home Assistant MQTT Device with multiple components\r\n2. Add the discovered thing from the Inbox\r\n3. Delete the discovery config for one of those components\r\n4. Observe that the channels still exist on the thing\r\n\r\n## Your Environment\r\n* Version used: openHAB 4.3.0-SNAPSHOT\r\n* Operating System and version (desktop or mobile, Windows 10, Raspbian Buster, ...): Ubuntu 22.04 jammy\r\n"", ""issue_word_count"": 217, ""test_files_count"": 2, ""non_test_files_count"": 3, ""pr_changed_files"": [""bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/DiscoverComponents.java"", ""bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/discovery/HomeAssistantDiscovery.java"", ""bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/handler/HomeAssistantThingHandler.java"", ""bundles/org.openhab.binding.mqtt.homeassistant/src/test/java/org/openhab/binding/mqtt/homeassistant/internal/discovery/HomeAssistantDiscoveryTests.java"", ""itests/org.openhab.binding.mqtt.homeassistant.tests/src/main/java/org/openhab/binding/mqtt/homeassistant/HomeAssistantMQTTImplementationTest.java""], ""pr_changed_test_files"": [""bundles/org.openhab.binding.mqtt.homeassistant/src/test/java/org/openhab/binding/mqtt/homeassistant/internal/discovery/HomeAssistantDiscoveryTests.java"", ""itests/org.openhab.binding.mqtt.homeassistant.tests/src/main/java/org/openhab/binding/mqtt/homeassistant/HomeAssistantMQTTImplementationTest.java""], ""base_commit"": ""044e9a33882a54d5b8098ba79a2e7fffa414df36"", ""head_commit"": ""b6df526fb9772c2c6a7f33e2cb24f0af4bed2e57"", ""repo_url"": ""https://github.com/openhab/openhab-addons/pull/17851"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/openhab__openhab-addons/17851"", ""dockerfile"": """", ""pr_merged_at"": ""2024-12-05T21:31:58.000Z"", ""patch"": ""diff --git a/bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/DiscoverComponents.java b/bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/DiscoverComponents.java\nindex 810d99d988d78..b88b596489a6b 100644\n--- a/bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/DiscoverComponents.java\n+++ b/bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/DiscoverComponents.java\n@@ -69,6 +69,8 @@ public class DiscoverComponents implements MqttMessageSubscriber {\n      */\n     public static interface ComponentDiscovered {\n         void componentDiscovered(HaID homeAssistantTopicID, AbstractComponent<?> component);\n+\n+        void componentRemoved(HaID homeAssistantTopicID);\n     }\n \n     /**\n@@ -121,7 +123,9 @@ public void processMessage(String topic, byte[] payload) {\n                 logger.warn(\""HomeAssistant discover error: {}\"", e.getMessage());\n             }\n         } else {\n-            logger.warn(\""Configuration of HomeAssistant thing {} is empty\"", haID.objectID);\n+            if (discoveredListener != null) {\n+                discoveredListener.componentRemoved(haID);\n+            }\n         }\n     }\n \n\ndiff --git a/bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/discovery/HomeAssistantDiscovery.java b/bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/discovery/HomeAssistantDiscovery.java\nindex ca675d346f8a1..0d8d99b29ff77 100644\n--- a/bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/discovery/HomeAssistantDiscovery.java\n+++ b/bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/discovery/HomeAssistantDiscovery.java\n@@ -18,18 +18,14 @@\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n-import java.util.TreeMap;\n-import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n-import java.util.stream.Collector;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n@@ -76,27 +72,14 @@\n public class HomeAssistantDiscovery extends AbstractMQTTDiscovery {\n     private final Logger logger = LoggerFactory.getLogger(HomeAssistantDiscovery.class);\n     private HomeAssistantConfiguration configuration;\n-    protected final Map<String, Set<HaID>> componentsPerThingID = new TreeMap<>();\n-    protected final Map<String, ThingUID> thingIDPerTopic = new TreeMap<>();\n-    protected final Map<String, DiscoveryResult> results = new ConcurrentHashMap<>();\n+    protected final Map<String, Set<HaID>> componentsPerThingID = new HashMap<>();\n+    protected final Map<String, ThingUID> thingIDPerTopic = new HashMap<>();\n+    protected final Map<String, DiscoveryResult> results = new HashMap<>();\n+    protected final Map<String, DiscoveryResult> allResults = new HashMap<>();\n \n     private @Nullable ScheduledFuture<?> future;\n     private final Gson gson;\n \n-    public static final Map<String, String> HA_COMP_TO_NAME = new TreeMap<>();\n-    {\n-        HA_COMP_TO_NAME.put(\""alarm_control_panel\"", \""Alarm Control Panel\"");\n-        HA_COMP_TO_NAME.put(\""binary_sensor\"", \""Sensor\"");\n-        HA_COMP_TO_NAME.put(\""camera\"", \""Camera\"");\n-        HA_COMP_TO_NAME.put(\""cover\"", \""Blind\"");\n-        HA_COMP_TO_NAME.put(\""fan\"", \""Fan\"");\n-        HA_COMP_TO_NAME.put(\""climate\"", \""Climate Control\"");\n-        HA_COMP_TO_NAME.put(\""light\"", \""Light\"");\n-        HA_COMP_TO_NAME.put(\""lock\"", \""Lock\"");\n-        HA_COMP_TO_NAME.put(\""sensor\"", \""Sensor\"");\n-        HA_COMP_TO_NAME.put(\""switch\"", \""Switch\"");\n-    }\n-\n     static final String BASE_TOPIC = \""homeassistant\"";\n     static final String BIRTH_TOPIC = \""homeassistant/status\"";\n     static final String ONLINE_STATUS = \""online\"";\n@@ -148,36 +131,8 @@ public Set<ThingTypeUID> getSupportedThingTypes() {\n         return typeProvider.getThingTypes(null).stream().map(ThingType::getUID).collect(Collectors.toSet());\n     }\n \n-    /**\n-     * Summarize components such as {Switch, Switch, Sensor} into string \""Sensor, 2x Switch\""\n-     *\n-     * @param componentNames stream of component names\n-     * @return summary string of component names and their counts\n-     */\n-    static String getComponentNamesSummary(Stream<String> componentNames) {\n-        StringBuilder summary = new StringBuilder();\n-        Collector<String, ?, Long> countingCollector = Collectors.counting();\n-        Map<String, Long> componentCounts = componentNames\n-                .collect(Collectors.groupingBy(Function.identity(), countingCollector));\n-        componentCounts.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {\n-            String componentName = entry.getKey();\n-            long count = entry.getValue();\n-            if (summary.length() > 0) {\n-                // not the first entry, so let's add the separating comma\n-                summary.append(\"", \"");\n-            }\n-            if (count > 1) {\n-                summary.append(count);\n-                summary.append(\""x \"");\n-            }\n-            summary.append(componentName);\n-        });\n-        return summary.toString();\n-    }\n-\n     @Override\n-    public void receivedMessage(ThingUID connectionBridge, MqttBrokerConnection connection, String topic,\n-            byte[] payload) {\n+    public void receivedMessage(ThingUID bridgeUID, MqttBrokerConnection connection, String topic, byte[] payload) {\n         resetTimeout();\n \n         // For HomeAssistant we need to subscribe to a wildcard topic, because topics can either be:\n@@ -188,13 +143,7 @@ public void receivedMessage(ThingUID connectionBridge, MqttBrokerConnection conn\n             return;\n         }\n \n-        // Reset the found-component timer.\n-        // We will collect components for the thing label description for another 2 seconds.\n-        final ScheduledFuture<?> future = this.future;\n-        if (future != null) {\n-            future.cancel(false);\n-        }\n-        this.future = scheduler.schedule(this::publishResults, 2, TimeUnit.SECONDS);\n+        resetPublishTimer();\n \n         // We will of course find multiple of the same unique Thing IDs, for each different component another one.\n         // Therefore the components are assembled into a list and given to the DiscoveryResult label for the user to\n@@ -206,45 +155,18 @@ public void receivedMessage(ThingUID connectionBridge, MqttBrokerConnection conn\n                     .fromString(new String(payload, StandardCharsets.UTF_8), gson);\n \n             final String thingID = config.getThingId(haID.objectID);\n-            final ThingUID thingUID = new ThingUID(MqttBindingConstants.HOMEASSISTANT_MQTT_THING, connectionBridge,\n-                    thingID);\n-\n-            thingIDPerTopic.put(topic, thingUID);\n-\n-            // We need to keep track of already found component topics for a specific thing\n-            final List<HaID> components;\n-            {\n-                Set<HaID> componentsUnordered = componentsPerThingID.computeIfAbsent(thingID,\n-                        key -> ConcurrentHashMap.newKeySet());\n-\n-                // Invariant. For compiler, computeIfAbsent above returns always\n-                // non-null\n-                Objects.requireNonNull(componentsUnordered);\n-                componentsUnordered.add(haID);\n-\n-                components = componentsUnordered.stream().collect(Collectors.toList());\n-                // We sort the components for consistent jsondb serialization order of 'topics' thing property\n-                // Sorting key is HaID::toString, i.e. using the full topic string\n-                components.sort(Comparator.comparing(HaID::toString));\n-            }\n+            final ThingUID thingUID = new ThingUID(MqttBindingConstants.HOMEASSISTANT_MQTT_THING, bridgeUID, thingID);\n \n-            final String componentNames = getComponentNamesSummary(\n-                    components.stream().map(id -> id.component).map(c -> HA_COMP_TO_NAME.getOrDefault(c, c)));\n+            synchronized (results) {\n+                thingIDPerTopic.put(topic, thingUID);\n \n-            final List<String> topics = components.stream().map(HaID::toShortTopic).collect(Collectors.toList());\n+                Map<String, Object> properties = new HashMap<>();\n+                properties = config.appendToProperties(properties);\n+                properties.put(\""deviceId\"", thingID);\n+                properties.put(\""newStyleChannels\"", \""true\"");\n \n-            Map<String, Object> properties = new HashMap<>();\n-            HandlerConfiguration handlerConfig = new HandlerConfiguration(haID.baseTopic, topics);\n-            properties = handlerConfig.appendToProperties(properties);\n-            properties = config.appendToProperties(properties);\n-            properties.put(\""deviceId\"", thingID);\n-            properties.put(\""newStyleChannels\"", \""true\"");\n-\n-            // Because we need the new properties map with the updated \""components\"" list\n-            results.put(thingUID.getAsString(),\n-                    DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n-                            .withRepresentationProperty(\""deviceId\"").withBridge(connectionBridge)\n-                            .withLabel(config.getThingName() + \"" (\"" + componentNames + \"")\"").build());\n+                buildResult(thingID, thingUID, config.getThingName(), haID, properties, bridgeUID);\n+            }\n         } catch (ConfigurationException e) {\n             logger.warn(\""HomeAssistant discover error: invalid configuration of thing {} component {}: {}\"",\n                     haID.objectID, haID.component, e.getMessage());\n@@ -273,23 +195,64 @@ private void triggerDeviceDiscovery() {\n         getDiscoveryService().publish(BIRTH_TOPIC, ONLINE_STATUS.getBytes(), 1, false);\n     }\n \n+    private void resetPublishTimer() {\n+        // Reset the found-component timer.\n+        // We will collect components for the thing label description for another 2 seconds.\n+        final ScheduledFuture<?> future = this.future;\n+        if (future != null) {\n+            future.cancel(false);\n+        }\n+        this.future = scheduler.schedule(this::publishResults, 2, TimeUnit.SECONDS);\n+    }\n+\n+    private void buildResult(String thingID, ThingUID thingUID, String thingName, HaID haID,\n+            Map<String, Object> properties, ThingUID bridgeUID) {\n+        // We need to keep track of already found component topics for a specific thing\n+        final List<HaID> components;\n+        {\n+            Set<HaID> componentsUnordered = componentsPerThingID.computeIfAbsent(thingID, key -> new HashSet<>());\n+\n+            // Invariant. For compiler, computeIfAbsent above returns always\n+            // non-null\n+            Objects.requireNonNull(componentsUnordered);\n+            componentsUnordered.add(haID);\n+\n+            components = componentsUnordered.stream().collect(Collectors.toList());\n+            // We sort the components for consistent jsondb serialization order of 'topics' thing property\n+            // Sorting key is HaID::toString, i.e. using the full topic string\n+            components.sort(Comparator.comparing(HaID::toString));\n+        }\n+\n+        final List<String> topics = components.stream().map(HaID::toShortTopic).collect(Collectors.toList());\n+\n+        HandlerConfiguration handlerConfig = new HandlerConfiguration(haID.baseTopic, topics);\n+        properties = handlerConfig.appendToProperties(properties);\n+\n+        DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withRepresentationProperty(\""deviceId\"").withBridge(bridgeUID).withLabel(thingName).build();\n+        // Because we need the new properties map with the updated \""components\"" list\n+        results.put(thingUID.toString(), result);\n+        allResults.put(thingUID.toString(), result);\n+    }\n+\n     protected void publishResults() {\n         Collection<DiscoveryResult> localResults;\n \n-        localResults = new ArrayList<>(results.values());\n-        results.clear();\n-        componentsPerThingID.clear();\n+        synchronized (results) {\n+            localResults = new ArrayList<>(results.values());\n+            results.clear();\n+        }\n         for (DiscoveryResult result : localResults) {\n             thingDiscovered(result);\n         }\n     }\n \n     @Override\n-    public void topicVanished(ThingUID connectionBridge, MqttBrokerConnection connection, String topic) {\n+    public void topicVanished(ThingUID bridgeUID, MqttBrokerConnection connection, String topic) {\n         if (!topic.endsWith(\""/config\"")) {\n             return;\n         }\n-        if (thingIDPerTopic.containsKey(topic)) {\n+        synchronized (results) {\n             ThingUID thingUID = thingIDPerTopic.remove(topic);\n             if (thingUID != null) {\n                 final String thingID = thingUID.getId();\n@@ -299,7 +262,20 @@ public void topicVanished(ThingUID connectionBridge, MqttBrokerConnection connec\n                 Set<HaID> components = componentsPerThingID.getOrDefault(thingID, Collections.emptySet());\n                 components.remove(haID);\n                 if (components.isEmpty()) {\n+                    allResults.remove(thingUID.toString());\n+                    results.remove(thingUID.toString());\n                     thingRemoved(thingUID);\n+                } else {\n+                    resetPublishTimer();\n+\n+                    DiscoveryResult existingThing = allResults.get(thingUID.toString());\n+                    if (existingThing == null) {\n+                        logger.warn(\""Could not find discovery result for removed component {}; this is a bug\"",\n+                                thingUID);\n+                        return;\n+                    }\n+                    Map<String, Object> properties = new HashMap<>(existingThing.getProperties());\n+                    buildResult(thingID, thingUID, existingThing.getLabel(), haID, properties, bridgeUID);\n                 }\n             }\n         }\n\ndiff --git a/bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/handler/HomeAssistantThingHandler.java b/bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/handler/HomeAssistantThingHandler.java\nindex 11ce67c84f7ae..739c834d7ee67 100644\n--- a/bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/handler/HomeAssistantThingHandler.java\n+++ b/bundles/org.openhab.binding.mqtt.homeassistant/src/main/java/org/openhab/binding/mqtt/homeassistant/internal/handler/HomeAssistantThingHandler.java\n@@ -82,7 +82,7 @@\n  */\n @NonNullByDefault\n public class HomeAssistantThingHandler extends AbstractMQTTThingHandler\n-        implements ComponentDiscovered, Consumer<List<AbstractComponent<?>>> {\n+        implements ComponentDiscovered, Consumer<List<Object>> {\n     public static final String AVAILABILITY_CHANNEL = \""availability\"";\n     private static final Comparator<AbstractComponent<?>> COMPONENT_COMPARATOR = Comparator\n             .comparing((AbstractComponent<?> component) -> component.hasGroup())\n@@ -96,12 +96,13 @@ public class HomeAssistantThingHandler extends AbstractMQTTThingHandler\n     protected final ChannelTypeRegistry channelTypeRegistry;\n     protected final Jinjava jinjava;\n     public final int attributeReceiveTimeout;\n-    protected final DelayedBatchProcessing<AbstractComponent<?>> delayedProcessing;\n+    protected final DelayedBatchProcessing<Object> delayedProcessing;\n     protected final DiscoverComponents discoverComponents;\n \n     private final Gson gson;\n     protected final Map<@Nullable String, AbstractComponent<?>> haComponents = new HashMap<>();\n     protected final Map<@Nullable String, AbstractComponent<?>> haComponentsByUniqueId = new HashMap<>();\n+    protected final Map<HaID, AbstractComponent<?>> haComponentsByHaId = new HashMap<>();\n     protected final Map<ChannelUID, ChannelState> channelStates = new HashMap<>();\n \n     protected HandlerConfiguration config = new HandlerConfiguration();\n@@ -267,12 +268,38 @@ public void componentDiscovered(HaID homeAssistantTopicID, AbstractComponent<?>\n         delayedProcessing.accept(component);\n     }\n \n+    @Override\n+    public void componentRemoved(HaID haID) {\n+        delayedProcessing.accept(haID);\n+    }\n+\n     /**\n      * Callback of {@link DelayedBatchProcessing}.\n-     * Add all newly discovered components to the Thing and start the components.\n+     * Add all newly discovered and removed components to the Thing and start the components.\n      */\n     @Override\n-    public void accept(List<AbstractComponent<?>> discoveredComponentsList) {\n+    public void accept(List<Object> actions) {\n+        List<AbstractComponent<?>> discoveredComponents = new ArrayList<>();\n+        List<HaID> removedComponents = new ArrayList<>();\n+        for (Object item : actions) {\n+            if (item instanceof AbstractComponent<?> component) {\n+                discoveredComponents.add(component);\n+            } else if (item instanceof HaID removedComponent) {\n+                removedComponents.add(removedComponent);\n+            }\n+        }\n+        if (!discoveredComponents.isEmpty()) {\n+            addComponents(discoveredComponents);\n+        }\n+        if (!removedComponents.isEmpty()) {\n+            removeComponents(removedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Add all newly discovered components to the Thing and start the components.\n+     */\n+    private void addComponents(List<AbstractComponent<?>> discoveredComponentsList) {\n         MqttBrokerConnection connection = this.connection;\n         if (connection == null) {\n             return;\n@@ -293,6 +320,7 @@ public void accept(List<AbstractComponent<?>> discoveredComponentsList) {\n                         // The component will be replaced in a moment.\n                         known.stop();\n                         haComponentsByUniqueId.remove(discovered.getUniqueId());\n+                        haComponentsByHaId.remove(known.getHaID());\n                         haComponents.remove(known.getComponentId());\n                         if (!known.getComponentId().equals(discovered.getComponentId())) {\n                             discovered.resolveConflict();\n@@ -321,6 +349,29 @@ public void accept(List<AbstractComponent<?>> discoveredComponentsList) {\n         }\n     }\n \n+    /**\n+     * Remove all matching deleted components.\n+     */\n+    private void removeComponents(List<HaID> removedComponentsList) {\n+        synchronized (haComponents) {\n+            boolean componentActuallyRemoved = false;\n+            for (HaID removed : removedComponentsList) {\n+                AbstractComponent<?> known = haComponentsByHaId.get(removed);\n+                if (known != null) {\n+                    // Don't wait for the future to complete. We are also not interested in failures.\n+                    known.stop();\n+                    haComponentsByUniqueId.remove(known.getUniqueId());\n+                    haComponents.remove(known.getComponentId());\n+                    haComponentsByHaId.remove(removed);\n+                    componentActuallyRemoved = true;\n+                }\n+            }\n+            if (componentActuallyRemoved) {\n+                updateThingType(getThing().getThingTypeUID());\n+            }\n+        }\n+    }\n+\n     @Override\n     protected void updateThingStatus(boolean messageReceived, Optional<Boolean> availabilityTopicsSeen) {\n         if (availabilityTopicsSeen.orElse(messageReceived)) {\n@@ -402,7 +453,7 @@ private boolean updateThingType(ThingTypeUID typeID) {\n         return true;\n     }\n \n-    private ThingTypeUID calculateThingTypeUID(AbstractComponent component) {\n+    private ThingTypeUID calculateThingTypeUID(AbstractComponent<?> component) {\n         return new ThingTypeUID(MqttBindingConstants.BINDING_ID, MqttBindingConstants.HOMEASSISTANT_MQTT_THING.getId()\n                 + \""_\"" + component.getChannelConfiguration().getThingId(component.getHaID().objectID));\n     }\n@@ -428,8 +479,8 @@ private void releaseStateUpdated(Update.ReleaseState state) {\n     }\n \n     // should only be called when it's safe to access haComponents\n-    private boolean addComponent(AbstractComponent component) {\n-        AbstractComponent existing = haComponents.get(component.getComponentId());\n+    private boolean addComponent(AbstractComponent<?> component) {\n+        AbstractComponent<?> existing = haComponents.get(component.getComponentId());\n         if (existing != null) {\n             // DeviceTriggers that are for the same subtype, topic, and value template\n             // can be coalesced together\n@@ -455,6 +506,7 @@ private boolean addComponent(AbstractComponent component) {\n                         });\n                     }\n                     haComponentsByUniqueId.put(component.getUniqueId(), component);\n+                    haComponentsByHaId.put(component.getHaID(), component);\n                     return false;\n                 }\n             }\n@@ -467,6 +519,7 @@ private boolean addComponent(AbstractComponent component) {\n         }\n         haComponents.put(component.getComponentId(), component);\n         haComponentsByUniqueId.put(component.getUniqueId(), component);\n+        haComponentsByHaId.put(component.getHaID(), component);\n         return true;\n     }\n \n@@ -478,16 +531,16 @@ private List<Configuration> flattenChannelConfiguration(Configuration multiCompo\n             ChannelUID channelUID) {\n         Object component = multiComponentChannelConfig.get(\""component\"");\n         Object nodeid = multiComponentChannelConfig.get(\""nodeid\"");\n-        if ((multiComponentChannelConfig.get(\""objectid\"") instanceof List objectIds)\n-                && (multiComponentChannelConfig.get(\""config\"") instanceof List configurations)) {\n+        if ((multiComponentChannelConfig.get(\""objectid\"") instanceof List<?> objectIds)\n+                && (multiComponentChannelConfig.get(\""config\"") instanceof List<?> configurations)) {\n             if (objectIds.size() != configurations.size()) {\n                 logger.warn(\""objectid and config for channel {} do not have the same number of items; ignoring\"",\n                         channelUID);\n                 return List.of();\n             }\n-            List<Configuration> result = new ArrayList();\n-            Iterator<Object> objectIdIterator = objectIds.iterator();\n-            Iterator<Object> configIterator = configurations.iterator();\n+            List<Configuration> result = new ArrayList<>();\n+            Iterator<?> objectIdIterator = objectIds.iterator();\n+            Iterator<?> configIterator = configurations.iterator();\n             while (objectIdIterator.hasNext()) {\n                 Configuration componentConfiguration = new Configuration();\n                 componentConfiguration.put(\""component\"", component);\n"", ""test_patch"": ""diff --git a/bundles/org.openhab.binding.mqtt.homeassistant/src/test/java/org/openhab/binding/mqtt/homeassistant/internal/discovery/HomeAssistantDiscoveryTests.java b/bundles/org.openhab.binding.mqtt.homeassistant/src/test/java/org/openhab/binding/mqtt/homeassistant/internal/discovery/HomeAssistantDiscoveryTests.java\nindex 15999087f4bef..d44e5a9763f53 100644\n--- a/bundles/org.openhab.binding.mqtt.homeassistant/src/test/java/org/openhab/binding/mqtt/homeassistant/internal/discovery/HomeAssistantDiscoveryTests.java\n+++ b/bundles/org.openhab.binding.mqtt.homeassistant/src/test/java/org/openhab/binding/mqtt/homeassistant/internal/discovery/HomeAssistantDiscoveryTests.java\n@@ -15,13 +15,13 @@\n import static org.hamcrest.CoreMatchers.*;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n-import java.util.stream.Stream;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n@@ -56,15 +56,84 @@ public void beforeEach() {\n     }\n \n     @Test\n-    public void testComponentNameSummary() {\n-        assertThat(\n-                HomeAssistantDiscovery.getComponentNamesSummary(\n-                        Stream.of(\""Sensor\"", \""Switch\"", \""Sensor\"", \""Foobar\"", \""Foobar\"", \""Foobar\"")), //\n-                is(\""3x Foobar, 2x Sensor, Switch\""));\n+    public void testOneThingDiscovery() throws Exception {\n+        var discoveryListener = new LatchDiscoveryListener();\n+        var latch = discoveryListener.createWaitForThingsDiscoveredLatch(1);\n+\n+        // When discover one thing with two channels\n+        discovery.addDiscoveryListener(discoveryListener);\n+        discovery.receivedMessage(HA_UID, bridgeConnection,\n+                \""homeassistant/climate/0x847127fffe11dd6a_climate_zigbee2mqtt/config\"",\n+                getResourceAsByteArray(\""component/configTS0601ClimateThermostat.json\""));\n+        discovery.receivedMessage(HA_UID, bridgeConnection,\n+                \""homeassistant/switch/0x847127fffe11dd6a_auto_lock_zigbee2mqtt/config\"",\n+                getResourceAsByteArray(\""component/configTS0601AutoLock.json\""));\n+\n+        // Then one thing found\n+        assert latch.await(3, TimeUnit.SECONDS);\n+        var discoveryResults = discoveryListener.getDiscoveryResults();\n+        assertThat(discoveryResults.size(), is(1));\n+        var result = discoveryResults.get(0);\n+        assertThat(result.getBridgeUID(), is(HA_UID));\n+        assertThat(result.getProperties().get(Thing.PROPERTY_MODEL_ID),\n+                is(\""Radiator valve with thermostat (TS0601_thermostat)\""));\n+        assertThat(result.getProperties().get(Thing.PROPERTY_VENDOR), is(\""TuYa\""));\n+        assertThat(result.getProperties().get(Thing.PROPERTY_FIRMWARE_VERSION), is(\""Zigbee2MQTT 1.18.2\""));\n+        assertThat(result.getProperties().get(HandlerConfiguration.PROPERTY_BASETOPIC), is(\""homeassistant\""));\n+        assertThat(result.getLabel(), is(\""th1\""));\n+        assertThat((List<String>) result.getProperties().get(HandlerConfiguration.PROPERTY_TOPICS), hasItems(\n+                \""climate/0x847127fffe11dd6a_climate_zigbee2mqtt\"", \""switch/0x847127fffe11dd6a_auto_lock_zigbee2mqtt\""));\n     }\n \n     @Test\n-    public void testOneThingDiscovery() throws Exception {\n+    public void testComponentAddedToExistingThing() throws Exception {\n+        var discoveryListener = new LatchDiscoveryListener();\n+        var latch = discoveryListener.createWaitForThingsDiscoveredLatch(1);\n+\n+        // When discover one thing with two channels\n+        discovery.addDiscoveryListener(discoveryListener);\n+        discovery.receivedMessage(HA_UID, bridgeConnection,\n+                \""homeassistant/climate/0x847127fffe11dd6a_climate_zigbee2mqtt/config\"",\n+                getResourceAsByteArray(\""component/configTS0601ClimateThermostat.json\""));\n+\n+        // Then one thing found\n+        assert latch.await(3, TimeUnit.SECONDS);\n+        var discoveryResults = discoveryListener.getDiscoveryResults();\n+        assertThat(discoveryResults.size(), is(1));\n+        var result = discoveryResults.get(0);\n+        assertThat(result.getBridgeUID(), is(HA_UID));\n+        assertThat(result.getProperties().get(Thing.PROPERTY_MODEL_ID),\n+                is(\""Radiator valve with thermostat (TS0601_thermostat)\""));\n+        assertThat(result.getProperties().get(Thing.PROPERTY_VENDOR), is(\""TuYa\""));\n+        assertThat(result.getProperties().get(Thing.PROPERTY_FIRMWARE_VERSION), is(\""Zigbee2MQTT 1.18.2\""));\n+        assertThat(result.getProperties().get(HandlerConfiguration.PROPERTY_BASETOPIC), is(\""homeassistant\""));\n+        assertThat(result.getLabel(), is(\""th1\""));\n+        assertThat((List<String>) result.getProperties().get(HandlerConfiguration.PROPERTY_TOPICS),\n+                hasItems(\""climate/0x847127fffe11dd6a_climate_zigbee2mqtt\""));\n+\n+        // Now another component added to the same thing\n+        latch = discoveryListener.createWaitForThingsDiscoveredLatch(1);\n+        discovery.receivedMessage(HA_UID, bridgeConnection,\n+                \""homeassistant/switch/0x847127fffe11dd6a_auto_lock_zigbee2mqtt/config\"",\n+                getResourceAsByteArray(\""component/configTS0601AutoLock.json\""));\n+\n+        assert latch.await(3, TimeUnit.SECONDS);\n+        discoveryResults = discoveryListener.getDiscoveryResults();\n+        assertThat(discoveryResults.size(), is(1));\n+        result = discoveryResults.get(0);\n+        assertThat(result.getBridgeUID(), is(HA_UID));\n+        assertThat(result.getProperties().get(Thing.PROPERTY_MODEL_ID),\n+                is(\""Radiator valve with thermostat (TS0601_thermostat)\""));\n+        assertThat(result.getProperties().get(Thing.PROPERTY_VENDOR), is(\""TuYa\""));\n+        assertThat(result.getProperties().get(Thing.PROPERTY_FIRMWARE_VERSION), is(\""Zigbee2MQTT 1.18.2\""));\n+        assertThat(result.getProperties().get(HandlerConfiguration.PROPERTY_BASETOPIC), is(\""homeassistant\""));\n+        assertThat(result.getLabel(), is(\""th1\""));\n+        assertThat((List<String>) result.getProperties().get(HandlerConfiguration.PROPERTY_TOPICS), hasItems(\n+                \""climate/0x847127fffe11dd6a_climate_zigbee2mqtt\"", \""switch/0x847127fffe11dd6a_auto_lock_zigbee2mqtt\""));\n+    }\n+\n+    @Test\n+    public void testComponentRemovedFromExistingThing() throws Exception {\n         var discoveryListener = new LatchDiscoveryListener();\n         var latch = discoveryListener.createWaitForThingsDiscoveredLatch(1);\n \n@@ -88,9 +157,28 @@ public void testOneThingDiscovery() throws Exception {\n         assertThat(result.getProperties().get(Thing.PROPERTY_VENDOR), is(\""TuYa\""));\n         assertThat(result.getProperties().get(Thing.PROPERTY_FIRMWARE_VERSION), is(\""Zigbee2MQTT 1.18.2\""));\n         assertThat(result.getProperties().get(HandlerConfiguration.PROPERTY_BASETOPIC), is(\""homeassistant\""));\n-        assertThat(result.getLabel(), is(\""th1 (Climate Control, Switch)\""));\n+        assertThat(result.getLabel(), is(\""th1\""));\n         assertThat((List<String>) result.getProperties().get(HandlerConfiguration.PROPERTY_TOPICS), hasItems(\n                 \""climate/0x847127fffe11dd6a_climate_zigbee2mqtt\"", \""switch/0x847127fffe11dd6a_auto_lock_zigbee2mqtt\""));\n+\n+        // Now remove the second component\n+        latch = discoveryListener.createWaitForThingsDiscoveredLatch(1);\n+        discovery.topicVanished(HA_UID, bridgeConnection,\n+                \""homeassistant/switch/0x847127fffe11dd6a_auto_lock_zigbee2mqtt/config\"");\n+\n+        assert latch.await(3, TimeUnit.SECONDS);\n+        discoveryResults = discoveryListener.getDiscoveryResults();\n+        assertThat(discoveryResults.size(), is(1));\n+        result = discoveryResults.get(0);\n+        assertThat(result.getBridgeUID(), is(HA_UID));\n+        assertThat(result.getProperties().get(Thing.PROPERTY_MODEL_ID),\n+                is(\""Radiator valve with thermostat (TS0601_thermostat)\""));\n+        assertThat(result.getProperties().get(Thing.PROPERTY_VENDOR), is(\""TuYa\""));\n+        assertThat(result.getProperties().get(Thing.PROPERTY_FIRMWARE_VERSION), is(\""Zigbee2MQTT 1.18.2\""));\n+        assertThat(result.getProperties().get(HandlerConfiguration.PROPERTY_BASETOPIC), is(\""homeassistant\""));\n+        assertThat(result.getLabel(), is(\""th1\""));\n+        assertThat((List<String>) result.getProperties().get(HandlerConfiguration.PROPERTY_TOPICS),\n+                hasItems(\""climate/0x847127fffe11dd6a_climate_zigbee2mqtt\""));\n     }\n \n     private static class TestHomeAssistantDiscovery extends HomeAssistantDiscovery {\n@@ -122,8 +210,10 @@ public void thingRemoved(DiscoveryService source, ThingUID thingUID) {\n             return Collections.emptyList();\n         }\n \n-        public CopyOnWriteArrayList<DiscoveryResult> getDiscoveryResults() {\n-            return discoveryResults;\n+        public List<DiscoveryResult> getDiscoveryResults() {\n+            ArrayList<DiscoveryResult> localResults = new ArrayList<>(discoveryResults);\n+            discoveryResults.clear();\n+            return localResults;\n         }\n \n         public CountDownLatch createWaitForThingsDiscoveredLatch(int count) {\n\ndiff --git a/itests/org.openhab.binding.mqtt.homeassistant.tests/src/main/java/org/openhab/binding/mqtt/homeassistant/HomeAssistantMQTTImplementationTest.java b/itests/org.openhab.binding.mqtt.homeassistant.tests/src/main/java/org/openhab/binding/mqtt/homeassistant/HomeAssistantMQTTImplementationTest.java\nindex 64781741ea182..d001274eb6033 100644\n--- a/itests/org.openhab.binding.mqtt.homeassistant.tests/src/main/java/org/openhab/binding/mqtt/homeassistant/HomeAssistantMQTTImplementationTest.java\n+++ b/itests/org.openhab.binding.mqtt.homeassistant.tests/src/main/java/org/openhab/binding/mqtt/homeassistant/HomeAssistantMQTTImplementationTest.java\n@@ -138,6 +138,26 @@ public void retrieveAllTopics() throws Exception {\n                 \""Connection \"" + haConnection.getClientId() + \"" not retrieving all topics\"");\n     }\n \n+    private static class ComponentDiscoveredProxy implements ComponentDiscovered {\n+        private final Map<String, AbstractComponent<?>> haComponents;\n+        private final CountDownLatch latch;\n+\n+        public ComponentDiscoveredProxy(Map<String, AbstractComponent<?>> haComponents, CountDownLatch latch) {\n+            this.haComponents = haComponents;\n+            this.latch = latch;\n+        }\n+\n+        @Override\n+        public void componentDiscovered(HaID homeAssistantTopicID, AbstractComponent<?> component) {\n+            haComponents.put(component.getComponentId(), component);\n+            latch.countDown();\n+        }\n+\n+        @Override\n+        public void componentRemoved(HaID homeAssistantTopicID) {\n+        }\n+    }\n+\n     @Test\n     public void parseHATree() throws Exception {\n         MqttChannelTypeProvider channelTypeProvider = mock(MqttChannelTypeProvider.class);\n@@ -154,10 +174,7 @@ public void parseHATree() throws Exception {\n         // In the following implementation we add the found component to the `haComponents` map\n         // and add the types to the channelTypeProvider, like in the real Thing handler.\n         final CountDownLatch latch = new CountDownLatch(1);\n-        ComponentDiscovered cd = (haID, c) -> {\n-            haComponents.put(c.getComponentId(), c);\n-            latch.countDown();\n-        };\n+        ComponentDiscovered cd = new ComponentDiscoveredProxy(haComponents, latch);\n \n         // Start the discovery for 2000ms. Forced timeout after 4000ms.\n         HaID haID = new HaID(testObjectTopic + \""/config\"");\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
