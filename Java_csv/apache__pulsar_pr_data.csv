metadata
"{""instance_id"": ""apache__pulsar-24132"", ""pr_id"": 24132, ""issue_id"": 24129, ""repo"": ""apache/pulsar"", ""problem_statement"": ""[Bug] KinesisSink with jsonFlatten doesn't handle SchemaType.BYTES correctly\n### Search before asking\n\n- [x] I searched in the [issues](https://github.com/apache/pulsar/issues) and found nothing similar.\n\n\n### Read release policy\n\n- [x] I understand that unsupported versions don't get bug fixes. I will attempt to reproduce the issue on a supported version of Pulsar client and Pulsar broker.\n\n\n### Version\n\nHEAD\n\n### Minimal reproduce step\n\nRun the following test\n```java\n    @Test\n    public void testSerializeRecordToJsonExpandingValue() throws Exception {\n        SchemaType schemaType = SchemaType.AVRO;\n        RecordSchemaBuilder valueSchemaBuilder = org.apache.pulsar.client.api.schema.SchemaBuilder.record(\""value\"");\n        valueSchemaBuilder.field(\""a\"").type(SchemaType.BYTES).optional().defaultValue(null);\n        GenericSchema<GenericRecord> valueSchema = Schema.generic(valueSchemaBuilder.build(schemaType));\n\n        GenericRecord valueGenericRecord = valueSchema.newRecordBuilder()\n                .set(\""a\"", \""10\"".getBytes(StandardCharsets.UTF_8))\n                .build();\n\n        Record<GenericObject> genericObjectRecord = new Record<>() {\n\n            @Override\n            public org.apache.pulsar.client.api.Schema getSchema() {\n                return valueSchema;\n            }\n\n            @Override\n            public GenericObject getValue() {\n                return valueGenericRecord;\n            }\n        };\n\n        ObjectMapper objectMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);\n        String json = Utils.serializeRecordToJsonExpandingValue(objectMapper, genericObjectRecord, true);\n\n        assertEquals(json, \""{\\\""payload.a\\\"":\\\""MTA=\\\""}\"");\n    }\n```\n\n### What did you expect to see?\n\nThe test should pass.\n\n### What did you see instead?\n\nThe test fails because `payload.a` is `null`.\n```sh\njava.lang.AssertionError:\nExpected :{\""payload.a\"":\""MTA=\""}\nActual   :{\""payload.a\"":null}\n```\n\n### Anything else?\n\nThe problem is in the flattening library `json-flattener` which doesn't handle Jackson's BinaryNode.\nIn `JsonJacksonValue`, `isString` should also return `true` when the underlying `JsonNode` `isBinary` is `true`.\n\n### Are you willing to submit a PR?\n\n- [x] I'm willing to submit a PR!"", ""issue_word_count"": 243, ""test_files_count"": 2, ""non_test_files_count"": 2, ""pr_changed_files"": [""pulsar-io/kinesis/src/main/java/org/apache/pulsar/io/kinesis/Utils.java"", ""pulsar-io/kinesis/src/main/java/org/apache/pulsar/io/kinesis/json/JsonConverter.java"", ""pulsar-io/kinesis/src/test/java/org/apache/pulsar/io/kinesis/UtilsTest.java"", ""pulsar-io/kinesis/src/test/java/org/apache/pulsar/io/kinesis/json/JsonConverterTests.java""], ""pr_changed_test_files"": [""pulsar-io/kinesis/src/test/java/org/apache/pulsar/io/kinesis/UtilsTest.java"", ""pulsar-io/kinesis/src/test/java/org/apache/pulsar/io/kinesis/json/JsonConverterTests.java""], ""base_commit"": ""7aa49c6bd206fcde0a467c29440f458b43f7ad1e"", ""head_commit"": ""63206718bb0fa91fa002ef7f3c361807a40f1d57"", ""repo_url"": ""https://github.com/apache/pulsar/pull/24132"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/apache__pulsar/24132"", ""dockerfile"": """", ""pr_merged_at"": ""2025-03-28T09:59:26.000Z"", ""patch"": ""diff --git a/pulsar-io/kinesis/src/main/java/org/apache/pulsar/io/kinesis/Utils.java b/pulsar-io/kinesis/src/main/java/org/apache/pulsar/io/kinesis/Utils.java\nindex 32d3470524876..a52e42e9c6a55 100644\n--- a/pulsar-io/kinesis/src/main/java/org/apache/pulsar/io/kinesis/Utils.java\n+++ b/pulsar-io/kinesis/src/main/java/org/apache/pulsar/io/kinesis/Utils.java\n@@ -222,7 +222,7 @@ public static String serializeRecordToJsonExpandingValue(ObjectMapper mapper, Re\n         JsonRecord jsonRecord = new JsonRecord();\n         GenericObject value = record.getValue();\n         if (value != null) {\n-            jsonRecord.setPayload(toJsonSerializable(record.getSchema(), value.getNativeObject()));\n+            jsonRecord.setPayload(toJsonSerializable(record.getSchema(), value.getNativeObject(), flatten));\n         }\n         record.getKey().ifPresent(jsonRecord::setKey);\n         record.getTopicName().ifPresent(jsonRecord::setTopicName);\n@@ -242,7 +242,7 @@ public static org.apache.pulsar.client.api.Message<GenericObject> getMessage(Rec\n                 .orElseThrow(() -> new IllegalArgumentException(\""Record does not carry message information\""));\n     }\n \n-    private static Object toJsonSerializable(Schema<?> schema, Object val) {\n+    private static Object toJsonSerializable(Schema<?> schema, Object val, boolean convertBytesToString) {\n         if (schema == null || schema.getSchemaInfo().getType().isPrimitive()) {\n             return val;\n         }\n@@ -254,15 +254,15 @@ private static Object toJsonSerializable(Schema<?> schema, Object val) {\n                 Map<String, Object> jsonKeyValue = new HashMap<>();\n                 if (keyValue.getKey() != null) {\n                     jsonKeyValue.put(\""key\"", toJsonSerializable(keyValueSchema.getKeySchema(),\n-                            keyValue.getKey().getNativeObject()));\n+                            keyValue.getKey().getNativeObject(), convertBytesToString));\n                 }\n                 if (keyValue.getValue() != null) {\n                     jsonKeyValue.put(\""value\"", toJsonSerializable(keyValueSchema.getValueSchema(),\n-                            keyValue.getValue().getNativeObject()));\n+                            keyValue.getValue().getNativeObject(), convertBytesToString));\n                 }\n                 return jsonKeyValue;\n             case AVRO:\n-                return JsonConverter.toJson((org.apache.avro.generic.GenericRecord) val);\n+                return JsonConverter.toJson((org.apache.avro.generic.GenericRecord) val, convertBytesToString);\n             case JSON:\n                 return val;\n             default:\n\ndiff --git a/pulsar-io/kinesis/src/main/java/org/apache/pulsar/io/kinesis/json/JsonConverter.java b/pulsar-io/kinesis/src/main/java/org/apache/pulsar/io/kinesis/json/JsonConverter.java\nindex 5308971e8d24e..22412c395759a 100644\n--- a/pulsar-io/kinesis/src/main/java/org/apache/pulsar/io/kinesis/json/JsonConverter.java\n+++ b/pulsar-io/kinesis/src/main/java/org/apache/pulsar/io/kinesis/json/JsonConverter.java\n@@ -26,6 +26,7 @@\n import java.time.Instant;\n import java.time.LocalDate;\n import java.time.LocalTime;\n+import java.util.Base64;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.UUID;\n@@ -45,18 +46,18 @@ public class JsonConverter {\n     private static final Map<String, LogicalTypeConverter<?>> logicalTypeConverters = new HashMap<>();\n     private static final JsonNodeFactory jsonNodeFactory = JsonNodeFactory.withExactBigDecimals(true);\n \n-    public static JsonNode toJson(GenericRecord genericRecord) {\n+    public static JsonNode toJson(GenericRecord genericRecord, boolean convertBytesToString) {\n         if (genericRecord == null) {\n             return null;\n         }\n         ObjectNode objectNode = jsonNodeFactory.objectNode();\n         for (Schema.Field field : genericRecord.getSchema().getFields()) {\n-            objectNode.set(field.name(), toJson(field.schema(), genericRecord.get(field.name())));\n+            objectNode.set(field.name(), toJson(field.schema(), genericRecord.get(field.name()), convertBytesToString));\n         }\n         return objectNode;\n     }\n \n-    public static JsonNode toJson(Schema schema, Object value) {\n+    public static JsonNode toJson(Schema schema, Object value, boolean convertBytesToString) {\n         if (schema.getLogicalType() != null && logicalTypeConverters.containsKey(schema.getLogicalType().getName())) {\n             return logicalTypeConverters.get(schema.getLogicalType().getName()).toJson(schema, value);\n         }\n@@ -77,8 +78,16 @@ public static JsonNode toJson(Schema schema, Object value) {\n             case BOOLEAN:\n                 return jsonNodeFactory.booleanNode((Boolean) value);\n             case BYTES:\n+                // Workaround for https://github.com/wnameless/json-flattener/issues/91\n+                if (convertBytesToString) {\n+                    return jsonNodeFactory.textNode(Base64.getEncoder().encodeToString((byte[]) value));\n+                }\n                 return jsonNodeFactory.binaryNode((byte[]) value);\n             case FIXED:\n+                // Workaround for https://github.com/wnameless/json-flattener/issues/91\n+                if (convertBytesToString) {\n+                    return jsonNodeFactory.textNode(Base64.getEncoder().encodeToString(((GenericFixed) value).bytes()));\n+                }\n                 return jsonNodeFactory.binaryNode(((GenericFixed) value).bytes());\n             case ENUM: // GenericEnumSymbol\n             case STRING:\n@@ -93,7 +102,7 @@ public static JsonNode toJson(Schema schema, Object value) {\n                     iterable = (Object[]) value;\n                 }\n                 for (Object elem : iterable) {\n-                    JsonNode fieldValue = toJson(elementSchema, elem);\n+                    JsonNode fieldValue = toJson(elementSchema, elem, convertBytesToString);\n                     arrayNode.add(fieldValue);\n                 }\n                 return arrayNode;\n@@ -102,7 +111,7 @@ public static JsonNode toJson(Schema schema, Object value) {\n                 Map<Object, Object> map = (Map<Object, Object>) value;\n                 ObjectNode objectNode = jsonNodeFactory.objectNode();\n                 for (Map.Entry<Object, Object> entry : map.entrySet()) {\n-                    JsonNode jsonNode = toJson(schema.getValueType(), entry.getValue());\n+                    JsonNode jsonNode = toJson(schema.getValueType(), entry.getValue(), convertBytesToString);\n                     // can be a String or org.apache.avro.util.Utf8\n                     final String entryKey = entry.getKey() == null ? null : entry.getKey().toString();\n                     objectNode.set(entryKey, jsonNode);\n@@ -110,13 +119,13 @@ public static JsonNode toJson(Schema schema, Object value) {\n                 return objectNode;\n             }\n             case RECORD:\n-                return toJson((GenericRecord) value);\n+                return toJson((GenericRecord) value, convertBytesToString);\n             case UNION:\n                 for (Schema s : schema.getTypes()) {\n                     if (s.getType() == Schema.Type.NULL) {\n                         continue;\n                     }\n-                    return toJson(s, value);\n+                    return toJson(s, value, convertBytesToString);\n                 }\n                 // this case should not happen\n                 return jsonNodeFactory.textNode(value.toString());\n"", ""test_patch"": ""diff --git a/pulsar-io/kinesis/src/test/java/org/apache/pulsar/io/kinesis/UtilsTest.java b/pulsar-io/kinesis/src/test/java/org/apache/pulsar/io/kinesis/UtilsTest.java\nindex b0f9456b9487c..1eda566df04c3 100644\n--- a/pulsar-io/kinesis/src/test/java/org/apache/pulsar/io/kinesis/UtilsTest.java\n+++ b/pulsar-io/kinesis/src/test/java/org/apache/pulsar/io/kinesis/UtilsTest.java\n@@ -29,6 +29,8 @@\n import com.google.gson.Gson;\n \n import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n@@ -358,6 +360,7 @@ public void testKeyValueSerializeRecordToJsonExpandingValue(SchemaType schemaTyp\n         RecordSchemaBuilder udtSchemaBuilder = SchemaBuilder.record(\""type1\"");\n         udtSchemaBuilder.field(\""a\"").type(SchemaType.STRING).optional().defaultValue(null);\n         udtSchemaBuilder.field(\""b\"").type(SchemaType.BOOLEAN).optional().defaultValue(null);\n+        udtSchemaBuilder.field(\""c\"").type(SchemaType.BYTES).optional().defaultValue(null);\n         udtSchemaBuilder.field(\""d\"").type(SchemaType.DOUBLE).optional().defaultValue(null);\n         udtSchemaBuilder.field(\""f\"").type(SchemaType.FLOAT).optional().defaultValue(null);\n         udtSchemaBuilder.field(\""i\"").type(SchemaType.INT32).optional().defaultValue(null);\n@@ -366,12 +369,16 @@ public void testKeyValueSerializeRecordToJsonExpandingValue(SchemaType schemaTyp\n         valueSchemaBuilder.field(\""e\"", udtGenericSchema).type(schemaType).optional().defaultValue(null);\n         GenericSchema<GenericRecord> valueSchema = Schema.generic(valueSchemaBuilder.build(schemaType));\n \n+        byte[] bytes = \""10\"".getBytes(StandardCharsets.UTF_8);\n         GenericRecord valueGenericRecord = valueSchema.newRecordBuilder()\n                 .set(\""c\"", \""1\"")\n                 .set(\""d\"", 1)\n                 .set(\""e\"", udtGenericSchema.newRecordBuilder()\n                         .set(\""a\"", \""a\"")\n                         .set(\""b\"", true)\n+                        // There's a bug in json-flattener that doesn't handle byte[] fields correctly.\n+                        // But since we use AUTO_CONSUME, we won't get byte[] fields for JSON schema anyway.\n+                        .set(\""c\"", schemaType == SchemaType.AVRO ? bytes : Base64.getEncoder().encodeToString(bytes))\n                         .set(\""d\"", 1.0)\n                         .set(\""f\"", 1.0f)\n                         .set(\""i\"", 1)\n@@ -434,16 +441,17 @@ public Optional<Long> getEventTime() {\n         String json = Utils.serializeRecordToJsonExpandingValue(objectMapper, genericObjectRecord, false);\n \n         assertEquals(json, \""{\\\""topicName\\\"":\\\""data-ks1.table1\\\"",\\\""key\\\"":\\\""message-key\\\"",\""\n-                + \""\\\""payload\\\"":{\\\""value\\\"":{\\\""c\\\"":\\\""1\\\"",\\\""d\\\"":1,\\\""e\\\"":{\\\""a\\\"":\\\""a\\\"",\\\""b\\\"":true,\\\""d\\\"":1.0,\\\""f\\\"":1.0,\""\n-                + \""\\\""i\\\"":1,\\\""l\\\"":10}},\\\""key\\\"":{\\\""a\\\"":\\\""1\\\"",\\\""b\\\"":1}},\\\""properties\\\"":{\\\""prop-key\\\"":\\\""prop-value\\\""},\""\n-                + \""\\\""eventTime\\\"":1648502845803}\"");\n+                + \""\\\""payload\\\"":{\\\""value\\\"":{\\\""c\\\"":\\\""1\\\"",\\\""d\\\"":1,\\\""e\\\"":{\\\""a\\\"":\\\""a\\\"",\\\""b\\\"":true,\\\""c\\\"":\\\""MTA=\\\"",\\\""d\\\"":1.0,\""\n+                + \""\\\""f\\\"":1.0,\\\""i\\\"":1,\\\""l\\\"":10}},\\\""key\\\"":{\\\""a\\\"":\\\""1\\\"",\\\""b\\\"":1}},\""\n+                + \""\\\""properties\\\"":{\\\""prop-key\\\"":\\\""prop-value\\\""},\\\""eventTime\\\"":1648502845803}\"");\n \n         json = Utils.serializeRecordToJsonExpandingValue(objectMapper, genericObjectRecord, true);\n \n         assertEquals(json, \""{\\\""topicName\\\"":\\\""data-ks1.table1\\\"",\\\""key\\\"":\\\""message-key\\\"",\\\""payload.value.c\\\"":\\\""1\\\"",\""\n-                + \""\\\""payload.value.d\\\"":1,\\\""payload.value.e.a\\\"":\\\""a\\\"",\\\""payload.value.e.b\\\"":true,\\\""payload.value.e\""\n-                + \"".d\\\"":1.0,\\\""payload.value.e.f\\\"":1.0,\\\""payload.value.e.i\\\"":1,\\\""payload.value.e.l\\\"":10,\\\""payload.key\""\n-                + \"".a\\\"":\\\""1\\\"",\\\""payload.key.b\\\"":1,\\\""properties.prop-key\\\"":\\\""prop-value\\\"",\\\""eventTime\\\"":1648502845803}\"");\n+                + \""\\\""payload.value.d\\\"":1,\\\""payload.value.e.a\\\"":\\\""a\\\"",\\\""payload.value.e.b\\\"":true,\""\n+                + \""\\\""payload.value.e.c\\\"":\\\""MTA=\\\"",\\\""payload.value.e.d\\\"":1.0,\\\""payload.value.e.f\\\"":1.0,\""\n+                + \""\\\""payload.value.e.i\\\"":1,\\\""payload.value.e.l\\\"":10,\\\""payload.key.a\\\"":\\\""1\\\"",\\\""payload.key.b\\\"":1,\""\n+                + \""\\\""properties.prop-key\\\"":\\\""prop-value\\\"",\\\""eventTime\\\"":1648502845803}\"");\n     }\n \n     @Test(dataProvider = \""schemaType\"")\n\ndiff --git a/pulsar-io/kinesis/src/test/java/org/apache/pulsar/io/kinesis/json/JsonConverterTests.java b/pulsar-io/kinesis/src/test/java/org/apache/pulsar/io/kinesis/json/JsonConverterTests.java\nindex 94fd73135b398..c3bbaa06d014d 100644\n--- a/pulsar-io/kinesis/src/test/java/org/apache/pulsar/io/kinesis/json/JsonConverterTests.java\n+++ b/pulsar-io/kinesis/src/test/java/org/apache/pulsar/io/kinesis/json/JsonConverterTests.java\n@@ -81,7 +81,7 @@ public void testAvroToJson() throws IOException {\n         genericRecord.put(\""arrayavro\"", new GenericData.Array<>(avroArraySchema, Arrays.asList(\""toto\"")));\n         genericRecord.put(\""map\"", ImmutableMap.of(\""a\"",10));\n         genericRecord.put(\""maputf8\"", ImmutableMap.of(new org.apache.avro.util.Utf8(\""a\""),10));\n-        JsonNode jsonNode = JsonConverter.toJson(genericRecord);\n+        JsonNode jsonNode = JsonConverter.toJson(genericRecord, false);\n         assertEquals(jsonNode.get(\""n\""), NullNode.getInstance());\n         assertEquals(jsonNode.get(\""l\"").asLong(), 1L);\n         assertEquals(jsonNode.get(\""i\"").asInt(), 1);\n@@ -135,7 +135,7 @@ public void testLogicalTypesToJson() throws IOException {\n         genericRecord.put(\""myuuid\"", myUuid.toString());\n \n         GenericRecord genericRecord2 = deserialize(serialize(genericRecord, schema), schema);\n-        JsonNode jsonNode = JsonConverter.toJson(genericRecord2);\n+        JsonNode jsonNode = JsonConverter.toJson(genericRecord2, false);\n         assertEquals(jsonNode.get(\""mydate\"").asInt(), calendar.toInstant().getEpochSecond());\n         assertEquals(jsonNode.get(\""tsmillis\"").asInt(), (int)calendar.getTimeInMillis());\n         assertEquals(jsonNode.get(\""tsmicros\"").asLong(), calendar.getTimeInMillis() * 1000);\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""apache__pulsar-23824"", ""pr_id"": 23824, ""issue_id"": 20635, ""repo"": ""apache/pulsar"", ""problem_statement"": ""[Bug] pulsar keep creating dead letter queue producer and exceed the maximum limit\n### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/apache/pulsar/issues) and found nothing similar.\r\n\r\n\r\n### Version\r\n2.11\r\n\r\n\r\n### Minimal reproduce step\r\nUse pulsar java client library to create a consumer with dlq prodcer. \r\n1. after application starts, stop bookie\r\n2. produce some message to the queue and trigger the consumer\r\n3.  check the log. \r\nIt seems keep creating dead letter queue producer, and eventually hit the maximum limit\r\n\r\n### What did you expect to see?\r\n\r\nextra producer should not be created if there is an issue on pulsar\r\n\r\n### What did you see instead?\r\n\r\ncreated over 10000 producers and eventually exceed the limits\r\n\r\n### Anything else?\r\nsee logs\r\n\r\n```\r\n--\r\nStarting Pulsar producer perf with config: {\""topicName\"":\""persistent://public/default/my-topic\"",\""producerName\"":null,\""sendTimeoutMs\"":30000,\""blockIfQueueFull\"":false,\""maxPendingMessages\"":0,\""maxPendingMessagesAcrossPartitions\"":0,\""messageRoutingMode\"":\""RoundRobinPartition\"",\""hashingScheme\"":\""JavaStringHash\"",\""cryptoFailureAction\"":\""FAIL\"",\""batchingMaxPublishDelayMicros\"":1000,\""batchingPartitionSwitchFrequencyByPublishDelay\"":10,\""batchingMaxMessages\"":1000,\""batchingMaxBytes\"":131072,\""batchingEnabled\"":true,\""chunkingEnabled\"":false,\""chunkMaxMessageSize\"":-1,\""compressionType\"":\""NONE\"",\""initialSequenceId\"":null,\""autoUpdatePartitions\"":true,\""autoUpdatePartitionsIntervalSeconds\"":60,\""multiSchema\"":true,\""accessMode\"":\""Shared\"",\""lazyStartPartitionedProducers\"":false,\""properties\"":{},\""initialSubscriptionName\"":null}\r\n--\r\nPulsar client config: {\""serviceUrl\"":\""pulsar://pulsar:6650\"",\""authPluginClassName\"":null,\""authParams\"":null,\""authParamMap\"":null,\""operationTimeoutMs\"":30000,\""lookupTimeoutMs\"":30000,\""statsIntervalSeconds\"":60,\""numIoThreads\"":1,\""numListenerThreads\"":1,\""connectionsPerBroker\"":1,\""connectionMaxIdleSeconds\"":180,\""useTcpNoDelay\"":true,\""useTls\"":false,\""tlsKeyFilePath\"":null,\""tlsCertificateFilePath\"":null,\""tlsTrustCertsFilePath\"":null,\""tlsAllowInsecureConnection\"":false,\""tlsHostnameVerificationEnable\"":false,\""concurrentLookupRequest\"":5000,\""maxLookupRequest\"":50000,\""maxLookupRedirects\"":20,\""maxNumberOfRejectedRequestPerConnection\"":50,\""keepAliveIntervalSeconds\"":30,\""connectionTimeoutMs\"":10000,\""requestTimeoutMs\"":60000,\""initialBackoffIntervalNanos\"":100000000,\""maxBackoffIntervalNanos\"":60000000000,\""enableBusyWait\"":false,\""listenerName\"":null,\""useKeyStoreTls\"":false,\""sslProvider\"":null,\""tlsKeyStoreType\"":\""JKS\"",\""tlsKeyStorePath\"":null,\""tlsKeyStorePassword\"":null,\""tlsTrustStoreType\"":\""JKS\"",\""tlsTrustStorePath\"":null,\""tlsTrustStorePassword\"":null,\""tlsCiphers\"":[],\""tlsProtocols\"":[],\""memoryLimitBytes\"":67108864,\""proxyServiceUrl\"":null,\""proxyProtocol\"":null,\""enableTransaction\"":true,\""dnsLookupBindAddress\"":null,\""dnsLookupBindPort\"":0,\""socks5ProxyAddress\"":null,\""socks5ProxyUsername\"":null,\""socks5ProxyPassword\"":null}\r\n[persistent://public/default/dlq] [null] Creating producer on cnx [id: 0x910a07bb, L:/10.204.68.122:45104 - R:pulsar/10.204.67.17:6650]\r\n[persistent://public/default/dlq] [pulsar-dev-5-10032] Created producer on cnx [id: 0x910a07bb, L:/10.204.68.122:45104 - R:pulsar/10.204.67.17:6650]\r\n[persistent://public/default/my-topic] failed to get schema : org.apache.pulsar.client.api.PulsarClientException: {\""errorMsg\"":\""org.apache.pulsar.broker.service.schema.exceptions.SchemaException: Bookie handle is not available - ledger=35399 - operation=Failed to read entry - entry=0\"",\""reqId\"":4059106653410978868, \""remote\"":\""pulsar/10.204.70.7:6650\"", \""local\"":\""/10.204.68.122:44372\""}\r\nDead letter producer exception with topic: persistent://public/default/dlq\r\nStarting Pulsar producer perf with config: {\""topicName\"":\""persistent://public/default/dlq\"",\""producerName\"":null,\""sendTimeoutMs\"":30000,\""blockIfQueueFull\"":false,\""maxPendingMessages\"":0,\""maxPendingMessagesAcrossPartitions\"":0,\""messageRoutingMode\"":\""RoundRobinPartition\"",\""hashingScheme\"":\""JavaStringHash\"",\""cryptoFailureAction\"":\""FAIL\"",\""batchingMaxPublishDelayMicros\"":1000,\""batchingPartitionSwitchFrequencyByPublishDelay\"":10,\""batchingMaxMessages\"":1000,\""batchingMaxBytes\"":131072,\""batchingEnabled\"":true,\""chunkingEnabled\"":false,\""chunkMaxMessageSize\"":-1,\""compressionType\"":\""NONE\"",\""initialSequenceId\"":null,\""autoUpdatePartitions\"":true,\""autoUpdatePartitionsIntervalSeconds\"":60,\""multiSchema\"":true,\""accessMode\"":\""Shared\"",\""lazyStartPartitionedProducers\"":false,\""properties\"":{},\""initialSubscriptionName\"":null}\r\nPulsar client config: {\""serviceUrl\"":\""pulsar://pulsar:6650\"",\""authPluginClassName\"":null,\""authParams\"":null,\""authParamMap\"":null,\""operationTimeoutMs\"":30000,\""lookupTimeoutMs\"":30000,\""statsIntervalSeconds\"":60,\""numIoThreads\"":1,\""numListenerThreads\"":1,\""connectionsPerBroker\"":1,\""connectionMaxIdleSeconds\"":180,\""useTcpNoDelay\"":true,\""useTls\"":false,\""tlsKeyFilePath\"":null,\""tlsCertificateFilePath\"":null,\""tlsTrustCertsFilePath\"":null,\""tlsAllowInsecureConnection\"":false,\""tlsHostnameVerificationEnable\"":false,\""concurrentLookupRequest\"":5000,\""maxLookupRequest\"":50000,\""maxLookupRedirects\"":20,\""maxNumberOfRejectedRequestPerConnection\"":50,\""keepAliveIntervalSeconds\"":30,\""connectionTimeoutMs\"":10000,\""requestTimeoutMs\"":60000,\""initialBackoffIntervalNanos\"":100000000,\""maxBackoffIntervalNanos\"":60000000000,\""enableBusyWait\"":false,\""listenerName\"":null,\""useKeyStoreTls\"":false,\""sslProvider\"":null,\""tlsKeyStoreType\"":\""JKS\"",\""tlsKeyStorePath\"":null,\""tlsKeyStorePassword\"":null,\""tlsTrustStoreType\"":\""JKS\"",\""tlsTrustStorePath\"":null,\""tlsTrustStorePassword\"":null,\""tlsCiphers\"":[],\""tlsProtocols\"":[],\""memoryLimitBytes\"":67108864,\""proxyServiceUrl\"":null,\""proxyProtocol\"":null,\""enableTransaction\"":true,\""dnsLookupBindAddress\"":null,\""dnsLookupBindPort\"":0,\""socks5ProxyAddress\"":null,\""socks5ProxyUsername\"":null,\""socks5ProxyPassword\"":null}\r\n[persistent://public/default/dlq] [null] Creating producer on cnx [id: 0x910a07bb, L:/10.204.68.122:45104 - R:pulsar/10.204.67.17:6650]\r\n[persistent://public/default/dlq] [pulsar-dev-5-10033] Created producer on cnx [id: 0x910a07bb, L:/10.204.68.122:45104 - R:pulsar/10.204.67.17:6650]\r\n[persistent://public/default/my-topic] failed to get schema : org.apache.pulsar.client.api.PulsarClientException: {\""errorMsg\"":\""org.apache.pulsar.broker.service.schema.exceptions.SchemaException: Bookie handle is not available - ledger=35399 - operation=Failed to read entry - entry=0\"",\""reqId\"":4059106653410978872, \""remote\"":\""pulsar/10.204.70.7:6650\"", \""local\"":\""/10.204.68.122:44372\""}\r\nDead letter producer exception with topic: persistent://public/default/dlq\r\nStarting Pulsar producer perf with config: {\""topicName\"":\""persistent://public/default/dlq\"",\""producerName\"":null,\""sendTimeoutMs\"":30000,\""blockIfQueueFull\"":false,\""maxPendingMessages\"":0,\""maxPendingMessagesAcrossPartitions\"":0,\""messageRoutingMode\"":\""RoundRobinPartition\"",\""hashingScheme\"":\""JavaStringHash\"",\""cryptoFailureAction\"":\""FAIL\"",\""batchingMaxPublishDelayMicros\"":1000,\""batchingPartitionSwitchFrequencyByPublishDelay\"":10,\""batchingMaxMessages\"":1000,\""batchingMaxBytes\"":131072,\""batchingEnabled\"":true,\""chunkingEnabled\"":false,\""chunkMaxMessageSize\"":-1,\""compressionType\"":\""NONE\"",\""initialSequenceId\"":null,\""autoUpdatePartitions\"":true,\""autoUpdatePartitionsIntervalSeconds\"":60,\""multiSchema\"":true,\""accessMode\"":\""Shared\"",\""lazyStartPartitionedProducers\"":false,\""properties\"":{},\""initialSubscriptionName\"":null}\r\nPulsar client config: {\""serviceUrl\"":\""pulsar://pulsar:6650\"",\""authPluginClassName\"":null,\""authParams\"":null,\""authParamMap\"":null,\""operationTimeoutMs\"":30000,\""lookupTimeoutMs\"":30000,\""statsIntervalSeconds\"":60,\""numIoThreads\"":1,\""numListenerThreads\"":1,\""connectionsPerBroker\"":1,\""connectionMaxIdleSeconds\"":180,\""useTcpNoDelay\"":true,\""useTls\"":false,\""tlsKeyFilePath\"":null,\""tlsCertificateFilePath\"":null,\""tlsTrustCertsFilePath\"":null,\""tlsAllowInsecureConnection\"":false,\""tlsHostnameVerificationEnable\"":false,\""concurrentLookupRequest\"":5000,\""maxLookupRequest\"":50000,\""maxLookupRedirects\"":20,\""maxNumberOfRejectedRequestPerConnection\"":50,\""keepAliveIntervalSeconds\"":30,\""connectionTimeoutMs\"":10000,\""requestTimeoutMs\"":60000,\""initialBackoffIntervalNanos\"":100000000,\""maxBackoffIntervalNanos\"":60000000000,\""enableBusyWait\"":false,\""listenerName\"":null,\""useKeyStoreTls\"":false,\""sslProvider\"":null,\""tlsKeyStoreType\"":\""JKS\"",\""tlsKeyStorePath\"":null,\""tlsKeyStorePassword\"":null,\""tlsTrustStoreType\"":\""JKS\"",\""tlsTrustStorePath\"":null,\""tlsTrustStorePassword\"":null,\""tlsCiphers\"":[],\""tlsProtocols\"":[],\""memoryLimitBytes\"":67108864,\""proxyServiceUrl\"":null,\""proxyProtocol\"":null,\""enableTransaction\"":true,\""dnsLookupBindAddress\"":null,\""dnsLookupBindPort\"":0,\""socks5ProxyAddress\"":null,\""socks5ProxyUsername\"":null,\""socks5ProxyPassword\"":null}\r\n[persistent://public/default/dlq] [null] Creating producer on cnx [id: 0x910a07bb, L:/10.204.68.122:45104 - R:pulsar/10.204.67.17:6650]\r\n[persistent://public/default/dlq] [pulsar-dev-5-10034] Created producer on cnx [id: 0x910a07bb, L:/10.204.68.122:45104 - R:pulsar/10.204.67.17:6650]\r\n[persistent://public/default/my-topic] failed to get schema : org.apache.pulsar.client.api.PulsarClientException: {\""errorMsg\"":\""org.apache.pulsar.broker.service.schema.exceptions.SchemaException: Bookie handle is not available - ledger=35399 - operation=Failed to read entry - entry=0\"",\""reqId\"":4059106653410978876, \""remote\"":\""pulsar/10.204.70.7:6650\"", \""local\"":\""/10.204.68.122:44372\""}\r\nDead letter producer exception with topic: persistent://public/default/dlq\r\nStarting Pulsar producer perf with config: {\""topicName\"":\""persistent://public/default/dlq\"",\""producerName\"":null,\""sendTimeoutMs\"":30000,\""blockIfQueueFull\"":false,\""maxPendingMessages\"":0,\""maxPendingMessagesAcrossPartitions\"":0,\""messageRoutingMode\"":\""RoundRobinPartition\"",\""hashingScheme\"":\""JavaStringHash\"",\""cryptoFailureAction\"":\""FAIL\"",\""batchingMaxPublishDelayMicros\"":1000,\""batchingPartitionSwitchFrequencyByPublishDelay\"":10,\""batchingMaxMessages\"":1000,\""batchingMaxBytes\"":131072,\""batchingEnabled\"":true,\""chunkingEnabled\"":false,\""chunkMaxMessageSize\"":-1,\""compressionType\"":\""NONE\"",\""initialSequenceId\"":null,\""autoUpdatePartitions\"":true,\""autoUpdatePartitionsIntervalSeconds\"":60,\""multiSchema\"":true,\""accessMode\"":\""Shared\"",\""lazyStartPartitionedProducers\"":false,\""properties\"":{},\""initialSubscriptionName\"":null}\r\nPulsar client config: {\""serviceUrl\"":\""pulsar://pulsar:6650\"",\""authPluginClassName\"":null,\""authParams\"":null,\""authParamMap\"":null,\""operationTimeoutMs\"":30000,\""lookupTimeoutMs\"":30000,\""statsIntervalSeconds\"":60,\""numIoThreads\"":1,\""numListenerThreads\"":1,\""connectionsPerBroker\"":1,\""connectionMaxIdleSeconds\"":180,\""useTcpNoDelay\"":true,\""useTls\"":false,\""tlsKeyFilePath\"":null,\""tlsCertificateFilePath\"":null,\""tlsTrustCertsFilePath\"":null,\""tlsAllowInsecureConnection\"":false,\""tlsHostnameVerificationEnable\"":false,\""concurrentLookupRequest\"":5000,\""maxLookupRequest\"":50000,\""maxLookupRedirects\"":20,\""maxNumberOfRejectedRequestPerConnection\"":50,\""keepAliveIntervalSeconds\"":30,\""connectionTimeoutMs\"":10000,\""requestTimeoutMs\"":60000,\""initialBackoffIntervalNanos\"":100000000,\""maxBackoffIntervalNanos\"":60000000000,\""enableBusyWait\"":false,\""listenerName\"":null,\""useKeyStoreTls\"":false,\""sslProvider\"":null,\""tlsKeyStoreType\"":\""JKS\"",\""tlsKeyStorePath\"":null,\""tlsKeyStorePassword\"":null,\""tlsTrustStoreType\"":\""JKS\"",\""tlsTrustStorePath\"":null,\""tlsTrustStorePassword\"":null,\""tlsCiphers\"":[],\""tlsProtocols\"":[],\""memoryLimitBytes\"":67108864,\""proxyServiceUrl\"":null,\""proxyProtocol\"":null,\""enableTransaction\"":true,\""dnsLookupBindAddress\"":null,\""dnsLookupBindPort\"":0,\""socks5ProxyAddress\"":null,\""socks5ProxyUsername\"":null,\""socks5ProxyPassword\"":null}\r\n[persistent://public/default/dlq] [null] Creating producer on cnx [id: 0x910a07bb, L:/10.204.68.122:45104 - R:pulsar/10.204.67.17:6650]\r\n[persistent://public/default/dlq] [pulsar-dev-5-10035] Created producer on cnx [id: 0x910a07bb, L:/10.204.68.122:45104 - R:pulsar/10.204.67.17:6650]\r\n[persistent://public/default/my-topic] failed to get schema : org.apache.pulsar.client.api.PulsarClientException: {\""errorMsg\"":\""org.apache.pulsar.broker.service.schema.exceptions.SchemaException: Bookie handle is not available - ledger=35399 - operation=Failed to read entry - entry=0\"",\""reqId\"":4059106653410978880, \""remote\"":\""pulsar/10.204.70.7:6650\"", \""local\"":\""/10.204.68.122:44372\""}\r\nDead letter producer exception with topic: persistent://public/default/dlq\r\n\r\n```\r\n\r\n### Are you willing to submit a PR?\r\n\r\n- [ ] I'm willing to submit a PR!"", ""issue_word_count"": 1221, ""test_files_count"": 2, ""non_test_files_count"": 3, ""pr_changed_files"": [""pulsar-broker/src/test/java/org/apache/pulsar/client/api/DeadLetterTopicTest.java"", ""pulsar-broker/src/test/java/org/apache/pulsar/client/api/RetryTopicTest.java"", ""pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerImpl.java"", ""pulsar-client/src/main/java/org/apache/pulsar/client/impl/MultiTopicsConsumerImpl.java"", ""pulsar-client/src/main/resources/findbugsExclude.xml""], ""pr_changed_test_files"": [""pulsar-broker/src/test/java/org/apache/pulsar/client/api/DeadLetterTopicTest.java"", ""pulsar-broker/src/test/java/org/apache/pulsar/client/api/RetryTopicTest.java""], ""base_commit"": ""2eb4eabc84f68fef5b29d894631c7c23d06ec3af"", ""head_commit"": ""678aadf02586d8b3f7ad461bb385a04d37b43fc4"", ""repo_url"": ""https://github.com/apache/pulsar/pull/23824"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/apache__pulsar/23824"", ""dockerfile"": """", ""pr_merged_at"": ""2025-01-09T19:10:49.000Z"", ""patch"": ""diff --git a/pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerImpl.java b/pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerImpl.java\nindex 86af4bdaf58c8..77a91a944ee6c 100644\n--- a/pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerImpl.java\n+++ b/pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerImpl.java\n@@ -67,6 +67,7 @@\n import java.util.concurrent.locks.ReadWriteLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.util.function.Function;\n+import java.util.function.Supplier;\n import java.util.stream.Collectors;\n import lombok.AccessLevel;\n import lombok.Getter;\n@@ -202,8 +203,9 @@ public class ConsumerImpl<T> extends ConsumerBase<T> implements ConnectionHandle\n     private final DeadLetterPolicy deadLetterPolicy;\n \n     private volatile CompletableFuture<Producer<byte[]>> deadLetterProducer;\n-\n+    private volatile int deadLetterProducerFailureCount;\n     private volatile CompletableFuture<Producer<byte[]>> retryLetterProducer;\n+    private volatile int retryLetterProducerFailureCount;\n     private final ReadWriteLock createProducerLock = new ReentrantReadWriteLock();\n \n     protected volatile boolean paused;\n@@ -682,9 +684,8 @@ protected CompletableFuture<Void> doReconsumeLater(Message<?> message, AckType a\n             return FutureUtil.failedFuture(exception);\n         }\n \n-        initRetryLetterProducerIfNeeded();\n         CompletableFuture<Void> result = new CompletableFuture<>();\n-        if (retryLetterProducer != null) {\n+        if (initRetryLetterProducerIfNeeded() != null) {\n             try {\n                 MessageImpl<T> retryMessage = (MessageImpl<T>) getMessageImpl(message);\n                 String originMessageIdStr = message.getMessageId().toString();\n@@ -707,52 +708,61 @@ protected CompletableFuture<Void> doReconsumeLater(Message<?> message, AckType a\n                 MessageId finalMessageId = messageId;\n                 if (reconsumeTimes > this.deadLetterPolicy.getMaxRedeliverCount()\n                         && StringUtils.isNotBlank(deadLetterPolicy.getDeadLetterTopic())) {\n-                    initDeadLetterProducerIfNeeded();\n-                    deadLetterProducer.thenAcceptAsync(dlqProducer -> {\n-                        TypedMessageBuilder<byte[]> typedMessageBuilderNew =\n-                                dlqProducer.newMessage(Schema.AUTO_PRODUCE_BYTES(retryMessage.getReaderSchema().get()))\n-                                        .value(retryMessage.getData())\n-                                        .properties(propertiesMap);\n-                        copyMessageKeysIfNeeded(message, typedMessageBuilderNew);\n-                        typedMessageBuilderNew.sendAsync().thenAccept(msgId -> {\n-                            consumerDlqMessagesCounter.increment();\n-\n-                            doAcknowledge(finalMessageId, ackType, Collections.emptyMap(), null).thenAccept(v -> {\n-                                result.complete(null);\n+                    initDeadLetterProducerIfNeeded().thenAcceptAsync(dlqProducer -> {\n+                        try {\n+                            TypedMessageBuilder<byte[]> typedMessageBuilderNew =\n+                                    dlqProducer.newMessage(\n+                                                    Schema.AUTO_PRODUCE_BYTES(retryMessage.getReaderSchema().get()))\n+                                            .value(retryMessage.getData())\n+                                            .properties(propertiesMap);\n+                            copyMessageKeysIfNeeded(message, typedMessageBuilderNew);\n+                            typedMessageBuilderNew.sendAsync().thenAccept(msgId -> {\n+                                consumerDlqMessagesCounter.increment();\n+\n+                                doAcknowledge(finalMessageId, ackType, Collections.emptyMap(), null).thenAccept(v -> {\n+                                    result.complete(null);\n+                                }).exceptionally(ex -> {\n+                                    result.completeExceptionally(ex);\n+                                    return null;\n+                                });\n                             }).exceptionally(ex -> {\n                                 result.completeExceptionally(ex);\n                                 return null;\n                             });\n-                        }).exceptionally(ex -> {\n-                            result.completeExceptionally(ex);\n-                            return null;\n-                        });\n+                        } catch (Exception e) {\n+                            result.completeExceptionally(e);\n+                        }\n                     }, internalPinnedExecutor).exceptionally(ex -> {\n                         result.completeExceptionally(ex);\n-                        deadLetterProducer = null;\n                         return null;\n                     });\n                 } else {\n                     assert retryMessage != null;\n-                    retryLetterProducer.thenAcceptAsync(rtlProducer -> {\n-                        TypedMessageBuilder<byte[]> typedMessageBuilderNew = rtlProducer\n-                                .newMessage(Schema.AUTO_PRODUCE_BYTES(message.getReaderSchema().get()))\n-                                .value(retryMessage.getData())\n-                                .properties(propertiesMap);\n-                        if (delayTime > 0) {\n-                            typedMessageBuilderNew.deliverAfter(delayTime, unit);\n+                    initRetryLetterProducerIfNeeded().thenAcceptAsync(rtlProducer -> {\n+                        try {\n+                            TypedMessageBuilder<byte[]> typedMessageBuilderNew = rtlProducer\n+                                    .newMessage(Schema.AUTO_PRODUCE_BYTES(message.getReaderSchema().get()))\n+                                    .value(retryMessage.getData())\n+                                    .properties(propertiesMap);\n+                            if (delayTime > 0) {\n+                                typedMessageBuilderNew.deliverAfter(delayTime, unit);\n+                            }\n+                            copyMessageKeysIfNeeded(message, typedMessageBuilderNew);\n+                            typedMessageBuilderNew.sendAsync()\n+                                    .thenCompose(\n+                                            __ -> doAcknowledge(finalMessageId, ackType, Collections.emptyMap(), null))\n+                                    .thenAccept(v -> {\n+                                        result.complete(null);\n+                                    })\n+                                    .exceptionally(ex -> {\n+                                        result.completeExceptionally(ex);\n+                                        return null;\n+                                    });\n+                        } catch (Exception e) {\n+                            result.completeExceptionally(e);\n                         }\n-                        copyMessageKeysIfNeeded(message, typedMessageBuilderNew);\n-                        typedMessageBuilderNew.sendAsync()\n-                                .thenCompose(__ -> doAcknowledge(finalMessageId, ackType, Collections.emptyMap(), null))\n-                                .thenAccept(v -> result.complete(null))\n-                                .exceptionally(ex -> {\n-                                    result.completeExceptionally(ex);\n-                                    return null;\n-                                });\n                     }, internalPinnedExecutor).exceptionally(ex -> {\n                         result.completeExceptionally(ex);\n-                        retryLetterProducer = null;\n                         return null;\n                     });\n                 }\n@@ -1099,10 +1109,29 @@ public void connectionFailed(PulsarClientException exception) {\n     public synchronized CompletableFuture<Void> closeAsync() {\n         CompletableFuture<Void> closeFuture = new CompletableFuture<>();\n \n+        ArrayList<CompletableFuture<Void>> closeFutures = new ArrayList<>(4);\n+        closeFutures.add(closeFuture);\n+        if (retryLetterProducer != null) {\n+            closeFutures.add(retryLetterProducer.thenCompose(p -> p.closeAsync()).whenComplete((ignore, ex) -> {\n+                if (ex != null) {\n+                    log.warn(\""Exception ignored in closing retryLetterProducer of consumer\"", ex);\n+                }\n+            }));\n+        }\n+        if (deadLetterProducer != null) {\n+            closeFutures.add(deadLetterProducer.thenCompose(p -> p.closeAsync()).whenComplete((ignore, ex) -> {\n+                if (ex != null) {\n+                    log.warn(\""Exception ignored in closing deadLetterProducer of consumer\"", ex);\n+                }\n+            }));\n+        }\n+        CompletableFuture<Void> compositeCloseFuture = FutureUtil.waitForAll(closeFutures);\n+\n+\n         if (getState() == State.Closing || getState() == State.Closed) {\n             closeConsumerTasks();\n             failPendingReceive().whenComplete((r, t) -> closeFuture.complete(null));\n-            return closeFuture;\n+            return compositeCloseFuture;\n         }\n \n         consumersClosedCounter.increment();\n@@ -1114,7 +1143,7 @@ public synchronized CompletableFuture<Void> closeAsync() {\n             deregisterFromClientCnx();\n             client.cleanupConsumer(this);\n             failPendingReceive().whenComplete((r, t) -> closeFuture.complete(null));\n-            return closeFuture;\n+            return compositeCloseFuture;\n         }\n \n         stats.getStatTimeout().ifPresent(Timeout::cancel);\n@@ -1141,23 +1170,7 @@ public synchronized CompletableFuture<Void> closeAsync() {\n             });\n         }\n \n-        ArrayList<CompletableFuture<Void>> closeFutures = new ArrayList<>(4);\n-        closeFutures.add(closeFuture);\n-        if (retryLetterProducer != null) {\n-            closeFutures.add(retryLetterProducer.thenCompose(p -> p.closeAsync()).whenComplete((ignore, ex) -> {\n-                if (ex != null) {\n-                    log.warn(\""Exception ignored in closing retryLetterProducer of consumer\"", ex);\n-                }\n-            }));\n-        }\n-        if (deadLetterProducer != null) {\n-            closeFutures.add(deadLetterProducer.thenCompose(p -> p.closeAsync()).whenComplete((ignore, ex) -> {\n-                if (ex != null) {\n-                    log.warn(\""Exception ignored in closing deadLetterProducer of consumer\"", ex);\n-                }\n-            }));\n-        }\n-        return FutureUtil.waitForAll(closeFutures);\n+        return compositeCloseFuture;\n     }\n \n     private void cleanupAtClose(CompletableFuture<Void> closeFuture, Throwable exception) {\n@@ -2216,47 +2229,54 @@ private CompletableFuture<Boolean> processPossibleToDLQ(MessageIdAdv messageId)\n         }\n         CompletableFuture<Boolean> result = new CompletableFuture<>();\n         if (deadLetterMessages != null) {\n-            initDeadLetterProducerIfNeeded();\n             List<MessageImpl<T>> finalDeadLetterMessages = deadLetterMessages;\n-            deadLetterProducer.thenAcceptAsync(producerDLQ -> {\n+            initDeadLetterProducerIfNeeded().thenAcceptAsync(producerDLQ -> {\n                 for (MessageImpl<T> message : finalDeadLetterMessages) {\n-                    String originMessageIdStr = message.getMessageId().toString();\n-                    String originTopicNameStr = getOriginTopicNameStr(message);\n-                    TypedMessageBuilder<byte[]> typedMessageBuilderNew =\n-                            producerDLQ.newMessage(Schema.AUTO_PRODUCE_BYTES(message.getReaderSchema().get()))\n-                            .value(message.getData())\n-                            .properties(getPropertiesMap(message, originMessageIdStr, originTopicNameStr));\n-                    copyMessageKeysIfNeeded(message, typedMessageBuilderNew);\n-                    typedMessageBuilderNew.sendAsync()\n-                            .thenAccept(messageIdInDLQ -> {\n-                                possibleSendToDeadLetterTopicMessages.remove(messageId);\n-                                acknowledgeAsync(messageId).whenComplete((v, ex) -> {\n-                                    if (ex != null) {\n-                                        log.warn(\""[{}] [{}] [{}] Failed to acknowledge the message {} of the original\""\n-                                                        + \"" topic but send to the DLQ successfully.\"",\n-                                                topicName, subscription, consumerName, messageId, ex);\n-                                        result.complete(false);\n+                    try {\n+                        String originMessageIdStr = message.getMessageId().toString();\n+                        String originTopicNameStr = getOriginTopicNameStr(message);\n+                        TypedMessageBuilder<byte[]> typedMessageBuilderNew =\n+                                producerDLQ.newMessage(Schema.AUTO_PRODUCE_BYTES(message.getReaderSchema().get()))\n+                                        .value(message.getData())\n+                                        .properties(getPropertiesMap(message, originMessageIdStr, originTopicNameStr));\n+                        copyMessageKeysIfNeeded(message, typedMessageBuilderNew);\n+                        typedMessageBuilderNew.sendAsync()\n+                                .thenAccept(messageIdInDLQ -> {\n+                                    possibleSendToDeadLetterTopicMessages.remove(messageId);\n+                                    acknowledgeAsync(messageId).whenComplete((v, ex) -> {\n+                                        if (ex != null) {\n+                                            log.warn(\n+                                                    \""[{}] [{}] [{}] Failed to acknowledge the message {} of the \""\n+                                                            + \""original topic but send to the DLQ successfully.\"",\n+                                                    topicName, subscription, consumerName, messageId, ex);\n+                                            result.complete(false);\n+                                        } else {\n+                                            result.complete(true);\n+                                        }\n+                                    });\n+                                }).exceptionally(ex -> {\n+                                    if (ex instanceof PulsarClientException.ProducerQueueIsFullError) {\n+                                        log.warn(\n+                                                \""[{}] [{}] [{}] Failed to send DLQ message to {} for message id {}: {}\"",\n+                                                topicName, subscription, consumerName,\n+                                                deadLetterPolicy.getDeadLetterTopic(), messageId, ex.getMessage());\n                                     } else {\n-                                        result.complete(true);\n+                                        log.warn(\""[{}] [{}] [{}] Failed to send DLQ message to {} for message id {}\"",\n+                                                topicName, subscription, consumerName,\n+                                                deadLetterPolicy.getDeadLetterTopic(), messageId, ex);\n                                     }\n+                                    result.complete(false);\n+                                    return null;\n                                 });\n-                            }).exceptionally(ex -> {\n-                                if (ex instanceof PulsarClientException.ProducerQueueIsFullError) {\n-                                    log.warn(\""[{}] [{}] [{}] Failed to send DLQ message to {} for message id {}: {}\"",\n-                                            topicName, subscription, consumerName,\n-                                            deadLetterPolicy.getDeadLetterTopic(), messageId, ex.getMessage());\n-                                } else {\n-                                    log.warn(\""[{}] [{}] [{}] Failed to send DLQ message to {} for message id {}\"",\n-                                            topicName, subscription, consumerName,\n-                                            deadLetterPolicy.getDeadLetterTopic(), messageId, ex);\n-                                }\n-                                result.complete(false);\n-                                return null;\n-                    });\n+                    } catch (Exception e) {\n+                        log.warn(\""[{}] [{}] [{}] Failed to send DLQ message to {} for message id {}\"",\n+                                topicName, subscription, consumerName, deadLetterPolicy.getDeadLetterTopic(), messageId,\n+                                e);\n+                        result.complete(false);\n+                    }\n                 }\n             }, internalPinnedExecutor).exceptionally(ex -> {\n                 log.error(\""Dead letter producer exception with topic: {}\"", deadLetterPolicy.getDeadLetterTopic(), ex);\n-                deadLetterProducer = null;\n                 result.complete(false);\n                 return null;\n             });\n@@ -2266,51 +2286,112 @@ private CompletableFuture<Boolean> processPossibleToDLQ(MessageIdAdv messageId)\n         return result;\n     }\n \n-    private void initDeadLetterProducerIfNeeded() {\n-        if (deadLetterProducer == null) {\n+    private CompletableFuture<Producer<byte[]>> initDeadLetterProducerIfNeeded() {\n+        CompletableFuture<Producer<byte[]>> p = deadLetterProducer;\n+        if (p == null || p.isCompletedExceptionally()) {\n             createProducerLock.writeLock().lock();\n             try {\n-                if (deadLetterProducer == null) {\n-                    deadLetterProducer =\n-                            ((ProducerBuilderImpl<byte[]>) client.newProducer(Schema.AUTO_PRODUCE_BYTES(schema)))\n-                                    .initialSubscriptionName(this.deadLetterPolicy.getInitialSubscriptionName())\n-                                    .topic(this.deadLetterPolicy.getDeadLetterTopic())\n-                                    .producerName(String.format(\""%s-%s-%s-%s-DLQ\"", this.topicName, this.subscription,\n-                                            this.consumerName, RandomStringUtils.randomAlphanumeric(5)))\n-                                    .blockIfQueueFull(false)\n-                                    .enableBatching(false)\n-                                    .enableChunking(true)\n-                                    .createAsync();\n-                    deadLetterProducer.thenAccept(dlqProducer -> {\n-                        stats.setDeadLetterProducerStats(dlqProducer.getStats());\n-                    });\n+                p = deadLetterProducer;\n+                if (p == null || p.isCompletedExceptionally()) {\n+                    p = createProducerWithBackOff(() -> {\n+                        CompletableFuture<Producer<byte[]>> newProducer =\n+                                ((ProducerBuilderImpl<byte[]>) client.newProducer(Schema.AUTO_PRODUCE_BYTES(schema)))\n+                                        .initialSubscriptionName(this.deadLetterPolicy.getInitialSubscriptionName())\n+                                        .topic(this.deadLetterPolicy.getDeadLetterTopic())\n+                                        .producerName(\n+                                                String.format(\""%s-%s-%s-%s-DLQ\"", this.topicName, this.subscription,\n+                                                        this.consumerName, RandomStringUtils.randomAlphanumeric(5)))\n+                                        .blockIfQueueFull(false)\n+                                        .enableBatching(false)\n+                                        .enableChunking(true)\n+                                        .createAsync();\n+                        newProducer.whenComplete((producer, ex) -> {\n+                            if (ex != null) {\n+                                log.error(\""[{}] [{}] [{}] Failed to create dead letter producer for topic {}\"",\n+                                        topicName, subscription, consumerName, deadLetterPolicy.getDeadLetterTopic(),\n+                                        ex);\n+                                deadLetterProducerFailureCount++;\n+                            } else {\n+                                deadLetterProducerFailureCount = 0;\n+                                stats.setDeadLetterProducerStats(producer.getStats());\n+                            }\n+                        });\n+                        return newProducer;\n+                    }, deadLetterProducerFailureCount, () -> \""dead letter producer (topic: \""\n+                            + deadLetterPolicy.getDeadLetterTopic() + \"")\"");\n+                    deadLetterProducer = p;\n                 }\n             } finally {\n                 createProducerLock.writeLock().unlock();\n             }\n         }\n+        return p;\n     }\n \n-    private void initRetryLetterProducerIfNeeded() {\n-        if (retryLetterProducer == null) {\n+    private CompletableFuture<Producer<byte[]>> createProducerWithBackOff(\n+            Supplier<CompletableFuture<Producer<byte[]>>> producerSupplier, int failureCount,\n+            Supplier<String> logDescription) {\n+        if (failureCount == 0) {\n+            return producerSupplier.get();\n+        } else {\n+            // calculate backoff time for given failure count\n+            Backoff backoff = new BackoffBuilder()\n+                    .setInitialTime(100, TimeUnit.MILLISECONDS)\n+                    .setMandatoryStop(client.getConfiguration().getOperationTimeoutMs() * 2,\n+                            TimeUnit.MILLISECONDS)\n+                    .setMax(1, TimeUnit.MINUTES)\n+                    .create();\n+            long backoffTimeMillis = 0;\n+            for (int i = 0; i < failureCount; i++) {\n+                backoffTimeMillis = backoff.next();\n+            }\n+            CompletableFuture<Producer<byte[]>> newProducer = new CompletableFuture<>();\n+            ScheduledExecutorService executor =\n+                    (ScheduledExecutorService) client.getScheduledExecutorProvider().getExecutor(this);\n+            log.info(\""Creating {} with backoff time of {} ms\"", logDescription.get(), backoffTimeMillis);\n+            executor.schedule(() -> {\n+                FutureUtil.completeAfter(newProducer, producerSupplier.get());\n+            }, backoffTimeMillis, TimeUnit.MILLISECONDS);\n+            return newProducer;\n+        }\n+    }\n+\n+    private CompletableFuture<Producer<byte[]>> initRetryLetterProducerIfNeeded() {\n+        CompletableFuture<Producer<byte[]>> p = retryLetterProducer;\n+        if (p == null || p.isCompletedExceptionally()) {\n             createProducerLock.writeLock().lock();\n             try {\n-                if (retryLetterProducer == null) {\n-                    retryLetterProducer = client\n-                            .newProducer(Schema.AUTO_PRODUCE_BYTES(schema))\n-                            .topic(this.deadLetterPolicy.getRetryLetterTopic())\n-                            .enableBatching(false)\n-                            .enableChunking(true)\n-                            .blockIfQueueFull(false)\n-                            .createAsync();\n-                    retryLetterProducer.thenAccept(rtlProducer -> {\n-                        stats.setRetryLetterProducerStats(rtlProducer.getStats());\n-                    });\n+                p = retryLetterProducer;\n+                if (p == null || p.isCompletedExceptionally()) {\n+                    p = createProducerWithBackOff(() -> {\n+                        CompletableFuture<Producer<byte[]>> newProducer = client\n+                                .newProducer(Schema.AUTO_PRODUCE_BYTES(schema))\n+                                .topic(this.deadLetterPolicy.getRetryLetterTopic())\n+                                .enableBatching(false)\n+                                .enableChunking(true)\n+                                .blockIfQueueFull(false)\n+                                .createAsync();\n+                        newProducer.whenComplete((producer, ex) -> {\n+                            if (ex != null) {\n+                                log.error(\""[{}] [{}] [{}] Failed to create retry letter producer for topic {}\"",\n+                                        topicName, subscription, consumerName, deadLetterPolicy.getRetryLetterTopic(),\n+                                        ex);\n+                                retryLetterProducerFailureCount++;\n+                            } else {\n+                                retryLetterProducerFailureCount = 0;\n+                                stats.setRetryLetterProducerStats(producer.getStats());\n+                            }\n+                        });\n+                        return newProducer;\n+                    }, retryLetterProducerFailureCount, () -> \""retry letter producer (topic: \""\n+                            + deadLetterPolicy.getRetryLetterTopic() + \"")\"");\n+                    retryLetterProducer = p;\n                 }\n             } finally {\n                 createProducerLock.writeLock().unlock();\n             }\n         }\n+        return p;\n     }\n \n     @Override\n\ndiff --git a/pulsar-client/src/main/java/org/apache/pulsar/client/impl/MultiTopicsConsumerImpl.java b/pulsar-client/src/main/java/org/apache/pulsar/client/impl/MultiTopicsConsumerImpl.java\nindex 6f9c5b47c55bb..341272cd69bf8 100644\n--- a/pulsar-client/src/main/java/org/apache/pulsar/client/impl/MultiTopicsConsumerImpl.java\n+++ b/pulsar-client/src/main/java/org/apache/pulsar/client/impl/MultiTopicsConsumerImpl.java\n@@ -638,7 +638,14 @@ public CompletableFuture<Void> closeAsync() {\n \n         CompletableFuture<Void> closeFuture = new CompletableFuture<>();\n         List<CompletableFuture<Void>> futureList = consumers.values().stream()\n-            .map(ConsumerImpl::closeAsync).collect(Collectors.toList());\n+            .map(consumer -> consumer.closeAsync().exceptionally(t -> {\n+                Throwable cause = FutureUtil.unwrapCompletionException(t);\n+                if (!(cause instanceof PulsarClientException.AlreadyClosedException)) {\n+                    log.warn(\""[{}] [{}] Error closing individual consumer\"", consumer.getTopic(),\n+                            consumer.getSubscription(), cause);\n+                }\n+                return null;\n+            })).collect(Collectors.toList());\n \n         FutureUtil.waitForAll(futureList)\n             .thenComposeAsync((r) -> {\n\ndiff --git a/pulsar-client/src/main/resources/findbugsExclude.xml b/pulsar-client/src/main/resources/findbugsExclude.xml\nindex 0e05d20cb9bb4..f7cf6b9cfd50e 100644\n--- a/pulsar-client/src/main/resources/findbugsExclude.xml\n+++ b/pulsar-client/src/main/resources/findbugsExclude.xml\n@@ -1043,4 +1043,8 @@\n         <Method name=\""getStats\""/>\n         <Bug pattern=\""EI_EXPOSE_REP\""/>\n     </Match>\n+    <Match>\n+        <Class name=\""org.apache.pulsar.client.impl.ConsumerImpl\""/>\n+        <Bug pattern=\""VO_VOLATILE_INCREMENT\""/>\n+    </Match>\n </FindBugsFilter>\n"", ""test_patch"": ""diff --git a/pulsar-broker/src/test/java/org/apache/pulsar/client/api/DeadLetterTopicTest.java b/pulsar-broker/src/test/java/org/apache/pulsar/client/api/DeadLetterTopicTest.java\nindex e46fddeacc117..ab26949c04fc6 100644\n--- a/pulsar-broker/src/test/java/org/apache/pulsar/client/api/DeadLetterTopicTest.java\n+++ b/pulsar-broker/src/test/java/org/apache/pulsar/client/api/DeadLetterTopicTest.java\n@@ -18,6 +18,7 @@\n  */\n package org.apache.pulsar.client.api;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.testng.Assert.assertEquals;\n import static org.testng.Assert.assertNotNull;\n import static org.testng.Assert.assertNull;\n@@ -40,9 +41,11 @@\n import lombok.Cleanup;\n import lombok.Data;\n import org.apache.avro.reflect.Nullable;\n+import org.apache.pulsar.broker.BrokerTestUtil;\n import org.apache.pulsar.client.api.schema.GenericRecord;\n import org.apache.pulsar.client.impl.ConsumerBuilderImpl;\n import org.apache.pulsar.client.util.RetryMessageUtil;\n+import org.apache.pulsar.common.policies.data.SchemaCompatibilityStrategy;\n import org.awaitility.Awaitility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -1167,4 +1170,94 @@ public void testDeadLetterPolicyDeserialize() throws Exception {\n         consumerBuilder.loadConf(config);\n         assertEquals(((ConsumerBuilderImpl)consumerBuilder).getConf().getDeadLetterPolicy(), policy);\n     }\n+\n+    @Data\n+    static class Payload {\n+        String number;\n+\n+        public Payload() {\n+\n+        }\n+\n+        public Payload(String number) {\n+            this.number = number;\n+        }\n+    }\n+\n+    @Data\n+    static class PayloadIncompatible {\n+        long number;\n+\n+        public PayloadIncompatible() {\n+\n+        }\n+\n+        public PayloadIncompatible(long number) {\n+            this.number = number;\n+        }\n+    }\n+\n+    // reproduce issue reported in https://github.com/apache/pulsar/issues/20635#issuecomment-1709616321\n+    @Test\n+    public void testCloseDeadLetterTopicProducerOnExceptionToPreventProducerLeak() throws Exception {\n+        String namespace = BrokerTestUtil.newUniqueName(\""my-property/my-ns\"");\n+        admin.namespaces().createNamespace(namespace);\n+        // don't enforce schema validation\n+        admin.namespaces().setSchemaValidationEnforced(namespace, false);\n+        // set schema compatibility strategy to always compatible\n+        admin.namespaces().setSchemaCompatibilityStrategy(namespace, SchemaCompatibilityStrategy.ALWAYS_COMPATIBLE);\n+\n+        Schema<Payload> schema = Schema.AVRO(Payload.class);\n+        Schema<PayloadIncompatible> schemaIncompatible = Schema.AVRO(PayloadIncompatible.class);\n+        String topic = BrokerTestUtil.newUniqueName(\""persistent://\"" + namespace\n+                        + \""/testCloseDeadLetterTopicProducerOnExceptionToPreventProducerLeak\"");\n+        String dlqTopic = topic + \""-DLQ\"";\n+\n+        // create topics\n+        admin.topics().createNonPartitionedTopic(topic);\n+        admin.topics().createNonPartitionedTopic(dlqTopic);\n+\n+        AtomicInteger nackCounter = new AtomicInteger(0);\n+        Consumer<Payload> payloadConsumer = null;\n+        try {\n+            payloadConsumer = pulsarClient.newConsumer(schema).topic(topic)\n+                    .subscriptionType(SubscriptionType.Shared).subscriptionName(\""sub\"")\n+                    .ackTimeout(1, TimeUnit.SECONDS)\n+                    .negativeAckRedeliveryDelay(1, TimeUnit.MILLISECONDS)\n+                    .deadLetterPolicy(DeadLetterPolicy.builder().maxRedeliverCount(3).deadLetterTopic(dlqTopic).build())\n+                    .messageListener((c, msg) -> {\n+                        if (nackCounter.incrementAndGet() < 10) {\n+                            c.negativeAcknowledge(msg);\n+                        }\n+                    }).subscribe();\n+\n+            // send a message to the topic with the incompatible schema\n+            PayloadIncompatible payloadIncompatible = new PayloadIncompatible(123);\n+            try (Producer<PayloadIncompatible> producer = pulsarClient.newProducer(schemaIncompatible).topic(topic)\n+                    .create()) {\n+                producer.send(payloadIncompatible);\n+            }\n+\n+            Thread.sleep(2000L);\n+\n+            assertThat(pulsar.getBrokerService().getTopicReference(dlqTopic).get().getProducers().size())\n+                    .describedAs(\""producer count of dlq topic %s should be <= 1 so that it doesn't leak producers\"",\n+                            dlqTopic)\n+                    .isLessThanOrEqualTo(1);\n+\n+        } finally {\n+            if (payloadConsumer != null) {\n+                try {\n+                    payloadConsumer.close();\n+                } catch (PulsarClientException e) {\n+                    // ignore\n+                }\n+            }\n+        }\n+\n+        assertThat(pulsar.getBrokerService().getTopicReference(dlqTopic).get().getProducers().size())\n+                .describedAs(\""producer count of dlq topic %s should be 0 here\"",\n+                        dlqTopic)\n+                .isEqualTo(0);\n+    }\n }\n\ndiff --git a/pulsar-broker/src/test/java/org/apache/pulsar/client/api/RetryTopicTest.java b/pulsar-broker/src/test/java/org/apache/pulsar/client/api/RetryTopicTest.java\nindex cd598585c8e87..91b97fa475817 100644\n--- a/pulsar-broker/src/test/java/org/apache/pulsar/client/api/RetryTopicTest.java\n+++ b/pulsar-broker/src/test/java/org/apache/pulsar/client/api/RetryTopicTest.java\n@@ -18,12 +18,12 @@\n  */\n package org.apache.pulsar.client.api;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.testng.Assert.assertEquals;\n import static org.testng.Assert.assertFalse;\n import static org.testng.Assert.assertNull;\n import static org.testng.Assert.assertTrue;\n import static org.testng.Assert.fail;\n-import java.lang.reflect.Field;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n@@ -36,11 +36,10 @@\n import lombok.Data;\n import org.apache.avro.AvroRuntimeException;\n import org.apache.avro.reflect.Nullable;\n+import org.apache.pulsar.broker.BrokerTestUtil;\n import org.apache.pulsar.client.api.schema.GenericRecord;\n-import org.apache.pulsar.client.impl.ConsumerImpl;\n-import org.apache.pulsar.client.impl.MultiTopicsConsumerImpl;\n import org.apache.pulsar.client.util.RetryMessageUtil;\n-import org.reflections.ReflectionUtils;\n+import org.apache.pulsar.common.policies.data.SchemaCompatibilityStrategy;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.testng.annotations.AfterMethod;\n@@ -617,10 +616,12 @@ public void testRetryTopicByCustomTopicName() throws Exception {\n \n     @Test(timeOut = 30000L)\n     public void testRetryTopicException() throws Exception {\n-        final String topic = \""persistent://my-property/my-ns/retry-topic\"";\n+        String retryLetterTopic = BrokerTestUtil.newUniqueName(\""persistent://my-property/my-ns/retry-topic\"");\n+        final String topic = BrokerTestUtil.newUniqueName(\""persistent://my-property/my-ns/input-topic\"");\n         final int maxRedeliveryCount = 2;\n         final int sendMessages = 1;\n         // subscribe before publish\n+        @Cleanup\n         Consumer<byte[]> consumer = pulsarClient.newConsumer(Schema.BYTES)\n                 .topic(topic)\n                 .subscriptionName(\""my-subscription\"")\n@@ -629,7 +630,7 @@ public void testRetryTopicException() throws Exception {\n                 .receiverQueueSize(100)\n                 .deadLetterPolicy(DeadLetterPolicy.builder()\n                         .maxRedeliverCount(maxRedeliveryCount)\n-                        .retryLetterTopic(\""persistent://my-property/my-ns/my-subscription-custom-Retry\"")\n+                        .retryLetterTopic(retryLetterTopic)\n                         .build())\n                 .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)\n                 .subscribe();\n@@ -642,30 +643,16 @@ public void testRetryTopicException() throws Exception {\n         }\n         producer.close();\n \n-        // mock a retry producer exception when reconsumelater is called\n-        MultiTopicsConsumerImpl<byte[]> multiTopicsConsumer = (MultiTopicsConsumerImpl<byte[]>) consumer;\n-        List<ConsumerImpl<byte[]>> consumers = multiTopicsConsumer.getConsumers();\n-        for (ConsumerImpl<byte[]> c : consumers) {\n-            Set<Field> deadLetterPolicyField =\n-                    ReflectionUtils.getAllFields(c.getClass(), ReflectionUtils.withName(\""deadLetterPolicy\""));\n-\n-            if (deadLetterPolicyField.size() != 0) {\n-                Field field = deadLetterPolicyField.iterator().next();\n-                field.setAccessible(true);\n-                DeadLetterPolicy deadLetterPolicy = (DeadLetterPolicy) field.get(c);\n-                deadLetterPolicy.setRetryLetterTopic(\""#persistent://invlaid-topic#\"");\n-            }\n-        }\n+        admin.topics().terminateTopic(retryLetterTopic);\n+\n         Message<byte[]> message = consumer.receive();\n         log.info(\""consumer received message : {} {}\"", message.getMessageId(), new String(message.getData()));\n         try {\n             consumer.reconsumeLater(message, 1, TimeUnit.SECONDS);\n-        } catch (PulsarClientException.InvalidTopicNameException e) {\n-            assertEquals(e.getClass(), PulsarClientException.InvalidTopicNameException.class);\n-        } catch (Exception e) {\n-            fail(\""exception should be PulsarClientException.InvalidTopicNameException\"");\n+            fail(\""exception should be PulsarClientException.TopicTerminatedException\"");\n+        } catch (PulsarClientException.TopicTerminatedException e) {\n+            // ok\n         }\n-        consumer.close();\n     }\n \n \n@@ -718,10 +705,12 @@ public void testRetryProducerWillCloseByConsumer() throws Exception {\n \n     @Test(timeOut = 30000L)\n     public void testRetryTopicExceptionWithConcurrent() throws Exception {\n-        final String topic = \""persistent://my-property/my-ns/retry-topic\"";\n+        String retryLetterTopic = BrokerTestUtil.newUniqueName(\""persistent://my-property/my-ns/retry-topic\"");\n+        final String topic = BrokerTestUtil.newUniqueName(\""persistent://my-property/my-ns/input-topic\"");\n         final int maxRedeliveryCount = 2;\n         final int sendMessages = 10;\n         // subscribe before publish\n+        @Cleanup\n         Consumer<byte[]> consumer = pulsarClient.newConsumer(Schema.BYTES)\n                 .topic(topic)\n                 .subscriptionName(\""my-subscription\"")\n@@ -730,7 +719,7 @@ public void testRetryTopicExceptionWithConcurrent() throws Exception {\n                 .receiverQueueSize(100)\n                 .deadLetterPolicy(DeadLetterPolicy.builder()\n                         .maxRedeliverCount(maxRedeliveryCount)\n-                        .retryLetterTopic(\""persistent://my-property/my-ns/my-subscription-custom-Retry\"")\n+                        .retryLetterTopic(retryLetterTopic)\n                         .build())\n                 .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)\n                 .subscribe();\n@@ -739,24 +728,11 @@ public void testRetryTopicExceptionWithConcurrent() throws Exception {\n                 .topic(topic)\n                 .create();\n         for (int i = 0; i < sendMessages; i++) {\n-            producer.newMessage().key(\""1\"").value(String.format(\""Hello Pulsar [%d]\"", i).getBytes()).send();\n+            producer.send(String.format(\""Hello Pulsar [%d]\"", i).getBytes());\n         }\n         producer.close();\n \n-        // mock a retry producer exception when reconsumelater is called\n-        MultiTopicsConsumerImpl<byte[]> multiTopicsConsumer = (MultiTopicsConsumerImpl<byte[]>) consumer;\n-        List<ConsumerImpl<byte[]>> consumers = multiTopicsConsumer.getConsumers();\n-        for (ConsumerImpl<byte[]> c : consumers) {\n-            Set<Field> deadLetterPolicyField =\n-                    ReflectionUtils.getAllFields(c.getClass(), ReflectionUtils.withName(\""deadLetterPolicy\""));\n-\n-            if (deadLetterPolicyField.size() != 0) {\n-                Field field = deadLetterPolicyField.iterator().next();\n-                field.setAccessible(true);\n-                DeadLetterPolicy deadLetterPolicy = (DeadLetterPolicy) field.get(c);\n-                deadLetterPolicy.setRetryLetterTopic(\""#persistent://invalid-topic#\"");\n-            }\n-        }\n+        admin.topics().terminateTopic(retryLetterTopic);\n \n         List<Message<byte[]>> messages = Lists.newArrayList();\n         for (int i = 0; i < sendMessages; i++) {\n@@ -769,16 +745,114 @@ public void testRetryTopicExceptionWithConcurrent() throws Exception {\n             new Thread(() -> {\n                 try {\n                     consumer.reconsumeLater(message, 1, TimeUnit.SECONDS);\n-                } catch (Exception ignore) {\n-\n-                } finally {\n+                } catch (PulsarClientException.TopicTerminatedException e) {\n+                    // ok\n                     latch.countDown();\n+                } catch (PulsarClientException e) {\n+                    // unexpected exception\n+                    fail(\""unexpected exception\"", e);\n                 }\n             }).start();\n         }\n \n-        latch.await();\n+        latch.await(sendMessages, TimeUnit.SECONDS);\n         consumer.close();\n     }\n \n+    @Data\n+    static class Payload {\n+        String number;\n+\n+        public Payload() {\n+\n+        }\n+\n+        public Payload(String number) {\n+            this.number = number;\n+        }\n+    }\n+\n+    @Data\n+    static class PayloadIncompatible {\n+        long number;\n+\n+        public PayloadIncompatible() {\n+\n+        }\n+\n+        public PayloadIncompatible(long number) {\n+            this.number = number;\n+        }\n+    }\n+\n+    // reproduce similar issue as reported in https://github.com/apache/pulsar/issues/20635#issuecomment-1709616321\n+    // but for retry topic\n+    @Test\n+    public void testCloseRetryLetterTopicProducerOnExceptionToPreventProducerLeak() throws Exception {\n+        String namespace = BrokerTestUtil.newUniqueName(\""my-property/my-ns\"");\n+        admin.namespaces().createNamespace(namespace);\n+        // don't enforce schema validation\n+        admin.namespaces().setSchemaValidationEnforced(namespace, false);\n+        // set schema compatibility strategy to always compatible\n+        admin.namespaces().setSchemaCompatibilityStrategy(namespace, SchemaCompatibilityStrategy.ALWAYS_COMPATIBLE);\n+\n+        Schema<Payload> schema = Schema.AVRO(Payload.class);\n+        Schema<PayloadIncompatible> schemaIncompatible = Schema.AVRO(\n+                PayloadIncompatible.class);\n+        String topic = BrokerTestUtil.newUniqueName(\""persistent://\"" + namespace\n+                + \""/testCloseDeadLetterTopicProducerOnExceptionToPreventProducerLeak\"");\n+        String dlqTopic = topic + \""-DLQ\"";\n+        String retryTopic = topic + \""-RETRY\"";\n+\n+        // create topics\n+        admin.topics().createNonPartitionedTopic(topic);\n+        admin.topics().createNonPartitionedTopic(dlqTopic);\n+        admin.topics().createNonPartitionedTopic(retryTopic);\n+\n+        Consumer<Payload> payloadConsumer = null;\n+        try {\n+            payloadConsumer = pulsarClient.newConsumer(schema).topic(topic)\n+                    .subscriptionType(SubscriptionType.Shared).subscriptionName(\""sub\"")\n+                    .ackTimeout(1, TimeUnit.SECONDS)\n+                    .negativeAckRedeliveryDelay(1, TimeUnit.MILLISECONDS)\n+                    .enableRetry(true)\n+                    .deadLetterPolicy(DeadLetterPolicy.builder().retryLetterTopic(retryTopic).maxRedeliverCount(3)\n+                            .deadLetterTopic(dlqTopic).build())\n+                    .messageListener((c, msg) -> {\n+                        try {\n+                            c.reconsumeLater(msg, 1, TimeUnit.MILLISECONDS);\n+                        } catch (PulsarClientException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }).subscribe();\n+\n+            // send a message to the topic with the incompatible schema\n+            PayloadIncompatible payloadIncompatible = new PayloadIncompatible(123);\n+            try (Producer<PayloadIncompatible> producer = pulsarClient.newProducer(schemaIncompatible).topic(topic)\n+                    .create()) {\n+                producer.send(payloadIncompatible);\n+            }\n+\n+            Thread.sleep(2000L);\n+\n+            assertThat(pulsar.getBrokerService().getTopicReference(retryTopic).get().getProducers().size())\n+                    .describedAs(\""producer count of retry topic %s should be <= 1 so that it doesn't leak producers\"",\n+                            retryTopic)\n+                    .isLessThanOrEqualTo(1);\n+\n+        } finally {\n+            if (payloadConsumer != null) {\n+                try {\n+                    payloadConsumer.close();\n+                } catch (PulsarClientException e) {\n+                    // ignore\n+                }\n+            }\n+        }\n+\n+        assertThat(pulsar.getBrokerService().getTopicReference(retryTopic).get().getProducers().size())\n+                .describedAs(\""producer count of retry topic %s should be 0 here\"",\n+                        retryTopic)\n+                .isEqualTo(0);\n+    }\n }\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""apache__pulsar-23811"", ""pr_id"": 23811, ""issue_id"": 23705, ""repo"": ""apache/pulsar"", ""problem_statement"": ""[Bug] Pulsar Function processing time doesn't get properly recorded for asynchronous functions\n### Search before asking\r\n\r\n- [X] I searched in the [issues](https://github.com/apache/pulsar/issues) and found nothing similar.\r\n\r\n\r\n### Read release policy\r\n\r\n- [X] I understand that unsupported versions don't get bug fixes. I will attempt to reproduce the issue on a supported version of Pulsar client and Pulsar broker.\r\n\r\n\r\n### Version\r\n\r\nany released version\r\n\r\n### Minimal reproduce step\r\n\r\nIn the code, it can be seen that asynchronous functions don't get handled properly. `stats.processTimeEnd()` gets called immediately when the result is returned:\r\nhttps://github.com/apache/pulsar/blob/6fe8100b1fd5d37a6e1bf33803a8904fa3879321/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstanceRunnable.java#L337-L355\r\n\r\n\r\n### What did you expect to see?\r\n\r\nasynchronous functions would also be handled\r\n\r\n### What did you see instead?\r\n\r\nasynchronous functions have invalid processing time stats\r\n\r\n### Anything else?\r\n\r\nThe current processing metric for async functions includes the time for doing the async calls and the waiting time when the concurrency limit is reached. The metric is useful for this purpose. \r\nIt doesn't tell the actual end-to-completion processing time which contains the async processing time.\r\n\r\n### Are you willing to submit a PR?\r\n\r\n- [ ] I'm willing to submit a PR!"", ""issue_word_count"": 206, ""test_files_count"": 2, ""non_test_files_count"": 8, ""pr_changed_files"": [""pulsar-broker/src/test/java/org/apache/pulsar/io/PulsarFunctionE2ETest.java"", ""pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaExecutionResult.java"", ""pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstance.java"", ""pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstanceRunnable.java"", ""pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/ComponentStatsManager.java"", ""pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/FunctionStatsManager.java"", ""pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/SinkStatsManager.java"", ""pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/SourceStatsManager.java"", ""pulsar-functions/instance/src/main/resources/findbugsExclude.xml"", ""pulsar-functions/instance/src/test/java/org/apache/pulsar/functions/instance/JavaInstanceRunnableTest.java""], ""pr_changed_test_files"": [""pulsar-broker/src/test/java/org/apache/pulsar/io/PulsarFunctionE2ETest.java"", ""pulsar-functions/instance/src/test/java/org/apache/pulsar/functions/instance/JavaInstanceRunnableTest.java""], ""base_commit"": ""420f62eef20aaef49ae404a683f2d5466ccfdec3"", ""head_commit"": ""f771093987e948eefe482a0ac939411efeb6a300"", ""repo_url"": ""https://github.com/apache/pulsar/pull/23811"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/apache__pulsar/23811"", ""dockerfile"": """", ""pr_merged_at"": ""2025-01-28T16:03:11.000Z"", ""patch"": ""diff --git a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaExecutionResult.java b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaExecutionResult.java\nindex 5856600196b49..9ca9aa2a879d4 100644\n--- a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaExecutionResult.java\n+++ b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaExecutionResult.java\n@@ -29,9 +29,5 @@\n public class JavaExecutionResult {\n     private Throwable userException;\n     private Object result;\n-\n-    public void reset() {\n-        setUserException(null);\n-        setResult(null);\n-    }\n+    private final long startTime = System.nanoTime();\n }\n\ndiff --git a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstance.java b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstance.java\nindex 5946be9fe5be9..c5f82898f8251 100644\n--- a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstance.java\n+++ b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstance.java\n@@ -47,6 +47,7 @@ public class JavaInstance implements AutoCloseable {\n     public static class AsyncFuncRequest {\n         private final Record record;\n         private final CompletableFuture processResult;\n+        private final JavaExecutionResult result;\n     }\n \n     @Getter(AccessLevel.PACKAGE)\n@@ -136,7 +137,7 @@ public JavaExecutionResult handleMessage(Record<?> record, Object input,\n                 if (asyncPreserveInputOrderForOutputMessages) {\n                     // Function is in format: Function<I, CompletableFuture<O>>\n                     AsyncFuncRequest request = new AsyncFuncRequest(\n-                            record, (CompletableFuture) output\n+                            record, (CompletableFuture) output, executionResult\n                     );\n                     pendingAsyncRequests.put(request);\n                 } else {\n@@ -148,13 +149,12 @@ public JavaExecutionResult handleMessage(Record<?> record, Object input,\n                             processAsyncResultsInInputOrder(asyncResultConsumer);\n                         } else {\n                             try {\n-                                JavaExecutionResult execResult = new JavaExecutionResult();\n                                 if (cause != null) {\n-                                    execResult.setUserException(FutureUtil.unwrapCompletionException(cause));\n+                                    executionResult.setUserException(FutureUtil.unwrapCompletionException(cause));\n                                 } else {\n-                                    execResult.setResult(res);\n+                                    executionResult.setResult(res);\n                                 }\n-                                asyncResultConsumer.accept(record, execResult);\n+                                asyncResultConsumer.accept(record, executionResult);\n                             } finally {\n                                 asyncRequestsConcurrencyLimiter.release();\n                             }\n@@ -187,7 +187,7 @@ private void processAsyncResultsInInputOrder(JavaInstanceRunnable.AsyncResultCon\n         while (asyncResult != null && asyncResult.getProcessResult().isDone()) {\n             pendingAsyncRequests.remove(asyncResult);\n \n-            JavaExecutionResult execResult = new JavaExecutionResult();\n+            JavaExecutionResult execResult = asyncResult.getResult();\n             try {\n                 Object result = asyncResult.getProcessResult().get();\n                 execResult.setResult(result);\n\ndiff --git a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstanceRunnable.java b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstanceRunnable.java\nindex 4f811c14704a0..cfb7e9536a3e6 100644\n--- a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstanceRunnable.java\n+++ b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstanceRunnable.java\n@@ -334,8 +334,6 @@ public void run() {\n                 // set last invocation time\n                 stats.setLastInvocation(System.currentTimeMillis());\n \n-                // start time for process latency stat\n-                stats.processTimeStart();\n \n                 // process the message\n                 Thread.currentThread().setContextClassLoader(functionClassLoader);\n@@ -346,9 +344,6 @@ public void run() {\n                         asyncErrorHandler);\n                 Thread.currentThread().setContextClassLoader(instanceClassLoader);\n \n-                // register end time\n-                stats.processTimeEnd();\n-\n                 if (result != null) {\n                     // process the synchronous results\n                     handleResult(currentRecord, result);\n@@ -448,6 +443,8 @@ void handleResult(Record srcRecord, JavaExecutionResult result) throws Exception\n             // increment total successfully processed\n             stats.incrTotalProcessedSuccessfully();\n         }\n+        // handle endTime here\n+        stats.processTimeEnd(result.getStartTime());\n     }\n \n     private void sendOutputMessage(Record srcRecord, Object output) throws Exception {\n@@ -631,6 +628,11 @@ public String getStatsAsString() throws IOException {\n         return \""\"";\n     }\n \n+    @VisibleForTesting\n+    void setStats(ComponentStatsManager stats) {\n+        this.stats = stats;\n+    }\n+\n     public InstanceCommunication.MetricsData getAndResetMetrics() {\n         if (isInitialized) {\n             statsLock.writeLock().lock();\n\ndiff --git a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/ComponentStatsManager.java b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/ComponentStatsManager.java\nindex 6da3c082f78f4..17321735256eb 100644\n--- a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/ComponentStatsManager.java\n+++ b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/ComponentStatsManager.java\n@@ -100,9 +100,8 @@ public ComponentStatsManager(FunctionCollectorRegistry collectorRegistry,\n \n     public abstract void setLastInvocation(long ts);\n \n-    public abstract void processTimeStart();\n \n-    public abstract void processTimeEnd();\n+    public abstract void processTimeEnd(long startTime);\n \n     public abstract double getTotalProcessedSuccessfully();\n \n\ndiff --git a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/FunctionStatsManager.java b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/FunctionStatsManager.java\nindex 8737c8a4fa913..0009fcea6671a 100644\n--- a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/FunctionStatsManager.java\n+++ b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/FunctionStatsManager.java\n@@ -336,20 +336,13 @@ public void setLastInvocation(long ts) {\n         statlastInvocationChild.set(ts);\n     }\n \n-    private Long processTimeStart;\n \n-    @Override\n-    public void processTimeStart() {\n-        processTimeStart = System.nanoTime();\n-    }\n \n     @Override\n-    public void processTimeEnd() {\n-        if (processTimeStart != null) {\n-            double endTimeMs = ((double) System.nanoTime() - processTimeStart) / 1.0E6D;\n+    public void processTimeEnd(long startTime) {\n+            double endTimeMs = ((double) System.nanoTime() - startTime) / 1.0E6D;\n             statProcessLatencyChild.observe(endTimeMs);\n             statProcessLatency1minChild.observe(endTimeMs);\n-        }\n     }\n \n     @Override\n\ndiff --git a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/SinkStatsManager.java b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/SinkStatsManager.java\nindex c515ce6bc872c..4fae7f9c292d1 100644\n--- a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/SinkStatsManager.java\n+++ b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/SinkStatsManager.java\n@@ -279,13 +279,9 @@ public void setLastInvocation(long ts) {\n         statlastInvocationChild.set(ts);\n     }\n \n-    @Override\n-    public void processTimeStart() {\n-        //no-op\n-    }\n \n     @Override\n-    public void processTimeEnd() {\n+    public void processTimeEnd(long startTime) {\n         //no-op\n     }\n \n\ndiff --git a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/SourceStatsManager.java b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/SourceStatsManager.java\nindex 1f7e159c4dcb5..b68e1d610f7d3 100644\n--- a/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/SourceStatsManager.java\n+++ b/pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/stats/SourceStatsManager.java\n@@ -279,13 +279,9 @@ public void setLastInvocation(long ts) {\n         statlastInvocationChild.set(ts);\n     }\n \n-    @Override\n-    public void processTimeStart() {\n-        //no-op\n-    }\n \n     @Override\n-    public void processTimeEnd() {\n+    public void processTimeEnd(long startTime) {\n         //no-op\n     }\n \n\ndiff --git a/pulsar-functions/instance/src/main/resources/findbugsExclude.xml b/pulsar-functions/instance/src/main/resources/findbugsExclude.xml\nindex 40e3e91112328..ffe23993eb702 100644\n--- a/pulsar-functions/instance/src/main/resources/findbugsExclude.xml\n+++ b/pulsar-functions/instance/src/main/resources/findbugsExclude.xml\n@@ -557,4 +557,9 @@\n     <Method name=\""setSourceInputSpecs\""/>\n     <Bug pattern=\""EI_EXPOSE_REP2\""/>\n   </Match>\n+  <Match>\n+    <Class name=\""org.apache.pulsar.functions.instance.JavaInstance$AsyncFuncRequest\""/>\n+    <Method name=\""getResult\""/>\n+    <Bug pattern=\""EI_EXPOSE_REP\""/>\n+  </Match>\n </FindBugsFilter>\n"", ""test_patch"": ""diff --git a/pulsar-broker/src/test/java/org/apache/pulsar/io/PulsarFunctionE2ETest.java b/pulsar-broker/src/test/java/org/apache/pulsar/io/PulsarFunctionE2ETest.java\nindex 74c2a93b84e9f..aef75e5fc7efb 100644\n--- a/pulsar-broker/src/test/java/org/apache/pulsar/io/PulsarFunctionE2ETest.java\n+++ b/pulsar-broker/src/test/java/org/apache/pulsar/io/PulsarFunctionE2ETest.java\n@@ -64,6 +64,7 @@\n import org.apache.pulsar.common.policies.data.TopicStats;\n import org.apache.pulsar.compaction.PublishingOrderCompactor;\n import org.apache.pulsar.functions.api.Context;\n+import org.apache.pulsar.functions.api.examples.JavaNativeAsyncExclamationFunction;\n import org.apache.pulsar.functions.instance.InstanceUtils;\n import org.apache.pulsar.functions.utils.FunctionCommon;\n import org.apache.pulsar.functions.worker.FunctionRuntimeManager;\n@@ -296,6 +297,100 @@ public void testReadCompactedFunction() throws Exception {\n         producer.close();\n     }\n \n+    @Test(timeOut = 20000)\n+    public void testPulsarFunctionAsyncStatTime() throws Exception {\n+        final String namespacePortion = \""io\"";\n+        final String replNamespace = tenant + \""/\"" + namespacePortion;\n+        final String sourceTopic = \""persistent://\"" + replNamespace + \""/my-topic1\"";\n+        final String sinkTopic = \""persistent://\"" + replNamespace + \""/output\"";\n+        final String functionName = \""JavaNativeAsyncExclamationFunction\"";\n+        final String subscriptionName = \""test-sub\"";\n+        admin.namespaces().createNamespace(replNamespace);\n+        Set<String> clusters = Sets.newHashSet(Lists.newArrayList(\""use\""));\n+        admin.namespaces().setNamespaceReplicationClusters(replNamespace, clusters);\n+\n+        FunctionConfig functionConfig = new FunctionConfig();\n+        functionConfig.setTenant(tenant);\n+        functionConfig.setNamespace(namespacePortion);\n+        functionConfig.setName(functionName);\n+        functionConfig.setParallelism(1);\n+        functionConfig.setSubName(subscriptionName);\n+        functionConfig.setInputSpecs(Collections.singletonMap(sourceTopic,\n+                ConsumerConfig.builder().poolMessages(true).build()));\n+        functionConfig.setAutoAck(true);\n+        functionConfig.setClassName(JavaNativeAsyncExclamationFunction.class.getName());\n+        functionConfig.setRuntime(FunctionConfig.Runtime.JAVA);\n+        functionConfig.setOutput(sinkTopic);\n+        functionConfig.setCleanupSubscription(true);\n+        functionConfig.setProcessingGuarantees(FunctionConfig.ProcessingGuarantees.ATLEAST_ONCE);\n+\n+        admin.functions().createFunctionWithUrl(functionConfig,\n+                PulsarFunctionE2ETest.class.getProtectionDomain().getCodeSource().getLocation().toURI().toString());\n+\n+        // create a producer that creates a topic at broker\n+        Producer<String> producer = pulsarClient.newProducer(Schema.STRING).topic(sourceTopic).create();\n+        Consumer<String> consumer =\n+                pulsarClient.newConsumer(Schema.STRING).topic(sinkTopic).subscriptionName(subscriptionName).subscribe();\n+\n+        retryStrategically((test) -> {\n+            try {\n+                return admin.topics().getStats(sourceTopic).getSubscriptions().size() == 1;\n+            } catch (PulsarAdminException e) {\n+                return false;\n+            }\n+        }, 50, 150);\n+        retryStrategically((test) -> {\n+            try {\n+                return admin.topics().getStats(sinkTopic).getSubscriptions().size() == 1;\n+            } catch (PulsarAdminException e) {\n+                return false;\n+            }\n+        }, 50, 150);\n+        // validate pulsar sink consumer has started on the topic\n+        assertEquals(admin.topics().getStats(sourceTopic).getSubscriptions().size(), 1);\n+        assertEquals(admin.topics().getStats(sinkTopic).getSubscriptions().size(), 1);\n+\n+        int cntMsg = 5;\n+        for (int i = 0; i < cntMsg; i++) {\n+            producer.newMessage().value(\""it is the \"" + i + \""th message , it will spend 500ms\"").send();\n+        }\n+        Awaitility.await().ignoreExceptions().untilAsserted(() -> {\n+            SubscriptionStats subStats = admin.topics().getStats(sourceTopic).getSubscriptions().get(subscriptionName);\n+            assertEquals(subStats.getUnackedMessages(), 0);\n+        });\n+        int count = 0;\n+        while (true) {\n+            Message<String> message = consumer.receive(10, TimeUnit.SECONDS);\n+            if (message == null) {\n+                break;\n+            }\n+            consumer.acknowledge(message);\n+            count++;\n+        }\n+        Assert.assertEquals(count, cntMsg);\n+\n+        String prometheusMetrics = TestPulsarFunctionUtils.getPrometheusMetrics(pulsar.getListenPortHTTP().get());\n+        log.info(\""prometheus metrics: {}\"", prometheusMetrics);\n+        Map<String, TestPulsarFunctionUtils.Metric> statsMetrics =\n+                TestPulsarFunctionUtils.parseMetrics(prometheusMetrics);\n+\n+        assertEquals(statsMetrics.get(\""pulsar_function_process_latency_ms\"").value, 500.0, 100.0);\n+        admin.functions().deleteFunction(tenant, namespacePortion, functionName);\n+\n+        retryStrategically((test) -> {\n+            try {\n+                return admin.topics().getStats(sourceTopic).getSubscriptions().size() == 0;\n+            } catch (PulsarAdminException e) {\n+                return false;\n+            }\n+        }, 50, 150);\n+\n+        // make sure subscriptions are cleanup\n+        assertEquals(admin.topics().getStats(sourceTopic).getSubscriptions().size(), 0);\n+\n+        tempDirectory.assertThatFunctionDownloadTempFilesHaveBeenDeleted();\n+    }\n+\n     @Test(timeOut = 20000)\n     public void testPulsarFunctionStats() throws Exception {\n \n\ndiff --git a/pulsar-functions/instance/src/test/java/org/apache/pulsar/functions/instance/JavaInstanceRunnableTest.java b/pulsar-functions/instance/src/test/java/org/apache/pulsar/functions/instance/JavaInstanceRunnableTest.java\nindex c83648132d488..385d78e671727 100644\n--- a/pulsar-functions/instance/src/test/java/org/apache/pulsar/functions/instance/JavaInstanceRunnableTest.java\n+++ b/pulsar-functions/instance/src/test/java/org/apache/pulsar/functions/instance/JavaInstanceRunnableTest.java\n@@ -24,7 +24,9 @@\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n+\n import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.time.Duration;\n@@ -36,6 +38,7 @@\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.atomic.AtomicReference;\n+\n import lombok.Getter;\n import lombok.Setter;\n import lombok.extern.slf4j.Slf4j;\n@@ -50,6 +53,7 @@\n import org.apache.pulsar.functions.api.Record;\n import org.apache.pulsar.functions.api.SerDe;\n import org.apache.pulsar.functions.instance.stats.ComponentStatsManager;\n+import org.apache.pulsar.functions.instance.stats.FunctionStatsManager;\n import org.apache.pulsar.functions.proto.Function.FunctionDetails;\n import org.apache.pulsar.functions.proto.Function.SinkSpec;\n import org.apache.pulsar.functions.proto.Function.SourceSpec;\n@@ -61,6 +65,7 @@\n import org.apache.pulsar.io.core.SourceContext;\n import org.awaitility.Awaitility;\n import org.jetbrains.annotations.NotNull;\n+import org.mockito.ArgumentCaptor;\n import org.testng.Assert;\n import org.testng.annotations.AfterClass;\n import org.testng.annotations.AfterMethod;\n@@ -173,6 +178,24 @@ public Void process(String input, Context context) throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testFunctionAsyncTime() throws Exception {\n+        FunctionDetails functionDetails = FunctionDetails.newBuilder()\n+                .setAutoAck(true)\n+                .setProcessingGuarantees(org.apache.pulsar.functions.proto.Function.ProcessingGuarantees.MANUAL)\n+                .build();\n+        JavaInstanceRunnable javaInstanceRunnable = createRunnable(functionDetails);\n+        FunctionStatsManager manager = mock(FunctionStatsManager.class);\n+        javaInstanceRunnable.setStats(manager);\n+        JavaExecutionResult javaExecutionResult = new JavaExecutionResult();\n+        Thread.sleep(500);\n+        Record record = mock(Record.class);\n+        javaInstanceRunnable.handleResult(record, javaExecutionResult);\n+        ArgumentCaptor<Long> timeCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(manager).processTimeEnd(timeCaptor.capture());\n+        Assert.assertEquals(timeCaptor.getValue(), javaExecutionResult.getStartTime());\n+    }\n+\n     @Test\n     public void testFunctionResultNull() throws Exception {\n         JavaExecutionResult javaExecutionResult = new JavaExecutionResult();\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""apache__pulsar-23676"", ""pr_id"": 23676, ""issue_id"": 23670, ""repo"": ""apache/pulsar"", ""problem_statement"": ""[Bug] `onFilter` method in custom `BrokerInterceptor` doesn't get called\n### Search before asking\n\n- [X] I searched in the [issues](https://github.com/apache/pulsar/issues) and found nothing similar.\n\n\n### Read release policy\n\n- [X] I understand that unsupported versions don't get bug fixes. I will attempt to reproduce the issue on a supported version of Pulsar client and Pulsar broker.\n\n\n### Version\n\nmaster(f27905560207eb2ade32f8086b4585dffb918b80)\n\n### Minimal reproduce step\n\n1. implement a simple `BrokerInterceptor` like below, and build a nar package for it:\r\n\r\n  ```\r\n  public class TestFilter implements BrokerInterceptor {\r\n      private static final Logger log = LoggerFactory.getLogger(TestFilter.class);\r\n      @Override\r\n      public void onPulsarCommand(BaseCommand command, ServerCnx cnx) {\r\n      }\r\n  \r\n      @Override\r\n      public void onConnectionClosed(ServerCnx cnx) {\r\n      }\r\n  \r\n      @Override\r\n      public void onWebserviceRequest(ServletRequest request) {\r\n      }\r\n  \r\n      @Override\r\n      public void onWebserviceResponse(ServletRequest request, ServletResponse response) {\r\n      }\r\n  \r\n      @Override\r\n      public void initialize(PulsarService pulsarService) {\r\n      }\r\n  \r\n      @Override\r\n      public void onFilter(ServletRequest request, ServletResponse response, FilterChain chain)\r\n              throws ServletException, IOException {\r\n          log.info(\""====test\"");\r\n          chain.doFilter(request, response);\r\n      }\r\n  \r\n      @Override\r\n      public void close() {\r\n  \r\n      }\r\n  }\r\n  ```\r\n\r\n2. edit the `standalone.conf`, and update the `brokerInterceptors=` field to the `test-filter`\r\n3. start the pulsar service in standalone mode\r\n4. call `pulsar-admin tenants list` to fire a http request\n\n### What did you expect to see?\n\nthe pulsar process should printed below logs:\r\n\r\n```\r\n====test\r\n```\n\n### What did you see instead?\n\nthe `====test` logs doesn't get printed\n\n### Anything else?\n\nThe issue lies in the implementation:\r\n\r\nAlthough [PR #10489](https://github.com/apache/pulsar/pull/10489) introduced an `onFilter` method in the `BrokerInterceptor` interface, the `PulsarService` is hardcoded to use `BrokerInterceptors` as the entry interceptor. Custom interceptors configured via the `brokerInterceptors=` parameter are loaded into `BrokerInterceptors` and executed sequentially. However, `BrokerInterceptors` does not override the `onFilter` method, causing it to fall back to the default implementation:\r\n\r\n```java\r\ndefault void onFilter(ServletRequest request, ServletResponse response, FilterChain chain)\r\n        throws IOException, ServletException {\r\n    // Just continue the chain by default.\r\n    chain.doFilter(request, response);\r\n}\r\n```\r\n\r\nAs a result, even if a custom `BrokerInterceptor` implements the `onFilter` method, it is never invoked.\r\n\r\nThis issue exists in branch-3.0, 3.3, 4.0 too\n\n### Are you willing to submit a PR?\n\n- [X] I'm willing to submit a PR!"", ""issue_word_count"": 345, ""test_files_count"": 2, ""non_test_files_count"": 2, ""pr_changed_files"": [""pulsar-broker/src/main/java/org/apache/pulsar/broker/intercept/BrokerInterceptorWithClassLoader.java"", ""pulsar-broker/src/main/java/org/apache/pulsar/broker/web/WebService.java"", ""tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/LoggingBrokerInterceptor.java"", ""tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestBrokerInterceptors.java""], ""pr_changed_test_files"": [""tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/LoggingBrokerInterceptor.java"", ""tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestBrokerInterceptors.java""], ""base_commit"": ""f27905560207eb2ade32f8086b4585dffb918b80"", ""head_commit"": ""1ff6d0e76d4ec0f88266c8b07f2f293e96f43915"", ""repo_url"": ""https://github.com/apache/pulsar/pull/23676"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/apache__pulsar/23676"", ""dockerfile"": """", ""pr_merged_at"": ""2024-12-04T10:13:51.000Z"", ""patch"": ""diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/intercept/BrokerInterceptorWithClassLoader.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/intercept/BrokerInterceptorWithClassLoader.java\nindex 3997e214f4316..849f7aa39f0ef 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/intercept/BrokerInterceptorWithClassLoader.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/intercept/BrokerInterceptorWithClassLoader.java\n@@ -22,6 +22,7 @@\n import io.netty.buffer.ByteBuf;\n import java.io.IOException;\n import java.util.Map;\n+import javax.servlet.FilterChain;\n import javax.servlet.ServletException;\n import javax.servlet.ServletRequest;\n import javax.servlet.ServletResponse;\n@@ -272,6 +273,18 @@ public void initialize(PulsarService pulsarService) throws Exception {\n         }\n     }\n \n+    @Override\n+    public void onFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n+            throws ServletException, IOException {\n+        final ClassLoader previousContext = Thread.currentThread().getContextClassLoader();\n+        try {\n+            Thread.currentThread().setContextClassLoader(narClassLoader);\n+            this.interceptor.onFilter(request, response, chain);\n+        } finally {\n+            Thread.currentThread().setContextClassLoader(previousContext);\n+        }\n+    }\n+\n     @Override\n     public void close() {\n         final ClassLoader previousContext = Thread.currentThread().getContextClassLoader();\n\ndiff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/web/WebService.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/web/WebService.java\nindex 5f5e260890a02..7eb1f2fae09b6 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/web/WebService.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/web/WebService.java\n@@ -41,6 +41,8 @@\n import org.apache.pulsar.broker.PulsarServerException;\n import org.apache.pulsar.broker.PulsarService;\n import org.apache.pulsar.broker.ServiceConfiguration;\n+import org.apache.pulsar.broker.intercept.BrokerInterceptor;\n+import org.apache.pulsar.broker.intercept.BrokerInterceptors;\n import org.apache.pulsar.common.util.PulsarSslConfiguration;\n import org.apache.pulsar.common.util.PulsarSslFactory;\n import org.apache.pulsar.jetty.tls.JettySslContextFactory;\n@@ -258,7 +260,17 @@ private static class FilterInitializer {\n                 // Enable PreInterceptFilter only when interceptors are enabled\n                 filterHolders.add(\n                         new FilterHolder(new PreInterceptFilter(pulsarService.getBrokerInterceptor(), handler)));\n-                filterHolders.add(new FilterHolder(new ProcessHandlerFilter(pulsarService.getBrokerInterceptor())));\n+                // The `ProcessHandlerFilter` is used to overwrite `doFilter` method, which cannot be called multiple\n+                // times inside one `Filter`, so we cannot use one `ProcessHandlerFilter` with a `BrokerInterceptors` to\n+                // hold all interceptors, instead we need to create a `ProcessHandlerFilter` for each `interceptor`.\n+                if (pulsarService.getBrokerInterceptor() instanceof BrokerInterceptors) {\n+                    for (BrokerInterceptor interceptor: ((BrokerInterceptors) pulsarService.getBrokerInterceptor())\n+                            .getInterceptors().values()) {\n+                        filterHolders.add(new FilterHolder(new ProcessHandlerFilter(interceptor)));\n+                    }\n+                } else {\n+                    filterHolders.add(new FilterHolder(new ProcessHandlerFilter(pulsarService.getBrokerInterceptor())));\n+                }\n             }\n \n             if (config.isAuthenticationEnabled()) {\n"", ""test_patch"": ""diff --git a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/LoggingBrokerInterceptor.java b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/LoggingBrokerInterceptor.java\nindex 992c6dd69a6b2..7e46ba18492d2 100644\n--- a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/LoggingBrokerInterceptor.java\n+++ b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/LoggingBrokerInterceptor.java\n@@ -19,8 +19,10 @@\n package org.apache.pulsar.tests.integration.plugins;\n \n import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n import java.util.Map;\n import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n import javax.servlet.ServletRequest;\n import javax.servlet.ServletResponse;\n import org.apache.bookkeeper.mledger.Entry;\n@@ -122,7 +124,9 @@ public void txnEnded(String txnID, long txnAction) {\n     }\n \n     @Override\n-    public void onFilter(ServletRequest request, ServletResponse response, FilterChain chain) {\n+    public void onFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n+            throws ServletException, IOException {\n         log.info(\""onFilter\"");\n+        chain.doFilter(request, response);\n     }\n }\n\ndiff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestBrokerInterceptors.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestBrokerInterceptors.java\nindex 98000c6f40636..b39339969e52c 100644\n--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestBrokerInterceptors.java\n+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestBrokerInterceptors.java\n@@ -96,6 +96,7 @@ public void test(Supplier<String> serviceUrlSupplier) throws Exception {\n                 \""consumerCreated\"",\n                 \""messageProduced\"",\n                 \""beforeSendMessage: OK\"",\n+                \""onFilter\"",\n         }) {\n             assertTrue(log.contains(\""LoggingBrokerInterceptor - \"" + line), \""Log did not contain line '\"" + line + \""'\"");\n         }\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
