metadata
"{""instance_id"": ""spring-projects__spring-security-16996"", ""pr_id"": 16996, ""issue_id"": 16706, ""repo"": ""spring-projects/spring-security"", ""problem_statement"": ""AuthorizationProxyFactory.proxy should return the same type that is passed into the method\nThis would make it type safe for consumers of the API. Instead of\n\n```java\nService service = (Service) factory.proxy(new Service());\n```\n\nit could be written\n\n```java\nService service = factory.proxy(new Service());\n```\n\nNOTE: I think this might be a change fore 7.0"", ""issue_word_count"": 56, ""test_files_count"": 2, ""non_test_files_count"": 4, ""pr_changed_files"": [""config/src/main/java/org/springframework/security/config/annotation/method/configuration/AuthorizationProxyWebConfiguration.java"", ""config/src/test/java/org/springframework/security/config/annotation/method/configuration/AuthorizationProxyConfigurationTests.java"", ""core/src/main/java/org/springframework/security/aot/hint/AuthorizeReturnObjectHintsRegistrar.java"", ""core/src/main/java/org/springframework/security/authorization/AuthorizationProxyFactory.java"", ""core/src/main/java/org/springframework/security/authorization/method/AuthorizationAdvisorProxyFactory.java"", ""core/src/test/java/org/springframework/security/authorization/AuthorizationAdvisorProxyFactoryTests.java""], ""pr_changed_test_files"": [""config/src/test/java/org/springframework/security/config/annotation/method/configuration/AuthorizationProxyConfigurationTests.java"", ""core/src/test/java/org/springframework/security/authorization/AuthorizationAdvisorProxyFactoryTests.java""], ""base_commit"": ""ff8b77df296990eea4abd1a3676c87a327e2d71c"", ""head_commit"": ""3c8a94d22794731f8911a161a31b22a2c85c5d45"", ""repo_url"": ""https://github.com/spring-projects/spring-security/pull/16996"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/spring-projects__spring-security/16996"", ""dockerfile"": """", ""pr_merged_at"": ""2025-05-23T20:48:11.000Z"", ""patch"": ""diff --git a/config/src/main/java/org/springframework/security/config/annotation/method/configuration/AuthorizationProxyWebConfiguration.java b/config/src/main/java/org/springframework/security/config/annotation/method/configuration/AuthorizationProxyWebConfiguration.java\nindex 4af062ef96f..62faa1a6bc6 100644\n--- a/config/src/main/java/org/springframework/security/config/annotation/method/configuration/AuthorizationProxyWebConfiguration.java\n+++ b/config/src/main/java/org/springframework/security/config/annotation/method/configuration/AuthorizationProxyWebConfiguration.java\n@@ -51,7 +51,7 @@ public Object visit(AuthorizationAdvisorProxyFactory proxyFactory, Object target\n \t\t\tif (target instanceof ModelAndView mav) {\n \t\t\t\tView view = mav.getView();\n \t\t\t\tString viewName = mav.getViewName();\n-\t\t\t\tMap<String, Object> model = (Map<String, Object>) proxyFactory.proxy(mav.getModel());\n+\t\t\t\tMap<String, Object> model = proxyFactory.proxy(mav.getModel());\n \t\t\t\tModelAndView proxied = (view != null) ? new ModelAndView(view, model)\n \t\t\t\t\t\t: new ModelAndView(viewName, model);\n \t\t\t\tproxied.setStatus(mav.getStatus());\n\ndiff --git a/core/src/main/java/org/springframework/security/aot/hint/AuthorizeReturnObjectHintsRegistrar.java b/core/src/main/java/org/springframework/security/aot/hint/AuthorizeReturnObjectHintsRegistrar.java\nindex 0c430160b72..d2194eff7fc 100644\n--- a/core/src/main/java/org/springframework/security/aot/hint/AuthorizeReturnObjectHintsRegistrar.java\n+++ b/core/src/main/java/org/springframework/security/aot/hint/AuthorizeReturnObjectHintsRegistrar.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -109,7 +109,7 @@ public void registerHints(RuntimeHints hints, ConfigurableListableBeanFactory be\n \t}\n \n \tprivate void registerProxy(RuntimeHints hints, Class<?> clazz) {\n-\t\tClass<?> proxied = (Class<?>) this.proxyFactory.proxy(clazz);\n+\t\tClass<?> proxied = this.proxyFactory.proxy(clazz);\n \t\tif (proxied == null) {\n \t\t\treturn;\n \t\t}\n\ndiff --git a/core/src/main/java/org/springframework/security/authorization/AuthorizationProxyFactory.java b/core/src/main/java/org/springframework/security/authorization/AuthorizationProxyFactory.java\nindex c425db9a01d..e6e1210e74b 100644\n--- a/core/src/main/java/org/springframework/security/authorization/AuthorizationProxyFactory.java\n+++ b/core/src/main/java/org/springframework/security/authorization/AuthorizationProxyFactory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -20,6 +20,7 @@\n  * A factory for wrapping arbitrary objects in authorization-related advice\n  *\n  * @author Josh Cummings\n+ * @author daewon kim\n  * @since 6.3\n  * @see org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory\n  */\n@@ -30,11 +31,12 @@ public interface AuthorizationProxyFactory {\n \t *\n \t * <p>\n \t * Please check the implementation for which kinds of objects it supports.\n+\t * @param <T> the type of the object being proxied\n \t * @param object the object to proxy\n \t * @return the proxied object\n \t * @throws org.springframework.aop.framework.AopConfigException if a proxy cannot be\n \t * created\n \t */\n-\tObject proxy(Object object);\n+\t<T> T proxy(T object);\n \n }\n\ndiff --git a/core/src/main/java/org/springframework/security/authorization/method/AuthorizationAdvisorProxyFactory.java b/core/src/main/java/org/springframework/security/authorization/method/AuthorizationAdvisorProxyFactory.java\nindex dd4abb3754c..f0f3984cb7c 100644\n--- a/core/src/main/java/org/springframework/security/authorization/method/AuthorizationAdvisorProxyFactory.java\n+++ b/core/src/main/java/org/springframework/security/authorization/method/AuthorizationAdvisorProxyFactory.java\n@@ -172,16 +172,16 @@ public void afterSingletonsInstantiated() {\n \t * @return the proxied instance\n \t */\n \t@Override\n-\tpublic Object proxy(Object target) {\n+\tpublic <T> T proxy(T target) {\n \t\tif (target == null) {\n \t\t\treturn null;\n \t\t}\n \t\tif (target instanceof AuthorizationProxy proxied) {\n-\t\t\treturn proxied;\n+\t\t\treturn (T) proxied;\n \t\t}\n \t\tObject proxied = this.visitor.visit(this, target);\n \t\tif (proxied != null) {\n-\t\t\treturn proxied;\n+\t\t\treturn (T) proxied;\n \t\t}\n \t\tProxyFactory factory = new ProxyFactory(target);\n \t\tfactory.addAdvisors(this.authorizationProxy);\n@@ -191,7 +191,7 @@ public Object proxy(Object target) {\n \t\tfactory.addInterface(AuthorizationProxy.class);\n \t\tfactory.setOpaque(true);\n \t\tfactory.setProxyTargetClass(!Modifier.isFinal(target.getClass().getModifiers()));\n-\t\treturn factory.getProxy();\n+\t\treturn (T) factory.getProxy();\n \t}\n \n \t/**\n@@ -442,7 +442,7 @@ public Object visit(AuthorizationAdvisorProxyFactory proxyFactory, Object target\n \n \t\t@SuppressWarnings(\""unchecked\"")\n \t\tprivate <T> T proxyCast(AuthorizationProxyFactory proxyFactory, T target) {\n-\t\t\treturn (T) proxyFactory.proxy(target);\n+\t\t\treturn proxyFactory.proxy(target);\n \t\t}\n \n \t\tprivate <T> Iterable<T> proxyIterable(AuthorizationProxyFactory proxyFactory, Iterable<T> iterable) {\n"", ""test_patch"": ""diff --git a/config/src/test/java/org/springframework/security/config/annotation/method/configuration/AuthorizationProxyConfigurationTests.java b/config/src/test/java/org/springframework/security/config/annotation/method/configuration/AuthorizationProxyConfigurationTests.java\nindex 254c8b08713..8a668819294 100644\n--- a/config/src/test/java/org/springframework/security/config/annotation/method/configuration/AuthorizationProxyConfigurationTests.java\n+++ b/config/src/test/java/org/springframework/security/config/annotation/method/configuration/AuthorizationProxyConfigurationTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -58,7 +58,7 @@ public class AuthorizationProxyConfigurationTests {\n \t@Test\n \tpublic void proxyWhenNotPreAuthorizedThenDenies() {\n \t\tthis.spring.register(DefaultsConfig.class).autowire();\n-\t\tToaster toaster = (Toaster) this.proxyFactory.proxy(new Toaster());\n+\t\tToaster toaster = this.proxyFactory.proxy(new Toaster());\n \t\tassertThatExceptionOfType(AccessDeniedException.class).isThrownBy(toaster::makeToast)\n \t\t\t.withMessage(\""Access Denied\"");\n \t\tassertThatExceptionOfType(AccessDeniedException.class).isThrownBy(toaster::extractBread)\n@@ -69,7 +69,7 @@ public void proxyWhenNotPreAuthorizedThenDenies() {\n \t@Test\n \tpublic void proxyWhenPreAuthorizedThenAllows() {\n \t\tthis.spring.register(DefaultsConfig.class).autowire();\n-\t\tToaster toaster = (Toaster) this.proxyFactory.proxy(new Toaster());\n+\t\tToaster toaster = this.proxyFactory.proxy(new Toaster());\n \t\ttoaster.makeToast();\n \t\tassertThat(toaster.extractBread()).isEqualTo(\""yummy\"");\n \t}\n@@ -77,7 +77,7 @@ public void proxyWhenPreAuthorizedThenAllows() {\n \t@Test\n \tpublic void proxyReactiveWhenNotPreAuthorizedThenDenies() {\n \t\tthis.spring.register(ReactiveDefaultsConfig.class).autowire();\n-\t\tToaster toaster = (Toaster) this.proxyFactory.proxy(new Toaster());\n+\t\tToaster toaster = this.proxyFactory.proxy(new Toaster());\n \t\tAuthentication user = TestAuthentication.authenticatedUser();\n \t\tStepVerifier\n \t\t\t.create(toaster.reactiveMakeToast().contextWrite(ReactiveSecurityContextHolder.withAuthentication(user)))\n@@ -90,7 +90,7 @@ public void proxyReactiveWhenNotPreAuthorizedThenDenies() {\n \t@Test\n \tpublic void proxyReactiveWhenPreAuthorizedThenAllows() {\n \t\tthis.spring.register(ReactiveDefaultsConfig.class).autowire();\n-\t\tToaster toaster = (Toaster) this.proxyFactory.proxy(new Toaster());\n+\t\tToaster toaster = this.proxyFactory.proxy(new Toaster());\n \t\tAuthentication admin = TestAuthentication.authenticatedAdmin();\n \t\tStepVerifier\n \t\t\t.create(toaster.reactiveMakeToast().contextWrite(ReactiveSecurityContextHolder.withAuthentication(admin)))\n\ndiff --git a/core/src/test/java/org/springframework/security/authorization/AuthorizationAdvisorProxyFactoryTests.java b/core/src/test/java/org/springframework/security/authorization/AuthorizationAdvisorProxyFactoryTests.java\nindex 93d7ee1520c..3babccf147d 100644\n--- a/core/src/test/java/org/springframework/security/authorization/AuthorizationAdvisorProxyFactoryTests.java\n+++ b/core/src/test/java/org/springframework/security/authorization/AuthorizationAdvisorProxyFactoryTests.java\n@@ -335,7 +335,7 @@ public void setTargetVisitorThenUses() {\n \t@Test\n \tpublic void setTargetVisitorIgnoreValueTypesThenIgnores() {\n \t\tAuthorizationAdvisorProxyFactory factory = AuthorizationAdvisorProxyFactory.withDefaults();\n-\t\tassertThatExceptionOfType(ClassCastException.class).isThrownBy(() -> ((Integer) factory.proxy(35)).intValue());\n+\t\tassertThatExceptionOfType(ClassCastException.class).isThrownBy(() -> factory.proxy(35).intValue());\n \t\tfactory.setTargetVisitor(TargetVisitor.defaultsSkipValueTypes());\n \t\tassertThat(factory.proxy(35)).isEqualTo(35);\n \t}\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""spring-projects__spring-security-16574"", ""pr_id"": 16574, ""issue_id"": 1813, ""repo"": ""spring-projects/spring-security"", ""problem_statement"": ""SEC-1571: Let User have a \n[David J. M. Karlsen](https://jira.spring.io/secure/ViewProfile.jspa?name=davidkarlsen) (Migrated from [SEC-1571](https://jira.spring.io/browse/SEC-1571?redirect=false)) said:\n\norg.springframework.security.core.userdetails.User takes a Collection of GrantedAuthority as one of it's arguments.\nIt feels cleaner if this instead was a GrantedAuthoritiesContainer which fulfills the same role - but behind a cleaner interface.\nThen it could contain mutable or immutable containers.\nThe Collection<GrantedAuthority> getAuthorities() method could keep it's signature as this would simply be a delegation to the containers getAuthorities()\n"", ""issue_word_count"": 98, ""test_files_count"": 3, ""non_test_files_count"": 7, ""pr_changed_files"": [""config/src/main/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/DPoPAuthenticationConfigurer.java"", ""config/src/main/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/OAuth2ResourceServerConfigurer.java"", ""config/src/test/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/DPoPAuthenticationConfigurerTests.java"", ""oauth2/oauth2-core/src/main/java/org/springframework/security/oauth2/core/OAuth2ErrorCodes.java"", ""oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/DPoPProofContext.java"", ""oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/DPoPProofJwtDecoderFactory.java"", ""oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/DPoPProofJwtDecoderFactoryTests.java"", ""oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationProvider.java"", ""oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationToken.java"", ""oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationProviderTests.java""], ""pr_changed_test_files"": [""config/src/test/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/DPoPAuthenticationConfigurerTests.java"", ""oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/DPoPProofJwtDecoderFactoryTests.java"", ""oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationProviderTests.java""], ""base_commit"": ""27cb1154f25c74a6532dbd222ead9da53e880020"", ""head_commit"": ""8153fb81bcb87bd6ddeba89bfa6bfa83c946d65f"", ""repo_url"": ""https://github.com/spring-projects/spring-security/pull/16574"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/spring-projects__spring-security/16574"", ""dockerfile"": """", ""pr_merged_at"": ""2025-02-11T19:10:23.000Z"", ""patch"": ""diff --git a/config/src/main/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/DPoPAuthenticationConfigurer.java b/config/src/main/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/DPoPAuthenticationConfigurer.java\nnew file mode 100644\nindex 00000000000..acbe8221917\n--- /dev/null\n+++ b/config/src/main/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/DPoPAuthenticationConfigurer.java\n@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2002-2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.config.annotation.web.configurers.oauth2.server.resource;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jakarta.servlet.http.HttpServletRequest;\n+\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.security.authentication.AuthenticationManager;\n+import org.springframework.security.config.annotation.web.HttpSecurityBuilder;\n+import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.oauth2.core.OAuth2AccessToken;\n+import org.springframework.security.oauth2.core.OAuth2AuthenticationException;\n+import org.springframework.security.oauth2.core.OAuth2Error;\n+import org.springframework.security.oauth2.core.OAuth2ErrorCodes;\n+import org.springframework.security.oauth2.server.resource.authentication.DPoPAuthenticationProvider;\n+import org.springframework.security.oauth2.server.resource.authentication.DPoPAuthenticationToken;\n+import org.springframework.security.web.authentication.AuthenticationConverter;\n+import org.springframework.security.web.authentication.AuthenticationEntryPointFailureHandler;\n+import org.springframework.security.web.authentication.AuthenticationFailureHandler;\n+import org.springframework.security.web.authentication.AuthenticationFilter;\n+import org.springframework.security.web.authentication.AuthenticationSuccessHandler;\n+import org.springframework.security.web.authentication.HttpStatusEntryPoint;\n+import org.springframework.security.web.context.RequestAttributeSecurityContextRepository;\n+import org.springframework.security.web.util.matcher.RequestMatcher;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+/**\n+ * @author Joe Grandja\n+ * @since 6.5\n+ * @see DPoPAuthenticationProvider\n+ */\n+final class DPoPAuthenticationConfigurer<B extends HttpSecurityBuilder<B>>\n+\t\textends AbstractHttpConfigurer<DPoPAuthenticationConfigurer<B>, B> {\n+\n+\tprivate RequestMatcher requestMatcher;\n+\n+\tprivate AuthenticationConverter authenticationConverter;\n+\n+\tprivate AuthenticationSuccessHandler authenticationSuccessHandler;\n+\n+\tprivate AuthenticationFailureHandler authenticationFailureHandler;\n+\n+\t@Override\n+\tpublic void configure(B http) {\n+\t\tAuthenticationManager authenticationManager = http.getSharedObject(AuthenticationManager.class);\n+\t\thttp.authenticationProvider(new DPoPAuthenticationProvider(authenticationManager));\n+\t\tAuthenticationFilter authenticationFilter = new AuthenticationFilter(authenticationManager,\n+\t\t\t\tgetAuthenticationConverter());\n+\t\tauthenticationFilter.setRequestMatcher(getRequestMatcher());\n+\t\tauthenticationFilter.setSuccessHandler(getAuthenticationSuccessHandler());\n+\t\tauthenticationFilter.setFailureHandler(getAuthenticationFailureHandler());\n+\t\tauthenticationFilter.setSecurityContextRepository(new RequestAttributeSecurityContextRepository());\n+\t\tauthenticationFilter = postProcess(authenticationFilter);\n+\t\thttp.addFilter(authenticationFilter);\n+\t}\n+\n+\tprivate RequestMatcher getRequestMatcher() {\n+\t\tif (this.requestMatcher == null) {\n+\t\t\tthis.requestMatcher = new DPoPRequestMatcher();\n+\t\t}\n+\t\treturn this.requestMatcher;\n+\t}\n+\n+\tprivate AuthenticationConverter getAuthenticationConverter() {\n+\t\tif (this.authenticationConverter == null) {\n+\t\t\tthis.authenticationConverter = new DPoPAuthenticationConverter();\n+\t\t}\n+\t\treturn this.authenticationConverter;\n+\t}\n+\n+\tprivate AuthenticationSuccessHandler getAuthenticationSuccessHandler() {\n+\t\tif (this.authenticationSuccessHandler == null) {\n+\t\t\tthis.authenticationSuccessHandler = (request, response, authentication) -> {\n+\t\t\t\t// No-op - will continue on filter chain\n+\t\t\t};\n+\t\t}\n+\t\treturn this.authenticationSuccessHandler;\n+\t}\n+\n+\tprivate AuthenticationFailureHandler getAuthenticationFailureHandler() {\n+\t\tif (this.authenticationFailureHandler == null) {\n+\t\t\tthis.authenticationFailureHandler = new AuthenticationEntryPointFailureHandler(\n+\t\t\t\t\tnew HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED));\n+\t\t}\n+\t\treturn this.authenticationFailureHandler;\n+\t}\n+\n+\tprivate static final class DPoPRequestMatcher implements RequestMatcher {\n+\n+\t\t@Override\n+\t\tpublic boolean matches(HttpServletRequest request) {\n+\t\t\tString authorization = request.getHeader(HttpHeaders.AUTHORIZATION);\n+\t\t\tif (!StringUtils.hasText(authorization)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\treturn StringUtils.startsWithIgnoreCase(authorization, OAuth2AccessToken.TokenType.DPOP.getValue());\n+\t\t}\n+\n+\t}\n+\n+\tprivate static final class DPoPAuthenticationConverter implements AuthenticationConverter {\n+\n+\t\tprivate static final Pattern AUTHORIZATION_PATTERN = Pattern.compile(\""^DPoP (?<token>[a-zA-Z0-9-._~+/]+=*)$\"",\n+\t\t\t\tPattern.CASE_INSENSITIVE);\n+\n+\t\t@Override\n+\t\tpublic Authentication convert(HttpServletRequest request) {\n+\t\t\tList<String> authorizationList = Collections.list(request.getHeaders(HttpHeaders.AUTHORIZATION));\n+\t\t\tif (CollectionUtils.isEmpty(authorizationList)) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tif (authorizationList.size() != 1) {\n+\t\t\t\tOAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.INVALID_REQUEST,\n+\t\t\t\t\t\t\""Found multiple Authorization headers.\"", null);\n+\t\t\t\tthrow new OAuth2AuthenticationException(error);\n+\t\t\t}\n+\t\t\tString authorization = authorizationList.get(0);\n+\t\t\tif (!StringUtils.startsWithIgnoreCase(authorization, OAuth2AccessToken.TokenType.DPOP.getValue())) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tMatcher matcher = AUTHORIZATION_PATTERN.matcher(authorization);\n+\t\t\tif (!matcher.matches()) {\n+\t\t\t\tOAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.INVALID_TOKEN, \""DPoP access token is malformed.\"",\n+\t\t\t\t\t\tnull);\n+\t\t\t\tthrow new OAuth2AuthenticationException(error);\n+\t\t\t}\n+\t\t\tString accessToken = matcher.group(\""token\"");\n+\t\t\tList<String> dPoPProofList = Collections\n+\t\t\t\t.list(request.getHeaders(OAuth2AccessToken.TokenType.DPOP.getValue()));\n+\t\t\tif (CollectionUtils.isEmpty(dPoPProofList) || dPoPProofList.size() != 1) {\n+\t\t\t\tOAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.INVALID_REQUEST,\n+\t\t\t\t\t\t\""DPoP proof is missing or invalid.\"", null);\n+\t\t\t\tthrow new OAuth2AuthenticationException(error);\n+\t\t\t}\n+\t\t\tString dPoPProof = dPoPProofList.get(0);\n+\t\t\treturn new DPoPAuthenticationToken(accessToken, dPoPProof, request.getMethod(),\n+\t\t\t\t\trequest.getRequestURL().toString());\n+\t\t}\n+\n+\t}\n+\n+}\n\ndiff --git a/config/src/main/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/OAuth2ResourceServerConfigurer.java b/config/src/main/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/OAuth2ResourceServerConfigurer.java\nindex 31a8c265a04..e9a425d46d2 100644\n--- a/config/src/main/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/OAuth2ResourceServerConfigurer.java\n+++ b/config/src/main/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/OAuth2ResourceServerConfigurer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -152,6 +152,8 @@ public final class OAuth2ResourceServerConfigurer<H extends HttpSecurityBuilder<\n \n \tprivate final ApplicationContext context;\n \n+\tprivate final DPoPAuthenticationConfigurer<H> dPoPAuthenticationConfigurer = new DPoPAuthenticationConfigurer<>();\n+\n \tprivate AuthenticationManagerResolver<HttpServletRequest> authenticationManagerResolver;\n \n \tprivate BearerTokenResolver bearerTokenResolver;\n@@ -283,6 +285,7 @@ public void configure(H http) {\n \t\tfilter.setSecurityContextHolderStrategy(getSecurityContextHolderStrategy());\n \t\tfilter = postProcess(filter);\n \t\thttp.addFilter(filter);\n+\t\tthis.dPoPAuthenticationConfigurer.configure(http);\n \t}\n \n \tprivate void validateConfiguration() {\n\ndiff --git a/oauth2/oauth2-core/src/main/java/org/springframework/security/oauth2/core/OAuth2ErrorCodes.java b/oauth2/oauth2-core/src/main/java/org/springframework/security/oauth2/core/OAuth2ErrorCodes.java\nindex 47587435bc1..004c65350ad 100644\n--- a/oauth2/oauth2-core/src/main/java/org/springframework/security/oauth2/core/OAuth2ErrorCodes.java\n+++ b/oauth2/oauth2-core/src/main/java/org/springframework/security/oauth2/core/OAuth2ErrorCodes.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -139,6 +139,15 @@ public final class OAuth2ErrorCodes {\n \t */\n \tpublic static final String INVALID_REDIRECT_URI = \""invalid_redirect_uri\"";\n \n+\t/**\n+\t * {@code invalid_dpop_proof} - The DPoP Proof JWT is invalid.\n+\t *\n+\t * @since 6.5\n+\t * @see <a href=\""https://datatracker.ietf.org/doc/html/rfc9449\"">RFC-9449 - OAuth 2.0\n+\t * Demonstrating Proof of Possession (DPoP)</a>\n+\t */\n+\tpublic static final String INVALID_DPOP_PROOF = \""invalid_dpop_proof\"";\n+\n \tprivate OAuth2ErrorCodes() {\n \t}\n \n\ndiff --git a/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/DPoPProofContext.java b/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/DPoPProofContext.java\nnew file mode 100644\nindex 00000000000..16a5947cf5c\n--- /dev/null\n+++ b/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/DPoPProofContext.java\n@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2002-2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.oauth2.jwt;\n+\n+import java.net.URI;\n+\n+import org.springframework.lang.Nullable;\n+import org.springframework.security.oauth2.core.OAuth2Token;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * @author Joe Grandja\n+ * @since 6.5\n+ * @see DPoPProofJwtDecoderFactory\n+ */\n+public final class DPoPProofContext {\n+\n+\tprivate final String dPoPProof;\n+\n+\tprivate final String method;\n+\n+\tprivate final String targetUri;\n+\n+\tprivate final OAuth2Token accessToken;\n+\n+\tprivate DPoPProofContext(String dPoPProof, String method, String targetUri, @Nullable OAuth2Token accessToken) {\n+\t\tthis.dPoPProof = dPoPProof;\n+\t\tthis.method = method;\n+\t\tthis.targetUri = targetUri;\n+\t\tthis.accessToken = accessToken;\n+\t}\n+\n+\tpublic String getDPoPProof() {\n+\t\treturn this.dPoPProof;\n+\t}\n+\n+\tpublic String getMethod() {\n+\t\treturn this.method;\n+\t}\n+\n+\tpublic String getTargetUri() {\n+\t\treturn this.targetUri;\n+\t}\n+\n+\t@SuppressWarnings(\""unchecked\"")\n+\t@Nullable\n+\tpublic <T extends OAuth2Token> T getAccessToken() {\n+\t\treturn (T) this.accessToken;\n+\t}\n+\n+\tpublic static Builder withDPoPProof(String dPoPProof) {\n+\t\treturn new Builder(dPoPProof);\n+\t}\n+\n+\tpublic static final class Builder {\n+\n+\t\tprivate String dPoPProof;\n+\n+\t\tprivate String method;\n+\n+\t\tprivate String targetUri;\n+\n+\t\tprivate OAuth2Token accessToken;\n+\n+\t\tprivate Builder(String dPoPProof) {\n+\t\t\tAssert.hasText(dPoPProof, \""dPoPProof cannot be empty\"");\n+\t\t\tthis.dPoPProof = dPoPProof;\n+\t\t}\n+\n+\t\tpublic Builder method(String method) {\n+\t\t\tthis.method = method;\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder targetUri(String targetUri) {\n+\t\t\tthis.targetUri = targetUri;\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder accessToken(OAuth2Token accessToken) {\n+\t\t\tthis.accessToken = accessToken;\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic DPoPProofContext build() {\n+\t\t\tvalidate();\n+\t\t\treturn new DPoPProofContext(this.dPoPProof, this.method, this.targetUri, this.accessToken);\n+\t\t}\n+\n+\t\tprivate void validate() {\n+\t\t\tAssert.hasText(this.method, \""method cannot be empty\"");\n+\t\t\tAssert.hasText(this.targetUri, \""targetUri cannot be empty\"");\n+\t\t\tif (!\""GET\"".equals(this.method) && !\""HEAD\"".equals(this.method) && !\""POST\"".equals(this.method)\n+\t\t\t\t\t&& !\""PUT\"".equals(this.method) && !\""PATCH\"".equals(this.method) && !\""DELETE\"".equals(this.method)\n+\t\t\t\t\t&& !\""OPTIONS\"".equals(this.method) && !\""TRACE\"".equals(this.method)) {\n+\t\t\t\tthrow new IllegalArgumentException(\""method is invalid\"");\n+\t\t\t}\n+\t\t\tURI uri;\n+\t\t\ttry {\n+\t\t\t\turi = new URI(this.targetUri);\n+\t\t\t\turi.toURL();\n+\t\t\t}\n+\t\t\tcatch (Exception ex) {\n+\t\t\t\tthrow new IllegalArgumentException(\""targetUri must be a valid URL\"", ex);\n+\t\t\t}\n+\t\t\tif (uri.getQuery() != null || uri.getFragment() != null) {\n+\t\t\t\tthrow new IllegalArgumentException(\""targetUri cannot contain query or fragment parts\"");\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\n+}\n\ndiff --git a/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/DPoPProofJwtDecoderFactory.java b/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/DPoPProofJwtDecoderFactory.java\nnew file mode 100644\nindex 00000000000..32a59135264\n--- /dev/null\n+++ b/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/DPoPProofJwtDecoderFactory.java\n@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2002-2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.oauth2.jwt;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JOSEObjectType;\n+import com.nimbusds.jose.JWSAlgorithm;\n+import com.nimbusds.jose.jwk.ECKey;\n+import com.nimbusds.jose.jwk.JWK;\n+import com.nimbusds.jose.jwk.RSAKey;\n+import com.nimbusds.jose.proc.DefaultJOSEObjectTypeVerifier;\n+import com.nimbusds.jose.proc.JOSEObjectTypeVerifier;\n+import com.nimbusds.jose.proc.JWSKeySelector;\n+import com.nimbusds.jose.proc.SecurityContext;\n+import com.nimbusds.jwt.proc.ConfigurableJWTProcessor;\n+import com.nimbusds.jwt.proc.DefaultJWTProcessor;\n+\n+import org.springframework.security.oauth2.core.DelegatingOAuth2TokenValidator;\n+import org.springframework.security.oauth2.core.OAuth2Error;\n+import org.springframework.security.oauth2.core.OAuth2ErrorCodes;\n+import org.springframework.security.oauth2.core.OAuth2TokenValidator;\n+import org.springframework.security.oauth2.core.OAuth2TokenValidatorResult;\n+import org.springframework.util.Assert;\n+import org.springframework.util.StringUtils;\n+\n+/**\n+ * @author Joe Grandja\n+ * @since 6.5\n+ * @see DPoPProofContext\n+ */\n+public final class DPoPProofJwtDecoderFactory implements JwtDecoderFactory<DPoPProofContext> {\n+\n+\tprivate static final JOSEObjectTypeVerifier<SecurityContext> DPOP_TYPE_VERIFIER = new DefaultJOSEObjectTypeVerifier<>(\n+\t\t\tnew JOSEObjectType(\""dpop+jwt\""));\n+\n+\tpublic static final Function<DPoPProofContext, OAuth2TokenValidator<Jwt>> DEFAULT_JWT_VALIDATOR_FACTORY = defaultJwtValidatorFactory();\n+\n+\tprivate Function<DPoPProofContext, OAuth2TokenValidator<Jwt>> jwtValidatorFactory = DEFAULT_JWT_VALIDATOR_FACTORY;\n+\n+\t@Override\n+\tpublic JwtDecoder createDecoder(DPoPProofContext dPoPProofContext) {\n+\t\tAssert.notNull(dPoPProofContext, \""dPoPProofContext cannot be null\"");\n+\t\tNimbusJwtDecoder jwtDecoder = buildDecoder();\n+\t\tjwtDecoder.setJwtValidator(this.jwtValidatorFactory.apply(dPoPProofContext));\n+\t\treturn jwtDecoder;\n+\t}\n+\n+\tpublic void setJwtValidatorFactory(Function<DPoPProofContext, OAuth2TokenValidator<Jwt>> jwtValidatorFactory) {\n+\t\tAssert.notNull(jwtValidatorFactory, \""jwtValidatorFactory cannot be null\"");\n+\t\tthis.jwtValidatorFactory = jwtValidatorFactory;\n+\t}\n+\n+\tprivate static NimbusJwtDecoder buildDecoder() {\n+\t\tConfigurableJWTProcessor<SecurityContext> jwtProcessor = new DefaultJWTProcessor<>();\n+\t\tjwtProcessor.setJWSTypeVerifier(DPOP_TYPE_VERIFIER);\n+\t\tjwtProcessor.setJWSKeySelector(jwsKeySelector());\n+\t\t// Override the default Nimbus claims set verifier and use jwtValidatorFactory for\n+\t\t// claims validation\n+\t\tjwtProcessor.setJWTClaimsSetVerifier((claims, context) -> {\n+\t\t});\n+\t\treturn new NimbusJwtDecoder(jwtProcessor);\n+\t}\n+\n+\tprivate static JWSKeySelector<SecurityContext> jwsKeySelector() {\n+\t\treturn (header, context) -> {\n+\t\t\tJWSAlgorithm algorithm = header.getAlgorithm();\n+\t\t\tif (!JWSAlgorithm.Family.RSA.contains(algorithm) && !JWSAlgorithm.Family.EC.contains(algorithm)) {\n+\t\t\t\tthrow new BadJwtException(\""Unsupported alg parameter in JWS Header: \"" + algorithm.getName());\n+\t\t\t}\n+\n+\t\t\tJWK jwk = header.getJWK();\n+\t\t\tif (jwk == null) {\n+\t\t\t\tthrow new BadJwtException(\""Missing jwk parameter in JWS Header.\"");\n+\t\t\t}\n+\t\t\tif (jwk.isPrivate()) {\n+\t\t\t\tthrow new BadJwtException(\""Invalid jwk parameter in JWS Header.\"");\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tif (JWSAlgorithm.Family.RSA.contains(algorithm) && jwk instanceof RSAKey rsaKey) {\n+\t\t\t\t\treturn Collections.singletonList(rsaKey.toRSAPublicKey());\n+\t\t\t\t}\n+\t\t\t\telse if (JWSAlgorithm.Family.EC.contains(algorithm) && jwk instanceof ECKey ecKey) {\n+\t\t\t\t\treturn Collections.singletonList(ecKey.toECPublicKey());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcatch (JOSEException ex) {\n+\t\t\t\tthrow new BadJwtException(\""Invalid jwk parameter in JWS Header.\"");\n+\t\t\t}\n+\n+\t\t\tthrow new BadJwtException(\""Invalid alg / jwk parameter in JWS Header: alg=\"" + algorithm.getName()\n+\t\t\t\t\t+ \"", jwk.kty=\"" + jwk.getKeyType().getValue());\n+\t\t};\n+\t}\n+\n+\tprivate static Function<DPoPProofContext, OAuth2TokenValidator<Jwt>> defaultJwtValidatorFactory() {\n+\t\treturn (context) -> new DelegatingOAuth2TokenValidator<>(\n+\t\t\t\tnew JwtClaimValidator<>(\""htm\"", context.getMethod()::equals),\n+\t\t\t\tnew JwtClaimValidator<>(\""htu\"", context.getTargetUri()::equals), new JtiClaimValidator(),\n+\t\t\t\tnew IatClaimValidator());\n+\t}\n+\n+\tprivate static final class JtiClaimValidator implements OAuth2TokenValidator<Jwt> {\n+\n+\t\tprivate static final Map<String, Long> jtiCache = new ConcurrentHashMap<>();\n+\n+\t\t@Override\n+\t\tpublic OAuth2TokenValidatorResult validate(Jwt jwt) {\n+\t\t\tAssert.notNull(jwt, \""DPoP proof jwt cannot be null\"");\n+\t\t\tString jti = jwt.getId();\n+\t\t\tif (!StringUtils.hasText(jti)) {\n+\t\t\t\tOAuth2Error error = createOAuth2Error(\""jti claim is required.\"");\n+\t\t\t\treturn OAuth2TokenValidatorResult.failure(error);\n+\t\t\t}\n+\n+\t\t\t// Enforce single-use to protect against DPoP proof replay\n+\t\t\tString jtiHash;\n+\t\t\ttry {\n+\t\t\t\tjtiHash = computeSHA256(jti);\n+\t\t\t}\n+\t\t\tcatch (Exception ex) {\n+\t\t\t\tOAuth2Error error = createOAuth2Error(\""jti claim is invalid.\"");\n+\t\t\t\treturn OAuth2TokenValidatorResult.failure(error);\n+\t\t\t}\n+\t\t\tInstant now = Instant.now(Clock.systemUTC());\n+\t\t\tif ((jtiCache.putIfAbsent(jtiHash, now.toEpochMilli())) != null) {\n+\t\t\t\t// Already used\n+\t\t\t\tOAuth2Error error = createOAuth2Error(\""jti claim is invalid.\"");\n+\t\t\t\treturn OAuth2TokenValidatorResult.failure(error);\n+\t\t\t}\n+\t\t\treturn OAuth2TokenValidatorResult.success();\n+\t\t}\n+\n+\t\tprivate static OAuth2Error createOAuth2Error(String reason) {\n+\t\t\treturn new OAuth2Error(OAuth2ErrorCodes.INVALID_DPOP_PROOF, reason, null);\n+\t\t}\n+\n+\t\tprivate static String computeSHA256(String value) throws Exception {\n+\t\t\tMessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n+\t\t\tbyte[] digest = md.digest(value.getBytes(StandardCharsets.UTF_8));\n+\t\t\treturn Base64.getUrlEncoder().withoutPadding().encodeToString(digest);\n+\t\t}\n+\n+\t}\n+\n+\tprivate static final class IatClaimValidator implements OAuth2TokenValidator<Jwt> {\n+\n+\t\tprivate final Duration clockSkew = Duration.ofSeconds(60);\n+\n+\t\tprivate final Clock clock = Clock.systemUTC();\n+\n+\t\t@Override\n+\t\tpublic OAuth2TokenValidatorResult validate(Jwt jwt) {\n+\t\t\tAssert.notNull(jwt, \""DPoP proof jwt cannot be null\"");\n+\t\t\tInstant issuedAt = jwt.getIssuedAt();\n+\t\t\tif (issuedAt == null) {\n+\t\t\t\tOAuth2Error error = createOAuth2Error(\""iat claim is required.\"");\n+\t\t\t\treturn OAuth2TokenValidatorResult.failure(error);\n+\t\t\t}\n+\n+\t\t\t// Check time window of validity\n+\t\t\tInstant now = Instant.now(this.clock);\n+\t\t\tInstant notBefore = now.minus(this.clockSkew);\n+\t\t\tInstant notAfter = now.plus(this.clockSkew);\n+\t\t\tif (issuedAt.isBefore(notBefore) || issuedAt.isAfter(notAfter)) {\n+\t\t\t\tOAuth2Error error = createOAuth2Error(\""iat claim is invalid.\"");\n+\t\t\t\treturn OAuth2TokenValidatorResult.failure(error);\n+\t\t\t}\n+\t\t\treturn OAuth2TokenValidatorResult.success();\n+\t\t}\n+\n+\t\tprivate static OAuth2Error createOAuth2Error(String reason) {\n+\t\t\treturn new OAuth2Error(OAuth2ErrorCodes.INVALID_DPOP_PROOF, reason, null);\n+\t\t}\n+\n+\t}\n+\n+}\n\ndiff --git a/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationProvider.java b/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationProvider.java\nnew file mode 100644\nindex 00000000000..b26cb754c70\n--- /dev/null\n+++ b/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationProvider.java\n@@ -0,0 +1,273 @@\n+/*\n+ * Copyright 2002-2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.oauth2.server.resource.authentication;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.PublicKey;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import com.nimbusds.jose.jwk.AsymmetricJWK;\n+import com.nimbusds.jose.jwk.JWK;\n+\n+import org.springframework.security.authentication.AuthenticationManager;\n+import org.springframework.security.authentication.AuthenticationProvider;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.AuthenticationException;\n+import org.springframework.security.oauth2.core.ClaimAccessor;\n+import org.springframework.security.oauth2.core.DelegatingOAuth2TokenValidator;\n+import org.springframework.security.oauth2.core.OAuth2AuthenticationException;\n+import org.springframework.security.oauth2.core.OAuth2Error;\n+import org.springframework.security.oauth2.core.OAuth2ErrorCodes;\n+import org.springframework.security.oauth2.core.OAuth2Token;\n+import org.springframework.security.oauth2.core.OAuth2TokenValidator;\n+import org.springframework.security.oauth2.core.OAuth2TokenValidatorResult;\n+import org.springframework.security.oauth2.jwt.DPoPProofContext;\n+import org.springframework.security.oauth2.jwt.DPoPProofJwtDecoderFactory;\n+import org.springframework.security.oauth2.jwt.Jwt;\n+import org.springframework.security.oauth2.jwt.JwtDecoder;\n+import org.springframework.security.oauth2.jwt.JwtDecoderFactory;\n+import org.springframework.security.oauth2.jwt.JwtException;\n+import org.springframework.util.Assert;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+/**\n+ * @author Joe Grandja\n+ * @since 6.5\n+ * @see DPoPAuthenticationToken\n+ * @see DPoPProofJwtDecoderFactory\n+ */\n+public final class DPoPAuthenticationProvider implements AuthenticationProvider {\n+\n+\tprivate final AuthenticationManager tokenAuthenticationManager;\n+\n+\tprivate JwtDecoderFactory<DPoPProofContext> dPoPProofVerifierFactory;\n+\n+\tpublic DPoPAuthenticationProvider(AuthenticationManager tokenAuthenticationManager) {\n+\t\tAssert.notNull(tokenAuthenticationManager, \""tokenAuthenticationManager cannot be null\"");\n+\t\tthis.tokenAuthenticationManager = tokenAuthenticationManager;\n+\t\tFunction<DPoPProofContext, OAuth2TokenValidator<Jwt>> jwtValidatorFactory = (\n+\t\t\t\tcontext) -> new DelegatingOAuth2TokenValidator<>(\n+\t\t\t\t\t\t// Use default validators\n+\t\t\t\t\t\tDPoPProofJwtDecoderFactory.DEFAULT_JWT_VALIDATOR_FACTORY.apply(context),\n+\t\t\t\t\t\t// Add custom validators\n+\t\t\t\t\t\tnew AthClaimValidator(context.getAccessToken()),\n+\t\t\t\t\t\tnew JwkThumbprintValidator(context.getAccessToken()));\n+\t\tDPoPProofJwtDecoderFactory dPoPProofJwtDecoderFactory = new DPoPProofJwtDecoderFactory();\n+\t\tdPoPProofJwtDecoderFactory.setJwtValidatorFactory(jwtValidatorFactory);\n+\t\tthis.dPoPProofVerifierFactory = dPoPProofJwtDecoderFactory;\n+\t}\n+\n+\t@Override\n+\tpublic Authentication authenticate(Authentication authentication) throws AuthenticationException {\n+\t\tDPoPAuthenticationToken dPoPAuthenticationToken = (DPoPAuthenticationToken) authentication;\n+\n+\t\tBearerTokenAuthenticationToken accessTokenAuthenticationRequest = new BearerTokenAuthenticationToken(\n+\t\t\t\tdPoPAuthenticationToken.getAccessToken());\n+\t\tAuthentication accessTokenAuthenticationResult = this.tokenAuthenticationManager\n+\t\t\t.authenticate(accessTokenAuthenticationRequest);\n+\n+\t\tAbstractOAuth2TokenAuthenticationToken<OAuth2Token> accessTokenAuthentication = null;\n+\t\tif (accessTokenAuthenticationResult instanceof AbstractOAuth2TokenAuthenticationToken) {\n+\t\t\taccessTokenAuthentication = (AbstractOAuth2TokenAuthenticationToken) accessTokenAuthenticationResult;\n+\t\t}\n+\t\tif (accessTokenAuthentication == null) {\n+\t\t\tOAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.INVALID_TOKEN,\n+\t\t\t\t\t\""Unable to authenticate the DPoP-bound access token.\"", null);\n+\t\t\tthrow new OAuth2AuthenticationException(error);\n+\t\t}\n+\n+\t\tOAuth2AccessTokenClaims accessToken = new OAuth2AccessTokenClaims(accessTokenAuthentication.getToken(),\n+\t\t\t\taccessTokenAuthentication.getTokenAttributes());\n+\n+\t\tDPoPProofContext dPoPProofContext = DPoPProofContext.withDPoPProof(dPoPAuthenticationToken.getDPoPProof())\n+\t\t\t.accessToken(accessToken)\n+\t\t\t.method(dPoPAuthenticationToken.getMethod())\n+\t\t\t.targetUri(dPoPAuthenticationToken.getResourceUri())\n+\t\t\t.build();\n+\t\tJwtDecoder dPoPProofVerifier = this.dPoPProofVerifierFactory.createDecoder(dPoPProofContext);\n+\n+\t\ttry {\n+\t\t\tdPoPProofVerifier.decode(dPoPProofContext.getDPoPProof());\n+\t\t}\n+\t\tcatch (JwtException ex) {\n+\t\t\tOAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.INVALID_DPOP_PROOF);\n+\t\t\tthrow new OAuth2AuthenticationException(error, ex);\n+\t\t}\n+\n+\t\treturn accessTokenAuthenticationResult;\n+\t}\n+\n+\t@Override\n+\tpublic boolean supports(Class<?> authentication) {\n+\t\treturn DPoPAuthenticationToken.class.isAssignableFrom(authentication);\n+\t}\n+\n+\tpublic void setDPoPProofVerifierFactory(JwtDecoderFactory<DPoPProofContext> dPoPProofVerifierFactory) {\n+\t\tAssert.notNull(dPoPProofVerifierFactory, \""dPoPProofVerifierFactory cannot be null\"");\n+\t\tthis.dPoPProofVerifierFactory = dPoPProofVerifierFactory;\n+\t}\n+\n+\tprivate static final class AthClaimValidator implements OAuth2TokenValidator<Jwt> {\n+\n+\t\tprivate final OAuth2AccessTokenClaims accessToken;\n+\n+\t\tprivate AthClaimValidator(OAuth2AccessTokenClaims accessToken) {\n+\t\t\tAssert.notNull(accessToken, \""accessToken cannot be null\"");\n+\t\t\tthis.accessToken = accessToken;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic OAuth2TokenValidatorResult validate(Jwt jwt) {\n+\t\t\tAssert.notNull(jwt, \""DPoP proof jwt cannot be null\"");\n+\t\t\tString accessTokenHashClaim = jwt.getClaimAsString(\""ath\"");\n+\t\t\tif (!StringUtils.hasText(accessTokenHashClaim)) {\n+\t\t\t\tOAuth2Error error = createOAuth2Error(\""ath claim is required.\"");\n+\t\t\t\treturn OAuth2TokenValidatorResult.failure(error);\n+\t\t\t}\n+\n+\t\t\tString accessTokenHash;\n+\t\t\ttry {\n+\t\t\t\taccessTokenHash = computeSHA256(this.accessToken.getTokenValue());\n+\t\t\t}\n+\t\t\tcatch (Exception ex) {\n+\t\t\t\tOAuth2Error error = createOAuth2Error(\""Failed to compute SHA-256 Thumbprint for access token.\"");\n+\t\t\t\treturn OAuth2TokenValidatorResult.failure(error);\n+\t\t\t}\n+\t\t\tif (!accessTokenHashClaim.equals(accessTokenHash)) {\n+\t\t\t\tOAuth2Error error = createOAuth2Error(\""ath claim is invalid.\"");\n+\t\t\t\treturn OAuth2TokenValidatorResult.failure(error);\n+\t\t\t}\n+\t\t\treturn OAuth2TokenValidatorResult.success();\n+\t\t}\n+\n+\t\tprivate static OAuth2Error createOAuth2Error(String reason) {\n+\t\t\treturn new OAuth2Error(OAuth2ErrorCodes.INVALID_DPOP_PROOF, reason, null);\n+\t\t}\n+\n+\t\tprivate static String computeSHA256(String value) throws Exception {\n+\t\t\tMessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n+\t\t\tbyte[] digest = md.digest(value.getBytes(StandardCharsets.UTF_8));\n+\t\t\treturn Base64.getUrlEncoder().withoutPadding().encodeToString(digest);\n+\t\t}\n+\n+\t}\n+\n+\tprivate static final class JwkThumbprintValidator implements OAuth2TokenValidator<Jwt> {\n+\n+\t\tprivate final OAuth2AccessTokenClaims accessToken;\n+\n+\t\tprivate JwkThumbprintValidator(OAuth2AccessTokenClaims accessToken) {\n+\t\t\tAssert.notNull(accessToken, \""accessToken cannot be null\"");\n+\t\t\tthis.accessToken = accessToken;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic OAuth2TokenValidatorResult validate(Jwt jwt) {\n+\t\t\tAssert.notNull(jwt, \""DPoP proof jwt cannot be null\"");\n+\t\t\tString jwkThumbprintClaim = null;\n+\t\t\tMap<String, Object> confirmationMethodClaim = this.accessToken.getClaimAsMap(\""cnf\"");\n+\t\t\tif (!CollectionUtils.isEmpty(confirmationMethodClaim) && confirmationMethodClaim.containsKey(\""jkt\"")) {\n+\t\t\t\tjwkThumbprintClaim = (String) confirmationMethodClaim.get(\""jkt\"");\n+\t\t\t}\n+\t\t\tif (jwkThumbprintClaim == null) {\n+\t\t\t\tOAuth2Error error = createOAuth2Error(\""jkt claim is required.\"");\n+\t\t\t\treturn OAuth2TokenValidatorResult.failure(error);\n+\t\t\t}\n+\n+\t\t\tPublicKey publicKey = null;\n+\t\t\t@SuppressWarnings(\""unchecked\"")\n+\t\t\tMap<String, Object> jwkJson = (Map<String, Object>) jwt.getHeaders().get(\""jwk\"");\n+\t\t\ttry {\n+\t\t\t\tJWK jwk = JWK.parse(jwkJson);\n+\t\t\t\tif (jwk instanceof AsymmetricJWK) {\n+\t\t\t\t\tpublicKey = ((AsymmetricJWK) jwk).toPublicKey();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcatch (Exception ignored) {\n+\t\t\t}\n+\t\t\tif (publicKey == null) {\n+\t\t\t\tOAuth2Error error = createOAuth2Error(\""jwk header is missing or invalid.\"");\n+\t\t\t\treturn OAuth2TokenValidatorResult.failure(error);\n+\t\t\t}\n+\n+\t\t\tString jwkThumbprint;\n+\t\t\ttry {\n+\t\t\t\tjwkThumbprint = computeSHA256(publicKey);\n+\t\t\t}\n+\t\t\tcatch (Exception ex) {\n+\t\t\t\tOAuth2Error error = createOAuth2Error(\""Failed to compute SHA-256 Thumbprint for jwk.\"");\n+\t\t\t\treturn OAuth2TokenValidatorResult.failure(error);\n+\t\t\t}\n+\n+\t\t\tif (!jwkThumbprintClaim.equals(jwkThumbprint)) {\n+\t\t\t\tOAuth2Error error = createOAuth2Error(\""jkt claim is invalid.\"");\n+\t\t\t\treturn OAuth2TokenValidatorResult.failure(error);\n+\t\t\t}\n+\t\t\treturn OAuth2TokenValidatorResult.success();\n+\t\t}\n+\n+\t\tprivate static OAuth2Error createOAuth2Error(String reason) {\n+\t\t\treturn new OAuth2Error(OAuth2ErrorCodes.INVALID_DPOP_PROOF, reason, null);\n+\t\t}\n+\n+\t\tprivate static String computeSHA256(PublicKey publicKey) throws Exception {\n+\t\t\tMessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n+\t\t\tbyte[] digest = md.digest(publicKey.getEncoded());\n+\t\t\treturn Base64.getUrlEncoder().withoutPadding().encodeToString(digest);\n+\t\t}\n+\n+\t}\n+\n+\tprivate static final class OAuth2AccessTokenClaims implements OAuth2Token, ClaimAccessor {\n+\n+\t\tprivate final OAuth2Token accessToken;\n+\n+\t\tprivate final Map<String, Object> claims;\n+\n+\t\tprivate OAuth2AccessTokenClaims(OAuth2Token accessToken, Map<String, Object> claims) {\n+\t\t\tthis.accessToken = accessToken;\n+\t\t\tthis.claims = claims;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getTokenValue() {\n+\t\t\treturn this.accessToken.getTokenValue();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Instant getIssuedAt() {\n+\t\t\treturn this.accessToken.getIssuedAt();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Instant getExpiresAt() {\n+\t\t\treturn this.accessToken.getExpiresAt();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Map<String, Object> getClaims() {\n+\t\t\treturn this.claims;\n+\t\t}\n+\n+\t}\n+\n+}\n\ndiff --git a/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationToken.java b/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationToken.java\nnew file mode 100644\nindex 00000000000..0abca697068\n--- /dev/null\n+++ b/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationToken.java\n@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2002-2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.oauth2.server.resource.authentication;\n+\n+import java.io.Serial;\n+import java.util.Collections;\n+\n+import org.springframework.security.authentication.AbstractAuthenticationToken;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * @author Joe Grandja\n+ * @since 6.5\n+ * @see DPoPAuthenticationProvider\n+ */\n+public class DPoPAuthenticationToken extends AbstractAuthenticationToken {\n+\n+\t@Serial\n+\tprivate static final long serialVersionUID = 5481690438914686216L;\n+\n+\tprivate final String accessToken;\n+\n+\tprivate final String dPoPProof;\n+\n+\tprivate final String method;\n+\n+\tprivate final String resourceUri;\n+\n+\tpublic DPoPAuthenticationToken(String accessToken, String dPoPProof, String method, String resourceUri) {\n+\t\tsuper(Collections.emptyList());\n+\t\tAssert.hasText(accessToken, \""accessToken cannot be empty\"");\n+\t\tAssert.hasText(dPoPProof, \""dPoPProof cannot be empty\"");\n+\t\tAssert.hasText(method, \""method cannot be empty\"");\n+\t\tAssert.hasText(resourceUri, \""resourceUri cannot be empty\"");\n+\t\tthis.accessToken = accessToken;\n+\t\tthis.dPoPProof = dPoPProof;\n+\t\tthis.method = method;\n+\t\tthis.resourceUri = resourceUri;\n+\t}\n+\n+\t@Override\n+\tpublic Object getPrincipal() {\n+\t\treturn getAccessToken();\n+\t}\n+\n+\t@Override\n+\tpublic Object getCredentials() {\n+\t\treturn getAccessToken();\n+\t}\n+\n+\tpublic String getAccessToken() {\n+\t\treturn this.accessToken;\n+\t}\n+\n+\tpublic String getDPoPProof() {\n+\t\treturn this.dPoPProof;\n+\t}\n+\n+\tpublic String getMethod() {\n+\t\treturn this.method;\n+\t}\n+\n+\tpublic String getResourceUri() {\n+\t\treturn this.resourceUri;\n+\t}\n+\n+}\n"", ""test_patch"": ""diff --git a/config/src/test/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/DPoPAuthenticationConfigurerTests.java b/config/src/test/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/DPoPAuthenticationConfigurerTests.java\nnew file mode 100644\nindex 00000000000..00117286244\n--- /dev/null\n+++ b/config/src/test/java/org/springframework/security/config/annotation/web/configurers/oauth2/server/resource/DPoPAuthenticationConfigurerTests.java\n@@ -0,0 +1,279 @@\n+/*\n+ * Copyright 2002-2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.config.annotation.web.configurers.oauth2.server.resource;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.PublicKey;\n+import java.security.interfaces.ECPrivateKey;\n+import java.security.interfaces.ECPublicKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPublicKey;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import com.nimbusds.jose.jwk.ECKey;\n+import com.nimbusds.jose.jwk.JWKSet;\n+import com.nimbusds.jose.jwk.RSAKey;\n+import com.nimbusds.jose.jwk.source.JWKSource;\n+import com.nimbusds.jose.proc.SecurityContext;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.security.config.Customizer;\n+import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n+import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n+import org.springframework.security.config.test.SpringTestContext;\n+import org.springframework.security.config.test.SpringTestContextExtension;\n+import org.springframework.security.oauth2.core.endpoint.OAuth2ParameterNames;\n+import org.springframework.security.oauth2.jose.TestJwks;\n+import org.springframework.security.oauth2.jose.TestKeys;\n+import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;\n+import org.springframework.security.oauth2.jwt.JwsHeader;\n+import org.springframework.security.oauth2.jwt.Jwt;\n+import org.springframework.security.oauth2.jwt.JwtClaimsSet;\n+import org.springframework.security.oauth2.jwt.JwtEncoderParameters;\n+import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;\n+import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;\n+import org.springframework.security.web.SecurityFilterChain;\n+import org.springframework.test.web.servlet.MockMvc;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+import org.springframework.web.servlet.config.annotation.EnableWebMvc;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+/**\n+ * Tests for {@link DPoPAuthenticationConfigurer}.\n+ *\n+ * @author Joe Grandja\n+ */\n+@ExtendWith(SpringTestContextExtension.class)\n+public class DPoPAuthenticationConfigurerTests {\n+\n+\tprivate static final RSAPublicKey PROVIDER_RSA_PUBLIC_KEY = TestKeys.DEFAULT_PUBLIC_KEY;\n+\n+\tprivate static final RSAPrivateKey PROVIDER_RSA_PRIVATE_KEY = TestKeys.DEFAULT_PRIVATE_KEY;\n+\n+\tprivate static final ECPublicKey CLIENT_EC_PUBLIC_KEY = (ECPublicKey) TestKeys.DEFAULT_EC_KEY_PAIR.getPublic();\n+\n+\tprivate static final ECPrivateKey CLIENT_EC_PRIVATE_KEY = (ECPrivateKey) TestKeys.DEFAULT_EC_KEY_PAIR.getPrivate();\n+\n+\tprivate static NimbusJwtEncoder providerJwtEncoder;\n+\n+\tprivate static NimbusJwtEncoder clientJwtEncoder;\n+\n+\tpublic final SpringTestContext spring = new SpringTestContext(this);\n+\n+\t@Autowired\n+\tprivate MockMvc mvc;\n+\n+\t@BeforeAll\n+\tpublic static void init() {\n+\t\tRSAKey providerRsaKey = TestJwks.jwk(PROVIDER_RSA_PUBLIC_KEY, PROVIDER_RSA_PRIVATE_KEY).build();\n+\t\tJWKSource<SecurityContext> providerJwkSource = (jwkSelector, securityContext) -> jwkSelector\n+\t\t\t.select(new JWKSet(providerRsaKey));\n+\t\tproviderJwtEncoder = new NimbusJwtEncoder(providerJwkSource);\n+\t\tECKey clientEcKey = TestJwks.jwk(CLIENT_EC_PUBLIC_KEY, CLIENT_EC_PRIVATE_KEY).build();\n+\t\tJWKSource<SecurityContext> clientJwkSource = (jwkSelector, securityContext) -> jwkSelector\n+\t\t\t.select(new JWKSet(clientEcKey));\n+\t\tclientJwtEncoder = new NimbusJwtEncoder(clientJwkSource);\n+\t}\n+\n+\t@Test\n+\tpublic void requestWhenDPoPAndBearerAuthenticationThenUnauthorized() throws Exception {\n+\t\tthis.spring.register(SecurityConfig.class, ResourceEndpoints.class).autowire();\n+\t\tSet<String> scope = Collections.singleton(\""resource1.read\"");\n+\t\tString accessToken = generateAccessToken(scope, CLIENT_EC_PUBLIC_KEY);\n+\t\tString dPoPProof = generateDPoPProof(HttpMethod.GET.name(), \""http://localhost/resource1\"", accessToken);\n+\t\t// @formatter:off\n+\t\tthis.mvc.perform(get(\""/resource1\"")\n+\t\t\t\t\t\t.header(HttpHeaders.AUTHORIZATION, \""DPoP \"" + accessToken)\n+\t\t\t\t\t\t.header(HttpHeaders.AUTHORIZATION, \""Bearer \"" + accessToken)\n+\t\t\t\t\t\t.header(\""DPoP\"", dPoPProof))\n+\t\t\t\t.andExpect(status().isUnauthorized());\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Test\n+\tpublic void requestWhenDPoPAccessTokenMalformedThenUnauthorized() throws Exception {\n+\t\tthis.spring.register(SecurityConfig.class, ResourceEndpoints.class).autowire();\n+\t\tSet<String> scope = Collections.singleton(\""resource1.read\"");\n+\t\tString accessToken = generateAccessToken(scope, CLIENT_EC_PUBLIC_KEY);\n+\t\tString dPoPProof = generateDPoPProof(HttpMethod.GET.name(), \""http://localhost/resource1\"", accessToken);\n+\t\t// @formatter:off\n+\t\tthis.mvc.perform(get(\""/resource1\"")\n+\t\t\t\t\t\t.header(HttpHeaders.AUTHORIZATION, \""DPoP \"" + accessToken + \"" m a l f o r m e d \"")\n+\t\t\t\t\t\t.header(\""DPoP\"", dPoPProof))\n+\t\t\t\t.andExpect(status().isUnauthorized());\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Test\n+\tpublic void requestWhenMultipleDPoPProofsThenUnauthorized() throws Exception {\n+\t\tthis.spring.register(SecurityConfig.class, ResourceEndpoints.class).autowire();\n+\t\tSet<String> scope = Collections.singleton(\""resource1.read\"");\n+\t\tString accessToken = generateAccessToken(scope, CLIENT_EC_PUBLIC_KEY);\n+\t\tString dPoPProof = generateDPoPProof(HttpMethod.GET.name(), \""http://localhost/resource1\"", accessToken);\n+\t\t// @formatter:off\n+\t\tthis.mvc.perform(get(\""/resource1\"")\n+\t\t\t\t\t\t.header(HttpHeaders.AUTHORIZATION, \""DPoP \"" + accessToken)\n+\t\t\t\t\t\t.header(\""DPoP\"", dPoPProof)\n+\t\t\t\t\t\t.header(\""DPoP\"", dPoPProof))\n+\t\t\t\t.andExpect(status().isUnauthorized());\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Test\n+\tpublic void requestWhenDPoPAuthenticationValidThenAccessed() throws Exception {\n+\t\tthis.spring.register(SecurityConfig.class, ResourceEndpoints.class).autowire();\n+\t\tSet<String> scope = Collections.singleton(\""resource1.read\"");\n+\t\tString accessToken = generateAccessToken(scope, CLIENT_EC_PUBLIC_KEY);\n+\t\tString dPoPProof = generateDPoPProof(HttpMethod.GET.name(), \""http://localhost/resource1\"", accessToken);\n+\t\t// @formatter:off\n+\t\tthis.mvc.perform(get(\""/resource1\"")\n+\t\t\t\t\t\t.header(HttpHeaders.AUTHORIZATION, \""DPoP \"" + accessToken)\n+\t\t\t\t\t\t.header(\""DPoP\"", dPoPProof))\n+\t\t\t\t.andExpect(status().isOk())\n+\t\t\t\t.andExpect(content().string(\""resource1\""));\n+\t\t// @formatter:on\n+\t}\n+\n+\tprivate static String generateAccessToken(Set<String> scope, PublicKey clientPublicKey) {\n+\t\tMap<String, Object> jktClaim = null;\n+\t\tif (clientPublicKey != null) {\n+\t\t\ttry {\n+\t\t\t\tString sha256Thumbprint = computeSHA256(clientPublicKey);\n+\t\t\t\tjktClaim = new HashMap<>();\n+\t\t\t\tjktClaim.put(\""jkt\"", sha256Thumbprint);\n+\t\t\t}\n+\t\t\tcatch (Exception ignored) {\n+\t\t\t}\n+\t\t}\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256).build();\n+\t\tInstant issuedAt = Instant.now();\n+\t\tInstant expiresAt = issuedAt.plus(30, ChronoUnit.MINUTES);\n+\t\t// @formatter:off\n+\t\tJwtClaimsSet.Builder claimsBuilder = JwtClaimsSet.builder()\n+\t\t\t\t.issuer(\""https://provider.com\"")\n+\t\t\t\t.subject(\""subject\"")\n+\t\t\t\t.issuedAt(issuedAt)\n+\t\t\t\t.expiresAt(expiresAt)\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.claim(OAuth2ParameterNames.SCOPE, scope);\n+\t\tif (jktClaim != null) {\n+\t\t\tclaimsBuilder.claim(\""cnf\"", jktClaim);\t// Bind client public key\n+\t\t}\n+\t\t// @formatter:on\n+\t\tJwt jwt = providerJwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claimsBuilder.build()));\n+\t\treturn jwt.getTokenValue();\n+\t}\n+\n+\tprivate static String generateDPoPProof(String method, String resourceUri, String accessToken) throws Exception {\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = TestJwks.jwk(CLIENT_EC_PUBLIC_KEY, CLIENT_EC_PRIVATE_KEY)\n+\t\t\t\t.build()\n+\t\t\t\t.toPublicJWK()\n+\t\t\t\t.toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.ES256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", resourceUri)\n+\t\t\t\t.claim(\""ath\"", computeSHA256(accessToken))\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\t\tJwt jwt = clientJwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\t\treturn jwt.getTokenValue();\n+\t}\n+\n+\tprivate static String computeSHA256(String value) throws Exception {\n+\t\tMessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n+\t\tbyte[] digest = md.digest(value.getBytes(StandardCharsets.UTF_8));\n+\t\treturn Base64.getUrlEncoder().withoutPadding().encodeToString(digest);\n+\t}\n+\n+\tprivate static String computeSHA256(PublicKey publicKey) throws Exception {\n+\t\tMessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n+\t\tbyte[] digest = md.digest(publicKey.getEncoded());\n+\t\treturn Base64.getUrlEncoder().withoutPadding().encodeToString(digest);\n+\t}\n+\n+\t@Configuration\n+\t@EnableWebSecurity\n+\t@EnableWebMvc\n+\tstatic class SecurityConfig {\n+\n+\t\t@Bean\n+\t\tSecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n+\t\t\t// @formatter:off\n+\t\t\thttp\n+\t\t\t\t.authorizeHttpRequests((authorize) ->\n+\t\t\t\t\tauthorize\n+\t\t\t\t\t\t.requestMatchers(\""/resource1\"").hasAnyAuthority(\""SCOPE_resource1.read\"", \""SCOPE_resource1.write\"")\n+\t\t\t\t\t\t.requestMatchers(\""/resource2\"").hasAnyAuthority(\""SCOPE_resource2.read\"", \""SCOPE_resource2.write\"")\n+\t\t\t\t\t\t.anyRequest().authenticated()\n+\t\t\t\t)\n+\t\t\t\t.oauth2ResourceServer((oauth2ResourceServer) ->\n+\t\t\t\t\toauth2ResourceServer\n+\t\t\t\t\t\t.jwt(Customizer.withDefaults()));\n+\t\t\t// @formatter:on\n+\t\t\treturn http.build();\n+\t\t}\n+\n+\t\t@Bean\n+\t\tNimbusJwtDecoder jwtDecoder() {\n+\t\t\treturn NimbusJwtDecoder.withPublicKey(PROVIDER_RSA_PUBLIC_KEY).build();\n+\t\t}\n+\n+\t}\n+\n+\t@RestController\n+\tstatic class ResourceEndpoints {\n+\n+\t\t@RequestMapping(value = \""/resource1\"", method = { RequestMethod.GET, RequestMethod.POST })\n+\t\tString resource1() {\n+\t\t\treturn \""resource1\"";\n+\t\t}\n+\n+\t\t@RequestMapping(value = \""/resource2\"", method = { RequestMethod.GET, RequestMethod.POST })\n+\t\tString resource2() {\n+\t\t\treturn \""resource2\"";\n+\t\t}\n+\n+\t}\n+\n+}\n\ndiff --git a/oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/DPoPProofJwtDecoderFactoryTests.java b/oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/DPoPProofJwtDecoderFactoryTests.java\nnew file mode 100644\nindex 00000000000..6f107fa6757\n--- /dev/null\n+++ b/oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/DPoPProofJwtDecoderFactoryTests.java\n@@ -0,0 +1,451 @@\n+/*\n+ * Copyright 2002-2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.oauth2.jwt;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import com.nimbusds.jose.jwk.RSAKey;\n+import com.nimbusds.jose.jwk.source.JWKSource;\n+import com.nimbusds.jose.proc.SecurityContext;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import org.springframework.security.oauth2.jose.TestJwks;\n+import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;\n+\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Tests for {@link DPoPProofJwtDecoderFactory}.\n+ *\n+ * @author Joe Grandja\n+ */\n+public class DPoPProofJwtDecoderFactoryTests {\n+\n+\tprivate JWKSource<SecurityContext> jwkSource;\n+\n+\tprivate NimbusJwtEncoder jwtEncoder;\n+\n+\tprivate DPoPProofJwtDecoderFactory jwtDecoderFactory = new DPoPProofJwtDecoderFactory();\n+\n+\t@BeforeEach\n+\tpublic void setUp() {\n+\t\tthis.jwkSource = mock(JWKSource.class);\n+\t\tthis.jwtEncoder = new NimbusJwtEncoder(this.jwkSource);\n+\t}\n+\n+\t@Test\n+\tpublic void setJwtValidatorFactoryWhenNullThenThrowIllegalArgumentException() {\n+\t\tassertThatIllegalArgumentException().isThrownBy(() -> this.jwtDecoderFactory.setJwtValidatorFactory(null))\n+\t\t\t.withMessage(\""jwtValidatorFactory cannot be null\"");\n+\t}\n+\n+\t@Test\n+\tpublic void createDecoderWhenContextNullThenThrowIllegalArgumentException() {\n+\t\tassertThatIllegalArgumentException().isThrownBy(() -> this.jwtDecoderFactory.createDecoder(null))\n+\t\t\t.withMessage(\""dPoPProofContext cannot be null\"");\n+\t}\n+\n+\t@Test\n+\tpublic void decodeWhenJoseTypeInvalidThenThrowBadJwtException() throws Exception {\n+\t\tRSAKey rsaJwk = TestJwks.DEFAULT_RSA_JWK;\n+\t\tgiven(this.jwkSource.get(any(), any())).willReturn(Collections.singletonList(rsaJwk));\n+\n+\t\tString method = \""GET\"";\n+\t\tString targetUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = rsaJwk.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""invalid-type\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", targetUri)\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\t// @formatter:off\n+\t\tDPoPProofContext dPoPProofContext = DPoPProofContext.withDPoPProof(dPoPProof.getTokenValue())\n+\t\t\t\t.method(method)\n+\t\t\t\t.targetUri(targetUri)\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwtDecoder jwtDecoder = this.jwtDecoderFactory.createDecoder(dPoPProofContext);\n+\n+\t\tassertThatExceptionOfType(BadJwtException.class)\n+\t\t\t.isThrownBy(() -> jwtDecoder.decode(dPoPProofContext.getDPoPProof()))\n+\t\t\t.withMessageContaining(\""JOSE header typ (type) invalid-type not allowed\"");\n+\t}\n+\n+\t@Test\n+\tpublic void decodeWhenJwkMissingThenThrowBadJwtException() throws Exception {\n+\t\tRSAKey rsaJwk = TestJwks.DEFAULT_RSA_JWK;\n+\t\tgiven(this.jwkSource.get(any(), any())).willReturn(Collections.singletonList(rsaJwk));\n+\n+\t\tString method = \""GET\"";\n+\t\tString targetUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = rsaJwk.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+//\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", targetUri)\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\t// @formatter:off\n+\t\tDPoPProofContext dPoPProofContext = DPoPProofContext.withDPoPProof(dPoPProof.getTokenValue())\n+\t\t\t\t.method(method)\n+\t\t\t\t.targetUri(targetUri)\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwtDecoder jwtDecoder = this.jwtDecoderFactory.createDecoder(dPoPProofContext);\n+\n+\t\tassertThatExceptionOfType(BadJwtException.class)\n+\t\t\t.isThrownBy(() -> jwtDecoder.decode(dPoPProofContext.getDPoPProof()))\n+\t\t\t.withMessageContaining(\""Missing jwk parameter in JWS Header.\"");\n+\t}\n+\n+\t@Test\n+\tpublic void decodeWhenMethodInvalidThenThrowBadJwtException() throws Exception {\n+\t\tRSAKey rsaJwk = TestJwks.DEFAULT_RSA_JWK;\n+\t\tgiven(this.jwkSource.get(any(), any())).willReturn(Collections.singletonList(rsaJwk));\n+\n+\t\tString method = \""GET\"";\n+\t\tString targetUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = rsaJwk.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", targetUri)\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\t// @formatter:off\n+\t\tDPoPProofContext dPoPProofContext = DPoPProofContext.withDPoPProof(dPoPProof.getTokenValue())\n+\t\t\t\t.method(\""POST\"")\t\t// Mismatch\n+\t\t\t\t.targetUri(targetUri)\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwtDecoder jwtDecoder = this.jwtDecoderFactory.createDecoder(dPoPProofContext);\n+\n+\t\tassertThatExceptionOfType(BadJwtException.class)\n+\t\t\t.isThrownBy(() -> jwtDecoder.decode(dPoPProofContext.getDPoPProof()))\n+\t\t\t.withMessageContaining(\""The htm claim is not valid\"");\n+\t}\n+\n+\t@Test\n+\tpublic void decodeWhenTargetUriInvalidThenThrowBadJwtException() throws Exception {\n+\t\tRSAKey rsaJwk = TestJwks.DEFAULT_RSA_JWK;\n+\t\tgiven(this.jwkSource.get(any(), any())).willReturn(Collections.singletonList(rsaJwk));\n+\n+\t\tString method = \""GET\"";\n+\t\tString targetUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = rsaJwk.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", targetUri)\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\t// @formatter:off\n+\t\tDPoPProofContext dPoPProofContext = DPoPProofContext.withDPoPProof(dPoPProof.getTokenValue())\n+\t\t\t\t.method(method)\n+\t\t\t\t.targetUri(\""https://resource2\"")\t\t// Mismatch\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwtDecoder jwtDecoder = this.jwtDecoderFactory.createDecoder(dPoPProofContext);\n+\n+\t\tassertThatExceptionOfType(BadJwtException.class)\n+\t\t\t.isThrownBy(() -> jwtDecoder.decode(dPoPProofContext.getDPoPProof()))\n+\t\t\t.withMessageContaining(\""The htu claim is not valid\"");\n+\t}\n+\n+\t@Test\n+\tpublic void decodeWhenJtiMissingThenThrowBadJwtException() throws Exception {\n+\t\tRSAKey rsaJwk = TestJwks.DEFAULT_RSA_JWK;\n+\t\tgiven(this.jwkSource.get(any(), any())).willReturn(Collections.singletonList(rsaJwk));\n+\n+\t\tString method = \""GET\"";\n+\t\tString targetUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = rsaJwk.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", targetUri)\n+//\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\t// @formatter:off\n+\t\tDPoPProofContext dPoPProofContext = DPoPProofContext.withDPoPProof(dPoPProof.getTokenValue())\n+\t\t\t\t.method(method)\n+\t\t\t\t.targetUri(targetUri)\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwtDecoder jwtDecoder = this.jwtDecoderFactory.createDecoder(dPoPProofContext);\n+\n+\t\tassertThatExceptionOfType(BadJwtException.class)\n+\t\t\t.isThrownBy(() -> jwtDecoder.decode(dPoPProofContext.getDPoPProof()))\n+\t\t\t.withMessageContaining(\""jti claim is required\"");\n+\t}\n+\n+\t@Test\n+\tpublic void decodeWhenJtiAlreadyUsedThenThrowBadJwtException() throws Exception {\n+\t\tRSAKey rsaJwk = TestJwks.DEFAULT_RSA_JWK;\n+\t\tgiven(this.jwkSource.get(any(), any())).willReturn(Collections.singletonList(rsaJwk));\n+\n+\t\tString method = \""GET\"";\n+\t\tString targetUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = rsaJwk.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", targetUri)\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\t// @formatter:off\n+\t\tDPoPProofContext dPoPProofContext = DPoPProofContext.withDPoPProof(dPoPProof.getTokenValue())\n+\t\t\t\t.method(method)\n+\t\t\t\t.targetUri(targetUri)\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwtDecoder jwtDecoder = this.jwtDecoderFactory.createDecoder(dPoPProofContext);\n+\n+\t\tjwtDecoder.decode(dPoPProofContext.getDPoPProof());\n+\t\tassertThatExceptionOfType(BadJwtException.class)\n+\t\t\t.isThrownBy(() -> jwtDecoder.decode(dPoPProofContext.getDPoPProof()))\n+\t\t\t.withMessageContaining(\""jti claim is invalid\"");\n+\t}\n+\n+\t@Test\n+\tpublic void decodeWhenIatMissingThenThrowBadJwtException() throws Exception {\n+\t\tRSAKey rsaJwk = TestJwks.DEFAULT_RSA_JWK;\n+\t\tgiven(this.jwkSource.get(any(), any())).willReturn(Collections.singletonList(rsaJwk));\n+\n+\t\tString method = \""GET\"";\n+\t\tString targetUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = rsaJwk.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+//\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", targetUri)\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\t// @formatter:off\n+\t\tDPoPProofContext dPoPProofContext = DPoPProofContext.withDPoPProof(dPoPProof.getTokenValue())\n+\t\t\t\t.method(method)\n+\t\t\t\t.targetUri(targetUri)\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwtDecoder jwtDecoder = this.jwtDecoderFactory.createDecoder(dPoPProofContext);\n+\n+\t\tassertThatExceptionOfType(BadJwtException.class)\n+\t\t\t.isThrownBy(() -> jwtDecoder.decode(dPoPProofContext.getDPoPProof()))\n+\t\t\t.withMessageContaining(\""iat claim is required\"");\n+\t}\n+\n+\t@Test\n+\tpublic void decodeWhenIatBeforeTimeWindowThenThrowBadJwtException() throws Exception {\n+\t\tRSAKey rsaJwk = TestJwks.DEFAULT_RSA_JWK;\n+\t\tgiven(this.jwkSource.get(any(), any())).willReturn(Collections.singletonList(rsaJwk));\n+\n+\t\tString method = \""GET\"";\n+\t\tString targetUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = rsaJwk.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tInstant issuedAt = Instant.now().minus(Duration.ofSeconds(65));\t\t// now minus 65 seconds\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(issuedAt)\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", targetUri)\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\t// @formatter:off\n+\t\tDPoPProofContext dPoPProofContext = DPoPProofContext.withDPoPProof(dPoPProof.getTokenValue())\n+\t\t\t\t.method(method)\n+\t\t\t\t.targetUri(targetUri)\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwtDecoder jwtDecoder = this.jwtDecoderFactory.createDecoder(dPoPProofContext);\n+\n+\t\tassertThatExceptionOfType(BadJwtException.class)\n+\t\t\t.isThrownBy(() -> jwtDecoder.decode(dPoPProofContext.getDPoPProof()))\n+\t\t\t.withMessageContaining(\""iat claim is invalid\"");\n+\t}\n+\n+\t@Test\n+\tpublic void decodeWhenIatAfterTimeWindowThenThrowBadJwtException() throws Exception {\n+\t\tRSAKey rsaJwk = TestJwks.DEFAULT_RSA_JWK;\n+\t\tgiven(this.jwkSource.get(any(), any())).willReturn(Collections.singletonList(rsaJwk));\n+\n+\t\tString method = \""GET\"";\n+\t\tString targetUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = rsaJwk.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tInstant issuedAt = Instant.now().plus(Duration.ofSeconds(65));\t\t// now plus 65 seconds\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(issuedAt)\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", targetUri)\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\t// @formatter:off\n+\t\tDPoPProofContext dPoPProofContext = DPoPProofContext.withDPoPProof(dPoPProof.getTokenValue())\n+\t\t\t\t.method(method)\n+\t\t\t\t.targetUri(targetUri)\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwtDecoder jwtDecoder = this.jwtDecoderFactory.createDecoder(dPoPProofContext);\n+\n+\t\tassertThatExceptionOfType(BadJwtException.class)\n+\t\t\t.isThrownBy(() -> jwtDecoder.decode(dPoPProofContext.getDPoPProof()))\n+\t\t\t.withMessageContaining(\""iat claim is invalid\"");\n+\t}\n+\n+\t@Test\n+\tpublic void decodeWhenDPoPProofValidThenDecoded() throws Exception {\n+\t\tRSAKey rsaJwk = TestJwks.DEFAULT_RSA_JWK;\n+\t\tgiven(this.jwkSource.get(any(), any())).willReturn(Collections.singletonList(rsaJwk));\n+\n+\t\tString method = \""GET\"";\n+\t\tString targetUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = rsaJwk.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", targetUri)\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\t// @formatter:off\n+\t\tDPoPProofContext dPoPProofContext = DPoPProofContext.withDPoPProof(dPoPProof.getTokenValue())\n+\t\t\t\t.method(method)\n+\t\t\t\t.targetUri(targetUri)\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwtDecoder jwtDecoder = this.jwtDecoderFactory.createDecoder(dPoPProofContext);\n+\t\tjwtDecoder.decode(dPoPProof.getTokenValue());\n+\t}\n+\n+}\n\ndiff --git a/oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationProviderTests.java b/oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationProviderTests.java\nnew file mode 100644\nindex 00000000000..08aec389000\n--- /dev/null\n+++ b/oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/DPoPAuthenticationProviderTests.java\n@@ -0,0 +1,331 @@\n+/*\n+ * Copyright 2002-2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.oauth2.server.resource.authentication;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.PublicKey;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import com.nimbusds.jose.jwk.JWKSet;\n+import com.nimbusds.jose.jwk.source.JWKSource;\n+import com.nimbusds.jose.proc.SecurityContext;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import org.springframework.security.authentication.AuthenticationManager;\n+import org.springframework.security.oauth2.core.OAuth2AuthenticationException;\n+import org.springframework.security.oauth2.core.OAuth2ErrorCodes;\n+import org.springframework.security.oauth2.jose.TestJwks;\n+import org.springframework.security.oauth2.jose.TestKeys;\n+import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;\n+import org.springframework.security.oauth2.jwt.JwsHeader;\n+import org.springframework.security.oauth2.jwt.Jwt;\n+import org.springframework.security.oauth2.jwt.JwtClaimsSet;\n+import org.springframework.security.oauth2.jwt.JwtEncoderParameters;\n+import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Tests for {@link DPoPAuthenticationProvider}.\n+ *\n+ * @author Joe Grandja\n+ */\n+public class DPoPAuthenticationProviderTests {\n+\n+\tprivate NimbusJwtEncoder accessTokenJwtEncoder;\n+\n+\tprivate NimbusJwtEncoder dPoPProofJwtEncoder;\n+\n+\tprivate AuthenticationManager tokenAuthenticationManager;\n+\n+\tprivate DPoPAuthenticationProvider authenticationProvider;\n+\n+\t@BeforeEach\n+\tpublic void setUp() {\n+\t\tJWKSource<SecurityContext> jwkSource = (jwkSelector, securityContext) -> jwkSelector\n+\t\t\t.select(new JWKSet(TestJwks.DEFAULT_EC_JWK));\n+\t\tthis.accessTokenJwtEncoder = new NimbusJwtEncoder(jwkSource);\n+\t\tjwkSource = (jwkSelector, securityContext) -> jwkSelector.select(new JWKSet(TestJwks.DEFAULT_RSA_JWK));\n+\t\tthis.dPoPProofJwtEncoder = new NimbusJwtEncoder(jwkSource);\n+\t\tthis.tokenAuthenticationManager = mock(AuthenticationManager.class);\n+\t\tthis.authenticationProvider = new DPoPAuthenticationProvider(this.tokenAuthenticationManager);\n+\t}\n+\n+\t@Test\n+\tpublic void constructorWhenTokenAuthenticationManagerNullThenThrowIllegalArgumentException() {\n+\t\tassertThatIllegalArgumentException().isThrownBy(() -> new DPoPAuthenticationProvider(null))\n+\t\t\t.withMessage(\""tokenAuthenticationManager cannot be null\"");\n+\t}\n+\n+\t@Test\n+\tpublic void supportsWhenDPoPAuthenticationTokenThenReturnsTrue() {\n+\t\tassertThat(this.authenticationProvider.supports(DPoPAuthenticationToken.class)).isTrue();\n+\t}\n+\n+\t@Test\n+\tpublic void setDPoPProofVerifierFactoryWhenNullThenThrowIllegalArgumentException() {\n+\t\tassertThatIllegalArgumentException()\n+\t\t\t.isThrownBy(() -> this.authenticationProvider.setDPoPProofVerifierFactory(null))\n+\t\t\t.withMessage(\""dPoPProofVerifierFactory cannot be null\"");\n+\t}\n+\n+\t@Test\n+\tpublic void authenticateWhenUnableToAuthenticateAccessTokenThenThrowOAuth2AuthenticationException() {\n+\t\tDPoPAuthenticationToken dPoPAuthenticationToken = new DPoPAuthenticationToken(\""access-token\"", \""dpop-proof\"",\n+\t\t\t\t\""GET\"", \""https://resource1\"");\n+\t\tassertThatExceptionOfType(OAuth2AuthenticationException.class)\n+\t\t\t.isThrownBy(() -> this.authenticationProvider.authenticate(dPoPAuthenticationToken))\n+\t\t\t.satisfies((ex) -> {\n+\t\t\t\tassertThat(ex.getError().getErrorCode()).isEqualTo(OAuth2ErrorCodes.INVALID_TOKEN);\n+\t\t\t\tassertThat(ex.getError().getDescription())\n+\t\t\t\t\t.isEqualTo(\""Unable to authenticate the DPoP-bound access token.\"");\n+\t\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void authenticateWhenAthMissingThenThrowOAuth2AuthenticationException() {\n+\t\tJwt accessToken = generateAccessToken();\n+\t\tJwtAuthenticationToken jwtAuthenticationToken = new JwtAuthenticationToken(accessToken);\n+\t\tgiven(this.tokenAuthenticationManager.authenticate(any())).willReturn(jwtAuthenticationToken);\n+\n+\t\tString method = \""GET\"";\n+\t\tString resourceUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = TestJwks.DEFAULT_RSA_JWK.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", resourceUri)\n+//\t\t\t\t.claim(\""ath\"", computeSHA256(accessToken.getTokenValue()))\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.dPoPProofJwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\tDPoPAuthenticationToken dPoPAuthenticationToken = new DPoPAuthenticationToken(accessToken.getTokenValue(),\n+\t\t\t\tdPoPProof.getTokenValue(), method, resourceUri);\n+\t\tassertThatExceptionOfType(OAuth2AuthenticationException.class)\n+\t\t\t.isThrownBy(() -> this.authenticationProvider.authenticate(dPoPAuthenticationToken))\n+\t\t\t.satisfies((ex) -> {\n+\t\t\t\tassertThat(ex.getError().getErrorCode()).isEqualTo(OAuth2ErrorCodes.INVALID_DPOP_PROOF);\n+\t\t\t\tassertThat(ex.getMessage()).contains(\""ath claim is required\"");\n+\t\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void authenticateWhenAthDoesNotMatchThenThrowOAuth2AuthenticationException() throws Exception {\n+\t\tJwt accessToken = generateAccessToken();\n+\t\tJwtAuthenticationToken jwtAuthenticationToken = new JwtAuthenticationToken(accessToken);\n+\t\tgiven(this.tokenAuthenticationManager.authenticate(any())).willReturn(jwtAuthenticationToken);\n+\n+\t\tString method = \""GET\"";\n+\t\tString resourceUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = TestJwks.DEFAULT_RSA_JWK.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", resourceUri)\n+\t\t\t\t.claim(\""ath\"", computeSHA256(accessToken.getTokenValue()) + \""-mismatch\"")\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.dPoPProofJwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\tDPoPAuthenticationToken dPoPAuthenticationToken = new DPoPAuthenticationToken(accessToken.getTokenValue(),\n+\t\t\t\tdPoPProof.getTokenValue(), method, resourceUri);\n+\t\tassertThatExceptionOfType(OAuth2AuthenticationException.class)\n+\t\t\t.isThrownBy(() -> this.authenticationProvider.authenticate(dPoPAuthenticationToken))\n+\t\t\t.satisfies((ex) -> {\n+\t\t\t\tassertThat(ex.getError().getErrorCode()).isEqualTo(OAuth2ErrorCodes.INVALID_DPOP_PROOF);\n+\t\t\t\tassertThat(ex.getMessage()).contains(\""ath claim is invalid\"");\n+\t\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void authenticateWhenJktMissingThenThrowOAuth2AuthenticationException() throws Exception {\n+\t\tJwt accessToken = generateAccessToken(null); // jkt claim is not added\n+\t\tJwtAuthenticationToken jwtAuthenticationToken = new JwtAuthenticationToken(accessToken);\n+\t\tgiven(this.tokenAuthenticationManager.authenticate(any())).willReturn(jwtAuthenticationToken);\n+\n+\t\tString method = \""GET\"";\n+\t\tString resourceUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = TestJwks.DEFAULT_RSA_JWK.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", resourceUri)\n+\t\t\t\t.claim(\""ath\"", computeSHA256(accessToken.getTokenValue()))\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.dPoPProofJwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\tDPoPAuthenticationToken dPoPAuthenticationToken = new DPoPAuthenticationToken(accessToken.getTokenValue(),\n+\t\t\t\tdPoPProof.getTokenValue(), method, resourceUri);\n+\t\tassertThatExceptionOfType(OAuth2AuthenticationException.class)\n+\t\t\t.isThrownBy(() -> this.authenticationProvider.authenticate(dPoPAuthenticationToken))\n+\t\t\t.satisfies((ex) -> {\n+\t\t\t\tassertThat(ex.getError().getErrorCode()).isEqualTo(OAuth2ErrorCodes.INVALID_DPOP_PROOF);\n+\t\t\t\tassertThat(ex.getMessage()).contains(\""jkt claim is required\"");\n+\t\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void authenticateWhenJktDoesNotMatchThenThrowOAuth2AuthenticationException() throws Exception {\n+\t\t// Use different client public key\n+\t\tJwt accessToken = generateAccessToken(TestKeys.DEFAULT_EC_KEY_PAIR.getPublic());\n+\t\tJwtAuthenticationToken jwtAuthenticationToken = new JwtAuthenticationToken(accessToken);\n+\t\tgiven(this.tokenAuthenticationManager.authenticate(any())).willReturn(jwtAuthenticationToken);\n+\n+\t\tString method = \""GET\"";\n+\t\tString resourceUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = TestJwks.DEFAULT_RSA_JWK.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", resourceUri)\n+\t\t\t\t.claim(\""ath\"", computeSHA256(accessToken.getTokenValue()))\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.dPoPProofJwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\tDPoPAuthenticationToken dPoPAuthenticationToken = new DPoPAuthenticationToken(accessToken.getTokenValue(),\n+\t\t\t\tdPoPProof.getTokenValue(), method, resourceUri);\n+\t\tassertThatExceptionOfType(OAuth2AuthenticationException.class)\n+\t\t\t.isThrownBy(() -> this.authenticationProvider.authenticate(dPoPAuthenticationToken))\n+\t\t\t.satisfies((ex) -> {\n+\t\t\t\tassertThat(ex.getError().getErrorCode()).isEqualTo(OAuth2ErrorCodes.INVALID_DPOP_PROOF);\n+\t\t\t\tassertThat(ex.getMessage()).contains(\""jkt claim is invalid\"");\n+\t\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void authenticateWhenDPoPProofValidThenSuccess() throws Exception {\n+\t\tJwt accessToken = generateAccessToken();\n+\t\tJwtAuthenticationToken jwtAuthenticationToken = new JwtAuthenticationToken(accessToken);\n+\t\tgiven(this.tokenAuthenticationManager.authenticate(any())).willReturn(jwtAuthenticationToken);\n+\n+\t\tString method = \""GET\"";\n+\t\tString resourceUri = \""https://resource1\"";\n+\n+\t\t// @formatter:off\n+\t\tMap<String, Object> publicJwk = TestJwks.DEFAULT_RSA_JWK.toPublicJWK().toJSONObject();\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n+\t\t\t\t.type(\""dpop+jwt\"")\n+\t\t\t\t.jwk(publicJwk)\n+\t\t\t\t.build();\n+\t\tJwtClaimsSet claims = JwtClaimsSet.builder()\n+\t\t\t\t.issuedAt(Instant.now())\n+\t\t\t\t.claim(\""htm\"", method)\n+\t\t\t\t.claim(\""htu\"", resourceUri)\n+\t\t\t\t.claim(\""ath\"", computeSHA256(accessToken.getTokenValue()))\n+\t\t\t\t.id(UUID.randomUUID().toString())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\n+\t\tJwt dPoPProof = this.dPoPProofJwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n+\n+\t\tDPoPAuthenticationToken dPoPAuthenticationToken = new DPoPAuthenticationToken(accessToken.getTokenValue(),\n+\t\t\t\tdPoPProof.getTokenValue(), method, resourceUri);\n+\t\tassertThat(this.authenticationProvider.authenticate(dPoPAuthenticationToken)).isSameAs(jwtAuthenticationToken);\n+\t}\n+\n+\tprivate Jwt generateAccessToken() {\n+\t\treturn generateAccessToken(TestKeys.DEFAULT_PUBLIC_KEY);\n+\t}\n+\n+\tprivate Jwt generateAccessToken(PublicKey clientPublicKey) {\n+\t\tMap<String, Object> jktClaim = null;\n+\t\tif (clientPublicKey != null) {\n+\t\t\ttry {\n+\t\t\t\tString sha256Thumbprint = computeSHA256(clientPublicKey);\n+\t\t\t\tjktClaim = new HashMap<>();\n+\t\t\t\tjktClaim.put(\""jkt\"", sha256Thumbprint);\n+\t\t\t}\n+\t\t\tcatch (Exception ignored) {\n+\t\t\t}\n+\t\t}\n+\t\tJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.ES256).build();\n+\t\tInstant issuedAt = Instant.now();\n+\t\tInstant expiresAt = issuedAt.plus(30, ChronoUnit.MINUTES);\n+\t\t// @formatter:off\n+\t\tJwtClaimsSet.Builder claimsBuilder = JwtClaimsSet.builder()\n+\t\t\t\t.issuer(\""https://provider.com\"")\n+\t\t\t\t.subject(\""subject\"")\n+\t\t\t\t.issuedAt(issuedAt)\n+\t\t\t\t.expiresAt(expiresAt)\n+\t\t\t\t.id(UUID.randomUUID().toString());\n+\t\tif (jktClaim != null) {\n+\t\t\tclaimsBuilder.claim(\""cnf\"", jktClaim);\t// Bind client public key\n+\t\t}\n+\t\t// @formatter:on\n+\t\treturn this.accessTokenJwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claimsBuilder.build()));\n+\t}\n+\n+\tprivate static String computeSHA256(String value) throws Exception {\n+\t\tMessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n+\t\tbyte[] digest = md.digest(value.getBytes(StandardCharsets.UTF_8));\n+\t\treturn Base64.getUrlEncoder().withoutPadding().encodeToString(digest);\n+\t}\n+\n+\tprivate static String computeSHA256(PublicKey publicKey) throws Exception {\n+\t\tMessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n+\t\tbyte[] digest = md.digest(publicKey.getEncoded());\n+\t\treturn Base64.getUrlEncoder().withoutPadding().encodeToString(digest);\n+\t}\n+\n+}\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""spring-projects__spring-security-16505"", ""pr_id"": 16505, ""issue_id"": 16444, ""repo"": ""spring-projects/spring-security"", ""problem_statement"": ""In the UsernamePasswordAuthenticationFilter, the authRequest is added as an attribute to the HttpServletRequest.\n**Expected Behavior**\n\nYou expect to receive username and password in the application/json format and be able to extract them again in the unsuccessHandler.\n\n\nIn traditional HTML forms, the default encoding is x-www-urlencoded, but nowadays, application/json format is more commonly preferred in web development. While it is up to the developer to customize UsernamePasswordAuthenticationFilter to handle application/json format for username and password, an issue arises.\n\nThe HttpServletRequest in application/json format is a consumable stream, meaning once the data is extracted, it cannot be extracted again. This leads to a problem where, in the unsuccessHandler, you are unable to perform subsequent actions (e.g., incrementing account error counts for the username) because the stream has already been consumed.\n\nTo solve this problem, developers may find that completely customizing the filter is inefficient and means they are missing out on useful functionality provided by Spring Security.\n\nTherefore, if authRequest is saved in the HttpServletRequest in UsernamePasswordAuthenticationFilter, it would resolve this issue.\n \n\n**Context**\n\nAfter receiving the login credentials in the application/json format for form login, you'd like to use the username and password in the unsuccessHandler for subsequent processing like error count increments.\n\n\n```java\n\npublic class CustomLoginFailureHandler implements AuthenticationFailureHandler {\n\t\n\t@Override\n\tpublic void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException {\n\t\n\t\tUsernamePasswordAuthenticationToken authRequest = (UsernamePasswordAuthenticationToken) request.getAttribute(\""authRequest\"");\n\t\t// For example, you can extract the username using authRequest.getPrincipal() \n\t\t// and increment the account failure count.\n\t\t\n}\n```"", ""issue_word_count"": 250, ""test_files_count"": 6, ""non_test_files_count"": 11, ""pr_changed_files"": [""core/src/main/java/org/springframework/security/authentication/DelegatingReactiveAuthenticationManager.java"", ""core/src/main/java/org/springframework/security/authentication/ProviderManager.java"", ""core/src/main/java/org/springframework/security/core/AuthenticationException.java"", ""core/src/main/java/org/springframework/security/jackson2/BadCredentialsExceptionMixin.java"", ""core/src/test/java/org/springframework/security/authentication/DelegatingReactiveAuthenticationManagerTests.java"", ""core/src/test/java/org/springframework/security/authentication/ProviderManagerTests.java"", ""etc/checkstyle/checkstyle-suppressions.xml"", ""oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerAuthenticationManagerResolver.java"", ""oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerReactiveAuthenticationManagerResolver.java"", ""oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerAuthenticationManagerResolverTests.java"", ""oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerReactiveAuthenticationManagerResolverTests.java"", ""web/src/main/java/org/springframework/security/web/access/ExceptionTranslationFilter.java"", ""web/src/main/java/org/springframework/security/web/authentication/RequestMatcherDelegatingAuthenticationManagerResolver.java"", ""web/src/main/java/org/springframework/security/web/server/authentication/ServerWebExchangeDelegatingReactiveAuthenticationManagerResolver.java"", ""web/src/main/java/org/springframework/security/web/server/authorization/ExceptionTranslationWebFilter.java"", ""web/src/test/java/org/springframework/security/web/access/ExceptionTranslationFilterTests.java"", ""web/src/test/java/org/springframework/security/web/server/authorization/ExceptionTranslationWebFilterTests.java""], ""pr_changed_test_files"": [""core/src/test/java/org/springframework/security/authentication/DelegatingReactiveAuthenticationManagerTests.java"", ""core/src/test/java/org/springframework/security/authentication/ProviderManagerTests.java"", ""oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerAuthenticationManagerResolverTests.java"", ""oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerReactiveAuthenticationManagerResolverTests.java"", ""web/src/test/java/org/springframework/security/web/access/ExceptionTranslationFilterTests.java"", ""web/src/test/java/org/springframework/security/web/server/authorization/ExceptionTranslationWebFilterTests.java""], ""base_commit"": ""10ed5009e6f922b993080f2f640abe0eedb64691"", ""head_commit"": ""659e7d25f49963ac4b2f6f104a8a69032def89d6"", ""repo_url"": ""https://github.com/spring-projects/spring-security/pull/16505"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/spring-projects__spring-security/16505"", ""dockerfile"": """", ""pr_merged_at"": ""2025-03-22T03:54:32.000Z"", ""patch"": ""diff --git a/core/src/main/java/org/springframework/security/authentication/DelegatingReactiveAuthenticationManager.java b/core/src/main/java/org/springframework/security/authentication/DelegatingReactiveAuthenticationManager.java\nindex 2fdc2d48c42..399e2aede59 100644\n--- a/core/src/main/java/org/springframework/security/authentication/DelegatingReactiveAuthenticationManager.java\n+++ b/core/src/main/java/org/springframework/security/authentication/DelegatingReactiveAuthenticationManager.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -26,6 +26,7 @@\n import reactor.core.publisher.Mono;\n \n import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.AuthenticationException;\n import org.springframework.util.Assert;\n \n /**\n@@ -58,6 +59,7 @@ public DelegatingReactiveAuthenticationManager(List<ReactiveAuthenticationManage\n \tpublic Mono<Authentication> authenticate(Authentication authentication) {\n \t\tFlux<ReactiveAuthenticationManager> result = Flux.fromIterable(this.delegates);\n \t\tFunction<ReactiveAuthenticationManager, Mono<Authentication>> logging = (m) -> m.authenticate(authentication)\n+\t\t\t.doOnError(AuthenticationException.class, (ex) -> ex.setAuthenticationRequest(authentication))\n \t\t\t.doOnError(this.logger::debug);\n \n \t\treturn ((this.continueOnError) ? result.concatMapDelayError(logging) : result.concatMap(logging)).next();\n\ndiff --git a/core/src/main/java/org/springframework/security/authentication/ProviderManager.java b/core/src/main/java/org/springframework/security/authentication/ProviderManager.java\nindex 479f99f704e..aa8b82bcd71 100644\n--- a/core/src/main/java/org/springframework/security/authentication/ProviderManager.java\n+++ b/core/src/main/java/org/springframework/security/authentication/ProviderManager.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2020 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -202,6 +202,7 @@ public Authentication authenticate(Authentication authentication) throws Authent\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (AuthenticationException ex) {\n+\t\t\t\tex.setAuthenticationRequest(authentication);\n \t\t\t\tlogger.debug(LogMessage.format(\""Authentication failed with provider %s since %s\"",\n \t\t\t\t\t\tprovider.getClass().getSimpleName(), ex.getMessage()));\n \t\t\t\tlastException = ex;\n@@ -265,6 +266,7 @@ public Authentication authenticate(Authentication authentication) throws Authent\n \n \t@SuppressWarnings(\""deprecation\"")\n \tprivate void prepareException(AuthenticationException ex, Authentication auth) {\n+\t\tex.setAuthenticationRequest(auth);\n \t\tthis.eventPublisher.publishAuthenticationFailure(ex, auth);\n \t}\n \n\ndiff --git a/core/src/main/java/org/springframework/security/core/AuthenticationException.java b/core/src/main/java/org/springframework/security/core/AuthenticationException.java\nindex 9e1fb756086..8efe1be55f1 100644\n--- a/core/src/main/java/org/springframework/security/core/AuthenticationException.java\n+++ b/core/src/main/java/org/springframework/security/core/AuthenticationException.java\n@@ -18,6 +18,8 @@\n \n import java.io.Serial;\n \n+import org.springframework.util.Assert;\n+\n /**\n  * Abstract superclass for all exceptions related to an {@link Authentication} object\n  * being invalid for whatever reason.\n@@ -29,6 +31,8 @@ public abstract class AuthenticationException extends RuntimeException {\n \t@Serial\n \tprivate static final long serialVersionUID = 2018827803361503060L;\n \n+\tprivate Authentication authenticationRequest;\n+\n \t/**\n \t * Constructs an {@code AuthenticationException} with the specified message and root\n \t * cause.\n@@ -48,4 +52,31 @@ public AuthenticationException(String msg) {\n \t\tsuper(msg);\n \t}\n \n+\t/**\n+\t * Get the {@link Authentication} object representing the failed authentication\n+\t * attempt.\n+\t * <p>\n+\t * This field captures the authentication request that was attempted but ultimately\n+\t * failed, providing critical information for diagnosing the failure and facilitating\n+\t * debugging\n+\t * @since 6.5\n+\t */\n+\tpublic Authentication getAuthenticationRequest() {\n+\t\treturn this.authenticationRequest;\n+\t}\n+\n+\t/**\n+\t * Set the {@link Authentication} object representing the failed authentication\n+\t * attempt.\n+\t * <p>\n+\t * The provided {@code authenticationRequest} should not be null\n+\t * @param authenticationRequest the authentication request associated with the failed\n+\t * authentication attempt\n+\t * @since 6.5\n+\t */\n+\tpublic void setAuthenticationRequest(Authentication authenticationRequest) {\n+\t\tAssert.notNull(authenticationRequest, \""authenticationRequest cannot be null\"");\n+\t\tthis.authenticationRequest = authenticationRequest;\n+\t}\n+\n }\n\ndiff --git a/core/src/main/java/org/springframework/security/jackson2/BadCredentialsExceptionMixin.java b/core/src/main/java/org/springframework/security/jackson2/BadCredentialsExceptionMixin.java\nindex 5471374b4d7..aedb7507adf 100644\n--- a/core/src/main/java/org/springframework/security/jackson2/BadCredentialsExceptionMixin.java\n+++ b/core/src/main/java/org/springframework/security/jackson2/BadCredentialsExceptionMixin.java\n@@ -40,7 +40,7 @@\n  * @see CoreJackson2Module\n  */\n @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY)\n-@JsonIgnoreProperties(ignoreUnknown = true, value = { \""cause\"", \""stackTrace\"" })\n+@JsonIgnoreProperties(ignoreUnknown = true, value = { \""cause\"", \""stackTrace\"", \""authenticationRequest\"" })\n class BadCredentialsExceptionMixin {\n \n \t/**\n\ndiff --git a/etc/checkstyle/checkstyle-suppressions.xml b/etc/checkstyle/checkstyle-suppressions.xml\nindex b368ce84e84..c1c5baf08a3 100644\n--- a/etc/checkstyle/checkstyle-suppressions.xml\n+++ b/etc/checkstyle/checkstyle-suppressions.xml\n@@ -38,6 +38,7 @@\n \t<suppress files=\""AbstractOAuth2AuthorizationGrantRequestEntityConverter\\.java\"" checks=\""SpringMethodVisibility\""/>\n \t<suppress files=\""JoseHeader\\.java\"" checks=\""SpringMethodVisibility\""/>\n \t<suppress files=\""DefaultLoginPageGeneratingFilterTests\\.java\"" checks=\""SpringLeadingWhitespace\""/>\n+\t<suppress files=\""AuthenticationException\\.java\"" checks=\""MutableException\""/>\n \n \t<!-- Lambdas that we can't replace with a method reference because a closure is required -->\n \t<suppress files=\""BearerTokenAuthenticationFilter\\.java\"" checks=\""SpringLambda\""/>\n\ndiff --git a/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerAuthenticationManagerResolver.java b/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerAuthenticationManagerResolver.java\nindex 5d80e981bb0..de1bda32a7c 100644\n--- a/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerAuthenticationManagerResolver.java\n+++ b/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerAuthenticationManagerResolver.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2020 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -176,9 +176,17 @@ public Authentication authenticate(Authentication authentication) throws Authent\n \t\t\tString issuer = this.issuerConverter.convert(token);\n \t\t\tAuthenticationManager authenticationManager = this.issuerAuthenticationManagerResolver.resolve(issuer);\n \t\t\tif (authenticationManager == null) {\n-\t\t\t\tthrow new InvalidBearerTokenException(\""Invalid issuer\"");\n+\t\t\t\tAuthenticationException ex = new InvalidBearerTokenException(\""Invalid issuer\"");\n+\t\t\t\tex.setAuthenticationRequest(authentication);\n+\t\t\t\tthrow ex;\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\treturn authenticationManager.authenticate(authentication);\n+\t\t\t}\n+\t\t\tcatch (AuthenticationException ex) {\n+\t\t\t\tex.setAuthenticationRequest(authentication);\n+\t\t\t\tthrow ex;\n \t\t\t}\n-\t\t\treturn authenticationManager.authenticate(authentication);\n \t\t}\n \n \t}\n@@ -194,10 +202,14 @@ public String convert(@NonNull BearerTokenAuthenticationToken authentication) {\n \t\t\t\t\treturn issuer;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcatch (Exception ex) {\n-\t\t\t\tthrow new InvalidBearerTokenException(ex.getMessage(), ex);\n+\t\t\tcatch (Exception cause) {\n+\t\t\t\tAuthenticationException ex = new InvalidBearerTokenException(cause.getMessage(), cause);\n+\t\t\t\tex.setAuthenticationRequest(authentication);\n+\t\t\t\tthrow ex;\n \t\t\t}\n-\t\t\tthrow new InvalidBearerTokenException(\""Missing issuer\"");\n+\t\t\tAuthenticationException ex = new InvalidBearerTokenException(\""Missing issuer\"");\n+\t\t\tex.setAuthenticationRequest(authentication);\n+\t\t\tthrow ex;\n \t\t}\n \n \t}\n\ndiff --git a/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerReactiveAuthenticationManagerResolver.java b/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerReactiveAuthenticationManagerResolver.java\nindex 2e81d3b3d8b..b764e4ca76c 100644\n--- a/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerReactiveAuthenticationManagerResolver.java\n+++ b/oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerReactiveAuthenticationManagerResolver.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -36,6 +36,7 @@\n import org.springframework.security.authentication.ReactiveAuthenticationManager;\n import org.springframework.security.authentication.ReactiveAuthenticationManagerResolver;\n import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.AuthenticationException;\n import org.springframework.security.oauth2.core.OAuth2AuthenticationException;\n import org.springframework.security.oauth2.jwt.ReactiveJwtDecoders;\n import org.springframework.security.oauth2.server.resource.InvalidBearerTokenException;\n@@ -181,8 +182,13 @@ public Mono<Authentication> authenticate(Authentication authentication) {\n \t\t\tBearerTokenAuthenticationToken token = (BearerTokenAuthenticationToken) authentication;\n \t\t\treturn this.issuerConverter.convert(token)\n \t\t\t\t.flatMap((issuer) -> this.issuerAuthenticationManagerResolver.resolve(issuer)\n-\t\t\t\t\t.switchIfEmpty(Mono.error(() -> new InvalidBearerTokenException(\""Invalid issuer \"" + issuer))))\n-\t\t\t\t.flatMap((manager) -> manager.authenticate(authentication));\n+\t\t\t\t\t.switchIfEmpty(Mono.error(() -> {\n+\t\t\t\t\t\tAuthenticationException ex = new InvalidBearerTokenException(\""Invalid issuer \"" + issuer);\n+\t\t\t\t\t\tex.setAuthenticationRequest(authentication);\n+\t\t\t\t\t\treturn ex;\n+\t\t\t\t\t})))\n+\t\t\t\t.flatMap((manager) -> manager.authenticate(authentication))\n+\t\t\t\t.doOnError(AuthenticationException.class, (ex) -> ex.setAuthenticationRequest(authentication));\n \t\t}\n \n \t}\n@@ -194,12 +200,18 @@ public Mono<String> convert(@NonNull BearerTokenAuthenticationToken token) {\n \t\t\ttry {\n \t\t\t\tString issuer = JWTParser.parse(token.getToken()).getJWTClaimsSet().getIssuer();\n \t\t\t\tif (issuer == null) {\n-\t\t\t\t\tthrow new InvalidBearerTokenException(\""Missing issuer\"");\n+\t\t\t\t\tAuthenticationException ex = new InvalidBearerTokenException(\""Missing issuer\"");\n+\t\t\t\t\tex.setAuthenticationRequest(token);\n+\t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\treturn Mono.just(issuer);\n \t\t\t}\n-\t\t\tcatch (Exception ex) {\n-\t\t\t\treturn Mono.error(() -> new InvalidBearerTokenException(ex.getMessage(), ex));\n+\t\t\tcatch (Exception cause) {\n+\t\t\t\treturn Mono.error(() -> {\n+\t\t\t\t\tAuthenticationException ex = new InvalidBearerTokenException(cause.getMessage(), cause);\n+\t\t\t\t\tex.setAuthenticationRequest(token);\n+\t\t\t\t\treturn ex;\n+\t\t\t\t});\n \t\t\t}\n \t\t}\n \n\ndiff --git a/web/src/main/java/org/springframework/security/web/access/ExceptionTranslationFilter.java b/web/src/main/java/org/springframework/security/web/access/ExceptionTranslationFilter.java\nindex 9a38b1d2312..765fec6ed3d 100644\n--- a/web/src/main/java/org/springframework/security/web/access/ExceptionTranslationFilter.java\n+++ b/web/src/main/java/org/springframework/security/web/access/ExceptionTranslationFilter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2004-2022 the original author or authors.\n+ * Copyright 2004-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -194,10 +194,11 @@ private void handleAccessDeniedException(HttpServletRequest request, HttpServlet\n \t\t\t\tlogger.trace(LogMessage.format(\""Sending %s to authentication entry point since access is denied\"",\n \t\t\t\t\t\tauthentication), exception);\n \t\t\t}\n-\t\t\tsendStartAuthentication(request, response, chain,\n-\t\t\t\t\tnew InsufficientAuthenticationException(\n-\t\t\t\t\t\t\tthis.messages.getMessage(\""ExceptionTranslationFilter.insufficientAuthentication\"",\n-\t\t\t\t\t\t\t\t\t\""Full authentication is required to access this resource\"")));\n+\t\t\tAuthenticationException ex = new InsufficientAuthenticationException(\n+\t\t\t\t\tthis.messages.getMessage(\""ExceptionTranslationFilter.insufficientAuthentication\"",\n+\t\t\t\t\t\t\t\""Full authentication is required to access this resource\""));\n+\t\t\tex.setAuthenticationRequest(authentication);\n+\t\t\tsendStartAuthentication(request, response, chain, ex);\n \t\t}\n \t\telse {\n \t\t\tif (logger.isTraceEnabled()) {\n\ndiff --git a/web/src/main/java/org/springframework/security/web/authentication/RequestMatcherDelegatingAuthenticationManagerResolver.java b/web/src/main/java/org/springframework/security/web/authentication/RequestMatcherDelegatingAuthenticationManagerResolver.java\nindex 04833fdeae5..eb164ea9e89 100644\n--- a/web/src/main/java/org/springframework/security/web/authentication/RequestMatcherDelegatingAuthenticationManagerResolver.java\n+++ b/web/src/main/java/org/springframework/security/web/authentication/RequestMatcherDelegatingAuthenticationManagerResolver.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -27,6 +27,7 @@\n import org.springframework.security.authentication.AuthenticationManagerResolver;\n import org.springframework.security.authentication.AuthenticationServiceException;\n import org.springframework.security.authorization.AuthorizationManager;\n+import org.springframework.security.core.AuthenticationException;\n import org.springframework.security.web.access.intercept.RequestMatcherDelegatingAuthorizationManager;\n import org.springframework.security.web.util.matcher.RequestMatcher;\n import org.springframework.security.web.util.matcher.RequestMatcherEntry;\n@@ -46,7 +47,9 @@ public final class RequestMatcherDelegatingAuthenticationManagerResolver\n \tprivate final List<RequestMatcherEntry<AuthenticationManager>> authenticationManagers;\n \n \tprivate AuthenticationManager defaultAuthenticationManager = (authentication) -> {\n-\t\tthrow new AuthenticationServiceException(\""Cannot authenticate \"" + authentication);\n+\t\tAuthenticationException ex = new AuthenticationServiceException(\""Cannot authenticate \"" + authentication);\n+\t\tex.setAuthenticationRequest(authentication);\n+\t\tthrow ex;\n \t};\n \n \t/**\n\ndiff --git a/web/src/main/java/org/springframework/security/web/server/authentication/ServerWebExchangeDelegatingReactiveAuthenticationManagerResolver.java b/web/src/main/java/org/springframework/security/web/server/authentication/ServerWebExchangeDelegatingReactiveAuthenticationManagerResolver.java\nindex 4605b0d1993..efca0acb628 100644\n--- a/web/src/main/java/org/springframework/security/web/server/authentication/ServerWebExchangeDelegatingReactiveAuthenticationManagerResolver.java\n+++ b/web/src/main/java/org/springframework/security/web/server/authentication/ServerWebExchangeDelegatingReactiveAuthenticationManagerResolver.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -26,6 +26,7 @@\n import org.springframework.security.authentication.AuthenticationServiceException;\n import org.springframework.security.authentication.ReactiveAuthenticationManager;\n import org.springframework.security.authentication.ReactiveAuthenticationManagerResolver;\n+import org.springframework.security.core.AuthenticationException;\n import org.springframework.security.web.access.intercept.RequestMatcherDelegatingAuthorizationManager;\n import org.springframework.security.web.server.util.matcher.ServerWebExchangeMatcher;\n import org.springframework.security.web.server.util.matcher.ServerWebExchangeMatcherEntry;\n@@ -46,8 +47,11 @@ public final class ServerWebExchangeDelegatingReactiveAuthenticationManagerResol\n \n \tprivate final List<ServerWebExchangeMatcherEntry<ReactiveAuthenticationManager>> authenticationManagers;\n \n-\tprivate ReactiveAuthenticationManager defaultAuthenticationManager = (authentication) -> Mono\n-\t\t.error(new AuthenticationServiceException(\""Cannot authenticate \"" + authentication));\n+\tprivate ReactiveAuthenticationManager defaultAuthenticationManager = (authentication) -> {\n+\t\tAuthenticationException ex = new AuthenticationServiceException(\""Cannot authenticate \"" + authentication);\n+\t\tex.setAuthenticationRequest(authentication);\n+\t\treturn Mono.error(ex);\n+\t};\n \n \t/**\n \t * Construct an\n\ndiff --git a/web/src/main/java/org/springframework/security/web/server/authorization/ExceptionTranslationWebFilter.java b/web/src/main/java/org/springframework/security/web/server/authorization/ExceptionTranslationWebFilter.java\nindex 6be2a6258ea..0c85e6ef033 100644\n--- a/web/src/main/java/org/springframework/security/web/server/authorization/ExceptionTranslationWebFilter.java\n+++ b/web/src/main/java/org/springframework/security/web/server/authorization/ExceptionTranslationWebFilter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -50,14 +50,19 @@ public class ExceptionTranslationWebFilter implements WebFilter {\n \t@Override\n \tpublic Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {\n \t\treturn chain.filter(exchange)\n-\t\t\t.onErrorResume(AccessDeniedException.class, (denied) -> exchange.getPrincipal()\n-\t\t\t\t.filter((principal) -> (!(principal instanceof Authentication) || (principal instanceof Authentication\n-\t\t\t\t\t\t&& (this.authenticationTrustResolver.isAuthenticated((Authentication) principal)))))\n-\t\t\t\t.switchIfEmpty(commenceAuthentication(exchange,\n-\t\t\t\t\t\tnew InsufficientAuthenticationException(\n-\t\t\t\t\t\t\t\t\""Full authentication is required to access this resource\"")))\n-\t\t\t\t.flatMap((principal) -> this.accessDeniedHandler.handle(exchange, denied))\n-\t\t\t\t.then());\n+\t\t\t.onErrorResume(AccessDeniedException.class,\n+\t\t\t\t\t(denied) -> exchange.getPrincipal()\n+\t\t\t\t\t\t.switchIfEmpty(Mono.defer(() -> commenceAuthentication(exchange, null)))\n+\t\t\t\t\t\t.flatMap((principal) -> {\n+\t\t\t\t\t\t\tif (!(principal instanceof Authentication authentication)) {\n+\t\t\t\t\t\t\t\treturn this.accessDeniedHandler.handle(exchange, denied);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (this.authenticationTrustResolver.isAuthenticated(authentication)) {\n+\t\t\t\t\t\t\t\treturn this.accessDeniedHandler.handle(exchange, denied);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn commenceAuthentication(exchange, authentication);\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.then());\n \t}\n \n \t/**\n@@ -92,10 +97,14 @@ public void setAuthenticationTrustResolver(AuthenticationTrustResolver authentic\n \t\tthis.authenticationTrustResolver = authenticationTrustResolver;\n \t}\n \n-\tprivate <T> Mono<T> commenceAuthentication(ServerWebExchange exchange, AuthenticationException denied) {\n-\t\treturn this.authenticationEntryPoint\n-\t\t\t.commence(exchange, new AuthenticationCredentialsNotFoundException(\""Not Authenticated\"", denied))\n-\t\t\t.then(Mono.empty());\n+\tprivate <T> Mono<T> commenceAuthentication(ServerWebExchange exchange, Authentication authentication) {\n+\t\tAuthenticationException cause = new InsufficientAuthenticationException(\n+\t\t\t\t\""Full authentication is required to access this resource\"");\n+\t\tAuthenticationException ex = new AuthenticationCredentialsNotFoundException(\""Not Authenticated\"", cause);\n+\t\tif (authentication != null) {\n+\t\t\tex.setAuthenticationRequest(authentication);\n+\t\t}\n+\t\treturn this.authenticationEntryPoint.commence(exchange, ex).then(Mono.empty());\n \t}\n \n }\n"", ""test_patch"": ""diff --git a/core/src/test/java/org/springframework/security/authentication/DelegatingReactiveAuthenticationManagerTests.java b/core/src/test/java/org/springframework/security/authentication/DelegatingReactiveAuthenticationManagerTests.java\nindex 2d4b2c7a158..6d7aa590184 100644\n--- a/core/src/test/java/org/springframework/security/authentication/DelegatingReactiveAuthenticationManagerTests.java\n+++ b/core/src/test/java/org/springframework/security/authentication/DelegatingReactiveAuthenticationManagerTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -26,6 +26,7 @@\n import reactor.test.StepVerifier;\n \n import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.AuthenticationException;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n@@ -108,6 +109,15 @@ public void authenticateWhenContinueOnErrorAndDelegate1NotEmptyThenReturnsNotEmp\n \t\tassertThat(manager.authenticate(this.authentication).block()).isEqualTo(this.authentication);\n \t}\n \n+\t@Test\n+\tvoid whenAccountStatusExceptionThenAuthenticationRequestIsIncluded() {\n+\t\tAuthenticationException expected = new LockedException(\""\"");\n+\t\tgiven(this.delegate1.authenticate(any())).willReturn(Mono.error(expected));\n+\t\tReactiveAuthenticationManager manager = new DelegatingReactiveAuthenticationManager(this.delegate1);\n+\t\tStepVerifier.create(manager.authenticate(this.authentication)).expectError(LockedException.class).verify();\n+\t\tassertThat(expected.getAuthenticationRequest()).isEqualTo(this.authentication);\n+\t}\n+\n \tprivate DelegatingReactiveAuthenticationManager managerWithContinueOnError() {\n \t\tDelegatingReactiveAuthenticationManager manager = new DelegatingReactiveAuthenticationManager(this.delegate1,\n \t\t\t\tthis.delegate2);\n\ndiff --git a/core/src/test/java/org/springframework/security/authentication/ProviderManagerTests.java b/core/src/test/java/org/springframework/security/authentication/ProviderManagerTests.java\nindex 9b98bd522a9..7bb0c136bca 100644\n--- a/core/src/test/java/org/springframework/security/authentication/ProviderManagerTests.java\n+++ b/core/src/test/java/org/springframework/security/authentication/ProviderManagerTests.java\n@@ -18,7 +18,6 @@\n \n import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Collections;\n import java.util.List;\n \n import org.junit.jupiter.api.Test;\n@@ -47,7 +46,7 @@\n public class ProviderManagerTests {\n \n \t@Test\n-\tpublic void authenticationFailsWithUnsupportedToken() {\n+\tvoid authenticationFailsWithUnsupportedToken() {\n \t\tAuthentication token = new AbstractAuthenticationToken(null) {\n \t\t\t@Override\n \t\t\tpublic Object getCredentials() {\n@@ -65,7 +64,7 @@ public Object getPrincipal() {\n \t}\n \n \t@Test\n-\tpublic void credentialsAreClearedByDefault() {\n+\tvoid credentialsAreClearedByDefault() {\n \t\tUsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(\""Test\"",\n \t\t\t\t\""Password\"");\n \t\tProviderManager mgr = makeProviderManager();\n@@ -78,8 +77,8 @@ public void credentialsAreClearedByDefault() {\n \t}\n \n \t@Test\n-\tpublic void authenticationSucceedsWithSupportedTokenAndReturnsExpectedObject() {\n-\t\tfinal Authentication a = mock(Authentication.class);\n+\tvoid authenticationSucceedsWithSupportedTokenAndReturnsExpectedObject() {\n+\t\tAuthentication a = mock(Authentication.class);\n \t\tProviderManager mgr = new ProviderManager(createProviderWhichReturns(a));\n \t\tAuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher.class);\n \t\tmgr.setAuthenticationEventPublisher(publisher);\n@@ -89,8 +88,8 @@ public void authenticationSucceedsWithSupportedTokenAndReturnsExpectedObject() {\n \t}\n \n \t@Test\n-\tpublic void authenticationSucceedsWhenFirstProviderReturnsNullButSecondAuthenticates() {\n-\t\tfinal Authentication a = mock(Authentication.class);\n+\tvoid authenticationSucceedsWhenFirstProviderReturnsNullButSecondAuthenticates() {\n+\t\tAuthentication a = mock(Authentication.class);\n \t\tProviderManager mgr = new ProviderManager(\n \t\t\t\tArrays.asList(createProviderWhichReturns(null), createProviderWhichReturns(a)));\n \t\tAuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher.class);\n@@ -101,24 +100,24 @@ public void authenticationSucceedsWhenFirstProviderReturnsNullButSecondAuthentic\n \t}\n \n \t@Test\n-\tpublic void testStartupFailsIfProvidersNotSetAsList() {\n+\tvoid testStartupFailsIfProvidersNotSetAsList() {\n \t\tassertThatIllegalArgumentException().isThrownBy(() -> new ProviderManager((List<AuthenticationProvider>) null));\n \t}\n \n \t@Test\n-\tpublic void testStartupFailsIfProvidersNotSetAsVarargs() {\n+\tvoid testStartupFailsIfProvidersNotSetAsVarargs() {\n \t\tassertThatIllegalArgumentException().isThrownBy(() -> new ProviderManager((AuthenticationProvider) null));\n \t}\n \n \t@Test\n-\tpublic void testStartupFailsIfProvidersContainNullElement() {\n+\tvoid testStartupFailsIfProvidersContainNullElement() {\n \t\tassertThatIllegalArgumentException()\n \t\t\t.isThrownBy(() -> new ProviderManager(Arrays.asList(mock(AuthenticationProvider.class), null)));\n \t}\n \n \t// gh-8689\n \t@Test\n-\tpublic void constructorWhenUsingListOfThenNoException() {\n+\tvoid constructorWhenUsingListOfThenNoException() {\n \t\tList<AuthenticationProvider> providers = spy(ArrayList.class);\n \t\t// List.of(null) in JDK 9 throws a NullPointerException\n \t\tgiven(providers.contains(eq(null))).willThrow(NullPointerException.class);\n@@ -127,7 +126,7 @@ public void constructorWhenUsingListOfThenNoException() {\n \t}\n \n \t@Test\n-\tpublic void detailsAreNotSetOnAuthenticationTokenIfAlreadySetByProvider() {\n+\tvoid detailsAreNotSetOnAuthenticationTokenIfAlreadySetByProvider() {\n \t\tObject requestDetails = \""(Request Details)\"";\n \t\tfinal Object resultDetails = \""(Result Details)\"";\n \t\t// A provider which sets the details object\n@@ -151,7 +150,7 @@ public boolean supports(Class<?> authentication) {\n \t}\n \n \t@Test\n-\tpublic void detailsAreSetOnAuthenticationTokenIfNotAlreadySetByProvider() {\n+\tvoid detailsAreSetOnAuthenticationTokenIfNotAlreadySetByProvider() {\n \t\tObject details = new Object();\n \t\tProviderManager authMgr = makeProviderManager();\n \t\tTestingAuthenticationToken request = createAuthenticationToken();\n@@ -162,8 +161,8 @@ public void detailsAreSetOnAuthenticationTokenIfNotAlreadySetByProvider() {\n \t}\n \n \t@Test\n-\tpublic void authenticationExceptionIsIgnoredIfLaterProviderAuthenticates() {\n-\t\tfinal Authentication authReq = mock(Authentication.class);\n+\tvoid authenticationExceptionIsIgnoredIfLaterProviderAuthenticates() {\n+\t\tAuthentication authReq = mock(Authentication.class);\n \t\tProviderManager mgr = new ProviderManager(\n \t\t\t\tcreateProviderWhichThrows(new BadCredentialsException(\""\"", new Throwable())),\n \t\t\t\tcreateProviderWhichReturns(authReq));\n@@ -171,7 +170,7 @@ public void authenticationExceptionIsIgnoredIfLaterProviderAuthenticates() {\n \t}\n \n \t@Test\n-\tpublic void authenticationExceptionIsRethrownIfNoLaterProviderAuthenticates() {\n+\tvoid authenticationExceptionIsRethrownIfNoLaterProviderAuthenticates() {\n \t\tProviderManager mgr = new ProviderManager(Arrays\n \t\t\t.asList(createProviderWhichThrows(new BadCredentialsException(\""\"")), createProviderWhichReturns(null)));\n \t\tassertThatExceptionOfType(BadCredentialsException.class)\n@@ -180,7 +179,7 @@ public void authenticationExceptionIsRethrownIfNoLaterProviderAuthenticates() {\n \n \t// SEC-546\n \t@Test\n-\tpublic void accountStatusExceptionPreventsCallsToSubsequentProviders() {\n+\tvoid accountStatusExceptionPreventsCallsToSubsequentProviders() {\n \t\tAuthenticationProvider iThrowAccountStatusException = createProviderWhichThrows(new AccountStatusException(\""\"") {\n \t\t});\n \t\tAuthenticationProvider otherProvider = mock(AuthenticationProvider.class);\n@@ -191,48 +190,47 @@ public void accountStatusExceptionPreventsCallsToSubsequentProviders() {\n \t}\n \n \t@Test\n-\tpublic void parentAuthenticationIsUsedIfProvidersDontAuthenticate() {\n+\tvoid parentAuthenticationIsUsedIfProvidersDontAuthenticate() {\n \t\tAuthenticationManager parent = mock(AuthenticationManager.class);\n \t\tAuthentication authReq = mock(Authentication.class);\n \t\tgiven(parent.authenticate(authReq)).willReturn(authReq);\n-\t\tProviderManager mgr = new ProviderManager(Collections.singletonList(mock(AuthenticationProvider.class)),\n-\t\t\t\tparent);\n+\t\tProviderManager mgr = new ProviderManager(List.of(mock(AuthenticationProvider.class)), parent);\n \t\tassertThat(mgr.authenticate(authReq)).isSameAs(authReq);\n \t}\n \n \t@Test\n-\tpublic void parentIsNotCalledIfAccountStatusExceptionIsThrown() {\n+\tvoid parentIsNotCalledIfAccountStatusExceptionIsThrown() {\n \t\tAuthenticationProvider iThrowAccountStatusException = createProviderWhichThrows(\n \t\t\t\tnew AccountStatusException(\""\"", new Throwable()) {\n \t\t\t\t});\n \t\tAuthenticationManager parent = mock(AuthenticationManager.class);\n-\t\tProviderManager mgr = new ProviderManager(Collections.singletonList(iThrowAccountStatusException), parent);\n+\t\tProviderManager mgr = new ProviderManager(List.of(iThrowAccountStatusException), parent);\n \t\tassertThatExceptionOfType(AccountStatusException.class)\n \t\t\t.isThrownBy(() -> mgr.authenticate(mock(Authentication.class)));\n \t\tverifyNoInteractions(parent);\n \t}\n \n \t@Test\n-\tpublic void providerNotFoundFromParentIsIgnored() {\n+\tvoid providerNotFoundFromParentIsIgnored() {\n \t\tfinal Authentication authReq = mock(Authentication.class);\n \t\tAuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher.class);\n \t\tAuthenticationManager parent = mock(AuthenticationManager.class);\n \t\tgiven(parent.authenticate(authReq)).willThrow(new ProviderNotFoundException(\""\""));\n \t\t// Set a provider that throws an exception - this is the exception we expect to be\n \t\t// propagated\n-\t\tProviderManager mgr = new ProviderManager(\n-\t\t\t\tCollections.singletonList(createProviderWhichThrows(new BadCredentialsException(\""\""))), parent);\n+\t\tProviderManager mgr = new ProviderManager(List.of(createProviderWhichThrows(new BadCredentialsException(\""\""))),\n+\t\t\t\tparent);\n \t\tmgr.setAuthenticationEventPublisher(publisher);\n \t\tassertThatExceptionOfType(BadCredentialsException.class).isThrownBy(() -> mgr.authenticate(authReq))\n \t\t\t.satisfies((ex) -> verify(publisher).publishAuthenticationFailure(ex, authReq));\n \t}\n \n \t@Test\n-\tpublic void authenticationExceptionFromParentOverridesPreviousOnes() {\n+\tvoid authenticationExceptionFromParentOverridesPreviousOnes() {\n \t\tAuthenticationManager parent = mock(AuthenticationManager.class);\n-\t\tProviderManager mgr = new ProviderManager(\n-\t\t\t\tCollections.singletonList(createProviderWhichThrows(new BadCredentialsException(\""\""))), parent);\n-\t\tfinal Authentication authReq = mock(Authentication.class);\n+\t\tProviderManager mgr = new ProviderManager(List.of(createProviderWhichThrows(new BadCredentialsException(\""\""))),\n+\t\t\t\tparent);\n+\t\tAuthentication authReq = mock(Authentication.class);\n \t\tAuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher.class);\n \t\tmgr.setAuthenticationEventPublisher(publisher);\n \t\t// Set a provider that throws an exception - this is the exception we expect to be\n@@ -244,21 +242,48 @@ public void authenticationExceptionFromParentOverridesPreviousOnes() {\n \t}\n \n \t@Test\n-\tpublic void statusExceptionIsPublished() {\n+\tvoid statusExceptionIsPublished() {\n \t\tAuthenticationManager parent = mock(AuthenticationManager.class);\n-\t\tfinal LockedException expected = new LockedException(\""\"");\n-\t\tProviderManager mgr = new ProviderManager(Collections.singletonList(createProviderWhichThrows(expected)),\n-\t\t\t\tparent);\n-\t\tfinal Authentication authReq = mock(Authentication.class);\n+\t\tLockedException expected = new LockedException(\""\"");\n+\t\tProviderManager mgr = new ProviderManager(List.of(createProviderWhichThrows(expected)), parent);\n+\t\tAuthentication authReq = mock(Authentication.class);\n \t\tAuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher.class);\n \t\tmgr.setAuthenticationEventPublisher(publisher);\n \t\tassertThatExceptionOfType(LockedException.class).isThrownBy(() -> mgr.authenticate(authReq));\n \t\tverify(publisher).publishAuthenticationFailure(expected, authReq);\n \t}\n \n+\t@Test\n+\tvoid whenAccountStatusExceptionThenAuthenticationRequestIsIncluded() {\n+\t\tAuthenticationException expected = new LockedException(\""\"");\n+\t\tProviderManager mgr = new ProviderManager(createProviderWhichThrows(expected));\n+\t\tAuthentication authReq = mock(Authentication.class);\n+\t\tassertThatExceptionOfType(LockedException.class).isThrownBy(() -> mgr.authenticate(authReq));\n+\t\tassertThat(expected.getAuthenticationRequest()).isEqualTo(authReq);\n+\t}\n+\n+\t@Test\n+\tvoid whenInternalServiceAuthenticationExceptionThenAuthenticationRequestIsIncluded() {\n+\t\tAuthenticationException expected = new InternalAuthenticationServiceException(\""\"");\n+\t\tProviderManager mgr = new ProviderManager(createProviderWhichThrows(expected));\n+\t\tAuthentication authReq = mock(Authentication.class);\n+\t\tassertThatExceptionOfType(InternalAuthenticationServiceException.class)\n+\t\t\t.isThrownBy(() -> mgr.authenticate(authReq));\n+\t\tassertThat(expected.getAuthenticationRequest()).isEqualTo(authReq);\n+\t}\n+\n+\t@Test\n+\tvoid whenAuthenticationExceptionThenAuthenticationRequestIsIncluded() {\n+\t\tAuthenticationException expected = new BadCredentialsException(\""\"");\n+\t\tProviderManager mgr = new ProviderManager(createProviderWhichThrows(expected));\n+\t\tAuthentication authReq = mock(Authentication.class);\n+\t\tassertThatExceptionOfType(BadCredentialsException.class).isThrownBy(() -> mgr.authenticate(authReq));\n+\t\tassertThat(expected.getAuthenticationRequest()).isEqualTo(authReq);\n+\t}\n+\n \t// SEC-2367\n \t@Test\n-\tpublic void providerThrowsInternalAuthenticationServiceException() {\n+\tvoid providerThrowsInternalAuthenticationServiceException() {\n \t\tInternalAuthenticationServiceException expected = new InternalAuthenticationServiceException(\""Expected\"");\n \t\tProviderManager mgr = new ProviderManager(Arrays.asList(createProviderWhichThrows(expected),\n \t\t\t\tcreateProviderWhichThrows(new BadCredentialsException(\""Oops\""))), null);\n@@ -269,15 +294,15 @@ public void providerThrowsInternalAuthenticationServiceException() {\n \n \t// gh-6281\n \t@Test\n-\tpublic void authenticateWhenFailsInParentAndPublishesThenChildDoesNotPublish() {\n+\tvoid authenticateWhenFailsInParentAndPublishesThenChildDoesNotPublish() {\n \t\tBadCredentialsException badCredentialsExParent = new BadCredentialsException(\""Bad Credentials in parent\"");\n \t\tProviderManager parentMgr = new ProviderManager(createProviderWhichThrows(badCredentialsExParent));\n-\t\tProviderManager childMgr = new ProviderManager(Collections.singletonList(\n-\t\t\t\tcreateProviderWhichThrows(new BadCredentialsException(\""Bad Credentials in child\""))), parentMgr);\n+\t\tProviderManager childMgr = new ProviderManager(\n+\t\t\t\tList.of(createProviderWhichThrows(new BadCredentialsException(\""Bad Credentials in child\""))), parentMgr);\n \t\tAuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher.class);\n \t\tparentMgr.setAuthenticationEventPublisher(publisher);\n \t\tchildMgr.setAuthenticationEventPublisher(publisher);\n-\t\tfinal Authentication authReq = mock(Authentication.class);\n+\t\tAuthentication authReq = mock(Authentication.class);\n \t\tassertThatExceptionOfType(BadCredentialsException.class).isThrownBy(() -> childMgr.authenticate(authReq))\n \t\t\t.isSameAs(badCredentialsExParent);\n \t\tverify(publisher).publishAuthenticationFailure(badCredentialsExParent, authReq); // Parent\n\ndiff --git a/oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerAuthenticationManagerResolverTests.java b/oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerAuthenticationManagerResolverTests.java\nindex 8a50dab1530..8d5e9c7780e 100644\n--- a/oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerAuthenticationManagerResolverTests.java\n+++ b/oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerAuthenticationManagerResolverTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2020 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -37,14 +37,18 @@\n import org.springframework.security.authentication.AuthenticationManager;\n import org.springframework.security.authentication.AuthenticationManagerResolver;\n import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.AuthenticationException;\n import org.springframework.security.oauth2.core.OAuth2AuthenticationException;\n import org.springframework.security.oauth2.jose.TestKeys;\n import org.springframework.security.oauth2.jwt.JwtClaimNames;\n+import org.springframework.security.oauth2.server.resource.InvalidBearerTokenException;\n import org.springframework.security.oauth2.server.resource.authentication.JwtIssuerAuthenticationManagerResolver.TrustedIssuerJwtAuthenticationManagerResolver;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.BDDMockito.given;\n import static org.mockito.BDDMockito.mock;\n import static org.mockito.BDDMockito.verify;\n \n@@ -263,6 +267,19 @@ public void resolveWhenBearerTokenEvilThenGenericException() {\n \t\t// @formatter:on\n \t}\n \n+\t@Test\n+\tpublic void resolveWhenAuthenticationExceptionThenAuthenticationRequestIsIncluded() {\n+\t\tAuthentication authentication = new BearerTokenAuthenticationToken(this.jwt);\n+\t\tAuthenticationException ex = new InvalidBearerTokenException(\""\"");\n+\t\tAuthenticationManager manager = mock(AuthenticationManager.class);\n+\t\tgiven(manager.authenticate(any())).willThrow(ex);\n+\t\tJwtIssuerAuthenticationManagerResolver resolver = new JwtIssuerAuthenticationManagerResolver(\n+\t\t\t\t(issuer) -> manager);\n+\t\tassertThatExceptionOfType(InvalidBearerTokenException.class)\n+\t\t\t.isThrownBy(() -> resolver.resolve(null).authenticate(authentication));\n+\t\tassertThat(ex.getAuthenticationRequest()).isEqualTo(authentication);\n+\t}\n+\n \t@Test\n \tpublic void factoryWhenNullOrEmptyIssuersThenException() {\n \t\tassertThatIllegalArgumentException()\n\ndiff --git a/oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerReactiveAuthenticationManagerResolverTests.java b/oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerReactiveAuthenticationManagerResolverTests.java\nindex f12c6d65be5..63bd66cf735 100644\n--- a/oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerReactiveAuthenticationManagerResolverTests.java\n+++ b/oauth2/oauth2-resource-server/src/test/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerReactiveAuthenticationManagerResolverTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2020 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -34,13 +34,16 @@\n import okhttp3.mockwebserver.MockWebServer;\n import org.junit.jupiter.api.Test;\n import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n \n import org.springframework.security.authentication.ReactiveAuthenticationManager;\n import org.springframework.security.authentication.ReactiveAuthenticationManagerResolver;\n import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.AuthenticationException;\n import org.springframework.security.oauth2.core.OAuth2AuthenticationException;\n import org.springframework.security.oauth2.jose.TestKeys;\n import org.springframework.security.oauth2.jwt.JwtClaimNames;\n+import org.springframework.security.oauth2.server.resource.InvalidBearerTokenException;\n import org.springframework.security.oauth2.server.resource.authentication.JwtIssuerReactiveAuthenticationManagerResolver.TrustedIssuerJwtAuthenticationManagerResolver;\n \n import static org.assertj.core.api.Assertions.assertThat;\n@@ -262,6 +265,20 @@ public void resolveWhenBearerTokenEvilThenGenericException() {\n \t\t// @formatter:on\n \t}\n \n+\t@Test\n+\tpublic void resolveWhenAuthenticationExceptionThenAuthenticationRequestIsIncluded() {\n+\t\tAuthentication authentication = new BearerTokenAuthenticationToken(this.jwt);\n+\t\tAuthenticationException ex = new InvalidBearerTokenException(\""\"");\n+\t\tReactiveAuthenticationManager manager = mock(ReactiveAuthenticationManager.class);\n+\t\tgiven(manager.authenticate(any())).willReturn(Mono.error(ex));\n+\t\tJwtIssuerReactiveAuthenticationManagerResolver resolver = new JwtIssuerReactiveAuthenticationManagerResolver(\n+\t\t\t\t(issuer) -> Mono.just(manager));\n+\t\tStepVerifier.create(resolver.resolve(null).block().authenticate(authentication))\n+\t\t\t.expectError(InvalidBearerTokenException.class)\n+\t\t\t.verify();\n+\t\tassertThat(ex.getAuthenticationRequest()).isEqualTo(authentication);\n+\t}\n+\n \t@Test\n \tpublic void factoryWhenNullOrEmptyIssuersThenException() {\n \t\tassertThatIllegalArgumentException().isThrownBy(\n\ndiff --git a/web/src/test/java/org/springframework/security/web/access/ExceptionTranslationFilterTests.java b/web/src/test/java/org/springframework/security/web/access/ExceptionTranslationFilterTests.java\nindex 085ec955780..89159fd7377 100644\n--- a/web/src/test/java/org/springframework/security/web/access/ExceptionTranslationFilterTests.java\n+++ b/web/src/test/java/org/springframework/security/web/access/ExceptionTranslationFilterTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2004-2024 the original author or authors.\n+ * Copyright 2004-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -27,6 +27,7 @@\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n \n import org.springframework.context.MessageSource;\n import org.springframework.context.i18n.LocaleContextHolder;\n@@ -38,6 +39,7 @@\n import org.springframework.security.authentication.AuthenticationTrustResolverImpl;\n import org.springframework.security.authentication.BadCredentialsException;\n import org.springframework.security.authentication.RememberMeAuthenticationToken;\n+import org.springframework.security.core.AuthenticationException;\n import org.springframework.security.core.authority.AuthorityUtils;\n import org.springframework.security.core.context.SecurityContext;\n import org.springframework.security.core.context.SecurityContextHolder;\n@@ -107,6 +109,23 @@ public void testAccessDeniedWhenAnonymous() throws Exception {\n \t\tassertThat(response.getRedirectedUrl()).isEqualTo(\""/mycontext/login.jsp\"");\n \t}\n \n+\t@Test\n+\tpublic void testAccessDeniedWhenAnonymousThenIncludesAuthenticationRequest() throws Exception {\n+\t\t// Setup our HTTP request\n+\t\tMockHttpServletRequest request = new MockHttpServletRequest(\""GET\"", \""/\"");\n+\t\tFilterChain fc = mockFilterChainWithException(new AccessDeniedException(\""\""));\n+\t\tAnonymousAuthenticationToken token = new AnonymousAuthenticationToken(\""ignored\"", \""ignored\"",\n+\t\t\t\tAuthorityUtils.createAuthorityList(\""IGNORED\""));\n+\t\tSecurityContextHolder.getContext().setAuthentication(token);\n+\t\tAuthenticationEntryPoint entryPoint = mock(AuthenticationEntryPoint.class);\n+\t\tExceptionTranslationFilter filter = new ExceptionTranslationFilter(entryPoint);\n+\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n+\t\tfilter.doFilter(request, response, fc);\n+\t\tArgumentCaptor<AuthenticationException> ex = ArgumentCaptor.forClass(AuthenticationException.class);\n+\t\tverify(entryPoint).commence(any(), any(), ex.capture());\n+\t\tassertThat(ex.getValue().getAuthenticationRequest()).isEqualTo(token);\n+\t}\n+\n \t@Test\n \tpublic void testAccessDeniedWithRememberMe() throws Exception {\n \t\t// Setup our HTTP request\n\ndiff --git a/web/src/test/java/org/springframework/security/web/server/authorization/ExceptionTranslationWebFilterTests.java b/web/src/test/java/org/springframework/security/web/server/authorization/ExceptionTranslationWebFilterTests.java\nindex e323572b1af..0c4f2a21775 100644\n--- a/web/src/test/java/org/springframework/security/web/server/authorization/ExceptionTranslationWebFilterTests.java\n+++ b/web/src/test/java/org/springframework/security/web/server/authorization/ExceptionTranslationWebFilterTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \""License\"");\n  * you may not use this file except in compliance with the License.\n@@ -21,6 +21,7 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n import org.mockito.Mock;\n import org.mockito.junit.jupiter.MockitoExtension;\n import reactor.core.publisher.Mono;\n@@ -31,6 +32,7 @@\n import org.springframework.mock.http.server.reactive.MockServerHttpResponse;\n import org.springframework.security.access.AccessDeniedException;\n import org.springframework.security.authentication.AnonymousAuthenticationToken;\n+import org.springframework.security.core.AuthenticationException;\n import org.springframework.security.web.server.ServerAuthenticationEntryPoint;\n import org.springframework.web.server.ServerWebExchange;\n import org.springframework.web.server.WebFilterChain;\n@@ -39,6 +41,7 @@\n import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.verify;\n \n /**\n  * @author Rob Winch\n@@ -129,7 +132,6 @@ public void filterWhenDefaultsAndAccessDeniedExceptionAndNotAuthenticatedThenUna\n \t@Test\n \tpublic void filterWhenAccessDeniedExceptionAndAuthenticatedThenHandled() {\n \t\tgiven(this.deniedHandler.handle(any(), any())).willReturn(this.deniedPublisher.mono());\n-\t\tgiven(this.entryPoint.commence(any(), any())).willReturn(this.entryPointPublisher.mono());\n \t\tgiven(this.exchange.getPrincipal()).willReturn(Mono.just(this.principal));\n \t\tgiven(this.chain.filter(this.exchange)).willReturn(Mono.error(new AccessDeniedException(\""Not Authorized\"")));\n \t\tStepVerifier.create(this.filter.filter(this.exchange, this.chain)).expectComplete().verify();\n@@ -147,6 +149,17 @@ public void filterWhenAccessDeniedExceptionAndAnonymousAuthenticatedThenHandled(\n \t\tthis.entryPointPublisher.assertWasSubscribed();\n \t}\n \n+\t@Test\n+\tpublic void filterWhenAccessDeniedExceptionAndAnonymousAuthenticatedThenIncludesAuthenticationRequest() {\n+\t\tgiven(this.entryPoint.commence(any(), any())).willReturn(this.entryPointPublisher.mono());\n+\t\tgiven(this.exchange.getPrincipal()).willReturn(Mono.just(this.anonymousPrincipal));\n+\t\tgiven(this.chain.filter(this.exchange)).willReturn(Mono.error(new AccessDeniedException(\""Not Authorized\"")));\n+\t\tStepVerifier.create(this.filter.filter(this.exchange, this.chain)).expectComplete().verify();\n+\t\tArgumentCaptor<AuthenticationException> ex = ArgumentCaptor.forClass(AuthenticationException.class);\n+\t\tverify(this.entryPoint).commence(any(), ex.capture());\n+\t\tassertThat(ex.getValue().getAuthenticationRequest()).isEqualTo(this.anonymousPrincipal);\n+\t}\n+\n \t@Test\n \tpublic void setAccessDeniedHandlerWhenNullThenException() {\n \t\tassertThatIllegalArgumentException().isThrownBy(() -> this.filter.setAccessDeniedHandler(null));\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""spring-projects__spring-security-16245"", ""pr_id"": 16245, ""issue_id"": 16177, ""repo"": ""spring-projects/spring-security"", ""problem_statement"": ""Issue when using @AuthenticationPrincipal on interfaces\nIn the current version of Spring Security (version 6.4), a changed behavior occurs when using the `@AuthenticationPrincipal` annotation on an interface. If the annotation is applied directly to the concrete implementation, everything works as expected and the `UserDetails` object is passed correctly. However, if the annotation is applied to an interface, the implementation receives a new or empty UserDetails object.\r\n\r\n**Reproduction of the problem:**\r\nThe problem can be reproduced with the example project: [K-e-l-v-i-n-12/spring-security](https://github.com/K-e-l-v-i-n-12/spring-security)\r\n\r\n**Steps to reproduce:**\r\n- Start the application.\r\n- Call `http://localhost:8080/userByInterface` (any username/password). The response is: Hello, null.\r\n- Call `http://localhost:8080/userByImplementation` (any username/password). The response is: Hello, test.\r\n\r\n**Actual behaviour:**\r\nIf `@AuthenticationPrincipal` is applied to an interface, the implementation receives an empty UserDetails object.\r\n\r\n**Expected behaviour:**\r\nThe UserDetails object should be passed correctly even when an interface is used.\r\n\r\n**Proposed solution:**\r\nExtend support for @AuthenticationPrincipal to interfaces."", ""issue_word_count"": 172, ""test_files_count"": 5, ""non_test_files_count"": 7, ""pr_changed_files"": [""config/src/test/java/org/springframework/security/config/annotation/web/reactive/EnableWebFluxSecurityTests.java"", ""messaging/src/main/java/org/springframework/security/messaging/context/AuthenticationPrincipalArgumentResolver.java"", ""messaging/src/main/java/org/springframework/security/messaging/handler/invocation/reactive/AuthenticationPrincipalArgumentResolver.java"", ""messaging/src/main/java/org/springframework/security/messaging/handler/invocation/reactive/CurrentSecurityContextArgumentResolver.java"", ""messaging/src/test/java/org/springframework/security/messaging/context/AuthenticationPrincipalArgumentResolverTests.java"", ""messaging/src/test/java/org/springframework/security/messaging/handler/invocation/reactive/AuthenticationPrincipalArgumentResolverTests.java"", ""web/src/main/java/org/springframework/security/web/method/annotation/AuthenticationPrincipalArgumentResolver.java"", ""web/src/main/java/org/springframework/security/web/method/annotation/CurrentSecurityContextArgumentResolver.java"", ""web/src/main/java/org/springframework/security/web/reactive/result/method/annotation/AuthenticationPrincipalArgumentResolver.java"", ""web/src/main/java/org/springframework/security/web/reactive/result/method/annotation/CurrentSecurityContextArgumentResolver.java"", ""web/src/test/java/org/springframework/security/web/method/annotation/AuthenticationPrincipalArgumentResolverTests.java"", ""web/src/test/java/org/springframework/security/web/reactive/result/method/annotation/AuthenticationPrincipalArgumentResolverTests.java""], ""pr_changed_test_files"": [""config/src/test/java/org/springframework/security/config/annotation/web/reactive/EnableWebFluxSecurityTests.java"", ""messaging/src/test/java/org/springframework/security/messaging/context/AuthenticationPrincipalArgumentResolverTests.java"", ""messaging/src/test/java/org/springframework/security/messaging/handler/invocation/reactive/AuthenticationPrincipalArgumentResolverTests.java"", ""web/src/test/java/org/springframework/security/web/method/annotation/AuthenticationPrincipalArgumentResolverTests.java"", ""web/src/test/java/org/springframework/security/web/reactive/result/method/annotation/AuthenticationPrincipalArgumentResolverTests.java""], ""base_commit"": ""b168ec5f0d9c3de9cfc5c33d6736de370d04a0fd"", ""head_commit"": ""8018b0ed552d618f3cb6fc4f52b0acaac804b6d6"", ""repo_url"": ""https://github.com/spring-projects/spring-security/pull/16245"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/spring-projects__spring-security/16245"", ""dockerfile"": """", ""pr_merged_at"": ""2024-12-10T21:09:47.000Z"", ""patch"": ""diff --git a/messaging/src/main/java/org/springframework/security/messaging/context/AuthenticationPrincipalArgumentResolver.java b/messaging/src/main/java/org/springframework/security/messaging/context/AuthenticationPrincipalArgumentResolver.java\nindex f3f6f80fbea..5cee1b49acb 100644\n--- a/messaging/src/main/java/org/springframework/security/messaging/context/AuthenticationPrincipalArgumentResolver.java\n+++ b/messaging/src/main/java/org/springframework/security/messaging/context/AuthenticationPrincipalArgumentResolver.java\n@@ -19,6 +19,8 @@\n import java.lang.annotation.Annotation;\n \n import org.springframework.core.MethodParameter;\n+import org.springframework.core.annotation.AnnotationUtils;\n+import org.springframework.core.annotation.MergedAnnotations;\n import org.springframework.expression.Expression;\n import org.springframework.expression.ExpressionParser;\n import org.springframework.expression.spel.standard.SpelExpressionParser;\n@@ -95,8 +97,12 @@ public final class AuthenticationPrincipalArgumentResolver implements HandlerMet\n \n \tprivate ExpressionParser parser = new SpelExpressionParser();\n \n+\tprivate final Class<AuthenticationPrincipal> annotationType = AuthenticationPrincipal.class;\n+\n \tprivate SecurityAnnotationScanner<AuthenticationPrincipal> scanner = SecurityAnnotationScanners\n-\t\t.requireUnique(AuthenticationPrincipal.class);\n+\t\t.requireUnique(this.annotationType);\n+\n+\tprivate boolean useAnnotationTemplate = false;\n \n \t@Override\n \tpublic boolean supportsParameter(MethodParameter parameter) {\n@@ -149,6 +155,7 @@ public void setSecurityContextHolderStrategy(SecurityContextHolderStrategy secur\n \t * @since 6.4\n \t */\n \tpublic void setTemplateDefaults(AnnotationTemplateExpressionDefaults templateDefaults) {\n+\t\tthis.useAnnotationTemplate = templateDefaults != null;\n \t\tthis.scanner = SecurityAnnotationScanners.requireUnique(AuthenticationPrincipal.class, templateDefaults);\n \t}\n \n@@ -158,9 +165,22 @@ public void setTemplateDefaults(AnnotationTemplateExpressionDefaults templateDef\n \t * @param parameter the {@link MethodParameter} to search for an {@link Annotation}\n \t * @return the {@link Annotation} that was found or null.\n \t */\n-\t@SuppressWarnings(\""unchecked\"")\n-\tprivate <T extends Annotation> T findMethodAnnotation(MethodParameter parameter) {\n-\t\treturn (T) this.scanner.scan(parameter.getParameter());\n+\tprivate AuthenticationPrincipal findMethodAnnotation(MethodParameter parameter) {\n+\t\tif (this.useAnnotationTemplate) {\n+\t\t\treturn this.scanner.scan(parameter.getParameter());\n+\t\t}\n+\t\tAuthenticationPrincipal annotation = parameter.getParameterAnnotation(this.annotationType);\n+\t\tif (annotation != null) {\n+\t\t\treturn annotation;\n+\t\t}\n+\t\tAnnotation[] annotationsToSearch = parameter.getParameterAnnotations();\n+\t\tfor (Annotation toSearch : annotationsToSearch) {\n+\t\t\tannotation = AnnotationUtils.findAnnotation(toSearch.annotationType(), this.annotationType);\n+\t\t\tif (annotation != null) {\n+\t\t\t\treturn MergedAnnotations.from(toSearch).get(this.annotationType).synthesize();\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n \t}\n \n }\n\ndiff --git a/messaging/src/main/java/org/springframework/security/messaging/handler/invocation/reactive/AuthenticationPrincipalArgumentResolver.java b/messaging/src/main/java/org/springframework/security/messaging/handler/invocation/reactive/AuthenticationPrincipalArgumentResolver.java\nindex bb0590a9caa..ef8a93a4d4e 100644\n--- a/messaging/src/main/java/org/springframework/security/messaging/handler/invocation/reactive/AuthenticationPrincipalArgumentResolver.java\n+++ b/messaging/src/main/java/org/springframework/security/messaging/handler/invocation/reactive/AuthenticationPrincipalArgumentResolver.java\n@@ -25,6 +25,8 @@\n import org.springframework.core.ReactiveAdapter;\n import org.springframework.core.ReactiveAdapterRegistry;\n import org.springframework.core.ResolvableType;\n+import org.springframework.core.annotation.AnnotationUtils;\n+import org.springframework.core.annotation.MergedAnnotations;\n import org.springframework.expression.BeanResolver;\n import org.springframework.expression.Expression;\n import org.springframework.expression.ExpressionParser;\n@@ -99,8 +101,12 @@ public class AuthenticationPrincipalArgumentResolver implements HandlerMethodArg\n \n \tprivate ExpressionParser parser = new SpelExpressionParser();\n \n+\tprivate final Class<AuthenticationPrincipal> annotationType = AuthenticationPrincipal.class;\n+\n \tprivate SecurityAnnotationScanner<AuthenticationPrincipal> scanner = SecurityAnnotationScanners\n-\t\t.requireUnique(AuthenticationPrincipal.class);\n+\t\t.requireUnique(this.annotationType);\n+\n+\tprivate boolean useAnnotationTemplate = false;\n \n \tprivate BeanResolver beanResolver;\n \n@@ -190,6 +196,7 @@ private boolean isInvalidType(MethodParameter parameter, Object principal) {\n \t * @since 6.4\n \t */\n \tpublic void setTemplateDefaults(AnnotationTemplateExpressionDefaults templateDefaults) {\n+\t\tthis.useAnnotationTemplate = templateDefaults != null;\n \t\tthis.scanner = SecurityAnnotationScanners.requireUnique(AuthenticationPrincipal.class, templateDefaults);\n \t}\n \n@@ -199,9 +206,22 @@ public void setTemplateDefaults(AnnotationTemplateExpressionDefaults templateDef\n \t * @param parameter the {@link MethodParameter} to search for an {@link Annotation}\n \t * @return the {@link Annotation} that was found or null.\n \t */\n-\t@SuppressWarnings(\""unchecked\"")\n-\tprivate <T extends Annotation> T findMethodAnnotation(MethodParameter parameter) {\n-\t\treturn (T) this.scanner.scan(parameter.getParameter());\n+\tprivate AuthenticationPrincipal findMethodAnnotation(MethodParameter parameter) {\n+\t\tif (this.useAnnotationTemplate) {\n+\t\t\treturn this.scanner.scan(parameter.getParameter());\n+\t\t}\n+\t\tAuthenticationPrincipal annotation = parameter.getParameterAnnotation(this.annotationType);\n+\t\tif (annotation != null) {\n+\t\t\treturn annotation;\n+\t\t}\n+\t\tAnnotation[] annotationsToSearch = parameter.getParameterAnnotations();\n+\t\tfor (Annotation toSearch : annotationsToSearch) {\n+\t\t\tannotation = AnnotationUtils.findAnnotation(toSearch.annotationType(), this.annotationType);\n+\t\t\tif (annotation != null) {\n+\t\t\t\treturn MergedAnnotations.from(toSearch).get(this.annotationType).synthesize();\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n \t}\n \n }\n\ndiff --git a/messaging/src/main/java/org/springframework/security/messaging/handler/invocation/reactive/CurrentSecurityContextArgumentResolver.java b/messaging/src/main/java/org/springframework/security/messaging/handler/invocation/reactive/CurrentSecurityContextArgumentResolver.java\nindex 62f25fefbb1..f2d7aafa4d6 100644\n--- a/messaging/src/main/java/org/springframework/security/messaging/handler/invocation/reactive/CurrentSecurityContextArgumentResolver.java\n+++ b/messaging/src/main/java/org/springframework/security/messaging/handler/invocation/reactive/CurrentSecurityContextArgumentResolver.java\n@@ -25,6 +25,8 @@\n import org.springframework.core.ReactiveAdapter;\n import org.springframework.core.ReactiveAdapterRegistry;\n import org.springframework.core.ResolvableType;\n+import org.springframework.core.annotation.AnnotationUtils;\n+import org.springframework.core.annotation.MergedAnnotations;\n import org.springframework.expression.BeanResolver;\n import org.springframework.expression.Expression;\n import org.springframework.expression.ExpressionParser;\n@@ -97,8 +99,12 @@ public class CurrentSecurityContextArgumentResolver implements HandlerMethodArgu\n \n \tprivate ExpressionParser parser = new SpelExpressionParser();\n \n+\tprivate final Class<CurrentSecurityContext> annotationType = CurrentSecurityContext.class;\n+\n \tprivate SecurityAnnotationScanner<CurrentSecurityContext> scanner = SecurityAnnotationScanners\n-\t\t.requireUnique(CurrentSecurityContext.class);\n+\t\t.requireUnique(this.annotationType);\n+\n+\tprivate boolean useAnnotationTemplate = false;\n \n \tprivate BeanResolver beanResolver;\n \n@@ -208,6 +214,7 @@ private boolean isInvalidType(MethodParameter parameter, Object value) {\n \t * @since 6.4\n \t */\n \tpublic void setTemplateDefaults(AnnotationTemplateExpressionDefaults templateDefaults) {\n+\t\tthis.useAnnotationTemplate = templateDefaults != null;\n \t\tthis.scanner = SecurityAnnotationScanners.requireUnique(CurrentSecurityContext.class, templateDefaults);\n \t}\n \n@@ -216,9 +223,22 @@ public void setTemplateDefaults(AnnotationTemplateExpressionDefaults templateDef\n \t * @param parameter the {@link MethodParameter} to search for an {@link Annotation}\n \t * @return the {@link Annotation} that was found or null.\n \t */\n-\t@SuppressWarnings(\""unchecked\"")\n-\tprivate <T extends Annotation> T findMethodAnnotation(MethodParameter parameter) {\n-\t\treturn (T) this.scanner.scan(parameter.getParameter());\n+\tprivate CurrentSecurityContext findMethodAnnotation(MethodParameter parameter) {\n+\t\tif (this.useAnnotationTemplate) {\n+\t\t\treturn this.scanner.scan(parameter.getParameter());\n+\t\t}\n+\t\tCurrentSecurityContext annotation = parameter.getParameterAnnotation(this.annotationType);\n+\t\tif (annotation != null) {\n+\t\t\treturn annotation;\n+\t\t}\n+\t\tAnnotation[] annotationsToSearch = parameter.getParameterAnnotations();\n+\t\tfor (Annotation toSearch : annotationsToSearch) {\n+\t\t\tannotation = AnnotationUtils.findAnnotation(toSearch.annotationType(), this.annotationType);\n+\t\t\tif (annotation != null) {\n+\t\t\t\treturn MergedAnnotations.from(toSearch).get(this.annotationType).synthesize();\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n \t}\n \n }\n\ndiff --git a/web/src/main/java/org/springframework/security/web/method/annotation/AuthenticationPrincipalArgumentResolver.java b/web/src/main/java/org/springframework/security/web/method/annotation/AuthenticationPrincipalArgumentResolver.java\nindex 63a660012d7..94471bb3476 100644\n--- a/web/src/main/java/org/springframework/security/web/method/annotation/AuthenticationPrincipalArgumentResolver.java\n+++ b/web/src/main/java/org/springframework/security/web/method/annotation/AuthenticationPrincipalArgumentResolver.java\n@@ -19,6 +19,8 @@\n import java.lang.annotation.Annotation;\n \n import org.springframework.core.MethodParameter;\n+import org.springframework.core.annotation.AnnotationUtils;\n+import org.springframework.core.annotation.MergedAnnotations;\n import org.springframework.expression.BeanResolver;\n import org.springframework.expression.Expression;\n import org.springframework.expression.ExpressionParser;\n@@ -93,6 +95,8 @@\n  */\n public final class AuthenticationPrincipalArgumentResolver implements HandlerMethodArgumentResolver {\n \n+\tprivate final Class<AuthenticationPrincipal> annotationType = AuthenticationPrincipal.class;\n+\n \tprivate SecurityContextHolderStrategy securityContextHolderStrategy = SecurityContextHolder\n \t\t.getContextHolderStrategy();\n \n@@ -101,6 +105,8 @@ public final class AuthenticationPrincipalArgumentResolver implements HandlerMet\n \tprivate SecurityAnnotationScanner<AuthenticationPrincipal> scanner = SecurityAnnotationScanners\n \t\t.requireUnique(AuthenticationPrincipal.class);\n \n+\tprivate boolean useAnnotationTemplate = false;\n+\n \tprivate BeanResolver beanResolver;\n \n \t@Override\n@@ -165,6 +171,7 @@ public void setSecurityContextHolderStrategy(SecurityContextHolderStrategy secur\n \t */\n \tpublic void setTemplateDefaults(AnnotationTemplateExpressionDefaults templateDefaults) {\n \t\tthis.scanner = SecurityAnnotationScanners.requireUnique(AuthenticationPrincipal.class, templateDefaults);\n+\t\tthis.useAnnotationTemplate = templateDefaults != null;\n \t}\n \n \t/**\n@@ -174,8 +181,22 @@ public void setTemplateDefaults(AnnotationTemplateExpressionDefaults templateDef\n \t * @return the {@link Annotation} that was found or null.\n \t */\n \t@SuppressWarnings(\""unchecked\"")\n-\tprivate <T extends Annotation> T findMethodAnnotation(MethodParameter parameter) {\n-\t\treturn (T) this.scanner.scan(parameter.getParameter());\n+\tprivate AuthenticationPrincipal findMethodAnnotation(MethodParameter parameter) {\n+\t\tif (this.useAnnotationTemplate) {\n+\t\t\treturn this.scanner.scan(parameter.getParameter());\n+\t\t}\n+\t\tAuthenticationPrincipal annotation = parameter.getParameterAnnotation(this.annotationType);\n+\t\tif (annotation != null) {\n+\t\t\treturn annotation;\n+\t\t}\n+\t\tAnnotation[] annotationsToSearch = parameter.getParameterAnnotations();\n+\t\tfor (Annotation toSearch : annotationsToSearch) {\n+\t\t\tannotation = AnnotationUtils.findAnnotation(toSearch.annotationType(), this.annotationType);\n+\t\t\tif (annotation != null) {\n+\t\t\t\treturn MergedAnnotations.from(toSearch).get(this.annotationType).synthesize();\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n \t}\n \n }\n\ndiff --git a/web/src/main/java/org/springframework/security/web/method/annotation/CurrentSecurityContextArgumentResolver.java b/web/src/main/java/org/springframework/security/web/method/annotation/CurrentSecurityContextArgumentResolver.java\nindex 600060e78e9..74d68e5d09f 100644\n--- a/web/src/main/java/org/springframework/security/web/method/annotation/CurrentSecurityContextArgumentResolver.java\n+++ b/web/src/main/java/org/springframework/security/web/method/annotation/CurrentSecurityContextArgumentResolver.java\n@@ -19,6 +19,8 @@\n import java.lang.annotation.Annotation;\n \n import org.springframework.core.MethodParameter;\n+import org.springframework.core.annotation.AnnotationUtils;\n+import org.springframework.core.annotation.MergedAnnotations;\n import org.springframework.expression.BeanResolver;\n import org.springframework.expression.Expression;\n import org.springframework.expression.ExpressionParser;\n@@ -84,8 +86,12 @@ public final class CurrentSecurityContextArgumentResolver implements HandlerMeth\n \n \tprivate ExpressionParser parser = new SpelExpressionParser();\n \n+\tprivate final Class<CurrentSecurityContext> annotationType = CurrentSecurityContext.class;\n+\n \tprivate SecurityAnnotationScanner<CurrentSecurityContext> scanner = SecurityAnnotationScanners\n-\t\t.requireUnique(CurrentSecurityContext.class);\n+\t\t.requireUnique(this.annotationType);\n+\n+\tprivate boolean useAnnotationTemplate = false;\n \n \tprivate BeanResolver beanResolver;\n \n@@ -140,6 +146,7 @@ public void setBeanResolver(BeanResolver beanResolver) {\n \t * @since 6.4\n \t */\n \tpublic void setTemplateDefaults(AnnotationTemplateExpressionDefaults templateDefaults) {\n+\t\tthis.useAnnotationTemplate = templateDefaults != null;\n \t\tthis.scanner = SecurityAnnotationScanners.requireUnique(CurrentSecurityContext.class, templateDefaults);\n \t}\n \n@@ -171,9 +178,22 @@ private Object resolveSecurityContextFromAnnotation(MethodParameter parameter, C\n \t * @param parameter the {@link MethodParameter} to search for an {@link Annotation}\n \t * @return the {@link Annotation} that was found or null.\n \t */\n-\t@SuppressWarnings(\""unchecked\"")\n-\tprivate <T extends Annotation> T findMethodAnnotation(MethodParameter parameter) {\n-\t\treturn (T) this.scanner.scan(parameter.getParameter());\n+\tprivate CurrentSecurityContext findMethodAnnotation(MethodParameter parameter) {\n+\t\tif (this.useAnnotationTemplate) {\n+\t\t\treturn this.scanner.scan(parameter.getParameter());\n+\t\t}\n+\t\tCurrentSecurityContext annotation = parameter.getParameterAnnotation(this.annotationType);\n+\t\tif (annotation != null) {\n+\t\t\treturn annotation;\n+\t\t}\n+\t\tAnnotation[] annotationsToSearch = parameter.getParameterAnnotations();\n+\t\tfor (Annotation toSearch : annotationsToSearch) {\n+\t\t\tannotation = AnnotationUtils.findAnnotation(toSearch.annotationType(), this.annotationType);\n+\t\t\tif (annotation != null) {\n+\t\t\t\treturn MergedAnnotations.from(toSearch).get(this.annotationType).synthesize();\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n \t}\n \n }\n\ndiff --git a/web/src/main/java/org/springframework/security/web/reactive/result/method/annotation/AuthenticationPrincipalArgumentResolver.java b/web/src/main/java/org/springframework/security/web/reactive/result/method/annotation/AuthenticationPrincipalArgumentResolver.java\nindex aae0b46be22..31faf325a65 100644\n--- a/web/src/main/java/org/springframework/security/web/reactive/result/method/annotation/AuthenticationPrincipalArgumentResolver.java\n+++ b/web/src/main/java/org/springframework/security/web/reactive/result/method/annotation/AuthenticationPrincipalArgumentResolver.java\n@@ -25,6 +25,8 @@\n import org.springframework.core.ReactiveAdapter;\n import org.springframework.core.ReactiveAdapterRegistry;\n import org.springframework.core.ResolvableType;\n+import org.springframework.core.annotation.AnnotationUtils;\n+import org.springframework.core.annotation.MergedAnnotations;\n import org.springframework.expression.BeanResolver;\n import org.springframework.expression.Expression;\n import org.springframework.expression.ExpressionParser;\n@@ -53,8 +55,12 @@ public class AuthenticationPrincipalArgumentResolver extends HandlerMethodArgume\n \n \tprivate ExpressionParser parser = new SpelExpressionParser();\n \n+\tprivate final Class<AuthenticationPrincipal> annotationType = AuthenticationPrincipal.class;\n+\n \tprivate SecurityAnnotationScanner<AuthenticationPrincipal> scanner = SecurityAnnotationScanners\n-\t\t.requireUnique(AuthenticationPrincipal.class);\n+\t\t.requireUnique(this.annotationType);\n+\n+\tprivate boolean useAnnotationTemplate = false;\n \n \tprivate BeanResolver beanResolver;\n \n@@ -134,6 +140,7 @@ private boolean isInvalidType(MethodParameter parameter, Object principal) {\n \t * @since 6.4\n \t */\n \tpublic void setTemplateDefaults(AnnotationTemplateExpressionDefaults templateDefaults) {\n+\t\tthis.useAnnotationTemplate = templateDefaults != null;\n \t\tthis.scanner = SecurityAnnotationScanners.requireUnique(AuthenticationPrincipal.class, templateDefaults);\n \t}\n \n@@ -143,9 +150,22 @@ public void setTemplateDefaults(AnnotationTemplateExpressionDefaults templateDef\n \t * @param parameter the {@link MethodParameter} to search for an {@link Annotation}\n \t * @return the {@link Annotation} that was found or null.\n \t */\n-\t@SuppressWarnings(\""unchecked\"")\n-\tprivate <T extends Annotation> T findMethodAnnotation(MethodParameter parameter) {\n-\t\treturn (T) this.scanner.scan(parameter.getParameter());\n+\tprivate AuthenticationPrincipal findMethodAnnotation(MethodParameter parameter) {\n+\t\tif (this.useAnnotationTemplate) {\n+\t\t\treturn this.scanner.scan(parameter.getParameter());\n+\t\t}\n+\t\tAuthenticationPrincipal annotation = parameter.getParameterAnnotation(this.annotationType);\n+\t\tif (annotation != null) {\n+\t\t\treturn annotation;\n+\t\t}\n+\t\tAnnotation[] annotationsToSearch = parameter.getParameterAnnotations();\n+\t\tfor (Annotation toSearch : annotationsToSearch) {\n+\t\t\tannotation = AnnotationUtils.findAnnotation(toSearch.annotationType(), this.annotationType);\n+\t\t\tif (annotation != null) {\n+\t\t\t\treturn MergedAnnotations.from(toSearch).get(this.annotationType).synthesize();\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n \t}\n \n }\n\ndiff --git a/web/src/main/java/org/springframework/security/web/reactive/result/method/annotation/CurrentSecurityContextArgumentResolver.java b/web/src/main/java/org/springframework/security/web/reactive/result/method/annotation/CurrentSecurityContextArgumentResolver.java\nindex 8fd7c724755..c7107cc150d 100644\n--- a/web/src/main/java/org/springframework/security/web/reactive/result/method/annotation/CurrentSecurityContextArgumentResolver.java\n+++ b/web/src/main/java/org/springframework/security/web/reactive/result/method/annotation/CurrentSecurityContextArgumentResolver.java\n@@ -25,6 +25,8 @@\n import org.springframework.core.ReactiveAdapter;\n import org.springframework.core.ReactiveAdapterRegistry;\n import org.springframework.core.ResolvableType;\n+import org.springframework.core.annotation.AnnotationUtils;\n+import org.springframework.core.annotation.MergedAnnotations;\n import org.springframework.expression.BeanResolver;\n import org.springframework.expression.Expression;\n import org.springframework.expression.ExpressionParser;\n@@ -53,8 +55,12 @@ public class CurrentSecurityContextArgumentResolver extends HandlerMethodArgumen\n \n \tprivate ExpressionParser parser = new SpelExpressionParser();\n \n+\tprivate final Class<CurrentSecurityContext> annotationType = CurrentSecurityContext.class;\n+\n \tprivate SecurityAnnotationScanner<CurrentSecurityContext> scanner = SecurityAnnotationScanners\n-\t\t.requireUnique(CurrentSecurityContext.class);\n+\t\t.requireUnique(this.annotationType);\n+\n+\tprivate boolean useAnnotationTemplate = false;\n \n \tprivate BeanResolver beanResolver;\n \n@@ -81,6 +87,7 @@ public void setBeanResolver(BeanResolver beanResolver) {\n \t * @since 6.4\n \t */\n \tpublic void setTemplateDefaults(AnnotationTemplateExpressionDefaults templateDefaults) {\n+\t\tthis.useAnnotationTemplate = templateDefaults != null;\n \t\tthis.scanner = SecurityAnnotationScanners.requireUnique(CurrentSecurityContext.class, templateDefaults);\n \t}\n \n@@ -183,9 +190,22 @@ private boolean isInvalidType(MethodParameter parameter, Object reactiveSecurity\n \t * @param parameter the {@link MethodParameter} to search for an {@link Annotation}\n \t * @return the {@link Annotation} that was found or null.\n \t */\n-\t@SuppressWarnings(\""unchecked\"")\n-\tprivate <T extends Annotation> T findMethodAnnotation(MethodParameter parameter) {\n-\t\treturn (T) this.scanner.scan(parameter.getParameter());\n+\tprivate CurrentSecurityContext findMethodAnnotation(MethodParameter parameter) {\n+\t\tif (this.useAnnotationTemplate) {\n+\t\t\treturn this.scanner.scan(parameter.getParameter());\n+\t\t}\n+\t\tCurrentSecurityContext annotation = parameter.getParameterAnnotation(this.annotationType);\n+\t\tif (annotation != null) {\n+\t\t\treturn annotation;\n+\t\t}\n+\t\tAnnotation[] annotationsToSearch = parameter.getParameterAnnotations();\n+\t\tfor (Annotation toSearch : annotationsToSearch) {\n+\t\t\tannotation = AnnotationUtils.findAnnotation(toSearch.annotationType(), this.annotationType);\n+\t\t\tif (annotation != null) {\n+\t\t\t\treturn MergedAnnotations.from(toSearch).get(this.annotationType).synthesize();\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n \t}\n \n }\n"", ""test_patch"": ""diff --git a/config/src/test/java/org/springframework/security/config/annotation/web/reactive/EnableWebFluxSecurityTests.java b/config/src/test/java/org/springframework/security/config/annotation/web/reactive/EnableWebFluxSecurityTests.java\nindex 890af2bfa07..a2c0a7de2ff 100644\n--- a/config/src/test/java/org/springframework/security/config/annotation/web/reactive/EnableWebFluxSecurityTests.java\n+++ b/config/src/test/java/org/springframework/security/config/annotation/web/reactive/EnableWebFluxSecurityTests.java\n@@ -16,6 +16,10 @@\n \n package org.springframework.security.config.annotation.web.reactive;\n \n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n import java.nio.charset.StandardCharsets;\n \n import org.junit.jupiter.api.Test;\n@@ -28,6 +32,7 @@\n import org.springframework.context.annotation.Configuration;\n import org.springframework.context.annotation.Import;\n import org.springframework.core.Ordered;\n+import org.springframework.core.annotation.AliasFor;\n import org.springframework.core.annotation.Order;\n import org.springframework.core.io.buffer.DataBuffer;\n import org.springframework.core.io.buffer.DefaultDataBufferFactory;\n@@ -404,11 +409,28 @@ public String username(UserDetails user) {\n \n \t\t}\n \n+\t\t@Target({ ElementType.PARAMETER })\n+\t\t@Retention(RetentionPolicy.RUNTIME)\n+\t\t@AuthenticationPrincipal\n+\t\t@interface Property {\n+\n+\t\t\t@AliasFor(attribute = \""expression\"", annotation = AuthenticationPrincipal.class)\n+\t\t\tString value() default \""id\"";\n+\n+\t\t}\n+\n+\t\tinterface UsernameResolver {\n+\n+\t\t\tString username(@Property(\""@principalBean.username(#this)\"") String username);\n+\n+\t\t}\n+\n \t\t@RestController\n-\t\tstatic class AuthenticationPrincipalResolver {\n+\t\tstatic class AuthenticationPrincipalResolver implements UsernameResolver {\n \n+\t\t\t@Override\n \t\t\t@GetMapping(\""/spel\"")\n-\t\t\tString username(@AuthenticationPrincipal(expression = \""@principalBean.username(#this)\"") String username) {\n+\t\t\tpublic String username(String username) {\n \t\t\t\treturn username;\n \t\t\t}\n \n\ndiff --git a/messaging/src/test/java/org/springframework/security/messaging/context/AuthenticationPrincipalArgumentResolverTests.java b/messaging/src/test/java/org/springframework/security/messaging/context/AuthenticationPrincipalArgumentResolverTests.java\nindex 0074657e222..a2b7a0603e1 100644\n--- a/messaging/src/test/java/org/springframework/security/messaging/context/AuthenticationPrincipalArgumentResolverTests.java\n+++ b/messaging/src/test/java/org/springframework/security/messaging/context/AuthenticationPrincipalArgumentResolverTests.java\n@@ -28,6 +28,7 @@\n \n import org.springframework.core.MethodParameter;\n import org.springframework.core.annotation.AliasFor;\n+import org.springframework.core.annotation.AnnotatedMethod;\n import org.springframework.security.authentication.TestingAuthenticationToken;\n import org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults;\n import org.springframework.security.core.annotation.AuthenticationPrincipal;\n@@ -186,10 +187,21 @@ public void resolveArgumentCustomMetaAnnotationTpl() throws Exception {\n \t\tassertThat(this.resolver.resolveArgument(showUserCustomMetaAnnotationTpl(), null)).isEqualTo(principal.id);\n \t}\n \n+\t@Test\n+\tpublic void resolveArgumentWhenAliasForOnInterfaceThenInherits() {\n+\t\tCustomUserPrincipal principal = new CustomUserPrincipal();\n+\t\tsetAuthenticationPrincipal(principal);\n+\t\tassertThat(this.resolver.resolveArgument(showUserNoConcreteAnnotation(), null)).isEqualTo(principal.property);\n+\t}\n+\n \tprivate MethodParameter showUserNoAnnotation() {\n \t\treturn getMethodParameter(\""showUserNoAnnotation\"", String.class);\n \t}\n \n+\tprivate MethodParameter showUserNoConcreteAnnotation() {\n+\t\treturn getMethodParameter(\""showUserNoConcreteAnnotation\"", String.class);\n+\t}\n+\n \tprivate MethodParameter showUserAnnotationString() {\n \t\treturn getMethodParameter(\""showUserAnnotation\"", String.class);\n \t}\n@@ -240,7 +252,7 @@ private MethodParameter showUserAnnotationObject() {\n \n \tprivate MethodParameter getMethodParameter(String methodName, Class<?>... paramTypes) {\n \t\tMethod method = ReflectionUtils.findMethod(TestController.class, methodName, paramTypes);\n-\t\treturn new MethodParameter(method, 0);\n+\t\treturn new AnnotatedMethod(method).getMethodParameters()[0];\n \t}\n \n \tprivate void setAuthenticationPrincipal(Object principal) {\n@@ -280,11 +292,32 @@ private void setAuthenticationPrincipal(Object principal) {\n \n \t}\n \n-\tpublic static class TestController {\n+\t@Target({ ElementType.PARAMETER })\n+\t@Retention(RetentionPolicy.RUNTIME)\n+\t@AuthenticationPrincipal\n+\t@interface Property {\n+\n+\t\t@AliasFor(attribute = \""expression\"", annotation = AuthenticationPrincipal.class)\n+\t\tString value() default \""id\"";\n+\n+\t}\n+\n+\tprivate interface TestInterface {\n+\n+\t\tvoid showUserNoConcreteAnnotation(@Property(\""property\"") String property);\n+\n+\t}\n+\n+\tpublic static class TestController implements TestInterface {\n \n \t\tpublic void showUserNoAnnotation(String user) {\n \t\t}\n \n+\t\t@Override\n+\t\tpublic void showUserNoConcreteAnnotation(String user) {\n+\n+\t\t}\n+\n \t\tpublic void showUserAnnotation(@AuthenticationPrincipal String user) {\n \t\t}\n \n\ndiff --git a/messaging/src/test/java/org/springframework/security/messaging/handler/invocation/reactive/AuthenticationPrincipalArgumentResolverTests.java b/messaging/src/test/java/org/springframework/security/messaging/handler/invocation/reactive/AuthenticationPrincipalArgumentResolverTests.java\nindex 67c77123b86..3d1b6440367 100644\n--- a/messaging/src/test/java/org/springframework/security/messaging/handler/invocation/reactive/AuthenticationPrincipalArgumentResolverTests.java\n+++ b/messaging/src/test/java/org/springframework/security/messaging/handler/invocation/reactive/AuthenticationPrincipalArgumentResolverTests.java\n@@ -16,14 +16,17 @@\n \n package org.springframework.security.messaging.handler.invocation.reactive;\n \n+import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n \n import org.junit.jupiter.api.Test;\n import reactor.core.publisher.Mono;\n \n import org.springframework.core.MethodParameter;\n import org.springframework.core.annotation.AliasFor;\n+import org.springframework.core.annotation.AnnotatedMethod;\n import org.springframework.core.annotation.SynthesizingMethodParameter;\n import org.springframework.security.authentication.TestAuthentication;\n import org.springframework.security.authentication.TestingAuthenticationToken;\n@@ -128,6 +131,19 @@ public void supportsParameterWhenNotAnnotatedThenFalse() {\n \t\tassertThat(this.resolver.supportsParameter(arg0(\""monoUserDetails\""))).isFalse();\n \t}\n \n+\t@Test\n+\tpublic void resolveArgumentWhenAliasForOnInterfaceThenInherits() {\n+\t\tCustomUserPrincipal principal = new CustomUserPrincipal();\n+\t\tAuthentication authentication = new TestingAuthenticationToken(principal, \""password\"", \""ROLE_USER\"");\n+\t\tResolvableMethod method = ResolvableMethod.on(TestController.class)\n+\t\t\t.named(\""showUserNoConcreteAnnotation\"")\n+\t\t\t.method();\n+\t\tMethodParameter parameter = new AnnotatedMethod(method.method()).getMethodParameters()[0];\n+\t\tMono<Object> result = this.resolver.resolveArgument(parameter, null)\n+\t\t\t.contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication));\n+\t\tassertThat(result.block()).isEqualTo(principal.property);\n+\t}\n+\n \t@SuppressWarnings(\""unused\"")\n \tprivate void monoUserDetails(Mono<UserDetails> user) {\n \t}\n@@ -172,6 +188,8 @@ static class CustomUserPrincipal {\n \n \t\tpublic final int id = 1;\n \n+\t\tpublic final String property = \""property\"";\n+\n \t\tpublic Object getPrincipal() {\n \t\t\treturn this;\n \t\t}\n@@ -195,4 +213,29 @@ public Object getPrincipal() {\n \n \t}\n \n+\t@Target({ ElementType.PARAMETER })\n+\t@Retention(RetentionPolicy.RUNTIME)\n+\t@AuthenticationPrincipal\n+\t@interface Property {\n+\n+\t\t@AliasFor(attribute = \""expression\"", annotation = AuthenticationPrincipal.class)\n+\t\tString value() default \""id\"";\n+\n+\t}\n+\n+\tprivate interface TestInterface {\n+\n+\t\tvoid showUserNoConcreteAnnotation(@Property(\""property\"") String property);\n+\n+\t}\n+\n+\tprivate static class TestController implements TestInterface {\n+\n+\t\t@Override\n+\t\tpublic void showUserNoConcreteAnnotation(String user) {\n+\n+\t\t}\n+\n+\t}\n+\n }\n\ndiff --git a/web/src/test/java/org/springframework/security/web/method/annotation/AuthenticationPrincipalArgumentResolverTests.java b/web/src/test/java/org/springframework/security/web/method/annotation/AuthenticationPrincipalArgumentResolverTests.java\nindex eda4249315b..fcc1e05088c 100644\n--- a/web/src/test/java/org/springframework/security/web/method/annotation/AuthenticationPrincipalArgumentResolverTests.java\n+++ b/web/src/test/java/org/springframework/security/web/method/annotation/AuthenticationPrincipalArgumentResolverTests.java\n@@ -28,6 +28,7 @@\n \n import org.springframework.core.MethodParameter;\n import org.springframework.core.annotation.AliasFor;\n+import org.springframework.core.annotation.AnnotatedMethod;\n import org.springframework.expression.BeanResolver;\n import org.springframework.security.authentication.TestingAuthenticationToken;\n import org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults;\n@@ -214,10 +215,22 @@ public void resolveArgumentCustomMetaAnnotationTpl() throws Exception {\n \t\t\t.isEqualTo(this.expectedPrincipal);\n \t}\n \n+\t@Test\n+\tpublic void resolveArgumentWhenAliasForOnInterfaceThenInherits() throws Exception {\n+\t\tCustomUserPrincipal principal = new CustomUserPrincipal();\n+\t\tsetAuthenticationPrincipal(principal);\n+\t\tassertThat(this.resolver.resolveArgument(showUserNoConcreteAnnotation(), null, null, null))\n+\t\t\t.isEqualTo(principal.property);\n+\t}\n+\n \tprivate MethodParameter showUserNoAnnotation() {\n \t\treturn getMethodParameter(\""showUserNoAnnotation\"", String.class);\n \t}\n \n+\tprivate MethodParameter showUserNoConcreteAnnotation() {\n+\t\treturn getMethodParameter(\""showUserNoConcreteAnnotation\"", String.class);\n+\t}\n+\n \tprivate MethodParameter showUserAnnotationString() {\n \t\treturn getMethodParameter(\""showUserAnnotation\"", String.class);\n \t}\n@@ -272,7 +285,7 @@ private MethodParameter showUserCustomMetaAnnotationTpl() {\n \n \tprivate MethodParameter getMethodParameter(String methodName, Class<?>... paramTypes) {\n \t\tMethod method = ReflectionUtils.findMethod(TestController.class, methodName, paramTypes);\n-\t\treturn new MethodParameter(method, 0);\n+\t\treturn new AnnotatedMethod(method).getMethodParameters()[0];\n \t}\n \n \tprivate void setAuthenticationPrincipal(Object principal) {\n@@ -295,6 +308,16 @@ private void setAuthenticationPrincipal(Object principal) {\n \n \t}\n \n+\t@Target({ ElementType.PARAMETER })\n+\t@Retention(RetentionPolicy.RUNTIME)\n+\t@AuthenticationPrincipal\n+\t@interface Property {\n+\n+\t\t@AliasFor(attribute = \""expression\"", annotation = AuthenticationPrincipal.class)\n+\t\tString value() default \""id\"";\n+\n+\t}\n+\n \t@Retention(RetentionPolicy.RUNTIME)\n \t@AuthenticationPrincipal\n \tpublic @interface CurrentUser2 {\n@@ -312,11 +335,22 @@ private void setAuthenticationPrincipal(Object principal) {\n \n \t}\n \n-\tpublic static class TestController {\n+\tpublic interface TestInterface {\n+\n+\t\tvoid showUserNoConcreteAnnotation(@Property(\""property\"") String property);\n+\n+\t}\n+\n+\tpublic static class TestController implements TestInterface {\n \n \t\tpublic void showUserNoAnnotation(String user) {\n \t\t}\n \n+\t\t@Override\n+\t\tpublic void showUserNoConcreteAnnotation(String user) {\n+\n+\t\t}\n+\n \t\tpublic void showUserAnnotation(@AuthenticationPrincipal String user) {\n \t\t}\n \n\ndiff --git a/web/src/test/java/org/springframework/security/web/reactive/result/method/annotation/AuthenticationPrincipalArgumentResolverTests.java b/web/src/test/java/org/springframework/security/web/reactive/result/method/annotation/AuthenticationPrincipalArgumentResolverTests.java\nindex 507175a9df9..63d6deea0aa 100644\n--- a/web/src/test/java/org/springframework/security/web/reactive/result/method/annotation/AuthenticationPrincipalArgumentResolverTests.java\n+++ b/web/src/test/java/org/springframework/security/web/reactive/result/method/annotation/AuthenticationPrincipalArgumentResolverTests.java\n@@ -32,6 +32,7 @@\n import org.springframework.core.MethodParameter;\n import org.springframework.core.ReactiveAdapterRegistry;\n import org.springframework.core.annotation.AliasFor;\n+import org.springframework.core.annotation.AnnotatedMethod;\n import org.springframework.core.annotation.SynthesizingMethodParameter;\n import org.springframework.expression.BeanResolver;\n import org.springframework.security.core.Authentication;\n@@ -230,6 +231,19 @@ public void resolveArgumentCustomMetaAnnotationTpl() {\n \t\tassertThat(result.block()).isEqualTo(principal.id);\n \t}\n \n+\t@Test\n+\tpublic void resolveArgumentWhenAliasForOnInterfaceThenInherits() {\n+\t\tCustomUserPrincipal principal = new CustomUserPrincipal();\n+\t\tgiven(this.authentication.getPrincipal()).willReturn(principal);\n+\t\tResolvableMethod method = ResolvableMethod.on(TestController.class)\n+\t\t\t.named(\""showUserNoConcreteAnnotation\"")\n+\t\t\t.build();\n+\t\tMethodParameter parameter = new AnnotatedMethod(method.method()).getMethodParameters()[0];\n+\t\tMono<Object> result = this.resolver.resolveArgument(parameter, this.bindingContext, this.exchange)\n+\t\t\t.contextWrite(ReactiveSecurityContextHolder.withAuthentication(this.authentication));\n+\t\tassertThat(result.block()).isEqualTo(principal.property);\n+\t}\n+\n \tprivate MethodParameter arg0(String methodName) {\n \t\tResolvableMethod method = ResolvableMethod.on(getClass()).named(methodName).build();\n \t\treturn new SynthesizingMethodParameter(method.method(), 0);\n@@ -317,6 +331,8 @@ static class CustomUserPrincipal {\n \n \t\tpublic final int id = 1;\n \n+\t\tpublic final String property = \""property\"";\n+\n \t\tpublic Object getPrincipal() {\n \t\t\treturn this;\n \t\t}\n@@ -340,4 +356,29 @@ public Object getPrincipal() {\n \n \t}\n \n+\t@Target({ ElementType.PARAMETER })\n+\t@Retention(RetentionPolicy.RUNTIME)\n+\t@AuthenticationPrincipal\n+\t@interface Property {\n+\n+\t\t@AliasFor(attribute = \""expression\"", annotation = AuthenticationPrincipal.class)\n+\t\tString value() default \""id\"";\n+\n+\t}\n+\n+\tprivate interface TestInterface {\n+\n+\t\tvoid showUserNoConcreteAnnotation(@Property(\""property\"") String property);\n+\n+\t}\n+\n+\tprivate static class TestController implements TestInterface {\n+\n+\t\t@Override\n+\t\tpublic void showUserNoConcreteAnnotation(String user) {\n+\n+\t\t}\n+\n+\t}\n+\n }\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""spring-projects__spring-security-15853"", ""pr_id"": 15853, ""issue_id"": 15852, ""repo"": ""spring-projects/spring-security"", ""problem_statement"": ""JwtDecoderProviderConfigurationUtils incorrectly handles issuer URI\n**Describe the bug**\r\n`JwtDecoderProviderConfigurationUtils` use `UriComponentsBuilder` to modify a `URI` in `oidc`, `oidcRfc8414` and `oauth`.\r\nDue to a known issue in UriComponents builder (https://github.com/spring-projects/spring-framework/issues/27774), this produces invalid URIs in the cases where the URI contains an `authority`, but no `host`.\r\nThese still come up in practice though, e.g. see the following partial backtrace:\r\n\r\n```\r\nCaused by: java.lang.IllegalArgumentException: Unable to resolve the Configuration with the provided Issuer of \""http://elated_sutherland:8080/auth/realms/my-realm\""\r\n        at org.springframework.security.oauth2.jwt.JwtDecoderProviderConfigurationUtils.getConfiguration(JwtDecoderProviderConfigurationUtils.java:178)\r\n        at org.springframework.security.oauth2.jwt.JwtDecoderProviderConfigurationUtils.getConfigurationForIssuerLocation(JwtDecoderProviderConfigurationUtils.java:90)\r\n        at org.springframework.security.oauth2.jwt.NimbusJwtDecoder.lambda$withIssuerLocation$2(NimbusJwtDecoder.java:226)\r\n        at org.springframework.security.oauth2.jwt.NimbusJwtDecoder$JwkSetUriJwtDecoderBuilder.processor(NimbusJwtDecoder.java:389)\r\n        at org.springframework.security.oauth2.jwt.NimbusJwtDecoder$JwkSetUriJwtDecoderBuilder.build(NimbusJwtDecoder.java:405)\r\n        at org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerJwtConfiguration$JwtDecoderConfiguration.lambda$jwtDecoderByIssuerUri$3(OAuth2ResourceServerJwtConfiguration.java:159)\r\n        at org.springframework.security.oauth2.jwt.SupplierJwtDecoder.lambda$new$0(SupplierJwtDecoder.java:36)\r\n        ... 88 common frames omitted\r\nCaused by: org.springframework.web.client.ResourceAccessException: I/O error on GET request for \""http:/auth/realms/my-realm/.well-known/openid-configuration\"": Failed to select a proxy\r\n        at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:915)\r\n        at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:895)\r\n        at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:740)\r\n        at org.springframework.security.oauth2.jwt.JwtDecoderProviderConfigurationUtils.getConfiguration(JwtDecoderProviderConfigurationUtils.java:167)\r\n        ... 94 common frames omitted\r\n```\r\n\r\n**To Reproduce**\r\n```java\r\nimport org.springframework.web.util.UriComponentsBuilder;\r\n\r\nimport java.net.URI;\r\nimport java.util.Collections;\r\n\r\nString rawUrl = \""http://elated_sutherland:8080/auth/realms/my-realm\"";\r\nURI uri = URI.create(rawUrl);\r\nSystem.out.println(uri.getAuthority());\r\nSystem.out.println(uri.getHost());\r\nURI newUrl = UriComponentsBuilder.fromUri(uri)\r\n  .replacePath(uri.getPath() + \""/.well-known/openid-configuration\"")\r\n  .build(Collections.emptyMap());\r\nSystem.out.println(newUrl);\r\n```\r\n\r\nshows what happens. It outputs:\r\n```\r\nelated_sutherland:8080\r\nnull\r\nhttp:/auth/realms/my-realm/.well-known/openid-configuration\r\n```\r\n\r\n**Expected behavior**\r\nThe correct oidc URI should be generated: `http://elated_sutherland:8080/auth/realms/my-realm/.well-known/openid-configuration`."", ""issue_word_count"": 352, ""test_files_count"": 3, ""non_test_files_count"": 3, ""pr_changed_files"": [""oauth2/oauth2-client/src/main/java/org/springframework/security/oauth2/client/registration/ClientRegistrations.java"", ""oauth2/oauth2-client/src/test/java/org/springframework/security/oauth2/client/registration/ClientRegistrationsTests.java"", ""oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/JwtDecoderProviderConfigurationUtils.java"", ""oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/ReactiveJwtDecoderProviderConfigurationUtils.java"", ""oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/JwtDecoderProviderConfigurationUtilsTests.java"", ""oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/ReactiveJwtDecoderProviderConfigurationUtilsTests.java""], ""pr_changed_test_files"": [""oauth2/oauth2-client/src/test/java/org/springframework/security/oauth2/client/registration/ClientRegistrationsTests.java"", ""oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/JwtDecoderProviderConfigurationUtilsTests.java"", ""oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/ReactiveJwtDecoderProviderConfigurationUtilsTests.java""], ""base_commit"": ""43ddf73ddbba2ca7f331bfa4f60afe495b5d4ddd"", ""head_commit"": ""49e5d3796e019d8ba03c68481e7c1a4327cad751"", ""repo_url"": ""https://github.com/spring-projects/spring-security/pull/15853"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/spring-projects__spring-security/15853"", ""dockerfile"": """", ""pr_merged_at"": ""2025-02-20T23:54:24.000Z"", ""patch"": ""diff --git a/oauth2/oauth2-client/src/main/java/org/springframework/security/oauth2/client/registration/ClientRegistrations.java b/oauth2/oauth2-client/src/main/java/org/springframework/security/oauth2/client/registration/ClientRegistrations.java\nindex 91517d640a5..54efef5107d 100644\n--- a/oauth2/oauth2-client/src/main/java/org/springframework/security/oauth2/client/registration/ClientRegistrations.java\n+++ b/oauth2/oauth2-client/src/main/java/org/springframework/security/oauth2/client/registration/ClientRegistrations.java\n@@ -17,7 +17,6 @@\n package org.springframework.security.oauth2.client.registration;\n \n import java.net.URI;\n-import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -37,6 +36,7 @@\n import org.springframework.util.Assert;\n import org.springframework.web.client.HttpClientErrorException;\n import org.springframework.web.client.RestTemplate;\n+import org.springframework.web.util.UriComponents;\n import org.springframework.web.util.UriComponentsBuilder;\n \n /**\n@@ -145,7 +145,7 @@ public static ClientRegistration.Builder fromOidcConfiguration(Map<String, Objec\n \t */\n \tpublic static ClientRegistration.Builder fromOidcIssuerLocation(String issuer) {\n \t\tAssert.hasText(issuer, \""issuer cannot be empty\"");\n-\t\treturn getBuilder(issuer, oidc(URI.create(issuer)));\n+\t\treturn getBuilder(issuer, oidc(issuer));\n \t}\n \n \t/**\n@@ -188,21 +188,17 @@ public static ClientRegistration.Builder fromOidcIssuerLocation(String issuer) {\n \t */\n \tpublic static ClientRegistration.Builder fromIssuerLocation(String issuer) {\n \t\tAssert.hasText(issuer, \""issuer cannot be empty\"");\n-\t\tURI uri = URI.create(issuer);\n-\t\treturn getBuilder(issuer, oidc(uri), oidcRfc8414(uri), oauth(uri));\n+\t\treturn getBuilder(issuer, oidc(issuer), oidcRfc8414(issuer), oauth(issuer));\n \t}\n \n-\tprivate static Supplier<ClientRegistration.Builder> oidc(URI issuer) {\n-\t\t// @formatter:off\n-\t\tURI uri = UriComponentsBuilder.fromUri(issuer)\n-\t\t\t\t.replacePath(issuer.getPath() + OIDC_METADATA_PATH)\n-\t\t\t\t.build(Collections.emptyMap());\n+\tstatic Supplier<ClientRegistration.Builder> oidc(String issuer) {\n+\t\tUriComponents uri = oidcUri(issuer);\n \t\t// @formatter:on\n \t\treturn () -> {\n-\t\t\tRequestEntity<Void> request = RequestEntity.get(uri).build();\n+\t\t\tRequestEntity<Void> request = RequestEntity.get(uri.toUriString()).build();\n \t\t\tMap<String, Object> configuration = rest.exchange(request, typeReference).getBody();\n \t\t\tOIDCProviderMetadata metadata = parse(configuration, OIDCProviderMetadata::parse);\n-\t\t\tClientRegistration.Builder builder = withProviderConfiguration(metadata, issuer.toASCIIString())\n+\t\t\tClientRegistration.Builder builder = withProviderConfiguration(metadata, issuer)\n \t\t\t\t.jwkSetUri(metadata.getJWKSetURI().toASCIIString());\n \t\t\tif (metadata.getUserInfoEndpointURI() != null) {\n \t\t\t\tbuilder.userInfoUri(metadata.getUserInfoEndpointURI().toASCIIString());\n@@ -211,30 +207,48 @@ private static Supplier<ClientRegistration.Builder> oidc(URI issuer) {\n \t\t};\n \t}\n \n-\tprivate static Supplier<ClientRegistration.Builder> oidcRfc8414(URI issuer) {\n+\tstatic UriComponents oidcUri(String issuer) {\n+\t\tUriComponents uri = UriComponentsBuilder.fromUriString(issuer).build();\n \t\t// @formatter:off\n-\t\tURI uri = UriComponentsBuilder.fromUri(issuer)\n-\t\t\t\t.replacePath(OIDC_METADATA_PATH + issuer.getPath())\n-\t\t\t\t.build(Collections.emptyMap());\n+\t\treturn UriComponentsBuilder.newInstance().uriComponents(uri)\n+\t\t\t\t.replacePath(uri.getPath() + OIDC_METADATA_PATH)\n+\t\t\t\t.build();\n+\t}\n+\n+\tstatic Supplier<ClientRegistration.Builder> oidcRfc8414(String issuer) {\n+\t\tUriComponents uri = oidcRfc8414Uri(issuer);\n \t\t// @formatter:on\n \t\treturn getRfc8414Builder(issuer, uri);\n \t}\n \n-\tprivate static Supplier<ClientRegistration.Builder> oauth(URI issuer) {\n+\tstatic UriComponents oidcRfc8414Uri(String issuer) {\n+\t\tUriComponents uri = UriComponentsBuilder.fromUriString(issuer).build();\n \t\t// @formatter:off\n-\t\tURI uri = UriComponentsBuilder.fromUri(issuer)\n-\t\t\t\t.replacePath(OAUTH_METADATA_PATH + issuer.getPath())\n-\t\t\t\t.build(Collections.emptyMap());\n-\t\t// @formatter:on\n+\t\treturn UriComponentsBuilder.newInstance().uriComponents(uri)\n+\t\t\t\t.replacePath(OIDC_METADATA_PATH + uri.getPath())\n+\t\t\t\t.build();\n+\t}\n+\n+\tstatic Supplier<ClientRegistration.Builder> oauth(String issuer) {\n+\t\tUriComponents uri = oauthUri(issuer);\n \t\treturn getRfc8414Builder(issuer, uri);\n \t}\n \n-\tprivate static Supplier<ClientRegistration.Builder> getRfc8414Builder(URI issuer, URI uri) {\n+\tstatic UriComponents oauthUri(String issuer) {\n+\t\tUriComponents uri = UriComponentsBuilder.fromUriString(issuer).build();\n+\t\t// @formatter:off\n+\t\treturn UriComponentsBuilder.newInstance().uriComponents(uri)\n+\t\t\t\t.replacePath(OAUTH_METADATA_PATH + uri.getPath())\n+\t\t\t\t.build();\n+\t\t// @formatter:on\n+\t}\n+\n+\tprivate static Supplier<ClientRegistration.Builder> getRfc8414Builder(String issuer, UriComponents uri) {\n \t\treturn () -> {\n-\t\t\tRequestEntity<Void> request = RequestEntity.get(uri).build();\n+\t\t\tRequestEntity<Void> request = RequestEntity.get(uri.toUriString()).build();\n \t\t\tMap<String, Object> configuration = rest.exchange(request, typeReference).getBody();\n \t\t\tAuthorizationServerMetadata metadata = parse(configuration, AuthorizationServerMetadata::parse);\n-\t\t\tClientRegistration.Builder builder = withProviderConfiguration(metadata, issuer.toASCIIString());\n+\t\t\tClientRegistration.Builder builder = withProviderConfiguration(metadata, issuer);\n \t\t\tURI jwkSetUri = metadata.getJWKSetURI();\n \t\t\tif (jwkSetUri != null) {\n \t\t\t\tbuilder.jwkSetUri(jwkSetUri.toASCIIString());\n\ndiff --git a/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/JwtDecoderProviderConfigurationUtils.java b/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/JwtDecoderProviderConfigurationUtils.java\nindex e69286c2d67..d901743e371 100644\n--- a/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/JwtDecoderProviderConfigurationUtils.java\n+++ b/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/JwtDecoderProviderConfigurationUtils.java\n@@ -16,8 +16,6 @@\n \n package org.springframework.security.oauth2.jwt;\n \n-import java.net.URI;\n-import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n@@ -45,6 +43,7 @@\n import org.springframework.web.client.HttpClientErrorException;\n import org.springframework.web.client.RestOperations;\n import org.springframework.web.client.RestTemplate;\n+import org.springframework.web.util.UriComponents;\n import org.springframework.web.util.UriComponentsBuilder;\n \n /**\n@@ -82,12 +81,11 @@ private JwtDecoderProviderConfigurationUtils() {\n \t}\n \n \tstatic Map<String, Object> getConfigurationForOidcIssuerLocation(String oidcIssuerLocation) {\n-\t\treturn getConfiguration(oidcIssuerLocation, rest, oidc(URI.create(oidcIssuerLocation)));\n+\t\treturn getConfiguration(oidcIssuerLocation, rest, oidc(oidcIssuerLocation));\n \t}\n \n \tstatic Map<String, Object> getConfigurationForIssuerLocation(String issuer, RestOperations rest) {\n-\t\tURI uri = URI.create(issuer);\n-\t\treturn getConfiguration(issuer, rest, oidc(uri), oidcRfc8414(uri), oauth(uri));\n+\t\treturn getConfiguration(issuer, rest, oidc(issuer), oidcRfc8414(issuer), oauth(issuer));\n \t}\n \n \tstatic Map<String, Object> getConfigurationForIssuerLocation(String issuer) {\n@@ -159,11 +157,11 @@ private static String getMetadataIssuer(Map<String, Object> configuration) {\n \t\treturn \""(unavailable)\"";\n \t}\n \n-\tprivate static Map<String, Object> getConfiguration(String issuer, RestOperations rest, URI... uris) {\n+\tprivate static Map<String, Object> getConfiguration(String issuer, RestOperations rest, UriComponents... uris) {\n \t\tString errorMessage = \""Unable to resolve the Configuration with the provided Issuer of \"" + \""\\\""\"" + issuer + \""\\\""\"";\n-\t\tfor (URI uri : uris) {\n+\t\tfor (UriComponents uri : uris) {\n \t\t\ttry {\n-\t\t\t\tRequestEntity<Void> request = RequestEntity.get(uri).build();\n+\t\t\t\tRequestEntity<Void> request = RequestEntity.get(uri.toUriString()).build();\n \t\t\t\tResponseEntity<Map<String, Object>> response = rest.exchange(request, STRING_OBJECT_MAP);\n \t\t\t\tMap<String, Object> configuration = response.getBody();\n \t\t\t\tAssert.isTrue(configuration.get(\""jwks_uri\"") != null, \""The public JWK set URI must not be null\"");\n@@ -183,27 +181,30 @@ private static Map<String, Object> getConfiguration(String issuer, RestOperation\n \t\tthrow new IllegalArgumentException(errorMessage);\n \t}\n \n-\tprivate static URI oidc(URI issuer) {\n+\tstatic UriComponents oidc(String issuer) {\n+\t\tUriComponents uri = UriComponentsBuilder.fromUriString(issuer).build();\n \t\t// @formatter:off\n-\t\treturn UriComponentsBuilder.fromUri(issuer)\n-\t\t\t\t.replacePath(issuer.getPath() + OIDC_METADATA_PATH)\n-\t\t\t\t.build(Collections.emptyMap());\n+\t\treturn UriComponentsBuilder.newInstance().uriComponents(uri)\n+\t\t\t\t.replacePath(uri.getPath() + OIDC_METADATA_PATH)\n+\t\t\t\t.build();\n \t\t// @formatter:on\n \t}\n \n-\tprivate static URI oidcRfc8414(URI issuer) {\n+\tstatic UriComponents oidcRfc8414(String issuer) {\n+\t\tUriComponents uri = UriComponentsBuilder.fromUriString(issuer).build();\n \t\t// @formatter:off\n-\t\treturn UriComponentsBuilder.fromUri(issuer)\n-\t\t\t\t.replacePath(OIDC_METADATA_PATH + issuer.getPath())\n-\t\t\t\t.build(Collections.emptyMap());\n+\t\treturn UriComponentsBuilder.newInstance().uriComponents(uri)\n+\t\t\t\t.replacePath(OIDC_METADATA_PATH + uri.getPath())\n+\t\t\t\t.build();\n \t\t// @formatter:on\n \t}\n \n-\tprivate static URI oauth(URI issuer) {\n+\tstatic UriComponents oauth(String issuer) {\n+\t\tUriComponents uri = UriComponentsBuilder.fromUriString(issuer).build();\n \t\t// @formatter:off\n-\t\treturn UriComponentsBuilder.fromUri(issuer)\n-\t\t\t\t.replacePath(OAUTH_METADATA_PATH + issuer.getPath())\n-\t\t\t\t.build(Collections.emptyMap());\n+\t\treturn UriComponentsBuilder.newInstance().uriComponents(uri)\n+\t\t\t\t.replacePath(OAUTH_METADATA_PATH + uri.getPath())\n+\t\t\t\t.build();\n \t\t// @formatter:on\n \t}\n \n\ndiff --git a/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/ReactiveJwtDecoderProviderConfigurationUtils.java b/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/ReactiveJwtDecoderProviderConfigurationUtils.java\nindex 7b0b98e6eed..d9506d900df 100644\n--- a/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/ReactiveJwtDecoderProviderConfigurationUtils.java\n+++ b/oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/ReactiveJwtDecoderProviderConfigurationUtils.java\n@@ -16,8 +16,6 @@\n \n package org.springframework.security.oauth2.jwt;\n \n-import java.net.URI;\n-import java.util.Collections;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n@@ -41,6 +39,7 @@\n import org.springframework.util.Assert;\n import org.springframework.web.reactive.function.client.WebClient;\n import org.springframework.web.reactive.function.client.WebClientResponseException;\n+import org.springframework.web.util.UriComponents;\n import org.springframework.web.util.UriComponentsBuilder;\n \n final class ReactiveJwtDecoderProviderConfigurationUtils {\n@@ -93,38 +92,40 @@ else if (jwk.getKeyType() == KeyType.EC) {\n \t}\n \n \tstatic Mono<Map<String, Object>> getConfigurationForIssuerLocation(String issuer, WebClient web) {\n-\t\tURI uri = URI.create(issuer);\n-\t\treturn getConfiguration(issuer, web, oidc(uri), oidcRfc8414(uri), oauth(uri));\n+\t\treturn getConfiguration(issuer, web, oidc(issuer), oidcRfc8414(issuer), oauth(issuer));\n \t}\n \n-\tprivate static URI oidc(URI issuer) {\n+\tstatic UriComponents oidc(String issuer) {\n+\t\tUriComponents uri = UriComponentsBuilder.fromUriString(issuer).build();\n \t\t// @formatter:off\n-\t\treturn UriComponentsBuilder.fromUri(issuer)\n-\t\t\t\t.replacePath(issuer.getPath() + OIDC_METADATA_PATH)\n-\t\t\t\t.build(Collections.emptyMap());\n+\t\treturn UriComponentsBuilder.newInstance().uriComponents(uri)\n+\t\t\t\t.replacePath(uri.getPath() + OIDC_METADATA_PATH)\n+\t\t\t\t.build();\n \t\t// @formatter:on\n \t}\n \n-\tprivate static URI oidcRfc8414(URI issuer) {\n+\tstatic UriComponents oidcRfc8414(String issuer) {\n+\t\tUriComponents uri = UriComponentsBuilder.fromUriString(issuer).build();\n \t\t// @formatter:off\n-\t\treturn UriComponentsBuilder.fromUri(issuer)\n-\t\t\t\t.replacePath(OIDC_METADATA_PATH + issuer.getPath())\n-\t\t\t\t.build(Collections.emptyMap());\n+\t\treturn UriComponentsBuilder.newInstance().uriComponents(uri)\n+\t\t\t\t.replacePath(OIDC_METADATA_PATH + uri.getPath())\n+\t\t\t\t.build();\n \t\t// @formatter:on\n \t}\n \n-\tprivate static URI oauth(URI issuer) {\n+\tstatic UriComponents oauth(String issuer) {\n+\t\tUriComponents uri = UriComponentsBuilder.fromUriString(issuer).build();\n \t\t// @formatter:off\n-\t\treturn UriComponentsBuilder.fromUri(issuer)\n-\t\t\t\t.replacePath(OAUTH_METADATA_PATH + issuer.getPath())\n-\t\t\t\t.build(Collections.emptyMap());\n+\t\treturn UriComponentsBuilder.newInstance().uriComponents(uri)\n+\t\t\t\t.replacePath(OAUTH_METADATA_PATH + uri.getPath())\n+\t\t\t\t.build();\n \t\t// @formatter:on\n \t}\n \n-\tprivate static Mono<Map<String, Object>> getConfiguration(String issuer, WebClient web, URI... uris) {\n+\tprivate static Mono<Map<String, Object>> getConfiguration(String issuer, WebClient web, UriComponents... uris) {\n \t\tString errorMessage = \""Unable to resolve the Configuration with the provided Issuer of \"" + \""\\\""\"" + issuer + \""\\\""\"";\n \t\treturn Flux.just(uris)\n-\t\t\t.concatMap((uri) -> web.get().uri(uri).retrieve().bodyToMono(STRING_OBJECT_MAP))\n+\t\t\t.concatMap((uri) -> web.get().uri(uri.toUriString()).retrieve().bodyToMono(STRING_OBJECT_MAP))\n \t\t\t.flatMap((configuration) -> {\n \t\t\t\tif (configuration.get(\""jwks_uri\"") == null) {\n \t\t\t\t\treturn Mono.error(() -> new IllegalArgumentException(\""The public JWK set URI must not be null\""));\n"", ""test_patch"": ""diff --git a/oauth2/oauth2-client/src/test/java/org/springframework/security/oauth2/client/registration/ClientRegistrationsTests.java b/oauth2/oauth2-client/src/test/java/org/springframework/security/oauth2/client/registration/ClientRegistrationsTests.java\nindex 59c0fb05288..f66fe394548 100644\n--- a/oauth2/oauth2-client/src/test/java/org/springframework/security/oauth2/client/registration/ClientRegistrationsTests.java\n+++ b/oauth2/oauth2-client/src/test/java/org/springframework/security/oauth2/client/registration/ClientRegistrationsTests.java\n@@ -34,6 +34,7 @@\n import org.springframework.http.MediaType;\n import org.springframework.security.oauth2.core.AuthorizationGrantType;\n import org.springframework.security.oauth2.core.ClientAuthenticationMethod;\n+import org.springframework.web.util.UriComponents;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n@@ -569,6 +570,17 @@ public void issuerWhenOidcConfigurationTlsClientAuthMethodThenSuccess() throws E\n \t\t\t.isEqualTo(ClientAuthenticationMethod.CLIENT_SECRET_BASIC);\n \t}\n \n+\t// gh-15852\n+\t@Test\n+\tpublic void oidcWhenHostContainsUnderscoreThenRetains() {\n+\t\tUriComponents oidc = ClientRegistrations.oidcUri(\""https://elated_sutherland:8080/path\"");\n+\t\tassertThat(oidc.getHost()).isEqualTo(\""elated_sutherland\"");\n+\t\tUriComponents oauth = ClientRegistrations.oauthUri(\""https://elated_sutherland:8080/path\"");\n+\t\tassertThat(oauth.getHost()).isEqualTo(\""elated_sutherland\"");\n+\t\tUriComponents oidcRfc8414 = ClientRegistrations.oidcRfc8414Uri(\""https://elated_sutherland:8080/path\"");\n+\t\tassertThat(oidcRfc8414.getHost()).isEqualTo(\""elated_sutherland\"");\n+\t}\n+\n \tprivate ClientRegistration.Builder registration(String path) throws Exception {\n \t\tthis.issuer = createIssuerFromServer(path);\n \t\tthis.response.put(\""issuer\"", this.issuer);\n\ndiff --git a/oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/JwtDecoderProviderConfigurationUtilsTests.java b/oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/JwtDecoderProviderConfigurationUtilsTests.java\nindex 1b88d6f3f35..ec87e7a1de1 100644\n--- a/oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/JwtDecoderProviderConfigurationUtilsTests.java\n+++ b/oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/JwtDecoderProviderConfigurationUtilsTests.java\n@@ -35,6 +35,7 @@\n import org.springframework.security.oauth2.jose.TestKeys;\n import org.springframework.security.oauth2.jose.jws.JwsAlgorithms;\n import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;\n+import org.springframework.web.util.UriComponents;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n@@ -90,4 +91,16 @@ public void getSignatureAlgorithmsWhenAlgorithmThenParses() throws Exception {\n \t\tassertThat(algorithms).containsOnly(SignatureAlgorithm.RS256);\n \t}\n \n+\t// gh-15852\n+\t@Test\n+\tpublic void oidcWhenHostContainsUnderscoreThenRetains() {\n+\t\tUriComponents oidc = JwtDecoderProviderConfigurationUtils.oidc(\""https://elated_sutherland:8080/path\"");\n+\t\tassertThat(oidc.getHost()).isEqualTo(\""elated_sutherland\"");\n+\t\tUriComponents oauth = JwtDecoderProviderConfigurationUtils.oauth(\""https://elated_sutherland:8080/path\"");\n+\t\tassertThat(oauth.getHost()).isEqualTo(\""elated_sutherland\"");\n+\t\tUriComponents oidcRfc8414 = JwtDecoderProviderConfigurationUtils\n+\t\t\t.oidcRfc8414(\""https://elated_sutherland:8080/path\"");\n+\t\tassertThat(oidcRfc8414.getHost()).isEqualTo(\""elated_sutherland\"");\n+\t}\n+\n }\n\ndiff --git a/oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/ReactiveJwtDecoderProviderConfigurationUtilsTests.java b/oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/ReactiveJwtDecoderProviderConfigurationUtilsTests.java\nindex 30a0affd144..12ccd7c46fb 100644\n--- a/oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/ReactiveJwtDecoderProviderConfigurationUtilsTests.java\n+++ b/oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/ReactiveJwtDecoderProviderConfigurationUtilsTests.java\n@@ -37,6 +37,7 @@\n import org.springframework.http.HttpHeaders;\n import org.springframework.http.MediaType;\n import org.springframework.web.reactive.function.client.WebClient;\n+import org.springframework.web.util.UriComponents;\n import org.springframework.web.util.UriComponentsBuilder;\n \n import static org.assertj.core.api.Assertions.assertThat;\n@@ -227,6 +228,18 @@ public void issuerWhenOidcFallbackRequestedIssuerIsUnresponsiveThenThrowsIllegal\n \t\t// @formatter:on\n \t}\n \n+\t// gh-15852\n+\t@Test\n+\tpublic void oidcWhenHostContainsUnderscoreThenRetains() {\n+\t\tUriComponents oidc = ReactiveJwtDecoderProviderConfigurationUtils.oidc(\""https://elated_sutherland:8080/path\"");\n+\t\tassertThat(oidc.getHost()).isEqualTo(\""elated_sutherland\"");\n+\t\tUriComponents oauth = ReactiveJwtDecoderProviderConfigurationUtils.oauth(\""https://elated_sutherland:8080/path\"");\n+\t\tassertThat(oauth.getHost()).isEqualTo(\""elated_sutherland\"");\n+\t\tUriComponents oidcRfc8414 = ReactiveJwtDecoderProviderConfigurationUtils\n+\t\t\t.oidcRfc8414(\""https://elated_sutherland:8080/path\"");\n+\t\tassertThat(oidcRfc8414.getHost()).isEqualTo(\""elated_sutherland\"");\n+\t}\n+\n \tprivate void prepareConfigurationResponse() {\n \t\tString body = String.format(DEFAULT_RESPONSE_TEMPLATE, this.issuer, this.issuer);\n \t\tprepareConfigurationResponse(body);\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
