metadata
"{""instance_id"": ""apache__rocketmq-9255"", ""pr_id"": 9255, ""issue_id"": 9253, ""repo"": ""apache/rocketmq"", ""problem_statement"": ""[Enhancement] Make the message visible earlier when adding renew task fails due to client disconnection\n### Before Creating the Enhancement Request\n\n- [x] I have confirmed that this should be classified as an enhancement rather than a bug/feature.\n\n\n### Summary\n\nIn proxy receiveMessage process, when adding message renew task fails due to client disconnection, we can make the message visible earlier by calling changeInvisibleTime, to reduce delay of the next consumption retry.\n\n### Motivation\n\nReproduce code:\n\n```\npublic static void main(String[] args) throws ClientException, IOException, InterruptedException {\n        String topic = \""topic\"";\n        String consumerGroup = \""group\"";\n        String accessKey = \""xxx\"";\n        String secretKey = \""xxx\"";\n        String endpoints = \""127.0.0.1:8080\"";\n\n        SessionCredentialsProvider sessionCredentialsProvider = new StaticSessionCredentialsProvider(accessKey, secretKey);\n        ClientConfiguration clientConfiguration = ClientConfiguration.newBuilder()\n            .setEndpoints(endpoints)\n            .enableSsl(false)\n            .setCredentialProvider(sessionCredentialsProvider)\n            .build();\n\n        ClientServiceProvider provider = ClientServiceProvider.loadService();\n        PushConsumerBuilder pushConsumerBuilder = provider.newPushConsumerBuilder()\n            .setClientConfiguration(clientConfiguration)\n            .setConsumerGroup(consumerGroup)\n            .setSubscriptionExpressions(Collections.singletonMap(topic, new FilterExpression(\""*\"", FilterExpressionType.TAG)))\n            .setMessageListener(messageView -> {\n                System.out.printf(\""%s [consumer] receive %s attempts=%d%n\"",\n                    dateFormat.format(new Date()), messageView.getMessageId(), messageView.getDeliveryAttempt());\n                return ConsumeResult.SUCCESS;\n            });\n\n        // Start consumer\n        AtomicReference<PushConsumer> consumerRef = new AtomicReference<>(pushConsumerBuilder.build());\n        System.out.printf(\""%s [consumer] started %n\"", dateFormat.format(new Date()));\n\n        // Wait for a while\n        TimeUnit.SECONDS.sleep(3);\n\n        new Thread(() -> {\n            try {\n                // Restart consumer\n                consumerRef.get().close();\n                System.out.printf(\""%s [consumer] closed %n\"", dateFormat.format(new Date()));\n                consumerRef.set(pushConsumerBuilder.build());\n                System.out.printf(\""%s [consumer] restarted %n\"", dateFormat.format(new Date()));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        // Wait for a while\n        TimeUnit.SECONDS.sleep(1);\n\n        // Then send one message\n        Producer producer = provider.newProducerBuilder()\n            .setClientConfiguration(clientConfiguration)\n            .setTopics(topic)\n            .build();\n        System.out.printf(\""%s [producer] started %n\"", dateFormat.format(new Date()));\n        MessageBuilder messageBuilder = provider.newMessageBuilder()\n            .setTopic(topic)\n            .setBody(\""BODY\"".getBytes());\n        SendReceipt receipt = producer.send(messageBuilder.build());\n        System.out.printf(\""%s [producer] send %s %n\"", dateFormat.format(new Date()), receipt.getMessageId());\n\n        TimeUnit.MINUTES.sleep(10);\n        producer.close();\n        consumerRef.get().close();\n    }\n```\n\nOutput:\n<img width=\""799\"" alt=\""Image\"" src=\""https://github.com/user-attachments/assets/aaac9e0d-45e1-4d52-aa51-155c20557fe3\"" />\n\nProxy NullPointerException logs:\n> 2025-03-17 10:30:11 INFO GrpcClientManagerThreadPool-1 - clear handle of this client when client unregister. group:group, clientChannelInfo:ClientChannelInfo [channel=GrpcClientChannel{clientId=ANONYMOUS-MB0@28703@0@f21f9v1emn, remoteAddress=127.0.0.1:52424, localAddress=127.0.0.1:8081}, clientId=ANONYMOUS-MB0@28703@0@f21f9v1emn, language=JAVA, version=413, lastUpdateTimestamp=1742178611780]\n2025-03-17 10:30:11 INFO GrpcClientManagerThreadPool-1 - remove grpc channel when client unregister. group:group, clientChannelInfo:ClientChannelInfo [channel=GrpcClientChannel{clientId=ANONYMOUS-MB0@28703@0@f21f9v1emn, remoteAddress=127.0.0.1:52424, localAddress=127.0.0.1:8081}, clientId=ANONYMOUS-MB0@28703@0@f21f9v1emn, language=JAVA, version=413, lastUpdateTimestamp=1742178611780], removed:false\n2025-03-17 10:30:11 INFO GrpcClientManagerThreadPool-1 - remove remoting channel when client unregister. clientChannelInfo:ClientChannelInfo [channel=GrpcClientChannel{clientId=ANONYMOUS-MB0@28703@0@f21f9v1emn, remoteAddress=127.0.0.1:52424, localAddress=127.0.0.1:8081}, clientId=ANONYMOUS-MB0@28703@0@f21f9v1emn, language=JAVA, version=413, lastUpdateTimestamp=1742178611780]\n2025-03-17 10:30:12 ERROR ConsumerProcessorExecutor-9 - internal server error\njava.lang.NullPointerException: null\n\tat org.apache.rocketmq.proxy.common.ReceiptHandleGroupKey.getChannelId(ReceiptHandleGroupKey.java:34)\n\tat org.apache.rocketmq.proxy.common.ReceiptHandleGroupKey.hashCode(ReceiptHandleGroupKey.java:59)\n\tat java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:936)\n\tat org.apache.rocketmq.common.utils.ConcurrentHashMapUtils.computeIfAbsent(ConcurrentHashMapUtils.java:48)\n\tat org.apache.rocketmq.proxy.service.receipt.DefaultReceiptHandleManager.addReceiptHandle(DefaultReceiptHandleManager.java:128)\n\tat org.apache.rocketmq.proxy.processor.ReceiptHandleProcessor.addReceiptHandle(ReceiptHandleProcessor.java:61)\n\tat org.apache.rocketmq.proxy.processor.DefaultMessagingProcessor.addReceiptHandle(DefaultMessagingProcessor.java:362)\n\tat org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivity.lambda$receiveMessage$0(ReceiveMessageActivity.java:145)\n\tat java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:670)\n\tat java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:646)\n\tat java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)\n\tat java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:1975)\n\tat org.apache.rocketmq.common.utils.FutureUtils.lambda$appendNextFuture$0(FutureUtils.java:31)\n\tat java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:774)\n\tat java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:750)\n\tat java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:456)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:750)\n\n### Describe the Solution You'd Like\n\nCall changeInvisibleTime  to make message visible earlier when this happens.\n\n### Describe Alternatives You've Considered\n\n/\n\n### Additional Context\n\n_No response_"", ""issue_word_count"": 714, ""test_files_count"": 2, ""non_test_files_count"": 2, ""pr_changed_files"": [""proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageResponseStreamWriter.java"", ""proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java"", ""proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageResponseStreamWriterTest.java""], ""pr_changed_test_files"": [""proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java"", ""proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageResponseStreamWriterTest.java""], ""base_commit"": ""2219fd8c1aee3bc42f6a66394e0e4cf131006a26"", ""head_commit"": ""5a7dbeb610aaebdf461638bff29cea3147b74412"", ""repo_url"": ""https://github.com/apache/rocketmq/pull/9255"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/apache__rocketmq/9255"", ""dockerfile"": """", ""pr_merged_at"": ""2025-05-13T02:17:14.000Z"", ""patch"": ""diff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java\nindex b3550eb4f37..50b6d924fda 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivity.java\n@@ -36,8 +36,10 @@\n import org.apache.rocketmq.proxy.config.ProxyConfig;\n import org.apache.rocketmq.proxy.grpc.v2.AbstractMessingActivity;\n import org.apache.rocketmq.proxy.grpc.v2.channel.GrpcChannelManager;\n+import org.apache.rocketmq.proxy.grpc.v2.channel.GrpcClientChannel;\n import org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManager;\n import org.apache.rocketmq.proxy.grpc.v2.common.GrpcConverter;\n+import org.apache.rocketmq.proxy.grpc.v2.common.GrpcProxyException;\n import org.apache.rocketmq.proxy.processor.MessagingProcessor;\n import org.apache.rocketmq.proxy.processor.QueueSelector;\n import org.apache.rocketmq.proxy.service.route.AddressableMessageQueue;\n@@ -135,6 +137,14 @@ public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n                 ).thenAccept(popResult -> {\n                     if (proxyConfig.isEnableProxyAutoRenew() && request.getAutoRenew()) {\n                         if (PopStatus.FOUND.equals(popResult.getPopStatus())) {\n+                            GrpcClientChannel clientChannel = grpcChannelManager.getChannel(ctx.getClientID());\n+                            if (clientChannel == null) {\n+                                GrpcProxyException e = new GrpcProxyException(Code.MESSAGE_NOT_FOUND,\n+                                    String.format(\""The client [%s] is disconnected.\"", ctx.getClientID()));\n+                                popResult.getMsgFoundList().forEach(messageExt ->\n+                                    writer.processThrowableWhenWriteMessage(e, ctx, request, messageExt));\n+                                throw e;\n+                            }\n                             List<MessageExt> messageExtList = popResult.getMsgFoundList();\n                             for (MessageExt messageExt : messageExtList) {\n                                 String receiptHandle = messageExt.getProperty(MessageConst.PROPERTY_POP_CK);\n@@ -142,7 +152,7 @@ public void receiveMessage(ProxyContext ctx, ReceiveMessageRequest request,\n                                     MessageReceiptHandle messageReceiptHandle =\n                                         new MessageReceiptHandle(group, topic, messageExt.getQueueId(), receiptHandle, messageExt.getMsgId(),\n                                             messageExt.getQueueOffset(), messageExt.getReconsumeTimes());\n-                                    messagingProcessor.addReceiptHandle(ctx, grpcChannelManager.getChannel(ctx.getClientID()), group, messageExt.getMsgId(), messageReceiptHandle);\n+                                    messagingProcessor.addReceiptHandle(ctx, clientChannel, group, messageExt.getMsgId(), messageReceiptHandle);\n                                 }\n                             }\n                         }\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageResponseStreamWriter.java b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageResponseStreamWriter.java\nindex d0f94e8613a..bdeffbbc8de 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageResponseStreamWriter.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageResponseStreamWriter.java\n@@ -64,9 +64,15 @@ public void writeAndComplete(ProxyContext ctx, ReceiveMessageRequest request, Po\n                             .setStatus(ResponseBuilder.getInstance().buildStatus(Code.MESSAGE_NOT_FOUND, \""no match message\""))\n                             .build());\n                     } else {\n-                        streamObserver.onNext(ReceiveMessageResponse.newBuilder()\n-                            .setStatus(ResponseBuilder.getInstance().buildStatus(Code.OK, Code.OK.name()))\n-                            .build());\n+                        try {\n+                            streamObserver.onNext(ReceiveMessageResponse.newBuilder()\n+                                .setStatus(ResponseBuilder.getInstance().buildStatus(Code.OK, Code.OK.name()))\n+                                .build());\n+                        } catch (Throwable t) {\n+                            messageFoundList.forEach(messageExt ->\n+                                this.processThrowableWhenWriteMessage(t, ctx, request, messageExt));\n+                            throw t;\n+                        }\n                         Iterator<MessageExt> messageIterator = messageFoundList.iterator();\n                         while (messageIterator.hasNext()) {\n                             MessageExt curMessageExt = messageIterator.next();\n"", ""test_patch"": ""diff --git a/proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java b/proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java\nindex 77ae5e4d111..b002db19b5a 100644\n--- a/proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java\n+++ b/proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageActivityTest.java\n@@ -30,14 +30,21 @@\n import io.grpc.stub.ServerCallStreamObserver;\n import io.grpc.stub.StreamObserver;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.rocketmq.client.consumer.AckResult;\n import org.apache.rocketmq.client.consumer.PopResult;\n import org.apache.rocketmq.client.consumer.PopStatus;\n import org.apache.rocketmq.common.MixAll;\n import org.apache.rocketmq.common.constant.PermName;\n+import org.apache.rocketmq.common.consumer.ReceiptHandle;\n+import org.apache.rocketmq.common.message.MessageAccessor;\n+import org.apache.rocketmq.common.message.MessageConst;\n+import org.apache.rocketmq.common.message.MessageExt;\n import org.apache.rocketmq.proxy.common.ProxyContext;\n import org.apache.rocketmq.proxy.config.ConfigurationManager;\n import org.apache.rocketmq.proxy.grpc.v2.BaseActivityTest;\n@@ -61,6 +68,8 @@\n import static org.mockito.Mockito.doNothing;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n public class ReceiveMessageActivityTest extends BaseActivityTest {\n \n@@ -223,6 +232,87 @@ public void testReceiveMessageIllegalInvisibleTimeTooLarge() {\n         assertEquals(Code.ILLEGAL_INVISIBLE_TIME, getResponseCodeFromReceiveMessageResponseList(responseArgumentCaptor.getAllValues()));\n     }\n \n+    @Test\n+    public void testReceiveMessageAddReceiptHandle() {\n+        ConfigurationManager.getProxyConfig().setEnableProxyAutoRenew(true);\n+        StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n+        doNothing().when(receiveStreamObserver).onNext(any());\n+        when(this.grpcClientSettingsManager.getClientSettings(any())).thenReturn(Settings.newBuilder().getDefaultInstanceForType());\n+\n+        MessageExt messageExt1 = new MessageExt();\n+        String msgId1 = \""msgId1\"";\n+        String popCk1 = \""0 0 60000 0 0 broker 0 0 0\"";\n+        messageExt1.setTopic(TOPIC);\n+        messageExt1.setMsgId(msgId1);\n+        MessageAccessor.putProperty(messageExt1, MessageConst.PROPERTY_POP_CK, popCk1);\n+        messageExt1.setBody(\""body1\"".getBytes());\n+        MessageExt messageExt2 = new MessageExt();\n+        String msgId2 = \""msgId2\"";\n+        String popCk2 = \""0 0 60000 0 0 broker 0 1 1000\"";\n+        messageExt2.setTopic(TOPIC);\n+        messageExt2.setMsgId(msgId2);\n+        MessageAccessor.putProperty(messageExt2, MessageConst.PROPERTY_POP_CK, popCk2);\n+        messageExt2.setBody(\""body2\"".getBytes());\n+        PopResult popResult = new PopResult(PopStatus.FOUND, Arrays.asList(messageExt1, messageExt2));\n+        when(this.messagingProcessor.popMessage(\n+            any(),\n+            any(),\n+            anyString(),\n+            anyString(),\n+            anyInt(),\n+            anyLong(),\n+            anyLong(),\n+            anyInt(),\n+            any(),\n+            anyBoolean(),\n+            any(),\n+            isNull(),\n+            anyLong())).thenReturn(CompletableFuture.completedFuture(popResult));\n+        ArgumentCaptor<String> msgIdCaptor = ArgumentCaptor.forClass(String.class);\n+        ArgumentCaptor<ReceiptHandle> receiptHandleCaptor = ArgumentCaptor.forClass(ReceiptHandle.class);\n+        when(this.messagingProcessor.changeInvisibleTime(\n+            any(),\n+            receiptHandleCaptor.capture(),\n+            msgIdCaptor.capture(),\n+            anyString(),\n+            anyString(),\n+            anyLong())).thenReturn(CompletableFuture.completedFuture(new AckResult()));\n+\n+        // normal\n+        ProxyContext ctx = createContext();\n+        this.grpcChannelManager.createChannel(ctx, ctx.getClientID());\n+        ReceiveMessageRequest receiveMessageRequest = ReceiveMessageRequest.newBuilder()\n+            .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n+            .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n+            .setAutoRenew(true)\n+            .setFilterExpression(FilterExpression.newBuilder()\n+                .setType(FilterType.TAG)\n+                .setExpression(\""*\"")\n+                .build())\n+            .build();\n+        this.receiveMessageActivity.receiveMessage(ctx, receiveMessageRequest, receiveStreamObserver);\n+        verify(this.messagingProcessor, times(0)).changeInvisibleTime(\n+            any(),\n+            any(),\n+            anyString(),\n+            anyString(),\n+            anyString(),\n+            anyLong());\n+\n+        // abnormal\n+        this.grpcChannelManager.removeChannel(ctx.getClientID());\n+        this.receiveMessageActivity.receiveMessage(ctx, receiveMessageRequest, receiveStreamObserver);\n+        verify(this.messagingProcessor, times(2)).changeInvisibleTime(\n+            any(),\n+            any(),\n+            anyString(),\n+            anyString(),\n+            anyString(),\n+            anyLong());\n+        assertEquals(Arrays.asList(msgId1, msgId2), msgIdCaptor.getAllValues());\n+        assertEquals(Arrays.asList(popCk1, popCk2), receiptHandleCaptor.getAllValues().stream().map(ReceiptHandle::encode).collect(Collectors.toList()));\n+    }\n+\n     @Test\n     public void testReceiveMessage() {\n         StreamObserver<ReceiveMessageResponse> receiveStreamObserver = mock(ServerCallStreamObserver.class);\n\ndiff --git a/proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageResponseStreamWriterTest.java b/proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageResponseStreamWriterTest.java\nindex fb449a89989..a717c78ca1b 100644\n--- a/proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageResponseStreamWriterTest.java\n+++ b/proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/consumer/ReceiveMessageResponseStreamWriterTest.java\n@@ -53,6 +53,7 @@\n import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.doNothing;\n import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n@@ -90,16 +91,17 @@ public void testWriteMessage() {\n         messageExtList.add(createMessageExt(TOPIC, \""tag\""));\n         messageExtList.add(createMessageExt(TOPIC, \""tag\""));\n         PopResult popResult = new PopResult(PopStatus.FOUND, messageExtList);\n+        ReceiveMessageRequest receiveMessageRequest = ReceiveMessageRequest.newBuilder()\n+            .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n+            .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n+            .setFilterExpression(FilterExpression.newBuilder()\n+                .setType(FilterType.TAG)\n+                .setExpression(\""*\"")\n+                .build())\n+            .build();\n         writer.writeAndComplete(\n             ProxyContext.create(),\n-            ReceiveMessageRequest.newBuilder()\n-                .setGroup(Resource.newBuilder().setName(CONSUMER_GROUP).build())\n-                .setMessageQueue(MessageQueue.newBuilder().setTopic(Resource.newBuilder().setName(TOPIC).build()).build())\n-                .setFilterExpression(FilterExpression.newBuilder()\n-                    .setType(FilterType.TAG)\n-                    .setExpression(\""*\"")\n-                    .build())\n-                .build(),\n+            receiveMessageRequest,\n             popResult\n         );\n \n@@ -114,6 +116,16 @@ public void testWriteMessage() {\n         assertEquals(messageExtList.get(0).getMsgId(), responseArgumentCaptor.getAllValues().get(1).getMessage().getSystemProperties().getMessageId());\n \n         assertEquals(messageExtList.get(1).getMsgId(), changeInvisibleTimeMsgIdCaptor.getValue());\n+\n+        // case: fail to write response status at first step\n+        doThrow(new RuntimeException()).when(streamObserver).onNext(any());\n+        writer.writeAndComplete(\n+            ProxyContext.create(),\n+            receiveMessageRequest,\n+            popResult\n+        );\n+        verify(this.messagingProcessor, times(3))\n+            .changeInvisibleTime(any(), any(), anyString(), anyString(), anyString(), anyLong());\n     }\n \n     @Test\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""apache__rocketmq-9192"", ""pr_id"": 9192, ""issue_id"": 9191, ""repo"": ""apache/rocketmq"", ""problem_statement"": ""[Enhancement] Provide the ability to replace the remoting layer implementation for Proxy and Broker\n### Before Creating the Enhancement Request\n\n- [x] I have confirmed that this should be classified as an enhancement rather than a bug/feature.\n\n\n### Summary\n\nProvide the ability to replace the remoting layer implementation for Proxy and Broker. \n\n### Motivation\n\nThis allows us to implement custom `RemotingClient` and `RemotingServer` to support a variety of network protocols.\n\n### Describe the Solution You'd Like\n\nFor the server side, by using a map to store multiple `RemotingServer`s, and by adding new `RemotingServer` implementations, it is possible to support different network protocols.\nFor the client side, by adding a parameter and passing it through, it is possible to create new implementations of `RemotingClient`to support different network protocols.\n\n### Describe Alternatives You've Considered\n\nNone.\n\n### Additional Context\n\n_No response_"", ""issue_word_count"": 136, ""test_files_count"": 2, ""non_test_files_count"": 11, ""pr_changed_files"": [""broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java"", ""broker/src/test/java/org/apache/rocketmq/broker/BrokerControllerTest.java"", ""client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java"", ""client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExt.java"", ""client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIFactory.java"", ""client/src/test/java/org/apache/rocketmq/client/impl/MQClientAPIImplTest.java"", ""common/src/main/java/org/apache/rocketmq/common/ObjectCreator.java"", ""container/src/main/java/org/apache/rocketmq/container/InnerBrokerController.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/service/ClusterServiceManager.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/service/ServiceManagerFactory.java"", ""remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java"", ""remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingClient.java"", ""remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingServer.java""], ""pr_changed_test_files"": [""broker/src/test/java/org/apache/rocketmq/broker/BrokerControllerTest.java"", ""client/src/test/java/org/apache/rocketmq/client/impl/MQClientAPIImplTest.java""], ""base_commit"": ""6cccff82f42d7c8326774c88334b4616b0a46e5e"", ""head_commit"": ""107ac8ec6a8b1dc2961117e0ef850fda78f7573f"", ""repo_url"": ""https://github.com/apache/rocketmq/pull/9192"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/apache__rocketmq/9192"", ""dockerfile"": """", ""pr_merged_at"": ""2025-02-24T04:27:30.000Z"", ""patch"": ""diff --git a/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java b/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java\nindex 006695c6bc8..4031dce8d6f 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java\n@@ -244,10 +244,10 @@ public class BrokerController {\n     protected final List<SendMessageHook> sendMessageHookList = new ArrayList<>();\n     protected final List<ConsumeMessageHook> consumeMessageHookList = new ArrayList<>();\n     protected MessageStore messageStore;\n-    protected RemotingServer remotingServer;\n+    protected static final String TCP_REMOTING_SERVER = \""TCP_REMOTING_SERVER\"";\n+    protected static final String FAST_REMOTING_SERVER = \""FAST_REMOTING_SERVER\"";\n+    protected final Map<String, RemotingServer> remotingServerMap = new ConcurrentHashMap<>();\n     protected CountDownLatch remotingServerStartLatch;\n-    protected RemotingServer fastRemotingServer;\n-\n     /**\n      * If {Topic, SubscriptionGroup, Offset}ManagerV2 are used, config entries are stored in RocksDB.\n      */\n@@ -494,7 +494,7 @@ public BrokerMetricsManager getBrokerMetricsManager() {\n     }\n \n     protected void initializeRemotingServer() throws CloneNotSupportedException {\n-        this.remotingServer = new NettyRemotingServer(this.nettyServerConfig, this.clientHousekeepingService);\n+        RemotingServer tcpRemotingServer = new NettyRemotingServer(this.nettyServerConfig, this.clientHousekeepingService);\n         NettyServerConfig fastConfig = (NettyServerConfig) this.nettyServerConfig.clone();\n \n         int listeningPort = nettyServerConfig.getListenPort() - 2;\n@@ -503,7 +503,10 @@ protected void initializeRemotingServer() throws CloneNotSupportedException {\n         }\n         fastConfig.setListenPort(listeningPort);\n \n-        this.fastRemotingServer = new NettyRemotingServer(fastConfig, this.clientHousekeepingService);\n+        RemotingServer fastRemotingServer = new NettyRemotingServer(fastConfig, this.clientHousekeepingService);\n+\n+        remotingServerMap.put(TCP_REMOTING_SERVER, tcpRemotingServer);\n+        remotingServerMap.put(FAST_REMOTING_SERVER, fastRemotingServer);\n     }\n \n     /**\n@@ -939,8 +942,12 @@ public void onChanged(String path) {\n                             }\n \n                             private void reloadServerSslContext() {\n-                                ((NettyRemotingServer) remotingServer).loadSslContext();\n-                                ((NettyRemotingServer) fastRemotingServer).loadSslContext();\n+                                for (Map.Entry<String, RemotingServer> entry : remotingServerMap.entrySet()) {\n+                                    RemotingServer remotingServer = entry.getValue();\n+                                    if (remotingServer instanceof NettyRemotingServer) {\n+                                        ((NettyRemotingServer) remotingServer).loadSslContext();\n+                                    }\n+                                }\n                             }\n                         });\n                 } catch (Exception e) {\n@@ -1092,59 +1099,62 @@ private void initialRequestPipeline() {\n     }\n \n     public void registerProcessor() {\n+        RemotingServer remotingServer = remotingServerMap.get(TCP_REMOTING_SERVER);\n+        RemotingServer fastRemotingServer = remotingServerMap.get(FAST_REMOTING_SERVER);\n+\n         /*\n          * SendMessageProcessor\n          */\n         sendMessageProcessor.registerSendMessageHook(sendMessageHookList);\n         sendMessageProcessor.registerConsumeMessageHook(consumeMessageHookList);\n \n-        this.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendMessageProcessor, this.sendMessageExecutor);\n-        this.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendMessageProcessor, this.sendMessageExecutor);\n-        this.remotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendMessageProcessor, this.sendMessageExecutor);\n-        this.remotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendMessageProcessor, this.sendMessageExecutor);\n-        this.remotingServer.registerProcessor(RequestCode.RECALL_MESSAGE, recallMessageProcessor, this.sendMessageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendMessageProcessor, this.sendMessageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendMessageProcessor, this.sendMessageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendMessageProcessor, this.sendMessageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendMessageProcessor, this.sendMessageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.RECALL_MESSAGE, recallMessageProcessor, this.sendMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendMessageProcessor, this.sendMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendMessageProcessor, this.sendMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendMessageProcessor, this.sendMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendMessageProcessor, this.sendMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.RECALL_MESSAGE, recallMessageProcessor, this.sendMessageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendMessageProcessor, this.sendMessageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendMessageProcessor, this.sendMessageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendMessageProcessor, this.sendMessageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendMessageProcessor, this.sendMessageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.RECALL_MESSAGE, recallMessageProcessor, this.sendMessageExecutor);\n         /**\n          * PullMessageProcessor\n          */\n-        this.remotingServer.registerProcessor(RequestCode.PULL_MESSAGE, this.pullMessageProcessor, this.pullMessageExecutor);\n-        this.remotingServer.registerProcessor(RequestCode.LITE_PULL_MESSAGE, this.pullMessageProcessor, this.litePullMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.PULL_MESSAGE, this.pullMessageProcessor, this.pullMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.LITE_PULL_MESSAGE, this.pullMessageProcessor, this.litePullMessageExecutor);\n         this.pullMessageProcessor.registerConsumeMessageHook(consumeMessageHookList);\n         /**\n          * PeekMessageProcessor\n          */\n-        this.remotingServer.registerProcessor(RequestCode.PEEK_MESSAGE, this.peekMessageProcessor, this.pullMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.PEEK_MESSAGE, this.peekMessageProcessor, this.pullMessageExecutor);\n         /**\n          * PopMessageProcessor\n          */\n-        this.remotingServer.registerProcessor(RequestCode.POP_MESSAGE, this.popMessageProcessor, this.pullMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.POP_MESSAGE, this.popMessageProcessor, this.pullMessageExecutor);\n \n         /**\n          * AckMessageProcessor\n          */\n-        this.remotingServer.registerProcessor(RequestCode.ACK_MESSAGE, this.ackMessageProcessor, this.ackMessageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.ACK_MESSAGE, this.ackMessageProcessor, this.ackMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.ACK_MESSAGE, this.ackMessageProcessor, this.ackMessageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.ACK_MESSAGE, this.ackMessageProcessor, this.ackMessageExecutor);\n \n-        this.remotingServer.registerProcessor(RequestCode.BATCH_ACK_MESSAGE, this.ackMessageProcessor, this.ackMessageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.BATCH_ACK_MESSAGE, this.ackMessageProcessor, this.ackMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.BATCH_ACK_MESSAGE, this.ackMessageProcessor, this.ackMessageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.BATCH_ACK_MESSAGE, this.ackMessageProcessor, this.ackMessageExecutor);\n         /**\n          * ChangeInvisibleTimeProcessor\n          */\n-        this.remotingServer.registerProcessor(RequestCode.CHANGE_MESSAGE_INVISIBLETIME, this.changeInvisibleTimeProcessor, this.ackMessageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.CHANGE_MESSAGE_INVISIBLETIME, this.changeInvisibleTimeProcessor, this.ackMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.CHANGE_MESSAGE_INVISIBLETIME, this.changeInvisibleTimeProcessor, this.ackMessageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.CHANGE_MESSAGE_INVISIBLETIME, this.changeInvisibleTimeProcessor, this.ackMessageExecutor);\n         /**\n          * notificationProcessor\n          */\n-        this.remotingServer.registerProcessor(RequestCode.NOTIFICATION, this.notificationProcessor, this.pullMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.NOTIFICATION, this.notificationProcessor, this.pullMessageExecutor);\n \n         /**\n          * pollingInfoProcessor\n          */\n-        this.remotingServer.registerProcessor(RequestCode.POLLING_INFO, this.pollingInfoProcessor, this.pullMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.POLLING_INFO, this.pollingInfoProcessor, this.pullMessageExecutor);\n \n         /**\n          * ReplyMessageProcessor\n@@ -1152,64 +1162,64 @@ public void registerProcessor() {\n \n         replyMessageProcessor.registerSendMessageHook(sendMessageHookList);\n \n-        this.remotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE, replyMessageProcessor, replyMessageExecutor);\n-        this.remotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE_V2, replyMessageProcessor, replyMessageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE, replyMessageProcessor, replyMessageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE_V2, replyMessageProcessor, replyMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE, replyMessageProcessor, replyMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE_V2, replyMessageProcessor, replyMessageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE, replyMessageProcessor, replyMessageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE_V2, replyMessageProcessor, replyMessageExecutor);\n \n         /**\n          * QueryMessageProcessor\n          */\n         NettyRequestProcessor queryProcessor = new QueryMessageProcessor(this);\n-        this.remotingServer.registerProcessor(RequestCode.QUERY_MESSAGE, queryProcessor, this.queryMessageExecutor);\n-        this.remotingServer.registerProcessor(RequestCode.VIEW_MESSAGE_BY_ID, queryProcessor, this.queryMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.QUERY_MESSAGE, queryProcessor, this.queryMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.VIEW_MESSAGE_BY_ID, queryProcessor, this.queryMessageExecutor);\n \n-        this.fastRemotingServer.registerProcessor(RequestCode.QUERY_MESSAGE, queryProcessor, this.queryMessageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.VIEW_MESSAGE_BY_ID, queryProcessor, this.queryMessageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.QUERY_MESSAGE, queryProcessor, this.queryMessageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.VIEW_MESSAGE_BY_ID, queryProcessor, this.queryMessageExecutor);\n \n         /**\n          * ClientManageProcessor\n          */\n-        this.remotingServer.registerProcessor(RequestCode.HEART_BEAT, clientManageProcessor, this.heartbeatExecutor);\n-        this.remotingServer.registerProcessor(RequestCode.UNREGISTER_CLIENT, clientManageProcessor, this.clientManageExecutor);\n-        this.remotingServer.registerProcessor(RequestCode.CHECK_CLIENT_CONFIG, clientManageProcessor, this.clientManageExecutor);\n+        remotingServer.registerProcessor(RequestCode.HEART_BEAT, clientManageProcessor, this.heartbeatExecutor);\n+        remotingServer.registerProcessor(RequestCode.UNREGISTER_CLIENT, clientManageProcessor, this.clientManageExecutor);\n+        remotingServer.registerProcessor(RequestCode.CHECK_CLIENT_CONFIG, clientManageProcessor, this.clientManageExecutor);\n \n-        this.fastRemotingServer.registerProcessor(RequestCode.HEART_BEAT, clientManageProcessor, this.heartbeatExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.UNREGISTER_CLIENT, clientManageProcessor, this.clientManageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.CHECK_CLIENT_CONFIG, clientManageProcessor, this.clientManageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.HEART_BEAT, clientManageProcessor, this.heartbeatExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.UNREGISTER_CLIENT, clientManageProcessor, this.clientManageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.CHECK_CLIENT_CONFIG, clientManageProcessor, this.clientManageExecutor);\n \n         /**\n          * ConsumerManageProcessor\n          */\n         ConsumerManageProcessor consumerManageProcessor = new ConsumerManageProcessor(this);\n-        this.remotingServer.registerProcessor(RequestCode.GET_CONSUMER_LIST_BY_GROUP, consumerManageProcessor, this.consumerManageExecutor);\n-        this.remotingServer.registerProcessor(RequestCode.UPDATE_CONSUMER_OFFSET, consumerManageProcessor, this.consumerManageExecutor);\n-        this.remotingServer.registerProcessor(RequestCode.QUERY_CONSUMER_OFFSET, consumerManageProcessor, this.consumerManageExecutor);\n+        remotingServer.registerProcessor(RequestCode.GET_CONSUMER_LIST_BY_GROUP, consumerManageProcessor, this.consumerManageExecutor);\n+        remotingServer.registerProcessor(RequestCode.UPDATE_CONSUMER_OFFSET, consumerManageProcessor, this.consumerManageExecutor);\n+        remotingServer.registerProcessor(RequestCode.QUERY_CONSUMER_OFFSET, consumerManageProcessor, this.consumerManageExecutor);\n \n-        this.fastRemotingServer.registerProcessor(RequestCode.GET_CONSUMER_LIST_BY_GROUP, consumerManageProcessor, this.consumerManageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.UPDATE_CONSUMER_OFFSET, consumerManageProcessor, this.consumerManageExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.QUERY_CONSUMER_OFFSET, consumerManageProcessor, this.consumerManageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.GET_CONSUMER_LIST_BY_GROUP, consumerManageProcessor, this.consumerManageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.UPDATE_CONSUMER_OFFSET, consumerManageProcessor, this.consumerManageExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.QUERY_CONSUMER_OFFSET, consumerManageProcessor, this.consumerManageExecutor);\n \n         /**\n          * QueryAssignmentProcessor\n          */\n-        this.remotingServer.registerProcessor(RequestCode.QUERY_ASSIGNMENT, queryAssignmentProcessor, loadBalanceExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.QUERY_ASSIGNMENT, queryAssignmentProcessor, loadBalanceExecutor);\n-        this.remotingServer.registerProcessor(RequestCode.SET_MESSAGE_REQUEST_MODE, queryAssignmentProcessor, loadBalanceExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.SET_MESSAGE_REQUEST_MODE, queryAssignmentProcessor, loadBalanceExecutor);\n+        remotingServer.registerProcessor(RequestCode.QUERY_ASSIGNMENT, queryAssignmentProcessor, loadBalanceExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.QUERY_ASSIGNMENT, queryAssignmentProcessor, loadBalanceExecutor);\n+        remotingServer.registerProcessor(RequestCode.SET_MESSAGE_REQUEST_MODE, queryAssignmentProcessor, loadBalanceExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.SET_MESSAGE_REQUEST_MODE, queryAssignmentProcessor, loadBalanceExecutor);\n \n         /**\n          * EndTransactionProcessor\n          */\n-        this.remotingServer.registerProcessor(RequestCode.END_TRANSACTION, endTransactionProcessor, this.endTransactionExecutor);\n-        this.fastRemotingServer.registerProcessor(RequestCode.END_TRANSACTION, endTransactionProcessor, this.endTransactionExecutor);\n+        remotingServer.registerProcessor(RequestCode.END_TRANSACTION, endTransactionProcessor, this.endTransactionExecutor);\n+        fastRemotingServer.registerProcessor(RequestCode.END_TRANSACTION, endTransactionProcessor, this.endTransactionExecutor);\n \n         /*\n          * Default\n          */\n         AdminBrokerProcessor adminProcessor = new AdminBrokerProcessor(this);\n-        this.remotingServer.registerDefaultProcessor(adminProcessor, this.adminBrokerExecutor);\n-        this.fastRemotingServer.registerDefaultProcessor(adminProcessor, this.adminBrokerExecutor);\n+        remotingServer.registerDefaultProcessor(adminProcessor, this.adminBrokerExecutor);\n+        fastRemotingServer.registerDefaultProcessor(adminProcessor, this.adminBrokerExecutor);\n \n         /*\n          * Initialize the mapping of request codes to request headers.\n@@ -1342,14 +1352,6 @@ public ProducerManager getProducerManager() {\n         return producerManager;\n     }\n \n-    public void setFastRemotingServer(RemotingServer fastRemotingServer) {\n-        this.fastRemotingServer = fastRemotingServer;\n-    }\n-\n-    public RemotingServer getFastRemotingServer() {\n-        return fastRemotingServer;\n-    }\n-\n     public PullMessageProcessor getPullMessageProcessor() {\n         return pullMessageProcessor;\n     }\n@@ -1400,12 +1402,11 @@ protected void shutdownBasicService() {\n             this.shutdownHook.beforeShutdown(this);\n         }\n \n-        if (this.remotingServer != null) {\n-            this.remotingServer.shutdown();\n-        }\n-\n-        if (this.fastRemotingServer != null) {\n-            this.fastRemotingServer.shutdown();\n+        for (Map.Entry<String, RemotingServer> entry : remotingServerMap.entrySet()) {\n+            RemotingServer remotingServer = entry.getValue();\n+            if (remotingServer != null) {\n+                remotingServer.shutdown();\n+            }\n         }\n \n         if (this.brokerMetricsManager != null) {\n@@ -1658,19 +1659,20 @@ protected void startBasicService() throws Exception {\n             remotingServerStartLatch.await();\n         }\n \n-        if (this.remotingServer != null) {\n-            this.remotingServer.start();\n+        for (Map.Entry<String, RemotingServer> entry : remotingServerMap.entrySet()) {\n+            RemotingServer remotingServer = entry.getValue();\n+            if (remotingServer != null) {\n+                remotingServer.start();\n \n-            // In test scenarios where it is up to OS to pick up an available port, set the listening port back to config\n-            if (null != nettyServerConfig && 0 == nettyServerConfig.getListenPort()) {\n-                nettyServerConfig.setListenPort(remotingServer.localListenPort());\n+                if (TCP_REMOTING_SERVER.equals(entry.getKey())) {\n+                    // In test scenarios where it is up to OS to pick up an available port, set the listening port back to config\n+                    if (null != nettyServerConfig && 0 == nettyServerConfig.getListenPort()) {\n+                        nettyServerConfig.setListenPort(remotingServer.localListenPort());\n+                    }\n+                }\n             }\n         }\n \n-        if (this.fastRemotingServer != null) {\n-            this.fastRemotingServer.start();\n-        }\n-\n         this.storeHost = new InetSocketAddress(this.getBrokerConfig().getBrokerIP1(), this.getNettyServerConfig().getListenPort());\n \n         for (BrokerAttachedPlugin brokerAttachedPlugin : brokerAttachedPlugins) {\n@@ -2353,21 +2355,49 @@ public void registerConsumeMessageHook(final ConsumeMessageHook hook) {\n     }\n \n     public void registerServerRPCHook(RPCHook rpcHook) {\n-        getRemotingServer().registerRPCHook(rpcHook);\n-        this.fastRemotingServer.registerRPCHook(rpcHook);\n+        for (Map.Entry<String, RemotingServer> entry : remotingServerMap.entrySet()) {\n+            RemotingServer remotingServer = entry.getValue();\n+            if (remotingServer != null) {\n+                remotingServer.registerRPCHook(rpcHook);\n+            }\n+        }\n     }\n \n     public void setRequestPipeline(RequestPipeline pipeline) {\n-        this.getRemotingServer().setRequestPipeline(pipeline);\n-        this.fastRemotingServer.setRequestPipeline(pipeline);\n+        for (Map.Entry<String, RemotingServer> entry : remotingServerMap.entrySet()) {\n+            RemotingServer remotingServer = entry.getValue();\n+            if (remotingServer != null) {\n+                remotingServer.setRequestPipeline(pipeline);\n+            }\n+        }\n     }\n \n     public RemotingServer getRemotingServer() {\n-        return remotingServer;\n+        return remotingServerMap.get(TCP_REMOTING_SERVER);\n     }\n \n     public void setRemotingServer(RemotingServer remotingServer) {\n-        this.remotingServer = remotingServer;\n+        remotingServerMap.put(TCP_REMOTING_SERVER, remotingServer);\n+    }\n+\n+    public RemotingServer getFastRemotingServer() {\n+        return remotingServerMap.get(FAST_REMOTING_SERVER);\n+    }\n+\n+    public void setFastRemotingServer(RemotingServer fastRemotingServer) {\n+        remotingServerMap.put(FAST_REMOTING_SERVER, fastRemotingServer);\n+    }\n+\n+    public RemotingServer getRemotingServerByName(String name) {\n+        return remotingServerMap.get(name);\n+    }\n+\n+    public void setRemotingServerByName(String name, RemotingServer remotingServer) {\n+        remotingServerMap.put(name, remotingServer);\n+    }\n+\n+    public ClientHousekeepingService getClientHousekeepingService() {\n+        return clientHousekeepingService;\n     }\n \n     public CountDownLatch getRemotingServerStartLatch() {\n\ndiff --git a/client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java b/client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java\nindex bed6c1c4762..30d7b0a1d5f 100644\n--- a/client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java\n+++ b/client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java\n@@ -59,6 +59,7 @@\n import org.apache.rocketmq.common.CheckRocksdbCqWriteResult;\n import org.apache.rocketmq.common.MQVersion;\n import org.apache.rocketmq.common.MixAll;\n+import org.apache.rocketmq.common.ObjectCreator;\n import org.apache.rocketmq.common.Pair;\n import org.apache.rocketmq.common.PlainAccessConfig;\n import org.apache.rocketmq.common.TopicConfig;\n@@ -268,19 +269,43 @@ public class MQClientAPIImpl implements NameServerUpdateCallback, StartAndShutdo\n     private String nameSrvAddr = null;\n     private ClientConfig clientConfig;\n \n-    public MQClientAPIImpl(final NettyClientConfig nettyClientConfig,\n+    public MQClientAPIImpl(\n+        final NettyClientConfig nettyClientConfig,\n         final ClientRemotingProcessor clientRemotingProcessor,\n-        RPCHook rpcHook, final ClientConfig clientConfig) {\n+        final RPCHook rpcHook,\n+        final ClientConfig clientConfig\n+    ) {\n         this(nettyClientConfig, clientRemotingProcessor, rpcHook, clientConfig, null);\n     }\n \n-    public MQClientAPIImpl(final NettyClientConfig nettyClientConfig,\n+    public MQClientAPIImpl(\n+        final NettyClientConfig nettyClientConfig,\n         final ClientRemotingProcessor clientRemotingProcessor,\n-        RPCHook rpcHook, final ClientConfig clientConfig, final ChannelEventListener channelEventListener) {\n+        final RPCHook rpcHook,\n+        final ClientConfig clientConfig,\n+        final ChannelEventListener channelEventListener\n+    ) {\n+        this(\n+            nettyClientConfig,\n+            clientRemotingProcessor,\n+            rpcHook,\n+            clientConfig,\n+            channelEventListener,\n+            null\n+        );\n+    }\n+\n+    public MQClientAPIImpl(final NettyClientConfig nettyClientConfig,\n+                           final ClientRemotingProcessor clientRemotingProcessor,\n+                           RPCHook rpcHook, final ClientConfig clientConfig,\n+                           final ChannelEventListener channelEventListener,\n+                           final ObjectCreator<RemotingClient> remotingClientCreator) {\n         this.clientConfig = clientConfig;\n         topAddressing = new DefaultTopAddressing(MixAll.getWSAddr(), clientConfig.getUnitName());\n         topAddressing.registerChangeCallBack(this);\n-        this.remotingClient = new NettyRemotingClient(nettyClientConfig, channelEventListener);\n+        this.remotingClient = remotingClientCreator != null\n+            ? remotingClientCreator.create(nettyClientConfig, channelEventListener)\n+            : new NettyRemotingClient(nettyClientConfig, channelEventListener);\n         this.clientRemotingProcessor = clientRemotingProcessor;\n \n         this.remotingClient.registerRPCHook(new NamespaceRpcHook(clientConfig));\n\ndiff --git a/client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExt.java b/client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExt.java\nindex 6624b3100d8..c22f4534771 100644\n--- a/client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExt.java\n+++ b/client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExt.java\n@@ -37,6 +37,7 @@\n import org.apache.rocketmq.client.impl.admin.MqClientAdminImpl;\n import org.apache.rocketmq.client.impl.consumer.PullResultExt;\n import org.apache.rocketmq.client.producer.SendResult;\n+import org.apache.rocketmq.common.ObjectCreator;\n import org.apache.rocketmq.common.constant.LoggerName;\n import org.apache.rocketmq.common.message.Message;\n import org.apache.rocketmq.common.message.MessageBatch;\n@@ -48,6 +49,7 @@\n import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\n import org.apache.rocketmq.remoting.InvokeCallback;\n import org.apache.rocketmq.remoting.RPCHook;\n+import org.apache.rocketmq.remoting.RemotingClient;\n import org.apache.rocketmq.remoting.exception.RemotingCommandException;\n import org.apache.rocketmq.remoting.netty.NettyClientConfig;\n import org.apache.rocketmq.remoting.netty.ResponseFuture;\n@@ -97,7 +99,17 @@ public MQClientAPIExt(\n         ClientRemotingProcessor clientRemotingProcessor,\n         RPCHook rpcHook\n     ) {\n-        super(nettyClientConfig, clientRemotingProcessor, rpcHook, clientConfig);\n+        this(clientConfig, nettyClientConfig, clientRemotingProcessor, rpcHook, null);\n+    }\n+\n+    public MQClientAPIExt(\n+        ClientConfig clientConfig,\n+        NettyClientConfig nettyClientConfig,\n+        ClientRemotingProcessor clientRemotingProcessor,\n+        RPCHook rpcHook,\n+        ObjectCreator<RemotingClient> remotingClientCreator\n+    ) {\n+        super(nettyClientConfig, clientRemotingProcessor, rpcHook, clientConfig, null, remotingClientCreator);\n         this.clientConfig = clientConfig;\n         this.mqClientAdmin = new MqClientAdminImpl(getRemotingClient());\n     }\n\ndiff --git a/client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIFactory.java b/client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIFactory.java\nindex 0fa31b66406..d85dcc70a55 100644\n--- a/client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIFactory.java\n+++ b/client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIFactory.java\n@@ -17,18 +17,22 @@\n package org.apache.rocketmq.client.impl.mqclient;\n \n import com.google.common.base.Strings;\n+\n import java.time.Duration;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n+\n import org.apache.commons.lang3.StringUtils;\n import org.apache.rocketmq.client.ClientConfig;\n import org.apache.rocketmq.client.common.NameserverAccessConfig;\n import org.apache.rocketmq.client.impl.ClientRemotingProcessor;\n import org.apache.rocketmq.common.MixAll;\n import org.apache.rocketmq.common.utils.AsyncShutdownHelper;\n+import org.apache.rocketmq.common.ObjectCreator;\n import org.apache.rocketmq.common.utils.StartAndShutdown;\n import org.apache.rocketmq.remoting.RPCHook;\n+import org.apache.rocketmq.remoting.RemotingClient;\n import org.apache.rocketmq.remoting.netty.NettyClientConfig;\n \n public class MQClientAPIFactory implements StartAndShutdown {\n@@ -40,16 +44,35 @@ public class MQClientAPIFactory implements StartAndShutdown {\n     private final RPCHook rpcHook;\n     private final ScheduledExecutorService scheduledExecutorService;\n     private final NameserverAccessConfig nameserverAccessConfig;\n+    private final ObjectCreator<RemotingClient> remotingClientCreator;\n+\n+    public MQClientAPIFactory(\n+        NameserverAccessConfig nameserverAccessConfig,\n+        String namePrefix,\n+        int clientNum,\n+        ClientRemotingProcessor clientRemotingProcessor,\n+        RPCHook rpcHook,\n+        ScheduledExecutorService scheduledExecutorService\n+    ) {\n+        this(nameserverAccessConfig, namePrefix, clientNum, clientRemotingProcessor, rpcHook, scheduledExecutorService, null);\n+    }\n \n-    public MQClientAPIFactory(NameserverAccessConfig nameserverAccessConfig, String namePrefix, int clientNum,\n+    public MQClientAPIFactory(\n+        NameserverAccessConfig nameserverAccessConfig,\n+        String namePrefix,\n+        int clientNum,\n         ClientRemotingProcessor clientRemotingProcessor,\n-        RPCHook rpcHook, ScheduledExecutorService scheduledExecutorService) {\n+        RPCHook rpcHook,\n+        ScheduledExecutorService scheduledExecutorService,\n+        ObjectCreator<RemotingClient> remotingClientCreator\n+    ) {\n         this.nameserverAccessConfig = nameserverAccessConfig;\n         this.namePrefix = namePrefix;\n         this.clientNum = clientNum;\n         this.clientRemotingProcessor = clientRemotingProcessor;\n         this.rpcHook = rpcHook;\n         this.scheduledExecutorService = scheduledExecutorService;\n+        this.remotingClientCreator = remotingClientCreator;\n \n         this.init();\n     }\n@@ -102,9 +125,13 @@ protected MQClientAPIExt createAndStart(String instanceName) {\n         NettyClientConfig nettyClientConfig = new NettyClientConfig();\n         nettyClientConfig.setDisableCallbackExecutor(true);\n \n-        MQClientAPIExt mqClientAPIExt = new MQClientAPIExt(clientConfig, nettyClientConfig,\n+        MQClientAPIExt mqClientAPIExt = new MQClientAPIExt(\n+            clientConfig,\n+            nettyClientConfig,\n             clientRemotingProcessor,\n-            rpcHook);\n+            rpcHook,\n+            remotingClientCreator\n+        );\n \n         if (!mqClientAPIExt.updateNameServerAddressList()) {\n             mqClientAPIExt.fetchNameServerAddr();\n\ndiff --git a/common/src/main/java/org/apache/rocketmq/common/ObjectCreator.java b/common/src/main/java/org/apache/rocketmq/common/ObjectCreator.java\nnew file mode 100644\nindex 00000000000..14c645424f3\n--- /dev/null\n+++ b/common/src/main/java/org/apache/rocketmq/common/ObjectCreator.java\n@@ -0,0 +1,21 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.common;\n+\n+public interface ObjectCreator<T> {\n+    T create(Object... args);\n+}\n\ndiff --git a/container/src/main/java/org/apache/rocketmq/container/InnerBrokerController.java b/container/src/main/java/org/apache/rocketmq/container/InnerBrokerController.java\nindex a1c1eecf590..616188e52d1 100644\n--- a/container/src/main/java/org/apache/rocketmq/container/InnerBrokerController.java\n+++ b/container/src/main/java/org/apache/rocketmq/container/InnerBrokerController.java\n@@ -23,6 +23,7 @@\n import org.apache.rocketmq.common.AbstractBrokerRunnable;\n import org.apache.rocketmq.common.BrokerConfig;\n import org.apache.rocketmq.common.MixAll;\n+import org.apache.rocketmq.remoting.RemotingServer;\n import org.apache.rocketmq.remoting.netty.NettyClientConfig;\n import org.apache.rocketmq.remoting.netty.NettyServerConfig;\n import org.apache.rocketmq.store.MessageStore;\n@@ -43,8 +44,11 @@ public InnerBrokerController(\n \n     @Override\n     protected void initializeRemotingServer() {\n-        this.remotingServer = this.brokerContainer.getRemotingServer().newRemotingServer(brokerConfig.getListenPort());\n-        this.fastRemotingServer = this.brokerContainer.getRemotingServer().newRemotingServer(brokerConfig.getListenPort() - 2);\n+        RemotingServer remotingServer = this.brokerContainer.getRemotingServer().newRemotingServer(brokerConfig.getListenPort());\n+        RemotingServer fastRemotingServer = this.brokerContainer.getRemotingServer().newRemotingServer(brokerConfig.getListenPort() - 2);\n+\n+        setRemotingServer(remotingServer);\n+        setFastRemotingServer(fastRemotingServer);\n     }\n \n     @Override\n@@ -119,11 +123,11 @@ public void shutdown() {\n             scheduledFuture.cancel(true);\n         }\n \n-        if (this.remotingServer != null) {\n+        if (getRemotingServer() != null) {\n             this.brokerContainer.getRemotingServer().removeRemotingServer(brokerConfig.getListenPort());\n         }\n \n-        if (this.fastRemotingServer != null) {\n+        if (getFastRemotingServer() != null) {\n             this.brokerContainer.getRemotingServer().removeRemotingServer(brokerConfig.getListenPort() - 2);\n         }\n     }\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/service/ClusterServiceManager.java b/proxy/src/main/java/org/apache/rocketmq/proxy/service/ClusterServiceManager.java\nindex 9786cec5577..33b65d2550e 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/service/ClusterServiceManager.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/service/ClusterServiceManager.java\n@@ -28,6 +28,7 @@\n import org.apache.rocketmq.client.common.NameserverAccessConfig;\n import org.apache.rocketmq.client.impl.mqclient.DoNothingClientRemotingProcessor;\n import org.apache.rocketmq.client.impl.mqclient.MQClientAPIFactory;\n+import org.apache.rocketmq.common.ObjectCreator;\n import org.apache.rocketmq.common.constant.LoggerName;\n import org.apache.rocketmq.common.utils.AbstractStartAndShutdown;\n import org.apache.rocketmq.common.utils.ThreadUtils;\n@@ -51,6 +52,7 @@\n import org.apache.rocketmq.proxy.service.transaction.ClusterTransactionService;\n import org.apache.rocketmq.proxy.service.transaction.TransactionService;\n import org.apache.rocketmq.remoting.RPCHook;\n+import org.apache.rocketmq.remoting.RemotingClient;\n \n public class ClusterServiceManager extends AbstractStartAndShutdown implements ServiceManager {\n     private static final Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);\n@@ -70,6 +72,10 @@ public class ClusterServiceManager extends AbstractStartAndShutdown implements S\n     protected MQClientAPIFactory transactionClientAPIFactory;\n \n     public ClusterServiceManager(RPCHook rpcHook) {\n+        this(rpcHook, null);\n+    }\n+\n+    public ClusterServiceManager(RPCHook rpcHook, ObjectCreator<RemotingClient> remotingClientCreator) {\n         ProxyConfig proxyConfig = ConfigurationManager.getProxyConfig();\n         NameserverAccessConfig nameserverAccessConfig = new NameserverAccessConfig(proxyConfig.getNamesrvAddr(),\n             proxyConfig.getNamesrvDomain(), proxyConfig.getNamesrvDomainSubgroup());\n@@ -81,14 +87,18 @@ public ClusterServiceManager(RPCHook rpcHook) {\n             proxyConfig.getRocketmqMQClientNum(),\n             new DoNothingClientRemotingProcessor(null),\n             rpcHook,\n-            scheduledExecutorService);\n+            scheduledExecutorService,\n+            remotingClientCreator\n+        );\n+\n         this.operationClientAPIFactory = new MQClientAPIFactory(\n             nameserverAccessConfig,\n             \""OperationClient_\"",\n             1,\n             new DoNothingClientRemotingProcessor(null),\n             rpcHook,\n-            this.scheduledExecutorService\n+            this.scheduledExecutorService,\n+            remotingClientCreator\n         );\n \n         this.topicRouteService = new ClusterTopicRouteService(operationClientAPIFactory);\n@@ -105,7 +115,10 @@ public ClusterServiceManager(RPCHook rpcHook) {\n             1,\n             new ProxyClientRemotingProcessor(producerManager),\n             rpcHook,\n-            scheduledExecutorService);\n+            scheduledExecutorService,\n+            remotingClientCreator\n+        );\n+\n         this.clusterTransactionService = new ClusterTransactionService(this.topicRouteService, this.producerManager,\n             this.transactionClientAPIFactory);\n         this.proxyRelayService = new ClusterProxyRelayService(this.clusterTransactionService);\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/service/ServiceManagerFactory.java b/proxy/src/main/java/org/apache/rocketmq/proxy/service/ServiceManagerFactory.java\nindex c186752788d..e1252fe31fd 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/service/ServiceManagerFactory.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/service/ServiceManagerFactory.java\n@@ -17,7 +17,9 @@\n package org.apache.rocketmq.proxy.service;\n \n import org.apache.rocketmq.broker.BrokerController;\n+import org.apache.rocketmq.common.ObjectCreator;\n import org.apache.rocketmq.remoting.RPCHook;\n+import org.apache.rocketmq.remoting.RemotingClient;\n \n public class ServiceManagerFactory {\n     public static ServiceManager createForLocalMode(BrokerController brokerController) {\n@@ -29,10 +31,14 @@ public static ServiceManager createForLocalMode(BrokerController brokerControlle\n     }\n \n     public static ServiceManager createForClusterMode() {\n-        return createForClusterMode(null);\n+        return createForClusterMode(null, null);\n     }\n \n     public static ServiceManager createForClusterMode(RPCHook rpcHook) {\n-        return new ClusterServiceManager(rpcHook);\n+        return createForClusterMode(rpcHook, null);\n+    }\n+\n+    public static ServiceManager createForClusterMode(RPCHook rpcHook, ObjectCreator<RemotingClient> remotingClientCreator) {\n+        return new ClusterServiceManager(rpcHook, remotingClientCreator);\n     }\n }\n\ndiff --git a/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java b/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java\nindex d3f5a88cf2a..a4f23f181a3 100644\n--- a/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java\n+++ b/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingAbstract.java\n@@ -673,6 +673,10 @@ public void invokeOnewayImpl(final Channel channel, final RemotingCommand reques\n         }\n     }\n \n+    public HashMap<Integer, Pair<NettyRequestProcessor, ExecutorService>> getProcessorTable() {\n+        return processorTable;\n+    }\n+\n     class NettyEventExecutor extends ServiceThread {\n         private final LinkedBlockingQueue<NettyEvent> eventQueue = new LinkedBlockingQueue<>();\n \n\ndiff --git a/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingClient.java b/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingClient.java\nindex 6ac54aed6d2..e92809ccdff 100644\n--- a/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingClient.java\n+++ b/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingClient.java\n@@ -98,7 +98,7 @@ public class NettyRemotingClient extends NettyRemotingAbstract implements Remoti\n     private static final long LOCK_TIMEOUT_MILLIS = 3000;\n     private static final long MIN_CLOSE_TIMEOUT_MILLIS = 100;\n \n-    private final NettyClientConfig nettyClientConfig;\n+    protected final NettyClientConfig nettyClientConfig;\n     private final Bootstrap bootstrap = new Bootstrap();\n     private final EventLoopGroup eventLoopGroupWorker;\n     private final Lock lockChannelTables = new ReentrantLock();\n@@ -288,6 +288,13 @@ private Map.Entry<String, SocksProxyConfig> getProxy(String addr) {\n         return null;\n     }\n \n+    protected ChannelFuture doConnect(String addr) {\n+        String[] hostAndPort = getHostAndPort(addr);\n+        String host = hostAndPort[0];\n+        int port = Integer.parseInt(hostAndPort[1]);\n+        return fetchBootstrap(addr).connect(host, port);\n+    }\n+\n     private Bootstrap fetchBootstrap(String addr) {\n         Map.Entry<String, SocksProxyConfig> proxyEntry = getProxy(addr);\n         if (proxyEntry == null) {\n@@ -359,7 +366,7 @@ public void initChannel(SocketChannel ch) {\n     }\n \n     // Do not use RemotingHelper.string2SocketAddress(), it will directly resolve the domain\n-    private String[] getHostAndPort(String address) {\n+    protected String[] getHostAndPort(String address) {\n         int split = address.lastIndexOf(\"":\"");\n         return split < 0 ? new String[]{address} : new String[]{address.substring(0, split), address.substring(split + 1)};\n     }\n@@ -712,9 +719,7 @@ private ChannelFuture createChannelAsync(final String addr) throws InterruptedEx\n     }\n \n     private ChannelWrapper createChannel(String addr) {\n-        String[] hostAndPort = getHostAndPort(addr);\n-        ChannelFuture channelFuture = fetchBootstrap(addr)\n-            .connect(hostAndPort[0], Integer.parseInt(hostAndPort[1]));\n+        ChannelFuture channelFuture = doConnect(addr);\n         LOGGER.info(\""createChannel: begin to connect remote host[{}] asynchronously\"", addr);\n         ChannelWrapper cw = new ChannelWrapper(addr, channelFuture);\n         this.channelTables.put(addr, cw);\n@@ -1047,9 +1052,7 @@ public boolean reconnect(Channel channel) {\n                 try {\n                     if (isWrapperOf(channel)) {\n                         channelToClose = channelFuture;\n-                        String[] hostAndPort = getHostAndPort(channelAddress);\n-                        channelFuture = fetchBootstrap(channelAddress)\n-                            .connect(hostAndPort[0], Integer.parseInt(hostAndPort[1]));\n+                        channelFuture = doConnect(channelAddress);\n                         return true;\n                     } else {\n                         LOGGER.warn(\""channelWrapper has reconnect, so do nothing, now channelId={}, input channelId={}\"",getChannel().id(), channel.id());\n@@ -1119,15 +1122,14 @@ public void operationFail(final Throwable throwable) {\n         }\n     }\n \n-    class NettyClientHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n-\n+    public class NettyClientHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n         @Override\n         protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {\n             processMessageReceived(ctx, msg);\n         }\n     }\n \n-    class NettyConnectManageHandler extends ChannelDuplexHandler {\n+    public class NettyConnectManageHandler extends ChannelDuplexHandler {\n         @Override\n         public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress,\n             ChannelPromise promise) throws Exception {\n\ndiff --git a/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingServer.java b/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingServer.java\nindex cbf25c23c60..7ed804483be 100644\n--- a/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingServer.java\n+++ b/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingServer.java\n@@ -54,19 +54,6 @@\n import io.netty.util.Timeout;\n import io.netty.util.TimerTask;\n import io.netty.util.concurrent.DefaultEventExecutorGroup;\n-import java.io.IOException;\n-import java.net.InetSocketAddress;\n-import java.security.cert.CertificateException;\n-import java.time.Duration;\n-import java.util.List;\n-import java.util.NoSuchElementException;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n import org.apache.commons.collections.CollectionUtils;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.rocketmq.common.Pair;\n@@ -88,15 +75,28 @@\n import org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException;\n import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n \n-@SuppressWarnings(\""NullableProblems\"")\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.security.cert.CertificateException;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n public class NettyRemotingServer extends NettyRemotingAbstract implements RemotingServer {\n     private static final Logger log = LoggerFactory.getLogger(LoggerName.ROCKETMQ_REMOTING_NAME);\n     private static final Logger TRAFFIC_LOGGER = LoggerFactory.getLogger(LoggerName.ROCKETMQ_TRAFFIC_NAME);\n \n     private final ServerBootstrap serverBootstrap;\n-    private final EventLoopGroup eventLoopGroupSelector;\n-    private final EventLoopGroup eventLoopGroupBoss;\n-    private final NettyServerConfig nettyServerConfig;\n+    protected final EventLoopGroup eventLoopGroupSelector;\n+    protected final EventLoopGroup eventLoopGroupBoss;\n+    protected final NettyServerConfig nettyServerConfig;\n \n     private final ExecutorService publicExecutor;\n     private final ScheduledExecutorService scheduledExecutorService;\n@@ -120,18 +120,18 @@ public class NettyRemotingServer extends NettyRemotingAbstract implements Remoti\n     public static final String FILE_REGION_ENCODER_NAME = \""fileRegionEncoder\"";\n \n     // sharable handlers\n-    private TlsModeHandler tlsModeHandler;\n-    private NettyEncoder encoder;\n-    private NettyConnectManageHandler connectionManageHandler;\n-    private NettyServerHandler serverHandler;\n-    private RemotingCodeDistributionHandler distributionHandler;\n+    protected final TlsModeHandler tlsModeHandler = new TlsModeHandler(TlsSystemConfig.tlsMode);\n+    protected final NettyEncoder encoder = new NettyEncoder();\n+    protected final NettyConnectManageHandler connectionManageHandler = new NettyConnectManageHandler();\n+    protected final NettyServerHandler serverHandler = new NettyServerHandler();\n+    protected final RemotingCodeDistributionHandler distributionHandler = new RemotingCodeDistributionHandler();\n \n     public NettyRemotingServer(final NettyServerConfig nettyServerConfig) {\n         this(nettyServerConfig, null);\n     }\n \n     public NettyRemotingServer(final NettyServerConfig nettyServerConfig,\n-        final ChannelEventListener channelEventListener) {\n+                               final ChannelEventListener channelEventListener) {\n         super(nettyServerConfig.getServerOnewaySemaphoreValue(), nettyServerConfig.getServerAsyncSemaphoreValue());\n         this.serverBootstrap = new ServerBootstrap();\n         this.nettyServerConfig = nettyServerConfig;\n@@ -140,13 +140,13 @@ public NettyRemotingServer(final NettyServerConfig nettyServerConfig,\n         this.publicExecutor = buildPublicExecutor(nettyServerConfig);\n         this.scheduledExecutorService = buildScheduleExecutor();\n \n-        this.eventLoopGroupBoss = buildBossEventLoopGroup();\n+        this.eventLoopGroupBoss = buildEventLoopGroupBoss();\n         this.eventLoopGroupSelector = buildEventLoopGroupSelector();\n \n         loadSslContext();\n     }\n \n-    private EventLoopGroup buildEventLoopGroupSelector() {\n+    protected EventLoopGroup buildEventLoopGroupSelector() {\n         if (useEpoll()) {\n             return new EpollEventLoopGroup(nettyServerConfig.getServerSelectorThreads(), new ThreadFactoryImpl(\""NettyServerEPOLLSelector_\""));\n         } else {\n@@ -154,7 +154,7 @@ private EventLoopGroup buildEventLoopGroupSelector() {\n         }\n     }\n \n-    private EventLoopGroup buildBossEventLoopGroup() {\n+    protected EventLoopGroup buildEventLoopGroupBoss() {\n         if (useEpoll()) {\n             return new EpollEventLoopGroup(1, new ThreadFactoryImpl(\""NettyEPOLLBoss_\""));\n         } else {\n@@ -197,13 +197,7 @@ private boolean useEpoll() {\n             && Epoll.isAvailable();\n     }\n \n-    @Override\n-    public void start() {\n-        this.defaultEventExecutorGroup = new DefaultEventExecutorGroup(nettyServerConfig.getServerWorkerThreads(),\n-            new ThreadFactoryImpl(\""NettyServerCodecThread_\""));\n-\n-        prepareSharableHandlers();\n-\n+    protected void initServerBootstrap(ServerBootstrap serverBootstrap) {\n         serverBootstrap.group(this.eventLoopGroupBoss, this.eventLoopGroupSelector)\n             .channel(useEpoll() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 1024)\n@@ -220,6 +214,14 @@ public void initChannel(SocketChannel ch) {\n             });\n \n         addCustomConfig(serverBootstrap);\n+    }\n+\n+    @Override\n+    public void start() {\n+        this.defaultEventExecutorGroup = new DefaultEventExecutorGroup(nettyServerConfig.getServerWorkerThreads(),\n+            new ThreadFactoryImpl(\""NettyServerCodecThread_\""));\n+\n+        initServerBootstrap(serverBootstrap);\n \n         try {\n             ChannelFuture sync = serverBootstrap.bind().sync();\n@@ -411,14 +413,6 @@ public ExecutorService getCallbackExecutor() {\n         return this.publicExecutor;\n     }\n \n-    private void prepareSharableHandlers() {\n-        tlsModeHandler = new TlsModeHandler(TlsSystemConfig.tlsMode);\n-        encoder = new NettyEncoder();\n-        connectionManageHandler = new NettyConnectManageHandler();\n-        serverHandler = new NettyServerHandler();\n-        distributionHandler = new RemotingCodeDistributionHandler();\n-    }\n-\n     private void printRemotingCodeDistribution() {\n         if (distributionHandler != null) {\n             String inBoundSnapshotString = distributionHandler.getInBoundSnapshotString();\n@@ -469,8 +463,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> o\n                 }\n                 if (detectionResult.state() == ProtocolDetectionState.DETECTED) {\n                     ctx.pipeline().addAfter(defaultEventExecutorGroup, ctx.name(), HA_PROXY_DECODER, new HAProxyMessageDecoder())\n-                            .addAfter(defaultEventExecutorGroup, HA_PROXY_DECODER, HA_PROXY_HANDLER, new HAProxyMessageHandler())\n-                            .addAfter(defaultEventExecutorGroup, HA_PROXY_HANDLER, TLS_MODE_HANDLER, tlsModeHandler);\n+                        .addAfter(defaultEventExecutorGroup, HA_PROXY_DECODER, HA_PROXY_HANDLER, new HAProxyMessageHandler())\n+                        .addAfter(defaultEventExecutorGroup, HA_PROXY_HANDLER, TLS_MODE_HANDLER, tlsModeHandler);\n                 } else {\n                     ctx.pipeline().addAfter(defaultEventExecutorGroup, ctx.name(), TLS_MODE_HANDLER, tlsModeHandler);\n                 }\n@@ -664,7 +658,7 @@ class SubRemotingServer extends NettyRemotingAbstract implements RemotingServer\n \n         @Override\n         public void registerProcessor(final int requestCode, final NettyRequestProcessor processor,\n-            final ExecutorService executor) {\n+                                      final ExecutorService executor) {\n             ExecutorService executorThis = executor;\n             if (null == executor) {\n                 executorThis = NettyRemotingServer.this.publicExecutor;\n@@ -708,19 +702,19 @@ public void removeRemotingServer(final int port) {\n \n         @Override\n         public RemotingCommand invokeSync(final Channel channel, final RemotingCommand request,\n-            final long timeoutMillis) throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException {\n+                                          final long timeoutMillis) throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException {\n             return this.invokeSyncImpl(channel, request, timeoutMillis);\n         }\n \n         @Override\n         public void invokeAsync(final Channel channel, final RemotingCommand request, final long timeoutMillis,\n-            final InvokeCallback invokeCallback) throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException {\n+                                final InvokeCallback invokeCallback) throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException {\n             this.invokeAsyncImpl(channel, request, timeoutMillis, invokeCallback);\n         }\n \n         @Override\n         public void invokeOneway(final Channel channel, final RemotingCommand request,\n-            final long timeoutMillis) throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException {\n+                                 final long timeoutMillis) throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException {\n             this.invokeOnewayImpl(channel, request, timeoutMillis);\n         }\n \n"", ""test_patch"": ""diff --git a/broker/src/test/java/org/apache/rocketmq/broker/BrokerControllerTest.java b/broker/src/test/java/org/apache/rocketmq/broker/BrokerControllerTest.java\nindex 6035a20acb2..3ce1fe3dbdf 100644\n--- a/broker/src/test/java/org/apache/rocketmq/broker/BrokerControllerTest.java\n+++ b/broker/src/test/java/org/apache/rocketmq/broker/BrokerControllerTest.java\n@@ -26,11 +26,18 @@\n import org.apache.rocketmq.common.BrokerConfig;\n import org.apache.rocketmq.common.UtilAll;\n import org.apache.rocketmq.common.future.FutureTaskExt;\n+import org.apache.rocketmq.remoting.RPCHook;\n+import org.apache.rocketmq.remoting.RemotingServer;\n import org.apache.rocketmq.remoting.netty.NettyClientConfig;\n+import org.apache.rocketmq.remoting.netty.NettyRemotingAbstract;\n+import org.apache.rocketmq.remoting.netty.NettyRemotingServer;\n import org.apache.rocketmq.remoting.netty.NettyServerConfig;\n import org.apache.rocketmq.remoting.netty.RequestTask;\n+import org.apache.rocketmq.remoting.pipeline.RequestPipeline;\n+import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n import org.apache.rocketmq.store.config.MessageStoreConfig;\n import org.junit.After;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n \n@@ -94,4 +101,43 @@ public void run() {\n         TimeUnit.MILLISECONDS.sleep(headSlowTimeMills);\n         assertThat(brokerController.headSlowTimeMills(queue)).isGreaterThanOrEqualTo(headSlowTimeMills);\n     }\n+\n+    @Test\n+    public void testCustomRemotingServer() throws CloneNotSupportedException {\n+        final RemotingServer mockRemotingServer = new NettyRemotingServer(nettyServerConfig);\n+        final String mockRemotingServerName = \""MOCK_REMOTING_SERVER\"";\n+\n+        BrokerController brokerController = new BrokerController(brokerConfig, nettyServerConfig, new NettyClientConfig(), messageStoreConfig);\n+        brokerController.setRemotingServerByName(mockRemotingServerName, mockRemotingServer);\n+        brokerController.initializeRemotingServer();\n+\n+        final RPCHook rpcHook = new RPCHook() {\n+            @Override\n+            public void doBeforeRequest(String remoteAddr, RemotingCommand request) {\n+\n+            }\n+\n+            @Override\n+            public void doAfterResponse(String remoteAddr, RemotingCommand request, RemotingCommand response) {\n+\n+            }\n+        };\n+        brokerController.registerServerRPCHook(rpcHook);\n+\n+        // setRequestPipelineTest\n+        final RequestPipeline requestPipeline = (ctx, request) -> {\n+\n+        };\n+        brokerController.setRequestPipeline(requestPipeline);\n+\n+        NettyRemotingAbstract tcpRemotingServer = (NettyRemotingAbstract) brokerController.getRemotingServer();\n+        Assert.assertTrue(tcpRemotingServer.getRPCHook().contains(rpcHook));\n+\n+        NettyRemotingAbstract fastRemotingServer = (NettyRemotingAbstract) brokerController.getFastRemotingServer();\n+        Assert.assertTrue(fastRemotingServer.getRPCHook().contains(rpcHook));\n+\n+        NettyRemotingAbstract mockRemotingServer1 = (NettyRemotingAbstract) brokerController.getRemotingServerByName(mockRemotingServerName);\n+        Assert.assertTrue(mockRemotingServer1.getRPCHook().contains(rpcHook));\n+        Assert.assertSame(mockRemotingServer, mockRemotingServer1);\n+    }\n }\n\ndiff --git a/client/src/test/java/org/apache/rocketmq/client/impl/MQClientAPIImplTest.java b/client/src/test/java/org/apache/rocketmq/client/impl/MQClientAPIImplTest.java\nindex c76d0c734a0..6cb96df05f4 100644\n--- a/client/src/test/java/org/apache/rocketmq/client/impl/MQClientAPIImplTest.java\n+++ b/client/src/test/java/org/apache/rocketmq/client/impl/MQClientAPIImplTest.java\n@@ -35,6 +35,7 @@\n import org.apache.rocketmq.client.producer.SendResult;\n import org.apache.rocketmq.client.producer.SendStatus;\n import org.apache.rocketmq.common.MixAll;\n+import org.apache.rocketmq.common.ObjectCreator;\n import org.apache.rocketmq.common.Pair;\n import org.apache.rocketmq.common.PlainAccessConfig;\n import org.apache.rocketmq.common.TopicConfig;\n@@ -59,6 +60,7 @@\n import org.apache.rocketmq.remoting.exception.RemotingSendRequestException;\n import org.apache.rocketmq.remoting.exception.RemotingTimeoutException;\n import org.apache.rocketmq.remoting.netty.NettyClientConfig;\n+import org.apache.rocketmq.remoting.netty.NettyRemotingClient;\n import org.apache.rocketmq.remoting.netty.ResponseFuture;\n import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n import org.apache.rocketmq.remoting.protocol.RemotingSerializable;\n@@ -2104,6 +2106,48 @@ public void operationFail(Throwable throwable) {\n         done.await();\n     }\n \n+    @Test\n+    public void testMQClientAPIImplWithoutObjectCreator() {\n+        MQClientAPIImpl clientAPI = new MQClientAPIImpl(\n+            new NettyClientConfig(),\n+            null,\n+            null,\n+            new ClientConfig(),\n+            null,\n+            null\n+        );\n+        RemotingClient remotingClient1 = clientAPI.getRemotingClient();\n+        Assert.assertTrue(remotingClient1 instanceof NettyRemotingClient);\n+    }\n+\n+    @Test\n+    public void testMQClientAPIImplWithObjectCreator() {\n+        ObjectCreator<RemotingClient> clientObjectCreator = args -> new MockRemotingClientTest((NettyClientConfig) args[0]);\n+        final NettyClientConfig nettyClientConfig = new NettyClientConfig();\n+        MQClientAPIImpl clientAPI = new MQClientAPIImpl(\n+            nettyClientConfig,\n+            null,\n+            null,\n+            new ClientConfig(),\n+            null,\n+            clientObjectCreator\n+        );\n+        RemotingClient remotingClient1 = clientAPI.getRemotingClient();\n+        Assert.assertTrue(remotingClient1 instanceof MockRemotingClientTest);\n+        MockRemotingClientTest remotingClientTest = (MockRemotingClientTest) remotingClient1;\n+        Assert.assertSame(remotingClientTest.getNettyClientConfig(), nettyClientConfig);\n+    }\n+\n+    private static class MockRemotingClientTest extends NettyRemotingClient {\n+        public MockRemotingClientTest(NettyClientConfig nettyClientConfig) {\n+            super(nettyClientConfig);\n+        }\n+\n+        public NettyClientConfig getNettyClientConfig() {\n+            return nettyClientConfig;\n+        }\n+    }\n+\n     private Properties createProperties() {\n         Properties result = new Properties();\n         result.put(\""key\"", \""value\"");\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""apache__rocketmq-9113"", ""pr_id"": 9113, ""issue_id"": 9112, ""repo"": ""apache/rocketmq"", ""problem_statement"": ""[Bug] Speedup revive scan in Pop Consumption and support server side reset offset\n### Before Creating the Bug Report\r\n\r\n- [X] I found a bug, not just asking a question, which should be created in [GitHub Discussions](https://github.com/apache/rocketmq/discussions).\r\n- [X] I have searched the [GitHub Issues](https://github.com/apache/rocketmq/issues) and [GitHub Discussions](https://github.com/apache/rocketmq/discussions)  of this repository and believe that this is not a duplicate.\r\n- [X] I have confirmed that this bug belongs to the current repository, not other repositories of RocketMQ.\r\n\r\n### Runtime platform environment\r\n\r\nLinux 5.10\r\n\r\n### RocketMQ version\r\n\r\nonly develop branch about version 5.3.1\r\n\r\n### JDK Version\r\n\r\nJDK11\r\n\r\n### Describe the Bug\r\n\r\nThe current development branch uses the rocksdb seek first API, which has certain performance issues. The related issues are as follows:\r\n\r\n1. https://github.com/aptos-labs/aptos-core/pull/3032\r\n2. https://github.com/facebook/rocksdb/issues/10300\r\n3. https://github.com/facebook/rocksdb/issues/10510\r\n\r\nSolution:\r\n> Actually, our application receives a delete request every time it is invoked by the user, and this is not something we can control. In some scenarios, the user will delete all keys under one prefix one by one, and the order of deletion is not consecutive, so we cannot convert the point deletes into range deletes.\r\n\r\nRocksdb official description: \r\nhttps://github.com/facebook/rocksdb/wiki/Prefix-Seek\r\n\r\nWhen the server-side offset feature is enabled, the Pop KV implementation does not effectively reset the offset.\r\n\r\n### Steps to Reproduce\r\n\r\nI have written a test case, We can observe that using the seek first API results in higher latency.\r\n\r\n![image](https://github.com/user-attachments/assets/07551da3-fef4-4b9e-a276-5b7f3aafafd1)\r\n\r\n### What Did You Expect to See?\r\n\r\n1. The seek API has stable latency and fast\r\n2. We can reset offset when server offset feature is enable\r\n\r\n### What Did You See Instead?\r\n\r\nNone\r\n\r\n### Additional Context\r\n\r\n_No response_"", ""issue_word_count"": 316, ""test_files_count"": 2, ""non_test_files_count"": 4, ""pr_changed_files"": [""broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerKVStore.java"", ""broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerRocksdbStore.java"", ""broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerService.java"", ""broker/src/test/java/org/apache/rocketmq/broker/pop/PopConsumerRocksdbStoreTest.java"", ""broker/src/test/java/org/apache/rocketmq/broker/pop/PopConsumerServiceTest.java"", ""common/src/main/java/org/apache/rocketmq/common/config/AbstractRocksDBStorage.java""], ""pr_changed_test_files"": [""broker/src/test/java/org/apache/rocketmq/broker/pop/PopConsumerRocksdbStoreTest.java"", ""broker/src/test/java/org/apache/rocketmq/broker/pop/PopConsumerServiceTest.java""], ""base_commit"": ""9ce83452a62f3fb910454bab92c092c83d561bdb"", ""head_commit"": ""d2e967c8162f15b1f74e1abb9924edceb1caa6e8"", ""repo_url"": ""https://github.com/apache/rocketmq/pull/9113"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/apache__rocketmq/9113"", ""dockerfile"": """", ""pr_merged_at"": ""2025-01-08T15:00:22.000Z"", ""patch"": ""diff --git a/broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerKVStore.java b/broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerKVStore.java\nindex 5569abe3db7..33072d699b5 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerKVStore.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerKVStore.java\n@@ -49,10 +49,13 @@ public interface PopConsumerKVStore {\n     void deleteRecords(List<PopConsumerRecord> consumerRecordList);\n \n     /**\n-     * Scans and returns a list of expired consumer records before the current time.\n-     * @param currentTime The current revive checkpoint timestamp.\n+     * Scans and returns a list of expired consumer records within the specified time range.\n+     * @param lowerTime The start time (inclusive) of the time range to search, in milliseconds.\n+     * @param upperTime The end time (exclusive) of the time range to search, in milliseconds.\n      * @param maxCount The maximum number of records to return.\n-     * @return A list of expired consumer records.\n+     *                 Even if more records match the criteria, only this many will be returned.\n+     * @return A list of expired consumer records within the specified time range.\n+     *         If no matching records are found, an empty list is returned.\n      */\n-    List<PopConsumerRecord> scanExpiredRecords(long currentTime, int maxCount);\n+    List<PopConsumerRecord> scanExpiredRecords(long lowerTime, long upperTime, int maxCount);\n }\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerRocksdbStore.java b/broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerRocksdbStore.java\nindex f2a617b4084..7ab276a4185 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerRocksdbStore.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerRocksdbStore.java\n@@ -28,9 +28,11 @@\n import org.rocksdb.ColumnFamilyHandle;\n import org.rocksdb.ColumnFamilyOptions;\n import org.rocksdb.CompactRangeOptions;\n+import org.rocksdb.ReadOptions;\n import org.rocksdb.RocksDB;\n import org.rocksdb.RocksDBException;\n import org.rocksdb.RocksIterator;\n+import org.rocksdb.Slice;\n import org.rocksdb.WriteBatch;\n import org.rocksdb.WriteOptions;\n import org.slf4j.Logger;\n@@ -43,7 +45,7 @@ public class PopConsumerRocksdbStore extends AbstractRocksDBStorage implements P\n \n     private WriteOptions writeOptions;\n     private WriteOptions deleteOptions;\n-    private ColumnFamilyHandle columnFamilyHandle;\n+    protected ColumnFamilyHandle columnFamilyHandle;\n \n     public PopConsumerRocksdbStore(String filePath) {\n         super(filePath);\n@@ -60,8 +62,7 @@ protected void initOptions() {\n         this.writeOptions.setNoSlowdown(false);\n \n         this.deleteOptions = new WriteOptions();\n-        this.deleteOptions.setSync(false);\n-        this.deleteOptions.setLowPri(true);\n+        this.deleteOptions.setSync(true);\n         this.deleteOptions.setDisableWAL(false);\n         this.deleteOptions.setNoSlowdown(false);\n \n@@ -135,18 +136,19 @@ public void deleteRecords(List<PopConsumerRecord> consumerRecordList) {\n     }\n \n     @Override\n-    public List<PopConsumerRecord> scanExpiredRecords(long currentTime, int maxCount) {\n+    // https://github.com/facebook/rocksdb/issues/10300\n+    public List<PopConsumerRecord> scanExpiredRecords(long lower, long upper, int maxCount) {\n         // In RocksDB, we can use SstPartitionerFixedPrefixFactory in cfOptions\n         // and new ColumnFamilyOptions().useFixedLengthPrefixExtractor() to\n         // configure prefix indexing to improve the performance of scans.\n         // However, in the current implementation, this is not the bottleneck.\n         List<PopConsumerRecord> consumerRecordList = new ArrayList<>();\n-        try (RocksIterator iterator = db.newIterator(this.columnFamilyHandle)) {\n-            iterator.seekToFirst();\n+        try (ReadOptions scanOptions = new ReadOptions()\n+            .setIterateLowerBound(new Slice(ByteBuffer.allocate(Long.BYTES).putLong(lower).array()))\n+            .setIterateUpperBound(new Slice(ByteBuffer.allocate(Long.BYTES).putLong(upper).array()));\n+             RocksIterator iterator = db.newIterator(this.columnFamilyHandle, scanOptions)) {\n+            iterator.seek(ByteBuffer.allocate(Long.BYTES).putLong(lower).array());\n             while (iterator.isValid() && consumerRecordList.size() < maxCount) {\n-                if (ByteBuffer.wrap(iterator.key()).getLong() > currentTime) {\n-                    break;\n-                }\n                 consumerRecordList.add(PopConsumerRecord.decode(iterator.value()));\n                 iterator.next();\n             }\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerService.java b/broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerService.java\nindex 647e3d6ff7f..1f0125412a7 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerService.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/pop/PopConsumerService.java\n@@ -75,6 +75,7 @@ public class PopConsumerService extends ServiceThread {\n     private final AtomicBoolean consumerRunning;\n     private final BrokerConfig brokerConfig;\n     private final BrokerController brokerController;\n+    private final AtomicLong currentTime;\n     private final AtomicLong lastCleanupLockTime;\n     private final PopConsumerCache popConsumerCache;\n     private final PopConsumerKVStore popConsumerStore;\n@@ -88,6 +89,7 @@ public PopConsumerService(BrokerController brokerController) {\n \n         this.consumerRunning = new AtomicBoolean(false);\n         this.requestCountTable = new ConcurrentHashMap<>();\n+        this.currentTime = new AtomicLong(TimeUnit.SECONDS.toMillis(3));\n         this.lastCleanupLockTime = new AtomicLong(System.currentTimeMillis());\n         this.consumerLockService = new PopConsumerLockService(TimeUnit.MINUTES.toMillis(2));\n         this.popConsumerStore = new PopConsumerRocksdbStore(Paths.get(\n@@ -195,12 +197,27 @@ public PopConsumerContext addGetMessageResult(PopConsumerContext context, GetMes\n         return context;\n     }\n \n+    public Long getPopOffset(String groupId, String topicId, int queueId) {\n+        Long resetOffset =\n+            this.brokerController.getConsumerOffsetManager().queryThenEraseResetOffset(topicId, groupId, queueId);\n+        if (resetOffset != null) {\n+            this.clearCache(groupId, topicId, queueId);\n+            this.brokerController.getConsumerOrderInfoManager().clearBlock(topicId, groupId, queueId);\n+            this.brokerController.getConsumerOffsetManager()\n+                .commitOffset(\""ResetPopOffset\"", groupId, topicId, queueId, resetOffset);\n+        }\n+        return resetOffset;\n+    }\n+\n     public CompletableFuture<GetMessageResult> getMessageAsync(String clientHost,\n         String groupId, String topicId, int queueId, long offset, int batchSize, MessageFilter filter) {\n \n         log.debug(\""PopConsumerService getMessageAsync, groupId={}, topicId={}, queueId={}, offset={}, batchSize={}, filter={}\"",\n             groupId, topicId, offset, queueId, batchSize, filter != null);\n \n+        Long resetOffset = this.getPopOffset(groupId, topicId, queueId);\n+        final long currentOffset = resetOffset != null ? resetOffset : offset;\n+\n         CompletableFuture<GetMessageResult> getMessageFuture =\n             brokerController.getMessageStore().getMessageAsync(groupId, topicId, queueId, offset, batchSize, filter);\n \n@@ -223,7 +240,7 @@ public CompletableFuture<GetMessageResult> getMessageAsync(String clientHost,\n \n                 log.warn(\""PopConsumerService getMessageAsync, initial offset because store is no correct, \"" +\n                         \""groupId={}, topicId={}, queueId={}, batchSize={}, offset={}->{}\"",\n-                    groupId, topicId, queueId, batchSize, offset, result.getNextBeginOffset());\n+                    groupId, topicId, queueId, batchSize, currentOffset, result.getNextBeginOffset());\n \n                 return brokerController.getMessageStore().getMessageAsync(\n                     groupId, topicId, queueId, result.getNextBeginOffset(), batchSize, filter);\n@@ -482,10 +499,12 @@ public void clearCache(String groupId, String topicId, int queueId) {\n         }\n     }\n \n-    public long revive(long currentTime, int maxCount) {\n+    public long revive(AtomicLong currentTime, int maxCount) {\n         Stopwatch stopwatch = Stopwatch.createStarted();\n-        List<PopConsumerRecord> consumerRecords =\n-            this.popConsumerStore.scanExpiredRecords(currentTime, maxCount);\n+        long upperTime = System.currentTimeMillis() - 50L;\n+        List<PopConsumerRecord> consumerRecords = this.popConsumerStore.scanExpiredRecords(\n+                currentTime.get() - TimeUnit.SECONDS.toMillis(3), upperTime, maxCount);\n+        long scanCostTime = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n         Queue<PopConsumerRecord> failureList = new LinkedBlockingQueue<>();\n         List<CompletableFuture<?>> futureList = new ArrayList<>(consumerRecords.size());\n \n@@ -497,9 +516,9 @@ public long revive(long currentTime, int maxCount) {\n                         long backoffInterval = 1000L * REWRITE_INTERVALS_IN_SECONDS[\n                             Math.min(REWRITE_INTERVALS_IN_SECONDS.length, record.getAttemptTimes())];\n                         long nextInvisibleTime = record.getInvisibleTime() + backoffInterval;\n-                        PopConsumerRecord retryRecord = new PopConsumerRecord(record.getPopTime(), record.getGroupId(),\n-                            record.getTopicId(), record.getQueueId(), record.getRetryFlag(), nextInvisibleTime,\n-                            record.getOffset(), record.getAttemptId());\n+                        PopConsumerRecord retryRecord = new PopConsumerRecord(System.currentTimeMillis(),\n+                            record.getGroupId(), record.getTopicId(), record.getQueueId(),\n+                            record.getRetryFlag(), nextInvisibleTime, record.getOffset(), record.getAttemptId());\n                         retryRecord.setAttemptTimes(record.getAttemptTimes() + 1);\n                         failureList.add(retryRecord);\n                         log.warn(\""PopConsumerService revive backoff retry, record={}\"", retryRecord);\n@@ -513,14 +532,20 @@ public long revive(long currentTime, int maxCount) {\n         CompletableFuture.allOf(futureList.toArray(new CompletableFuture[0])).join();\n         this.popConsumerStore.writeRecords(new ArrayList<>(failureList));\n         this.popConsumerStore.deleteRecords(consumerRecords);\n+        currentTime.set(consumerRecords.isEmpty() ?\n+            upperTime : consumerRecords.get(consumerRecords.size() - 1).getVisibilityTimeout());\n \n         if (brokerConfig.isEnablePopBufferMerge()) {\n-            log.info(\""PopConsumerService, key size={}, cache size={}, revive count={}, failure count={}, cost={}ms\"",\n-                popConsumerCache.getCacheKeySize(), popConsumerCache.getCacheSize(), consumerRecords.size(),\n-                failureList.size(), stopwatch.elapsed(TimeUnit.MILLISECONDS));\n+            log.info(\""PopConsumerService, key size={}, cache size={}, revive count={}, failure count={}, \"" +\n+                    \""behindInMillis={}, scanInMillis={}, costInMillis={}\"",\n+                popConsumerCache.getCacheKeySize(), popConsumerCache.getCacheSize(),\n+                consumerRecords.size(), failureList.size(), upperTime - currentTime.get(),\n+                scanCostTime, stopwatch.elapsed(TimeUnit.MILLISECONDS));\n         } else {\n-            log.info(\""PopConsumerService, revive count={}, failure count={}, cost={}ms\"",\n-                consumerRecords.size(), failureList.size(), stopwatch.elapsed(TimeUnit.MILLISECONDS));\n+            log.info(\""PopConsumerService, revive count={}, failure count={}, \"" +\n+                    \""behindInMillis={}, scanInMillis={}, costInMillis={}\"",\n+                consumerRecords.size(), failureList.size(), upperTime - currentTime.get(),\n+                scanCostTime, stopwatch.elapsed(TimeUnit.MILLISECONDS));\n         }\n \n         return consumerRecords.size();\n@@ -588,11 +613,6 @@ public boolean reviveRetry(PopConsumerRecord record, MessageExt messageExt) {\n         PutMessageResult putMessageResult =\n             brokerController.getEscapeBridge().putMessageToSpecificQueue(msgInner);\n \n-        if (brokerConfig.isEnablePopLog()) {\n-            log.debug(\""PopConsumerService revive retry msg, put status={}, ck={}, delay={}ms\"",\n-                putMessageResult, JSON.toJSONString(record), System.currentTimeMillis() - record.getVisibilityTimeout());\n-        }\n-\n         if (putMessageResult.getAppendMessageResult() == null ||\n             putMessageResult.getAppendMessageResult().getStatus() != AppendMessageStatus.PUT_OK) {\n             log.error(\""PopConsumerService revive retry msg error, put status={}, ck={}, delay={}ms\"",\n@@ -616,7 +636,7 @@ public synchronized void transferToFsStore() {\n         while (true) {\n             try {\n                 List<PopConsumerRecord> consumerRecords = this.popConsumerStore.scanExpiredRecords(\n-                    Long.MAX_VALUE, brokerConfig.getPopReviveMaxReturnSizePerRead());\n+                    0, Long.MAX_VALUE, brokerConfig.getPopReviveMaxReturnSizePerRead());\n                 if (consumerRecords == null || consumerRecords.isEmpty()) {\n                     break;\n                 }\n@@ -695,7 +715,7 @@ public void run() {\n         while (!isStopped()) {\n             try {\n                 // to prevent concurrency issues during read and write operations\n-                long reviveCount = this.revive(System.currentTimeMillis() - 50L,\n+                long reviveCount = this.revive(this.currentTime,\n                     brokerConfig.getPopReviveMaxReturnSizePerRead());\n \n                 long current = System.currentTimeMillis();\n@@ -704,7 +724,7 @@ public void run() {\n                     this.lastCleanupLockTime.set(current);\n                 }\n \n-                if (reviveCount == 0) {\n+                if (reviveCount < brokerConfig.getPopReviveMaxReturnSizePerRead()) {\n                     this.waitForRunning(500);\n                 }\n             } catch (Exception e) {\n\ndiff --git a/common/src/main/java/org/apache/rocketmq/common/config/AbstractRocksDBStorage.java b/common/src/main/java/org/apache/rocketmq/common/config/AbstractRocksDBStorage.java\nindex 48ba4b8086c..347d92304dc 100644\n--- a/common/src/main/java/org/apache/rocketmq/common/config/AbstractRocksDBStorage.java\n+++ b/common/src/main/java/org/apache/rocketmq/common/config/AbstractRocksDBStorage.java\n@@ -365,7 +365,7 @@ public synchronized boolean start() {\n         }\n         if (postLoad()) {\n             this.loaded = true;\n-            LOGGER.info(\""RocksDB[{}] starts OK\"", this.dbPath);\n+            LOGGER.info(\""RocksDB [{}] starts OK\"", this.dbPath);\n             this.closed = false;\n             return true;\n         } else {\n@@ -437,9 +437,9 @@ public synchronized boolean shutdown() {\n             this.options = null;\n \n             this.loaded = false;\n-            LOGGER.info(\""shutdown OK. {}\"", this.dbPath);\n+            LOGGER.info(\""RocksDB shutdown OK. {}\"", this.dbPath);\n         } catch (Exception e) {\n-            LOGGER.error(\""shutdown Failed. {}\"", this.dbPath, e);\n+            LOGGER.error(\""RocksDB shutdown failed. {}\"", this.dbPath, e);\n             return false;\n         }\n         return true;\n"", ""test_patch"": ""diff --git a/broker/src/test/java/org/apache/rocketmq/broker/pop/PopConsumerRocksdbStoreTest.java b/broker/src/test/java/org/apache/rocketmq/broker/pop/PopConsumerRocksdbStoreTest.java\nindex 5facaeb55f1..3c2b190d1cd 100644\n--- a/broker/src/test/java/org/apache/rocketmq/broker/pop/PopConsumerRocksdbStoreTest.java\n+++ b/broker/src/test/java/org/apache/rocketmq/broker/pop/PopConsumerRocksdbStoreTest.java\n@@ -16,18 +16,26 @@\n  */\n package org.apache.rocketmq.broker.pop;\n \n+import com.google.common.base.Stopwatch;\n import java.io.File;\n import java.io.IOException;\n+import java.lang.reflect.Field;\n import java.nio.file.Paths;\n+import java.util.ArrayList;\n import java.util.List;\n import java.util.UUID;\n import java.util.concurrent.TimeUnit;\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n import org.apache.commons.io.FileUtils;\n+import org.apache.rocketmq.common.config.AbstractRocksDBStorage;\n import org.apache.rocketmq.common.constant.LoggerName;\n+import org.apache.rocketmq.tieredstore.util.MessageStoreUtil;\n import org.junit.Assert;\n+import org.junit.Ignore;\n import org.junit.Test;\n+import org.rocksdb.RocksDB;\n+import org.rocksdb.RocksIterator;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -85,18 +93,101 @@ public void rocksdbStoreWriteDeleteTest() {\n             .collect(Collectors.toList()));\n \n         List<PopConsumerRecord> consumerRecords =\n-            consumerStore.scanExpiredRecords(20002, 2);\n+            consumerStore.scanExpiredRecords(0, 20002, 2);\n         Assert.assertEquals(2, consumerRecords.size());\n         consumerStore.deleteRecords(consumerRecords);\n \n-        consumerRecords = consumerStore.scanExpiredRecords(20002, 2);\n+        consumerRecords = consumerStore.scanExpiredRecords(0, 20003, 2);\n         Assert.assertEquals(1, consumerRecords.size());\n         consumerStore.deleteRecords(consumerRecords);\n \n-        consumerRecords = consumerStore.scanExpiredRecords(20004, 3);\n+        consumerRecords = consumerStore.scanExpiredRecords(0, 20005, 3);\n         Assert.assertEquals(2, consumerRecords.size());\n \n         consumerStore.shutdown();\n         deleteStoreDirectory(filePath);\n     }\n+\n+    private long getDirectorySizeRecursive(File directory) {\n+        long size = 0;\n+        File[] files = directory.listFiles();\n+        if (files != null) {\n+            for (File file : files) {\n+                if (file.isFile()) {\n+                    size += file.length();\n+                } else if (file.isDirectory()) {\n+                    size += getDirectorySizeRecursive(file);\n+                }\n+            }\n+        }\n+        return size;\n+    }\n+\n+    @Test\n+    @Ignore\n+    @SuppressWarnings(\""ConstantValue\"")\n+    public void tombstoneDeletionTest() throws IllegalAccessException, NoSuchFieldException {\n+        PopConsumerRocksdbStore rocksdbStore = new PopConsumerRocksdbStore(getRandomStorePath());\n+        rocksdbStore.start();\n+\n+        int iterCount = 1000 * 1000;\n+        boolean useSeekFirstDelete = false;\n+        Field dbField = AbstractRocksDBStorage.class.getDeclaredField(\""db\"");\n+        dbField.setAccessible(true);\n+        RocksDB rocksDB = (RocksDB) dbField.get(rocksdbStore);\n+\n+        long currentTime = 0L;\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        for (int i = 0; i < iterCount; i++) {\n+            List<PopConsumerRecord> records = new ArrayList<>();\n+            for (int j = 0; j < 1000; j++) {\n+                PopConsumerRecord record = getConsumerRecord();\n+                record.setPopTime((long) i * iterCount + j);\n+                record.setGroupId(\""GroupTest\"");\n+                record.setTopicId(\""TopicTest\"");\n+                record.setQueueId(i % 10);\n+                record.setRetryFlag(0);\n+                record.setInvisibleTime(TimeUnit.SECONDS.toMillis(30));\n+                record.setOffset(i);\n+                records.add(record);\n+            }\n+            rocksdbStore.writeRecords(records);\n+\n+            long start = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n+            List<PopConsumerRecord> deleteList = new ArrayList<>();\n+            if (useSeekFirstDelete) {\n+                try (RocksIterator iterator = rocksDB.newIterator(rocksdbStore.columnFamilyHandle)) {\n+                    iterator.seekToFirst();\n+                    if (i % 10 == 0) {\n+                        long fileSize = getDirectorySizeRecursive(new File(rocksdbStore.getFilePath()));\n+                        log.info(\""DirectorySize={}, Cost={}ms\"",\n+                            MessageStoreUtil.toHumanReadable(fileSize), stopwatch.elapsed(TimeUnit.MILLISECONDS) - start);\n+                    }\n+                    while (iterator.isValid() && deleteList.size() < 1024) {\n+                        deleteList.add(PopConsumerRecord.decode(iterator.value()));\n+                        iterator.next();\n+                    }\n+                }\n+            } else {\n+                long upper = System.currentTimeMillis();\n+                deleteList = rocksdbStore.scanExpiredRecords(currentTime, upper, 800);\n+                if (!deleteList.isEmpty()) {\n+                    currentTime = deleteList.get(deleteList.size() - 1).getVisibilityTimeout();\n+                }\n+                long scanCost = stopwatch.elapsed(TimeUnit.MILLISECONDS) - start;\n+                if (i % 100 == 0) {\n+                    long fileSize = getDirectorySizeRecursive(new File(rocksdbStore.getFilePath()));\n+                    long seekTime = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n+                    try (RocksIterator iterator = rocksDB.newIterator(rocksdbStore.columnFamilyHandle)) {\n+                        iterator.seekToFirst();\n+                    }\n+                    log.info(\""DirectorySize={}, Cost={}ms, SeekFirstCost={}ms\"", MessageStoreUtil.toHumanReadable(fileSize),\n+                        scanCost, stopwatch.elapsed(TimeUnit.MILLISECONDS) - seekTime);\n+                }\n+            }\n+            rocksdbStore.deleteRecords(deleteList);\n+        }\n+        rocksdbStore.shutdown();\n+        deleteStoreDirectory(rocksdbStore.getFilePath());\n+    }\n }\n\\ No newline at end of file\n\ndiff --git a/broker/src/test/java/org/apache/rocketmq/broker/pop/PopConsumerServiceTest.java b/broker/src/test/java/org/apache/rocketmq/broker/pop/PopConsumerServiceTest.java\nindex b77c170c8c6..2b930d5852c 100644\n--- a/broker/src/test/java/org/apache/rocketmq/broker/pop/PopConsumerServiceTest.java\n+++ b/broker/src/test/java/org/apache/rocketmq/broker/pop/PopConsumerServiceTest.java\n@@ -25,6 +25,7 @@\n import java.util.UUID;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n import org.apache.commons.io.FileUtils;\n@@ -371,17 +372,17 @@ public void reviveRetryTest() {\n \n         Mockito.doReturn(CompletableFuture.completedFuture(null))\n             .when(consumerServiceSpy).getMessageAsync(any(PopConsumerRecord.class));\n-        consumerServiceSpy.revive(20 * 1000, 1);\n+        consumerServiceSpy.revive(new AtomicLong(20 * 1000), 1);\n \n         Mockito.doReturn(CompletableFuture.completedFuture(\n                 Triple.of(null, \""GetMessageResult is null\"", false)))\n             .when(consumerServiceSpy).getMessageAsync(any(PopConsumerRecord.class));\n-        consumerServiceSpy.revive(20 * 1000, 1);\n+        consumerServiceSpy.revive(new AtomicLong(20 * 1000), 1);\n \n         Mockito.doReturn(CompletableFuture.completedFuture(\n                 Triple.of(Mockito.mock(MessageExt.class), null, false)))\n             .when(consumerServiceSpy).getMessageAsync(any(PopConsumerRecord.class));\n-        consumerServiceSpy.revive(20 * 1000, 1);\n+        consumerServiceSpy.revive(new AtomicLong(20 * 1000), 1);\n         consumerService.shutdown();\n     }\n \n@@ -412,11 +413,11 @@ public void reviveBackoffRetryTest() {\n         long visibleTimestamp = popTime + invisibleTime;\n \n         // revive fails\n-        Assert.assertEquals(1, consumerServiceSpy.revive(visibleTimestamp, 1));\n+        Assert.assertEquals(1, consumerServiceSpy.revive(new AtomicLong(visibleTimestamp), 1));\n         // should be invisible now\n-        Assert.assertEquals(0, consumerService.getPopConsumerStore().scanExpiredRecords(visibleTimestamp, 1).size());\n+        Assert.assertEquals(0, consumerService.getPopConsumerStore().scanExpiredRecords(0, visibleTimestamp, 1).size());\n         // will be visible again in 10 seconds\n-        Assert.assertEquals(1, consumerService.getPopConsumerStore().scanExpiredRecords(visibleTimestamp + 10 * 1000, 1).size());\n+        Assert.assertEquals(1, consumerService.getPopConsumerStore().scanExpiredRecords(visibleTimestamp, System.currentTimeMillis() + visibleTimestamp + 10 * 1000, 1).size());\n \n         consumerService.shutdown();\n     }\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""apache__rocketmq-9101"", ""pr_id"": 9101, ""issue_id"": 9105, ""repo"": ""apache/rocketmq"", ""problem_statement"": ""[Bug] Messages are duplicated when using LMQ for pop consumption\n### Before Creating the Bug Report\n\n- [X] I found a bug, not just asking a question, which should be created in [GitHub Discussions](https://github.com/apache/rocketmq/discussions).\n\n- [X] I have searched the [GitHub Issues](https://github.com/apache/rocketmq/issues) and [GitHub Discussions](https://github.com/apache/rocketmq/discussions)  of this repository and believe that this is not a duplicate.\n\n- [X] I have confirmed that this bug belongs to the current repository, not other repositories of RocketMQ.\n\n\n### Runtime platform environment\n\nAny platform\n\n### RocketMQ version\n\nrocketmq 5.3.1\n\n### JDK Version\n\njdk 8\n\n### Describe the Bug\n\nMessages are duplicated when using LMQ for pop consumption\n\n### Steps to Reproduce\n\nUse LMQ for pop consumption\n\n### What Did You Expect to See?\n\nMessages are not duplicated\n\n### What Did You See Instead?\n\nMessages are duplicated\n\n### Additional Context\n\nNo\r\n"", ""issue_word_count"": 144, ""test_files_count"": 2, ""non_test_files_count"": 4, ""pr_changed_files"": [""broker/src/main/java/org/apache/rocketmq/broker/longpolling/PopLongPollingService.java"", ""broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java"", ""broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java"", ""broker/src/main/java/org/apache/rocketmq/broker/processor/PopBufferMergeService.java"", ""broker/src/test/java/org/apache/rocketmq/broker/longpolling/PopLongPollingServiceTest.java"", ""broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java""], ""pr_changed_test_files"": [""broker/src/test/java/org/apache/rocketmq/broker/longpolling/PopLongPollingServiceTest.java"", ""broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java""], ""base_commit"": ""a3afb05cb32f6c63fe8af5aef7a86ad1a4d5797f"", ""head_commit"": ""46cff3751082be893dcf567306374a50af9526f3"", ""repo_url"": ""https://github.com/apache/rocketmq/pull/9101"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/apache__rocketmq/9101"", ""dockerfile"": """", ""pr_merged_at"": ""2025-01-06T02:51:59.000Z"", ""patch"": ""diff --git a/broker/src/main/java/org/apache/rocketmq/broker/longpolling/PopLongPollingService.java b/broker/src/main/java/org/apache/rocketmq/broker/longpolling/PopLongPollingService.java\nindex 91185fbe94c..e87a8e803fd 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/longpolling/PopLongPollingService.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/longpolling/PopLongPollingService.java\n@@ -52,7 +52,7 @@ public class PopLongPollingService extends ServiceThread {\n         LoggerFactory.getLogger(LoggerName.ROCKETMQ_POP_LOGGER_NAME);\n     private final BrokerController brokerController;\n     private final NettyRequestProcessor processor;\n-    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Byte>> topicCidMap;\n+    private final ConcurrentLinkedHashMap<String, ConcurrentHashMap<String, Byte>> topicCidMap;\n     private final ConcurrentLinkedHashMap<String, ConcurrentSkipListSet<PopRequest>> pollingMap;\n     private long lastCleanTime = 0;\n \n@@ -63,7 +63,8 @@ public PopLongPollingService(BrokerController brokerController, NettyRequestProc\n         this.brokerController = brokerController;\n         this.processor = processor;\n         // 100000 topic default,  100000 lru topic + cid + qid\n-        this.topicCidMap = new ConcurrentHashMap<>(brokerController.getBrokerConfig().getPopPollingMapSize());\n+        this.topicCidMap = new ConcurrentLinkedHashMap.Builder<String, ConcurrentHashMap<String, Byte>>()\n+            .maximumWeightedCapacity(this.brokerController.getBrokerConfig().getPopPollingMapSize() * 2L).build();\n         this.pollingMap = new ConcurrentLinkedHashMap.Builder<String, ConcurrentSkipListSet<PopRequest>>()\n             .maximumWeightedCapacity(this.brokerController.getBrokerConfig().getPopPollingMapSize()).build();\n         this.notifyLast = notifyLast;\n@@ -350,7 +351,7 @@ private void cleanUnusedResource() {\n                     Map.Entry<String, ConcurrentHashMap<String, Byte>> entry = topicCidMapIter.next();\n                     String topic = entry.getKey();\n                     if (brokerController.getTopicConfigManager().selectTopicConfig(topic) == null) {\n-                        POP_LOGGER.info(\""remove not exit topic {} in topicCidMap!\"", topic);\n+                        POP_LOGGER.info(\""remove nonexistent topic {} in topicCidMap!\"", topic);\n                         topicCidMapIter.remove();\n                         continue;\n                     }\n@@ -358,8 +359,8 @@ private void cleanUnusedResource() {\n                     while (cidMapIter.hasNext()) {\n                         Map.Entry<String, Byte> cidEntry = cidMapIter.next();\n                         String cid = cidEntry.getKey();\n-                        if (!brokerController.getSubscriptionGroupManager().getSubscriptionGroupTable().containsKey(cid)) {\n-                            POP_LOGGER.info(\""remove not exit sub {} of topic {} in topicCidMap!\"", cid, topic);\n+                        if (!brokerController.getSubscriptionGroupManager().containsSubscriptionGroup(cid)) {\n+                            POP_LOGGER.info(\""remove nonexistent subscription group {} of topic {} in topicCidMap!\"", cid, topic);\n                             cidMapIter.remove();\n                         }\n                     }\n@@ -380,12 +381,12 @@ private void cleanUnusedResource() {\n                     String topic = keyArray[0];\n                     String cid = keyArray[1];\n                     if (brokerController.getTopicConfigManager().selectTopicConfig(topic) == null) {\n-                        POP_LOGGER.info(\""remove not exit topic {} in pollingMap!\"", topic);\n+                        POP_LOGGER.info(\""remove nonexistent topic {} in pollingMap!\"", topic);\n                         pollingMapIter.remove();\n                         continue;\n                     }\n-                    if (!brokerController.getSubscriptionGroupManager().getSubscriptionGroupTable().containsKey(cid)) {\n-                        POP_LOGGER.info(\""remove not exit sub {} of topic {} in pollingMap!\"", cid, topic);\n+                    if (!brokerController.getSubscriptionGroupManager().containsSubscriptionGroup(cid)) {\n+                        POP_LOGGER.info(\""remove nonexistent subscription group {} of topic {} in pollingMap!\"", cid, topic);\n                         pollingMapIter.remove();\n                     }\n                 }\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java b/broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java\nindex 4eccc6c0374..120f5b104c7 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManager.java\n@@ -281,7 +281,7 @@ protected void autoClean() {\n                 continue;\n             }\n \n-            if (this.brokerController.getSubscriptionGroupManager().getSubscriptionGroupTable().get(group) == null) {\n+            if (!this.brokerController.getSubscriptionGroupManager().containsSubscriptionGroup(group)) {\n                 iterator.remove();\n                 log.info(\""Group not exist, Clean order info, {}:{}\"", topicAtGroup, qs);\n                 continue;\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java b/broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java\nindex 6bcf9aaa0f7..6fb7584aa9b 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java\n@@ -424,7 +424,7 @@ private RemotingCommand getSubscriptionGroup(ChannelHandlerContext ctx,\n         GetSubscriptionGroupConfigRequestHeader requestHeader = (GetSubscriptionGroupConfigRequestHeader) request.decodeCommandCustomHeader(GetSubscriptionGroupConfigRequestHeader.class);\n         final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n \n-        SubscriptionGroupConfig groupConfig = this.brokerController.getSubscriptionGroupManager().getSubscriptionGroupTable().get(requestHeader.getGroup());\n+        SubscriptionGroupConfig groupConfig = this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());\n         if (groupConfig == null) {\n             LOGGER.error(\""No group in this broker, client: {} group: {}\"", ctx.channel().remoteAddress(), requestHeader.getGroup());\n             response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n@@ -2444,7 +2444,7 @@ private RemotingCommand consumeMessageDirectly(ChannelHandlerContext ctx,\n         }\n         // groupSysFlag\n         if (StringUtils.isNotEmpty(requestHeader.getConsumerGroup())) {\n-            SubscriptionGroupConfig groupConfig = brokerController.getSubscriptionGroupManager().getSubscriptionGroupTable().get(requestHeader.getConsumerGroup());\n+            SubscriptionGroupConfig groupConfig = brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n             if (groupConfig != null) {\n                 request.addExtField(\""groupSysFlag\"", String.valueOf(groupConfig.getGroupSysFlag()));\n             }\n@@ -2933,7 +2933,7 @@ private RemotingCommand getTopicConfig(ChannelHandlerContext ctx,\n         GetTopicConfigRequestHeader requestHeader = (GetTopicConfigRequestHeader) request.decodeCommandCustomHeader(GetTopicConfigRequestHeader.class);\n         final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n \n-        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().getTopicConfigTable().get(requestHeader.getTopic());\n+        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n         if (topicConfig == null) {\n             LOGGER.error(\""No topic in this broker, client: {} topic: {}\"", ctx.channel().remoteAddress(), requestHeader.getTopic());\n             //be care of the response code, should set \""not-exist\"" explicitly\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/processor/PopBufferMergeService.java b/broker/src/main/java/org/apache/rocketmq/broker/processor/PopBufferMergeService.java\nindex 05a92c54b18..820388b18d2 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/processor/PopBufferMergeService.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/processor/PopBufferMergeService.java\n@@ -197,12 +197,12 @@ private void scanGarbage() {\n             String topic = keyArray[0];\n             String cid = keyArray[1];\n             if (brokerController.getTopicConfigManager().selectTopicConfig(topic) == null) {\n-                POP_LOGGER.info(\""[PopBuffer]remove not exit topic {} in buffer!\"", topic);\n+                POP_LOGGER.info(\""[PopBuffer]remove nonexistent topic {} in buffer!\"", topic);\n                 iterator.remove();\n                 continue;\n             }\n-            if (!brokerController.getSubscriptionGroupManager().getSubscriptionGroupTable().containsKey(cid)) {\n-                POP_LOGGER.info(\""[PopBuffer]remove not exit sub {} of topic {} in buffer!\"", cid, topic);\n+            if (!brokerController.getSubscriptionGroupManager().containsSubscriptionGroup(cid)) {\n+                POP_LOGGER.info(\""[PopBuffer]remove nonexistent subscription group {} of topic {} in buffer!\"", cid, topic);\n                 iterator.remove();\n                 continue;\n             }\n"", ""test_patch"": ""diff --git a/broker/src/test/java/org/apache/rocketmq/broker/longpolling/PopLongPollingServiceTest.java b/broker/src/test/java/org/apache/rocketmq/broker/longpolling/PopLongPollingServiceTest.java\nindex 1f064ec05d1..003bf09842a 100644\n--- a/broker/src/test/java/org/apache/rocketmq/broker/longpolling/PopLongPollingServiceTest.java\n+++ b/broker/src/test/java/org/apache/rocketmq/broker/longpolling/PopLongPollingServiceTest.java\n@@ -55,20 +55,20 @@ public class PopLongPollingServiceTest {\n     \n     @Mock\n     private BrokerController brokerController;\n-    \n+\n     @Mock\n     private NettyRequestProcessor processor;\n-    \n+\n     @Mock\n     private ChannelHandlerContext ctx;\n-    \n+\n     @Mock\n     private ExecutorService pullMessageExecutor;\n-    \n+\n     private PopLongPollingService popLongPollingService;\n-    \n+\n     private final String defaultTopic = \""defaultTopic\"";\n-    \n+\n     @Before\n     public void init() {\n         BrokerConfig brokerConfig = new BrokerConfig();\n@@ -76,7 +76,7 @@ public void init() {\n         when(brokerController.getBrokerConfig()).thenReturn(brokerConfig);\n         popLongPollingService = spy(new PopLongPollingService(brokerController, processor, true));\n     }\n-    \n+\n     @Test\n     public void testNotifyMessageArrivingWithRetryTopic() {\n         int queueId = 0;\n@@ -84,31 +84,32 @@ public void testNotifyMessageArrivingWithRetryTopic() {\n         popLongPollingService.notifyMessageArrivingWithRetryTopic(defaultTopic, queueId);\n         verify(popLongPollingService, times(1)).notifyMessageArrivingWithRetryTopic(defaultTopic, queueId, -1L, null, 0L, null, null);\n     }\n-    \n+\n     @Test\n     public void testNotifyMessageArriving() {\n         int queueId = 0;\n         Long tagsCode = 123L;\n         long offset = 123L;\n         long msgStoreTime = System.currentTimeMillis();\n-        byte[] filterBitMap = new byte[]{0x01};\n+        byte[] filterBitMap = new byte[] {0x01};\n         Map<String, String> properties = new ConcurrentHashMap<>();\n         doNothing().when(popLongPollingService).notifyMessageArriving(defaultTopic, queueId, offset, tagsCode, msgStoreTime, filterBitMap, properties);\n         popLongPollingService.notifyMessageArrivingWithRetryTopic(defaultTopic, queueId, offset, tagsCode, msgStoreTime, filterBitMap, properties);\n         verify(popLongPollingService).notifyMessageArriving(defaultTopic, queueId, offset, tagsCode, msgStoreTime, filterBitMap, properties);\n     }\n-    \n+\n     @Test\n     public void testNotifyMessageArrivingValidRequest() throws Exception {\n         String cid = \""CID_1\"";\n         int queueId = 0;\n-        ConcurrentHashMap<String, ConcurrentHashMap<String, Byte>> topicCidMap = new ConcurrentHashMap<>();\n+        ConcurrentLinkedHashMap<String, ConcurrentHashMap<String, Byte>> topicCidMap = new ConcurrentLinkedHashMap.Builder<String, ConcurrentHashMap<String, Byte>>()\n+            .maximumWeightedCapacity(10).build();\n         ConcurrentHashMap<String, Byte> cids = new ConcurrentHashMap<>();\n         cids.put(cid, (byte) 1);\n         topicCidMap.put(defaultTopic, cids);\n         popLongPollingService = new PopLongPollingService(brokerController, processor, true);\n         ConcurrentLinkedHashMap<String, ConcurrentSkipListSet<PopRequest>> pollingMap =\n-                new ConcurrentLinkedHashMap.Builder<String, ConcurrentSkipListSet<PopRequest>>().maximumWeightedCapacity(this.brokerController.getBrokerConfig().getPopPollingMapSize()).build();\n+            new ConcurrentLinkedHashMap.Builder<String, ConcurrentSkipListSet<PopRequest>>().maximumWeightedCapacity(this.brokerController.getBrokerConfig().getPopPollingMapSize()).build();\n         Channel channel = mock(Channel.class);\n         when(channel.isActive()).thenReturn(true);\n         PopRequest popRequest = mock(PopRequest.class);\n@@ -126,19 +127,19 @@ public void testNotifyMessageArrivingValidRequest() throws Exception {\n         boolean actual = popLongPollingService.notifyMessageArriving(defaultTopic, queueId, cid, null, 0, null, null);\n         assertFalse(actual);\n     }\n-    \n+\n     @Test\n     public void testWakeUpNullRequest() {\n         assertFalse(popLongPollingService.wakeUp(null));\n     }\n-    \n+\n     @Test\n     public void testWakeUpIncompleteRequest() {\n         PopRequest request = mock(PopRequest.class);\n         when(request.complete()).thenReturn(false);\n         assertFalse(popLongPollingService.wakeUp(request));\n     }\n-    \n+\n     @Test\n     public void testWakeUpInactiveChannel() {\n         PopRequest request = mock(PopRequest.class);\n@@ -150,7 +151,7 @@ public void testWakeUpInactiveChannel() {\n         when(brokerController.getPullMessageExecutor()).thenReturn(pullMessageExecutor);\n         assertTrue(popLongPollingService.wakeUp(request));\n     }\n-    \n+\n     @Test\n     public void testWakeUpValidRequestWithException() throws Exception {\n         PopRequest request = mock(PopRequest.class);\n@@ -168,7 +169,7 @@ public void testWakeUpValidRequestWithException() throws Exception {\n         captor.getValue().run();\n         verify(processor).processRequest(any(), any());\n     }\n-    \n+\n     @Test\n     public void testPollingNotPolling() {\n         ChannelHandlerContext ctx = mock(ChannelHandlerContext.class);\n@@ -180,7 +181,7 @@ public void testPollingNotPolling() {\n         PollingResult result = popLongPollingService.polling(ctx, remotingCommand, requestHeader, subscriptionData, messageFilter);\n         assertEquals(PollingResult.NOT_POLLING, result);\n     }\n-    \n+\n     @Test\n     public void testPollingServicePollingTimeout() throws IllegalAccessException {\n         String cid = \""CID_1\"";\n@@ -194,7 +195,8 @@ public void testPollingServicePollingTimeout() throws IllegalAccessException {\n         when(requestHeader.getPollTime()).thenReturn(1000L);\n         when(requestHeader.getTopic()).thenReturn(defaultTopic);\n         when(requestHeader.getConsumerGroup()).thenReturn(\""defaultGroup\"");\n-        ConcurrentHashMap<String, ConcurrentHashMap<String, Byte>> topicCidMap = new ConcurrentHashMap<>();\n+        ConcurrentLinkedHashMap<String, ConcurrentHashMap<String, Byte>> topicCidMap = new ConcurrentLinkedHashMap.Builder<String, ConcurrentHashMap<String, Byte>>()\n+            .maximumWeightedCapacity(10).build();\n         ConcurrentHashMap<String, Byte> cids = new ConcurrentHashMap<>();\n         cids.put(cid, (byte) 1);\n         topicCidMap.put(defaultTopic, cids);\n@@ -202,7 +204,7 @@ public void testPollingServicePollingTimeout() throws IllegalAccessException {\n         PollingResult result = popLongPollingService.polling(ctx, remotingCommand, requestHeader, subscriptionData, messageFilter);\n         assertEquals(PollingResult.POLLING_TIMEOUT, result);\n     }\n-    \n+\n     @Test\n     public void testPollingPollingSuc() {\n         ChannelHandlerContext ctx = mock(ChannelHandlerContext.class);\n\ndiff --git a/broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java b/broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java\nindex 25b418c9344..4414eda54e9 100644\n--- a/broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java\n+++ b/broker/src/test/java/org/apache/rocketmq/broker/offset/ConsumerOrderInfoManagerTest.java\n@@ -21,7 +21,6 @@\n import java.util.Map;\n import java.util.UUID;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.TimeUnit;\n import org.apache.rocketmq.broker.BrokerController;\n import org.apache.rocketmq.broker.subscription.SubscriptionGroupManager;\n@@ -29,7 +28,6 @@\n import org.apache.rocketmq.common.BrokerConfig;\n import org.apache.rocketmq.common.TopicConfig;\n import org.apache.rocketmq.remoting.protocol.header.ExtraInfoUtil;\n-import org.apache.rocketmq.remoting.protocol.subscription.SubscriptionGroupConfig;\n import org.assertj.core.util.Lists;\n import org.junit.Before;\n import org.junit.Test;\n@@ -384,9 +382,7 @@ public void testAutoCleanAndEncode() {\n \n         SubscriptionGroupManager subscriptionGroupManager = mock(SubscriptionGroupManager.class);\n         when(brokerController.getSubscriptionGroupManager()).thenReturn(subscriptionGroupManager);\n-        ConcurrentMap<String, SubscriptionGroupConfig> subscriptionGroupConfigConcurrentMap = new ConcurrentHashMap<>();\n-        subscriptionGroupConfigConcurrentMap.put(GROUP, new SubscriptionGroupConfig());\n-        when(subscriptionGroupManager.getSubscriptionGroupTable()).thenReturn(subscriptionGroupConfigConcurrentMap);\n+        when(subscriptionGroupManager.containsSubscriptionGroup(GROUP)).thenReturn(true);\n \n         TopicConfig topicConfig = new TopicConfig(TOPIC);\n         when(topicConfigManager.selectTopicConfig(eq(TOPIC))).thenReturn(topicConfig);\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""apache__rocketmq-9071"", ""pr_id"": 9071, ""issue_id"": 9069, ""repo"": ""apache/rocketmq"", ""problem_statement"": ""[Bug] tiered store  ConstructIndexFile ConcurrentModificationException\n### Before Creating the Bug Report\n\n- [X] I found a bug, not just asking a question, which should be created in [GitHub Discussions](https://github.com/apache/rocketmq/discussions).\n\n- [x] I have searched the [GitHub Issues](https://github.com/apache/rocketmq/issues) and [GitHub Discussions](https://github.com/apache/rocketmq/discussions)  of this repository and believe that this is not a duplicate.\n\n- [X] I have confirmed that this bug belongs to the current repository, not other repositories of RocketMQ.\n\n\n### Runtime platform environment\n\nlinux\n\n### RocketMQ version\n\ndevlop|5.3.x\n\n### JDK Version\n\njdk1.8\n\n### Describe the Bug\n\n\r\n    public CompletableFuture<Void> commitAsync(FlatFileInterface flatFile) {\r\n        return flatFile.commitAsync().thenAcceptAsync(success -> {\r\n            if (success) {\r\n                if (storeConfig.isMessageIndexEnable()) {\r\n                    flatFile.getDispatchRequestList().forEach(\r\n                        request -> constructIndexFile(flatFile.getTopicId(), request));\r\n                }\r\n                flatFile.release();\r\n            }\r\n        }, storeExecutor.bufferCommitExecutor);\r\n    }\r\n-------------------------------------------\r\nI found this issue while conducting stress testing on tieredstore. When the TPS reached 100000, the Messenger Dispatcher # ConstructIndexFile call threw an exception\r\n\u201djava.util. ConcurrentModificationException\u201c\n\n### Steps to Reproduce\n\nTested again, it still appears, as shown in the screenshot below\n\n### What Did You Expect to See?\n\nIndex construction without errors\n\n### What Did You See Instead?\n\n--\n\n### Additional Context\n\n_No response_"", ""issue_word_count"": 187, ""test_files_count"": 3, ""non_test_files_count"": 4, ""pr_changed_files"": [""tieredstore/src/main/java/org/apache/rocketmq/tieredstore/common/GroupCommitContext.java"", ""tieredstore/src/main/java/org/apache/rocketmq/tieredstore/core/MessageStoreDispatcherImpl.java"", ""tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/FlatFileInterface.java"", ""tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/FlatMessageFile.java"", ""tieredstore/src/test/java/org/apache/rocketmq/tieredstore/common/GroupCommitContextTest.java"", ""tieredstore/src/test/java/org/apache/rocketmq/tieredstore/core/MessageStoreDispatcherImplTest.java"", ""tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/FlatMessageFileTest.java""], ""pr_changed_test_files"": [""tieredstore/src/test/java/org/apache/rocketmq/tieredstore/common/GroupCommitContextTest.java"", ""tieredstore/src/test/java/org/apache/rocketmq/tieredstore/core/MessageStoreDispatcherImplTest.java"", ""tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/FlatMessageFileTest.java""], ""base_commit"": ""16b6e53263477794125a49d9f31a994a510970b7"", ""head_commit"": ""b675339dc15c38dc7f5062dd5ef643b8c787f898"", ""repo_url"": ""https://github.com/apache/rocketmq/pull/9071"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/apache__rocketmq/9071"", ""dockerfile"": """", ""pr_merged_at"": ""2024-12-25T09:02:06.000Z"", ""patch"": ""diff --git a/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/common/GroupCommitContext.java b/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/common/GroupCommitContext.java\nnew file mode 100644\nindex 00000000000..f677e7c934e\n--- /dev/null\n+++ b/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/common/GroupCommitContext.java\n@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.tieredstore.common;\n+\n+import java.util.List;\n+import org.apache.rocketmq.store.DispatchRequest;\n+import org.apache.rocketmq.store.SelectMappedBufferResult;\n+\n+public class GroupCommitContext {\n+\n+    private long endOffset;\n+\n+    private List<SelectMappedBufferResult> bufferList;\n+\n+    private List<DispatchRequest> dispatchRequests;\n+\n+    public long getEndOffset() {\n+        return endOffset;\n+    }\n+\n+    public void setEndOffset(long endOffset) {\n+        this.endOffset = endOffset;\n+    }\n+\n+    public List<SelectMappedBufferResult> getBufferList() {\n+        return bufferList;\n+    }\n+\n+    public void setBufferList(List<SelectMappedBufferResult> bufferList) {\n+        this.bufferList = bufferList;\n+    }\n+\n+    public List<DispatchRequest> getDispatchRequests() {\n+        return dispatchRequests;\n+    }\n+\n+    public void setDispatchRequests(List<DispatchRequest> dispatchRequests) {\n+        this.dispatchRequests = dispatchRequests;\n+    }\n+\n+    public void release() {\n+        if (bufferList != null) {\n+            for (SelectMappedBufferResult bufferResult : bufferList) {\n+                bufferResult.release();\n+            }\n+            bufferList.clear();\n+            bufferList = null;\n+        }\n+        if (dispatchRequests != null) {\n+            dispatchRequests.clear();\n+            dispatchRequests = null;\n+        }\n+\n+    }\n+}\n\ndiff --git a/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/core/MessageStoreDispatcherImpl.java b/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/core/MessageStoreDispatcherImpl.java\nindex 9b1e53564d7..bcc4e225da2 100644\n--- a/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/core/MessageStoreDispatcherImpl.java\n+++ b/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/core/MessageStoreDispatcherImpl.java\n@@ -16,15 +16,20 @@\n  */\n package org.apache.rocketmq.tieredstore.core;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.opentelemetry.api.common.Attributes;\n import java.nio.ByteBuffer;\n import java.time.Duration;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n import org.apache.commons.lang3.StringUtils;\n@@ -42,6 +47,7 @@\n import org.apache.rocketmq.tieredstore.TieredMessageStore;\n import org.apache.rocketmq.tieredstore.common.AppendResult;\n import org.apache.rocketmq.tieredstore.common.FileSegmentType;\n+import org.apache.rocketmq.tieredstore.common.GroupCommitContext;\n import org.apache.rocketmq.tieredstore.file.FlatFileInterface;\n import org.apache.rocketmq.tieredstore.file.FlatFileStore;\n import org.apache.rocketmq.tieredstore.index.IndexService;\n@@ -65,6 +71,7 @@ public class MessageStoreDispatcherImpl extends ServiceThread implements Message\n     protected final MessageStoreFilter topicFilter;\n     protected final Semaphore semaphore;\n     protected final IndexService indexService;\n+    protected final Map<FlatFileInterface, GroupCommitContext> failedGroupCommitMap;\n \n     public MessageStoreDispatcherImpl(TieredMessageStore messageStore) {\n         this.messageStore = messageStore;\n@@ -77,6 +84,7 @@ public MessageStoreDispatcherImpl(TieredMessageStore messageStore) {\n         this.flatFileStore = messageStore.getFlatFileStore();\n         this.storeExecutor = messageStore.getStoreExecutor();\n         this.indexService = messageStore.getIndexService();\n+        this.failedGroupCommitMap = new ConcurrentHashMap<>();\n     }\n \n     @Override\n@@ -84,6 +92,11 @@ public String getServiceName() {\n         return MessageStoreDispatcher.class.getSimpleName();\n     }\n \n+    @VisibleForTesting\n+    public Map<FlatFileInterface, GroupCommitContext> getFailedGroupCommitMap() {\n+        return failedGroupCommitMap;\n+    }\n+\n     public void dispatchWithSemaphore(FlatFileInterface flatFile) {\n         try {\n             if (stopped) {\n@@ -153,10 +166,22 @@ public CompletableFuture<Boolean> doScheduleDispatch(FlatFileInterface flatFile,\n \n             // If the previous commit fails, attempt to trigger a commit directly.\n             if (commitOffset < currentOffset) {\n-                this.commitAsync(flatFile);\n+                this.commitAsync(flatFile).whenComplete((result, throwable) -> {\n+                    if (throwable != null) {\n+                        log.error(\""MessageDispatcher#flatFile commitOffset less than currentOffset, commitAsync again failed. topic: {}, queueId: {} \"", topic, queueId, throwable);\n+                    }\n+                });\n                 return CompletableFuture.completedFuture(false);\n             }\n \n+            if (failedGroupCommitMap.containsKey(flatFile)) {\n+                GroupCommitContext failedCommit = failedGroupCommitMap.get(flatFile);\n+                if (failedCommit.getEndOffset() <= commitOffset) {\n+                    failedGroupCommitMap.remove(flatFile);\n+                    constructIndexFile(flatFile.getTopicId(), failedCommit);\n+                }\n+            }\n+\n             if (currentOffset < minOffsetInQueue) {\n                 log.warn(\""MessageDispatcher#dispatch, current offset is too small, topic={}, queueId={}, offset={}-{}, current={}\"",\n                     topic, queueId, minOffsetInQueue, maxOffsetInQueue, currentOffset);\n@@ -224,6 +249,8 @@ public CompletableFuture<Boolean> doScheduleDispatch(FlatFileInterface flatFile,\n             }\n \n             long offset = currentOffset;\n+            List<SelectMappedBufferResult> appendingBufferList = new ArrayList<>();\n+            List<DispatchRequest> dispatchRequestList = new ArrayList<>();\n             for (; offset < targetOffset; offset++) {\n                 cqUnit = consumeQueue.get(offset);\n                 bufferSize += cqUnit.getSize();\n@@ -231,6 +258,7 @@ public CompletableFuture<Boolean> doScheduleDispatch(FlatFileInterface flatFile,\n                     break;\n                 }\n                 message = defaultStore.selectOneMessageByOffset(cqUnit.getPos(), cqUnit.getSize());\n+                appendingBufferList.add(message);\n \n                 ByteBuffer byteBuffer = message.getByteBuffer();\n                 AppendResult result = flatFile.appendCommitLog(message);\n@@ -251,13 +279,20 @@ public CompletableFuture<Boolean> doScheduleDispatch(FlatFileInterface flatFile,\n                 result = flatFile.appendConsumeQueue(dispatchRequest);\n                 if (!AppendResult.SUCCESS.equals(result)) {\n                     break;\n+                } else {\n+                    dispatchRequestList.add(dispatchRequest);\n                 }\n             }\n \n+            GroupCommitContext groupCommitContext = new GroupCommitContext();\n+            groupCommitContext.setEndOffset(offset);\n+            groupCommitContext.setBufferList(appendingBufferList);\n+            groupCommitContext.setDispatchRequests(dispatchRequestList);\n+\n             // If there are many messages waiting to be uploaded, call the upload logic immediately.\n             boolean repeat = timeout || maxOffsetInQueue - offset > storeConfig.getTieredStoreGroupCommitCount();\n \n-            if (!flatFile.getDispatchRequestList().isEmpty()) {\n+            if (!dispatchRequestList.isEmpty()) {\n                 Attributes attributes = TieredStoreMetricsManager.newAttributesBuilder()\n                     .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic)\n                     .put(TieredStoreMetricsConstant.LABEL_QUEUE_ID, queueId)\n@@ -265,8 +300,19 @@ public CompletableFuture<Boolean> doScheduleDispatch(FlatFileInterface flatFile,\n                     .build();\n                 TieredStoreMetricsManager.messagesDispatchTotal.add(offset - currentOffset, attributes);\n \n-                this.commitAsync(flatFile).whenComplete((unused, throwable) -> {\n-                        if (repeat) {\n+                this.commitAsync(flatFile).whenComplete((success, throwable) -> {\n+                        if (success) {\n+                            constructIndexFile(flatFile.getTopicId(), groupCommitContext);\n+                        }\n+                        else {\n+                            //next commit async,execute constructIndexFile.\n+                            GroupCommitContext oldCommit = failedGroupCommitMap.put(flatFile, groupCommitContext);\n+                            if (oldCommit != null) {\n+                                log.warn(\""MessageDispatcher#commitAsync failed,flatFile old failed commit context not release, topic={}, queueId={}  \"", topic, queueId);\n+                                oldCommit.release();\n+                            }\n+                        }\n+                        if (success && repeat) {\n                             storeExecutor.commonExecutor.submit(() -> dispatchWithSemaphore(flatFile));\n                         }\n                     }\n@@ -282,22 +328,28 @@ public CompletableFuture<Boolean> doScheduleDispatch(FlatFileInterface flatFile,\n         return CompletableFuture.completedFuture(false);\n     }\n \n-    public CompletableFuture<Void> commitAsync(FlatFileInterface flatFile) {\n-        return flatFile.commitAsync().thenAcceptAsync(success -> {\n-            if (success) {\n-                if (storeConfig.isMessageIndexEnable()) {\n-                    flatFile.getDispatchRequestList().forEach(\n-                        request -> constructIndexFile(flatFile.getTopicId(), request));\n+    public CompletableFuture<Boolean> commitAsync(FlatFileInterface flatFile) {\n+        return flatFile.commitAsync();\n+    }\n+\n+    public void constructIndexFile(long topicId, GroupCommitContext groupCommitContext) {\n+        MessageStoreExecutor.getInstance().bufferCommitExecutor.submit(() -> {\n+            if (storeConfig.isMessageIndexEnable()) {\n+                try {\n+                    groupCommitContext.getDispatchRequests().forEach(request -> constructIndexFile0(topicId, request));\n+                }\n+                catch (Throwable e) {\n+                    log.error(\""constructIndexFile error {}\"", topicId, e);\n                 }\n-                flatFile.release();\n             }\n-        }, storeExecutor.bufferCommitExecutor);\n+            groupCommitContext.release();\n+        });\n     }\n \n     /**\n      * Building indexes with offsetId is no longer supported because offsetId has changed in tiered storage\n      */\n-    public void constructIndexFile(long topicId, DispatchRequest request) {\n+    public void constructIndexFile0(long topicId, DispatchRequest request) {\n         Set<String> keySet = new HashSet<>();\n         if (StringUtils.isNotBlank(request.getUniqKey())) {\n             keySet.add(request.getUniqKey());\n@@ -309,12 +361,27 @@ public void constructIndexFile(long topicId, DispatchRequest request) {\n             request.getCommitLogOffset(), request.getMsgSize(), request.getStoreTimestamp());\n     }\n \n+    public void releaseClosedPendingGroupCommit() {\n+        Iterator<Map.Entry<FlatFileInterface, GroupCommitContext>> iterator = failedGroupCommitMap.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry<FlatFileInterface, GroupCommitContext> entry = iterator.next();\n+            if (entry.getKey().isClosed()) {\n+                entry.getValue().release();\n+                iterator.remove();\n+            }\n+        }\n+    }\n+\n+\n     @Override\n     public void run() {\n         log.info(\""{} service started\"", this.getServiceName());\n         while (!this.isStopped()) {\n             try {\n                 flatFileStore.deepCopyFlatFileToList().forEach(this::dispatchWithSemaphore);\n+\n+                releaseClosedPendingGroupCommit();\n+\n                 this.waitForRunning(Duration.ofSeconds(20).toMillis());\n             } catch (Throwable t) {\n                 log.error(\""MessageStore dispatch error\"", t);\n\ndiff --git a/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/FlatFileInterface.java b/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/FlatFileInterface.java\nindex 619470fbc27..01e7f25a467 100644\n--- a/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/FlatFileInterface.java\n+++ b/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/FlatFileInterface.java\n@@ -17,7 +17,6 @@\n package org.apache.rocketmq.tieredstore.file;\n \n import java.nio.ByteBuffer;\n-import java.util.List;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.locks.Lock;\n import org.apache.rocketmq.common.BoundaryType;\n@@ -58,8 +57,6 @@ public interface FlatFileInterface {\n      */\n     AppendResult appendConsumeQueue(DispatchRequest request);\n \n-    List<DispatchRequest> getDispatchRequestList();\n-\n     void release();\n \n     long getMinStoreTimestamp();\n@@ -143,6 +140,8 @@ public interface FlatFileInterface {\n      */\n     CompletableFuture<Long> getQueueOffsetByTimeAsync(long timestamp, BoundaryType boundaryType);\n \n+    boolean isClosed();\n+\n     /**\n      * Shutdown process\n      */\n\ndiff --git a/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/FlatMessageFile.java b/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/FlatMessageFile.java\nindex d5675976cb1..4510a8a1271 100644\n--- a/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/FlatMessageFile.java\n+++ b/tieredstore/src/main/java/org/apache/rocketmq/tieredstore/file/FlatMessageFile.java\n@@ -17,12 +17,14 @@\n package org.apache.rocketmq.tieredstore.file;\n \n import com.alibaba.fastjson.JSON;\n+import com.google.common.annotations.VisibleForTesting;\n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.Semaphore;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n@@ -51,14 +53,13 @@ public class FlatMessageFile implements FlatFileInterface {\n \n     protected final String filePath;\n     protected final ReentrantLock fileLock;\n+    protected final Semaphore commitLock = new Semaphore(1);\n     protected final MessageStoreConfig storeConfig;\n     protected final MetadataStore metadataStore;\n     protected final FlatCommitLogFile commitLog;\n     protected final FlatConsumeQueueFile consumeQueue;\n     protected final AtomicLong lastDestroyTime;\n \n-    protected final List<SelectMappedBufferResult> bufferResultList;\n-    protected final List<DispatchRequest> dispatchRequestList;\n     protected final ConcurrentMap<String, CompletableFuture<?>> inFlightRequestMap;\n \n     public FlatMessageFile(FlatFileFactory fileFactory, String topic, int queueId) {\n@@ -76,8 +77,6 @@ public FlatMessageFile(FlatFileFactory fileFactory, String filePath) {\n         this.commitLog = fileFactory.createFlatFileForCommitLog(filePath);\n         this.consumeQueue = fileFactory.createFlatFileForConsumeQueue(filePath);\n         this.lastDestroyTime = new AtomicLong();\n-        this.bufferResultList = new ArrayList<>();\n-        this.dispatchRequestList = new ArrayList<>();\n         this.inFlightRequestMap = new ConcurrentHashMap<>();\n     }\n \n@@ -127,6 +126,11 @@ public Lock getFileLock() {\n         return this.fileLock;\n     }\n \n+    @VisibleForTesting\n+    public Semaphore getCommitLock() {\n+        return commitLock;\n+    }\n+\n     @Override\n     public boolean rollingFile(long interval) {\n         return this.commitLog.tryRollingFile(interval);\n@@ -156,7 +160,6 @@ public AppendResult appendCommitLog(SelectMappedBufferResult message) {\n         if (closed) {\n             return AppendResult.FILE_CLOSED;\n         }\n-        this.bufferResultList.add(message);\n         return this.appendCommitLog(message.getByteBuffer());\n     }\n \n@@ -172,29 +175,14 @@ public AppendResult appendConsumeQueue(DispatchRequest request) {\n         buffer.putLong(request.getTagsCode());\n         buffer.flip();\n \n-        this.dispatchRequestList.add(request);\n         return consumeQueue.append(buffer, request.getStoreTimestamp());\n     }\n \n-    @Override\n-    public List<DispatchRequest> getDispatchRequestList() {\n-        return dispatchRequestList;\n-    }\n+\n \n     @Override\n     public void release() {\n-        for (SelectMappedBufferResult bufferResult : bufferResultList) {\n-            bufferResult.release();\n-        }\n-\n-        if (queueMetadata != null) {\n-            log.trace(\""FlatMessageFile release, topic={}, queueId={}, bufferSize={}, requestListSize={}\"",\n-                queueMetadata.getQueue().getTopic(), queueMetadata.getQueue().getQueueId(),\n-                bufferResultList.size(), dispatchRequestList.size());\n-        }\n \n-        bufferResultList.clear();\n-        dispatchRequestList.clear();\n     }\n \n     @Override\n@@ -246,13 +234,18 @@ public long getConsumeQueueCommitOffset() {\n \n     @Override\n     public CompletableFuture<Boolean> commitAsync() {\n+        // acquire lock\n+        if (commitLock.drainPermits() <= 0) {\n+            return CompletableFuture.completedFuture(false);\n+        }\n+\n         return this.commitLog.commitAsync()\n             .thenCompose(result -> {\n                 if (result) {\n                     return consumeQueue.commitAsync();\n                 }\n                 return CompletableFuture.completedFuture(false);\n-            });\n+            }).whenComplete((result, throwable) -> commitLock.release());\n     }\n \n     @Override\n@@ -363,6 +356,11 @@ public boolean equals(Object obj) {\n         return StringUtils.equals(filePath, ((FlatMessageFile) obj).filePath);\n     }\n \n+    @Override\n+    public boolean isClosed() {\n+        return closed;\n+    }\n+\n     @Override\n     public void shutdown() {\n         closed = true;\n"", ""test_patch"": ""diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/common/GroupCommitContextTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/common/GroupCommitContextTest.java\nnew file mode 100644\nindex 00000000000..e692360761d\n--- /dev/null\n+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/common/GroupCommitContextTest.java\n@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.tieredstore.common;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.rocketmq.store.DispatchRequest;\n+import org.apache.rocketmq.store.SelectMappedBufferResult;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class GroupCommitContextTest {\n+\n+    @Test\n+    public void groupCommitContextTest() {\n+        GroupCommitContext releaseGroupCommitContext = new GroupCommitContext();\n+        releaseGroupCommitContext.release();\n+\n+        long endOffset = 1000;\n+        List<DispatchRequest> dispatchRequestList = new ArrayList<>();\n+        dispatchRequestList.add(new DispatchRequest(1000));\n+        List<SelectMappedBufferResult> selectMappedBufferResultList = new ArrayList<>();\n+        selectMappedBufferResultList.add(new SelectMappedBufferResult(100, ByteBuffer.allocate(10), 1000, null));\n+        GroupCommitContext groupCommitContext = new GroupCommitContext();\n+        groupCommitContext.setEndOffset(endOffset);\n+        groupCommitContext.setBufferList(selectMappedBufferResultList);\n+        groupCommitContext.setDispatchRequests(dispatchRequestList);\n+\n+        Assert.assertTrue(groupCommitContext.getEndOffset() == endOffset);\n+        Assert.assertTrue(groupCommitContext.getBufferList().equals(selectMappedBufferResultList));\n+        Assert.assertTrue(groupCommitContext.getDispatchRequests().equals(dispatchRequestList));\n+        groupCommitContext.release();\n+        Assert.assertTrue(groupCommitContext.getDispatchRequests() == null);\n+        Assert.assertTrue(groupCommitContext.getBufferList() == null);\n+        Assert.assertTrue(dispatchRequestList.isEmpty());\n+        Assert.assertTrue(selectMappedBufferResultList.isEmpty());\n+    }\n+\n+}\n\ndiff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/core/MessageStoreDispatcherImplTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/core/MessageStoreDispatcherImplTest.java\nindex 92e989e596f..6b960769489 100644\n--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/core/MessageStoreDispatcherImplTest.java\n+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/core/MessageStoreDispatcherImplTest.java\n@@ -35,6 +35,7 @@\n import org.apache.rocketmq.tieredstore.MessageStoreConfig;\n import org.apache.rocketmq.tieredstore.MessageStoreExecutor;\n import org.apache.rocketmq.tieredstore.TieredMessageStore;\n+import org.apache.rocketmq.tieredstore.common.GroupCommitContext;\n import org.apache.rocketmq.tieredstore.file.FlatFileFactory;\n import org.apache.rocketmq.tieredstore.file.FlatFileStore;\n import org.apache.rocketmq.tieredstore.file.FlatMessageFile;\n@@ -157,6 +158,130 @@ public void dispatchFromCommitLogTest() throws Exception {\n         Assert.assertEquals(200L, flatFile.getConsumeQueueCommitOffset());\n     }\n \n+    @Test\n+    public void dispatchCommitFailedTest() throws Exception {\n+        MessageStore defaultStore = Mockito.mock(MessageStore.class);\n+        Mockito.when(defaultStore.getMinOffsetInQueue(anyString(), anyInt())).thenReturn(100L);\n+        Mockito.when(defaultStore.getMaxOffsetInQueue(anyString(), anyInt())).thenReturn(200L);\n+\n+        messageStore = Mockito.mock(TieredMessageStore.class);\n+        IndexService indexService =\n+            new IndexStoreService(new FlatFileFactory(metadataStore, storeConfig), storePath);\n+        indexService.start();\n+        Mockito.when(messageStore.getDefaultStore()).thenReturn(defaultStore);\n+        Mockito.when(messageStore.getStoreConfig()).thenReturn(storeConfig);\n+        Mockito.when(messageStore.getStoreExecutor()).thenReturn(executor);\n+        Mockito.when(messageStore.getFlatFileStore()).thenReturn(fileStore);\n+        Mockito.when(messageStore.getIndexService()).thenReturn(indexService);\n+\n+        // mock message\n+        ByteBuffer buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n+        MessageExt messageExt = MessageDecoder.decode(buffer);\n+        messageExt.setKeys(\""Key\"");\n+        MessageAccessor.putProperty(\n+            messageExt, MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, \""uk\"");\n+        messageExt.setBody(new byte[10]);\n+        messageExt.setStoreSize(0);\n+        buffer = ByteBuffer.wrap(MessageDecoder.encode(messageExt, false));\n+        buffer.putInt(0, buffer.remaining());\n+\n+        DispatchRequest request = new DispatchRequest(mq.getTopic(), mq.getQueueId(),\n+            MessageFormatUtil.getCommitLogOffset(buffer), buffer.remaining(), 0L,\n+            MessageFormatUtil.getStoreTimeStamp(buffer), 0L,\n+            \""\"", \""\"", 0, 0L, new HashMap<>());\n+\n+        // construct flat file\n+        MessageStoreDispatcher dispatcher = new MessageStoreDispatcherImpl(messageStore);\n+        dispatcher.dispatch(request);\n+        FlatMessageFile flatFile = fileStore.getFlatFile(mq);\n+        Assert.assertNotNull(flatFile);\n+\n+        // init offset\n+        dispatcher.doScheduleDispatch(flatFile, true).join();\n+        Assert.assertEquals(100L, flatFile.getConsumeQueueMinOffset());\n+        Assert.assertEquals(100L, flatFile.getConsumeQueueMaxOffset());\n+        Assert.assertEquals(100L, flatFile.getConsumeQueueCommitOffset());\n+\n+        ConsumeQueueInterface cq = Mockito.mock(ConsumeQueueInterface.class);\n+        Mockito.when(defaultStore.getConsumeQueue(anyString(), anyInt())).thenReturn(cq);\n+        Mockito.when(cq.get(anyLong())).thenReturn(\n+            new CqUnit(100, 1000, buffer.remaining(), 0L));\n+        Mockito.when(defaultStore.selectOneMessageByOffset(anyLong(), anyInt())).thenReturn(\n+            new SelectMappedBufferResult(0L, buffer.asReadOnlyBuffer(), buffer.remaining(), null));\n+        flatFile.getCommitLock().drainPermits();\n+        dispatcher.doScheduleDispatch(flatFile, true).join();\n+        GroupCommitContext groupCommitContext = ((MessageStoreDispatcherImpl)dispatcher).getFailedGroupCommitMap().get(flatFile);\n+        Assert.assertTrue(groupCommitContext != null);\n+        Assert.assertTrue(groupCommitContext.getEndOffset() == 200);\n+        flatFile.getCommitLock().release();\n+        flatFile.commitAsync().join();\n+        dispatcher.doScheduleDispatch(flatFile, true).join();\n+        Assert.assertTrue(((MessageStoreDispatcherImpl)dispatcher).getFailedGroupCommitMap().get(flatFile) == null);\n+        ((MessageStoreDispatcherImpl)dispatcher).flatFileStore.destroyFile(mq);\n+        ((MessageStoreDispatcherImpl)dispatcher).releaseClosedPendingGroupCommit();\n+\n+    }\n+\n+    @Test\n+    public void dispatchFailedGroupCommitMapReleaseTest() throws Exception {\n+        MessageStore defaultStore = Mockito.mock(MessageStore.class);\n+        Mockito.when(defaultStore.getMinOffsetInQueue(anyString(), anyInt())).thenReturn(100L);\n+        Mockito.when(defaultStore.getMaxOffsetInQueue(anyString(), anyInt())).thenReturn(200L);\n+\n+        messageStore = Mockito.mock(TieredMessageStore.class);\n+        IndexService indexService =\n+            new IndexStoreService(new FlatFileFactory(metadataStore, storeConfig), storePath);\n+        indexService.start();\n+        Mockito.when(messageStore.getDefaultStore()).thenReturn(defaultStore);\n+        Mockito.when(messageStore.getStoreConfig()).thenReturn(storeConfig);\n+        Mockito.when(messageStore.getStoreExecutor()).thenReturn(executor);\n+        Mockito.when(messageStore.getFlatFileStore()).thenReturn(fileStore);\n+        Mockito.when(messageStore.getIndexService()).thenReturn(indexService);\n+\n+        // mock message\n+        ByteBuffer buffer = MessageFormatUtilTest.buildMockedMessageBuffer();\n+        MessageExt messageExt = MessageDecoder.decode(buffer);\n+        messageExt.setKeys(\""Key\"");\n+        MessageAccessor.putProperty(\n+            messageExt, MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, \""uk\"");\n+        messageExt.setBody(new byte[10]);\n+        messageExt.setStoreSize(0);\n+        buffer = ByteBuffer.wrap(MessageDecoder.encode(messageExt, false));\n+        buffer.putInt(0, buffer.remaining());\n+\n+        DispatchRequest request = new DispatchRequest(mq.getTopic(), mq.getQueueId(),\n+            MessageFormatUtil.getCommitLogOffset(buffer), buffer.remaining(), 0L,\n+            MessageFormatUtil.getStoreTimeStamp(buffer), 0L,\n+            \""\"", \""\"", 0, 0L, new HashMap<>());\n+\n+        // construct flat file\n+        MessageStoreDispatcher dispatcher = new MessageStoreDispatcherImpl(messageStore);\n+        dispatcher.dispatch(request);\n+        FlatMessageFile flatFile = fileStore.getFlatFile(mq);\n+        Assert.assertNotNull(flatFile);\n+\n+        // init offset\n+        dispatcher.doScheduleDispatch(flatFile, true).join();\n+        Assert.assertEquals(100L, flatFile.getConsumeQueueMinOffset());\n+        Assert.assertEquals(100L, flatFile.getConsumeQueueMaxOffset());\n+        Assert.assertEquals(100L, flatFile.getConsumeQueueCommitOffset());\n+\n+        ConsumeQueueInterface cq = Mockito.mock(ConsumeQueueInterface.class);\n+        Mockito.when(defaultStore.getConsumeQueue(anyString(), anyInt())).thenReturn(cq);\n+        Mockito.when(cq.get(anyLong())).thenReturn(\n+            new CqUnit(100, 1000, buffer.remaining(), 0L));\n+        Mockito.when(defaultStore.selectOneMessageByOffset(anyLong(), anyInt())).thenReturn(\n+            new SelectMappedBufferResult(0L, buffer.asReadOnlyBuffer(), buffer.remaining(), null));\n+        flatFile.getCommitLock().drainPermits();\n+        dispatcher.doScheduleDispatch(flatFile, true).join();\n+        GroupCommitContext groupCommitContext = ((MessageStoreDispatcherImpl)dispatcher).getFailedGroupCommitMap().get(flatFile);\n+        Assert.assertTrue(groupCommitContext != null);\n+        ((MessageStoreDispatcherImpl)dispatcher).flatFileStore.destroyFile(mq);\n+        ((MessageStoreDispatcherImpl)dispatcher).releaseClosedPendingGroupCommit();\n+        Assert.assertTrue(((MessageStoreDispatcherImpl)dispatcher).getFailedGroupCommitMap().get(flatFile) == null);\n+\n+    }\n+\n     @Test\n     public void dispatchServiceTest() {\n         MessageStore defaultStore = Mockito.mock(MessageStore.class);\n\ndiff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/FlatMessageFileTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/FlatMessageFileTest.java\nindex 8a417f54a74..8208d277415 100644\n--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/FlatMessageFileTest.java\n+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/file/FlatMessageFileTest.java\n@@ -216,4 +216,12 @@ public void testBinarySearchInQueueByTime() {\n \n         flatFile.destroy();\n     }\n+\n+    @Test\n+    public void testCommitLock() {\n+        String topic = \""CommitLogTest\"";\n+        FlatMessageFile flatFile = new FlatMessageFile(flatFileFactory, topic, 0);\n+        flatFile.getCommitLock().drainPermits();\n+        Assert.assertFalse(flatFile.commitAsync().join());\n+    }\n }\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""apache__rocketmq-8975"", ""pr_id"": 8975, ""issue_id"": 8974, ""repo"": ""apache/rocketmq"", ""problem_statement"": ""[Feature] Support recalling of delay message\n### Is Your Feature Request Related to a Problem?\n\n.\n\n### Describe the Solution You'd Like\n\nAs the timer wheel implementation of delay message, we've reserved a cancellation ability: recalling scheduled messages by sending a corresponding delete message. However, we have not exposed an API to the upper layer. Some developers may construct and send a special message to achieve this, but this is not a friendly and sustainable solution because:\r\n\r\n- There is no clear API semantics.\r\n- It depends on internal implementation details and may become invalid due to system updates.\r\n- Sending and recalling are probably not in the same context, but the required information needs to be saved and depends on the details at the time of sending. \r\n- Grpc is not supported.\r\n\r\nTherefore, the first step is to provide a user-friendly API to implement this feature.\r\n\r\n1. A new rpc request and processor.\r\n2. Client side API definition: `recallMessage(topic, handle)`, recall handle from sending result is a bit like ReceiptHandle, containing information such as ID, broker, and timestamp.\r\n3. Still based on time wheel, only support delay message for now, and perform limited parameter validation in the internal implementation, that is\r\n    - can not accurately determine whether the message truly exists\r\n    - recall may fail when it's too close to the delivery time\r\n4. Regard the recall operation as a PUB operation for authorization.\r\n5. Support Remoting and Grpc protocol, proxy and proxy-less mode.\n\n### Describe Alternatives You've Considered\n\n.\n\n### Additional Context\n\n."", ""issue_word_count"": 249, ""test_files_count"": 19, ""non_test_files_count"": 35, ""pr_changed_files"": [""acl/src/main/java/org/apache/rocketmq/acl/plain/PlainAccessResource.java"", ""acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessResourceTest.java"", ""auth/src/main/java/org/apache/rocketmq/auth/authorization/builder/DefaultAuthorizationContextBuilder.java"", ""auth/src/test/java/org/apache/rocketmq/auth/authorization/builder/DefaultAuthorizationContextBuilderTest.java"", ""broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java"", ""broker/src/main/java/org/apache/rocketmq/broker/processor/RecallMessageProcessor.java"", ""broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java"", ""broker/src/test/java/org/apache/rocketmq/broker/processor/RecallMessageProcessorTest.java"", ""broker/src/test/java/org/apache/rocketmq/broker/processor/SendMessageProcessorTest.java"", ""client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java"", ""client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExt.java"", ""client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java"", ""client/src/main/java/org/apache/rocketmq/client/producer/DefaultMQProducer.java"", ""client/src/main/java/org/apache/rocketmq/client/producer/MQProducer.java"", ""client/src/main/java/org/apache/rocketmq/client/producer/SendResult.java"", ""client/src/main/java/org/apache/rocketmq/client/trace/TraceDataEncoder.java"", ""client/src/main/java/org/apache/rocketmq/client/trace/TraceType.java"", ""client/src/main/java/org/apache/rocketmq/client/trace/hook/DefaultRecallMessageTraceHook.java"", ""client/src/test/java/org/apache/rocketmq/client/impl/MQClientAPIImplTest.java"", ""client/src/test/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExtTest.java"", ""client/src/test/java/org/apache/rocketmq/client/producer/selector/DefaultMQProducerImplTest.java"", ""common/src/main/java/org/apache/rocketmq/common/BrokerConfig.java"", ""common/src/main/java/org/apache/rocketmq/common/producer/RecallMessageHandle.java"", ""common/src/test/java/org/apache/rocketmq/common/producer/RecallMessageHandleTest.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/grpc/interceptor/RequestMapping.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/DefaultGrpcMessingActivity.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/GrpcMessagingApplication.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/GrpcMessingActivity.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/producer/RecallMessageActivity.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/producer/SendMessageActivity.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/processor/DefaultMessagingProcessor.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/processor/MessagingProcessor.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/processor/ProducerProcessor.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/remoting/RemotingProtocolServer.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/RecallMessageActivity.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/service/message/ClusterMessageService.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/service/message/LocalMessageService.java"", ""proxy/src/main/java/org/apache/rocketmq/proxy/service/message/MessageService.java"", ""proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/producer/RecallMessageActivityTest.java"", ""proxy/src/test/java/org/apache/rocketmq/proxy/processor/ProducerProcessorTest.java"", ""proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/RecallMessageActivityTest.java"", ""proxy/src/test/java/org/apache/rocketmq/proxy/service/message/LocalMessageServiceTest.java"", ""remoting/src/main/java/org/apache/rocketmq/remoting/protocol/RequestCode.java"", ""remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/RecallMessageRequestHeader.java"", ""remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/RecallMessageResponseHeader.java"", ""remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/SendMessageResponseHeader.java"", ""store/src/main/java/org/apache/rocketmq/store/timer/TimerMessageStore.java"", ""store/src/test/java/org/apache/rocketmq/store/timer/TimerMessageStoreTest.java"", ""test/BUILD.bazel"", ""test/src/test/java/org/apache/rocketmq/test/grpc/v2/ClusterGrpcIT.java"", ""test/src/test/java/org/apache/rocketmq/test/grpc/v2/GrpcBaseIT.java"", ""test/src/test/java/org/apache/rocketmq/test/grpc/v2/LocalGrpcIT.java"", ""test/src/test/java/org/apache/rocketmq/test/recall/RecallWithTraceIT.java"", ""test/src/test/java/org/apache/rocketmq/test/recall/SendAndRecallDelayMessageIT.java""], ""pr_changed_test_files"": [""acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessResourceTest.java"", ""auth/src/test/java/org/apache/rocketmq/auth/authorization/builder/DefaultAuthorizationContextBuilderTest.java"", ""broker/src/test/java/org/apache/rocketmq/broker/processor/RecallMessageProcessorTest.java"", ""broker/src/test/java/org/apache/rocketmq/broker/processor/SendMessageProcessorTest.java"", ""client/src/test/java/org/apache/rocketmq/client/impl/MQClientAPIImplTest.java"", ""client/src/test/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExtTest.java"", ""client/src/test/java/org/apache/rocketmq/client/producer/selector/DefaultMQProducerImplTest.java"", ""common/src/test/java/org/apache/rocketmq/common/producer/RecallMessageHandleTest.java"", ""proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/producer/RecallMessageActivityTest.java"", ""proxy/src/test/java/org/apache/rocketmq/proxy/processor/ProducerProcessorTest.java"", ""proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/RecallMessageActivityTest.java"", ""proxy/src/test/java/org/apache/rocketmq/proxy/service/message/LocalMessageServiceTest.java"", ""store/src/test/java/org/apache/rocketmq/store/timer/TimerMessageStoreTest.java"", ""test/BUILD.bazel"", ""test/src/test/java/org/apache/rocketmq/test/grpc/v2/ClusterGrpcIT.java"", ""test/src/test/java/org/apache/rocketmq/test/grpc/v2/GrpcBaseIT.java"", ""test/src/test/java/org/apache/rocketmq/test/grpc/v2/LocalGrpcIT.java"", ""test/src/test/java/org/apache/rocketmq/test/recall/RecallWithTraceIT.java"", ""test/src/test/java/org/apache/rocketmq/test/recall/SendAndRecallDelayMessageIT.java""], ""base_commit"": ""715dd5a885ae89ebc05aea33971029d7306c80ae"", ""head_commit"": ""7750db708f800a81e1b908424b728817c8317c85"", ""repo_url"": ""https://github.com/apache/rocketmq/pull/8975"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/apache__rocketmq/8975"", ""dockerfile"": """", ""pr_merged_at"": ""2024-12-09T08:56:12.000Z"", ""patch"": ""diff --git a/acl/src/main/java/org/apache/rocketmq/acl/plain/PlainAccessResource.java b/acl/src/main/java/org/apache/rocketmq/acl/plain/PlainAccessResource.java\nindex ef05fa6adbb..e45f99799d3 100644\n--- a/acl/src/main/java/org/apache/rocketmq/acl/plain/PlainAccessResource.java\n+++ b/acl/src/main/java/org/apache/rocketmq/acl/plain/PlainAccessResource.java\n@@ -26,6 +26,7 @@\n import apache.rocketmq.v2.NotifyClientTerminationRequest;\n import apache.rocketmq.v2.QueryAssignmentRequest;\n import apache.rocketmq.v2.QueryRouteRequest;\n+import apache.rocketmq.v2.RecallMessageRequest;\n import apache.rocketmq.v2.ReceiveMessageRequest;\n import apache.rocketmq.v2.Resource;\n import apache.rocketmq.v2.SendMessageRequest;\n@@ -128,6 +129,9 @@ public static PlainAccessResource parse(RemotingCommand request, String remoteAd\n                     final String topicV2 = request.getExtFields().get(\""b\"");\n                     accessResource.addResourceAndPerm(topicV2, PlainAccessResource.isRetryTopic(topicV2) ? Permission.SUB : Permission.PUB);\n                     break;\n+                case RequestCode.RECALL_MESSAGE:\n+                    accessResource.addResourceAndPerm(request.getExtFields().get(\""topic\""), Permission.PUB);\n+                    break;\n                 case RequestCode.CONSUMER_SEND_MSG_BACK:\n                     accessResource.addResourceAndPerm(getRetryTopic(request.getExtFields().get(\""group\"")), Permission.SUB);\n                     break;\n@@ -232,6 +236,9 @@ public static PlainAccessResource parse(GeneratedMessageV3 messageV3, Authentica\n                     }\n                 }\n                 accessResource.addResourceAndPerm(topic, Permission.PUB);\n+            } else if (RecallMessageRequest.getDescriptor().getFullName().equals(rpcFullName)) {\n+                RecallMessageRequest request = (RecallMessageRequest) messageV3;\n+                accessResource.addResourceAndPerm(request.getTopic(), Permission.PUB);\n             } else if (ReceiveMessageRequest.getDescriptor().getFullName().equals(rpcFullName)) {\n                 ReceiveMessageRequest request = (ReceiveMessageRequest) messageV3;\n                 accessResource.addGroupResourceAndPerm(request.getGroup(), Permission.SUB);\n\ndiff --git a/auth/src/main/java/org/apache/rocketmq/auth/authorization/builder/DefaultAuthorizationContextBuilder.java b/auth/src/main/java/org/apache/rocketmq/auth/authorization/builder/DefaultAuthorizationContextBuilder.java\nindex e69abdaf805..bf86892ea61 100644\n--- a/auth/src/main/java/org/apache/rocketmq/auth/authorization/builder/DefaultAuthorizationContextBuilder.java\n+++ b/auth/src/main/java/org/apache/rocketmq/auth/authorization/builder/DefaultAuthorizationContextBuilder.java\n@@ -25,6 +25,7 @@\n import apache.rocketmq.v2.NotifyClientTerminationRequest;\n import apache.rocketmq.v2.QueryAssignmentRequest;\n import apache.rocketmq.v2.QueryRouteRequest;\n+import apache.rocketmq.v2.RecallMessageRequest;\n import apache.rocketmq.v2.ReceiveMessageRequest;\n import apache.rocketmq.v2.SendMessageRequest;\n import apache.rocketmq.v2.Subscription;\n@@ -101,6 +102,10 @@ public List<DefaultAuthorizationContext> build(Metadata metadata, GeneratedMessa\n             }\n             result = newPubContext(metadata, request.getMessages(0).getTopic());\n         }\n+        if (message instanceof RecallMessageRequest) {\n+            RecallMessageRequest request = (RecallMessageRequest) message;\n+            result = newPubContext(metadata, request.getTopic());\n+        }\n         if (message instanceof EndTransactionRequest) {\n             EndTransactionRequest request = (EndTransactionRequest) message;\n             result = newPubContext(metadata, request.getTopic());\n@@ -207,6 +212,10 @@ public List<DefaultAuthorizationContext> build(ChannelHandlerContext context, Re\n                         result.add(DefaultAuthorizationContext.of(subject, topic, Action.PUB, sourceIp));\n                     }\n                     break;\n+                case RequestCode.RECALL_MESSAGE:\n+                    topic = Resource.ofTopic(fields.get(TOPIC));\n+                    result.add(DefaultAuthorizationContext.of(subject, topic, Action.PUB, sourceIp));\n+                    break;\n                 case RequestCode.END_TRANSACTION:\n                     if (StringUtils.isNotBlank(fields.get(TOPIC))) {\n                         topic = Resource.ofTopic(fields.get(TOPIC));\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java b/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java\nindex b907489bbfb..1df040720cb 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java\n@@ -93,6 +93,7 @@\n import org.apache.rocketmq.broker.processor.PullMessageProcessor;\n import org.apache.rocketmq.broker.processor.QueryAssignmentProcessor;\n import org.apache.rocketmq.broker.processor.QueryMessageProcessor;\n+import org.apache.rocketmq.broker.processor.RecallMessageProcessor;\n import org.apache.rocketmq.broker.processor.ReplyMessageProcessor;\n import org.apache.rocketmq.broker.processor.SendMessageProcessor;\n import org.apache.rocketmq.broker.schedule.ScheduleMessageService;\n@@ -210,6 +211,7 @@ public class BrokerController {\n     protected final QueryAssignmentProcessor queryAssignmentProcessor;\n     protected final ClientManageProcessor clientManageProcessor;\n     protected final SendMessageProcessor sendMessageProcessor;\n+    protected final RecallMessageProcessor recallMessageProcessor;\n     protected final ReplyMessageProcessor replyMessageProcessor;\n     protected final PullRequestHoldService pullRequestHoldService;\n     protected final MessageArrivingListener messageArrivingListener;\n@@ -369,6 +371,7 @@ public BrokerController(\n         this.ackMessageProcessor = new AckMessageProcessor(this);\n         this.changeInvisibleTimeProcessor = new ChangeInvisibleTimeProcessor(this);\n         this.sendMessageProcessor = new SendMessageProcessor(this);\n+        this.recallMessageProcessor = new RecallMessageProcessor(this);\n         this.replyMessageProcessor = new ReplyMessageProcessor(this);\n         this.messageArrivingListener = new NotifyMessageArrivingListener(this.pullRequestHoldService, this.popMessageProcessor, this.notificationProcessor);\n         this.consumerIdsChangeListener = new DefaultConsumerIdsChangeListener(this);\n@@ -1096,10 +1099,12 @@ public void registerProcessor() {\n         this.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendMessageProcessor, this.sendMessageExecutor);\n         this.remotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendMessageProcessor, this.sendMessageExecutor);\n         this.remotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendMessageProcessor, this.sendMessageExecutor);\n+        this.remotingServer.registerProcessor(RequestCode.RECALL_MESSAGE, recallMessageProcessor, this.sendMessageExecutor);\n         this.fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendMessageProcessor, this.sendMessageExecutor);\n         this.fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendMessageProcessor, this.sendMessageExecutor);\n         this.fastRemotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendMessageProcessor, this.sendMessageExecutor);\n         this.fastRemotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendMessageProcessor, this.sendMessageExecutor);\n+        this.fastRemotingServer.registerProcessor(RequestCode.RECALL_MESSAGE, recallMessageProcessor, this.sendMessageExecutor);\n         /**\n          * PullMessageProcessor\n          */\n@@ -2419,6 +2424,10 @@ public SendMessageProcessor getSendMessageProcessor() {\n         return sendMessageProcessor;\n     }\n \n+    public RecallMessageProcessor getRecallMessageProcessor() {\n+        return recallMessageProcessor;\n+    }\n+\n     public QueryAssignmentProcessor getQueryAssignmentProcessor() {\n         return queryAssignmentProcessor;\n     }\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/processor/RecallMessageProcessor.java b/broker/src/main/java/org/apache/rocketmq/broker/processor/RecallMessageProcessor.java\nnew file mode 100644\nindex 00000000000..7a652f43151\n--- /dev/null\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/processor/RecallMessageProcessor.java\n@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.broker.processor;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.apache.rocketmq.broker.BrokerController;\n+import org.apache.rocketmq.common.TopicConfig;\n+import org.apache.rocketmq.common.constant.PermName;\n+import org.apache.rocketmq.common.message.MessageAccessor;\n+import org.apache.rocketmq.common.message.MessageClientIDSetter;\n+import org.apache.rocketmq.common.message.MessageConst;\n+import org.apache.rocketmq.common.message.MessageDecoder;\n+import org.apache.rocketmq.common.message.MessageExt;\n+import org.apache.rocketmq.common.message.MessageExtBrokerInner;\n+import org.apache.rocketmq.common.producer.RecallMessageHandle;\n+import org.apache.rocketmq.remoting.exception.RemotingCommandException;\n+import org.apache.rocketmq.remoting.netty.NettyRequestProcessor;\n+import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n+import org.apache.rocketmq.remoting.protocol.ResponseCode;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageResponseHeader;\n+import org.apache.rocketmq.store.PutMessageResult;\n+import org.apache.rocketmq.store.config.BrokerRole;\n+import org.apache.rocketmq.store.timer.TimerMessageStore;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+public class RecallMessageProcessor implements NettyRequestProcessor {\n+    private static final String RECALL_MESSAGE_TAG = \""_RECALL_TAG_\"";\n+    private final BrokerController brokerController;\n+\n+    public RecallMessageProcessor(final BrokerController brokerController) {\n+        this.brokerController = brokerController;\n+    }\n+\n+    @Override\n+    public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws\n+            RemotingCommandException {\n+        final RemotingCommand response = RemotingCommand.createResponseCommand(RecallMessageResponseHeader.class);\n+        response.addExtField(MessageConst.PROPERTY_MSG_REGION, this.brokerController.getBrokerConfig().getRegionId());\n+        final RecallMessageRequestHeader requestHeader =\n+            request.decodeCommandCustomHeader(RecallMessageRequestHeader.class);\n+\n+        if (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) {\n+            response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);\n+            response.setRemark(\""recall failed, broker service not available\"");\n+            return response;\n+        }\n+\n+        final long startTimestamp = this.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();\n+        if (this.brokerController.getMessageStore().now() < startTimestamp) {\n+            response.setCode(ResponseCode.SERVICE_NOT_AVAILABLE);\n+            response.setRemark(\""recall failed, broker service not available\"");\n+            return response;\n+        }\n+\n+        if (!PermName.isWriteable(this.brokerController.getBrokerConfig().getBrokerPermission())\n+            && !this.brokerController.getBrokerConfig().isAllowRecallWhenBrokerNotWriteable()) {\n+            response.setCode(ResponseCode.SERVICE_NOT_AVAILABLE);\n+            response.setRemark(\""recall failed, broker service not available\"");\n+            return response;\n+        }\n+\n+        TopicConfig topicConfig =\n+            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n+        if (null == topicConfig) {\n+            response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n+            response.setRemark(\""recall failed, the topic[\"" + requestHeader.getTopic() + \""] not exist\"");\n+            return response;\n+        }\n+\n+        RecallMessageHandle.HandleV1 handle;\n+        try {\n+            handle = (RecallMessageHandle.HandleV1) RecallMessageHandle.decodeHandle(requestHeader.getRecallHandle());\n+        } catch (DecoderException e) {\n+            response.setCode(ResponseCode.ILLEGAL_OPERATION);\n+            response.setRemark(e.getMessage());\n+            return response;\n+        }\n+\n+        if (!requestHeader.getTopic().equals(handle.getTopic())) {\n+            response.setCode(ResponseCode.ILLEGAL_OPERATION);\n+            response.setRemark(\""recall failed, topic not match\"");\n+            return response;\n+        }\n+        if (!brokerController.getBrokerConfig().getBrokerName().equals(handle.getBrokerName())) {\n+            response.setCode(ResponseCode.ILLEGAL_OPERATION);\n+            response.setRemark(\""recall failed, broker service not available\"");\n+            return response;\n+        }\n+\n+        long timestamp = NumberUtils.toLong(handle.getTimestampStr(), -1);\n+        long timeLeft = timestamp - System.currentTimeMillis();\n+        if (timeLeft <= 0\n+            || timeLeft >= brokerController.getMessageStoreConfig().getTimerMaxDelaySec() * 1000L) {\n+            response.setCode(ResponseCode.ILLEGAL_OPERATION);\n+            response.setRemark(\""recall failed, timestamp invalid\"");\n+            return response;\n+        }\n+\n+        MessageExtBrokerInner msgInner = buildMessage(ctx, requestHeader, handle);\n+        long beginTimeMillis = this.brokerController.getMessageStore().now();\n+        PutMessageResult putMessageResult = this.brokerController.getMessageStore().putMessage(msgInner);\n+        handlePutMessageResult(putMessageResult, request, response, msgInner, ctx, beginTimeMillis);\n+        return response;\n+    }\n+\n+    public MessageExtBrokerInner buildMessage(ChannelHandlerContext ctx, RecallMessageRequestHeader requestHeader,\n+        RecallMessageHandle.HandleV1 handle) {\n+        MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n+        msgInner.setTopic(handle.getTopic());\n+        msgInner.setBody(\""0\"".getBytes(StandardCharsets.UTF_8));\n+        msgInner.setTags(RECALL_MESSAGE_TAG);\n+        msgInner.setTagsCode(RECALL_MESSAGE_TAG.hashCode());\n+        msgInner.setQueueId(0);\n+        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_TIMER_DEL_UNIQKEY,\n+            TimerMessageStore.buildDeleteKey(handle.getTopic(), handle.getMessageId()));\n+        MessageAccessor.putProperty(msgInner,\n+            MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, handle.getMessageId());\n+        MessageAccessor.putProperty(msgInner,\n+            MessageConst.PROPERTY_TIMER_DELIVER_MS, String.valueOf(handle.getTimestampStr()));\n+        MessageAccessor.putProperty(msgInner,\n+            MessageConst.PROPERTY_BORN_TIMESTAMP, String.valueOf(System.currentTimeMillis()));\n+        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_TRACE_CONTEXT, \""\"");\n+        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_PRODUCER_GROUP, requestHeader.getProducerGroup());\n+        msgInner.setBornTimestamp(System.currentTimeMillis());\n+        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));\n+        msgInner.setBornHost(ctx.channel().remoteAddress());\n+        msgInner.setStoreHost(this.brokerController.getStoreHost());\n+        return msgInner;\n+    }\n+\n+    public void handlePutMessageResult(PutMessageResult putMessageResult, RemotingCommand request,\n+        RemotingCommand response, MessageExt message, ChannelHandlerContext ctx, long beginTimeMillis) {\n+        if (null == putMessageResult) {\n+            response.setCode(ResponseCode.SYSTEM_ERROR);\n+            response.setRemark(\""recall failed, execute error\"");\n+            return;\n+        }\n+        RecallMessageResponseHeader responseHeader = (RecallMessageResponseHeader) response.readCustomHeader();\n+        switch (putMessageResult.getPutMessageStatus()) {\n+            case PUT_OK:\n+                this.brokerController.getBrokerStatsManager().incTopicPutNums(\n+                    message.getTopic(), putMessageResult.getAppendMessageResult().getMsgNum(), 1); // system timer topic\n+                this.brokerController.getBrokerStatsManager().incTopicPutSize(\n+                    message.getTopic(), putMessageResult.getAppendMessageResult().getWroteBytes());\n+                this.brokerController.getBrokerStatsManager().incBrokerPutNums(\n+                    message.getTopic(), putMessageResult.getAppendMessageResult().getMsgNum());\n+                this.brokerController.getBrokerStatsManager().incTopicPutLatency(\n+                    message.getTopic(), 0, (int) (this.brokerController.getMessageStore().now() - beginTimeMillis));\n+            case FLUSH_DISK_TIMEOUT:\n+            case FLUSH_SLAVE_TIMEOUT:\n+            case SLAVE_NOT_AVAILABLE:\n+                response.setCode(ResponseCode.SUCCESS);\n+                responseHeader.setMsgId(MessageClientIDSetter.getUniqID(message));\n+                break;\n+            default:\n+                response.setCode(ResponseCode.SYSTEM_ERROR);\n+                response.setRemark(\""recall failed, execute error\"");\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public boolean rejectRequest() {\n+        return false;\n+    }\n+}\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java b/broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java\nindex db5b22888dc..669cd5e6771 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java\n@@ -40,6 +40,7 @@\n import org.apache.rocketmq.common.message.MessageExt;\n import org.apache.rocketmq.common.message.MessageExtBatch;\n import org.apache.rocketmq.common.message.MessageExtBrokerInner;\n+import org.apache.rocketmq.common.producer.RecallMessageHandle;\n import org.apache.rocketmq.common.sysflag.MessageSysFlag;\n import org.apache.rocketmq.common.topic.TopicValidator;\n import org.apache.rocketmq.common.utils.CleanupPolicyUtils;\n@@ -483,6 +484,7 @@ private RemotingCommand handlePutMessageResult(PutMessageResult putMessageResult\n             responseHeader.setQueueId(queueIdInt);\n             responseHeader.setQueueOffset(putMessageResult.getAppendMessageResult().getLogicsOffset());\n             responseHeader.setTransactionId(MessageClientIDSetter.getUniqID(msg));\n+            attachRecallHandle(request, msg, responseHeader);\n \n             RemotingCommand rewriteResult = rewriteResponseForStaticTopic(responseHeader, mappingContext);\n             if (rewriteResult != null) {\n@@ -647,6 +649,21 @@ private RemotingCommand sendBatchMessage(final ChannelHandlerContext ctx,\n         }\n     }\n \n+    public void attachRecallHandle(RemotingCommand request, MessageExt msg, SendMessageResponseHeader responseHeader) {\n+        if (RequestCode.SEND_BATCH_MESSAGE == request.getCode()\n+            || RequestCode.CONSUMER_SEND_MSG_BACK == request.getCode()) {\n+            return;\n+        }\n+        String timestampStr = msg.getProperty(MessageConst.PROPERTY_TIMER_OUT_MS);\n+        String realTopic = msg.getProperty(MessageConst.PROPERTY_REAL_TOPIC);\n+        if (timestampStr != null && realTopic != null && !realTopic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n+            timestampStr = String.valueOf(Long.parseLong(timestampStr) + 1); // consider of floor\n+            String recallHandle = RecallMessageHandle.HandleV1.buildHandle(realTopic,\n+                brokerController.getBrokerConfig().getBrokerName(), timestampStr, MessageClientIDSetter.getUniqID(msg));\n+            responseHeader.setRecallHandle(recallHandle);\n+        }\n+    }\n+\n     private String diskUtil() {\n         double physicRatio = 100;\n         String storePath;\n\ndiff --git a/client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java b/client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java\nindex 554b1efa524..2e088ac9da5 100644\n--- a/client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java\n+++ b/client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java\n@@ -204,6 +204,8 @@\n import org.apache.rocketmq.remoting.protocol.header.QuerySubscriptionByConsumerRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.QueryTopicConsumeByWhoRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.QueryTopicsByConsumerRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageResponseHeader;\n import org.apache.rocketmq.remoting.protocol.header.RemoveBrokerRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.ResetMasterFlushOffsetHeader;\n import org.apache.rocketmq.remoting.protocol.header.ResetOffsetRequestHeader;\n@@ -853,6 +855,7 @@ protected SendResult processSendResponse(\n             uniqMsgId,\n             responseHeader.getMsgId(), messageQueue, responseHeader.getQueueOffset());\n         sendResult.setTransactionId(responseHeader.getTransactionId());\n+        sendResult.setRecallHandle(responseHeader.getRecallHandle());\n         String regionId = response.getExtFields().get(MessageConst.PROPERTY_MSG_REGION);\n         if (regionId == null || regionId.isEmpty()) {\n             regionId = MixAll.DEFAULT_TRACE_REGION_ID;\n@@ -3525,4 +3528,49 @@ public List<AclInfo> listAcl(String addr, String subjectFilter, String resourceF\n         }\n         throw new MQBrokerException(response.getCode(), response.getRemark());\n     }\n+\n+    public String recallMessage(\n+        final String addr,\n+        RecallMessageRequestHeader requestHeader,\n+        final long timeoutMillis\n+    ) throws RemotingException, MQBrokerException, InterruptedException {\n+        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.RECALL_MESSAGE, requestHeader);\n+\n+        RemotingCommand response = this.remotingClient.invokeSync(addr, request, timeoutMillis);\n+        switch (response.getCode()) {\n+            case ResponseCode.SUCCESS: {\n+                RecallMessageResponseHeader responseHeader =\n+                    response.decodeCommandCustomHeader(RecallMessageResponseHeader.class);\n+                return responseHeader.getMsgId();\n+            }\n+            default:\n+                break;\n+        }\n+        throw new MQBrokerException(response.getCode(), response.getRemark(), addr);\n+    }\n+\n+    public void recallMessageAsync(\n+        final String addr,\n+        final RecallMessageRequestHeader requestHeader,\n+        final long timeoutMillis,\n+        final InvokeCallback invokeCallback\n+    ) throws RemotingException, InterruptedException {\n+        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.RECALL_MESSAGE, requestHeader);\n+\n+        this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() {\n+            @Override\n+            public void operationComplete(ResponseFuture responseFuture) {\n+            }\n+\n+            @Override\n+            public void operationSucceed(RemotingCommand response) {\n+                invokeCallback.operationSucceed(response);\n+            }\n+\n+            @Override\n+            public void operationFail(Throwable throwable) {\n+                invokeCallback.operationFail(throwable);\n+            }\n+        });\n+    }\n }\n\ndiff --git a/client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExt.java b/client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExt.java\nindex 0e2092b8a0f..6624b3100d8 100644\n--- a/client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExt.java\n+++ b/client/src/main/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExt.java\n@@ -74,6 +74,8 @@\n import org.apache.rocketmq.remoting.protocol.header.PullMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.QueryConsumerOffsetRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.QueryConsumerOffsetResponseHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageResponseHeader;\n import org.apache.rocketmq.remoting.protocol.header.SearchOffsetRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SearchOffsetResponseHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n@@ -624,6 +626,26 @@ public CompletableFuture<Boolean> notification(String brokerAddr, NotificationRe\n         });\n     }\n \n+    public CompletableFuture<String> recallMessageAsync(String brokerAddr,\n+        RecallMessageRequestHeader requestHeader, long timeoutMillis) {\n+        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.RECALL_MESSAGE, requestHeader);\n+        return this.getRemotingClient().invoke(brokerAddr, request, timeoutMillis).thenCompose(response -> {\n+            CompletableFuture<String> future = new CompletableFuture<>();\n+            if (ResponseCode.SUCCESS == response.getCode()) {\n+                try {\n+                    RecallMessageResponseHeader responseHeader =\n+                        response.decodeCommandCustomHeader(RecallMessageResponseHeader.class);\n+                    future.complete(responseHeader.getMsgId());\n+                } catch (Throwable t) {\n+                    future.completeExceptionally(t);\n+                }\n+            } else {\n+                future.completeExceptionally(new MQBrokerException(response.getCode(), response.getRemark(), brokerAddr));\n+            }\n+            return future;\n+        });\n+    }\n+\n     public CompletableFuture<RemotingCommand> invoke(String brokerAddr, RemotingCommand request, long timeoutMillis) {\n         return getRemotingClient().invoke(brokerAddr, request, timeoutMillis);\n     }\n\ndiff --git a/client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java b/client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java\nindex 3d4fdbec373..15264f0e503 100644\n--- a/client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java\n+++ b/client/src/main/java/org/apache/rocketmq/client/impl/producer/DefaultMQProducerImpl.java\n@@ -35,6 +35,7 @@\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.commons.lang3.StringUtils;\n import org.apache.rocketmq.client.QueryResult;\n import org.apache.rocketmq.client.Validators;\n import org.apache.rocketmq.client.common.ClientErrorCode;\n@@ -81,6 +82,7 @@\n import org.apache.rocketmq.common.message.MessageId;\n import org.apache.rocketmq.common.message.MessageQueue;\n import org.apache.rocketmq.common.message.MessageType;\n+import org.apache.rocketmq.common.producer.RecallMessageHandle;\n import org.apache.rocketmq.common.sysflag.MessageSysFlag;\n import org.apache.rocketmq.common.utils.CorrelationIdUtil;\n import org.apache.rocketmq.remoting.RPCHook;\n@@ -91,6 +93,7 @@\n import org.apache.rocketmq.remoting.protocol.NamespaceUtil;\n import org.apache.rocketmq.remoting.protocol.header.CheckTransactionStateRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.EndTransactionRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n import org.apache.rocketmq.logging.org.slf4j.Logger;\n import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\n@@ -1549,6 +1552,40 @@ public void endTransaction(\n             this.defaultMQProducer.getSendMsgTimeout());\n     }\n \n+    public String recallMessage(\n+        String topic,\n+        String recallHandle) throws RemotingException, MQClientException, MQBrokerException, InterruptedException {\n+        makeSureStateOK();\n+        Validators.checkTopic(topic);\n+        if (NamespaceUtil.isRetryTopic(topic) || NamespaceUtil.isDLQTopic(topic)) {\n+            throw new MQClientException(\""topic is not supported\"", null);\n+        }\n+        RecallMessageHandle.HandleV1 handleEntity;\n+        try {\n+            handleEntity = (RecallMessageHandle.HandleV1) RecallMessageHandle.decodeHandle(recallHandle);\n+        } catch (Exception e) {\n+            throw new MQClientException(e.getMessage(), null);\n+        }\n+\n+        tryToFindTopicPublishInfo(topic);\n+        String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(handleEntity.getBrokerName());\n+        brokerAddr = StringUtils.isNotEmpty(brokerAddr) ?\n+            // find another address to support multi proxy endpoints,\n+            // may cause failure request in proxy-less mode when the broker is temporarily unavailable\n+            brokerAddr : this.mQClientFactory.findBrokerAddrByTopic(topic);\n+        if (StringUtils.isEmpty(brokerAddr)) {\n+            log.warn(\""can't find broker service address. {}\"", handleEntity.getBrokerName());\n+            throw new MQClientException(\""The broker service address not found\"", null);\n+        }\n+        RecallMessageRequestHeader requestHeader = new RecallMessageRequestHeader();\n+        requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());\n+        requestHeader.setTopic(topic);\n+        requestHeader.setRecallHandle(recallHandle);\n+        requestHeader.setBrokerName(handleEntity.getBrokerName());\n+        return this.mQClientFactory.getMQClientAPIImpl().recallMessage(brokerAddr,\n+            requestHeader, this.defaultMQProducer.getSendMsgTimeout());\n+    }\n+\n     public void setCallbackExecutor(final ExecutorService callbackExecutor) {\n         this.mQClientFactory.getMQClientAPIImpl().getRemotingClient().setCallbackExecutor(callbackExecutor);\n     }\n\ndiff --git a/client/src/main/java/org/apache/rocketmq/client/producer/DefaultMQProducer.java b/client/src/main/java/org/apache/rocketmq/client/producer/DefaultMQProducer.java\nindex a8bf7cee85f..e3f81ad9685 100644\n--- a/client/src/main/java/org/apache/rocketmq/client/producer/DefaultMQProducer.java\n+++ b/client/src/main/java/org/apache/rocketmq/client/producer/DefaultMQProducer.java\n@@ -25,6 +25,7 @@\n import org.apache.rocketmq.client.impl.MQClientManager;\n import org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl;\n import org.apache.rocketmq.client.lock.ReadWriteCASLock;\n+import org.apache.rocketmq.client.trace.hook.DefaultRecallMessageTraceHook;\n import org.apache.rocketmq.client.trace.AsyncTraceDispatcher;\n import org.apache.rocketmq.client.trace.TraceDispatcher;\n import org.apache.rocketmq.client.trace.hook.EndTransactionTraceHookImpl;\n@@ -381,6 +382,8 @@ public void start() throws MQClientException {\n                     new SendMessageTraceHookImpl(traceDispatcher));\n                 this.defaultMQProducerImpl.registerEndTransactionHook(\n                     new EndTransactionTraceHookImpl(traceDispatcher));\n+                this.defaultMQProducerImpl.getMqClientFactory().getMQClientAPIImpl().getRemotingClient()\n+                    .registerRPCHook(new DefaultRecallMessageTraceHook(traceDispatcher));\n             } catch (Throwable e) {\n                 logger.error(\""system mqtrace hook init failed ,maybe can't send msg trace data\"");\n             }\n@@ -1128,6 +1131,12 @@ public void send(Collection<Message> msgs, MessageQueue mq,\n         this.defaultMQProducerImpl.send(batch(msgs), queueWithNamespace(mq), sendCallback, timeout);\n     }\n \n+    @Override\n+    public String recallMessage(String topic, String recallHandle)\n+        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n+        return this.defaultMQProducerImpl.recallMessage(withNamespace(topic), recallHandle);\n+    }\n+\n     /**\n      * Sets an Executor to be used for executing callback methods.\n      *\n\ndiff --git a/client/src/main/java/org/apache/rocketmq/client/producer/MQProducer.java b/client/src/main/java/org/apache/rocketmq/client/producer/MQProducer.java\nindex 8bd30e98d7b..4286fdd7f96 100644\n--- a/client/src/main/java/org/apache/rocketmq/client/producer/MQProducer.java\n+++ b/client/src/main/java/org/apache/rocketmq/client/producer/MQProducer.java\n@@ -113,6 +113,9 @@ void send(final Collection<Message> msgs, final MessageQueue mq, final SendCallb\n         final long timeout) throws MQClientException,\n         RemotingException, MQBrokerException, InterruptedException;\n \n+    String recallMessage(String topic, String recallHandle)\n+        throws MQClientException, RemotingException, MQBrokerException, InterruptedException;\n+\n     //for rpc\n     Message request(final Message msg, final long timeout) throws RequestTimeoutException, MQClientException,\n         RemotingException, MQBrokerException, InterruptedException;\n\ndiff --git a/client/src/main/java/org/apache/rocketmq/client/producer/SendResult.java b/client/src/main/java/org/apache/rocketmq/client/producer/SendResult.java\nindex dd7ea1cdc5f..d160eb4eae9 100644\n--- a/client/src/main/java/org/apache/rocketmq/client/producer/SendResult.java\n+++ b/client/src/main/java/org/apache/rocketmq/client/producer/SendResult.java\n@@ -29,6 +29,7 @@ public class SendResult {\n     private String regionId;\n     private boolean traceOn = true;\n     private byte[] rawRespBody;\n+    private String recallHandle;\n \n     public SendResult() {\n     }\n@@ -126,10 +127,18 @@ public void setOffsetMsgId(String offsetMsgId) {\n         this.offsetMsgId = offsetMsgId;\n     }\n \n+    public String getRecallHandle() {\n+        return recallHandle;\n+    }\n+\n+    public void setRecallHandle(String recallHandle) {\n+        this.recallHandle = recallHandle;\n+    }\n+\n     @Override\n     public String toString() {\n         return \""SendResult [sendStatus=\"" + sendStatus + \"", msgId=\"" + msgId + \"", offsetMsgId=\"" + offsetMsgId + \"", messageQueue=\"" + messageQueue\n-            + \"", queueOffset=\"" + queueOffset + \""]\"";\n+            + \"", queueOffset=\"" + queueOffset + \"", recallHandle=\"" + recallHandle + \""]\"";\n     }\n \n     public void setRawRespBody(byte[] body) {\n\ndiff --git a/client/src/main/java/org/apache/rocketmq/client/trace/TraceDataEncoder.java b/client/src/main/java/org/apache/rocketmq/client/trace/TraceDataEncoder.java\nindex 57e9b6410db..1e66aa0498d 100644\n--- a/client/src/main/java/org/apache/rocketmq/client/trace/TraceDataEncoder.java\n+++ b/client/src/main/java/org/apache/rocketmq/client/trace/TraceDataEncoder.java\n@@ -132,6 +132,19 @@ public static List<TraceContext> decoderFromTraceDataString(String traceData) {\n                 endTransactionContext.setTraceBeans(new ArrayList<>(1));\n                 endTransactionContext.getTraceBeans().add(bean);\n                 resList.add(endTransactionContext);\n+            } else if (line[0].equals(TraceType.Recall.name())) {\n+                TraceContext recallContext = new TraceContext();\n+                recallContext.setTraceType(TraceType.Recall);\n+                recallContext.setTimeStamp(Long.parseLong(line[1]));\n+                recallContext.setRegionId(line[2]);\n+                recallContext.setGroupName(line[3]);\n+                TraceBean bean = new TraceBean();\n+                bean.setTopic(line[4]);\n+                bean.setMsgId(line[5]);\n+                recallContext.setSuccess(Boolean.parseBoolean(line[6]));\n+                recallContext.setTraceBeans(new ArrayList<>(1));\n+                recallContext.getTraceBeans().add(bean);\n+                resList.add(recallContext);\n             }\n         }\n         return resList;\n@@ -217,6 +230,17 @@ public static TraceTransferBean encoderFromContextBean(TraceContext ctx) {\n                     .append(bean.isFromTransactionCheck()).append(TraceConstants.FIELD_SPLITOR);\n             }\n             break;\n+            case Recall: {\n+                TraceBean bean = ctx.getTraceBeans().get(0);\n+                sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)\n+                    .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)\n+                    .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)\n+                    .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)\n+                    .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)\n+                    .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)\n+                    .append(ctx.isSuccess()).append(TraceConstants.FIELD_SPLITOR);//\n+            }\n+            break;\n             default:\n         }\n         transferBean.setTransData(sb.toString());\n\ndiff --git a/client/src/main/java/org/apache/rocketmq/client/trace/TraceType.java b/client/src/main/java/org/apache/rocketmq/client/trace/TraceType.java\nindex 8870ddcbdb3..4c0e7d8ab26 100644\n--- a/client/src/main/java/org/apache/rocketmq/client/trace/TraceType.java\n+++ b/client/src/main/java/org/apache/rocketmq/client/trace/TraceType.java\n@@ -18,6 +18,7 @@\n \n public enum TraceType {\n     Pub,\n+    Recall,\n     SubBefore,\n     SubAfter,\n     EndTransaction,\n\ndiff --git a/client/src/main/java/org/apache/rocketmq/client/trace/hook/DefaultRecallMessageTraceHook.java b/client/src/main/java/org/apache/rocketmq/client/trace/hook/DefaultRecallMessageTraceHook.java\nnew file mode 100644\nindex 00000000000..c490a7b3599\n--- /dev/null\n+++ b/client/src/main/java/org/apache/rocketmq/client/trace/hook/DefaultRecallMessageTraceHook.java\n@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.client.trace.hook;\n+\n+import org.apache.rocketmq.client.trace.TraceBean;\n+import org.apache.rocketmq.client.trace.TraceContext;\n+import org.apache.rocketmq.client.trace.TraceDispatcher;\n+import org.apache.rocketmq.client.trace.TraceType;\n+import org.apache.rocketmq.common.message.MessageConst;\n+import org.apache.rocketmq.common.producer.RecallMessageHandle;\n+import org.apache.rocketmq.remoting.RPCHook;\n+import org.apache.rocketmq.remoting.protocol.NamespaceUtil;\n+import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n+import org.apache.rocketmq.remoting.protocol.RequestCode;\n+import org.apache.rocketmq.remoting.protocol.ResponseCode;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n+\n+import java.util.ArrayList;\n+\n+public class DefaultRecallMessageTraceHook implements RPCHook {\n+\n+    private static final String RECALL_TRACE_ENABLE_KEY = \""com.rocketmq.recall.default.trace.enable\"";\n+    private boolean enableDefaultTrace = Boolean.parseBoolean(System.getProperty(RECALL_TRACE_ENABLE_KEY, \""false\""));\n+    private TraceDispatcher traceDispatcher;\n+\n+    public DefaultRecallMessageTraceHook(TraceDispatcher traceDispatcher) {\n+        this.traceDispatcher = traceDispatcher;\n+    }\n+\n+    @Override\n+    public void doBeforeRequest(String remoteAddr, RemotingCommand request) {\n+    }\n+\n+    @Override\n+    public void doAfterResponse(String remoteAddr, RemotingCommand request, RemotingCommand response) {\n+        if (request.getCode() != RequestCode.RECALL_MESSAGE\n+            || !enableDefaultTrace\n+            || null == response.getExtFields()\n+            || null == response.getExtFields().get(MessageConst.PROPERTY_MSG_REGION)\n+            || null == traceDispatcher) {\n+            return;\n+        }\n+\n+        try {\n+            String regionId = response.getExtFields().get(MessageConst.PROPERTY_MSG_REGION);\n+            RecallMessageRequestHeader requestHeader =\n+                request.decodeCommandCustomHeader(RecallMessageRequestHeader.class);\n+            String topic = NamespaceUtil.withoutNamespace(requestHeader.getTopic());\n+            String group = NamespaceUtil.withoutNamespace(requestHeader.getProducerGroup());\n+            String recallHandle = requestHeader.getRecallHandle();\n+            RecallMessageHandle.HandleV1 handleV1 =\n+                (RecallMessageHandle.HandleV1) RecallMessageHandle.decodeHandle(recallHandle);\n+\n+            TraceBean traceBean = new TraceBean();\n+            traceBean.setTopic(topic);\n+            traceBean.setMsgId(handleV1.getMessageId());\n+\n+            TraceContext traceContext = new TraceContext();\n+            traceContext.setRegionId(regionId);\n+            traceContext.setTraceBeans(new ArrayList<>(1));\n+            traceContext.setTraceType(TraceType.Recall);\n+            traceContext.setGroupName(group);\n+            traceContext.getTraceBeans().add(traceBean);\n+            traceContext.setSuccess(ResponseCode.SUCCESS == response.getCode());\n+\n+            traceDispatcher.append(traceContext);\n+        } catch (Exception e) {\n+        }\n+    }\n+}\n\ndiff --git a/common/src/main/java/org/apache/rocketmq/common/BrokerConfig.java b/common/src/main/java/org/apache/rocketmq/common/BrokerConfig.java\nindex 9d8d9135217..437837469df 100644\n--- a/common/src/main/java/org/apache/rocketmq/common/BrokerConfig.java\n+++ b/common/src/main/java/org/apache/rocketmq/common/BrokerConfig.java\n@@ -443,6 +443,8 @@ public class BrokerConfig extends BrokerIdentity {\n      */\n     private String configManagerVersion = ConfigManagerVersion.V1.getVersion();\n \n+    private boolean allowRecallWhenBrokerNotWriteable = true;\n+\n     public String getConfigBlackList() {\n         return configBlackList;\n     }\n@@ -1923,4 +1925,12 @@ public String getConfigManagerVersion() {\n     public void setConfigManagerVersion(String configManagerVersion) {\n         this.configManagerVersion = configManagerVersion;\n     }\n+\n+    public boolean isAllowRecallWhenBrokerNotWriteable() {\n+        return allowRecallWhenBrokerNotWriteable;\n+    }\n+\n+    public void setAllowRecallWhenBrokerNotWriteable(boolean allowRecallWhenBrokerNotWriteable) {\n+        this.allowRecallWhenBrokerNotWriteable = allowRecallWhenBrokerNotWriteable;\n+    }\n }\n\ndiff --git a/common/src/main/java/org/apache/rocketmq/common/producer/RecallMessageHandle.java b/common/src/main/java/org/apache/rocketmq/common/producer/RecallMessageHandle.java\nnew file mode 100644\nindex 00000000000..b00b15bd863\n--- /dev/null\n+++ b/common/src/main/java/org/apache/rocketmq/common/producer/RecallMessageHandle.java\n@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.common.producer;\n+\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.util.Base64;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * handle to recall a message, only support delay message for now\n+ * v1 pattern like this:\n+ * version topic brokerName timestamp messageId\n+ * use Base64 to encode it\n+ */\n+public class RecallMessageHandle {\n+    private static final String SEPARATOR = \"" \"";\n+    private static final String VERSION_1 = \""v1\"";\n+\n+    public static class HandleV1 extends RecallMessageHandle {\n+        private String version;\n+        private String topic;\n+        private String brokerName;\n+        private String timestampStr;\n+        private String messageId; // id of unique key\n+\n+        public HandleV1(String topic, String brokerName, String timestamp, String messageId) {\n+            this.version = VERSION_1;\n+            this.topic = topic;\n+            this.brokerName = brokerName;\n+            this.timestampStr = timestamp;\n+            this.messageId = messageId;\n+        }\n+\n+        // no param check\n+        public static String buildHandle(String topic, String brokerName, String timestampStr, String messageId) {\n+            String rawString = String.join(SEPARATOR, VERSION_1, topic, brokerName, timestampStr, messageId);\n+            return Base64.getUrlEncoder().encodeToString(rawString.getBytes(UTF_8));\n+        }\n+\n+        public String getTopic() {\n+            return topic;\n+        }\n+\n+        public String getBrokerName() {\n+            return brokerName;\n+        }\n+\n+        public String getTimestampStr() {\n+            return timestampStr;\n+        }\n+\n+        public String getMessageId() {\n+            return messageId;\n+        }\n+\n+        public String getVersion() {\n+            return version;\n+        }\n+    }\n+\n+    public static RecallMessageHandle decodeHandle(String handle) throws DecoderException {\n+        if (StringUtils.isEmpty(handle)) {\n+            throw new DecoderException(\""recall handle is invalid\"");\n+        }\n+        String rawString;\n+        try {\n+            rawString =\n+                new String(Base64.getUrlDecoder().decode(handle.getBytes(UTF_8)), UTF_8);\n+        } catch (IllegalArgumentException e) {\n+            throw new DecoderException(\""recall handle is invalid\"");\n+        }\n+        String[] items = rawString.split(SEPARATOR);\n+        if (!VERSION_1.equals(items[0]) || items.length < 5) {\n+            throw new DecoderException(\""recall handle is invalid\"");\n+        }\n+        return new HandleV1(items[1], items[2], items[3], items[4]);\n+    }\n+}\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/interceptor/RequestMapping.java b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/interceptor/RequestMapping.java\nindex 866124d747c..f5edc03ba4a 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/interceptor/RequestMapping.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/interceptor/RequestMapping.java\n@@ -25,6 +25,7 @@\n import apache.rocketmq.v2.NotifyClientTerminationRequest;\n import apache.rocketmq.v2.QueryAssignmentRequest;\n import apache.rocketmq.v2.QueryRouteRequest;\n+import apache.rocketmq.v2.RecallMessageRequest;\n import apache.rocketmq.v2.ReceiveMessageRequest;\n import apache.rocketmq.v2.SendMessageRequest;\n import java.util.HashMap;\n@@ -38,6 +39,7 @@ public class RequestMapping {\n             put(QueryRouteRequest.getDescriptor().getFullName(), RequestCode.GET_ROUTEINFO_BY_TOPIC);\n             put(HeartbeatRequest.getDescriptor().getFullName(), RequestCode.HEART_BEAT);\n             put(SendMessageRequest.getDescriptor().getFullName(), RequestCode.SEND_MESSAGE_V2);\n+            put(RecallMessageRequest.getDescriptor().getFullName(), RequestCode.RECALL_MESSAGE);\n             put(QueryAssignmentRequest.getDescriptor().getFullName(), RequestCode.GET_ROUTEINFO_BY_TOPIC);\n             put(ReceiveMessageRequest.getDescriptor().getFullName(), RequestCode.PULL_MESSAGE);\n             put(AckMessageRequest.getDescriptor().getFullName(), RequestCode.UPDATE_CONSUMER_OFFSET);\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/DefaultGrpcMessingActivity.java b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/DefaultGrpcMessingActivity.java\nindex 091e9086ecc..3c6f120ee58 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/DefaultGrpcMessingActivity.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/DefaultGrpcMessingActivity.java\n@@ -32,6 +32,8 @@\n import apache.rocketmq.v2.QueryAssignmentResponse;\n import apache.rocketmq.v2.QueryRouteRequest;\n import apache.rocketmq.v2.QueryRouteResponse;\n+import apache.rocketmq.v2.RecallMessageRequest;\n+import apache.rocketmq.v2.RecallMessageResponse;\n import apache.rocketmq.v2.ReceiveMessageRequest;\n import apache.rocketmq.v2.ReceiveMessageResponse;\n import apache.rocketmq.v2.SendMessageRequest;\n@@ -51,6 +53,7 @@\n import org.apache.rocketmq.proxy.grpc.v2.consumer.ChangeInvisibleDurationActivity;\n import org.apache.rocketmq.proxy.grpc.v2.consumer.ReceiveMessageActivity;\n import org.apache.rocketmq.proxy.grpc.v2.producer.ForwardMessageToDLQActivity;\n+import org.apache.rocketmq.proxy.grpc.v2.producer.RecallMessageActivity;\n import org.apache.rocketmq.proxy.grpc.v2.producer.SendMessageActivity;\n import org.apache.rocketmq.proxy.grpc.v2.route.RouteActivity;\n import org.apache.rocketmq.proxy.grpc.v2.transaction.EndTransactionActivity;\n@@ -65,6 +68,7 @@ public class DefaultGrpcMessingActivity extends AbstractStartAndShutdown impleme\n     protected AckMessageActivity ackMessageActivity;\n     protected ChangeInvisibleDurationActivity changeInvisibleDurationActivity;\n     protected SendMessageActivity sendMessageActivity;\n+    protected RecallMessageActivity recallMessageActivity;\n     protected ForwardMessageToDLQActivity forwardMessageToDLQActivity;\n     protected EndTransactionActivity endTransactionActivity;\n     protected RouteActivity routeActivity;\n@@ -82,6 +86,7 @@ protected void init(MessagingProcessor messagingProcessor) {\n         this.ackMessageActivity = new AckMessageActivity(messagingProcessor, grpcClientSettingsManager, grpcChannelManager);\n         this.changeInvisibleDurationActivity = new ChangeInvisibleDurationActivity(messagingProcessor, grpcClientSettingsManager, grpcChannelManager);\n         this.sendMessageActivity = new SendMessageActivity(messagingProcessor, grpcClientSettingsManager, grpcChannelManager);\n+        this.recallMessageActivity = new RecallMessageActivity(messagingProcessor, grpcClientSettingsManager, grpcChannelManager);\n         this.forwardMessageToDLQActivity = new ForwardMessageToDLQActivity(messagingProcessor, grpcClientSettingsManager, grpcChannelManager);\n         this.endTransactionActivity = new EndTransactionActivity(messagingProcessor, grpcClientSettingsManager, grpcChannelManager);\n         this.routeActivity = new RouteActivity(messagingProcessor, grpcClientSettingsManager, grpcChannelManager);\n@@ -145,6 +150,12 @@ public CompletableFuture<ChangeInvisibleDurationResponse> changeInvisibleDuratio\n         return this.changeInvisibleDurationActivity.changeInvisibleDuration(ctx, request);\n     }\n \n+    @Override\n+    public CompletableFuture<RecallMessageResponse> recallMessage(ProxyContext ctx,\n+        RecallMessageRequest request) {\n+        return this.recallMessageActivity.recallMessage(ctx, request);\n+    }\n+\n     @Override\n     public ContextStreamObserver<TelemetryCommand> telemetry(StreamObserver<TelemetryCommand> responseObserver) {\n         return this.clientActivity.telemetry(responseObserver);\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/GrpcMessagingApplication.java b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/GrpcMessagingApplication.java\nindex 4f029dec336..c470eda55ca 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/GrpcMessagingApplication.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/GrpcMessagingApplication.java\n@@ -35,6 +35,8 @@\n import apache.rocketmq.v2.QueryAssignmentResponse;\n import apache.rocketmq.v2.QueryRouteRequest;\n import apache.rocketmq.v2.QueryRouteResponse;\n+import apache.rocketmq.v2.RecallMessageRequest;\n+import apache.rocketmq.v2.RecallMessageResponse;\n import apache.rocketmq.v2.ReceiveMessageRequest;\n import apache.rocketmq.v2.ReceiveMessageResponse;\n import apache.rocketmq.v2.SendMessageRequest;\n@@ -371,6 +373,25 @@ public void changeInvisibleDuration(ChangeInvisibleDurationRequest request,\n         }\n     }\n \n+    @Override\n+    public void recallMessage(RecallMessageRequest request, StreamObserver<RecallMessageResponse> responseObserver) {\n+        Function<Status, RecallMessageResponse> statusResponseCreator =\n+            status -> RecallMessageResponse.newBuilder().setStatus(status).build();\n+        ProxyContext context = createContext();\n+        try {\n+            this.addExecutor(this.producerThreadPoolExecutor, // reuse producer thread pool\n+                context,\n+                request,\n+                () -> grpcMessingActivity.recallMessage(context, request)\n+                    .whenComplete((response, throwable) ->\n+                        writeResponse(context, request, response, responseObserver, throwable, statusResponseCreator)),\n+                responseObserver,\n+                statusResponseCreator);\n+        } catch (Throwable t) {\n+            writeResponse(context, request, null, responseObserver, t, statusResponseCreator);\n+        }\n+    }\n+\n     @Override\n     public StreamObserver<TelemetryCommand> telemetry(StreamObserver<TelemetryCommand> responseObserver) {\n         Function<Status, TelemetryCommand> statusResponseCreator = status -> TelemetryCommand.newBuilder().setStatus(status).build();\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/GrpcMessingActivity.java b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/GrpcMessingActivity.java\nindex 77bd3a88f9d..db15f25f6f7 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/GrpcMessingActivity.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/GrpcMessingActivity.java\n@@ -33,6 +33,8 @@\n import apache.rocketmq.v2.QueryAssignmentResponse;\n import apache.rocketmq.v2.QueryRouteRequest;\n import apache.rocketmq.v2.QueryRouteResponse;\n+import apache.rocketmq.v2.RecallMessageRequest;\n+import apache.rocketmq.v2.RecallMessageResponse;\n import apache.rocketmq.v2.ReceiveMessageRequest;\n import apache.rocketmq.v2.ReceiveMessageResponse;\n import apache.rocketmq.v2.SendMessageRequest;\n@@ -69,5 +71,7 @@ CompletableFuture<NotifyClientTerminationResponse> notifyClientTermination(Proxy\n     CompletableFuture<ChangeInvisibleDurationResponse> changeInvisibleDuration(ProxyContext ctx,\n         ChangeInvisibleDurationRequest request);\n \n+    CompletableFuture<RecallMessageResponse> recallMessage(ProxyContext ctx, RecallMessageRequest request);\n+\n     ContextStreamObserver<TelemetryCommand> telemetry(StreamObserver<TelemetryCommand> responseObserver);\n }\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/producer/RecallMessageActivity.java b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/producer/RecallMessageActivity.java\nnew file mode 100644\nindex 00000000000..28ec97dca34\n--- /dev/null\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/producer/RecallMessageActivity.java\n@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.proxy.grpc.v2.producer;\n+\n+import apache.rocketmq.v2.Code;\n+import apache.rocketmq.v2.RecallMessageRequest;\n+import apache.rocketmq.v2.RecallMessageResponse;\n+import apache.rocketmq.v2.Resource;\n+import org.apache.rocketmq.proxy.common.ProxyContext;\n+import org.apache.rocketmq.proxy.grpc.v2.AbstractMessingActivity;\n+import org.apache.rocketmq.proxy.grpc.v2.channel.GrpcChannelManager;\n+import org.apache.rocketmq.proxy.grpc.v2.common.GrpcClientSettingsManager;\n+import org.apache.rocketmq.proxy.grpc.v2.common.ResponseBuilder;\n+import org.apache.rocketmq.proxy.processor.MessagingProcessor;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class RecallMessageActivity extends AbstractMessingActivity {\n+\n+    public RecallMessageActivity(MessagingProcessor messagingProcessor,\n+                                 GrpcClientSettingsManager grpcClientSettingsManager, GrpcChannelManager grpcChannelManager) {\n+        super(messagingProcessor, grpcClientSettingsManager, grpcChannelManager);\n+    }\n+\n+    public CompletableFuture<RecallMessageResponse> recallMessage(ProxyContext ctx,\n+        RecallMessageRequest request) {\n+        CompletableFuture<RecallMessageResponse> future = new CompletableFuture<>();\n+\n+        try {\n+            Resource topic = request.getTopic();\n+            validateTopic(topic);\n+\n+            future = this.messagingProcessor.recallMessage(\n+                ctx,\n+                topic.getName(),\n+                request.getRecallHandle(),\n+                Duration.ofSeconds(2).toMillis()\n+            ).thenApply(result -> RecallMessageResponse.newBuilder()\n+                .setMessageId(result)\n+                .setStatus(ResponseBuilder.getInstance().buildStatus(Code.OK, Code.OK.name()))\n+                .build());\n+        } catch (Throwable t) {\n+            future.completeExceptionally(t);\n+        }\n+        return future;\n+    }\n+}\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/producer/SendMessageActivity.java b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/producer/SendMessageActivity.java\nindex 8a3d315c68c..f7b8014bb99 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/producer/SendMessageActivity.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/grpc/v2/producer/SendMessageActivity.java\n@@ -341,6 +341,7 @@ protected SendMessageResponse convertToSendMessageResponse(ProxyContext ctx, Sen\n                         .setOffset(result.getQueueOffset())\n                         .setMessageId(StringUtils.defaultString(result.getMsgId()))\n                         .setTransactionId(StringUtils.defaultString(result.getTransactionId()))\n+                        .setRecallHandle(StringUtils.defaultString(result.getRecallHandle()))\n                         .build();\n                     break;\n                 default:\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/processor/DefaultMessagingProcessor.java b/proxy/src/main/java/org/apache/rocketmq/proxy/processor/DefaultMessagingProcessor.java\nindex 9c494d7a451..d0c0dd6e655 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/processor/DefaultMessagingProcessor.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/processor/DefaultMessagingProcessor.java\n@@ -261,6 +261,12 @@ public CompletableFuture<Long> getMinOffset(ProxyContext ctx, MessageQueue messa\n         return this.consumerProcessor.getMinOffset(ctx, messageQueue, timeoutMillis);\n     }\n \n+    @Override\n+    public CompletableFuture<String> recallMessage(ProxyContext ctx, String topic,\n+                                                   String recallHandle, long timeoutMillis) {\n+        return this.producerProcessor.recallMessage(ctx, topic, recallHandle, timeoutMillis);\n+    }\n+\n     @Override\n     public CompletableFuture<RemotingCommand> request(ProxyContext ctx, String brokerName, RemotingCommand request,\n         long timeoutMillis) {\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/processor/MessagingProcessor.java b/proxy/src/main/java/org/apache/rocketmq/proxy/processor/MessagingProcessor.java\nindex 03d28262d73..fee0465e2bf 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/processor/MessagingProcessor.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/processor/MessagingProcessor.java\n@@ -260,6 +260,13 @@ CompletableFuture<Long> getMinOffset(\n         long timeoutMillis\n     );\n \n+    CompletableFuture<String> recallMessage(\n+        ProxyContext ctx,\n+        String topic,\n+        String recallHandle,\n+        long timeoutMillis\n+    );\n+\n     CompletableFuture<RemotingCommand> request(ProxyContext ctx, String brokerName, RemotingCommand request,\n         long timeoutMillis);\n \n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/processor/ProducerProcessor.java b/proxy/src/main/java/org/apache/rocketmq/proxy/processor/ProducerProcessor.java\nindex 4f2d5280d37..43e16ddd2d7 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/processor/ProducerProcessor.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/processor/ProducerProcessor.java\n@@ -19,6 +19,7 @@\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutorService;\n+import org.apache.commons.codec.DecoderException;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.rocketmq.client.producer.SendResult;\n import org.apache.rocketmq.client.producer.SendStatus;\n@@ -32,6 +33,7 @@\n import org.apache.rocketmq.common.message.MessageConst;\n import org.apache.rocketmq.common.message.MessageDecoder;\n import org.apache.rocketmq.common.message.MessageId;\n+import org.apache.rocketmq.common.producer.RecallMessageHandle;\n import org.apache.rocketmq.common.sysflag.MessageSysFlag;\n import org.apache.rocketmq.common.topic.TopicValidator;\n import org.apache.rocketmq.common.utils.FutureUtils;\n@@ -49,6 +51,7 @@\n import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n import org.apache.rocketmq.remoting.protocol.ResponseCode;\n import org.apache.rocketmq.remoting.protocol.header.ConsumerSendMsgBackRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n \n public class ProducerProcessor extends AbstractProcessor {\n@@ -124,6 +127,33 @@ public CompletableFuture<List<SendResult>> sendMessage(ProxyContext ctx, QueueSe\n         return FutureUtils.addExecutor(future, this.executor);\n     }\n \n+    public CompletableFuture<String> recallMessage(ProxyContext ctx, String topic,\n+                                                   String recallHandle, long timeoutMillis) {\n+        CompletableFuture<String> future = new CompletableFuture<>();\n+        try {\n+            if (ConfigurationManager.getProxyConfig().isEnableTopicMessageTypeCheck()) {\n+                TopicMessageType messageType = serviceManager.getMetadataService().getTopicMessageType(ctx, topic);\n+                topicMessageTypeValidator.validate(messageType, TopicMessageType.DELAY);\n+            }\n+\n+            RecallMessageHandle.HandleV1 handleEntity;\n+            try {\n+                handleEntity = (RecallMessageHandle.HandleV1) RecallMessageHandle.decodeHandle(recallHandle);\n+            } catch (DecoderException e) {\n+                throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, e.getMessage());\n+            }\n+            String brokerName = handleEntity.getBrokerName();\n+            RecallMessageRequestHeader requestHeader = new RecallMessageRequestHeader();\n+            requestHeader.setTopic(topic);\n+            requestHeader.setRecallHandle(recallHandle);\n+            requestHeader.setBrokerName(brokerName);\n+            future = serviceManager.getMessageService().recallMessage(ctx, brokerName, requestHeader, timeoutMillis);\n+        } catch (Throwable t) {\n+            future.completeExceptionally(t);\n+        }\n+        return FutureUtils.addExecutor(future, this.executor);\n+    }\n+\n     protected void fillTransactionData(ProxyContext ctx, String producerGroup, AddressableMessageQueue messageQueue, SendResult sendResult, List<Message> messageList) {\n         try {\n             MessageId id;\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/remoting/RemotingProtocolServer.java b/proxy/src/main/java/org/apache/rocketmq/proxy/remoting/RemotingProtocolServer.java\nindex 14c7c0db6fa..8c44305b42c 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/remoting/RemotingProtocolServer.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/remoting/RemotingProtocolServer.java\n@@ -45,6 +45,7 @@\n import org.apache.rocketmq.proxy.remoting.activity.GetTopicRouteActivity;\n import org.apache.rocketmq.proxy.remoting.activity.PopMessageActivity;\n import org.apache.rocketmq.proxy.remoting.activity.PullMessageActivity;\n+import org.apache.rocketmq.proxy.remoting.activity.RecallMessageActivity;\n import org.apache.rocketmq.proxy.remoting.activity.SendMessageActivity;\n import org.apache.rocketmq.proxy.remoting.activity.TransactionActivity;\n import org.apache.rocketmq.proxy.remoting.channel.RemotingChannelManager;\n@@ -75,6 +76,7 @@ public class RemotingProtocolServer implements StartAndShutdown, RemotingProxyOu\n     protected final ClientManagerActivity clientManagerActivity;\n     protected final ConsumerManagerActivity consumerManagerActivity;\n     protected final SendMessageActivity sendMessageActivity;\n+    protected final RecallMessageActivity recallMessageActivity;\n     protected final TransactionActivity transactionActivity;\n     protected final PullMessageActivity pullMessageActivity;\n     protected final PopMessageActivity popMessageActivity;\n@@ -97,6 +99,7 @@ public RemotingProtocolServer(MessagingProcessor messagingProcessor, List<Access\n         this.clientManagerActivity = new ClientManagerActivity(pipeline, messagingProcessor, remotingChannelManager);\n         this.consumerManagerActivity = new ConsumerManagerActivity(pipeline, messagingProcessor);\n         this.sendMessageActivity = new SendMessageActivity(pipeline, messagingProcessor);\n+        this.recallMessageActivity = new RecallMessageActivity(pipeline, messagingProcessor);\n         this.transactionActivity = new TransactionActivity(pipeline, messagingProcessor);\n         this.pullMessageActivity = new PullMessageActivity(pipeline, messagingProcessor);\n         this.popMessageActivity = new PopMessageActivity(pipeline, messagingProcessor);\n@@ -195,6 +198,7 @@ protected void registerRemotingServer(RemotingServer remotingServer) {\n         remotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendMessageActivity, sendMessageExecutor);\n \n         remotingServer.registerProcessor(RequestCode.END_TRANSACTION, transactionActivity, sendMessageExecutor);\n+        remotingServer.registerProcessor(RequestCode.RECALL_MESSAGE, recallMessageActivity, sendMessageExecutor);\n \n         remotingServer.registerProcessor(RequestCode.HEART_BEAT, clientManagerActivity, this.heartbeatExecutor);\n         remotingServer.registerProcessor(RequestCode.UNREGISTER_CLIENT, clientManagerActivity, this.defaultExecutor);\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/RecallMessageActivity.java b/proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/RecallMessageActivity.java\nnew file mode 100644\nindex 00000000000..6f17745c974\n--- /dev/null\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/remoting/activity/RecallMessageActivity.java\n@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.proxy.remoting.activity;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import org.apache.rocketmq.common.attribute.TopicMessageType;\n+import org.apache.rocketmq.proxy.common.ProxyContext;\n+import org.apache.rocketmq.proxy.config.ConfigurationManager;\n+import org.apache.rocketmq.proxy.processor.MessagingProcessor;\n+import org.apache.rocketmq.proxy.processor.validator.DefaultTopicMessageTypeValidator;\n+import org.apache.rocketmq.proxy.processor.validator.TopicMessageTypeValidator;\n+import org.apache.rocketmq.proxy.remoting.pipeline.RequestPipeline;\n+import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n+\n+import java.time.Duration;\n+\n+public class RecallMessageActivity extends AbstractRemotingActivity {\n+    TopicMessageTypeValidator topicMessageTypeValidator;\n+\n+    public RecallMessageActivity(RequestPipeline requestPipeline,\n+                                 MessagingProcessor messagingProcessor) {\n+        super(requestPipeline, messagingProcessor);\n+        this.topicMessageTypeValidator = new DefaultTopicMessageTypeValidator();\n+    }\n+\n+    @Override\n+    public RemotingCommand processRequest0(ChannelHandlerContext ctx, RemotingCommand request,\n+        ProxyContext context) throws Exception {\n+        RecallMessageRequestHeader requestHeader = request.decodeCommandCustomHeader(RecallMessageRequestHeader.class);\n+        String topic = requestHeader.getTopic();\n+        if (ConfigurationManager.getProxyConfig().isEnableTopicMessageTypeCheck()) {\n+            TopicMessageType messageType = messagingProcessor.getMetadataService().getTopicMessageType(context, topic);\n+            topicMessageTypeValidator.validate(messageType, TopicMessageType.DELAY);\n+        }\n+        return request(ctx, request, context, Duration.ofSeconds(2).toMillis());\n+    }\n+}\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/service/message/ClusterMessageService.java b/proxy/src/main/java/org/apache/rocketmq/proxy/service/message/ClusterMessageService.java\nindex f9eb94fcfce..f6f3406ab4e 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/service/message/ClusterMessageService.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/service/message/ClusterMessageService.java\n@@ -47,6 +47,7 @@\n import org.apache.rocketmq.remoting.protocol.header.PopMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.PullMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.QueryConsumerOffsetRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.UpdateConsumerOffsetRequestHeader;\n \n@@ -232,6 +233,16 @@ public CompletableFuture<Long> getMinOffset(ProxyContext ctx, AddressableMessage\n         );\n     }\n \n+    @Override\n+    public CompletableFuture<String> recallMessage(ProxyContext ctx, String brokerName,\n+        RecallMessageRequestHeader requestHeader, long timeoutMillis) {\n+        return this.mqClientAPIFactory.getClient().recallMessageAsync(\n+            this.resolveBrokerAddr(ctx, brokerName),\n+            requestHeader,\n+            timeoutMillis\n+        );\n+    }\n+\n     @Override\n     public CompletableFuture<RemotingCommand> request(ProxyContext ctx, String brokerName, RemotingCommand request,\n         long timeoutMillis) {\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/service/message/LocalMessageService.java b/proxy/src/main/java/org/apache/rocketmq/proxy/service/message/LocalMessageService.java\nindex a8088a95d0a..cb9b7a4ae00 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/service/message/LocalMessageService.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/service/message/LocalMessageService.java\n@@ -71,6 +71,8 @@\n import org.apache.rocketmq.remoting.protocol.header.PopMessageResponseHeader;\n import org.apache.rocketmq.remoting.protocol.header.PullMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.QueryConsumerOffsetRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageResponseHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageResponseHeader;\n import org.apache.rocketmq.remoting.protocol.header.UpdateConsumerOffsetRequestHeader;\n@@ -153,6 +155,7 @@ public CompletableFuture<List<SendResult>> sendMessage(ProxyContext ctx, Address\n             sendResult.setQueueOffset(responseHeader.getQueueOffset());\n             sendResult.setTransactionId(responseHeader.getTransactionId());\n             sendResult.setOffsetMsgId(responseHeader.getMsgId());\n+            sendResult.setRecallHandle(responseHeader.getRecallHandle());\n             return Collections.singletonList(sendResult);\n         });\n     }\n@@ -470,6 +473,32 @@ public CompletableFuture<Long> getMinOffset(ProxyContext ctx, AddressableMessage\n         throw new NotImplementedException(\""getMinOffset is not implemented in LocalMessageService\"");\n     }\n \n+    @Override\n+    public CompletableFuture<String> recallMessage(ProxyContext ctx, String brokerName,\n+        RecallMessageRequestHeader requestHeader, long timeoutMillis) {\n+        SimpleChannel channel = channelManager.createChannel(ctx);\n+        ChannelHandlerContext channelHandlerContext = channel.getChannelHandlerContext();\n+        RemotingCommand command =\n+            LocalRemotingCommand.createRequestCommand(RequestCode.RECALL_MESSAGE, requestHeader, ctx.getLanguage());\n+        CompletableFuture<RemotingCommand> future = new CompletableFuture<>();\n+        try {\n+            RemotingCommand response = brokerController.getRecallMessageProcessor()\n+                .processRequest(channelHandlerContext, command);\n+            future.complete(response);\n+        } catch (Exception e) {\n+            log.error(\""Fail to process recallMessage command\"", e);\n+            future.completeExceptionally(e);\n+        }\n+        return future.thenApply(r -> {\n+            switch (r.getCode()) {\n+                case ResponseCode.SUCCESS:\n+                    return ((RecallMessageResponseHeader) r.readCustomHeader()).getMsgId();\n+                default:\n+                    throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, r.getRemark());\n+            }\n+        });\n+    }\n+\n     @Override\n     public CompletableFuture<RemotingCommand> request(ProxyContext ctx, String brokerName, RemotingCommand request,\n         long timeoutMillis) {\n\ndiff --git a/proxy/src/main/java/org/apache/rocketmq/proxy/service/message/MessageService.java b/proxy/src/main/java/org/apache/rocketmq/proxy/service/message/MessageService.java\nindex 61accbc0412..80f5ae7217c 100644\n--- a/proxy/src/main/java/org/apache/rocketmq/proxy/service/message/MessageService.java\n+++ b/proxy/src/main/java/org/apache/rocketmq/proxy/service/message/MessageService.java\n@@ -40,6 +40,7 @@\n import org.apache.rocketmq.remoting.protocol.header.PopMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.PullMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.QueryConsumerOffsetRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.UpdateConsumerOffsetRequestHeader;\n \n@@ -155,6 +156,13 @@ CompletableFuture<Long> getMinOffset(\n         long timeoutMillis\n     );\n \n+    CompletableFuture<String> recallMessage(\n+        ProxyContext ctx,\n+        String brokerName,\n+        RecallMessageRequestHeader requestHeader,\n+        long timeoutMillis\n+    );\n+\n     CompletableFuture<RemotingCommand> request(ProxyContext ctx, String brokerName, RemotingCommand request,\n         long timeoutMillis);\n \n\ndiff --git a/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/RequestCode.java b/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/RequestCode.java\nindex cfc5cc22785..9e86422c482 100644\n--- a/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/RequestCode.java\n+++ b/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/RequestCode.java\n@@ -220,6 +220,7 @@ public class RequestCode {\n     public static final int CHECK_ROCKSDB_CQ_WRITE_PROGRESS = 354;\n \n     public static final int LITE_PULL_MESSAGE = 361;\n+    public static final int RECALL_MESSAGE = 370;\n \n     public static final int QUERY_ASSIGNMENT = 400;\n     public static final int SET_MESSAGE_REQUEST_MODE = 401;\n\ndiff --git a/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/RecallMessageRequestHeader.java b/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/RecallMessageRequestHeader.java\nnew file mode 100644\nindex 00000000000..c29883682a0\n--- /dev/null\n+++ b/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/RecallMessageRequestHeader.java\n@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.remoting.protocol.header;\n+\n+import com.google.common.base.MoreObjects;\n+import org.apache.rocketmq.common.action.Action;\n+import org.apache.rocketmq.common.action.RocketMQAction;\n+import org.apache.rocketmq.common.resource.ResourceType;\n+import org.apache.rocketmq.common.resource.RocketMQResource;\n+import org.apache.rocketmq.remoting.annotation.CFNotNull;\n+import org.apache.rocketmq.remoting.annotation.CFNullable;\n+import org.apache.rocketmq.remoting.exception.RemotingCommandException;\n+import org.apache.rocketmq.remoting.protocol.RequestCode;\n+import org.apache.rocketmq.remoting.rpc.TopicRequestHeader;\n+\n+@RocketMQAction(value = RequestCode.RECALL_MESSAGE, action = Action.PUB)\n+public class RecallMessageRequestHeader extends TopicRequestHeader {\n+    @CFNullable\n+    private String producerGroup;\n+\n+    @CFNotNull\n+    @RocketMQResource(ResourceType.TOPIC)\n+    private String topic;\n+\n+    @CFNotNull\n+    private String recallHandle;\n+\n+    @Override\n+    public void checkFields() throws RemotingCommandException {\n+    }\n+\n+    public String getProducerGroup() {\n+        return producerGroup;\n+    }\n+\n+    public void setProducerGroup(String producerGroup) {\n+        this.producerGroup = producerGroup;\n+    }\n+\n+    public String getTopic() {\n+        return topic;\n+    }\n+\n+    public void setTopic(String topic) {\n+        this.topic = topic;\n+    }\n+\n+    public String getRecallHandle() {\n+        return recallHandle;\n+    }\n+\n+    public void setRecallHandle(String recallHandle) {\n+        this.recallHandle = recallHandle;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return MoreObjects.toStringHelper(this)\n+                .add(\""producerGroup\"", producerGroup)\n+                .add(\""topic\"", topic)\n+                .add(\""recallHandle\"", recallHandle)\n+                .toString();\n+    }\n+}\n\ndiff --git a/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/RecallMessageResponseHeader.java b/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/RecallMessageResponseHeader.java\nnew file mode 100644\nindex 00000000000..1833cfcd053\n--- /dev/null\n+++ b/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/RecallMessageResponseHeader.java\n@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.remoting.protocol.header;\n+\n+import org.apache.rocketmq.remoting.CommandCustomHeader;\n+import org.apache.rocketmq.remoting.annotation.CFNotNull;\n+import org.apache.rocketmq.remoting.exception.RemotingCommandException;\n+\n+public class RecallMessageResponseHeader implements CommandCustomHeader {\n+    @CFNotNull\n+    private String msgId;\n+    @Override\n+    public void checkFields() throws RemotingCommandException {\n+    }\n+\n+    public String getMsgId() {\n+        return msgId;\n+    }\n+\n+    public void setMsgId(String msgId) {\n+        this.msgId = msgId;\n+    }\n+}\n\ndiff --git a/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/SendMessageResponseHeader.java b/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/SendMessageResponseHeader.java\nindex fe1e8533e54..7563b910331 100644\n--- a/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/SendMessageResponseHeader.java\n+++ b/remoting/src/main/java/org/apache/rocketmq/remoting/protocol/header/SendMessageResponseHeader.java\n@@ -36,6 +36,7 @@ public class SendMessageResponseHeader implements CommandCustomHeader, FastCodes\n     private Long queueOffset;\n     private String transactionId;\n     private String batchUniqId;\n+    private String recallHandle;\n \n     @Override\n     public void checkFields() throws RemotingCommandException {\n@@ -48,6 +49,7 @@ public void encode(ByteBuf out) {\n         writeIfNotNull(out, \""queueOffset\"", queueOffset);\n         writeIfNotNull(out, \""transactionId\"", transactionId);\n         writeIfNotNull(out, \""batchUniqId\"", batchUniqId);\n+        writeIfNotNull(out, \""recallHandle\"", recallHandle);\n     }\n \n     @Override\n@@ -76,6 +78,11 @@ public void decode(HashMap<String, String> fields) throws RemotingCommandExcepti\n         if (str != null) {\n             this.batchUniqId = str;\n         }\n+\n+        str = fields.get(\""recallHandle\"");\n+        if (str != null) {\n+            this.recallHandle = str;\n+        }\n     }\n \n     public String getMsgId() {\n@@ -117,4 +124,12 @@ public String getBatchUniqId() {\n     public void setBatchUniqId(String batchUniqId) {\n         this.batchUniqId = batchUniqId;\n     }\n+\n+    public String getRecallHandle() {\n+        return recallHandle;\n+    }\n+\n+    public void setRecallHandle(String recallHandle) {\n+        this.recallHandle = recallHandle;\n+    }\n }\n\ndiff --git a/store/src/main/java/org/apache/rocketmq/store/timer/TimerMessageStore.java b/store/src/main/java/org/apache/rocketmq/store/timer/TimerMessageStore.java\nindex 071b1c02192..84ba6f5179e 100644\n--- a/store/src/main/java/org/apache/rocketmq/store/timer/TimerMessageStore.java\n+++ b/store/src/main/java/org/apache/rocketmq/store/timer/TimerMessageStore.java\n@@ -1567,7 +1567,8 @@ public void run() {\n                                     if (null == uniqueKey) {\n                                         LOGGER.warn(\""No uniqueKey for msg:{}\"", msgExt);\n                                     }\n-                                    if (null != uniqueKey && tr.getDeleteList() != null && tr.getDeleteList().size() > 0 && tr.getDeleteList().contains(uniqueKey)) {\n+                                    if (null != uniqueKey && tr.getDeleteList() != null && tr.getDeleteList().size() > 0\n+                                        && tr.getDeleteList().contains(buildDeleteKey(getRealTopic(msgExt), uniqueKey))) {\n                                         //Normally, it cancels out with the +1 above\n                                         addMetric(msgExt, -1);\n                                         doRes = true;\n@@ -1877,4 +1878,9 @@ public void setFrequency(AtomicInteger frequency) {\n     public TimerCheckpoint getTimerCheckpoint() {\n         return timerCheckpoint;\n     }\n+\n+    // identify a message by topic + uk, like query operation\n+    public static String buildDeleteKey(String realTopic, String uniqueKey) {\n+        return realTopic + \""+\"" + uniqueKey;\n+    }\n }\n"", ""test_patch"": ""diff --git a/acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessResourceTest.java b/acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessResourceTest.java\nindex 8ff3d610486..bccd37e39ef 100644\n--- a/acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessResourceTest.java\n+++ b/acl/src/test/java/org/apache/rocketmq/acl/plain/PlainAccessResourceTest.java\n@@ -19,10 +19,15 @@\n \n import java.util.HashMap;\n import java.util.Map;\n+import apache.rocketmq.v2.RecallMessageRequest;\n+import apache.rocketmq.v2.Resource;\n+import com.google.protobuf.GeneratedMessageV3;\n+import org.apache.rocketmq.acl.common.AuthenticationHeader;\n import org.apache.rocketmq.acl.common.Permission;\n import org.apache.rocketmq.common.MixAll;\n import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n import org.apache.rocketmq.remoting.protocol.RequestCode;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeaderV2;\n import org.junit.Assert;\n@@ -33,6 +38,8 @@ public class PlainAccessResourceTest {\n     public static final String DEFAULT_PRODUCER_GROUP = \""PID_acl\"";\n     public static final String DEFAULT_CONSUMER_GROUP = \""GID_acl\"";\n     public static final String DEFAULT_REMOTE_ADDR = \""192.128.1.1\"";\n+    public static final String AUTH_HEADER =\n+        \""Signature Credential=1234567890/test, SignedHeaders=host, Signature=1234567890\"";\n \n     @Test\n     public void testParseSendNormal() {\n@@ -93,4 +100,34 @@ public void testParseSendRetryV2() {\n \n         Assert.assertEquals(permMap, accessResource.getResourcePermMap());\n     }\n+\n+    @Test\n+    public void testParseRecallMessage() {\n+        // remoting\n+        RecallMessageRequestHeader requestHeader = new RecallMessageRequestHeader();\n+        requestHeader.setTopic(DEFAULT_TOPIC);\n+        requestHeader.setProducerGroup(DEFAULT_PRODUCER_GROUP);\n+        requestHeader.setRecallHandle(\""handle\"");\n+        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.RECALL_MESSAGE, requestHeader);\n+        request.makeCustomHeaderToNet();\n+\n+        PlainAccessResource accessResource = PlainAccessResource.parse(request, DEFAULT_REMOTE_ADDR);\n+        Assert.assertTrue(Permission.PUB == accessResource.getResourcePermMap().get(DEFAULT_TOPIC));\n+\n+        // grpc\n+        GeneratedMessageV3 grpcRequest = RecallMessageRequest.newBuilder()\n+            .setTopic(Resource.newBuilder().setName(DEFAULT_TOPIC).build())\n+            .setRecallHandle(\""handle\"")\n+            .build();\n+        accessResource = PlainAccessResource.parse(grpcRequest, mockAuthenticationHeader());\n+        Assert.assertTrue(Permission.PUB == accessResource.getResourcePermMap().get(DEFAULT_TOPIC));\n+    }\n+\n+    private AuthenticationHeader mockAuthenticationHeader() {\n+        return AuthenticationHeader.builder()\n+            .remoteAddress(DEFAULT_REMOTE_ADDR)\n+            .authorization(AUTH_HEADER)\n+            .datetime(\""datetime\"")\n+            .build();\n+    }\n }\n\ndiff --git a/auth/src/test/java/org/apache/rocketmq/auth/authorization/builder/DefaultAuthorizationContextBuilderTest.java b/auth/src/test/java/org/apache/rocketmq/auth/authorization/builder/DefaultAuthorizationContextBuilderTest.java\nindex 4ee73f3d797..c73e07d7529 100644\n--- a/auth/src/test/java/org/apache/rocketmq/auth/authorization/builder/DefaultAuthorizationContextBuilderTest.java\n+++ b/auth/src/test/java/org/apache/rocketmq/auth/authorization/builder/DefaultAuthorizationContextBuilderTest.java\n@@ -28,6 +28,7 @@\n import apache.rocketmq.v2.Publishing;\n import apache.rocketmq.v2.QueryAssignmentRequest;\n import apache.rocketmq.v2.QueryRouteRequest;\n+import apache.rocketmq.v2.RecallMessageRequest;\n import apache.rocketmq.v2.ReceiveMessageRequest;\n import apache.rocketmq.v2.Resource;\n import apache.rocketmq.v2.SendMessageRequest;\n@@ -65,6 +66,7 @@\n import org.apache.rocketmq.remoting.protocol.header.PullMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.QueryConsumerOffsetRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.QueryMessageRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeaderV2;\n import org.apache.rocketmq.remoting.protocol.header.UnregisterClientRequestHeader;\n@@ -122,6 +124,19 @@ public void buildGrpc() {\n         Assert.assertEquals(result.get(0).getChannelId(), \""channel-id\"");\n         Assert.assertEquals(result.get(0).getRpcCode(), SendMessageRequest.getDescriptor().getFullName());\n \n+        request = RecallMessageRequest.newBuilder()\n+            .setTopic(Resource.newBuilder().setName(\""topic\"").build())\n+            .setRecallHandle(\""handle\"")\n+            .build();\n+        result = builder.build(metadata, request);\n+        Assert.assertEquals(1, result.size());\n+        Assert.assertEquals(result.get(0).getSubject().getSubjectKey(), \""User:rocketmq\"");\n+        Assert.assertEquals(result.get(0).getResource().getResourceKey(), \""Topic:topic\"");\n+        Assert.assertTrue(result.get(0).getActions().containsAll(Arrays.asList(Action.PUB)));\n+        Assert.assertEquals(result.get(0).getSourceIp(), \""192.168.0.1\"");\n+        Assert.assertEquals(result.get(0).getChannelId(), \""channel-id\"");\n+        Assert.assertEquals(result.get(0).getRpcCode(), RecallMessageRequest.getDescriptor().getFullName());\n+\n         request = EndTransactionRequest.newBuilder()\n             .setTopic(Resource.newBuilder().setName(\""topic\"").build())\n             .build();\n@@ -315,6 +330,22 @@ public void buildRemoting() {\n         Assert.assertEquals(\""Group:group\"", result.get(0).getResource().getResourceKey());\n         Assert.assertTrue(result.get(0).getActions().containsAll(Arrays.asList(Action.SUB)));\n \n+        RecallMessageRequestHeader recallMessageRequestHeader = new RecallMessageRequestHeader();\n+        recallMessageRequestHeader.setTopic(\""topic\"");\n+        recallMessageRequestHeader.setRecallHandle(\""handle\"");\n+        request = RemotingCommand.createRequestCommand(RequestCode.RECALL_MESSAGE, recallMessageRequestHeader);\n+        request.setVersion(441);\n+        request.addExtField(\""AccessKey\"", \""rocketmq\"");\n+        request.makeCustomHeaderToNet();\n+        result = builder.build(channelHandlerContext, request);\n+        Assert.assertEquals(1, result.size());\n+        Assert.assertEquals(\""User:rocketmq\"", result.get(0).getSubject().getSubjectKey());\n+        Assert.assertEquals(\""Topic:topic\"", result.get(0).getResource().getResourceKey());\n+        Assert.assertTrue(result.get(0).getActions().containsAll(Arrays.asList(Action.PUB)));\n+        Assert.assertEquals(\""192.168.0.1\"", result.get(0).getSourceIp());\n+        Assert.assertEquals(\""channel-id\"", result.get(0).getChannelId());\n+        Assert.assertEquals(RequestCode.RECALL_MESSAGE + \""\"", result.get(0).getRpcCode());\n+\n         EndTransactionRequestHeader endTransactionRequestHeader = new EndTransactionRequestHeader();\n         endTransactionRequestHeader.setTopic(\""topic\"");\n         request = RemotingCommand.createRequestCommand(RequestCode.END_TRANSACTION, endTransactionRequestHeader);\n\ndiff --git a/broker/src/test/java/org/apache/rocketmq/broker/processor/RecallMessageProcessorTest.java b/broker/src/test/java/org/apache/rocketmq/broker/processor/RecallMessageProcessorTest.java\nnew file mode 100644\nindex 00000000000..7bd260cc2c0\n--- /dev/null\n+++ b/broker/src/test/java/org/apache/rocketmq/broker/processor/RecallMessageProcessorTest.java\n@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.broker.processor;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import org.apache.rocketmq.broker.BrokerController;\n+import org.apache.rocketmq.broker.topic.TopicConfigManager;\n+import org.apache.rocketmq.common.BrokerConfig;\n+import org.apache.rocketmq.common.TopicConfig;\n+import org.apache.rocketmq.common.message.MessageAccessor;\n+import org.apache.rocketmq.common.message.MessageConst;\n+import org.apache.rocketmq.common.message.MessageDecoder;\n+import org.apache.rocketmq.common.message.MessageExt;\n+import org.apache.rocketmq.common.message.MessageExtBrokerInner;\n+import org.apache.rocketmq.common.producer.RecallMessageHandle;\n+import org.apache.rocketmq.remoting.exception.RemotingCommandException;\n+import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n+import org.apache.rocketmq.remoting.protocol.RequestCode;\n+import org.apache.rocketmq.remoting.protocol.ResponseCode;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageResponseHeader;\n+import org.apache.rocketmq.store.AppendMessageResult;\n+import org.apache.rocketmq.store.AppendMessageStatus;\n+import org.apache.rocketmq.store.MessageStore;\n+import org.apache.rocketmq.store.PutMessageResult;\n+import org.apache.rocketmq.store.PutMessageStatus;\n+import org.apache.rocketmq.store.config.BrokerRole;\n+import org.apache.rocketmq.store.config.MessageStoreConfig;\n+import org.apache.rocketmq.store.stats.BrokerStatsManager;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.verify;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class RecallMessageProcessorTest {\n+    private static final String TOPIC = \""topic\"";\n+    private static final String BROKER_NAME = \""brokerName\"";\n+\n+    private RecallMessageProcessor recallMessageProcessor;\n+    @Mock\n+    private BrokerConfig brokerConfig;\n+    @Mock\n+    private BrokerController brokerController;\n+    @Mock\n+    private ChannelHandlerContext handlerContext;\n+    @Mock\n+    private MessageStoreConfig messageStoreConfig;\n+    @Mock\n+    private TopicConfigManager topicConfigManager;\n+    @Mock\n+    private MessageStore messageStore;\n+    @Mock\n+    private BrokerStatsManager brokerStatsManager;\n+    @Mock\n+    private Channel channel;\n+\n+    @Before\n+    public void init() throws IllegalAccessException, NoSuchFieldException {\n+        when(brokerController.getMessageStoreConfig()).thenReturn(messageStoreConfig);\n+        when(brokerController.getTopicConfigManager()).thenReturn(topicConfigManager);\n+        when(brokerController.getMessageStore()).thenReturn(messageStore);\n+        when(brokerController.getBrokerConfig()).thenReturn(brokerConfig);\n+        when(brokerConfig.getBrokerName()).thenReturn(BROKER_NAME);\n+        when(brokerController.getBrokerStatsManager()).thenReturn(brokerStatsManager);\n+        when(handlerContext.channel()).thenReturn(channel);\n+        recallMessageProcessor = new RecallMessageProcessor(brokerController);\n+    }\n+\n+    @Test\n+    public void testBuildMessage() {\n+        String timestampStr = String.valueOf(System.currentTimeMillis());\n+        String id = \""id\"";\n+        RecallMessageHandle.HandleV1 handle = new RecallMessageHandle.HandleV1(TOPIC, \""brokerName\"", timestampStr, id);\n+        MessageExtBrokerInner msg =\n+            recallMessageProcessor.buildMessage(handlerContext, new RecallMessageRequestHeader(), handle);\n+\n+        Assert.assertEquals(TOPIC, msg.getTopic());\n+        Map<String, String> properties = MessageDecoder.string2messageProperties(msg.getPropertiesString());\n+        Assert.assertEquals(timestampStr, properties.get(MessageConst.PROPERTY_TIMER_DELIVER_MS));\n+        Assert.assertEquals(id, properties.get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));\n+        Assert.assertEquals(TOPIC + \""+\"" + id, properties.get(MessageConst.PROPERTY_TIMER_DEL_UNIQKEY));\n+    }\n+\n+    @Test\n+    public void testHandlePutMessageResult() {\n+        MessageExt message = new MessageExt();\n+        MessageAccessor.putProperty(message, MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, \""id\"");\n+        RemotingCommand response = RemotingCommand.createResponseCommand(RecallMessageResponseHeader.class);\n+        recallMessageProcessor.handlePutMessageResult(null, null, response, message, handlerContext, 0L);\n+        Assert.assertEquals(ResponseCode.SYSTEM_ERROR, response.getCode());\n+\n+        List<PutMessageStatus> okStatus = Arrays.asList(PutMessageStatus.PUT_OK, PutMessageStatus.FLUSH_DISK_TIMEOUT,\n+            PutMessageStatus.FLUSH_SLAVE_TIMEOUT, PutMessageStatus.SLAVE_NOT_AVAILABLE);\n+\n+        for (PutMessageStatus status : PutMessageStatus.values()) {\n+            PutMessageResult putMessageResult =\n+                new PutMessageResult(status, new AppendMessageResult(AppendMessageStatus.PUT_OK));\n+            recallMessageProcessor.handlePutMessageResult(putMessageResult, null, response, message, handlerContext, 0L);\n+            if (okStatus.contains(status)) {\n+                Assert.assertEquals(ResponseCode.SUCCESS, response.getCode());\n+                RecallMessageResponseHeader responseHeader = (RecallMessageResponseHeader) response.readCustomHeader();\n+                Assert.assertEquals(\""id\"", responseHeader.getMsgId());\n+            } else {\n+                Assert.assertEquals(ResponseCode.SYSTEM_ERROR, response.getCode());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testProcessRequest_invalidStatus() throws RemotingCommandException {\n+        RemotingCommand request = mockRequest(0, TOPIC, TOPIC, \""id\"", BROKER_NAME);\n+        RemotingCommand response;\n+\n+        // role slave\n+        when(messageStoreConfig.getBrokerRole()).thenReturn(BrokerRole.SLAVE);\n+        response = recallMessageProcessor.processRequest(handlerContext, request);\n+        Assert.assertEquals(ResponseCode.SLAVE_NOT_AVAILABLE, response.getCode());\n+\n+        // not reach startTimestamp\n+        when(messageStoreConfig.getBrokerRole()).thenReturn(BrokerRole.SYNC_MASTER);\n+        when(messageStore.now()).thenReturn(0L);\n+        when(brokerConfig.getStartAcceptSendRequestTimeStamp()).thenReturn(System.currentTimeMillis());\n+        response = recallMessageProcessor.processRequest(handlerContext, request);\n+        Assert.assertEquals(ResponseCode.SERVICE_NOT_AVAILABLE, response.getCode());\n+    }\n+\n+    @Test\n+    public void testProcessRequest_notWriteable() throws RemotingCommandException {\n+        when(brokerConfig.getBrokerPermission()).thenReturn(4);\n+        when(brokerConfig.isAllowRecallWhenBrokerNotWriteable()).thenReturn(false);\n+        RemotingCommand request = mockRequest(0, TOPIC, TOPIC, \""id\"", BROKER_NAME);\n+        RemotingCommand response = recallMessageProcessor.processRequest(handlerContext, request);\n+        Assert.assertEquals(ResponseCode.SERVICE_NOT_AVAILABLE, response.getCode());\n+    }\n+\n+    @Test\n+    public void testProcessRequest_topicNotFound_or_notMatch() throws RemotingCommandException {\n+        when(brokerConfig.getBrokerPermission()).thenReturn(6);\n+        RemotingCommand request;\n+        RemotingCommand response;\n+\n+        // not found\n+        request = mockRequest(0, TOPIC, TOPIC, \""id\"", BROKER_NAME);\n+        response = recallMessageProcessor.processRequest(handlerContext, request);\n+        Assert.assertEquals(ResponseCode.TOPIC_NOT_EXIST, response.getCode());\n+\n+        // not match\n+        when(topicConfigManager.selectTopicConfig(TOPIC)).thenReturn(new TopicConfig(TOPIC));\n+        request = mockRequest(0, TOPIC, \""anotherTopic\"", \""id\"", BROKER_NAME);\n+        response = recallMessageProcessor.processRequest(handlerContext, request);\n+        Assert.assertEquals(ResponseCode.ILLEGAL_OPERATION, response.getCode());\n+    }\n+\n+    @Test\n+    public void testProcessRequest_brokerNameNotMatch() throws RemotingCommandException {\n+        when(brokerConfig.getBrokerPermission()).thenReturn(6);\n+        when(topicConfigManager.selectTopicConfig(TOPIC)).thenReturn(new TopicConfig(TOPIC));\n+\n+        RemotingCommand request = mockRequest(0, TOPIC, \""anotherTopic\"", \""id\"", BROKER_NAME + \""_other\"");\n+        RemotingCommand response = recallMessageProcessor.processRequest(handlerContext, request);\n+        Assert.assertEquals(ResponseCode.ILLEGAL_OPERATION, response.getCode());\n+    }\n+\n+    @Test\n+    public void testProcessRequest_timestampInvalid() throws RemotingCommandException {\n+        when(brokerConfig.getBrokerPermission()).thenReturn(6);\n+        when(topicConfigManager.selectTopicConfig(TOPIC)).thenReturn(new TopicConfig(TOPIC));\n+        RemotingCommand request;\n+        RemotingCommand response;\n+\n+        // past timestamp\n+        request = mockRequest(0, TOPIC, TOPIC, \""id\"", BROKER_NAME);\n+        response = recallMessageProcessor.processRequest(handlerContext, request);\n+        Assert.assertEquals(ResponseCode.ILLEGAL_OPERATION, response.getCode());\n+\n+        // timestamp overflow\n+        when(messageStoreConfig.getTimerMaxDelaySec()).thenReturn(86400);\n+        request = mockRequest(System.currentTimeMillis() + 86400 * 2 * 1000, TOPIC, TOPIC, \""id\"", BROKER_NAME);\n+        response = recallMessageProcessor.processRequest(handlerContext, request);\n+        Assert.assertEquals(ResponseCode.ILLEGAL_OPERATION, response.getCode());\n+    }\n+\n+    @Test\n+    public void testProcessRequest_success() throws RemotingCommandException {\n+        when(brokerConfig.getBrokerPermission()).thenReturn(6);\n+        when(topicConfigManager.selectTopicConfig(TOPIC)).thenReturn(new TopicConfig(TOPIC));\n+        when(messageStoreConfig.getTimerMaxDelaySec()).thenReturn(86400);\n+        when(messageStore.putMessage(any())).thenReturn(\n+            new PutMessageResult(PutMessageStatus.PUT_OK, new AppendMessageResult(AppendMessageStatus.PUT_OK)));\n+\n+        String msgId = \""msgId\"";\n+        RemotingCommand request = mockRequest(System.currentTimeMillis() + 90 * 1000, TOPIC, TOPIC, msgId, BROKER_NAME);\n+        RemotingCommand response = recallMessageProcessor.processRequest(handlerContext, request);\n+        RecallMessageResponseHeader responseHeader = (RecallMessageResponseHeader) response.readCustomHeader();\n+        Assert.assertEquals(ResponseCode.SUCCESS, response.getCode());\n+        Assert.assertEquals(msgId, responseHeader.getMsgId());\n+        verify(messageStore, times(1)).putMessage(any());\n+    }\n+\n+    private RemotingCommand mockRequest(long timestamp, String requestTopic, String handleTopic,\n+        String msgId, String brokerName) {\n+        String handle =\n+            RecallMessageHandle.HandleV1.buildHandle(handleTopic, brokerName, String.valueOf(timestamp), msgId);\n+        RecallMessageRequestHeader requestHeader = new RecallMessageRequestHeader();\n+        requestHeader.setProducerGroup(\""group\"");\n+        requestHeader.setTopic(requestTopic);\n+        requestHeader.setRecallHandle(handle);\n+        requestHeader.setBrokerName(brokerName);\n+        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.RECALL_MESSAGE, requestHeader);\n+        request.makeCustomHeaderToNet();\n+        return request;\n+    }\n+}\n\ndiff --git a/broker/src/test/java/org/apache/rocketmq/broker/processor/SendMessageProcessorTest.java b/broker/src/test/java/org/apache/rocketmq/broker/processor/SendMessageProcessorTest.java\nindex 442794dcd26..9da6a96ec99 100644\n--- a/broker/src/test/java/org/apache/rocketmq/broker/processor/SendMessageProcessorTest.java\n+++ b/broker/src/test/java/org/apache/rocketmq/broker/processor/SendMessageProcessorTest.java\n@@ -25,6 +25,7 @@\n import java.util.Map;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Executors;\n+import org.apache.commons.codec.DecoderException;\n import org.apache.rocketmq.broker.BrokerController;\n import org.apache.rocketmq.common.AbortProcessException;\n import org.apache.rocketmq.broker.mqtrace.ConsumeMessageContext;\n@@ -36,10 +37,13 @@\n import org.apache.rocketmq.broker.transaction.TransactionalMessageService;\n import org.apache.rocketmq.common.BrokerConfig;\n import org.apache.rocketmq.common.TopicConfig;\n+import org.apache.rocketmq.common.message.MessageAccessor;\n+import org.apache.rocketmq.common.message.MessageClientIDSetter;\n import org.apache.rocketmq.common.message.MessageConst;\n import org.apache.rocketmq.common.message.MessageDecoder;\n import org.apache.rocketmq.common.message.MessageExt;\n import org.apache.rocketmq.common.message.MessageExtBrokerInner;\n+import org.apache.rocketmq.common.producer.RecallMessageHandle;\n import org.apache.rocketmq.common.sysflag.MessageSysFlag;\n import org.apache.rocketmq.common.topic.TopicValidator;\n import org.apache.rocketmq.remoting.exception.RemotingCommandException;\n@@ -50,12 +54,14 @@\n import org.apache.rocketmq.remoting.protocol.ResponseCode;\n import org.apache.rocketmq.remoting.protocol.header.ConsumerSendMsgBackRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.SendMessageResponseHeader;\n import org.apache.rocketmq.store.AppendMessageResult;\n import org.apache.rocketmq.store.AppendMessageStatus;\n import org.apache.rocketmq.store.MessageStore;\n import org.apache.rocketmq.store.PutMessageResult;\n import org.apache.rocketmq.store.PutMessageStatus;\n import org.apache.rocketmq.store.config.MessageStoreConfig;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -69,6 +75,8 @@\n import static org.mockito.ArgumentMatchers.anyLong;\n import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.times;\n \n @RunWith(MockitoJUnitRunner.class)\n public class SendMessageProcessorTest {\n@@ -78,6 +86,8 @@ public class SendMessageProcessorTest {\n     @Mock\n     private Channel channel;\n     @Spy\n+    private BrokerConfig brokerConfig;\n+    @Spy\n     private BrokerController brokerController = new BrokerController(new BrokerConfig(), new NettyServerConfig(),\n         new NettyClientConfig(), new MessageStoreConfig());\n     @Mock\n@@ -98,6 +108,7 @@ public void init() {\n         when(brokerController.getSubscriptionGroupManager()).thenReturn(subscriptionGroupManager);\n         when(brokerController.getTopicConfigManager()).thenReturn(topicConfigManager);\n         when(brokerController.getPutMessageFutureExecutor()).thenReturn(Executors.newSingleThreadExecutor());\n+        when(brokerController.getBrokerConfig()).thenReturn(brokerConfig);\n         when(messageStore.now()).thenReturn(System.currentTimeMillis());\n         when(channel.remoteAddress()).thenReturn(new InetSocketAddress(1024));\n         when(handlerContext.channel()).thenReturn(channel);\n@@ -299,6 +310,60 @@ public void consumeMessageAfter(ConsumeMessageContext context) {\n         assertThat(response.getCode()).isEqualTo(ResponseCode.SUCCESS);\n     }\n \n+    @Test\n+    public void testAttachRecallHandle_skip() {\n+        MessageExt message = new MessageExt();\n+        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.SEND_BATCH_MESSAGE, null);\n+        sendMessageProcessor.attachRecallHandle(request, message, new SendMessageResponseHeader());\n+\n+        request = RemotingCommand.createRequestCommand(RequestCode.CONSUMER_SEND_MSG_BACK, null);\n+        sendMessageProcessor.attachRecallHandle(request, message, new SendMessageResponseHeader());\n+\n+        request = RemotingCommand.createRequestCommand(RequestCode.SEND_MESSAGE, null);\n+        sendMessageProcessor.attachRecallHandle(request, message, new SendMessageResponseHeader());\n+\n+        request = RemotingCommand.createRequestCommand(RequestCode.SEND_MESSAGE_V2, null);\n+        sendMessageProcessor.attachRecallHandle(request, message, new SendMessageResponseHeader());\n+\n+        verify(brokerConfig, times(0)).getBrokerName();\n+    }\n+\n+    @Test\n+    public void testAttachRecallHandle_doAttach() throws DecoderException {\n+        int[] precisionSet = {100, 200, 500, 1000};\n+        SendMessageResponseHeader responseHeader = new SendMessageResponseHeader();\n+        String id = MessageClientIDSetter.createUniqID();\n+        long timestamp = System.currentTimeMillis();\n+\n+        for (int precisionMs : precisionSet) {\n+            long deliverMs = floor(timestamp, precisionMs);\n+            MessageExt message = new MessageExt();\n+            MessageAccessor.putProperty(message, MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, id);\n+            MessageAccessor.putProperty(message, MessageConst.PROPERTY_TIMER_OUT_MS, String.valueOf(deliverMs));\n+            MessageAccessor.putProperty(message, MessageConst.PROPERTY_REAL_TOPIC, topic);\n+\n+            RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.SEND_MESSAGE_V2, null);\n+            sendMessageProcessor.attachRecallHandle(request, message, responseHeader);\n+            Assert.assertNotNull(responseHeader.getRecallHandle());\n+            RecallMessageHandle.HandleV1 v1 =\n+                (RecallMessageHandle.HandleV1) RecallMessageHandle.decodeHandle(responseHeader.getRecallHandle());\n+            Assert.assertEquals(id, v1.getMessageId());\n+            Assert.assertEquals(topic, v1.getTopic());\n+            Assert.assertEquals(deliverMs + 1, Long.parseLong(v1.getTimestampStr()));\n+            Assert.assertEquals(deliverMs, floor(Long.valueOf(v1.getTimestampStr()), precisionMs));\n+        }\n+    }\n+\n+    private long floor(long deliverMs, int precisionMs) {\n+        assert precisionMs > 0;\n+        if (deliverMs % precisionMs == 0) {\n+            deliverMs -= precisionMs;\n+        } else {\n+            deliverMs = deliverMs / precisionMs * precisionMs;\n+        }\n+        return deliverMs;\n+    }\n+\n     private RemotingCommand createSendTransactionMsgCommand(int requestCode) {\n         SendMessageRequestHeader header = createSendMsgRequestHeader();\n         int sysFlag = header.getSysFlag();\n\ndiff --git a/client/src/test/java/org/apache/rocketmq/client/impl/MQClientAPIImplTest.java b/client/src/test/java/org/apache/rocketmq/client/impl/MQClientAPIImplTest.java\nindex 81dc5883fb8..c76d0c734a0 100644\n--- a/client/src/test/java/org/apache/rocketmq/client/impl/MQClientAPIImplTest.java\n+++ b/client/src/test/java/org/apache/rocketmq/client/impl/MQClientAPIImplTest.java\n@@ -41,6 +41,7 @@\n import org.apache.rocketmq.common.consumer.ConsumeFromWhere;\n import org.apache.rocketmq.common.message.Message;\n import org.apache.rocketmq.common.message.MessageAccessor;\n+import org.apache.rocketmq.common.message.MessageClientIDSetter;\n import org.apache.rocketmq.common.message.MessageConst;\n import org.apache.rocketmq.common.message.MessageDecoder;\n import org.apache.rocketmq.common.message.MessageExt;\n@@ -118,6 +119,8 @@\n import org.apache.rocketmq.remoting.protocol.header.QueryConsumerOffsetRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.QueryConsumerOffsetResponseHeader;\n import org.apache.rocketmq.remoting.protocol.header.QueryMessageRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageResponseHeader;\n import org.apache.rocketmq.remoting.protocol.header.SearchOffsetResponseHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageResponseHeader;\n@@ -142,6 +145,7 @@\n import org.apache.rocketmq.remoting.protocol.subscription.GroupForbidden;\n import org.apache.rocketmq.remoting.protocol.subscription.SubscriptionGroupConfig;\n import org.assertj.core.api.Assertions;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -170,6 +174,7 @@\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyLong;\n@@ -2028,6 +2033,77 @@ public void assertListAcl() throws RemotingException, InterruptedException, MQBr\n         assertEquals(1, actual.get(0).getPolicies().size());\n     }\n \n+    @Test\n+    public void testRecallMessage() throws RemotingException, InterruptedException, MQBrokerException {\n+        RecallMessageRequestHeader requestHeader = new RecallMessageRequestHeader();\n+        requestHeader.setProducerGroup(group);\n+        requestHeader.setTopic(topic);\n+        requestHeader.setRecallHandle(\""handle\"");\n+        requestHeader.setBrokerName(brokerName);\n+\n+        // success\n+        mockInvokeSync();\n+        String msgId = MessageClientIDSetter.createUniqID();\n+        RecallMessageResponseHeader responseHeader = new RecallMessageResponseHeader();\n+        responseHeader.setMsgId(msgId);\n+        setResponseHeader(responseHeader);\n+        String result = mqClientAPI.recallMessage(defaultBrokerAddr, requestHeader, defaultTimeout);\n+        assertEquals(msgId, result);\n+\n+        // error\n+        when(response.getCode()).thenReturn(ResponseCode.SYSTEM_ERROR);\n+        when(response.getRemark()).thenReturn(\""error\"");\n+        MQBrokerException e = assertThrows(MQBrokerException.class, () -> {\n+            mqClientAPI.recallMessage(defaultBrokerAddr, requestHeader, defaultTimeout);\n+        });\n+        assertEquals(ResponseCode.SYSTEM_ERROR, e.getResponseCode());\n+        assertEquals(\""error\"", e.getErrorMessage());\n+        assertEquals(defaultBrokerAddr, e.getBrokerAddr());\n+    }\n+\n+    @Test\n+    public void testRecallMessageAsync() throws RemotingException, InterruptedException {\n+        RecallMessageRequestHeader requestHeader = new RecallMessageRequestHeader();\n+        requestHeader.setProducerGroup(group);\n+        requestHeader.setTopic(topic);\n+        requestHeader.setRecallHandle(\""handle\"");\n+        requestHeader.setBrokerName(brokerName);\n+        String msgId = \""msgId\"";\n+        doAnswer((Answer<Void>) mock -> {\n+            InvokeCallback callback = mock.getArgument(3);\n+            RemotingCommand request = mock.getArgument(1);\n+            RemotingCommand response = RemotingCommand.createResponseCommand(RecallMessageResponseHeader.class);\n+            response.setCode(ResponseCode.SUCCESS);\n+            response.setOpaque(request.getOpaque());\n+            RecallMessageResponseHeader responseHeader = (RecallMessageResponseHeader) response.readCustomHeader();\n+            responseHeader.setMsgId(msgId);\n+            ResponseFuture responseFuture = new ResponseFuture(null, request.getOpaque(), 3 * 1000, null, null);\n+            responseFuture.setResponseCommand(response);\n+            callback.operationSucceed(responseFuture.getResponseCommand());\n+            return null;\n+        }).when(remotingClient).invokeAsync(anyString(), any(RemotingCommand.class), anyLong(), any(InvokeCallback.class));\n+\n+        final CountDownLatch done = new CountDownLatch(1);\n+        mqClientAPI.recallMessageAsync(defaultBrokerAddr, requestHeader,\n+            defaultTimeout, new InvokeCallback() {\n+                @Override\n+                public void operationComplete(ResponseFuture responseFuture) {\n+                }\n+\n+                @Override\n+                public void operationSucceed(RemotingCommand response) {\n+                    RecallMessageResponseHeader responseHeader = (RecallMessageResponseHeader) response.readCustomHeader();\n+                    Assert.assertEquals(msgId, responseHeader.getMsgId());\n+                    done.countDown();\n+                }\n+\n+                @Override\n+                public void operationFail(Throwable throwable) {\n+                }\n+            });\n+        done.await();\n+    }\n+\n     private Properties createProperties() {\n         Properties result = new Properties();\n         result.put(\""key\"", \""value\"");\n\ndiff --git a/client/src/test/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExtTest.java b/client/src/test/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExtTest.java\nindex 6f692dff950..e2a29c9a21f 100644\n--- a/client/src/test/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExtTest.java\n+++ b/client/src/test/java/org/apache/rocketmq/client/impl/mqclient/MQClientAPIExtTest.java\n@@ -18,6 +18,7 @@\n package org.apache.rocketmq.client.impl.mqclient;\n \n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n import java.util.concurrent.ExecutionException;\n import org.apache.rocketmq.client.ClientConfig;\n import org.apache.rocketmq.client.exception.MQBrokerException;\n@@ -29,8 +30,11 @@\n import org.apache.rocketmq.remoting.netty.NettyRemotingClient;\n import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n import org.apache.rocketmq.remoting.protocol.ResponseCode;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageResponseHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.UpdateConsumerOffsetRequestHeader;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -108,4 +112,47 @@ public void testUpdateConsumerOffsetAsync_Fail() throws InterruptedException {\n             assertEquals(customEx.getErrorMessage(), \""QueueId is null, topic is testTopic\"");\n         }\n     }\n+\n+    @Test\n+    public void testRecallMessageAsync_success() {\n+        String msgId = \""msgId\"";\n+        RecallMessageRequestHeader requestHeader = new RecallMessageRequestHeader();\n+        requestHeader.setProducerGroup(\""group\"");\n+        requestHeader.setTopic(\""topic\"");\n+        requestHeader.setRecallHandle(\""handle\"");\n+        requestHeader.setBrokerName(\""brokerName\"");\n+\n+        RemotingCommand response = RemotingCommand.createResponseCommand(RecallMessageResponseHeader.class);\n+        response.setCode(ResponseCode.SUCCESS);\n+        RecallMessageResponseHeader responseHeader = (RecallMessageResponseHeader) response.readCustomHeader();\n+        responseHeader.setMsgId(msgId);\n+        response.makeCustomHeaderToNet();\n+        CompletableFuture<RemotingCommand> remotingFuture = new CompletableFuture<>();\n+        remotingFuture.complete(response);\n+        doReturn(remotingFuture).when(remotingClientMock).invoke(anyString(), any(RemotingCommand.class), anyLong());\n+\n+        String resultId =\n+            mqClientAPIExt.recallMessageAsync(\""brokerAddr\"", requestHeader, 3000L).join();\n+        Assert.assertEquals(msgId, resultId);\n+    }\n+\n+    @Test\n+    public void testRecallMessageAsync_fail() {\n+        RecallMessageRequestHeader requestHeader = new RecallMessageRequestHeader();\n+        requestHeader.setProducerGroup(\""group\"");\n+        requestHeader.setTopic(\""topic\"");\n+        requestHeader.setRecallHandle(\""handle\"");\n+        requestHeader.setBrokerName(\""brokerName\"");\n+\n+        CompletableFuture<RemotingCommand> remotingFuture = new CompletableFuture<>();\n+        remotingFuture.complete(RemotingCommand.createResponseCommand(ResponseCode.SERVICE_NOT_AVAILABLE, \""\""));\n+        doReturn(remotingFuture).when(remotingClientMock).invoke(anyString(), any(RemotingCommand.class), anyLong());\n+\n+        CompletionException exception = Assert.assertThrows(CompletionException.class, () -> {\n+            mqClientAPIExt.recallMessageAsync(\""brokerAddr\"", requestHeader, 3000L).join();\n+        });\n+        Assert.assertTrue(exception.getCause() instanceof MQBrokerException);\n+        MQBrokerException cause = (MQBrokerException) exception.getCause();\n+        Assert.assertEquals(ResponseCode.SERVICE_NOT_AVAILABLE, cause.getResponseCode());\n+    }\n }\n\\ No newline at end of file\n\ndiff --git a/client/src/test/java/org/apache/rocketmq/client/producer/selector/DefaultMQProducerImplTest.java b/client/src/test/java/org/apache/rocketmq/client/producer/selector/DefaultMQProducerImplTest.java\nindex a17fe43f461..77a83af19c0 100644\n--- a/client/src/test/java/org/apache/rocketmq/client/producer/selector/DefaultMQProducerImplTest.java\n+++ b/client/src/test/java/org/apache/rocketmq/client/producer/selector/DefaultMQProducerImplTest.java\n@@ -33,11 +33,13 @@\n import org.apache.rocketmq.client.producer.SendResult;\n import org.apache.rocketmq.client.producer.TransactionListener;\n import org.apache.rocketmq.client.producer.TransactionMQProducer;\n+import org.apache.rocketmq.common.MixAll;\n import org.apache.rocketmq.common.ServiceState;\n import org.apache.rocketmq.common.message.Message;\n import org.apache.rocketmq.common.message.MessageConst;\n import org.apache.rocketmq.common.message.MessageExt;\n import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.common.producer.RecallMessageHandle;\n import org.apache.rocketmq.remoting.exception.RemotingException;\n import org.apache.rocketmq.remoting.protocol.header.CheckTransactionStateRequestHeader;\n import org.junit.Before;\n@@ -61,9 +63,11 @@\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertThrows;\n import static org.mockito.AdditionalMatchers.or;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.anyLong;\n import static org.mockito.ArgumentMatchers.isNull;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n@@ -86,10 +90,15 @@ public class DefaultMQProducerImplTest {\n     @Mock\n     private MQClientInstance mQClientFactory;\n \n+    @Mock\n+    private MQClientAPIImpl mQClientAPIImpl;\n+\n     private DefaultMQProducerImpl defaultMQProducerImpl;\n \n     private final long defaultTimeout = 30000L;\n \n+    private final String defaultBrokerName = \""broker-0\"";\n+\n     private final String defaultBrokerAddr = \""127.0.0.1:10911\"";\n \n     private final String defaultTopic = \""testTopic\"";\n@@ -104,7 +113,6 @@ public void init() throws Exception {\n         when(clientConfig.queueWithNamespace(any())).thenReturn(messageQueue);\n         when(mQClientFactory.getClientConfig()).thenReturn(clientConfig);\n         when(mQClientFactory.getTopicRouteTable()).thenReturn(mock(ConcurrentMap.class));\n-        MQClientAPIImpl mQClientAPIImpl = mock(MQClientAPIImpl.class);\n         when(mQClientFactory.getMQClientAPIImpl()).thenReturn(mQClientAPIImpl);\n         when(mQClientFactory.findBrokerAddressInPublish(or(isNull(), anyString()))).thenReturn(defaultBrokerAddr);\n         when(message.getTopic()).thenReturn(defaultTopic);\n@@ -313,6 +321,39 @@ public void assertCheckListener() {\n         assertNull(defaultMQProducerImpl.checkListener());\n     }\n \n+    @Test\n+    public void testRecallMessage_invalid() {\n+        assertThrows(MQClientException.class, () -> {\n+            defaultMQProducerImpl.recallMessage(MixAll.REPLY_TOPIC_POSTFIX + defaultTopic, \""handle\"");\n+        });\n+        assertThrows(MQClientException.class, () -> {\n+            defaultMQProducerImpl.recallMessage(MixAll.DLQ_GROUP_TOPIC_PREFIX + defaultTopic, \""handle\"");\n+        });\n+        assertThrows(MQClientException.class, () -> {\n+            defaultMQProducerImpl.recallMessage(defaultTopic, \""handle\"");\n+        });\n+    }\n+\n+    @Test\n+    public void testRecallMessage_addressNotFound() {\n+        String handle = RecallMessageHandle.HandleV1.buildHandle(defaultTopic, defaultBrokerName, \""1\"", \""id\"");\n+        when(mQClientFactory.findBrokerAddressInPublish(defaultBrokerName)).thenReturn(null);\n+        MQClientException e = assertThrows(MQClientException.class, () -> {\n+            defaultMQProducerImpl.recallMessage(defaultTopic, handle);\n+        });\n+        assertEquals(\""The broker service address not found\"", e.getErrorMessage());\n+    }\n+\n+    @Test\n+    public void testRecallMessage_success()\n+        throws RemotingException, MQClientException, MQBrokerException, InterruptedException {\n+        String handle = RecallMessageHandle.HandleV1.buildHandle(defaultTopic, defaultBrokerName, \""1\"", \""id\"");\n+        when(mQClientFactory.findBrokerAddressInPublish(defaultBrokerName)).thenReturn(defaultBrokerAddr);\n+        when(mQClientAPIImpl.recallMessage(any(), any(), anyLong())).thenReturn(\""id\"");\n+        String result = defaultMQProducerImpl.recallMessage(defaultTopic, handle);\n+        assertEquals(\""id\"", result);\n+    }\n+\n     private void setMQClientFactory() throws IllegalAccessException, NoSuchFieldException {\n         setField(defaultMQProducerImpl, \""mQClientFactory\"", mQClientFactory);\n     }\n\ndiff --git a/common/src/test/java/org/apache/rocketmq/common/producer/RecallMessageHandleTest.java b/common/src/test/java/org/apache/rocketmq/common/producer/RecallMessageHandleTest.java\nnew file mode 100644\nindex 00000000000..56608227693\n--- /dev/null\n+++ b/common/src/test/java/org/apache/rocketmq/common/producer/RecallMessageHandleTest.java\n@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.common.producer;\n+\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.rocketmq.common.message.MessageClientIDSetter;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+\n+public class RecallMessageHandleTest {\n+    @Test\n+    public void testHandleInvalid() {\n+        Assert.assertThrows(DecoderException.class, () -> {\n+            RecallMessageHandle.decodeHandle(\""\"");\n+        });\n+        Assert.assertThrows(DecoderException.class, () -> {\n+            RecallMessageHandle.decodeHandle(null);\n+        });\n+\n+        Assert.assertThrows(DecoderException.class, () -> {\n+            String invalidHandle = Base64.getUrlEncoder().encodeToString(\""v1 a b c\"".getBytes(StandardCharsets.UTF_8));\n+            RecallMessageHandle.decodeHandle(invalidHandle);\n+        });\n+        Assert.assertThrows(DecoderException.class, () -> {\n+            String invalidHandle = Base64.getUrlEncoder().encodeToString(\""v2 a b c d\"".getBytes(StandardCharsets.UTF_8));\n+            RecallMessageHandle.decodeHandle(invalidHandle);\n+        });\n+        Assert.assertThrows(DecoderException.class, () -> {\n+            String invalidHandle = \""v1 a b c d\"";\n+            RecallMessageHandle.decodeHandle(invalidHandle);\n+        });\n+    }\n+\n+    @Test\n+    public void testEncodeAndDecodeV1() throws DecoderException {\n+        String topic = \""topic\"";\n+        String brokerName = \""broker-0\"";\n+        String timestampStr = String.valueOf(System.currentTimeMillis());\n+        String messageId = MessageClientIDSetter.createUniqID();\n+        String handle = RecallMessageHandle.HandleV1.buildHandle(topic, brokerName, timestampStr, messageId);\n+        RecallMessageHandle handleEntity = RecallMessageHandle.decodeHandle(handle);\n+        Assert.assertTrue(handleEntity instanceof RecallMessageHandle.HandleV1);\n+        RecallMessageHandle.HandleV1 handleV1 = (RecallMessageHandle.HandleV1) handleEntity;\n+        Assert.assertEquals(handleV1.getVersion(), \""v1\"");\n+        Assert.assertEquals(handleV1.getTopic(), topic);\n+        Assert.assertEquals(handleV1.getBrokerName(), brokerName);\n+        Assert.assertEquals(handleV1.getTimestampStr(), timestampStr);\n+        Assert.assertEquals(handleV1.getMessageId(), messageId);\n+    }\n+}\n\ndiff --git a/proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/producer/RecallMessageActivityTest.java b/proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/producer/RecallMessageActivityTest.java\nnew file mode 100644\nindex 00000000000..e42aeadbb6b\n--- /dev/null\n+++ b/proxy/src/test/java/org/apache/rocketmq/proxy/grpc/v2/producer/RecallMessageActivityTest.java\n@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.proxy.grpc.v2.producer;\n+\n+import apache.rocketmq.v2.Code;\n+import apache.rocketmq.v2.RecallMessageRequest;\n+import apache.rocketmq.v2.RecallMessageResponse;\n+import apache.rocketmq.v2.Resource;\n+import org.apache.rocketmq.proxy.common.ProxyException;\n+import org.apache.rocketmq.proxy.common.ProxyExceptionCode;\n+import org.apache.rocketmq.proxy.grpc.v2.BaseActivityTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.when;\n+\n+public class RecallMessageActivityTest extends BaseActivityTest {\n+    private RecallMessageActivity recallMessageActivity;\n+\n+    @Before\n+    public void before() throws Throwable {\n+        super.before();\n+        this.recallMessageActivity =\n+            new RecallMessageActivity(messagingProcessor, grpcClientSettingsManager, grpcChannelManager);\n+    }\n+\n+    @Test\n+    public void testRecallMessage_success() {\n+        when(this.messagingProcessor.recallMessage(any(), any(), any(), anyLong()))\n+            .thenReturn(CompletableFuture.completedFuture(\""msgId\""));\n+\n+        RecallMessageResponse response = this.recallMessageActivity.recallMessage(\n+            createContext(),\n+            RecallMessageRequest.newBuilder()\n+                .setRecallHandle(\""handle\"")\n+                .setTopic(Resource.newBuilder().setResourceNamespace(\""ns\"").setName(\""topic\""))\n+                .build()\n+        ).join();\n+\n+        assertEquals(Code.OK, response.getStatus().getCode());\n+        assertEquals(\""msgId\"", response.getMessageId());\n+    }\n+\n+    @Test\n+    public void testRecallMessage_fail() {\n+        CompletableFuture<String> exceptionFuture = new CompletableFuture();\n+        when(this.messagingProcessor.recallMessage(any(), any(), any(), anyLong())).thenReturn(exceptionFuture);\n+        exceptionFuture.completeExceptionally(\n+            new ProxyException(ProxyExceptionCode.MESSAGE_PROPERTY_CONFLICT_WITH_TYPE, \""info\""));\n+\n+        CompletionException exception = Assert.assertThrows(CompletionException.class, () -> {\n+            this.recallMessageActivity.recallMessage(\n+                createContext(),\n+                RecallMessageRequest.newBuilder()\n+                    .setRecallHandle(\""handle\"")\n+                    .setTopic(Resource.newBuilder().setResourceNamespace(\""ns\"").setName(\""topic\""))\n+                    .build()\n+            ).join();\n+        });\n+        Assert.assertTrue(exception.getCause() instanceof ProxyException);\n+        ProxyException cause = (ProxyException) exception.getCause();\n+        Assert.assertEquals(ProxyExceptionCode.MESSAGE_PROPERTY_CONFLICT_WITH_TYPE, cause.getCode());\n+    }\n+}\n\ndiff --git a/proxy/src/test/java/org/apache/rocketmq/proxy/processor/ProducerProcessorTest.java b/proxy/src/test/java/org/apache/rocketmq/proxy/processor/ProducerProcessorTest.java\nindex 3192d5c8dfb..6729ef0c4b3 100644\n--- a/proxy/src/test/java/org/apache/rocketmq/proxy/processor/ProducerProcessorTest.java\n+++ b/proxy/src/test/java/org/apache/rocketmq/proxy/processor/ProducerProcessorTest.java\n@@ -21,6 +21,7 @@\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n import java.util.concurrent.Executors;\n import org.apache.rocketmq.client.producer.SendResult;\n import org.apache.rocketmq.client.producer.SendStatus;\n@@ -34,20 +35,25 @@\n import org.apache.rocketmq.common.message.MessageConst;\n import org.apache.rocketmq.common.message.MessageDecoder;\n import org.apache.rocketmq.common.message.MessageExt;\n+import org.apache.rocketmq.common.producer.RecallMessageHandle;\n import org.apache.rocketmq.common.sysflag.MessageSysFlag;\n import org.apache.rocketmq.common.utils.NetworkUtil;\n+import org.apache.rocketmq.proxy.common.ProxyException;\n+import org.apache.rocketmq.proxy.common.ProxyExceptionCode;\n import org.apache.rocketmq.proxy.service.route.AddressableMessageQueue;\n import org.apache.rocketmq.proxy.service.transaction.TransactionData;\n import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n import org.apache.rocketmq.remoting.protocol.header.ConsumerSendMsgBackRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n import org.assertj.core.util.Lists;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.ArgumentCaptor;\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyLong;\n import static org.mockito.ArgumentMatchers.anyString;\n@@ -205,6 +211,39 @@ public void testForwardMessageToDeadLetterQueue() throws Throwable {\n         assertEquals(CONSUMER_GROUP, requestHeader.getGroup());\n     }\n \n+    @Test\n+    public void testRecallMessage_notDelayMessage() {\n+        when(metadataService.getTopicMessageType(any(), any())).thenReturn(TopicMessageType.NORMAL);\n+        CompletionException exception = Assert.assertThrows(CompletionException.class, () -> {\n+            producerProcessor.recallMessage(createContext(), TOPIC, \""handle\"", 3000).join();\n+        });\n+        assertTrue(exception.getCause() instanceof ProxyException);\n+        ProxyException cause = (ProxyException) exception.getCause();\n+        assertEquals(ProxyExceptionCode.MESSAGE_PROPERTY_CONFLICT_WITH_TYPE, cause.getCode());\n+    }\n+\n+    @Test\n+    public void testRecallMessage_invalidRecallHandle() {\n+        when(metadataService.getTopicMessageType(any(), any())).thenReturn(TopicMessageType.DELAY);\n+        CompletionException exception = Assert.assertThrows(CompletionException.class, () -> {\n+            producerProcessor.recallMessage(createContext(), TOPIC, \""handle\"", 3000).join();\n+        });\n+        assertTrue(exception.getCause() instanceof ProxyException);\n+        ProxyException cause = (ProxyException) exception.getCause();\n+        assertEquals(\""recall handle is invalid\"", cause.getMessage());\n+    }\n+\n+    @Test\n+    public void testRecallMessage_success() {\n+        when(metadataService.getTopicMessageType(any(), any())).thenReturn(TopicMessageType.DELAY);\n+        when(this.messageService.recallMessage(any(), any(), any(), anyLong()))\n+            .thenReturn(CompletableFuture.completedFuture(\""msgId\""));\n+\n+        String handle = RecallMessageHandle.HandleV1.buildHandle(TOPIC, \""brokerName\"", \""timestampStr\"", \""whateverId\"");\n+        String msgId = producerProcessor.recallMessage(createContext(), TOPIC, handle, 3000).join();\n+        assertEquals(\""msgId\"", msgId);\n+    }\n+\n     private static String createOffsetMsgId(long commitLogOffset) {\n         int msgIDLength = 4 + 4 + 8;\n         ByteBuffer byteBufferMsgId = ByteBuffer.allocate(msgIDLength);\n\ndiff --git a/proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/RecallMessageActivityTest.java b/proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/RecallMessageActivityTest.java\nnew file mode 100644\nindex 00000000000..7d64923d774\n--- /dev/null\n+++ b/proxy/src/test/java/org/apache/rocketmq/proxy/remoting/activity/RecallMessageActivityTest.java\n@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.proxy.remoting.activity;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import org.apache.rocketmq.common.attribute.TopicMessageType;\n+import org.apache.rocketmq.proxy.common.ProxyException;\n+import org.apache.rocketmq.proxy.common.ProxyExceptionCode;\n+import org.apache.rocketmq.proxy.config.InitConfigTest;\n+import org.apache.rocketmq.proxy.processor.MessagingProcessor;\n+import org.apache.rocketmq.proxy.service.channel.SimpleChannel;\n+import org.apache.rocketmq.proxy.service.channel.SimpleChannelHandlerContext;\n+import org.apache.rocketmq.proxy.service.metadata.MetadataService;\n+import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n+import org.apache.rocketmq.remoting.protocol.RequestCode;\n+import org.apache.rocketmq.remoting.protocol.ResponseCode;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class RecallMessageActivityTest extends InitConfigTest {\n+    private static final String TOPIC = \""topic\"";\n+    private static final String GROUP = \""group\"";\n+    private static final String BROKER_NAME = \""brokerName\"";\n+\n+    private RecallMessageActivity recallMessageActivity;\n+    @Mock\n+    private MessagingProcessor messagingProcessor;\n+    @Mock\n+    private MetadataService metadataService;\n+\n+    @Spy\n+    private ChannelHandlerContext ctx = new SimpleChannelHandlerContext(new SimpleChannel(null, \""1\"", \""2\"")) {\n+        @Override\n+        public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {\n+            return null;\n+        }\n+    };\n+\n+    @Before\n+    public void init() {\n+        recallMessageActivity = new RecallMessageActivity(null, messagingProcessor);\n+        when(messagingProcessor.getMetadataService()).thenReturn(metadataService);\n+    }\n+\n+    @Test\n+    public void testRecallMessage_notDelayMessage() {\n+        when(metadataService.getTopicMessageType(any(), eq(TOPIC))).thenReturn(TopicMessageType.NORMAL);\n+        ProxyException exception = Assert.assertThrows(ProxyException.class, () -> {\n+            recallMessageActivity.processRequest0(ctx, mockRequest(), null);\n+        });\n+        Assert.assertEquals(ProxyExceptionCode.MESSAGE_PROPERTY_CONFLICT_WITH_TYPE, exception.getCode());\n+    }\n+\n+    @Test\n+    public void testRecallMessage_success() throws Exception {\n+        when(metadataService.getTopicMessageType(any(), eq(TOPIC))).thenReturn(TopicMessageType.DELAY);\n+        RemotingCommand request = mockRequest();\n+        RemotingCommand expectResponse = RemotingCommand.createResponseCommand(ResponseCode.SUCCESS, \""\"");\n+        when(messagingProcessor.request(any(), eq(BROKER_NAME), eq(request), anyLong()))\n+            .thenReturn(CompletableFuture.completedFuture(expectResponse));\n+        RemotingCommand response = recallMessageActivity.processRequest0(ctx, request, null);\n+        Assert.assertNull(response);\n+        verify(ctx, times(1)).writeAndFlush(eq(expectResponse));\n+    }\n+\n+    private RemotingCommand mockRequest() {\n+        RecallMessageRequestHeader requestHeader = new RecallMessageRequestHeader();\n+        requestHeader.setProducerGroup(GROUP);\n+        requestHeader.setTopic(TOPIC);\n+        requestHeader.setRecallHandle(\""handle\"");\n+        requestHeader.setBrokerName(BROKER_NAME);\n+        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.RECALL_MESSAGE, requestHeader);\n+        request.makeCustomHeaderToNet();\n+        return request;\n+    }\n+}\n\ndiff --git a/proxy/src/test/java/org/apache/rocketmq/proxy/service/message/LocalMessageServiceTest.java b/proxy/src/test/java/org/apache/rocketmq/proxy/service/message/LocalMessageServiceTest.java\nindex f7a656d7682..20ce2a16848 100644\n--- a/proxy/src/test/java/org/apache/rocketmq/proxy/service/message/LocalMessageServiceTest.java\n+++ b/proxy/src/test/java/org/apache/rocketmq/proxy/service/message/LocalMessageServiceTest.java\n@@ -26,12 +26,14 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n import java.util.concurrent.ExecutionException;\n import org.apache.rocketmq.broker.BrokerController;\n import org.apache.rocketmq.broker.processor.AckMessageProcessor;\n import org.apache.rocketmq.broker.processor.ChangeInvisibleTimeProcessor;\n import org.apache.rocketmq.broker.processor.EndTransactionProcessor;\n import org.apache.rocketmq.broker.processor.PopMessageProcessor;\n+import org.apache.rocketmq.broker.processor.RecallMessageProcessor;\n import org.apache.rocketmq.broker.processor.SendMessageProcessor;\n import org.apache.rocketmq.client.consumer.AckResult;\n import org.apache.rocketmq.client.consumer.AckStatus;\n@@ -68,8 +70,11 @@\n import org.apache.rocketmq.remoting.protocol.header.ExtraInfoUtil;\n import org.apache.rocketmq.remoting.protocol.header.PopMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.PopMessageResponseHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageRequestHeader;\n+import org.apache.rocketmq.remoting.protocol.header.RecallMessageResponseHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\n import org.apache.rocketmq.remoting.protocol.header.SendMessageResponseHeader;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -94,6 +99,8 @@ public class LocalMessageServiceTest extends InitConfigTest {\n     @Mock\n     private AckMessageProcessor ackMessageProcessorMock;\n     @Mock\n+    private RecallMessageProcessor recallMessageProcessorMock;\n+    @Mock\n     private BrokerController brokerControllerMock;\n \n     private ProxyContext proxyContext;\n@@ -122,6 +129,7 @@ public void setUp() throws Throwable {\n         Mockito.when(brokerControllerMock.getChangeInvisibleTimeProcessor()).thenReturn(changeInvisibleTimeProcessorMock);\n         Mockito.when(brokerControllerMock.getAckMessageProcessor()).thenReturn(ackMessageProcessorMock);\n         Mockito.when(brokerControllerMock.getEndTransactionProcessor()).thenReturn(endTransactionProcessorMock);\n+        Mockito.when(brokerControllerMock.getRecallMessageProcessor()).thenReturn(recallMessageProcessorMock);\n         Mockito.when(brokerControllerMock.getBrokerConfig()).thenReturn(new BrokerConfig());\n         localMessageService = new LocalMessageService(brokerControllerMock, channelManager, null);\n         proxyContext = ProxyContext.create().withVal(ContextVariable.REMOTE_ADDRESS, \""0.0.0.1\"")\n@@ -424,6 +432,31 @@ public void testAckMessage() throws Exception {\n         assertThat(ackResult.getStatus()).isEqualTo(AckStatus.OK);\n     }\n \n+    @Test\n+    public void testRecallMessage_success() throws Exception {\n+        RecallMessageResponseHeader responseHeader = new RecallMessageResponseHeader();\n+        responseHeader.setMsgId(\""msgId\"");\n+        RemotingCommand response = RemotingCommand.createResponseCommandWithHeader(ResponseCode.SUCCESS, responseHeader);\n+        Mockito.when(recallMessageProcessorMock.processRequest(Mockito.any(SimpleChannelHandlerContext.class),\n+            Mockito.any())).thenReturn(response);\n+        RecallMessageRequestHeader requestHeader = new RecallMessageRequestHeader();\n+        String msgId = localMessageService.recallMessage(proxyContext, \""brokerName\"", requestHeader, 1000L).join();\n+        assertThat(msgId).isEqualTo(\""msgId\"");\n+    }\n+\n+    @Test\n+    public void testRecallMessage_fail() throws Exception {\n+        RecallMessageResponseHeader responseHeader = new RecallMessageResponseHeader();\n+        RemotingCommand response = RemotingCommand.createResponseCommandWithHeader(ResponseCode.SLAVE_NOT_AVAILABLE, responseHeader);\n+        Mockito.when(recallMessageProcessorMock.processRequest(Mockito.any(SimpleChannelHandlerContext.class),\n+            Mockito.any())).thenReturn(response);\n+        RecallMessageRequestHeader requestHeader = new RecallMessageRequestHeader();\n+        CompletionException exception = Assert.assertThrows(CompletionException.class, () -> {\n+            localMessageService.recallMessage(proxyContext, \""brokerName\"", requestHeader, 1000L).join();\n+        });\n+        Assert.assertTrue(exception.getCause() instanceof ProxyException);\n+    }\n+\n     private MessageExt buildMessageExt(String topic, int queueId, long queueOffset) {\n         MessageExt message1 = new MessageExt();\n         message1.setTopic(topic);\n\ndiff --git a/store/src/test/java/org/apache/rocketmq/store/timer/TimerMessageStoreTest.java b/store/src/test/java/org/apache/rocketmq/store/timer/TimerMessageStoreTest.java\nindex 4ce3985f6c9..4a6b68bd02c 100644\n--- a/store/src/test/java/org/apache/rocketmq/store/timer/TimerMessageStoreTest.java\n+++ b/store/src/test/java/org/apache/rocketmq/store/timer/TimerMessageStoreTest.java\n@@ -306,7 +306,7 @@ public void testDeleteTimerMessage() throws Exception {\n \n         MessageExtBrokerInner delMsg = buildMessage(delayMs, topic, false);\n         transformTimerMessage(timerMessageStore,delMsg);\n-        MessageAccessor.putProperty(delMsg, TimerMessageStore.TIMER_DELETE_UNIQUE_KEY, uniqKey);\n+        MessageAccessor.putProperty(delMsg, TimerMessageStore.TIMER_DELETE_UNIQUE_KEY, TimerMessageStore.buildDeleteKey(topic, uniqKey));\n         delMsg.setPropertiesString(MessageDecoder.messageProperties2String(delMsg.getProperties()));\n         assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(delMsg).getPutMessageStatus());\n \n@@ -321,6 +321,49 @@ public void testDeleteTimerMessage() throws Exception {\n         assertNull(getOneMessage(topic, 0, 4, 500));\n     }\n \n+    @Test\n+    public void testDeleteTimerMessage_ukCollision() throws Exception {\n+        String topic = \""TimerTest_testDeleteTimerMessage\"";\n+        String collisionTopic = \""TimerTest_testDeleteTimerMessage_collision\"";\n+\n+        TimerMessageStore timerMessageStore = createTimerMessageStore(null);\n+        timerMessageStore.load();\n+        timerMessageStore.start(true);\n+\n+        long curr = System.currentTimeMillis() / precisionMs * precisionMs;\n+        long delayMs = curr + 1000;\n+\n+        MessageExtBrokerInner inner = buildMessage(delayMs, topic, false);\n+        transformTimerMessage(timerMessageStore, inner);\n+        String firstUniqKey = MessageClientIDSetter.getUniqID(inner);\n+        assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(inner).getPutMessageStatus());\n+\n+        inner = buildMessage(delayMs, topic, false);\n+        transformTimerMessage(timerMessageStore, inner);\n+        String secondUniqKey = MessageClientIDSetter.getUniqID(inner);\n+        assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(inner).getPutMessageStatus());\n+\n+        MessageExtBrokerInner delMsg = buildMessage(delayMs, \""whatever\"", false);\n+        transformTimerMessage(timerMessageStore, delMsg);\n+        MessageAccessor.putProperty(delMsg, TimerMessageStore.TIMER_DELETE_UNIQUE_KEY, TimerMessageStore.buildDeleteKey(topic, firstUniqKey));\n+        delMsg.setPropertiesString(MessageDecoder.messageProperties2String(delMsg.getProperties()));\n+        assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(delMsg).getPutMessageStatus());\n+\n+        delMsg = buildMessage(delayMs, \""whatever\"", false);\n+        transformTimerMessage(timerMessageStore, delMsg);\n+        MessageAccessor.putProperty(delMsg, TimerMessageStore.TIMER_DELETE_UNIQUE_KEY, TimerMessageStore.buildDeleteKey(collisionTopic, secondUniqKey));\n+        delMsg.setPropertiesString(MessageDecoder.messageProperties2String(delMsg.getProperties()));\n+        assertEquals(PutMessageStatus.PUT_OK, messageStore.putMessage(delMsg).getPutMessageStatus());\n+\n+        // The first one should have been deleted, the second one should not be deleted.\n+        ByteBuffer msgBuff = getOneMessage(topic, 0, 0, 3000);\n+        assertNotNull(msgBuff);\n+        MessageExt msgExt = MessageDecoder.decode(msgBuff);\n+        assertNotNull(msgExt);\n+        assertNotEquals(firstUniqKey, MessageClientIDSetter.getUniqID(msgExt));\n+        assertEquals(secondUniqKey, MessageClientIDSetter.getUniqID(msgExt));\n+    }\n+\n     @Test\n     public void testPutDeleteTimerMessage() throws Exception {\n         String topic = \""TimerTest_testPutDeleteTimerMessage\"";\n\ndiff --git a/test/BUILD.bazel b/test/BUILD.bazel\nindex e6703d69a01..80bd06539e8 100644\n--- a/test/BUILD.bazel\n+++ b/test/BUILD.bazel\n@@ -117,6 +117,8 @@ GenTestRules(\n         \""src/test/java/org/apache/rocketmq/test/client/producer/oneway/OneWaySendIT\"",\n         \""src/test/java/org/apache/rocketmq/test/client/producer/oneway/OneWaySendWithMQIT\"",\n         \""src/test/java/org/apache/rocketmq/test/offset/OffsetNotFoundIT\"",\n+        \""src/test/java/org/apache/rocketmq/test/recall/RecallWithTraceIT\"",\n+        \""src/test/java/org/apache/rocketmq/test/recall/SendAndRecallDelayMessageIT\"",\n         \""src/test/java/org/apache/rocketmq/test/client/producer/querymsg/QueryMsgByIdIT\"",\n         \""src/test/java/org/apache/rocketmq/test/client/producer/oneway/OneWaySendWithSelectorIT\"",\n         \""src/test/java/org/apache/rocketmq/test/smoke/NormalMessageSendAndRecvIT\"",\n\ndiff --git a/test/src/test/java/org/apache/rocketmq/test/grpc/v2/ClusterGrpcIT.java b/test/src/test/java/org/apache/rocketmq/test/grpc/v2/ClusterGrpcIT.java\nindex 77f5f362125..b754466a916 100644\n--- a/test/src/test/java/org/apache/rocketmq/test/grpc/v2/ClusterGrpcIT.java\n+++ b/test/src/test/java/org/apache/rocketmq/test/grpc/v2/ClusterGrpcIT.java\n@@ -93,6 +93,11 @@ public void testSimpleConsumerSendAndRecvDelayMessage() throws Exception {\n         super.testSimpleConsumerSendAndRecvDelayMessage();\n     }\n \n+    @Test\n+    public void testSimpleConsumerSendAndRecallDelayMessage() throws Exception {\n+        super.testSimpleConsumerSendAndRecallDelayMessage();\n+    }\n+\n     @Test\n     public void testSimpleConsumerSendAndRecvBigMessage() throws Exception {\n         super.testSimpleConsumerSendAndRecvBigMessage();\n\ndiff --git a/test/src/test/java/org/apache/rocketmq/test/grpc/v2/GrpcBaseIT.java b/test/src/test/java/org/apache/rocketmq/test/grpc/v2/GrpcBaseIT.java\nindex 9d8f85b9981..534108c2805 100644\n--- a/test/src/test/java/org/apache/rocketmq/test/grpc/v2/GrpcBaseIT.java\n+++ b/test/src/test/java/org/apache/rocketmq/test/grpc/v2/GrpcBaseIT.java\n@@ -41,6 +41,8 @@\n import apache.rocketmq.v2.QueryAssignmentResponse;\n import apache.rocketmq.v2.QueryRouteRequest;\n import apache.rocketmq.v2.QueryRouteResponse;\n+import apache.rocketmq.v2.RecallMessageRequest;\n+import apache.rocketmq.v2.RecallMessageResponse;\n import apache.rocketmq.v2.ReceiveMessageRequest;\n import apache.rocketmq.v2.ReceiveMessageResponse;\n import apache.rocketmq.v2.RecoverOrphanedTransactionCommand;\n@@ -393,6 +395,69 @@ public void testSimpleConsumerSendAndRecvDelayMessage() throws Exception {\n         assertThat(Math.abs(recvTime.get() - sendTime - delayTime) < 2 * 1000).isTrue();\n     }\n \n+    public void testSimpleConsumerSendAndRecallDelayMessage() throws Exception {\n+        String topic = initTopicOnSampleTopicBroker(BROKER1_NAME, TopicMessageType.DELAY);\n+        String group = MQRandomUtils.getRandomConsumerGroup();\n+        long delayTime = TimeUnit.SECONDS.toMillis(5);\n+\n+        // init consumer offset\n+        this.sendClientSettings(stub, buildSimpleConsumerClientSettings(group)).get();\n+        receiveMessage(blockingStub, topic, group, 1);\n+\n+        this.sendClientSettings(stub, buildProducerClientSettings(topic)).get();\n+        String messageId = createUniqID();\n+        SendMessageResponse sendResponse = blockingStub.sendMessage(SendMessageRequest.newBuilder()\n+            .addMessages(Message.newBuilder()\n+                .setTopic(Resource.newBuilder()\n+                    .setName(topic)\n+                    .build())\n+                .setSystemProperties(SystemProperties.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setQueueId(0)\n+                    .setMessageType(MessageType.DELAY)\n+                    .setBodyEncoding(Encoding.GZIP)\n+                    .setBornTimestamp(Timestamps.fromMillis(System.currentTimeMillis()))\n+                    .setBornHost(StringUtils.defaultString(NetworkUtil.getLocalAddress(), \""127.0.0.1:1234\""))\n+                    .setDeliveryTimestamp(Timestamps.fromMillis(System.currentTimeMillis() + delayTime))\n+                    .build())\n+                .setBody(ByteString.copyFromUtf8(\""hello\""))\n+                .build())\n+            .build());\n+        long sendTime = System.currentTimeMillis();\n+        assertSendMessage(sendResponse, messageId);\n+        String recallHandle = sendResponse.getEntries(0).getRecallHandle();\n+        assertThat(recallHandle).isNotEmpty();\n+\n+        RecallMessageRequest recallRequest = RecallMessageRequest.newBuilder()\n+            .setRecallHandle(recallHandle)\n+            .setTopic(Resource.newBuilder().setResourceNamespace(\""\"").setName(topic).build())\n+            .build();\n+        RecallMessageResponse recallResponse =\n+            blockingStub.withDeadlineAfter(2, TimeUnit.SECONDS).recallMessage(recallRequest);\n+        assertThat(recallResponse.getStatus()).isEqualTo(\n+            ResponseBuilder.getInstance().buildStatus(Code.OK, Code.OK.name()));\n+        assertThat(recallResponse.getMessageId()).isEqualTo(messageId);\n+\n+        this.sendClientSettings(stub, buildSimpleConsumerClientSettings(group)).get();\n+\n+        AtomicLong recvTime = new AtomicLong();\n+        AtomicReference<Message> recvMessage = new AtomicReference<>();\n+        try {\n+            await().atMost(java.time.Duration.ofSeconds(10)).until(() -> {\n+                List<Message> messageList = getMessageFromReceiveMessageResponse(receiveMessage(blockingStub, topic, group));\n+                if (messageList.isEmpty()) {\n+                    return false;\n+                }\n+                recvTime.set(System.currentTimeMillis());\n+                recvMessage.set(messageList.get(0));\n+                return messageList.get(0).getSystemProperties().getMessageId().equals(messageId);\n+            });\n+        } catch (Exception e) {\n+        }\n+        assertThat(recvTime.get()).isEqualTo(0L);\n+        assertThat(recvMessage.get()).isNull();\n+    }\n+\n     public void testSimpleConsumerSendAndRecvBigMessage() throws Exception {\n         String topic = initTopicOnSampleTopicBroker(BROKER1_NAME);\n         String group = MQRandomUtils.getRandomConsumerGroup();\n@@ -427,6 +492,7 @@ public void testSimpleConsumerSendAndRecv() throws Exception {\n         String messageId = createUniqID();\n         SendMessageResponse sendResponse = blockingStub.sendMessage(buildSendMessageRequest(topic, messageId));\n         assertSendMessage(sendResponse, messageId);\n+        assertThat(sendResponse.getEntries(0).getRecallHandle()).isNullOrEmpty();\n \n         this.sendClientSettings(stub, buildSimpleConsumerClientSettings(group)).get();\n \n\ndiff --git a/test/src/test/java/org/apache/rocketmq/test/grpc/v2/LocalGrpcIT.java b/test/src/test/java/org/apache/rocketmq/test/grpc/v2/LocalGrpcIT.java\nindex 515c3f121dd..5dd06f53420 100644\n--- a/test/src/test/java/org/apache/rocketmq/test/grpc/v2/LocalGrpcIT.java\n+++ b/test/src/test/java/org/apache/rocketmq/test/grpc/v2/LocalGrpcIT.java\n@@ -81,6 +81,11 @@ public void testSimpleConsumerSendAndRecvDelayMessage() throws Exception {\n         super.testSimpleConsumerSendAndRecvDelayMessage();\n     }\n \n+    @Test\n+    public void testSimpleConsumerSendAndRecallDelayMessage() throws Exception {\n+        super.testSimpleConsumerSendAndRecallDelayMessage();\n+    }\n+\n     @Test\n     public void testSimpleConsumerSendAndRecvBigMessage() throws Exception {\n         super.testSimpleConsumerSendAndRecvBigMessage();\n\ndiff --git a/test/src/test/java/org/apache/rocketmq/test/recall/RecallWithTraceIT.java b/test/src/test/java/org/apache/rocketmq/test/recall/RecallWithTraceIT.java\nnew file mode 100644\nindex 00000000000..d52c7002548\n--- /dev/null\n+++ b/test/src/test/java/org/apache/rocketmq/test/recall/RecallWithTraceIT.java\n@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.test.recall;\n+\n+import org.apache.rocketmq.client.consumer.PopResult;\n+import org.apache.rocketmq.client.consumer.PopStatus;\n+import org.apache.rocketmq.client.exception.MQBrokerException;\n+import org.apache.rocketmq.client.exception.MQClientException;\n+import org.apache.rocketmq.client.producer.DefaultMQProducer;\n+import org.apache.rocketmq.client.trace.TraceContext;\n+import org.apache.rocketmq.client.trace.TraceDataEncoder;\n+import org.apache.rocketmq.client.trace.TraceType;\n+import org.apache.rocketmq.common.attribute.CQType;\n+import org.apache.rocketmq.common.attribute.TopicMessageType;\n+import org.apache.rocketmq.common.message.MessageClientIDSetter;\n+import org.apache.rocketmq.common.message.MessageExt;\n+import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.common.producer.RecallMessageHandle;\n+import org.apache.rocketmq.remoting.exception.RemotingException;\n+import org.apache.rocketmq.test.base.BaseConf;\n+import org.apache.rocketmq.test.base.IntegrationTestBase;\n+import org.apache.rocketmq.test.client.rmq.RMQPopConsumer;\n+import org.apache.rocketmq.test.factory.ConsumerFactory;\n+import org.apache.rocketmq.test.listener.rmq.concurrent.RMQNormalListener;\n+import org.apache.rocketmq.test.util.MQRandomUtils;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.awaitility.Awaitility.await;\n+\n+public class RecallWithTraceIT extends BaseConf {\n+    private static String topic;\n+    private static String group;\n+    private static DefaultMQProducer producer;\n+    private static RMQPopConsumer popConsumer;\n+\n+    @BeforeClass\n+    public static void init() throws MQClientException {\n+        System.setProperty(\""com.rocketmq.recall.default.trace.enable\"", Boolean.TRUE.toString());\n+        topic = MQRandomUtils.getRandomTopic();\n+        IntegrationTestBase.initTopic(topic, NAMESRV_ADDR, BROKER1_NAME, 1, CQType.SimpleCQ, TopicMessageType.NORMAL);\n+        group = initConsumerGroup();\n+        producer = new DefaultMQProducer(group, true, topic);\n+        producer.setNamesrvAddr(NAMESRV_ADDR);\n+        producer.start();\n+        popConsumer = ConsumerFactory.getRMQPopConsumer(NAMESRV_ADDR, group, topic, \""*\"", new RMQNormalListener());\n+        mqClients.add(popConsumer);\n+        mqClients.add(producer);\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() {\n+        shutdown();\n+    }\n+\n+    @Test\n+    public void testRecallTrace() throws MQBrokerException, RemotingException, InterruptedException, MQClientException {\n+        String msgId = MessageClientIDSetter.createUniqID();\n+        String recallHandle = RecallMessageHandle.HandleV1.buildHandle(topic, BROKER1_NAME,\n+            String.valueOf(System.currentTimeMillis() + 30000), msgId);\n+        producer.recallMessage(topic, recallHandle);\n+\n+        MessageQueue messageQueue = new MessageQueue(topic, BROKER1_NAME, 0);\n+        String brokerAddress = brokerController1.getBrokerAddr();\n+        AtomicReference<MessageExt> traceMessage = new AtomicReference();\n+        await()\n+            .pollInterval(1, TimeUnit.SECONDS)\n+            .atMost(15, TimeUnit.SECONDS)\n+            .until(() -> {\n+                PopResult popResult = popConsumer.pop(brokerAddress, messageQueue, 60 * 1000, -1);\n+                boolean found = popResult.getPopStatus().equals(PopStatus.FOUND);\n+                traceMessage.set(found ? popResult.getMsgFoundList().get(0) : null);\n+                return found;\n+            });\n+\n+        Assert.assertNotNull(traceMessage.get());\n+        TraceContext context =\n+            TraceDataEncoder.decoderFromTraceDataString(new String(traceMessage.get().getBody())).get(0);\n+        Assert.assertEquals(TraceType.Recall, context.getTraceType());\n+        Assert.assertEquals(group, context.getGroupName());\n+        Assert.assertTrue(context.isSuccess());\n+        Assert.assertEquals(msgId, context.getTraceBeans().get(0).getMsgId());\n+    }\n+}\n\ndiff --git a/test/src/test/java/org/apache/rocketmq/test/recall/SendAndRecallDelayMessageIT.java b/test/src/test/java/org/apache/rocketmq/test/recall/SendAndRecallDelayMessageIT.java\nnew file mode 100644\nindex 00000000000..2fb9e023712\n--- /dev/null\n+++ b/test/src/test/java/org/apache/rocketmq/test/recall/SendAndRecallDelayMessageIT.java\n@@ -0,0 +1,193 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.test.recall;\n+\n+import org.apache.rocketmq.client.consumer.PopResult;\n+import org.apache.rocketmq.client.consumer.PopStatus;\n+import org.apache.rocketmq.client.producer.SendResult;\n+import org.apache.rocketmq.common.attribute.CQType;\n+import org.apache.rocketmq.common.attribute.TopicMessageType;\n+import org.apache.rocketmq.common.message.Message;\n+import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.common.producer.RecallMessageHandle;\n+import org.apache.rocketmq.test.base.BaseConf;\n+import org.apache.rocketmq.test.base.IntegrationTestBase;\n+import org.apache.rocketmq.test.client.rmq.RMQNormalProducer;\n+import org.apache.rocketmq.test.client.rmq.RMQPopConsumer;\n+import org.apache.rocketmq.test.factory.ConsumerFactory;\n+import org.apache.rocketmq.test.listener.rmq.concurrent.RMQNormalListener;\n+import org.apache.rocketmq.test.util.MQRandomUtils;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.awaitility.Awaitility.await;\n+\n+public class SendAndRecallDelayMessageIT extends BaseConf {\n+\n+    private static String initTopic;\n+    private static String consumerGroup;\n+    private static RMQNormalProducer producer;\n+    private static RMQPopConsumer popConsumer;\n+\n+    @BeforeClass\n+    public static void init() {\n+        initTopic = initTopic();\n+        consumerGroup = initConsumerGroup();\n+        producer = getProducer(NAMESRV_ADDR, initTopic);\n+        popConsumer = ConsumerFactory.getRMQPopConsumer(NAMESRV_ADDR, consumerGroup, initTopic, \""*\"", new RMQNormalListener());\n+        mqClients.add(popConsumer);\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() {\n+        shutdown();\n+    }\n+\n+    @Test\n+    public void testSendAndRecv() throws Exception {\n+        int delaySecond = 1;\n+        String topic = MQRandomUtils.getRandomTopic();\n+        IntegrationTestBase.initTopic(topic, NAMESRV_ADDR, BROKER1_NAME, 1, CQType.SimpleCQ, TopicMessageType.DELAY);\n+        MessageQueue messageQueue = new MessageQueue(topic, BROKER1_NAME, 0);\n+        String brokerAddress = brokerController1.getBrokerAddr();\n+\n+        List<Message> sendList = buildSendMessageList(topic, delaySecond);\n+        List<Message> recvList = new ArrayList<>();\n+\n+        for (Message message : sendList) {\n+            producer.getProducer().send(message);\n+        }\n+\n+        await()\n+            .pollInterval(1, TimeUnit.SECONDS)\n+            .atMost(delaySecond + 15, TimeUnit.SECONDS)\n+            .until(() -> {\n+                PopResult popResult = popConsumer.pop(brokerAddress, messageQueue, 60 * 1000, -1);\n+                processPopResult(recvList, popResult);\n+                return recvList.size() == sendList.size();\n+            });\n+    }\n+\n+    @Test\n+    public void testSendAndRecall() throws Exception {\n+        int delaySecond = 5;\n+        String topic = MQRandomUtils.getRandomTopic();\n+        IntegrationTestBase.initTopic(topic, NAMESRV_ADDR, BROKER1_NAME, 1, CQType.SimpleCQ, TopicMessageType.DELAY);\n+        MessageQueue messageQueue = new MessageQueue(topic, BROKER1_NAME, 0);\n+        String brokerAddress = brokerController1.getBrokerAddr();\n+\n+        List<Message> sendList = buildSendMessageList(topic, delaySecond);\n+        List<Message> recvList = new ArrayList<>();\n+        int recallCount = 0;\n+\n+        for (Message message : sendList) {\n+            SendResult sendResult = producer.getProducer().send(message);\n+            if (sendResult.getRecallHandle() != null) {\n+                String messageId = producer.getProducer().recallMessage(topic, sendResult.getRecallHandle());\n+                assertEquals(sendResult.getMsgId(), messageId);\n+                recallCount += 1;\n+            }\n+        }\n+        assertEquals(sendList.size() - 2, recallCount); // one normal and one delay-level message\n+        try {\n+            await()\n+                .pollInterval(1, TimeUnit.SECONDS)\n+                .atMost(delaySecond + 15, TimeUnit.SECONDS)\n+                .until(() -> {\n+                    PopResult popResult = popConsumer.pop(brokerAddress, messageQueue, 60 * 1000, -1);\n+                    processPopResult(recvList, popResult);\n+                    return recvList.size() == sendList.size();\n+                });\n+        } catch (Exception e) {\n+        }\n+        assertEquals(sendList.size() - recallCount, recvList.size());\n+    }\n+\n+    @Test\n+    public void testSendAndRecall_ukCollision() throws Exception {\n+        int delaySecond = 5;\n+        String topic = MQRandomUtils.getRandomTopic();\n+        String collisionTopic = MQRandomUtils.getRandomTopic();\n+        IntegrationTestBase.initTopic(topic, NAMESRV_ADDR, BROKER1_NAME, 1, CQType.SimpleCQ, TopicMessageType.DELAY);\n+        IntegrationTestBase.initTopic(collisionTopic, NAMESRV_ADDR, BROKER1_NAME, 1, CQType.SimpleCQ, TopicMessageType.DELAY);\n+        MessageQueue messageQueue = new MessageQueue(topic, BROKER1_NAME, 0);\n+        String brokerAddress = brokerController1.getBrokerAddr();\n+\n+        List<Message> sendList = buildSendMessageList(topic, delaySecond);\n+        List<Message> recvList = new ArrayList<>();\n+        int recallCount = 0;\n+\n+        for (Message message : sendList) {\n+            SendResult sendResult = producer.getProducer().send(message);\n+            if (sendResult.getRecallHandle() != null) {\n+                RecallMessageHandle.HandleV1 handleEntity =\n+                    (RecallMessageHandle.HandleV1) RecallMessageHandle.decodeHandle(sendResult.getRecallHandle());\n+                String collisionHandle = RecallMessageHandle.HandleV1.buildHandle(collisionTopic,\n+                    handleEntity.getBrokerName(), handleEntity.getTimestampStr(), handleEntity.getMessageId());\n+                String messageId = producer.getProducer().recallMessage(collisionTopic, collisionHandle);\n+                assertEquals(sendResult.getMsgId(), messageId);\n+                recallCount += 1;\n+            }\n+        }\n+        assertEquals(sendList.size() - 2, recallCount); // one normal and one delay-level message\n+\n+        try {\n+            await()\n+                .pollInterval(1, TimeUnit.SECONDS)\n+                .atMost(delaySecond + 15, TimeUnit.SECONDS)\n+                .until(() -> {\n+                    PopResult popResult = popConsumer.pop(brokerAddress, messageQueue, 60 * 1000, -1);\n+                    processPopResult(recvList, popResult);\n+                    return recvList.size() == sendList.size();\n+                });\n+        } catch (Exception e) {\n+        }\n+        assertEquals(sendList.size(), recvList.size());\n+    }\n+\n+    private void processPopResult(List<Message> recvList, PopResult popResult) {\n+        if (popResult.getPopStatus() == PopStatus.FOUND && popResult.getMsgFoundList() != null) {\n+            recvList.addAll(popResult.getMsgFoundList());\n+        }\n+    }\n+\n+    private List<Message> buildSendMessageList(String topic, int delaySecond) {\n+        Message msg0 = new Message(topic, \""tag\"", \""Hello RocketMQ\"".getBytes()); // not supported\n+\n+        Message msg1 = new Message(topic, \""tag\"", \""Hello RocketMQ\"".getBytes()); // not supported\n+        msg1.setDelayTimeLevel(2);\n+\n+        Message msg2 = new Message(topic, \""tag\"", \""Hello RocketMQ\"".getBytes());\n+        msg2.setDelayTimeMs(delaySecond * 1000L);\n+\n+        Message msg3 = new Message(topic, \""tag\"", \""Hello RocketMQ\"".getBytes());\n+        msg3.setDelayTimeSec(delaySecond);\n+\n+        Message msg4 = new Message(topic, \""tag\"", \""Hello RocketMQ\"".getBytes());\n+        msg4.setDeliverTimeMs(System.currentTimeMillis() + delaySecond * 1000L);\n+\n+        return Arrays.asList(msg0, msg1, msg2, msg3, msg4);\n+    }\n+}\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""apache__rocketmq-8915"", ""pr_id"": 8915, ""issue_id"": 8829, ""repo"": ""apache/rocketmq"", ""problem_statement"": ""[Feature] LMQ Optimization: Revamp on top of RocksDB\n### Is Your Feature Request Related to a Problem?\n\nLMQ is supposed to be light-weight in terms of resource cost and lifecycle. Current implementation is still based on file queue and does not scale as expected\n\n### Describe the Solution You'd Like\n\nProvide a key-value based implementation\n\n### Describe Alternatives You've Considered\n\nIn-place optimization is not a viable option in the long run.\n\n### Additional Context\n\n_No response_"", ""issue_word_count"": 77, ""test_files_count"": 4, ""non_test_files_count"": 14, ""pr_changed_files"": [""broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java"", ""broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConfigHelper.java"", ""broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConfigStorage.java"", ""broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConsumerOffsetManagerV2.java"", ""broker/src/main/java/org/apache/rocketmq/broker/config/v2/SubscriptionGroupManagerV2.java"", ""broker/src/main/java/org/apache/rocketmq/broker/config/v2/TopicConfigManagerV2.java"", ""broker/src/test/java/org/apache/rocketmq/broker/config/v2/ConsumerOffsetManagerV2Test.java"", ""broker/src/test/java/org/apache/rocketmq/broker/config/v2/SubscriptionGroupManagerV2Test.java"", ""broker/src/test/java/org/apache/rocketmq/broker/config/v2/TopicConfigManagerV2Test.java"", ""broker/src/test/java/org/apache/rocketmq/broker/offset/RocksdbTransferOffsetAndCqTest.java"", ""common/src/main/java/org/apache/rocketmq/common/config/AbstractRocksDBStorage.java"", ""common/src/main/java/org/apache/rocketmq/common/config/ConfigHelper.java"", ""common/src/main/java/org/apache/rocketmq/common/config/ConfigRocksDBStorage.java"", ""store/src/main/java/org/apache/rocketmq/store/CommitLog.java"", ""store/src/main/java/org/apache/rocketmq/store/config/MessageStoreConfig.java"", ""store/src/main/java/org/apache/rocketmq/store/queue/RocksDBConsumeQueueStore.java"", ""store/src/main/java/org/apache/rocketmq/store/queue/RocksGroupCommitService.java"", ""store/src/main/java/org/apache/rocketmq/store/rocksdb/RocksDBOptionsFactory.java""], ""pr_changed_test_files"": [""broker/src/test/java/org/apache/rocketmq/broker/config/v2/ConsumerOffsetManagerV2Test.java"", ""broker/src/test/java/org/apache/rocketmq/broker/config/v2/SubscriptionGroupManagerV2Test.java"", ""broker/src/test/java/org/apache/rocketmq/broker/config/v2/TopicConfigManagerV2Test.java"", ""broker/src/test/java/org/apache/rocketmq/broker/offset/RocksdbTransferOffsetAndCqTest.java""], ""base_commit"": ""804847e87765f835afa147887f9507b8a41ae08c"", ""head_commit"": ""a20b1e7d0d738ac4deac3bba7f4bb476f51f02e6"", ""repo_url"": ""https://github.com/apache/rocketmq/pull/8915"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/apache__rocketmq/8915"", ""dockerfile"": """", ""pr_merged_at"": ""2024-12-02T02:07:54.000Z"", ""patch"": ""diff --git a/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java b/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java\nindex ee211e1b80a..6acc407c713 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java\n@@ -345,7 +345,7 @@ public BrokerController(\n         this.brokerStatsManager = messageStoreConfig.isEnableLmq() ? new LmqBrokerStatsManager(this.brokerConfig.getBrokerClusterName(), this.brokerConfig.isEnableDetailStat()) : new BrokerStatsManager(this.brokerConfig.getBrokerClusterName(), this.brokerConfig.isEnableDetailStat());\n         this.broadcastOffsetManager = new BroadcastOffsetManager(this);\n         if (ConfigManagerVersion.V2.getVersion().equals(brokerConfig.getConfigManagerVersion())) {\n-            this.configStorage = new ConfigStorage(messageStoreConfig.getStorePathRootDir());\n+            this.configStorage = new ConfigStorage(messageStoreConfig);\n             this.topicConfigManager = new TopicConfigManagerV2(this, configStorage);\n             this.subscriptionGroupManager = new SubscriptionGroupManagerV2(this, configStorage);\n             this.consumerOffsetManager = new ConsumerOffsetManagerV2(this, configStorage);\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConfigHelper.java b/broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConfigHelper.java\nindex 8183a1f8358..29a7c313bab 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConfigHelper.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConfigHelper.java\n@@ -64,7 +64,7 @@ public static Optional<ByteBuf> loadDataVersion(ConfigStorage configStorage, Tab\n         return Optional.empty();\n     }\n \n-    public static void stampDataVersion(WriteBatch writeBatch, DataVersion dataVersion, long stateMachineVersion)\n+    public static void stampDataVersion(WriteBatch writeBatch, TableId table, DataVersion dataVersion, long stateMachineVersion)\n         throws RocksDBException {\n         // Increase data version\n         dataVersion.nextVersion(stateMachineVersion);\n@@ -75,7 +75,7 @@ public static void stampDataVersion(WriteBatch writeBatch, DataVersion dataVersi\n         ByteBuf valueBuf = AbstractRocksDBStorage.POOLED_ALLOCATOR.buffer(Long.BYTES * 3);\n         try {\n             keyBuf.writeByte(TablePrefix.TABLE.getValue());\n-            keyBuf.writeShort(TableId.CONSUMER_OFFSET.getValue());\n+            keyBuf.writeShort(table.getValue());\n             keyBuf.writeByte(RecordPrefix.DATA_VERSION.getValue());\n             keyBuf.writeBytes(ConfigStorage.DATA_VERSION_KEY_BYTES);\n             valueBuf.writeLong(dataVersion.getStateVersion());\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConfigStorage.java b/broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConfigStorage.java\nindex 6bc62957a86..c4056d142fc 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConfigStorage.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConfigStorage.java\n@@ -16,17 +16,29 @@\n  */\n package org.apache.rocketmq.broker.config.v2;\n \n+import com.google.common.base.Stopwatch;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.netty.buffer.PooledByteBufAllocatorMetric;\n import io.netty.util.internal.PlatformDependent;\n import java.io.File;\n import java.nio.ByteBuffer;\n import java.nio.charset.StandardCharsets;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.rocketmq.common.ServiceThread;\n import org.apache.rocketmq.common.UtilAll;\n import org.apache.rocketmq.common.config.AbstractRocksDBStorage;\n import org.apache.rocketmq.common.config.ConfigHelper;\n+import org.apache.rocketmq.store.config.MessageStoreConfig;\n import org.rocksdb.ColumnFamilyDescriptor;\n import org.rocksdb.ColumnFamilyOptions;\n+import org.rocksdb.FlushOptions;\n import org.rocksdb.ReadOptions;\n import org.rocksdb.RocksDB;\n import org.rocksdb.RocksDBException;\n@@ -43,8 +55,48 @@ public class ConfigStorage extends AbstractRocksDBStorage {\n     public static final String DATA_VERSION_KEY = \""data_version\"";\n     public static final byte[] DATA_VERSION_KEY_BYTES = DATA_VERSION_KEY.getBytes(StandardCharsets.UTF_8);\n \n-    public ConfigStorage(String storePath) {\n-        super(storePath + File.separator + \""config\"" + File.separator + \""rdb\"");\n+    private final ScheduledExecutorService scheduledExecutorService;\n+\n+    /**\n+     * Number of write ops since previous flush.\n+     */\n+    private final AtomicInteger writeOpsCounter;\n+\n+    private final AtomicLong estimateWalFileSize = new AtomicLong(0L);\n+\n+    private final MessageStoreConfig messageStoreConfig;\n+\n+    private final FlushSyncService flushSyncService;\n+\n+    public ConfigStorage(MessageStoreConfig messageStoreConfig) {\n+        super(messageStoreConfig.getStorePathRootDir() + File.separator + \""config\"" + File.separator + \""rdb\"");\n+        this.messageStoreConfig = messageStoreConfig;\n+        ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+            .setDaemon(true)\n+            .setNameFormat(\""config-storage-%d\"")\n+            .build();\n+        scheduledExecutorService = new ScheduledThreadPoolExecutor(1, threadFactory);\n+        writeOpsCounter = new AtomicInteger(0);\n+        this.flushSyncService = new FlushSyncService();\n+        this.flushSyncService.setDaemon(true);\n+    }\n+\n+    private void statNettyMemory() {\n+        PooledByteBufAllocatorMetric metric = AbstractRocksDBStorage.POOLED_ALLOCATOR.metric();\n+        LOGGER.info(\""Netty Memory Usage: {}\"", metric);\n+    }\n+\n+    @Override\n+    public synchronized boolean start() {\n+        boolean started = super.start();\n+        if (started) {\n+            scheduledExecutorService.scheduleWithFixedDelay(() -> statRocksdb(LOGGER), 1, 10, TimeUnit.SECONDS);\n+            scheduledExecutorService.scheduleWithFixedDelay(this::statNettyMemory, 10, 10, TimeUnit.SECONDS);\n+            this.flushSyncService.start();\n+        } else {\n+            LOGGER.error(\""Failed to start config storage\"");\n+        }\n+        return started;\n     }\n \n     @Override\n@@ -58,7 +110,7 @@ protected boolean postLoad() {\n             initOptions();\n             List<ColumnFamilyDescriptor> cfDescriptors = new ArrayList<>();\n \n-            ColumnFamilyOptions defaultOptions = ConfigHelper.createConfigOptions();\n+            ColumnFamilyOptions defaultOptions = ConfigHelper.createConfigColumnFamilyOptions();\n             this.cfOptions.add(defaultOptions);\n             cfDescriptors.add(new ColumnFamilyDescriptor(RocksDB.DEFAULT_COLUMN_FAMILY, defaultOptions));\n \n@@ -66,7 +118,7 @@ protected boolean postLoad() {\n             open(cfDescriptors);\n \n             this.defaultCFHandle = cfHandles.get(0);\n-        } catch (final Exception e) {\n+        } catch (Exception e) {\n             AbstractRocksDBStorage.LOGGER.error(\""postLoad Failed. {}\"", this.dbPath, e);\n             return false;\n         }\n@@ -75,7 +127,8 @@ protected boolean postLoad() {\n \n     @Override\n     protected void preShutdown() {\n-\n+        scheduledExecutorService.shutdown();\n+        flushSyncService.shutdown();\n     }\n \n     protected void initOptions() {\n@@ -105,6 +158,12 @@ public byte[] get(ByteBuffer key) throws RocksDBException {\n \n     public void write(WriteBatch writeBatch) throws RocksDBException {\n         db.write(ableWalWriteOptions, writeBatch);\n+        accountWriteOps(writeBatch.getDataSize());\n+    }\n+\n+    private void accountWriteOps(long dataSize) {\n+        writeOpsCounter.incrementAndGet();\n+        estimateWalFileSize.addAndGet(dataSize);\n     }\n \n     public RocksIterator iterate(ByteBuffer beginKey, ByteBuffer endKey) {\n@@ -125,4 +184,91 @@ public RocksIterator iterate(ByteBuffer beginKey, ByteBuffer endKey) {\n             return iterator;\n         }\n     }\n+\n+    /**\n+     * RocksDB writes contain 3 stages: application memory buffer --> OS Page Cache --> Disk.\n+     * Given that we are having DBOptions::manual_wal_flush, we need to manually call DB::FlushWAL and DB::SyncWAL\n+     * Note: DB::FlushWAL(true) will internally call DB::SyncWAL.\n+     * <p>\n+     * See <a href=\""https://rocksdb.org/blog/2017/08/25/flushwal.html\"">Flush And Sync WAL</a>\n+     */\n+    class FlushSyncService extends ServiceThread {\n+\n+        private long lastSyncTime = 0;\n+\n+        private static final long MAX_SYNC_INTERVAL_IN_MILLIS = 100;\n+\n+        private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+        private final FlushOptions flushOptions = new FlushOptions();\n+\n+        @Override\n+        public String getServiceName() {\n+            return \""FlushSyncService\"";\n+        }\n+\n+        @Override\n+        public void run() {\n+            flushOptions.setAllowWriteStall(false);\n+            flushOptions.setWaitForFlush(true);\n+            log.info(\""{} service started\"", this.getServiceName());\n+            while (!this.isStopped()) {\n+                try {\n+                    this.waitForRunning(10);\n+                    this.flushAndSyncWAL(false);\n+                } catch (Exception e) {\n+                    log.warn(\""{} service has exception. \"", this.getServiceName(), e);\n+                }\n+            }\n+            try {\n+                flushAndSyncWAL(true);\n+            } catch (Exception e) {\n+                log.warn(\""{} raised an exception while performing flush-and-sync WAL on exit\"",\n+                    this.getServiceName(), e);\n+            }\n+            flushOptions.close();\n+            log.info(\""{} service end\"", this.getServiceName());\n+        }\n+\n+        private void flushAndSyncWAL(boolean onExit) throws RocksDBException {\n+            int writeOps = writeOpsCounter.get();\n+            if (0 == writeOps) {\n+                // No write ops to flush\n+                return;\n+            }\n+\n+            /*\n+             * Normally, when MemTables become full then immutable, RocksDB threads will automatically flush them to L0\n+             * SST files. The use case here is different: the MemTable may never get full and immutable given that the\n+             * volume of data involved is relatively small. Further, we are constantly modifying the key-value pairs and\n+             * generating WAL entries. The WAL file size can grow up to dozens of gigabytes without manual triggering of\n+             * flush.\n+             */\n+            if (ConfigStorage.this.estimateWalFileSize.get() >= messageStoreConfig.getRocksdbWalFileRollingThreshold()) {\n+                ConfigStorage.this.flush(flushOptions);\n+                estimateWalFileSize.set(0L);\n+            }\n+\n+            // Flush and Sync WAL if we have committed enough writes\n+            if (writeOps >= messageStoreConfig.getRocksdbFlushWalFrequency() || onExit) {\n+                stopwatch.reset().start();\n+                ConfigStorage.this.db.flushWal(true);\n+                long elapsed = stopwatch.stop().elapsed(TimeUnit.MILLISECONDS);\n+                writeOpsCounter.getAndAdd(-writeOps);\n+                lastSyncTime = System.currentTimeMillis();\n+                LOGGER.debug(\""Flush and Sync WAL of RocksDB[{}] costs {}ms, write-ops={}\"", dbPath, elapsed, writeOps);\n+                return;\n+            }\n+            // Flush and Sync WAL if some writes are out there for a period of time\n+            long elapsedTime = System.currentTimeMillis() - lastSyncTime;\n+            if (elapsedTime > MAX_SYNC_INTERVAL_IN_MILLIS) {\n+                stopwatch.reset().start();\n+                ConfigStorage.this.db.flushWal(true);\n+                long elapsed = stopwatch.stop().elapsed(TimeUnit.MILLISECONDS);\n+                LOGGER.debug(\""Flush and Sync WAL of RocksDB[{}] costs {}ms, write-ops={}\"", dbPath, elapsed, writeOps);\n+                writeOpsCounter.getAndAdd(-writeOps);\n+                lastSyncTime = System.currentTimeMillis();\n+            }\n+        }\n+    }\n }\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConsumerOffsetManagerV2.java b/broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConsumerOffsetManagerV2.java\nindex 2c5d3677d88..1821c801cbc 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConsumerOffsetManagerV2.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/config/v2/ConsumerOffsetManagerV2.java\n@@ -97,7 +97,7 @@ protected void removeConsumerOffset(String topicAtGroup) {\n             // TODO: we have to make a copy here as WriteBatch lacks ByteBuffer API here\n             writeBatch.deleteRange(ConfigHelper.readBytes(beginKey), ConfigHelper.readBytes(endKey));\n             long stateMachineVersion = brokerController.getMessageStore() != null ? brokerController.getMessageStore().getStateMachineVersion() : 0;\n-            ConfigHelper.stampDataVersion(writeBatch, dataVersion, stateMachineVersion);\n+            ConfigHelper.stampDataVersion(writeBatch, TableId.CONSUMER_OFFSET, dataVersion, stateMachineVersion);\n             configStorage.write(writeBatch);\n         } catch (RocksDBException e) {\n             LOG.error(\""Failed to removeConsumerOffset, topicAtGroup={}\"", topicAtGroup, e);\n@@ -138,7 +138,7 @@ public void removeOffset(String group) {\n             writeBatch.deleteRange(ConfigHelper.readBytes(beginKey), ConfigHelper.readBytes(endKey));\n             MessageStore messageStore = brokerController.getMessageStore();\n             long stateMachineVersion = messageStore != null ? messageStore.getStateMachineVersion() : 0;\n-            ConfigHelper.stampDataVersion(writeBatch, dataVersion, stateMachineVersion);\n+            ConfigHelper.stampDataVersion(writeBatch, TableId.CONSUMER_OFFSET, dataVersion, stateMachineVersion);\n             configStorage.write(writeBatch);\n         } catch (RocksDBException e) {\n             LOG.error(\""Failed to consumer offsets by group={}\"", group, e);\n@@ -194,7 +194,7 @@ public void commitOffset(String clientHost, String group, String topic, int queu\n             writeBatch.put(keyBuf.nioBuffer(), valueBuf.nioBuffer());\n             MessageStore messageStore = brokerController.getMessageStore();\n             long stateMachineVersion = messageStore != null ? messageStore.getStateMachineVersion() : 0;\n-            ConfigHelper.stampDataVersion(writeBatch, dataVersion, stateMachineVersion);\n+            ConfigHelper.stampDataVersion(writeBatch, TableId.CONSUMER_OFFSET, dataVersion, stateMachineVersion);\n             configStorage.write(writeBatch);\n         } catch (RocksDBException e) {\n             LOG.error(\""Failed to commit consumer offset\"", e);\n@@ -394,7 +394,7 @@ public void commitPullOffset(String clientHost, String group, String topic, int\n         try (WriteBatch writeBatch = new WriteBatch()) {\n             writeBatch.put(keyBuf.nioBuffer(), valueBuf.nioBuffer());\n             long stateMachineVersion = brokerController.getMessageStore() != null ? brokerController.getMessageStore().getStateMachineVersion() : 0;\n-            ConfigHelper.stampDataVersion(writeBatch, dataVersion, stateMachineVersion);\n+            ConfigHelper.stampDataVersion(writeBatch, TableId.PULL_OFFSET, dataVersion, stateMachineVersion);\n             configStorage.write(writeBatch);\n         } catch (RocksDBException e) {\n             LOG.error(\""Failed to commit pull offset. group={}, topic={}, queueId={}, offset={}\"",\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/config/v2/SubscriptionGroupManagerV2.java b/broker/src/main/java/org/apache/rocketmq/broker/config/v2/SubscriptionGroupManagerV2.java\nindex dea8a2d2c17..dd67871f184 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/config/v2/SubscriptionGroupManagerV2.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/config/v2/SubscriptionGroupManagerV2.java\n@@ -137,8 +137,10 @@ public void updateSubscriptionGroupConfig(final SubscriptionGroupConfig config)\n         try (WriteBatch writeBatch = new WriteBatch()) {\n             writeBatch.put(keyBuf.nioBuffer(), valueBuf.nioBuffer());\n             long stateMachineVersion = brokerController.getMessageStore() != null ? brokerController.getMessageStore().getStateMachineVersion() : 0;\n-            ConfigHelper.stampDataVersion(writeBatch, dataVersion, stateMachineVersion);\n+            ConfigHelper.stampDataVersion(writeBatch, TableId.SUBSCRIPTION_GROUP, dataVersion, stateMachineVersion);\n             configStorage.write(writeBatch);\n+            // fdatasync on core metadata change\n+            persist();\n         } catch (RocksDBException e) {\n             log.error(\""update subscription group config error\"", e);\n         } finally {\n@@ -163,7 +165,7 @@ protected SubscriptionGroupConfig removeSubscriptionGroupConfig(String groupName\n         try (WriteBatch writeBatch = new WriteBatch()) {\n             writeBatch.delete(ConfigHelper.readBytes(keyBuf));\n             long stateMachineVersion = brokerController.getMessageStore().getStateMachineVersion();\n-            ConfigHelper.stampDataVersion(writeBatch, dataVersion, stateMachineVersion);\n+            ConfigHelper.stampDataVersion(writeBatch, TableId.SUBSCRIPTION_GROUP, dataVersion, stateMachineVersion);\n             configStorage.write(writeBatch);\n         } catch (RocksDBException e) {\n             log.error(\""Failed to remove subscription group config by group-name={}\"", groupName, e);\n\ndiff --git a/broker/src/main/java/org/apache/rocketmq/broker/config/v2/TopicConfigManagerV2.java b/broker/src/main/java/org/apache/rocketmq/broker/config/v2/TopicConfigManagerV2.java\nindex 4e36b087275..7991d704459 100644\n--- a/broker/src/main/java/org/apache/rocketmq/broker/config/v2/TopicConfigManagerV2.java\n+++ b/broker/src/main/java/org/apache/rocketmq/broker/config/v2/TopicConfigManagerV2.java\n@@ -151,8 +151,10 @@ public void updateTopicConfig(final TopicConfig topicConfig) {\n         try (WriteBatch writeBatch = new WriteBatch()) {\n             writeBatch.put(keyBuf.nioBuffer(), valueBuf.nioBuffer());\n             long stateMachineVersion = brokerController.getMessageStore() != null ? brokerController.getMessageStore().getStateMachineVersion() : 0;\n-            ConfigHelper.stampDataVersion(writeBatch, dataVersion, stateMachineVersion);\n+            ConfigHelper.stampDataVersion(writeBatch, TableId.TOPIC, dataVersion, stateMachineVersion);\n             configStorage.write(writeBatch);\n+            // fdatasync on core metadata change\n+            this.persist();\n         } catch (RocksDBException e) {\n             log.error(\""Failed to update topic config\"", e);\n         } finally {\n@@ -167,7 +169,7 @@ protected TopicConfig removeTopicConfig(String topicName) {\n         try (WriteBatch writeBatch = new WriteBatch()) {\n             writeBatch.delete(keyBuf.nioBuffer());\n             long stateMachineVersion = brokerController.getMessageStore() != null ? brokerController.getMessageStore().getStateMachineVersion() : 0;\n-            ConfigHelper.stampDataVersion(writeBatch, dataVersion, stateMachineVersion);\n+            ConfigHelper.stampDataVersion(writeBatch, TableId.TOPIC, dataVersion, stateMachineVersion);\n             configStorage.write(writeBatch);\n         } catch (RocksDBException e) {\n             log.error(\""Failed to delete topic config by topicName={}\"", topicName, e);\n\ndiff --git a/common/src/main/java/org/apache/rocketmq/common/config/AbstractRocksDBStorage.java b/common/src/main/java/org/apache/rocketmq/common/config/AbstractRocksDBStorage.java\nindex d434cce7451..1efc708e979 100644\n--- a/common/src/main/java/org/apache/rocketmq/common/config/AbstractRocksDBStorage.java\n+++ b/common/src/main/java/org/apache/rocketmq/common/config/AbstractRocksDBStorage.java\n@@ -121,14 +121,16 @@ protected void initWriteOptions() {\n         this.writeOptions = new WriteOptions();\n         this.writeOptions.setSync(false);\n         this.writeOptions.setDisableWAL(true);\n-        this.writeOptions.setNoSlowdown(true);\n+        // https://github.com/facebook/rocksdb/wiki/Write-Stalls\n+        this.writeOptions.setNoSlowdown(false);\n     }\n \n     protected void initAbleWalWriteOptions() {\n         this.ableWalWriteOptions = new WriteOptions();\n         this.ableWalWriteOptions.setSync(false);\n         this.ableWalWriteOptions.setDisableWAL(false);\n-        this.ableWalWriteOptions.setNoSlowdown(true);\n+        // https://github.com/facebook/rocksdb/wiki/Write-Stalls\n+        this.ableWalWriteOptions.setNoSlowdown(false);\n     }\n \n     protected void initReadOptions() {\n@@ -362,7 +364,7 @@ public synchronized boolean start() {\n         }\n         if (postLoad()) {\n             this.loaded = true;\n-            LOGGER.info(\""start OK. {}\"", this.dbPath);\n+            LOGGER.info(\""RocksDB[{}] starts OK\"", this.dbPath);\n             this.closed = false;\n             return true;\n         } else {\n@@ -559,7 +561,15 @@ private String getStatusError(RocksDBException e) {\n \n     public void statRocksdb(Logger logger) {\n         try {\n+            // Log Memory Usage\n+            String blockCacheMemUsage = this.db.getProperty(\""rocksdb.block-cache-usage\"");\n+            String indexesAndFilterBlockMemUsage = this.db.getProperty(\""rocksdb.estimate-table-readers-mem\"");\n+            String memTableMemUsage = this.db.getProperty(\""rocksdb.cur-size-all-mem-tables\"");\n+            String blocksPinnedByIteratorMemUsage = this.db.getProperty(\""rocksdb.block-cache-pinned-usage\"");\n+            logger.info(\""RocksDB Memory Usage: BlockCache: {}, IndexesAndFilterBlock: {}, MemTable: {}, BlocksPinnedByIterator: {}\"",\n+                blockCacheMemUsage, indexesAndFilterBlockMemUsage, memTableMemUsage, blocksPinnedByIteratorMemUsage);\n \n+            // Log file metadata by level\n             List<LiveFileMetaData> liveFileMetaDataList = this.getCompactionStatus();\n             if (liveFileMetaDataList == null || liveFileMetaDataList.isEmpty()) {\n                 return;\n@@ -569,21 +579,13 @@ public void statRocksdb(Logger logger) {\n                 StringBuilder sb = map.computeIfAbsent(metaData.level(), k -> new StringBuilder(256));\n                 sb.append(new String(metaData.columnFamilyName(), StandardCharsets.UTF_8)).append(SPACE).\n                     append(metaData.fileName()).append(SPACE).\n-                    append(\""s: \"").append(metaData.size()).append(SPACE).\n-                    append(\""a: \"").append(metaData.numEntries()).append(SPACE).\n-                    append(\""r: \"").append(metaData.numReadsSampled()).append(SPACE).\n-                    append(\""d: \"").append(metaData.numDeletions()).append(SPACE).\n-                    append(metaData.beingCompacted()).append(\""\\n\"");\n+                    append(\""file-size: \"").append(metaData.size()).append(SPACE).\n+                    append(\""number-of-entries: \"").append(metaData.numEntries()).append(SPACE).\n+                    append(\""file-read-times: \"").append(metaData.numReadsSampled()).append(SPACE).\n+                    append(\""deletions: \"").append(metaData.numDeletions()).append(SPACE).\n+                    append(\""being-compacted: \"").append(metaData.beingCompacted()).append(\""\\n\"");\n             }\n-\n             map.forEach((key, value) -> logger.info(\""level: {}\\n{}\"", key, value.toString()));\n-\n-            String blockCacheMemUsage = this.db.getProperty(\""rocksdb.block-cache-usage\"");\n-            String indexesAndFilterBlockMemUsage = this.db.getProperty(\""rocksdb.estimate-table-readers-mem\"");\n-            String memTableMemUsage = this.db.getProperty(\""rocksdb.cur-size-all-mem-tables\"");\n-            String blocksPinnedByIteratorMemUsage = this.db.getProperty(\""rocksdb.block-cache-pinned-usage\"");\n-            logger.info(\""MemUsage. blockCache: {}, indexesAndFilterBlock: {}, MemTable: {}, blocksPinnedByIterator: {}\"",\n-                blockCacheMemUsage, indexesAndFilterBlockMemUsage, memTableMemUsage, blocksPinnedByIteratorMemUsage);\n         } catch (Exception ignored) {\n         }\n     }\n\ndiff --git a/common/src/main/java/org/apache/rocketmq/common/config/ConfigHelper.java b/common/src/main/java/org/apache/rocketmq/common/config/ConfigHelper.java\nindex a4ba35bd5ae..e3f6f22002e 100644\n--- a/common/src/main/java/org/apache/rocketmq/common/config/ConfigHelper.java\n+++ b/common/src/main/java/org/apache/rocketmq/common/config/ConfigHelper.java\n@@ -38,7 +38,7 @@\n import org.rocksdb.util.SizeUnit;\n \n public class ConfigHelper {\n-    public static ColumnFamilyOptions createConfigOptions() {\n+    public static ColumnFamilyOptions createConfigColumnFamilyOptions() {\n         BlockBasedTableConfig blockBasedTableConfig = new BlockBasedTableConfig().\n             setFormatVersion(5).\n             setIndexType(IndexType.kBinarySearch).\n@@ -46,7 +46,7 @@ public static ColumnFamilyOptions createConfigOptions() {\n             setBlockSize(32 * SizeUnit.KB).\n             setFilterPolicy(new BloomFilter(16, false)).\n             // Indicating if we'd put index/filter blocks to the block cache.\n-                setCacheIndexAndFilterBlocks(false).\n+            setCacheIndexAndFilterBlocks(true).\n             setCacheIndexAndFilterBlocksWithHighPriority(true).\n             setPinL0FilterAndIndexBlocksInCache(false).\n             setPinTopLevelIndexAndFilter(true).\n@@ -54,9 +54,8 @@ public static ColumnFamilyOptions createConfigOptions() {\n             setWholeKeyFiltering(true);\n \n         ColumnFamilyOptions options = new ColumnFamilyOptions();\n-        return options.setMaxWriteBufferNumber(2).\n-            // MemTable size, MemTable(cache) -> immutable MemTable(cache) -> SST(disk)\n-                setWriteBufferSize(8 * SizeUnit.MB).\n+        return options.setMaxWriteBufferNumber(4).\n+            setWriteBufferSize(64 * SizeUnit.MB).\n             setMinWriteBufferNumberToMerge(1).\n             setTableFormatConfig(blockBasedTableConfig).\n             setMemTableConfig(new SkipListMemTableConfig()).\n@@ -67,17 +66,17 @@ public static ColumnFamilyOptions createConfigOptions() {\n             setLevel0SlowdownWritesTrigger(8).\n             setLevel0StopWritesTrigger(12).\n             // The target file size for compaction.\n-                setTargetFileSizeBase(64 * SizeUnit.MB).\n+            setTargetFileSizeBase(64 * SizeUnit.MB).\n             setTargetFileSizeMultiplier(2).\n             // The upper-bound of the total size of L1 files in bytes\n-                setMaxBytesForLevelBase(256 * SizeUnit.MB).\n+            setMaxBytesForLevelBase(256 * SizeUnit.MB).\n             setMaxBytesForLevelMultiplier(2).\n             setMergeOperator(new StringAppendOperator()).\n             setInplaceUpdateSupport(true);\n     }\n \n     public static DBOptions createConfigDBOptions() {\n-        //Turn based on https://github.com/facebook/rocksdb/wiki/RocksDB-Tuning-Guide\n+        // Tune based on https://github.com/facebook/rocksdb/wiki/RocksDB-Tuning-Guide\n         // and http://gitlab.alibaba-inc.com/aloha/aloha/blob/branch_2_5_0/jstorm-core/src/main/java/com/alibaba/jstorm/cache/rocksdb/RocksDbOptionsFactory.java\n         DBOptions options = new DBOptions();\n         Statistics statistics = new Statistics();\n@@ -86,10 +85,20 @@ public static DBOptions createConfigDBOptions() {\n             setDbLogDir(getDBLogDir()).\n             setInfoLogLevel(InfoLogLevel.INFO_LEVEL).\n             setWalRecoveryMode(WALRecoveryMode.SkipAnyCorruptedRecords).\n+            /*\n+             * We use manual flush to achieve desired balance between reliability and performance:\n+             * for metadata that matters, including {topic, subscription}-config changes, each write incurs a\n+             * flush-and-sync to ensure reliability; for {commit, pull}-offset advancements, group-flush are offered for\n+             * every N(configurable, 1024 by default) writes or aging of writes, similar to OS page-cache flush\n+             * mechanism.\n+             */\n             setManualWalFlush(true).\n-            setMaxTotalWalSize(500 * SizeUnit.MB).\n-            setWalSizeLimitMB(0).\n-            setWalTtlSeconds(0).\n+            // This option takes effect only when we have multiple column families\n+            // https://github.com/facebook/rocksdb/issues/4180\n+            // setMaxTotalWalSize(1024 * SizeUnit.MB).\n+            setDbWriteBufferSize(128 * SizeUnit.MB).\n+            setBytesPerSync(SizeUnit.MB).\n+            setWalBytesPerSync(SizeUnit.MB).\n             setCreateIfMissing(true).\n             setCreateMissingColumnFamilies(true).\n             setMaxOpenFiles(-1).\n@@ -99,7 +108,6 @@ public static DBOptions createConfigDBOptions() {\n             setAllowConcurrentMemtableWrite(false).\n             setStatistics(statistics).\n             setStatsDumpPeriodSec(600).\n-            setAtomicFlush(true).\n             setMaxBackgroundJobs(32).\n             setMaxSubcompactions(4).\n             setParanoidChecks(true).\n\ndiff --git a/common/src/main/java/org/apache/rocketmq/common/config/ConfigRocksDBStorage.java b/common/src/main/java/org/apache/rocketmq/common/config/ConfigRocksDBStorage.java\nindex 3b924a6a0d2..5fd9bab2d77 100644\n--- a/common/src/main/java/org/apache/rocketmq/common/config/ConfigRocksDBStorage.java\n+++ b/common/src/main/java/org/apache/rocketmq/common/config/ConfigRocksDBStorage.java\n@@ -70,7 +70,7 @@ protected boolean postLoad() {\n \n             final List<ColumnFamilyDescriptor> cfDescriptors = new ArrayList<>();\n \n-            ColumnFamilyOptions defaultOptions = ConfigHelper.createConfigOptions();\n+            ColumnFamilyOptions defaultOptions = ConfigHelper.createConfigColumnFamilyOptions();\n             this.cfOptions.add(defaultOptions);\n             cfDescriptors.add(new ColumnFamilyDescriptor(RocksDB.DEFAULT_COLUMN_FAMILY, defaultOptions));\n             cfDescriptors.add(new ColumnFamilyDescriptor(KV_DATA_VERSION_COLUMN_FAMILY_NAME, defaultOptions));\n\ndiff --git a/store/src/main/java/org/apache/rocketmq/store/CommitLog.java b/store/src/main/java/org/apache/rocketmq/store/CommitLog.java\nindex 63022520e2a..999d9bd301d 100644\n--- a/store/src/main/java/org/apache/rocketmq/store/CommitLog.java\n+++ b/store/src/main/java/org/apache/rocketmq/store/CommitLog.java\n@@ -326,22 +326,26 @@ public void recoverNormally(long maxPhyOffsetOfConsumeQueue) throws RocksDBExcep\n         boolean checkDupInfo = this.defaultMessageStore.getMessageStoreConfig().isDuplicationEnable();\n         final List<MappedFile> mappedFiles = this.mappedFileQueue.getMappedFiles();\n         if (!mappedFiles.isEmpty()) {\n-            // Began to recover from the last third file\n-            int index = mappedFiles.size() - 3;\n-            if (index < 0) {\n-                index = 0;\n+            int index = mappedFiles.size() - 1;\n+            while (index > 0) {\n+                MappedFile mappedFile = mappedFiles.get(index);\n+                if (mappedFile.getFileFromOffset() <= maxPhyOffsetOfConsumeQueue) {\n+                    // It's safe to recover from this mapped file\n+                    break;\n+                }\n+                index--;\n             }\n+            // TODO: Discuss if we need to load more commit-log mapped files into memory.\n \n             MappedFile mappedFile = mappedFiles.get(index);\n             ByteBuffer byteBuffer = mappedFile.sliceByteBuffer();\n             long processOffset = mappedFile.getFileFromOffset();\n             long mappedFileOffset = 0;\n             long lastValidMsgPhyOffset = this.getConfirmOffset();\n-            // normal recover doesn't require dispatching\n-            boolean doDispatch = false;\n             while (true) {\n                 DispatchRequest dispatchRequest = this.checkMessageAndReturnSize(byteBuffer, checkCRCOnRecover, checkDupInfo);\n                 int size = dispatchRequest.getMsgSize();\n+                boolean doDispatch = dispatchRequest.getCommitLogOffset() > maxPhyOffsetOfConsumeQueue;\n                 // Normal data\n                 if (dispatchRequest.isSuccess() && size > 0) {\n                     lastValidMsgPhyOffset = processOffset + mappedFileOffset;\n\ndiff --git a/store/src/main/java/org/apache/rocketmq/store/config/MessageStoreConfig.java b/store/src/main/java/org/apache/rocketmq/store/config/MessageStoreConfig.java\nindex fe090e3fa2a..6dfdc0b1c84 100644\n--- a/store/src/main/java/org/apache/rocketmq/store/config/MessageStoreConfig.java\n+++ b/store/src/main/java/org/apache/rocketmq/store/config/MessageStoreConfig.java\n@@ -23,6 +23,7 @@\n import org.apache.rocketmq.store.StoreType;\n import org.apache.rocketmq.store.queue.BatchConsumeQueue;\n import org.rocksdb.CompressionType;\n+import org.rocksdb.util.SizeUnit;\n \n public class MessageStoreConfig {\n \n@@ -444,6 +445,13 @@ public class MessageStoreConfig {\n \n     private String rocksdbCompressionType = CompressionType.LZ4_COMPRESSION.getLibraryName();\n \n+    /**\n+     * Flush RocksDB WAL frequency, aka, flush WAL every N write ops.\n+     */\n+    private int rocksdbFlushWalFrequency = 1024;\n+\n+    private long rocksdbWalFileRollingThreshold = SizeUnit.GB;\n+\n     public String getRocksdbCompressionType() {\n         return rocksdbCompressionType;\n     }\n@@ -1902,6 +1910,22 @@ public void setBottomMostCompressionTypeForConsumeQueueStore(String bottomMostCo\n         this.bottomMostCompressionTypeForConsumeQueueStore = bottomMostCompressionTypeForConsumeQueueStore;\n     }\n \n+    public int getRocksdbFlushWalFrequency() {\n+        return rocksdbFlushWalFrequency;\n+    }\n+\n+    public void setRocksdbFlushWalFrequency(int rocksdbFlushWalFrequency) {\n+        this.rocksdbFlushWalFrequency = rocksdbFlushWalFrequency;\n+    }\n+\n+    public long getRocksdbWalFileRollingThreshold() {\n+        return rocksdbWalFileRollingThreshold;\n+    }\n+\n+    public void setRocksdbWalFileRollingThreshold(long rocksdbWalFileRollingThreshold) {\n+        this.rocksdbWalFileRollingThreshold = rocksdbWalFileRollingThreshold;\n+    }\n+\n     public int getSpinLockCollisionRetreatOptimalDegree() {\n         return spinLockCollisionRetreatOptimalDegree;\n     }\n\ndiff --git a/store/src/main/java/org/apache/rocketmq/store/queue/RocksDBConsumeQueueStore.java b/store/src/main/java/org/apache/rocketmq/store/queue/RocksDBConsumeQueueStore.java\nindex 67a00157431..e9e7e8248ee 100644\n--- a/store/src/main/java/org/apache/rocketmq/store/queue/RocksDBConsumeQueueStore.java\n+++ b/store/src/main/java/org/apache/rocketmq/store/queue/RocksDBConsumeQueueStore.java\n@@ -30,12 +30,14 @@\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n \n+import java.util.concurrent.atomic.AtomicReference;\n import javax.annotation.Nonnull;\n import org.apache.commons.io.FileUtils;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.rocketmq.common.BoundaryType;\n import org.apache.rocketmq.common.MixAll;\n import org.apache.rocketmq.common.Pair;\n+import org.apache.rocketmq.common.ServiceState;\n import org.apache.rocketmq.common.ThreadFactoryImpl;\n import org.apache.rocketmq.common.constant.LoggerName;\n import org.apache.rocketmq.common.message.MessageConst;\n@@ -84,6 +86,10 @@ public class RocksDBConsumeQueueStore extends AbstractConsumeQueueStore {\n \n     private final OffsetInitializer offsetInitializer;\n \n+    private final RocksGroupCommitService groupCommitService;\n+\n+    private final AtomicReference<ServiceState> serviceState = new AtomicReference<>(ServiceState.CREATE_JUST);\n+\n     public RocksDBConsumeQueueStore(DefaultMessageStore messageStore) {\n         super(messageStore);\n \n@@ -93,6 +99,7 @@ public RocksDBConsumeQueueStore(DefaultMessageStore messageStore) {\n         this.rocksDBConsumeQueueOffsetTable = new RocksDBConsumeQueueOffsetTable(rocksDBConsumeQueueTable, rocksDBStorage, messageStore);\n \n         this.offsetInitializer = new OffsetInitializerRocksDBImpl(this);\n+        this.groupCommitService = new RocksGroupCommitService(this);\n         this.cqBBPairList = new ArrayList<>(16);\n         this.offsetBBPairList = new ArrayList<>(DEFAULT_BYTE_BUFFER_CAPACITY);\n         for (int i = 0; i < DEFAULT_BYTE_BUFFER_CAPACITY; i++) {\n@@ -123,14 +130,17 @@ private Pair<ByteBuffer, ByteBuffer> getOffsetByteBufferPair() {\n \n     @Override\n     public void start() {\n-        log.info(\""RocksDB ConsumeQueueStore start!\"");\n-        this.scheduledExecutorService.scheduleAtFixedRate(() -> {\n-            this.rocksDBStorage.statRocksdb(ROCKSDB_LOG);\n-        }, 10, this.messageStoreConfig.getStatRocksDBCQIntervalSec(), TimeUnit.SECONDS);\n-\n-        this.scheduledExecutorService.scheduleWithFixedDelay(() -> {\n-            cleanDirty(messageStore.getTopicConfigs().keySet());\n-        }, 10, this.messageStoreConfig.getCleanRocksDBDirtyCQIntervalMin(), TimeUnit.MINUTES);\n+        if (serviceState.compareAndSet(ServiceState.CREATE_JUST, ServiceState.RUNNING)) {\n+            log.info(\""RocksDB ConsumeQueueStore start!\"");\n+            this.groupCommitService.start();\n+            this.scheduledExecutorService.scheduleAtFixedRate(() -> {\n+                this.rocksDBStorage.statRocksdb(ROCKSDB_LOG);\n+            }, 10, this.messageStoreConfig.getStatRocksDBCQIntervalSec(), TimeUnit.SECONDS);\n+\n+            this.scheduledExecutorService.scheduleWithFixedDelay(() -> {\n+                cleanDirty(messageStore.getTopicConfigs().keySet());\n+            }, 10, this.messageStoreConfig.getCleanRocksDBDirtyCQIntervalMin(), TimeUnit.MINUTES);\n+        }\n     }\n \n     private void cleanDirty(final Set<String> existTopicSet) {\n@@ -165,18 +175,23 @@ public boolean loadAfterDestroy() {\n \n     @Override\n     public void recover() {\n-        // ignored\n+        start();\n     }\n \n     @Override\n     public boolean recoverConcurrently() {\n+        start();\n         return true;\n     }\n \n     @Override\n     public boolean shutdown() {\n-        this.scheduledExecutorService.shutdown();\n-        return shutdownInner();\n+        if (serviceState.compareAndSet(ServiceState.RUNNING, ServiceState.SHUTDOWN_ALREADY)) {\n+            this.groupCommitService.shutdown();\n+            this.scheduledExecutorService.shutdown();\n+            return shutdownInner();\n+        }\n+        return true;\n     }\n \n     private boolean shutdownInner() {\n@@ -188,23 +203,25 @@ public void putMessagePositionInfoWrapper(DispatchRequest request) throws RocksD\n         if (null == request) {\n             return;\n         }\n-        // We are taking advantage of Atomic Flush, this operation is purely memory-based.\n-        // batch and cache in Java heap does not make sense, instead, we should put the metadata into RocksDB immediately\n-        // to optimized overall end-to-end latency.\n-        putMessagePosition(request);\n+\n+        try {\n+            groupCommitService.putRequest(request);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n     }\n \n-    public void putMessagePosition(DispatchRequest request) throws RocksDBException {\n+    public void putMessagePosition(List<DispatchRequest> requests) throws RocksDBException {\n         final int maxRetries = 30;\n         for (int i = 0; i < maxRetries; i++) {\n-            if (putMessagePosition0(request)) {\n+            if (putMessagePosition0(requests)) {\n                 if (this.isCQError) {\n                     this.messageStore.getRunningFlags().clearLogicsQueueError();\n                     this.isCQError = false;\n                 }\n                 return;\n             } else {\n-                ERROR_LOG.warn(\""{} put cq Failed. retryTime: {}\"", i);\n+                ERROR_LOG.warn(\""Put cq Failed. retryTime: {}\"", i);\n                 try {\n                     Thread.sleep(100);\n                 } catch (InterruptedException ignored) {\n@@ -219,34 +236,43 @@ public void putMessagePosition(DispatchRequest request) throws RocksDBException\n         throw new RocksDBException(\""put CQ Failed\"");\n     }\n \n-    private boolean putMessagePosition0(DispatchRequest request) {\n+    private boolean putMessagePosition0(List<DispatchRequest> requests) {\n         if (!this.rocksDBStorage.hold()) {\n             return false;\n         }\n \n         try (WriteBatch writeBatch = new WriteBatch()) {\n+            final int size = requests.size();\n+            if (size == 0) {\n+                return true;\n+            }\n             long maxPhyOffset = 0;\n-            DispatchEntry entry = DispatchEntry.from(request);\n-            dispatch(entry, writeBatch);\n-            dispatchLMQ(request, writeBatch);\n-\n-            final int msgSize = request.getMsgSize();\n-            final long phyOffset = request.getCommitLogOffset();\n-            if (phyOffset + msgSize >= maxPhyOffset) {\n-                maxPhyOffset = phyOffset + msgSize;\n+            for (int i = size - 1; i >= 0; i--) {\n+                final DispatchRequest request = requests.get(i);\n+                DispatchEntry entry = DispatchEntry.from(request);\n+                dispatch(entry, writeBatch);\n+                dispatchLMQ(request, writeBatch);\n+\n+                final int msgSize = request.getMsgSize();\n+                final long phyOffset = request.getCommitLogOffset();\n+                if (phyOffset + msgSize >= maxPhyOffset) {\n+                    maxPhyOffset = phyOffset + msgSize;\n+                }\n             }\n \n             this.rocksDBConsumeQueueOffsetTable.putMaxPhyAndCqOffset(tempTopicQueueMaxOffsetMap, writeBatch, maxPhyOffset);\n \n             this.rocksDBStorage.batchPut(writeBatch);\n+\n             this.rocksDBConsumeQueueOffsetTable.putHeapMaxCqOffset(tempTopicQueueMaxOffsetMap);\n-            long storeTimeStamp = request.getStoreTimestamp();\n+\n+            long storeTimeStamp = requests.get(size - 1).getStoreTimestamp();\n             if (this.messageStore.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE\n                 || this.messageStore.getMessageStoreConfig().isEnableDLegerCommitLog()) {\n                 this.messageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimeStamp);\n             }\n             this.messageStore.getStoreCheckpoint().setLogicsMsgTimestamp(storeTimeStamp);\n-            notifyMessageArrival(request);\n+            notifyMessageArriveAndClear(requests);\n             return true;\n         } catch (Exception e) {\n             ERROR_LOG.error(\""putMessagePosition0 failed.\"", e);\n@@ -311,9 +337,12 @@ private void dispatchLMQ(@Nonnull DispatchRequest request, @Nonnull final WriteB\n         }\n     }\n \n-    private void notifyMessageArrival(DispatchRequest request) {\n+    private void notifyMessageArriveAndClear(List<DispatchRequest> requests) {\n         try {\n-            this.messageStore.notifyMessageArriveIfNecessary(request);\n+            for (DispatchRequest dp : requests) {\n+                this.messageStore.notifyMessageArriveIfNecessary(dp);\n+            }\n+            requests.clear();\n         } catch (Exception e) {\n             ERROR_LOG.error(\""notifyMessageArriveAndClear Failed.\"", e);\n         }\n@@ -532,4 +561,8 @@ public Long getMaxOffset(String topic, int queueId) throws ConsumeQueueException\n         }\n         return super.getMaxOffset(topic, queueId);\n     }\n+\n+    public boolean isStopped() {\n+        return ServiceState.SHUTDOWN_ALREADY == serviceState.get();\n+    }\n }\n\ndiff --git a/store/src/main/java/org/apache/rocketmq/store/queue/RocksGroupCommitService.java b/store/src/main/java/org/apache/rocketmq/store/queue/RocksGroupCommitService.java\nnew file mode 100644\nindex 00000000000..e2f2c9ee2c1\n--- /dev/null\n+++ b/store/src/main/java/org/apache/rocketmq/store/queue/RocksGroupCommitService.java\n@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \""License\""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.rocketmq.store.queue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.rocketmq.common.ServiceThread;\n+import org.apache.rocketmq.store.DispatchRequest;\n+import org.rocksdb.RocksDBException;\n+\n+public class RocksGroupCommitService extends ServiceThread {\n+\n+    private static final int MAX_BUFFER_SIZE = 100_000;\n+\n+    private static final int PREFERRED_DISPATCH_REQUEST_COUNT = 256;\n+\n+    private final LinkedBlockingQueue<DispatchRequest> buffer;\n+\n+    private final RocksDBConsumeQueueStore store;\n+\n+    private final List<DispatchRequest> requests = new ArrayList<>(PREFERRED_DISPATCH_REQUEST_COUNT);\n+\n+    public RocksGroupCommitService(RocksDBConsumeQueueStore store) {\n+        this.store = store;\n+        this.buffer = new LinkedBlockingQueue<>(MAX_BUFFER_SIZE);\n+    }\n+\n+    @Override\n+    public String getServiceName() {\n+        return \""RocksGroupCommit\"";\n+    }\n+\n+    @Override\n+    public void run() {\n+        log.info(\""{} service started\"", this.getServiceName());\n+        while (!this.isStopped()) {\n+            try {\n+                this.waitForRunning(10);\n+                this.doCommit();\n+            } catch (Exception e) {\n+                log.warn(\""{} service has exception. \"", this.getServiceName(), e);\n+            }\n+        }\n+        log.info(\""{} service end\"", this.getServiceName());\n+    }\n+\n+    public void putRequest(final DispatchRequest request) throws InterruptedException {\n+        while (!buffer.offer(request, 3, TimeUnit.SECONDS)) {\n+            log.warn(\""RocksGroupCommitService#buffer is full, 3s elapsed before space becomes available\"");\n+        }\n+        this.wakeup();\n+    }\n+\n+    private void doCommit() {\n+        while (!buffer.isEmpty()) {\n+            while (true) {\n+                DispatchRequest dispatchRequest = buffer.poll();\n+                if (null != dispatchRequest) {\n+                    requests.add(dispatchRequest);\n+                }\n+\n+                if (requests.isEmpty()) {\n+                    // buffer has been drained\n+                    break;\n+                }\n+\n+                if (null == dispatchRequest || requests.size() >= PREFERRED_DISPATCH_REQUEST_COUNT) {\n+                    groupCommit();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void groupCommit() {\n+        while (!store.isStopped()) {\n+            try {\n+                // putMessagePosition will clear requests after consume queue building completion\n+                store.putMessagePosition(requests);\n+                break;\n+            } catch (RocksDBException e) {\n+                log.error(\""Failed to build consume queue in RocksDB\"", e);\n+            }\n+        }\n+    }\n+\n+}\n\ndiff --git a/store/src/main/java/org/apache/rocketmq/store/rocksdb/RocksDBOptionsFactory.java b/store/src/main/java/org/apache/rocketmq/store/rocksdb/RocksDBOptionsFactory.java\nindex 66f5cbd095d..2fac3bf485d 100644\n--- a/store/src/main/java/org/apache/rocketmq/store/rocksdb/RocksDBOptionsFactory.java\n+++ b/store/src/main/java/org/apache/rocketmq/store/rocksdb/RocksDBOptionsFactory.java\n@@ -22,6 +22,7 @@\n import org.rocksdb.BloomFilter;\n import org.rocksdb.ColumnFamilyOptions;\n import org.rocksdb.CompactionOptionsUniversal;\n+import org.rocksdb.CompactionPriority;\n import org.rocksdb.CompactionStopStyle;\n import org.rocksdb.CompactionStyle;\n import org.rocksdb.CompressionType;\n@@ -79,6 +80,7 @@ public static ColumnFamilyOptions createCQCFOptions(final MessageStore messageSt\n                 setCompressionType(compressionType).\n                 setBottommostCompressionType(bottomMostCompressionType).\n                 setNumLevels(7).\n+                setCompactionPriority(CompactionPriority.MinOverlappingRatio).\n                 setCompactionStyle(CompactionStyle.UNIVERSAL).\n                 setCompactionOptionsUniversal(compactionOption).\n                 setMaxCompactionBytes(100 * SizeUnit.GB).\n@@ -144,10 +146,8 @@ public static DBOptions createDBOptions() {\n                 setInfoLogLevel(InfoLogLevel.INFO_LEVEL).\n                 setWalRecoveryMode(WALRecoveryMode.PointInTimeRecovery).\n                 setManualWalFlush(true).\n-                setMaxTotalWalSize(0).\n-                setWalSizeLimitMB(0).\n-                setWalTtlSeconds(0).\n                 setCreateIfMissing(true).\n+                setBytesPerSync(SizeUnit.MB).\n                 setCreateMissingColumnFamilies(true).\n                 setMaxOpenFiles(-1).\n                 setMaxLogFileSize(SizeUnit.GB).\n@@ -156,6 +156,7 @@ public static DBOptions createDBOptions() {\n                 setAllowConcurrentMemtableWrite(false).\n                 setStatistics(statistics).\n                 setAtomicFlush(true).\n+                setCompactionReadaheadSize(4 * SizeUnit.MB).\n                 setMaxBackgroundJobs(32).\n                 setMaxSubcompactions(8).\n                 setParanoidChecks(true).\n"", ""test_patch"": ""diff --git a/broker/src/test/java/org/apache/rocketmq/broker/config/v2/ConsumerOffsetManagerV2Test.java b/broker/src/test/java/org/apache/rocketmq/broker/config/v2/ConsumerOffsetManagerV2Test.java\nindex d7f46855e1a..132bd5c1a56 100644\n--- a/broker/src/test/java/org/apache/rocketmq/broker/config/v2/ConsumerOffsetManagerV2Test.java\n+++ b/broker/src/test/java/org/apache/rocketmq/broker/config/v2/ConsumerOffsetManagerV2Test.java\n@@ -23,6 +23,7 @@\n import org.apache.rocketmq.broker.offset.ConsumerOffsetManager;\n import org.apache.rocketmq.common.BrokerConfig;\n import org.apache.rocketmq.common.MixAll;\n+import org.apache.rocketmq.store.config.MessageStoreConfig;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n@@ -44,6 +45,8 @@ public class ConsumerOffsetManagerV2Test {\n     @Mock\n     private BrokerController controller;\n \n+    private MessageStoreConfig messageStoreConfig;\n+\n     @Rule\n     public TemporaryFolder tf = new TemporaryFolder();\n \n@@ -60,7 +63,9 @@ public void setUp() throws IOException {\n         Mockito.doReturn(brokerConfig).when(controller).getBrokerConfig();\n \n         File configStoreDir = tf.newFolder();\n-        configStorage = new ConfigStorage(configStoreDir.getAbsolutePath());\n+        messageStoreConfig = new MessageStoreConfig();\n+        messageStoreConfig.setStorePathRootDir(configStoreDir.getAbsolutePath());\n+        configStorage = new ConfigStorage(messageStoreConfig);\n         configStorage.start();\n         consumerOffsetManagerV2 = new ConsumerOffsetManagerV2(controller, configStorage);\n     }\n@@ -84,7 +89,9 @@ public void testCommitOffset_Standard() {\n         consumerOffsetManagerV2.getOffsetTable().clear();\n         Assert.assertEquals(-1L, consumerOffsetManagerV2.queryOffset(group, topic, queueId));\n \n+        configStorage = new ConfigStorage(messageStoreConfig);\n         configStorage.start();\n+        consumerOffsetManagerV2 = new ConsumerOffsetManagerV2(controller, configStorage);\n         consumerOffsetManagerV2.load();\n         Assert.assertEquals(queueOffset, consumerOffsetManagerV2.queryOffset(group, topic, queueId));\n     }\n@@ -106,7 +113,9 @@ public void testCommitOffset_LMQ() {\n \n         configStorage.shutdown();\n \n+        configStorage = new ConfigStorage(messageStoreConfig);\n         configStorage.start();\n+        consumerOffsetManagerV2 = new ConsumerOffsetManagerV2(controller, configStorage);\n         consumerOffsetManagerV2.load();\n         Assert.assertEquals(queueOffset, consumerOffsetManagerV2.queryOffset(group, topic, queueId));\n     }\n@@ -129,7 +138,9 @@ public void testCommitPullOffset_LMQ() {\n \n         configStorage.shutdown();\n \n+        configStorage = new ConfigStorage(messageStoreConfig);\n         configStorage.start();\n+        consumerOffsetManagerV2 = new ConsumerOffsetManagerV2(controller, configStorage);\n         consumerOffsetManagerV2.load();\n         Assert.assertEquals(queueOffset, consumerOffsetManagerV2.queryPullOffset(group, topic, queueId));\n     }\n@@ -157,7 +168,10 @@ public void testRemoveByTopicAtGroup() {\n         Assert.assertEquals(queueOffset, consumerOffsetManagerV2.queryOffset(group, topic2, queueId));\n \n         configStorage.shutdown();\n+\n+        configStorage = new ConfigStorage(messageStoreConfig);\n         configStorage.start();\n+        consumerOffsetManagerV2 = new ConsumerOffsetManagerV2(controller, configStorage);\n         consumerOffsetManagerV2.load();\n         Assert.assertEquals(-1L, consumerOffsetManagerV2.queryOffset(group, topic, queueId));\n         Assert.assertEquals(queueOffset, consumerOffsetManagerV2.queryOffset(group, topic2, queueId));\n@@ -184,7 +198,10 @@ public void testRemoveByGroup() {\n         Assert.assertEquals(-1L, consumerOffsetManagerV2.queryOffset(group, topic2, queueId));\n \n         configStorage.shutdown();\n+\n+        configStorage = new ConfigStorage(messageStoreConfig);\n         configStorage.start();\n+        consumerOffsetManagerV2 = new ConsumerOffsetManagerV2(controller, configStorage);\n         consumerOffsetManagerV2.load();\n         Assert.assertEquals(-1L, consumerOffsetManagerV2.queryOffset(group, topic, queueId));\n         Assert.assertEquals(-1L, consumerOffsetManagerV2.queryOffset(group, topic2, queueId));\n\ndiff --git a/broker/src/test/java/org/apache/rocketmq/broker/config/v2/SubscriptionGroupManagerV2Test.java b/broker/src/test/java/org/apache/rocketmq/broker/config/v2/SubscriptionGroupManagerV2Test.java\nindex 6d436a7c4db..4ff8a81e60a 100644\n--- a/broker/src/test/java/org/apache/rocketmq/broker/config/v2/SubscriptionGroupManagerV2Test.java\n+++ b/broker/src/test/java/org/apache/rocketmq/broker/config/v2/SubscriptionGroupManagerV2Test.java\n@@ -25,6 +25,7 @@\n import org.apache.rocketmq.remoting.protocol.subscription.GroupRetryPolicyType;\n import org.apache.rocketmq.remoting.protocol.subscription.SubscriptionGroupConfig;\n import org.apache.rocketmq.store.MessageStore;\n+import org.apache.rocketmq.store.config.MessageStoreConfig;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n@@ -38,6 +39,9 @@\n \n @RunWith(MockitoJUnitRunner.class)\n public class SubscriptionGroupManagerV2Test {\n+\n+    private MessageStoreConfig messageStoreConfig;\n+\n     private ConfigStorage configStorage;\n \n     private SubscriptionGroupManagerV2 subscriptionGroupManagerV2;\n@@ -68,7 +72,9 @@ public void setUp() throws IOException {\n         Mockito.doReturn(1L).when(messageStore).getStateMachineVersion();\n \n         File configStoreDir = tf.newFolder();\n-        configStorage = new ConfigStorage(configStoreDir.getAbsolutePath());\n+        messageStoreConfig = new MessageStoreConfig();\n+        messageStoreConfig.setStorePathRootDir(configStoreDir.getAbsolutePath());\n+        configStorage = new ConfigStorage(messageStoreConfig);\n         configStorage.start();\n         subscriptionGroupManagerV2 = new SubscriptionGroupManagerV2(controller, configStorage);\n     }\n@@ -98,7 +104,10 @@ public void testUpdateSubscriptionGroupConfig() {\n \n         subscriptionGroupManagerV2.getSubscriptionGroupTable().clear();\n         configStorage.shutdown();\n+\n+        configStorage = new ConfigStorage(messageStoreConfig);\n         configStorage.start();\n+        subscriptionGroupManagerV2 = new SubscriptionGroupManagerV2(controller, configStorage);\n         subscriptionGroupManagerV2.load();\n         found = subscriptionGroupManagerV2.findSubscriptionGroupConfig(subscriptionGroupConfig.getGroupName());\n         Assert.assertEquals(subscriptionGroupConfig, found);\n@@ -132,7 +141,11 @@ public void testDeleteSubscriptionGroupConfig() {\n         Assert.assertNull(found);\n \n         configStorage.shutdown();\n+\n+        configStorage = new ConfigStorage(messageStoreConfig);\n         configStorage.start();\n+\n+        subscriptionGroupManagerV2 = new SubscriptionGroupManagerV2(controller, configStorage);\n         subscriptionGroupManagerV2.load();\n         found = subscriptionGroupManagerV2.findSubscriptionGroupConfig(subscriptionGroupConfig.getGroupName());\n         Assert.assertNull(found);\n\ndiff --git a/broker/src/test/java/org/apache/rocketmq/broker/config/v2/TopicConfigManagerV2Test.java b/broker/src/test/java/org/apache/rocketmq/broker/config/v2/TopicConfigManagerV2Test.java\nindex 92c936b110a..731a1f538fb 100644\n--- a/broker/src/test/java/org/apache/rocketmq/broker/config/v2/TopicConfigManagerV2Test.java\n+++ b/broker/src/test/java/org/apache/rocketmq/broker/config/v2/TopicConfigManagerV2Test.java\n@@ -23,6 +23,7 @@\n import org.apache.rocketmq.broker.BrokerController;\n import org.apache.rocketmq.common.BrokerConfig;\n import org.apache.rocketmq.common.TopicConfig;\n+import org.apache.rocketmq.store.MessageStore;\n import org.apache.rocketmq.store.config.MessageStoreConfig;\n import org.junit.After;\n import org.junit.Assert;\n@@ -35,17 +36,19 @@\n import org.mockito.Mockito;\n import org.mockito.junit.MockitoJUnitRunner;\n \n-\n @RunWith(value = MockitoJUnitRunner.class)\n public class TopicConfigManagerV2Test {\n \n-    private ConfigStorage configStorage;\n+    private MessageStoreConfig messageStoreConfig;\n \n-    private TopicConfigManagerV2 topicConfigManagerV2;\n+    private ConfigStorage configStorage;\n \n     @Mock\n     private BrokerController controller;\n \n+    @Mock\n+    private MessageStore messageStore;\n+\n     @Rule\n     public TemporaryFolder tf = new TemporaryFolder();\n \n@@ -61,17 +64,22 @@ public void setUp() throws IOException {\n         BrokerConfig brokerConfig = new BrokerConfig();\n         Mockito.doReturn(brokerConfig).when(controller).getBrokerConfig();\n \n-        MessageStoreConfig messageStoreConfig = new MessageStoreConfig();\n+        messageStoreConfig = new MessageStoreConfig();\n         Mockito.doReturn(messageStoreConfig).when(controller).getMessageStoreConfig();\n+        Mockito.doReturn(messageStore).when(controller).getMessageStore();\n \n         File configStoreDir = tf.newFolder();\n-        configStorage = new ConfigStorage(configStoreDir.getAbsolutePath());\n+        messageStoreConfig.setStorePathRootDir(configStoreDir.getAbsolutePath());\n+\n+        configStorage = new ConfigStorage(messageStoreConfig);\n         configStorage.start();\n-        topicConfigManagerV2 = new TopicConfigManagerV2(controller, configStorage);\n     }\n \n     @Test\n     public void testUpdateTopicConfig() {\n+        TopicConfigManagerV2 topicConfigManagerV2 = new TopicConfigManagerV2(controller, configStorage);\n+        topicConfigManagerV2.load();\n+\n         TopicConfig topicConfig = new TopicConfig();\n         String topicName = \""T1\"";\n         topicConfig.setTopicName(topicName);\n@@ -86,7 +94,9 @@ public void testUpdateTopicConfig() {\n \n         topicConfigManagerV2.getTopicConfigTable().clear();\n \n+        configStorage = new ConfigStorage(messageStoreConfig);\n         Assert.assertTrue(configStorage.start());\n+        topicConfigManagerV2 = new TopicConfigManagerV2(controller, configStorage);\n         Assert.assertTrue(topicConfigManagerV2.load());\n \n         TopicConfig loaded = topicConfigManagerV2.selectTopicConfig(topicName);\n@@ -111,12 +121,15 @@ public void testRemoveTopicConfig() {\n         topicConfig.setWriteQueueNums(4);\n         topicConfig.setOrder(true);\n         topicConfig.setTopicSysFlag(4);\n+        TopicConfigManagerV2 topicConfigManagerV2 = new TopicConfigManagerV2(controller, configStorage);\n         topicConfigManagerV2.updateTopicConfig(topicConfig);\n         topicConfigManagerV2.removeTopicConfig(topicName);\n         Assert.assertFalse(topicConfigManagerV2.containsTopic(topicName));\n         Assert.assertTrue(configStorage.shutdown());\n \n+        configStorage = new ConfigStorage(messageStoreConfig);\n         Assert.assertTrue(configStorage.start());\n+        topicConfigManagerV2 = new TopicConfigManagerV2(controller, configStorage);\n         Assert.assertTrue(topicConfigManagerV2.load());\n         Assert.assertFalse(topicConfigManagerV2.containsTopic(topicName));\n     }\n\ndiff --git a/broker/src/test/java/org/apache/rocketmq/broker/offset/RocksdbTransferOffsetAndCqTest.java b/broker/src/test/java/org/apache/rocketmq/broker/offset/RocksdbTransferOffsetAndCqTest.java\nindex 4b320eb53f3..6a805b04340 100644\n--- a/broker/src/test/java/org/apache/rocketmq/broker/offset/RocksdbTransferOffsetAndCqTest.java\n+++ b/broker/src/test/java/org/apache/rocketmq/broker/offset/RocksdbTransferOffsetAndCqTest.java\n@@ -23,11 +23,11 @@\n import java.util.UUID;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n import org.apache.commons.collections.MapUtils;\n import org.apache.rocketmq.broker.BrokerController;\n import org.apache.rocketmq.broker.config.v1.RocksDBConsumerOffsetManager;\n import org.apache.rocketmq.common.BrokerConfig;\n-import org.apache.rocketmq.common.MixAll;\n import org.apache.rocketmq.common.Pair;\n import org.apache.rocketmq.common.TopicConfig;\n import org.apache.rocketmq.store.DefaultMessageStore;\n@@ -38,6 +38,7 @@\n import org.apache.rocketmq.store.queue.ConsumeQueueStoreInterface;\n import org.apache.rocketmq.store.queue.CqUnit;\n import org.apache.rocketmq.store.stats.BrokerStatsManager;\n+import org.awaitility.Awaitility;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n@@ -135,6 +136,7 @@ public void testRocksdbCqWrite() throws RocksDBException {\n         }\n         RocksDBMessageStore kvStore = defaultMessageStore.getRocksDBMessageStore();\n         ConsumeQueueStoreInterface store = kvStore.getConsumeQueueStore();\n+        store.start();\n         ConsumeQueueInterface rocksdbCq = defaultMessageStore.getRocksDBMessageStore().findConsumeQueue(topic, queueId);\n         ConsumeQueueInterface fileCq = defaultMessageStore.findConsumeQueue(topic, queueId);\n         for (int i = 0; i < 200; i++) {\n@@ -142,13 +144,21 @@ public void testRocksdbCqWrite() throws RocksDBException {\n             fileCq.putMessagePositionInfoWrapper(request);\n             store.putMessagePositionInfoWrapper(request);\n         }\n+        Awaitility.await()\n+            .pollInterval(100, TimeUnit.MILLISECONDS)\n+            .atMost(3, TimeUnit.SECONDS)\n+            .until(() -> rocksdbCq.getMaxOffsetInQueue() == 200);\n         Pair<CqUnit, Long> unit = rocksdbCq.getCqUnitAndStoreTime(100);\n         Pair<CqUnit, Long> unit1 = fileCq.getCqUnitAndStoreTime(100);\n-        Assert.assertTrue(unit.getObject1().getPos() == unit1.getObject1().getPos());\n+        Assert.assertEquals(unit.getObject1().getPos(), unit1.getObject1().getPos());\n     }\n \n+    /**\n+     * No need to skip macOS platform.\n+     * @return true if some platform is NOT a good fit for this test case.\n+     */\n     private boolean notToBeExecuted() {\n-        return MixAll.isMac();\n+        return false;\n     }\n \n }\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
