metadata
"{""instance_id"": ""grpc__grpc-java-12125"", ""pr_id"": 12125, ""issue_id"": 10845, ""repo"": ""grpc/grpc-java"", ""problem_statement"": ""AbstractTransportTest's fakes should be factored out and made available to other tests\n### Is your feature request related to a problem?\r\nMany grpc-java unit tests create their own fake implementations of the various listener interfaces for synchronization. This results in code duplication, and low quality one-off implementations. When a test fails, both the system-under-test and the test itself are suspect.\r\n\r\n### Describe the solution you'd like\r\nHigh quality fake implementations of ServerListener, ServerTransportListener, ServerStreamListener and ClientStreamListener, available for other unit tests to use, and each with their own unit tests. \r\n\r\n### Describe alternatives you've considered\r\nstatus quo?\r\n\r\n### Additional context\r\nhttps://github.com/grpc/grpc-java/pull/10822#discussion_r1458031851\r\n"", ""issue_word_count"": 112, ""test_files_count"": 7, ""non_test_files_count"": 0, ""pr_changed_files"": [""binder/src/test/java/io/grpc/binder/internal/BinderServerTransportTest.java"", ""core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java"", ""core/src/testFixtures/java/io/grpc/internal/ClientStreamListenerBase.java"", ""core/src/testFixtures/java/io/grpc/internal/MockServerListener.java"", ""core/src/testFixtures/java/io/grpc/internal/MockServerTransportListener.java"", ""core/src/testFixtures/java/io/grpc/internal/ServerStreamListenerBase.java"", ""inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java""], ""pr_changed_test_files"": [""binder/src/test/java/io/grpc/binder/internal/BinderServerTransportTest.java"", ""core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java"", ""core/src/testFixtures/java/io/grpc/internal/ClientStreamListenerBase.java"", ""core/src/testFixtures/java/io/grpc/internal/MockServerListener.java"", ""core/src/testFixtures/java/io/grpc/internal/MockServerTransportListener.java"", ""core/src/testFixtures/java/io/grpc/internal/ServerStreamListenerBase.java"", ""inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java""], ""base_commit"": ""6bad6005924d0e665adcd959109f8b7ad45c3a7c"", ""head_commit"": ""f62bc30820105ad717794f3624ede283bbea2722"", ""repo_url"": ""https://github.com/grpc/grpc-java/pull/12125"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/grpc__grpc-java/12125"", ""dockerfile"": """", ""pr_merged_at"": ""2025-06-05T10:09:51.000Z"", ""patch"": """", ""test_patch"": ""diff --git a/binder/src/test/java/io/grpc/binder/internal/BinderServerTransportTest.java b/binder/src/test/java/io/grpc/binder/internal/BinderServerTransportTest.java\nindex d3c13d6c89e..d47106d1d35 100644\n--- a/binder/src/test/java/io/grpc/binder/internal/BinderServerTransportTest.java\n+++ b/binder/src/test/java/io/grpc/binder/internal/BinderServerTransportTest.java\n@@ -16,7 +16,6 @@\n \n package io.grpc.binder.internal;\n \n-import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -29,11 +28,9 @@\n import android.os.Parcel;\n import com.google.common.collect.ImmutableList;\n import io.grpc.Attributes;\n-import io.grpc.Metadata;\n import io.grpc.Status;\n import io.grpc.internal.FixedObjectPool;\n-import io.grpc.internal.ServerStream;\n-import io.grpc.internal.ServerTransportListener;\n+import io.grpc.internal.MockServerTransportListener;\n import java.util.concurrent.ScheduledExecutorService;\n import org.junit.Before;\n import org.junit.Rule;\n@@ -55,7 +52,7 @@ public final class BinderServerTransportTest {\n   @Rule public MockitoRule mocks = MockitoJUnit.rule();\n \n   private final ScheduledExecutorService executorService = new MainThreadScheduledExecutorService();\n-  private final TestTransportListener transportListener = new TestTransportListener();\n+  private MockServerTransportListener transportListener;\n \n   @Mock IBinder mockBinder;\n \n@@ -70,6 +67,7 @@ public void setUp() throws Exception {\n             ImmutableList.of(),\n             OneWayBinderProxy.IDENTITY_DECORATOR,\n             mockBinder);\n+    transportListener = new MockServerTransportListener(transport);\n   }\n \n   @Test\n@@ -82,34 +80,6 @@ public void testSetupTransactionFailureCausesMultipleShutdowns_b153460678() thro\n     transport.shutdownNow(Status.UNKNOWN.withDescription(\""reasons\""));\n     shadowOf(Looper.getMainLooper()).idle();\n \n-    assertThat(transportListener.terminated).isTrue();\n-  }\n-\n-  private static final class TestTransportListener implements ServerTransportListener {\n-\n-    public boolean ready;\n-    public boolean terminated;\n-\n-    /**\n-     * Called when a new stream was created by the remote client.\n-     *\n-     * @param stream the newly created stream.\n-     * @param method the fully qualified method name being called on the server.\n-     * @param headers containing metadata for the call.\n-     */\n-    @Override\n-    public void streamCreated(ServerStream stream, String method, Metadata headers) {}\n-\n-    @Override\n-    public Attributes transportReady(Attributes attributes) {\n-      ready = true;\n-      return attributes;\n-    }\n-\n-    @Override\n-    public void transportTerminated() {\n-      checkState(!terminated, \""Terminated twice\"");\n-      terminated = true;\n-    }\n+    assertThat(transportListener.isTerminated()).isTrue();\n   }\n }\n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java b/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\nindex 1f4c2b41f15..32c3bff74e9 100644\n--- a/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\n+++ b/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\n@@ -58,6 +58,7 @@\n import io.grpc.MethodDescriptor;\n import io.grpc.ServerStreamTracer;\n import io.grpc.Status;\n+import io.grpc.internal.MockServerTransportListener.StreamCreation;\n import io.grpc.internal.testing.TestClientStreamTracer;\n import io.grpc.internal.testing.TestServerStreamTracer;\n import java.io.ByteArrayInputStream;\n@@ -69,10 +70,8 @@\n import java.util.Arrays;\n import java.util.List;\n import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Future;\n-import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n import org.junit.After;\n@@ -296,8 +295,8 @@ public void frameAfterRstStreamShouldNotBreakClientChannel() throws Exception {\n     serverStreamCreation.stream.flush();\n \n     assertEquals(\n-        Status.CANCELLED, clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+        Status.CANCELLED, clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     ClientStreamListener mockClientStreamListener2 = mock(ClientStreamListener.class);\n \n@@ -469,7 +468,7 @@ public void openStreamPreventsTermination() throws Exception {\n     // the stream still functions.\n     serverStream.writeHeaders(new Metadata(), true);\n     clientStream.halfClose();\n-    assertNotNull(clientStreamListener.headers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitHeaders(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertTrue(serverStreamListener.awaitHalfClosed(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     verify(mockClientTransportListener, never()).transportTerminated();\n@@ -511,9 +510,9 @@ public void shutdownNowKillsClientStream() throws Exception {\n     assertTrue(serverTransportListener.waitForTermination(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertTrue(serverTransportListener.isTerminated());\n \n-    assertEquals(status, clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status serverStatus = serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertEquals(status, clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status serverStatus = serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertFalse(serverStatus.isOk());\n     assertTrue(clientStreamTracer1.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertNull(clientStreamTracer1.getInboundTrailers());\n@@ -550,9 +549,9 @@ public void shutdownNowKillsServerStream() throws Exception {\n     assertTrue(serverTransportListener.waitForTermination(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertTrue(serverTransportListener.isTerminated());\n \n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertFalse(clientStreamStatus.isOk());\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertTrue(clientStreamTracer1.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertNull(clientStreamTracer1.getInboundTrailers());\n     assertStatusEquals(clientStreamStatus, clientStreamTracer1.getStatus());\n@@ -562,7 +561,7 @@ public void shutdownNowKillsServerStream() throws Exception {\n     // Generally will be same status provided to shutdownNow, but InProcessTransport can't\n     // differentiate between client and server shutdownNow. The status is not really used on\n     // server-side, so we don't care much.\n-    assertNotNull(serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n   }\n \n   @Test\n@@ -643,8 +642,8 @@ public void newStream_duringShutdown() throws Exception {\n     ClientStreamListenerBase clientStreamListener2 = new ClientStreamListenerBase();\n     stream2.start(clientStreamListener2);\n     Status clientStreamStatus2 =\n-        clientStreamListener2.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-    assertNotNull(clientStreamListener2.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+        clientStreamListener2.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertNotNull(clientStreamListener2.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertCodeEquals(Status.UNAVAILABLE, clientStreamStatus2);\n     assertNull(clientStreamTracer2.getInboundTrailers());\n     assertSame(clientStreamStatus2, clientStreamTracer2.getStatus());\n@@ -658,8 +657,8 @@ public void newStream_duringShutdown() throws Exception {\n     StreamCreation serverStreamCreation\n         = serverTransportListener.takeStreamOrFail(20 * TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     serverStreamCreation.stream.close(Status.OK, new Metadata());\n-    assertCodeEquals(Status.OK, clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertCodeEquals(Status.OK, clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n   }\n \n   @Test\n@@ -679,8 +678,8 @@ public void newStream_afterTermination() throws Exception {\n     ClientStreamListenerBase clientStreamListener = new ClientStreamListenerBase();\n     stream.start(clientStreamListener);\n     assertEquals(\n-        shutdownReason, clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+        shutdownReason, clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     verify(mockClientTransportListener, never()).transportInUse(anyBoolean());\n     assertNull(clientStreamTracer1.getInboundTrailers());\n     assertSame(shutdownReason, clientStreamTracer1.getStatus());\n@@ -788,6 +787,17 @@ public void transportInUse_clientCancel() throws Exception {\n \n   @Test\n   public void basicStream() throws Exception {\n+    serverListener =\n+        new MockServerListener(\n+            transport ->\n+                new MockServerTransportListener(transport) {\n+                  @Override\n+                  public Attributes transportReady(Attributes attributes) {\n+                    return super.transportReady(attributes).toBuilder()\n+                        .set(ADDITIONAL_TRANSPORT_ATTR_KEY, \""additional attribute value\"")\n+                        .build();\n+                  }\n+                });\n     InOrder serverInOrder = inOrder(serverStreamTracerFactory);\n     server.start(serverListener);\n     client = newClientTransport(server);\n@@ -881,7 +891,7 @@ public void basicStream() throws Exception {\n     Metadata serverHeadersCopy = new Metadata();\n     serverHeadersCopy.merge(serverHeaders);\n     serverStream.writeHeaders(serverHeaders, true);\n-    Metadata headers = clientStreamListener.headers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Metadata headers = clientStreamListener.awaitHeaders(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNotNull(headers);\n     assertAsciiMetadataValuesEqual(serverHeadersCopy.getAll(asciiKey), headers.getAll(asciiKey));\n     assertEquals(\n@@ -926,11 +936,11 @@ public void basicStream() throws Exception {\n     serverStream.close(status, trailers);\n     assertNull(serverStreamTracer1.nextInboundEvent());\n     assertNull(serverStreamTracer1.nextOutboundEvent());\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertSame(status, serverStreamTracer1.getStatus());\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     Metadata clientStreamTrailers =\n-        clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertSame(clientStreamTrailers, clientStreamTracer1.getInboundTrailers());\n     assertSame(clientStreamStatus, clientStreamTracer1.getStatus());\n     assertNull(clientStreamTracer1.nextInboundEvent());\n@@ -999,14 +1009,14 @@ public void zeroMessageStream() throws Exception {\n     assertTrue(serverStreamListener.awaitHalfClosed(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     serverStream.writeHeaders(new Metadata(), true);\n-    assertNotNull(clientStreamListener.headers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitHeaders(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     Status status = Status.OK.withDescription(\""Nice talking to you\"");\n     serverStream.close(status, new Metadata());\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     Metadata clientStreamTrailers =\n-        clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNotNull(clientStreamTrailers);\n     assertEquals(status.getCode(), clientStreamStatus.getCode());\n     assertEquals(status.getDescription(), clientStreamStatus.getDescription());\n@@ -1036,15 +1046,15 @@ public void earlyServerClose_withServerHeaders() throws Exception {\n     ServerStreamListenerBase serverStreamListener = serverStreamCreation.listener;\n \n     serverStream.writeHeaders(new Metadata(), true);\n-    assertNotNull(clientStreamListener.headers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitHeaders(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     Status strippedStatus = Status.OK.withDescription(\""Hello. Goodbye.\"");\n     Status status = strippedStatus.withCause(new Exception());\n     serverStream.close(status, new Metadata());\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     Metadata clientStreamTrailers =\n-        clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNotNull(clientStreamTrailers);\n     checkClientStatus(status, clientStreamStatus);\n     assertTrue(clientStreamTracer1.getOutboundHeaders());\n@@ -1080,10 +1090,10 @@ public void earlyServerClose_noServerHeaders() throws Exception {\n     trailers.put(asciiKey, \""dupvalue\"");\n     trailers.put(binaryKey, \""\u00e4binarytrailers\"");\n     serverStream.close(status, trailers);\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     Metadata clientStreamTrailers =\n-        clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     checkClientStatus(status, clientStreamStatus);\n     assertEquals(\n         Lists.newArrayList(trailers.getAll(asciiKey)),\n@@ -1118,10 +1128,10 @@ public void earlyServerClose_serverFailure() throws Exception {\n     Status strippedStatus = Status.INTERNAL.withDescription(\""I'm not listening\"");\n     Status status = strippedStatus.withCause(new Exception());\n     serverStream.close(status, new Metadata());\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     Metadata clientStreamTrailers =\n-        clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNotNull(clientStreamTrailers);\n     checkClientStatus(status, clientStreamStatus);\n     assertTrue(clientStreamTracer1.getOutboundHeaders());\n@@ -1161,10 +1171,10 @@ public void closed(\n     Status strippedStatus = Status.INTERNAL.withDescription(\""I'm not listening\"");\n     Status status = strippedStatus.withCause(new Exception());\n     serverStream.close(status, new Metadata());\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     Metadata clientStreamTrailers =\n-        clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNotNull(clientStreamTrailers);\n     checkClientStatus(status, clientStreamStatus);\n     assertTrue(clientStreamTracer1.getOutboundHeaders());\n@@ -1192,9 +1202,9 @@ public void clientCancel() throws Exception {\n \n     Status status = Status.CANCELLED.withDescription(\""Nevermind\"").withCause(new Exception());\n     clientStream.cancel(status);\n-    assertEquals(status, clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status serverStatus = serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertEquals(status, clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status serverStatus = serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNotEquals(Status.Code.OK, serverStatus.getCode());\n     // Cause should not be transmitted between client and server by default\n     assertNull(serverStatus.getCause());\n@@ -1306,9 +1316,9 @@ public void serverCancel() throws Exception {\n     Status status = Status.DEADLINE_EXCEEDED.withDescription(\""It was bound to happen\"")\n         .withCause(new Exception());\n     serverStream.cancel(status);\n-    assertEquals(status, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertEquals(status, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     // Presently we can't sent much back to the client in this case. Verify that is the current\n     // behavior for consistency between transports.\n     assertCodeEquals(Status.CANCELLED, clientStreamStatus);\n@@ -1452,7 +1462,7 @@ public void flowControlPushBack() throws Exception {\n     serverStream.close(status, new Metadata());\n     doPingPong(serverListener);\n     try {\n-      clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+      clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n       fail(\""Expected TimeoutException\"");\n     } catch (TimeoutException expectedException) {\n     }\n@@ -1460,9 +1470,9 @@ public void flowControlPushBack() throws Exception {\n     clientStream.request(1);\n     clientReceived += verifyMessageCountAndClose(clientStreamListener.messageQueue, 1);\n     assertEquals(serverSent + 6, clientReceived);\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertEquals(status.getCode(), clientStreamStatus.getCode());\n     assertEquals(status.getDescription(), clientStreamStatus.getDescription());\n   }\n@@ -1518,9 +1528,9 @@ public void flowControlDoesNotDeadlockLargeMessage() throws Exception {\n     serverStream.close(status, new Metadata());\n     doPingPong(serverListener);\n     clientStream.request(1);\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertEquals(status.getCode(), clientStreamStatus.getCode());\n     assertEquals(status.getDescription(), clientStreamStatus.getDescription());\n   }\n@@ -1588,8 +1598,8 @@ public void interactionsAfterServerStreamCloseAreNoops() throws Exception {\n     // setup\n     clientStream.request(1);\n     server.stream.close(Status.INTERNAL, new Metadata());\n-    assertNotNull(clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     // Ensure that for a closed ServerStream, interactions are noops\n     server.stream.writeHeaders(new Metadata(), true);\n@@ -1621,7 +1631,7 @@ public void interactionsAfterClientStreamCancelAreNoops() throws Exception {\n     // setup\n     server.stream.request(1);\n     clientStream.cancel(Status.UNKNOWN);\n-    assertNotNull(server.listener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(server.listener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     // Ensure that for a cancelled ClientStream, interactions are noops\n     clientStream.writeMessage(methodDescriptor.streamRequest(\""request\""));\n@@ -1744,9 +1754,8 @@ public void transportTracer_server_streamEnded_ok() throws Exception {\n     clientStream.halfClose();\n     serverStream.close(Status.OK, new Metadata());\n     // do not validate stats until close() has been called on client\n-    assertNotNull(clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-\n+    assertNotNull(clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     TransportStats serverAfter = getTransportStats(serverTransportListener.transport);\n     assertEquals(1, serverAfter.streamsSucceeded);\n@@ -1783,9 +1792,8 @@ public void transportTracer_server_streamEnded_nonOk() throws Exception {\n \n     serverStream.close(Status.UNKNOWN, new Metadata());\n     // do not validate stats until close() has been called on client\n-    assertNotNull(clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-\n+    assertNotNull(clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     TransportStats serverAfter = getTransportStats(serverTransportListener.transport);\n     assertEquals(1, serverAfter.streamsFailed);\n@@ -1823,7 +1831,7 @@ public void transportTracer_client_streamEnded_nonOk() throws Exception {\n \n     clientStream.cancel(Status.UNKNOWN);\n     // do not validate stats until close() has been called on server\n-    assertNotNull(serverStreamCreation.listener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(serverStreamCreation.listener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     TransportStats serverAfter = getTransportStats(serverTransportListener.transport);\n     assertEquals(1, serverAfter.streamsFailed);\n@@ -1980,7 +1988,7 @@ public void serverChecksInboundMetadataSize() throws Exception {\n     // Server shouldn't have created a stream, so nothing to clean up on server-side\n \n     // If this times out, the server probably isn't noticing the metadata size\n-    Status status = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Status status = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     List<Status.Code> codeOptions = Arrays.asList(\n         Status.Code.UNKNOWN, Status.Code.RESOURCE_EXHAUSTED, Status.Code.INTERNAL);\n     if (!codeOptions.contains(status.getCode())) {\n@@ -2021,13 +2029,13 @@ public void clientChecksInboundMetadataSize_header() throws Exception {\n     serverStreamCreation.stream.writeMessage(methodDescriptor.streamResponse(\""response\""));\n     serverStreamCreation.stream.close(Status.OK, new Metadata());\n \n-    Status status = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Status status = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     List<Status.Code> codeOptions = Arrays.asList(\n         Status.Code.UNKNOWN, Status.Code.RESOURCE_EXHAUSTED, Status.Code.INTERNAL);\n     if (!codeOptions.contains(status.getCode())) {\n       fail(\""Status code was not expected: \"" + status);\n     }\n-    assertFalse(clientStreamListener.headers.isDone());\n+    assertFalse(clientStreamListener.hasHeaders());\n   }\n \n   /** This assumes the client limits metadata size to GrpcUtil.DEFAULT_MAX_HEADER_LIST_SIZE. */\n@@ -2066,13 +2074,13 @@ public void clientChecksInboundMetadataSize_trailer() throws Exception {\n     serverStreamCreation.stream.writeMessage(methodDescriptor.streamResponse(\""response\""));\n     serverStreamCreation.stream.close(Status.OK, tooLargeMetadata);\n \n-    Status status = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Status status = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     List<Status.Code> codeOptions = Arrays.asList(\n         Status.Code.UNKNOWN, Status.Code.RESOURCE_EXHAUSTED, Status.Code.INTERNAL);\n     if (!codeOptions.contains(status.getCode())) {\n       fail(\""Status code was not expected: \"" + status);\n     }\n-    Metadata metadata = clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Metadata metadata = clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNull(metadata.get(tellTaleKey));\n   }\n \n@@ -2100,9 +2108,9 @@ methodDescriptor, new Metadata(), callOptions,\n     ServerStreamListenerBase serverStreamListener = serverStreamCreation.listener;\n \n     serverStream.close(Status.OK, new Metadata());\n-    assertNotNull(clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     client.shutdown(Status.UNAVAILABLE);\n   }\n \n@@ -2147,7 +2155,7 @@ private static void checkClientStatus(Status expectedStatus, Status clientStream\n     assertNull(clientStreamStatus.getCause());\n   }\n \n-  private static boolean waitForFuture(Future<?> future, long timeout, TimeUnit unit)\n+  static boolean waitForFuture(Future<?> future, long timeout, TimeUnit unit)\n       throws InterruptedException {\n     try {\n       future.get(timeout, unit);\n@@ -2183,218 +2191,6 @@ public void streamCreated(Attributes transportAttrs, Metadata metadata) {\n     }\n   }\n \n-  public static class MockServerListener implements ServerListener {\n-    public final BlockingQueue<MockServerTransportListener> listeners\n-        = new LinkedBlockingQueue<>();\n-    private final SettableFuture<?> shutdown = SettableFuture.create();\n-\n-    @Override\n-    public ServerTransportListener transportCreated(ServerTransport transport) {\n-      MockServerTransportListener listener = new MockServerTransportListener(transport);\n-      listeners.add(listener);\n-      return listener;\n-    }\n-\n-    @Override\n-    public void serverShutdown() {\n-      assertTrue(shutdown.set(null));\n-    }\n-\n-    public boolean waitForShutdown(long timeout, TimeUnit unit) throws InterruptedException {\n-      return waitForFuture(shutdown, timeout, unit);\n-    }\n-\n-    public MockServerTransportListener takeListenerOrFail(long timeout, TimeUnit unit)\n-        throws InterruptedException {\n-      MockServerTransportListener listener = listeners.poll(timeout, unit);\n-      if (listener == null) {\n-        fail(\""Timed out waiting for server transport\"");\n-      }\n-      return listener;\n-    }\n-  }\n-\n-  public static class MockServerTransportListener implements ServerTransportListener {\n-    public final ServerTransport transport;\n-    public final BlockingQueue<StreamCreation> streams = new LinkedBlockingQueue<>();\n-    private final SettableFuture<?> terminated = SettableFuture.create();\n-\n-    public MockServerTransportListener(ServerTransport transport) {\n-      this.transport = transport;\n-    }\n-\n-    @Override\n-    public void streamCreated(ServerStream stream, String method, Metadata headers) {\n-      ServerStreamListenerBase listener = new ServerStreamListenerBase();\n-      streams.add(new StreamCreation(stream, method, headers, listener));\n-      stream.setListener(listener);\n-    }\n-\n-    @Override\n-    public Attributes transportReady(Attributes attributes) {\n-      assertFalse(terminated.isDone());\n-      return Attributes.newBuilder()\n-          .setAll(attributes)\n-          .set(ADDITIONAL_TRANSPORT_ATTR_KEY, \""additional attribute value\"")\n-          .build();\n-    }\n-\n-    @Override\n-    public void transportTerminated() {\n-      assertTrue(terminated.set(null));\n-    }\n-\n-    public boolean waitForTermination(long timeout, TimeUnit unit) throws InterruptedException {\n-      return waitForFuture(terminated, timeout, unit);\n-    }\n-\n-    public boolean isTerminated() {\n-      return terminated.isDone();\n-    }\n-\n-    public StreamCreation takeStreamOrFail(long timeout, TimeUnit unit)\n-        throws InterruptedException {\n-      StreamCreation stream = streams.poll(timeout, unit);\n-      if (stream == null) {\n-        fail(\""Timed out waiting for server stream\"");\n-      }\n-      return stream;\n-    }\n-  }\n-\n-  public static class ServerStreamListenerBase implements ServerStreamListener {\n-    public final BlockingQueue<InputStream> messageQueue = new LinkedBlockingQueue<>();\n-    // Would have used Void instead of Object, but null elements are not allowed\n-    private final BlockingQueue<Object> readyQueue = new LinkedBlockingQueue<>();\n-    private final CountDownLatch halfClosedLatch = new CountDownLatch(1);\n-    private final SettableFuture<Status> status = SettableFuture.create();\n-\n-    private boolean awaitOnReady(int timeout, TimeUnit unit) throws Exception {\n-      return readyQueue.poll(timeout, unit) != null;\n-    }\n-\n-    private boolean awaitOnReadyAndDrain(int timeout, TimeUnit unit) throws Exception {\n-      if (!awaitOnReady(timeout, unit)) {\n-        return false;\n-      }\n-      // Throw the rest away\n-      readyQueue.drainTo(Lists.newArrayList());\n-      return true;\n-    }\n-\n-    private boolean awaitHalfClosed(int timeout, TimeUnit unit) throws Exception {\n-      return halfClosedLatch.await(timeout, unit);\n-    }\n-\n-    @Override\n-    public void messagesAvailable(MessageProducer producer) {\n-      if (status.isDone()) {\n-        fail(\""messagesAvailable invoked after closed\"");\n-      }\n-      InputStream message;\n-      while ((message = producer.next()) != null) {\n-        messageQueue.add(message);\n-      }\n-    }\n-\n-    @Override\n-    public void onReady() {\n-      if (status.isDone()) {\n-        fail(\""onReady invoked after closed\"");\n-      }\n-      readyQueue.add(new Object());\n-    }\n-\n-    @Override\n-    public void halfClosed() {\n-      if (status.isDone()) {\n-        fail(\""halfClosed invoked after closed\"");\n-      }\n-      halfClosedLatch.countDown();\n-    }\n-\n-    @Override\n-    public void closed(Status status) {\n-      if (this.status.isDone()) {\n-        fail(\""closed invoked more than once\"");\n-      }\n-      this.status.set(status);\n-    }\n-  }\n-\n-  public static class ClientStreamListenerBase implements ClientStreamListener {\n-    public final BlockingQueue<InputStream> messageQueue = new LinkedBlockingQueue<>();\n-    // Would have used Void instead of Object, but null elements are not allowed\n-    private final BlockingQueue<Object> readyQueue = new LinkedBlockingQueue<>();\n-    private final SettableFuture<Metadata> headers = SettableFuture.create();\n-    private final SettableFuture<Metadata> trailers = SettableFuture.create();\n-    private final SettableFuture<Status> status = SettableFuture.create();\n-\n-    private boolean awaitOnReady(int timeout, TimeUnit unit) throws Exception {\n-      return readyQueue.poll(timeout, unit) != null;\n-    }\n-\n-    private boolean awaitOnReadyAndDrain(int timeout, TimeUnit unit) throws Exception {\n-      if (!awaitOnReady(timeout, unit)) {\n-        return false;\n-      }\n-      // Throw the rest away\n-      readyQueue.drainTo(Lists.newArrayList());\n-      return true;\n-    }\n-\n-    @Override\n-    public void messagesAvailable(MessageProducer producer) {\n-      if (status.isDone()) {\n-        fail(\""messagesAvailable invoked after closed\"");\n-      }\n-      InputStream message;\n-      while ((message = producer.next()) != null) {\n-        messageQueue.add(message);\n-      }\n-    }\n-\n-    @Override\n-    public void onReady() {\n-      if (status.isDone()) {\n-        fail(\""onReady invoked after closed\"");\n-      }\n-      readyQueue.add(new Object());\n-    }\n-\n-    @Override\n-    public void headersRead(Metadata headers) {\n-      if (status.isDone()) {\n-        fail(\""headersRead invoked after closed\"");\n-      }\n-      this.headers.set(headers);\n-    }\n-\n-    @Override\n-    public void closed(Status status, RpcProgress rpcProgress, Metadata trailers) {\n-      if (this.status.isDone()) {\n-        fail(\""headersRead invoked after closed\"");\n-      }\n-      this.status.set(status);\n-      this.trailers.set(trailers);\n-    }\n-  }\n-\n-  public static class StreamCreation {\n-    public final ServerStream stream;\n-    public final String method;\n-    public final Metadata headers;\n-    public final ServerStreamListenerBase listener;\n-\n-    public StreamCreation(\n-        ServerStream stream, String method, Metadata headers, ServerStreamListenerBase listener) {\n-      this.stream = stream;\n-      this.method = method;\n-      this.headers = headers;\n-      this.listener = listener;\n-    }\n-  }\n-\n   private static class StringMarshaller implements MethodDescriptor.Marshaller<String> {\n     public static final StringMarshaller INSTANCE = new StringMarshaller();\n \n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/ClientStreamListenerBase.java b/core/src/testFixtures/java/io/grpc/internal/ClientStreamListenerBase.java\nnew file mode 100644\nindex 00000000000..97186400cb2\n--- /dev/null\n+++ b/core/src/testFixtures/java/io/grpc/internal/ClientStreamListenerBase.java\n@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2025 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static org.junit.Assert.fail;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import java.io.InputStream;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class ClientStreamListenerBase implements ClientStreamListener {\n+  public final BlockingQueue<InputStream> messageQueue = new LinkedBlockingQueue<>();\n+  // Would have used Void instead of Object, but null elements are not allowed\n+  private final BlockingQueue<Object> readyQueue = new LinkedBlockingQueue<>();\n+  private final SettableFuture<Metadata> headers = SettableFuture.create();\n+  private final SettableFuture<Metadata> trailers = SettableFuture.create();\n+  private final SettableFuture<Status> status = SettableFuture.create();\n+\n+  /**\n+   * Returns the stream's status or throws {@link java.util.concurrent.TimeoutException} if it isn't\n+   * closed before the timeout.\n+   */\n+  public Status awaitClose(int timeout, TimeUnit unit) throws Exception {\n+    return status.get(timeout, unit);\n+  }\n+\n+  /**\n+   * Returns response headers from the server or throws {@link\n+   * java.util.concurrent.TimeoutException} if they aren't delivered before the timeout.\n+   *\n+   * <p>Callers must not modify the returned object.\n+   */\n+  public Metadata awaitHeaders(int timeout, TimeUnit unit) throws Exception {\n+    return headers.get(timeout, unit);\n+  }\n+\n+  /**\n+   * Returns response trailers from the server or throws {@link\n+   * java.util.concurrent.TimeoutException} if they aren't delivered before the timeout.\n+   *\n+   * <p>Callers must not modify the returned object.\n+   */\n+  public Metadata awaitTrailers(int timeout, TimeUnit unit) throws Exception {\n+    return trailers.get(timeout, unit);\n+  }\n+\n+  public boolean awaitOnReady(int timeout, TimeUnit unit) throws Exception {\n+    return readyQueue.poll(timeout, unit) != null;\n+  }\n+\n+  public boolean awaitOnReadyAndDrain(int timeout, TimeUnit unit) throws Exception {\n+    if (!awaitOnReady(timeout, unit)) {\n+      return false;\n+    }\n+    // Throw the rest away\n+    readyQueue.drainTo(Lists.newArrayList());\n+    return true;\n+  }\n+\n+  @Override\n+  public void messagesAvailable(MessageProducer producer) {\n+    if (status.isDone()) {\n+      fail(\""messagesAvailable invoked after closed\"");\n+    }\n+    InputStream message;\n+    while ((message = producer.next()) != null) {\n+      messageQueue.add(message);\n+    }\n+  }\n+\n+  @Override\n+  public void onReady() {\n+    if (status.isDone()) {\n+      fail(\""onReady invoked after closed\"");\n+    }\n+    readyQueue.add(new Object());\n+  }\n+\n+  @Override\n+  public void headersRead(Metadata headers) {\n+    if (status.isDone()) {\n+      fail(\""headersRead invoked after closed\"");\n+    }\n+    this.headers.set(headers);\n+  }\n+\n+  @Override\n+  public void closed(Status status, RpcProgress rpcProgress, Metadata trailers) {\n+    if (this.status.isDone()) {\n+      fail(\""headersRead invoked after closed\"");\n+    }\n+    this.status.set(status);\n+    this.trailers.set(trailers);\n+  }\n+\n+  /** Returns true iff response headers have been received from the server. */\n+  public boolean hasHeaders() {\n+    return headers.isDone();\n+  }\n+}\n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/MockServerListener.java b/core/src/testFixtures/java/io/grpc/internal/MockServerListener.java\nnew file mode 100644\nindex 00000000000..0c33b98cf1c\n--- /dev/null\n+++ b/core/src/testFixtures/java/io/grpc/internal/MockServerListener.java\n@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2025 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import com.google.common.util.concurrent.SettableFuture;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link ServerListener} that helps you write blocking unit tests.\n+ *\n+ * <p>TODO: Rename, since this is not actually a mock:\n+ * https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html\n+ */\n+public class MockServerListener implements ServerListener {\n+  private final BlockingQueue<MockServerTransportListener> listeners = new LinkedBlockingQueue<>();\n+  private final SettableFuture<?> shutdown = SettableFuture.create();\n+  private final ServerTransportListenerFactory serverTransportListenerFactory;\n+\n+  /**\n+   * Lets you customize the {@link MockServerTransportListener} installed on newly created\n+   * {@link ServerTransport}s.\n+   */\n+  public interface ServerTransportListenerFactory {\n+    MockServerTransportListener create(ServerTransport transport);\n+  }\n+\n+  public MockServerListener(ServerTransportListenerFactory serverTransportListenerFactory) {\n+    this.serverTransportListenerFactory = serverTransportListenerFactory;\n+  }\n+\n+  public MockServerListener() {\n+    this(MockServerTransportListener::new);\n+  }\n+\n+  @Override\n+  public ServerTransportListener transportCreated(ServerTransport transport) {\n+    MockServerTransportListener listener = serverTransportListenerFactory.create(transport);\n+    listeners.add(listener);\n+    return listener;\n+  }\n+\n+  @Override\n+  public void serverShutdown() {\n+    assertTrue(shutdown.set(null));\n+  }\n+\n+  public boolean waitForShutdown(long timeout, TimeUnit unit) throws InterruptedException {\n+    return AbstractTransportTest.waitForFuture(shutdown, timeout, unit);\n+  }\n+\n+  public MockServerTransportListener takeListenerOrFail(long timeout, TimeUnit unit)\n+      throws InterruptedException {\n+    MockServerTransportListener listener = listeners.poll(timeout, unit);\n+    if (listener == null) {\n+      fail(\""Timed out waiting for server transport\"");\n+    }\n+    return listener;\n+  }\n+}\n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/MockServerTransportListener.java b/core/src/testFixtures/java/io/grpc/internal/MockServerTransportListener.java\nnew file mode 100644\nindex 00000000000..e6c4e2f578e\n--- /dev/null\n+++ b/core/src/testFixtures/java/io/grpc/internal/MockServerTransportListener.java\n@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2025 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Attributes;\n+import io.grpc.Metadata;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link ServerTransportListener} that helps you write blocking unit tests.\n+ *\n+ * <p>TODO: Rename, since this is not actually a mock:\n+ * https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html\n+ */\n+public class MockServerTransportListener implements ServerTransportListener {\n+  public final ServerTransport transport;\n+  private final BlockingQueue<StreamCreation> streams = new LinkedBlockingQueue<>();\n+  private final SettableFuture<?> terminated = SettableFuture.create();\n+\n+  public MockServerTransportListener(ServerTransport transport) {\n+    this.transport = transport;\n+  }\n+\n+  @Override\n+  public void streamCreated(ServerStream stream, String method, Metadata headers) {\n+    ServerStreamListenerBase listener = new ServerStreamListenerBase();\n+    streams.add(new StreamCreation(stream, method, headers, listener));\n+    stream.setListener(listener);\n+  }\n+\n+  @Override\n+  public Attributes transportReady(Attributes attributes) {\n+    assertFalse(terminated.isDone());\n+    return attributes;\n+  }\n+\n+  @Override\n+  public void transportTerminated() {\n+    assertTrue(terminated.set(null));\n+  }\n+\n+  public boolean waitForTermination(long timeout, TimeUnit unit) throws InterruptedException {\n+    return AbstractTransportTest.waitForFuture(terminated, timeout, unit);\n+  }\n+\n+  public boolean isTerminated() {\n+    return terminated.isDone();\n+  }\n+\n+  public StreamCreation takeStreamOrFail(long timeout, TimeUnit unit) throws InterruptedException {\n+    StreamCreation stream = streams.poll(timeout, unit);\n+    if (stream == null) {\n+      fail(\""Timed out waiting for server stream\"");\n+    }\n+    return stream;\n+  }\n+\n+  public static class StreamCreation {\n+    public final ServerStream stream;\n+    public final String method;\n+    public final Metadata headers;\n+    public final ServerStreamListenerBase listener;\n+\n+    public StreamCreation(\n+        ServerStream stream, String method, Metadata headers, ServerStreamListenerBase listener) {\n+      this.stream = stream;\n+      this.method = method;\n+      this.headers = headers;\n+      this.listener = listener;\n+    }\n+  }\n+}\n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/ServerStreamListenerBase.java b/core/src/testFixtures/java/io/grpc/internal/ServerStreamListenerBase.java\nnew file mode 100644\nindex 00000000000..b4ded80e5b2\n--- /dev/null\n+++ b/core/src/testFixtures/java/io/grpc/internal/ServerStreamListenerBase.java\n@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2025 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \""License\"");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \""AS IS\"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static org.junit.Assert.fail;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Status;\n+import java.io.InputStream;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link ServerStreamListener} that helps you write blocking unit tests.\n+ */\n+public class ServerStreamListenerBase implements ServerStreamListener {\n+  public final BlockingQueue<InputStream> messageQueue = new LinkedBlockingQueue<>();\n+  // Would have used Void instead of Object, but null elements are not allowed\n+  private final BlockingQueue<Object> readyQueue = new LinkedBlockingQueue<>();\n+  private final CountDownLatch halfClosedLatch = new CountDownLatch(1);\n+  private final SettableFuture<Status> status = SettableFuture.create();\n+\n+  public boolean awaitOnReady(int timeout, TimeUnit unit) throws Exception {\n+    return readyQueue.poll(timeout, unit) != null;\n+  }\n+\n+  public boolean awaitOnReadyAndDrain(int timeout, TimeUnit unit) throws Exception {\n+    if (!awaitOnReady(timeout, unit)) {\n+      return false;\n+    }\n+    // Throw the rest away\n+    readyQueue.drainTo(Lists.newArrayList());\n+    return true;\n+  }\n+\n+  public boolean awaitHalfClosed(int timeout, TimeUnit unit) throws Exception {\n+    return halfClosedLatch.await(timeout, unit);\n+  }\n+\n+  public Status awaitClose(int timeout, TimeUnit unit) throws Exception {\n+    return status.get(timeout, unit);\n+  }\n+\n+  @Override\n+  public void messagesAvailable(MessageProducer producer) {\n+    if (status.isDone()) {\n+      fail(\""messagesAvailable invoked after closed\"");\n+    }\n+    InputStream message;\n+    while ((message = producer.next()) != null) {\n+      messageQueue.add(message);\n+    }\n+  }\n+\n+  @Override\n+  public void onReady() {\n+    if (status.isDone()) {\n+      fail(\""onReady invoked after closed\"");\n+    }\n+    readyQueue.add(new Object());\n+  }\n+\n+  @Override\n+  public void halfClosed() {\n+    if (status.isDone()) {\n+      fail(\""halfClosed invoked after closed\"");\n+    }\n+    halfClosedLatch.countDown();\n+  }\n+\n+  @Override\n+  public void closed(Status status) {\n+    if (this.status.isDone()) {\n+      fail(\""closed invoked more than once\"");\n+    }\n+    this.status.set(status);\n+  }\n+}\n\ndiff --git a/inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java b/inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java\nindex 3ed8dd24ca9..d2220e05114 100644\n--- a/inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java\n+++ b/inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java\n@@ -36,10 +36,14 @@\n import io.grpc.StatusRuntimeException;\n import io.grpc.internal.AbstractTransportTest;\n import io.grpc.internal.ClientStream;\n+import io.grpc.internal.ClientStreamListenerBase;\n import io.grpc.internal.GrpcUtil;\n import io.grpc.internal.InternalServer;\n import io.grpc.internal.ManagedClientTransport;\n+import io.grpc.internal.MockServerTransportListener;\n+import io.grpc.internal.MockServerTransportListener.StreamCreation;\n import io.grpc.internal.ServerStream;\n+import io.grpc.internal.ServerStreamListenerBase;\n import io.grpc.internal.testing.TestStreamTracer;\n import io.grpc.stub.ClientCalls;\n import io.grpc.testing.GrpcCleanupRule;\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
