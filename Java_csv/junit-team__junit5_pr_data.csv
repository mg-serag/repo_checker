metadata
"{""instance_id"": ""junit-team__junit5-4459"", ""pr_id"": 4459, ""issue_id"": 242, ""repo"": ""junit-team/junit5"", ""problem_statement"": ""Introduce error handling mechanism for validation and discovery errors\n## Overview\n\nThe JUnit Platform currently provides no means to report warnings and errors during test discovery. Thus, malformed test cases (for example, Jupiter test methods with a non-void return type) get silently ignored which poses a severe risk for downstream projects: something that looks like a test in a pull request diff might not actually get executed. Therefore, we should introduce a mechanism to collect and report warnings and errors and use it for the Jupiter and Vintage engines. In addition, we should reach out to third-party test engine open source projects and ask them to adopt the new mechanism.\n\nValidation errors (e.g., for invalid `@BeforeEach` method declarations) should not abort the entire discovery phase. Instead the _discovery phase_ should continue, with the error tracked and reported during the _execution phase_. \n\n## Areas of Applicability\n\n- [x] exceptions thrown by test engines, as discussed in #750\n- [x] unresolvable unique IDs, as discussed in #210\n  - note, however, that a TestEngine should not report a unique ID as unresolvable if the unique ID does not apply to the particular TestEngine (see #1026 ).\n- [x] invalid `@BeforeAll`, `@AfterAll`, `@BeforeEach`, and `@AfterEach` method declarations\n- [x] [Competing method-level annotations](https://github.com/marcphilipp/junit5/blob/202d939953a2fa61f54a1b0c70e74e122740a427/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java#L99-L108) (e.g. `@Test` _and_ `@TestTemplate` on the same method)\n- [x] invalid `@Test`, `@TestFactory`, `@RepeatedTest`, and `@ParameterizedTest` method declarations (see #2244)\n- [x] invalid `@Suite` class declarations\n- [x] invalid `@Nested` test class declarations (see #1223 and #2717)\n- [x] non-static test class declaration (see #2311)\n- [x] missing `@Nested` annotation (see #1736)\n- [x] _blank_ display names supplied by the user, as discussed in #743\n- [x] `@Order` annotations on test classes and methods when class/method orderer is not `OrderAnnotation`\n\n## Proposals\n\n1. Allow engines to track errors by creating a special type of `TestDescriptor` such as an `AlwaysFailingTestDescriptor`, `DeadOnArrivalTestDescriptor`, or `ErrorReportingTestDescriptor`.\n    - Tracked errors for such a corresponding `TestDescriptor` could then be thrown as an exception during the execution phase instead of executing the corresponding container or test.\n2. Introduce a new property in `TestDescriptor` that signals an error that was encountered during the _discovery phase_.\n3. Pass a _reporting object_ from the `Launcher` into each `TestEngine` to report errors.\n    - See https://github.com/junit-team/junit5/issues/242#issuecomment-294301875\n\n## Related Issues\n\n- #121 \n- #210 \n- #743 \n- #750 \n- #835\n- #876  \n- #971 \n- #1026 \n- #1074 \n- #1223\n- #1944\n- #2244\n- #2311\n- #2717\n- #4125\n\n## Deliverables\n\n- [x] #4385\n- [x] #4389\n- [x] #4393\n- [x] #4398\n- [x] Revisit the changes made in #971 and determine if it makes sense to move the look-up of lifecycle methods back to the constructor of `ClassTestDescriptor`.\n- [x] #4401\n- [x] #4405\n- [x] #4408\n- [x] #4415\n- [x] #4420\n- [x] Revisit the results of #835 and update the code accordingly by tracking such errors instead of just ignoring such incorrect usage.\n- [x] #4423\n- [x] #949\n- [x] #4429\n- [x] #4448\n- [x] #1736\n- [x] #4453\n- [x] #4456\n- [x] #4458\n- [x] #4459\n- [x] Use the new mechanism to replace the current ad hoc use of logging and transparent defaulting as a work-around.\n  - Search for `TODO [#242]` within the code base.\n  - See https://github.com/junit-team/junit5/issues/750#issuecomment-294296045\n- [x] Determine where else the new mechanism can be used and apply it.\n- [x] #4463\n- [x] #4465\n- [x] Reach out to third-party test engine authors and ask them to adopt the new mechanism\n\t- https://github.com/spockframework/spock/issues/2145\n\t- https://github.com/cucumber/cucumber-jvm/issues/2987"", ""issue_word_count"": 584, ""test_files_count"": 3, ""non_test_files_count"": 3, ""pr_changed_files"": [""junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java"", ""junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java"", ""junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DiscoveryIssueCollector.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java"", ""platform-tests/src/test/java/org/junit/platform/launcher/core/DiscoveryIssueCollectorTests.java""], ""pr_changed_test_files"": [""jupiter-tests/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java"", ""platform-tests/src/test/java/org/junit/platform/launcher/core/DiscoveryIssueCollectorTests.java""], ""base_commit"": ""e0e9bf8443d19fc4678301287bc48afecfce0762"", ""head_commit"": ""0ebd6cd603982782790a46cc1c8d85a34a1107ea"", ""repo_url"": ""https://github.com/junit-team/junit5/pull/4459"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/junit-team__junit5/4459"", ""dockerfile"": """", ""pr_merged_at"": ""2025-04-09T06:51:02.000Z"", ""patch"": ""diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java\nindex 7ef4db7ed9b9..d7714236f56e 100644\n--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java\n+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java\n@@ -29,12 +29,9 @@\n import java.util.function.Predicate;\n \n import org.apiguardian.api.API;\n-import org.junit.platform.commons.logging.Logger;\n-import org.junit.platform.commons.logging.LoggerFactory;\n import org.junit.platform.commons.support.ReflectionSupport;\n import org.junit.platform.commons.util.ClassUtils;\n import org.junit.platform.commons.util.Preconditions;\n-import org.junit.platform.commons.util.StringUtils;\n \n /**\n  * {@code DisplayNameGenerator} defines the SPI for generating display names\n@@ -350,8 +347,6 @@ class IndicativeSentences implements DisplayNameGenerator {\n \n \t\tstatic final DisplayNameGenerator INSTANCE = new IndicativeSentences();\n \n-\t\tprivate static final Logger logger = LoggerFactory.getLogger(IndicativeSentences.class);\n-\n \t\tprivate static final Predicate<Class<?>> notIndicativeSentences = clazz -> clazz != IndicativeSentences.class;\n \n \t\tpublic IndicativeSentences() {\n@@ -502,22 +497,14 @@ private static Optional<IndicativeSentencesGeneration> findIndicativeSentencesGe\n \t\t}\n \n \t\tprivate static String getSentenceFragment(AnnotatedElement element) {\n-\t\t\tOptional<SentenceFragment> annotation = findAnnotation(element, SentenceFragment.class);\n-\t\t\tif (annotation.isPresent()) {\n-\t\t\t\tString sentenceFragment = annotation.get().value().trim();\n-\n-\t\t\t\t// TODO [#242] Replace logging with precondition check once we have a proper mechanism for\n-\t\t\t\t// handling validation exceptions during the TestEngine discovery phase.\n-\t\t\t\tif (StringUtils.isBlank(sentenceFragment)) {\n-\t\t\t\t\tlogger.warn(() -> String.format(\n-\t\t\t\t\t\t\""Configuration error: @SentenceFragment on [%s] must be declared with a non-blank value.\"",\n-\t\t\t\t\t\telement));\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\treturn sentenceFragment;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn null;\n+\t\t\treturn findAnnotation(element, SentenceFragment.class) //\n+\t\t\t\t\t.map(SentenceFragment::value) //\n+\t\t\t\t\t.map(sentenceFragment -> {\n+\t\t\t\t\t\tPreconditions.notBlank(sentenceFragment, String.format(\n+\t\t\t\t\t\t\t\""@SentenceFragment on [%s] must be declared with a non-blank value.\"", element));\n+\t\t\t\t\t\treturn sentenceFragment.trim();\n+\t\t\t\t\t}) //\n+\t\t\t\t\t.orElse(null);\n \t\t}\n \n \t}\n\ndiff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java\nindex 90c81d4d3b9c..287523181921 100644\n--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java\n+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java\n@@ -123,6 +123,9 @@ interface Builder {\n \n \t\t/**\n \t\t * Set the {@link TestSource} for the {@code DiscoveryIssue}.\n+\t\t *\n+\t\t * @param source the {@link TestSource} for the {@code DiscoveryIssue};\n+\t\t * never {@code null} but potentially empty\n \t\t */\n \t\tdefault Builder source(Optional<TestSource> source) {\n \t\t\tsource.ifPresent(this::source);\n@@ -131,11 +134,17 @@ default Builder source(Optional<TestSource> source) {\n \n \t\t/**\n \t\t * Set the {@link TestSource} for the {@code DiscoveryIssue}.\n+\t\t *\n+\t\t * @param source the {@link TestSource} for the {@code DiscoveryIssue};\n+\t\t * may be {@code null}\n \t\t */\n \t\tBuilder source(TestSource source);\n \n \t\t/**\n \t\t * Set the {@link Throwable} that caused the {@code DiscoveryIssue}.\n+\t\t *\n+\t\t * @param cause the {@link Throwable} that caused the\n+\t\t * {@code DiscoveryIssue}; never {@code null} but potentially empty\n \t\t */\n \t\tdefault Builder cause(Optional<Throwable> cause) {\n \t\t\tcause.ifPresent(this::cause);\n@@ -144,6 +153,9 @@ default Builder cause(Optional<Throwable> cause) {\n \n \t\t/**\n \t\t * Set the {@link Throwable} that caused the {@code DiscoveryIssue}.\n+\t\t *\n+\t\t * @param cause the {@link Throwable} that caused the\n+\t\t * {@code DiscoveryIssue}; may be {@code null}\n \t\t */\n \t\tBuilder cause(Throwable cause);\n \n\ndiff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DiscoveryIssueCollector.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DiscoveryIssueCollector.java\nindex a43e14488174..2b19b1e92f81 100644\n--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DiscoveryIssueCollector.java\n+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DiscoveryIssueCollector.java\n@@ -24,8 +24,24 @@\n import org.junit.platform.engine.DiscoveryIssue.Severity;\n import org.junit.platform.engine.DiscoverySelector;\n import org.junit.platform.engine.SelectorResolutionResult;\n+import org.junit.platform.engine.TestSource;\n import org.junit.platform.engine.UniqueId;\n+import org.junit.platform.engine.discovery.ClassSelector;\n+import org.junit.platform.engine.discovery.ClasspathResourceSelector;\n+import org.junit.platform.engine.discovery.DirectorySelector;\n+import org.junit.platform.engine.discovery.FileSelector;\n+import org.junit.platform.engine.discovery.MethodSelector;\n+import org.junit.platform.engine.discovery.PackageSelector;\n import org.junit.platform.engine.discovery.UniqueIdSelector;\n+import org.junit.platform.engine.discovery.UriSelector;\n+import org.junit.platform.engine.support.descriptor.ClassSource;\n+import org.junit.platform.engine.support.descriptor.ClasspathResourceSource;\n+import org.junit.platform.engine.support.descriptor.DirectorySource;\n+import org.junit.platform.engine.support.descriptor.FilePosition;\n+import org.junit.platform.engine.support.descriptor.FileSource;\n+import org.junit.platform.engine.support.descriptor.MethodSource;\n+import org.junit.platform.engine.support.descriptor.PackageSource;\n+import org.junit.platform.engine.support.descriptor.UriSource;\n import org.junit.platform.launcher.LauncherConstants;\n import org.junit.platform.launcher.LauncherDiscoveryListener;\n \n@@ -50,6 +66,7 @@ public void selectorProcessed(UniqueId engineId, DiscoverySelector selector, Sel\n \t\tif (result.getStatus() == FAILED) {\n \t\t\tthis.issues.add(DiscoveryIssue.builder(Severity.ERROR, selector + \"" resolution failed\"") //\n \t\t\t\t\t.cause(result.getThrowable()) //\n+\t\t\t\t\t.source(toSource(selector)) //\n \t\t\t\t\t.build());\n \t\t}\n \t\telse if (result.getStatus() == UNRESOLVED && selector instanceof UniqueIdSelector) {\n@@ -60,6 +77,48 @@ else if (result.getStatus() == UNRESOLVED && selector instanceof UniqueIdSelecto\n \t\t}\n \t}\n \n+\tstatic TestSource toSource(DiscoverySelector selector) {\n+\t\tif (selector instanceof ClassSelector) {\n+\t\t\treturn ClassSource.from(((ClassSelector) selector).getClassName());\n+\t\t}\n+\t\tif (selector instanceof MethodSelector) {\n+\t\t\tMethodSelector methodSelector = (MethodSelector) selector;\n+\t\t\treturn MethodSource.from(methodSelector.getClassName(), methodSelector.getMethodName(),\n+\t\t\t\tmethodSelector.getParameterTypeNames());\n+\t\t}\n+\t\tif (selector instanceof ClasspathResourceSelector) {\n+\t\t\tClasspathResourceSelector resourceSelector = (ClasspathResourceSelector) selector;\n+\t\t\tString resourceName = resourceSelector.getClasspathResourceName();\n+\t\t\treturn resourceSelector.getPosition() //\n+\t\t\t\t\t.map(DiscoveryIssueCollector::convert) //\n+\t\t\t\t\t.map(position -> ClasspathResourceSource.from(resourceName, position)) //\n+\t\t\t\t\t.orElseGet(() -> ClasspathResourceSource.from(resourceName));\n+\t\t}\n+\t\tif (selector instanceof PackageSelector) {\n+\t\t\treturn PackageSource.from(((PackageSelector) selector).getPackageName());\n+\t\t}\n+\t\tif (selector instanceof FileSelector) {\n+\t\t\tFileSelector fileSelector = (FileSelector) selector;\n+\t\t\treturn fileSelector.getPosition() //\n+\t\t\t\t\t.map(DiscoveryIssueCollector::convert) //\n+\t\t\t\t\t.map(position -> FileSource.from(fileSelector.getFile(), position)) //\n+\t\t\t\t\t.orElseGet(() -> FileSource.from(fileSelector.getFile()));\n+\t\t}\n+\t\tif (selector instanceof DirectorySelector) {\n+\t\t\treturn DirectorySource.from(((DirectorySelector) selector).getDirectory());\n+\t\t}\n+\t\tif (selector instanceof UriSelector) {\n+\t\t\treturn UriSource.from(((UriSelector) selector).getUri());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate static FilePosition convert(org.junit.platform.engine.discovery.FilePosition position) {\n+\t\treturn position.getColumn() //\n+\t\t\t\t.map(column -> FilePosition.from(position.getLine(), column)) //\n+\t\t\t\t.orElseGet(() -> FilePosition.from(position.getLine()));\n+\t}\n+\n \t@Override\n \tpublic void issueEncountered(UniqueId engineId, DiscoveryIssue issue) {\n \t\tthis.issues.add(issue);\n"", ""test_patch"": ""diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java\nindex 27578670dab7..323470e59556 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java\n@@ -16,7 +16,7 @@\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;\n-import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;\n+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;\n \n import java.lang.reflect.Method;\n import java.util.EmptyStackException;\n@@ -30,7 +30,8 @@\n import org.junit.jupiter.api.extension.ExtendWith;\n import org.junit.jupiter.api.extension.ExtensionContext;\n import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;\n-import org.junit.platform.engine.TestDescriptor;\n+import org.junit.platform.engine.DiscoveryIssue.Severity;\n+import org.junit.platform.testkit.engine.EngineExecutionResults;\n import org.junit.platform.testkit.engine.Event;\n \n /**\n@@ -189,6 +190,30 @@ void checkDisplayNameGeneratedForIndicativeGeneratorWithCustomSentenceFragments(\n \t\t);\n \t}\n \n+\t@Test\n+\tvoid blankSentenceFragmentOnClassYieldsError() {\n+\t\tvar results = discoverTests(selectClass(BlankSentenceFragmentOnClassTestCase.class));\n+\n+\t\tvar discoveryIssues = results.getDiscoveryIssues();\n+\t\tassertThat(discoveryIssues).hasSize(1);\n+\t\tassertThat(discoveryIssues.getFirst().severity()).isEqualTo(Severity.ERROR);\n+\t\tassertThat(discoveryIssues.getFirst().cause().orElseThrow()) //\n+\t\t\t\t.hasMessage(\""@SentenceFragment on [%s] must be declared with a non-blank value.\"",\n+\t\t\t\t\tBlankSentenceFragmentOnClassTestCase.class);\n+\t}\n+\n+\t@Test\n+\tvoid blankSentenceFragmentOnMethodYieldsError() throws Exception {\n+\t\tvar results = discoverTests(selectMethod(BlankSentenceFragmentOnMethodTestCase.class, \""test\""));\n+\n+\t\tvar discoveryIssues = results.getDiscoveryIssues();\n+\t\tassertThat(discoveryIssues).hasSize(1);\n+\t\tassertThat(discoveryIssues.getFirst().severity()).isEqualTo(Severity.ERROR);\n+\t\tassertThat(discoveryIssues.getFirst().cause().orElseThrow()) //\n+\t\t\t\t.hasMessage(\""@SentenceFragment on [%s] must be declared with a non-blank value.\"",\n+\t\t\t\t\tBlankSentenceFragmentOnMethodTestCase.class.getDeclaredMethod(\""test\""));\n+\t}\n+\n \t@Test\n \tvoid displayNameGenerationInheritance() {\n \t\tcheck(DisplayNameGenerationInheritanceTestCase.InnerNestedTestCase.class, //\n@@ -273,15 +298,17 @@ void indicativeSentencesOnClassTemplate() {\n \t}\n \n \tprivate void check(Class<?> testClass, String... expectedDisplayNames) {\n-\t\tvar request = request().selectors(selectClass(testClass)).build();\n-\t\tvar descriptors = executeTests(request).allEvents().started().stream() //\n-\t\t\t\t.map(Event::getTestDescriptor) //\n-\t\t\t\t.skip(1); // Skip engine descriptor\n-\t\tassertThat(descriptors).map(this::describe).containsExactlyInAnyOrder(expectedDisplayNames);\n+\t\tvar results = executeTestsForClass(testClass);\n+\t\tcheck(results, expectedDisplayNames);\n \t}\n \n-\tprivate String describe(TestDescriptor descriptor) {\n-\t\treturn descriptor.getType() + \"": \"" + descriptor.getDisplayName();\n+\tprivate void check(EngineExecutionResults results, String[] expectedDisplayNames) {\n+\t\tvar descriptors = results.allEvents().started().stream() //\n+\t\t\t\t.map(Event::getTestDescriptor) //\n+\t\t\t\t.skip(1); // Skip engine descriptor\n+\t\tassertThat(descriptors) //\n+\t\t\t\t.map(it -> it.getType() + \"": \"" + it.getDisplayName()) //\n+\t\t\t\t.containsExactlyInAnyOrder(expectedDisplayNames);\n \t}\n \n \t// -------------------------------------------------------------------------\n@@ -622,4 +649,22 @@ public String getDisplayName(int invocationIndex) {\n \t\t}\n \t}\n \n+\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n+\t@IndicativeSentencesGeneration\n+\t@SentenceFragment(\""\"")\n+\tstatic class BlankSentenceFragmentOnClassTestCase {\n+\t\t@Test\n+\t\tvoid test() {\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n+\t@IndicativeSentencesGeneration\n+\tstatic class BlankSentenceFragmentOnMethodTestCase {\n+\t\t@SentenceFragment(\""\\t\"")\n+\t\t@Test\n+\t\tvoid test() {\n+\t\t}\n+\t}\n+\n }\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java\nindex 82c9eab01bb2..35a2e8941a73 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java\n@@ -71,7 +71,7 @@ protected EngineDiscoveryResults discoverTests(Consumer<LauncherDiscoveryRequest\n \t}\n \n \tprotected EngineDiscoveryResults discoverTests(DiscoverySelector... selectors) {\n-\t\treturn discoverTests(defaultRequest().selectors(selectors));\n+\t\treturn discoverTests(request -> request.selectors(selectors));\n \t}\n \n \tprotected EngineDiscoveryResults discoverTests(LauncherDiscoveryRequestBuilder builder) {\n\ndiff --git a/platform-tests/src/test/java/org/junit/platform/launcher/core/DiscoveryIssueCollectorTests.java b/platform-tests/src/test/java/org/junit/platform/launcher/core/DiscoveryIssueCollectorTests.java\nnew file mode 100644\nindex 000000000000..c7c37b385b8f\n--- /dev/null\n+++ b/platform-tests/src/test/java/org/junit/platform/launcher/core/DiscoveryIssueCollectorTests.java\n@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2015-2025 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junit.platform.launcher.core;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;\n+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClasspathResource;\n+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectDirectory;\n+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectFile;\n+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;\n+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectPackage;\n+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectUri;\n+import static org.mockito.Mockito.mock;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.platform.engine.DiscoveryIssue;\n+import org.junit.platform.engine.DiscoveryIssue.Severity;\n+import org.junit.platform.engine.DiscoverySelector;\n+import org.junit.platform.engine.SelectorResolutionResult;\n+import org.junit.platform.engine.TestSource;\n+import org.junit.platform.engine.UniqueId;\n+import org.junit.platform.engine.discovery.FilePosition;\n+import org.junit.platform.engine.support.descriptor.ClassSource;\n+import org.junit.platform.engine.support.descriptor.ClasspathResourceSource;\n+import org.junit.platform.engine.support.descriptor.DirectorySource;\n+import org.junit.platform.engine.support.descriptor.FileSource;\n+import org.junit.platform.engine.support.descriptor.PackageSource;\n+import org.junit.platform.engine.support.descriptor.UriSource;\n+\n+class DiscoveryIssueCollectorTests {\n+\n+\t@ParameterizedTest(name = \""{0}\"")\n+\t@MethodSource(\""pairs\"")\n+\tvoid reportsFailedResolutionResultAsDiscoveryIssue(Pair pair) {\n+\t\tvar collector = new DiscoveryIssueCollector(mock());\n+\t\tvar failure = SelectorResolutionResult.failed(new RuntimeException(\""boom\""));\n+\t\tcollector.selectorProcessed(UniqueId.forEngine(\""dummy\""), pair.selector, failure);\n+\n+\t\tvar expectedIssue = DiscoveryIssue.builder(Severity.ERROR, pair.selector + \"" resolution failed\"") //\n+\t\t\t\t.cause(failure.getThrowable()) //\n+\t\t\t\t.source(pair.source).build();\n+\t\tassertThat(collector.toNotifier().getAllIssues()).containsExactly(expectedIssue);\n+\t}\n+\n+\tpublic static Stream<Pair> pairs() {\n+\t\treturn Stream.of( //\n+\t\t\tnew Pair(selectClass(\""SomeClass\""), ClassSource.from(\""SomeClass\"")), //\n+\t\t\tnew Pair(selectMethod(\""SomeClass#someMethod(int,int)\""),\n+\t\t\t\torg.junit.platform.engine.support.descriptor.MethodSource.from(\""SomeClass\"", \""someMethod\"", \""int,int\"")), //\n+\t\t\tnew Pair(selectClasspathResource(\""someResource\""), ClasspathResourceSource.from(\""someResource\"")), //\n+\t\t\tnew Pair(selectClasspathResource(\""someResource\"", FilePosition.from(42)),\n+\t\t\t\tClasspathResourceSource.from(\""someResource\"",\n+\t\t\t\t\torg.junit.platform.engine.support.descriptor.FilePosition.from(42))), //\n+\t\t\tnew Pair(selectClasspathResource(\""someResource\"", FilePosition.from(42, 23)),\n+\t\t\t\tClasspathResourceSource.from(\""someResource\"",\n+\t\t\t\t\torg.junit.platform.engine.support.descriptor.FilePosition.from(42, 23))), //\n+\t\t\tnew Pair(selectPackage(\""some.package\""), PackageSource.from(\""some.package\"")), //\n+\t\t\tnew Pair(selectFile(\""someFile\""), FileSource.from(new File(\""someFile\""))), //\n+\t\t\tnew Pair(selectFile(\""someFile\"", FilePosition.from(42)),\n+\t\t\t\tFileSource.from(new File(\""someFile\""),\n+\t\t\t\t\torg.junit.platform.engine.support.descriptor.FilePosition.from(42))), //\n+\t\t\tnew Pair(selectFile(\""someFile\"", FilePosition.from(42, 23)),\n+\t\t\t\tFileSource.from(new File(\""someFile\""),\n+\t\t\t\t\torg.junit.platform.engine.support.descriptor.FilePosition.from(42, 23))), //\n+\t\t\tnew Pair(selectDirectory(\""someDir\""), DirectorySource.from(new File(\""someDir\""))), //\n+\t\t\tnew Pair(selectUri(\""some:uri\""), UriSource.from(URI.create(\""some:uri\""))) //\n+\t\t);\n+\t}\n+\n+\trecord Pair(DiscoverySelector selector, TestSource source) {\n+\t}\n+}\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""junit-team__junit5-4448"", ""pr_id"": 4448, ""issue_id"": 242, ""repo"": ""junit-team/junit5"", ""problem_statement"": ""Introduce error handling mechanism for validation and discovery errors\n## Overview\n\nThe JUnit Platform currently provides no means to report warnings and errors during test discovery. Thus, malformed test cases (for example, Jupiter test methods with a non-void return type) get silently ignored which poses a severe risk for downstream projects: something that looks like a test in a pull request diff might not actually get executed. Therefore, we should introduce a mechanism to collect and report warnings and errors and use it for the Jupiter and Vintage engines. In addition, we should reach out to third-party test engine open source projects and ask them to adopt the new mechanism.\n\nValidation errors (e.g., for invalid `@BeforeEach` method declarations) should not abort the entire discovery phase. Instead the _discovery phase_ should continue, with the error tracked and reported during the _execution phase_. \n\n## Areas of Applicability\n\n- [x] exceptions thrown by test engines, as discussed in #750\n- [x] unresolvable unique IDs, as discussed in #210\n  - note, however, that a TestEngine should not report a unique ID as unresolvable if the unique ID does not apply to the particular TestEngine (see #1026 ).\n- [x] invalid `@BeforeAll`, `@AfterAll`, `@BeforeEach`, and `@AfterEach` method declarations\n- [x] [Competing method-level annotations](https://github.com/marcphilipp/junit5/blob/202d939953a2fa61f54a1b0c70e74e122740a427/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java#L99-L108) (e.g. `@Test` _and_ `@TestTemplate` on the same method)\n- [x] invalid `@Test`, `@TestFactory`, `@RepeatedTest`, and `@ParameterizedTest` method declarations (see #2244)\n- [x] invalid `@Suite` class declarations\n- [x] invalid `@Nested` test class declarations (see #1223 and #2717)\n- [x] non-static test class declaration (see #2311)\n- [x] missing `@Nested` annotation (see #1736)\n- [x] _blank_ display names supplied by the user, as discussed in #743\n- [x] `@Order` annotations on test classes and methods when class/method orderer is not `OrderAnnotation`\n\n## Proposals\n\n1. Allow engines to track errors by creating a special type of `TestDescriptor` such as an `AlwaysFailingTestDescriptor`, `DeadOnArrivalTestDescriptor`, or `ErrorReportingTestDescriptor`.\n    - Tracked errors for such a corresponding `TestDescriptor` could then be thrown as an exception during the execution phase instead of executing the corresponding container or test.\n2. Introduce a new property in `TestDescriptor` that signals an error that was encountered during the _discovery phase_.\n3. Pass a _reporting object_ from the `Launcher` into each `TestEngine` to report errors.\n    - See https://github.com/junit-team/junit5/issues/242#issuecomment-294301875\n\n## Related Issues\n\n- #121 \n- #210 \n- #743 \n- #750 \n- #835\n- #876  \n- #971 \n- #1026 \n- #1074 \n- #1223\n- #1944\n- #2244\n- #2311\n- #2717\n- #4125\n\n## Deliverables\n\n- [x] #4385\n- [x] #4389\n- [x] #4393\n- [x] #4398\n- [x] Revisit the changes made in #971 and determine if it makes sense to move the look-up of lifecycle methods back to the constructor of `ClassTestDescriptor`.\n- [x] #4401\n- [x] #4405\n- [x] #4408\n- [x] #4415\n- [x] #4420\n- [x] Revisit the results of #835 and update the code accordingly by tracking such errors instead of just ignoring such incorrect usage.\n- [x] #4423\n- [x] #949\n- [x] #4429\n- [x] #4448\n- [x] #1736\n- [x] #4453\n- [x] #4456\n- [x] #4458\n- [x] #4459\n- [x] Use the new mechanism to replace the current ad hoc use of logging and transparent defaulting as a work-around.\n  - Search for `TODO [#242]` within the code base.\n  - See https://github.com/junit-team/junit5/issues/750#issuecomment-294296045\n- [x] Determine where else the new mechanism can be used and apply it.\n- [x] #4463\n- [x] #4465\n- [x] Reach out to third-party test engine authors and ask them to adopt the new mechanism\n\t- https://github.com/spockframework/spock/issues/2145\n\t- https://github.com/cucumber/cucumber-jvm/issues/2987"", ""issue_word_count"": 584, ""test_files_count"": 16, ""non_test_files_count"": 5, ""pr_changed_files"": [""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsInnerClass.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsNestedTestClass.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsPotentialTestContainer.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTests.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java"", ""junit-jupiter-engine/src/testFixtures/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java"", ""junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/ClassTemplateInvocationTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsInnerClassTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsNestedTestClassTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsPotentialTestContainerTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java"", ""platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java""], ""pr_changed_test_files"": [""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsNestedTestClass.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsPotentialTestContainer.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTests.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java"", ""junit-jupiter-engine/src/testFixtures/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/ClassTemplateInvocationTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsInnerClassTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsNestedTestClassTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsPotentialTestContainerTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java"", ""platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java""], ""base_commit"": ""b514c5b059ab48e28e0ddae9e7b25db363f75e89"", ""head_commit"": ""1c63dc501347b3c48b22a2eaca31d8e713d867ed"", ""repo_url"": ""https://github.com/junit-team/junit5/pull/4448"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/junit-team__junit5/4448"", ""dockerfile"": """", ""pr_merged_at"": ""2025-04-07T08:02:41.000Z"", ""patch"": ""diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java\nindex ba1d9dc264fb..231bf9a035cd 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java\n@@ -15,7 +15,6 @@\n import static java.util.stream.Collectors.toCollection;\n import static java.util.stream.Collectors.toSet;\n import static org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor.getEnclosingTestClasses;\n-import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;\n import static org.junit.platform.commons.support.HierarchyTraversalMode.TOP_DOWN;\n import static org.junit.platform.commons.support.ReflectionSupport.findMethods;\n import static org.junit.platform.commons.support.ReflectionSupport.streamNestedClasses;\n@@ -34,7 +33,6 @@\n import java.util.function.Supplier;\n import java.util.stream.Stream;\n \n-import org.junit.jupiter.api.ClassTemplate;\n import org.junit.jupiter.api.extension.ClassTemplateInvocationContext;\n import org.junit.jupiter.engine.config.JupiterConfiguration;\n import org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor;\n@@ -44,7 +42,7 @@\n import org.junit.jupiter.engine.descriptor.Filterable;\n import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;\n import org.junit.jupiter.engine.descriptor.TestClassAware;\n-import org.junit.jupiter.engine.discovery.predicates.IsTestClassWithTests;\n+import org.junit.jupiter.engine.discovery.predicates.TestClassPredicates;\n import org.junit.platform.commons.support.ReflectionSupport;\n import org.junit.platform.engine.DiscoverySelector;\n import org.junit.platform.engine.TestDescriptor;\n@@ -62,41 +60,45 @@\n  */\n class ClassSelectorResolver implements SelectorResolver {\n \n-\tprivate static final Predicate<Class<?>> isAnnotatedWithClassTemplate = testClass -> isAnnotated(testClass,\n-\t\tClassTemplate.class);\n-\n-\tprivate final IsTestClassWithTests isTestClassWithTests;\n-\n \tprivate final Predicate<String> classNameFilter;\n \tprivate final JupiterConfiguration configuration;\n+\tprivate final TestClassPredicates predicates;\n \n \tClassSelectorResolver(Predicate<String> classNameFilter, JupiterConfiguration configuration,\n \t\t\tDiscoveryIssueReporter issueReporter) {\n \t\tthis.classNameFilter = classNameFilter;\n \t\tthis.configuration = configuration;\n-\t\tthis.isTestClassWithTests = new IsTestClassWithTests(issueReporter);\n+\t\tthis.predicates = new TestClassPredicates(issueReporter);\n \t}\n \n \t@Override\n \tpublic Resolution resolve(ClassSelector selector, Context context) {\n \t\tClass<?> testClass = selector.getJavaClass();\n-\t\tif (this.isTestClassWithTests.test(testClass)) {\n-\t\t\t// Nested tests are never filtered out\n-\t\t\tif (classNameFilter.test(testClass.getName())) {\n+\n+\t\tif (this.predicates.isAnnotatedWithNested.test(testClass)) {\n+\t\t\t// Class name filter is not applied to nested test classes\n+\t\t\tif (this.predicates.isValidNestedTestClass(testClass)) {\n \t\t\t\treturn toResolution(\n-\t\t\t\t\tcontext.addToParent(parent -> Optional.of(newStaticClassTestDescriptor(parent, testClass))));\n+\t\t\t\t\tcontext.addToParent(() -> DiscoverySelectors.selectClass(testClass.getEnclosingClass()),\n+\t\t\t\t\t\tparent -> Optional.of(newMemberClassTestDescriptor(parent, testClass))));\n \t\t\t}\n \t\t}\n-\t\telse if (this.isTestClassWithTests.isNestedTestClass.test(testClass)) {\n-\t\t\treturn toResolution(context.addToParent(() -> DiscoverySelectors.selectClass(testClass.getEnclosingClass()),\n-\t\t\t\tparent -> Optional.of(newMemberClassTestDescriptor(parent, testClass))));\n+\t\telse if (isAcceptedStandaloneTestClass(testClass)) {\n+\t\t\treturn toResolution(\n+\t\t\t\tcontext.addToParent(parent -> Optional.of(newStandaloneClassTestDescriptor(parent, testClass))));\n \t\t}\n \t\treturn unresolved();\n \t}\n \n+\tprivate boolean isAcceptedStandaloneTestClass(Class<?> testClass) {\n+\t\treturn this.classNameFilter.test(testClass.getName()) //\n+\t\t\t\t&& this.predicates.looksLikeIntendedTestClass(testClass) //\n+\t\t\t\t&& this.predicates.isValidStandaloneTestClass(testClass);\n+\t}\n+\n \t@Override\n \tpublic Resolution resolve(NestedClassSelector selector, Context context) {\n-\t\tif (this.isTestClassWithTests.isNestedTestClass.test(selector.getNestedClass())) {\n+\t\tif (this.predicates.isAnnotatedWithNestedAndValid.test(selector.getNestedClass())) {\n \t\t\treturn toResolution(context.addToParent(() -> selectClass(selector.getEnclosingClasses()),\n \t\t\t\tparent -> Optional.of(newMemberClassTestDescriptor(parent, selector.getNestedClass()))));\n \t\t}\n@@ -108,17 +110,17 @@ public Resolution resolve(UniqueIdSelector selector, Context context) {\n \t\tUniqueId uniqueId = selector.getUniqueId();\n \t\tUniqueId.Segment lastSegment = uniqueId.getLastSegment();\n \t\tif (ClassTestDescriptor.SEGMENT_TYPE.equals(lastSegment.getType())) {\n-\t\t\treturn resolveStaticClassUniqueId(context, lastSegment, __ -> true, this::newClassTestDescriptor);\n+\t\t\treturn resolveStandaloneClassUniqueId(context, lastSegment, __ -> true, this::newClassTestDescriptor);\n \t\t}\n-\t\tif (ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE.equals(lastSegment.getType())) {\n-\t\t\treturn resolveStaticClassUniqueId(context, lastSegment, isAnnotatedWithClassTemplate,\n-\t\t\t\tthis::newStaticClassTemplateTestDescriptor);\n+\t\tif (ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE.equals(lastSegment.getType())) {\n+\t\t\treturn resolveStandaloneClassUniqueId(context, lastSegment, this.predicates.isAnnotatedWithClassTemplate,\n+\t\t\t\tthis::newClassTemplateTestDescriptor);\n \t\t}\n \t\tif (NestedClassTestDescriptor.SEGMENT_TYPE.equals(lastSegment.getType())) {\n \t\t\treturn resolveNestedClassUniqueId(context, uniqueId, __ -> true, this::newNestedClassTestDescriptor);\n \t\t}\n \t\tif (ClassTemplateTestDescriptor.NESTED_CLASS_SEGMENT_TYPE.equals(lastSegment.getType())) {\n-\t\t\treturn resolveNestedClassUniqueId(context, uniqueId, isAnnotatedWithClassTemplate,\n+\t\t\treturn resolveNestedClassUniqueId(context, uniqueId, this.predicates.isAnnotatedWithClassTemplate,\n \t\t\t\tthis::newNestedClassTemplateTestDescriptor);\n \t\t}\n \t\tif (ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE.equals(lastSegment.getType())) {\n@@ -138,11 +140,11 @@ public Resolution resolve(UniqueIdSelector selector, Context context) {\n \tpublic Resolution resolve(IterationSelector selector, Context context) {\n \t\tDiscoverySelector parentSelector = selector.getParentSelector();\n \t\tif (parentSelector instanceof ClassSelector\n-\t\t\t\t&& isAnnotatedWithClassTemplate.test(((ClassSelector) parentSelector).getJavaClass())) {\n+\t\t\t\t&& this.predicates.isAnnotatedWithClassTemplate.test(((ClassSelector) parentSelector).getJavaClass())) {\n \t\t\treturn resolveIterations(selector, context);\n \t\t}\n-\t\tif (parentSelector instanceof NestedClassSelector\n-\t\t\t\t&& isAnnotatedWithClassTemplate.test(((NestedClassSelector) parentSelector).getNestedClass())) {\n+\t\tif (parentSelector instanceof NestedClassSelector && this.predicates.isAnnotatedWithClassTemplate.test(\n+\t\t\t((NestedClassSelector) parentSelector).getNestedClass())) {\n \t\t\treturn resolveIterations(selector, context);\n \t\t}\n \t\treturn unresolved();\n@@ -160,13 +162,13 @@ private Resolution resolveIterations(IterationSelector selector, Context context\n \t\treturn matches.isEmpty() ? unresolved() : Resolution.matches(matches);\n \t}\n \n-\tprivate Resolution resolveStaticClassUniqueId(Context context, UniqueId.Segment lastSegment,\n+\tprivate Resolution resolveStandaloneClassUniqueId(Context context, UniqueId.Segment lastSegment,\n \t\t\tPredicate<? super Class<?>> condition,\n \t\t\tBiFunction<TestDescriptor, Class<?>, ClassBasedTestDescriptor> factory) {\n \n \t\tString className = lastSegment.getValue();\n \t\treturn ReflectionSupport.tryToLoadClass(className).toOptional() //\n-\t\t\t\t.filter(this.isTestClassWithTests) //\n+\t\t\t\t.filter(this.predicates::isValidStandaloneTestClass) //\n \t\t\t\t.filter(condition) //\n \t\t\t\t.map(testClass -> toResolution(\n \t\t\t\t\tcontext.addToParent(parent -> Optional.of(factory.apply(parent, testClass))))) //\n@@ -180,8 +182,9 @@ private Resolution resolveNestedClassUniqueId(Context context, UniqueId uniqueId\n \t\tString simpleClassName = uniqueId.getLastSegment().getValue();\n \t\treturn toResolution(context.addToParent(() -> selectUniqueId(uniqueId.removeLastSegment()), parent -> {\n \t\t\tClass<?> parentTestClass = ((TestClassAware) parent).getTestClass();\n-\t\t\treturn ReflectionSupport.findNestedClasses(parentTestClass, this.isTestClassWithTests.isNestedTestClass.and(\n-\t\t\t\twhere(Class::getSimpleName, isEqual(simpleClassName)))).stream() //\n+\t\t\treturn ReflectionSupport.findNestedClasses(parentTestClass,\n+\t\t\t\tthis.predicates.isAnnotatedWithNestedAndValid.and(\n+\t\t\t\t\twhere(Class::getSimpleName, isEqual(simpleClassName)))).stream() //\n \t\t\t\t\t.findFirst() //\n \t\t\t\t\t.filter(condition) //\n \t\t\t\t\t.map(testClass -> factory.apply(parent, testClass));\n@@ -196,15 +199,14 @@ private ClassTemplateInvocationTestDescriptor newDummyClassTemplateInvocationTes\n \t\t\tDummyClassTemplateInvocationContext.INSTANCE, index, parent.getSource().orElse(null), configuration);\n \t}\n \n-\tprivate ClassBasedTestDescriptor newStaticClassTestDescriptor(TestDescriptor parent, Class<?> testClass) {\n-\t\treturn isAnnotatedWithClassTemplate.test(testClass) //\n-\t\t\t\t? newStaticClassTemplateTestDescriptor(parent, testClass) //\n+\tprivate ClassBasedTestDescriptor newStandaloneClassTestDescriptor(TestDescriptor parent, Class<?> testClass) {\n+\t\treturn this.predicates.isAnnotatedWithClassTemplate.test(testClass) //\n+\t\t\t\t? newClassTemplateTestDescriptor(parent, testClass) //\n \t\t\t\t: newClassTestDescriptor(parent, testClass);\n \t}\n \n-\tprivate ClassTemplateTestDescriptor newStaticClassTemplateTestDescriptor(TestDescriptor parent,\n-\t\t\tClass<?> testClass) {\n-\t\treturn newClassTemplateTestDescriptor(parent, ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\tprivate ClassTemplateTestDescriptor newClassTemplateTestDescriptor(TestDescriptor parent, Class<?> testClass) {\n+\t\treturn newClassTemplateTestDescriptor(parent, ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tnewClassTestDescriptor(parent, testClass));\n \t}\n \n@@ -215,7 +217,7 @@ private ClassTestDescriptor newClassTestDescriptor(TestDescriptor parent, Class<\n \t}\n \n \tprivate ClassBasedTestDescriptor newMemberClassTestDescriptor(TestDescriptor parent, Class<?> testClass) {\n-\t\treturn isAnnotatedWithClassTemplate.test(testClass) //\n+\t\treturn this.predicates.isAnnotatedWithClassTemplate.test(testClass) //\n \t\t\t\t? newNestedClassTemplateTestDescriptor(parent, testClass) //\n \t\t\t\t: newNestedClassTestDescriptor(parent, testClass);\n \t}\n@@ -273,11 +275,11 @@ private Supplier<Set<? extends DiscoverySelector>> expansionCallback(TestDescrip\n \t\t\tList<Class<?>> testClasses = testClassesSupplier.get();\n \t\t\tClass<?> testClass = testClasses.get(testClasses.size() - 1);\n \t\t\tStream<DiscoverySelector> methods = findMethods(testClass,\n-\t\t\t\tthis.isTestClassWithTests.isTestOrTestFactoryOrTestTemplateMethod, TOP_DOWN).stream().map(\n-\t\t\t\t\tmethod -> selectMethod(testClasses, method));\n+\t\t\t\tthis.predicates.isTestOrTestFactoryOrTestTemplateMethod, TOP_DOWN).stream() //\n+\t\t\t\t\t\t.map(method -> selectMethod(testClasses, method));\n \t\t\tStream<NestedClassSelector> nestedClasses = streamNestedClasses(testClass,\n-\t\t\t\tthis.isTestClassWithTests.isNestedTestClass).map(\n-\t\t\t\t\tnestedClass -> DiscoverySelectors.selectNestedClass(testClasses, nestedClass));\n+\t\t\t\tthis.predicates.isAnnotatedWithNestedAndValid) //\n+\t\t\t\t\t\t.map(nestedClass -> DiscoverySelectors.selectNestedClass(testClasses, nestedClass));\n \t\t\treturn Stream.concat(methods, nestedClasses).collect(\n \t\t\t\ttoCollection((Supplier<Set<DiscoverySelector>>) LinkedHashSet::new));\n \t\t};\n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java\nindex b8ade50c6766..4b25b3d43f49 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java\n@@ -16,7 +16,7 @@\n import org.junit.jupiter.engine.config.JupiterConfiguration;\n import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;\n import org.junit.jupiter.engine.descriptor.Validatable;\n-import org.junit.jupiter.engine.discovery.predicates.IsTestClassWithTests;\n+import org.junit.jupiter.engine.discovery.predicates.TestClassPredicates;\n import org.junit.platform.engine.EngineDiscoveryRequest;\n import org.junit.platform.engine.TestDescriptor;\n import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n@@ -38,7 +38,8 @@\n public class DiscoverySelectorResolver {\n \n \tprivate static final EngineDiscoveryRequestResolver<JupiterEngineDescriptor> resolver = EngineDiscoveryRequestResolver.<JupiterEngineDescriptor> builder() //\n-\t\t\t.addClassContainerSelectorResolverWithContext(ctx -> new IsTestClassWithTests(ctx.getIssueReporter())) //\n+\t\t\t.addClassContainerSelectorResolverWithContext(\n+\t\t\t\tctx -> new TestClassPredicates(ctx.getIssueReporter()).looksLikeNestedOrStandaloneTestClass) //\n \t\t\t.addSelectorResolver(ctx -> new ClassSelectorResolver(ctx.getClassNameFilter(), getConfiguration(ctx),\n \t\t\t\tctx.getIssueReporter())) //\n \t\t\t.addSelectorResolver(ctx -> new MethodSelectorResolver(getConfiguration(ctx), ctx.getIssueReporter())) //\n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java\nindex 88db046ee24c..09b021766f72 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java\n@@ -36,10 +36,10 @@\n import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;\n import org.junit.jupiter.engine.descriptor.TestTemplateInvocationTestDescriptor;\n import org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor;\n-import org.junit.jupiter.engine.discovery.predicates.IsTestClassWithTests;\n import org.junit.jupiter.engine.discovery.predicates.IsTestFactoryMethod;\n import org.junit.jupiter.engine.discovery.predicates.IsTestMethod;\n import org.junit.jupiter.engine.discovery.predicates.IsTestTemplateMethod;\n+import org.junit.jupiter.engine.discovery.predicates.TestClassPredicates;\n import org.junit.platform.commons.util.ClassUtils;\n import org.junit.platform.engine.DiscoveryIssue;\n import org.junit.platform.engine.DiscoveryIssue.Severity;\n@@ -71,8 +71,7 @@ class MethodSelectorResolver implements SelectorResolver {\n \t\tthis.configuration = configuration;\n \t\tthis.issueReporter = issueReporter;\n \t\tthis.methodTypes = MethodType.allPossibilities(issueReporter);\n-\t\tIsTestClassWithTests classPredicate = new IsTestClassWithTests(issueReporter);\n-\t\tthis.testClassPredicate = classPredicate.or(classPredicate.isNestedTestClass);\n+\t\tthis.testClassPredicate = new TestClassPredicates(issueReporter).looksLikeNestedOrStandaloneTestClass;\n \t}\n \n \t@Override\n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsInnerClass.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsInnerClass.java\ndeleted file mode 100644\nindex 1e30582d48ca..000000000000\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsInnerClass.java\n+++ /dev/null\n@@ -1,42 +0,0 @@\n-/*\n- * Copyright 2015-2025 the original author or authors.\n- *\n- * All rights reserved. This program and the accompanying materials are\n- * made available under the terms of the Eclipse Public License v2.0 which\n- * accompanies this distribution and is available at\n- *\n- * https://www.eclipse.org/legal/epl-v20.html\n- */\n-\n-package org.junit.jupiter.engine.discovery.predicates;\n-\n-import static org.apiguardian.api.API.Status.INTERNAL;\n-import static org.junit.platform.commons.support.ModifierSupport.isPrivate;\n-import static org.junit.platform.commons.util.ReflectionUtils.isInnerClass;\n-\n-import java.util.function.Predicate;\n-\n-import org.apiguardian.api.API;\n-\n-/**\n- * Test if a class is a non-private inner class (i.e., a non-static nested class).\n- *\n- * @since 5.0\n- */\n-@API(status = INTERNAL, since = \""5.0\"")\n-public class IsInnerClass implements Predicate<Class<?>> {\n-\n-\t@Override\n-\tpublic boolean test(Class<?> candidate) {\n-\t\t// Do not collapse into a single return statement.\n-\t\tif (isPrivate(candidate)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!isInnerClass(candidate)) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\treturn true;\n-\t}\n-\n-}\n\ndiff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java\nindex c774b0a39c59..4d259e52b875 100644\n--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java\n+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java\n@@ -1236,10 +1236,35 @@ public static List<Class<?>> findNestedClasses(Class<?> clazz, Predicate<Class<?\n \t\tPreconditions.notNull(predicate, \""Predicate must not be null\"");\n \n \t\tSet<Class<?>> candidates = new LinkedHashSet<>();\n-\t\tfindNestedClasses(clazz, predicate, candidates);\n+\t\tvisitNestedClasses(clazz, predicate, nestedClass -> {\n+\t\t\tcandidates.add(nestedClass);\n+\t\t\treturn true;\n+\t\t});\n \t\treturn Collections.unmodifiableList(new ArrayList<>(candidates));\n \t}\n \n+\t/**\n+\t * Determine if a nested class within the supplied class, or inherited by the\n+\t * supplied class, that conforms to the supplied predicate is present.\n+\t *\n+\t * <p>This method does <strong>not</strong> search for nested classes\n+\t * recursively.\n+\t *\n+\t * @param clazz the class to be searched; never {@code null}\n+\t * @param predicate the predicate against which the list of nested classes is\n+\t * checked; never {@code null}\n+\t * @return {@code true} if such a nested class is present\n+\t * @throws JUnitException if a cycle is detected within an inner class hierarchy\n+\t */\n+\t@API(status = INTERNAL, since = \""1.13\"")\n+\tpublic static boolean isNestedClassPresent(Class<?> clazz, Predicate<Class<?>> predicate) {\n+\t\tPreconditions.notNull(clazz, \""Class must not be null\"");\n+\t\tPreconditions.notNull(predicate, \""Predicate must not be null\"");\n+\n+\t\tboolean visitorWasNotCalled = visitNestedClasses(clazz, predicate, __ -> false);\n+\t\treturn !visitorWasNotCalled;\n+\t}\n+\n \t/**\n \t * since 1.10\n \t * @see org.junit.platform.commons.support.ReflectionSupport#streamNestedClasses(Class, Predicate)\n@@ -1248,9 +1273,10 @@ public static Stream<Class<?>> streamNestedClasses(Class<?> clazz, Predicate<Cla\n \t\treturn findNestedClasses(clazz, predicate).stream();\n \t}\n \n-\tprivate static void findNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate, Set<Class<?>> candidates) {\n+\tprivate static boolean visitNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate,\n+\t\t\tVisitor<Class<?>> visitor) {\n \t\tif (!isSearchable(clazz)) {\n-\t\t\treturn;\n+\t\t\treturn true;\n \t\t}\n \n \t\tif (isInnerClass(clazz) && predicate.test(clazz)) {\n@@ -1262,7 +1288,10 @@ private static void findNestedClasses(Class<?> clazz, Predicate<Class<?>> predic\n \t\t\tfor (Class<?> nestedClass : clazz.getDeclaredClasses()) {\n \t\t\t\tif (predicate.test(nestedClass)) {\n \t\t\t\t\tdetectInnerClassCycle(nestedClass);\n-\t\t\t\t\tcandidates.add(nestedClass);\n+\t\t\t\t\tboolean shouldContinue = visitor.accept(nestedClass);\n+\t\t\t\t\tif (!shouldContinue) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -1271,12 +1300,20 @@ private static void findNestedClasses(Class<?> clazz, Predicate<Class<?>> predic\n \t\t}\n \n \t\t// Search class hierarchy\n-\t\tfindNestedClasses(clazz.getSuperclass(), predicate, candidates);\n+\t\tboolean shouldContinue = visitNestedClasses(clazz.getSuperclass(), predicate, visitor);\n+\t\tif (!shouldContinue) {\n+\t\t\treturn false;\n+\t\t}\n \n \t\t// Search interface hierarchy\n \t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n-\t\t\tfindNestedClasses(ifc, predicate, candidates);\n+\t\t\tshouldContinue = visitNestedClasses(ifc, predicate, visitor);\n+\t\t\tif (!shouldContinue) {\n+\t\t\t\treturn false;\n+\t\t\t}\n \t\t}\n+\n+\t\treturn true;\n \t}\n \n \t/**\n@@ -2073,4 +2110,14 @@ private static boolean getLegacySearchSemanticsFlag() {\n \t\treturn isTrue;\n \t}\n \n+\tprivate interface Visitor<T> {\n+\n+\t\t/**\n+\t\t * @return {@code true} if the visitor should continue searching;\n+\t\t * {@code false} if the visitor should stop\n+\t\t */\n+\t\tboolean accept(T value);\n+\n+\t}\n+\n }\n"", ""test_patch"": ""diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java\nindex b3be1dfa5df1..77b540c6e2bb 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java\n@@ -51,7 +51,7 @@\n @API(status = INTERNAL, since = \""5.13\"")\n public class ClassTemplateTestDescriptor extends ClassBasedTestDescriptor implements Filterable {\n \n-\tpublic static final String STATIC_CLASS_SEGMENT_TYPE = \""class-template\"";\n+\tpublic static final String STANDALONE_CLASS_SEGMENT_TYPE = \""class-template\"";\n \tpublic static final String NESTED_CLASS_SEGMENT_TYPE = \""nested-class-template\"";\n \n \tprivate final Map<Integer, Collection<? extends TestDescriptor>> childrenPrototypesByIndex = new HashMap<>();\n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsNestedTestClass.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsNestedTestClass.java\ndeleted file mode 100644\nindex f1fc79a0226b..000000000000\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsNestedTestClass.java\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-/*\n- * Copyright 2015-2025 the original author or authors.\n- *\n- * All rights reserved. This program and the accompanying materials are\n- * made available under the terms of the Eclipse Public License v2.0 which\n- * accompanies this distribution and is available at\n- *\n- * https://www.eclipse.org/legal/epl-v20.html\n- */\n-\n-package org.junit.jupiter.engine.discovery.predicates;\n-\n-import static org.apiguardian.api.API.Status.INTERNAL;\n-import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;\n-\n-import java.util.function.Predicate;\n-\n-import org.apiguardian.api.API;\n-import org.junit.jupiter.api.Nested;\n-\n-/**\n- * Test if a class is a JUnit Jupiter {@link Nested @Nested} test class.\n- *\n- * @since 5.0\n- */\n-@API(status = INTERNAL, since = \""5.0\"")\n-public class IsNestedTestClass implements Predicate<Class<?>> {\n-\n-\tprivate static final IsInnerClass isInnerClass = new IsInnerClass();\n-\n-\tIsNestedTestClass() {\n-\t}\n-\n-\t@Override\n-\tpublic boolean test(Class<?> candidate) {\n-\t\t//please do not collapse into single return\n-\t\tif (!isInnerClass.test(candidate)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn isAnnotated(candidate, Nested.class);\n-\t}\n-\n-}\n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsPotentialTestContainer.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsPotentialTestContainer.java\ndeleted file mode 100644\nindex 0534cd2481c0..000000000000\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsPotentialTestContainer.java\n+++ /dev/null\n@@ -1,49 +0,0 @@\n-/*\n- * Copyright 2015-2025 the original author or authors.\n- *\n- * All rights reserved. This program and the accompanying materials are\n- * made available under the terms of the Eclipse Public License v2.0 which\n- * accompanies this distribution and is available at\n- *\n- * https://www.eclipse.org/legal/epl-v20.html\n- */\n-\n-package org.junit.jupiter.engine.discovery.predicates;\n-\n-import static org.apiguardian.api.API.Status.INTERNAL;\n-import static org.junit.platform.commons.support.ModifierSupport.isAbstract;\n-import static org.junit.platform.commons.support.ModifierSupport.isPrivate;\n-import static org.junit.platform.commons.util.ReflectionUtils.isInnerClass;\n-\n-import java.util.function.Predicate;\n-\n-import org.apiguardian.api.API;\n-\n-/**\n- * Test if a class is a potential top-level JUnit Jupiter test container, even if\n- * it does not contain tests.\n- *\n- * @since 5.0\n- */\n-@API(status = INTERNAL, since = \""5.0\"")\n-public class IsPotentialTestContainer implements Predicate<Class<?>> {\n-\n-\t@Override\n-\tpublic boolean test(Class<?> candidate) {\n-\t\t// Please do not collapse the following into a single statement.\n-\t\tif (isPrivate(candidate)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (isAbstract(candidate)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (candidate.isLocalClass()) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (candidate.isAnonymousClass()) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn !isInnerClass(candidate);\n-\t}\n-\n-}\n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTests.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTests.java\ndeleted file mode 100644\nindex 2b8f85b49e24..000000000000\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTests.java\n+++ /dev/null\n@@ -1,59 +0,0 @@\n-/*\n- * Copyright 2015-2025 the original author or authors.\n- *\n- * All rights reserved. This program and the accompanying materials are\n- * made available under the terms of the Eclipse Public License v2.0 which\n- * accompanies this distribution and is available at\n- *\n- * https://www.eclipse.org/legal/epl-v20.html\n- */\n-\n-package org.junit.jupiter.engine.discovery.predicates;\n-\n-import static org.apiguardian.api.API.Status.INTERNAL;\n-\n-import java.lang.reflect.Method;\n-import java.util.function.Predicate;\n-\n-import org.apiguardian.api.API;\n-import org.junit.platform.commons.support.ReflectionSupport;\n-import org.junit.platform.commons.util.ReflectionUtils;\n-import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n-\n-/**\n- * Test if a class is a JUnit Jupiter test class containing executable tests,\n- * test factories, test templates, or nested tests.\n- *\n- * @since 5.0\n- */\n-@API(status = INTERNAL, since = \""5.1\"")\n-public class IsTestClassWithTests implements Predicate<Class<?>> {\n-\n-\tpublic final Predicate<Method> isTestOrTestFactoryOrTestTemplateMethod;\n-\n-\tprivate static final IsPotentialTestContainer isPotentialTestContainer = new IsPotentialTestContainer();\n-\n-\tpublic final IsNestedTestClass isNestedTestClass = new IsNestedTestClass();\n-\n-\t@API(status = INTERNAL, since = \""5.13\"")\n-\tpublic IsTestClassWithTests(DiscoveryIssueReporter issueReporter) {\n-\t\tthis.isTestOrTestFactoryOrTestTemplateMethod = new IsTestMethod(issueReporter) //\n-\t\t\t\t.or(new IsTestFactoryMethod(issueReporter)) //\n-\t\t\t\t.or(new IsTestTemplateMethod(issueReporter));\n-\t}\n-\n-\t@Override\n-\tpublic boolean test(Class<?> candidate) {\n-\t\treturn isPotentialTestContainer.test(candidate)\n-\t\t\t\t&& (hasTestOrTestFactoryOrTestTemplateMethods(candidate) || hasNestedTests(candidate));\n-\t}\n-\n-\tprivate boolean hasTestOrTestFactoryOrTestTemplateMethods(Class<?> candidate) {\n-\t\treturn ReflectionUtils.isMethodPresent(candidate, isTestOrTestFactoryOrTestTemplateMethod);\n-\t}\n-\n-\tprivate boolean hasNestedTests(Class<?> candidate) {\n-\t\treturn !ReflectionSupport.findNestedClasses(candidate, isNestedTestClass).isEmpty();\n-\t}\n-\n-}\n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java\nnew file mode 100644\nindex 000000000000..30afdd83477a\n--- /dev/null\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java\n@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2015-2025 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junit.jupiter.engine.discovery.predicates;\n+\n+import static org.apiguardian.api.API.Status.INTERNAL;\n+import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;\n+import static org.junit.platform.commons.support.ModifierSupport.isAbstract;\n+import static org.junit.platform.commons.support.ModifierSupport.isNotAbstract;\n+import static org.junit.platform.commons.support.ModifierSupport.isNotPrivate;\n+import static org.junit.platform.commons.util.ReflectionUtils.isInnerClass;\n+import static org.junit.platform.commons.util.ReflectionUtils.isMethodPresent;\n+import static org.junit.platform.commons.util.ReflectionUtils.isNestedClassPresent;\n+\n+import java.lang.reflect.Method;\n+import java.util.function.Predicate;\n+\n+import org.apiguardian.api.API;\n+import org.junit.jupiter.api.ClassTemplate;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.platform.commons.util.ReflectionUtils;\n+import org.junit.platform.engine.DiscoveryIssue;\n+import org.junit.platform.engine.support.descriptor.ClassSource;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter.Condition;\n+\n+/**\n+ * Predicates for determining whether a class is a JUnit Jupiter test class.\n+ *\n+ * @since 5.13\n+ */\n+@API(status = INTERNAL, since = \""5.13\"")\n+public class TestClassPredicates {\n+\n+\tpublic final Predicate<Class<?>> isAnnotatedWithNested = testClass -> isAnnotated(testClass, Nested.class);\n+\tpublic final Predicate<Class<?>> isAnnotatedWithClassTemplate = testClass -> isAnnotated(testClass,\n+\t\tClassTemplate.class);\n+\n+\tpublic final Predicate<Class<?>> isAnnotatedWithNestedAndValid = candidate -> this.isAnnotatedWithNested.test(\n+\t\tcandidate) && isValidNestedTestClass(candidate);\n+\tpublic final Predicate<Class<?>> looksLikeNestedOrStandaloneTestClass = candidate -> this.isAnnotatedWithNested.test(\n+\t\tcandidate) || looksLikeIntendedTestClass(candidate);\n+\tpublic final Predicate<Method> isTestOrTestFactoryOrTestTemplateMethod;\n+\n+\tprivate final Condition<Class<?>> isValidNestedTestClass;\n+\tprivate final Condition<Class<?>> isValidStandaloneTestClass;\n+\n+\tpublic TestClassPredicates(DiscoveryIssueReporter issueReporter) {\n+\t\tthis.isTestOrTestFactoryOrTestTemplateMethod = new IsTestMethod(issueReporter) //\n+\t\t\t\t.or(new IsTestFactoryMethod(issueReporter)) //\n+\t\t\t\t.or(new IsTestTemplateMethod(issueReporter));\n+\t\tthis.isValidNestedTestClass = isNotPrivateUnlessAbstract(\""@Nested\"", issueReporter) //\n+\t\t\t\t.and(isInner(issueReporter));\n+\t\tthis.isValidStandaloneTestClass = isNotPrivateUnlessAbstract(\""Test\"", issueReporter) //\n+\t\t\t\t.and(isNotLocal(issueReporter)) //\n+\t\t\t\t.and(isNotInner(issueReporter)) // or should be annotated with @Nested!\n+\t\t\t\t.and(isNotAnonymous(issueReporter));\n+\t}\n+\n+\tpublic boolean looksLikeIntendedTestClass(Class<?> candidate) {\n+\t\treturn this.isAnnotatedWithClassTemplate.test(candidate) //\n+\t\t\t\t|| hasTestOrTestFactoryOrTestTemplateMethods(candidate) //\n+\t\t\t\t|| hasNestedTests(candidate);\n+\t}\n+\n+\tpublic boolean isValidNestedTestClass(Class<?> candidate) {\n+\t\treturn this.isValidNestedTestClass.check(candidate) //\n+\t\t\t\t&& isNotAbstract(candidate);\n+\t}\n+\n+\tpublic boolean isValidStandaloneTestClass(Class<?> candidate) {\n+\t\treturn this.isValidStandaloneTestClass.check(candidate) //\n+\t\t\t\t&& isNotAbstract(candidate);\n+\t}\n+\n+\tprivate boolean hasTestOrTestFactoryOrTestTemplateMethods(Class<?> candidate) {\n+\t\treturn isMethodPresent(candidate, this.isTestOrTestFactoryOrTestTemplateMethod);\n+\t}\n+\n+\tprivate boolean hasNestedTests(Class<?> candidate) {\n+\t\treturn isNestedClassPresent(candidate, this.isAnnotatedWithNestedAndValid);\n+\t}\n+\n+\tprivate static Condition<Class<?>> isNotPrivateUnlessAbstract(String prefix, DiscoveryIssueReporter issueReporter) {\n+\t\t// Allow abstract test classes to be private because subclasses may widen access.\n+\t\treturn issueReporter.createReportingCondition(testClass -> isNotPrivate(testClass) || isAbstract(testClass),\n+\t\t\ttestClass -> createIssue(prefix, testClass, \""must not be private\""));\n+\t}\n+\n+\tprivate static Condition<Class<?>> isNotLocal(DiscoveryIssueReporter issueReporter) {\n+\t\treturn issueReporter.createReportingCondition(testClass -> !testClass.isLocalClass(),\n+\t\t\ttestClass -> createIssue(\""Test\"", testClass, \""must not be a local class\""));\n+\t}\n+\n+\tprivate static Condition<Class<?>> isInner(DiscoveryIssueReporter issueReporter) {\n+\t\treturn issueReporter.createReportingCondition(ReflectionUtils::isInnerClass, testClass -> {\n+\t\t\tif (testClass.getEnclosingClass() == null) {\n+\t\t\t\treturn createIssue(\""@Nested\"", testClass, \""must not be a top-level class\"");\n+\t\t\t}\n+\t\t\treturn createIssue(\""@Nested\"", testClass, \""must not be static\"");\n+\t\t});\n+\t}\n+\n+\tprivate static Condition<Class<?>> isNotInner(DiscoveryIssueReporter issueReporter) {\n+\t\treturn issueReporter.createReportingCondition(testClass -> !isInnerClass(testClass),\n+\t\t\ttestClass -> createIssue(\""Test\"", testClass, \""must not be an inner class unless annotated with @Nested\""));\n+\t}\n+\n+\tprivate static Condition<Class<?>> isNotAnonymous(DiscoveryIssueReporter issueReporter) {\n+\t\treturn issueReporter.createReportingCondition(testClass -> !testClass.isAnonymousClass(),\n+\t\t\ttestClass -> createIssue(\""Test\"", testClass, \""must not be anonymous\""));\n+\t}\n+\n+\tprivate static DiscoveryIssue createIssue(String prefix, Class<?> testClass, String detailMessage) {\n+\t\tString message = String.format(\""%s class '%s' %s. It will not be executed.\"", prefix, testClass.getName(),\n+\t\t\tdetailMessage);\n+\t\treturn DiscoveryIssue.builder(DiscoveryIssue.Severity.WARNING, message) //\n+\t\t\t\t.source(ClassSource.from(testClass)) //\n+\t\t\t\t.build();\n+\t}\n+}\n\ndiff --git a/junit-jupiter-engine/src/testFixtures/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java b/junit-jupiter-engine/src/testFixtures/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java\nindex d7f6e252e096..d504f3605d65 100644\n--- a/junit-jupiter-engine/src/testFixtures/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java\n+++ b/junit-jupiter-engine/src/testFixtures/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java\n@@ -51,7 +51,7 @@ public static UniqueId uniqueIdForStaticClass(String className) {\n \tprivate static String staticClassSegmentType(String className) {\n \t\treturn ReflectionSupport.tryToLoadClass(className).toOptional() //\n \t\t\t\t.map(it -> classSegmentType(it, ClassTestDescriptor.SEGMENT_TYPE,\n-\t\t\t\t\tClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE)) //\n+\t\t\t\t\tClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE)) //\n \t\t\t\t.orElse(ClassTestDescriptor.SEGMENT_TYPE);\n \t}\n \n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java\nindex 0790db75c7f9..82c9eab01bb2 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java\n@@ -13,12 +13,14 @@\n import static org.junit.jupiter.api.Assertions.fail;\n import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;\n import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;\n+import static org.junit.platform.launcher.LauncherConstants.CRITICAL_DISCOVERY_ISSUE_SEVERITY_PROPERTY_NAME;\n import static org.junit.platform.launcher.LauncherConstants.STACKTRACE_PRUNING_ENABLED_PROPERTY_NAME;\n import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;\n import static org.junit.platform.launcher.core.OutputDirectoryProviders.dummyOutputDirectoryProvider;\n \n import java.util.function.Consumer;\n \n+import org.junit.platform.engine.DiscoveryIssue.Severity;\n import org.junit.platform.engine.DiscoverySelector;\n import org.junit.platform.engine.UniqueId;\n import org.junit.platform.launcher.LauncherDiscoveryRequest;\n@@ -84,6 +86,7 @@ private static LauncherDiscoveryRequestBuilder defaultRequest() {\n \t\treturn request() //\n \t\t\t\t.outputDirectoryProvider(dummyOutputDirectoryProvider()) //\n \t\t\t\t.configurationParameter(STACKTRACE_PRUNING_ENABLED_PROPERTY_NAME, String.valueOf(false)) //\n+\t\t\t\t.configurationParameter(CRITICAL_DISCOVERY_ISSUE_SEVERITY_PROPERTY_NAME, Severity.INFO.name()) //\n \t\t\t\t.enableImplicitConfigurationParameters(false);\n \t}\n \n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/ClassTemplateInvocationTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/ClassTemplateInvocationTests.java\nindex 364f78a7306d..be8a076bfe45 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/ClassTemplateInvocationTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/ClassTemplateInvocationTests.java\n@@ -110,7 +110,7 @@ public class ClassTemplateInvocationTests extends AbstractJupiterTestEngineTests\n \t})\n \tvoid executesClassTemplateClassTwice(String selectorIdentifierTemplate) {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tTwoInvocationsTestCase.class.getName());\n \t\tvar invocationId1 = classTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#1\"");\n \t\tvar invocation1MethodAId = invocationId1.append(TestMethodTestDescriptor.SEGMENT_TYPE, \""a()\"");\n@@ -299,7 +299,7 @@ void executesNestedClassTemplateClassTwiceWithNestedClassSelector() {\n \t@Test\n \tvoid executesNestedClassTemplatesTwiceEach() {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar outerClassTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar outerClassTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tTwoTimesTwoInvocationsTestCase.class.getName());\n \n \t\tvar outerInvocation1Id = outerClassTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#1\"");\n@@ -403,7 +403,7 @@ void eachInvocationHasSeparateExtensionContext() {\n \t@Test\n \tvoid supportsTestTemplateMethodsInsideClassTemplateClasses() {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tCombinationWithTestTemplateTestCase.class.getName());\n \t\tvar invocationId1 = classTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#1\"");\n \t\tvar testTemplateId1 = invocationId1.append(TestTemplateTestDescriptor.SEGMENT_TYPE, \""test(int)\"");\n@@ -459,7 +459,7 @@ void supportsTestTemplateMethodsInsideClassTemplateClasses() {\n \t@Test\n \tvoid testTemplateInvocationInsideClassTemplateClassCanBeSelectedByUniqueId() {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tCombinationWithTestTemplateTestCase.class.getName());\n \t\tvar invocationId2 = classTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#2\"");\n \t\tvar testTemplateId2 = invocationId2.append(TestTemplateTestDescriptor.SEGMENT_TYPE, \""test(int)\"");\n@@ -490,7 +490,7 @@ void testTemplateInvocationInsideClassTemplateClassCanBeSelectedByUniqueId() {\n \t@Test\n \tvoid supportsTestFactoryMethodsInsideClassTemplateClasses() {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tCombinationWithTestFactoryTestCase.class.getName());\n \t\tvar invocationId1 = classTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#1\"");\n \t\tvar testFactoryId1 = invocationId1.append(TestFactoryTestDescriptor.SEGMENT_TYPE, \""test()\"");\n@@ -546,7 +546,7 @@ void supportsTestFactoryMethodsInsideClassTemplateClasses() {\n \t@Test\n \tvoid specificDynamicTestInsideClassTemplateClassCanBeSelectedByUniqueId() {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tCombinationWithTestFactoryTestCase.class.getName());\n \t\tvar invocationId2 = classTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#2\"");\n \t\tvar testFactoryId2 = invocationId2.append(TestFactoryTestDescriptor.SEGMENT_TYPE, \""test()\"");\n@@ -617,7 +617,7 @@ void failsIfNoSupportingProviderIsRegistered(Class<?> testClass) {\n \t@Test\n \tvoid classTemplateInvocationCanBeSelectedByUniqueId() {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tTwoInvocationsTestCase.class.getName());\n \t\tvar invocationId2 = classTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#2\"");\n \t\tvar methodAId = invocationId2.append(TestMethodTestDescriptor.SEGMENT_TYPE, \""a()\"");\n@@ -650,7 +650,7 @@ void classTemplateInvocationCanBeSelectedByUniqueId() {\n \t@Test\n \tvoid classTemplateInvocationCanBeSelectedByIteration() {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tTwoInvocationsTestCase.class.getName());\n \t\tvar invocationId2 = classTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#2\"");\n \t\tvar methodAId = invocationId2.append(TestMethodTestDescriptor.SEGMENT_TYPE, \""a()\"");\n@@ -687,7 +687,7 @@ void classTemplateInvocationCanBeSelectedByIteration() {\n \t})\n \tvoid executesAllInvocationsForRedundantSelectors(String classTemplateSelectorIdentifier) {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tTwoInvocationsTestCase.class.getName());\n \t\tvar invocationId2 = classTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#2\"");\n \n@@ -700,7 +700,7 @@ void executesAllInvocationsForRedundantSelectors(String classTemplateSelectorIde\n \t@Test\n \tvoid methodInClassTemplateInvocationCanBeSelectedByUniqueId() {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tTwoInvocationsTestCase.class.getName());\n \t\tvar invocationId2 = classTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#2\"");\n \t\tvar methodAId = invocationId2.append(TestMethodTestDescriptor.SEGMENT_TYPE, \""a()\"");\n@@ -725,7 +725,7 @@ void methodInClassTemplateInvocationCanBeSelectedByUniqueId() {\n \t@Test\n \tvoid nestedMethodInClassTemplateInvocationCanBeSelectedByUniqueId() {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar classTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tTwoInvocationsTestCase.class.getName());\n \t\tvar invocationId2 = classTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#2\"");\n \t\tvar nestedClassId = invocationId2.append(NestedClassTestDescriptor.SEGMENT_TYPE, \""NestedTestCase\"");\n@@ -754,7 +754,7 @@ void nestedMethodInClassTemplateInvocationCanBeSelectedByUniqueId() {\n \t@Test\n \tvoid nestedClassTemplateInvocationCanBeSelectedByUniqueId() {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar outerClassTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar outerClassTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tTwoTimesTwoInvocationsWithMultipleMethodsTestCase.class.getName());\n \t\tvar outerInvocation2Id = outerClassTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#2\"");\n \t\tvar outerInvocation2NestedClassTemplateId = outerInvocation2Id.append(\n@@ -794,7 +794,7 @@ void nestedClassTemplateInvocationCanBeSelectedByUniqueId() {\n \t@Test\n \tvoid nestedClassTemplateInvocationCanBeSelectedByIteration() {\n \t\tvar engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);\n-\t\tvar outerClassTemplateId = engineId.append(ClassTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,\n+\t\tvar outerClassTemplateId = engineId.append(ClassTemplateTestDescriptor.STANDALONE_CLASS_SEGMENT_TYPE,\n \t\t\tTwoTimesTwoInvocationsTestCase.class.getName());\n \t\tvar outerInvocation1Id = outerClassTemplateId.append(ClassTemplateInvocationTestDescriptor.SEGMENT_TYPE, \""#1\"");\n \t\tvar outerInvocation1NestedClassTemplateId = outerInvocation1Id.append(\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java\nindex 328ef26a73db..2fe8352f41b8 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java\n@@ -10,15 +10,19 @@\n \n package org.junit.jupiter.engine;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.junit.jupiter.api.Assertions.assertAll;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;\n import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;\n import static org.junit.platform.engine.discovery.DiscoverySelectors.selectUniqueId;\n+import static org.junit.platform.launcher.LauncherConstants.CRITICAL_DISCOVERY_ISSUE_SEVERITY_PROPERTY_NAME;\n import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;\n import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;\n import static org.junit.platform.testkit.engine.TestExecutionResultConditions.message;\n \n+import java.util.List;\n+\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n@@ -27,7 +31,9 @@\n import org.junit.jupiter.engine.NestedTestClassesTests.OuterClass.NestedClass;\n import org.junit.jupiter.engine.NestedTestClassesTests.OuterClass.NestedClass.RecursiveNestedClass;\n import org.junit.jupiter.engine.NestedTestClassesTests.OuterClass.NestedClass.RecursiveNestedSiblingClass;\n+import org.junit.platform.engine.DiscoveryIssue.Severity;\n import org.junit.platform.engine.TestDescriptor;\n+import org.junit.platform.engine.support.descriptor.ClassSource;\n import org.junit.platform.launcher.LauncherDiscoveryRequest;\n import org.junit.platform.testkit.engine.EngineExecutionResults;\n import org.junit.platform.testkit.engine.Events;\n@@ -95,7 +101,14 @@ void doublyNestedTestsAreExecuted() {\n \n \t@Test\n \tvoid inheritedNestedTestsAreExecuted() {\n-\t\tEngineExecutionResults executionResults = executeTestsForClass(TestCaseWithInheritedNested.class);\n+\t\tvar discoveryIssues = discoverTestsForClass(TestCaseWithInheritedNested.class).getDiscoveryIssues();\n+\t\tassertThat(discoveryIssues).hasSize(1);\n+\t\tassertThat(discoveryIssues.getFirst().source()) //\n+\t\t\t\t.contains(ClassSource.from(InterfaceWithNestedClass.NestedInInterface.class));\n+\n+\t\tvar executionResults = executeTests(request -> request //\n+\t\t\t\t.selectors(selectClass(TestCaseWithInheritedNested.class)) //\n+\t\t\t\t.configurationParameter(CRITICAL_DISCOVERY_ISSUE_SEVERITY_PROPERTY_NAME, Severity.ERROR.name()));\n \t\tEvents containers = executionResults.containerEvents();\n \t\tEvents tests = executionResults.testEvents();\n \n@@ -109,7 +122,14 @@ void inheritedNestedTestsAreExecuted() {\n \n \t@Test\n \tvoid extendedNestedTestsAreExecuted() {\n-\t\tvar executionResults = executeTestsForClass(TestCaseWithExtendedNested.class);\n+\t\tvar discoveryIssues = discoverTestsForClass(TestCaseWithExtendedNested.class).getDiscoveryIssues();\n+\t\tassertThat(discoveryIssues).hasSize(1);\n+\t\tassertThat(discoveryIssues.getFirst().source()) //\n+\t\t\t\t.contains(ClassSource.from(InterfaceWithNestedClass.NestedInInterface.class));\n+\n+\t\tvar executionResults = executeTests(request -> request //\n+\t\t\t\t.selectors(selectClass(TestCaseWithExtendedNested.class)) //\n+\t\t\t\t.configurationParameter(CRITICAL_DISCOVERY_ISSUE_SEVERITY_PROPERTY_NAME, Severity.ERROR.name()));\n \t\tEvents containers = executionResults.containerEvents();\n \t\tEvents tests = executionResults.testEvents();\n \n@@ -123,10 +143,21 @@ void extendedNestedTestsAreExecuted() {\n \n \t@Test\n \tvoid deeplyNestedInheritedMethodsAreExecutedWhenSelectedViaUniqueId() {\n-\t\tvar executionResults = executeTests(selectUniqueId(\n-\t\t\t\""[engine:junit-jupiter]/[class:org.junit.jupiter.engine.NestedTestClassesTests$TestCaseWithExtendedNested]/[nested-class:ConcreteInner1]/[nested-class:NestedInAbstractClass]/[nested-class:SecondLevelInherited]/[method:test()]\""),\n+\t\tvar selectors = List.of( //\n+\t\t\tselectUniqueId(\n+\t\t\t\t\""[engine:junit-jupiter]/[class:org.junit.jupiter.engine.NestedTestClassesTests$TestCaseWithExtendedNested]/[nested-class:ConcreteInner1]/[nested-class:NestedInAbstractClass]/[nested-class:SecondLevelInherited]/[method:test()]\""),\n \t\t\tselectUniqueId(\n \t\t\t\t\""[engine:junit-jupiter]/[class:org.junit.jupiter.engine.NestedTestClassesTests$TestCaseWithExtendedNested]/[nested-class:ConcreteInner2]/[nested-class:NestedInAbstractClass]/[nested-class:SecondLevelInherited]/[method:test()]\""));\n+\n+\t\tvar discoveryIssues = discoverTests(request -> request.selectors(selectors)).getDiscoveryIssues();\n+\t\tassertThat(discoveryIssues).hasSize(1);\n+\t\tassertThat(discoveryIssues.getFirst().source()) //\n+\t\t\t\t.contains(ClassSource.from(InterfaceWithNestedClass.NestedInInterface.class));\n+\n+\t\tvar executionResults = executeTests(request -> request //\n+\t\t\t\t.selectors(selectors) //\n+\t\t\t\t.configurationParameter(CRITICAL_DISCOVERY_ISSUE_SEVERITY_PROPERTY_NAME, Severity.ERROR.name()));\n+\n \t\tEvents containers = executionResults.containerEvents();\n \t\tEvents tests = executionResults.testEvents();\n \n@@ -281,7 +312,7 @@ void failing() {\n \n \tinterface InterfaceWithNestedClass {\n \n-\t\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n+\t\t@SuppressWarnings({ \""JUnitMalformedDeclaration\"", \""NewClassNamingConvention\"" })\n \t\t@Nested\n \t\tclass NestedInInterface {\n \n@@ -333,7 +364,7 @@ class ConcreteInner2 extends AbstractSuperClass {\n \tstatic class AbstractOuterClass {\n \t}\n \n-\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n+\t@SuppressWarnings({ \""JUnitMalformedDeclaration\"", \""NewClassNamingConvention\"" })\n \tstatic class OuterClass extends AbstractOuterClass {\n \n \t\t@Test\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java\nindex cfc8c24f0672..368ec1b7f50f 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java\n@@ -16,10 +16,12 @@\n import static org.junit.jupiter.api.Assertions.fail;\n import static org.junit.jupiter.api.Named.named;\n import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.uniqueIdForTestTemplateMethod;\n+import static org.junit.jupiter.params.provider.Arguments.argumentSet;\n import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;\n import static org.junit.platform.engine.discovery.ClassNameFilter.includeClassNamePatterns;\n import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;\n import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;\n+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectNestedClass;\n import static org.junit.platform.engine.discovery.DiscoverySelectors.selectNestedMethod;\n import static org.junit.platform.engine.discovery.DiscoverySelectors.selectPackage;\n import static org.junit.platform.engine.discovery.DiscoverySelectors.selectUniqueId;\n@@ -42,6 +44,7 @@\n import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;\n import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;\n import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;\n import org.junit.platform.engine.DiscoveryIssue;\n import org.junit.platform.engine.TestDescriptor;\n@@ -174,7 +177,7 @@ void discoverDeeplyNestedTestMethodByNestedMethodSelector() throws Exception {\n \t@MethodSource(\""requestsForTestClassWithInvalidTestMethod\"")\n \tvoid reportsWarningForTestClassWithInvalidTestMethod(LauncherDiscoveryRequest request) throws Exception {\n \n-\t\tvar method = InvalidTestMethodTestCase.class.getDeclaredMethod(\""test\"");\n+\t\tvar method = InvalidTestCases.InvalidTestMethodTestCase.class.getDeclaredMethod(\""test\"");\n \n \t\tvar results = discoverTests(request);\n \n@@ -191,14 +194,75 @@ void reportsWarningForTestClassWithInvalidTestMethod(LauncherDiscoveryRequest re\n \n \tstatic List<Named<LauncherDiscoveryRequest>> requestsForTestClassWithInvalidTestMethod() {\n \t\treturn List.of( //\n-\t\t\tnamed(\""directly selected\"", request().selectors(selectClass(InvalidTestMethodTestCase.class)).build()), //\n+\t\t\tnamed(\""directly selected\"",\n+\t\t\t\trequest().selectors(selectClass(InvalidTestCases.InvalidTestMethodTestCase.class)).build()), //\n \t\t\tnamed(\""indirectly selected\"", request() //\n-\t\t\t\t\t.selectors(selectPackage(InvalidTestMethodTestCase.class.getPackageName())) //\n-\t\t\t\t\t.filters(\n-\t\t\t\t\t\tincludeClassNamePatterns(Pattern.quote(InvalidTestMethodTestCase.class.getName()))).build()), //\n+\t\t\t\t\t.selectors(selectPackage(InvalidTestCases.InvalidTestMethodTestCase.class.getPackageName())) //\n+\t\t\t\t\t.filters(includeClassNamePatterns(\n+\t\t\t\t\t\tPattern.quote(InvalidTestCases.InvalidTestMethodTestCase.class.getName()))).build()), //\n \t\t\tnamed(\""subclasses\"", request() //\n-\t\t\t\t\t.selectors(selectClass(InvalidTestMethodSubclass1TestCase.class),\n-\t\t\t\t\t\tselectClass(InvalidTestMethodSubclass2TestCase.class)) //\n+\t\t\t\t\t.selectors(selectClass(InvalidTestCases.InvalidTestMethodSubclass1TestCase.class),\n+\t\t\t\t\t\tselectClass(InvalidTestCases.InvalidTestMethodSubclass2TestCase.class)) //\n+\t\t\t\t\t.build()) //\n+\t\t);\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\""requestsForTestClassWithInvalidStandaloneTestClass\"")\n+\tvoid reportsWarningForInvalidStandaloneTestClass(LauncherDiscoveryRequest request, Class<?> testClass) {\n+\n+\t\tvar results = discoverTests(request);\n+\n+\t\tvar discoveryIssues = results.getDiscoveryIssues().stream().sorted(comparing(DiscoveryIssue::message)).toList();\n+\t\tassertThat(discoveryIssues).hasSize(2);\n+\t\tassertThat(discoveryIssues.getFirst().message()) //\n+\t\t\t\t.isEqualTo(\n+\t\t\t\t\t\""Test class '%s' must not be an inner class unless annotated with @Nested. It will not be executed.\"",\n+\t\t\t\t\ttestClass.getName());\n+\t\tassertThat(discoveryIssues.getLast().message()) //\n+\t\t\t\t.isEqualTo(\""Test class '%s' must not be private. It will not be executed.\"", testClass.getName());\n+\t}\n+\n+\tstatic List<Arguments> requestsForTestClassWithInvalidStandaloneTestClass() {\n+\t\treturn List.of( //\n+\t\t\targumentSet(\""directly selected\"",\n+\t\t\t\trequest().selectors(selectClass(InvalidTestCases.InvalidTestClassTestCase.class)).build(),\n+\t\t\t\tInvalidTestCases.InvalidTestClassTestCase.class), //\n+\t\t\targumentSet(\""indirectly selected\"", request() //\n+\t\t\t\t\t.selectors(selectPackage(InvalidTestCases.InvalidTestClassTestCase.class.getPackageName())) //\n+\t\t\t\t\t.filters(includeClassNamePatterns(\n+\t\t\t\t\t\tPattern.quote(InvalidTestCases.InvalidTestClassTestCase.class.getName()))).build(), //\n+\t\t\t\tInvalidTestCases.InvalidTestClassTestCase.class), //\n+\t\t\targumentSet(\""subclass\"", request() //\n+\t\t\t\t\t.selectors(selectClass(InvalidTestCases.InvalidTestClassSubclassTestCase.class)) //\n+\t\t\t\t\t.build(), //\n+\t\t\t\tInvalidTestCases.InvalidTestClassSubclassTestCase.class) //\n+\t\t);\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\""requestsForTestClassWithInvalidNestedTestClass\"")\n+\tvoid reportsWarningForInvalidNestedTestClass(LauncherDiscoveryRequest request) {\n+\n+\t\tvar results = discoverTests(request);\n+\n+\t\tvar discoveryIssues = results.getDiscoveryIssues().stream().sorted(comparing(DiscoveryIssue::message)).toList();\n+\t\tassertThat(discoveryIssues).hasSize(2);\n+\t\tassertThat(discoveryIssues.getFirst().message()) //\n+\t\t\t\t.isEqualTo(\""@Nested class '%s' must not be private. It will not be executed.\"",\n+\t\t\t\t\tInvalidTestCases.InvalidTestClassTestCase.Inner.class.getName());\n+\t\tassertThat(discoveryIssues.getLast().message()) //\n+\t\t\t\t.isEqualTo(\""@Nested class '%s' must not be static. It will not be executed.\"",\n+\t\t\t\t\tInvalidTestCases.InvalidTestClassTestCase.Inner.class.getName());\n+\t}\n+\n+\tstatic List<Named<LauncherDiscoveryRequest>> requestsForTestClassWithInvalidNestedTestClass() {\n+\t\treturn List.of( //\n+\t\t\tnamed(\""directly selected\"",\n+\t\t\t\trequest().selectors(selectClass(InvalidTestCases.InvalidTestClassTestCase.Inner.class)).build()), //\n+\t\t\tnamed(\""subclass\"", request() //\n+\t\t\t\t\t.selectors(selectNestedClass(List.of(InvalidTestCases.InvalidTestClassSubclassTestCase.class),\n+\t\t\t\t\t\tInvalidTestCases.InvalidTestClassTestCase.Inner.class)) //\n \t\t\t\t\t.build()) //\n \t\t);\n \t}\n@@ -271,18 +335,45 @@ class ConcreteInner1 extends AbstractSuperClass {\n \t\t}\n \t}\n \n-\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n-\tstatic class InvalidTestMethodTestCase {\n-\t\t@Test\n-\t\tprivate static int test() {\n-\t\t\treturn fail(\""should not be called\"");\n+\tstatic class InvalidTestCases {\n+\n+\t\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n+\t\tstatic class InvalidTestMethodTestCase {\n+\t\t\t@Test\n+\t\t\tprivate static int test() {\n+\t\t\t\treturn fail(\""should not be called\"");\n+\t\t\t}\n \t\t}\n-\t}\n \n-\tstatic class InvalidTestMethodSubclass1TestCase extends InvalidTestMethodTestCase {\n-\t}\n+\t\tstatic class InvalidTestMethodSubclass1TestCase extends InvalidTestMethodTestCase {\n+\t\t}\n+\n+\t\tstatic class InvalidTestMethodSubclass2TestCase extends InvalidTestMethodTestCase {\n+\t\t}\n+\n+\t\t@SuppressWarnings({ \""JUnitMalformedDeclaration\"", \""InnerClassMayBeStatic\"" })\n+\t\tprivate class InvalidTestClassTestCase {\n+\n+\t\t\t@SuppressWarnings(\""unused\"")\n+\t\t\t@Test\n+\t\t\tvoid test() {\n+\t\t\t\tfail(\""should not be called\"");\n+\t\t\t}\n+\n+\t\t\t@Nested\n+\t\t\tprivate static class Inner {\n+\t\t\t\t@SuppressWarnings(\""unused\"")\n+\t\t\t\t@Test\n+\t\t\t\tvoid test() {\n+\t\t\t\t\tfail(\""should not be called\"");\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tprivate class InvalidTestClassSubclassTestCase extends InvalidTestClassTestCase {\n+\t\t}\n \n-\tstatic class InvalidTestMethodSubclass2TestCase extends InvalidTestMethodTestCase {\n \t}\n \n }\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsInnerClassTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsInnerClassTests.java\ndeleted file mode 100644\nindex d371fd3f2e03..000000000000\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsInnerClassTests.java\n+++ /dev/null\n@@ -1,54 +0,0 @@\n-/*\n- * Copyright 2015-2025 the original author or authors.\n- *\n- * All rights reserved. This program and the accompanying materials are\n- * made available under the terms of the Eclipse Public License v2.0 which\n- * accompanies this distribution and is available at\n- *\n- * https://www.eclipse.org/legal/epl-v20.html\n- */\n-\n-package org.junit.jupiter.engine.discovery.predicates;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import java.util.function.Predicate;\n-\n-import org.junit.jupiter.api.Test;\n-\n-/**\n- * @since 5.0\n- */\n-class IsInnerClassTests {\n-\n-\tprivate final Predicate<Class<?>> isInnerClass = new IsInnerClass();\n-\n-\t@Test\n-\tvoid innerClassEvaluatesToTrue() {\n-\t\tassertThat(isInnerClass).accepts(InnerClassesTestCase.InnerClass.class);\n-\t}\n-\n-\t@Test\n-\tvoid staticNestedClassEvaluatesToFalse() {\n-\t\tassertThat(isInnerClass).rejects(InnerClassesTestCase.StaticNestedClass.class);\n-\t}\n-\n-\t@Test\n-\tvoid privateInnerClassEvaluatesToFalse() {\n-\t\tassertThat(isInnerClass).rejects(InnerClassesTestCase.PrivateInnerClass.class);\n-\t}\n-\n-\tprivate static class InnerClassesTestCase {\n-\n-\t\tclass InnerClass {\n-\t\t}\n-\n-\t\tstatic class StaticNestedClass {\n-\t\t}\n-\n-\t\tprivate class PrivateInnerClass {\n-\t\t}\n-\n-\t}\n-\n-}\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsNestedTestClassTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsNestedTestClassTests.java\ndeleted file mode 100644\nindex 609785f4a3e4..000000000000\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsNestedTestClassTests.java\n+++ /dev/null\n@@ -1,60 +0,0 @@\n-/*\n- * Copyright 2015-2025 the original author or authors.\n- *\n- * All rights reserved. This program and the accompanying materials are\n- * made available under the terms of the Eclipse Public License v2.0 which\n- * accompanies this distribution and is available at\n- *\n- * https://www.eclipse.org/legal/epl-v20.html\n- */\n-\n-package org.junit.jupiter.engine.discovery.predicates;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import java.util.function.Predicate;\n-\n-import org.junit.jupiter.api.Nested;\n-import org.junit.jupiter.api.Test;\n-\n-/**\n- * @since 5.0\n- */\n-class IsNestedTestClassTests {\n-\n-\tprivate final Predicate<Class<?>> isNestedTestClass = new IsNestedTestClass();\n-\n-\t@Test\n-\tvoid innerClassEvaluatesToTrue() {\n-\t\tassertThat(isNestedTestClass).accepts(NestedClassesTestCase.InnerClass.class);\n-\t}\n-\n-\t@Test\n-\tvoid staticNestedClassEvaluatesToFalse() {\n-\t\tassertThat(isNestedTestClass).rejects(NestedClassesTestCase.StaticNestedClass.class);\n-\t}\n-\n-\t@Test\n-\tvoid privateNestedClassEvaluatesToFalse() {\n-\t\tassertThat(isNestedTestClass).rejects(NestedClassesTestCase.PrivateInnerClass.class);\n-\t}\n-\n-\tprivate static class NestedClassesTestCase {\n-\n-\t\t@Nested\n-\t\tclass InnerClass {\n-\t\t}\n-\n-\t\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n-\t\t@Nested\n-\t\tstatic class StaticNestedClass {\n-\t\t}\n-\n-\t\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n-\t\t@Nested\n-\t\tprivate class PrivateInnerClass {\n-\t\t}\n-\n-\t}\n-\n-}\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsPotentialTestContainerTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsPotentialTestContainerTests.java\ndeleted file mode 100644\nindex 47c9c7143815..000000000000\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsPotentialTestContainerTests.java\n+++ /dev/null\n@@ -1,71 +0,0 @@\n-/*\n- * Copyright 2015-2025 the original author or authors.\n- *\n- * All rights reserved. This program and the accompanying materials are\n- * made available under the terms of the Eclipse Public License v2.0 which\n- * accompanies this distribution and is available at\n- *\n- * https://www.eclipse.org/legal/epl-v20.html\n- */\n-\n-package org.junit.jupiter.engine.discovery.predicates;\n-\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-import org.junit.jupiter.api.Test;\n-\n-/**\n- * @since 5.0\n- */\n-class IsPotentialTestContainerTests {\n-\n-\tprivate final IsPotentialTestContainer isPotentialTestContainer = new IsPotentialTestContainer();\n-\n-\t@Test\n-\tvoid staticClassEvaluatesToTrue() {\n-\t\tassertTrue(isPotentialTestContainer.test(StaticClass.class));\n-\t}\n-\n-\t@Test\n-\tvoid privateStaticClassEvaluatesToFalse() {\n-\t\tassertFalse(isPotentialTestContainer.test(PrivateStaticClass.class));\n-\t}\n-\n-\t@Test\n-\tvoid abstractClassEvaluatesToFalse() {\n-\t\tassertFalse(isPotentialTestContainer.test(AbstractClass.class));\n-\t}\n-\n-\t@Test\n-\tvoid localClassEvaluatesToFalse() {\n-\n-\t\tclass LocalClass {\n-\t\t}\n-\n-\t\tassertFalse(isPotentialTestContainer.test(LocalClass.class));\n-\t}\n-\n-\t@Test\n-\tvoid anonymousClassEvaluatesToFalse() {\n-\n-\t\tObject object = new Object() {\n-\t\t\t@Override\n-\t\t\tpublic String toString() {\n-\t\t\t\treturn \""\"";\n-\t\t\t}\n-\t\t};\n-\n-\t\tassertFalse(isPotentialTestContainer.test(object.getClass()));\n-\t}\n-\n-\tprivate static class PrivateStaticClass {\n-\t}\n-\n-\tstatic class StaticClass {\n-\t}\n-\n-}\n-\n-abstract class AbstractClass {\n-}\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java\ndeleted file mode 100644\nindex 746740034f08..000000000000\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java\n+++ /dev/null\n@@ -1,220 +0,0 @@\n-/*\n- * Copyright 2015-2025 the original author or authors.\n- *\n- * All rights reserved. This program and the accompanying materials are\n- * made available under the terms of the Eclipse Public License v2.0 which\n- * accompanies this distribution and is available at\n- *\n- * https://www.eclipse.org/legal/epl-v20.html\n- */\n-\n-package org.junit.jupiter.engine.discovery.predicates;\n-\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.function.Predicate;\n-\n-import org.junit.jupiter.api.DynamicTest;\n-import org.junit.jupiter.api.Nested;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.TestFactory;\n-import org.junit.jupiter.api.TestTemplate;\n-import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n-\n-/**\n- * Unit tests for {@link IsTestClassWithTests}.\n- *\n- * @since 5.0\n- */\n-class IsTestClassWithTestsTests {\n-\n-\tprivate final Predicate<Class<?>> isTestClassWithTests = new IsTestClassWithTests(\n-\t\tDiscoveryIssueReporter.consuming(__ -> {\n-\t\t}));\n-\n-\t@Test\n-\tvoid classWithTestMethodEvaluatesToTrue() {\n-\t\tassertTrue(isTestClassWithTests.test(ClassWithTestMethod.class));\n-\t}\n-\n-\t@Test\n-\tvoid classWithTestFactoryEvaluatesToTrue() {\n-\t\tassertTrue(isTestClassWithTests.test(ClassWithTestFactory.class));\n-\t}\n-\n-\t@Test\n-\tvoid classWithTestTemplateEvaluatesToTrue() {\n-\t\tassertTrue(isTestClassWithTests.test(ClassWithTestTemplate.class));\n-\t}\n-\n-\t@Test\n-\tvoid classWithNestedTestClassEvaluatesToTrue() {\n-\t\tassertTrue(isTestClassWithTests.test(ClassWithNestedTestClass.class));\n-\t}\n-\n-\t@Test\n-\tvoid staticTestClassEvaluatesToTrue() {\n-\t\tassertTrue(isTestClassWithTests.test(StaticTestCase.class));\n-\t}\n-\n-\t// -------------------------------------------------------------------------\n-\n-\t@Test\n-\tvoid privateClassWithTestMethodEvaluatesToFalse() {\n-\t\tassertFalse(isTestClassWithTests.test(PrivateClassWithTestMethod.class));\n-\t}\n-\n-\t@Test\n-\tvoid privateClassWithTestFactoryEvaluatesToFalse() {\n-\t\tassertFalse(isTestClassWithTests.test(PrivateClassWithTestFactory.class));\n-\t}\n-\n-\t@Test\n-\tvoid privateClassWithTestTemplateEvaluatesToFalse() {\n-\t\tassertFalse(isTestClassWithTests.test(PrivateClassWithTestTemplate.class));\n-\t}\n-\n-\t@Test\n-\tvoid privateClassWithNestedTestCasesEvaluatesToFalse() {\n-\t\tassertFalse(isTestClassWithTests.test(PrivateClassWithNestedTestClass.class));\n-\t}\n-\n-\t@Test\n-\tvoid privateStaticTestClassEvaluatesToFalse() {\n-\t\tassertFalse(isTestClassWithTests.test(PrivateStaticTestCase.class));\n-\t}\n-\n-\t/**\n-\t * @see https://github.com/junit-team/junit5/issues/2249\n-\t */\n-\t@Test\n-\tvoid recursiveHierarchies() {\n-\t\tassertTrue(isTestClassWithTests.test(OuterClass.class));\n-\t\tassertFalse(isTestClassWithTests.test(OuterClass.RecursiveInnerClass.class));\n-\t}\n-\n-\t// -------------------------------------------------------------------------\n-\n-\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n-\tprivate class PrivateClassWithTestMethod {\n-\n-\t\t@Test\n-\t\tvoid test() {\n-\t\t}\n-\n-\t}\n-\n-\tprivate class PrivateClassWithTestFactory {\n-\n-\t\t@TestFactory\n-\t\tCollection<DynamicTest> factory() {\n-\t\t\treturn new ArrayList<>();\n-\t\t}\n-\n-\t}\n-\n-\tprivate class PrivateClassWithTestTemplate {\n-\n-\t\t@TestTemplate\n-\t\tvoid template(int a) {\n-\t\t}\n-\n-\t}\n-\n-\tprivate class PrivateClassWithNestedTestClass {\n-\n-\t\t@Nested\n-\t\tclass InnerClass {\n-\n-\t\t\t@Test\n-\t\t\tvoid first() {\n-\t\t\t}\n-\n-\t\t\t@Test\n-\t\t\tvoid second() {\n-\t\t\t}\n-\n-\t\t}\n-\t}\n-\n-\t// -------------------------------------------------------------------------\n-\n-\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n-\tstatic class StaticTestCase {\n-\n-\t\t@Test\n-\t\tvoid test() {\n-\t\t}\n-\t}\n-\n-\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n-\tprivate static class PrivateStaticTestCase {\n-\n-\t\t@Test\n-\t\tvoid test() {\n-\t\t}\n-\t}\n-\n-\tstatic class OuterClass {\n-\n-\t\t@Nested\n-\t\tclass InnerClass {\n-\n-\t\t\t@Test\n-\t\t\tvoid test() {\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Intentionally commented out so that RecursiveInnerClass is NOT a candidate test class\n-\t\t// @Nested\n-\t\tclass RecursiveInnerClass extends OuterClass {\n-\t\t}\n-\t}\n-\n-}\n-\n-// -----------------------------------------------------------------------------\n-\n-class ClassWithTestMethod {\n-\n-\t@Test\n-\tvoid test() {\n-\t}\n-\n-}\n-\n-class ClassWithTestFactory {\n-\n-\t@TestFactory\n-\tCollection<DynamicTest> factory() {\n-\t\treturn new ArrayList<>();\n-\t}\n-\n-}\n-\n-class ClassWithTestTemplate {\n-\n-\t@TestTemplate\n-\tvoid template(int a) {\n-\t}\n-\n-}\n-\n-class ClassWithNestedTestClass {\n-\n-\t@Nested\n-\tclass InnerClass {\n-\n-\t\t@Test\n-\t\tvoid first() {\n-\t\t}\n-\n-\t\t@Test\n-\t\tvoid second() {\n-\t\t}\n-\n-\t}\n-}\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java\nnew file mode 100644\nindex 000000000000..7f06ef15d0c5\n--- /dev/null\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java\n@@ -0,0 +1,492 @@\n+/*\n+ * Copyright 2015-2025 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junit.jupiter.engine.discovery.predicates;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.DynamicTest;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestFactory;\n+import org.junit.jupiter.api.TestTemplate;\n+import org.junit.platform.engine.DiscoveryIssue;\n+import org.junit.platform.engine.DiscoveryIssue.Severity;\n+import org.junit.platform.engine.support.descriptor.ClassSource;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n+\n+public class TestClassPredicatesTests {\n+\n+\tprivate final List<DiscoveryIssue> discoveryIssues = new ArrayList<>();\n+\tprivate final TestClassPredicates predicates = new TestClassPredicates(\n+\t\tDiscoveryIssueReporter.collecting(discoveryIssues));\n+\n+\t@Nested\n+\tclass StandaloneTestClasses {\n+\n+\t\t@Test\n+\t\tvoid classWithTestMethodEvaluatesToTrue() {\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(ClassWithTestMethod.class));\n+\t\t\tassertTrue(predicates.isValidStandaloneTestClass(ClassWithTestMethod.class));\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid classWithTestFactoryEvaluatesToTrue() {\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(ClassWithTestFactory.class));\n+\t\t\tassertTrue(predicates.isValidStandaloneTestClass(ClassWithTestFactory.class));\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid classWithTestTemplateEvaluatesToTrue() {\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(ClassWithTestTemplate.class));\n+\t\t\tassertTrue(predicates.isValidStandaloneTestClass(ClassWithTestTemplate.class));\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid classWithNestedTestClassEvaluatesToTrue() {\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(ClassWithNestedTestClass.class));\n+\t\t\tassertTrue(predicates.isValidStandaloneTestClass(ClassWithNestedTestClass.class));\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid staticTestClassEvaluatesToTrue() {\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(TestCases.StaticTestCase.class));\n+\t\t\tassertTrue(predicates.isValidStandaloneTestClass(TestCases.StaticTestCase.class));\n+\t\t}\n+\n+\t\t// -------------------------------------------------------------------------\n+\n+\t\t@Test\n+\t\tvoid abstractClassEvaluatesToFalse() {\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(AbstractClass.class));\n+\t\t\tassertFalse(predicates.isValidStandaloneTestClass(AbstractClass.class));\n+\t\t\tassertThat(discoveryIssues).isEmpty();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid localClassEvaluatesToFalse() {\n+\n+\t\t\t@SuppressWarnings({ \""JUnitMalformedDeclaration\"", \""NewClassNamingConvention\"" })\n+\t\t\tclass LocalClass {\n+\t\t\t\t@SuppressWarnings(\""unused\"")\n+\t\t\t\t@Test\n+\t\t\t\tvoid test() {\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tvar candidate = LocalClass.class;\n+\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(candidate));\n+\t\t\tassertFalse(predicates.isValidStandaloneTestClass(candidate));\n+\n+\t\t\tvar issue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""Test class '%s' must not be a local class. It will not be executed.\"".formatted(candidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tassertThat(discoveryIssues).containsExactly(issue);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid anonymousClassEvaluatesToFalse() {\n+\n+\t\t\tObject object = new Object() {\n+\t\t\t\t@SuppressWarnings(\""unused\"")\n+\t\t\t\t@Test\n+\t\t\t\tvoid test() {\n+\t\t\t\t}\n+\t\t\t};\n+\n+\t\t\tClass<?> candidate = object.getClass();\n+\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(candidate));\n+\t\t\tassertFalse(predicates.isValidStandaloneTestClass(candidate));\n+\n+\t\t\tvar issue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""Test class '%s' must not be anonymous. It will not be executed.\"".formatted(candidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tassertThat(discoveryIssues).containsExactly(issue);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid privateClassWithTestMethodEvaluatesToFalse() {\n+\t\t\tvar candidate = TestCases.PrivateClassWithTestMethod.class;\n+\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(candidate));\n+\t\t\tassertFalse(predicates.isValidStandaloneTestClass(candidate));\n+\n+\t\t\tvar notPrivateIssue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""Test class '%s' must not be private. It will not be executed.\"".formatted(candidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tvar notInnerClassIssue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""Test class '%s' must not be an inner class unless annotated with @Nested. It will not be executed.\"".formatted(\n+\t\t\t\t\tcandidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tassertThat(discoveryIssues).containsExactlyInAnyOrder(notPrivateIssue, notInnerClassIssue);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid privateClassWithTestFactoryEvaluatesToFalse() {\n+\t\t\tvar candidate = TestCases.PrivateClassWithTestFactory.class;\n+\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(candidate));\n+\t\t\tassertFalse(predicates.isValidStandaloneTestClass(candidate));\n+\n+\t\t\tvar notPrivateIssue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""Test class '%s' must not be private. It will not be executed.\"".formatted(candidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tvar notInnerClassIssue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""Test class '%s' must not be an inner class unless annotated with @Nested. It will not be executed.\"".formatted(\n+\t\t\t\t\tcandidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tassertThat(discoveryIssues).containsExactlyInAnyOrder(notPrivateIssue, notInnerClassIssue);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid privateClassWithTestTemplateEvaluatesToFalse() {\n+\t\t\tvar candidate = TestCases.PrivateClassWithTestTemplate.class;\n+\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(candidate));\n+\t\t\tassertFalse(predicates.isValidStandaloneTestClass(candidate));\n+\n+\t\t\tvar notPrivateIssue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""Test class '%s' must not be private. It will not be executed.\"".formatted(candidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tvar notInnerClassIssue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""Test class '%s' must not be an inner class unless annotated with @Nested. It will not be executed.\"".formatted(\n+\t\t\t\t\tcandidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tassertThat(discoveryIssues).containsExactlyInAnyOrder(notPrivateIssue, notInnerClassIssue);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid privateClassWithNestedTestCasesEvaluatesToFalse() {\n+\t\t\tvar candidate = TestCases.PrivateClassWithNestedTestClass.class;\n+\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(candidate));\n+\t\t\tassertFalse(predicates.isValidStandaloneTestClass(candidate));\n+\n+\t\t\tvar notPrivateIssue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""Test class '%s' must not be private. It will not be executed.\"".formatted(candidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tvar notInnerClassIssue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""Test class '%s' must not be an inner class unless annotated with @Nested. It will not be executed.\"".formatted(\n+\t\t\t\t\tcandidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tassertThat(discoveryIssues).containsExactlyInAnyOrder(notPrivateIssue, notInnerClassIssue);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid privateStaticTestClassEvaluatesToFalse() {\n+\t\t\tvar candidate = TestCases.PrivateStaticTestCase.class;\n+\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(candidate));\n+\t\t\tassertFalse(predicates.isValidStandaloneTestClass(candidate));\n+\n+\t\t\tvar notPrivateIssue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""Test class '%s' must not be private. It will not be executed.\"".formatted(candidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tassertThat(discoveryIssues).containsExactly(notPrivateIssue);\n+\t\t}\n+\n+\t\t/*\n+\t\t * see https://github.com/junit-team/junit5/issues/2249\n+\t\t */\n+\t\t@Test\n+\t\tvoid recursiveHierarchies() {\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(TestCases.OuterClass.class));\n+\t\t\tassertTrue(predicates.isValidStandaloneTestClass(TestCases.OuterClass.class));\n+\t\t\tassertThat(discoveryIssues).isEmpty();\n+\n+\t\t\tvar candidate = TestCases.OuterClass.RecursiveInnerClass.class;\n+\n+\t\t\tassertTrue(predicates.looksLikeIntendedTestClass(candidate));\n+\t\t\tassertFalse(predicates.isValidStandaloneTestClass(candidate));\n+\n+\t\t\tvar notInnerClassIssue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""Test class '%s' must not be an inner class unless annotated with @Nested. It will not be executed.\"".formatted(\n+\t\t\t\t\tcandidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tassertThat(discoveryIssues).containsExactly(notInnerClassIssue);\n+\t\t}\n+\n+\t}\n+\n+\t@Nested\n+\tclass NestedTestClasses {\n+\n+\t\t@Test\n+\t\tvoid innerClassEvaluatesToTrue() {\n+\t\t\tvar candidate = TestCases.NestedClassesTestCase.InnerClass.class;\n+\t\t\tassertThat(predicates.isAnnotatedWithNested).accepts(candidate);\n+\t\t\tassertTrue(predicates.isValidNestedTestClass(candidate));\n+\t\t\tassertThat(predicates.isAnnotatedWithNestedAndValid).accepts(candidate);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid staticNestedClassEvaluatesToFalse() {\n+\t\t\tvar candidate = TestCases.NestedClassesTestCase.StaticNestedClass.class;\n+\t\t\tassertThat(predicates.isAnnotatedWithNested).accepts(candidate);\n+\t\t\tassertFalse(predicates.isValidNestedTestClass(candidate));\n+\t\t\tassertThat(predicates.isAnnotatedWithNestedAndValid).rejects(candidate);\n+\n+\t\t\tvar issue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""@Nested class '%s' must not be static. It will not be executed.\"".formatted(candidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tassertThat(discoveryIssues.stream().distinct()).containsExactly(issue);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid topLevelClassEvaluatesToFalse() {\n+\t\t\tvar candidate = InvalidTopLevelNestedTestClass.class;\n+\t\t\tassertThat(predicates.isAnnotatedWithNested).accepts(candidate);\n+\t\t\tassertFalse(predicates.isValidNestedTestClass(candidate));\n+\t\t\tassertThat(predicates.isAnnotatedWithNestedAndValid).rejects(candidate);\n+\n+\t\t\tvar issue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""@Nested class '%s' must not be a top-level class. It will not be executed.\"".formatted(\n+\t\t\t\t\tcandidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tassertThat(discoveryIssues.stream().distinct()).containsExactly(issue);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid privateNestedClassEvaluatesToFalse() {\n+\t\t\tvar candidate = TestCases.NestedClassesTestCase.PrivateInnerClass.class;\n+\t\t\tassertThat(predicates.isAnnotatedWithNested).accepts(candidate);\n+\t\t\tassertFalse(predicates.isValidNestedTestClass(candidate));\n+\t\t\tassertThat(predicates.isAnnotatedWithNestedAndValid).rejects(candidate);\n+\n+\t\t\tvar issue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""@Nested class '%s' must not be private. It will not be executed.\"".formatted(candidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tassertThat(discoveryIssues.stream().distinct()).containsExactly(issue);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid abstractInnerClassEvaluatesToFalse() {\n+\t\t\tvar candidate = TestCases.NestedClassesTestCase.AbstractInnerClass.class;\n+\t\t\tassertThat(predicates.isAnnotatedWithNested).accepts(candidate);\n+\t\t\tassertFalse(predicates.isValidNestedTestClass(candidate));\n+\t\t\tassertThat(predicates.isAnnotatedWithNestedAndValid).rejects(candidate);\n+\t\t\tassertThat(discoveryIssues).isEmpty();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid localClassEvaluatesToFalse() {\n+\n+\t\t\t@Nested\n+\t\t\tclass LocalClass {\n+\t\t\t}\n+\n+\t\t\tvar candidate = LocalClass.class;\n+\n+\t\t\tassertThat(predicates.isAnnotatedWithNested).accepts(candidate);\n+\t\t\tassertFalse(predicates.isValidNestedTestClass(candidate));\n+\t\t\tassertThat(predicates.isAnnotatedWithNestedAndValid).rejects(candidate);\n+\n+\t\t\tvar issue = DiscoveryIssue.builder(Severity.WARNING,\n+\t\t\t\t\""@Nested class '%s' must not be static. It will not be executed.\"".formatted(candidate.getName())) //\n+\t\t\t\t\t.source(ClassSource.from(candidate)) //\n+\t\t\t\t\t.build();\n+\t\t\tassertThat(discoveryIssues.stream().distinct()).containsExactly(issue);\n+\t\t}\n+\t}\n+\n+\t// -------------------------------------------------------------------------\n+\n+\tstatic class TestCases {\n+\n+\t\t@SuppressWarnings({ \""JUnitMalformedDeclaration\"", \""InnerClassMayBeStatic\"" })\n+\t\tprivate class PrivateClassWithTestMethod {\n+\n+\t\t\t@Test\n+\t\t\tvoid test() {\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\t@SuppressWarnings(\""InnerClassMayBeStatic\"")\n+\t\tprivate class PrivateClassWithTestFactory {\n+\n+\t\t\t@TestFactory\n+\t\t\tCollection<DynamicTest> factory() {\n+\t\t\t\treturn new ArrayList<>();\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\t@SuppressWarnings(\""InnerClassMayBeStatic\"")\n+\t\tprivate class PrivateClassWithTestTemplate {\n+\n+\t\t\t@TestTemplate\n+\t\t\tvoid template(int a) {\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\t@SuppressWarnings(\""InnerClassMayBeStatic\"")\n+\t\tprivate class PrivateClassWithNestedTestClass {\n+\n+\t\t\t@Nested\n+\t\t\tclass InnerClass {\n+\n+\t\t\t\t@Test\n+\t\t\t\tvoid first() {\n+\t\t\t\t}\n+\n+\t\t\t\t@Test\n+\t\t\t\tvoid second() {\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\n+\t\t// -------------------------------------------------------------------------\n+\n+\t\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n+\t\tstatic class StaticTestCase {\n+\n+\t\t\t@Test\n+\t\t\tvoid test() {\n+\t\t\t}\n+\t\t}\n+\n+\t\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n+\t\tprivate static class PrivateStaticTestCase {\n+\n+\t\t\t@Test\n+\t\t\tvoid test() {\n+\t\t\t}\n+\t\t}\n+\n+\t\t@SuppressWarnings(\""NewClassNamingConvention\"")\n+\t\tstatic class OuterClass {\n+\n+\t\t\t@Nested\n+\t\t\tclass InnerClass {\n+\n+\t\t\t\t@Test\n+\t\t\t\tvoid test() {\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Intentionally commented out so that RecursiveInnerClass is NOT a candidate test class\n+\t\t\t// @Nested\n+\t\t\t@SuppressWarnings(\""InnerClassMayBeStatic\"")\n+\t\t\tclass RecursiveInnerClass extends OuterClass {\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate static class NestedClassesTestCase {\n+\n+\t\t\t@Nested\n+\t\t\tclass InnerClass {\n+\t\t\t}\n+\n+\t\t\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n+\t\t\t@Nested\n+\t\t\tstatic class StaticNestedClass {\n+\t\t\t}\n+\n+\t\t\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n+\t\t\t@Nested\n+\t\t\tprivate class PrivateInnerClass {\n+\t\t\t}\n+\n+\t\t\t@Nested\n+\t\t\tprivate abstract class AbstractInnerClass {\n+\t\t\t}\n+\n+\t\t}\n+\t}\n+\n+}\n+\n+// -----------------------------------------------------------------------------\n+\n+abstract class AbstractClass {\n+\t@SuppressWarnings(\""unused\"")\n+\t@Test\n+\tvoid test() {\n+\t}\n+}\n+\n+@SuppressWarnings(\""NewClassNamingConvention\"")\n+class ClassWithTestMethod {\n+\n+\t@Test\n+\tvoid test() {\n+\t}\n+\n+}\n+\n+@SuppressWarnings(\""NewClassNamingConvention\"")\n+class ClassWithTestFactory {\n+\n+\t@TestFactory\n+\tCollection<DynamicTest> factory() {\n+\t\treturn new ArrayList<>();\n+\t}\n+\n+}\n+\n+@SuppressWarnings(\""NewClassNamingConvention\"")\n+class ClassWithTestTemplate {\n+\n+\t@TestTemplate\n+\tvoid template(int a) {\n+\t}\n+\n+}\n+\n+@SuppressWarnings(\""NewClassNamingConvention\"")\n+class ClassWithNestedTestClass {\n+\n+\t@Nested\n+\tclass InnerClass {\n+\n+\t\t@Test\n+\t\tvoid first() {\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid second() {\n+\t\t}\n+\n+\t}\n+}\n+\n+@SuppressWarnings(\""NewClassNamingConvention\"")\n+@Nested\n+class InvalidTopLevelNestedTestClass {\n+\t@Test\n+\tvoid test() {\n+\t}\n+}\n\ndiff --git a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java\nindex 5c7fea2a0f1a..11c2259b28a1 100644\n--- a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java\n+++ b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java\n@@ -1036,24 +1036,43 @@ void findNestedClassesPreconditions() {\n \t\t\t// @formatter:on\n \t\t}\n \n+\t\t@Test\n+\t\tvoid isNestedClassPresentPreconditions() {\n+\t\t\t// @formatter:off\n+\t\t\tassertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(null, null));\n+\t\t\tassertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(null, clazz -> true));\n+\t\t\tassertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(getClass(), null));\n+\t\t\t// @formatter:on\n+\t\t}\n+\n \t\t@Test\n \t\tvoid findNestedClasses() {\n \t\t\t// @formatter:off\n \t\t\tassertThat(findNestedClasses(Object.class)).isEmpty();\n+\t\t\tassertThat(isNestedClassPresent(Object.class)).isFalse();\n \n \t\t\tassertThat(findNestedClasses(ClassWithNestedClasses.class))\n \t\t\t\t\t.containsOnly(Nested1.class, Nested2.class, Nested3.class);\n+\t\t\tassertThat(isNestedClassPresent(ClassWithNestedClasses.class))\n+\t\t\t\t\t.isTrue();\n \n \t\t\tassertThat(ReflectionUtils.findNestedClasses(ClassWithNestedClasses.class, clazz -> clazz.getName().contains(\""1\"")))\n \t\t\t\t\t.containsExactly(Nested1.class);\n+\t\t\tassertThat(ReflectionUtils.isNestedClassPresent(ClassWithNestedClasses.class, clazz -> clazz.getName().contains(\""1\"")))\n+\t\t\t\t\t.isTrue();\n \n \t\t\tassertThat(ReflectionUtils.findNestedClasses(ClassWithNestedClasses.class, ReflectionUtils::isStatic))\n \t\t\t\t\t.containsExactly(Nested3.class);\n+\t\t\tassertThat(ReflectionUtils.isNestedClassPresent(ClassWithNestedClasses.class, ReflectionUtils::isStatic))\n+\t\t\t\t\t.isTrue();\n \n \t\t\tassertThat(findNestedClasses(ClassExtendingClassWithNestedClasses.class))\n \t\t\t\t\t.containsOnly(Nested1.class, Nested2.class, Nested3.class, Nested4.class, Nested5.class);\n+\t\t\tassertThat(isNestedClassPresent(ClassExtendingClassWithNestedClasses.class))\n+\t\t\t\t\t.isTrue();\n \n \t\t\tassertThat(findNestedClasses(ClassWithNestedClasses.Nested1.class)).isEmpty();\n+\t\t\tassertThat(isNestedClassPresent(ClassWithNestedClasses.Nested1.class)).isFalse();\n \t\t\t// @formatter:on\n \t\t}\n \n@@ -1064,26 +1083,39 @@ void findNestedClasses() {\n \t\tvoid findNestedClassesWithSeeminglyRecursiveHierarchies() {\n \t\t\tassertThat(findNestedClasses(AbstractOuterClass.class))//\n \t\t\t\t\t.containsExactly(AbstractOuterClass.InnerClass.class);\n+\t\t\tassertThat(isNestedClassPresent(AbstractOuterClass.class))//\n+\t\t\t\t\t.isTrue();\n \n \t\t\t// OuterClass contains recursive hierarchies, but the non-matching\n \t\t\t// predicate should prevent cycle detection.\n \t\t\t// See https://github.com/junit-team/junit5/issues/2249\n \t\t\tassertThat(ReflectionUtils.findNestedClasses(OuterClass.class, clazz -> false)).isEmpty();\n+\t\t\tassertThat(ReflectionUtils.isNestedClassPresent(OuterClass.class, clazz -> false)).isFalse();\n+\n \t\t\t// RecursiveInnerInnerClass is part of a recursive hierarchy, but the non-matching\n \t\t\t// predicate should prevent cycle detection.\n \t\t\tassertThat(ReflectionUtils.findNestedClasses(RecursiveInnerInnerClass.class, clazz -> false)).isEmpty();\n+\t\t\tassertThat(ReflectionUtils.isNestedClassPresent(RecursiveInnerInnerClass.class, clazz -> false)).isFalse();\n \n \t\t\t// Sibling types don't actually result in cycles.\n \t\t\tassertThat(findNestedClasses(StaticNestedSiblingClass.class))//\n \t\t\t\t\t.containsExactly(AbstractOuterClass.InnerClass.class);\n+\t\t\tassertThat(isNestedClassPresent(StaticNestedSiblingClass.class))//\n+\t\t\t\t\t.isTrue();\n \t\t\tassertThat(findNestedClasses(InnerSiblingClass.class))//\n \t\t\t\t\t.containsExactly(AbstractOuterClass.InnerClass.class);\n+\t\t\tassertThat(isNestedClassPresent(InnerSiblingClass.class))//\n+\t\t\t\t\t.isTrue();\n \n \t\t\t// Interfaces with static nested classes\n \t\t\tassertThat(findNestedClasses(OuterClassImplementingInterface.class))//\n \t\t\t\t\t.containsExactly(InnerClassImplementingInterface.class, Nested4.class);\n+\t\t\tassertThat(isNestedClassPresent(OuterClassImplementingInterface.class))//\n+\t\t\t\t\t.isTrue();\n \t\t\tassertThat(findNestedClasses(InnerClassImplementingInterface.class))//\n \t\t\t\t\t.containsExactly(Nested4.class);\n+\t\t\tassertThat(isNestedClassPresent(InnerClassImplementingInterface.class))//\n+\t\t\t\t\t.isTrue();\n \t\t}\n \n \t\t/**\n@@ -1105,6 +1137,10 @@ private static List<Class<?>> findNestedClasses(Class<?> clazz) {\n \t\t\treturn ReflectionUtils.findNestedClasses(clazz, c -> true);\n \t\t}\n \n+\t\tprivate static boolean isNestedClassPresent(Class<?> clazz) {\n+\t\t\treturn ReflectionUtils.isNestedClassPresent(clazz, c -> true);\n+\t\t}\n+\n \t\tprivate void assertNestedCycle(Class<?> from, Class<?> to) {\n \t\t\tassertNestedCycle(from, from, to);\n \t\t}\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""junit-team__junit5-4429"", ""pr_id"": 4429, ""issue_id"": 242, ""repo"": ""junit-team/junit5"", ""problem_statement"": ""Introduce error handling mechanism for validation and discovery errors\n## Overview\n\nThe JUnit Platform currently provides no means to report warnings and errors during test discovery. Thus, malformed test cases (for example, Jupiter test methods with a non-void return type) get silently ignored which poses a severe risk for downstream projects: something that looks like a test in a pull request diff might not actually get executed. Therefore, we should introduce a mechanism to collect and report warnings and errors and use it for the Jupiter and Vintage engines. In addition, we should reach out to third-party test engine open source projects and ask them to adopt the new mechanism.\n\nValidation errors (e.g., for invalid `@BeforeEach` method declarations) should not abort the entire discovery phase. Instead the _discovery phase_ should continue, with the error tracked and reported during the _execution phase_. \n\n## Areas of Applicability\n\n- [x] exceptions thrown by test engines, as discussed in #750\n- [x] unresolvable unique IDs, as discussed in #210\n  - note, however, that a TestEngine should not report a unique ID as unresolvable if the unique ID does not apply to the particular TestEngine (see #1026 ).\n- [x] invalid `@BeforeAll`, `@AfterAll`, `@BeforeEach`, and `@AfterEach` method declarations\n- [x] [Competing method-level annotations](https://github.com/marcphilipp/junit5/blob/202d939953a2fa61f54a1b0c70e74e122740a427/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java#L99-L108) (e.g. `@Test` _and_ `@TestTemplate` on the same method)\n- [x] invalid `@Test`, `@TestFactory`, `@RepeatedTest`, and `@ParameterizedTest` method declarations (see #2244)\n- [x] invalid `@Suite` class declarations\n- [x] invalid `@Nested` test class declarations (see #1223 and #2717)\n- [x] non-static test class declaration (see #2311)\n- [x] missing `@Nested` annotation (see #1736)\n- [x] _blank_ display names supplied by the user, as discussed in #743\n- [x] `@Order` annotations on test classes and methods when class/method orderer is not `OrderAnnotation`\n\n## Proposals\n\n1. Allow engines to track errors by creating a special type of `TestDescriptor` such as an `AlwaysFailingTestDescriptor`, `DeadOnArrivalTestDescriptor`, or `ErrorReportingTestDescriptor`.\n    - Tracked errors for such a corresponding `TestDescriptor` could then be thrown as an exception during the execution phase instead of executing the corresponding container or test.\n2. Introduce a new property in `TestDescriptor` that signals an error that was encountered during the _discovery phase_.\n3. Pass a _reporting object_ from the `Launcher` into each `TestEngine` to report errors.\n    - See https://github.com/junit-team/junit5/issues/242#issuecomment-294301875\n\n## Related Issues\n\n- #121 \n- #210 \n- #743 \n- #750 \n- #835\n- #876  \n- #971 \n- #1026 \n- #1074 \n- #1223\n- #1944\n- #2244\n- #2311\n- #2717\n- #4125\n\n## Deliverables\n\n- [x] #4385\n- [x] #4389\n- [x] #4393\n- [x] #4398\n- [x] Revisit the changes made in #971 and determine if it makes sense to move the look-up of lifecycle methods back to the constructor of `ClassTestDescriptor`.\n- [x] #4401\n- [x] #4405\n- [x] #4408\n- [x] #4415\n- [x] #4420\n- [x] Revisit the results of #835 and update the code accordingly by tracking such errors instead of just ignoring such incorrect usage.\n- [x] #4423\n- [x] #949\n- [x] #4429\n- [x] #4448\n- [x] #1736\n- [x] #4453\n- [x] #4456\n- [x] #4458\n- [x] #4459\n- [x] Use the new mechanism to replace the current ad hoc use of logging and transparent defaulting as a work-around.\n  - Search for `TODO [#242]` within the code base.\n  - See https://github.com/junit-team/junit5/issues/750#issuecomment-294296045\n- [x] Determine where else the new mechanism can be used and apply it.\n- [x] #4463\n- [x] #4465\n- [x] Reach out to third-party test engine authors and ask them to adopt the new mechanism\n\t- https://github.com/spockframework/spock/issues/2145\n\t- https://github.com/cucumber/cucumber-jvm/issues/2987"", ""issue_word_count"": 584, ""test_files_count"": 16, ""non_test_files_count"": 8, ""pr_changed_files"": [""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestableMethod.java"", ""junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java"", ""junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/DiscoveryIssueReporter.java"", ""junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java"", ""junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/ClassSelectorResolver.java"", ""junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/DiscoverySelectorResolver.java"", ""junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/IsPotentialTestContainer.java"", ""junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/IsSuiteClass.java"", ""junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/LifecycleMethodUtils.java"", ""junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/SuiteTestDescriptor.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtilsTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethodTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethodTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestTemplateMethodTests.java"", ""platform-tests/src/test/java/org/junit/platform/engine/DiscoveryIssueTests.java"", ""platform-tests/src/test/java/org/junit/platform/suite/engine/SuiteEngineTests.java"", ""platform-tests/src/test/java/org/junit/platform/suite/engine/SuiteTestDescriptorTests.java"", ""platform-tests/src/test/java/org/junit/platform/suite/engine/testcases/ErroneousTestCase.java"", ""platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/ErroneousTestSuite.java"", ""platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/InheritedSuite.java"", ""platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/SuiteWithErroneousTestSuite.java""], ""pr_changed_test_files"": [""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestableMethod.java"", ""junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/IsPotentialTestContainer.java"", ""junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/SuiteTestDescriptor.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtilsTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethodTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethodTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestTemplateMethodTests.java"", ""platform-tests/src/test/java/org/junit/platform/engine/DiscoveryIssueTests.java"", ""platform-tests/src/test/java/org/junit/platform/suite/engine/SuiteEngineTests.java"", ""platform-tests/src/test/java/org/junit/platform/suite/engine/SuiteTestDescriptorTests.java"", ""platform-tests/src/test/java/org/junit/platform/suite/engine/testcases/ErroneousTestCase.java"", ""platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/ErroneousTestSuite.java"", ""platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/InheritedSuite.java"", ""platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/SuiteWithErroneousTestSuite.java""], ""base_commit"": ""6592d4b7cf01ace46948b082b596843d68c71ba3"", ""head_commit"": ""5615e0bc7c2238fc7c03fb4a61a75c3de2b5626b"", ""repo_url"": ""https://github.com/junit-team/junit5/pull/4429"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/junit-team__junit5/4429"", ""dockerfile"": """", ""pr_merged_at"": ""2025-03-31T12:51:45.000Z"", ""patch"": ""diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java\nindex 571d90522aaa..8d629e82fbf4 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java\n@@ -13,6 +13,7 @@\n import static org.junit.platform.commons.support.AnnotationSupport.findAnnotatedMethods;\n import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n import static org.junit.platform.commons.util.CollectionUtils.toUnmodifiableList;\n+import static org.junit.platform.engine.support.discovery.DiscoveryIssueReporter.Condition.alwaysSatisfied;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Method;\n@@ -93,8 +94,8 @@ static void validateClassTemplateInvocationLifecycleMethodsAreDeclaredCorrectly(\n \t\t\t\t\t\t.and(requireStatic\n \t\t\t\t\t\t\t\t? isStatic(issueReporter,\n \t\t\t\t\t\t\t\t\tLifecycleMethodUtils::classTemplateInvocationLifecycleMethodAnnotationName)\n-\t\t\t\t\t\t\t\t: __ -> true) //\n-\t\t\t\t);\n+\t\t\t\t\t\t\t\t: alwaysSatisfied()) //\n+\t\t\t\t\t\t.toConsumer());\n \t}\n \n \tprivate static Stream<Method> findAllClassTemplateInvocationLifecycleMethods(Class<?> testClass) {\n@@ -113,7 +114,7 @@ private static List<Method> findMethodsAndCheckStatic(Class<?> testClass, boolea\n \n \t\tCondition<Method> additionalCondition = requireStatic\n \t\t\t\t? isStatic(issueReporter, __ -> annotationType.getSimpleName())\n-\t\t\t\t: __ -> true;\n+\t\t\t\t: alwaysSatisfied();\n \t\treturn findMethodsAndCheckVoidReturnType(testClass, annotationType, traversalMode, issueReporter,\n \t\t\tadditionalCondition);\n \t}\n@@ -131,9 +132,9 @@ private static List<Method> findMethodsAndCheckVoidReturnType(Class<?> testClass\n \t\t\tDiscoveryIssueReporter issueReporter, Condition<? super Method> additionalCondition) {\n \n \t\treturn findAnnotatedMethods(testClass, annotationType, traversalMode).stream() //\n-\t\t\t\t.peek(isNotPrivateWarning(issueReporter, annotationType::getSimpleName)) //\n-\t\t\t\t.filter(\n-\t\t\t\t\treturnsPrimitiveVoid(issueReporter, __ -> annotationType.getSimpleName()).and(additionalCondition)) //\n+\t\t\t\t.peek(isNotPrivateWarning(issueReporter, annotationType::getSimpleName).toConsumer()) //\n+\t\t\t\t.filter(returnsPrimitiveVoid(issueReporter, __ -> annotationType.getSimpleName()).and(\n+\t\t\t\t\tadditionalCondition).toPredicate()) //\n \t\t\t\t.collect(toUnmodifiableList());\n \t}\n \n\ndiff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java\nindex 4c9775583f45..90c81d4d3b9c 100644\n--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java\n+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java\n@@ -13,8 +13,10 @@\n import static org.apiguardian.api.API.Status.EXPERIMENTAL;\n \n import java.util.Optional;\n+import java.util.function.UnaryOperator;\n \n import org.apiguardian.api.API;\n+import org.junit.platform.commons.util.Preconditions;\n \n /**\n  * {@code DiscoveryIssue} represents an issue that was encountered during test\n@@ -29,6 +31,8 @@ public interface DiscoveryIssue {\n \t * Create a new {@code DiscoveryIssue} with the supplied {@link Severity} and\n \t * message.\n \t *\n+\t * @param severity the severity of the issue; never {@code null}\n+\t * @param message the message of the issue; never blank\n \t * @see #builder(Severity, String)\n \t */\n \tstatic DiscoveryIssue create(Severity severity, String message) {\n@@ -39,10 +43,14 @@ static DiscoveryIssue create(Severity severity, String message) {\n \t * Create a new {@link Builder} for creating a {@code DiscoveryIssue} with\n \t * the supplied {@link Severity} and message.\n \t *\n+\t * @param severity the severity of the issue; never {@code null}\n+\t * @param message the message of the issue; never blank\n \t * @see Builder\n \t * @see #create(Severity, String)\n \t */\n \tstatic Builder builder(Severity severity, String message) {\n+\t\tPreconditions.notNull(severity, \""severity must not be null\"");\n+\t\tPreconditions.notBlank(message, \""message must not be blank\"");\n \t\treturn new DefaultDiscoveryIssue.Builder(severity, message);\n \t}\n \n@@ -66,6 +74,22 @@ static Builder builder(Severity severity, String message) {\n \t */\n \tOptional<Throwable> cause();\n \n+\t/**\n+\t * Create a copy of this issue with the modified message produced by the\n+\t * supplied operator.\n+\t */\n+\tdefault DiscoveryIssue withMessage(UnaryOperator<String> messageModifier) {\n+\t\tString oldMessage = message();\n+\t\tString newMessage = messageModifier.apply(oldMessage);\n+\t\tif (oldMessage.equals(newMessage)) {\n+\t\t\treturn this;\n+\t\t}\n+\t\treturn DiscoveryIssue.builder(severity(), newMessage) //\n+\t\t\t\t.source(source()) //\n+\t\t\t\t.cause(cause()) //\n+\t\t\t\t.build();\n+\t}\n+\n \t/**\n \t * The severity of a {@code DiscoveryIssue}.\n \t */\n\ndiff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/DiscoveryIssueReporter.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/DiscoveryIssueReporter.java\nindex f7813149d35a..a2e4b1bbf388 100644\n--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/DiscoveryIssueReporter.java\n+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/DiscoveryIssueReporter.java\n@@ -12,6 +12,7 @@\n \n import static org.apiguardian.api.API.Status.EXPERIMENTAL;\n \n+import java.util.Collection;\n import java.util.HashSet;\n import java.util.Set;\n import java.util.function.Consumer;\n@@ -28,11 +29,12 @@\n  * {@code DiscoveryIssueReporter} defines the API for reporting\n  * {@link DiscoveryIssue DiscoveryIssues}.\n  *\n+ * <p>This interface is not intended to be implemented by clients.\n+ *\n  * @since 1.13\n  * @see SelectorResolver.Context\n  */\n @API(status = EXPERIMENTAL, since = \""1.13\"")\n-@FunctionalInterface\n public interface DiscoveryIssueReporter {\n \n \t/**\n@@ -49,6 +51,28 @@ static DiscoveryIssueReporter forwarding(EngineDiscoveryListener engineDiscovery\n \t\treturn issue -> engineDiscoveryListener.issueEncountered(engineId, issue);\n \t}\n \n+\t/**\n+\t * Create a new {@code DiscoveryIssueReporter} that adds reported issues to\n+\t * the supplied collection.\n+\t *\n+\t * @param collection the collection to add issues to; never {@code null}\n+\t */\n+\tstatic DiscoveryIssueReporter collecting(Collection<? super DiscoveryIssue> collection) {\n+\t\tPreconditions.notNull(collection, \""collection must not be null\"");\n+\t\treturn collection::add;\n+\t}\n+\n+\t/**\n+\t * Create a new {@code DiscoveryIssueReporter} that adds reported issues to\n+\t * the supplied consumer.\n+\t *\n+\t * @param consumer the consumer to report issues to; never {@code null}\n+\t */\n+\tstatic DiscoveryIssueReporter consuming(Consumer<? super DiscoveryIssue> consumer) {\n+\t\tPreconditions.notNull(consumer, \""consumer must not be null\"");\n+\t\treturn consumer::accept;\n+\t}\n+\n \t/**\n \t * Create a new {@code DiscoveryIssueReporter} that avoids reporting\n \t * duplicate issues.\n@@ -113,10 +137,23 @@ default <T> Condition<T> createReportingCondition(Predicate<T> predicate,\n \t * for filtering, or to {@link java.util.stream.Stream#peek(Consumer)} if it\n \t * is only used for reporting or other side effects.\n \t *\n+\t * <p>This interface is not intended to be implemented by clients.\n+\t *\n \t * @see #createReportingCondition(Predicate, Function)\n \t */\n-\t@FunctionalInterface\n-\tinterface Condition<T> extends Predicate<T>, Consumer<T> {\n+\tinterface Condition<T> {\n+\n+\t\t/**\n+\t\t * Create a {@link Condition} that is always satisfied.\n+\t\t */\n+\t\tstatic <T> Condition<T> alwaysSatisfied() {\n+\t\t\treturn __ -> true;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Evaluate this condition to potentially report an issue.\n+\t\t */\n+\t\tboolean check(T value);\n \n \t\t/**\n \t\t * Return a composed condition that represents a logical AND of this\n@@ -128,35 +165,24 @@ interface Condition<T> extends Predicate<T>, Consumer<T> {\n \t\t *\n \t\t * @return the composed condition; never {@code null}\n \t\t */\n-\t\t@Override\n-\t\tdefault Condition<T> and(Predicate<? super T> other) {\n-\t\t\tPreconditions.notNull(other, \""other condition must not be null\"");\n-\t\t\treturn (t) -> test(t) & other.test(t);\n+\t\tdefault Condition<T> and(Condition<? super T> that) {\n+\t\t\tPreconditions.notNull(that, \""condition must not be null\"");\n+\t\t\treturn value -> this.check(value) & that.check(value);\n \t\t}\n \n \t\t/**\n-\t\t * Return a composed condition that represents a logical AND of this\n-\t\t * and the supplied condition.\n-\t\t *\n-\t\t * <p>The default implementation avoids short-circuiting so\n-\t\t * <em>both</em> conditions will be evaluated even if this condition\n-\t\t * returns {@code true} to ensure that all issues are reported.\n-\t\t *\n-\t\t * @return the composed condition; never {@code null}\n+\t\t * {@return this condition as a {@link Predicate}}\n \t\t */\n-\t\t@Override\n-\t\tdefault Predicate<T> or(Predicate<? super T> other) {\n-\t\t\tPreconditions.notNull(other, \""other condition must not be null\"");\n-\t\t\treturn (t) -> test(t) | other.test(t);\n+\t\tdefault Predicate<T> toPredicate() {\n+\t\t\treturn this::check;\n \t\t}\n \n \t\t/**\n-\t\t * Evaluate the {@code #test(Object)} method of this condition to\n-\t\t * potentially report an issue.\n+\t\t * {@return this condition as a {@link Consumer}}\n \t\t */\n-\t\t@Override\n-\t\tdefault void accept(T value) {\n-\t\t\ttest(value);\n+\t\tdefault Consumer<T> toConsumer() {\n+\t\t\treturn this::check;\n \t\t}\n+\n \t}\n }\n\ndiff --git a/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java b/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java\nindex ccee1edb4eb8..79e8ef209728 100644\n--- a/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java\n+++ b/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java\n@@ -11,6 +11,7 @@\n package org.junit.platform.suite.commons;\n \n import static java.util.stream.Collectors.toList;\n+import static org.apiguardian.api.API.Status.INTERNAL;\n import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n import static org.junit.platform.commons.support.AnnotationSupport.findRepeatableAnnotations;\n import static org.junit.platform.engine.discovery.ClassNameFilter.STANDARD_INCLUDE_PATTERN;\n@@ -30,7 +31,6 @@\n import java.util.stream.Stream;\n \n import org.apiguardian.api.API;\n-import org.apiguardian.api.API.Status;\n import org.junit.platform.commons.util.Preconditions;\n import org.junit.platform.commons.util.StringUtils;\n import org.junit.platform.engine.ConfigurationParameters;\n@@ -43,6 +43,7 @@\n import org.junit.platform.engine.discovery.PackageNameFilter;\n import org.junit.platform.engine.reporting.OutputDirectoryProvider;\n import org.junit.platform.launcher.EngineFilter;\n+import org.junit.platform.launcher.LauncherDiscoveryListener;\n import org.junit.platform.launcher.LauncherDiscoveryRequest;\n import org.junit.platform.launcher.TagFilter;\n import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;\n@@ -111,8 +112,7 @@\n  * @see org.junit.platform.launcher.EngineFilter\n  * @see org.junit.platform.launcher.TagFilter\n  */\n-@API(status = Status.INTERNAL, since = \""1.8\"", consumers = { \""org.junit.platform.suite.engine\"",\n-\t\t\""org.junit.platform.runner\"" })\n+@API(status = INTERNAL, since = \""1.8\"", consumers = { \""org.junit.platform.suite.engine\"", \""org.junit.platform.runner\"" })\n public final class SuiteLauncherDiscoveryRequestBuilder {\n \n \tprivate final LauncherDiscoveryRequestBuilder delegate = LauncherDiscoveryRequestBuilder.request();\n@@ -268,6 +268,12 @@ public SuiteLauncherDiscoveryRequestBuilder outputDirectoryProvider(\n \t\treturn this;\n \t}\n \n+\t@API(status = INTERNAL, since = \""1.13\"")\n+\tpublic SuiteLauncherDiscoveryRequestBuilder listener(LauncherDiscoveryListener listener) {\n+\t\tdelegate.listeners(listener);\n+\t\treturn this;\n+\t}\n+\n \t/**\n \t * Apply a suite's annotation-based configuration, selectors, and filters to\n \t * this builder.\n\ndiff --git a/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/ClassSelectorResolver.java b/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/ClassSelectorResolver.java\nindex 20289f336e5c..9694f15c9860 100644\n--- a/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/ClassSelectorResolver.java\n+++ b/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/ClassSelectorResolver.java\n@@ -16,16 +16,18 @@\n import java.util.Optional;\n import java.util.function.Predicate;\n \n-import org.junit.platform.commons.logging.Logger;\n-import org.junit.platform.commons.logging.LoggerFactory;\n import org.junit.platform.commons.support.ReflectionSupport;\n import org.junit.platform.engine.ConfigurationParameters;\n+import org.junit.platform.engine.DiscoveryIssue;\n+import org.junit.platform.engine.DiscoveryIssue.Severity;\n+import org.junit.platform.engine.EngineDiscoveryListener;\n import org.junit.platform.engine.TestDescriptor;\n import org.junit.platform.engine.UniqueId;\n import org.junit.platform.engine.UniqueId.Segment;\n import org.junit.platform.engine.discovery.ClassSelector;\n import org.junit.platform.engine.discovery.UniqueIdSelector;\n import org.junit.platform.engine.reporting.OutputDirectoryProvider;\n+import org.junit.platform.engine.support.descriptor.ClassSource;\n import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n import org.junit.platform.engine.support.discovery.SelectorResolver;\n \n@@ -34,23 +36,24 @@\n  */\n final class ClassSelectorResolver implements SelectorResolver {\n \n-\tprivate static final Logger log = LoggerFactory.getLogger(ClassSelectorResolver.class);\n-\n-\tprivate static final IsSuiteClass isSuiteClass = new IsSuiteClass();\n-\n+\tprivate final IsSuiteClass isSuiteClass;\n \tprivate final Predicate<String> classNameFilter;\n \tprivate final SuiteEngineDescriptor suiteEngineDescriptor;\n \tprivate final ConfigurationParameters configurationParameters;\n \tprivate final OutputDirectoryProvider outputDirectoryProvider;\n+\tprivate final EngineDiscoveryListener discoveryListener;\n \tprivate final DiscoveryIssueReporter issueReporter;\n \n \tClassSelectorResolver(Predicate<String> classNameFilter, SuiteEngineDescriptor suiteEngineDescriptor,\n \t\t\tConfigurationParameters configurationParameters, OutputDirectoryProvider outputDirectoryProvider,\n-\t\t\tDiscoveryIssueReporter issueReporter) {\n+\t\t\tEngineDiscoveryListener discoveryListener, DiscoveryIssueReporter issueReporter) {\n+\n+\t\tthis.isSuiteClass = new IsSuiteClass(issueReporter);\n \t\tthis.classNameFilter = classNameFilter;\n \t\tthis.suiteEngineDescriptor = suiteEngineDescriptor;\n \t\tthis.configurationParameters = configurationParameters;\n \t\tthis.outputDirectoryProvider = outputDirectoryProvider;\n+\t\tthis.discoveryListener = discoveryListener;\n \t\tthis.issueReporter = issueReporter;\n \t}\n \n@@ -106,12 +109,14 @@ private static Resolution toResolution(Optional<SuiteTestDescriptor> suite) {\n \tprivate Optional<SuiteTestDescriptor> newSuiteDescriptor(Class<?> suiteClass, TestDescriptor parent) {\n \t\tUniqueId id = parent.getUniqueId().append(SuiteTestDescriptor.SEGMENT_TYPE, suiteClass.getName());\n \t\tif (containsCycle(id)) {\n-\t\t\tlog.config(() -> createConfigContainsCycleMessage(suiteClass, id));\n+\t\t\tissueReporter.reportIssue(\n+\t\t\t\tDiscoveryIssue.builder(Severity.INFO, createConfigContainsCycleMessage(suiteClass, id)) //\n+\t\t\t\t\t\t.source(ClassSource.from(suiteClass)));\n \t\t\treturn Optional.empty();\n \t\t}\n \n-\t\treturn Optional.of(\n-\t\t\tnew SuiteTestDescriptor(id, suiteClass, configurationParameters, outputDirectoryProvider, issueReporter));\n+\t\treturn Optional.of(new SuiteTestDescriptor(id, suiteClass, configurationParameters, outputDirectoryProvider,\n+\t\t\tdiscoveryListener, issueReporter));\n \t}\n \n \tprivate static boolean containsCycle(UniqueId id) {\n\ndiff --git a/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/DiscoverySelectorResolver.java b/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/DiscoverySelectorResolver.java\nindex 0c7aead14921..871bf6e7d3d7 100644\n--- a/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/DiscoverySelectorResolver.java\n+++ b/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/DiscoverySelectorResolver.java\n@@ -12,6 +12,7 @@\n \n import org.junit.platform.engine.EngineDiscoveryRequest;\n import org.junit.platform.engine.TestDescriptor;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n import org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver;\n \n /**\n@@ -21,12 +22,13 @@ final class DiscoverySelectorResolver {\n \n \t// @formatter:off\n \tprivate static final EngineDiscoveryRequestResolver<SuiteEngineDescriptor> resolver = EngineDiscoveryRequestResolver.<SuiteEngineDescriptor>builder()\n-\t\t\t.addClassContainerSelectorResolver(new IsSuiteClass())\n+\t\t\t.addClassContainerSelectorResolverWithContext(context -> new IsSuiteClass(context.getIssueReporter()))\n \t\t\t.addSelectorResolver(context -> new ClassSelectorResolver(\n \t\t\t\t\tcontext.getClassNameFilter(),\n \t\t\t\t\tcontext.getEngineDescriptor(),\n \t\t\t\t\tcontext.getDiscoveryRequest().getConfigurationParameters(),\n \t\t\t\t\tcontext.getDiscoveryRequest().getOutputDirectoryProvider(),\n+\t\t\t\t\tcontext.getDiscoveryRequest().getDiscoveryListener(),\n \t\t\t\t\tcontext.getIssueReporter()))\n \t\t\t.build();\n \t// @formatter:on\n@@ -40,7 +42,9 @@ private static void discoverSuites(SuiteEngineDescriptor engineDescriptor) {\n \t}\n \n \tvoid resolveSelectors(EngineDiscoveryRequest request, SuiteEngineDescriptor engineDescriptor) {\n-\t\tresolver.resolve(request, engineDescriptor);\n+\t\tDiscoveryIssueReporter issueReporter = DiscoveryIssueReporter.deduplicating(\n+\t\t\tDiscoveryIssueReporter.forwarding(request.getDiscoveryListener(), engineDescriptor.getUniqueId()));\n+\t\tresolver.resolve(request, engineDescriptor, issueReporter);\n \t\tdiscoverSuites(engineDescriptor);\n \t\tengineDescriptor.accept(TestDescriptor::prune);\n \t}\n\ndiff --git a/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/IsSuiteClass.java b/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/IsSuiteClass.java\nindex 97947eefc831..dd5738be8df9 100644\n--- a/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/IsSuiteClass.java\n+++ b/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/IsSuiteClass.java\n@@ -10,9 +10,18 @@\n \n package org.junit.platform.suite.engine;\n \n+import static org.junit.platform.commons.support.ModifierSupport.isAbstract;\n+import static org.junit.platform.commons.support.ModifierSupport.isNotAbstract;\n+import static org.junit.platform.commons.support.ModifierSupport.isNotPrivate;\n+\n import java.util.function.Predicate;\n \n import org.junit.platform.commons.support.AnnotationSupport;\n+import org.junit.platform.commons.util.ReflectionUtils;\n+import org.junit.platform.engine.DiscoveryIssue;\n+import org.junit.platform.engine.support.descriptor.ClassSource;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter.Condition;\n import org.junit.platform.suite.api.Suite;\n \n /**\n@@ -20,15 +29,46 @@\n  */\n final class IsSuiteClass implements Predicate<Class<?>> {\n \n-\tprivate static final IsPotentialTestContainer isPotentialTestContainer = new IsPotentialTestContainer();\n+\tprivate final Condition<Class<?>> condition;\n+\n+\tIsSuiteClass(DiscoveryIssueReporter issueReporter) {\n+\t\tthis.condition = isNotPrivateUnlessAbstract(issueReporter) //\n+\t\t\t\t.and(isNotLocal(issueReporter)) //\n+\t\t\t\t.and(isNotInner(issueReporter));\n+\t}\n \n \t@Override\n \tpublic boolean test(Class<?> testClass) {\n-\t\treturn isPotentialTestContainer.test(testClass) && hasSuiteAnnotation(testClass);\n+\t\treturn hasSuiteAnnotation(testClass) //\n+\t\t\t\t&& condition.check(testClass) //\n+\t\t\t\t&& isNotAbstract(testClass);\n \t}\n \n \tprivate boolean hasSuiteAnnotation(Class<?> testClass) {\n \t\treturn AnnotationSupport.isAnnotated(testClass, Suite.class);\n \t}\n \n+\tprivate static Condition<Class<?>> isNotPrivateUnlessAbstract(DiscoveryIssueReporter issueReporter) {\n+\t\t// Allow abstract test classes to be private because @Suite is inherited and subclasses may widen access.\n+\t\treturn issueReporter.createReportingCondition(testClass -> isNotPrivate(testClass) || isAbstract(testClass),\n+\t\t\ttestClass -> createIssue(testClass, \""must not be private.\""));\n+\t}\n+\n+\tprivate static Condition<Class<?>> isNotLocal(DiscoveryIssueReporter issueReporter) {\n+\t\treturn issueReporter.createReportingCondition(testClass -> !testClass.isLocalClass(),\n+\t\t\ttestClass -> createIssue(testClass, \""must not be a local class.\""));\n+\t}\n+\n+\tprivate static Condition<Class<?>> isNotInner(DiscoveryIssueReporter issueReporter) {\n+\t\treturn issueReporter.createReportingCondition(testClass -> !ReflectionUtils.isInnerClass(testClass),\n+\t\t\ttestClass -> createIssue(testClass, \""must not be an inner class. Did you forget to declare it static?\""));\n+\t}\n+\n+\tprivate static DiscoveryIssue createIssue(Class<?> testClass, String detailMessage) {\n+\t\tString message = String.format(\""@Suite class '%s' %s\"", testClass.getName(), detailMessage);\n+\t\treturn DiscoveryIssue.builder(DiscoveryIssue.Severity.WARNING, message) //\n+\t\t\t\t.source(ClassSource.from(testClass)) //\n+\t\t\t\t.build();\n+\t}\n+\n }\n\ndiff --git a/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/LifecycleMethodUtils.java b/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/LifecycleMethodUtils.java\nindex 5844ee0261b4..df8d894c3444 100644\n--- a/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/LifecycleMethodUtils.java\n+++ b/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/LifecycleMethodUtils.java\n@@ -58,7 +58,7 @@ private static List<Method> findMethodsAndCheckStaticAndNonPrivate(Class<?> test\n \t\t\t\t\t\t\t.and(isStatic(annotationType, issueReporter)) //\n \t\t\t\t\t\t\t.and(isNotPrivate(annotationType, issueReporter)) //\n \t\t\t\t\t\t\t.and(hasNoParameters(annotationType, issueReporter)) //\n-\t\t\t\t) //\n+\t\t\t\t\t\t\t.toPredicate()) //\n \t\t\t\t.collect(toUnmodifiableList());\n \t}\n \n"", ""test_patch"": ""diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java\nindex eb4a5141c667..95b36fcda748 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java\n@@ -566,10 +566,11 @@ private static class LifecycleMethods {\n \t\tLifecycleMethods(ClassInfo classInfo) {\n \t\t\tClass<?> testClass = classInfo.testClass;\n \t\t\tboolean requireStatic = classInfo.lifecycle == Lifecycle.PER_METHOD;\n-\t\t\tthis.beforeAll = findBeforeAllMethods(testClass, requireStatic, discoveryIssues::add);\n-\t\t\tthis.afterAll = findAfterAllMethods(testClass, requireStatic, discoveryIssues::add);\n-\t\t\tthis.beforeEach = findBeforeEachMethods(testClass, discoveryIssues::add);\n-\t\t\tthis.afterEach = findAfterEachMethods(testClass, discoveryIssues::add);\n+\t\t\tDiscoveryIssueReporter issueReporter = DiscoveryIssueReporter.collecting(discoveryIssues);\n+\t\t\tthis.beforeAll = findBeforeAllMethods(testClass, requireStatic, issueReporter);\n+\t\t\tthis.afterAll = findAfterAllMethods(testClass, requireStatic, issueReporter);\n+\t\t\tthis.beforeEach = findBeforeEachMethods(testClass, issueReporter);\n+\t\t\tthis.afterEach = findAfterEachMethods(testClass, issueReporter);\n \t\t}\n \t}\n \n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestableMethod.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestableMethod.java\nindex 060fc0141f39..351be62aaecd 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestableMethod.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestableMethod.java\n@@ -46,7 +46,7 @@ abstract class IsTestableMethod implements Predicate<Method> {\n \t@Override\n \tpublic boolean test(Method candidate) {\n \t\tif (isAnnotated(candidate, this.annotationType)) {\n-\t\t\treturn condition.test(candidate);\n+\t\t\treturn condition.check(candidate);\n \t\t}\n \t\treturn false;\n \t}\n\ndiff --git a/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/IsPotentialTestContainer.java b/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/IsPotentialTestContainer.java\ndeleted file mode 100644\nindex ebfa4cc50e05..000000000000\n--- a/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/IsPotentialTestContainer.java\n+++ /dev/null\n@@ -1,42 +0,0 @@\n-/*\n- * Copyright 2015-2025 the original author or authors.\n- *\n- * All rights reserved. This program and the accompanying materials are\n- * made available under the terms of the Eclipse Public License v2.0 which\n- * accompanies this distribution and is available at\n- *\n- * https://www.eclipse.org/legal/epl-v20.html\n- */\n-\n-package org.junit.platform.suite.engine;\n-\n-import static org.junit.platform.commons.support.ModifierSupport.isAbstract;\n-import static org.junit.platform.commons.support.ModifierSupport.isPrivate;\n-import static org.junit.platform.commons.util.ReflectionUtils.isInnerClass;\n-\n-import java.util.function.Predicate;\n-\n-/**\n- * @since 1.8\n- */\n-final class IsPotentialTestContainer implements Predicate<Class<?>> {\n-\n-\t@Override\n-\tpublic boolean test(Class<?> candidate) {\n-\t\t// Please do not collapse the following into a single statement.\n-\t\tif (isPrivate(candidate)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (isAbstract(candidate)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (candidate.isLocalClass()) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (candidate.isAnonymousClass()) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn !isInnerClass(candidate);\n-\t}\n-\n-}\n\ndiff --git a/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/SuiteTestDescriptor.java b/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/SuiteTestDescriptor.java\nindex 9a4257d8a0cc..0bcc205217a8 100644\n--- a/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/SuiteTestDescriptor.java\n+++ b/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/SuiteTestDescriptor.java\n@@ -10,21 +10,29 @@\n \n package org.junit.platform.suite.engine;\n \n+import static java.util.function.Predicate.isEqual;\n+import static java.util.stream.Collectors.joining;\n import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n+import static org.junit.platform.commons.util.FunctionUtils.where;\n import static org.junit.platform.suite.commons.SuiteLauncherDiscoveryRequestBuilder.request;\n \n import java.lang.reflect.Method;\n import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n \n import org.junit.platform.commons.JUnitException;\n import org.junit.platform.commons.support.ReflectionSupport;\n import org.junit.platform.commons.util.Preconditions;\n import org.junit.platform.commons.util.StringUtils;\n import org.junit.platform.engine.ConfigurationParameters;\n+import org.junit.platform.engine.DiscoveryIssue;\n+import org.junit.platform.engine.EngineDiscoveryListener;\n import org.junit.platform.engine.EngineExecutionListener;\n import org.junit.platform.engine.TestDescriptor;\n import org.junit.platform.engine.TestExecutionResult;\n import org.junit.platform.engine.UniqueId;\n+import org.junit.platform.engine.UniqueId.Segment;\n import org.junit.platform.engine.discovery.DiscoverySelectors;\n import org.junit.platform.engine.reporting.OutputDirectoryProvider;\n import org.junit.platform.engine.support.descriptor.AbstractTestDescriptor;\n@@ -32,6 +40,7 @@\n import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n import org.junit.platform.engine.support.hierarchical.OpenTest4JAwareThrowableCollector;\n import org.junit.platform.engine.support.hierarchical.ThrowableCollector;\n+import org.junit.platform.launcher.LauncherDiscoveryListener;\n import org.junit.platform.launcher.LauncherDiscoveryRequest;\n import org.junit.platform.launcher.core.LauncherDiscoveryResult;\n import org.junit.platform.launcher.listeners.TestExecutionSummary;\n@@ -64,13 +73,15 @@ final class SuiteTestDescriptor extends AbstractTestDescriptor {\n \tprivate SuiteLauncher launcher;\n \n \tSuiteTestDescriptor(UniqueId id, Class<?> suiteClass, ConfigurationParameters configurationParameters,\n-\t\t\tOutputDirectoryProvider outputDirectoryProvider, DiscoveryIssueReporter issueReporter) {\n+\t\t\tOutputDirectoryProvider outputDirectoryProvider, EngineDiscoveryListener discoveryListener,\n+\t\t\tDiscoveryIssueReporter issueReporter) {\n \t\tsuper(id, getSuiteDisplayName(suiteClass), ClassSource.from(suiteClass));\n \t\tthis.configurationParameters = configurationParameters;\n \t\tthis.outputDirectoryProvider = outputDirectoryProvider;\n \t\tthis.failIfNoTests = getFailIfNoTests(suiteClass);\n \t\tthis.suiteClass = suiteClass;\n \t\tthis.lifecycleMethods = new LifecycleMethods(suiteClass, issueReporter);\n+\t\tthis.discoveryRequestBuilder.listener(DiscoveryIssueForwardingListener.create(id, discoveryListener));\n \t}\n \n \tprivate static Boolean getFailIfNoTests(Class<?> suiteClass) {\n@@ -209,4 +220,45 @@ private static class LifecycleMethods {\n \t\t}\n \t}\n \n+\tprivate static class DiscoveryIssueForwardingListener implements LauncherDiscoveryListener {\n+\n+\t\tprivate static final Predicate<Segment> SUITE_SEGMENTS = where(Segment::getType, isEqual(SEGMENT_TYPE));\n+\n+\t\tstatic DiscoveryIssueForwardingListener create(UniqueId id, EngineDiscoveryListener discoveryListener) {\n+\t\t\tboolean isNestedSuite = id.getSegments().stream().filter(SUITE_SEGMENTS).count() > 1;\n+\t\t\tif (isNestedSuite) {\n+\t\t\t\treturn new DiscoveryIssueForwardingListener(discoveryListener, (__, issue) -> issue);\n+\t\t\t}\n+\t\t\treturn new DiscoveryIssueForwardingListener(discoveryListener,\n+\t\t\t\t(engineUniqueId, issue) -> issue.withMessage(message -> {\n+\t\t\t\t\tString engineId = engineUniqueId.getLastSegment().getValue();\n+\t\t\t\t\tif (SuiteEngineDescriptor.ENGINE_ID.equals(engineId)) {\n+\t\t\t\t\t\treturn message;\n+\t\t\t\t\t}\n+\t\t\t\t\tString suitePath = engineUniqueId.getSegments().stream() //\n+\t\t\t\t\t\t\t.filter(SUITE_SEGMENTS) //\n+\t\t\t\t\t\t\t.map(Segment::getValue) //\n+\t\t\t\t\t\t\t.collect(joining(\"" > \""));\n+\t\t\t\t\tif (message.endsWith(\"".\"")) {\n+\t\t\t\t\t\tmessage = message.substring(0, message.length() - 1);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn String.format(\""[%s] %s (via @Suite %s).\"", engineId, message, suitePath);\n+\t\t\t\t}));\n+\t\t}\n+\n+\t\tprivate final EngineDiscoveryListener discoveryListener;\n+\t\tprivate final BiFunction<UniqueId, DiscoveryIssue, DiscoveryIssue> issueTransformer;\n+\n+\t\tprivate DiscoveryIssueForwardingListener(EngineDiscoveryListener discoveryListener,\n+\t\t\t\tBiFunction<UniqueId, DiscoveryIssue, DiscoveryIssue> issueTransformer) {\n+\t\t\tthis.discoveryListener = discoveryListener;\n+\t\t\tthis.issueTransformer = issueTransformer;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void issueEncountered(UniqueId engineUniqueId, DiscoveryIssue issue) {\n+\t\t\tDiscoveryIssue transformedIssue = this.issueTransformer.apply(engineUniqueId, issue);\n+\t\t\tthis.discoveryListener.issueEncountered(engineUniqueId, transformedIssue);\n+\t\t}\n+\t}\n }\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtilsTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtilsTests.java\nindex 22b9197886b6..d4f56b9b684f 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtilsTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtilsTests.java\n@@ -32,6 +32,7 @@\n import org.junit.platform.engine.DiscoveryIssue;\n import org.junit.platform.engine.DiscoveryIssue.Severity;\n import org.junit.platform.engine.support.descriptor.MethodSource;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n \n /**\n  * Unit tests for {@link LifecycleMethodUtils}.\n@@ -41,10 +42,11 @@\n class LifecycleMethodUtilsTests {\n \n \tList<DiscoveryIssue> discoveryIssues = new ArrayList<>();\n+\tDiscoveryIssueReporter issueReporter = DiscoveryIssueReporter.collecting(discoveryIssues);\n \n \t@Test\n \tvoid findNonVoidBeforeAllMethodsWithStandardLifecycle() throws Exception {\n-\t\tvar methods = findBeforeAllMethods(TestCaseWithInvalidLifecycleMethods.class, true, discoveryIssues::add);\n+\t\tvar methods = findBeforeAllMethods(TestCaseWithInvalidLifecycleMethods.class, true, issueReporter);\n \t\tassertThat(methods).isEmpty();\n \n \t\tvar methodSource = MethodSource.from(TestCaseWithInvalidLifecycleMethods.class.getDeclaredMethod(\""cc\""));\n@@ -65,7 +67,7 @@ void findNonVoidBeforeAllMethodsWithStandardLifecycle() throws Exception {\n \n \t@Test\n \tvoid findNonVoidAfterAllMethodsWithStandardLifecycle() throws Exception {\n-\t\tvar methods = findAfterAllMethods(TestCaseWithInvalidLifecycleMethods.class, true, discoveryIssues::add);\n+\t\tvar methods = findAfterAllMethods(TestCaseWithInvalidLifecycleMethods.class, true, issueReporter);\n \t\tassertThat(methods).isEmpty();\n \n \t\tvar methodSource = MethodSource.from(TestCaseWithInvalidLifecycleMethods.class.getDeclaredMethod(\""dd\""));\n@@ -86,7 +88,7 @@ void findNonVoidAfterAllMethodsWithStandardLifecycle() throws Exception {\n \n \t@Test\n \tvoid findNonVoidBeforeEachMethodsWithStandardLifecycle() throws Exception {\n-\t\tvar methods = findBeforeEachMethods(TestCaseWithInvalidLifecycleMethods.class, discoveryIssues::add);\n+\t\tvar methods = findBeforeEachMethods(TestCaseWithInvalidLifecycleMethods.class, issueReporter);\n \t\tassertThat(methods).isEmpty();\n \n \t\tvar methodSource = MethodSource.from(TestCaseWithInvalidLifecycleMethods.class.getDeclaredMethod(\""aa\""));\n@@ -103,7 +105,7 @@ void findNonVoidBeforeEachMethodsWithStandardLifecycle() throws Exception {\n \n \t@Test\n \tvoid findNonVoidAfterEachMethodsWithStandardLifecycle() throws Exception {\n-\t\tvar methods = findAfterEachMethods(TestCaseWithInvalidLifecycleMethods.class, discoveryIssues::add);\n+\t\tvar methods = findAfterEachMethods(TestCaseWithInvalidLifecycleMethods.class, issueReporter);\n \t\tassertThat(methods).isEmpty();\n \n \t\tvar methodSource = MethodSource.from(TestCaseWithInvalidLifecycleMethods.class.getDeclaredMethod(\""bb\""));\n@@ -120,7 +122,7 @@ void findNonVoidAfterEachMethodsWithStandardLifecycle() throws Exception {\n \n \t@Test\n \tvoid findBeforeEachMethodsWithStandardLifecycle() {\n-\t\tList<Method> methods = findBeforeEachMethods(TestCaseWithStandardLifecycle.class, discoveryIssues::add);\n+\t\tList<Method> methods = findBeforeEachMethods(TestCaseWithStandardLifecycle.class, issueReporter);\n \n \t\tassertThat(namesOf(methods)).containsExactlyInAnyOrder(\""nine\"", \""ten\"");\n \t\tassertThat(discoveryIssues).isEmpty();\n@@ -128,14 +130,14 @@ void findBeforeEachMethodsWithStandardLifecycle() {\n \n \t@Test\n \tvoid findAfterEachMethodsWithStandardLifecycle() {\n-\t\tList<Method> methods = findAfterEachMethods(TestCaseWithStandardLifecycle.class, discoveryIssues::add);\n+\t\tList<Method> methods = findAfterEachMethods(TestCaseWithStandardLifecycle.class, issueReporter);\n \n \t\tassertThat(namesOf(methods)).containsExactlyInAnyOrder(\""eleven\"", \""twelve\"");\n \t}\n \n \t@Test\n \tvoid findBeforeAllMethodsWithStandardLifecycleAndWithoutRequiringStatic() {\n-\t\tList<Method> methods = findBeforeAllMethods(TestCaseWithStandardLifecycle.class, false, discoveryIssues::add);\n+\t\tList<Method> methods = findBeforeAllMethods(TestCaseWithStandardLifecycle.class, false, issueReporter);\n \n \t\tassertThat(namesOf(methods)).containsExactly(\""one\"");\n \t\tassertThat(discoveryIssues).isEmpty();\n@@ -143,7 +145,7 @@ void findBeforeAllMethodsWithStandardLifecycleAndWithoutRequiringStatic() {\n \n \t@Test\n \tvoid findBeforeAllMethodsWithStandardLifecycleAndRequiringStatic() throws Exception {\n-\t\tvar methods = findBeforeAllMethods(TestCaseWithStandardLifecycle.class, true, discoveryIssues::add);\n+\t\tvar methods = findBeforeAllMethods(TestCaseWithStandardLifecycle.class, true, issueReporter);\n \t\tassertThat(methods).isEmpty();\n \n \t\tvar expectedIssue = DiscoveryIssue.builder(Severity.ERROR,\n@@ -155,7 +157,7 @@ void findBeforeAllMethodsWithStandardLifecycleAndRequiringStatic() throws Except\n \n \t@Test\n \tvoid findBeforeAllMethodsWithLifeCyclePerClassAndRequiringStatic() {\n-\t\tList<Method> methods = findBeforeAllMethods(TestCaseWithLifecyclePerClass.class, false, discoveryIssues::add);\n+\t\tList<Method> methods = findBeforeAllMethods(TestCaseWithLifecyclePerClass.class, false, issueReporter);\n \n \t\tassertThat(namesOf(methods)).containsExactlyInAnyOrder(\""three\"", \""four\"");\n \t\tassertThat(discoveryIssues).isEmpty();\n@@ -163,7 +165,7 @@ void findBeforeAllMethodsWithLifeCyclePerClassAndRequiringStatic() {\n \n \t@Test\n \tvoid findAfterAllMethodsWithStandardLifecycleAndWithoutRequiringStatic() {\n-\t\tList<Method> methods = findAfterAllMethods(TestCaseWithStandardLifecycle.class, false, discoveryIssues::add);\n+\t\tList<Method> methods = findAfterAllMethods(TestCaseWithStandardLifecycle.class, false, issueReporter);\n \n \t\tassertThat(namesOf(methods)).containsExactlyInAnyOrder(\""five\"", \""six\"");\n \t\tassertThat(discoveryIssues).isEmpty();\n@@ -171,7 +173,7 @@ void findAfterAllMethodsWithStandardLifecycleAndWithoutRequiringStatic() {\n \n \t@Test\n \tvoid findAfterAllMethodsWithStandardLifecycleAndRequiringStatic() {\n-\t\tvar methods = findAfterAllMethods(TestCaseWithStandardLifecycle.class, true, discoveryIssues::add);\n+\t\tvar methods = findAfterAllMethods(TestCaseWithStandardLifecycle.class, true, issueReporter);\n \t\tassertThat(methods).isEmpty();\n \n \t\tassertThat(discoveryIssues) //\n@@ -181,7 +183,7 @@ void findAfterAllMethodsWithStandardLifecycleAndRequiringStatic() {\n \n \t@Test\n \tvoid findAfterAllMethodsWithLifeCyclePerClassAndRequiringStatic() {\n-\t\tList<Method> methods = findAfterAllMethods(TestCaseWithLifecyclePerClass.class, false, discoveryIssues::add);\n+\t\tList<Method> methods = findAfterAllMethods(TestCaseWithLifecyclePerClass.class, false, issueReporter);\n \n \t\tassertThat(namesOf(methods)).containsExactlyInAnyOrder(\""seven\"", \""eight\"");\n \t}\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java\nindex 53658ebe7a8f..746740034f08 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java\n@@ -22,6 +22,7 @@\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.TestFactory;\n import org.junit.jupiter.api.TestTemplate;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n \n /**\n  * Unit tests for {@link IsTestClassWithTests}.\n@@ -30,8 +31,9 @@\n  */\n class IsTestClassWithTestsTests {\n \n-\tprivate final Predicate<Class<?>> isTestClassWithTests = new IsTestClassWithTests(__ -> {\n-\t});\n+\tprivate final Predicate<Class<?>> isTestClassWithTests = new IsTestClassWithTests(\n+\t\tDiscoveryIssueReporter.consuming(__ -> {\n+\t\t}));\n \n \t@Test\n \tvoid classWithTestMethodEvaluatesToTrue() {\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethodTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethodTests.java\nindex 763591ab3068..8b0949794fdd 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethodTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethodTests.java\n@@ -32,6 +32,7 @@\n import org.junit.platform.commons.support.ReflectionSupport;\n import org.junit.platform.engine.DiscoveryIssue;\n import org.junit.platform.engine.support.descriptor.MethodSource;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n \n /**\n  * Unit tests for {@link IsTestFactoryMethod}.\n@@ -41,7 +42,8 @@\n class IsTestFactoryMethodTests {\n \n \tfinal List<DiscoveryIssue> discoveryIssues = new ArrayList<>();\n-\tfinal Predicate<Method> isTestFactoryMethod = new IsTestFactoryMethod(discoveryIssues::add);\n+\tfinal Predicate<Method> isTestFactoryMethod = new IsTestFactoryMethod(\n+\t\tDiscoveryIssueReporter.collecting(discoveryIssues));\n \n \t@ParameterizedTest\n \t@ValueSource(strings = { \""dynamicTestsFactoryFromCollection\"", \""dynamicTestsFactoryFromStreamWithExtendsWildcard\"",\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethodTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethodTests.java\nindex 5336386614f4..d89cbd3cdc53 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethodTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethodTests.java\n@@ -29,6 +29,7 @@\n import org.junit.platform.engine.DiscoveryIssue;\n import org.junit.platform.engine.DiscoveryIssue.Severity;\n import org.junit.platform.engine.support.descriptor.MethodSource;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n \n /**\n  * Unit tests for {@link IsTestMethod}.\n@@ -38,7 +39,7 @@\n class IsTestMethodTests {\n \n \tfinal List<DiscoveryIssue> discoveryIssues = new ArrayList<>();\n-\tfinal Predicate<Method> isTestMethod = new IsTestMethod(discoveryIssues::add);\n+\tfinal Predicate<Method> isTestMethod = new IsTestMethod(DiscoveryIssueReporter.collecting(discoveryIssues));\n \n \t@Test\n \tvoid publicTestMethod() {\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestTemplateMethodTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestTemplateMethodTests.java\nindex 82473b4e0163..49ad8eba297c 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestTemplateMethodTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestTemplateMethodTests.java\n@@ -22,6 +22,7 @@\n import org.junit.platform.commons.support.ReflectionSupport;\n import org.junit.platform.engine.DiscoveryIssue;\n import org.junit.platform.engine.support.descriptor.MethodSource;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n \n /**\n  * Unit tests for {@link IsTestTemplateMethod}.\n@@ -31,7 +32,8 @@\n class IsTestTemplateMethodTests {\n \n \tfinal List<DiscoveryIssue> discoveryIssues = new ArrayList<>();\n-\tfinal IsTestTemplateMethod isTestTemplateMethod = new IsTestTemplateMethod(discoveryIssues::add);\n+\tfinal IsTestTemplateMethod isTestTemplateMethod = new IsTestTemplateMethod(\n+\t\tDiscoveryIssueReporter.collecting(discoveryIssues));\n \n \t@Test\n \tvoid testTemplateMethodReturningVoid() {\n\ndiff --git a/platform-tests/src/test/java/org/junit/platform/engine/DiscoveryIssueTests.java b/platform-tests/src/test/java/org/junit/platform/engine/DiscoveryIssueTests.java\nindex ed23c6099ae1..4ed3ff25a262 100644\n--- a/platform-tests/src/test/java/org/junit/platform/engine/DiscoveryIssueTests.java\n+++ b/platform-tests/src/test/java/org/junit/platform/engine/DiscoveryIssueTests.java\n@@ -15,6 +15,7 @@\n import static org.mockito.Mockito.mock;\n \n import java.util.Optional;\n+import java.util.function.UnaryOperator;\n \n import org.junit.jupiter.api.Test;\n import org.junit.platform.engine.DiscoveryIssue.Severity;\n@@ -95,4 +96,32 @@ void stringRepresentationWithOptionalAttributes() {\n \t\t\t\t.isEqualTo(\n \t\t\t\t\t\""DiscoveryIssue [severity = WARNING, message = 'message', source = ClassSource [className = 'org.junit.platform.engine.DiscoveryIssue', filePosition = null], cause = java.lang.RuntimeException: boom]\"");\n \t}\n+\n+\t@Test\n+\tvoid withNewMessage() {\n+\t\tvar issue = DiscoveryIssue.builder(Severity.WARNING, \""message\"") //\n+\t\t\t\t.source(ClassSource.from(DiscoveryIssue.class)) //\n+\t\t\t\t.cause(new RuntimeException(\""boom\"")) //\n+\t\t\t\t.build();\n+\n+\t\tvar newIssue = issue.withMessage(__ -> \""new message\"");\n+\n+\t\tassertThat(newIssue.severity()).isEqualTo(Severity.WARNING);\n+\t\tassertThat(newIssue.message()).isEqualTo(\""new message\"");\n+\t\tassertThat(newIssue.source()).containsSame(issue.source().orElseThrow());\n+\t\tassertThat(newIssue.cause()).containsSame(issue.cause().orElseThrow());\n+\t}\n+\n+\t@Test\n+\tvoid withSameMessage() {\n+\t\tvar issue = DiscoveryIssue.builder(Severity.WARNING, \""message\"") //\n+\t\t\t\t.source(ClassSource.from(DiscoveryIssue.class)) //\n+\t\t\t\t.cause(new RuntimeException(\""boom\"")) //\n+\t\t\t\t.build();\n+\n+\t\tvar newIssue = issue.withMessage(UnaryOperator.identity());\n+\n+\t\tassertThat(newIssue).isSameAs(issue);\n+\t}\n+\n }\n\ndiff --git a/platform-tests/src/test/java/org/junit/platform/suite/engine/SuiteEngineTests.java b/platform-tests/src/test/java/org/junit/platform/suite/engine/SuiteEngineTests.java\nindex 8041c89f1cf7..589ddf72e73a 100644\n--- a/platform-tests/src/test/java/org/junit/platform/suite/engine/SuiteEngineTests.java\n+++ b/platform-tests/src/test/java/org/junit/platform/suite/engine/SuiteEngineTests.java\n@@ -33,14 +33,20 @@\n import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;\n import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;\n import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.junit.platform.engine.DiscoveryIssue;\n+import org.junit.platform.engine.DiscoveryIssue.Severity;\n import org.junit.platform.engine.FilterResult;\n import org.junit.platform.engine.UniqueId;\n+import org.junit.platform.engine.support.descriptor.ClassSource;\n import org.junit.platform.engine.support.descriptor.MethodSource;\n import org.junit.platform.launcher.PostDiscoveryFilter;\n import org.junit.platform.suite.api.SelectClasses;\n import org.junit.platform.suite.api.Suite;\n import org.junit.platform.suite.engine.testcases.ConfigurationSensitiveTestCase;\n import org.junit.platform.suite.engine.testcases.DynamicTestsTestCase;\n+import org.junit.platform.suite.engine.testcases.ErroneousTestCase;\n import org.junit.platform.suite.engine.testcases.JUnit4TestsTestCase;\n import org.junit.platform.suite.engine.testcases.MultipleTestsTestCase;\n import org.junit.platform.suite.engine.testcases.SingleTestTestCase;\n@@ -54,6 +60,8 @@\n import org.junit.platform.suite.engine.testsuites.EmptyDynamicTestWithFailIfNoTestFalseSuite;\n import org.junit.platform.suite.engine.testsuites.EmptyTestCaseSuite;\n import org.junit.platform.suite.engine.testsuites.EmptyTestCaseWithFailIfNoTestFalseSuite;\n+import org.junit.platform.suite.engine.testsuites.ErroneousTestSuite;\n+import org.junit.platform.suite.engine.testsuites.InheritedSuite;\n import org.junit.platform.suite.engine.testsuites.MultiEngineSuite;\n import org.junit.platform.suite.engine.testsuites.MultipleSuite;\n import org.junit.platform.suite.engine.testsuites.NestedSuite;\n@@ -62,6 +70,7 @@\n import org.junit.platform.suite.engine.testsuites.SelectMethodsSuite;\n import org.junit.platform.suite.engine.testsuites.SuiteDisplayNameSuite;\n import org.junit.platform.suite.engine.testsuites.SuiteSuite;\n+import org.junit.platform.suite.engine.testsuites.SuiteWithErroneousTestSuite;\n import org.junit.platform.suite.engine.testsuites.ThreePartCyclicSuite;\n import org.junit.platform.testkit.engine.EngineTestKit;\n \n@@ -73,16 +82,22 @@ class SuiteEngineTests {\n \t@TempDir\n \tprivate Path outputDir;\n \n-\t@Test\n-\tvoid selectClasses() {\n+\t@ParameterizedTest\n+\t@ValueSource(classes = { SelectClassesSuite.class, InheritedSuite.class })\n+\tvoid selectClasses(Class<?> suiteClass) {\n \t\t// @formatter:off\n-\t\tEngineTestKit.engine(ENGINE_ID)\n-\t\t\t\t.selectors(selectClass(SelectClassesSuite.class))\n-\t\t\t\t.outputDirectoryProvider(hierarchicalOutputDirectoryProvider(outputDir))\n+\t\tvar testKit = EngineTestKit.engine(ENGINE_ID)\n+\t\t\t\t.selectors(selectClass(suiteClass))\n+\t\t\t\t.outputDirectoryProvider(hierarchicalOutputDirectoryProvider(outputDir));\n+\n+\t\tassertThat(testKit.discover().getDiscoveryIssues())\n+\t\t\t\t.isEmpty();\n+\n+\t\ttestKit\n \t\t\t\t.execute()\n \t\t\t\t.testEvents()\n \t\t\t\t.assertThatEvents()\n-\t\t\t\t.haveExactly(1, event(test(SelectClassesSuite.class.getName()), finishedSuccessfully()))\n+\t\t\t\t.haveExactly(1, event(test(suiteClass.getName()), finishedSuccessfully()))\n \t\t\t\t.haveExactly(1, event(test(SingleTestTestCase.class.getName()), finishedSuccessfully()));\n \t\t// @formatter:on\n \t}\n@@ -90,8 +105,13 @@ void selectClasses() {\n \t@Test\n \tvoid selectMethods() {\n \t\t// @formatter:off\n-\t\tEngineTestKit.engine(ENGINE_ID)\n-\t\t\t\t.selectors(selectClass(SelectMethodsSuite.class))\n+\t\tvar testKit = EngineTestKit.engine(ENGINE_ID)\n+\t\t\t\t.selectors(selectClass(SelectMethodsSuite.class));\n+\n+\t\tassertThat(testKit.discover().getDiscoveryIssues())\n+\t\t\t\t.isEmpty();\n+\n+\t\ttestKit\n \t\t\t\t.execute()\n \t\t\t\t.testEvents()\n \t\t\t\t.assertThatEvents()\n@@ -115,8 +135,13 @@ void suiteDisplayName() {\n \t@Test\n \tvoid abstractSuiteIsNotExecuted() {\n \t\t// @formatter:off\n-\t\tEngineTestKit.engine(ENGINE_ID)\n-\t\t\t\t.selectors(selectClass(AbstractSuite.class))\n+\t\tvar testKit = EngineTestKit.engine(ENGINE_ID)\n+\t\t\t\t.selectors(selectClass(AbstractSuite.class));\n+\n+\t\tassertThat(testKit.discover().getDiscoveryIssues())\n+\t\t\t\t.isEmpty();\n+\n+\t\ttestKit\n \t\t\t\t.execute()\n \t\t\t\t.testEvents()\n \t\t\t\t.assertThatEvents()\n@@ -127,8 +152,18 @@ void abstractSuiteIsNotExecuted() {\n \t@Test\n \tvoid privateSuiteIsNotExecuted() {\n \t\t// @formatter:off\n-\t\tEngineTestKit.engine(ENGINE_ID)\n-\t\t\t\t.selectors(selectClass(PrivateSuite.class))\n+\t\tvar message = \""@Suite class '%s' must not be private.\""\n+\t\t\t\t.formatted(PrivateSuite.class.getName());\n+\t\tvar issue = DiscoveryIssue.builder(Severity.WARNING, message)\n+\t\t\t\t.source(ClassSource.from(PrivateSuite.class))\n+\t\t\t\t.build();\n+\t\tvar testKit = EngineTestKit.engine(ENGINE_ID)\n+\t\t\t\t.selectors(selectClass(PrivateSuite.class));\n+\n+\t\tassertThat(testKit.discover().getDiscoveryIssues())\n+\t\t\t\t.containsExactly(issue);\n+\n+\t\ttestKit\n \t\t\t\t.execute()\n \t\t\t\t.testEvents()\n \t\t\t\t.assertThatEvents()\n@@ -137,10 +172,86 @@ void privateSuiteIsNotExecuted() {\n \t}\n \n \t@Test\n-\tvoid innerSuiteIsNotExecuted() {\n+\tvoid abstractPrivateSuiteIsNotExecuted() {\n \t\t// @formatter:off\n-\t\tEngineTestKit.engine(ENGINE_ID)\n-\t\t\t\t.selectors(selectClass(InnerSuite.class))\n+\t\tvar testKit = EngineTestKit.engine(ENGINE_ID)\n+\t\t\t\t.selectors(selectClass(AbstractPrivateSuite.class));\n+\n+\t\tassertThat(testKit.discover().getDiscoveryIssues())\n+\t\t\t\t.isEmpty();\n+\n+\t\ttestKit\n+\t\t\t\t.execute()\n+\t\t\t\t.testEvents()\n+\t\t\t\t.assertThatEvents()\n+\t\t\t\t.isEmpty();\n+\t\t// @formatter:on\n+\t}\n+\n+\t@ParameterizedTest\n+\t@ValueSource(classes = { InnerSuite.class, AbstractInnerSuite.class })\n+\tvoid innerSuiteIsNotExecuted(Class<?> suiteClass) {\n+\t\t// @formatter:off\n+\t\tvar message = \""@Suite class '%s' must not be an inner class. Did you forget to declare it static?\""\n+\t\t\t\t.formatted(suiteClass.getName());\n+\t\tvar issue = DiscoveryIssue.builder(Severity.WARNING, message)\n+\t\t\t\t.source(ClassSource.from(suiteClass))\n+\t\t\t\t.build();\n+\t\tvar testKit = EngineTestKit.engine(ENGINE_ID)\n+\t\t\t\t.selectors(selectClass(suiteClass));\n+\n+\t\tassertThat(testKit.discover().getDiscoveryIssues())\n+\t\t\t\t.containsExactly(issue);\n+\n+\t\ttestKit\n+\t\t\t\t.execute()\n+\t\t\t\t.testEvents()\n+\t\t\t\t.assertThatEvents()\n+\t\t\t\t.isEmpty();\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Test\n+\tvoid localSuiteIsNotExecuted() {\n+\n+\t\t@Suite\n+\t\t@SelectClasses(names = \""org.junit.platform.suite.engine.testcases.SingleTestTestCase\"")\n+\t\tclass LocalSuite {\n+\t\t}\n+\n+\t\t// @formatter:off\n+\t\tvar message = \""@Suite class '%s' must not be a local class.\""\n+\t\t\t\t.formatted(LocalSuite.class.getName());\n+\t\tvar issue = DiscoveryIssue.builder(Severity.WARNING, message)\n+\t\t\t\t.source(ClassSource.from(LocalSuite.class))\n+\t\t\t\t.build();\n+\t\tvar testKit = EngineTestKit.engine(ENGINE_ID)\n+\t\t\t\t.selectors(selectClass(LocalSuite.class));\n+\n+\t\tassertThat(testKit.discover().getDiscoveryIssues())\n+\t\t\t\t.containsExactly(issue);\n+\n+\t\ttestKit\n+\t\t\t\t.execute()\n+\t\t\t\t.testEvents()\n+\t\t\t\t.assertThatEvents()\n+\t\t\t\t.isEmpty();\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Test\n+\tvoid anonymousSuiteIsNotExecuted() {\n+\t\tvar object = new Object() {\n+\t\t};\n+\n+\t\t// @formatter:off\n+\t\tvar testKit = EngineTestKit.engine(ENGINE_ID)\n+\t\t\t\t.selectors(selectClass(object.getClass()));\n+\n+\t\tassertThat(testKit.discover().getDiscoveryIssues())\n+\t\t\t\t.isEmpty();\n+\n+\t\ttestKit\n \t\t\t\t.execute()\n \t\t\t\t.testEvents()\n \t\t\t\t.assertThatEvents()\n@@ -401,9 +512,24 @@ void pruneAfterPostDiscoveryFilters() {\n \t@Test\n \tvoid cyclicSuite() {\n \t\t// @formatter:off\n-\t\tEngineTestKit.engine(ENGINE_ID)\n+\t\tvar expectedUniqueId = UniqueId.forEngine(ENGINE_ID)\n+\t\t\t\t.append(SuiteTestDescriptor.SEGMENT_TYPE, CyclicSuite.class.getName())\n+\t\t\t\t.appendEngine(ENGINE_ID)\n+\t\t\t\t.append(SuiteTestDescriptor.SEGMENT_TYPE, CyclicSuite.class.getName());\n+\t\tvar message = \""The suite configuration of [%s] resulted in a cycle [%s] and will not be discovered a second time.\""\n+\t\t\t\t.formatted(CyclicSuite.class.getName(), expectedUniqueId);\n+\t\tvar issue = DiscoveryIssue.builder(Severity.INFO, message)\n+\t\t\t\t.source(ClassSource.from(CyclicSuite.class))\n+\t\t\t\t.build();\n+\n+\t\tvar testKit = EngineTestKit.engine(ENGINE_ID)\n \t\t\t\t.selectors(selectClass(CyclicSuite.class))\n-\t\t\t\t.outputDirectoryProvider(hierarchicalOutputDirectoryProvider(outputDir))\n+\t\t\t\t.outputDirectoryProvider(hierarchicalOutputDirectoryProvider(outputDir));\n+\n+\t\tassertThat(testKit.discover().getDiscoveryIssues())\n+\t\t\t\t.containsExactly(issue);\n+\n+\t\ttestKit\n \t\t\t\t.execute()\n \t\t\t\t.allEvents()\n \t\t\t\t.assertThatEvents()\n@@ -467,6 +593,37 @@ void passesOutputDirectoryProviderToEnginesInSuite() {\n \t\tassertThat(outputDir).isDirectoryRecursivelyContaining(\""glob:**/test.txt\"");\n \t}\n \n+\t@Test\n+\tvoid discoveryIssueOfNestedTestEnginesAreReported() throws Exception {\n+\t\t// @formatter:off\n+\t\tvar testKit = EngineTestKit.engine(ENGINE_ID)\n+\t\t\t\t.selectors(selectClass(SuiteWithErroneousTestSuite.class));\n+\n+\t\tvar discoveryIssues = testKit.discover().getDiscoveryIssues();\n+\t\tassertThat(discoveryIssues).hasSize(1);\n+\n+\t\tvar issue = discoveryIssues.getFirst();\n+\t\tassertThat(issue.message()) //\n+\t\t\t\t.startsWith(\""[junit-jupiter] @BeforeAll method\"") //\n+\t\t\t\t.endsWith(\"" (via @Suite %s > %s).\"".formatted(SuiteWithErroneousTestSuite.class.getName(),\n+\t\t\t\t\t\tErroneousTestSuite.class.getName()));\n+\n+\t\tvar method = ErroneousTestCase.class.getDeclaredMethod(\""nonStaticLifecycleMethod\"");\n+\t\tassertThat(issue.source()).contains(MethodSource.from(method));\n+\n+\t\ttestKit\n+\t\t\t\t.execute()\n+\t\t\t\t.testEvents()\n+\t\t\t\t.assertThatEvents()\n+\t\t\t\t.isEmpty();\n+\t\t// @formatter:on\n+\t}\n+\n+\t@Suite\n+\t@SelectClasses(SingleTestTestCase.class)\n+\tabstract private static class AbstractPrivateSuite {\n+\t}\n+\n \t@Suite\n \t@SelectClasses(SingleTestTestCase.class)\n \tprivate static class PrivateSuite {\n@@ -474,7 +631,12 @@ private static class PrivateSuite {\n \n \t@Suite\n \t@SelectClasses(names = \""org.junit.platform.suite.engine.testcases.SingleTestTestCase\"")\n-\tprivate class InnerSuite {\n+\tabstract class AbstractInnerSuite {\n+\t}\n+\n+\t@Suite\n+\t@SelectClasses(names = \""org.junit.platform.suite.engine.testcases.SingleTestTestCase\"")\n+\tclass InnerSuite {\n \t}\n \n }\n\ndiff --git a/platform-tests/src/test/java/org/junit/platform/suite/engine/SuiteTestDescriptorTests.java b/platform-tests/src/test/java/org/junit/platform/suite/engine/SuiteTestDescriptorTests.java\nindex c89e6ef61582..d9b2be9a741e 100644\n--- a/platform-tests/src/test/java/org/junit/platform/suite/engine/SuiteTestDescriptorTests.java\n+++ b/platform-tests/src/test/java/org/junit/platform/suite/engine/SuiteTestDescriptorTests.java\n@@ -52,7 +52,7 @@ class SuiteTestDescriptorTests {\n \tfinal OutputDirectoryProvider outputDirectoryProvider = OutputDirectoryProviders.dummyOutputDirectoryProvider();\n \tfinal DiscoveryIssueReporter discoveryIssueReporter = DiscoveryIssueReporter.forwarding(mock(), engineId);\n \tfinal SuiteTestDescriptor suite = new SuiteTestDescriptor(suiteId, TestSuite.class, configurationParameters,\n-\t\toutputDirectoryProvider, discoveryIssueReporter);\n+\t\toutputDirectoryProvider, mock(), discoveryIssueReporter);\n \n \t@Test\n \tvoid suiteIsEmptyBeforeDiscovery() {\n\ndiff --git a/platform-tests/src/test/java/org/junit/platform/suite/engine/testcases/ErroneousTestCase.java b/platform-tests/src/test/java/org/junit/platform/suite/engine/testcases/ErroneousTestCase.java\nnew file mode 100644\nindex 000000000000..bd73a27ea69e\n--- /dev/null\n+++ b/platform-tests/src/test/java/org/junit/platform/suite/engine/testcases/ErroneousTestCase.java\n@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2015-2025 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junit.platform.suite.engine.testcases;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+public class ErroneousTestCase {\n+\n+\t@SuppressWarnings({ \""JUnitMalformedDeclaration\"", \""unused\"" })\n+\t@BeforeAll\n+\tvoid nonStaticLifecycleMethod() {\n+\t\tfail(\""should not be called\"");\n+\t}\n+\n+\t@Test\n+\tvoid name() {\n+\t\tfail(\""should not be called\"");\n+\t}\n+}\n\ndiff --git a/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/ErroneousTestSuite.java b/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/ErroneousTestSuite.java\nnew file mode 100644\nindex 000000000000..988770cd5ec9\n--- /dev/null\n+++ b/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/ErroneousTestSuite.java\n@@ -0,0 +1,20 @@\n+/*\n+ * Copyright 2015-2025 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junit.platform.suite.engine.testsuites;\n+\n+import org.junit.platform.suite.api.SelectClasses;\n+import org.junit.platform.suite.api.Suite;\n+import org.junit.platform.suite.engine.testcases.ErroneousTestCase;\n+\n+@Suite\n+@SelectClasses(ErroneousTestCase.class)\n+public class ErroneousTestSuite {\n+}\n\ndiff --git a/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/InheritedSuite.java b/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/InheritedSuite.java\nnew file mode 100644\nindex 000000000000..fd6bb9a3aea1\n--- /dev/null\n+++ b/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/InheritedSuite.java\n@@ -0,0 +1,14 @@\n+/*\n+ * Copyright 2015-2025 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junit.platform.suite.engine.testsuites;\n+\n+public class InheritedSuite extends AbstractSuite {\n+}\n\ndiff --git a/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/SuiteWithErroneousTestSuite.java b/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/SuiteWithErroneousTestSuite.java\nnew file mode 100644\nindex 000000000000..3b0825d0fafd\n--- /dev/null\n+++ b/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/SuiteWithErroneousTestSuite.java\n@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2015-2025 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junit.platform.suite.engine.testsuites;\n+\n+import org.junit.platform.suite.api.SelectClasses;\n+import org.junit.platform.suite.api.Suite;\n+\n+@Suite\n+@SelectClasses(ErroneousTestSuite.class)\n+public class SuiteWithErroneousTestSuite {\n+}\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""junit-team__junit5-4408"", ""pr_id"": 4408, ""issue_id"": 242, ""repo"": ""junit-team/junit5"", ""problem_statement"": ""Introduce error handling mechanism for validation and discovery errors\n## Overview\n\nThe JUnit Platform currently provides no means to report warnings and errors during test discovery. Thus, malformed test cases (for example, Jupiter test methods with a non-void return type) get silently ignored which poses a severe risk for downstream projects: something that looks like a test in a pull request diff might not actually get executed. Therefore, we should introduce a mechanism to collect and report warnings and errors and use it for the Jupiter and Vintage engines. In addition, we should reach out to third-party test engine open source projects and ask them to adopt the new mechanism.\n\nValidation errors (e.g., for invalid `@BeforeEach` method declarations) should not abort the entire discovery phase. Instead the _discovery phase_ should continue, with the error tracked and reported during the _execution phase_. \n\n## Areas of Applicability\n\n- [x] exceptions thrown by test engines, as discussed in #750\n- [x] unresolvable unique IDs, as discussed in #210\n  - note, however, that a TestEngine should not report a unique ID as unresolvable if the unique ID does not apply to the particular TestEngine (see #1026 ).\n- [x] invalid `@BeforeAll`, `@AfterAll`, `@BeforeEach`, and `@AfterEach` method declarations\n- [x] [Competing method-level annotations](https://github.com/marcphilipp/junit5/blob/202d939953a2fa61f54a1b0c70e74e122740a427/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java#L99-L108) (e.g. `@Test` _and_ `@TestTemplate` on the same method)\n- [x] invalid `@Test`, `@TestFactory`, `@RepeatedTest`, and `@ParameterizedTest` method declarations (see #2244)\n- [x] invalid `@Suite` class declarations\n- [x] invalid `@Nested` test class declarations (see #1223 and #2717)\n- [x] non-static test class declaration (see #2311)\n- [x] missing `@Nested` annotation (see #1736)\n- [x] _blank_ display names supplied by the user, as discussed in #743\n- [x] `@Order` annotations on test classes and methods when class/method orderer is not `OrderAnnotation`\n\n## Proposals\n\n1. Allow engines to track errors by creating a special type of `TestDescriptor` such as an `AlwaysFailingTestDescriptor`, `DeadOnArrivalTestDescriptor`, or `ErrorReportingTestDescriptor`.\n    - Tracked errors for such a corresponding `TestDescriptor` could then be thrown as an exception during the execution phase instead of executing the corresponding container or test.\n2. Introduce a new property in `TestDescriptor` that signals an error that was encountered during the _discovery phase_.\n3. Pass a _reporting object_ from the `Launcher` into each `TestEngine` to report errors.\n    - See https://github.com/junit-team/junit5/issues/242#issuecomment-294301875\n\n## Related Issues\n\n- #121 \n- #210 \n- #743 \n- #750 \n- #835\n- #876  \n- #971 \n- #1026 \n- #1074 \n- #1223\n- #1944\n- #2244\n- #2311\n- #2717\n- #4125\n\n## Deliverables\n\n- [x] #4385\n- [x] #4389\n- [x] #4393\n- [x] #4398\n- [x] Revisit the changes made in #971 and determine if it makes sense to move the look-up of lifecycle methods back to the constructor of `ClassTestDescriptor`.\n- [x] #4401\n- [x] #4405\n- [x] #4408\n- [x] #4415\n- [x] #4420\n- [x] Revisit the results of #835 and update the code accordingly by tracking such errors instead of just ignoring such incorrect usage.\n- [x] #4423\n- [x] #949\n- [x] #4429\n- [x] #4448\n- [x] #1736\n- [x] #4453\n- [x] #4456\n- [x] #4458\n- [x] #4459\n- [x] Use the new mechanism to replace the current ad hoc use of logging and transparent defaulting as a work-around.\n  - Search for `TODO [#242]` within the code base.\n  - See https://github.com/junit-team/junit5/issues/750#issuecomment-294296045\n- [x] Determine where else the new mechanism can be used and apply it.\n- [x] #4463\n- [x] #4465\n- [x] Reach out to third-party test engine authors and ask them to adopt the new mechanism\n\t- https://github.com/spockframework/spock/issues/2145\n\t- https://github.com/cucumber/cucumber-jvm/issues/2987"", ""issue_word_count"": 584, ""test_files_count"": 2, ""non_test_files_count"": 5, ""pr_changed_files"": [""junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ClassTemplateInvocationLifecycleMethod.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java"", ""junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java"", ""junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java"", ""junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedClassIntegrationTests.java""], ""pr_changed_test_files"": [""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedClassIntegrationTests.java""], ""base_commit"": ""1aa837d1d8d02058f5f791709022cb99769dab86"", ""head_commit"": ""44bddc429f585d0a511ad36ce1ce0652f8e3acb6"", ""repo_url"": ""https://github.com/junit-team/junit5/pull/4408"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/junit-team__junit5/4408"", ""dockerfile"": """", ""pr_merged_at"": ""2025-03-19T11:30:25.000Z"", ""patch"": ""diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ClassTemplateInvocationLifecycleMethod.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ClassTemplateInvocationLifecycleMethod.java\nnew file mode 100644\nindex 000000000000..ed311c323357\n--- /dev/null\n+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ClassTemplateInvocationLifecycleMethod.java\n@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2015-2025 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junit.jupiter.api.extension;\n+\n+import static org.apiguardian.api.API.Status.INTERNAL;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import org.apiguardian.api.API;\n+\n+/**\n+ * Internal marker annotation for lifecycle methods specific to implementations\n+ * of {@link ClassTemplateInvocationContextProvider}.\n+ *\n+ * @since 5.13\n+ */\n+@API(status = INTERNAL, since = \""5.13\"")\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.ANNOTATION_TYPE)\n+public @interface ClassTemplateInvocationLifecycleMethod {\n+\n+\t/**\n+\t * The actual annotation class for reporting of discovery issues.\n+\t */\n+\tClass<? extends Annotation> value();\n+\n+}\n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java\nindex a73d9fc2f491..7eee75e476e4 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java\n@@ -17,11 +17,16 @@\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Method;\n import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n \n import org.junit.jupiter.api.AfterAll;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.extension.ClassTemplateInvocationLifecycleMethod;\n+import org.junit.platform.commons.support.AnnotationSupport;\n import org.junit.platform.commons.support.HierarchyTraversalMode;\n import org.junit.platform.commons.support.ModifierSupport;\n import org.junit.platform.commons.util.ReflectionUtils;\n@@ -64,11 +69,35 @@ static List<Method> findAfterEachMethods(Class<?> testClass, DiscoveryIssueRepor\n \t\t\tissueReporter);\n \t}\n \n+\tstatic void validateClassTemplateInvocationLifecycleMethods(Class<?> testClass, boolean requireStatic,\n+\t\t\tDiscoveryIssueReporter issueReporter) {\n+\n+\t\tStream<Method> allMethods = Stream.concat( //\n+\t\t\tfindAnnotatedMethods(testClass, ClassTemplateInvocationLifecycleMethod.class,\n+\t\t\t\tHierarchyTraversalMode.TOP_DOWN).stream(), //\n+\t\t\tfindAnnotatedMethods(testClass, ClassTemplateInvocationLifecycleMethod.class,\n+\t\t\t\tHierarchyTraversalMode.BOTTOM_UP).stream() //\n+\t\t);\n+\t\tallMethods //\n+\t\t\t\t.distinct() //\n+\t\t\t\t.forEach(allOf( //\n+\t\t\t\t\tisNotPrivateError(issueReporter), //\n+\t\t\t\t\treturnsPrimitiveVoid(issueReporter,\n+\t\t\t\t\t\tLifecycleMethodUtils::classTemplateInvocationLifecycleMethodAnnotationName), //\n+\t\t\t\t\trequireStatic\n+\t\t\t\t\t\t\t? isStatic(issueReporter,\n+\t\t\t\t\t\t\t\tLifecycleMethodUtils::classTemplateInvocationLifecycleMethodAnnotationName)\n+\t\t\t\t\t\t\t: __ -> true //\n+\t\t\t\t));\n+\t}\n+\n \tprivate static List<Method> findMethodsAndCheckStatic(Class<?> testClass, boolean requireStatic,\n \t\t\tClass<? extends Annotation> annotationType, HierarchyTraversalMode traversalMode,\n \t\t\tDiscoveryIssueReporter issueReporter) {\n \n-\t\tCondition<Method> additionalCondition = requireStatic ? isStatic(annotationType, issueReporter) : __ -> true;\n+\t\tCondition<Method> additionalCondition = requireStatic\n+\t\t\t\t? isStatic(issueReporter, __ -> annotationType.getSimpleName())\n+\t\t\t\t: __ -> true;\n \t\treturn findMethodsAndCheckVoidReturnType(testClass, annotationType, traversalMode, issueReporter,\n \t\t\tadditionalCondition);\n \t}\n@@ -78,7 +107,7 @@ private static List<Method> findMethodsAndCheckNonStatic(Class<?> testClass,\n \t\t\tDiscoveryIssueReporter issueReporter) {\n \n \t\treturn findMethodsAndCheckVoidReturnType(testClass, annotationType, traversalMode, issueReporter,\n-\t\t\tisNotStatic(annotationType, issueReporter));\n+\t\t\tisNotStatic(issueReporter, __ -> annotationType.getSimpleName()));\n \t}\n \n \tprivate static List<Method> findMethodsAndCheckVoidReturnType(Class<?> testClass,\n@@ -86,49 +115,64 @@ private static List<Method> findMethodsAndCheckVoidReturnType(Class<?> testClass\n \t\t\tDiscoveryIssueReporter issueReporter, Condition<? super Method> additionalCondition) {\n \n \t\treturn findAnnotatedMethods(testClass, annotationType, traversalMode).stream() //\n-\t\t\t\t.peek(isNotPrivate(annotationType, issueReporter)) //\n-\t\t\t\t.filter(allOf(returnsPrimitiveVoid(annotationType, issueReporter), additionalCondition)) //\n+\t\t\t\t.peek(isNotPrivateDeprecation(issueReporter, annotationType::getSimpleName)) //\n+\t\t\t\t.filter(allOf(returnsPrimitiveVoid(issueReporter, __ -> annotationType.getSimpleName()),\n+\t\t\t\t\tadditionalCondition)) //\n \t\t\t\t.collect(toUnmodifiableList());\n \t}\n \n-\tprivate static Condition<Method> isStatic(Class<? extends Annotation> annotationType,\n-\t\t\tDiscoveryIssueReporter issueReporter) {\n+\tprivate static Condition<Method> isStatic(DiscoveryIssueReporter issueReporter,\n+\t\t\tFunction<Method, String> annotationNameProvider) {\n \t\treturn issueReporter.createReportingCondition(ModifierSupport::isStatic, method -> {\n \t\t\tString message = String.format(\n \t\t\t\t\""@%s method '%s' must be static unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS).\"",\n-\t\t\t\tannotationType.getSimpleName(), method.toGenericString());\n+\t\t\t\tannotationNameProvider.apply(method), method.toGenericString());\n \t\t\treturn createIssue(Severity.ERROR, message, method);\n \t\t});\n \t}\n \n-\tprivate static Condition<Method> isNotStatic(Class<? extends Annotation> annotationType,\n-\t\t\tDiscoveryIssueReporter issueReporter) {\n+\tprivate static Condition<Method> isNotStatic(DiscoveryIssueReporter issueReporter,\n+\t\t\tFunction<Method, String> annotationNameProvider) {\n \t\treturn issueReporter.createReportingCondition(ModifierSupport::isNotStatic, method -> {\n-\t\t\tString message = String.format(\""@%s method '%s' must not be static.\"", annotationType.getSimpleName(),\n+\t\t\tString message = String.format(\""@%s method '%s' must not be static.\"", annotationNameProvider.apply(method),\n \t\t\t\tmethod.toGenericString());\n \t\t\treturn createIssue(Severity.ERROR, message, method);\n \t\t});\n \t}\n \n-\tprivate static Condition<Method> isNotPrivate(Class<? extends Annotation> annotationType,\n-\t\t\tDiscoveryIssueReporter issueReporter) {\n+\tprivate static Condition<Method> isNotPrivateError(DiscoveryIssueReporter issueReporter) {\n+\t\treturn issueReporter.createReportingCondition(ModifierSupport::isNotPrivate, method -> {\n+\t\t\tString message = String.format(\""@%s method '%s' must not be private.\"",\n+\t\t\t\tclassTemplateInvocationLifecycleMethodAnnotationName(method), method.toGenericString());\n+\t\t\treturn createIssue(Severity.ERROR, message, method);\n+\t\t});\n+\t}\n+\n+\tprivate static Condition<Method> isNotPrivateDeprecation(DiscoveryIssueReporter issueReporter,\n+\t\t\tSupplier<String> annotationNameProvider) {\n \t\treturn issueReporter.createReportingCondition(ModifierSupport::isNotPrivate, method -> {\n \t\t\tString message = String.format(\n \t\t\t\t\""@%s method '%s' should not be private. This will be disallowed in a future release.\"",\n-\t\t\t\tannotationType.getSimpleName(), method.toGenericString());\n+\t\t\t\tannotationNameProvider.get(), method.toGenericString());\n \t\t\treturn createIssue(Severity.DEPRECATION, message, method);\n \t\t});\n \t}\n \n-\tprivate static Condition<Method> returnsPrimitiveVoid(Class<? extends Annotation> annotationType,\n-\t\t\tDiscoveryIssueReporter issueReporter) {\n+\tprivate static Condition<Method> returnsPrimitiveVoid(DiscoveryIssueReporter issueReporter,\n+\t\t\tFunction<Method, String> annotationNameProvider) {\n \t\treturn issueReporter.createReportingCondition(ReflectionUtils::returnsPrimitiveVoid, method -> {\n-\t\t\tString message = String.format(\""@%s method '%s' must not return a value.\"", annotationType.getSimpleName(),\n-\t\t\t\tmethod.toGenericString());\n+\t\t\tString message = String.format(\""@%s method '%s' must not return a value.\"",\n+\t\t\t\tannotationNameProvider.apply(method), method.toGenericString());\n \t\t\treturn createIssue(Severity.ERROR, message, method);\n \t\t});\n \t}\n \n+\tprivate static String classTemplateInvocationLifecycleMethodAnnotationName(Method method) {\n+\t\treturn AnnotationSupport.findAnnotation(method, ClassTemplateInvocationLifecycleMethod.class) //\n+\t\t\t\t.map(ClassTemplateInvocationLifecycleMethod::value).map(Class::getSimpleName) //\n+\t\t\t\t.orElseGet(ClassTemplateInvocationLifecycleMethod.class::getSimpleName);\n+\t}\n+\n \tprivate static DiscoveryIssue createIssue(Severity severity, String message, Method method) {\n \t\treturn DiscoveryIssue.builder(severity, message).source(MethodSource.from(method)).build();\n \t}\n\ndiff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java\nindex a97c62e6ac77..112347a0bf3a 100644\n--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java\n+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java\n@@ -19,6 +19,7 @@\n import java.lang.annotation.Target;\n \n import org.apiguardian.api.API;\n+import org.junit.jupiter.api.extension.ClassTemplateInvocationLifecycleMethod;\n import org.junit.jupiter.params.aggregator.AggregateWith;\n import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n \n@@ -157,6 +158,7 @@\n @Retention(RetentionPolicy.RUNTIME)\n @Documented\n @API(status = EXPERIMENTAL, since = \""5.13\"")\n+@ClassTemplateInvocationLifecycleMethod(AfterParameterizedClassInvocation.class)\n public @interface AfterParameterizedClassInvocation {\n \n \t/**\n\ndiff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java\nindex c6b23587e58d..0ede11363f3a 100644\n--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java\n+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java\n@@ -19,6 +19,7 @@\n import java.lang.annotation.Target;\n \n import org.apiguardian.api.API;\n+import org.junit.jupiter.api.extension.ClassTemplateInvocationLifecycleMethod;\n import org.junit.jupiter.params.aggregator.AggregateWith;\n import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n \n@@ -158,6 +159,7 @@\n @Retention(RetentionPolicy.RUNTIME)\n @Documented\n @API(status = EXPERIMENTAL, since = \""5.13\"")\n+@ClassTemplateInvocationLifecycleMethod(BeforeParameterizedClassInvocation.class)\n public @interface BeforeParameterizedClassInvocation {\n \n \t/**\n\ndiff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java\nindex 31528072b80a..f73fff4e1e23 100644\n--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java\n+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java\n@@ -12,15 +12,15 @@\n \n import static java.util.Collections.emptyList;\n import static java.util.Collections.reverse;\n-import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;\n+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_METHOD;\n import static org.junit.platform.commons.support.AnnotationSupport.findAnnotatedMethods;\n+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;\n import static org.junit.platform.commons.support.HierarchyTraversalMode.BOTTOM_UP;\n import static org.junit.platform.commons.support.HierarchyTraversalMode.TOP_DOWN;\n import static org.junit.platform.commons.support.ReflectionSupport.findFields;\n import static org.junit.platform.commons.util.CollectionUtils.toUnmodifiableList;\n import static org.junit.platform.commons.util.ReflectionUtils.isRecordClass;\n-import static org.junit.platform.commons.util.ReflectionUtils.returnsPrimitiveVoid;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n@@ -33,7 +33,6 @@\n import org.junit.jupiter.api.extension.ClassTemplateInvocationContext;\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.platform.commons.JUnitException;\n-import org.junit.platform.commons.support.AnnotationSupport;\n import org.junit.platform.commons.support.HierarchyTraversalMode;\n import org.junit.platform.commons.support.ModifierSupport;\n import org.junit.platform.commons.util.ReflectionUtils;\n@@ -153,14 +152,12 @@ private static <A extends Annotation> List<ArgumentSetLifecycleMethod> findLifec\n \t\t\tClass<?> testClass, TestInstance.Lifecycle testInstanceLifecycle, HierarchyTraversalMode traversalMode,\n \t\t\tClass<A> annotationType, Predicate<A> injectArgumentsPredicate, ResolverFacade resolverFacade) {\n \n-\t\tList<Method> methods = findMethodsAndCheckVoidReturnTypeAndNonPrivate(testClass, annotationType, traversalMode);\n+\t\tList<Method> methods = findAnnotatedMethods(testClass, annotationType, traversalMode);\n \n \t\treturn methods.stream() //\n-\t\t\t\t.peek(method -> {\n-\t\t\t\t\tif (testInstanceLifecycle != PER_CLASS) {\n-\t\t\t\t\t\tassertStatic(annotationType, method);\n-\t\t\t\t\t}\n-\t\t\t\t}) //\n+\t\t\t\t.filter(ModifierSupport::isNotPrivate) //\n+\t\t\t\t.filter(testInstanceLifecycle == PER_METHOD ? ModifierSupport::isStatic : __ -> true) //\n+\t\t\t\t.filter(ReflectionUtils::returnsPrimitiveVoid) //\n \t\t\t\t.map(method -> {\n \t\t\t\t\tA annotation = getAnnotation(method, annotationType);\n \t\t\t\t\tif (injectArgumentsPredicate.test(annotation)) {\n@@ -173,43 +170,10 @@ private static <A extends Annotation> List<ArgumentSetLifecycleMethod> findLifec\n \t}\n \n \tprivate static <A extends Annotation> A getAnnotation(Method method, Class<A> annotationType) {\n-\t\treturn AnnotationSupport.findAnnotation(method, annotationType) //\n+\t\treturn findAnnotation(method, annotationType) //\n \t\t\t\t.orElseThrow(() -> new JUnitException(\""Method not annotated with @\"" + annotationType.getSimpleName()));\n \t}\n \n-\tprivate static List<Method> findMethodsAndCheckVoidReturnTypeAndNonPrivate(Class<?> testClass,\n-\t\t\tClass<? extends Annotation> annotationType, HierarchyTraversalMode traversalMode) {\n-\n-\t\tList<Method> methods = findAnnotatedMethods(testClass, annotationType, traversalMode);\n-\t\tmethods.forEach(method -> {\n-\t\t\tassertVoid(annotationType, method);\n-\t\t\tassertNonPrivate(annotationType, method);\n-\t\t});\n-\t\treturn methods;\n-\t}\n-\n-\tprivate static void assertStatic(Class<? extends Annotation> annotationType, Method method) {\n-\t\tif (ModifierSupport.isNotStatic(method)) {\n-\t\t\tthrow new JUnitException(String.format(\n-\t\t\t\t\""@%s method '%s' must be static unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS).\"",\n-\t\t\t\tannotationType.getSimpleName(), method.toGenericString()));\n-\t\t}\n-\t}\n-\n-\tprivate static void assertVoid(Class<? extends Annotation> annotationType, Method method) {\n-\t\tif (!returnsPrimitiveVoid(method)) {\n-\t\t\tthrow new JUnitException(String.format(\""@%s method '%s' must not return a value.\"",\n-\t\t\t\tannotationType.getSimpleName(), method.toGenericString()));\n-\t\t}\n-\t}\n-\n-\tprivate static void assertNonPrivate(Class<? extends Annotation> annotationType, Method method) {\n-\t\tif (ModifierSupport.isPrivate(method)) {\n-\t\t\tthrow new JUnitException(String.format(\""@%s method '%s' must not be private.\"",\n-\t\t\t\tannotationType.getSimpleName(), method.toGenericString()));\n-\t\t}\n-\t}\n-\n \tenum InjectionType {\n \t\tCONSTRUCTOR, FIELDS\n \t}\n"", ""test_patch"": ""diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java\nindex 469c477e2b51..b91c39bb4659 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java\n@@ -13,6 +13,8 @@\n import static java.util.stream.Collectors.toCollection;\n import static java.util.stream.Collectors.toList;\n import static org.apiguardian.api.API.Status.INTERNAL;\n+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_METHOD;\n+import static org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.validateClassTemplateInvocationLifecycleMethods;\n \n import java.util.ArrayList;\n import java.util.Collection;\n@@ -39,6 +41,7 @@\n import org.junit.platform.engine.TestDescriptor;\n import org.junit.platform.engine.TestTag;\n import org.junit.platform.engine.UniqueId;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n import org.junit.platform.engine.support.hierarchical.ExclusiveResource;\n import org.junit.platform.engine.support.hierarchical.Node;\n \n@@ -74,6 +77,15 @@ public Set<TestTag> getTags() {\n \t\treturn this.delegate.getTags();\n \t}\n \n+\t// --- Validatable ---------------------------------------------------------\n+\n+\t@Override\n+\tpublic void validate(DiscoveryIssueReporter reporter) {\n+\t\tthis.delegate.validate(reporter);\n+\t\tboolean requireStatic = this.classInfo.lifecycle == PER_METHOD;\n+\t\tvalidateClassTemplateInvocationLifecycleMethods(getTestClass(), requireStatic, reporter);\n+\t}\n+\n \t// --- Filterable ----------------------------------------------------------\n \n \t@Override\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedClassIntegrationTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedClassIntegrationTests.java\nindex 3bbfc99ff470..1f715d08935f 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedClassIntegrationTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedClassIntegrationTests.java\n@@ -27,6 +27,7 @@\n import static org.junit.jupiter.params.ParameterizedInvocationConstants.INDEX_PLACEHOLDER;\n import static org.junit.jupiter.params.provider.Arguments.argumentSet;\n import static org.junit.jupiter.params.provider.Arguments.arguments;\n+import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;\n import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;\n import static org.junit.platform.testkit.engine.EventConditions.container;\n import static org.junit.platform.testkit.engine.EventConditions.displayName;\n@@ -93,6 +94,7 @@\n import org.junit.jupiter.params.support.FieldContext;\n import org.junit.jupiter.params.support.ParameterDeclarations;\n import org.junit.platform.commons.util.StringUtils;\n+import org.junit.platform.engine.DiscoveryIssue;\n import org.junit.platform.engine.TestDescriptor;\n import org.junit.platform.engine.TestExecutionResult;\n import org.junit.platform.engine.UniqueId;\n@@ -607,23 +609,49 @@ void lifecycleMethodsNeedToBeStaticByDefault(String simpleClassName, String anno\n \n \t\t\tvar className = ParameterizedClassIntegrationTests.class.getName() + \""$\"" + simpleClassName;\n \n-\t\t\tvar results = executeTestsForClass(Class.forName(className));\n+\t\t\tvar results = discoverTestsForClass(Class.forName(className));\n \n-\t\t\tresults.containerEvents().assertThatEvents() //\n-\t\t\t\t\t.haveExactly(1, finishedWithFailure(message(\n-\t\t\t\t\t\t\""%s method 'void %s.%s()' must be static unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS).\"" //\n-\t\t\t\t\t\t\t\t.formatted(annotationName, className, lifecycleMethodName))));\n+\t\t\tvar issue = getOnlyElement(results.getDiscoveryIssues());\n+\t\t\tassertThat(issue.severity()) //\n+\t\t\t\t\t.isEqualTo(DiscoveryIssue.Severity.ERROR);\n+\t\t\tassertThat(issue.message()) //\n+\t\t\t\t\t.isEqualTo(\n+\t\t\t\t\t\t\""%s method 'void %s.%s()' must be static unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS).\"",\n+\t\t\t\t\t\tannotationName, className, lifecycleMethodName);\n+\t\t\tassertThat(issue.source()) //\n+\t\t\t\t\t.containsInstanceOf(org.junit.platform.engine.support.descriptor.MethodSource.class);\n \t\t}\n \n \t\t@Test\n \t\tvoid lifecycleMethodsMustNotBePrivate() {\n \n-\t\t\tvar results = executeTestsForClass(PrivateLifecycleMethodTestCase.class);\n+\t\t\tvar results = discoverTestsForClass(PrivateLifecycleMethodTestCase.class);\n \n-\t\t\tresults.containerEvents().assertThatEvents() //\n-\t\t\t\t\t.haveExactly(1, finishedWithFailure(message(\n-\t\t\t\t\t\t\""@BeforeParameterizedClassInvocation method 'private static void %s.beforeParameterizedClassInvocation()' must not be private.\"" //\n-\t\t\t\t\t\t\t\t.formatted(PrivateLifecycleMethodTestCase.class.getName()))));\n+\t\t\tvar issue = getOnlyElement(results.getDiscoveryIssues());\n+\t\t\tassertThat(issue.severity()) //\n+\t\t\t\t\t.isEqualTo(DiscoveryIssue.Severity.ERROR);\n+\t\t\tassertThat(issue.message()) //\n+\t\t\t\t\t.isEqualTo(\n+\t\t\t\t\t\t\""@BeforeParameterizedClassInvocation method 'private static void %s.beforeParameterizedClassInvocation()' must not be private.\"",\n+\t\t\t\t\t\tPrivateLifecycleMethodTestCase.class.getName());\n+\t\t\tassertThat(issue.source()) //\n+\t\t\t\t\t.containsInstanceOf(org.junit.platform.engine.support.descriptor.MethodSource.class);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid lifecycleMethodsMustNotDeclareReturnType() {\n+\n+\t\t\tvar results = discoverTestsForClass(NonVoidLifecycleMethodTestCase.class);\n+\n+\t\t\tvar issue = getOnlyElement(results.getDiscoveryIssues());\n+\t\t\tassertThat(issue.severity()) //\n+\t\t\t\t\t.isEqualTo(DiscoveryIssue.Severity.ERROR);\n+\t\t\tassertThat(issue.message()) //\n+\t\t\t\t\t.isEqualTo(\n+\t\t\t\t\t\t\""@BeforeParameterizedClassInvocation method 'static int %s.beforeParameterizedClassInvocation()' must not return a value.\"",\n+\t\t\t\t\t\tNonVoidLifecycleMethodTestCase.class.getName());\n+\t\t\tassertThat(issue.source()) //\n+\t\t\t\t\t.containsInstanceOf(org.junit.platform.engine.support.descriptor.MethodSource.class);\n \t\t}\n \n \t\t@Test\n@@ -1767,6 +1795,21 @@ void test() {\n \t\t}\n \t}\n \n+\t@ParameterizedClass\n+\t@ValueSource(ints = 1)\n+\trecord NonVoidLifecycleMethodTestCase() {\n+\n+\t\t@BeforeParameterizedClassInvocation\n+\t\tstatic int beforeParameterizedClassInvocation() {\n+\t\t\treturn fail(\""should not be called\"");\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid test() {\n+\t\t\tfail(\""should not be called\"");\n+\t\t}\n+\t}\n+\n \tstatic abstract class AbstractBaseLifecycleTestCase {\n \n \t\t@BeforeParameterizedClassInvocation\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""junit-team__junit5-4401"", ""pr_id"": 4401, ""issue_id"": 242, ""repo"": ""junit-team/junit5"", ""problem_statement"": ""Introduce error handling mechanism for validation and discovery errors\n## Overview\n\nThe JUnit Platform currently provides no means to report warnings and errors during test discovery. Thus, malformed test cases (for example, Jupiter test methods with a non-void return type) get silently ignored which poses a severe risk for downstream projects: something that looks like a test in a pull request diff might not actually get executed. Therefore, we should introduce a mechanism to collect and report warnings and errors and use it for the Jupiter and Vintage engines. In addition, we should reach out to third-party test engine open source projects and ask them to adopt the new mechanism.\n\nValidation errors (e.g., for invalid `@BeforeEach` method declarations) should not abort the entire discovery phase. Instead the _discovery phase_ should continue, with the error tracked and reported during the _execution phase_. \n\n## Areas of Applicability\n\n- [x] exceptions thrown by test engines, as discussed in #750\n- [x] unresolvable unique IDs, as discussed in #210\n  - note, however, that a TestEngine should not report a unique ID as unresolvable if the unique ID does not apply to the particular TestEngine (see #1026 ).\n- [x] invalid `@BeforeAll`, `@AfterAll`, `@BeforeEach`, and `@AfterEach` method declarations\n- [x] [Competing method-level annotations](https://github.com/marcphilipp/junit5/blob/202d939953a2fa61f54a1b0c70e74e122740a427/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java#L99-L108) (e.g. `@Test` _and_ `@TestTemplate` on the same method)\n- [x] invalid `@Test`, `@TestFactory`, `@RepeatedTest`, and `@ParameterizedTest` method declarations (see #2244)\n- [x] invalid `@Suite` class declarations\n- [x] invalid `@Nested` test class declarations (see #1223 and #2717)\n- [x] non-static test class declaration (see #2311)\n- [x] missing `@Nested` annotation (see #1736)\n- [x] _blank_ display names supplied by the user, as discussed in #743\n- [x] `@Order` annotations on test classes and methods when class/method orderer is not `OrderAnnotation`\n\n## Proposals\n\n1. Allow engines to track errors by creating a special type of `TestDescriptor` such as an `AlwaysFailingTestDescriptor`, `DeadOnArrivalTestDescriptor`, or `ErrorReportingTestDescriptor`.\n    - Tracked errors for such a corresponding `TestDescriptor` could then be thrown as an exception during the execution phase instead of executing the corresponding container or test.\n2. Introduce a new property in `TestDescriptor` that signals an error that was encountered during the _discovery phase_.\n3. Pass a _reporting object_ from the `Launcher` into each `TestEngine` to report errors.\n    - See https://github.com/junit-team/junit5/issues/242#issuecomment-294301875\n\n## Related Issues\n\n- #121 \n- #210 \n- #743 \n- #750 \n- #835\n- #876  \n- #971 \n- #1026 \n- #1074 \n- #1223\n- #1944\n- #2244\n- #2311\n- #2717\n- #4125\n\n## Deliverables\n\n- [x] #4385\n- [x] #4389\n- [x] #4393\n- [x] #4398\n- [x] Revisit the changes made in #971 and determine if it makes sense to move the look-up of lifecycle methods back to the constructor of `ClassTestDescriptor`.\n- [x] #4401\n- [x] #4405\n- [x] #4408\n- [x] #4415\n- [x] #4420\n- [x] Revisit the results of #835 and update the code accordingly by tracking such errors instead of just ignoring such incorrect usage.\n- [x] #4423\n- [x] #949\n- [x] #4429\n- [x] #4448\n- [x] #1736\n- [x] #4453\n- [x] #4456\n- [x] #4458\n- [x] #4459\n- [x] Use the new mechanism to replace the current ad hoc use of logging and transparent defaulting as a work-around.\n  - Search for `TODO [#242]` within the code base.\n  - See https://github.com/junit-team/junit5/issues/750#issuecomment-294296045\n- [x] Determine where else the new mechanism can be used and apply it.\n- [x] #4463\n- [x] #4465\n- [x] Reach out to third-party test engine authors and ask them to adopt the new mechanism\n\t- https://github.com/spockframework/spock/issues/2145\n\t- https://github.com/cucumber/cucumber-jvm/issues/2987"", ""issue_word_count"": 584, ""test_files_count"": 2, ""non_test_files_count"": 4, ""pr_changed_files"": [""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java"", ""junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolution.java"", ""junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/engine/MultipleTestableAnnotationsTests.java"", ""platform-tests/src/test/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolverTests.java""], ""pr_changed_test_files"": [""jupiter-tests/src/test/java/org/junit/jupiter/engine/MultipleTestableAnnotationsTests.java"", ""platform-tests/src/test/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolverTests.java""], ""base_commit"": ""22836eb0b10f31566577807a39952c5983e7222a"", ""head_commit"": ""2fe42d86a9e849d5679ca6737f302da5aa5f9d51"", ""repo_url"": ""https://github.com/junit-team/junit5/pull/4401"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/junit-team__junit5/4401"", ""dockerfile"": """", ""pr_merged_at"": ""2025-03-19T08:08:15.000Z"", ""patch"": ""diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java\nindex 1198d6da5a6d..1b6d6b48101e 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java\n@@ -40,7 +40,7 @@ public class DiscoverySelectorResolver {\n \tprivate static final EngineDiscoveryRequestResolver<JupiterEngineDescriptor> resolver = EngineDiscoveryRequestResolver.<JupiterEngineDescriptor> builder() //\n \t\t\t.addClassContainerSelectorResolver(new IsTestClassWithTests()) //\n \t\t\t.addSelectorResolver(ctx -> new ClassSelectorResolver(ctx.getClassNameFilter(), getConfiguration(ctx))) //\n-\t\t\t.addSelectorResolver(ctx -> new MethodSelectorResolver(getConfiguration(ctx))) //\n+\t\t\t.addSelectorResolver(ctx -> new MethodSelectorResolver(getConfiguration(ctx), ctx.getIssueReporter())) //\n \t\t\t.addTestDescriptorVisitor(ctx -> TestDescriptor.Visitor.composite( //\n \t\t\t\tnew ClassOrderingVisitor(getConfiguration(ctx)), //\n \t\t\t\tnew MethodOrderingVisitor(getConfiguration(ctx)), //\n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java\nindex 44479f7eb0c3..f956edfd7905 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java\n@@ -41,9 +41,9 @@\n import org.junit.jupiter.engine.discovery.predicates.IsTestFactoryMethod;\n import org.junit.jupiter.engine.discovery.predicates.IsTestMethod;\n import org.junit.jupiter.engine.discovery.predicates.IsTestTemplateMethod;\n-import org.junit.platform.commons.logging.Logger;\n-import org.junit.platform.commons.logging.LoggerFactory;\n import org.junit.platform.commons.util.ClassUtils;\n+import org.junit.platform.engine.DiscoveryIssue;\n+import org.junit.platform.engine.DiscoveryIssue.Severity;\n import org.junit.platform.engine.DiscoverySelector;\n import org.junit.platform.engine.TestDescriptor;\n import org.junit.platform.engine.UniqueId;\n@@ -52,6 +52,8 @@\n import org.junit.platform.engine.discovery.MethodSelector;\n import org.junit.platform.engine.discovery.NestedMethodSelector;\n import org.junit.platform.engine.discovery.UniqueIdSelector;\n+import org.junit.platform.engine.support.descriptor.MethodSource;\n+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;\n import org.junit.platform.engine.support.discovery.SelectorResolver;\n \n /**\n@@ -59,15 +61,16 @@\n  */\n class MethodSelectorResolver implements SelectorResolver {\n \n-\tprivate static final Logger logger = LoggerFactory.getLogger(MethodSelectorResolver.class);\n \tprivate static final MethodFinder methodFinder = new MethodFinder();\n \tprivate static final Predicate<Class<?>> testClassPredicate = new IsTestClassWithTests().or(\n \t\tnew IsNestedTestClass());\n \n-\tprotected final JupiterConfiguration configuration;\n+\tprivate final JupiterConfiguration configuration;\n+\tprivate final DiscoveryIssueReporter issueReporter;\n \n-\tMethodSelectorResolver(JupiterConfiguration configuration) {\n+\tMethodSelectorResolver(JupiterConfiguration configuration, DiscoveryIssueReporter issueReporter) {\n \t\tthis.configuration = configuration;\n+\t\tthis.issueReporter = issueReporter;\n \t}\n \n \t@Override\n@@ -97,14 +100,14 @@ private Resolution resolve(Context context, List<Class<?>> enclosingClasses, Cla\n \t\t\t\t.collect(toSet());\n \t\t// @formatter:on\n \t\tif (matches.size() > 1) {\n-\t\t\tlogger.warn(() -> {\n-\t\t\t\tStream<TestDescriptor> testDescriptors = matches.stream().map(Match::getTestDescriptor);\n-\t\t\t\treturn String.format(\n-\t\t\t\t\t\""Possible configuration error: method [%s] resulted in multiple TestDescriptors %s. \""\n-\t\t\t\t\t\t\t+ \""This is typically the result of annotating a method with multiple competing annotations \""\n-\t\t\t\t\t\t\t+ \""such as @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, etc.\"",\n-\t\t\t\t\tmethod.toGenericString(), testDescriptors.map(d -> d.getClass().getName()).collect(toList()));\n-\t\t\t});\n+\t\t\tStream<TestDescriptor> testDescriptors = matches.stream().map(Match::getTestDescriptor);\n+\t\t\tString message = String.format(\n+\t\t\t\t\""Possible configuration error: method [%s] resulted in multiple TestDescriptors %s. \""\n+\t\t\t\t\t\t+ \""This is typically the result of annotating a method with multiple competing annotations \""\n+\t\t\t\t\t\t+ \""such as @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, etc.\"",\n+\t\t\t\tmethod.toGenericString(), testDescriptors.map(d -> d.getClass().getName()).collect(toList()));\n+\t\t\tissueReporter.reportIssue(\n+\t\t\t\tDiscoveryIssue.builder(Severity.WARNING, message).source(MethodSource.from(method)));\n \t\t}\n \t\treturn matches.isEmpty() ? unresolved() : matches(matches);\n \t}\n\ndiff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolution.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolution.java\nindex 0064d7dd2f21..46670c941fc3 100644\n--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolution.java\n+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolution.java\n@@ -30,7 +30,6 @@\n \n import org.junit.platform.commons.JUnitException;\n import org.junit.platform.commons.util.UnrecoverableExceptions;\n-import org.junit.platform.engine.DiscoveryIssue;\n import org.junit.platform.engine.DiscoverySelector;\n import org.junit.platform.engine.EngineDiscoveryListener;\n import org.junit.platform.engine.EngineDiscoveryRequest;\n@@ -262,11 +261,6 @@ private <T extends TestDescriptor> Optional<T> createAndAdd(TestDescriptor paren\n \t\t\treturn child;\n \t\t}\n \n-\t\t@Override\n-\t\tpublic void reportIssue(DiscoveryIssue issue) {\n-\t\t\tissueReporter.reportIssue(issue);\n-\t\t}\n-\n \t}\n \n }\n\ndiff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java\nindex 11afb2f23e7b..a402a4679152 100644\n--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java\n+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java\n@@ -357,7 +357,7 @@ default Resolution resolve(DiscoverySelector selector, Context context) {\n \t * @see SelectorResolver\n \t */\n \t@API(status = STABLE, since = \""1.10\"")\n-\tinterface Context extends DiscoveryIssueReporter {\n+\tinterface Context {\n \n \t\t/**\n \t\t * Resolve the supplied {@link TestDescriptor}, if possible.\n"", ""test_patch"": ""diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/MultipleTestableAnnotationsTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/MultipleTestableAnnotationsTests.java\nindex 6aa1fc0e1c84..a03a569a0c76 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/MultipleTestableAnnotationsTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/MultipleTestableAnnotationsTests.java\n@@ -10,18 +10,15 @@\n \n package org.junit.jupiter.engine;\n \n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;\n-import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;\n-\n-import java.util.logging.Level;\n-import java.util.logging.LogRecord;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;\n \n import org.junit.jupiter.api.RepeatedTest;\n import org.junit.jupiter.api.RepetitionInfo;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.fixtures.TrackLogRecords;\n-import org.junit.platform.commons.logging.LogRecordListener;\n+import org.junit.platform.engine.DiscoveryIssue.Severity;\n+import org.junit.platform.engine.support.descriptor.MethodSource;\n \n /**\n  * Integration tests that verify the correct behavior for methods annotated\n@@ -32,23 +29,27 @@\n class MultipleTestableAnnotationsTests extends AbstractJupiterTestEngineTests {\n \n \t@Test\n-\tvoid testAndRepeatedTest(@TrackLogRecords LogRecordListener listener) {\n-\t\tdiscoverTests(request().selectors(selectClass(TestCase.class)).build());\n-\n-\t\t// @formatter:off\n-\t\tassertTrue(listener.stream(Level.WARNING)\n-\t\t\t.map(LogRecord::getMessage)\n-\t\t\t.anyMatch(m -> m.matches(\""Possible configuration error: method .+ resulted in multiple TestDescriptors .+\"")));\n-\t\t// @formatter:on\n+\tvoid testAndRepeatedTest() throws Exception {\n+\t\tvar results = discoverTestsForClass(TestCase.class);\n+\n+\t\tvar discoveryIssue = getOnlyElement(results.getDiscoveryIssues());\n+\n+\t\tassertThat(discoveryIssue.severity()) //\n+\t\t\t\t.isEqualTo(Severity.WARNING);\n+\t\tassertThat(discoveryIssue.message()) //\n+\t\t\t\t.matches(\""Possible configuration error: method .+ resulted in multiple TestDescriptors .+\"");\n+\t\tassertThat(discoveryIssue.source()) //\n+\t\t\t\t.contains(\n+\t\t\t\t\tMethodSource.from(TestCase.class.getDeclaredMethod(\""testAndRepeatedTest\"", RepetitionInfo.class)));\n \t}\n \n \t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n \tstatic class TestCase {\n \n-\t\t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n \t\t@Test\n \t\t@RepeatedTest(1)\n \t\tvoid testAndRepeatedTest(RepetitionInfo repetitionInfo) {\n+\t\t\tassertNotNull(repetitionInfo);\n \t\t}\n \n \t}\n\ndiff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolverTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolverTests.java\nindex 33fc84821de0..e93c016d0521 100644\n--- a/platform-tests/src/test/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolverTests.java\n+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolverTests.java\n@@ -31,11 +31,12 @@ public class EngineDiscoveryRequestResolverTests {\n \t@Test\n \tvoid allowsSelectorResolversToReportDiscoveryIssues() {\n \t\tvar resolver = EngineDiscoveryRequestResolver.builder() //\n-\t\t\t\t.addSelectorResolver(new SelectorResolver() {\n+\t\t\t\t.addSelectorResolver(ctx -> new SelectorResolver() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Resolution resolve(ClassSelector selector, Context context) {\n-\t\t\t\t\t\tcontext.reportIssue(DiscoveryIssue.builder(NOTICE, \""test\"") //\n-\t\t\t\t\t\t\t\t.source(ClassSource.from(selector.getClassName())));\n+\t\t\t\t\t\tctx.getIssueReporter() //\n+\t\t\t\t\t\t\t\t.reportIssue(DiscoveryIssue.builder(NOTICE, \""test\"") //\n+\t\t\t\t\t\t\t\t\t\t.source(ClassSource.from(selector.getClassName())));\n \t\t\t\t\t\treturn unresolved();\n \t\t\t\t\t}\n \t\t\t\t}) //\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""junit-team__junit5-4267"", ""pr_id"": 4267, ""issue_id"": 4163, ""repo"": ""junit-team/junit5"", ""problem_statement"": ""Change `ResourceLockProvider`'s methods to be in sync with `DisplayNameGenerator`\nAs outlined in https://github.com/junit-team/junit5/issues/4130#issuecomment-2493733172, `DisplayNameGenerator` is receiving new methods with an additional `List<Class<?>> enclosingInstanceTypes` parameter. Once that issue is resolved, we should change `ResourceLockProvider` accordingly. Since it's not yet released, we don't have to make it backward compatible, though.\n\n## Deliverables\n\n- [x] Add `List<Class<?>> enclosingInstanceTypes` parameter to `provideForNestedClass` and `provideForMethod` methods"", ""issue_word_count"": 73, ""test_files_count"": 6, ""non_test_files_count"": 2, ""pr_changed_files"": [""documentation/src/test/java/example/sharedresources/DynamicSharedResourcesDemo.java"", ""junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLocksProvider.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ResourceLockAware.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLockAnnotationTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLocksProviderTests.java""], ""pr_changed_test_files"": [""documentation/src/test/java/example/sharedresources/DynamicSharedResourcesDemo.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java"", ""junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLockAnnotationTests.java"", ""jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLocksProviderTests.java""], ""base_commit"": ""060f4db0e03f032ea4b39c042d75052deb4a5486"", ""head_commit"": ""48461277df10c8a9b21dfe2f9a15019ea31144ed"", ""repo_url"": ""https://github.com/junit-team/junit5/pull/4267"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/junit-team__junit5/4267"", ""dockerfile"": """", ""pr_merged_at"": ""2025-01-26T18:23:12.000Z"", ""patch"": ""diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLocksProvider.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLocksProvider.java\nindex d94024d99f3b..2cffc5d6101f 100644\n--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLocksProvider.java\n+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLocksProvider.java\n@@ -14,6 +14,7 @@\n import static org.apiguardian.api.API.Status.EXPERIMENTAL;\n \n import java.lang.reflect.Method;\n+import java.util.List;\n import java.util.Objects;\n import java.util.Set;\n \n@@ -43,7 +44,7 @@\n public interface ResourceLocksProvider {\n \n \t/**\n-\t * Add shared resources to a test class.\n+\t * Add shared resources for a test class.\n \t *\n \t * <p>Invoked in case a test class or its parent class is annotated with\n \t * {@code @ResourceLock(providers)}.\n@@ -60,8 +61,8 @@ default Set<Lock> provideForClass(Class<?> testClass) {\n \t}\n \n \t/**\n-\t * Add shared resources to a {@linkplain org.junit.jupiter.api.Nested @Nested}\n-\t * test class.\n+\t * Add shared resources for a\n+\t * {@link org.junit.jupiter.api.Nested @Nested} test class.\n \t *\n \t * <p>Invoked in case:\n \t * <ul>\n@@ -75,16 +76,24 @@ default Set<Lock> provideForClass(Class<?> testClass) {\n \t * the same semantics as annotating a nested test class with an analogous\n \t * {@code @ResourceLock(value, mode)} declaration.\n \t *\n+\t * @implNote The classes supplied as {@code enclosingInstanceTypes} may\n+\t * differ from the classes returned from invocations of\n+\t * {@link Class#getEnclosingClass()} &mdash; for example, when a nested test\n+\t * class is inherited from a superclass.\n+\t *\n+\t * @param enclosingInstanceTypes the runtime types of the enclosing\n+\t * instances for the test class, ordered from outermost to innermost,\n+\t * excluding {@code testClass}; never {@code null}\n \t * @param testClass a nested test class for which to add shared resources\n \t * @return a set of {@link Lock}; may be empty\n \t * @see org.junit.jupiter.api.Nested @Nested\n \t */\n-\tdefault Set<Lock> provideForNestedClass(Class<?> testClass) {\n+\tdefault Set<Lock> provideForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> testClass) {\n \t\treturn emptySet();\n \t}\n \n \t/**\n-\t * Add shared resources to a test method.\n+\t * Add shared resources for a test method.\n \t *\n \t * <p>Invoked in case:\n \t * <ul>\n@@ -97,13 +106,24 @@ default Set<Lock> provideForNestedClass(Class<?> testClass) {\n \t * has the same semantics as annotating a test method\n \t * with analogous {@code @ResourceLock(value, mode)}.\n \t *\n+\t * @implNote The classes supplied as {@code enclosingInstanceTypes} may\n+\t * differ from the classes returned from invocations of\n+\t * {@link Class#getEnclosingClass()} &mdash; for example, when a nested test\n+\t * class is inherited from a superclass. Similarly, the class instance\n+\t * supplied as {@code testClass} may differ from the class returned by\n+\t * {@code testMethod.getDeclaringClass()} &mdash; for example, when a test\n+\t * method is inherited from a superclass.\n+\t *\n+\t * @param enclosingInstanceTypes the runtime types of the enclosing\n+\t * instances for the test class, ordered from outermost to innermost,\n+\t * excluding {@code testClass}; never {@code null}\n \t * @param testClass the test class or {@link org.junit.jupiter.api.Nested @Nested}\n \t * test class that contains the {@code testMethod}\n \t * @param testMethod a test method for which to add shared resources\n \t * @return a set of {@link Lock}; may be empty\n \t * @see org.junit.jupiter.api.Nested @Nested\n \t */\n-\tdefault Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n+\tdefault Set<Lock> provideForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass, Method testMethod) {\n \t\treturn emptySet();\n \t}\n \n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ResourceLockAware.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ResourceLockAware.java\nindex e7aa88edea52..c4f427989036 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ResourceLockAware.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ResourceLockAware.java\n@@ -14,7 +14,11 @@\n \n import java.util.ArrayDeque;\n import java.util.Deque;\n+import java.util.List;\n import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n import java.util.stream.Stream;\n \n import org.junit.jupiter.api.parallel.ResourceLocksProvider;\n@@ -35,8 +39,10 @@ default Stream<ExclusiveResource> determineExclusiveResources() {\n \t\t\tparent = parent.getParent().orElse(null);\n \t\t}\n \n+\t\tFunction<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> evaluator = getResourceLocksProviderEvaluator();\n+\n \t\tif (ancestors.isEmpty()) {\n-\t\t\treturn determineOwnExclusiveResources();\n+\t\t\treturn determineOwnExclusiveResources(evaluator);\n \t\t}\n \n \t\tStream<ExclusiveResource> parentStaticResourcesForChildren = ancestors.getLast() //\n@@ -44,18 +50,37 @@ default Stream<ExclusiveResource> determineExclusiveResources() {\n \n \t\tStream<ExclusiveResource> ancestorDynamicResources = ancestors.stream() //\n \t\t\t\t.map(ResourceLockAware::getExclusiveResourceCollector) //\n-\t\t\t\t.flatMap(collector -> collector.getDynamicResources(this::evaluateResourceLocksProvider));\n+\t\t\t\t.flatMap(collector -> collector.getDynamicResources(evaluator));\n \n-\t\treturn Stream.of(ancestorDynamicResources, parentStaticResourcesForChildren, determineOwnExclusiveResources())//\n+\t\treturn Stream.of(ancestorDynamicResources, parentStaticResourcesForChildren,\n+\t\t\tdetermineOwnExclusiveResources(evaluator))//\n \t\t\t\t.flatMap(s -> s);\n \t}\n \n-\tdefault Stream<ExclusiveResource> determineOwnExclusiveResources() {\n-\t\treturn this.getExclusiveResourceCollector().getAllExclusiveResources(this::evaluateResourceLocksProvider);\n+\tdefault Stream<ExclusiveResource> determineOwnExclusiveResources(\n+\t\t\tFunction<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> providerToLocks) {\n+\t\treturn this.getExclusiveResourceCollector().getAllExclusiveResources(providerToLocks);\n \t}\n \n \tExclusiveResourceCollector getExclusiveResourceCollector();\n \n-\tSet<ResourceLocksProvider.Lock> evaluateResourceLocksProvider(ResourceLocksProvider provider);\n+\tFunction<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> getResourceLocksProviderEvaluator();\n+\n+\tstatic Function<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> enclosingInstanceTypesDependentResourceLocksProviderEvaluator(\n+\t\t\tSupplier<List<Class<?>>> enclosingInstanceTypesSupplier,\n+\t\t\tBiFunction<ResourceLocksProvider, List<Class<?>>, Set<ResourceLocksProvider.Lock>> evaluator) {\n+\t\treturn new Function<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>>() {\n+\n+\t\t\tprivate List<Class<?>> enclosingInstanceTypes;\n+\n+\t\t\t@Override\n+\t\t\tpublic Set<ResourceLocksProvider.Lock> apply(ResourceLocksProvider provider) {\n+\t\t\t\tif (this.enclosingInstanceTypes == null) {\n+\t\t\t\t\tthis.enclosingInstanceTypes = enclosingInstanceTypesSupplier.get();\n+\t\t\t\t}\n+\t\t\t\treturn evaluator.apply(provider, this.enclosingInstanceTypes);\n+\t\t\t}\n+\t\t};\n+\t}\n \n }\n"", ""test_patch"": ""diff --git a/documentation/src/test/java/example/sharedresources/DynamicSharedResourcesDemo.java b/documentation/src/test/java/example/sharedresources/DynamicSharedResourcesDemo.java\nindex 31f4c37e6bb3..4abe7297e357 100644\n--- a/documentation/src/test/java/example/sharedresources/DynamicSharedResourcesDemo.java\n+++ b/documentation/src/test/java/example/sharedresources/DynamicSharedResourcesDemo.java\n@@ -19,6 +19,7 @@\n \n import java.lang.reflect.Method;\n import java.util.Collections;\n+import java.util.List;\n import java.util.Properties;\n import java.util.Set;\n \n@@ -68,7 +69,8 @@ void canSetCustomPropertyToBanana() {\n \tstatic class Provider implements ResourceLocksProvider {\n \n \t\t@Override\n-\t\tpublic Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n+\t\tpublic Set<Lock> provideForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass,\n+\t\t\t\tMethod testMethod) {\n \t\t\tResourceAccessMode mode = testMethod.getName().startsWith(\""canSet\"") ? READ_WRITE : READ;\n \t\t\treturn Collections.singleton(new Lock(SYSTEM_PROPERTIES, mode));\n \t\t}\n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java\nindex 7c2a5571694c..e935db38e782 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java\n@@ -18,6 +18,7 @@\n import java.util.List;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n \n import org.apiguardian.api.API;\n import org.junit.jupiter.api.extension.TestInstances;\n@@ -79,8 +80,8 @@ protected TestInstances instantiateTestClass(JupiterEngineExecutionContext paren\n \t}\n \n \t@Override\n-\tpublic Set<ResourceLocksProvider.Lock> evaluateResourceLocksProvider(ResourceLocksProvider provider) {\n-\t\treturn provider.provideForClass(getTestClass());\n+\tpublic Function<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> getResourceLocksProviderEvaluator() {\n+\t\treturn provider -> provider.provideForClass(getTestClass());\n \t}\n \n }\n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java\nindex 52bf3c4ef8b9..3a5b785591f8 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java\n@@ -13,14 +13,17 @@\n import static org.apiguardian.api.API.Status.INTERNAL;\n import static org.junit.jupiter.api.parallel.ResourceLockTarget.CHILDREN;\n import static org.junit.jupiter.engine.descriptor.DisplayNameUtils.determineDisplayNameForMethod;\n+import static org.junit.jupiter.engine.descriptor.ResourceLockAware.enclosingInstanceTypesDependentResourceLocksProviderEvaluator;\n import static org.junit.platform.commons.util.CollectionUtils.forEachInReverseOrder;\n \n import java.lang.reflect.Method;\n+import java.util.Collections;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Optional;\n import java.util.Set;\n import java.util.function.Consumer;\n+import java.util.function.Function;\n import java.util.function.Supplier;\n \n import org.apiguardian.api.API;\n@@ -97,8 +100,18 @@ public ExclusiveResourceCollector getExclusiveResourceCollector() {\n \t}\n \n \t@Override\n-\tpublic Set<ResourceLocksProvider.Lock> evaluateResourceLocksProvider(ResourceLocksProvider provider) {\n-\t\treturn provider.provideForMethod(getTestClass(), getTestMethod());\n+\tpublic Function<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> getResourceLocksProviderEvaluator() {\n+\t\treturn enclosingInstanceTypesDependentResourceLocksProviderEvaluator(this::getEnclosingTestClasses,\n+\t\t\t(provider, enclosingInstanceTypes) -> provider.provideForMethod(enclosingInstanceTypes, getTestClass(),\n+\t\t\t\tgetTestMethod()));\n+\t}\n+\n+\tprivate List<Class<?>> getEnclosingTestClasses() {\n+\t\treturn getParent() //\n+\t\t\t\t.filter(ClassBasedTestDescriptor.class::isInstance) //\n+\t\t\t\t.map(ClassBasedTestDescriptor.class::cast) //\n+\t\t\t\t.map(ClassBasedTestDescriptor::getEnclosingTestClasses) //\n+\t\t\t\t.orElseGet(Collections::emptyList);\n \t}\n \n \t@Override\n\ndiff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java\nindex 72d11ce5b09e..b0619fa09cff 100644\n--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java\n+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java\n@@ -13,12 +13,14 @@\n import static java.util.Collections.emptyList;\n import static org.apiguardian.api.API.Status.INTERNAL;\n import static org.junit.jupiter.engine.descriptor.DisplayNameUtils.createDisplayNameSupplierForNestedClass;\n+import static org.junit.jupiter.engine.descriptor.ResourceLockAware.enclosingInstanceTypesDependentResourceLocksProviderEvaluator;\n \n import java.util.ArrayList;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n import java.util.function.Supplier;\n \n import org.apiguardian.api.API;\n@@ -94,8 +96,9 @@ protected TestInstances instantiateTestClass(JupiterEngineExecutionContext paren\n \t}\n \n \t@Override\n-\tpublic Set<ResourceLocksProvider.Lock> evaluateResourceLocksProvider(ResourceLocksProvider provider) {\n-\t\treturn provider.provideForNestedClass(getTestClass());\n+\tpublic Function<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> getResourceLocksProviderEvaluator() {\n+\t\treturn enclosingInstanceTypesDependentResourceLocksProviderEvaluator(this::getEnclosingTestClasses, (provider,\n+\t\t\t\tenclosingInstanceTypes) -> provider.provideForNestedClass(enclosingInstanceTypes, getTestClass()));\n \t}\n \n }\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLockAnnotationTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLockAnnotationTests.java\nindex b095a8d28e7c..60e7c36b808f 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLockAnnotationTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLockAnnotationTests.java\n@@ -361,7 +361,8 @@ public Set<Lock> provideForClass(Class<?> testClass) {\n \t\t\t}\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n+\t\t\tpublic Set<Lock> provideForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass,\n+\t\t\t\t\tMethod testMethod) {\n \t\t\t\treturn Set.of(new Lock(\""b1\""));\n \t\t\t}\n \t\t}\n@@ -369,7 +370,8 @@ public Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n \t\tstatic class MethodLevelProvider implements ResourceLocksProvider {\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n+\t\t\tpublic Set<Lock> provideForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass,\n+\t\t\t\t\tMethod testMethod) {\n \t\t\t\treturn Set.of(new Lock(\""b2\""));\n \t\t\t}\n \t\t}\n@@ -377,7 +379,7 @@ public Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n \t\tstatic class NestedClassLevelProvider implements ResourceLocksProvider {\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForNestedClass(Class<?> testClass) {\n+\t\t\tpublic Set<Lock> provideForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> testClass) {\n \t\t\t\treturn Set.of(new Lock(\""c1\""), new Lock(\""c2\"", ResourceAccessMode.READ));\n \t\t\t}\n \t\t}\n@@ -417,12 +419,13 @@ public Set<Lock> provideForClass(Class<?> testClass) {\n \t\tstatic class SecondClassLevelProvider implements ResourceLocksProvider {\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n+\t\t\tpublic Set<Lock> provideForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass,\n+\t\t\t\t\tMethod testMethod) {\n \t\t\t\treturn Set.of(new Lock(\""b2\"", ResourceAccessMode.READ));\n \t\t\t}\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForNestedClass(Class<?> testClass) {\n+\t\t\tpublic Set<Lock> provideForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> testClass) {\n \t\t\t\treturn Set.of(new Lock(\""c2\""));\n \t\t\t}\n \t\t}\n@@ -430,7 +433,7 @@ public Set<Lock> provideForNestedClass(Class<?> testClass) {\n \t\tstatic class NestedClassLevelProvider implements ResourceLocksProvider {\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForNestedClass(Class<?> testClass) {\n+\t\t\tpublic Set<Lock> provideForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> testClass) {\n \t\t\t\treturn Set.of(new Lock(\""c3\""));\n \t\t\t}\n \t\t}\n@@ -452,7 +455,8 @@ void test() {\n \t\tstatic class Provider implements ResourceLocksProvider {\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n+\t\t\tpublic Set<Lock> provideForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass,\n+\t\t\t\t\tMethod testMethod) {\n \t\t\t\treturn Set.of(new Lock(\""a1\""));\n \t\t\t}\n \t\t}\n\ndiff --git a/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLocksProviderTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLocksProviderTests.java\nindex 8a73be42b8ee..f5bc7a17b77b 100644\n--- a/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLocksProviderTests.java\n+++ b/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLocksProviderTests.java\n@@ -20,6 +20,7 @@\n import static org.junit.platform.testkit.engine.EventConditions.test;\n \n import java.lang.reflect.Method;\n+import java.util.List;\n import java.util.Set;\n import java.util.stream.Stream;\n \n@@ -60,6 +61,12 @@ void methodLevelProviderInNestedClass() {\n \t\tassertThat(events.filter(event(test(), finishedSuccessfully())::matches)).hasSize(2);\n \t}\n \n+\t@Test\n+\tvoid providesAccessToRuntimeEnclosingInstances() {\n+\t\tvar events = execute(SubClassLevelProviderTestCase.class);\n+\t\tassertThat(events.filter(event(test(), finishedSuccessfully())::matches)).hasSize(2);\n+\t}\n+\n \tprivate Stream<Event> execute(Class<?> testCase) {\n \t\treturn executeTestsForClass(testCase).allEvents().stream();\n \t}\n@@ -108,28 +115,35 @@ static class Provider implements ResourceLocksProvider {\n \t\t\tprivate static boolean isProvideForNestedClassCalled = false;\n \t\t\tprivate static boolean isProvideForNestedTestMethodCalled = false;\n \n+\t\t\tprivate Class<?> testClass;\n+\n \t\t\t@Override\n \t\t\tpublic Set<Lock> provideForClass(Class<?> testClass) {\n+\t\t\t\tthis.testClass = testClass;\n \t\t\t\tisProvideForClassCalled = true;\n-\t\t\t\tassertEquals(ClassLevelProviderTestCase.class, testClass);\n+\t\t\t\tassertThat(testClass).isAssignableTo(ClassLevelProviderTestCase.class);\n \t\t\t\treturn emptySet();\n \t\t\t}\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForNestedClass(Class<?> testClass) {\n+\t\t\tpublic Set<Lock> provideForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> testClass) {\n \t\t\t\tisProvideForNestedClassCalled = true;\n+\t\t\t\tassertEquals(List.of(this.testClass), enclosingInstanceTypes);\n \t\t\t\tassertEquals(ClassLevelProviderTestCase.NestedClass.class, testClass);\n \t\t\t\treturn emptySet();\n \t\t\t}\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n-\t\t\t\tif (testClass == ClassLevelProviderTestCase.class) {\n+\t\t\tpublic Set<Lock> provideForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass,\n+\t\t\t\t\tMethod testMethod) {\n+\t\t\t\tif (ClassLevelProviderTestCase.class.isAssignableFrom(testClass)) {\n+\t\t\t\t\tassertEquals(List.of(), enclosingInstanceTypes);\n \t\t\t\t\tassertEquals(\""test\"", testMethod.getName());\n \t\t\t\t\tisProvideForTestMethodCalled = true;\n \t\t\t\t\treturn emptySet();\n \t\t\t\t}\n \t\t\t\tif (testClass == ClassLevelProviderTestCase.NestedClass.class) {\n+\t\t\t\t\tassertEquals(List.of(this.testClass), enclosingInstanceTypes);\n \t\t\t\t\tassertEquals(\""nestedTest\"", testMethod.getName());\n \t\t\t\t\tisProvideForNestedTestMethodCalled = true;\n \t\t\t\t\treturn emptySet();\n@@ -140,6 +154,9 @@ public Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n \t\t}\n \t}\n \n+\tstatic class SubClassLevelProviderTestCase extends ClassLevelProviderTestCase {\n+\t}\n+\n \t@SuppressWarnings(\""JUnitMalformedDeclaration\"")\n \tstatic class NestedClassLevelProviderTestCase {\n \n@@ -177,15 +194,18 @@ public Set<Lock> provideForClass(Class<?> testClass) {\n \t\t\t}\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForNestedClass(Class<?> testClass) {\n+\t\t\tpublic Set<Lock> provideForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> testClass) {\n \t\t\t\tisProvideForNestedClassCalled = true;\n+\t\t\t\tassertEquals(List.of(NestedClassLevelProviderTestCase.class), enclosingInstanceTypes);\n \t\t\t\tassertEquals(NestedClass.class, testClass);\n \t\t\t\treturn emptySet();\n \t\t\t}\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n+\t\t\tpublic Set<Lock> provideForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass,\n+\t\t\t\t\tMethod testMethod) {\n \t\t\t\tisProvideForMethodCalled = true;\n+\t\t\t\tassertEquals(List.of(NestedClassLevelProviderTestCase.class), enclosingInstanceTypes);\n \t\t\t\tassertEquals(NestedClassLevelProviderTestCase.NestedClass.class, testClass);\n \t\t\t\tassertEquals(\""nestedTest\"", testMethod.getName());\n \t\t\t\treturn emptySet();\n@@ -226,14 +246,16 @@ public Set<Lock> provideForClass(Class<?> testClass) {\n \t\t\t}\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForNestedClass(Class<?> testClass) {\n+\t\t\tpublic Set<Lock> provideForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> testClass) {\n \t\t\t\tfail(\""'provideForNestedClass' should not be called\"");\n \t\t\t\treturn emptySet();\n \t\t\t}\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n+\t\t\tpublic Set<Lock> provideForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass,\n+\t\t\t\t\tMethod testMethod) {\n \t\t\t\tisProvideForMethodCalled = true;\n+\t\t\t\tassertEquals(List.of(), enclosingInstanceTypes);\n \t\t\t\tassertEquals(MethodLevelProviderTestCase.class, testClass);\n \t\t\t\tassertEquals(\""test\"", testMethod.getName());\n \t\t\t\treturn emptySet();\n@@ -274,14 +296,16 @@ public Set<Lock> provideForClass(Class<?> testClass) {\n \t\t\t}\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForNestedClass(Class<?> testClass) {\n+\t\t\tpublic Set<Lock> provideForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> testClass) {\n \t\t\t\tfail(\""'provideForNestedClass' should not be called\"");\n \t\t\t\treturn emptySet();\n \t\t\t}\n \n \t\t\t@Override\n-\t\t\tpublic Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {\n+\t\t\tpublic Set<Lock> provideForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass,\n+\t\t\t\t\tMethod testMethod) {\n \t\t\t\tisProvideForMethodCalled = true;\n+\t\t\t\tassertEquals(List.of(MethodLevelProviderInNestedClassTestCase.class), enclosingInstanceTypes);\n \t\t\t\tassertEquals(MethodLevelProviderInNestedClassTestCase.NestedClass.class, testClass);\n \t\t\t\tassertEquals(\""nestedTest\"", testMethod.getName());\n \t\t\t\treturn emptySet();\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
