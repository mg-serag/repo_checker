metadata
"{""instance_id"": ""eclipse__jetty.project-13233"", ""pr_id"": 13233, ""issue_id"": 13232, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Regression in ee9/ee8 getRequestDispatcher() exceptions\n**Jetty version(s)**\n12.0.22\n\n**Jetty Environment**\nee9 / ee8 (not ee10 onwards)\n\n**Description**\nIn Jetty 12.0.22, the exception produced from bad inputs on `getRequestDispatcher(String)` (both on `HttpServletRequest` and `ServletContext`) changed from `BadMessageException` to `IllegalStateException`.\n\nWhile in ee10 onwards, the `IllegalStateException` is expected, the legacy behavior that ee9/ee8 is attempting to maintain was changed in the 12.0.22 release.\n\nThe bad input applies to bad paths and bad queries.\nSome types of bad input trigger in the `getRequestDispatcher(String)` call, and some trigger in the subsequent `RequestDispatcher.forward(req,resp)` or `RequestDispatcher.include(req,resp)` calls.\n\n"", ""issue_word_count"": 107, ""test_files_count"": 2, ""non_test_files_count"": 2, ""pr_changed_files"": [""jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Dispatcher.java"", ""jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java"", ""jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/DispatcherTest.java"", ""jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/ServletContextHandlerTest.java""], ""pr_changed_test_files"": [""jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/DispatcherTest.java"", ""jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/ServletContextHandlerTest.java""], ""base_commit"": ""ab1c1d2f94c5438ecf00f1098d4d11b4c63482fd"", ""head_commit"": ""a294fc5aab4f7b5bc3b52ab668ebb429557ef56a"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/13233"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/13233"", ""dockerfile"": """", ""pr_merged_at"": ""2025-06-13T13:01:21.000Z"", ""patch"": ""diff --git a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Dispatcher.java b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Dispatcher.java\nindex 4d58e53e2ef0..0794954d0913 100644\n--- a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Dispatcher.java\n+++ b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Dispatcher.java\n@@ -26,6 +26,7 @@\n import jakarta.servlet.http.HttpServletMapping;\n import jakarta.servlet.http.HttpServletRequest;\n import jakarta.servlet.http.HttpServletResponse;\n+import org.eclipse.jetty.http.BadMessageException;\n import org.eclipse.jetty.http.HttpException;\n import org.eclipse.jetty.http.HttpURI;\n import org.eclipse.jetty.http.UriCompliance;\n@@ -100,8 +101,15 @@ public void include(ServletRequest request, ServletResponse response) throws Ser\n             else\n             {\n                 Objects.requireNonNull(_uri);\n-                // Check any URI violations against the compliance for this request\n-                checkUriViolations(_uri, baseRequest);\n+                try\n+                {\n+                    // Check any URI violations against the compliance for this request\n+                    checkUriViolations(_uri, baseRequest);\n+                }\n+                catch (IllegalStateException e)\n+                {\n+                    throw new BadMessageException(e.getMessage(), e);\n+                }\n \n                 IncludeAttributes attr = new IncludeAttributes(\n                     old_attr,\n@@ -165,8 +173,15 @@ protected void forward(ServletRequest request, ServletResponse response, Dispatc\n             else\n             {\n                 Objects.requireNonNull(_uri);\n-                // Check any URI violations against the compliance for this request\n-                checkUriViolations(_uri, baseRequest);\n+                try\n+                {\n+                    // Check any URI violations against the compliance for this request\n+                    checkUriViolations(_uri, baseRequest);\n+                }\n+                catch (IllegalStateException e)\n+                {\n+                    throw new BadMessageException(e.getMessage(), e);\n+                }\n \n                 // If we have already been forwarded previously, then keep using the established\n                 // original value. Otherwise, this is the first forward, and we need to establish the values.\n\ndiff --git a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java\nindex c449f33255a3..e32dce4ae708 100644\n--- a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java\n+++ b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java\n@@ -2197,7 +2197,18 @@ public void mergeQueryParameters(String oldQuery, String newQuery)\n         if (newQuery != null)\n         {\n             newQueryParams = new Fields(true);\n-            UrlEncoded.decodeTo(newQuery, newQueryParams::add, UrlEncoded.ENCODING);\n+            try\n+            {\n+                UrlEncoded.decodeTo(newQuery, newQueryParams::add, UrlEncoded.ENCODING);\n+            }\n+            catch (BadMessageException e)\n+            {\n+                throw e;\n+            }\n+            catch (Throwable th)\n+            {\n+                throw new BadMessageException(\""Bad query encoding\"", th);\n+            }\n         }\n \n         Fields oldQueryParams = _queryParameters;\n@@ -2208,6 +2219,10 @@ public void mergeQueryParameters(String oldQuery, String newQuery)\n             {\n                 UrlEncoded.decodeTo(oldQuery, oldQueryParams::add, getQueryCharset());\n             }\n+            catch (BadMessageException e)\n+            {\n+                throw e;\n+            }\n             catch (Throwable th)\n             {\n                 _queryParameters = BAD_PARAMS;\n"", ""test_patch"": ""diff --git a/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/DispatcherTest.java b/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/DispatcherTest.java\nindex 762d6503583f..ca7ae4511552 100644\n--- a/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/DispatcherTest.java\n+++ b/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/DispatcherTest.java\n@@ -424,7 +424,7 @@ public void testForwardWithBadParams() throws Exception\n             assertThat(response, containsString(\""forward\""));\n \n             response = _connector.getResponse(\""GET /context/forward/badparams?echo=badparams HTTP/1.0\\n\\n\"");\n-            assertThat(response, containsString(\"" 500 \""));\n+            assertThat(response, containsString(\"" 400 \""));\n \n             response = _connector.getResponse(\""GET /context/forward/?echo=badclient&bad=%88%A4 HTTP/1.0\\n\\n\"");\n             assertThat(response, containsString(\"" 400 \""));\n@@ -433,7 +433,7 @@ public void testForwardWithBadParams() throws Exception\n             assertThat(response, containsString(\"" 400 \""));\n \n             response = _connector.getResponse(\""GET /context/forward/badparams?echo=badclientandparam&bad=%88%A4 HTTP/1.0\\n\\n\"");\n-            assertThat(response, containsString(\"" 500 \""));\n+            assertThat(response, containsString(\"" 400 \""));\n         }\n     }\n \n\ndiff --git a/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/ServletContextHandlerTest.java b/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/ServletContextHandlerTest.java\nindex 78301bc026df..f4ef05cd4efc 100644\n--- a/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/ServletContextHandlerTest.java\n+++ b/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/ServletContextHandlerTest.java\n@@ -16,6 +16,7 @@\n import java.io.IOException;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n+import java.util.Base64;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.EnumSet;\n@@ -27,6 +28,7 @@\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n \n import jakarta.servlet.DispatcherType;\n import jakarta.servlet.Filter;\n@@ -34,6 +36,7 @@\n import jakarta.servlet.FilterConfig;\n import jakarta.servlet.FilterRegistration;\n import jakarta.servlet.GenericServlet;\n+import jakarta.servlet.RequestDispatcher;\n import jakarta.servlet.Servlet;\n import jakarta.servlet.ServletContainerInitializer;\n import jakarta.servlet.ServletContext;\n@@ -60,6 +63,7 @@\n import jakarta.servlet.http.HttpSessionIdListener;\n import jakarta.servlet.http.HttpSessionListener;\n import org.eclipse.jetty.ee9.nested.ContextHandler;\n+import org.eclipse.jetty.ee9.nested.Dispatcher;\n import org.eclipse.jetty.ee9.nested.Handler;\n import org.eclipse.jetty.ee9.nested.HandlerWrapper;\n import org.eclipse.jetty.ee9.nested.Request;\n@@ -67,6 +71,7 @@\n import org.eclipse.jetty.ee9.nested.SessionHandler;\n import org.eclipse.jetty.ee9.security.RoleInfo;\n import org.eclipse.jetty.ee9.security.SecurityHandler;\n+import org.eclipse.jetty.http.HttpStatus;\n import org.eclipse.jetty.http.HttpTester;\n import org.eclipse.jetty.logging.StacklessLogging;\n import org.eclipse.jetty.security.UserIdentity;\n@@ -81,13 +86,17 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n import org.junit.jupiter.params.provider.ValueSource;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n import static org.hamcrest.Matchers.sameInstance;\n@@ -2339,4 +2348,102 @@ protected void service(HttpServletRequest req, HttpServletResponse resp) throws\n         HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n         assertThat(response.getContent(), containsString(\""OK2\""));\n     }\n+\n+    public static Stream<Arguments> getRequestDispatcherCases()\n+    {\n+        List<String> inputs = List.of(\n+            // Bad path examples\n+            \""/..%2fbar/\"",\n+            // Bad Query examples\n+            \""/test?foo=%7=\"",\n+            \""/test?foo=abc%\"",\n+            \""/test?Name=%FF%FF%FF\"",\n+            \""/test?Name=%EF%EF%EF\"",\n+            \""/test?Name=X%c0%afZ\"",\n+            \""/test?Name=%E%F%F\""\n+        );\n+\n+        List<Arguments> cases = new ArrayList<>();\n+        for (String input : inputs)\n+        {\n+            cases.add(Arguments.of(input, \""forward\""));\n+            cases.add(Arguments.of(input, \""include\""));\n+        }\n+        return cases.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""getRequestDispatcherCases\"")\n+    public void testGetRequestDispatcherLegacyException(String requestDispatcherPath, String dispatcherMode) throws Exception\n+    {\n+        ServletContextHandler context = new ServletContextHandler(null, \""/context\"", ServletContextHandler.NO_SESSIONS);\n+        context.setCrossContextDispatchSupported(true);\n+        ErrorPageErrorHandler errorPageErrorHandler = new ErrorPageErrorHandler();\n+        errorPageErrorHandler.addErrorPage(400, \""/error\"");\n+        context.setErrorHandler(errorPageErrorHandler);\n+\n+        context.addServlet(new ServletHolder(\""dispatcher-servlet\"", new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\n+            {\n+                req.setAttribute(\""reached.testcase\"", \""true\"");\n+                String base64Path = req.getHeader(\""X-GetRequestDispatcher\"");\n+                String path = new String(Base64.getDecoder().decode(base64Path));\n+                RequestDispatcher requestDispatcher = req.getRequestDispatcher(path); // This can trigger an exception on bad path\n+                String mode = req.getHeader(\""X-DispatcherMode\"");\n+                req.setAttribute(\""mode.testcase\"", mode);\n+                switch (mode)\n+                {\n+                    case \""forward\"" -> requestDispatcher.forward(req, resp); // This can trigger an exception on bad query\n+                    case \""include\"" -> requestDispatcher.include(req, resp); // This can trigger an exception on bad query\n+                }\n+                // If we reached this point, then the input path isn't sufficiently bad enough to trigger\n+                // a BadMessageException.  That means the testcase input is itself not valid, and should be changed or removed.\n+                fail(\""Input path is not triggering an Exception: \\\""%s\\\""\"".formatted(path));\n+            }\n+        }), \""/dispatcher/*\"");\n+        context.addServlet(new ServletHolder(\""error-servlet\"", new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\n+            {\n+                resp.setCharacterEncoding(\""UTF-8\"");\n+                resp.setContentType(\""text/plain\"");\n+                PrintWriter out = resp.getWriter();\n+                out.printf(\""ERROR %s\\n\"", req.getAttribute(Dispatcher.ERROR_STATUS_CODE));\n+                // Make sure we actually reached the testcase servlet\n+                out.printf(\""reached.testcase=%s\\n\"", req.getAttribute(\""reached.testcase\""));\n+                out.printf(\""mode.testcase=%s\\n\"", req.getAttribute(\""mode.testcase\""));\n+                out.close();\n+            }\n+        }), \""/error\"");\n+\n+        _server.setHandler(context);\n+        _server.start();\n+\n+        // We want to test how HttpServletRequest.getRequestDispatcher(String) behaves with bad input.\n+        // So we encode the raw path into Base64 here to send over an HTTP header without the HTTP Parser freaking out\n+        // over badly formatted values in an HTTP Header (like invalid pct-encoding, truncated pct-encoding, or bad utf-8 sequences).\n+        String base64Path = Base64.getEncoder().encodeToString(requestDispatcherPath.getBytes(UTF_8));\n+\n+        String rawRequest = \""\""\""\n+            GET /context/dispatcher/ HTTP/1.1\\r\n+            Host: localhost\\r\n+            Connection: close\\r\n+            X-GetRequestDispatcher: %s\\r\n+            X-DispatcherMode: %s\\r\n+            \\r\n+            \""\""\"".formatted(base64Path, dispatcherMode);\n+\n+        String rawResponse = _connector.getResponse(rawRequest);\n+        HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n+        assertThat(response.getStatus(), is(HttpStatus.BAD_REQUEST_400));\n+        // Test response output to ensure we actually reached the getRequestDispatcher testcase code\n+        assertThat(response.getContent(), containsString(\""\""\""\n+            ERROR 400\n+            reached.testcase=true\n+            mode.testcase=%s\n+            \""\""\"".formatted(dispatcherMode)));\n+    }\n }\n\\ No newline at end of file\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-13182"", ""pr_id"": 13182, ""issue_id"": 13168, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""RFC2965_LEGACY cookie mode leads to request being unusable if cookie value is non-compliant\n**Jetty version(s)**\nJetty 12.0.17\n\n**Jetty Environment**\nEE10, but applicable for other EEs too\n\n**Description**\n\nWhen using `CookieCompliance.RFC2965_LEGACY` and receiving a request where a comma is used in the cookie value, followed by one of the symbols not valid in a cookie name, an exception is thrown from the servlet/filter implementation on an attempted access to the request cookies:\n\n```\njava.lang.IllegalArgumentException: Cookie name \""c/u\"" is a reserved token or contains an invalid character for a cookie name\n\tat jakarta.servlet.http.Cookie.<init>(Cookie.java:133) ~[jakarta.servlet-api-6.0.0.jar:6.0.0]\n\tat org.eclipse.jetty.ee10.servlet.ServletApiRequest.convertCookie(ServletApiRequest.java:378) ~[jetty-ee10-servlet-12.0.17.jar:12.0.17]\n\tat org.eclipse.jetty.server.CookieCache.convert(CookieCache.java:292) ~[jetty-server-12.0.17.jar:12.0.17]\n\tat org.eclipse.jetty.server.CookieCache.getApiCookies(CookieCache.java:266) ~[jetty-server-12.0.17.jar:12.0.17]\n\tat org.eclipse.jetty.server.CookieCache.getApiCookies(CookieCache.java:107) ~[jetty-server-12.0.17.jar:12.0.17]\n\tat org.eclipse.jetty.ee10.servlet.ServletApiRequest.getCookies(ServletApiRequest.java:372) ~[jetty-ee10-servlet-12.0.17.jar:12.0.17]\n```\n\nMeanwhile, when using `CookieCompliance.RFC2965`, a cookie with an incorrect value is getting discarded, and the `getCookies` method works.\n\nThe behavior of `CookieCompliance.RFC2965_LEGACY` is effectively more restrictive than `CookieCompliance.RFC2965`, as it renders such a request unusable if the application code accesses the cookies, while it should be more permissible:\n\n```java\n    /**\n     * A CookieCompliance mode that allows <a href=\""https://tools.ietf.org/html/rfc2965\"">RFC 2965</a> compliance.\n     */\n    public static final CookieCompliance RFC2965_LEGACY;\n\n    /**\n     * A CookieCompliance mode that allows <a href=\""https://tools.ietf.org/html/rfc2965\"">RFC 2965</a> compliance\n     * but does <b>not</b> allow:\n     * <ul>\n     * <li>{@link Violation#BAD_QUOTES}</li>\n     * <li>{@link Violation#COMMA_NOT_VALID_OCTET}</li>\n     * <li>{@link Violation#RESERVED_NAMES_NOT_DOLLAR_PREFIXED}</li>\n     * </ul>\n     */\n    public static final CookieCompliance RFC2965;\n```\n \n\n**How to reproduce?**\n\nRun Jetty server with `CookieCompliance.RFC2965_LEGACY` and call\n```sh\ncurl '<endpoint>' -b 'c=A==,b==,c/u=='\n```\n\nIn this example, a second comma is seen as a cookie separator (equivalent to \"";\""), and \""c/u\"" is attempted to be parsed as a cookie name.\n\n"", ""issue_word_count"": 380, ""test_files_count"": 2, ""non_test_files_count"": 2, ""pr_changed_files"": [""jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/CookieCompliance.java"", ""jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/CookieCutter.java"", ""jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/CookieCutterTest.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ServerHttpCookieTest.java""], ""pr_changed_test_files"": [""jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/CookieCutterTest.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ServerHttpCookieTest.java""], ""base_commit"": ""d874262fdc8395e28b5dcd4e586a52671bcbf843"", ""head_commit"": ""764e0e9bab960341f50a606d4f1181bffb8fa771"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/13182"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/13182"", ""dockerfile"": """", ""pr_merged_at"": ""2025-05-29T14:35:31.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/CookieCompliance.java b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/CookieCompliance.java\nindex 7e0a26f48a49..fbd6fc25d4e9 100644\n--- a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/CookieCompliance.java\n+++ b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/CookieCompliance.java\n@@ -165,7 +165,8 @@ public String getDescription()\n     );\n \n     /**\n-     * A CookieCompliance mode that allows <a href=\""https://tools.ietf.org/html/rfc2965\"">RFC 2965</a> compliance.\n+     * A CookieCompliance mode that allows <a href=\""https://tools.ietf.org/html/rfc2965\"">RFC 2965</a> compliance, but with\n+     * exceptions that match the behavior of legacy Jetty releases.\n      */\n     public static final CookieCompliance RFC2965_LEGACY = new CookieCompliance(\""RFC2965_LEGACY\"", allOf(Violation.class));\n \n@@ -174,12 +175,11 @@ public String getDescription()\n      * but does <b>not</b> allow:\n      * <ul>\n      * <li>{@link Violation#BAD_QUOTES}</li>\n-     * <li>{@link Violation#COMMA_NOT_VALID_OCTET}</li>\n      * <li>{@link Violation#RESERVED_NAMES_NOT_DOLLAR_PREFIXED}</li>\n      * </ul>\n      */\n     public static final CookieCompliance RFC2965 = new CookieCompliance(\""RFC2965\"", complementOf(of(\n-        Violation.BAD_QUOTES, Violation.COMMA_NOT_VALID_OCTET, Violation.RESERVED_NAMES_NOT_DOLLAR_PREFIXED)\n+        Violation.BAD_QUOTES, Violation.RESERVED_NAMES_NOT_DOLLAR_PREFIXED)\n     ));\n \n     private static final List<CookieCompliance> KNOWN_MODES = Arrays.asList(RFC6265, RFC6265_STRICT, RFC6265_LEGACY, RFC2965, RFC2965_LEGACY);\n@@ -211,9 +211,9 @@ public static CookieCompliance valueOf(String name)\n      * with a '-' to exclude them from the mode.  Examples are:\n      * </p>\n      * <dl>\n-     * <dt>{@code 0,RESERVED_NAMES_NOT_DOLLAR_PREFIXED}</dt><dd>Only allow {@link CookieCompliance.Violation#RESERVED_NAMES_NOT_DOLLAR_PREFIXED}</dd>\n-     * <dt>{@code *,-RESERVED_NAMES_NOT_DOLLAR_PREFIXED}</dt><dd>Allow all violations, except {@link CookieCompliance.Violation#RESERVED_NAMES_NOT_DOLLAR_PREFIXED}</dd>\n-     * <dt>{@code RFC2965,RESERVED_NAMES_NOT_DOLLAR_PREFIXED}</dt><dd>Same as RFC2965, but allows {@link CookieCompliance.Violation#RESERVED_NAMES_NOT_DOLLAR_PREFIXED}</dd>\n+     * <dt>{@code 0,ESCAPE_IN_QUOTES}</dt><dd>Only allow {@link CookieCompliance.Violation#ESCAPE_IN_QUOTES}</dd>\n+     * <dt>{@code *,-ESCAPE_IN_QUOTES}</dt><dd>Allow all violations, except {@link CookieCompliance.Violation#ESCAPE_IN_QUOTES}</dd>\n+     * <dt>{@code RFC2965,ESCAPE_IN_QUOTES}</dt><dd>Same as RFC2965, but allows {@link CookieCompliance.Violation#ESCAPE_IN_QUOTES}</dd>\n      * </dl>\n      *\n      * @param spec A string describing the compliance\n\ndiff --git a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/CookieCutter.java b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/CookieCutter.java\nindex 38bb55e87855..a4099b3e117b 100644\n--- a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/CookieCutter.java\n+++ b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/CookieCutter.java\n@@ -210,6 +210,14 @@ else if (tokenstart >= 0)\n                                         // This is a new cookie, so add the completed last cookie if we have one\n                                         if (cookieName != null)\n                                         {\n+                                            if (!isLegacyCookieName(cookieName))\n+                                            {\n+                                                if (!_complianceMode.allows(INVALID_COOKIES))\n+                                                    throw new InvalidCookieException(\""Bad Cookie Name\"");\n+                                                reportComplianceViolation(INVALID_COOKIES, hdr);\n+                                                reject = true;\n+                                            }\n+\n                                             if (reject)\n                                             {\n                                                 if (_complianceMode.allows(INVALID_COOKIES))\n@@ -385,4 +393,25 @@ protected boolean isRFC6265RejectedCharacter(char c)\n             c == ';' || // semicolon\n             c == '\\\\';  // backslash\n     }\n+\n+    private boolean isLegacyCookieNameToken(char c)\n+    {\n+        return c >= 0x20 && c < 0x7f && \""/()<>@,;:\\\\\\\""[]?={} \\t\"".indexOf(c) == -1;\n+    }\n+\n+    private boolean isLegacyCookieName(String name)\n+    {\n+        for (int i = 0; i < name.length(); i++)\n+            if (!isLegacyCookieNameToken(name.charAt(i)))\n+                return false;\n+        return !name.equalsIgnoreCase(\""Comment\"") && // rfc2019\n+            !name.equalsIgnoreCase(\""Discard\"") && // 2019++\n+            !name.equalsIgnoreCase(\""Domain\"") &&\n+            !name.equalsIgnoreCase(\""Expires\"") && // (old cookies)\n+            !name.equalsIgnoreCase(\""Max-Age\"") && // rfc2019\n+            !name.equalsIgnoreCase(\""Path\"") &&\n+            !name.equalsIgnoreCase(\""Secure\"") &&\n+            !name.equalsIgnoreCase(\""Version\"") &&\n+            !name.startsWith(\""$\"");\n+    }\n }\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/CookieCutterTest.java b/jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/CookieCutterTest.java\nindex 709f0d3ae0ee..9167cba06c84 100644\n--- a/jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/CookieCutterTest.java\n+++ b/jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/CookieCutterTest.java\n@@ -26,7 +26,12 @@ public class CookieCutterTest\n {\n     private Cookie[] parseCookieHeaders(CookieCompliance compliance, String... headers)\n     {\n-        TestCutter cutter = new TestCutter(compliance, null);\n+        return parseCookieHeaders(compliance, null, headers);\n+    }\n+\n+    private Cookie[] parseCookieHeaders(CookieCompliance compliance, ComplianceViolation.Listener listener, String... headers)\n+    {\n+        TestCutter cutter = new TestCutter(compliance, listener);\n         for (String header : headers)\n         {\n             cutter.parseFields(header);\n@@ -46,6 +51,20 @@ private void assertCookie(String prefix, Cookie cookie,\n         assertThat(prefix + \"".path\"", cookie.getPath(), is(expectedPath));\n     }\n \n+    /**\n+     * Example from RFC2109 and RFC2965\n+     */\n+    @Test\n+    public void testLEGACY()\n+    {\n+        String rawCookie = \""a=A=,b=B=,c/u=CU=,d=D=\"";\n+        Cookie[] cookies = parseCookieHeaders(CookieCompliance.RFC2965_LEGACY, rawCookie);\n+        assertThat(cookies.length, is(3));\n+        assertCookie(\""0\"", cookies[0], \""a\"", \""A=\"", 0, null);\n+        assertCookie(\""1\"", cookies[1], \""b\"", \""B=\"", 0, null);\n+        assertCookie(\""2\"", cookies[2], \""d\"", \""D=\"", 0, null);\n+    }\n+\n     /**\n      * Example from RFC2109 and RFC2965\n      */\n@@ -283,6 +302,12 @@ public String getComment()\n         {\n             return comment;\n         }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return \""Cookie: \"" + name + \"" = \"" + value;\n+        }\n     }\n \n     class TestCutter implements CookieParser.Handler\n\ndiff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ServerHttpCookieTest.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ServerHttpCookieTest.java\nindex 7d0aede6fbb0..00455845513a 100644\n--- a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ServerHttpCookieTest.java\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ServerHttpCookieTest.java\n@@ -97,6 +97,12 @@ public static Stream<Arguments> requestCases()\n         return Stream.of(\n             Arguments.of(RFC6265_STRICT, \""Cookie: name=value\"", 200, \""Version=\"", List.of(\""[name=value]\"").toArray(new String[0])),\n \n+            // LEGACY Test\n+            Arguments.of(RFC2965, \""Cookie: c=A==,b==,c/u==,z=f\"", 200, \""Version=\"", List.of(\""[c=A==]\"", \""[b==]\"").toArray(new String[0])),\n+            Arguments.of(RFC2965_LEGACY, \""Cookie: c=A==,b==,c/u==,z=f\"", 200, \""Version=\"", List.of(\""[c=A==]\"", \""[b==]\"", \""[z=f]\"").toArray(new String[0])),\n+            Arguments.of(RFC6265, \""Cookie: c/u=v\"", 200, \""Version=\"", new String[0]),\n+            Arguments.of(RFC6265_LEGACY, \""Cookie: c/u=v\"", 200, \""Version=\"", new String[0]),\n+\n             // Attribute tests\n             Arguments.of(RFC6265_STRICT, \""Cookie:  $version=1; name=value\"", 200, \""Version=\"", List.of(\""[$version=1]\"", \""[name=value]\"").toArray(new String[0])),\n             Arguments.of(RFC6265, \""Cookie: $version=1; name=value\"", 200, \""Version=\"", List.of(\""[$version=1]\"", \""[name=value]\"").toArray(new String[0])),\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-13165"", ""pr_id"": 13165, ""issue_id"": 13057, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""InvalidPathException instead of MalformedURLException after switching to jetty12\n**Jetty version(s)**\n12.0.16\n\n**Jetty Environment**\nee10\n\n**Java version/vendor**\njava version \""21.0.2\"" 2024-01-16 LTS\nJava(TM) SE Runtime Environment (build 21.0.2+13-LTS-58)\nJava HotSpot(TM) 64-Bit Server VM (build 21.0.2+13-LTS-58, mixed mode, sharing)\n\n**OS type/version**\nwindows 11\n\n**Description**\nIn our application we are trying to get the resource. In some cases it can be an html file\n```java\njakarta.servlet.ServletContext.getResource(\""/test.html\"");\n```\nor even html code\n```java\njakarta.servlet.ServletContext.getResource(\""/Welcome home <br>\"");\n```\n\nIn case of use of html code, after switching to jetty12 and org.eclipse.jetty.ee10.webapp.WebAppContext we got an InvalidPathException instead of MalformedURLException, which caused our application to crash.\n\n```\nCaused by: java.nio.file.InvalidPathException: Illegal char <<> at index XXX: C:/XXX/webapp/Welcome home <br>\n        at sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:204) ~[?:?]\n        at sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:175) ~[?:?]\n        at sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77) ~[?:?]\n        at sun.nio.fs.WindowsPath.parse(WindowsPath.java:92) ~[?:?]\n        at sun.nio.fs.WindowsUriSupport.fromUri(WindowsUriSupport.java:166) ~[?:?]\n        at sun.nio.fs.WindowsFileSystemProvider.getPath(WindowsFileSystemProvider.java:96) ~[?:?]\n        at java.nio.file.Path.of(Path.java:204) ~[?:?]\n        at java.nio.file.Paths.get(Paths.java:98) ~[?:?]\n        at org.eclipse.jetty.util.resource.PathResource.resolve(PathResource.java:294) ~[?:?]\n        at org.eclipse.jetty.ee10.servlet.ServletContextHandler.getResource(ServletContextHandler.java:774) ~[?:?]\n        at org.eclipse.jetty.ee10.webapp.WebAppContext.getResource(WebAppContext.java:366) ~[?:?]\n        at org.eclipse.jetty.ee10.webapp.WebAppContext$ServletApiContext.getResource(WebAppContext.java:1478) ~[?:?]\n```\n\n**How to reproduce?**\n```java\npackage org.example;\n\nimport org.eclipse.jetty.ee10.annotations.AnnotationConfiguration;\nimport org.eclipse.jetty.ee10.plus.webapp.EnvConfiguration;\nimport org.eclipse.jetty.ee10.plus.webapp.PlusConfiguration;\nimport org.eclipse.jetty.ee10.webapp.*;\nimport org.eclipse.jetty.ee10.websocket.jakarta.server.config.JakartaWebSocketConfiguration;\nimport org.eclipse.jetty.server.AllowedResourceAliasChecker;\nimport org.eclipse.jetty.server.Request;\nimport org.eclipse.jetty.server.Server;\nimport org.eclipse.jetty.server.handler.ContextHandlerCollection;\nimport org.eclipse.jetty.server.handler.ErrorHandler;\nimport org.eclipse.jetty.util.ClassMatcher;\n\nimport java.io.IOException;\nimport java.io.Writer;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tContextHandlerCollection contexts = new ContextHandlerCollection();\n\t\tServer server = new Server(8080);\n\t\tWebAppContext webapp = new WebAppContext();\n\t\twebapp.setContextPath(\""/\"");\n\t\twebapp.setBaseResourceAsString(\""C:\\\\Projects\\\\embedded-jetty\\\\src\\\\main\\\\webapp\\\\\"");\n\t\twebapp.setTempDirectoryPersistent(true);\n\t\twebapp.setThrowUnavailableOnStartupException(true);\n\t\twebapp.addAliasCheck(new AllowedResourceAliasChecker(webapp));\n\t\twebapp.setDefaultsDescriptor(null);\n\t\twebapp.addHiddenClassMatcher(new ClassMatcher(\""org.slf4j.impl.StaticLoggerBinder\""));\n\t\twebapp.setConfigurations(new org.eclipse.jetty.ee10.webapp.Configuration[] { new WebInfConfiguration(), new MetaInfConfiguration(), new FragmentConfiguration(), new EnvConfiguration(), new PlusConfiguration(), new AnnotationConfiguration(), new WebXmlConfiguration(), new JakartaWebSocketConfiguration() });\n\t\tErrorHandler errorHandler = new ErrorHandler() {\n\t\t\t@Override\n\t\t\tprotected void writeErrorHtmlBody(Request request, Writer writer, int code, String message, Throwable cause, boolean showStacks) throws IOException {\n\t\t\t\tString uri = request.getHttpURI().asString();\n\t\t\t\tthis.writeErrorHtmlMessage(request, writer, code, message, null, uri);\n\t\t\t}\n\t\t};\n\t\twebapp.setErrorHandler(errorHandler);\n\t\twebapp.addServlet(new JakartaServlet(), \""/test\"");\n\t\tcontexts.addHandler(webapp);\n\t\tserver.setHandler(contexts);\n\t\tserver.start();\n\t\tSystem.out.println(\""Server started at http://localhost:8080/\"");\n\t\tserver.join();\n\t}\n}\n```\n```java\npackage org.example;\n\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.MalformedURLException;\n\n@WebServlet(\""/test\"")\npublic class JakartaServlet extends HttpServlet {\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n\t\tPrintWriter out = resp.getWriter();\n\t\tout.println(\""HELLO FROM JAKARTA!\"");\n\t\ttry {\n\t\t\tgetServletContext().getResource(\""Welcome home <br>\"");\n\t\t} catch (MalformedURLException e) {\n\t\t\t// WORKS\n\t\t\tSystem.out.println(\""1 : ERROR : \"" + e.getMessage());\n\t\t}\n\t\ttry {\n\t\t\tgetServletContext().getResource(\""/Welcome home <br>\"");\n\t\t} catch (MalformedURLException e) {\n\t\t\t// DOES NOT WORK (THROWS java.nio.file.InvalidPathException)\n\t\t\tSystem.out.println(\""2 : ERROR : \"" + e.getMessage());\n\t\t}\n\t\t// DOES NOT PRINT\n\t\tSystem.out.println(\""+++END+++\"");\n\t}\n}\n```\n```\n<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n<project xmlns=\""http://maven.apache.org/POM/4.0.0\""\n         xmlns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\""\n         xsi:schemaLocation=\""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>embedded-jetty</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <packaging>jar</packaging>\n\n    <properties>\n        <maven.compiler.source>17</maven.compiler.source>\n        <maven.compiler.target>17</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <jetty.version>12.0.16</jetty.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.eclipse.jetty.ee10.websocket</groupId>\n            <artifactId>jetty-ee10-websocket-jakarta-server</artifactId>\n            <version>${jetty.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-simple</artifactId>\n            <version>1.7.36</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <configuration>\n                    <source>17</source>\n                    <target>17</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.0</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\""org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\"">\n                                    <mainClass>org.example.Main</mainClass>\n                                </transformer>\n                            </transformers>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n1. mvn clean install\n2. run jetty server \n```\nC:\\Java\\jdk-21\\bin\\java -jar C:/Projects/embedded-jetty/target/embedded-jetty-1.0-SNAPSHOT.jar\n```\n3. open localhost:8080/test\n4. an error is displayed\n\n"", ""issue_word_count"": 853, ""test_files_count"": 2, ""non_test_files_count"": 9, ""pr_changed_files"": [""jetty-ee10/jetty-ee10-servlet/pom.xml"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/CrossContextServletContext.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextHandler.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/ServletContextResourcesTest.java"", ""jetty-ee10/jetty-ee10-webapp/src/main/java/org/eclipse/jetty/ee10/webapp/WebAppContext.java"", ""jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java"", ""jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/CrossContextServletContext.java"", ""jetty-ee9/jetty-ee9-servlet/pom.xml"", ""jetty-ee9/jetty-ee9-servlet/src/main/java/module-info.java"", ""jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/ServletContextResourcesTest.java"", ""jetty-ee9/jetty-ee9-webapp/src/main/java/org/eclipse/jetty/ee9/webapp/WebAppContext.java""], ""pr_changed_test_files"": [""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/ServletContextResourcesTest.java"", ""jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/ServletContextResourcesTest.java""], ""base_commit"": ""64491a10bf579bab656263fa9b05858b746bfd23"", ""head_commit"": ""14248f5294605555465d3934b2db488f08110132"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/13165"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/13165"", ""dockerfile"": """", ""pr_merged_at"": ""2025-05-29T13:56:45.000Z"", ""patch"": ""diff --git a/jetty-ee10/jetty-ee10-servlet/pom.xml b/jetty-ee10/jetty-ee10-servlet/pom.xml\nindex e47055299df2..01f51759bf49 100644\n--- a/jetty-ee10/jetty-ee10-servlet/pom.xml\n+++ b/jetty-ee10/jetty-ee10-servlet/pom.xml\n@@ -86,7 +86,6 @@\n         <artifactId>maven-surefire-plugin</artifactId>\n         <configuration>\n           <argLine>@{argLine} ${jetty.surefire.argLine}\n-            --add-modules org.eclipse.jetty.util.ajax\n             --add-reads org.eclipse.jetty.ee10.servlet=org.eclipse.jetty.logging</argLine>\n         </configuration>\n       </plugin>\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/CrossContextServletContext.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/CrossContextServletContext.java\nindex 78db368d1f34..bec39cb4ba39 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/CrossContextServletContext.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/CrossContextServletContext.java\n@@ -113,7 +113,19 @@ public Set<String> getResourcePaths(String path)\n     @Override\n     public URL getResource(String path) throws MalformedURLException\n     {\n-        return _targetContext.getBaseResource().resolve(path).getURI().toURL();\n+        try\n+        {\n+            return _targetContext.getBaseResource().resolve(path).getURI().toURL();\n+        }\n+        catch (MalformedURLException e)\n+        {\n+            throw e;\n+        }\n+        catch (Throwable e)\n+        {\n+            // catch IOException, RuntimeException, and things like java.nio.fileInvalidPathException here.\n+            throw (MalformedURLException)new MalformedURLException(path).initCause(e);\n+        }\n     }\n \n     @Override\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextHandler.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextHandler.java\nindex 37525962946c..5a8da0264046 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextHandler.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextHandler.java\n@@ -2856,29 +2856,41 @@ else if (path.charAt(0) != '/')\n         @Override\n         public URL getResource(String path) throws MalformedURLException\n         {\n-            // This is an API call from the application which may pass non-normalized paths.\n-            // Thus, we normalize here, to avoid the enforcement of normalized paths in\n-            // ServletContextHandler.this.getResource(path).\n-            path = URIUtil.normalizePath(path);\n-            if (path == null)\n-                return null;\n+            try\n+            {\n+                // This is an API call from the application which may pass non-normalized paths.\n+                // Thus, we normalize here, to avoid the enforcement of normalized paths in\n+                // ServletContextHandler.this.getResource(path).\n+                path = URIUtil.normalizePath(path);\n+                if (path == null)\n+                    return null;\n \n-            // Assumption is that the resource base has been properly setup.\n-            // Spec requirement is that the WAR file is interrogated first.\n-            // If a WAR file is mounted, or is extracted to a temp directory,\n-            // then the first entry of the resource base must be the WAR file.\n-            Resource resource = ServletContextHandler.this.getResource(path);\n-            if (resource == null)\n-                return null;\n+                // Assumption is that the resource base has been properly setup.\n+                // Spec requirement is that the WAR file is interrogated first.\n+                // If a WAR file is mounted, or is extracted to a temp directory,\n+                // then the first entry of the resource base must be the WAR file.\n+                Resource resource = ServletContextHandler.this.getResource(path);\n+                if (resource == null)\n+                    return null;\n \n-            for (Resource r: resource)\n+                for (Resource r : resource)\n+                {\n+                    // return first\n+                    if (Resources.exists(r))\n+                        return r.getURI().toURL();\n+                }\n+            }\n+            catch (MalformedURLException e)\n             {\n-                // return first\n-                if (Resources.exists(r))\n-                    return r.getURI().toURL();\n+                throw e;\n+            }\n+            catch (Throwable e)\n+            {\n+                // catch IOException, RuntimeException, and things like java.nio.fileInvalidPathException here.\n+                throw (MalformedURLException)new MalformedURLException(path).initCause(e);\n             }\n \n-            // A Resource was returned, but did not exist\n+            // No hits\n             return null;\n         }\n \n@@ -2896,8 +2908,9 @@ public InputStream getResourceAsStream(String path)\n                     return null;\n                 return IOResources.asInputStream(r);\n             }\n-            catch (Exception e)\n+            catch (Throwable e)\n             {\n+                // catch RuntimeException and things like java.nio.fileInvalidPathException here.\n                 LOG.trace(\""IGNORED\"", e);\n                 return null;\n             }\n\ndiff --git a/jetty-ee10/jetty-ee10-webapp/src/main/java/org/eclipse/jetty/ee10/webapp/WebAppContext.java b/jetty-ee10/jetty-ee10-webapp/src/main/java/org/eclipse/jetty/ee10/webapp/WebAppContext.java\nindex efeea31e8faf..16bd63c2382f 100644\n--- a/jetty-ee10/jetty-ee10-webapp/src/main/java/org/eclipse/jetty/ee10/webapp/WebAppContext.java\n+++ b/jetty-ee10/jetty-ee10-webapp/src/main/java/org/eclipse/jetty/ee10/webapp/WebAppContext.java\n@@ -376,6 +376,11 @@ public Resource getResource(String pathInContext) throws MalformedURLException\n                 if (mue == null)\n                     mue = e;\n             }\n+            catch (Throwable t)\n+            {\n+                if (mue == null)\n+                    mue = new MalformedURLException(pathInContext);\n+            }\n         }\n \n         if (mue != null)\n@@ -1472,21 +1477,32 @@ public jakarta.servlet.ServletContext getContext(String path)\n         @Override\n         public URL getResource(String path) throws MalformedURLException\n         {\n-            if (path == null)\n-                return null;\n-\n-            // Assumption is that the resource base has been properly setup.\n-            // Spec requirement is that the WAR file is interrogated first.\n-            // If a WAR file is mounted, or is extracted to a temp directory,\n-            // then the first entry of the resource base must be the WAR file.\n-            Resource resource = WebAppContext.this.getResource(path);\n-            if (Resources.missing(resource))\n-                return null;\n-\n-            for (Resource r: resource)\n+            try\n+            {\n+                if (path == null)\n+                    return null;\n+\n+                // Assumption is that the resource base has been properly setup.\n+                // Spec requirement is that the WAR file is interrogated first.\n+                // If a WAR file is mounted, or is extracted to a temp directory,\n+                // then the first entry of the resource base must be the WAR file.\n+                Resource resource = WebAppContext.this.getResource(path);\n+                if (Resources.missing(resource))\n+                    return null;\n+\n+                for (Resource r : resource)\n+                {\n+                    // return first entry\n+                    return r.getURI().toURL();\n+                }\n+            }\n+            catch (MalformedURLException e)\n+            {\n+                throw e;\n+            }\n+            catch (Throwable e)\n             {\n-                // return first entry\n-                return r.getURI().toURL();\n+                throw (MalformedURLException)new MalformedURLException(path).initCause(e);\n             }\n \n             // A Resource was returned, but did not exist\n\ndiff --git a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java\nindex 080c6ad62ca4..1889eb601518 100644\n--- a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java\n+++ b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java\n@@ -1983,15 +1983,31 @@ else if (path.charAt(0) != '/')\n         @Override\n         public URL getResource(String path) throws MalformedURLException\n         {\n-            // This is an API call from the application which may pass non-canonical paths.\n-            // Thus, we canonicalize here, to avoid the enforcement of canonical paths in\n-            // ContextHandler.this.getResource(path).\n-            path = URIUtil.canonicalPath(path);\n-            if (path == null)\n-                return null;\n-            Resource resource = ContextHandler.this.getResource(path);\n-            if (resource != null && resource.exists())\n-                return resource.getURI().toURL();\n+            try\n+            {\n+                // This is an API call from the application which may pass non-canonical paths.\n+                // Thus, we canonicalize here, to avoid the enforcement of canonical paths in\n+                // ContextHandler.this.getResource(path).\n+                String canonicalPath = URIUtil.canonicalPath(path);\n+                if (canonicalPath == null)\n+                    return null;\n+\n+                if (!canonicalPath.startsWith(\""/\""))\n+                    throw new MalformedURLException(path);\n+\n+                Resource resource = ContextHandler.this.getResource(canonicalPath);\n+                if (resource != null && resource.exists())\n+                    return resource.getURI().toURL();\n+            }\n+            catch (MalformedURLException e)\n+            {\n+                throw e;\n+            }\n+            catch (Throwable e)\n+            {\n+                // catch IOException, RuntimeException, and things like java.nio.fileInvalidPathException here.\n+                throw (MalformedURLException)new MalformedURLException(path).initCause(e);\n+            }\n             return null;\n         }\n \n@@ -2009,8 +2025,9 @@ public InputStream getResourceAsStream(String path)\n                     return null;\n                 return IOResources.asInputStream(r);\n             }\n-            catch (Exception e)\n+            catch (Throwable e)\n             {\n+                // catch IOException, RuntimeException, and things like java.nio.fileInvalidPathException here.\n                 LOG.trace(\""IGNORED\"", e);\n                 return null;\n             }\n\ndiff --git a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/CrossContextServletContext.java b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/CrossContextServletContext.java\nindex da8359144fc9..009d13602a95 100644\n--- a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/CrossContextServletContext.java\n+++ b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/CrossContextServletContext.java\n@@ -141,7 +141,19 @@ public Set<String> getResourcePaths(String path)\n     @Override\n     public URL getResource(String path) throws MalformedURLException\n     {\n-        return _targetContext.getBaseResource().resolve(path).getURI().toURL();\n+        try\n+        {\n+            return _targetContext.getBaseResource().resolve(path).getURI().toURL();\n+        }\n+        catch (MalformedURLException e)\n+        {\n+            throw e;\n+        }\n+        catch (Throwable e)\n+        {\n+            // catch IOException, RuntimeException, and things like java.nio.fileInvalidPathException here.\n+            throw (MalformedURLException)new MalformedURLException(path).initCause(e);\n+        }\n     }\n \n     @Override\n\ndiff --git a/jetty-ee9/jetty-ee9-servlet/pom.xml b/jetty-ee9/jetty-ee9-servlet/pom.xml\nindex 51c3d97b4327..c098aad33e09 100644\n--- a/jetty-ee9/jetty-ee9-servlet/pom.xml\n+++ b/jetty-ee9/jetty-ee9-servlet/pom.xml\n@@ -74,7 +74,6 @@\n         <configuration>\n           <reuseForks>true</reuseForks>\n           <argLine>@{argLine} ${jetty.surefire.argLine}\n-            --add-modules org.eclipse.jetty.util.ajax\n             --add-reads org.eclipse.jetty.ee9.servlet=org.eclipse.jetty.logging</argLine>\n         </configuration>\n       </plugin>\n\ndiff --git a/jetty-ee9/jetty-ee9-servlet/src/main/java/module-info.java b/jetty-ee9/jetty-ee9-servlet/src/main/java/module-info.java\nindex bfdbae35b808..8cd538369e49 100644\n--- a/jetty-ee9/jetty-ee9-servlet/src/main/java/module-info.java\n+++ b/jetty-ee9/jetty-ee9-servlet/src/main/java/module-info.java\n@@ -26,7 +26,6 @@\n     requires static org.eclipse.jetty.jmx;\n     requires static org.eclipse.jetty.util.ajax;\n \n-\n     exports org.eclipse.jetty.ee9.servlet;\n     exports org.eclipse.jetty.ee9.servlet.listener;\n \n\ndiff --git a/jetty-ee9/jetty-ee9-webapp/src/main/java/org/eclipse/jetty/ee9/webapp/WebAppContext.java b/jetty-ee9/jetty-ee9-webapp/src/main/java/org/eclipse/jetty/ee9/webapp/WebAppContext.java\nindex eb028398e2f1..cd962615db9c 100644\n--- a/jetty-ee9/jetty-ee9-webapp/src/main/java/org/eclipse/jetty/ee9/webapp/WebAppContext.java\n+++ b/jetty-ee9/jetty-ee9-webapp/src/main/java/org/eclipse/jetty/ee9/webapp/WebAppContext.java\n@@ -1466,19 +1466,31 @@ public URL getResource(String path) throws MalformedURLException\n             if (path == null)\n                 return null;\n \n-            // Assumption is that the resource base has been properly setup.\n-            // Spec requirement is that the WAR file is interrogated first.\n-            // If a WAR file is mounted, or is extracted to a temp directory,\n-            // then the first entry of the resource base must be the WAR file.\n-            Resource resource = WebAppContext.this.getResource(path);\n-            if (Resources.missing(resource))\n-                return null;\n-\n-            for (Resource r: resource)\n+            try\n+            {\n+                // Assumption is that the resource base has been properly setup.\n+                // Spec requirement is that the WAR file is interrogated first.\n+                // If a WAR file is mounted, or is extracted to a temp directory,\n+                // then the first entry of the resource base must be the WAR file.\n+                Resource resource = WebAppContext.this.getResource(path);\n+                if (Resources.missing(resource))\n+                    return null;\n+\n+                for (Resource r : resource)\n+                {\n+                    // return first entry\n+                    if (Resources.exists(r))\n+                        return r.getURI().toURL();\n+                }\n+            }\n+            catch (MalformedURLException e)\n+            {\n+                throw e;\n+            }\n+            catch (Throwable e)\n             {\n-                // return first entry\n-                if (Resources.exists(r))\n-                    return r.getURI().toURL();\n+                // catch IOException, RuntimeException, and things like java.nio.fileInvalidPathException here.\n+                throw (MalformedURLException)new MalformedURLException(path).initCause(e);\n             }\n \n             // A Resource was returned, but did not exist\n"", ""test_patch"": ""diff --git a/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/ServletContextResourcesTest.java b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/ServletContextResourcesTest.java\nindex 89c666a6d8b5..99bb41ce22e6 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/ServletContextResourcesTest.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/ServletContextResourcesTest.java\n@@ -16,24 +16,30 @@\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.nio.charset.StandardCharsets;\n+import java.net.MalformedURLException;\n import java.nio.file.Path;\n+import java.util.function.Consumer;\n \n import jakarta.servlet.ServletException;\n import jakarta.servlet.http.HttpServlet;\n import jakarta.servlet.http.HttpServletRequest;\n import jakarta.servlet.http.HttpServletResponse;\n+import org.eclipse.jetty.http.HttpTester;\n import org.eclipse.jetty.server.HttpConfiguration;\n import org.eclipse.jetty.server.LocalConnector;\n import org.eclipse.jetty.server.Server;\n-import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n+import org.eclipse.jetty.toolchain.test.MavenPaths;\n import org.eclipse.jetty.util.IO;\n+import org.eclipse.jetty.util.component.LifeCycle;\n import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n \n+import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n \n public class ServletContextResourcesTest\n {\n@@ -52,7 +58,7 @@ protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Se\n             {\n                 if (in == null)\n                 {\n-                    out.write(\""<null>\"".getBytes(StandardCharsets.UTF_8));\n+                    out.write(\""<null>\"".getBytes(UTF_8));\n                 }\n                 else\n                 {\n@@ -60,69 +66,138 @@ protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Se\n                 }\n             }\n \n-            String resourceContents = new String(out.toByteArray(), StandardCharsets.UTF_8);\n+            String resourceContents = new String(out.toByteArray(), UTF_8);\n             resp.getWriter().printf(\""Resource '%s': %s\"", pathInfo, resourceContents);\n         }\n     }\n \n     private Server server;\n     private LocalConnector connector;\n-    private ServletContextHandler context;\n \n-    @BeforeEach\n-    public void init() throws Exception\n+    private void startServer(Consumer<Server> customizeServer) throws Exception\n     {\n         server = new Server();\n \n         connector = new LocalConnector(server);\n-        connector.getConnectionFactory(HttpConfiguration.ConnectionFactory.class).getHttpConfiguration().setSendServerVersion(false);\n-\n-        Path resBase = MavenTestingUtils.getTestResourcePathDir(\""contextResources\"");\n-\n-        context = new ServletContextHandler();\n-        context.setContextPath(\""/context\"");\n-        context.setBaseResourceAsPath(resBase);\n-\n-        server.setHandler(context);\n+        HttpConfiguration httpConfiguration = connector.getConnectionFactory(HttpConfiguration.ConnectionFactory.class).getHttpConfiguration();\n+        httpConfiguration.setSendServerVersion(false);\n+        httpConfiguration.setSendDateHeader(false);\n         server.addConnector(connector);\n \n+        customizeServer.accept(server);\n         server.start();\n     }\n \n     @AfterEach\n     public void destroy() throws Exception\n     {\n-        server.stop();\n-        server.join();\n+        LifeCycle.stop(server);\n     }\n \n     @Test\n     public void testGetResourceAsStreamRoot() throws Exception\n     {\n-        context.addServlet(ResourceAsStreamServlet.class, \""/*\"");\n-\n-        StringBuffer req1 = new StringBuffer();\n-        req1.append(\""GET /context/ HTTP/1.1\\r\\n\"");\n-        req1.append(\""Host: local\\r\\n\"");\n-        req1.append(\""Connection: close\\r\\n\"");\n-        req1.append(\""\\r\\n\"");\n-\n-        String response = connector.getResponse(req1.toString());\n+        startServer(server ->\n+        {\n+            Path resBase = MavenPaths.findTestResourceDir(\""contextResources\"");\n+            ServletContextHandler context = new ServletContextHandler();\n+            context.setContextPath(\""/context\"");\n+            context.setBaseResourceAsPath(resBase);\n+            context.addServlet(ResourceAsStreamServlet.class, \""/*\"");\n+            server.setHandler(context);\n+        });\n+\n+        String req1 = \""\""\""\n+            GET /context/ HTTP/1.1\\r\n+            Host: local\\r\n+            Connection: close\\r\n+            \\r\n+            \""\""\"";\n+\n+        String response = connector.getResponse(req1);\n         assertThat(\""Response\"", response, containsString(\""Resource '/': <null>\""));\n     }\n \n     @Test\n     public void testGetResourceAsStreamContent() throws Exception\n     {\n-        context.addServlet(ResourceAsStreamServlet.class, \""/*\"");\n-\n-        StringBuffer req1 = new StringBuffer();\n-        req1.append(\""GET /context/content.txt HTTP/1.1\\r\\n\"");\n-        req1.append(\""Host: local\\r\\n\"");\n-        req1.append(\""Connection: close\\r\\n\"");\n-        req1.append(\""\\r\\n\"");\n-\n-        String response = connector.getResponse(req1.toString());\n+        startServer(server ->\n+        {\n+            Path resBase = MavenPaths.findTestResourceDir(\""contextResources\"");\n+            ServletContextHandler context = new ServletContextHandler();\n+            context.setContextPath(\""/context\"");\n+            context.setBaseResourceAsPath(resBase);\n+            context.addServlet(ResourceAsStreamServlet.class, \""/*\"");\n+            server.setHandler(context);\n+        });\n+\n+        String req1 = \""\""\""\n+            GET /context/content.txt HTTP/1.1\\r\n+            Host: local\\r\n+            Connection: close\\r\n+            \\r\n+            \""\""\"";\n+\n+        String response = connector.getResponse(req1);\n         assertThat(\""Response\"", response, containsString(\""Resource '/content.txt': content goes here\""));\n     }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \""space with <p>\"",\n+        \""/null \\u0000 character\"",\n+        \""bad pct-encoding %%TOK%%\""\n+    })\n+    public void testGetResourcePathMalformed(String resourceName) throws Exception\n+    {\n+        startServer(server ->\n+        {\n+            Path resBase = MavenPaths.findTestResourceDir(\""contextResources\"");\n+            ServletContextHandler context = new ServletContextHandler();\n+            context.setContextPath(\""/context\"");\n+            context.setBaseResourceAsPath(resBase);\n+            HttpServlet servlet = new HttpServlet()\n+            {\n+                @Override\n+                protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+                {\n+                    try\n+                    {\n+                        getServletContext().getResource(resourceName);\n+                        // we shouldn't reach this next line\n+                        // if we do, then our resourceName isn't sufficiently bad/malformed for this test.\n+                        resp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n+                    }\n+                    catch (MalformedURLException e)\n+                    {\n+                        // tell client that this was the correct, expected behavior.\n+                        resp.setStatus(200);\n+                        resp.getWriter().println(e.getClass() + \"":\"" + e.getMessage());\n+                    }\n+                    catch (Throwable t)\n+                    {\n+                        t.printStackTrace(System.err);\n+                        resp.sendError(500, t.getMessage());\n+                    }\n+                }\n+            };\n+            ServletHolder servletHolder = new ServletHolder(\""get-resource-path-malformed\"", servlet);\n+            context.addServlet(servletHolder, \""/malformed/*\"");\n+            server.setHandler(context);\n+        });\n+\n+        String req1 = \""\""\""\n+            GET /context/malformed/ HTTP/1.1\\r\n+            Host: local\\r\n+            Connection: close\\r\n+            \\r\n+            \""\""\"";\n+\n+        String rawResponse = connector.getResponse(req1);\n+        HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n+        assertThat(\""response.status\"", response.getStatus(), is(200));\n+        String body = response.getContent();\n+        assertThat(\""response.body\"", body, containsString(\n+            String.format(\""%s:%s\"", MalformedURLException.class.getName(), resourceName)));\n+    }\n }\n\ndiff --git a/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/ServletContextResourcesTest.java b/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/ServletContextResourcesTest.java\nindex ffa369a5c501..360742faa8f1 100644\n--- a/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/ServletContextResourcesTest.java\n+++ b/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/ServletContextResourcesTest.java\n@@ -16,25 +16,33 @@\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.nio.charset.StandardCharsets;\n+import java.net.MalformedURLException;\n import java.nio.file.Path;\n+import java.util.function.Consumer;\n \n import jakarta.servlet.ServletException;\n import jakarta.servlet.http.HttpServlet;\n import jakarta.servlet.http.HttpServletRequest;\n import jakarta.servlet.http.HttpServletResponse;\n+import org.eclipse.jetty.http.HttpTester;\n import org.eclipse.jetty.server.HttpConfiguration;\n import org.eclipse.jetty.server.LocalConnector;\n import org.eclipse.jetty.server.Server;\n-import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n+import org.eclipse.jetty.toolchain.test.MavenPaths;\n import org.eclipse.jetty.util.IO;\n+import org.eclipse.jetty.util.component.LifeCycle;\n import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n \n+import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n \n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n public class ServletContextResourcesTest\n {\n     public static class ResourceAsStreamServlet extends HttpServlet\n@@ -52,7 +60,7 @@ protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Se\n             {\n                 if (in == null)\n                 {\n-                    out.write(\""<null>\"".getBytes(StandardCharsets.UTF_8));\n+                    out.write(\""<null>\"".getBytes(UTF_8));\n                 }\n                 else\n                 {\n@@ -60,69 +68,139 @@ protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Se\n                 }\n             }\n \n-            String resourceContents = new String(out.toByteArray(), StandardCharsets.UTF_8);\n+            String resourceContents = new String(out.toByteArray(), UTF_8);\n             resp.getWriter().printf(\""Resource '%s': %s\"", pathInfo, resourceContents);\n         }\n     }\n \n     private Server server;\n     private LocalConnector connector;\n-    private ServletContextHandler context;\n \n-    @BeforeEach\n-    public void init() throws Exception\n+    private void startServer(Consumer<Server> customizeServer) throws Exception\n     {\n         server = new Server();\n \n         connector = new LocalConnector(server);\n-        connector.getConnectionFactory(HttpConfiguration.ConnectionFactory.class).getHttpConfiguration().setSendServerVersion(false);\n-\n-        Path resBase = MavenTestingUtils.getTargetPath(\""test-classes/contextResources\"");\n-\n-        context = new ServletContextHandler();\n-        context.setContextPath(\""/context\"");\n-        context.setResourceBase(resBase.toFile().toURI().toASCIIString());\n-\n-        server.setHandler(context);\n+        HttpConfiguration httpConfiguration = connector.getConnectionFactory(HttpConfiguration.ConnectionFactory.class).getHttpConfiguration();\n+        httpConfiguration.setSendServerVersion(false);\n+        httpConfiguration.setSendDateHeader(false);\n         server.addConnector(connector);\n \n+        customizeServer.accept(server);\n         server.start();\n     }\n \n     @AfterEach\n     public void destroy() throws Exception\n     {\n-        server.stop();\n-        server.join();\n+        LifeCycle.stop(server);\n     }\n \n     @Test\n     public void testGetResourceAsStreamRoot() throws Exception\n     {\n-        context.addServlet(ResourceAsStreamServlet.class, \""/*\"");\n-\n-        StringBuffer req1 = new StringBuffer();\n-        req1.append(\""GET /context/ HTTP/1.1\\r\\n\"");\n-        req1.append(\""Host: local\\r\\n\"");\n-        req1.append(\""Connection: close\\r\\n\"");\n-        req1.append(\""\\r\\n\"");\n-\n-        String response = connector.getResponse(req1.toString());\n+        startServer(server ->\n+        {\n+            Path resBase = MavenPaths.findTestResourceDir(\""contextResources\"");\n+            ServletContextHandler context = new ServletContextHandler();\n+            context.setContextPath(\""/context\"");\n+            context.setBaseResourceAsPath(resBase);\n+            context.addServlet(ResourceAsStreamServlet.class, \""/*\"");\n+            server.setHandler(context);\n+        });\n+\n+        String req1 = \""\""\""\n+            GET /context/ HTTP/1.1\\r\n+            Host: local\\r\n+            Connection: close\\r\n+            \\r\n+            \""\""\"";\n+\n+        String response = connector.getResponse(req1);\n         assertThat(\""Response\"", response, containsString(\""Resource '/': <null>\""));\n     }\n \n     @Test\n     public void testGetResourceAsStreamContent() throws Exception\n     {\n-        context.addServlet(ResourceAsStreamServlet.class, \""/*\"");\n-\n-        StringBuffer req1 = new StringBuffer();\n-        req1.append(\""GET /context/content.txt HTTP/1.1\\r\\n\"");\n-        req1.append(\""Host: local\\r\\n\"");\n-        req1.append(\""Connection: close\\r\\n\"");\n-        req1.append(\""\\r\\n\"");\n-\n-        String response = connector.getResponse(req1.toString());\n+        startServer(server ->\n+        {\n+            Path resBase = MavenPaths.findTestResourceDir(\""contextResources\"");\n+            ServletContextHandler context = new ServletContextHandler();\n+            context.setContextPath(\""/context\"");\n+            context.setBaseResourceAsPath(resBase);\n+            context.addServlet(ResourceAsStreamServlet.class, \""/*\"");\n+            server.setHandler(context);\n+        });\n+\n+        String req1 = \""\""\""\n+            GET /context/content.txt HTTP/1.1\\r\n+            Host: local\\r\n+            Connection: close\\r\n+            \\r\n+            \""\""\"";\n+\n+        String response = connector.getResponse(req1);\n         assertThat(\""Response\"", response, containsString(\""Resource '/content.txt': content goes here\""));\n     }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \""space with <p>\"",\n+        \""/space with %0X\"",\n+        \""bad pct-encoding %%TOK%%\"",\n+        \""/bad pct-encoding %%TOK%%\""\n+    })\n+    public void testGetResourcePathMalformed(String resourceName) throws Exception\n+    {\n+        startServer(server ->\n+        {\n+            Path resBase = MavenPaths.findTestResourceDir(\""contextResources\"");\n+            ServletContextHandler context = new ServletContextHandler();\n+            context.setContextPath(\""/context\"");\n+            context.setBaseResourceAsPath(resBase);\n+            HttpServlet servlet = new HttpServlet()\n+            {\n+                @Override\n+                protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+                {\n+                    try\n+                    {\n+                        getServletContext().getResource(resourceName);\n+                        // we shouldn't reach this next line\n+                        // if we do, then our resourceName isn't sufficiently bad/malformed for this test.\n+                        resp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n+                    }\n+                    catch (MalformedURLException e)\n+                    {\n+                        // tell client that this was the correct, expected behavior.\n+                        resp.setStatus(200);\n+                        resp.getWriter().println(e.getClass() + \"":\"" + e.getMessage());\n+                    }\n+                    catch (Throwable t)\n+                    {\n+                        t.printStackTrace(System.err);\n+                        resp.sendError(500, t.getMessage());\n+                    }\n+                }\n+            };\n+            ServletHolder servletHolder = new ServletHolder(\""get-resource-path-malformed\"", servlet);\n+            context.addServlet(servletHolder, \""/malformed/*\"");\n+            server.setHandler(context);\n+        });\n+\n+        String req1 = \""\""\""\n+            GET /context/malformed/ HTTP/1.1\\r\n+            Host: local\\r\n+            Connection: close\\r\n+            \\r\n+            \""\""\"";\n+\n+        String rawResponse = connector.getResponse(req1);\n+        HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n+        assertThat(\""response.status\"", response.getStatus(), is(200));\n+        String body = response.getContent();\n+        assertThat(\""response.body\"", body, containsString(\n+            String.format(\""%s:%s\"", MalformedURLException.class.getName(), resourceName)));\n+    }\n }\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-13161"", ""pr_id"": 13161, ""issue_id"": 13160, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Fix WebSocketClient stop timeout\n**Jetty version(s)**\n12.0.x\n\n**Description**\nThe `WebSocketClient` in ee9 and core has the stop timeout set to `Long.MAX_VALUE` by default.\n\nIn their `doStop()` methods, they attempt a graceful shutdown, waiting for it to complete within the stop timeout, which is unfortunately about 292 million years of wait.\n\nThere is an issue in the shutdown notification, but we should fix the idle timeout to not wait for that long."", ""issue_word_count"": 75, ""test_files_count"": 4, ""non_test_files_count"": 2, ""pr_changed_files"": [""jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/WebSocketClient.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/WebSocketStopTest.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ClientCloseTest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/WebSocketClient.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/WebSocketStopTest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/client/ClientCloseTest.java""], ""pr_changed_test_files"": [""jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/WebSocketStopTest.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ClientCloseTest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/WebSocketStopTest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/client/ClientCloseTest.java""], ""base_commit"": ""bb1e92a12837159b005aaa9366e7faf16d45d565"", ""head_commit"": ""cb95137b0fd97571e8a1c2f9eabf70cf59971df6"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/13161"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/13161"", ""dockerfile"": """", ""pr_merged_at"": ""2025-05-22T15:30:50.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/WebSocketClient.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/WebSocketClient.java\nindex d34dbcaa3bf6..fbeeefcb0fe6 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/WebSocketClient.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/WebSocketClient.java\n@@ -60,7 +60,7 @@ public class WebSocketClient extends ContainerLifeCycle implements Configurable,\n     private final SessionTracker sessionTracker = new SessionTracker();\n     private final Configuration.ConfigurationCustomizer configurationCustomizer = new Configuration.ConfigurationCustomizer();\n     private boolean stopAtShutdown = false;\n-    private long _stopTimeout = Long.MAX_VALUE;\n+    private long _stopTimeout;\n \n     /**\n      * Instantiates a WebSocketClient with a default {@link HttpClient}.\n@@ -398,9 +398,16 @@ public boolean isStopAtShutdown()\n     @Override\n     protected void doStop() throws Exception\n     {\n-        if (getStopTimeout() > 0)\n-            Graceful.shutdown(this).get(getStopTimeout(), TimeUnit.MILLISECONDS);\n-        super.doStop();\n+        try\n+        {\n+            long stopTimeout = getStopTimeout();\n+            if (stopTimeout > 0L)\n+                Graceful.shutdown(this).get(stopTimeout, TimeUnit.MILLISECONDS);\n+        }\n+        finally\n+        {\n+            super.doStop();\n+        }\n     }\n \n     @Override\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/WebSocketClient.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/WebSocketClient.java\nindex c5fc52e9797e..0878f8e5a914 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/WebSocketClient.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/WebSocketClient.java\n@@ -64,7 +64,7 @@ public class WebSocketClient extends ContainerLifeCycle implements WebSocketPoli\n     private final Configuration.ConfigurationCustomizer configurationCustomizer = new Configuration.ConfigurationCustomizer();\n     private final WebSocketComponents components = new WebSocketComponents();\n     private boolean stopAtShutdown = false;\n-    private long _stopTimeout = Long.MAX_VALUE;\n+    private long _stopTimeout;\n \n     /**\n      * Instantiate a WebSocketClient with defaults\n@@ -394,9 +394,16 @@ public boolean isStopAtShutdown()\n     @Override\n     protected void doStop() throws Exception\n     {\n-        if (getStopTimeout() > 0)\n-            Graceful.shutdown(this).get(getStopTimeout(), TimeUnit.MILLISECONDS);\n-        super.doStop();\n+        try\n+        {\n+            long stopTimeout = getStopTimeout();\n+            if (stopTimeout > 0L)\n+                Graceful.shutdown(this).get(stopTimeout, TimeUnit.MILLISECONDS);\n+        }\n+        finally\n+        {\n+            super.doStop();\n+        }\n     }\n \n     @Override\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/WebSocketStopTest.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/WebSocketStopTest.java\nindex 1be9fba56b1f..4d74827ae8ea 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/WebSocketStopTest.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/WebSocketStopTest.java\n@@ -56,6 +56,7 @@ public void start() throws Exception\n         server.setHandler(wsHandler);\n         server.start();\n \n+        client.setStopTimeout(5000);\n         client.start();\n     }\n \n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ClientCloseTest.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ClientCloseTest.java\nindex 877d9bbae90b..73fbcc2c3c7b 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ClientCloseTest.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ClientCloseTest.java\n@@ -95,6 +95,7 @@ public void startClient() throws Exception\n     {\n         client = new WebSocketClient();\n         client.setMaxTextMessageSize(1024);\n+        client.setStopTimeout(5000);\n         client.start();\n     }\n \n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/WebSocketStopTest.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/WebSocketStopTest.java\nindex 1b587355a990..bbb0d66ea9be 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/WebSocketStopTest.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/WebSocketStopTest.java\n@@ -70,6 +70,7 @@ public void start() throws Exception\n         JettyWebSocketServletContainerInitializer.configure(contextHandler, null);\n \n         server.start();\n+        client.setStopTimeout(5000);\n         client.start();\n     }\n \n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/client/ClientCloseTest.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/client/ClientCloseTest.java\nindex b31798e11855..d442c0dae08d 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/client/ClientCloseTest.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/client/ClientCloseTest.java\n@@ -99,6 +99,7 @@ public void startClient() throws Exception\n     {\n         client = new WebSocketClient();\n         client.setMaxTextMessageSize(1024);\n+        client.setStopTimeout(5000);\n         client.start();\n     }\n \n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-13145"", ""pr_id"": 13145, ""issue_id"": 13144, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Cross Context Dispatch with Async does not honor context\n**Jetty version(s)**\n12.0.21\n\n**Jetty Environment**\nee9 / ee8 (but could be present in others too)\n\n**Description**\nWhen a cross-context dispatch occurs, and the dispatched to endpoint uses an `AsyncContext.dispatch()`, then the resulting dispatch has the wrong state, and dispatches to the previous context.\n\nExample:\n\nWe have 2 contexts involved.\n\n1. Context root `/`\n    - has a Filter that performs cross-context-dispatch.\n2. Context service `/service`\n    - has an Servlet `/alt/*` that uses AsyncContext and performs a dispatch()\n\nThe order of events.\n\n1. Context root `/` receives a request.\n2. The filter on Context root `/` gets a ServletContext from `/service`\n3. The filter gets a RequestDispatcher from `/service` to a path /service/alt/` context.\n4. The filter performs a `RequestDispatcher.forward()` to this `/service` endpoint\n5. The `/service/alt/*` servlet receives the FORWARD request.\n6. The `/service/alt/*` servlet establishes an AsyncContext, waits for a timeout, and then performs a `dispatch()`\n7. (Where problem occurs) - this dispatch goes to the root `/` context.\n\nThere are two problems observed (could be more).\n\nFirst in the `jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Dispatcher.java` \n\nThe call to `protected void forward(ServletRequest request, ServletResponse response, DispatcherType dispatch) throws ServletException, IOException` has a _finally_ block that resets several Request settings, like the `HttpURI`, this results in bad `HttpServletRequest.getRequestURL` on the dispatch.\n\nNext is the `jetty-ee9/jetty-ee9-servlet/src/main/java/org/eclipse/jetty/ee9/servlet/ServletHandler.java`\n\nIn the call to `public void doScope(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException`, there is a finally block that resets the old scope using `baseRequest.setUserIdentityScope(oldScope)`, this sets the Context back to the original context, which results in the `AsyncContext.dispatch()` calling the original context, not the dispatched to context, like what is expected (and how the behavior works in Jetty 11/10/9).\n"", ""issue_word_count"": 321, ""test_files_count"": 4, ""non_test_files_count"": 12, ""pr_changed_files"": [""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/AsyncContextEvent.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/CrossContextDispatcher.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/Dispatcher.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletApiRequest.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannelState.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/CrossContextDispatcherFilterTest.java"", ""jetty-ee10/jetty-ee10-tests/jetty-ee10-test-sessions/jetty-ee10-test-sessions-common/src/test/java/org/eclipse/jetty/ee10/session/AsyncTest.java"", ""jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/AsyncContextState.java"", ""jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java"", ""jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/HttpChannel.java"", ""jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/HttpChannelState.java"", ""jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java"", ""jetty-ee9/jetty-ee9-servlet/pom.xml"", ""jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/CrossContextDispatcherFilterTest.java"", ""jetty-ee9/jetty-ee9-tests/jetty-ee9-test-sessions/jetty-ee9-test-sessions-common/src/test/java/org/eclipse/jetty/ee9/session/AsyncTest.java""], ""pr_changed_test_files"": [""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/CrossContextDispatcherFilterTest.java"", ""jetty-ee10/jetty-ee10-tests/jetty-ee10-test-sessions/jetty-ee10-test-sessions-common/src/test/java/org/eclipse/jetty/ee10/session/AsyncTest.java"", ""jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/CrossContextDispatcherFilterTest.java"", ""jetty-ee9/jetty-ee9-tests/jetty-ee9-test-sessions/jetty-ee9-test-sessions-common/src/test/java/org/eclipse/jetty/ee9/session/AsyncTest.java""], ""base_commit"": ""86bc52d3c78ac04c4b99cd54e1601e9d48c5e1c8"", ""head_commit"": ""03640e8030e007dc12df5fb8a79d72d0fe0dc2ea"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/13145"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/13145"", ""dockerfile"": """", ""pr_merged_at"": ""2025-05-29T14:36:33.000Z"", ""patch"": ""diff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/AsyncContextEvent.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/AsyncContextEvent.java\nindex 847e57c44b76..b83a67c999cb 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/AsyncContextEvent.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/AsyncContextEvent.java\n@@ -42,8 +42,8 @@ public AsyncContextEvent(ServletContextHandler.ServletScopedContext context, Asy\n         _asyncContext = asyncContext;\n         _servletContext = ServletContextHandler.getServletContext(context);\n         _state = state;\n-        // TODO better than this:\n-        _baseURI = request == null ? null : (request instanceof HttpServletRequest hr) ? HttpURI.from(hr.getRequestURI()) : null;\n+\n+        _baseURI =  (request instanceof HttpServletRequest hsr) ? HttpURI.build(hsr.getRequestURI()).query(hsr.getQueryString()) : null;\n \n         // TODO: Should we store a wrapped request with the attributes?\n         // We are setting these attributes during startAsync, when the spec implies that\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/CrossContextDispatcher.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/CrossContextDispatcher.java\nindex 747e552d336b..9134b2ef6cfd 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/CrossContextDispatcher.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/CrossContextDispatcher.java\n@@ -152,9 +152,26 @@ public IncludeResponse(Request coreRequest, HttpServletResponse httpServletRespo\n         }\n     }\n \n+    private class AsyncRequest extends ServletCoreRequest\n+    {\n+        private final HttpURI _fullyQualifiedURI;\n+\n+        public AsyncRequest(HttpServletRequest httpServletRequest)\n+        {\n+            super(httpServletRequest, new ServletAttributes(httpServletRequest));\n+            _fullyQualifiedURI = HttpURI.build(httpServletRequest.getRequestURL().toString()).pathQuery(_uri.getPathQuery()).asImmutable();\n+        }\n+\n+        @Override\n+        public HttpURI getHttpURI()\n+        {\n+            return _fullyQualifiedURI;\n+        }\n+    }\n+\n     private class ForwardRequest extends ServletCoreRequest\n     {\n-         private HttpURI _fullyQualifiedURI;\n+         private final HttpURI _fullyQualifiedURI;\n \n         /**\n          * @param httpServletRequest the request to wrap\n@@ -217,6 +234,24 @@ public HttpURI getHttpURI()\n         _decodedPathInContext = decodedPathInContext;\n     }\n \n+    public void async(ServletRequest servletRequest, ServletResponse response) throws ServletException, IOException\n+    {\n+        HttpServletRequest httpServletRequest = (servletRequest instanceof HttpServletRequest) ? ((HttpServletRequest)servletRequest) : new ServletRequestHttpWrapper(servletRequest);\n+        HttpServletResponse httpResponse = (response instanceof HttpServletResponse) ? (HttpServletResponse)response : new ServletResponseHttpWrapper(response);\n+\n+        AsyncRequest asyncRequest = new AsyncRequest(httpServletRequest);\n+        // We must block when do a cross context async dispatch, as we cannot combine the state machines of the servletChannel from the source context and that of the target\n+        try (Blocker.Callback callback = Blocker.callback())\n+        {\n+            _targetContext.getTargetContext().getContextHandler().handle(asyncRequest, new ServletCoreResponse(asyncRequest, httpResponse, false), callback);\n+            callback.block();\n+        }\n+        catch (Exception e)\n+        {\n+            throw new ServletException(e);\n+        }\n+    }\n+\n     @Override\n     public void forward(ServletRequest servletRequest, ServletResponse response) throws ServletException, IOException\n     {\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/Dispatcher.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/Dispatcher.java\nindex a2b9017574b9..b03cf6707f4d 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/Dispatcher.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/Dispatcher.java\n@@ -45,6 +45,7 @@\n import org.eclipse.jetty.util.Fields;\n import org.eclipse.jetty.util.IO;\n import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.UrlEncoded;\n \n public class Dispatcher implements RequestDispatcher\n@@ -177,7 +178,7 @@ public ParameterRequestWrapper(HttpServletRequest request)\n             super(request);\n         }\n \n-        private Fields getParameters()\n+        protected Fields getParameters()\n         {\n             if (_parameters == null)\n             {\n@@ -753,6 +754,37 @@ public Enumeration<String> getAttributeNames()\n             names.add(AsyncContextState.ASYNC_QUERY_STRING);\n             return Collections.enumeration(names);\n         }\n+\n+        /**\n+         * Get the parameters merged from the request wrapped by this {@code AsyncRequest}\n+         * and those in the {@code RequestDispatcher}.\n+         * If the target path is the same as the request path, then\n+         * we do not want to re-extract the query string, as the wrapped request will\n+         * have already done the extraction.\n+         * @return the request parameters\n+         */\n+        @Override\n+        protected Fields getParameters()\n+        {\n+            // The AsyncRequest may have been dispatched to the same URI as the request that it is\n+            //wrapping. If so, We should not re-extract the parameters, just use what is there.\n+            if (getRequest() instanceof HttpServletRequest httpServletRequest)\n+            {\n+                HttpURI requestURI = HttpURI.build(httpServletRequest.getRequestURI()).query(httpServletRequest.getQueryString());\n+                if (requestURI.equals(_uri))\n+                {\n+                    if (getRequest() instanceof ParameterRequestWrapper parameterRequestWrapper)\n+                        return parameterRequestWrapper.getParameters();\n+                    else if (getRequest() instanceof ServletApiRequest servletApiRequest)\n+                        return servletApiRequest.getParameters();\n+                    else\n+                        return super.getParameters();\n+                }\n+                else\n+                    return super.getParameters();\n+            }\n+            return super.getParameters();\n+        }\n     }\n \n     private class ErrorRequest extends ParameterRequestWrapper\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletApiRequest.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletApiRequest.java\nindex 39e355fd73ea..f4fcd49d89a1 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletApiRequest.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletApiRequest.java\n@@ -1357,8 +1357,11 @@ public AsyncContext startAsync() throws IllegalStateException\n         ServletChannelState state = getServletRequestInfo().getState();\n         if (_async == null)\n             _async = new AsyncContextState(state);\n+\n+        // We must remember the request as last dispatched by the container so that we can use its uri for\n+        // possible subsequent dispatch\n         ServletRequestInfo servletRequestInfo = getServletRequestInfo();\n-        AsyncContextEvent event = new AsyncContextEvent(getServletRequestInfo().getServletContext(), _async, state, this, servletRequestInfo.getServletChannel().getServletContextResponse().getServletApiResponse());\n+        AsyncContextEvent event = new AsyncContextEvent(getServletRequestInfo().getServletContext(), _async, state, servletRequestInfo.getServletChannel().getServletContextRequest().getServletApiRequest(), servletRequestInfo.getServletChannel().getServletContextResponse().getServletApiResponse());\n         state.startAsync(event);\n         return _async;\n     }\n@@ -1371,6 +1374,7 @@ public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse se\n         ServletChannelState state = getServletRequestInfo().getState();\n         if (_async == null)\n             _async = new AsyncContextState(state);\n+        //We must remember the request and response passed in for use in a possible subsequent dispatch\n         AsyncContextEvent event = new AsyncContextEvent(getServletRequestInfo().getServletContext(), _async, state, servletRequest, servletResponse);\n         state.startAsync(event);\n         return _async;\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java\nindex a0239e154499..1bc67f4b4cf3 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java\n@@ -16,10 +16,13 @@\n import java.io.IOException;\n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n+import java.util.Objects;\n import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicLong;\n \n import jakarta.servlet.RequestDispatcher;\n+import jakarta.servlet.ServletContext;\n+import jakarta.servlet.ServletException;\n import org.eclipse.jetty.ee10.servlet.ServletChannelState.Action;\n import org.eclipse.jetty.http.BadMessageException;\n import org.eclipse.jetty.http.HttpFields;\n@@ -40,6 +43,7 @@\n import org.eclipse.jetty.util.Callback;\n import org.eclipse.jetty.util.ExceptionUtil;\n import org.eclipse.jetty.util.HostPort;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -824,52 +828,154 @@ private void dispatch() throws Exception\n         }\n     }\n \n+    /**\n+     * An AsyncContext dispatch method was called. We may need to dispatch to\n+     * a different context.\n+     * @throws Exception\n+     */\n     public void dispatchAsync() throws Exception\n     {\n-        ServletContextHandler servletContextHandler = getServletContextHandler();\n+        ServletContextHandler targetContextHandler = getServletContextHandler();\n         ServletContextRequest servletContextRequest = getServletContextRequest();\n         ServletApiRequest servletApiRequest = servletContextRequest.getServletApiRequest();\n         try\n         {\n-            servletContextHandler.requestInitialized(servletContextRequest, servletApiRequest);\n-\n-            HttpURI uri;\n-            String pathInContext;\n             AsyncContextEvent asyncContextEvent = _state.getAsyncContextEvent();\n             String dispatchString = asyncContextEvent.getDispatchPath();\n-            if (dispatchString != null)\n+\n+            if (asyncContextEvent.getDispatchContext() instanceof CrossContextServletContext crossContextServletContext)\n             {\n-                String contextPath = _context.getContextPath();\n-                HttpURI.Immutable dispatchUri = HttpURI.from(dispatchString);\n-                pathInContext = URIUtil.canonicalPath(dispatchUri.getPath());\n-                uri = HttpURI.build(servletContextRequest.getHttpURI())\n-                    .path(URIUtil.addPaths(contextPath, pathInContext))\n-                    .query(dispatchUri.getQuery());\n+                dispatchCrossContextAsync(crossContextServletContext);\n             }\n-            else\n+            else if (asyncContextEvent.getDispatchContext() == null)\n             {\n-                uri = asyncContextEvent.getBaseURI();\n-                if (uri == null)\n+                //the user dispatched to the current context\n+                targetContextHandler.requestInitialized(servletContextRequest, servletApiRequest);\n+\n+                String pathInContext;\n+                HttpURI uri;\n+\n+                if (dispatchString != null)\n                 {\n-                    uri = servletContextRequest.getHttpURI();\n-                    pathInContext = Request.getPathInContext(servletContextRequest);\n+                    //dispatch to different path in current context\n+                    String contextPath = _context.getContextPath();\n+                    HttpURI.Immutable dispatchUri = HttpURI.from(dispatchString);\n+                    pathInContext = URIUtil.canonicalPath(dispatchUri.getPath());\n+                    uri = HttpURI.build(servletContextRequest.getHttpURI())\n+                        .path(URIUtil.addPaths(contextPath, pathInContext))\n+                        .query(dispatchUri.getQuery());\n                 }\n                 else\n                 {\n-                    pathInContext = uri.getCanonicalPath();\n-                    int length = _context.getContextPath().length();\n-                    if (length > 1)\n-                        pathInContext = pathInContext.substring(length);\n+                    //dispatch to original path of event's request in current context\n+                    uri = asyncContextEvent.getBaseURI();\n+                    if (uri == null)\n+                    {\n+                        uri = servletContextRequest.getHttpURI();\n+                        pathInContext = Request.getPathInContext(servletContextRequest);\n+                    }\n+                    else\n+                    {\n+                        pathInContext = uri.getCanonicalPath();\n+                        int length = _context.getContextPath().length();\n+                        if (length > 1)\n+                            pathInContext = pathInContext.substring(length);\n+                    }\n                 }\n+\n+                // We first worked with the core pathInContext above, but now need to convert to servlet style\n+                String decodedPathInContext = URIUtil.decodePath(pathInContext);\n+                Dispatcher dispatcher = new Dispatcher(targetContextHandler, uri, decodedPathInContext);\n+                dispatcher.async(asyncContextEvent.getSuppliedRequest(), asyncContextEvent.getSuppliedResponse());\n+            }\n+            else\n+            {\n+                //the container has dispatched to a different context\n+                ServletContext targetContext = getServletContextHandler().getServletContext().getContext(asyncContextEvent.getDispatchContext().getContextPath());\n+                if (targetContext instanceof CrossContextServletContext crossContextServletContext)\n+                    dispatchCrossContextAsync(crossContextServletContext);\n             }\n-            // We first worked with the core pathInContext above, but now need to convert to servlet style\n-            String decodedPathInContext = URIUtil.decodePath(pathInContext);\n-            Dispatcher dispatcher = new Dispatcher(servletContextHandler, uri, decodedPathInContext);\n-            dispatcher.async(asyncContextEvent.getSuppliedRequest(), asyncContextEvent.getSuppliedResponse());\n         }\n         finally\n         {\n-            servletContextHandler.requestDestroyed(servletContextRequest, servletApiRequest);\n+            targetContextHandler.requestDestroyed(servletContextRequest, servletApiRequest);\n+        }\n+    }\n+\n+    /**\n+     * Async has been started, but dispatched to a different context. This can happen\n+     * either via application code calling {@link jakarta.servlet.AsyncContext#dispatch(ServletContext, String)}\n+     * or the container dispatching after application code returns without having performed a dispatch or otherwise\n+     * completed async.\n+     * @param crossContextServletContext the special context containing both the origin context and the destination context\n+     * @throws ServletException\n+     * @throws IOException\n+     */\n+    private void dispatchCrossContextAsync(CrossContextServletContext crossContextServletContext) throws ServletException, IOException\n+    {\n+        HttpURI uri;\n+        ServletContextHandler targetContextHandler = crossContextServletContext.getTargetContext().getContextHandler();\n+        AsyncContextEvent asyncContextEvent = _state.getAsyncContextEvent();\n+        String dispatchPathInContext = asyncContextEvent.getDispatchPath();\n+\n+        if (dispatchPathInContext != null)\n+        {\n+            //dispatch is to a specific path\n+            String encodedPathQuery = URIUtil.normalizePath(URIUtil.addEncodedPaths(targetContextHandler.getContextPath(), dispatchPathInContext));\n+            if (encodedPathQuery == null)\n+                throw new BadMessageException(500, \""Bad dispatch path\"");\n+\n+            //Add in any query params\n+            if (asyncContextEvent.getBaseURI() != null)\n+            {\n+                HttpURI.Mutable builder = HttpURI.build(asyncContextEvent.getBaseURI(), encodedPathQuery);\n+                if (StringUtil.isEmpty(builder.getParam()))\n+                    builder.param(asyncContextEvent.getBaseURI().getParam());\n+                if (StringUtil.isEmpty(builder.getQuery()))\n+                    builder.query(asyncContextEvent.getBaseURI().getQuery());\n+\n+                uri = builder.asImmutable();\n+                dispatchPathInContext = uri.getPathQuery();\n+            }\n+            else\n+            {\n+                //no base request URI, do our best with the context and dispatch path\n+                HttpURI.Mutable mutableHttpURI = HttpURI.build(dispatchPathInContext);\n+\n+                String targetContextPath = targetContextHandler.getContextPath();\n+                if (!StringUtil.isEmpty(targetContextPath) && !targetContextPath.equals(\""/\""))\n+                {\n+                    mutableHttpURI.path(URIUtil.addPaths(targetContextPath, mutableHttpURI.getPath()));\n+                }\n+                uri = mutableHttpURI.asImmutable();\n+            }\n         }\n+        else\n+        {\n+            //no dispatch path, assume path as at time of start async\n+            uri = asyncContextEvent.getBaseURI();\n+            String contextPath;\n+            if (uri == null)\n+            {\n+                //use the current request's uri and the current context path to extract just the servlet path\n+                uri = getServletContextRequest().getHttpURI();\n+                contextPath = getContext().getContextPath();\n+            }\n+            else\n+            {\n+                //use the context path at the time of start async to extract just the servlet path\n+                contextPath = asyncContextEvent.getContext().getContextPath();\n+            }\n+            dispatchPathInContext = uri.getCanonicalPath();\n+            int length = contextPath.length();\n+            if (length > 1)\n+                dispatchPathInContext = dispatchPathInContext.substring(length);\n+            HttpURI.Mutable mutableHttpURI = HttpURI.build(dispatchPathInContext);\n+            mutableHttpURI.path(URIUtil.addPaths(targetContextHandler.getContextPath(), dispatchPathInContext));\n+            uri = mutableHttpURI.asImmutable();\n+        }\n+\n+        CrossContextDispatcher dispatcher = new CrossContextDispatcher(crossContextServletContext, uri, dispatchPathInContext);\n+        dispatcher.async(asyncContextEvent.getSuppliedRequest(), asyncContextEvent.getSuppliedResponse());\n     }\n }\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannelState.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannelState.java\nindex 3c121ba78039..2b9942a80ea4 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannelState.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannelState.java\n@@ -684,8 +684,10 @@ public void dispatch(ServletContext context, String path)\n                     throw new IllegalStateException(this.getStatusStringLocked());\n             }\n \n+            //the context will be null if {@link AsyncContext#dispatch()} or {@link AsyncContext#dispatch(String)} were called\n             if (context != null)\n                 _event.setDispatchContext(context);\n+            //the path will be null if {@link AsyncContext#dispatch()} was called\n             if (path != null)\n                 _event.setDispatchPath(path);\n \n\ndiff --git a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/AsyncContextState.java b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/AsyncContextState.java\nindex 5c0c0d0d65c4..ef4834d776e3 100644\n--- a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/AsyncContextState.java\n+++ b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/AsyncContextState.java\n@@ -22,6 +22,7 @@\n import jakarta.servlet.ServletException;\n import jakarta.servlet.ServletRequest;\n import jakarta.servlet.ServletResponse;\n+import org.eclipse.jetty.util.TypeUtil;\n \n public class AsyncContextState implements AsyncContext\n {\n@@ -159,6 +160,12 @@ public HttpChannelState getHttpChannelState()\n         return state();\n     }\n \n+    @Override\n+    public String toString()\n+    {\n+        return String.format(\""%s@%h(state=%s,channel=%s)\"", TypeUtil.toShortName(AsyncContextState.class), hashCode(), _state, _channel);\n+    }\n+\n     public static class WrappedAsyncListener implements AsyncListener\n     {\n         private final AsyncListener _listener;\n\ndiff --git a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java\nindex 080c6ad62ca4..c62f5b6eae10 100644\n--- a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java\n+++ b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java\n@@ -1728,6 +1728,75 @@ protected void handleOptions(Request request, org.eclipse.jetty.ee9.nested.Respo\n     {\n     }\n \n+    /** A request has come in via an async dispatch from a different context.\n+     *\n+     * @param channel the HttpChannel associated with the request\n+     * @throws IOException\n+     * @throws ServletException\n+     */\n+    public void handleCrossContextAsync(HttpChannel channel) throws IOException, ServletException\n+    {\n+        AsyncContextEvent event = channel.getState().getAsyncContextEvent();\n+\n+        // we must mutate the request\n+        Request request = event.getHttpChannelState().getBaseRequest();\n+        HttpURI baseUri = event.getBaseURI();\n+        APIContext oldContext = request.getContext();\n+        HttpURI oldURI = request.getHttpURI();\n+        String oldPathInContext = request.getPathInContext();\n+        Fields oldQueryFields = request.getQueryFields();\n+\n+        //the path in the context (encoded with possible query string)\n+        String encodedPathQuery = event.getDispatchPath();\n+        if (encodedPathQuery == null && baseUri == null)\n+        {\n+            //TODO - what would this mean?\n+        }\n+        else\n+        {\n+            try\n+            {\n+                if (encodedPathQuery == null)\n+                {\n+                    request.setHttpURI(baseUri);\n+                }\n+                else\n+                {\n+                    String encodedContextPath = URIUtil.encodePath(getContextPath());\n+                    if (!StringUtil.isEmpty(encodedContextPath))\n+                    {\n+                        encodedPathQuery = URIUtil.canonicalPath(URIUtil.addEncodedPaths(encodedContextPath, encodedPathQuery));\n+                        if (encodedPathQuery == null)\n+                            throw new BadMessageException(500, \""Bad dispatch path\"");\n+                    }\n+\n+                    if (baseUri == null)\n+                        baseUri = request.getHttpURI();\n+                    HttpURI.Mutable builder = HttpURI.build(baseUri, encodedPathQuery);\n+\n+                    if (StringUtil.isEmpty(builder.getParam()))\n+                        builder.param(baseUri.getParam());\n+                    if (StringUtil.isEmpty(builder.getQuery()))\n+                        builder.query(baseUri.getQuery());\n+\n+                    request.setHttpURI(builder);\n+\n+                    if (baseUri.getQuery() != null && request.getQueryString() != null)\n+                        request.mergeQueryParameters(request.getHttpURI().getQuery(), request.getQueryString());\n+                }\n+\n+                request.setContext(_apiContext, event.getDispatchPath());\n+                handleAsync(channel, event, request);\n+            }\n+            finally\n+            {\n+                request.setContext(oldContext, oldPathInContext);\n+                request.setHttpURI(oldURI);\n+                request.setQueryFields(oldQueryFields);\n+            }\n+        }\n+    }\n+\n     /* Handle a request from a connection.\n      * Called to handle a request on the connection when either the header has been received,\n      * or after the entire request has been received (for short requests of known length), or\n\ndiff --git a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/HttpChannel.java b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/HttpChannel.java\nindex 7820d8cd6095..b153b8976778 100644\n--- a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/HttpChannel.java\n+++ b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/HttpChannel.java\n@@ -32,6 +32,7 @@\n \n import jakarta.servlet.DispatcherType;\n import jakarta.servlet.RequestDispatcher;\n+import jakarta.servlet.ServletContext;\n import jakarta.servlet.ServletException;\n import org.eclipse.jetty.http.BadMessageException;\n import org.eclipse.jetty.http.HttpException;\n@@ -1570,7 +1571,36 @@ private class AsyncDispatchable implements Dispatchable\n         @Override\n         public void dispatch() throws IOException, ServletException\n         {\n-            _contextHandler.handleAsync(HttpChannel.this);\n+            AsyncContextEvent event = HttpChannel.this.getState().getAsyncContextEvent();\n+\n+            //the user has dispatched to the same current context\n+            if (event == null || event.getDispatchContext() == null || event.getDispatchContext() == _contextHandler.getServletContext())\n+                _contextHandler.handleAsync(HttpChannel.this);\n+            else\n+            {\n+                //the user has dispatched to a different context\n+                if (event.getDispatchContext() instanceof CrossContextServletContext crossContextServletContext)\n+                {\n+                   dispatchCrossContext(crossContextServletContext);\n+                }\n+                else\n+                {\n+                    //the container has dispatched us to a different context\n+                    ServletContext targetContext = _contextHandler.getServletContext().getContext(event.getDispatchContext().getContextPath());\n+                    if (targetContext instanceof CrossContextServletContext crossContextServletContext)\n+                        dispatchCrossContext(crossContextServletContext);\n+                    else\n+                        throw new IllegalStateException(\""Dispatch \"" + _contextHandler.getContextPath() + \"" -> non CrossContextServletContext\"" + event.getDispatchContext().getContextPath() + event.getDispatchContext());\n+                }\n+            }\n+        }\n+\n+        private void dispatchCrossContext(CrossContextServletContext crossContextServletContext) throws ServletException, IOException\n+        {\n+            if (crossContextServletContext.getTargetContext().getContextHandler() instanceof ContextHandler.CoreContextHandler coreContextHandler)\n+            {\n+                coreContextHandler.getContextHandler().handleCrossContextAsync(HttpChannel.this);\n+            }\n         }\n     }\n \n\ndiff --git a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/HttpChannelState.java b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/HttpChannelState.java\nindex 17b1bf626883..00c11df95fce 100644\n--- a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/HttpChannelState.java\n+++ b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/HttpChannelState.java\n@@ -1235,9 +1235,14 @@ ContextHandler getContextHandler(AsyncContextEvent event)\n     {\n         if (event != null)\n         {\n-            ContextHandler.APIContext context = ((ContextHandler.APIContext)event.getServletContext());\n-            if (context != null)\n-                return context.getContextHandler();\n+            ServletContext servletContext = event.getServletContext();\n+            if (servletContext instanceof CrossContextServletContext crossContextServletContext)\n+            {\n+                if (crossContextServletContext.getTargetContext().getContextHandler() instanceof ContextHandler.CoreContextHandler coreContextHandler)\n+                    return  coreContextHandler.getContextHandler();\n+            }\n+            if (servletContext instanceof ContextHandler.APIContext apiContext)\n+                return apiContext.getContextHandler();\n         }\n         return null;\n     }\n\ndiff --git a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java\nindex 38c2dc4c2eef..c449f33255a3 100644\n--- a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java\n+++ b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java\n@@ -1944,6 +1944,8 @@ private AsyncContextState forceStartAsync()\n         if (_async == null)\n             _async = new AsyncContextState(state);\n         AsyncContextEvent event = new AsyncContextEvent(_context, _async, state, this, this, getResponse());\n+        //Note that we do not remember the context, httpuri or the path, as null values for these are used by\n+        //ContextHandler.handleAsync to recognize a non-cross context async dispatch\n         state.startAsync(event);\n         return _async;\n     }\n@@ -1957,6 +1959,7 @@ public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse se\n         if (_async == null)\n             _async = new AsyncContextState(state);\n         AsyncContextEvent event = new AsyncContextEvent(_context, _async, state, this, servletRequest, servletResponse, getHttpURI());\n+        event.setDispatchPath(URIUtil.encodePath(Request.getBaseRequest(servletRequest).getPathInContext()));\n         event.setDispatchContext(getServletContext());\n         state.startAsync(event);\n         return _async;\n\ndiff --git a/jetty-ee9/jetty-ee9-servlet/pom.xml b/jetty-ee9/jetty-ee9-servlet/pom.xml\nindex 51c3d97b4327..c098aad33e09 100644\n--- a/jetty-ee9/jetty-ee9-servlet/pom.xml\n+++ b/jetty-ee9/jetty-ee9-servlet/pom.xml\n@@ -74,7 +74,6 @@\n         <configuration>\n           <reuseForks>true</reuseForks>\n           <argLine>@{argLine} ${jetty.surefire.argLine}\n-            --add-modules org.eclipse.jetty.util.ajax\n             --add-reads org.eclipse.jetty.ee9.servlet=org.eclipse.jetty.logging</argLine>\n         </configuration>\n       </plugin>\n"", ""test_patch"": ""diff --git a/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/CrossContextDispatcherFilterTest.java b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/CrossContextDispatcherFilterTest.java\nnew file mode 100644\nindex 000000000000..13bf667e32bf\n--- /dev/null\n+++ b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/CrossContextDispatcherFilterTest.java\n@@ -0,0 +1,294 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.ee10.servlet;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.TimeUnit;\n+\n+import jakarta.servlet.AsyncContext;\n+import jakarta.servlet.AsyncEvent;\n+import jakarta.servlet.AsyncListener;\n+import jakarta.servlet.DispatcherType;\n+import jakarta.servlet.Filter;\n+import jakarta.servlet.FilterChain;\n+import jakarta.servlet.RequestDispatcher;\n+import jakarta.servlet.ServletContext;\n+import jakarta.servlet.ServletException;\n+import jakarta.servlet.ServletRequest;\n+import jakarta.servlet.ServletResponse;\n+import jakarta.servlet.http.HttpServlet;\n+import jakarta.servlet.http.HttpServletRequest;\n+import jakarta.servlet.http.HttpServletResponse;\n+import org.eclipse.jetty.http.HttpTester;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.LocalConnector;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.handler.ContextHandlerCollection;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.eclipse.jetty.toolchain.test.ExtraMatchers.ordered;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class CrossContextDispatcherFilterTest\n+{\n+    private Server server;\n+    private LocalConnector connector;\n+\n+    public void startServer(ContextHandlerCollection contextHandlerCollection) throws Exception\n+    {\n+        server = new Server();\n+        connector = new LocalConnector(server);\n+        connector.getConnectionFactory(HttpConfiguration.ConnectionFactory.class).getHttpConfiguration().setSendServerVersion(false);\n+        connector.getConnectionFactory(HttpConfiguration.ConnectionFactory.class).getHttpConfiguration().setSendDateHeader(false);\n+        server.addConnector(connector);\n+\n+        server.setHandler(contextHandlerCollection);\n+        server.start();\n+    }\n+\n+    @Test\n+    public void testFilterInitiated() throws Exception\n+    {\n+        final CountDownLatch filterCompleteLatch = new CountDownLatch(1);\n+        final BlockingQueue<String> events = new LinkedBlockingDeque<>();\n+\n+        // Root Context\n+        ServletContextHandler contextRoot = new ServletContextHandler();\n+        contextRoot.setCrossContextDispatchSupported(true);\n+        contextRoot.setContextPath(\""/\"");\n+        ServletHolder helloServlet = new ServletHolder(\""hello-servlet\"", new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+            {\n+                events.add(\""Hello Servlet GET (context=\"" + getServletContext().getContextPath() + \"")\"");\n+                resp.setCharacterEncoding(\""utf-8\"");\n+                resp.setContentType(\""text/plain\"");\n+                resp.getWriter().println(\""Reached HelloServlet\"");\n+            }\n+        });\n+        contextRoot.addServlet(helloServlet, \""*.hello\"");\n+        FilterHolder dispatchFilter = new FilterHolder(new Filter()\n+        {\n+            @Override\n+            public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException\n+            {\n+                HttpServletRequest httpRequest = (HttpServletRequest)request;\n+                events.add(\""Reached Filter (context=\"" + request.getServletContext().getContextPath() + \"")\"");\n+                ServletContext otherContext = request.getServletContext().getContext(\""/service\"");\n+                RequestDispatcher dispatcher = otherContext.getRequestDispatcher(\""/alt/foo.hello\"");\n+                events.add(\""Filter Dispatcher Forward (context=\"" + request.getServletContext().getContextPath() + \"")\"");\n+                events.add(\"" + http.requestURI=\"" + httpRequest.getRequestURI());\n+                events.add(\"" + http.requestURL=\"" + httpRequest.getRequestURL());\n+                dispatcher.forward(request, response);\n+                events.add(\""Filter Returned from Forward Dispatch (context=\"" + request.getServletContext().getContextPath() + \"")\"");\n+                events.add(\"" - http.requestURI=\"" + httpRequest.getRequestURI());\n+                events.add(\"" - http.requestURL=\"" + httpRequest.getRequestURL());\n+                filterCompleteLatch.countDown();\n+            }\n+        });\n+        contextRoot.addFilter(dispatchFilter, \""/group/*\"", EnumSet.of(DispatcherType.REQUEST));\n+\n+        // Service Context\n+        ServletContextHandler contextService = new ServletContextHandler();\n+        contextService.setCrossContextDispatchSupported(true);\n+        contextService.setContextPath(\""/service\"");\n+        ServletHolder serviceHolder = new ServletHolder(\""service-servlet\"", new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+            {\n+                events.add(\""Service Servlet GET (context=\"" + getServletContext().getContextPath() + \"")\"");\n+                resp.setCharacterEncoding(\""utf-8\"");\n+                resp.setContentType(\""text/plain\"");\n+                resp.getWriter().println(\""Reached Service context\"");\n+            }\n+        });\n+        contextService.addServlet(serviceHolder, \""/alt/*\"");\n+\n+        ContextHandlerCollection contextHandlerCollection = new ContextHandlerCollection();\n+        contextHandlerCollection.addHandler(contextRoot);\n+        contextHandlerCollection.addHandler(contextService);\n+\n+        startServer(contextHandlerCollection);\n+\n+        String rawRequest = \""\""\""\n+            GET /group/formal.hello HTTP/1.1\n+            Host: local\n+            Connection: close\n+            \n+            \""\""\"";\n+        HttpTester.Response response = HttpTester.parseResponse(connector.getResponse(rawRequest));\n+        assertThat(response.getStatus(), is(200));\n+        assertThat(response.getContent(), containsString(\""Reached Service context\""));\n+\n+        assertTrue(filterCompleteLatch.await(5, TimeUnit.SECONDS));\n+        List<String> expectedEvents = new ArrayList<>();\n+        expectedEvents.add(\""Reached Filter (context=)\"");\n+        expectedEvents.add(\""Filter Dispatcher Forward (context=)\"");\n+        expectedEvents.add(\"" + http.requestURI=/group/formal.hello\"");\n+        expectedEvents.add(\"" + http.requestURL=http://local/group/formal.hello\"");\n+        expectedEvents.add(\""Service Servlet GET (context=/service)\"");\n+        expectedEvents.add(\""Filter Returned from Forward Dispatch (context=)\"");\n+        expectedEvents.add(\"" - http.requestURI=/group/formal.hello\"");\n+        expectedEvents.add(\"" - http.requestURL=http://local/group/formal.hello\"");\n+        List<String> eventsInOrder = new ArrayList<>(events);\n+        assertThat(eventsInOrder, ordered(expectedEvents));\n+    }\n+\n+     @Test\n+    public void testFilterInitiatedWithAsync() throws Exception\n+    {\n+        final CountDownLatch filterCompleteLatch = new CountDownLatch(1);\n+        final BlockingQueue<String> events = new LinkedBlockingDeque<>();\n+\n+        // Root Context\n+        ServletContextHandler contextRoot = new ServletContextHandler();\n+        contextRoot.setCrossContextDispatchSupported(true);\n+        contextRoot.setContextPath(\""/\"");\n+        ServletHolder helloServlet = new ServletHolder(\""hello-servlet\"", new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+            {\n+                events.add(\""Hello Servlet GET (context=\"" + getServletContext().getContextPath() + \"")\"");\n+                resp.setCharacterEncoding(\""utf-8\"");\n+                resp.setContentType(\""text/plain\"");\n+                resp.getWriter().println(\""Reached HelloServlet\"");\n+            }\n+        });\n+        contextRoot.addServlet(helloServlet, \""*.hello\"");\n+        FilterHolder dispatchFilter = new FilterHolder(new Filter()\n+        {\n+            @Override\n+            public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException\n+            {\n+                HttpServletRequest httpRequest = (HttpServletRequest)request;\n+                events.add(\""Reached Filter (context=\"" + request.getServletContext().getContextPath() + \"", Dispatchertype=\"" + request.getDispatcherType() + \"")\"");\n+                ServletContext otherContext = request.getServletContext().getContext(\""/service\"");\n+                RequestDispatcher dispatcher = otherContext.getRequestDispatcher(\""/alt/foo.hello\"");\n+                events.add(\""Filter Dispatcher Forward (context=\"" + request.getServletContext().getContextPath() + \"", Dispatchertype=\"" + request.getDispatcherType() + \"")\"");\n+                events.add(\"" + http.requestURI=\"" + httpRequest.getRequestURI());\n+                events.add(\"" + http.requestURL=\"" + httpRequest.getRequestURL());\n+                dispatcher.forward(request, response);\n+                events.add(\""Filter Returned from Forward Dispatch (context=\"" + request.getServletContext().getContextPath() + \"", Dispatchertype=\"" + request.getDispatcherType() + \"")\"");\n+                events.add(\"" - http.requestURI=\"" + httpRequest.getRequestURI());\n+                events.add(\"" - http.requestURL=\"" + httpRequest.getRequestURL());\n+                filterCompleteLatch.countDown();\n+            }\n+        });\n+        contextRoot.addFilter(dispatchFilter, \""/group/*\"", EnumSet.of(DispatcherType.REQUEST));\n+\n+        // Service Context\n+        ServletContextHandler contextService = new ServletContextHandler();\n+        contextService.setCrossContextDispatchSupported(true);\n+        contextService.setContextPath(\""/service\"");\n+        ServletHolder serviceHolder = new ServletHolder(\""service-servlet\"", new HttpServlet()\n+        {\n+            static final String ASYNC_FLAG_NAME = \""async.flag\"";\n+\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+            {\n+                if (req.getAttribute(ASYNC_FLAG_NAME) == null)\n+                {\n+                    events.add(\""Service Servlet GET (context=\"" + getServletContext().getContextPath() + \"", Dispatchertype=\"" + req.getDispatcherType() + \"") startAsync\"");\n+                    AsyncContext asyncContext = req.startAsync(req, resp);\n+                    req.setAttribute(ASYNC_FLAG_NAME, new Object());\n+                    asyncContext.setTimeout(1000);\n+                    asyncContext.addListener(new AsyncListener()\n+                    {\n+                        @Override\n+                        public void onComplete(AsyncEvent event)\n+                        {\n+                        }\n+\n+                        @Override\n+                        public void onTimeout(AsyncEvent event)\n+                        {\n+                            // trigger redispatch back to this servlet\n+                            events.add(\""Async onTimeout predispatch\"");\n+                            event.getAsyncContext().dispatch();\n+                            events.add(\""Async onTimeout postdispatch\"");\n+                        }\n+\n+                        @Override\n+                        public void onError(AsyncEvent event)\n+                        {\n+                        }\n+\n+                        @Override\n+                        public void onStartAsync(AsyncEvent event)\n+                        {\n+                        }\n+                    });\n+                }\n+                else\n+                {\n+                    events.add(\""Service Servlet GET (context=\"" + getServletContext().getContextPath() + \"", Dispatchertype=\"" + req.getDispatcherType() + \"") afterDispatch\"");\n+                    resp.setCharacterEncoding(\""utf-8\"");\n+                    resp.setContentType(\""text/plain\"");\n+                    resp.getWriter().println(\""Reached Service context\"");\n+                }\n+            }\n+        });\n+        serviceHolder.setAsyncSupported(true);\n+        contextService.addServlet(serviceHolder, \""/alt/*\"");\n+\n+        ContextHandlerCollection contextHandlerCollection = new ContextHandlerCollection();\n+        contextHandlerCollection.addHandler(contextRoot);\n+        contextHandlerCollection.addHandler(contextService);\n+\n+        startServer(contextHandlerCollection);\n+\n+        String rawRequest = \""\""\""\n+            GET /group/formal.hello HTTP/1.1\n+            Host: local\n+            Connection: close\n+            \n+            \""\""\"";\n+        HttpTester.Response response = HttpTester.parseResponse(connector.getResponse(rawRequest));\n+        assertThat(response.getStatus(), is(200));\n+        assertThat(response.getContent(), containsString(\""Reached Service context\""));\n+        assertTrue(filterCompleteLatch.await(5, TimeUnit.SECONDS));\n+\n+        //Note that events are in a different order than ee9: in ee10 and above the forward\n+        //from the first context to the second context cannot complete until the async\n+        //dispatch that is started within the second context has completed.\n+        List<String> expectedEvents = new ArrayList<>();\n+        expectedEvents.add(\""Reached Filter (context=, Dispatchertype=REQUEST)\"");\n+        expectedEvents.add(\""Filter Dispatcher Forward (context=, Dispatchertype=REQUEST)\"");\n+        expectedEvents.add(\"" + http.requestURI=/group/formal.hello\"");\n+        expectedEvents.add(\"" + http.requestURL=http://local/group/formal.hello\"");\n+        expectedEvents.add(\""Service Servlet GET (context=/service, Dispatchertype=FORWARD) startAsync\"");\n+        expectedEvents.add(\""Async onTimeout predispatch\"");\n+        expectedEvents.add(\""Async onTimeout postdispatch\"");\n+        expectedEvents.add(\""Service Servlet GET (context=/service, Dispatchertype=ASYNC) afterDispatch\"");\n+        expectedEvents.add(\""Filter Returned from Forward Dispatch (context=, Dispatchertype=REQUEST)\"");\n+        expectedEvents.add(\"" - http.requestURI=/group/formal.hello\"");\n+        expectedEvents.add(\"" - http.requestURL=http://local/group/formal.hello\"");\n+\n+        List<String> eventsInOrder = new ArrayList<>(events);\n+        assertThat(eventsInOrder, ordered(expectedEvents));\n+    }\n+}\n\ndiff --git a/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-sessions/jetty-ee10-test-sessions-common/src/test/java/org/eclipse/jetty/ee10/session/AsyncTest.java b/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-sessions/jetty-ee10-test-sessions-common/src/test/java/org/eclipse/jetty/ee10/session/AsyncTest.java\nindex a89cfae4e990..1852cfb17167 100644\n--- a/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-sessions/jetty-ee10-test-sessions-common/src/test/java/org/eclipse/jetty/ee10/session/AsyncTest.java\n+++ b/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-sessions/jetty-ee10-test-sessions-common/src/test/java/org/eclipse/jetty/ee10/session/AsyncTest.java\n@@ -15,11 +15,18 @@\n \n import java.io.IOException;\n import java.lang.reflect.Proxy;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.concurrent.TimeUnit;\n \n import jakarta.servlet.AsyncContext;\n+import jakarta.servlet.AsyncEvent;\n+import jakarta.servlet.AsyncListener;\n+import jakarta.servlet.ServletContext;\n import jakarta.servlet.ServletException;\n import jakarta.servlet.ServletOutputStream;\n+import jakarta.servlet.ServletRequestEvent;\n+import jakarta.servlet.ServletRequestListener;\n import jakarta.servlet.WriteListener;\n import jakarta.servlet.http.HttpServlet;\n import jakarta.servlet.http.HttpServletRequest;\n@@ -30,7 +37,12 @@\n import org.eclipse.jetty.client.HttpClient;\n import org.eclipse.jetty.ee10.servlet.ServletContextHandler;\n import org.eclipse.jetty.ee10.servlet.ServletHolder;\n+import org.eclipse.jetty.http.HttpTester;\n import org.eclipse.jetty.logging.StacklessLogging;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.LocalConnector;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.handler.ContextHandlerCollection;\n import org.eclipse.jetty.session.DefaultSessionCacheFactory;\n import org.eclipse.jetty.session.SessionCache;\n import org.eclipse.jetty.session.SessionDataStoreFactory;\n@@ -38,9 +50,13 @@\n import org.eclipse.jetty.session.test.FooInvocationHandler;\n import org.eclipse.jetty.session.test.TestFoo;\n import org.eclipse.jetty.session.test.TestSessionDataStoreFactory;\n+import org.hamcrest.Matchers;\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n \n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n@@ -149,7 +165,131 @@ public void testSessionWithAsyncComplete() throws Exception\n         }\n     }\n \n-    @Disabled //TODO cross context not supported\n+    @Test\n+    public void testSimpleCrossContextAsync() throws Exception\n+    {\n+        //Test async cross context dispatch from context A to context B\n+        Server server = new Server();\n+        ContextHandlerCollection contextHandlerCollection = new ContextHandlerCollection();\n+\n+        final List<String> events = new ArrayList<>();\n+\n+        ServletContextHandler contextA = new ServletContextHandler();\n+        contextA.addEventListener(new ServletRequestListener()\n+        {\n+            @Override\n+            public void requestDestroyed(ServletRequestEvent sre)\n+            {\n+                events.add(\""Request Destroyed: \"" + sre.getServletRequest().getServletContext().getContextPath());\n+                ServletRequestListener.super.requestDestroyed(sre);\n+            }\n+\n+            @Override\n+            public void requestInitialized(ServletRequestEvent sre)\n+            {\n+                events.add(\""Request Initialized: \"" + sre.getServletRequest().getServletContext().getContextPath());\n+                ServletRequestListener.super.requestInitialized(sre);\n+            }\n+        });\n+        contextA.setContextPath(\""/ctxA\"");\n+        contextA.setCrossContextDispatchSupported(true);\n+        final String ASYNC_FLAG_NAME = \""async.flag\"";\n+\n+        ServletHolder serviceHolder = new ServletHolder(\""service-servlet\"", new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+            {\n+                if (req.getAttribute(ASYNC_FLAG_NAME) == null)\n+                {\n+                    AsyncContext asyncContext = req.startAsync(req, resp);\n+                    req.setAttribute(ASYNC_FLAG_NAME, new Object());\n+                    asyncContext.setTimeout(100);\n+                    asyncContext.addListener(new AsyncListener()\n+                    {\n+                        @Override\n+                        public void onComplete(AsyncEvent event)\n+                        {\n+                            events.add(\""ON complete\"");\n+                        }\n+\n+                        @Override\n+                        public void onTimeout(AsyncEvent event)\n+                        {\n+                            events.add(\""ON timeout\"");\n+                        }\n+\n+                        @Override\n+                        public void onError(AsyncEvent event)\n+                        {\n+                            events.add(\""ON error\"");\n+                        }\n+\n+                        @Override\n+                        public void onStartAsync(AsyncEvent event)\n+                        {\n+                            events.add(\""ON startasync\"");\n+                        }\n+                    });\n+                    //perform cross context dispatch\n+                    ServletContext destination = req.getServletContext().getContext(\""/ctxB\"");\n+                    asyncContext.dispatch(destination, \""/dispatched/z\"");\n+                }\n+            }\n+        });\n+\n+        serviceHolder.setAsyncSupported(true);\n+        contextA.addServlet(serviceHolder, \""/dispatcher/*\"");\n+        contextHandlerCollection.addHandler(contextA);\n+\n+        ServletContextHandler contextB = new ServletContextHandler();\n+        contextB.setContextPath(\""/ctxB\"");\n+        contextB.setCrossContextDispatchSupported(true);\n+\n+        ServletHolder testHolder = new ServletHolder(\""test-servlet\"", new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+            {\n+                resp.setCharacterEncoding(\""utf-8\"");\n+                resp.setContentType(\""text/plain\"");\n+                resp.getWriter().println(\""Dispatched to ctxB in test-servlet\"");\n+                resp.getWriter().println(req.getQueryString());\n+            }\n+        });\n+\n+        contextB.addServlet(testHolder, \""/dispatched/*\"");\n+        contextHandlerCollection.addHandler(contextB);\n+        server.setHandler(contextHandlerCollection);\n+        LocalConnector connector = new LocalConnector(server);\n+        connector.getConnectionFactory(HttpConfiguration.ConnectionFactory.class).getHttpConfiguration().setSendServerVersion(false);\n+        connector.getConnectionFactory(HttpConfiguration.ConnectionFactory.class).getHttpConfiguration().setSendDateHeader(false);\n+        server.addConnector(connector);\n+\n+        server.start();\n+\n+        try\n+        {\n+\n+            String rawRequest = \""\""\""\n+                GET /ctxA/dispatcher/x?foo=bar HTTP/1.1\n+                Host: local\n+                Connection: close\n+                            \n+                \""\""\"";\n+\n+            HttpTester.Response response = HttpTester.parseResponse(connector.getResponse(rawRequest));\n+            assertThat(response.getStatus(), is(200));\n+            assertThat(events, Matchers.containsInRelativeOrder(\""Request Initialized: /ctxA\"", \""Request Destroyed: /ctxA\""));\n+            assertThat(response.getContent(), containsString(\""Dispatched to ctxB in test-servlet\""));\n+            assertThat(response.getContent(), containsString(\""foo=bar\""));\n+        }\n+        finally\n+        {\n+            server.stop();\n+        }\n+    }\n+\n     @Test\n     public void testSessionWithCrossContextAsync() throws Exception\n     {\n@@ -163,11 +303,13 @@ public void testSessionWithCrossContextAsync() throws Exception\n         SessionTestSupport server = new SessionTestSupport(0, -1, -1, cacheFactory, storeFactory);\n \n         ServletContextHandler contextA = server.addContext(\""/ctxA\"");\n+        contextA.setCrossContextDispatchSupported(true);\n         CrossContextServlet ccServlet = new CrossContextServlet();\n         ServletHolder ccHolder = new ServletHolder(ccServlet);\n         contextA.addServlet(ccHolder, \""/*\"");\n \n         ServletContextHandler contextB = server.addContext(\""/ctxB\"");\n+        contextB.setCrossContextDispatchSupported(true);\n         TestServlet testServlet = new TestServlet();\n         ServletHolder testHolder = new ServletHolder(testServlet);\n         contextB.addServlet(testHolder, \""/*\"");\n@@ -250,13 +392,16 @@ public void testSessionCreatedBeforeDispatch() throws Exception\n         }   \n     }\n \n-    @Disabled //TODO cross context not supported\n     @Test\n     public void testSessionWithCrossContextAsyncComplete() throws Exception\n     {\n         // Test async dispatch from context A to context B, which then does an\n-        // async write, which creates a session (in context A) and completes outside of a\n-        // dispatch\n+        // async write, which creates a session and completes outside of a\n+        // dispatch. Note that the session will be created in context B, because\n+        // requests are immutable: the request that called startAsync retains its\n+        // pathInContext etc. In earlier versions of the Servlet Spec, the request\n+        // will have been mutated back to it's pre-async dispatch pathInContext\n+        // etc after returning to the container and concluding the async dispatch.\n \n         DefaultSessionCacheFactory cacheFactory = new DefaultSessionCacheFactory();\n         cacheFactory.setEvictionPolicy(SessionCache.EVICT_ON_SESSION_EXIT);\n@@ -265,11 +410,13 @@ public void testSessionWithCrossContextAsyncComplete() throws Exception\n         SessionTestSupport server = new SessionTestSupport(0, -1, -1, cacheFactory, storeFactory);\n \n         ServletContextHandler contextA = server.addContext(\""/ctxA\"");\n+        contextA.setCrossContextDispatchSupported(true);\n         CrossContextServlet ccServlet = new CrossContextServlet();\n         ServletHolder ccHolder = new ServletHolder(ccServlet);\n         contextA.addServlet(ccHolder, \""/*\"");\n \n         ServletContextHandler contextB = server.addContext(\""/ctxB\"");\n+        contextB.setCrossContextDispatchSupported(true);\n         TestServlet testServlet = new TestServlet();\n         ServletHolder testHolder = new ServletHolder(testServlet);\n         contextB.addServlet(testHolder, \""/*\"");\n@@ -280,7 +427,6 @@ public void testSessionWithCrossContextAsyncComplete() throws Exception\n \n         try (StacklessLogging stackless = new StacklessLogging(AsyncTest.class.getPackage()))\n         {\n-\n             client.start();\n             String url = \""http://localhost:\"" + port + \""/ctxA/test?action=asyncComplete\"";\n \n@@ -292,11 +438,11 @@ public void testSessionWithCrossContextAsyncComplete() throws Exception\n \n             assertNotNull(sessionCookie);\n \n-            //session should now be evicted from the cache A after request exited\n+            //session should now be evicted from the ctx B sessioncache after request exited\n             String id = SessionTestSupport.extractSessionId(sessionCookie);\n             Awaitility.await().atMost(30, TimeUnit.SECONDS)\n-                .until(() -> !contextA.getSessionHandler().getSessionCache().contains(id));\n-            assertTrue(contextA.getSessionHandler().getSessionCache().getSessionDataStore().exists(id));\n+                .until(() -> !contextB.getSessionHandler().getSessionCache().contains(id));\n+            assertTrue(contextB.getSessionHandler().getSessionCache().getSessionDataStore().exists(id));\n         }\n         finally\n         {\n@@ -375,6 +521,8 @@ public void onWritePossible() throws IOException\n                     {\n                         if (out.isReady())\n                         {\n+                            //This is a really BAD idea. You should not be creating a\n+                            //new session when you are supposed to be producing output.\n                             HttpSession s = request.getSession(true);\n                             out.print(\""OK\\n\"");\n                             acontext.complete();\n@@ -384,7 +532,7 @@ public void onWritePossible() throws IOException\n                     @Override\n                     public void onError(Throwable t)\n                     {\n-\n+                        t.printStackTrace();\n                     }\n                 });\n             }\n\ndiff --git a/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/CrossContextDispatcherFilterTest.java b/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/CrossContextDispatcherFilterTest.java\nnew file mode 100644\nindex 000000000000..7f366624f7d0\n--- /dev/null\n+++ b/jetty-ee9/jetty-ee9-servlet/src/test/java/org/eclipse/jetty/ee9/servlet/CrossContextDispatcherFilterTest.java\n@@ -0,0 +1,290 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.ee9.servlet;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.TimeUnit;\n+\n+import jakarta.servlet.AsyncContext;\n+import jakarta.servlet.AsyncEvent;\n+import jakarta.servlet.AsyncListener;\n+import jakarta.servlet.DispatcherType;\n+import jakarta.servlet.Filter;\n+import jakarta.servlet.FilterChain;\n+import jakarta.servlet.RequestDispatcher;\n+import jakarta.servlet.ServletContext;\n+import jakarta.servlet.ServletException;\n+import jakarta.servlet.ServletRequest;\n+import jakarta.servlet.ServletResponse;\n+import jakarta.servlet.http.HttpServlet;\n+import jakarta.servlet.http.HttpServletRequest;\n+import jakarta.servlet.http.HttpServletResponse;\n+import org.eclipse.jetty.http.HttpTester;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.LocalConnector;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.handler.ContextHandlerCollection;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.eclipse.jetty.toolchain.test.ExtraMatchers.ordered;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class CrossContextDispatcherFilterTest\n+{\n+    private Server server;\n+    private LocalConnector connector;\n+\n+    public void startServer(ContextHandlerCollection contextHandlerCollection) throws Exception\n+    {\n+        server = new Server();\n+        connector = new LocalConnector(server);\n+        connector.getConnectionFactory(HttpConfiguration.ConnectionFactory.class).getHttpConfiguration().setSendServerVersion(false);\n+        connector.getConnectionFactory(HttpConfiguration.ConnectionFactory.class).getHttpConfiguration().setSendDateHeader(false);\n+        server.addConnector(connector);\n+\n+        server.setHandler(contextHandlerCollection);\n+        server.start();\n+    }\n+\n+    @Test\n+    public void testFilterInitiated() throws Exception\n+    {\n+        final CountDownLatch filterCompleteLatch = new CountDownLatch(1);\n+        final BlockingQueue<String> events = new LinkedBlockingDeque<>();\n+\n+        // Root Context\n+        ServletContextHandler contextRoot = new ServletContextHandler();\n+        contextRoot.setCrossContextDispatchSupported(true);\n+        contextRoot.setContextPath(\""/\"");\n+        ServletHolder helloServlet = new ServletHolder(\""hello-servlet\"", new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+            {\n+                events.add(\""Hello Servlet GET (context=\"" + getServletContext().getContextPath() + \"")\"");\n+                resp.setCharacterEncoding(\""utf-8\"");\n+                resp.setContentType(\""text/plain\"");\n+                resp.getWriter().println(\""Reached HelloServlet\"");\n+            }\n+        });\n+        contextRoot.addServlet(helloServlet, \""*.hello\"");\n+        FilterHolder dispatchFilter = new FilterHolder(new Filter()\n+        {\n+            @Override\n+            public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException\n+            {\n+                HttpServletRequest httpRequest = (HttpServletRequest)request;\n+                events.add(\""Reached Filter (context=\"" + request.getServletContext().getContextPath() + \"")\"");\n+                ServletContext otherContext = request.getServletContext().getContext(\""/service\"");\n+                RequestDispatcher dispatcher = otherContext.getRequestDispatcher(\""/alt/foo.hello\"");\n+                events.add(\""Filter Dispatcher Forward (context=\"" + request.getServletContext().getContextPath() + \"")\"");\n+                events.add(\"" + http.requestURI=\"" + httpRequest.getRequestURI());\n+                events.add(\"" + http.requestURL=\"" + httpRequest.getRequestURL());\n+                dispatcher.forward(request, response);\n+                events.add(\""Filter Returned from Forward Dispatch (context=\"" + request.getServletContext().getContextPath() + \"")\"");\n+                events.add(\"" - http.requestURI=\"" + httpRequest.getRequestURI());\n+                events.add(\"" - http.requestURL=\"" + httpRequest.getRequestURL());\n+                filterCompleteLatch.countDown();\n+            }\n+        });\n+        contextRoot.addFilter(dispatchFilter, \""/group/*\"", EnumSet.of(DispatcherType.REQUEST));\n+\n+        // Service Context\n+        ServletContextHandler contextService = new ServletContextHandler();\n+        contextService.setCrossContextDispatchSupported(true);\n+        contextService.setContextPath(\""/service\"");\n+        ServletHolder serviceHolder = new ServletHolder(\""service-servlet\"", new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+            {\n+                events.add(\""Service Servlet GET (context=\"" + getServletContext().getContextPath() + \"")\"");\n+                resp.setCharacterEncoding(\""utf-8\"");\n+                resp.setContentType(\""text/plain\"");\n+                resp.getWriter().println(\""Reached Service context\"");\n+            }\n+        });\n+        contextService.addServlet(serviceHolder, \""/alt/*\"");\n+\n+        ContextHandlerCollection contextHandlerCollection = new ContextHandlerCollection();\n+        contextHandlerCollection.addHandler(contextRoot);\n+        contextHandlerCollection.addHandler(contextService);\n+\n+        startServer(contextHandlerCollection);\n+\n+        String rawRequest = \""\""\""\n+            GET /group/formal.hello HTTP/1.1\n+            Host: local\n+            Connection: close\n+            \n+            \""\""\"";\n+        HttpTester.Response response = HttpTester.parseResponse(connector.getResponse(rawRequest));\n+        assertThat(response.getStatus(), is(200));\n+        assertThat(response.getContent(), containsString(\""Reached Service context\""));\n+\n+        assertTrue(filterCompleteLatch.await(5, TimeUnit.SECONDS));\n+        List<String> expectedEvents = new ArrayList<>();\n+        expectedEvents.add(\""Reached Filter (context=)\"");\n+        expectedEvents.add(\""Filter Dispatcher Forward (context=)\"");\n+        expectedEvents.add(\"" + http.requestURI=/group/formal.hello\"");\n+        expectedEvents.add(\"" + http.requestURL=http://local/group/formal.hello\"");\n+        expectedEvents.add(\""Service Servlet GET (context=/service)\"");\n+        expectedEvents.add(\""Filter Returned from Forward Dispatch (context=)\"");\n+        expectedEvents.add(\"" - http.requestURI=/group/formal.hello\"");\n+        expectedEvents.add(\"" - http.requestURL=http://local/group/formal.hello\"");\n+        List<String> eventsInOrder = new ArrayList<>(events);\n+        assertThat(eventsInOrder, ordered(expectedEvents));\n+    }\n+\n+    @Test\n+    public void testFilterInitiatedWithAsync() throws Exception\n+    {\n+        final CountDownLatch filterCompleteLatch = new CountDownLatch(1);\n+        final BlockingQueue<String> events = new LinkedBlockingDeque<>();\n+\n+        // Root Context\n+        ServletContextHandler contextRoot = new ServletContextHandler();\n+        contextRoot.setCrossContextDispatchSupported(true);\n+        contextRoot.setContextPath(\""/\"");\n+        ServletHolder helloServlet = new ServletHolder(\""hello-servlet\"", new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+            {\n+                events.add(\""Hello Servlet GET (context=\"" + getServletContext().getContextPath() + \"")\"");\n+                resp.setCharacterEncoding(\""utf-8\"");\n+                resp.setContentType(\""text/plain\"");\n+                resp.getWriter().println(\""Reached HelloServlet\"");\n+            }\n+        });\n+        contextRoot.addServlet(helloServlet, \""*.hello\"");\n+        FilterHolder dispatchFilter = new FilterHolder(new Filter()\n+        {\n+            @Override\n+            public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException\n+            {\n+                HttpServletRequest httpRequest = (HttpServletRequest)request;\n+                events.add(\""Reached Filter (context=\"" + request.getServletContext().getContextPath() + \"")\"");\n+                ServletContext otherContext = request.getServletContext().getContext(\""/service\"");\n+                RequestDispatcher dispatcher = otherContext.getRequestDispatcher(\""/alt/foo.hello\"");\n+                events.add(\""Filter Dispatcher Forward (context=\"" + request.getServletContext().getContextPath() + \"")\"");\n+                events.add(\"" + http.requestURI=\"" + httpRequest.getRequestURI());\n+                events.add(\"" + http.requestURL=\"" + httpRequest.getRequestURL());\n+                dispatcher.forward(request, response);\n+                events.add(\""Filter Returned from Forward Dispatch (context=\"" + request.getServletContext().getContextPath() + \"")\"");\n+                events.add(\"" - http.requestURI=\"" + httpRequest.getRequestURI());\n+                events.add(\"" - http.requestURL=\"" + httpRequest.getRequestURL());\n+                filterCompleteLatch.countDown();\n+            }\n+        });\n+        contextRoot.addFilter(dispatchFilter, \""/group/*\"", EnumSet.of(DispatcherType.REQUEST));\n+\n+        // Service Context\n+        ServletContextHandler contextService = new ServletContextHandler();\n+        contextService.setCrossContextDispatchSupported(true);\n+        contextService.setContextPath(\""/service\"");\n+        ServletHolder serviceHolder = new ServletHolder(\""service-servlet\"", new HttpServlet()\n+        {\n+            static final String ASYNC_FLAG_NAME = \""async.flag\"";\n+\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+            {\n+                if (req.getAttribute(ASYNC_FLAG_NAME) == null)\n+                {\n+                    events.add(\""Service Servlet GET (context=\"" + getServletContext().getContextPath() + \"") startAsync\"");\n+                    AsyncContext asyncContext = req.startAsync(req, resp);\n+                    req.setAttribute(ASYNC_FLAG_NAME, new Object());\n+                    asyncContext.setTimeout(100);\n+                    asyncContext.addListener(new AsyncListener()\n+                    {\n+                        @Override\n+                        public void onComplete(AsyncEvent event)\n+                        {\n+                        }\n+\n+                        @Override\n+                        public void onTimeout(AsyncEvent event)\n+                        {\n+                            // trigger redispatch back to this servlet\n+                            events.add(\""Async onTimeout predispatch\"");\n+                            event.getAsyncContext().dispatch();\n+                            events.add(\""Async onTimeout postdispatch\"");\n+                        }\n+\n+                        @Override\n+                        public void onError(AsyncEvent event)\n+                        {\n+                        }\n+\n+                        @Override\n+                        public void onStartAsync(AsyncEvent event)\n+                        {\n+                        }\n+                    });\n+                }\n+                else\n+                {\n+                    events.add(\""Service Servlet GET (context=\"" + getServletContext().getContextPath() + \"") afterDispatch\"");\n+                    resp.setCharacterEncoding(\""utf-8\"");\n+                    resp.setContentType(\""text/plain\"");\n+                    resp.getWriter().println(\""Reached Service context\"");\n+                }\n+            }\n+        });\n+        serviceHolder.setAsyncSupported(true);\n+        contextService.addServlet(serviceHolder, \""/alt/*\"");\n+\n+        ContextHandlerCollection contextHandlerCollection = new ContextHandlerCollection();\n+        contextHandlerCollection.addHandler(contextRoot);\n+        contextHandlerCollection.addHandler(contextService);\n+\n+        startServer(contextHandlerCollection);\n+\n+        String rawRequest = \""\""\""\n+            GET /group/formal.hello HTTP/1.1\n+            Host: local\n+            Connection: close\n+            \n+            \""\""\"";\n+        HttpTester.Response response = HttpTester.parseResponse(connector.getResponse(rawRequest));\n+        assertThat(response.getStatus(), is(200));\n+        assertThat(response.getContent(), containsString(\""Reached Service context\""));\n+\n+        assertTrue(filterCompleteLatch.await(5, TimeUnit.SECONDS));\n+        List<String> expectedEvents = new ArrayList<>();\n+        expectedEvents.add(\""Reached Filter (context=)\"");\n+        expectedEvents.add(\""Filter Dispatcher Forward (context=)\"");\n+        expectedEvents.add(\"" + http.requestURI=/group/formal.hello\"");\n+        expectedEvents.add(\"" + http.requestURL=http://local/group/formal.hello\"");\n+        expectedEvents.add(\""Service Servlet GET (context=/service) startAsync\"");\n+        expectedEvents.add(\""Filter Returned from Forward Dispatch (context=)\"");\n+        expectedEvents.add(\"" - http.requestURI=/group/formal.hello\"");\n+        expectedEvents.add(\"" - http.requestURL=http://local/group/formal.hello\"");\n+        expectedEvents.add(\""Async onTimeout predispatch\"");\n+        expectedEvents.add(\""Async onTimeout postdispatch\"");\n+        expectedEvents.add(\""Service Servlet GET (context=/service) afterDispatch\"");\n+        List<String> eventsInOrder = new ArrayList<>(events);\n+        assertThat(eventsInOrder, ordered(expectedEvents));\n+    }\n+}\n\ndiff --git a/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-sessions/jetty-ee9-test-sessions-common/src/test/java/org/eclipse/jetty/ee9/session/AsyncTest.java b/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-sessions/jetty-ee9-test-sessions-common/src/test/java/org/eclipse/jetty/ee9/session/AsyncTest.java\nindex b00e45316fbe..e44fa7ee9505 100644\n--- a/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-sessions/jetty-ee9-test-sessions-common/src/test/java/org/eclipse/jetty/ee9/session/AsyncTest.java\n+++ b/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-sessions/jetty-ee9-test-sessions-common/src/test/java/org/eclipse/jetty/ee9/session/AsyncTest.java\n@@ -15,11 +15,18 @@\n \n import java.io.IOException;\n import java.lang.reflect.Proxy;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.concurrent.TimeUnit;\n \n import jakarta.servlet.AsyncContext;\n+import jakarta.servlet.AsyncEvent;\n+import jakarta.servlet.AsyncListener;\n+import jakarta.servlet.ServletContext;\n import jakarta.servlet.ServletException;\n import jakarta.servlet.ServletOutputStream;\n+import jakarta.servlet.ServletRequestEvent;\n+import jakarta.servlet.ServletRequestListener;\n import jakarta.servlet.WriteListener;\n import jakarta.servlet.http.HttpServlet;\n import jakarta.servlet.http.HttpServletRequest;\n@@ -30,7 +37,12 @@\n import org.eclipse.jetty.client.HttpClient;\n import org.eclipse.jetty.ee9.servlet.ServletContextHandler;\n import org.eclipse.jetty.ee9.servlet.ServletHolder;\n+import org.eclipse.jetty.http.HttpTester;\n import org.eclipse.jetty.logging.StacklessLogging;\n+import org.eclipse.jetty.server.HttpConfiguration;\n+import org.eclipse.jetty.server.LocalConnector;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.handler.ContextHandlerCollection;\n import org.eclipse.jetty.session.DefaultSessionCacheFactory;\n import org.eclipse.jetty.session.SessionCache;\n import org.eclipse.jetty.session.SessionDataStoreFactory;\n@@ -38,9 +50,12 @@\n import org.eclipse.jetty.session.test.FooInvocationHandler;\n import org.eclipse.jetty.session.test.TestFoo;\n import org.eclipse.jetty.session.test.TestSessionDataStoreFactory;\n-import org.junit.jupiter.api.Disabled;\n+import org.hamcrest.Matchers;\n import org.junit.jupiter.api.Test;\n \n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n@@ -145,7 +160,131 @@ public void testSessionWithAsyncComplete() throws Exception\n         }\n     }\n \n-    @Disabled //TODO cross context not supported\n+    @Test\n+    public void testSimpleCrossContextAsync() throws Exception\n+    {\n+        //Test async cross context dispatch from context A to context B\n+        Server server = new Server();\n+        ContextHandlerCollection contextHandlerCollection = new ContextHandlerCollection();\n+\n+        final List<String> events = new ArrayList<>();\n+\n+        ServletContextHandler contextA = new ServletContextHandler();\n+        contextA.addEventListener(new ServletRequestListener()\n+        {\n+            @Override\n+            public void requestDestroyed(ServletRequestEvent sre)\n+            {\n+                events.add(\""Request Destroyed: \"" + sre.getServletRequest().getServletContext().getContextPath());\n+                ServletRequestListener.super.requestDestroyed(sre);\n+            }\n+\n+            @Override\n+            public void requestInitialized(ServletRequestEvent sre)\n+            {\n+                events.add(\""Request Initialized: \"" + sre.getServletRequest().getServletContext().getContextPath());\n+                ServletRequestListener.super.requestInitialized(sre);\n+            }\n+        });\n+        contextA.setContextPath(\""/ctxA\"");\n+        contextA.setCrossContextDispatchSupported(true);\n+        final String ASYNC_FLAG_NAME = \""async.flag\"";\n+\n+        ServletHolder serviceHolder = new ServletHolder(\""service-servlet\"", new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+            {\n+                if (req.getAttribute(ASYNC_FLAG_NAME) == null)\n+                {\n+                    AsyncContext asyncContext = req.startAsync(req, resp);\n+                    req.setAttribute(ASYNC_FLAG_NAME, new Object());\n+                    asyncContext.setTimeout(100);\n+                    asyncContext.addListener(new AsyncListener()\n+                    {\n+                        @Override\n+                        public void onComplete(AsyncEvent event)\n+                        {\n+                            events.add(\""ON complete\"");\n+                        }\n+\n+                        @Override\n+                        public void onTimeout(AsyncEvent event)\n+                        {\n+                            events.add(\""ON timeout\"");\n+                        }\n+\n+                        @Override\n+                        public void onError(AsyncEvent event)\n+                        {\n+                            events.add(\""ON error\"");\n+                        }\n+\n+                        @Override\n+                        public void onStartAsync(AsyncEvent event)\n+                        {\n+                            events.add(\""ON startasync\"");\n+                        }\n+                    });\n+                    //perform cross context dispatch\n+                    ServletContext destination = req.getServletContext().getContext(\""/ctxB\"");\n+                    asyncContext.dispatch(destination, \""/dispatched/z\"");\n+                }\n+            }\n+        });\n+\n+        serviceHolder.setAsyncSupported(true);\n+        contextA.addServlet(serviceHolder, \""/dispatcher/*\"");\n+        contextHandlerCollection.addHandler(contextA);\n+\n+        ServletContextHandler contextB = new ServletContextHandler();\n+        contextB.setContextPath(\""/ctxB\"");\n+        contextB.setCrossContextDispatchSupported(true);\n+\n+        ServletHolder testHolder = new ServletHolder(\""test-servlet\"", new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException\n+            {\n+                resp.setCharacterEncoding(\""utf-8\"");\n+                resp.setContentType(\""text/plain\"");\n+                resp.getWriter().println(\""Dispatched to ctxB in test-servlet\"");\n+                resp.getWriter().println(req.getQueryString());\n+            }\n+        });\n+\n+        contextB.addServlet(testHolder, \""/dispatched/*\"");\n+        contextHandlerCollection.addHandler(contextB);\n+        server.setHandler(contextHandlerCollection);\n+        LocalConnector connector = new LocalConnector(server);\n+        connector.getConnectionFactory(HttpConfiguration.ConnectionFactory.class).getHttpConfiguration().setSendServerVersion(false);\n+        connector.getConnectionFactory(HttpConfiguration.ConnectionFactory.class).getHttpConfiguration().setSendDateHeader(false);\n+        server.addConnector(connector);\n+\n+        server.start();\n+\n+        try\n+        {\n+\n+            String rawRequest = \""\""\""\n+                GET /ctxA/dispatcher/x?foo=bar HTTP/1.1\n+                Host: local\n+                Connection: close\n+                            \n+                \""\""\"";\n+\n+            HttpTester.Response response = HttpTester.parseResponse(connector.getResponse(rawRequest));\n+            assertThat(response.getStatus(), is(200));\n+            assertThat(events, Matchers.containsInRelativeOrder(\""Request Initialized: /ctxA\"", \""Request Destroyed: /ctxA\""));\n+            assertThat(response.getContent(), containsString(\""Dispatched to ctxB in test-servlet\""));\n+            assertThat(response.getContent(), containsString(\""foo=bar\""));\n+        }\n+        finally\n+        {\n+            server.stop();\n+        }\n+    }\n+\n     @Test\n     public void testSessionWithCrossContextAsync() throws Exception\n     {\n@@ -160,10 +299,12 @@ public void testSessionWithCrossContextAsync() throws Exception\n \n         ServletContextHandler contextA = server.addContext(\""/ctxA\"");\n         CrossContextServlet ccServlet = new CrossContextServlet();\n+        contextA.setCrossContextDispatchSupported(true);\n         ServletHolder ccHolder = new ServletHolder(ccServlet);\n         contextA.addServlet(ccHolder, \""/*\"");\n \n         ServletContextHandler contextB = server.addContext(\""/ctxB\"");\n+        contextB.setCrossContextDispatchSupported(true);\n         TestServlet testServlet = new TestServlet();\n         ServletHolder testHolder = new ServletHolder(testServlet);\n         contextB.addServlet(testHolder, \""/*\"");\n@@ -244,7 +385,6 @@ public void testSessionCreatedBeforeDispatch() throws Exception\n         }   \n     }\n \n-    @Disabled //TODO cross context not supported\n     @Test\n     public void testSessionWithCrossContextAsyncComplete() throws Exception\n     {\n@@ -259,11 +399,13 @@ public void testSessionWithCrossContextAsyncComplete() throws Exception\n         SessionTestSupport server = new SessionTestSupport(0, -1, -1, cacheFactory, storeFactory);\n \n         ServletContextHandler contextA = server.addContext(\""/ctxA\"");\n+        contextA.setCrossContextDispatchSupported(true);\n         CrossContextServlet ccServlet = new CrossContextServlet();\n         ServletHolder ccHolder = new ServletHolder(ccServlet);\n         contextA.addServlet(ccHolder, \""/*\"");\n \n         ServletContextHandler contextB = server.addContext(\""/ctxB\"");\n+        contextB.setCrossContextDispatchSupported(true);\n         TestServlet testServlet = new TestServlet();\n         ServletHolder testHolder = new ServletHolder(testServlet);\n         contextB.addServlet(testHolder, \""/*\"");\n@@ -274,7 +416,6 @@ public void testSessionWithCrossContextAsyncComplete() throws Exception\n \n         try (StacklessLogging stackless = new StacklessLogging(AsyncTest.class.getPackage()))\n         {\n-\n             client.start();\n             String url = \""http://localhost:\"" + port + \""/ctxA/test?action=asyncComplete\"";\n \n@@ -369,6 +510,9 @@ public void onWritePossible() throws IOException\n                     {\n                         if (out.isReady())\n                         {\n+                            //This test is a really BAD idea - you should not be\n+                            //creating a HttpSession in a thread that should merely\n+                            //be performing writes on the response.\n                             HttpSession s = request.getSession(true);\n                             out.print(\""OK\\n\"");\n                             acontext.complete();\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-13106"", ""pr_id"": 13106, ""issue_id"": 13040, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Introduce Deploy property `baseResource` for use in 12.1.x deploy\n**Jetty version(s)**\n12.1.x\n\n**Enhancement Description**\nThe new ability to specific behaviors on deploy using just properties files is turning out to be quite useful.\n\nUsing just a simple property name (like we do for `contextPath`) we could even define static deployment using something like ...\n\n```\nenvironment=static\njetty.deploy.contextPath=/something\njetty.deploy.baseResource=/opt/assets/\n```\n\nIt should be able to support anything that ResourceHandler supports."", ""issue_word_count"": 79, ""test_files_count"": 6, ""non_test_files_count"": 7, ""pr_changed_files"": [""jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/CoreContextHandlerTest.java"", ""jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/StaticContextHandlerTest.java"", ""jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java"", ""jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/CoreContextHandler.java"", ""jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/StaticContextHandler.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/resource/ResourceFactory.java"", ""jetty-ee10/jetty-ee10-webapp/src/main/java/org/eclipse/jetty/ee10/webapp/WebAppContext.java"", ""jetty-ee11/jetty-ee11-webapp/src/main/java/org/eclipse/jetty/ee11/webapp/WebAppContext.java"", ""jetty-ee9/jetty-ee9-webapp/src/main/java/org/eclipse/jetty/ee9/webapp/WebAppContext.java"", ""tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/AbstractJettyHomeTest.java"", ""tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DemoModulesTests.java"", ""tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DeployerTest.java"", ""tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DistributionTests.java""], ""pr_changed_test_files"": [""jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/CoreContextHandlerTest.java"", ""jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/StaticContextHandlerTest.java"", ""tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/AbstractJettyHomeTest.java"", ""tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DemoModulesTests.java"", ""tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DeployerTest.java"", ""tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DistributionTests.java""], ""base_commit"": ""bd44568cc868eb37eb5e6be41536985426b7bb8d"", ""head_commit"": ""f664954434b9389658ebcc5df2d45467de30d0b4"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/13106"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/13106"", ""dockerfile"": """", ""pr_merged_at"": ""2025-05-12T13:02:36.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java\nindex fb8cc7af3e36..43ddeaf69e55 100644\n--- a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java\n+++ b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java\n@@ -684,6 +684,15 @@ public void initializeDefaults(Attributes attributes)\n                 case Deployable.TEMP_DIR -> setTempDirectory(IO.asFile(value));\n                 case Deployable.CONTEXT_PATH -> setContextPath((String)value);\n                 case Deployable.DEFAULT_CONTEXT_PATH -> setDefaultContextPath((String)value);\n+                case Deployable.BASE_RESOURCE ->\n+                {\n+                    if (value == null)\n+                        continue; // skip\n+\n+                    ResourceFactory resourceFactory = ResourceFactory.of(this);\n+                    Resource resource = resourceFactory.asResource(value);\n+                    setBaseResource(resource);\n+                }\n                 default -> initializeDefault(keyName, value);\n             }\n         }\n\ndiff --git a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/CoreContextHandler.java b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/CoreContextHandler.java\nindex 8f35f65992fe..07f2048f9990 100644\n--- a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/CoreContextHandler.java\n+++ b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/CoreContextHandler.java\n@@ -62,7 +62,6 @@ public class CoreContextHandler extends ContextHandler implements Deployable\n {\n     private static final Logger LOG = LoggerFactory.getLogger(CoreContextHandler.class);\n     private static final String ORIGINAL_BASE_RESOURCE = \""org.eclipse.jetty.webapp.originalBaseResource\"";\n-    private static final String[] SUPPORTED_ARCHIVE_EXTENSIONS = new String[]{\""war\"", \""jar\"", \""zip\""};\n     private boolean _initialized = false;\n     private List<Resource> _extraClasspath;\n     private ClassLoader _previousClassLoader;\n@@ -105,7 +104,7 @@ else if (value instanceof Boolean bool)\n             {\n                 // The Base Resource\n                 Path mainPath = (Path)value;\n-                if (FileID.isExtension(mainPath, SUPPORTED_ARCHIVE_EXTENSIONS) || Files.isDirectory(mainPath))\n+                if (Files.isDirectory(mainPath) || FileID.isArchive(mainPath))\n                 {\n                     ResourceFactory resourceFactory = ResourceFactory.of(this);\n                     Resource baseResource = resourceFactory.newResource((Path)value);\n@@ -199,6 +198,35 @@ public ResourceFactory getResourceFactory()\n         return ResourceFactory.of(this);\n     }\n \n+    @Override\n+    public void setBaseResource(Resource baseResource)\n+    {\n+        if (baseResource == null || Resources.isDirectory(baseResource))\n+        {\n+            super.setBaseResource(baseResource);\n+            return;\n+        }\n+\n+        if (Resources.isReadableFile(baseResource))\n+        {\n+            URI uri = baseResource.getURI();\n+            if (FileID.isArchive(uri))\n+            {\n+                // convert to \""jar:file:\"" resource\n+                Resource jarResource = getResourceFactory().newJarFileResource(uri);\n+                super.setBaseResource(jarResource);\n+            }\n+            else\n+            {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\""Ignored base resource: {}\"", baseResource);\n+            }\n+            return;\n+        }\n+\n+        super.setBaseResource(baseResource);\n+    }\n+\n     protected Resource unpack(Resource dir) throws IOException\n     {\n         Path tempDir = getTempDirectory().toPath();\n@@ -266,7 +294,7 @@ protected void initWebApp() throws IOException\n         if (!Resources.isDirectory(baseResource))\n         {\n             // see if we can unpack this reference.\n-            if (FileID.isExtension(baseResource.getURI(), SUPPORTED_ARCHIVE_EXTENSIONS))\n+            if (FileID.isArchive(baseResource.getURI()))\n             {\n                 // We have an archive that needs to be unpacked\n                 setAttribute(ORIGINAL_BASE_RESOURCE, baseResource.getURI());\n\ndiff --git a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/StaticContextHandler.java b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/StaticContextHandler.java\nindex 2d64c27660d8..f6db1ce81e83 100644\n--- a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/StaticContextHandler.java\n+++ b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/StaticContextHandler.java\n@@ -102,37 +102,28 @@ protected void initializeDefault(String keyName, Object value)\n                 else if (value instanceof Boolean bool)\n                     getResourceHandler().setDirAllowed(bool);\n             }\n-            case Deployable.BASE_RESOURCE ->\n-            {\n-                ResourceFactory resourceFactory = ResourceFactory.of(this);\n-                Resource resource = null;\n-                if (value instanceof Path path)\n-                    resource = resourceFactory.newResource(path);\n-                if (value instanceof String str)\n-                    resource = resourceFactory.newResource(str);\n-                if (value instanceof URI uri)\n-                    resource = resourceFactory.newResource(uri);\n-                if (value instanceof Resource res)\n-                    resource = res;\n+        }\n+    }\n \n-                if (resource != null)\n-                {\n-                    if (!Resources.isDirectory(resource))\n-                    {\n-                        URI uri = resource.getURI();\n-                        if (!\""jar\"".equalsIgnoreCase(uri.getScheme()) && FileID.isArchive(uri))\n-                        {\n-                            // open archive as resource, to serve contents.\n-                            setBaseResource(resourceFactory.newJarFileResource(uri));\n-                        }\n-                    }\n-                    else\n-                    {\n-                        // directories are ok\n-                        setBaseResource(resource);\n-                    }\n-                    // anything else isn't a base resource that this class cares about\n-                }\n+    @Override\n+    public void setBaseResource(Resource baseResource)\n+    {\n+        if (baseResource == null || Resources.isDirectory(baseResource))\n+        {\n+            super.setBaseResource(baseResource);\n+        }\n+        else if (Resources.isReadableFile(baseResource))\n+        {\n+            // see if we need to make a passed archive into a zipfs archive.\n+            URI uri = baseResource.getURI();\n+            if (!\""jar\"".equals(uri.getScheme()) && FileID.isArchive(uri))\n+            {\n+                Resource jarResource = ResourceFactory.of(this).newJarFileResource(uri);\n+                super.setBaseResource(jarResource);\n+            }\n+            else\n+            {\n+                super.setBaseResource(baseResource);\n             }\n         }\n     }\n\ndiff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/resource/ResourceFactory.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/resource/ResourceFactory.java\nindex 26c9214f5616..3ce5a0f93908 100644\n--- a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/resource/ResourceFactory.java\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/resource/ResourceFactory.java\n@@ -446,6 +446,36 @@ default Resource newJarFileResource(URI uri)\n         return newResource(URIUtil.toJarFileUri(uri));\n     }\n \n+    /**\n+     * Convert an anonymous Object to a Resource.\n+     *\n+     * <p>\n+     *     The supported types: {@link Path}, {@link String}, {@link URI}, {@link URL}, and {@link Resource}\n+     * </p>\n+     *\n+     * @param obj if the object to convert\n+     * @return the Resource representing the provided obj\n+     * @throws IllegalArgumentException if the object is none of the supported types.\n+     */\n+    default Resource asResource(Object obj)\n+    {\n+        if (obj == null)\n+            return null;\n+\n+        if (obj instanceof Path path)\n+            return newResource(path);\n+        if (obj instanceof String str)\n+            return newResource(str);\n+        if (obj instanceof URI uri)\n+            return newResource(uri);\n+        if (obj instanceof URL url)\n+            return newResource(url);\n+        if (obj instanceof Resource res)\n+            return res;\n+\n+        throw new IllegalArgumentException(\""Cannot convert %s to a Resource\"".formatted(obj.getClass().getName()));\n+    }\n+\n     /**\n      * Split a string of references, that may be split with '{@code ,}', or '{@code ;}', or '{@code |}' into a List of {@link Resource}.\n      * <p>\n\ndiff --git a/jetty-ee10/jetty-ee10-webapp/src/main/java/org/eclipse/jetty/ee10/webapp/WebAppContext.java b/jetty-ee10/jetty-ee10-webapp/src/main/java/org/eclipse/jetty/ee10/webapp/WebAppContext.java\nindex e2defbcdad41..59efc407c8e5 100644\n--- a/jetty-ee10/jetty-ee10-webapp/src/main/java/org/eclipse/jetty/ee10/webapp/WebAppContext.java\n+++ b/jetty-ee10/jetty-ee10-webapp/src/main/java/org/eclipse/jetty/ee10/webapp/WebAppContext.java\n@@ -55,6 +55,7 @@\n import org.eclipse.jetty.server.handler.ContextHandler;\n import org.eclipse.jetty.util.ClassMatcher;\n import org.eclipse.jetty.util.ExceptionUtil;\n+import org.eclipse.jetty.util.FileID;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n@@ -236,6 +237,37 @@ protected void initializeDefault(String keyName, Object value)\n         }\n     }\n \n+    @Override\n+    public void setBaseResource(Resource baseResource)\n+    {\n+        if (baseResource == null || Resources.isDirectory(baseResource))\n+        {\n+            super.setBaseResource(baseResource);\n+            return;\n+        }\n+\n+        // Allow only files that are archives\n+        if (Resources.isReadableFile(baseResource))\n+        {\n+            URI uri = baseResource.getURI();\n+            if (FileID.isArchive(uri))\n+            {\n+                setWarResource(baseResource);\n+                return;\n+            }\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\""Ignoring non-directory Base Resource: {}\"", baseResource);\n+\n+            // clear out old base resource, if it exists\n+            super.setBaseResource(null);\n+            return;\n+        }\n+\n+        // Other resource types are just allowed.\n+        super.setBaseResource(baseResource);\n+    }\n+\n     /**\n      * @param servletContextName The servletContextName to set.\n      */\n\ndiff --git a/jetty-ee11/jetty-ee11-webapp/src/main/java/org/eclipse/jetty/ee11/webapp/WebAppContext.java b/jetty-ee11/jetty-ee11-webapp/src/main/java/org/eclipse/jetty/ee11/webapp/WebAppContext.java\nindex 008f6bd12d86..41e85db00a94 100644\n--- a/jetty-ee11/jetty-ee11-webapp/src/main/java/org/eclipse/jetty/ee11/webapp/WebAppContext.java\n+++ b/jetty-ee11/jetty-ee11-webapp/src/main/java/org/eclipse/jetty/ee11/webapp/WebAppContext.java\n@@ -55,6 +55,7 @@\n import org.eclipse.jetty.server.handler.ContextHandler;\n import org.eclipse.jetty.util.ClassMatcher;\n import org.eclipse.jetty.util.ExceptionUtil;\n+import org.eclipse.jetty.util.FileID;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n@@ -220,6 +221,36 @@ protected void initializeDefault(String keyName, Object value)\n         }\n     }\n \n+    @Override\n+    public void setBaseResource(Resource baseResource)\n+    {\n+        if (baseResource == null || Resources.isDirectory(baseResource))\n+        {\n+            super.setBaseResource(baseResource);\n+            return;\n+        }\n+\n+        if (Resources.isReadableFile(baseResource))\n+        {\n+            URI uri = baseResource.getURI();\n+            if (FileID.isArchive(uri))\n+            {\n+                setWarResource(baseResource);\n+                return;\n+            }\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\""Ignoring non-directory Base Resource: {}\"", baseResource);\n+\n+            // clear out old base resource, if it exists\n+            super.setBaseResource(null);\n+            return;\n+        }\n+\n+        // Other resource types are just allowed.\n+        super.setBaseResource(baseResource);\n+    }\n+\n     /**\n      * @param servletContextName The servletContextName to set.\n      */\n\ndiff --git a/jetty-ee9/jetty-ee9-webapp/src/main/java/org/eclipse/jetty/ee9/webapp/WebAppContext.java b/jetty-ee9/jetty-ee9-webapp/src/main/java/org/eclipse/jetty/ee9/webapp/WebAppContext.java\nindex e8079745c2bc..ed59d4f915d7 100644\n--- a/jetty-ee9/jetty-ee9-webapp/src/main/java/org/eclipse/jetty/ee9/webapp/WebAppContext.java\n+++ b/jetty-ee9/jetty-ee9-webapp/src/main/java/org/eclipse/jetty/ee9/webapp/WebAppContext.java\n@@ -16,6 +16,7 @@\n import java.io.File;\n import java.io.IOException;\n import java.net.MalformedURLException;\n+import java.net.URI;\n import java.net.URL;\n import java.net.URLClassLoader;\n import java.security.PermissionCollection;\n@@ -57,6 +58,7 @@\n import org.eclipse.jetty.server.Server;\n import org.eclipse.jetty.util.Attributes;\n import org.eclipse.jetty.util.ExceptionUtil;\n+import org.eclipse.jetty.util.FileID;\n import org.eclipse.jetty.util.IO;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n@@ -257,6 +259,16 @@ public void initializeDefaults(Attributes attributes)\n                         setWar((String)value);\n                 }\n                 case Deployable.TEMP_DIR -> setTempDirectory(IO.asFile(value));\n+                // copied from core ContextHandler as ee9 doesn't extend from it.\n+                case Deployable.BASE_RESOURCE ->\n+                {\n+                    if (value == null)\n+                        continue; // skip\n+\n+                    ResourceFactory resourceFactory = ResourceFactory.of(this);\n+                    Resource resource = resourceFactory.asResource(value);\n+                    setBaseResource(resource);\n+                }\n                 case Deployable.CONFIGURATION_CLASSES -> setConfigurationClasses((String[])value);\n                 case Deployable.CONTAINER_SCAN_JARS -> setAttribute(MetaInfConfiguration.CONTAINER_JAR_PATTERN, value);\n                 case Deployable.CONTEXT_PATH -> setContextPath((String)value);\n@@ -281,6 +293,37 @@ public void initializeDefaults(Attributes attributes)\n         }\n     }\n \n+    @Override\n+    public void setBaseResource(Resource baseResource)\n+    {\n+        if (baseResource == null || Resources.isDirectory(baseResource))\n+        {\n+            super.setBaseResource(baseResource);\n+            return;\n+        }\n+\n+        // Allow only files that are archives\n+        if (Resources.isReadableFile(baseResource))\n+        {\n+            URI uri = baseResource.getURI();\n+            if (FileID.isArchive(uri))\n+            {\n+                setWarResource(baseResource);\n+                return;\n+            }\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\""Ignoring non-directory Base Resource: {}\"", baseResource);\n+\n+            // clear out old base resource, if it exists\n+            super.setBaseResource(null);\n+            return;\n+        }\n+\n+        // Other resource types are just allowed.\n+        super.setBaseResource(baseResource);\n+    }\n+\n     public boolean isContextPathDefault()\n     {\n         return _defaultContextPath;\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentScannerCoreWebappTest.java b/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/CoreContextHandlerTest.java\nsimilarity index 89%\nrename from jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentScannerCoreWebappTest.java\nrename to jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/CoreContextHandlerTest.java\nindex df4676d19f24..9ad16d023774 100644\n--- a/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentScannerCoreWebappTest.java\n+++ b/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/CoreContextHandlerTest.java\n@@ -58,7 +58,7 @@\n import static org.junit.jupiter.api.Assertions.assertThrows;\n \n @ExtendWith(WorkDirExtension.class)\n-public class DeploymentScannerCoreWebappTest extends AbstractCleanEnvironmentTest\n+public class CoreContextHandlerTest extends AbstractCleanEnvironmentTest\n {\n     public WorkDir workDir;\n     private final Server server = new Server();\n@@ -146,6 +146,61 @@ public void testExampleCoreDir(String dirname) throws Exception\n         assertThat(responseBody, containsString(\""it all looks so easy.\""));\n     }\n \n+    @Test\n+    public void testBaseResourceInXmlPointingOutsideWebappsDir() throws Exception\n+    {\n+        Path root = workDir.getEmptyPathDir();\n+\n+        Path demobase = root.resolve(\""demobase\"");\n+        FS.ensureDirExists(demobase);\n+\n+        Files.writeString(demobase.resolve(\""index.html\""),\n+            \""\""\""\n+                demobase index\n+                \""\""\"");\n+\n+        Path webapps = root.resolve(\""webapps\"");\n+        FS.ensureDirExists(webapps);\n+\n+        Path demoXml = webapps.resolve(\""demo.xml\"");\n+        String demoXmlStr = \""\""\""\n+            <?xml version=\""1.0\""?>\n+            <!DOCTYPE Configure PUBLIC \""-//Jetty//Configure//EN\"" \""https://jetty.org/configure.dtd\"">\n+            <Configure class=\""org.eclipse.jetty.server.handler.CoreContextHandler\"">\n+              <Set name=\""contextPath\"">/demo</Set>\n+              <Set name=\""baseResourceAsPath\"">\n+                <Call class=\""java.nio.file.Path\"" name=\""of\"">\n+                  <Arg>%s</Arg>\n+                </Call>\n+              </Set>\n+              <Set name=\""handler\"">\n+                <New class=\""org.eclipse.jetty.server.handler.ResourceHandler\"" />\n+              </Set>\n+            </Configure>\n+            \""\""\"".formatted(demobase.toString());\n+        Files.writeString(demoXml, demoXmlStr);\n+\n+        server.setHandler(contexts);\n+        ServerConnector connector = new ServerConnector(server);\n+        connector.setPort(0);\n+        server.addConnector(connector);\n+\n+        DeploymentScanner deploymentScanner = new DeploymentScanner(server);\n+        deploymentScanner.addWebappsDirectory(webapps);\n+        server.addBean(deploymentScanner);\n+        DeploymentScanner.EnvironmentConfig coreConfig = deploymentScanner.configureEnvironment(\""core\"");\n+        coreConfig.setContextHandlerClass(CoreContextHandler.class.getName());\n+\n+        server.start();\n+        deploymentScanner.start();\n+\n+        URI destURI = server.getURI().resolve(\""/demo/\"");\n+        HttpURLConnection http = (HttpURLConnection)destURI.toURL().openConnection();\n+        assertThat(http.getResponseCode(), is(200));\n+        String responseBody = IO.toString(http.getInputStream());\n+        assertThat(responseBody, containsString(\""demobase index\""));\n+    }\n+\n     @Test\n     public void testExampleCoreDirWithEnvironmentsProps() throws Exception\n     {\n\ndiff --git a/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/StaticContextHandlerTest.java b/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/StaticContextHandlerTest.java\nindex 15e44e9bc073..42a17ba12d83 100644\n--- a/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/StaticContextHandlerTest.java\n+++ b/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/StaticContextHandlerTest.java\n@@ -13,8 +13,14 @@\n \n package org.eclipse.jetty.deploy;\n \n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n import java.util.function.Consumer;\n \n import org.eclipse.jetty.http.HttpTester;\n@@ -103,6 +109,61 @@ public void testDefaultEmptyDir() throws Exception\n         ));\n     }\n \n+    @Test\n+    public void testStaticDir() throws Exception\n+    {\n+        Path webapps = workDir.getEmptyPathDir().resolve(\""webapps\"");\n+        FS.ensureEmpty(webapps);\n+\n+        Path staticDir = webapps.resolve(\""static\"");\n+        FS.ensureEmpty(staticDir);\n+        Files.writeString(staticDir.resolve(\""hello.txt\""), \""Hello from TEXT\"");\n+\n+        startServer(ds -> ds.addWebappsDirectory(webapps));\n+\n+        String rawResponse = localConnector.getResponse(\""\""\""\n+            GET /static/hello.txt HTTP/1.1\n+            Host: local\n+            Connection: close\n+            \n+            \""\""\"");\n+        HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n+        assertThat(response.getStatus(), is(200));\n+        assertThat(response.getContent(), containsString(\""Hello from TEXT\""));\n+    }\n+\n+    @Test\n+    public void testStaticJar() throws Exception\n+    {\n+        Path webapps = workDir.getEmptyPathDir().resolve(\""webapps\"");\n+        FS.ensureEmpty(webapps);\n+\n+        Path outputJar = webapps.resolve(\""test.jar\"");\n+        Map<String, String> env = new HashMap<>();\n+        env.put(\""create\"", \""true\"");\n+\n+        String testFileContent = \""Hello from TEXT\"";\n+        URI uri = URI.create(\""jar:\"" + outputJar.toUri().toASCIIString());\n+        // Use ZipFS so that we can create paths that are just \""/\""\n+        try (FileSystem zipfs = FileSystems.newFileSystem(uri, env))\n+        {\n+            Path root = zipfs.getPath(\""/\"");\n+            Files.writeString(root.resolve(\""hello.txt\""), testFileContent, StandardOpenOption.CREATE);\n+        }\n+\n+        startServer(ds -> ds.addWebappsDirectory(webapps));\n+\n+        String rawResponse = localConnector.getResponse(\""\""\""\n+            GET /test/hello.txt HTTP/1.1\n+            Host: local\n+            Connection: close\n+            \n+            \""\""\"");\n+        HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n+        assertThat(response.getStatus(), is(200));\n+        assertThat(response.getContent(), containsString(\""Hello from TEXT\""));\n+    }\n+\n     @ParameterizedTest\n     @ValueSource(strings = {\""other\"", \""dnd\""})\n     public void testDefaultToUnknownEnvironment(String unknownEnvName) throws Exception\n@@ -259,6 +320,7 @@ public void testCustomResourceHandlerPropertiesBaseResourceAlt() throws Exceptio\n         Path webapps = root.resolve(\""webapps\"");\n         FS.ensureEmpty(webapps);\n \n+        // Intentionally not in webapps directory\n         Path staticDir = root.resolve(\""static\"");\n         FS.ensureEmpty(staticDir);\n         Files.writeString(webapps.resolve(\""static.properties\""), \""\""\""\n\ndiff --git a/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/AbstractJettyHomeTest.java b/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/AbstractJettyHomeTest.java\nindex 54c72a17c1cb..b1b42d68fdd5 100644\n--- a/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/AbstractJettyHomeTest.java\n+++ b/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/AbstractJettyHomeTest.java\n@@ -14,7 +14,9 @@\n package org.eclipse.jetty.tests.distribution;\n \n import java.nio.file.Path;\n+import java.util.Arrays;\n import java.util.function.Supplier;\n+import java.util.stream.Stream;\n \n import org.eclipse.jetty.client.ContentResponse;\n import org.eclipse.jetty.client.HttpClient;\n@@ -25,6 +27,7 @@\n import org.eclipse.jetty.util.ssl.SslContextFactory;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.provider.Arguments;\n \n @ExtendWith({WorkDirExtension.class})\n public class AbstractJettyHomeTest\n@@ -33,6 +36,12 @@ public class AbstractJettyHomeTest\n \n     public static final int START_TIMEOUT = Integer.getInteger(\""home.start.timeout\"", 30);\n \n+    protected static Stream<Arguments> provideEnvironmentsToTest()\n+    {\n+        String envsToTest = System.getProperty(\""environmentsToTest\"", \""ee8,ee9,ee10,ee11\"");\n+        return Arrays.stream(envsToTest.split(\"",\"")).map(Arguments::of);\n+    }\n+\n     public static String toEnvironment(String module, String environment)\n     {\n         return environment + \""-\"" + module;\n\ndiff --git a/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DemoModulesTests.java b/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DemoModulesTests.java\nindex e9fbde63900a..c198ee709220 100644\n--- a/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DemoModulesTests.java\n+++ b/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DemoModulesTests.java\n@@ -16,7 +16,6 @@\n import java.net.URI;\n import java.nio.file.Files;\n import java.nio.file.Path;\n-import java.util.Arrays;\n import java.util.NoSuchElementException;\n import java.util.concurrent.TimeUnit;\n import java.util.stream.Stream;\n@@ -34,7 +33,6 @@\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n@@ -49,12 +47,6 @@\n @ExtendWith(WorkDirExtension.class)\n public class DemoModulesTests extends AbstractJettyHomeTest\n {\n-    private static Stream<Arguments> provideEnvironmentsToTest()\n-    {\n-        String envsToTest = System.getProperty(\""environmentsToTest\"", \""ee8,ee9,ee10,ee11\"");\n-        return Arrays.stream(envsToTest.split(\"",\"")).map(Arguments::of);\n-    }\n-\n     @ParameterizedTest\n     @MethodSource(\""provideEnvironmentsToTest\"")\n     public void testAuthentication(String env) throws Exception\n\ndiff --git a/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DeployerTest.java b/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DeployerTest.java\nindex 0b976f510c08..a4073012b5f4 100644\n--- a/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DeployerTest.java\n+++ b/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DeployerTest.java\n@@ -34,6 +34,8 @@\n import org.eclipse.jetty.util.Jetty;\n import org.eclipse.jetty.util.URIUtil;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -305,7 +307,62 @@ public void testStaticDeployJar() throws Exception\n \n                 startHttpClient();\n                 ContentResponse response = client.GET(\""http://localhost:\"" + httpPort + \""/test/test.txt\"");\n-                assertThat(response.getStatus(), is(HttpStatus.OK_200));\n+                assertEquals(HttpStatus.OK_200, response.getStatus(), () -> String.join(\""\\n\"", run2.getLogs()));\n+                assertThat(response.getContentAsString(), is(testFileContent));\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""provideEnvironmentsToTest\"")\n+    public void testEEWebAppProperties(String env) throws Exception\n+    {\n+        Path jettyBase = newTestJettyBaseDirectory();\n+        String jettyVersion = System.getProperty(\""jettyVersion\"");\n+        JettyHomeTester distribution = JettyHomeTester.Builder.newInstance()\n+            .jettyVersion(jettyVersion)\n+            .jettyBase(jettyBase)\n+            .build();\n+\n+        String[] argsConfig = {\n+            \""--add-modules=http,\"" + toEnvironment(\""deploy\"", env)\n+        };\n+\n+        try (JettyHomeTester.Run run1 = distribution.start(argsConfig))\n+        {\n+            assertTrue(run1.awaitFor(START_TIMEOUT, TimeUnit.SECONDS));\n+            assertEquals(0, run1.getExitValue());\n+\n+            Path wars = jettyBase.resolve(\""wars\"");\n+            FS.ensureDirExists(wars);\n+            Path outputJar = wars.resolve(\""app.war\"");\n+            Map<String, String> zipfsEnv = new HashMap<>();\n+            zipfsEnv.put(\""create\"", \""true\"");\n+\n+            String testFileContent = \""hello\"";\n+            URI uri = URI.create(\""jar:\"" + outputJar.toUri().toASCIIString());\n+            // Use ZipFS so that we can create paths that are just \""/\""\n+            try (FileSystem zipfs = FileSystems.newFileSystem(uri, zipfsEnv))\n+            {\n+                Path root = zipfs.getPath(\""/\"");\n+                Files.writeString(root.resolve(\""test.txt\""), testFileContent, StandardOpenOption.CREATE);\n+            }\n+\n+            Files.writeString(jettyBase.resolve(\""webapps/test-%s.properties\"".formatted(env)),\n+                \""\""\""\n+                    environment=%s\n+                    jetty.deploy.contextPath=/test\n+                    jetty.deploy.baseResource=%s\n+                    \""\""\"".formatted(env, outputJar.toString()));\n+\n+            int httpPort = Tester.freePort();\n+            try (JettyHomeTester.Run run2 = distribution.start(\""jetty.http.port=\"" + httpPort))\n+            {\n+                assertTrue(run2.awaitConsoleLogsFor(\""Started oejs.Server@\"", START_TIMEOUT, TimeUnit.SECONDS));\n+\n+                startHttpClient();\n+                ContentResponse response = client.GET(\""http://localhost:\"" + httpPort + \""/test/test.txt\"");\n+                assertEquals(HttpStatus.OK_200, response.getStatus(), () -> String.join(\""\\n\"", run2.getLogs()));\n                 assertThat(response.getContentAsString(), is(testFileContent));\n             }\n         }\n\ndiff --git a/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DistributionTests.java b/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DistributionTests.java\nindex 719cb8e2d172..bbf2ed21803b 100644\n--- a/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DistributionTests.java\n+++ b/tests/test-distribution/test-distribution-common/src/test/java/org/eclipse/jetty/tests/distribution/DistributionTests.java\n@@ -1493,11 +1493,11 @@ public void testEEFastCGIProxying(String env) throws Exception\n             // Deploy a Jetty context XML file that is only necessary for the test,\n             // as it simulates, for example, what the php-fpm server would return.\n             Path jettyBaseWork = jettyBase.resolve(\""work\"");\n-            Path phpXML = jettyBase.resolve(\""webapps\"").resolve(\""php.xml\"");\n+            Path phpXML = jettyBase.resolve(\""webapps/php.xml\"");\n             Files.writeString(phpXML, \""\""\""\n                 <?xml version=\""1.0\""?>\n                 <!DOCTYPE Configure PUBLIC \""-//Jetty//Configure//EN\"" \""https://jetty.org/configure_10_0.dtd\"">\n-                <Configure class=\""org.eclipse.jetty.server.handler.ContextHandler\"">\n+                <Configure class=\""org.eclipse.jetty.server.handler.CoreContextHandler\"">\n                   <Set name=\""contextPath\"">/php</Set>\n                   <Set name=\""baseResourceAsPath\"">\n                     <Call class=\""java.nio.file.Path\"" name=\""of\"">\n@@ -1509,6 +1509,10 @@ public void testEEFastCGIProxying(String env) throws Exception\n                   </Set>\n                 </Configure>\n                 \""\""\"".replace(\""$R\"", jettyBaseWork.toAbsolutePath().toString()), StandardOpenOption.CREATE);\n+            Files.writeString(jettyBase.resolve(\""webapps/php.properties\""),\n+                \""\""\""\n+                    environment=core\n+                    \""\""\"");\n             // Save a file in $JETTY_BASE/work so that it can be requested.\n             String testFileContent = \""hello\"";\n             Files.writeString(jettyBaseWork.resolve(\""test.txt\""), testFileContent, StandardOpenOption.CREATE);\n@@ -1537,7 +1541,8 @@ public void testEEFastCGIProxying(String env) throws Exception\n                 \""\""\"".replace(\""$ENV\"", env).replace(\""$P\"", String.valueOf(fcgiPort)), StandardOpenOption.CREATE);\n \n             Path proxyProps = jettyBase.resolve(\""webapps\"").resolve(\""proxy.properties\"");\n-            Files.writeString(proxyProps, \""\""\""\n+            Files.writeString(proxyProps,\n+                \""\""\""\n                 environment=$ENV\n                 \""\""\"".replace(\""$ENV\"", env), StandardOpenOption.CREATE);\n \n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-13060"", ""pr_id"": 13060, ""issue_id"": 13013, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Rework websocket `FrameFlusher`'s expiration\n**Jetty version(s)**\n12.0.x, 12.1.x\n\n**Enhancement Description**\nCurrently, the way `FrameFlusher`'s expiration somewhat duplicates the logic of `CyclicTimeouts` with some extra caveats: it uses `currentTimeMillis()` instead of `nanoTime()` and a possibly too lenient locking.\n\nThis should be revised.\n\nSee https://github.com/jetty/jetty.project/pull/12987\n"", ""issue_word_count"": 57, ""test_files_count"": 2, ""non_test_files_count"": 6, ""pr_changed_files"": [""jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/CyclicTimeouts.java"", ""jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/Configuration.java"", ""jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketConnection.java"", ""jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketConstants.java"", ""jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketCoreSession.java"", ""jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/internal/FrameFlusher.java"", ""jetty-core/jetty-websocket/jetty-websocket-core-tests/src/test/java/org/eclipse/jetty/websocket/core/internal/FrameFlusherTest.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/client/WriteTimeoutTest.java""], ""pr_changed_test_files"": [""jetty-core/jetty-websocket/jetty-websocket-core-tests/src/test/java/org/eclipse/jetty/websocket/core/internal/FrameFlusherTest.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/client/WriteTimeoutTest.java""], ""base_commit"": ""397b467c500f2a6488aefe03a745ab38209e1133"", ""head_commit"": ""46acd6a4a99ff1f49aba7e988dde7c3b1889e836"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/13060"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/13060"", ""dockerfile"": """", ""pr_merged_at"": ""2025-05-28T21:51:52.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/CyclicTimeouts.java b/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/CyclicTimeouts.java\nindex 1905a8d76405..b364c440e284 100644\n--- a/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/CyclicTimeouts.java\n+++ b/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/CyclicTimeouts.java\n@@ -75,7 +75,7 @@ public CyclicTimeouts(Scheduler scheduler)\n      */\n     protected abstract boolean onExpired(T expirable);\n \n-    private void onTimeoutExpired()\n+    protected void iterate()\n     {\n         if (LOG.isDebugEnabled())\n             LOG.debug(\""Timeouts check for {}\"", this);\n@@ -203,7 +203,7 @@ private Timeouts(Scheduler scheduler)\n         @Override\n         public void onTimeoutExpired()\n         {\n-            CyclicTimeouts.this.onTimeoutExpired();\n+            CyclicTimeouts.this.iterate();\n         }\n     }\n }\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/Configuration.java b/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/Configuration.java\nindex 8ccd49c30a35..f54864e68ebc 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/Configuration.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/Configuration.java\n@@ -28,7 +28,9 @@ public interface Configuration\n      * Get the Write Timeout\n      *\n      * @return the write timeout\n+     * @deprecated no replacement, applications should not call this method.\n      */\n+    @Deprecated(since = \""12.0.21\"", forRemoval = true)\n     Duration getWriteTimeout();\n \n     /**\n@@ -39,10 +41,12 @@ public interface Configuration\n     void setIdleTimeout(Duration timeout);\n \n     /**\n-     * Set the Write Timeout.\n+     * Set the Frame Write Timeout.\n      *\n      * @param timeout the timeout duration (timeout &lt;= 0 implies an infinite timeout)\n+     * @deprecated no replacement, applications should not call this method.\n      */\n+    @Deprecated(since = \""12.0.21\"", forRemoval = true)\n     void setWriteTimeout(Duration timeout);\n \n     boolean isAutoFragment();\n@@ -99,7 +103,7 @@ interface Customizer\n     class ConfigurationCustomizer implements Configuration, Customizer\n     {\n         private Duration idleTimeout;\n-        private Duration writeTimeout;\n+        private Duration frameTimeout;\n         private Boolean autoFragment;\n         private Long maxFrameSize;\n         private Integer outputBufferSize;\n@@ -117,7 +121,7 @@ public Duration getIdleTimeout()\n         @Override\n         public Duration getWriteTimeout()\n         {\n-            return writeTimeout == null ? WebSocketConstants.DEFAULT_WRITE_TIMEOUT : writeTimeout;\n+            return frameTimeout == null ? WebSocketConstants.DEFAULT_WRITE_TIMEOUT : frameTimeout;\n         }\n \n         @Override\n@@ -129,7 +133,7 @@ public void setIdleTimeout(Duration timeout)\n         @Override\n         public void setWriteTimeout(Duration timeout)\n         {\n-            this.writeTimeout = timeout;\n+            this.frameTimeout = timeout;\n         }\n \n         @Override\n@@ -221,8 +225,8 @@ public void customize(Configuration configurable)\n         {\n             if (idleTimeout != null)\n                 configurable.setIdleTimeout(idleTimeout);\n-            if (writeTimeout != null)\n-                configurable.setWriteTimeout(writeTimeout);\n+            if (frameTimeout != null)\n+                configurable.setWriteTimeout(frameTimeout);\n             if (autoFragment != null)\n                 configurable.setAutoFragment(autoFragment);\n             if (maxFrameSize != null)\n@@ -242,10 +246,10 @@ public void customize(Configuration configurable)\n         @Override\n         public String toString()\n         {\n-            return String.format(\""%s@%x{idleTimeout=%s, writeTimeout=%s, autoFragment=%s, maxFrameSize=%s, \"" +\n+            return String.format(\""%s@%x{idleTimeout=%s, frameWriteTimeout=%s, autoFragment=%s, maxFrameSize=%s, \"" +\n                     \""inputBufferSize=%s, outputBufferSize=%s, maxBinaryMessageSize=%s, maxTextMessageSize=%s, maxOutgoingFrames=%s}\"",\n                 getClass().getSimpleName(), hashCode(),\n-                idleTimeout, writeTimeout, autoFragment, maxFrameSize, inputBufferSize, outputBufferSize,\n+                idleTimeout, frameTimeout, autoFragment, maxFrameSize, inputBufferSize, outputBufferSize,\n                 maxBinaryMessageSize, maxTextMessageSize, maxOutgoingFrames);\n         }\n     }\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketConnection.java b/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketConnection.java\nindex ddf6dc9d49bf..80459b3b9d43 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketConnection.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketConnection.java\n@@ -179,9 +179,10 @@ public boolean isUseInputDirectByteBuffers()\n         return useInputDirectByteBuffers;\n     }\n \n+    @Deprecated(since = \""12.0.21\"", forRemoval = true)\n     public void setWriteTimeout(long writeTimeout)\n     {\n-        flusher.setIdleTimeout(writeTimeout);\n+        flusher.setFrameWriteTimeout(writeTimeout);\n     }\n \n     public void setUseInputDirectByteBuffers(boolean useInputDirectByteBuffers)\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketConstants.java b/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketConstants.java\nindex d8c8d2b9de1e..ce4ef0fe5fda 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketConstants.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketConstants.java\n@@ -65,6 +65,7 @@ public final class WebSocketConstants\n     /**\n      * The default maximum time a frame may be waiting to be sent.\n      */\n+    @Deprecated(since = \""12.0.21\"", forRemoval = true)\n     public static final Duration DEFAULT_WRITE_TIMEOUT = Duration.ZERO;\n \n     // Attributes for storing API requests as attributes on the base jetty-core request.\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketCoreSession.java b/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketCoreSession.java\nindex e328e018bb0d..6bb2df611b70 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketCoreSession.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/WebSocketCoreSession.java\n@@ -22,6 +22,7 @@\n import java.time.Duration;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.concurrent.Executor;\n import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicInteger;\n@@ -69,7 +70,7 @@ public class WebSocketCoreSession implements CoreSession, Dumpable\n     private long maxBinaryMessageSize = WebSocketConstants.DEFAULT_MAX_BINARY_MESSAGE_SIZE;\n     private long maxTextMessageSize = WebSocketConstants.DEFAULT_MAX_TEXT_MESSAGE_SIZE;\n     private Duration idleTimeout = WebSocketConstants.DEFAULT_IDLE_TIMEOUT;\n-    private Duration writeTimeout = WebSocketConstants.DEFAULT_WRITE_TIMEOUT;\n+    private Duration frameWriteTimeout = WebSocketConstants.DEFAULT_WRITE_TIMEOUT;\n     private ClassLoader classLoader;\n \n     public WebSocketCoreSession(FrameHandler handler, Behavior behavior, Negotiated negotiated, WebSocketComponents components)\n@@ -144,15 +145,16 @@ public void setIdleTimeout(Duration timeout)\n     @Override\n     public Duration getWriteTimeout()\n     {\n-        return writeTimeout;\n+        return frameWriteTimeout;\n     }\n \n     @Override\n     public void setWriteTimeout(Duration timeout)\n     {\n-        writeTimeout = timeout;\n-        if (getConnection() != null)\n-            getConnection().setWriteTimeout(timeout.toMillis());\n+        frameWriteTimeout = Objects.requireNonNull(timeout);\n+        WebSocketConnection connection = getConnection();\n+        if (connection != null)\n+            connection.setWriteTimeout(timeout.toMillis());\n     }\n \n     public SocketAddress getLocalAddress()\n@@ -189,7 +191,7 @@ public boolean isClosed()\n     public void setWebSocketConnection(WebSocketConnection connection)\n     {\n         connection.getEndPoint().setIdleTimeout(idleTimeout.toMillis());\n-        connection.setWriteTimeout(writeTimeout.toMillis());\n+        connection.setWriteTimeout(frameWriteTimeout.toMillis());\n         extensionStack.setLastDemand(connection::demand);\n         this.connection = connection;\n     }\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/internal/FrameFlusher.java b/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/internal/FrameFlusher.java\nindex b09e619cea54..76b9ffcf111a 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/internal/FrameFlusher.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/internal/FrameFlusher.java\n@@ -25,13 +25,13 @@\n import java.util.concurrent.atomic.LongAdder;\n \n import org.eclipse.jetty.io.ByteBufferPool;\n-import org.eclipse.jetty.io.CyclicTimeout;\n+import org.eclipse.jetty.io.CyclicTimeouts;\n import org.eclipse.jetty.io.EndPoint;\n import org.eclipse.jetty.io.RetainableByteBuffer;\n import org.eclipse.jetty.util.BufferUtil;\n import org.eclipse.jetty.util.Callback;\n import org.eclipse.jetty.util.IteratingCallback;\n-import org.eclipse.jetty.util.StaticException;\n+import org.eclipse.jetty.util.NanoTime;\n import org.eclipse.jetty.util.TypeUtil;\n import org.eclipse.jetty.util.thread.AutoLock;\n import org.eclipse.jetty.util.thread.Scheduler;\n@@ -55,60 +55,77 @@ public boolean isControlFrame()\n     };\n \n     private static final Logger LOG = LoggerFactory.getLogger(FrameFlusher.class);\n-    private static final Throwable CLOSED_CHANNEL = new StaticException(\""Closed\"");\n-\n-    private final AutoLock lock = new AutoLock();\n-    private final LongAdder messagesOut = new LongAdder();\n-    private final LongAdder bytesOut = new LongAdder();\n-    private final ByteBufferPool bufferPool;\n-    private final EndPoint endPoint;\n-    private final int bufferSize;\n-    private final Generator generator;\n-    private final int maxGather;\n-    private final Deque<Entry> queue = new ArrayDeque<>();\n-    private final List<ByteBuffer> buffers;\n-    private final CyclicTimeout cyclicTimeout;\n-    private final List<Entry> entries;\n-    private final List<Entry> previousEntries;\n-    private final List<Entry> failedEntries;\n-\n-    private List<RetainableByteBuffer> releasableBuffers = new ArrayList<>();\n-    private RetainableByteBuffer batchBuffer;\n-    private boolean canEnqueue = true;\n-    private boolean flushed = true;\n-    private Throwable closedCause;\n-    private long idleTimeout;\n-    private boolean useDirectByteBuffers;\n+\n+    private final AutoLock _lock = new AutoLock();\n+    private final LongAdder _messagesOut = new LongAdder();\n+    private final LongAdder _bytesOut = new LongAdder();\n+    private final ByteBufferPool _bufferPool;\n+    private final EndPoint _endPoint;\n+    private final int _bufferSize;\n+    private final Generator _generator;\n+    private final int _maxGather;\n+    private final CyclicTimeouts<Entry> _cyclicTimeouts;\n+    private final Deque<Entry> _queue = new ArrayDeque<>();\n+    private final List<Entry> _currentEntries;\n+    private final List<Entry> _completedEntries = new ArrayList<>();\n+    private final List<RetainableByteBuffer> _releasableBuffers = new ArrayList<>();\n+\n+    private RetainableByteBuffer _batchBuffer;\n+    private boolean _canEnqueue = true;\n+    private Throwable _closedCause;\n+    private long _frameTimeout;\n+    private boolean _useDirectByteBuffers;\n \n     public FrameFlusher(ByteBufferPool bufferPool, Scheduler scheduler, Generator generator, EndPoint endPoint, int bufferSize, int maxGather)\n     {\n-        this.bufferPool = bufferPool;\n-        this.endPoint = endPoint;\n-        this.bufferSize = bufferSize;\n-        this.generator = Objects.requireNonNull(generator);\n-        this.maxGather = maxGather;\n-        this.entries = new ArrayList<>(maxGather);\n-        this.previousEntries = new ArrayList<>(maxGather);\n-        this.failedEntries = new ArrayList<>(maxGather);\n-        this.buffers = new ArrayList<>((maxGather * 2) + 1);\n-        this.cyclicTimeout = new CyclicTimeout(scheduler)\n+        _bufferPool = bufferPool;\n+        _endPoint = endPoint;\n+        _bufferSize = bufferSize;\n+        _generator = Objects.requireNonNull(generator);\n+        _maxGather = maxGather;\n+        _currentEntries = new ArrayList<>(maxGather);\n+        _cyclicTimeouts = new CyclicTimeouts<>(scheduler)\n         {\n+            private boolean _expired = false;\n+\n             @Override\n-            public void onTimeoutExpired()\n+            protected boolean onExpired(Entry expirable)\n             {\n-                timeoutExpired();\n+                // This is called with lock held so we delay the abort until we exit the lock in iterate().\n+                _expired = true;\n+                return false;\n+            }\n+\n+            @Override\n+            protected Iterator<Entry> iterator()\n+            {\n+                return TypeUtil.concat(_currentEntries.iterator(), _queue.iterator());\n+            }\n+\n+            @Override\n+            protected void iterate()\n+            {\n+                // We need to acquire the lock before we can iterate over the queue and entries.\n+                try (AutoLock l = _lock.lock())\n+                {\n+                    super.iterate();\n+                }\n+\n+                // Abort the flusher if any entries have timed out.\n+                if (_expired)\n+                    abort(new WebSocketWriteTimeoutException(\""FrameFlusher Frame Write Timeout\""));\n             }\n         };\n     }\n \n     public boolean isUseDirectByteBuffers()\n     {\n-        return useDirectByteBuffers;\n+        return _useDirectByteBuffers;\n     }\n \n     public void setUseDirectByteBuffers(boolean useDirectByteBuffers)\n     {\n-        this.useDirectByteBuffers = useDirectByteBuffers;\n+        this._useDirectByteBuffers = useDirectByteBuffers;\n     }\n \n     /**\n@@ -125,52 +142,55 @@ public boolean enqueue(Frame frame, Callback callback, boolean batch)\n         Entry entry = new Entry(frame, callback, batch);\n         byte opCode = frame.getOpCode();\n \n-        Throwable dead;\n+        Throwable error = null;\n+        boolean abort = false;\n         List<Entry> failedEntries = null;\n         CloseStatus closeStatus = null;\n \n-        try (AutoLock l = lock.lock())\n+        try (AutoLock l = _lock.lock())\n         {\n-            if (canEnqueue)\n+            if (!_canEnqueue || _closedCause != null)\n             {\n-                dead = closedCause;\n-                if (dead == null)\n-                {\n-                    switch (opCode)\n-                    {\n-                        case OpCode.CLOSE:\n-                            closeStatus = CloseStatus.getCloseStatus(frame);\n-                            if (closeStatus.isAbnormal())\n-                            {\n-                                //fail all existing entries in the queue, and enqueue the error close\n-                                failedEntries = new ArrayList<>(queue);\n-                                queue.clear();\n-                            }\n-                            queue.offerLast(entry);\n-                            this.canEnqueue = false;\n-                            break;\n-\n-                        case OpCode.PING:\n-                        case OpCode.PONG:\n-                            queue.offerFirst(entry);\n-                            break;\n-\n-                        default:\n-                            queue.offerLast(entry);\n-                            break;\n-                    }\n-\n-                    /* If the queue was empty then no timeout has been set, so we set a timeout to check the current\n-                    entry when it expires. When the timeout expires we will go over entries in the queue and\n-                    entries list to see if any of them have expired, it will then reset the timeout for the frame\n-                    with the soonest expiry time. */\n-                    if ((idleTimeout > 0) && (queue.size() == 1) && entries.isEmpty())\n-                        cyclicTimeout.schedule(idleTimeout, TimeUnit.MILLISECONDS);\n-                }\n+                error = (_closedCause == null) ? new ClosedChannelException() : _closedCause;\n             }\n             else\n             {\n-                dead = new ClosedChannelException();\n+                switch (opCode)\n+                {\n+                    case OpCode.CLOSE:\n+                        closeStatus = CloseStatus.getCloseStatus(frame);\n+                        if (closeStatus.isAbnormal())\n+                        {\n+                            //fail all existing entries in the queue, and enqueue the error close\n+                            failedEntries = new ArrayList<>(_queue);\n+                            _queue.clear();\n+                        }\n+                        _queue.offerLast(entry);\n+                        this._canEnqueue = false;\n+                        break;\n+\n+                    case OpCode.PING:\n+                    case OpCode.PONG:\n+                        _queue.offerFirst(entry);\n+                        break;\n+\n+                    default:\n+                        if (entry.isExpired())\n+                        {\n+                            // For DATA frames there is a possibility that the message timeout has already expired in the\n+                            // case of a partial message. In this case do not even add it to the queue and abort the connection.\n+                            error = new WebSocketWriteTimeoutException(\""FrameFlusher Frame Write Timeout\"");\n+                            abort = true;\n+                        }\n+                        else\n+                        {\n+                            _queue.offerLast(entry);\n+                        }\n+                        break;\n+                }\n+\n+                if (!abort)\n+                    _cyclicTimeouts.schedule(entry);\n             }\n         }\n \n@@ -187,25 +207,26 @@ public boolean enqueue(Frame frame, Callback callback, boolean batch)\n             }\n         }\n \n-        if (dead == null)\n+        if (error != null)\n         {\n-            if (LOG.isDebugEnabled())\n-                LOG.debug(\""Enqueued {} to {}\"", entry, this);\n-\n-            return true;\n+            notifyCallbackFailure(callback, error);\n+            if (abort)\n+                abort(error);\n+            return false;\n         }\n \n-        notifyCallbackFailure(callback, dead);\n-        return false;\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\""Enqueued {} to {}\"", entry, this);\n+        return true;\n     }\n \n     public void onClose(Throwable cause)\n     {\n-        try (AutoLock l = lock.lock())\n+        try (AutoLock l = _lock.lock())\n         {\n-            closedCause = cause == null ? CLOSED_CHANNEL : cause;\n+            _closedCause = cause == null ? new ClosedChannelException() : cause;\n         }\n-        iterate();\n+        abort(_closedCause);\n     }\n \n     @Override\n@@ -215,120 +236,104 @@ protected Action process() throws Throwable\n             LOG.debug(\""Flushing {}\"", this);\n \n         boolean flush = false;\n-        Callback releasingCallback = this;\n-        try (AutoLock l = lock.lock())\n+        try (AutoLock l = _lock.lock())\n         {\n-            if (closedCause != null)\n-                throw closedCause;\n-\n-            // Remember entries to succeed from previous process\n-            previousEntries.addAll(entries);\n-            entries.clear();\n+            if (_closedCause != null)\n+                throw _closedCause;\n \n-            if (flushed && batchBuffer != null)\n-                batchBuffer.clear();\n-\n-            while (!queue.isEmpty() && entries.size() <= maxGather)\n+            while (!_queue.isEmpty() && _currentEntries.size() <= _maxGather)\n             {\n-                Entry entry = queue.poll();\n-                entries.add(entry);\n+                Entry entry = _queue.poll();\n+                _currentEntries.add(entry);\n                 if (entry.frame == FLUSH_FRAME)\n                 {\n                     flush = true;\n                     break;\n                 }\n+            }\n+        }\n \n-                messagesOut.increment();\n-\n-                int batchSpace = batchBuffer == null ? bufferSize : BufferUtil.space(batchBuffer.getByteBuffer());\n+        // Process the entries outside the lock, as inside the ICB we only need the lock to modify _entries but not iterate it.\n+        boolean canBatch = true;\n+        List<ByteBuffer> buffers = new ArrayList<>((_maxGather * 2) + 1);\n+        if (_batchBuffer != null)\n+            buffers.add(_batchBuffer.getByteBuffer());\n+        for (Entry entry : _currentEntries)\n+        {\n+            if (entry.frame == FLUSH_FRAME)\n+                continue;\n+            _messagesOut.increment();\n \n-                boolean batch = entry.batch &&\n-                    !entry.frame.isControlFrame() &&\n-                    entry.frame.getPayloadLength() < bufferSize / 4 &&\n-                    (batchSpace - Generator.MAX_HEADER_LENGTH) >= entry.frame.getPayloadLength();\n+            int batchSpace = _batchBuffer == null ? _bufferSize : BufferUtil.space(_batchBuffer.getByteBuffer());\n+            boolean batch = canBatch && entry.batch &&\n+                !entry.frame.isControlFrame() &&\n+                entry.frame.getPayloadLength() < _bufferSize / 4 &&\n+                (batchSpace - Generator.MAX_HEADER_LENGTH) >= entry.frame.getPayloadLength();\n \n-                if (batch)\n+            if (batch)\n+            {\n+                // Acquire a batchBuffer if we don't have one.\n+                if (_batchBuffer == null)\n                 {\n-                    // Acquire a batchBuffer if we don't have one.\n-                    if (batchBuffer == null)\n-                    {\n-                        batchBuffer = acquireBuffer(bufferSize);\n-                        buffers.add(batchBuffer.getByteBuffer());\n-                    }\n+                    _batchBuffer = acquireBuffer(_bufferSize);\n+                    buffers.add(_batchBuffer.getByteBuffer());\n+                }\n \n-                    // Generate the frame into the batchBuffer.\n-                    generator.generateWholeFrame(entry.frame, batchBuffer.getByteBuffer());\n+                // Generate the frame into the batchBuffer.\n+                _generator.generateWholeFrame(entry.frame, _batchBuffer.getByteBuffer());\n+            }\n+            else\n+            {\n+                if (canBatch && _batchBuffer != null && batchSpace >= Generator.MAX_HEADER_LENGTH)\n+                {\n+                    // Use the batch space for our header.\n+                    _generator.generateHeader(entry.frame, _batchBuffer.getByteBuffer());\n                 }\n                 else\n                 {\n-                    if (batchBuffer != null && batchSpace >= Generator.MAX_HEADER_LENGTH)\n-                    {\n-                        // Use the batch space for our header.\n-                        generator.generateHeader(entry.frame, batchBuffer.getByteBuffer());\n-                    }\n-                    else\n-                    {\n-                        // Add headers to the list of buffers.\n-                        RetainableByteBuffer headerBuffer = acquireBuffer(Generator.MAX_HEADER_LENGTH);\n-                        releasableBuffers.add(headerBuffer);\n-                        generator.generateHeader(entry.frame, headerBuffer.getByteBuffer());\n-                        buffers.add(headerBuffer.getByteBuffer());\n-                    }\n+                    // Add headers to the list of buffers.\n+                    RetainableByteBuffer headerBuffer = acquireBuffer(Generator.MAX_HEADER_LENGTH);\n+                    _releasableBuffers.add(headerBuffer);\n+                    _generator.generateHeader(entry.frame, headerBuffer.getByteBuffer());\n+                    buffers.add(headerBuffer.getByteBuffer());\n+                }\n \n-                    // Add the payload to the list of buffers.\n-                    ByteBuffer payload = entry.frame.getPayload();\n-                    if (BufferUtil.hasContent(payload))\n+                // Add the payload to the list of buffers.\n+                ByteBuffer payload = entry.frame.getPayload();\n+                if (BufferUtil.hasContent(payload))\n+                {\n+                    if (entry.frame.isMasked())\n                     {\n-                        if (entry.frame.isMasked())\n-                        {\n-                            RetainableByteBuffer masked = acquireBuffer(entry.frame.getPayloadLength());\n-                            payload = masked.getByteBuffer();\n-                            releasableBuffers.add(masked);\n-                            generator.generatePayload(entry.frame, payload);\n-                        }\n-                        buffers.add(payload.slice());\n+                        RetainableByteBuffer masked = acquireBuffer(entry.frame.getPayloadLength());\n+                        payload = masked.getByteBuffer();\n+                        _releasableBuffers.add(masked);\n+                        _generator.generatePayload(entry.frame, payload);\n                     }\n-                    flush = true;\n+                    buffers.add(payload.slice());\n                 }\n \n-                flushed = flush;\n-            }\n-\n-            // If we are going to flush we should release any buffers we have allocated after the callback completes.\n-            if (flush)\n-            {\n-                List<RetainableByteBuffer> callbackBuffers = releasableBuffers;\n-                releasableBuffers = new ArrayList<>();\n-                releasingCallback = Callback.from(releasingCallback, () -> callbackBuffers.forEach(RetainableByteBuffer::release));\n+                // Once we have added another buffer we cannot add to the batch buffer again.\n+                canBatch = false;\n+                flush = true;\n             }\n         }\n \n         if (LOG.isDebugEnabled())\n-            LOG.debug(\""{} processed {} entries flush={} batch={}: {}\"",\n+            LOG.debug(\""{} processed {} entries flush={}: {}\"",\n                 this,\n-                entries.size(),\n+                _currentEntries.size(),\n                 flush,\n-                batchBuffer,\n-                entries);\n-\n-        // succeed previous entries\n-        for (Entry entry : previousEntries)\n-        {\n-            if (entry.frame.getOpCode() == OpCode.CLOSE)\n-                endPoint.shutdownOutput();\n-            notifyCallbackSuccess(entry.callback);\n-        }\n-        previousEntries.clear();\n-\n-        // If we did not get any new entries go to IDLE state\n-        if (entries.isEmpty())\n-        {\n-            releaseAggregate();\n-            return Action.IDLE;\n-        }\n+                _currentEntries);\n \n         if (flush)\n         {\n+            // If we're flushing we should release the batch buffer upon completion.\n+            if (_batchBuffer != null)\n+            {\n+                _releasableBuffers.add(_batchBuffer);\n+                _batchBuffer = null;\n+            }\n+\n             int i = 0;\n             int bytes = 0;\n             ByteBuffer[] bufferArray = new ByteBuffer[buffers.size()];\n@@ -337,12 +342,19 @@ protected Action process() throws Throwable\n                 bytes += bb.limit() - bb.position();\n                 bufferArray[i++] = bb;\n             }\n-            bytesOut.add(bytes);\n-            endPoint.write(releasingCallback, bufferArray);\n+            _bytesOut.add(bytes);\n+            _endPoint.write(this, bufferArray);\n             buffers.clear();\n         }\n         else\n         {\n+            // If we did not get any new entries go to IDLE state\n+            if (_currentEntries.isEmpty())\n+            {\n+                releaseAggregateIfEmpty();\n+                return Action.IDLE;\n+            }\n+\n             // We just aggregated the entries, so we need to succeed their callbacks.\n             succeeded();\n         }\n@@ -352,104 +364,80 @@ protected Action process() throws Throwable\n \n     private RetainableByteBuffer acquireBuffer(int capacity)\n     {\n-        return bufferPool.acquire(capacity, isUseDirectByteBuffers());\n+        return _bufferPool.acquire(capacity, isUseDirectByteBuffers());\n     }\n \n     private int getQueueSize()\n     {\n-        try (AutoLock l = lock.lock())\n+        try (AutoLock l = _lock.lock())\n         {\n-            return queue.size();\n+            return _queue.size();\n         }\n     }\n \n-    private void timeoutExpired()\n+    @Override\n+    protected void onSuccess()\n     {\n-        boolean failed = false;\n-        try (AutoLock l = lock.lock())\n+        try (AutoLock l = _lock.lock())\n         {\n-            if (closedCause != null)\n-                return;\n-\n-            long currentTime = System.currentTimeMillis();\n-            long expiredIfCreatedBefore = currentTime - idleTimeout;\n-            long earliestEntry = currentTime;\n-\n-            /* Iterate through entries in both the queue and entries list.\n-            If any entry has expired then we fail the FrameFlusher.\n-            Otherwise we will try to schedule a new timeout. */\n-            Iterator<Entry> iterator = TypeUtil.concat(entries.iterator(), queue.iterator());\n-            while (iterator.hasNext())\n-            {\n-                Entry entry = iterator.next();\n-\n-                if (entry.getTimeOfCreation() <= expiredIfCreatedBefore)\n-                {\n-                    LOG.warn(\""FrameFlusher write timeout on entry: {}\"", entry);\n-                    failed = true;\n-                    canEnqueue = false;\n-                    closedCause = new WebSocketWriteTimeoutException(\""FrameFlusher Write Timeout\"");\n-                    failedEntries.addAll(entries);\n-                    failedEntries.addAll(queue);\n-                    entries.clear();\n-                    queue.clear();\n-                    break;\n-                }\n-\n-                if (entry.getTimeOfCreation() < earliestEntry)\n-                    earliestEntry = entry.getTimeOfCreation();\n-            }\n+            assert _completedEntries.isEmpty();\n+            _completedEntries.addAll(_currentEntries);\n+            _currentEntries.clear();\n+        }\n \n-            // if a timeout is set schedule a new timeout if we haven't failed and still have entries\n-            if (!failed && idleTimeout > 0 && !(entries.isEmpty() && queue.isEmpty()))\n-            {\n-                long nextTimeout = earliestEntry + idleTimeout - currentTime;\n-                cyclicTimeout.schedule(nextTimeout, TimeUnit.MILLISECONDS);\n-            }\n+        for (Entry entry : _completedEntries)\n+        {\n+            if (entry.frame.getOpCode() == OpCode.CLOSE)\n+                _endPoint.shutdownOutput();\n+            notifyCallbackSuccess(entry.callback);\n         }\n+        _completedEntries.clear();\n \n-        if (failed)\n-            this.iterate();\n+        _releasableBuffers.forEach(RetainableByteBuffer::release);\n+        _releasableBuffers.clear();\n+        super.onSuccess();\n     }\n \n     @Override\n     public void onCompleteFailure(Throwable failure)\n     {\n-        if (batchBuffer != null)\n-            batchBuffer.clear();\n-        releaseAggregate();\n-        try (AutoLock l = lock.lock())\n+        if (_batchBuffer != null)\n+            _batchBuffer.clear();\n+        releaseAggregateIfEmpty();\n+        try (AutoLock l = _lock.lock())\n         {\n-            failedEntries.addAll(queue);\n-            queue.clear();\n-\n-            failedEntries.addAll(entries);\n-            entries.clear();\n-\n-            releasableBuffers.forEach(RetainableByteBuffer::release);\n-            releasableBuffers.clear();\n-\n-            if (closedCause == null)\n-                closedCause = failure;\n-            else if (closedCause != failure)\n-                closedCause.addSuppressed(failure);\n+            // Ensure no more entries can be enqueued.\n+            _canEnqueue = false;\n+            if (_closedCause == null)\n+                _closedCause = failure;\n+            else if (_closedCause != failure)\n+                _closedCause.addSuppressed(failure);\n+\n+            assert _completedEntries.isEmpty();\n+            _completedEntries.addAll(_queue);\n+            _completedEntries.addAll(_currentEntries);\n+            _queue.clear();\n+            _currentEntries.clear();\n+            _cyclicTimeouts.destroy();\n         }\n \n-        for (Entry entry : failedEntries)\n+        for (Entry entry : _completedEntries)\n         {\n             notifyCallbackFailure(entry.callback, failure);\n         }\n+        _completedEntries.clear();\n \n-        failedEntries.clear();\n-        endPoint.close(closedCause);\n+        _releasableBuffers.forEach(RetainableByteBuffer::release);\n+        _releasableBuffers.clear();\n+        _endPoint.close(_closedCause);\n     }\n \n-    private void releaseAggregate()\n+    private void releaseAggregateIfEmpty()\n     {\n-        if (batchBuffer != null && !batchBuffer.hasRemaining())\n+        if (_batchBuffer != null && !_batchBuffer.hasRemaining())\n         {\n-            batchBuffer.release();\n-            batchBuffer = null;\n+            _batchBuffer.release();\n+            _batchBuffer = null;\n         }\n     }\n \n@@ -485,24 +473,19 @@ protected void notifyCallbackFailure(Callback callback, Throwable failure)\n         }\n     }\n \n-    public void setIdleTimeout(long idleTimeout)\n-    {\n-        this.idleTimeout = idleTimeout;\n-    }\n-\n-    public long getIdleTimeout()\n+    public void setFrameWriteTimeout(long idleTimeout)\n     {\n-        return idleTimeout;\n+        _frameTimeout = idleTimeout;\n     }\n \n     public long getMessagesOut()\n     {\n-        return messagesOut.longValue();\n+        return _messagesOut.longValue();\n     }\n \n     public long getBytesOut()\n     {\n-        return bytesOut.longValue();\n+        return _bytesOut.longValue();\n     }\n \n     @Override\n@@ -511,27 +494,39 @@ public String toString()\n         return String.format(\""%s[queueSize=%d,aggregate=%s]\"",\n             super.toString(),\n             getQueueSize(),\n-            batchBuffer);\n+            _batchBuffer);\n     }\n \n-    private static class Entry extends FrameEntry\n+    private class Entry extends FrameEntry implements CyclicTimeouts.Expirable\n     {\n-        private final long timeOfCreation = System.currentTimeMillis();\n+        private final long _expiry;\n \n         private Entry(Frame frame, Callback callback, boolean batch)\n         {\n             super(frame, callback, batch);\n+\n+            long currentTime = NanoTime.now();\n+            long expiry = Long.MAX_VALUE;\n+            if (_frameTimeout > 0)\n+                expiry = currentTime + TimeUnit.MILLISECONDS.toNanos(_frameTimeout);\n+            _expiry = expiry;\n+        }\n+\n+        @Override\n+        public long getExpireNanoTime()\n+        {\n+            return _expiry;\n         }\n \n-        private long getTimeOfCreation()\n+        public boolean isExpired()\n         {\n-            return timeOfCreation;\n+            return (_expiry != Long.MAX_VALUE) && NanoTime.until(_expiry) < 0;\n         }\n \n         @Override\n         public String toString()\n         {\n-            return String.format(\""%s{%s,%s,%b}\"", getClass().getSimpleName(), frame, callback, batch);\n+            return String.format(\""%s{%s,%s,batch=%b,expire=%s}\"", TypeUtil.toShortName(getClass()), frame, callback, batch, NanoTime.millisUntil(_expiry));\n         }\n     }\n }\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-websocket/jetty-websocket-core-tests/src/test/java/org/eclipse/jetty/websocket/core/internal/FrameFlusherTest.java b/jetty-core/jetty-websocket/jetty-websocket-core-tests/src/test/java/org/eclipse/jetty/websocket/core/internal/FrameFlusherTest.java\nindex 2ae247437e02..b21779eb0b20 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-core-tests/src/test/java/org/eclipse/jetty/websocket/core/internal/FrameFlusherTest.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-core-tests/src/test/java/org/eclipse/jetty/websocket/core/internal/FrameFlusherTest.java\n@@ -174,7 +174,7 @@ public void onCompleteFailure(Throwable failure)\n             }\n         };\n \n-        frameFlusher.setIdleTimeout(100);\n+        frameFlusher.setFrameWriteTimeout(100);\n         endPoint.setBlockTime(200);\n \n         Frame frame = new Frame(OpCode.TEXT).setPayload(\""message\"").setFin(true);\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/client/WriteTimeoutTest.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/client/WriteTimeoutTest.java\nindex e031d7f05a28..2fc70518708b 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/client/WriteTimeoutTest.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/client/WriteTimeoutTest.java\n@@ -13,6 +13,8 @@\n \n package org.eclipse.jetty.ee10.websocket.jakarta.tests.client;\n \n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n import jakarta.websocket.EndpointConfig;\n@@ -29,11 +31,14 @@\n \n import static org.hamcrest.CoreMatchers.instanceOf;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n public class WriteTimeoutTest\n {\n-    @ServerEndpoint(\""/logSocket\"")\n+    private static final CountDownLatch MESSAGE_LATCH = new CountDownLatch(1);\n+\n+    @ServerEndpoint(\""/\"")\n     public static class ServerSocket extends EventSocket\n     {\n         @Override\n@@ -43,6 +48,19 @@ public void onOpen(Session session, EndpointConfig endpointConfig)\n             session.setMaxTextMessageBufferSize(-1);\n             super.onOpen(session, endpointConfig);\n         }\n+\n+        @Override\n+        public void onMessage(String message) throws IOException\n+        {\n+            try\n+            {\n+                assertTrue(MESSAGE_LATCH.await(10, TimeUnit.SECONDS));\n+            }\n+            catch (InterruptedException e)\n+            {\n+                throw new RuntimeException(e);\n+            }\n+        }\n     }\n \n     private LocalServer server;\n@@ -67,26 +85,24 @@ public void stop() throws Exception\n     }\n \n     @Test\n-    public void testTimeoutOnLargeMessage() throws Exception\n+    public void testTimeoutFromSlowReads() throws Exception\n     {\n         EventSocket clientEndpoint = new EventSocket();\n-        Session session = client.connectToServer(clientEndpoint, server.getWsUri().resolve(\""/logSocket\""));\n+        Session session = client.connectToServer(clientEndpoint, server.getWsUri());\n+        session.getAsyncRemote().setSendTimeout(1000);\n \n-        session.getAsyncRemote().setSendTimeout(5);\n-        session.setMaxTextMessageBufferSize(1024 * 1024 * 6);\n-\n-        String string = \""xxxxxxx\"";\n-        StringBuilder sb = new StringBuilder();\n-        while (sb.length() < session.getMaxTextMessageBufferSize() - string.length())\n+        // Keep sending messages until one times out.\n+        Exception exception = assertThrows(Exception.class, () ->\n         {\n-            sb.append(string);\n-        }\n-        string = sb.toString();\n+            while (session.isOpen())\n+            {\n+                session.getBasicRemote().sendText(\""x\"".repeat(1024));\n+            }\n+        });\n+        assertThat(exception.getCause(), instanceOf(WebSocketWriteTimeoutException.class));\n \n-        while (session.isOpen())\n-        {\n-            session.getAsyncRemote().sendText(string);\n-        }\n+        // Unblock the thread in onMessage() on the server endpoint.\n+        MESSAGE_LATCH.countDown();\n \n         assertTrue(clientEndpoint.closeLatch.await(5, TimeUnit.SECONDS));\n         assertTrue(clientEndpoint.errorLatch.await(5, TimeUnit.SECONDS));\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-13049"", ""pr_id"": 13049, ""issue_id"": 13046, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Restore `ee9` (and `ee8`) behaviors with parsing `application/x-www-form-urlencoded` parameters\n**Jetty version(s)**\n12.0.19\n\n**Jetty Environment**\nee9/ee8 (not ee10)\n\n**Java version/vendor** `(use: java -version)`\nAny\n\n**OS type/version**\nAny\n\n**Description**\nIn Jetty 10/11 the parsing of bad POST request body results in a 400 response.\nIn Jetty 12, on the ee9/ee8 environments, this doesn't happen anymore.\nThe bad encoding results in a replacement character instead.\n\nExamples:\n\n**Jetty 11.0.25 - `--add-modules=http,demo`**\n\n```\n$ curl -X POST http://localhost:8080/test/dump -d \""foo=%88%A4\""\n<html>\n<head>\n<meta http-equiv=\""Content-Type\"" content=\""text/html;charset=ISO-8859-1\""/>\n<title>Error 400 Unable to parse form content</title>\n</head>\n<body><h2>HTTP ERROR 400 Unable to parse form content</h2>\n<table>\n<tr><th>URI:</th><td>/test/dump</td></tr>\n<tr><th>STATUS:</th><td>400</td></tr>\n<tr><th>MESSAGE:</th><td>Unable to parse form content</td></tr>\n<tr><th>SERVLET:</th><td>Dump</td></tr>\n<tr><th>CAUSED BY:</th><td>org.eclipse.jetty.http.BadMessageException: 400: Unable to parse form content</td></tr>\n<tr><th>CAUSED BY:</th><td>org.eclipse.jetty.util.Utf8Appendable$NotUtf8Exception: Not valid UTF8! byte 88 in state 0</td></tr>\n</table>\n<h3>Caused by:</h3><pre>org.eclipse.jetty.http.BadMessageException: 400: Unable to parse form content\n\tat org.eclipse.jetty.server.Request.getParameters(Request.java:471)\n\tat org.eclipse.jetty.server.Request.getParameter(Request.java:1049)\n\tat com.acme.Dump.doGet(Dump.java:123)\n\tat com.acme.Dump.doPost(Dump.java:86)\n\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:520)\n\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:587)\n\tat org.eclipse.jetty.servlet.ServletHolder$RunAs.service(ServletHolder.java:1371)\n\tat org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:764)\n\tat org.eclipse.jetty.servlet.ServletHandler$ChainEnd.doFilter(ServletHandler.java:1665)\n\tat com.acme.TestFilter.doFilter(TestFilter.java:92)\n\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:202)\n\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1635)\n\tat org.eclipse.jetty.servlets.QoSFilter.doFilter(QoSFilter.java:197)\n\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:202)\n\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1635)\n\tat org.eclipse.jetty.websocket.servlet.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:170)\n\tat org.eclipse.jetty.servlet.FilterHolder.doFilter(FilterHolder.java:202)\n\tat org.eclipse.jetty.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1635)\n\tat org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:527)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:131)\n\tat org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:569)\n\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:122)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:223)\n\tat org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1580)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:131)\n\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:122)\n\tat org.eclipse.jetty.server.handler.gzip.GzipHandler.handle(GzipHandler.java:822)\n\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:122)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:223)\n\tat org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1381)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:176)\n\tat org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:484)\n\tat org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1553)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:174)\n\tat org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1303)\n\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:129)\n\tat org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:192)\n\tat org.eclipse.jetty.server.handler.HandlerList.handle(HandlerList.java:51)\n\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:122)\n\tat org.eclipse.jetty.rewrite.handler.RewriteHandler.handle(RewriteHandler.java:301)\n\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:122)\n\tat org.eclipse.jetty.server.Server.handle(Server.java:563)\n\tat org.eclipse.jetty.server.HttpChannel$RequestDispatchable.dispatch(HttpChannel.java:1598)\n\tat org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:753)\n\tat org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:501)\n\tat org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:287)\n\tat org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:314)\n\tat org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:100)\n\tat org.eclipse.jetty.io.SelectableChannelEndPoint$1.run(SelectableChannelEndPoint.java:53)\n\tat org.eclipse.jetty.util.thread.strategy.AdaptiveExecutionStrategy.runTask(AdaptiveExecutionStrategy.java:421)\n\tat org.eclipse.jetty.util.thread.strategy.AdaptiveExecutionStrategy.consumeTask(AdaptiveExecutionStrategy.java:390)\n\tat org.eclipse.jetty.util.thread.strategy.AdaptiveExecutionStrategy.tryProduce(AdaptiveExecutionStrategy.java:277)\n\tat org.eclipse.jetty.util.thread.strategy.AdaptiveExecutionStrategy.produce(AdaptiveExecutionStrategy.java:193)\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:969)\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.doRunJob(QueuedThreadPool.java:1194)\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:1149)\n\tat java.base/java.lang.Thread.run(Thread.java:840)\nCaused by: org.eclipse.jetty.util.Utf8Appendable$NotUtf8Exception: Not valid UTF8! byte 88 in state 0\n\tat org.eclipse.jetty.util.Utf8Appendable.appendByte(Utf8Appendable.java:249)\n\tat org.eclipse.jetty.util.Utf8Appendable.append(Utf8Appendable.java:151)\n\tat org.eclipse.jetty.util.UrlEncoded.decodeUtf8To(UrlEncoded.java:465)\n\tat org.eclipse.jetty.util.UrlEncoded.decodeTo(UrlEncoded.java:515)\n\tat org.eclipse.jetty.server.Request.extractFormParameters(Request.java:599)\n\tat org.eclipse.jetty.server.Request.extractContentParameters(Request.java:546)\n\tat org.eclipse.jetty.server.Request.getParameters(Request.java:466)\n\t... 56 more\n</pre>\n<hr/><a href=\""https://jetty.org\"">Powered by Jetty:// 11.0.25</a><hr/>\n\n</body>\n</html>\n```\n\n**Jetty 12.0.19 - `--add-modules=http,ee8-demos`**\n\n```\n$ curl -k -X POST http://localhost:8080/ee8-test/dump/info -d \""foo=%88%A4\""\n<html>\n<body>\n<h1>Dump Servlet</h1>\n<table width=\""95%\""><tr>\n<th align=\""right\"">getContentLength:&nbsp;</th><td>10</td></tr><tr>\n<th align=\""right\"">getContentType:&nbsp;</th><td>application/x-www-form-urlencoded</td></tr><tr>\n<th align=\""right\"">getContextPath:&nbsp;</th><td>/ee8-test</td></tr><tr>\n<th align=\""right\"">getDispatcherType:&nbsp;</th><td>REQUEST</td></tr><tr>\n...(snip lots of output)...\n<th align=\""right\"">Content-Length:&nbsp;</th><td>10</td></tr><tr>\n<th align=\""right\"">Content-Type:&nbsp;</th><td>application/x-www-form-urlencoded</td></tr><tr>\n<th align=\""left\"" colspan=\""2\""><big><br/>Request Parameters:</big></th></tr><tr>\n<th align=\""right\"">foo:&nbsp;</th><td>\ufffd\ufffd</td></tr><tr>\n...(snip lots of output)...\n</body>\n</html>\n```\n\nYet oddly, this behavior is maintained in ee10...\n\n**Jetty 12.0.19 - `--add-modules=http,ee10-demos`**\n```\n$ curl -X POST http://localhost:8080/ee10-test/dump/info -d \""foo=%88%A4\""\n<html>\n<head>\n<meta http-equiv=\""Content-Type\"" content=\""text/html;charset=ISO-8859-1\""/>\n<title>Error 400 Unable to parse form content</title>\n</head>\n<body><h2>HTTP ERROR 400 Unable to parse form content</h2>\n<table>\n<tr><th>URI:</th><td>/ee10-test/dump/info</td></tr>\n<tr><th>STATUS:</th><td>400</td></tr>\n<tr><th>MESSAGE:</th><td>Unable to parse form content</td></tr>\n<tr><th>SERVLET:</th><td>Dump</td></tr>\n<tr><th>CAUSED BY:</th><td>org.eclipse.jetty.http.BadMessageException: 400: Unable to parse form content</td></tr>\n<tr><th>CAUSED BY:</th><td>java.util.concurrent.CompletionException: CharacterCodingException@1f7a33d9: Invalid UTF-8</td></tr>\n<tr><th>CAUSED BY:</th><td>CharacterCodingException@1f7a33d9: Invalid UTF-8</td></tr>\n</table>\n<h3>Caused by:</h3><pre>org.eclipse.jetty.http.BadMessageException: 400: Unable to parse form content\n\tat org.eclipse.jetty.ee10.servlet.ServletApiRequest.extractContentParameters(ServletApiRequest.java:1008)\n\tat org.eclipse.jetty.ee10.servlet.ServletApiRequest.getParameters(ServletApiRequest.java:963)\n\tat org.eclipse.jetty.ee10.servlet.ServletApiRequest.getParameter(ServletApiRequest.java:932)\n\tat org.example.Dump.doGet(Dump.java:121)\n\tat org.example.Dump.doPost(Dump.java:84)\n\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:547)\n\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)\n\tat org.eclipse.jetty.ee10.servlet.ServletHolder$RunAs.service(ServletHolder.java:1340)\n\tat org.eclipse.jetty.ee10.servlet.ServletHolder.handle(ServletHolder.java:736)\n\tat org.eclipse.jetty.ee10.servlet.ServletHandler$ChainEnd.doFilter(ServletHandler.java:1622)\n\tat org.example.TestFilter.doFilter(TestFilter.java:92)\n\tat org.eclipse.jetty.ee10.servlet.FilterHolder.doFilter(FilterHolder.java:205)\n\tat org.eclipse.jetty.ee10.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1594)\n\tat org.eclipse.jetty.ee10.servlets.QoSFilter.doFilter(QoSFilter.java:200)\n\tat org.eclipse.jetty.ee10.servlet.FilterHolder.doFilter(FilterHolder.java:205)\n\tat org.eclipse.jetty.ee10.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1594)\n\tat org.eclipse.jetty.ee10.websocket.servlet.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:195)\n\tat org.eclipse.jetty.ee10.servlet.FilterHolder.doFilter(FilterHolder.java:205)\n\tat org.eclipse.jetty.ee10.servlet.ServletHandler$Chain.doFilter(ServletHandler.java:1594)\n\tat org.eclipse.jetty.ee10.servlet.ServletHandler$MappedServlet.handle(ServletHandler.java:1555)\n\tat org.eclipse.jetty.ee10.servlet.ServletChannel.dispatch(ServletChannel.java:819)\n\tat org.eclipse.jetty.ee10.servlet.ServletChannel.handle(ServletChannel.java:436)\n\tat org.eclipse.jetty.ee10.servlet.ServletHandler.handle(ServletHandler.java:470)\n\tat org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:575)\n\tat org.eclipse.jetty.ee10.servlet.SessionHandler.handle(SessionHandler.java:717)\n\tat org.eclipse.jetty.server.handler.gzip.GzipHandler.handle(GzipHandler.java:611)\n\tat org.eclipse.jetty.server.handler.ContextHandler.handle(ContextHandler.java:1064)\n\tat org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:181)\n\tat org.eclipse.jetty.rewrite.handler.RewriteHandler$LastRuleHandler.handle(RewriteHandler.java:159)\n\tat org.eclipse.jetty.rewrite.handler.Rule$Handler.handle(Rule.java:108)\n\tat org.eclipse.jetty.rewrite.handler.CookiePatternRule$1.handle(CookiePatternRule.java:99)\n\tat org.eclipse.jetty.rewrite.handler.Rule$Handler.handle(Rule.java:108)\n\tat org.eclipse.jetty.rewrite.handler.RewriteHandler.handle(RewriteHandler.java:143)\n\tat org.eclipse.jetty.server.Server.handle(Server.java:182)\n\tat org.eclipse.jetty.server.internal.HttpChannelState$HandlerInvoker.run(HttpChannelState.java:662)\n\tat org.eclipse.jetty.server.internal.HttpConnection.onFillable(HttpConnection.java:416)\n\tat org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:322)\n\tat org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:99)\n\tat org.eclipse.jetty.io.SelectableChannelEndPoint$1.run(SelectableChannelEndPoint.java:53)\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:979)\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.doRunJob(QueuedThreadPool.java:1209)\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:1164)\n\tat java.base/java.lang.Thread.run(Thread.java:840)\nCaused by: java.util.concurrent.CompletionException: CharacterCodingException@1f7a33d9: Invalid UTF-8\n\tat java.base/java.util.concurrent.CompletableFuture.reportJoin(CompletableFuture.java:413)\n\tat java.base/java.util.concurrent.CompletableFuture.join(CompletableFuture.java:2118)\n\tat org.eclipse.jetty.io.content.ContentSourceCompletableFuture.join(ContentSourceCompletableFuture.java:234)\n\tat org.eclipse.jetty.server.FormFields.getFields(FormFields.java:143)\n\tat org.eclipse.jetty.ee10.servlet.ServletApiRequest.extractContentParameters(ServletApiRequest.java:1003)\n\t... 42 more\nCaused by: CharacterCodingException@1f7a33d9: Invalid UTF-8\n\tat org.eclipse.jetty.util.Utf8StringBuilder.takePartialString(Utf8StringBuilder.java:394)\n\tat org.eclipse.jetty.util.Utf8StringBuilder.takeCompleteString(Utf8StringBuilder.java:378)\n\tat org.eclipse.jetty.util.Utf8StringBuilder.build(Utf8StringBuilder.java:406)\n\tat org.eclipse.jetty.server.FormFields.parse(FormFields.java:404)\n\tat org.eclipse.jetty.server.FormFields.parse(FormFields.java:40)\n\tat org.eclipse.jetty.io.content.ContentSourceCompletableFuture.parse(ContentSourceCompletableFuture.java:126)\n\tat org.eclipse.jetty.server.FormFields.from(FormFields.java:293)\n\t... 44 more\n</pre>\n<hr/><a href=\""https://jetty.org/\"">Powered by Jetty:// 12.0.19</a><hr/>\n\n</body>\n</html>\n```"", ""issue_word_count"": 1888, ""test_files_count"": 5, ""non_test_files_count"": 5, ""pr_changed_files"": [""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/FormFieldsTest.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/CharsetStringBuilder.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlParameterDecoder.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/Utf8StringBuilder.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/URLEncodedTest.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlParameterDecoderTest.java"", ""jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/internal/NullAppendable.java"", ""tests/jetty-jmh/src/main/java/org/eclipse/jetty/util/UrlParameterDecoderBenchmark.java""], ""pr_changed_test_files"": [""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/FormFieldsTest.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/URLEncodedTest.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlParameterDecoderTest.java"", ""tests/jetty-jmh/src/main/java/org/eclipse/jetty/util/UrlParameterDecoderBenchmark.java""], ""base_commit"": ""e2f3857cb90fefcca6c95e90a40bf69274ce4e7a"", ""head_commit"": ""8b8b549006f5822f8f1aa23a4d01de7c6a237f94"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/13049"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/13049"", ""dockerfile"": """", ""pr_merged_at"": ""2025-05-05T15:55:20.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/CharsetStringBuilder.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/CharsetStringBuilder.java\nindex 0959e7406206..0cd3eb097d6d 100644\n--- a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/CharsetStringBuilder.java\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/CharsetStringBuilder.java\n@@ -22,6 +22,9 @@\n import java.util.Arrays;\n import java.util.Objects;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n /**\n  * <p>Build a string from a sequence of bytes and/or characters.</p>\n  * <p>Implementations of this interface are optimized for processing a mix of calls to already decoded\n@@ -93,7 +96,48 @@ default void append(ByteBuffer buf)\n      * @return The decoded built string which must be complete in regard to any multibyte sequences.\n      * @throws CharacterCodingException If the bytes cannot be correctly decoded or a multibyte sequence is incomplete.\n      */\n-    String build() throws CharacterCodingException;\n+    default String build() throws CharacterCodingException\n+    {\n+        return build(false);\n+    }\n+\n+    /**\n+     * <p>Attempt to build the completed string and reset the buffer,\n+     * returning a partial string if there are encoding errors</p>\n+     *\n+     * <p>Note, only some implementations support the {@code allowPartialString}\n+     * parameter</p>\n+     *\n+     * @param allowPartialString true if a partial string is allowed to be returned,\n+     * false means if complete string cannot be returned, an exception is thrown.\n+     * @return The available string (complete or partial)\n+     * @throws CharacterCodingException (only if {@code allowPartialString} is false) thrown if the bytes cannot be correctly decoded or a multibyte sequence is incomplete.\n+     */\n+    String build(boolean allowPartialString) throws CharacterCodingException;\n+\n+    /**\n+     * <p>Test for if there are and detected encoding errors</p>\n+     *\n+     * @return {@code True} if the characters in the builder contain encoding errors.\n+     *   Such as bad sequences, incomplete sequences, replacement characters, etc.\n+     */\n+    default boolean hasCodingErrors()\n+    {\n+        return false;\n+    }\n+\n+    /**\n+     * <p>If there is an incomplete sequence, replace it with the encoding\n+     * specific replacement character.</p>\n+     *\n+     * <p>Will set the encoding errors to true for {@link #hasCodingErrors()}</p>\n+     *\n+     * @return true if replacement occurred, false if there was no issue.\n+     */\n+    default boolean replaceIncomplete()\n+    {\n+        return false;\n+    }\n \n     /**\n      * @return the length in characters\n@@ -110,40 +154,22 @@ default void append(ByteBuffer buf)\n      * @return A {@link CharsetStringBuilder} suitable for the charset.\n      */\n     static CharsetStringBuilder forCharset(Charset charset)\n+    {\n+        return forCharset(charset, CodingErrorAction.REPORT, CodingErrorAction.REPORT);\n+    }\n+\n+    static CharsetStringBuilder forCharset(Charset charset, CodingErrorAction onMalformedInput, CodingErrorAction onUnmappableCharacter)\n     {\n         Objects.requireNonNull(charset);\n         if (charset == StandardCharsets.UTF_8)\n-            return new Utf8StringBuilder();\n+            return new Utf8StringBuilder(onMalformedInput, onUnmappableCharacter);\n         if (charset == StandardCharsets.ISO_8859_1)\n             return new Iso88591StringBuilder();\n         if (charset == StandardCharsets.US_ASCII)\n             return new UsAsciiStringBuilder();\n \n         // Use a CharsetDecoder that defaults to CodingErrorAction#REPORT\n-        return new DecoderStringBuilder(charset.newDecoder());\n-    }\n-\n-    /**\n-     * Extended Utf8StringBuilder that mimics {@link CodingErrorAction#REPORT} behaviour\n-     * for {@link CharsetStringBuilder} methods.\n-     */\n-    class ReportingUtf8StringBuilder extends Utf8StringBuilder\n-    {\n-        @Override\n-        public String toCompleteString()\n-        {\n-            if (hasCodingErrors())\n-                throw new RuntimeException(new CharacterCodingException());\n-            return super.toCompleteString();\n-        }\n-\n-        @Override\n-        public String build() throws CharacterCodingException\n-        {\n-            if (hasCodingErrors())\n-                throw new CharacterCodingException();\n-            return super.build();\n-        }\n+        return new DecoderStringBuilder(charset.newDecoder(), onMalformedInput, onUnmappableCharacter);\n     }\n \n     class Iso88591StringBuilder implements CharsetStringBuilder\n@@ -176,6 +202,12 @@ public String build()\n             return s;\n         }\n \n+        @Override\n+        public String build(boolean ignored)\n+        {\n+            return build();\n+        }\n+\n         @Override\n         public int length()\n         {\n@@ -221,6 +253,12 @@ public String build()\n             return s;\n         }\n \n+        @Override\n+        public String build(boolean ignored)\n+        {\n+            return build();\n+        }\n+\n         @Override\n         public int length()\n         {\n@@ -236,13 +274,16 @@ public void reset()\n \n     class DecoderStringBuilder implements CharsetStringBuilder\n     {\n+        private static final Logger LOG = LoggerFactory.getLogger(DecoderStringBuilder.class);\n         private final CharsetDecoder _decoder;\n         private final StringBuilder _stringBuilder = new StringBuilder(32);\n         private ByteBuffer _buffer = ByteBuffer.allocate(32);\n         \n-        public DecoderStringBuilder(CharsetDecoder charsetDecoder)\n+        public DecoderStringBuilder(CharsetDecoder charsetDecoder, CodingErrorAction onMalformedInput, CodingErrorAction onUnmappableCharacter)\n         {\n             _decoder = charsetDecoder;\n+            _decoder.onMalformedInput(onMalformedInput);\n+            _decoder.onUnmappableCharacter(onUnmappableCharacter);\n         }\n \n         private void ensureSpace(int needed)\n@@ -319,8 +360,12 @@ public void append(ByteBuffer buf)\n         }\n \n         @Override\n-        public String build() throws CharacterCodingException\n+        public String build(boolean ignore) throws CharacterCodingException\n         {\n+            // the parameter is ignored, as the CharsetDecoder configuration\n+            // determines the behavior.\n+            // See onMalformedInput(CodingErrorAction)\n+            // and onUnmappableCharacter(CodingErrorAction)\n             try\n             {\n                 if (_buffer.position() > 0)\n\ndiff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java\nindex a1aaf921f7aa..7e552a2b0962 100644\n--- a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java\n@@ -15,17 +15,14 @@\n \n import java.io.IOException;\n import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.StringWriter;\n import java.nio.charset.CharacterCodingException;\n import java.nio.charset.Charset;\n+import java.nio.charset.CodingErrorAction;\n import java.nio.charset.StandardCharsets;\n import java.util.List;\n import java.util.Map;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.BiConsumer;\n-import java.util.function.Supplier;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -366,156 +363,18 @@ public static boolean decodeUtf8To(String query, int offset, int length, BiConsu\n     public static boolean decodeUtf8To(String query, int offset, int length, BiConsumer<String, String> adder, boolean allowBadPercent, boolean allowBadUtf8, boolean allowTruncatedUtf8)\n         throws Utf8StringBuilder.Utf8IllegalArgumentException\n     {\n-        Utf8StringBuilder buffer = new Utf8StringBuilder();\n-        String key = null;\n-        String value;\n-\n-        AtomicBoolean badUtf8;\n-        Supplier<Utf8StringBuilder.Utf8IllegalArgumentException> onCodingError;\n-\n-        if (allowBadUtf8)\n-        {\n-            badUtf8 = new AtomicBoolean(false);\n-            onCodingError = () ->\n-            {\n-                badUtf8.set(true);\n-                return null;\n-            };\n-        }\n-        else\n-        {\n-            badUtf8 = null;\n-            onCodingError = Utf8StringBuilder.Utf8IllegalArgumentException::new;\n-        }\n-\n-        int end = offset + length;\n-        for (int i = offset; i < end; i++)\n-        {\n-            char c = query.charAt(i);\n-            switch (c)\n-            {\n-                case '&':\n-                    value = take(allowBadUtf8, allowTruncatedUtf8, buffer, badUtf8, onCodingError);\n-\n-                    if (key != null)\n-                    {\n-                        adder.accept(key, value);\n-                    }\n-                    else if (value != null && !value.isEmpty())\n-                    {\n-                        adder.accept(value, \""\"");\n-                    }\n-                    key = null;\n-                    break;\n-\n-                case '=':\n-                    if (key != null)\n-                    {\n-                        buffer.append(c);\n-                        break;\n-                    }\n-\n-                    key = take(allowBadUtf8, allowTruncatedUtf8, buffer, badUtf8, onCodingError);\n-                    break;\n-\n-                case '+':\n-                    buffer.append((byte)' ');\n-                    break;\n-\n-                case '%':\n-                    if (i + 2 < end)\n-                    {\n-                        char hi = query.charAt(++i);\n-                        char lo = query.charAt(++i);\n-                        try\n-                        {\n-                            decodeHexByteTo(buffer, hi, lo);\n-                        }\n-                        catch (NumberFormatException e)\n-                        {\n-                            boolean replaced = buffer.replaceIncomplete();\n-                            if (replaced && !allowBadUtf8 || !allowBadPercent)\n-                                throw e;\n-\n-                            if (hi == '&' || key == null && hi == '=')\n-                            {\n-                                if (!replaced)\n-                                    buffer.append('%');\n-                                i = i - 2;\n-                            }\n-                            else if (lo == '&' || key == null && lo == '=')\n-                            {\n-                                if (!replaced)\n-                                {\n-                                    buffer.append('%');\n-                                    buffer.append(hi);\n-                                }\n-                                i = i - 1;\n-                            }\n-                            else\n-                            {\n-                                if (!replaced)\n-                                {\n-                                    buffer.append('%');\n-                                    buffer.append(hi);\n-                                    buffer.append(lo);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    else if (buffer.replaceIncomplete())\n-                    {\n-                        if (!allowBadUtf8 || !allowBadPercent)\n-                            throw new Utf8StringBuilder.Utf8IllegalArgumentException();\n-                        i = end;\n-                    }\n-                    else if (allowBadPercent)\n-                    {\n-                        buffer.append('%');\n-                    }\n-                    else\n-                    {\n-                        throw new Utf8StringBuilder.Utf8IllegalArgumentException();\n-                    }\n-                    break;\n-\n-                default:\n-                    buffer.append(c);\n-                    break;\n-            }\n-        }\n-\n-        if (key != null)\n+        CodingErrorAction onCodingError = (allowBadUtf8 || allowBadPercent || allowTruncatedUtf8) ? CodingErrorAction.REPLACE : CodingErrorAction.REPORT;\n+        CharsetStringBuilder charsetStringBuilder = new Utf8StringBuilder(onCodingError, onCodingError);\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, adder, -1, -1, allowBadUtf8, allowBadPercent, allowTruncatedUtf8);\n+        try\n         {\n-            value = take(allowBadUtf8, allowTruncatedUtf8, buffer, badUtf8, onCodingError);\n-            adder.accept(key, value);\n+            return decoder.parse(query, offset, length);\n         }\n-        else if (buffer.length() > 0)\n+        catch (IOException e)\n         {\n-            key = take(allowBadUtf8, allowTruncatedUtf8, buffer, badUtf8, onCodingError);\n-            adder.accept(key, \""\"");\n+            // TODO: why do we do this only for String parsing, but not InputStream?\n+            throw new Utf8StringBuilder.Utf8IllegalArgumentException(e);\n         }\n-\n-        return badUtf8 == null || !badUtf8.get();\n-    }\n-\n-    private static <X extends Throwable> String take(boolean allowBadUtf8, Boolean allowTruncatedUtf8, Utf8StringBuilder buffer, AtomicBoolean badUtf8, Supplier<X> onCodingError) throws X\n-    {\n-        if (!allowBadUtf8 && !allowTruncatedUtf8)\n-            return buffer.takeCompleteString(onCodingError);\n-\n-        boolean codingError = buffer.hasCodingErrors();\n-        if (codingError && !allowBadUtf8)\n-            return buffer.takeCompleteString(onCodingError);\n-\n-        if (buffer.replaceIncomplete() && !allowTruncatedUtf8)\n-            return buffer.takeCompleteString(onCodingError);\n-\n-        String result = buffer.takeCompleteString(null);\n-        buffer.reset();\n-        if (badUtf8 != null)\n-            badUtf8.set(true);\n-        return result;\n     }\n \n     /**\n@@ -545,75 +404,9 @@ public static void decode88591To(InputStream in, MultiMap<String> map, int maxLe\n     public static void decode88591To(InputStream in, BiConsumer<String, String> adder, int maxLength, int maxKeys)\n         throws IOException\n     {\n-        StringBuilder buffer = new StringBuilder();\n-        String key = null;\n-        String value;\n-\n-        int b;\n-\n-        int totalLength = 0;\n-        int keys = 0;\n-        while ((b = in.read()) >= 0)\n-        {\n-            switch ((char)b)\n-            {\n-                case '&':\n-                    value = buffer.isEmpty() ? \""\"" : buffer.toString();\n-                    buffer.setLength(0);\n-                    if (key != null)\n-                    {\n-                        adder.accept(key, value);\n-                        keys++;\n-                    }\n-                    else if (!value.isEmpty())\n-                    {\n-                        adder.accept(value, \""\"");\n-                        keys++;\n-                    }\n-                    key = null;\n-                    checkMaxKeys(keys, maxKeys);\n-                    break;\n-\n-                case '=':\n-                    if (key != null)\n-                    {\n-                        buffer.append((char)b);\n-                        break;\n-                    }\n-                    key = buffer.toString();\n-                    buffer.setLength(0);\n-                    break;\n-\n-                case '+':\n-                    buffer.append(' ');\n-                    break;\n-\n-                case '%':\n-                    int code0 = in.read();\n-                    int code1 = in.read();\n-                    buffer.append(decodeHexChar(code0, code1));\n-                    break;\n-\n-                default:\n-                    buffer.append((char)b);\n-                    break;\n-            }\n-            checkMaxLength(++totalLength, maxLength);\n-        }\n-\n-        if (key != null)\n-        {\n-            value = buffer.isEmpty() ? \""\"" : buffer.toString();\n-            buffer.setLength(0);\n-            adder.accept(key, value);\n-            keys++;\n-        }\n-        else if (!buffer.isEmpty())\n-        {\n-            adder.accept(buffer.toString(), \""\"");\n-            keys++;\n-        }\n-        checkMaxKeys(keys, maxKeys);\n+        CharsetStringBuilder charsetStringBuilder = new CharsetStringBuilder.Iso88591StringBuilder();\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, adder, maxLength, maxKeys, false, false, false);\n+        decoder.parse(in, StandardCharsets.ISO_8859_1);\n     }\n \n     /**\n@@ -660,75 +453,9 @@ public static void decodeUtf8To(InputStream in, MultiMap<String> map, int maxLen\n     public static void decodeUtf8To(InputStream in, BiConsumer<String, String> adder, int maxLength, int maxKeys)\n         throws IOException\n     {\n-        Utf8StringBuilder buffer = new Utf8StringBuilder();\n-        String key = null;\n-        String value;\n-\n-        int b;\n-\n-        int totalLength = 0;\n-        int keys = 0;\n-        while ((b = in.read()) >= 0)\n-        {\n-            switch ((char)b)\n-            {\n-                case '&':\n-                    value = buffer.toCompleteString();\n-                    buffer.reset();\n-                    if (key != null)\n-                    {\n-                        adder.accept(key, value);\n-                        keys++;\n-                    }\n-                    else if (value != null && !value.isEmpty())\n-                    {\n-                        adder.accept(value, \""\"");\n-                        keys++;\n-                    }\n-                    key = null;\n-                    checkMaxKeys(keys, maxKeys);\n-                    break;\n-\n-                case '=':\n-                    if (key != null)\n-                    {\n-                        buffer.append((byte)b);\n-                        break;\n-                    }\n-                    key = buffer.toCompleteString();\n-                    buffer.reset();\n-                    break;\n-\n-                case '+':\n-                    buffer.append((byte)' ');\n-                    break;\n-\n-                case '%':\n-                    char code0 = (char)in.read();\n-                    char code1 = (char)in.read();\n-                    buffer.append(decodeHexByte(code0, code1));\n-                    break;\n-\n-                default:\n-                    buffer.append((byte)b);\n-                    break;\n-            }\n-            checkMaxLength(++totalLength, maxLength);\n-        }\n-\n-        if (key != null)\n-        {\n-            value = buffer.toCompleteString();\n-            buffer.reset();\n-            adder.accept(key, value);\n-            keys++;\n-        }\n-        else if (buffer.length() > 0)\n-        {\n-            adder.accept(buffer.toCompleteString(), \""\"");\n-            keys++;\n-        }\n-        checkMaxKeys(keys, maxKeys);\n+        CharsetStringBuilder charsetStringBuilder = new Utf8StringBuilder();\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, adder, maxLength, maxKeys);\n+        decoder.parse(in, StandardCharsets.UTF_8);\n     }\n \n     public static void decodeUtf16To(InputStream in, MultiMap<String> map, int maxLength, int maxKeys) throws IOException\n@@ -738,11 +465,9 @@ public static void decodeUtf16To(InputStream in, MultiMap<String> map, int maxLe\n \n     public static void decodeUtf16To(InputStream in, BiConsumer<String, String> adder, int maxLength, int maxKeys) throws IOException\n     {\n-        InputStreamReader input = new InputStreamReader(in, StandardCharsets.UTF_16);\n-        StringWriter buf = new StringWriter(8192);\n-        IO.copy(input, buf, maxLength);\n-\n-        decodeTo(buf.getBuffer().toString(), adder, StandardCharsets.UTF_16, maxKeys);\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(StandardCharsets.UTF_16);\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, adder, maxLength, maxKeys);\n+        decoder.parse(in, StandardCharsets.UTF_16);\n     }\n \n     /**\n@@ -789,97 +514,15 @@ public static void decodeTo(InputStream in, BiConsumer<String, String> adder, Ch\n         if (charset == null)\n             charset = ENCODING;\n \n-        if (StandardCharsets.UTF_8.equals(charset))\n-        {\n-            decodeUtf8To(in, adder, maxLength, maxKeys);\n-            return;\n-        }\n-\n-        if (StandardCharsets.ISO_8859_1.equals(charset))\n-        {\n-            decode88591To(in, adder, maxLength, maxKeys);\n-            return;\n-        }\n-\n-        if (StandardCharsets.UTF_16.equals(charset)) // Should be all 2 byte encodings\n-        {\n-            decodeUtf16To(in, adder, maxLength, maxKeys);\n-            return;\n-        }\n-\n-        String key = null;\n-        String value;\n-\n-        int c;\n-\n-        int totalLength = 0;\n-\n-        try (ByteArrayOutputStream2 output = new ByteArrayOutputStream2())\n-        {\n-            int keys = 0;\n-            int size;\n-\n-            while ((c = in.read()) > 0)\n-            {\n-                switch ((char)c)\n-                {\n-                    case '&':\n-                        size = output.size();\n-                        value = size == 0 ? \""\"" : output.toString(charset);\n-                        output.setCount(0);\n-                        if (key != null)\n-                        {\n-                            adder.accept(key, value);\n-                            keys++;\n-                        }\n-                        else if (value != null && !value.isEmpty())\n-                        {\n-                            adder.accept(value, \""\"");\n-                            keys++;\n-                        }\n-                        key = null;\n-                        checkMaxKeys(keys, maxKeys);\n-                        break;\n-                    case '=':\n-                        if (key != null)\n-                        {\n-                            output.write(c);\n-                            break;\n-                        }\n-                        size = output.size();\n-                        key = size == 0 ? \""\"" : output.toString(charset);\n-                        output.setCount(0);\n-                        break;\n-                    case '+':\n-                        output.write(' ');\n-                        break;\n-                    case '%':\n-                        int code0 = in.read();\n-                        int code1 = in.read();\n-                        output.write(decodeHexChar(code0, code1));\n-                        break;\n-                    default:\n-                        output.write(c);\n-                        break;\n-                }\n-                checkMaxLength(++totalLength, maxLength);\n-            }\n-\n-            size = output.size();\n-            if (key != null)\n-            {\n-                value = size == 0 ? \""\"" : output.toString(charset);\n-                output.setCount(0);\n-                adder.accept(key, value);\n-                keys++;\n-            }\n-            else if (size > 0)\n-            {\n-                adder.accept(output.toString(charset), \""\"");\n-                keys++;\n-            }\n-            checkMaxKeys(keys, maxKeys);\n-        }\n+        CodingErrorAction onMalformedError = CodingErrorAction.REPLACE;\n+        CodingErrorAction onUnmappableError = CodingErrorAction.REPLACE;\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(charset, onMalformedError, onUnmappableError);\n+        // Settings to maintain backward compat with Jetty 11.\n+        boolean allowBadEncoding = true;\n+        boolean allowBadPercent = false;\n+        boolean allowTruncatedEncoding = true;\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, adder, maxLength, maxKeys, allowBadEncoding, allowBadPercent, allowTruncatedEncoding);\n+        decoder.parse(in, charset);\n     }\n \n     private static void checkMaxKeys(int size, int maxKeys)\n@@ -909,6 +552,7 @@ private static void checkMaxLength(int length, int maxLength)\n      * @param encoded the encoded string to decode\n      * @return the decoded string\n      */\n+    // TODO: nothing is using this method\n     public static String decodeString(String encoded)\n     {\n         return decodeString(encoded, 0, encoded.length(), ENCODING);\n@@ -925,8 +569,12 @@ public static String decodeString(String encoded)\n      * @param charset the charset to use for decoding\n      * @return the decoded string\n      */\n+    // TODO: only the decodeString(String) method (above) uses this method.\n+    //       we could default this behavior to just the JVM implementation and punt on maintaining this code.\n     public static String decodeString(String encoded, int offset, int length, Charset charset)\n     {\n+        // TODO: see if this first if block can be rolled into the generic else case\n+        //       with the CodingErrorAction.REPLACE as default.\n         if (charset == null || StandardCharsets.UTF_8.equals(charset))\n         {\n             Utf8StringBuilder buffer = null;\n@@ -1084,18 +732,6 @@ else if (buffer != null)\n         }\n     }\n \n-    private static char decodeHexChar(int hi, int lo)\n-    {\n-        try\n-        {\n-            return (char)((convertHexDigit(hi) << 4) + convertHexDigit(lo));\n-        }\n-        catch (NumberFormatException e)\n-        {\n-            throw new IllegalArgumentException(\""Not valid encoding '%\"" + (char)hi + (char)lo + \""'\"");\n-        }\n-    }\n-\n     public static byte decodeHexByte(char hi, char lo)\n     {\n         try\n@@ -1108,11 +744,6 @@ public static byte decodeHexByte(char hi, char lo)\n         }\n     }\n \n-    private static void decodeHexByteTo(Utf8StringBuilder buffer, char hi, char lo)\n-    {\n-        buffer.append((byte)((convertHexDigit(hi) << 4) + convertHexDigit(lo)));\n-    }\n-\n     /**\n      * Perform URL encoding.\n      *\n\ndiff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlParameterDecoder.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlParameterDecoder.java\nnew file mode 100644\nindex 000000000000..58a2650c7bae\n--- /dev/null\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlParameterDecoder.java\n@@ -0,0 +1,446 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.CharBuffer;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.Charset;\n+import java.util.function.BiConsumer;\n+\n+import static org.eclipse.jetty.util.TypeUtil.convertHexDigit;\n+\n+/**\n+ * Parsing for URL/URI Query and {@code application/x-www-form-urlencoded} parameters.\n+ */\n+class UrlParameterDecoder\n+{\n+    private final BiConsumer<String, String> newFieldAdder;\n+    private final int maxLength;\n+    private final int maxKeys;\n+    private final boolean allowBadEncoding;\n+    private final boolean allowBadPercent;\n+    private final boolean allowTruncatedEncoding;\n+    private final CharsetStringBuilder builder;\n+    private String name;\n+    private int keyCount;\n+    private int charCount;\n+\n+    public UrlParameterDecoder(CharsetStringBuilder charsetStringBuilder, BiConsumer<String, String> newFieldAdder)\n+    {\n+        this(charsetStringBuilder, newFieldAdder, -1, -1);\n+    }\n+\n+    public UrlParameterDecoder(CharsetStringBuilder charsetStringBuilder, BiConsumer<String, String> newFieldAdder, int maxLength, int maxKeys)\n+    {\n+        this(charsetStringBuilder, newFieldAdder, maxLength, maxKeys, false, false, false);\n+    }\n+\n+    /**\n+     * Construct a {@code UrlParameterDecoder} that is responsible for parsing\n+     * the input ({@link String} or {@link InputStream}) into the provided {@code newFieldAdder}\n+     * using the {@link CharsetStringBuilder} (to satisfy {@link java.nio.charset.Charset})\n+     *\n+     * @param charsetStringBuilder the {@link CharsetStringBuilder} that holds parsed bytes according to {@link java.nio.charset.Charset} rules\n+     * @param newFieldAdder the consumer of new fields (often a {@link Fields} instance, but sometimes a {@link MultiMap} instance)\n+     * @param maxLength the maximum allowable length in bytes of the form (-1 to disable check)\n+     * @param maxKeys the maximum number of keys for the form (-1 to disable)\n+     * @param allowBadEncoding allow use of bad encoding with the {@link CharsetStringBuilder} (optional behavior)\n+     * @param allowBadPercent allow use of bad pct-encoding with the {@link CharsetStringBuilder} (optional behavior)\n+     * @param allowTruncatedEncoding allow use of truncated pct-encoding with the {@link CharsetStringBuilder} (optional behavior)\n+     */\n+    public UrlParameterDecoder(CharsetStringBuilder charsetStringBuilder, BiConsumer<String, String> newFieldAdder, int maxLength, int maxKeys,\n+                               boolean allowBadEncoding, boolean allowBadPercent, boolean allowTruncatedEncoding)\n+    {\n+        this.builder = charsetStringBuilder;\n+        this.newFieldAdder = newFieldAdder;\n+        this.maxLength = maxLength;\n+        this.maxKeys = maxKeys;\n+        this.allowBadEncoding = allowBadEncoding;\n+        this.allowBadPercent = allowBadPercent;\n+        this.allowTruncatedEncoding = allowTruncatedEncoding;\n+    }\n+\n+    /**\n+     * <p>Parse a CharSequence completely.</p>\n+     *\n+     * <p>The {@code newFieldAdder} is called for each encountered {@code key=value} pair.</p>\n+     *\n+     * @param charSequence the char sequence to parse, completing the parsing after parsing.\n+     * @return true if there were coding errors, false otherwise.\n+     * @throws CharacterCodingException if a coding issue is encountered with the\n+     * provided {@link CharsetStringBuilder} and the specific condition\n+     * is not allowed by one of the {@code allow*} parameters on the constructor.\n+     */\n+    public boolean parse(CharSequence charSequence) throws IOException\n+    {\n+        if (charSequence instanceof String s)\n+            return parseCompletely(new StringCharIterator(s));\n+        return parseCompletely(new CharSequenceCharIterator(charSequence));\n+    }\n+\n+    /**\n+     * <p>Parse a CharSequence section completely.</p>\n+     *\n+     * <p>The {@code newFieldAdder} is called for each encountered {@code key=value} pair.</p>\n+     *\n+     * @param charSequence the string to parse, completing the parsing after parsing.\n+     * @param offset the offset in the string to start parsing from.\n+     * @param length the length of the substring to parse.\n+     * @return true if there were coding errors, false otherwise.\n+     * @throws CharacterCodingException if a coding issue is encountered with the\n+     * provided {@link CharsetStringBuilder} and the specific condition\n+     * is not allowed by one of the {@code allow*} parameters on the constructor.\n+     */\n+    public boolean parse(CharSequence charSequence, int offset, int length) throws IOException\n+    {\n+        if (charSequence instanceof String s)\n+            return parseCompletely(new StringCharIterator(s, offset, length));\n+        return parseCompletely(new CharSequenceCharIterator(charSequence, offset, length));\n+    }\n+\n+    /**\n+     * <p>Parse a InputStream completely.</p>\n+     *\n+     * <p>The {@code newFieldAdder} is called for each encountered {@code key=value} pair.</p>\n+     *\n+     * <p>The InputStream is read until EOF</p>\n+     *\n+     * @param input the InputStream to parse, completing the parsing after parsing.\n+     * @param charset the charset to use when parsing the InputStream.\n+     * @return true if there were coding errors, false otherwise.\n+     * @throws CharacterCodingException if a coding issue is encountered with the\n+     * provided {@link CharsetStringBuilder} and the specific condition\n+     * is not allowed by one of the {@code allow*} parameters on the constructor.\n+     */\n+    public boolean parse(InputStream input, Charset charset) throws IOException\n+    {\n+        return parse(new InputStreamReader(input, charset));\n+    }\n+\n+    /**\n+     * <p>Parse a Reader completely.</p>\n+     *\n+     * <p>The {@code newFieldAdder} is called for each encountered {@code key=value} pair.</p>\n+     *\n+     * <p>The Reader is read until EOF</p>\n+     *\n+     * @param reader the Reader to parse, completing the parsing after parsing.\n+     * @return true if there were coding errors, false otherwise.\n+     * @throws CharacterCodingException if a coding issue is encountered with the\n+     * provided {@link CharsetStringBuilder} and the specific condition\n+     * is not allowed by one of the {@code allow*} parameters on the constructor.\n+     */\n+    public boolean parse(Reader reader) throws IOException\n+    {\n+        return parseCompletely(new ReaderCharIterator(reader));\n+    }\n+\n+    private boolean parseCompletely(CharIterator iter) throws IOException\n+    {\n+        int i;\n+        while ((i = iter.next()) >= 0)\n+        {\n+            char c = (char)i;\n+            if (maxLength >= 0 && ++charCount > maxLength)\n+                throw new IllegalStateException(\""Form is larger than max length \"" + maxLength);\n+\n+            if (!parseChar(c, iter))\n+                break;\n+        }\n+\n+        complete();\n+        return builder.hasCodingErrors();\n+    }\n+\n+    /**\n+     * Parse the read character.\n+     *\n+     * @param c the read character\n+     * @param iter the character iterator to pull more characters from\n+     * @return true if parsing should continue, false otherwise\n+     * @throws IOException if unable to parse for a fundamental reason\n+     */\n+    private boolean parseChar(char c, CharIterator iter) throws IOException\n+    {\n+        switch (c)\n+        {\n+            case '&' ->\n+            {\n+                String str = takeBuiltString();\n+                if (name == null)\n+                {\n+                    onNewField(str, \""\"");\n+                }\n+                else\n+                {\n+                    onNewField(name, str);\n+                    name = null;\n+                }\n+            }\n+            case '=' ->\n+            {\n+                if (name == null)\n+                    name = takeBuiltString();\n+                else\n+                    builder.append(c);\n+            }\n+            case '+' -> builder.append(' ');\n+            case '%' ->\n+            {\n+                int hi = iter.next();\n+                if (hi == -1)\n+                {\n+                    // we have a sequence ending in '%'\n+                    return handleIncompletePctEncoding(hi);\n+                }\n+                int lo = iter.next();\n+                if (lo == -1)\n+                {\n+                    // we have a sequence ending in `%?` (incomplete pct-encoding)\n+                    return handleIncompletePctEncoding(hi);\n+                }\n+\n+                try\n+                {\n+                    decodeHexByteTo(builder, (char)hi, (char)lo);\n+                }\n+                catch (NumberFormatException e)\n+                {\n+                    boolean replaced = builder.replaceIncomplete();\n+                    if (replaced && !allowBadEncoding || !allowBadPercent)\n+                        throw new IllegalArgumentException(notValidPctEncoding((char)hi, (char)lo));\n+\n+                    if (hi == '&' || name == null && hi == '=')\n+                    {\n+                        if (!replaced)\n+                            builder.append('%');\n+                        parseChar((char)hi, iter);\n+                        parseChar((char)lo, iter);\n+                    }\n+                    else if (lo == '&' || name == null && lo == '=')\n+                    {\n+                        if (!replaced)\n+                        {\n+                            builder.append('%');\n+                            builder.append((char)hi);\n+                        }\n+                        parseChar((char)lo, iter);\n+                    }\n+                    else\n+                    {\n+                        if (!replaced)\n+                        {\n+                            builder.append('%');\n+                            builder.append((char)hi);\n+                            builder.append((char)lo);\n+                        }\n+                    }\n+                }\n+            }\n+            default ->\n+            {\n+                builder.append(c);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Handle an incomplete pct-encoding such as {@code %} (ending in a percent symbol),\n+     * or {@code %A} (ending in only 1 hex digit).\n+     *\n+     * @param hi the hi char in the possible pct-encoding hex sequence (-1 for undefined)\n+     * @return true if parsing should continue, false otherwise\n+     */\n+    private boolean handleIncompletePctEncoding(int hi)\n+    {\n+        if (builder.replaceIncomplete())\n+        {\n+            if (!allowBadEncoding || !allowBadPercent)\n+                throw new IllegalArgumentException(notValidPctEncoding((char)hi, (char)0));\n+            return false;\n+        }\n+        else if (allowBadPercent)\n+        {\n+            builder.append('%');\n+            if (hi != -1)\n+                builder.append((char)hi);\n+            return true;\n+        }\n+        else\n+        {\n+            throw new IllegalArgumentException(notValidPctEncoding((char)hi, (char)0));\n+        }\n+    }\n+\n+    private static void decodeHexByteTo(CharsetStringBuilder buffer, char hi, char lo)\n+    {\n+        buffer.append((byte)((convertHexDigit(hi) << 4) + convertHexDigit(lo)));\n+    }\n+\n+    private void complete() throws CharacterCodingException\n+    {\n+        if (name != null)\n+        {\n+            String value = takeBuiltString();\n+            onNewField(name, value);\n+        }\n+        else if (builder.length() > 0)\n+        {\n+            name = takeBuiltString();\n+            onNewField(name, \""\"");\n+        }\n+    }\n+\n+    private String notValidPctEncoding(char hi, char lo)\n+    {\n+        return \""Not valid encoding '%%%c%c'\"".formatted(hi != 0 ? hi : '?', lo != 0 ? lo : '?');\n+    }\n+\n+    private String takeBuiltString() throws CharacterCodingException\n+    {\n+        if (!allowBadEncoding && !allowBadPercent && !allowTruncatedEncoding)\n+        {\n+            String result = builder.build(false);\n+            builder.reset();\n+            return result;\n+        }\n+\n+        boolean codingError = builder.hasCodingErrors();\n+        if (codingError && !allowBadEncoding)\n+        {\n+            return builder.build(false);\n+        }\n+\n+        if (builder.replaceIncomplete() && !allowTruncatedEncoding)\n+        {\n+            return builder.build(false);\n+        }\n+\n+        String result = builder.build(true);\n+        builder.reset();\n+        return result;\n+    }\n+\n+    private void onNewField(String name, String value)\n+    {\n+        if (name == null || name.isEmpty())\n+            return;\n+        keyCount++;\n+        newFieldAdder.accept(name, value);\n+        if (maxKeys >= 0 && keyCount > maxKeys)\n+            throw new IllegalStateException(String.format(\""Form with too many keys [%d > %d]\"", keyCount, maxKeys));\n+    }\n+\n+    interface CharIterator\n+    {\n+        /**\n+         * Pull the next single character.\n+         *\n+         * <p>\n+         *     This method might block, depending on implementation.\n+         * </p>\n+         *\n+         * @return The character read, as an integer in the range 0 to 65535\n+         *         ({@code 0x00-0xffff}), or -1 if the end of the iterator\n+         *         has been reached (such as the end of a String or a stream EOF)\n+         */\n+        int next() throws IOException;\n+    }\n+\n+    static class CharSequenceCharIterator implements CharIterator\n+    {\n+        private final CharSequence str;\n+        private final int end;\n+        private int idx;\n+\n+        CharSequenceCharIterator(CharSequence str)\n+        {\n+            this(str, 0, str.length());\n+        }\n+\n+        CharSequenceCharIterator(CharSequence str, int offset, int length)\n+        {\n+            this.str = str;\n+            this.end = offset + length;\n+            this.idx = offset;\n+        }\n+\n+        @Override\n+        public int next()\n+        {\n+            if (idx >= end)\n+                return -1;\n+            return str.charAt(idx++);\n+        }\n+    }\n+\n+    static class StringCharIterator implements CharIterator\n+    {\n+        private final char[] str;\n+        private final int end;\n+        private int idx;\n+\n+        StringCharIterator(String str)\n+        {\n+            this(str, 0, str.length());\n+        }\n+\n+        StringCharIterator(String str, int offset, int length)\n+        {\n+            this.str = str.toCharArray();\n+            this.end = offset + length;\n+            this.idx = offset;\n+        }\n+\n+        @Override\n+        public int next()\n+        {\n+            if (idx >= end)\n+                return -1;\n+            return str[idx++];\n+        }\n+    }\n+\n+    static class ReaderCharIterator implements CharIterator\n+    {\n+        private final Reader reader;\n+        private final CharBuffer buffer;\n+\n+        ReaderCharIterator(Reader reader)\n+        {\n+            this.reader = reader;\n+            this.buffer = CharBuffer.allocate(128);\n+            this.buffer.flip();\n+        }\n+\n+        @Override\n+        public int next() throws IOException\n+        {\n+            if (!buffer.hasRemaining())\n+            {\n+                buffer.clear();\n+                if (reader.read(buffer) == -1)\n+                    return -1;\n+                buffer.flip();\n+            }\n+\n+            return buffer.get();\n+        }\n+    }\n+}\n\ndiff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/Utf8StringBuilder.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/Utf8StringBuilder.java\nindex 6be07aeae501..ba6d377a5aa9 100644\n--- a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/Utf8StringBuilder.java\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/Utf8StringBuilder.java\n@@ -14,13 +14,18 @@\n package org.eclipse.jetty.util;\n \n import java.io.IOException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n import java.nio.ByteBuffer;\n import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.CodingErrorAction;\n import java.util.function.Supplier;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static java.lang.invoke.MethodType.methodType;\n+\n /**\n  * <p>\n  * This class wraps a standard {@link StringBuilder} and provides methods to append\n@@ -46,8 +51,6 @@ public class Utf8StringBuilder implements CharsetStringBuilder\n     private static final int UTF8_ACCEPT = 0;\n     private static final int UTF8_REJECT = 12;\n \n-    protected int _state = UTF8_ACCEPT;\n-\n     private static final byte[] BYTE_TABLE =\n         {\n             // The first part of the table maps bytes to character classes that\n@@ -73,13 +76,40 @@ public class Utf8StringBuilder implements CharsetStringBuilder\n             12, 36, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12\n         };\n \n+    private static final MethodHandle REPORT;\n+    private static final MethodHandle REPLACE;\n+    private static final MethodHandle IGNORE;\n+\n+    static\n+    {\n+        try\n+        {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            REPORT = lookup.findVirtual(Utf8StringBuilder.class, \""errorActionReport\"", methodType(void.class));\n+            REPLACE = lookup.findVirtual(Utf8StringBuilder.class, \""errorActionReplace\"", methodType(void.class));\n+            IGNORE = lookup.findVirtual(Utf8StringBuilder.class, \""errorActionIgnore\"", methodType(void.class));\n+        }\n+        catch (NoSuchMethodException | IllegalAccessException e)\n+        {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    protected int _state = UTF8_ACCEPT;\n     final StringBuilder _buffer;\n+    private final MethodHandle _malformedInputMethod;\n+    private final MethodHandle _unmappableCharacterMethod;\n     private int _codep;\n     private boolean _codingErrors;\n \n     public Utf8StringBuilder()\n     {\n-        _buffer = new StringBuilder();\n+        this(new StringBuilder());\n+    }\n+\n+    public Utf8StringBuilder(CodingErrorAction onMalformedInput, CodingErrorAction onUnmappableCharacter)\n+    {\n+        this(new StringBuilder(), onMalformedInput, onUnmappableCharacter);\n     }\n \n     public Utf8StringBuilder(int capacity)\n@@ -88,8 +118,72 @@ public Utf8StringBuilder(int capacity)\n     }\n \n     protected Utf8StringBuilder(StringBuilder buffer)\n+    {\n+        this(buffer, CodingErrorAction.REPLACE, CodingErrorAction.REPLACE);\n+    }\n+\n+    protected Utf8StringBuilder(StringBuilder buffer, CodingErrorAction onMalformedInput, CodingErrorAction onUnmappableCharacter)\n     {\n         _buffer = buffer;\n+        _malformedInputMethod = getErrorAction(onMalformedInput);\n+        _unmappableCharacterMethod = getErrorAction(onUnmappableCharacter);\n+    }\n+\n+    private MethodHandle getErrorAction(CodingErrorAction codingErrorAction)\n+    {\n+        if (codingErrorAction == CodingErrorAction.REPORT)\n+            return REPORT;\n+\n+        if (codingErrorAction == CodingErrorAction.REPLACE)\n+            return REPLACE;\n+\n+        return IGNORE;\n+    }\n+\n+    private void errorActionReport()\n+    {\n+        throw new Utf8IllegalArgumentException();\n+    }\n+\n+    private void errorActionReplace()\n+    {\n+        bufferAppend(REPLACEMENT);\n+    }\n+\n+    private void errorActionIgnore()\n+    {\n+    }\n+\n+    private void handleMalformedInput()\n+    {\n+        try\n+        {\n+            _malformedInputMethod.invoke(this);\n+        }\n+        catch (RuntimeException e)\n+        {\n+            throw e;\n+        }\n+        catch (Throwable e)\n+        {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void handleUnmappableCharacter()\n+    {\n+        try\n+        {\n+            _unmappableCharacterMethod.invoke(this);\n+        }\n+        catch (RuntimeException e)\n+        {\n+            throw e;\n+        }\n+        catch (Throwable e)\n+        {\n+            throw new RuntimeException(e);\n+        }\n     }\n \n     @Override\n@@ -101,6 +195,7 @@ public int length()\n     /**\n      * @return {@code True} if the characters decoded have contained UTF8 coding errors.\n      */\n+    @Override\n     public boolean hasCodingErrors()\n     {\n         return _codingErrors;\n@@ -132,9 +227,9 @@ protected void checkCharAppend()\n     {\n         if (_state != UTF8_ACCEPT)\n         {\n-            bufferAppend(REPLACEMENT);\n             _state = UTF8_ACCEPT;\n             _codingErrors = true;\n+            handleMalformedInput();\n         }\n     }\n \n@@ -143,10 +238,10 @@ public boolean replaceIncomplete()\n         if (_state == UTF8_ACCEPT)\n             return false;\n \n-        bufferAppend(REPLACEMENT);\n         _state = UTF8_ACCEPT;\n         _codep = 0;\n         _codingErrors = true;\n+        handleMalformedInput();\n         return true;\n     }\n \n@@ -294,8 +389,8 @@ public void appendByte(byte b) throws IOException\n                 case UTF8_REJECT ->\n                 {\n                     _codep = 0;\n-                    bufferAppend(REPLACEMENT);\n                     _codingErrors = true;\n+                    handleUnmappableCharacter();\n                     if (_state != UTF8_ACCEPT)\n                     {\n                         _state = UTF8_ACCEPT;\n@@ -325,7 +420,7 @@ public void complete()\n             _codep = 0;\n             _state = UTF8_ACCEPT;\n             _codingErrors = true;\n-            bufferAppend(REPLACEMENT);\n+            handleMalformedInput();\n         }\n     }\n \n@@ -363,6 +458,22 @@ public String toCompleteString()\n         return _buffer.toString();\n     }\n \n+    /**\n+     * <p>Attempt to build the completed string and reset the buffer,\n+     * returning a partial string if there are encoding errors</p>\n+     *\n+     * @param allowPartialString true if a partial string is allowed to be returned,\n+     * false means if complete string cannot be returned, an exception is thrown.\n+     * @return The available string (complete or partial)\n+     * @throws CharacterCodingException (only if {@code allowPartialString} is false) thrown if the bytes cannot be correctly decoded or a multibyte sequence is incomplete.\n+     */\n+    @Override\n+    public String build(boolean allowPartialString) throws CharacterCodingException\n+    {\n+        complete();\n+        return takePartialString(allowPartialString ? () -> null : Utf8IllegalArgumentException::new);\n+    }\n+\n     /**\n      * Take the completely decoded string.\n      *\n@@ -425,7 +536,12 @@ public static class Utf8IllegalArgumentException extends IllegalArgumentExceptio\n     {\n         public Utf8IllegalArgumentException()\n         {\n-            super(new Utf8CharacterCodingException());\n+            this(new Utf8CharacterCodingException());\n+        }\n+\n+        public Utf8IllegalArgumentException(IOException cause)\n+        {\n+            super(cause);\n         }\n     }\n }\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/internal/NullAppendable.java b/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/internal/NullAppendable.java\nindex 212bb9edddf0..47bfae297d52 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/internal/NullAppendable.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-core-common/src/main/java/org/eclipse/jetty/websocket/core/internal/NullAppendable.java\n@@ -18,6 +18,15 @@\n \n import org.eclipse.jetty.util.Utf8StringBuilder;\n \n+/**\n+ * Null Buffer/Builder Appendable.\n+ * <p>\n+ *     Used by WebSocket implementation to both validate that incoming bytes conform\n+ *     to UTF-8 rules, and also to truncated incoming Strings or bytes at\n+ *     whole codepoints.  (Neither of which require the bytes being checked to be\n+ *     appended to an internal buffer)\n+ * </p>\n+ */\n public class NullAppendable extends Utf8StringBuilder\n {\n     public NullAppendable()\n@@ -25,6 +34,12 @@ public NullAppendable()\n         super(null);\n     }\n \n+    @Override\n+    public int length()\n+    {\n+        return 0;\n+    }\n+\n     @Override\n     public void append(CharSequence chars, int offset, int length)\n     {\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/FormFieldsTest.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/FormFieldsTest.java\nindex 3f9b2a88df4b..bc7b66199481 100644\n--- a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/FormFieldsTest.java\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/FormFieldsTest.java\n@@ -13,7 +13,6 @@\n \n package org.eclipse.jetty.server;\n \n-import java.nio.charset.CharacterCodingException;\n import java.nio.charset.Charset;\n import java.util.HashMap;\n import java.util.List;\n@@ -126,7 +125,7 @@ public static Stream<Arguments> invalidData()\n             Arguments.of(List.of(\""n%AH=v\""), UTF_8, -1, -1, IllegalArgumentException.class),\n             Arguments.of(List.of(\""n=v%AH\""), UTF_8, -1, -1, IllegalArgumentException.class),\n             Arguments.of(List.of(\""n=%%TOK%%\""), UTF_8, -1, -1, IllegalArgumentException.class),\n-            Arguments.of(List.of(\""n=v%FF\""), UTF_8, -1, -1, CharacterCodingException.class),\n+            Arguments.of(List.of(\""n=v%FF\""), UTF_8, -1, -1, IllegalArgumentException.class),\n             Arguments.of(List.of(\""a=0&b=1&c=2&d=4\""), UTF_8, 2, -1, IllegalStateException.class),\n             Arguments.of(List.of(\""a=0\"", \""&b=1&\"", \""c=\"", \""2&d=4\""), UTF_8, 2, -1, IllegalStateException.class),\n             Arguments.of(List.of(\""abcde=123456\""), UTF_8, -1, 10, IllegalStateException.class),\n\ndiff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java\nindex 822fa4d20cfd..69abaa045955 100644\n--- a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java\n@@ -871,7 +871,8 @@ public static Stream<Arguments> queryBehaviorsBadUtf8Allowed()\n     @MethodSource(\""queryBehaviorsBadUtf8Allowed\"")\n     public void testQueryExtractionBehaviorBadUtf8Allowed(String inputQuery, int expectedStatus, String expectedKey, String expectedValue) throws Exception\n     {\n-        UriCompliance uriCompliance = UriCompliance.DEFAULT.with(\""test\"", UriCompliance.Violation.BAD_UTF8_ENCODING, UriCompliance.Violation.BAD_PERCENT_ENCODING);\n+        UriCompliance uriCompliance = UriCompliance.DEFAULT.with(\""test\"", UriCompliance.Violation.BAD_UTF8_ENCODING,\n+            UriCompliance.Violation.BAD_PERCENT_ENCODING, UriCompliance.Violation.TRUNCATED_UTF8_ENCODING);\n         testQueryExtractionBehavior(uriCompliance, inputQuery, expectedStatus, expectedKey, expectedValue);\n     }\n \n\ndiff --git a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/URLEncodedTest.java b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/URLEncodedTest.java\nindex c6c2313d1b86..6281e0c9c6a9 100644\n--- a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/URLEncodedTest.java\n+++ b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/URLEncodedTest.java\n@@ -40,7 +40,6 @@\n /**\n  * URL Encoding / Decoding Tests\n  */\n-// @checkstyle-disable-check : AvoidEscapedUnicodeCharactersCheck\n public class URLEncodedTest\n {\n     @TestFactory\n@@ -96,10 +95,10 @@ public Iterator<DynamicTest> testUrlEncoded()\n         {\n             MultiMap<String> urlEncoded = new MultiMap<>();\n             urlEncoded.clear();\n-            UrlEncoded.decodeTo(\""Name4=V\\u0629lue+4%21\"", urlEncoded, UrlEncoded.ENCODING);\n+            UrlEncoded.decodeTo(\""Name4=V\u0629lue+4%21\"", urlEncoded, UrlEncoded.ENCODING);\n             assertEquals(1, urlEncoded.size(), \""encoded param size\"");\n             assertEquals(\""Name4=V%D8%A9lue+4%21\"", UrlEncoded.encode(urlEncoded, UrlEncoded.ENCODING, false), \""encoded encode\"");\n-            assertEquals(\""V\\u0629lue 4!\"", urlEncoded.getString(\""Name4\""), \""encoded get\"");\n+            assertEquals(\""V\u0629lue 4!\"", urlEncoded.getString(\""Name4\""), \""encoded get\"");\n         }));\n \n         tests.add(dynamicTest(\""encoded param 1\"", () ->\n@@ -168,7 +167,7 @@ public Iterator<DynamicTest> testUrlEncodedStream()\n                 {StandardCharsets.UTF_8.name(), null, \""%30\""},\n                 {StandardCharsets.ISO_8859_1.name(), StandardCharsets.ISO_8859_1.name(), \""%30\""},\n                 {StandardCharsets.UTF_8.name(), StandardCharsets.UTF_8.name(), \""%30\""},\n-                {StandardCharsets.UTF_16.name(), StandardCharsets.UTF_16.name(), \""%00%30\""},\n+                {StandardCharsets.UTF_16.name(), StandardCharsets.UTF_16.name(), \""%FE%FF%00%30\""},\n             };\n \n         // Note: \""%30\"" -> decode -> \""0\""\n@@ -180,7 +179,7 @@ public Iterator<DynamicTest> testUrlEncodedStream()\n             tests.add(dynamicTest(params[0] + \"">\"" + params[1] + \""|\"" + params[2],\n                 () ->\n                 {\n-                    try (ByteArrayInputStream in = new ByteArrayInputStream((\""name\\n=value+\"" + params[2] + \""&name1=&name2&n\\u00e3me3=value+3\"").getBytes(params[0])))\n+                    try (ByteArrayInputStream in = new ByteArrayInputStream((\""name\\n=value+\"" + params[2] + \""&name1=&name2&n\u00e3me3=value+3\"").getBytes(params[0])))\n                     {\n                         MultiMap<String> m = new MultiMap<>();\n                         UrlEncoded.decodeTo(in, m, params[1] == null ? null : Charset.forName(params[1]), -1, -1);\n@@ -188,7 +187,7 @@ public Iterator<DynamicTest> testUrlEncodedStream()\n                         assertThat(params[1] + \"" stream name\\\\n\"", m.getString(\""name\\n\""), is(\""value 0\""));\n                         assertThat(params[1] + \"" stream name1\"", m.getString(\""name1\""), is(\""\""));\n                         assertThat(params[1] + \"" stream name2\"", m.getString(\""name2\""), is(\""\""));\n-                        assertThat(params[1] + \"" stream n\\u00e3me3\"", m.getString(\""n\\u00e3me3\""), is(\""value 3\""));\n+                        assertThat(params[1] + \"" stream n\u00e3me3\"", m.getString(\""n\u00e3me3\""), is(\""value 3\""));\n                     }\n                 }\n             ));\n@@ -196,15 +195,17 @@ public Iterator<DynamicTest> testUrlEncodedStream()\n \n         if (java.nio.charset.Charset.isSupported(\""Shift_JIS\""))\n         {\n+            Charset jisCharset = Charset.forName(\""Shift_JIS\"");\n             tests.add(dynamicTest(\""Shift_JIS\"",\n                 () ->\n                 {\n-                    try (ByteArrayInputStream in2 = new ByteArrayInputStream(\""name=%83e%83X%83g\"".getBytes(StandardCharsets.ISO_8859_1)))\n+                    try (ByteArrayInputStream in2 = new ByteArrayInputStream(\""name=%82%B1%82%F1%82%C9%82%BF%82%CD\"".getBytes(jisCharset)))\n                     {\n                         MultiMap<String> m2 = new MultiMap<>();\n-                        UrlEncoded.decodeTo(in2, m2, Charset.forName(\""Shift_JIS\""), -1, -1);\n+                        UrlEncoded.decodeTo(in2, m2, jisCharset, -1, -1);\n+                        String helloInJapanese = \""\u3053\u3093\u306b\u3061\u306f\"";\n                         assertEquals(1, m2.size(), \""stream length\"");\n-                        assertEquals(\""\\u30c6\\u30b9\\u30c8\"", m2.getString(\""name\""), \""stream name\"");\n+                        assertEquals(helloInJapanese, m2.getString(\""name\""), \""stream name\"");\n                     }\n                 }\n             ));\n@@ -253,7 +254,7 @@ public void testUtf8MultiByteCodePoint()\n         // Should be \""test\u00e4\""\n         // \""test\"" followed by a LATIN SMALL LETTER A WITH DIAERESIS\n \n-        String expected = \""test\\u00e4\"";\n+        String expected = \""test\u00e4\"";\n         assertThat(urlEncoded.getString(\""text\""), is(expected));\n     }\n \n\ndiff --git a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlParameterDecoderTest.java b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlParameterDecoderTest.java\nnew file mode 100644\nindex 000000000000..acfc4ef85544\n--- /dev/null\n+++ b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlParameterDecoderTest.java\n@@ -0,0 +1,666 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CodingErrorAction;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static java.nio.charset.StandardCharsets.UTF_16;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+\n+public class UrlParameterDecoderTest\n+{\n+    @Test\n+    public void testCharSequenceCharIterator() throws IOException\n+    {\n+        UrlParameterDecoder.CharIterator iter = new UrlParameterDecoder.CharSequenceCharIterator(\""Hello\"");\n+        StringBuilder output = new StringBuilder();\n+\n+        int i;\n+        while ((i = iter.next()) >= 0)\n+        {\n+            output.append((char)i);\n+        }\n+        assertEquals(\""Hello\"", output.toString());\n+    }\n+\n+    @Test\n+    public void testStringCharIterator() throws IOException\n+    {\n+        UrlParameterDecoder.CharIterator iter = new UrlParameterDecoder.StringCharIterator(\""Hello\"");\n+        StringBuilder output = new StringBuilder();\n+\n+        int i;\n+        while ((i = iter.next()) >= 0)\n+        {\n+            output.append((char)i);\n+        }\n+        assertEquals(\""Hello\"", output.toString());\n+    }\n+\n+    @Test\n+    public void testReaderCharIterator() throws IOException\n+    {\n+        Reader reader = new StringReader(\""Hello\"");\n+        UrlParameterDecoder.CharIterator iter = new UrlParameterDecoder.ReaderCharIterator(reader);\n+        StringBuilder output = new StringBuilder();\n+\n+        int i;\n+        while ((i = iter.next()) >= 0)\n+        {\n+            output.append((char)i);\n+        }\n+        assertEquals(\""Hello\"", output.toString());\n+    }\n+\n+    @Test\n+    public void testBasic()\n+        throws Exception\n+    {\n+        Fields fields = new Fields();\n+\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(UTF_8);\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add);\n+\n+        String input = \""a=b&c=d\"";\n+        decoder.parse(input);\n+\n+        assertEquals(\""b\"", fields.getValue(\""a\""));\n+        assertEquals(\""d\"", fields.getValue(\""c\""));\n+    }\n+\n+    @Test\n+    public void testManyPctEncoding()\n+        throws Exception\n+    {\n+        Fields fields = new Fields();\n+\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(UTF_8);\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add);\n+\n+        String input = \""text=%E0%B8%9F%E0%B8%AB%E0%B8%81%E0%B8%A7%E0%B8%94%E0%B8%B2%E0%B9%88%E0%B8%81%E0%B8%9F%E0%B8%A7%E0%B8%AB%E0%B8%AA%E0%B8%94%E0%B8%B2%E0%B9%88%E0%B8%AB%E0%B8%9F%E0%B8%81%E0%B8%A7%E0%B8%94%E0%B8%AA%E0%B8%B2%E0%B8%9F%E0%B8%81%E0%B8%AB%E0%B8%A3%E0%B8%94%E0%B9%89%E0%B8%9F%E0%B8%AB%E0%B8%99%E0%B8%81%E0%B8%A3%E0%B8%94%E0%B8%B5&Action=Submit\"";\n+        decoder.parse(input);\n+\n+        String hex = \""E0B89FE0B8ABE0B881E0B8A7E0B894E0B8B2E0B988E0B881E0B89FE0B8A7E0B8ABE0B8AAE0B894E0B8B2E0B988E0B8ABE0B89FE0B881E0B8A7E0B894E0B8AAE0B8B2E0B89FE0B881E0B8ABE0B8A3E0B894E0B989E0B89FE0B8ABE0B899E0B881E0B8A3E0B894E0B8B5\"";\n+        String expected = new String(StringUtil.fromHexString(hex), UTF_8);\n+        assertEquals(expected, fields.getValue(\""text\""));\n+    }\n+\n+    @Test\n+    public void testUtf8MultiByteCodePoint() throws IOException\n+    {\n+        Fields fields = new Fields();\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(UTF_8);\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add);\n+\n+        String input = \""text=test%C3%A4\"";\n+        decoder.parse(input);\n+\n+        // http://www.ltg.ed.ac.uk/~richard/utf-8.cgi?input=00e4&mode=hex\n+        // Should be \""test\u00e4\""\n+        // \""test\"" followed by a LATIN SMALL LETTER A WITH DIAERESIS\n+\n+        String expected = \""test\u00e4\"";\n+        assertThat(fields.getValue(\""text\""), is(expected));\n+    }\n+\n+    public static Stream<Arguments> invalidTestData()\n+    {\n+        List<Arguments> cases = new ArrayList<>();\n+\n+        List<Charset> charsets = List.of(UTF_8, ISO_8859_1, US_ASCII, Charset.forName(\""Shift-JIS\""));\n+        // First test fundamentally bad pct-encoding issues against several charsets\n+        // It shouldn't matter what the charset is here, as the issue happens before\n+        // the charset is even involved.\n+        for (Charset charset : charsets)\n+        {\n+            cases.add(Arguments.of(charset, \""Name=xx%zzyy\"", IllegalArgumentException.class));\n+            cases.add(Arguments.of(charset, \""Name=%E%F%F\"", IllegalArgumentException.class));\n+            cases.add(Arguments.of(charset, \""Name=x%\"", IllegalArgumentException.class));\n+            cases.add(Arguments.of(charset, \""Name=x%2\"", IllegalArgumentException.class));\n+            cases.add(Arguments.of(charset, \""Name=xxx%\"", IllegalArgumentException.class));\n+        }\n+\n+        // Complete pct-encoding sequences that some charsets do not like\n+        for (Charset charset : List.of(UTF_8, US_ASCII))\n+        {\n+            cases.add(Arguments.of(charset, \""Name=%FF%FF%FF\"", IllegalArgumentException.class));\n+            cases.add(Arguments.of(charset, \""Name=%EF%EF%EF\"", IllegalArgumentException.class));\n+            cases.add(Arguments.of(charset, \""name=X%c0%afZ\"", IllegalArgumentException.class));\n+        }\n+\n+        // Next add specific cases for specific charsets.\n+        // Euro unicode not allowed in US_ASCII\n+        cases.add(Arguments.of(US_ASCII, \""Name=euro%E2%82%AC\"", IllegalArgumentException.class));\n+        // Byte 0x80 unicode not allowed in US_ASCII\n+        cases.add(Arguments.of(US_ASCII, \""Name=%80x\"", IllegalArgumentException.class));\n+\n+        return cases.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""invalidTestData\"")\n+    public <X extends Throwable> void testInvalidDecode(Charset charset, String input, Class<X> expectedThrowableType)\n+    {\n+        assertThrows(expectedThrowableType, () ->\n+        {\n+            Fields fields = new Fields();\n+            CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(charset);\n+            UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add);\n+            decoder.parse(input);\n+            System.out.println(\""fields=\"" + fields);\n+        });\n+    }\n+\n+    /**\n+     * Example of a parameter with raw UTF-8 unicode which isn't pct-encoded.\n+     */\n+    @Test\n+    public void testBadlyEncodedValue() throws IOException\n+    {\n+        Fields fields = new Fields();\n+        CharsetStringBuilder charsetStringBuilder = new Utf8StringBuilder();\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add);\n+        String input = \""Name=Euro-\u20ac-Symbol\"";\n+        decoder.parse(input);\n+        assertThat(\""Field count\"", fields.getSize(), is(1));\n+        Fields.Field field = fields.get(\""Name\"");\n+        assertNotNull(field, \""Fields[Name]\"");\n+        assertEquals(\""Euro-\u20ac-Symbol\"", field.getValue(), \""Fields[Name]\"");\n+    }\n+\n+    @Test\n+    public void testUtf16EncodedString() throws IOException\n+    {\n+        Fields fields = new Fields();\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(UTF_16);\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add);\n+        String input = \""name\\n=value+%FE%FF%00%30&name1=&name2&n\u00e3me3=value+3\"";\n+        decoder.parse(input);\n+\n+        assertThat(\""Field count\"", fields.getSize(), is(4));\n+        Fields.Field field = fields.get(\""name\\n\"");\n+        assertNotNull(field, \""Fields[name\\\\n]\"");\n+        assertEquals(\""value 0\"", field.getValue(), \""Fields[name\\\\n]\"");\n+\n+        field = fields.get(\""name1\"");\n+        assertNotNull(field, \""Fields[name1]\"");\n+        assertEquals(\""\"", field.getValue(), \""Fields[name1]\"");\n+\n+        field = fields.get(\""name2\"");\n+        assertNotNull(field, \""Fields[name2]\"");\n+        assertEquals(\""\"", field.getValue(), \""Fields[name2]\"");\n+\n+        field = fields.get(\""n\u00e3me3\"");\n+        assertNotNull(field, \""Fields[n\u00e3me3]\"");\n+        assertEquals(\""value 3\"", field.getValue(), \""Fields[n\u00e3me3]\"");\n+    }\n+\n+    public static Stream<Arguments> queryBehaviorsBadUtf8Allowed()\n+    {\n+        List<Arguments> cases = new ArrayList<>();\n+\n+        // Normal cases\n+        cases.add(Arguments.of(\""param=aaa\"", Map.of(\""param\"", \""aaa\"")));\n+        cases.add(Arguments.of(\""param=aaa&other=foo\"", Map.of(\""param\"", \""aaa\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=\"", Map.of(\""param\"", \""\"")));\n+        cases.add(Arguments.of(\""param=&other=foo\"", Map.of(\""param\"", \""\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=%E2%9C%94\"", Map.of(\""param\"", \""\u2714\"")));\n+        cases.add(Arguments.of(\""param=%E2%9C%94&other=foo\"", Map.of(\""param\"", \""\u2714\"", \""other\"", \""foo\"")));\n+\n+        // Truncated / Insufficient Hex cases\n+        cases.add(Arguments.of(\""param=%E2%9C%9\"", Map.of(\""param\"", \""\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%E2%9C%9&other=foo\"", Map.of(\""param\"", \""\ufffd\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=%E2%9C%\"", Map.of(\""param\"", \""\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%E2%9C%&other=foo\"", Map.of(\""param\"", \""\ufffd\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=%E2%9C\"", Map.of(\""param\"", \""\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%E2%9C&other=foo\"", Map.of(\""param\"", \""\ufffd\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=%E2%9\"", Map.of(\""param\"", \""\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%E2%9&other=foo\"", Map.of(\""param\"", \""\ufffd\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=%E2%\"", Map.of(\""param\"", \""\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%E2%&other=foo\"", Map.of(\""param\"", \""\ufffd\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=%E2\"", Map.of(\""param\"", \""\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%E2&other=foo\"", Map.of(\""param\"", \""\ufffd\"", \""other\"", \""foo\"")));\n+\n+        // Tokenized cases\n+        cases.add(Arguments.of(\""param=%%TOK%%\"", Map.of(\""param\"", \""%%TOK%%\"")));\n+        cases.add(Arguments.of(\""param=%%TOK%%&other=foo\"", Map.of(\""param\"", \""%%TOK%%\"", \""other\"", \""foo\"")));\n+\n+        // Bad Hex\n+        cases.add(Arguments.of(\""param=%xx\"", Map.of(\""param\"", \""%xx\"")));\n+        cases.add(Arguments.of(\""param=%xx&other=foo\"", Map.of(\""param\"", \""%xx\"", \""other\"", \""foo\"")));\n+\n+        // Overlong UTF-8 Encoding\n+        cases.add(Arguments.of(\""param=%C0%AF\"", Map.of(\""param\"", \""\ufffd\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%C0%AF&other=foo\"", Map.of(\""param\"", \""\ufffd\ufffd\"", \""other\"", \""foo\"")));\n+\n+        // Out of range\n+        cases.add(Arguments.of(\""param=%F4%90%80%80\"", Map.of(\""param\"", \""\ufffd\ufffd\ufffd\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%F4%90%80%80&other=foo\"", Map.of(\""param\"", \""\ufffd\ufffd\ufffd\ufffd\"", \""other\"", \""foo\"")));\n+\n+        // Long surrogate\n+        cases.add(Arguments.of(\""param=%ED%A0%80\"", Map.of(\""param\"", \""\ufffd\ufffd\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%ED%A0%80&other=foo\"", Map.of(\""param\"", \""\ufffd\ufffd\ufffd\"", \""other\"", \""foo\"")));\n+\n+        // Standalone continuations\n+        cases.add(Arguments.of(\""param=%80\"", Map.of(\""param\"", \""\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%80&other=foo\"", Map.of(\""param\"", \""\ufffd\"", \""other\"", \""foo\"")));\n+\n+        // Truncated sequence\n+        cases.add(Arguments.of(\""param=%E2%82\"", Map.of(\""param\"", \""\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%E2%82&other=foo\"", Map.of(\""param\"", \""\ufffd\"", \""other\"", \""foo\"")));\n+\n+        // C1 never starts UTF-8\n+        cases.add(Arguments.of(\""param=%C1%BF\"", Map.of(\""param\"", \""\ufffd\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%C1%BF&other=foo\"", Map.of(\""param\"", \""\ufffd\ufffd\"", \""other\"", \""foo\"")));\n+\n+        // E0 must be followed by A0-BF\n+        cases.add(Arguments.of(\""param=%E0%9F%80\"", Map.of(\""param\"", \""\ufffd\ufffd\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%E0%9F%80&other=foo\"", Map.of(\""param\"", \""\ufffd\ufffd\ufffd\"", \""other\"", \""foo\"")));\n+\n+        // Community Examples\n+        cases.add(Arguments.of(\""param=f_%e0%b8\"", Map.of(\""param\"", \""f_\ufffd\"")));\n+        cases.add(Arguments.of(\""param=f_%e0%b8&other=foo\"", Map.of(\""param\"", \""f_\ufffd\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=%x\"", Map.of(\""param\"", \""%x\"")));\n+        cases.add(Arguments.of(\""param=%\u00a3\"", Map.of(\""param\"", \""%\u00a3\"")));\n+        cases.add(Arguments.of(\""param=%x&other=foo\"", Map.of(\""param\"", \""%x\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=%\u00a3&other=foo\"", Map.of(\""param\"", \""%\u00a3\"", \""other\"", \""foo\"")));\n+\n+        // Extra ampersands\n+        cases.add(Arguments.of(\""param=aaa&&&\"", Map.of(\""param\"", \""aaa\"")));\n+        cases.add(Arguments.of(\""&&&param=aaa\"", Map.of(\""param\"", \""aaa\"")));\n+        cases.add(Arguments.of(\""&&param=aaa&&other=foo\"", Map.of(\""param\"", \""aaa\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=aaa&&other=foo&&\"", Map.of(\""param\"", \""aaa\"", \""other\"", \""foo\"")));\n+\n+        // Encoded ampersands\n+        cases.add(Arguments.of(\""param=aaa%26&other=foo\"", Map.of(\""param\"", \""aaa&\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=aaa&%26other=foo\"", Map.of(\""param\"", \""aaa\"", \""&other\"", \""foo\"")));\n+\n+        // pct-encoded parameter names (\""\u5e3d\u5b50\"" means \""hat\"" in japanese)\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%90=Beret\"", Map.of(\""\u5e3d\u5b50\"", \""Beret\"")));\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%90=Beret&other=foo\"", Map.of(\""\u5e3d\u5b50\"", \""Beret\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""other=foo&%E5%B8%BD%E5%AD%90=Beret\"", Map.of(\""\u5e3d\u5b50\"", \""Beret\"", \""other\"", \""foo\"")));\n+\n+        // bad pct-encoded parameter names\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%9=Beret\"", Map.of(\""\u5e3d\ufffd\"", \""Beret\"")));\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%=Beret\"", Map.of(\""\u5e3d\ufffd\"", \""Beret\"")));\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD=Beret\"", Map.of(\""\u5e3d\ufffd\"", \""Beret\"")));\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%9=Beret&other=foo\"", Map.of(\""\u5e3d\ufffd\"", \""Beret\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%=Beret&other=foo\"", Map.of(\""\u5e3d\ufffd\"", \""Beret\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD=Beret&other=foo\"", Map.of(\""\u5e3d\ufffd\"", \""Beret\"", \""other\"", \""foo\"")));\n+\n+        return cases.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""queryBehaviorsBadUtf8Allowed\"")\n+    public void testQueryBehaviorsBadUtf8Allowed(String input, Map<String, String> expectedParams) throws IOException\n+    {\n+        Fields fields = new Fields();\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(UTF_8, CodingErrorAction.REPLACE, CodingErrorAction.REPLACE);\n+        boolean allowBadEncoding = true;\n+        boolean allowBadPercent = true;\n+        boolean allowTruncatedEncoding = true;\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add, -1, -1, allowBadEncoding, allowBadPercent, allowTruncatedEncoding);\n+\n+        decoder.parse(input);\n+\n+        assertThat(\""Field count\"", fields.getSize(), is(expectedParams.size()));\n+\n+        for (String key : expectedParams.keySet())\n+        {\n+            Fields.Field field = fields.get(key);\n+            String message = \""Fields[%s]\"".formatted(key);\n+            assertNotNull(field, message);\n+            assertEquals(expectedParams.get(key), field.getValue(), message);\n+        }\n+    }\n+\n+    /**\n+     * The set of allowed query string behaviors collected from Jetty 11.\n+     */\n+    public static Stream<Arguments> queryBehaviorsLegacyAllowed()\n+    {\n+        List<Arguments> cases = new ArrayList<>();\n+\n+        // Normal cases\n+        cases.add(Arguments.of(\""param=aaa\"", Map.of(\""param\"", \""aaa\"")));\n+        cases.add(Arguments.of(\""param=aaa&other=foo\"", Map.of(\""param\"", \""aaa\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=\"", Map.of(\""param\"", \""\"")));\n+        cases.add(Arguments.of(\""param=&other=foo\"", Map.of(\""param\"", \""\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=%E2%9C%94\"", Map.of(\""param\"", \""\u2714\"")));\n+        cases.add(Arguments.of(\""param=%E2%9C%94&other=foo\"", Map.of(\""param\"", \""\u2714\"", \""other\"", \""foo\"")));\n+\n+        // Truncated / Insufficient Hex cases\n+        cases.add(Arguments.of(\""param=%E2%9C\"", Map.of(\""param\"", \""\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%E2%9C&other=foo\"", Map.of(\""param\"", \""\ufffd\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=%E2\"", Map.of(\""param\"", \""\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%E2&other=foo\"", Map.of(\""param\"", \""\ufffd\"", \""other\"", \""foo\"")));\n+\n+        // Truncated sequence\n+        cases.add(Arguments.of(\""param=%E2%82\"", Map.of(\""param\"", \""\ufffd\"")));\n+        cases.add(Arguments.of(\""param=%E2%82&other=foo\"", Map.of(\""param\"", \""\ufffd\"", \""other\"", \""foo\"")));\n+\n+        // Community Examples\n+        cases.add(Arguments.of(\""param=f_%e0%b8\"", Map.of(\""param\"", \""f_\ufffd\"")));\n+        cases.add(Arguments.of(\""param=f_%e0%b8&other=foo\"", Map.of(\""param\"", \""f_\ufffd\"", \""other\"", \""foo\"")));\n+\n+        // Extra ampersands\n+        cases.add(Arguments.of(\""param=aaa&&&\"", Map.of(\""param\"", \""aaa\"")));\n+        cases.add(Arguments.of(\""&&&param=aaa\"", Map.of(\""param\"", \""aaa\"")));\n+        cases.add(Arguments.of(\""&&param=aaa&&other=foo\"", Map.of(\""param\"", \""aaa\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=aaa&&other=foo&&\"", Map.of(\""param\"", \""aaa\"", \""other\"", \""foo\"")));\n+\n+        // Encoded ampersands\n+        cases.add(Arguments.of(\""param=aaa%26&other=foo\"", Map.of(\""param\"", \""aaa&\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""param=aaa&%26other=foo\"", Map.of(\""param\"", \""aaa\"", \""&other\"", \""foo\"")));\n+\n+        // pct-encoded parameter names (\""\u5e3d\u5b50\"" means \""hat\"" in japanese)\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%90=Beret\"", Map.of(\""\u5e3d\u5b50\"", \""Beret\"")));\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%90=Beret&other=foo\"", Map.of(\""\u5e3d\u5b50\"", \""Beret\"", \""other\"", \""foo\"")));\n+        cases.add(Arguments.of(\""other=foo&%E5%B8%BD%E5%AD%90=Beret\"", Map.of(\""\u5e3d\u5b50\"", \""Beret\"", \""other\"", \""foo\"")));\n+\n+        // truncated pct-encoded parameter names\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD=Beret\"", Map.of(\""\u5e3d\ufffd\"", \""Beret\"")));\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD=Beret&other=foo\"", Map.of(\""\u5e3d\ufffd\"", \""Beret\"", \""other\"", \""foo\"")));\n+\n+        // raw unicode parameter names (strange replacement logic here)\n+        cases.add(Arguments.of(\""\u20ac=currency\"", Map.of(\""\u20ac\"", \""currency\"")));\n+        cases.add(Arguments.of(\""\u5e3d\u5b50=Beret\"", Map.of(\""\u5e3d\u5b50\"", \""Beret\"")));\n+\n+        return cases.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""queryBehaviorsLegacyAllowed\"")\n+    public void testQueryBehaviorsLegacyAllowed(String input, Map<String, String> expectedParams) throws IOException\n+    {\n+        Fields fields = new Fields();\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(UTF_8, CodingErrorAction.REPLACE, CodingErrorAction.REPORT);\n+        boolean allowBadEncoding = false;\n+        boolean allowBadPercent = false;\n+        boolean allowTruncatedEncoding = true;\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add, -1, -1, allowBadEncoding, allowBadPercent, allowTruncatedEncoding);\n+\n+        decoder.parse(input);\n+\n+        assertThat(\""Field count\"", fields.getSize(), is(expectedParams.size()));\n+\n+        for (String key : expectedParams.keySet())\n+        {\n+            Fields.Field field = fields.get(key);\n+            String message = \""Fields[%s]\"".formatted(key);\n+            assertNotNull(field, message);\n+            assertEquals(expectedParams.get(key), field.getValue(), message);\n+        }\n+    }\n+\n+    /**\n+     * The set of rejected query string behaviors collected from Jetty 11.\n+     */\n+    public static Stream<Arguments> queryBehaviorsLegacyRejected()\n+    {\n+        List<Arguments> cases = new ArrayList<>();\n+\n+        // Truncated / Insufficient Hex cases\n+        cases.add(Arguments.of(\""param=%E2%9C%9\""));\n+        cases.add(Arguments.of(\""param=%E2%9C%9&other=foo\""));\n+        cases.add(Arguments.of(\""param=%E2%9C%\""));\n+        cases.add(Arguments.of(\""param=%E2%9C%&other=foo\""));\n+        cases.add(Arguments.of(\""param=%E2%9\""));\n+        cases.add(Arguments.of(\""param=%E2%9&other=foo\""));\n+        cases.add(Arguments.of(\""param=%E2%\""));\n+        cases.add(Arguments.of(\""param=%E2%&other=foo\""));\n+\n+        // Tokenized cases\n+        cases.add(Arguments.of(\""param=%%TOK%%\""));\n+        cases.add(Arguments.of(\""param=%%TOK%%&other=foo\""));\n+\n+        // Bad Hex\n+        cases.add(Arguments.of(\""param=%xx\""));\n+        cases.add(Arguments.of(\""param=%xx&other=foo\""));\n+\n+        // Overlong UTF-8 Encoding\n+        cases.add(Arguments.of(\""param=%C0%AF\""));\n+        cases.add(Arguments.of(\""param=%C0%AF&other=foo\""));\n+\n+        // Out of range\n+        cases.add(Arguments.of(\""param=%F4%90%80%80\""));\n+        cases.add(Arguments.of(\""param=%F4%90%80%80&other=foo\""));\n+\n+        // Long surrogate\n+        cases.add(Arguments.of(\""param=%ED%A0%80\""));\n+        cases.add(Arguments.of(\""param=%ED%A0%80&other=foo\""));\n+\n+        // Standalone continuations\n+        cases.add(Arguments.of(\""param=%80\""));\n+        cases.add(Arguments.of(\""param=%80&other=foo\""));\n+\n+        // C1 never starts UTF-8\n+        cases.add(Arguments.of(\""param=%C1%BF\""));\n+        cases.add(Arguments.of(\""param=%C1%BF&other=foo\""));\n+\n+        // E0 must be followed by A0-BF\n+        cases.add(Arguments.of(\""param=%E0%9F%80\""));\n+        cases.add(Arguments.of(\""param=%E0%9F%80&other=foo\""));\n+\n+        // Community Examples\n+        cases.add(Arguments.of(\""param=%\u00a3\""));\n+        cases.add(Arguments.of(\""param=%\u00a3&other=foo\""));\n+\n+        // truncated pct-encoded parameter names\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%9=Beret\"")); // Not LEGACY\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%=Beret\""));\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%9=Beret&other=foo\"")); // Not LEGACY\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%=Beret&other=foo\""));\n+\n+        // invalid pct-encoded parameter name\n+        cases.add(Arguments.of(\""foo%xx=abc\""));\n+        cases.add(Arguments.of(\""foo%x=abc\""));\n+        cases.add(Arguments.of(\""foo%=abc\""));\n+\n+        // utf-16 values (LEGACY has UTF16_ENCODINGS enabled, but it doesn't work for query apparently)\n+        cases.add(Arguments.of(\""foo=a%u2192z\""));\n+\n+        // truncated utf-16 values (LEGACY has UTF16_ENCODINGS enabled, but it doesn't work for query apparently)\n+        cases.add(Arguments.of(\""foo=a%u219z\""));\n+\n+        return cases.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""queryBehaviorsLegacyRejected\"")\n+    public void testQueryBehaviorsLegacyRejected(String input)\n+    {\n+        Fields fields = new Fields();\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(UTF_8, CodingErrorAction.REPLACE, CodingErrorAction.REPORT);\n+        boolean allowBadEncoding = false;\n+        boolean allowBadPercent = false;\n+        boolean allowTruncatedEncoding = true;\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add, -1, -1, allowBadEncoding, allowBadPercent, allowTruncatedEncoding);\n+\n+        assertThrows(IllegalArgumentException.class, () -> decoder.parse(input));\n+    }\n+\n+    @Test\n+    public void testShiftJisEncodedString() throws IOException\n+    {\n+        assumeTrue(java.nio.charset.Charset.isSupported(\""Shift_JIS\""));\n+\n+        Fields fields = new Fields();\n+        Charset japaneseCharset = Charset.forName(\""Shift_JIS\"");\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(japaneseCharset);\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add);\n+        String input = \""name=%82%B1%82%F1%82%C9%82%BF%82%CD\"";\n+        decoder.parse(input);\n+\n+        String helloInJapanese = \""\u3053\u3093\u306b\u3061\u306f\"";\n+\n+        assertThat(\""Field count\"", fields.getSize(), is(1));\n+        Fields.Field field = fields.get(\""name\"");\n+        assertNotNull(field, \""Fields[name]\"");\n+        assertEquals(helloInJapanese, field.getValue(), \""Fields[name\\\\n]\"");\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource(delimiter = '|', useHeadersInDisplayName = false,\n+        textBlock = \""\""\""\n+            # query         | expectedName | expectedValue\n+            a=bad_%e0%b     | a            | bad_\ufffd\n+            b=bad_%e0%ba    | b            | bad_\ufffd\n+            c=short%a       | c            | short%a\n+            d=b%aam         | d            | b\ufffdm\n+            e=%%TOK%%       | e            | %%TOK%%\n+            f=%aardvark     | f            | \ufffdrdvark\n+            g=b%ar          | g            | b%ar\n+            h=end%          | h            | end%\n+            # This shows how the '&' symbol does not get swallowed by a bad pct-encoding.\n+            i=%&z=2         | i            | %\n+            \""\""\"")\n+    public void testDecodeAllowBadSequence(String query, String expectedName, String expectedValue) throws IOException\n+    {\n+        Fields fields = new Fields();\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(UTF_8, CodingErrorAction.REPLACE, CodingErrorAction.REPLACE);\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add, -1, -1, true, true, true);\n+        decoder.parse(query);\n+        Fields.Field field = fields.get(expectedName);\n+        assertThat(\""Name exists\"", field, notNullValue());\n+        assertThat(\""Value\"", field.getValue(), is(expectedValue));\n+    }\n+\n+    public static Stream<Arguments> incompleteSequenceCases()\n+    {\n+        List<Arguments> cases = new ArrayList<>();\n+\n+        // Incomplete sequence at the end\n+        byte[] bytes = {'a', 'b', '=', 'c', -50};\n+        Map<String, String> expected = new HashMap<>();\n+        expected.put(\""ab\"", \""c\"" + Utf8StringBuilder.REPLACEMENT);\n+        cases.add(Arguments.of(bytes, expected));\n+\n+        // Incomplete sequence at the end 2\n+        bytes = new byte[]{'a', 'b', '=', -50};\n+        expected = new HashMap<>();\n+        expected.put(\""ab\"", \""\"" + Utf8StringBuilder.REPLACEMENT);\n+        cases.add(Arguments.of(bytes, expected));\n+\n+        // Incomplete sequence in name\n+        bytes = new byte[]{'e', -50, '=', 'f', 'g', '&', 'a', 'b', '=', 'c', 'd'};\n+        expected = new HashMap<>();\n+        expected.put(\""e\"" + Utf8StringBuilder.REPLACEMENT, \""fg\"");\n+        expected.put(\""ab\"", \""cd\"");\n+        cases.add(Arguments.of(bytes, expected));\n+\n+        // Incomplete sequence in value\n+        bytes = new byte[]{'e', 'f', '=', 'g', -50, '&', 'a', 'b', '=', 'c', 'd'};\n+        expected = new HashMap<>();\n+        expected.put(\""ef\"", \""g\"" + Utf8StringBuilder.REPLACEMENT);\n+        expected.put(\""ab\"", \""cd\"");\n+        cases.add(Arguments.of(bytes, expected));\n+\n+        return cases.stream();\n+    }\n+\n+    /**\n+     * Default UrlDecoder behavior with incomplete sequences.\n+     */\n+    @ParameterizedTest\n+    @MethodSource(\""incompleteSequenceCases\"")\n+    public void testUtf8IncompleteSequenceDefault(byte[] input, Map<String, String> expected) throws IOException\n+    {\n+        Fields fields = new Fields();\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(UTF_8);\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add);\n+\n+        String s = new String(input, UTF_8);\n+        decoder.parse(s);\n+        assertThat(\""Field count\"", fields.getSize(), is(expected.size()));\n+        for (String expectedKey : expected.keySet())\n+        {\n+            String message = \""Field[%s]\"".formatted(expectedKey);\n+            Fields.Field field = fields.get(expectedKey);\n+            assertNotNull(field, message);\n+            assertEquals(expected.get(expectedKey), field.getValue(), message);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""incompleteSequenceCases\"")\n+    public void testUtf8IncompleteSequenceAllowedAsString(byte[] input, Map<String, String> expected) throws Exception\n+    {\n+        Fields fields = new Fields();\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(UTF_8, CodingErrorAction.REPLACE, CodingErrorAction.REPLACE);\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add, -1, -1, true, true, true);\n+\n+        String s = new String(input, UTF_8);\n+        decoder.parse(s);\n+\n+        assertThat(\""Field count\"", fields.getSize(), is(expected.size()));\n+        for (String expectedKey : expected.keySet())\n+        {\n+            String message = \""Field[%s]\"".formatted(expectedKey);\n+            Fields.Field field = fields.get(expectedKey);\n+            assertNotNull(field, message);\n+            assertEquals(expected.get(expectedKey), field.getValue(), message);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""incompleteSequenceCases\"")\n+    public void testUtf8IncompleteSequenceAllowedAsInputStream(byte[] input, Map<String, String> expected) throws Exception\n+    {\n+        Fields fields = new Fields();\n+        CharsetStringBuilder charsetStringBuilder = CharsetStringBuilder.forCharset(UTF_8, CodingErrorAction.REPLACE, CodingErrorAction.REPLACE);\n+        UrlParameterDecoder decoder = new UrlParameterDecoder(charsetStringBuilder, fields::add, -1, -1, true, true, true);\n+\n+        try (InputStream is = new ByteArrayInputStream(input))\n+        {\n+            decoder.parse(is, UTF_8);\n+\n+            assertThat(\""Field count\"", fields.getSize(), is(expected.size()));\n+            for (String expectedKey : expected.keySet())\n+            {\n+                String message = \""Field[%s]\"".formatted(expectedKey);\n+                Fields.Field field = fields.get(expectedKey);\n+                assertNotNull(field, message);\n+                assertEquals(expected.get(expectedKey), field.getValue(), message);\n+            }\n+        }\n+    }\n+}\n\ndiff --git a/tests/jetty-jmh/src/main/java/org/eclipse/jetty/util/UrlParameterDecoderBenchmark.java b/tests/jetty-jmh/src/main/java/org/eclipse/jetty/util/UrlParameterDecoderBenchmark.java\nnew file mode 100644\nindex 000000000000..1fbe3106f037\n--- /dev/null\n+++ b/tests/jetty-jmh/src/main/java/org/eclipse/jetty/util/UrlParameterDecoderBenchmark.java\n@@ -0,0 +1,150 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiConsumer;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+@State(Scope.Benchmark)\n+@Threads(1)\n+@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+public class UrlParameterDecoderBenchmark\n+{\n+    private static final String SMALL_STRING = \""param=aaa&other=foo\"";\n+    private static final int SMALL_LENGTH = SMALL_STRING.length();\n+    private static final byte[] SMALL_BYTES = SMALL_STRING.getBytes(UTF_8);\n+    private static final String LARGE_STRING = \""text=%E0%B8%9F%E0%B8%AB%E0%B8%81%E0%B8%A7%E0%B8%94%E0%B8%B2%E0%B9%88%E0%B8%81%E0%B8%9F%E0%B8%A7%E0%B8%AB%E0%B8%AA%E0%B8%94%E0%B8%B2%E0%B9%88%E0%B8%AB%E0%B8%9F%E0%B8%81%E0%B8%A7%E0%B8%94%E0%B8%AA%E0%B8%B2%E0%B8%9F%E0%B8%81%E0%B8%AB%E0%B8%A3%E0%B8%94%E0%B9%89%E0%B8%9F%E0%B8%AB%E0%B8%99%E0%B8%81%E0%B8%A3%E0%B8%94%E0%B8%B5&Action=Submit\"";\n+    private static final int LARGE_LENGTH = LARGE_STRING.length();\n+    private static final byte[] LARGE_BYTES = LARGE_STRING.getBytes(UTF_8);\n+\n+    private UrlParameterDecoder decoder;\n+    private InputStream smallInputStream;\n+    private InputStream largeInputStream;\n+    private Reader smallReader;\n+    private Reader largeReader;\n+\n+    @Setup(Level.Trial)\n+    public void setupTrial(Blackhole blackhole)\n+    {\n+        decoder = new UrlParameterDecoder(CharsetStringBuilder.forCharset(UTF_8), new BlackholeBiConsumer(blackhole));\n+    }\n+\n+    @Setup(Level.Invocation)\n+    public void setupInvocation()\n+    {\n+        // Even when the benchmark method does not need these fields, the performance still is impacted by\n+        // the extra garbage those allocations leave behind them.\n+        smallInputStream = new ByteArrayInputStream(SMALL_BYTES);\n+        largeInputStream = new ByteArrayInputStream(LARGE_BYTES);\n+\n+        smallReader = new StringReader(SMALL_STRING);\n+        largeReader = new StringReader(LARGE_STRING);\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void testSmallString(Blackhole blackhole) throws Exception\n+    {\n+        blackhole.consume(decoder.parse(SMALL_STRING, 0, SMALL_LENGTH));\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void testLargeString(Blackhole blackhole) throws Exception\n+    {\n+        blackhole.consume(decoder.parse(LARGE_STRING, 0, LARGE_LENGTH));\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void testSmallInputStream(Blackhole blackhole) throws Exception\n+    {\n+        blackhole.consume(decoder.parse(smallInputStream, UTF_8));\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void testLargeInputStream(Blackhole blackhole) throws Exception\n+    {\n+        blackhole.consume(decoder.parse(largeInputStream, UTF_8));\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void testSmallReader(Blackhole blackhole) throws Exception\n+    {\n+        blackhole.consume(decoder.parse(smallReader));\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void testLargeReader(Blackhole blackhole) throws Exception\n+    {\n+        blackhole.consume(decoder.parse(largeReader));\n+    }\n+\n+    private static class BlackholeBiConsumer implements BiConsumer<String, String>\n+    {\n+        private final Blackhole blackhole;\n+\n+        public BlackholeBiConsumer(Blackhole blackhole)\n+        {\n+            this.blackhole = blackhole;\n+        }\n+\n+        @Override\n+        public void accept(String s, String s2)\n+        {\n+            blackhole.consume(s);\n+            blackhole.consume(s2);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws RunnerException\n+    {\n+        // String asyncProfilerPath = \""/home/joakim/java/async-profiler-4.0-linux-x64/lib/libasyncProfiler.so\"";\n+        Options opt = new OptionsBuilder()\n+            .include(UrlParameterDecoderBenchmark.class.getSimpleName())\n+            // .addProfiler(AsyncProfiler.class, \""dir=/home/joakim/tmp/urlparamdecoder;output=flamegraph;event=cpu;interval=500000;libPath=\"" + asyncProfilerPath)\n+            .forks(1)\n+            // .addProfiler(LinuxPerfNormProfiler.class)\n+            // .addProfiler(LinuxPerfAsmProfiler.class)\n+            .build();\n+\n+        new Runner(opt).run();\n+    }\n+}\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-13041"", ""pr_id"": 13041, ""issue_id"": 12918, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""NullPointerException with ServeAs requests (with FormAuthenticator)\n**Jetty version(s)**\n12.0.17 and 12.0.18\n\n**Jetty Environment**\nee10\n\n**Java version/vendor** `(use: java -version)`\n```\njava version \""17.0.14\"" 2025-01-21 LTS\nJava(TM) SE Runtime Environment (build 17.0.14+8-LTS-191)\nJava HotSpot(TM) 64-Bit Server VM (build 17.0.14+8-LTS-191, mixed mode, sharing)\n```\n\n**OS type/version**\n```\nLinux everfree.forest 6.13.6-200.fc41.x86_64 #1 SMP PREEMPT_DYNAMIC Fri Mar  7 21:33:48 UTC 2025 x86_64 GNU/Linux\n```\n\n**Description**\nI'm back to working on ops4j/org.ops4j.pax.web#1802 which uses Jetty, Tomcat and Undertow as backends for OSGi CMPN specifications (Whiteboard - chapter 140, HttpService - chapter 102, Web Applications - chapter 128).\n\nPax Web 10 is finally going to use `jakarta.servlet` packages (including JSP/JSTL) and while Pax Web 8 used Jetty 9, Pax Web 9 used Jetty 10, Pax Web 10 will use Jetty 12.\nI have _a lot_ of OSGi integration tests in Pax Web: https://github.com/ops4j/org.ops4j.pax.web/tree/main-jakarta-2025/pax-web-itest/pax-web-itest-container/pax-web-itest-jetty/src/test/java/org/ops4j/pax/web/itest/jetty\n\nI have an issue with form authentication. I'll skip the \""How to reproduce?\"" section and just describe what's the issue when Jetty is embedded in OSGi.\n\n1. I have a web application with:\n```xml\n<login-config>\n\t<auth-method>FORM</auth-method>\n\t<form-login-config>\n\t\t<form-login-page>/login.jsp</form-login-page>\n\t\t<form-error-page>/loginError.jsp</form-error-page>\n\t</form-login-config>\n</login-config>\n<security-constraint>\n\t<web-resource-collection>\n\t\t<web-resource-name>Protected Area</web-resource-name>\n\t\t<description>Protect the Example Servlet</description>\n\t\t<url-pattern>/wc/example</url-pattern>\n\t</web-resource-collection>\n\t<auth-constraint>\n\t\t<description>Authorized Users Group</description>\n\t\t<role-name>admin</role-name>\n\t</auth-constraint>\n</security-constraint>\n```\n\n2. When `org.eclipse.jetty.ee10.servlet.SessionHandler#handle()` is called for the first time, `org.eclipse.jetty.session.AbstractSessionManager.RequestedSession` object is created which is empty:\n```\nrequestedSession = {org.eclipse.jetty.session.AbstractSessionManager$RequestedSession@15965} \""RequestedSession[session=null, sessionId=null, sessionIdFromCookie=false]\""\n session: org.eclipse.jetty.session.ManagedSession  = null\n sessionId: java.lang.String  = null\n sessionIdFromCookie: boolean  = false\n```\n\n3. `org.eclipse.jetty.security.SecurityHandler#handle()` uses `org.eclipse.jetty.security.authentication.FormAuthenticator` and its `FormAuthenticator#validateRequest()` creates new session.\n\n4. `FormAuthenticator#validateRequest()` returns `org.eclipse.jetty.security.AuthenticationState` which is:\n```\nauthenticationState = {org.eclipse.jetty.security.AuthenticationState$ServeAs@16390} \n _uri: org.eclipse.jetty.http.HttpURI  = {org.eclipse.jetty.http.HttpURI$Mutable@16399} \""http://127.0.0.1:8181/war-formauth/login.jsp\""\n```\n\n5. security handler (which is an instance of `org.eclipse.jetty.ee10.servlet.security.ConstraintSecurityHandler`) sees that the auth state is `authenticationState instanceof AuthenticationState.ServeAs serveAs`, so `org.eclipse.jetty.security.AuthenticationState.ServeAs#wrap()` is called.\n\n6. request object passed to `wrap()` method is:\n```\nrequest = {org.eclipse.jetty.ee10.servlet.ServletContextRequest@16155} \""ServletContextRequest@1b5dd06e{GET@5e5f5d61 http://127.0.0.1:8181/war-formauth/wc/example HTTP/1.1}\""\n ...\n _managedSession: org.eclipse.jetty.session.ManagedSession  = {org.eclipse.jetty.session.ManagedSession@16383} \""ManagedSession@5008afbb{id=node01kdegovy65v791kytastxxmdij1~war-formauth##war-formauth,x=node01kdegovy65v791kytastxxmdij1~war-formauth##war-formauth.node0,req=1,res=true}\""\n\n _requestedSession: org.eclipse.jetty.session.AbstractSessionManager$RequestedSession  = {org.eclipse.jetty.session.AbstractSessionManager$RequestedSession@15965} \""RequestedSession[session=null, sessionId=null, sessionIdFromCookie=false]\""\n ...\n```\n\n`_requestedSession` is empty, but not null and `_managedSession` is new session created by FormAuthenticator\n\nHowever the request returned from `wrap()` is:\n```\nresult = {org.eclipse.jetty.ee10.servlet.ServletContextRequest@16451} \""ServletContextRequest@3b282452{@1c32fde3{ServletContextRequest@1b5dd06e{GET@5e5f5d61 http://127.0.0.1:8181/war-formauth/wc/example HTTP/1.1}}}\""\n ...\n _request: org.eclipse.jetty.server.Request  = {org.eclipse.jetty.ee10.servlet.ServletContextRequest$2@16463} \""@1c32fde3{ServletContextRequest@1b5dd06e{GET@5e5f5d61 http://127.0.0.1:8181/war-formauth/wc/example HTTP/1.1}}\""\n  _request: org.eclipse.jetty.server.Request  = {org.eclipse.jetty.ee10.servlet.ServletContextRequest@16155} \""ServletContextRequest@1b5dd06e{GET@5e5f5d61 http://127.0.0.1:8181/war-formauth/wc/example HTTP/1.1}\""\n   ...\n   _managedSession: org.eclipse.jetty.session.ManagedSession  = {org.eclipse.jetty.session.ManagedSession@16383} \""ManagedSession@5008afbb{id=node01kdegovy65v791kytastxxmdij1~war-formauth##war-formauth,x=node01kdegovy65v791kytastxxmdij1~war-formauth##war-formauth.node0,req=1,res=true}\""\n   ...\n   _requestedSession: org.eclipse.jetty.session.AbstractSessionManager$RequestedSession  = {org.eclipse.jetty.session.AbstractSessionManager$RequestedSession@15965} \""RequestedSession[session=null, sessionId=null, sessionIdFromCookie=false]\""\n   ...\n  ...\n  uri: org.eclipse.jetty.http.HttpURI  = {org.eclipse.jetty.http.HttpURI$Mutable@16399} \""http://127.0.0.1:8181/war-formauth/login.jsp\""\n ...\n _requestedSession: org.eclipse.jetty.session.AbstractSessionManager$RequestedSession  = null\n ...\n```\n\nThis wrapped request contains the original request, but has null value of `_requestedSession` (and `_managedSession`).\n\n7. Eventually `org.apache.jasper.runtime.PageContextImpl#initialize()` gets requests session and hits NPE at:\n```java\n_sessionManager.newSession(this, _requestedSession.sessionId(), this::setManagedSession);\n```\n\nbecause `_requestedSession` is null...\n"", ""issue_word_count"": 790, ""test_files_count"": 5, ""non_test_files_count"": 11, ""pr_changed_files"": [""jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Request.java"", ""jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Response.java"", ""jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/MockContext.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/MockRequest.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ResponseTest.java"", ""jetty-ee10/jetty-ee10-jaspi/src/main/java/org/eclipse/jetty/ee10/security/jaspi/JaspiAuthenticator.java"", ""jetty-ee10/jetty-ee10-jaspi/src/main/java/org/eclipse/jetty/ee10/security/jaspi/JaspiMessageInfo.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/EagerFormHandler.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ErrorHandler.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ResourceServlet.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextRequest.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/SessionHandler.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/security/FormAuthenticatorTest.java""], ""pr_changed_test_files"": [""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/MockContext.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/MockRequest.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ResponseTest.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/security/FormAuthenticatorTest.java""], ""base_commit"": ""91ae02b4671a52649057b6b194a3b3d2f9ee09c0"", ""head_commit"": ""b68366f12b630b67906f69e98e5e99516168be7a"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/13041"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/13041"", ""dockerfile"": """", ""pr_merged_at"": ""2025-05-13T00:10:44.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Request.java b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Request.java\nindex e203c33e6064..06ce1f972623 100644\n--- a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Request.java\n+++ b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Request.java\n@@ -1021,6 +1021,12 @@ public String toString()\n         }\n     }\n \n+    /** Unwrap a Request back to the given type.\n+     * @param request the possibly wrapped request to unwrap\n+     * @param type the type to unwrap to\n+     * @return the request unwrapped back to the given type or\n+     * null if it cannot be unwrapped to the supplied type.\n+     */\n     @SuppressWarnings(\""unchecked\"")\n     static <T> T as(Request request, Class<T> type)\n     {\n@@ -1033,6 +1039,34 @@ static <T> T as(Request request, Class<T> type)\n         return null;\n     }\n \n+    /**\n+     * Unwrap a Request back to the given type, ensuring that we do not cross a\n+     * context boundary (as might be the case during cross-context dispatch).\n+     *\n+     * @param request the possibly wrapped request to unwrap\n+     * @param type the type to unwrap to\n+     * @return the request unwrapped back to the given type, or null if it cannot be\n+     * unwrapped to that type or a context boundary is crossed.\n+     */\n+    static <T extends Request> T asInContext(Request request, Class<T> type)\n+    {\n+        //the context whose boundary should not be crossed\n+        Context context = request == null ? null : request.getContext();\n+\n+        if (context == null)\n+            return Request.as(request, type);\n+\n+        while (request != null)\n+        {\n+            if (request.getContext() != context)\n+                return null;\n+            if (type.isInstance(request))\n+                return (T)request;\n+            request = request instanceof Request.Wrapper wrapper ? wrapper.getWrapped() : null;\n+        }\n+        return null;\n+    }\n+\n     @SuppressWarnings(\""unchecked\"")\n     static <T, R> R get(Request request, Class<T> type, Function<T, R> getter)\n     {\n\ndiff --git a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Response.java b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Response.java\nindex 9d37ad0bdabd..c45ef421253f 100644\n--- a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Response.java\n+++ b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Response.java\n@@ -207,6 +207,36 @@ static Content.Chunk.Processor newTrailersChunkProcessor(Response response)\n         };\n     }\n \n+    /**\n+     * Unwrap a Response back to the given type, ensuring that we do not cross a\n+     * context boundary (as might be the case during cross-context dispatch).\n+     *\n+     * @param response the possibly wrapped response to unwrap\n+     * @param type the type to unwrap to\n+     * @return the response unwrapped back to the given type, or null if it cannot be\n+     * unwrapped to that type or a context boundary is crossed.\n+     */\n+    static <T extends Response> T asInContext(Response response, Class<T> type)\n+    {\n+        //the context whose boundary should not be crossed\n+        Context context = response == null ? null : (response.getRequest() == null ? null : response.getRequest().getContext());\n+\n+        if (context == null)\n+            return Response.as(response, type);\n+\n+        while (response != null)\n+        {\n+            if (response.getRequest() == null)\n+                return null;\n+            if (response.getRequest().getContext() != context)\n+                return null;\n+            if (type.isInstance(response))\n+                return (T)response;\n+            response = response instanceof Response.Wrapper wrapper ? wrapper.getWrapped() : null;\n+        }\n+        return null;\n+    }\n+\n     /**\n      * <p>Unwraps the given response, recursively, until the wrapped instance\n      * is an instance of the given type, otherwise returns {@code null}.</p>\n\ndiff --git a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java\nindex 5c95923534c8..74c2ee1417f8 100644\n--- a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java\n+++ b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java\n@@ -116,7 +116,7 @@ public static ContextHandler getCurrentContextHandler()\n \n     public static ContextHandler getContextHandler(Request request)\n     {\n-        ContextRequest contextRequest = Request.as(request, ContextRequest.class);\n+        ContextRequest contextRequest = Request.asInContext(request, ContextRequest.class);\n         if (contextRequest == null)\n             return null;\n         return contextRequest.getContext() instanceof ScopedContext scoped ? scoped.getContextHandler() : null;\n\ndiff --git a/jetty-ee10/jetty-ee10-jaspi/src/main/java/org/eclipse/jetty/ee10/security/jaspi/JaspiAuthenticator.java b/jetty-ee10/jetty-ee10-jaspi/src/main/java/org/eclipse/jetty/ee10/security/jaspi/JaspiAuthenticator.java\nindex 73654970c536..600bc601f688 100644\n--- a/jetty-ee10/jetty-ee10-jaspi/src/main/java/org/eclipse/jetty/ee10/security/jaspi/JaspiAuthenticator.java\n+++ b/jetty-ee10/jetty-ee10-jaspi/src/main/java/org/eclipse/jetty/ee10/security/jaspi/JaspiAuthenticator.java\n@@ -248,7 +248,7 @@ public AuthenticationState validateRequest(JaspiMessageInfo messageInfo) throws\n     // TODO This is not longer supported by core security\n     public boolean secureResponse(Request request, Response response, Callback callback, boolean mandatory, AuthenticationState.Succeeded validatedSucceeded) throws ServerAuthException\n     {\n-        ServletContextRequest servletContextRequest = Request.as(request, ServletContextRequest.class);\n+        ServletContextRequest servletContextRequest = Request.asInContext(request, ServletContextRequest.class);\n         JaspiMessageInfo info = (JaspiMessageInfo)servletContextRequest.getServletApiRequest().getAttribute(\""org.eclipse.jetty.ee10.security.jaspi.info\"");\n         if (info == null)\n             throw new NullPointerException(\""MessageInfo from request missing: \"" + request);\n\ndiff --git a/jetty-ee10/jetty-ee10-jaspi/src/main/java/org/eclipse/jetty/ee10/security/jaspi/JaspiMessageInfo.java b/jetty-ee10/jetty-ee10-jaspi/src/main/java/org/eclipse/jetty/ee10/security/jaspi/JaspiMessageInfo.java\nindex d3f4f50d9236..2c0643211531 100644\n--- a/jetty-ee10/jetty-ee10-jaspi/src/main/java/org/eclipse/jetty/ee10/security/jaspi/JaspiMessageInfo.java\n+++ b/jetty-ee10/jetty-ee10-jaspi/src/main/java/org/eclipse/jetty/ee10/security/jaspi/JaspiMessageInfo.java\n@@ -73,7 +73,7 @@ public Object getRequestMessage()\n     {\n         if (_request == null)\n             return null;\n-        return Request.as(_request, ServletContextRequest.class).getServletApiRequest();\n+        return Request.asInContext(_request, ServletContextRequest.class).getServletApiRequest();\n     }\n \n     @Override\n@@ -81,7 +81,7 @@ public Object getResponseMessage()\n     {\n         if (_response == null)\n             return null;\n-        return Response.as(_response, ServletContextResponse.class).getServletApiResponse();\n+        return Response.asInContext(_response, ServletContextResponse.class).getServletApiResponse();\n     }\n \n     @Override\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/EagerFormHandler.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/EagerFormHandler.java\nindex 4365c3348cfa..7d25c2360d89 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/EagerFormHandler.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/EagerFormHandler.java\n@@ -147,7 +147,7 @@ public InvocationType getInvocationType()\n             }\n         };\n \n-        ServletMultiPartFormData.onParts(Request.as(request, ServletContextRequest.class).getServletApiRequest(), contentType, onParts);\n+        ServletMultiPartFormData.onParts(Request.asInContext(request, ServletContextRequest.class).getServletApiRequest(), contentType, onParts);\n         if (done.decrementAndGet() == 0)\n             onParts.handle();\n         return true;\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ErrorHandler.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ErrorHandler.java\nindex 60224960b316..aa3acad3e572 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ErrorHandler.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ErrorHandler.java\n@@ -88,7 +88,7 @@ public boolean handle(Request request, Response response, Callback callback) thr\n             return true;\n         }\n \n-        ServletContextRequest servletContextRequest = Request.as(request, ServletContextRequest.class);\n+        ServletContextRequest servletContextRequest = Request.asInContext(request, ServletContextRequest.class);\n         HttpServletRequest httpServletRequest = servletContextRequest.getServletApiRequest();\n         HttpServletResponse httpServletResponse = servletContextRequest.getHttpServletResponse();\n         ServletContextHandler contextHandler = servletContextRequest.getServletContext().getServletContextHandler();\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ResourceServlet.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ResourceServlet.java\nindex 983d698f0899..d4de3733b229 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ResourceServlet.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ResourceServlet.java\n@@ -838,7 +838,7 @@ protected boolean passConditionalHeaders(Request request, Response response, Htt\n \n         private HttpServletRequest getServletRequest(Request request)\n         {\n-            ServletCoreRequest servletCoreRequest = Request.as(request, ServletCoreRequest.class);\n+            ServletCoreRequest servletCoreRequest = Request.asInContext(request, ServletCoreRequest.class);\n             if (servletCoreRequest != null)\n                 return servletCoreRequest.getServletRequest();\n \n@@ -851,11 +851,11 @@ private HttpServletRequest getServletRequest(Request request)\n \n         private HttpServletResponse getServletResponse(Response response)\n         {\n-            ServletCoreResponse servletCoreResponse = Response.as(response, ServletCoreResponse.class);\n+            ServletCoreResponse servletCoreResponse = Response.asInContext(response, ServletCoreResponse.class);\n             if (servletCoreResponse != null)\n                 return servletCoreResponse.getServletResponse();\n \n-            ServletContextResponse servletContextResponse = Response.as(response, ServletContextResponse.class);\n+            ServletContextResponse servletContextResponse = Response.asInContext(response, ServletContextResponse.class);\n             if (servletContextResponse != null)\n                 return servletContextResponse.getServletApiResponse();\n \n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java\nindex f98489050c56..a0239e154499 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java\n@@ -143,7 +143,7 @@ public void associate(Request request, Response response, Callback callback)\n         if (_callback != null)\n             throw new IllegalStateException();\n \n-        if (request != _request && Request.as(request, ServletContextRequest.class) != _servletContextRequest)\n+        if (request != _request && Request.asInContext(request, ServletContextRequest.class) != _servletContextRequest)\n             throw new IllegalStateException();\n         _request = request;\n         _response = response;\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextRequest.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextRequest.java\nindex 9443cb9d4556..a7fac5e70f18 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextRequest.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextRequest.java\n@@ -190,6 +190,12 @@ public HttpURI getHttpURI()\n             decodedPathInContext,\n             matchedResource\n         );\n+        ServletContextRequest originalServletContextRequest = Request.asInContext(request, ServletContextRequest.class);\n+        if (originalServletContextRequest != null)\n+        {\n+            servletContextRequest.setRequestedSession(originalServletContextRequest.getRequestedSession());\n+            servletContextRequest.setManagedSession(originalServletContextRequest.getManagedSession());\n+        }\n         servletChannel.associate(servletContextRequest);\n         return servletContextRequest;\n     }\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/SessionHandler.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/SessionHandler.java\nindex 1b27c27b89e2..22a016527b74 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/SessionHandler.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/SessionHandler.java\n@@ -400,11 +400,11 @@ public SessionHandler()\n     @Override\n     public ManagedSession getManagedSession(Request request)\n     {\n-        ServletContextRequest servletContextRequest = Request.as(request, ServletContextRequest.class);\n+        ServletContextRequest servletContextRequest = Request.asInContext(request, ServletContextRequest.class);\n         if (servletContextRequest != null)\n             return servletContextRequest.getManagedSession();\n \n-        NonServletSessionRequest nonServletSessionRequest = Request.as(request, NonServletSessionRequest.class);\n+        NonServletSessionRequest nonServletSessionRequest = Request.asInContext(request, NonServletSessionRequest.class);\n         if (nonServletSessionRequest != null)\n             return nonServletSessionRequest.getManagedSession();\n \n"", ""test_patch"": ""diff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/MockContext.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/MockContext.java\nnew file mode 100644\nindex 000000000000..486bf4607092\n--- /dev/null\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/MockContext.java\n@@ -0,0 +1,120 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.jetty.http.MimeTypes;\n+import org.eclipse.jetty.util.resource.Resource;\n+\n+public class MockContext implements Context\n+{\n+    @Override\n+    public <T> T decorate(T o)\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public void destroy(Object o)\n+    {\n+\n+    }\n+\n+    @Override\n+    public String getContextPath()\n+    {\n+        return \""\"";\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader()\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public Resource getBaseResource()\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public Request.Handler getErrorHandler()\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public List<String> getVirtualHosts()\n+    {\n+        return List.of();\n+    }\n+\n+    @Override\n+    public MimeTypes getMimeTypes()\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task)\n+    {\n+\n+    }\n+\n+    @Override\n+    public Object removeAttribute(String name)\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object setAttribute(String name, Object attribute)\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name)\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public Set<String> getAttributeNameSet()\n+    {\n+        return Set.of();\n+    }\n+\n+    @Override\n+    public void run(Runnable task)\n+    {\n+\n+    }\n+\n+    @Override\n+    public void run(Runnable task, Request request)\n+    {\n+\n+    }\n+\n+    @Override\n+    public File getTempDirectory()\n+    {\n+        return null;\n+    }\n+}\n\ndiff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/MockRequest.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/MockRequest.java\nnew file mode 100644\nindex 000000000000..80211cceb8e4\n--- /dev/null\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/MockRequest.java\n@@ -0,0 +1,200 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.server;\n+\n+import java.util.Set;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpURI;\n+import org.eclipse.jetty.io.Content;\n+\n+public class MockRequest implements Request\n+{\n+    private final Context _context;\n+\n+    public static class MockWrapper extends Request.Wrapper\n+    {\n+        private Context _context;\n+\n+        public MockWrapper(Request wrapped)\n+        {\n+            super(wrapped);\n+        }\n+\n+        public MockWrapper(Request request, Context context)\n+        {\n+            super(request);\n+            _context = context;\n+        }\n+\n+        @Override\n+        public Context getContext()\n+        {\n+            return _context;\n+        }\n+    }\n+\n+    public MockRequest(Context context)\n+    {\n+        _context = context;\n+    }\n+\n+    @Override\n+    public String getId()\n+    {\n+        return \""\"";\n+    }\n+\n+    @Override\n+    public Components getComponents()\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public ConnectionMetaData getConnectionMetaData()\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getMethod()\n+    {\n+        return \""\"";\n+    }\n+\n+    @Override\n+    public HttpURI getHttpURI()\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public Context getContext()\n+    {\n+        return _context;\n+    }\n+\n+    @Override\n+    public HttpFields getHeaders()\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public void demand(Runnable demandCallback)\n+    {\n+\n+    }\n+\n+    @Override\n+    public void fail(Throwable failure)\n+    {\n+\n+    }\n+\n+    @Override\n+    public HttpFields getTrailers()\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public long getBeginNanoTime()\n+    {\n+        return 0;\n+    }\n+\n+    @Override\n+    public long getHeadersNanoTime()\n+    {\n+        return 0;\n+    }\n+\n+    @Override\n+    public boolean isSecure()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    public Content.Chunk read()\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean consumeAvailable()\n+    {\n+        return false;\n+    }\n+\n+    @Override\n+    public void addIdleTimeoutListener(Predicate<TimeoutException> onIdleTimeout)\n+    {\n+\n+    }\n+\n+    @Override\n+    public void addFailureListener(Consumer<Throwable> onFailure)\n+    {\n+\n+    }\n+\n+    @Override\n+    public TunnelSupport getTunnelSupport()\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public void addHttpStreamWrapper(Function<HttpStream, HttpStream> wrapper)\n+    {\n+\n+    }\n+\n+    @Override\n+    public Session getSession(boolean create)\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object removeAttribute(String name)\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object setAttribute(String name, Object attribute)\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name)\n+    {\n+        return null;\n+    }\n+\n+    @Override\n+    public Set<String> getAttributeNameSet()\n+    {\n+        return Set.of();\n+    }\n+}\n\ndiff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java\nindex 822fa4d20cfd..f23d84b946a9 100644\n--- a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java\n@@ -52,6 +52,7 @@\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class RequestTest\n@@ -77,6 +78,49 @@ public void dispose() throws Exception\n         connector = null;\n     }\n \n+    @Test\n+    public void testAsInContext() throws Exception\n+    {\n+        // no request\n+        assertNull(Request.asInContext(null, MockRequest.Wrapper.class));\n+\n+        // request with no context is the same as Request.as\n+        MockRequest request = new MockRequest(new MockContext());\n+        MockContext wrappedContext = new MockContext();\n+        MockRequest.MockWrapper wrapperA = new MockRequest.MockWrapper(request, wrappedContext);\n+        MockRequest.MockWrapper wrapperB = new MockRequest.MockWrapper(wrapperA, null);\n+        Request asInContext = Request.asInContext(wrapperB, MockRequest.MockWrapper.class);\n+        Request as = Request.as(wrapperB, MockRequest.MockWrapper.class);\n+        assertSame(asInContext, as);\n+        assertSame(wrapperB, asInContext);\n+        assertSame(wrapperB, as);\n+\n+        // request with context must not cross boundary\n+        wrapperB = new MockRequest.MockWrapper(wrapperA, new MockContext());\n+        Request.Wrapper wrapperC = new Request.Wrapper(wrapperB)\n+        {\n+            @Override\n+            public Context getContext()\n+            {\n+                return new MockContext();\n+            }\n+        };\n+        assertNull(Request.asInContext(wrapperC, MockRequest.MockWrapper.class));\n+\n+        // request with same context in more than one wrap returns first matching class\n+        wrapperB = new MockRequest.MockWrapper(wrapperA, wrapperA.getContext());\n+        wrapperC = new Request.Wrapper(wrapperB)\n+        {\n+            @Override\n+            public Context getContext()\n+            {\n+                return getWrapped().getContext();\n+            }\n+        };\n+\n+        assertSame(wrapperB, Request.asInContext(wrapperC, MockRequest.MockWrapper.class));\n+    }\n+\n     @Test\n     public void testEncodedSpace() throws Exception\n     {\n\ndiff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ResponseTest.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ResponseTest.java\nindex 3529615c73d1..c699ba044ea6 100644\n--- a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ResponseTest.java\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ResponseTest.java\n@@ -13,9 +13,12 @@\n \n package org.eclipse.jetty.server;\n \n+import java.nio.ByteBuffer;\n import java.util.Iterator;\n import java.util.List;\n import java.util.ListIterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n import java.util.stream.Stream;\n \n import org.eclipse.jetty.http.HttpCookie;\n@@ -44,6 +47,8 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class ResponseTest\n@@ -51,6 +56,96 @@ public class ResponseTest\n     private Server server;\n     private LocalConnector connector;\n \n+    private static class MockResponse implements Response\n+    {\n+        private final Request _request;\n+\n+        public MockResponse(Request request)\n+        {\n+            _request = request;\n+        }\n+\n+        @Override\n+        public Request getRequest()\n+        {\n+            return _request;\n+        }\n+\n+        @Override\n+        public int getStatus()\n+        {\n+            return 0;\n+        }\n+\n+        @Override\n+        public void setStatus(int code)\n+        {\n+\n+        }\n+\n+        @Override\n+        public HttpFields.Mutable getHeaders()\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public Supplier<HttpFields> getTrailersSupplier()\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public void setTrailersSupplier(Supplier<HttpFields> trailers)\n+        {\n+\n+        }\n+\n+        @Override\n+        public boolean isCommitted()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean hasLastWrite()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isCompletedSuccessfully()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public void reset()\n+        {\n+\n+        }\n+\n+        @Override\n+        public CompletableFuture<Void> writeInterim(int status, HttpFields headers)\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public void write(boolean last, ByteBuffer byteBuffer, Callback callback)\n+        {\n+\n+        }\n+    }\n+\n+    private static class MockResponseWrapper extends Response.Wrapper\n+    {\n+        public MockResponseWrapper(Request request, Response wrapped)\n+        {\n+            super(request, wrapped);\n+        }\n+    }\n+\n     @BeforeEach\n     public void prepare() throws Exception\n     {\n@@ -67,6 +162,47 @@ public void dispose() throws Exception\n         connector = null;\n     }\n \n+    @Test\n+    public void testAsInContext() throws Exception\n+    {\n+        // no response\n+        assertNull(Response.asInContext(null, MockResponseWrapper.class));\n+\n+       // response has no request\n+       MockResponse mockResponse = new MockResponse(null);\n+       assertNull(Response.asInContext(mockResponse, MockResponseWrapper.class));\n+\n+        // response with request with no context is the same as Response.as\n+        MockContext mockContext = new MockContext();\n+        MockRequest mockRequest = new MockRequest(mockContext);\n+        mockResponse  = new MockResponse(mockRequest);\n+        MockRequest.MockWrapper mockRequestWrapperA = new MockRequest.MockWrapper(mockRequest, mockContext);\n+        MockResponseWrapper mockResponseWrapperA = new MockResponseWrapper(mockRequestWrapperA, mockResponse);\n+        MockRequest.MockWrapper mockRequestWrapperB = new MockRequest.MockWrapper(mockRequestWrapperA, null);\n+        MockResponseWrapper mockResponseWrapperB = new MockResponseWrapper(mockRequestWrapperB, mockResponseWrapperA);\n+        Response asInContext = Response.asInContext(mockResponseWrapperB, MockResponseWrapper.class);\n+        Response as = Response.as(mockResponseWrapperB, MockResponseWrapper.class);\n+        assertSame(asInContext, as);\n+        assertSame(mockResponseWrapperB, asInContext);\n+        assertSame(mockResponseWrapperB, as);\n+\n+        // response with request with context must not cross context boundary\n+        mockRequestWrapperB = new MockRequest.MockWrapper(mockRequestWrapperA, new MockContext());\n+        mockResponseWrapperB = new MockResponseWrapper(mockRequestWrapperB, mockResponseWrapperA);\n+        Response.Wrapper wrapperC = new Response.Wrapper(new MockRequest.MockWrapper(mockRequestWrapperB, new MockContext()), mockResponseWrapperB)\n+        {\n+        };\n+        assertNull(Response.asInContext(wrapperC, MockResponseWrapper.class));\n+\n+        // response with request with same context in more than one wrap returns first matching class\n+        mockRequestWrapperB = new MockRequest.MockWrapper(mockRequestWrapperA, mockContext);\n+        mockResponseWrapperB = new MockResponseWrapper(mockRequestWrapperB, mockResponseWrapperA);\n+        wrapperC = new Response.Wrapper(new MockRequest.Wrapper(mockRequestWrapperB), mockResponseWrapperB)\n+        {\n+        };\n+        assertSame(mockResponseWrapperB, Response.asInContext(wrapperC, MockResponseWrapper.class));\n+    }\n+\n     @Test\n     public void testGET() throws Exception\n     {\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/security/FormAuthenticatorTest.java b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/security/FormAuthenticatorTest.java\nindex 101b27c8e971..f7fe598ab688 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/security/FormAuthenticatorTest.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/security/FormAuthenticatorTest.java\n@@ -66,6 +66,7 @@ public static class AuthenticationTestServlet extends HttpServlet\n         @Override\n         protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\n         {\n+            req.getSession();\n             PrintWriter writer = resp.getWriter();\n             writer.println(\""contextPath: \"" + req.getContextPath());\n             writer.println(\""servletPath: \"" + req.getServletPath());\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-13037"", ""pr_id"": 13037, ""issue_id"": 13003, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Avoid cycles in bean dumps\n**Jetty version(s)**\n12.1.x\n\n**Description**\n`EventListener` added to a component may be copied to a subcomponent.\n\nThis is the case where we add e.g. a `Connection.Listener` to `Connector`, but then we copy the `Connection.Listener` to the actual `Connection` object every time the `Connector` creates a new one.\n\nIt may happen that one of the copied listeners is a container for the subcomponent, which will form a cycle (not in the bean graph, perhaps, but in the dump execution).\nFor example, when `HTTP2SessionContainer` is added as a listener to `HTTP2Session`: trying to dump the session results in trying to dump the container, which tries to dump the session, resulting in `StackOverflowError`.\n\nWe should have a generic mechanism to avoid this dump cycle."", ""issue_word_count"": 131, ""test_files_count"": 7, ""non_test_files_count"": 5, ""pr_changed_files"": [""jetty-core/jetty-plus/src/main/java/org/eclipse/jetty/plus/jndi/NamingEntry.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ServerTest.java"", ""jetty-core/jetty-session/src/main/java/org/eclipse/jetty/session/AbstractSessionDataStore.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/Dumpable.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/DumpableCollection.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/ContainerLifeCycleTest.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/DumpableTest.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java"", ""jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/DebugListener.java"", ""jetty-ee11/jetty-ee11-websocket/jetty-ee11-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee11/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java"", ""jetty-ee9/jetty-ee9-plus/src/test/java/org/eclipse/jetty/ee9/plus/jndi/TestNamingEntryUtil.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java""], ""pr_changed_test_files"": [""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ServerTest.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/ContainerLifeCycleTest.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/DumpableTest.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java"", ""jetty-ee11/jetty-ee11-websocket/jetty-ee11-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee11/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java"", ""jetty-ee9/jetty-ee9-plus/src/test/java/org/eclipse/jetty/ee9/plus/jndi/TestNamingEntryUtil.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java""], ""base_commit"": ""3a5b6655cbce128cdfdb16d01d433a8415d65122"", ""head_commit"": ""8ed2df28973b57a9d8c1cee710cd2c7399f1f10d"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/13037"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/13037"", ""dockerfile"": """", ""pr_merged_at"": ""2025-04-28T22:24:40.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-plus/src/main/java/org/eclipse/jetty/plus/jndi/NamingEntry.java b/jetty-core/jetty-plus/src/main/java/org/eclipse/jetty/plus/jndi/NamingEntry.java\nindex 16b59b09c986..f706e6c72bd5 100644\n--- a/jetty-core/jetty-plus/src/main/java/org/eclipse/jetty/plus/jndi/NamingEntry.java\n+++ b/jetty-core/jetty-plus/src/main/java/org/eclipse/jetty/plus/jndi/NamingEntry.java\n@@ -13,7 +13,6 @@\n \n package org.eclipse.jetty.plus.jndi;\n \n-import java.util.Set;\n import javax.naming.Context;\n import javax.naming.InitialContext;\n import javax.naming.LinkRef;\n\ndiff --git a/jetty-core/jetty-session/src/main/java/org/eclipse/jetty/session/AbstractSessionDataStore.java b/jetty-core/jetty-session/src/main/java/org/eclipse/jetty/session/AbstractSessionDataStore.java\nindex ea1ce727758e..90a9a4ffd46a 100644\n--- a/jetty-core/jetty-session/src/main/java/org/eclipse/jetty/session/AbstractSessionDataStore.java\n+++ b/jetty-core/jetty-session/src/main/java/org/eclipse/jetty/session/AbstractSessionDataStore.java\n@@ -13,16 +13,10 @@\n \n package org.eclipse.jetty.session;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.OutputStream;\n import java.util.HashSet;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n \n-import org.eclipse.jetty.util.ClassLoadingObjectInputStream;\n import org.eclipse.jetty.util.FuturePromise;\n import org.eclipse.jetty.util.annotation.ManagedAttribute;\n import org.eclipse.jetty.util.annotation.ManagedObject;\n\ndiff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/Dumpable.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/Dumpable.java\nindex 17e003b28f1e..e3ca98f9ae33 100644\n--- a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/Dumpable.java\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/Dumpable.java\n@@ -23,9 +23,12 @@\n import java.time.format.DateTimeFormatter;\n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Set;\n import java.util.stream.Stream;\n \n import org.eclipse.jetty.util.Jetty;\n@@ -37,7 +40,7 @@\n @ManagedObject(\""Dumpable Object\"")\n public interface Dumpable\n {\n-    String KEY = \""key: +- bean, += managed, +~ unmanaged, +? auto, +: iterable, +] array, +@ map, +> undefined\\n\"";\n+    String LEGEND = \""legend: +- bean, += managed, +~ unmanaged, +? auto, +: iterable, +] array, +} map, +> pojo; @ visited\\n\"";\n \n     @ManagedOperation(value = \""Dump the nested Object state as a String\"", impact = \""INFO\"")\n     default String dump()\n@@ -64,9 +67,9 @@ default String dump()\n      */\n     static String dump(Dumpable dumpable)\n     {\n-        StringBuilder b = new StringBuilder();\n-        dump(dumpable, b);\n-        return b.toString();\n+        DumpAppendable buffer = new DumpAppendable();\n+        dump(dumpable, buffer);\n+        return buffer.toString();\n     }\n \n     /**\n@@ -77,14 +80,14 @@ static String dump(Dumpable dumpable)\n      */\n     static void dump(Dumpable dumpable, Appendable out)\n     {\n+        out = DumpAppendable.ensure(out);\n         try\n         {\n             dumpable.dump(out, \""\"");\n \n-            out.append(KEY);\n+            out.append(LEGEND);\n             Runtime runtime = Runtime.getRuntime();\n             Instant now = Instant.now();\n-            String zone = System.getProperty(\""user.timezone\"");\n             out.append(\""JVM: %s %s %s; OS: %s %s %s; Jetty: %s; CPUs: %d; mem(free/total/max): %,d/%,d/%,d MiB\\nUTC: %s; %s: %s\"".formatted(\n                 System.getProperty(\""java.vm.vendor\""),\n                 System.getProperty(\""java.vm.name\""),\n@@ -98,8 +101,8 @@ static void dump(Dumpable dumpable, Appendable out)\n                 runtime.totalMemory() / (1024 * 1024),\n                 runtime.maxMemory() / (1024 * 1024),\n                 DateTimeFormatter.ISO_DATE_TIME.format(now.atOffset(ZoneOffset.UTC)),\n-                zone,\n-                DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(now.atZone(ZoneId.of(zone)))));\n+                ZoneId.systemDefault(),\n+                DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(now.atZone(ZoneId.systemDefault()))));\n         }\n         catch (IOException e)\n         {\n@@ -129,6 +132,7 @@ default String dumpSelf()\n      */\n     static void dumpObject(Appendable out, Object o) throws IOException\n     {\n+        out = DumpAppendable.ensure(out);\n         try\n         {\n             String s;\n@@ -182,7 +186,11 @@ else if (o instanceof Map.Entry<?, ?> entry)\n     static void dumpObjects(Appendable out, String indent, Object object, Object... extraChildren) throws IOException\n     {\n         dumpObject(out, object);\n-        \n+\n+        if (DumpAppendable.hasVisited(out, object))\n+            return;\n+        DumpAppendable.visit(out, object);\n+\n         int extras = extraChildren == null ? 0 : extraChildren.length;\n         \n         if (object instanceof Stream)\n@@ -194,9 +202,9 @@ static void dumpObjects(Appendable out, String indent, Object object, Object...\n         {\n             dumpContainer(out, indent, (Container)object, extras == 0);\n         }\n-        // Dump an Iterable Path because it may contain itself.\n-        if (object instanceof Iterable && !(object instanceof Path))\n+        else if (object instanceof Iterable && !(object instanceof Path))\n         {\n+            // Do not Dump a Path as an Iterable because its toString is sufficient.\n             dumpIterable(out, indent, (Iterable<?>)object, extras == 0);\n         }\n         else if (object instanceof Map)\n@@ -212,11 +220,21 @@ else if (object instanceof Map)\n         {\n             i++;\n             String nextIndent = indent + (i < extras ? \""|  \"" : \""   \"");\n-            out.append(indent).append(\""+> \"");\n-            if (item instanceof Dumpable)\n-                ((Dumpable)item).dump(out, nextIndent);\n+            out.append(indent).append(\""+>\"");\n+\n+            if (DumpAppendable.hasVisited(out, item))\n+            {\n+                out.append(\""@ \"");\n+                dumpObject(out, item);\n+            }\n             else\n-                dumpObjects(out, nextIndent, item);\n+            {\n+                out.append(' ');\n+                if (item instanceof Dumpable)\n+                    ((Dumpable)item).dump(out, nextIndent);\n+                else\n+                    dumpObjects(out, nextIndent, item);\n+            }\n         }\n     }\n     \n@@ -232,38 +250,30 @@ static void dumpContainer(Appendable out, String indent, Container object, boole\n                 continue; //won't be dumped as a child bean\n \n             String nextIndent = indent + ((i.hasNext() || !last) ? \""|  \"" : \""   \"");\n+\n+            out.append(indent).append('+');\n             if (bean instanceof LifeCycle)\n             {\n                 if (container.isManaged(bean))\n-                {\n-                    out.append(indent).append(\""+= \"");\n-                    if (bean instanceof Dumpable)\n-                        ((Dumpable)bean).dump(out, nextIndent);\n-                    else\n-                        dumpObjects(out, nextIndent, bean);\n-                }\n+                    out.append('=');\n                 else if (containerLifeCycle != null && containerLifeCycle.isAuto(bean))\n-                {\n-                    out.append(indent).append(\""+? \"");\n-                    if (bean instanceof Dumpable)\n-                        ((Dumpable)bean).dump(out, nextIndent);\n-                    else\n-                        dumpObjects(out, nextIndent, bean);\n-                }\n+                    out.append('?');\n                 else\n-                {\n-                    out.append(indent).append(\""+~ \"");\n-                    dumpObject(out, bean);\n-                }\n+                    out.append('~');\n             }\n             else if (containerLifeCycle != null && containerLifeCycle.isUnmanaged(bean))\n+                out.append('~');\n+            else\n+                out.append('-');\n+\n+            if (DumpAppendable.hasVisited(out, bean))\n             {\n-                out.append(indent).append(\""+~ \"");\n-                dumpObject(out, bean);\n+                out.append(\""@ \"");\n+                dumpObject(out, object);\n             }\n             else\n             {\n-                out.append(indent).append(\""+- \"");\n+                out.append(' ');\n                 if (bean instanceof Dumpable)\n                     ((Dumpable)bean).dump(out, nextIndent);\n                 else\n@@ -274,7 +284,7 @@ else if (containerLifeCycle != null && containerLifeCycle.isUnmanaged(bean))\n \n     static void dumpIterable(Appendable out, String indent, Iterable<?> iterable, boolean last) throws IOException\n     {\n-        for (Iterator i = iterable.iterator(); i.hasNext(); )\n+        for (Iterator<?> i = iterable.iterator(); i.hasNext(); )\n         {\n             Object item = i.next();\n             // Safety net to stop iteration when an Iterable contains itself e.g. Path.\n@@ -332,8 +342,6 @@ public void dump(Appendable out, String indent) throws IOException\n     }\n \n     /**\n-     * DumpableContainer\n-     *\n      * A Dumpable that is a container of beans can implement this\n      * interface to allow it to refine which of its beans can be\n      * dumped.\n@@ -345,4 +353,63 @@ default boolean isDumpable(Object o)\n             return true;\n         }\n     }\n+\n+    /**\n+     * An Appendable that helps avoid dump cycles.\n+     */\n+    class DumpAppendable implements Appendable\n+    {\n+        private final Appendable _appendable;\n+        private final Set<Object> _visited = Collections.newSetFromMap(new IdentityHashMap<>());\n+\n+        public DumpAppendable()\n+        {\n+            this(null);\n+        }\n+\n+        public DumpAppendable(Appendable out)\n+        {\n+            _appendable = Objects.requireNonNullElseGet(out, StringBuilder::new);\n+        }\n+\n+        public static DumpAppendable ensure(Appendable out)\n+        {\n+            return out instanceof DumpAppendable da ? da : new DumpAppendable(out);\n+        }\n+\n+        public static void visit(Appendable out, Object item)\n+        {\n+            if (out instanceof DumpAppendable dumpAppendable)\n+                dumpAppendable._visited.add(item);\n+        }\n+\n+        static boolean hasVisited(Appendable out, Object item)\n+        {\n+            return out instanceof DumpAppendable dumpAppendable && dumpAppendable._visited.contains(item);\n+        }\n+\n+        @Override\n+        public Appendable append(CharSequence csq) throws IOException\n+        {\n+            return _appendable.append(csq);\n+        }\n+\n+        @Override\n+        public Appendable append(CharSequence csq, int start, int end) throws IOException\n+        {\n+            return _appendable.append(csq, start, end);\n+        }\n+\n+        @Override\n+        public Appendable append(char c) throws IOException\n+        {\n+            return _appendable.append(c);\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return _appendable.toString();\n+        }\n+    }\n }\n\ndiff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/DumpableCollection.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/DumpableCollection.java\nindex 83cac168237f..335baa164128 100644\n--- a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/DumpableCollection.java\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/DumpableCollection.java\n@@ -17,6 +17,9 @@\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Objects;\n+\n+import org.eclipse.jetty.util.TypeUtil;\n \n public class DumpableCollection implements Dumpable\n {\n@@ -26,7 +29,7 @@ public class DumpableCollection implements Dumpable\n     public DumpableCollection(String name, Collection<?> collection)\n     {\n         _name = name;\n-        _collection = collection;\n+        _collection = Objects.requireNonNullElseGet(collection, Collections::emptyList);\n     }\n \n     public static DumpableCollection fromArray(String name, Object[] array)\n@@ -47,8 +50,20 @@ public static DumpableCollection from(String name, Collection<?> collection)\n     @Override\n     public void dump(Appendable out, String indent) throws IOException\n     {\n-        Object[] array = (_collection == null ? null : _collection.toArray());\n-        Dumpable.dumpObjects(out, indent, _name + \"" size=\"" + (array == null ? 0 : array.length), array);\n+        Object[] array = _collection.toArray();\n+        Dumpable.dumpObjects(out, indent, this, array);\n+    }\n+\n+    @Override\n+    public String dumpSelf()\n+    {\n+        return _name + \"" size=\"" + _collection.size();\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \""%s@%x[%s,size=%d]\"".formatted(TypeUtil.toShortName(this.getClass()), hashCode(), _name, _collection.size());\n     }\n }\n \n\ndiff --git a/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/DebugListener.java b/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/DebugListener.java\nindex 53a95143a77e..8f6f8e929884 100644\n--- a/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/DebugListener.java\n+++ b/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/DebugListener.java\n@@ -125,14 +125,14 @@ public void contextInitialized(ServletContextEvent sce)\n             if (_out == null)\n             {\n                 handler.dumpStdErr();\n-                System.err.println(Dumpable.KEY);\n+                System.err.println(Dumpable.LEGEND);\n             }\n             else\n             {\n                 try\n                 {\n                     handler.dump(_out);\n-                    _out.println(Dumpable.KEY);\n+                    _out.println(Dumpable.LEGEND);\n                 }\n                 catch (Exception e)\n                 {\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ServerTest.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ServerTest.java\nindex f3b7724420d2..d03a4c555ef4 100644\n--- a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ServerTest.java\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/ServerTest.java\n@@ -160,7 +160,7 @@ public void testDump() throws Exception\n         assertThat(dump, containsString(\""+> java.runtime.version: \""));\n         assertThat(dump, containsString(\""+= oejsh.ContextHandler@\""));\n         assertThat(dump, containsString(\""+= LocalConnector@\""));\n-        assertThat(dump, containsString(\""key: +-\""));\n+        assertThat(dump, containsString(\""legend: +-\""));\n         assertThat(dump, containsString(\""JVM: \""));\n         assertThat(dump, containsString(Jetty.VERSION));\n     }\n\ndiff --git a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/ContainerLifeCycleTest.java b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/ContainerLifeCycleTest.java\nindex e8c04cb9c9f4..52887bd7c0dd 100644\n--- a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/ContainerLifeCycleTest.java\n+++ b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/ContainerLifeCycleTest.java\n@@ -39,8 +39,8 @@ public class ContainerLifeCycleTest\n     @Test\n     public void testStartStop() throws Exception\n     {\n-        ContainerLifeCycle a0 = new ContainerLifeCycle();\n-        TestContainerLifeCycle a1 = new TestContainerLifeCycle();\n+        ContainerLifeCycle a0 = new TestContainerLifeCycle(\""a0\"");\n+        TestContainerLifeCycle a1 = new TestContainerLifeCycle(\""a1\"");\n         a0.addBean(a1);\n \n         a0.start();\n@@ -72,8 +72,8 @@ public void testStartStop() throws Exception\n     @Test\n     public void testStartStopDestroy() throws Exception\n     {\n-        ContainerLifeCycle a0 = new ContainerLifeCycle();\n-        TestContainerLifeCycle a1 = new TestContainerLifeCycle();\n+        ContainerLifeCycle a0 = new TestContainerLifeCycle(\""a0\"");\n+        TestContainerLifeCycle a1 = new TestContainerLifeCycle(\""a1\"");\n \n         a0.start();\n         assertEquals(0, a1.started.get());\n@@ -133,8 +133,8 @@ public void testIllegalToStartAfterDestroy() throws Exception\n     @Test\n     public void testDisJoint() throws Exception\n     {\n-        ContainerLifeCycle a0 = new ContainerLifeCycle();\n-        TestContainerLifeCycle a1 = new TestContainerLifeCycle();\n+        ContainerLifeCycle a0 = new TestContainerLifeCycle(\""a0\"");\n+        TestContainerLifeCycle a1 = new TestContainerLifeCycle(\""a1\"");\n \n         // Start the a1 bean before adding, makes it auto disjoint\n         a1.start();\n@@ -203,17 +203,17 @@ public void testDisJoint() throws Exception\n     @Test\n     public void testDumpable() throws Exception\n     {\n-        ContainerLifeCycle a0 = new ContainerLifeCycle();\n+        ContainerLifeCycle a0 = new TestContainerLifeCycle(\""a0\"");\n         String dump = trim(a0.dump());\n         check(dump, \""oejuc.ContainerLifeCycl\"");\n \n-        ContainerLifeCycle aa0 = new ContainerLifeCycle();\n+        ContainerLifeCycle aa0 = new TestContainerLifeCycle(\""aa0\"");\n         a0.addBean(aa0);\n         dump = trim(a0.dump());\n         dump = check(dump, \""oejuc.ContainerLifeCycl\"");\n         check(dump, \""+? oejuc.ContainerLife\"");\n \n-        ContainerLifeCycle aa1 = new ContainerLifeCycle();\n+        ContainerLifeCycle aa1 = new TestContainerLifeCycle(\""aa1\"");\n         a0.addBean(aa1);\n         dump = trim(a0.dump());\n         dump = check(dump, \""oejuc.ContainerLifeCycl\"");\n@@ -221,7 +221,7 @@ public void testDumpable() throws Exception\n         dump = check(dump, \""+? oejuc.ContainerLife\"");\n         check(dump, \""\"");\n \n-        ContainerLifeCycle aa2 = new ContainerLifeCycle();\n+        ContainerLifeCycle aa2 = new TestContainerLifeCycle(\""aa2\"");\n         a0.addBean(aa2, false);\n         dump = trim(a0.dump());\n         dump = check(dump, \""oejuc.ContainerLifeCycl\"");\n@@ -247,7 +247,7 @@ public void testDumpable() throws Exception\n         dump = check(dump, \""+= oejuc.ContainerLife\"");\n         check(dump, \""\"");\n \n-        ContainerLifeCycle aaa0 = new ContainerLifeCycle();\n+        ContainerLifeCycle aaa0 = new TestContainerLifeCycle(\""aaa0\"");\n         aa0.addBean(aaa0);\n         dump = trim(a0.dump());\n         dump = check(dump, \""oejuc.ContainerLifeCycl\"");\n@@ -256,7 +256,7 @@ public void testDumpable() throws Exception\n         dump = check(dump, \""+= oejuc.ContainerLife\"");\n         check(dump, \""\"");\n \n-        ContainerLifeCycle aa10 = new ContainerLifeCycle();\n+        ContainerLifeCycle aa10 = new TestContainerLifeCycle(\""aa10\"");\n         aa1.addBean(aa10, true);\n         dump = trim(a0.dump());\n         dump = check(dump, \""oejuc.ContainerLifeCycl\"");\n@@ -266,12 +266,12 @@ public void testDumpable() throws Exception\n         dump = check(dump, \""   += oejuc.Container\"");\n         check(dump, \""\"");\n \n-        final ContainerLifeCycle a1 = new ContainerLifeCycle();\n-        final ContainerLifeCycle a2 = new ContainerLifeCycle();\n-        final ContainerLifeCycle a3 = new ContainerLifeCycle();\n-        final ContainerLifeCycle a4 = new ContainerLifeCycle();\n+        final ContainerLifeCycle a1 = new TestContainerLifeCycle(\""a1\"");\n+        final ContainerLifeCycle a2 = new TestContainerLifeCycle(\""a2\"");\n+        final ContainerLifeCycle a3 = new TestContainerLifeCycle(\""a3\"");\n+        final ContainerLifeCycle a4 = new TestContainerLifeCycle(\""a4\"");\n \n-        ContainerLifeCycle aa = new ContainerLifeCycle()\n+        ContainerLifeCycle aa = new TestContainerLifeCycle(\""aa\"")\n         {\n             @Override\n             public void dump(Appendable out, String indent) throws IOException\n@@ -309,8 +309,7 @@ public void dump(Appendable out, String indent) throws IOException\n         dump = check(dump, \""   +> ju.Arrays$ArrayList\"");\n         dump = check(dump, \""   |  +: oejuc.ContainerLifeCycle\"");\n         dump = check(dump, \""   |  +: oejuc.ContainerLifeCycle\"");\n-        dump = check(dump, \""   |     += oejuc.Conta\"");\n-        dump = check(dump, \""   |        +~ oejuc.C\"");\n+        dump = check(dump, \""   |     +=@ oejuc.Conta\"");\n         dump = check(dump, \""   +> ju.Arrays$ArrayList\"");\n         dump = check(dump, \""      +: oejuc.ContainerLifeCycle\"");\n         dump = check(dump, \""      +: oejuc.ContainerLifeCycle\"");\n@@ -327,7 +326,7 @@ public void dump(Appendable out, String indent) throws IOException\n         dump = check(dump, \""   +> ju.Arrays$ArrayList\"");\n         dump = check(dump, \""   |  +: oejuc.ContainerLifeCycle\"");\n         dump = check(dump, \""   |  +: oejuc.ContainerLifeCycle\"");\n-        dump = check(dump, \""   |     +~ oejuc.Conta\"");\n+        dump = check(dump, \""   |     +~@ oejuc.Conta\"");\n         dump = check(dump, \""   +> ju.Arrays$ArrayList\"");\n         dump = check(dump, \""      +: oejuc.ContainerLifeCycle\"");\n         dump = check(dump, \""      +: oejuc.ContainerLifeCycle\"");\n@@ -379,7 +378,7 @@ public String toString()\n             }\n         };\n \n-        ContainerLifeCycle c0 = new ContainerLifeCycle()\n+        ContainerLifeCycle c0 = new TestContainerLifeCycle(\""c0\"")\n         {\n             @Override\n             public String toString()\n@@ -387,7 +386,7 @@ public String toString()\n                 return \""c0\"";\n             }\n         };\n-        ContainerLifeCycle c00 = new ContainerLifeCycle()\n+        ContainerLifeCycle c00 = new TestContainerLifeCycle(\""c00\"")\n         {\n             @Override\n             public String toString()\n@@ -517,30 +516,9 @@ public String toString()\n     @Test\n     public void testInheritedListener() throws Exception\n     {\n-        ContainerLifeCycle c0 = new ContainerLifeCycle()\n-        {\n-            @Override\n-            public String toString()\n-            {\n-                return \""c0\"";\n-            }\n-        };\n-        ContainerLifeCycle c00 = new ContainerLifeCycle()\n-        {\n-            @Override\n-            public String toString()\n-            {\n-                return \""c00\"";\n-            }\n-        };\n-        ContainerLifeCycle c01 = new ContainerLifeCycle()\n-        {\n-            @Override\n-            public String toString()\n-            {\n-                return \""c01\"";\n-            }\n-        };\n+        ContainerLifeCycle c0 = new TestContainerLifeCycle(\""c0\"");\n+        ContainerLifeCycle c00 = new TestContainerLifeCycle(\""c00\"");\n+        ContainerLifeCycle c01 = new TestContainerLifeCycle(\""c01\"");\n         Container.InheritedListener inherited = new InheritedListenerLifeCycle();\n \n         c0.addBean(c00);\n@@ -588,10 +566,16 @@ String check(String s, String x)\n \n     private static class TestContainerLifeCycle extends ContainerLifeCycle\n     {\n+        private final String _name;\n         private final AtomicInteger destroyed = new AtomicInteger();\n         private final AtomicInteger started = new AtomicInteger();\n         private final AtomicInteger stopped = new AtomicInteger();\n \n+        private TestContainerLifeCycle(String name)\n+        {\n+            _name = name;\n+        }\n+\n         @Override\n         protected void doStart() throws Exception\n         {\n@@ -612,17 +596,23 @@ public void destroy()\n             destroyed.incrementAndGet();\n             super.destroy();\n         }\n+        \n+        @Override\n+        public String toString()\n+        {\n+            return super.toString() + \"":\"" + _name;\n+        }\n     }\n \n     @Test\n     public void testGetBeans()\n     {\n-        TestContainerLifeCycle root = new TestContainerLifeCycle();\n-        TestContainerLifeCycle left = new TestContainerLifeCycle();\n+        TestContainerLifeCycle root = new TestContainerLifeCycle(\""root\"");\n+        TestContainerLifeCycle left = new TestContainerLifeCycle(\""left\"");\n         root.addBean(left);\n-        TestContainerLifeCycle right = new TestContainerLifeCycle();\n+        TestContainerLifeCycle right = new TestContainerLifeCycle(\""right\"");\n         root.addBean(right);\n-        TestContainerLifeCycle leaf = new TestContainerLifeCycle();\n+        TestContainerLifeCycle leaf = new TestContainerLifeCycle(\""leaf\"");\n         right.addBean(leaf);\n \n         root.addBean(0);\n@@ -668,9 +658,9 @@ protected void doStop() throws Exception\n     public void testFailedManagedBeanCanBeRestarted() throws Exception\n     {\n         AtomicBoolean fail = new AtomicBoolean();\n-        ContainerLifeCycle container = new ContainerLifeCycle();\n-        ContainerLifeCycle bean1 = new ContainerLifeCycle();\n-        ContainerLifeCycle bean2 = new ContainerLifeCycle()\n+        ContainerLifeCycle container = new TestContainerLifeCycle(\""container\"");\n+        ContainerLifeCycle bean1 = new TestContainerLifeCycle(\""bean1\"");\n+        ContainerLifeCycle bean2 = new TestContainerLifeCycle(\""bean2\"")\n         {\n             @Override\n             protected void doStart() throws Exception\n@@ -681,7 +671,7 @@ protected void doStart() throws Exception\n                     throw new RuntimeException();\n             }\n         };\n-        ContainerLifeCycle bean3 = new ContainerLifeCycle();\n+        ContainerLifeCycle bean3 = new TestContainerLifeCycle(\""bean3\"");\n         container.addBean(bean1);\n         container.addBean(bean2);\n         container.addBean(bean3);\n@@ -705,7 +695,7 @@ protected void doStart() throws Exception\n     public void testFailedAutoBeanIsNotRestarted() throws Exception\n     {\n         AtomicBoolean fail = new AtomicBoolean();\n-        ContainerLifeCycle bean = new ContainerLifeCycle()\n+        ContainerLifeCycle bean = new TestContainerLifeCycle(\""bean\"")\n         {\n             @Override\n             protected void doStart() throws Exception\n@@ -720,7 +710,7 @@ protected void doStart() throws Exception\n         assertThrows(RuntimeException.class, bean::start);\n \n         // The same bean now becomes part of a container.\n-        ContainerLifeCycle container = new ContainerLifeCycle();\n+        ContainerLifeCycle container = new TestContainerLifeCycle(\""container\"");\n         container.addBean(bean);\n         assertTrue(container.isAuto(bean));\n \n\ndiff --git a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/DumpableTest.java b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/DumpableTest.java\nindex 38bc50c0891e..78121a4c30b2 100644\n--- a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/DumpableTest.java\n+++ b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/DumpableTest.java\n@@ -15,6 +15,7 @@\n \n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.List;\n \n import org.hamcrest.Matchers;\n import org.junit.jupiter.api.Test;\n@@ -45,4 +46,32 @@ public void testNonNullDumpableCollection() throws Exception\n         assertThat(dump, Matchers.containsString(\""two\""));\n         assertThat(dump, Matchers.containsString(\""three\""));\n     }\n+\n+    @Test\n+    public void testDumpableCollectionWithCycle() throws Exception\n+    {\n+        List<Object> listC = new ArrayList<>();\n+        DumpableCollection c = new DumpableCollection(\""C\"", listC);\n+        DumpableCollection b = new DumpableCollection(\""B\"", List.of(\""si\"", \""see\"", \""sea\"", c));\n+        DumpableCollection a = new DumpableCollection(\""A\"", List.of(b, \""be\"", \""bee\""));\n+        listC.add(\""ay\"");\n+        listC.add(a);\n+        listC.add(\""ai\"");\n+\n+        String dump = a.dump();\n+        assertThat(dump, Matchers.startsWith(\""\""\""\n+            A size=3\n+            +> B size=4\n+            |  +> si\n+            |  +> see\n+            |  +> sea\n+            |  +> C size=3\n+            |     +> ay\n+            |     +>@ A size=3\n+            |     +> ai\n+            +> be\n+            +> bee\n+            legend: +- bean, += managed, +~ unmanaged, +? auto, +: iterable, +] array, +} map, +> pojo; @ visited\n+            JVM:\""\""\""));\n+    }\n }\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java\nindex 1d0e73216fc6..6560fff144a0 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java\n@@ -43,7 +43,6 @@\n import org.junit.jupiter.api.parallel.Isolated;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.is;\n \n @Isolated\n@@ -184,13 +183,12 @@ public void websocketProvidedByWebApp() throws Exception\n         // Collect the toString result of the ShutdownContainers from the dump.\n         String dump = server.getServer().dump();\n         List<String> results = Arrays.stream(dump.split(\""\\n\""))\n-            .filter(line -> line.contains(\""+> \"" + JakartaWebSocketShutdownContainer.class.getSimpleName())).toList();\n+            .filter(line -> line.contains(\""+- \""))\n+            .filter(line -> line.contains(JakartaWebSocketShutdownContainer.class.getSimpleName()))\n+            .filter(line -> line.contains(\""size=1\""))\n+            .toList();\n \n         // We only have 3 Shutdown Containers and they all contain only 1 item to be shutdown.\n         assertThat(dump, results.size(), is(3));\n-        for (String result : results)\n-        {\n-            assertThat(dump, result, containsString(\""size=1\""));\n-        }\n     }\n }\n\ndiff --git a/jetty-ee11/jetty-ee11-websocket/jetty-ee11-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee11/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java b/jetty-ee11/jetty-ee11-websocket/jetty-ee11-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee11/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java\nindex 56f0f9729945..5483b83e979e 100644\n--- a/jetty-ee11/jetty-ee11-websocket/jetty-ee11-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee11/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java\n+++ b/jetty-ee11/jetty-ee11-websocket/jetty-ee11-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee11/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java\n@@ -43,7 +43,6 @@\n import org.junit.jupiter.api.parallel.Isolated;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.is;\n \n @Isolated\n@@ -184,13 +183,12 @@ public void websocketProvidedByWebApp() throws Exception\n         // Collect the toString result of the ShutdownContainers from the dump.\n         String dump = server.getServer().dump();\n         List<String> results = Arrays.stream(dump.split(\""\\n\""))\n-            .filter(line -> line.contains(\""+> \"" + JakartaWebSocketShutdownContainer.class.getSimpleName())).toList();\n+            .filter(line -> line.contains(\""+- \""))\n+            .filter(line -> line.contains(JakartaWebSocketShutdownContainer.class.getSimpleName()))\n+            .filter(line -> line.contains(\""size=1\""))\n+            .toList();\n \n         // We only have 3 Shutdown Containers and they all contain only 1 item to be shutdown.\n         assertThat(dump, results.size(), is(3));\n-        for (String result : results)\n-        {\n-            assertThat(dump, result, containsString(\""size=1\""));\n-        }\n     }\n }\n\ndiff --git a/jetty-ee9/jetty-ee9-plus/src/test/java/org/eclipse/jetty/ee9/plus/jndi/TestNamingEntryUtil.java b/jetty-ee9/jetty-ee9-plus/src/test/java/org/eclipse/jetty/ee9/plus/jndi/TestNamingEntryUtil.java\nindex eb3696557e48..09d7ebc7db0b 100644\n--- a/jetty-ee9/jetty-ee9-plus/src/test/java/org/eclipse/jetty/ee9/plus/jndi/TestNamingEntryUtil.java\n+++ b/jetty-ee9/jetty-ee9-plus/src/test/java/org/eclipse/jetty/ee9/plus/jndi/TestNamingEntryUtil.java\n@@ -18,7 +18,6 @@\n import javax.naming.InitialContext;\n import javax.naming.Name;\n import javax.naming.NameNotFoundException;\n-import javax.naming.NameParser;\n import javax.naming.NamingException;\n \n import org.eclipse.jetty.ee9.webapp.WebAppContext;\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java\nindex c22e18bf8ed9..30da4a661a2c 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/JakartaClientShutdownWithServerWebAppTest.java\n@@ -43,7 +43,6 @@\n import org.junit.jupiter.api.Test;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.is;\n \n public class JakartaClientShutdownWithServerWebAppTest\n@@ -181,14 +180,14 @@ public void websocketProvidedByWebApp() throws Exception\n         assertThat(response.getStatus(), is(HttpStatus.OK_200));\n \n         // Collect the toString result of the ShutdownContainers from the dump.\n-        List<String> results = Arrays.stream(server.getServer().dump().split(\""\\n\""))\n-            .filter(line -> line.contains(\""+> \"" + JakartaWebSocketShutdownContainer.class.getSimpleName())).toList();\n+        String dump = server.getServer().dump();\n+        List<String> results = Arrays.stream(dump.split(\""\\n\""))\n+            .filter(line -> line.contains(\""+- \""))\n+            .filter(line -> line.contains(JakartaWebSocketShutdownContainer.class.getSimpleName()))\n+            .filter(line -> line.contains(\""size=1\""))\n+            .toList();\n \n         // We only have 3 Shutdown Containers and they all contain only 1 item to be shutdown.\n-        assertThat(results.size(), is(3));\n-        for (String result : results)\n-        {\n-            assertThat(result, containsString(\""size=1\""));\n-        }\n+        assertThat(dump, results.size(), is(3));\n     }\n }\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-12974"", ""pr_id"": 12974, ""issue_id"": 12965, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Allow `Resource` instances to provide `Content.Source` directly\n**Jetty version(s)**\n12.0.x\n\n**Enhancement Description**\nIOResources.asContentSource is a static helper method that wraps `Resource`s as `Content.Source`.\nThe helper has several implementations for different `Resource` subclasses / types of resources (with/without Path).\n\nUnfortunately, `Resource`s themselves have no say in how they are represented as `Content.Source`, leading to suboptimal performance (also as see in #12963).\n\nIt would be useful to have `asContentSource` either directly with this default implementation as a method in `Resource`, or \u2014 if that's not desired \u2014 allow Resources to implement a ContentSourceProvider interface that takes ` ByteBufferPool bufferPool, int bufferSize, boolean direct` etc. as arguments and returns the `Content.Source` implementation that best fits the model.\n\nOne example on how this could be used is for `Resources` that describe chunked content that is provided from databases, etc.\n\nSuch resources could return `Content.Source from(ByteBuffer... byteBuffers)` with multiple buffers, one per chunk. Or they could provide a sequence of `Source`s that are only turned into ByteBuffers on demand, etc.\n\nMoreover, this will also allow for Resource subclasses that indeed return a non-null `Path` but still want to provide their content via `newInputStream`, which currently is impossible.\n"", ""issue_word_count"": 204, ""test_files_count"": 6, ""non_test_files_count"": 10, ""pr_changed_files"": [""jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPart.java"", ""jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPartByteRanges.java"", ""jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPartFormData.java"", ""jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/MultiPartCaptureTest.java"", ""jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferPool.java"", ""jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/Content.java"", ""jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/IOResources.java"", ""jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/content/InputStreamContentSource.java"", ""jetty-core/jetty-io/src/test/java/org/eclipse/jetty/io/IOResourcesTest.java"", ""jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/ResourceService.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/BufferUtil.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/BufferUtilTest.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletMultiPartFormData.java"", ""jetty-ee10/jetty-ee10-webapp/src/test/java/org/eclipse/jetty/ee10/webapp/HugeResourceTest.java"", ""jetty-ee9/jetty-ee9-webapp/src/test/java/org/eclipse/jetty/ee9/webapp/HugeResourceTest.java"", ""tests/test-integration/src/test/java/org/eclipse/jetty/test/CoreMultiPartTest.java""], ""pr_changed_test_files"": [""jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/MultiPartCaptureTest.java"", ""jetty-core/jetty-io/src/test/java/org/eclipse/jetty/io/IOResourcesTest.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/BufferUtilTest.java"", ""jetty-ee10/jetty-ee10-webapp/src/test/java/org/eclipse/jetty/ee10/webapp/HugeResourceTest.java"", ""jetty-ee9/jetty-ee9-webapp/src/test/java/org/eclipse/jetty/ee9/webapp/HugeResourceTest.java"", ""tests/test-integration/src/test/java/org/eclipse/jetty/test/CoreMultiPartTest.java""], ""base_commit"": ""a89ea96c7d27b2043702d699f98bb36bbe832f33"", ""head_commit"": ""f1ec074ffac3c6ec6d28e290b0b8258aa5d42992"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/12974"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/12974"", ""dockerfile"": """", ""pr_merged_at"": ""2025-04-14T07:09:05.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPart.java b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPart.java\nindex ef60d2e46454..36cab3ba814c 100644\n--- a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPart.java\n+++ b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPart.java\n@@ -34,6 +34,7 @@\n import java.util.Queue;\n import java.util.concurrent.ThreadLocalRandom;\n \n+import org.eclipse.jetty.io.ByteBufferPool;\n import org.eclipse.jetty.io.Content;\n import org.eclipse.jetty.io.content.ByteBufferContentSource;\n import org.eclipse.jetty.io.content.ChunksContentSource;\n@@ -127,11 +128,14 @@ public static String generateBoundary(String prefix, int randomLength)\n      * <p>A part has an optional name, an optional fileName,\n      * optional headers and an optional content.</p>\n      */\n-    public abstract static class Part implements Closeable\n+    public abstract static class Part implements Content.Source.Factory, Closeable\n     {\n         static final Throwable CLOSE_EXCEPTION = new StaticException(\""Closed\"");\n \n         private final AutoLock lock = new AutoLock();\n+        private final ByteBufferPool.Sized bufferPool;\n+        private final long first;\n+        private final long length;\n         private final String name;\n         private final String fileName;\n         private final HttpFields fields;\n@@ -139,13 +143,30 @@ public abstract static class Part implements Closeable\n         private Content.Source contentSource;\n         private boolean temporary;\n \n+        /**\n+         * @deprecated use {@link #Part(ByteBufferPool.Sized, String, String, HttpFields)} instead.\n+         */\n+        @Deprecated(since = \""12.0.20\"", forRemoval = true)\n         public Part(String name, String fileName, HttpFields fields)\n         {\n-            this(name, fileName, fields, null);\n+            this(null, 0L, -1L, name, fileName, fields, null);\n+        }\n+\n+        public Part(ByteBufferPool.Sized bufferPool, String name, String fileName, HttpFields fields)\n+        {\n+            this(bufferPool, 0L, -1L, name, fileName, fields, null);\n         }\n \n-        private Part(String name, String fileName, HttpFields fields, Path path)\n+        public Part(ByteBufferPool.Sized bufferPool, long first, long length, String name, String fileName, HttpFields fields)\n         {\n+            this(bufferPool, first, length, name, fileName, fields, null);\n+        }\n+\n+        private Part(ByteBufferPool.Sized bufferPool, long first, long length, String name, String fileName, HttpFields fields, Path path)\n+        {\n+            this.bufferPool = bufferPool;\n+            this.first = first;\n+            this.length = length;\n             this.name = name;\n             this.fileName = fileName;\n             this.fields = fields != null ? fields : HttpFields.EMPTY;\n@@ -205,7 +226,7 @@ public Content.Source getContentSource()\n             try (AutoLock ignored = lock.lock())\n             {\n                 if (contentSource == null)\n-                    contentSource = newContentSource();\n+                    contentSource = newContentSource(bufferPool, first, length);\n                 return contentSource;\n             }\n         }\n@@ -222,8 +243,33 @@ public Content.Source getContentSource()\n          *\n          * @return the content of this part as a new {@link Content.Source} or null if the content cannot be consumed multiple times.\n          * @see #getContentSource()\n+         * @deprecated override {@link #newContentSource(ByteBufferPool.Sized, long, long)} instead.\n          */\n-        public abstract Content.Source newContentSource();\n+        @Deprecated(since = \""12.0.20\"", forRemoval = true)\n+        public Content.Source newContentSource()\n+        {\n+            return null;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         *\n+         * <p>Returns the content of this part as a new {@link Content.Source}</p>\n+         * <p>If the content is reproducible, invoking this method multiple times will return\n+         * a different independent instance for every invocation.</p>\n+         * <p>If the content is not reproducible, subsequent calls to this method will return null.</p>\n+         * <p>The content type and content encoding are specified in this part's {@link #getHeaders() headers}.</p>\n+         * <p>The content encoding may be specified by the part named {@code _charset_},\n+         * as specified in\n+         * <a href=\""https://datatracker.ietf.org/doc/html/rfc7578#section-4.6\"">RFC 7578, section 4.6</a>.</p>\n+         *\n+         * @see #getContentSource()\n+         */\n+        @Override\n+        public Content.Source newContentSource(ByteBufferPool.Sized bufferPool, long first, long length)\n+        {\n+            return newContentSource();\n+        }\n \n         public long getLength()\n         {\n@@ -255,7 +301,7 @@ public String getContentAsString(Charset defaultCharset)\n                 Charset charset = defaultCharset != null ? defaultCharset : UTF_8;\n                 if (charsetName != null)\n                     charset = Charset.forName(charsetName);\n-                return Content.Source.asString(newContentSource(), charset);\n+                return Content.Source.asString(newContentSource(bufferPool, first, length), charset);\n             }\n             catch (IOException x)\n             {\n@@ -285,7 +331,7 @@ public void writeTo(Path path) throws IOException\n             {\n                 try (OutputStream out = Files.newOutputStream(path))\n                 {\n-                    IO.copy(Content.Source.asInputStream(newContentSource()), out);\n+                    IO.copy(Content.Source.asInputStream(newContentSource(bufferPool, first, length)), out);\n                 }\n                 newPath = path;\n             }\n@@ -363,12 +409,12 @@ public ByteBufferPart(String name, String fileName, HttpFields fields, ByteBuffe\n \n         public ByteBufferPart(String name, String fileName, HttpFields fields, List<ByteBuffer> content)\n         {\n-            super(name, fileName, fields);\n+            super(null, name, fileName, fields);\n             this.content = content;\n         }\n \n         @Override\n-        public Content.Source newContentSource()\n+        public Content.Source newContentSource(ByteBufferPool.Sized bufferPool, long first, long length)\n         {\n             return new ByteBufferContentSource(content);\n         }\n@@ -398,13 +444,13 @@ public static class ChunksPart extends Part\n \n         public ChunksPart(String name, String fileName, HttpFields fields, List<Content.Chunk> content)\n         {\n-            super(name, fileName, fields);\n+            super(null, name, fileName, fields);\n             this.content.addAll(content);\n             content.forEach(Content.Chunk::retain);\n         }\n \n         @Override\n-        public Content.Source newContentSource()\n+        public Content.Source newContentSource(ByteBufferPool.Sized bufferPool, long first, long length)\n         {\n             try (AutoLock ignored = lock.lock())\n             {\n@@ -462,9 +508,18 @@ public String toString()\n      */\n     public static class PathPart extends Part\n     {\n+        /**\n+         * @deprecated use {@link #PathPart(ByteBufferPool.Sized, String, String, HttpFields, Path)} instead.\n+         */\n+        @Deprecated(since = \""12.0.20\"", forRemoval = true)\n         public PathPart(String name, String fileName, HttpFields fields, Path path)\n         {\n-            super(name, fileName, fields, path);\n+            super(null, 0L, -1L, name, fileName, fields, path);\n+        }\n+\n+        public PathPart(ByteBufferPool.Sized bufferPool, String name, String fileName, HttpFields fields, Path path)\n+        {\n+            super(bufferPool, 0L, -1L, name, fileName, fields, path);\n         }\n \n         public Path getPath()\n@@ -473,10 +528,9 @@ public Path getPath()\n         }\n \n         @Override\n-        public Content.Source newContentSource()\n+        public Content.Source newContentSource(ByteBufferPool.Sized bufferPool, long first, long length)\n         {\n-            // TODO: use a ByteBuffer pool and direct ByteBuffers?\n-            return Content.Source.from(getPath());\n+            return Content.Source.from(bufferPool, getPath(), first, length);\n         }\n \n         @Override\n@@ -501,12 +555,12 @@ public static class ContentSourcePart extends Part\n \n         public ContentSourcePart(String name, String fileName, HttpFields fields, Content.Source content)\n         {\n-            super(name, fileName, fields);\n+            super(null, name, fileName, fields);\n             this.content = Objects.requireNonNull(content);\n         }\n \n         @Override\n-        public Content.Source newContentSource()\n+        public Content.Source newContentSource(ByteBufferPool.Sized bufferPool, long first, long length)\n         {\n             Content.Source c = content;\n             content = null;\n\ndiff --git a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPartByteRanges.java b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPartByteRanges.java\nindex 8651bc37a39d..323d25349804 100644\n--- a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPartByteRanges.java\n+++ b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPartByteRanges.java\n@@ -19,6 +19,7 @@\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Objects;\n import java.util.concurrent.CompletableFuture;\n \n import org.eclipse.jetty.io.ByteBufferPool;\n@@ -221,8 +222,6 @@ public boolean rewind()\n     public static class Part extends MultiPart.Part\n     {\n         private final Resource resource;\n-        private final ByteRange byteRange;\n-        private final ByteBufferPool bufferPool;\n \n         public Part(String contentType, Resource resource, ByteRange byteRange, long contentLength)\n         {\n@@ -230,7 +229,17 @@ public Part(String contentType, Resource resource, ByteRange byteRange, long con\n                 .put(HttpHeader.CONTENT_RANGE, byteRange.toHeaderValue(contentLength)), resource, byteRange, null);\n         }\n \n+        /**\n+         * @deprecated use {@link #Part(String, Resource, ByteRange, long, ByteBufferPool.Sized)} instead.\n+         */\n+        @Deprecated(since = \""12.0.20\"", forRemoval = true)\n         public Part(String contentType, Resource resource, ByteRange byteRange, long contentLength, ByteBufferPool bufferPool)\n+        {\n+            this(HttpFields.build().put(HttpHeader.CONTENT_TYPE, contentType)\n+                .put(HttpHeader.CONTENT_RANGE, byteRange.toHeaderValue(contentLength)), resource, byteRange, new ByteBufferPool.Sized(bufferPool));\n+        }\n+\n+        public Part(String contentType, Resource resource, ByteRange byteRange, long contentLength, ByteBufferPool.Sized bufferPool)\n         {\n             this(HttpFields.build().put(HttpHeader.CONTENT_TYPE, contentType)\n                 .put(HttpHeader.CONTENT_RANGE, byteRange.toHeaderValue(contentLength)), resource, byteRange, bufferPool);\n@@ -241,18 +250,25 @@ public Part(HttpFields headers, Resource resource, ByteRange byteRange)\n             this(headers, resource, byteRange, null);\n         }\n \n+        /**\n+         * @deprecated use {@link #Part(HttpFields, Resource, ByteRange, ByteBufferPool.Sized)} instead.\n+         */\n+        @Deprecated(since = \""12.0.20\"", forRemoval = true)\n         public Part(HttpFields headers, Resource resource, ByteRange byteRange, ByteBufferPool bufferPool)\n         {\n-            super(null, null, headers);\n+            this(headers, resource, byteRange, new ByteBufferPool.Sized(bufferPool));\n+        }\n+\n+        public Part(HttpFields headers, Resource resource, ByteRange byteRange, ByteBufferPool.Sized bufferPool)\n+        {\n+            super(Objects.requireNonNullElse(bufferPool, ByteBufferPool.SIZED_NON_POOLING), byteRange.first(), byteRange.getLength(), null, null, headers);\n             this.resource = resource;\n-            this.byteRange = byteRange;\n-            this.bufferPool = bufferPool == null ? ByteBufferPool.NON_POOLING : bufferPool;\n         }\n \n         @Override\n-        public Content.Source newContentSource()\n+        public Content.Source newContentSource(ByteBufferPool.Sized bufferPool, long first, long length)\n         {\n-            return IOResources.asContentSource(resource, bufferPool, 0, false, byteRange.first(), byteRange.getLength());\n+            return IOResources.asContentSource(resource, bufferPool.getWrapped(), bufferPool.getSize(), bufferPool.isDirect(), first, length);\n         }\n     }\n \n\ndiff --git a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPartFormData.java b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPartFormData.java\nindex 1414a42f1d85..800f20600b5d 100644\n--- a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPartFormData.java\n+++ b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/MultiPartFormData.java\n@@ -855,7 +855,7 @@ public void onPart(String name, String fileName, HttpFields headers)\n \n                     MultiPart.Part part;\n                     if (fileChannel != null)\n-                        part = new MultiPart.PathPart(name, fileName, headers, filePath);\n+                        part = new MultiPart.PathPart(null, name, fileName, headers, filePath); // TODO use a pool\n                     else\n                         part = new MultiPart.ChunksPart(name, fileName, headers, List.copyOf(partChunks));\n                     // Reset part-related state.\n\ndiff --git a/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferPool.java b/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferPool.java\nindex e988d28efbf0..fe6b1bd7e888 100644\n--- a/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferPool.java\n+++ b/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/ByteBufferPool.java\n@@ -130,7 +130,7 @@ public Sized(ByteBufferPool wrapped)\n          * Create a sized pool for a give directness and size from a wrapped pool.\n          * @param wrapped The actual {@link ByteBufferPool}\n          * @param direct {@code true} for direct buffers.\n-         * @param size The specified size in bytes of the buffer, or -1 for a default\n+         * @param size The specified size in bytes of the buffer, any value less than 1 means use a default value.\n          */\n         public Sized(ByteBufferPool wrapped, boolean direct, int size)\n         {\n@@ -156,6 +156,24 @@ public RetainableByteBuffer acquire()\n         {\n             return getWrapped().acquire(_size, _direct);\n         }\n+\n+        /**\n+         * @return A {@link RetainableByteBuffer} suitable for the specified preconfigured type.\n+         * @param size The specified size in bytes of the buffer\n+         */\n+        public RetainableByteBuffer acquire(int size)\n+        {\n+            return getWrapped().acquire(size, _direct);\n+        }\n+\n+        /**\n+         * @return A {@link RetainableByteBuffer} suitable for the specified preconfigured size.\n+         * @param direct true for a direct byte buffer, false otherwise\n+         */\n+        public RetainableByteBuffer acquire(boolean direct)\n+        {\n+            return getWrapped().acquire(_size, direct);\n+        }\n     }\n \n     /**\n\ndiff --git a/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/Content.java b/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/Content.java\nindex a35c503cf37f..35a186a86b90 100644\n--- a/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/Content.java\n+++ b/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/Content.java\n@@ -155,6 +155,22 @@ public static void copy(Source source, Sink sink, Chunk.Processor chunkProcessor\n      */\n     public interface Source\n     {\n+        /**\n+         * Factory of {@link Content.Source}.\n+         */\n+        interface Factory\n+        {\n+            /**\n+             * Creates a new {@link Content.Source}.\n+             *\n+             * @param bufferPool the {@link ByteBufferPool.Sized} to get buffers from. {@code null} means allocate new buffers as needed.\n+             * @param first the first byte of the resource to start from.\n+             * @param length the length of the content to make available, -1 for the full length.\n+             * @return a {@link Content.Source}.\n+             */\n+            Content.Source newContentSource(ByteBufferPool.Sized bufferPool, long first, long length);\n+        }\n+\n         /**\n          * Create a {@code Content.Source} from zero or more {@link ByteBuffer}s\n          * @param byteBuffers The {@link ByteBuffer}s to use as the source.\n\ndiff --git a/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/IOResources.java b/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/IOResources.java\nindex ed8d6ed29640..696f9e5a62e0 100644\n--- a/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/IOResources.java\n+++ b/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/IOResources.java\n@@ -21,7 +21,6 @@\n import java.nio.file.Path;\n \n import org.eclipse.jetty.io.content.ByteBufferContentSource;\n-import org.eclipse.jetty.io.content.InputStreamContentSource;\n import org.eclipse.jetty.util.BufferUtil;\n import org.eclipse.jetty.util.Callback;\n import org.eclipse.jetty.util.IO;\n@@ -42,7 +41,7 @@ public class IOResources\n      * {@link Resource#newInputStream()} is used as a fallback.</p>\n      *\n      * @param resource the resource to be read.\n-     * @param bufferPool the {@link ByteBufferPool} to get buffers from. null means allocate new buffers as needed.\n+     * @param bufferPool the {@link ByteBufferPool} to get buffers from. {@code null} means allocate new buffers as needed.\n      * @param direct the directness of the buffers.\n      * @return a {@link RetainableByteBuffer} containing the resource's contents.\n      * @throws IllegalArgumentException if the resource is a directory or does not exist or there is no way to access its contents.\n@@ -52,6 +51,20 @@ public static RetainableByteBuffer toRetainableByteBuffer(Resource resource, Byt\n         if (resource.isDirectory() || !resource.exists())\n             throw new IllegalArgumentException(\""Resource must exist and cannot be a directory: \"" + resource);\n \n+        // Optimize for Content.Source.Factory.\n+        if (resource instanceof Content.Source.Factory factory)\n+        {\n+            try\n+            {\n+                ByteBuffer buffer = Content.Source.asByteBuffer(factory.newContentSource(new ByteBufferPool.Sized(bufferPool, direct, 0), 0L, -1L));\n+                return RetainableByteBuffer.wrap(buffer);\n+            }\n+            catch (IOException e)\n+            {\n+                throw new RuntimeIOException(e);\n+            }\n+        }\n+\n         // Optimize for MemoryResource.\n         if (resource instanceof MemoryResource memoryResource)\n             return RetainableByteBuffer.wrap(ByteBuffer.wrap(memoryResource.getBytes()));\n@@ -121,8 +134,8 @@ public static RetainableByteBuffer toRetainableByteBuffer(Resource resource, Byt\n      * {@link Resource#newInputStream()} is used as a fallback.</p>\n      *\n      * @param resource the resource from which to get a {@link Content.Source}.\n-     * @param bufferPool the {@link ByteBufferPool} to get buffers from. null means allocate new buffers as needed.\n-     * @param bufferSize the size of the buffer to be used for the copy. Any value &lt; 1 means use a default value.\n+     * @param bufferPool the {@link ByteBufferPool} to get buffers from. {@code null} means allocate new buffers as needed.\n+     * @param bufferSize the size of the buffer to be used for the copy. Any value less than 1 means use a default value.\n      * @param direct the directness of the buffers, this parameter is ignored if {@code bufferSize} is &lt; 1.\n      * @return the {@link Content.Source}.\n      * @throws IllegalArgumentException if the resource is a directory or does not exist or there is no way to access its contents.\n@@ -133,21 +146,21 @@ public static Content.Source asContentSource(Resource resource, ByteBufferPool b\n             throw new IllegalArgumentException(\""Resource must exist and cannot be a directory: \"" + resource);\n \n         // Try to find an optimized content source.\n+        if (resource instanceof Content.Source.Factory factory)\n+            return factory.newContentSource(new ByteBufferPool.Sized(bufferPool, direct, bufferSize), 0, -1);\n         Path path = resource.getPath();\n         if (path != null)\n-        {\n-            return Content.Source.from(new ByteBufferPool.Sized(bufferPool, direct, bufferSize), path, 0, -1);\n-        }\n+            return Content.Source.from(new ByteBufferPool.Sized(bufferPool, direct, bufferSize), path);\n         if (resource instanceof MemoryResource memoryResource)\n-        {\n-            byte[] bytes = memoryResource.getBytes();\n-            return new ByteBufferContentSource(ByteBuffer.wrap(bytes));\n-        }\n+            return new ByteBufferContentSource(ByteBuffer.wrap(memoryResource.getBytes()));\n \n         // Fallback to wrapping InputStream.\n         try\n         {\n-            return new InputStreamContentSource(resource.newInputStream(), new ByteBufferPool.Sized(bufferPool, false, bufferSize));\n+            InputStream inputStream = resource.newInputStream();\n+            if (inputStream == null)\n+                throw new IllegalArgumentException(\""Resource does not support InputStream: \"" + resource);\n+            return Content.Source.from(new ByteBufferPool.Sized(bufferPool, direct, bufferSize), inputStream);\n         }\n         catch (IOException e)\n         {\n@@ -163,11 +176,11 @@ public static Content.Source asContentSource(Resource resource, ByteBufferPool b\n      * {@link Resource#newInputStream()} is used as a fallback.</p>\n      *\n      * @param resource the resource from which to get a {@link Content.Source}.\n-     * @param bufferPool the {@link ByteBufferPool} to get buffers from. null means allocate new buffers as needed.\n-     * @param bufferSize the size of the buffer to be used for the copy. Any value &lt; 1 means use a default value.\n+     * @param bufferPool the {@link ByteBufferPool} to get buffers from. {@code null} means allocate new buffers as needed.\n+     * @param bufferSize the size of the buffer to be used for the copy. Any value less than 1 means use a default value.\n      * @param direct the directness of the buffers, this parameter is ignored if {@code bufferSize} is &lt; 1.\n      * @param first the first byte from which to read from.\n-     * @param length the length of the content to read.\n+     * @param length the length of the content to read, -1 for the full length.\n      * @return the {@link Content.Source}.\n      * @throws IllegalArgumentException if the resource is a directory or does not exist or there is no way to access its contents.\n      */\n@@ -176,16 +189,18 @@ public static Content.Source asContentSource(Resource resource, ByteBufferPool b\n         if (resource.isDirectory() || !resource.exists())\n             throw new IllegalArgumentException(\""Resource must exist and cannot be a directory: \"" + resource);\n \n+        // Try Content.Source.Factory.\n+        if (resource instanceof Content.Source.Factory factory)\n+            return factory.newContentSource(new ByteBufferPool.Sized(bufferPool, direct, bufferSize), first, length);\n+\n         // Try using the resource's path if possible, as the nio API is async and helps to avoid buffer copies.\n         Path path = resource.getPath();\n         if (path != null)\n-        {\n             return Content.Source.from(new ByteBufferPool.Sized(bufferPool, direct, bufferSize), path, first, length);\n-        }\n \n         // Try an optimization for MemoryResource.\n         if (resource instanceof MemoryResource memoryResource)\n-            return Content.Source.from(ByteBuffer.wrap(memoryResource.getBytes()));\n+            return Content.Source.from(BufferUtil.slice(ByteBuffer.wrap(memoryResource.getBytes()), Math.toIntExact(first), Math.toIntExact(length)));\n \n         // Fallback to InputStream.\n         try\n@@ -235,43 +250,52 @@ public static InputStream asInputStream(Resource resource) throws IllegalArgumen\n      *\n      * @param resource the resource to copy from.\n      * @param sink the sink to copy to.\n-     * @param bufferPool the {@link ByteBufferPool} to get buffers from. null means allocate new buffers as needed.\n-     * @param bufferSize the size of the buffer to be used for the copy. Any value &lt; 1 means use a default value.\n+     * @param bufferPool the {@link ByteBufferPool} to get buffers from. {@code null} means allocate new buffers as needed.\n+     * @param bufferSize the size of the buffer to be used for the copy. Any value less than 1 means use a default value.\n      * @param direct the directness of the buffers, this parameter is ignored if {@code bufferSize} is &lt; 1.\n      * @param callback the callback to notify when the copy is done.\n-     * @throws IllegalArgumentException if the resource is a directory or does not exist or there is no way to access its contents.\n      */\n-    public static void copy(Resource resource, Content.Sink sink, ByteBufferPool bufferPool, int bufferSize, boolean direct, Callback callback) throws IllegalArgumentException\n+    public static void copy(Resource resource, Content.Sink sink, ByteBufferPool bufferPool, int bufferSize, boolean direct, Callback callback)\n     {\n-        if (resource.isDirectory() || !resource.exists())\n-            throw new IllegalArgumentException(\""Resource must exist and cannot be a directory: \"" + resource);\n-\n-        // Save a Content.Source allocation for resources with a Path.\n-        Path path = resource.getPath();\n-        if (path != null)\n+        try\n         {\n-            try\n+            if (resource.isDirectory() || !resource.exists())\n+                throw new IllegalArgumentException(\""Resource must exist and cannot be a directory: \"" + resource);\n+\n+            // Check if the resource is a Content.Source.Factory as the first step.\n+            if (resource instanceof Content.Source.Factory factory)\n+            {\n+                Content.Source source = factory.newContentSource(new ByteBufferPool.Sized(bufferPool, direct, bufferSize), 0, -1);\n+                Content.copy(source, sink, callback);\n+                return;\n+            }\n+\n+            // Save a Content.Source allocation for resources with a Path.\n+            Path path = resource.getPath();\n+            if (path != null)\n             {\n                 new PathToSinkCopier(path, sink, bufferPool, bufferSize, direct, callback).iterate();\n+                return;\n             }\n-            catch (Throwable x)\n+\n+            // Directly write the byte array if the resource is a MemoryResource.\n+            if (resource instanceof MemoryResource memoryResource)\n             {\n-                callback.failed(x);\n+                sink.write(true, ByteBuffer.wrap(memoryResource.getBytes()), callback);\n+                return;\n             }\n-            return;\n-        }\n \n-        // Directly write the byte array if the resource is a MemoryResource.\n-        if (resource instanceof MemoryResource memoryResource)\n+            // Fallback to Content.Source.\n+            InputStream inputStream = resource.newInputStream();\n+            if (inputStream == null)\n+                throw new IllegalArgumentException(\""Resource does not support InputStream: \"" + resource);\n+            Content.Source source = Content.Source.from(new ByteBufferPool.Sized(bufferPool, direct, bufferSize), inputStream, 0, -1);\n+            Content.copy(source, sink, callback);\n+        }\n+        catch (Throwable x)\n         {\n-            byte[] bytes = memoryResource.getBytes();\n-            sink.write(true, ByteBuffer.wrap(bytes), callback);\n-            return;\n+            callback.failed(x);\n         }\n-\n-        // Fallback to Content.Source.\n-        Content.Source source = asContentSource(resource, bufferPool, bufferSize, direct);\n-        Content.copy(source, sink, callback);\n     }\n \n     /**\n@@ -283,50 +307,54 @@ public static void copy(Resource resource, Content.Sink sink, ByteBufferPool buf\n      *\n      * @param resource the resource to copy from.\n      * @param sink the sink to copy to.\n-     * @param bufferPool the {@link ByteBufferPool} to get buffers from. null means allocate new buffers as needed.\n-     * @param bufferSize the size of the buffer to be used for the copy. Any value &lt; 1 means use a default value.\n+     * @param bufferPool the {@link ByteBufferPool} to get buffers from. {@code null} means allocate new buffers as needed.\n+     * @param bufferSize the size of the buffer to be used for the copy. Any value less than 1 means use a default value.\n      * @param direct the directness of the buffers, this parameter is ignored if {@code bufferSize} is &lt; 1.\n      * @param first the first byte of the resource to start from.\n      * @param length the length of the resource's contents to copy.\n      * @param callback the callback to notify when the copy is done.\n-     * @throws IllegalArgumentException if the resource is a directory or does not exist or there is no way to access its contents.\n      */\n-    public static void copy(Resource resource, Content.Sink sink, ByteBufferPool bufferPool, int bufferSize, boolean direct, long first, long length, Callback callback) throws IllegalArgumentException\n+    public static void copy(Resource resource, Content.Sink sink, ByteBufferPool bufferPool, int bufferSize, boolean direct, long first, long length, Callback callback)\n     {\n-        if (resource.isDirectory() || !resource.exists())\n-            throw new IllegalArgumentException(\""Resource must exist and cannot be a directory: \"" + resource);\n-\n-        // Save a Content.Source allocation for resources with a Path.\n-        Path path = resource.getPath();\n-        if (path != null)\n+        try\n         {\n-            try\n+            if (resource.isDirectory() || !resource.exists())\n+                throw new IllegalArgumentException(\""Resource must exist and cannot be a directory: \"" + resource);\n+\n+            // Check if the resource is a Content.Source.Factory as the first step.\n+            if (resource instanceof Content.Source.Factory factory)\n+            {\n+                Content.Source source = factory.newContentSource(new ByteBufferPool.Sized(bufferPool, direct, bufferSize), first, length);\n+                Content.copy(source, sink, callback);\n+                return;\n+            }\n+\n+            // Save a Content.Source allocation for resources with a Path.\n+            Path path = resource.getPath();\n+            if (path != null)\n             {\n                 new PathToSinkCopier(path, sink, bufferPool, bufferSize, direct, first, length, callback).iterate();\n+                return;\n             }\n-            catch (Throwable x)\n+\n+            // Directly write the byte array if the resource is a MemoryResource.\n+            if (resource instanceof MemoryResource memoryResource)\n             {\n-                callback.failed(x);\n+                sink.write(true, BufferUtil.slice(ByteBuffer.wrap(memoryResource.getBytes()), Math.toIntExact(first), Math.toIntExact(length)), callback);\n+                return;\n             }\n-            return;\n-        }\n \n-        // Directly write the byte array if the resource is a MemoryResource.\n-        if (resource instanceof MemoryResource memoryResource)\n+            // Fallback to Content.Source.\n+            InputStream inputStream = resource.newInputStream();\n+            if (inputStream == null)\n+                throw new IllegalArgumentException(\""Resource does not support InputStream: \"" + resource);\n+            Content.Source source = Content.Source.from(new ByteBufferPool.Sized(bufferPool, direct, bufferSize), inputStream, first, length);\n+            Content.copy(source, sink, callback);\n+        }\n+        catch (Throwable x)\n         {\n-            byte[] bytes = memoryResource.getBytes();\n-            ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n-            if (first >= 0)\n-                byteBuffer.position((int)first);\n-            if (length >= 0)\n-                byteBuffer.limit((int)(byteBuffer.position() + length));\n-            sink.write(true, byteBuffer, callback);\n-            return;\n+            callback.failed(x);\n         }\n-\n-        // Fallback to Content.Source.\n-        Content.Source source = asContentSource(resource, bufferPool, bufferSize, direct, first, length);\n-        Content.copy(source, sink, callback);\n     }\n \n     private static class PathToSinkCopier extends IteratingNestedCallback\n\ndiff --git a/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/content/InputStreamContentSource.java b/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/content/InputStreamContentSource.java\nindex dcce4d5c7ce2..157abbe492d7 100644\n--- a/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/content/InputStreamContentSource.java\n+++ b/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/content/InputStreamContentSource.java\n@@ -110,7 +110,7 @@ public Content.Chunk read()\n                 return Content.Chunk.EOF;\n         }\n \n-        RetainableByteBuffer streamBuffer = bufferPool.acquire();\n+        RetainableByteBuffer streamBuffer = bufferPool.acquire(false);\n         try\n         {\n             ByteBuffer buffer = streamBuffer.getByteBuffer();\n\ndiff --git a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/ResourceService.java b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/ResourceService.java\nindex b367f376ea01..1578dfa171ed 100644\n--- a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/ResourceService.java\n+++ b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/ResourceService.java\n@@ -700,7 +700,7 @@ private void sendData(Request request, Response response, Callback callback, Htt\n         String contentType = \""multipart/byteranges; boundary=\"";\n         String boundary = MultiPart.generateBoundary(null, 24);\n         MultiPartByteRanges.ContentSource byteRanges = new MultiPartByteRanges.ContentSource(boundary);\n-        ranges.forEach(range -> byteRanges.addPart(new MultiPartByteRanges.Part(content.getContentTypeValue(), content.getResource(), range, contentLength, request.getComponents().getByteBufferPool())));\n+        ranges.forEach(range -> byteRanges.addPart(new MultiPartByteRanges.Part(content.getContentTypeValue(), content.getResource(), range, contentLength, request.getComponents().getByteBufferPool()))); // TODO use a sized pool\n         byteRanges.close();\n         long partsContentLength = byteRanges.getLength();\n         putHeaders(response, content, partsContentLength);\n\ndiff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/BufferUtil.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/BufferUtil.java\nindex 39d22fb451eb..5dcfb3044ac3 100644\n--- a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/BufferUtil.java\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/BufferUtil.java\n@@ -286,6 +286,31 @@ public static void putIntLittleEndian(ByteBuffer buffer, int value)\n         flipToFlush(buffer, p);\n     }\n \n+    /**\n+     * Slice a buffer given an offset and a length, similar to RFC 7233 ranges.\n+     * @param buffer the buffer to slice\n+     * @param offset the offset, relative to the current position of the buffer, must be positive\n+     * @param length the length, -1 meaning use the current limit\n+     * @return the sliced buffer\n+     */\n+    public static ByteBuffer slice(ByteBuffer buffer, int offset, int length)\n+    {\n+        if (offset < 0)\n+            throw new IllegalArgumentException(\""Invalid offset: \"" + offset);\n+        ByteBuffer slice = buffer.slice();\n+        if (offset > 0)\n+        {\n+            int newPosition = slice.position() + offset;\n+            if (newPosition > slice.limit() && length == 0)\n+                slice.position(slice.limit());\n+            else\n+                slice.position(newPosition);\n+        }\n+        if (length > -1)\n+            slice.limit(slice.position() + length);\n+        return slice;\n+    }\n+\n     /**\n      * Convert a ByteBuffer to a byte array.\n      *\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletMultiPartFormData.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletMultiPartFormData.java\nindex f3486247f308..53f4cfb893df 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletMultiPartFormData.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletMultiPartFormData.java\n@@ -278,7 +278,7 @@ private ServletPart(Path directory, MultiPart.Part part)\n         @Override\n         public InputStream getInputStream() throws IOException\n         {\n-            return Content.Source.asInputStream(_part.newContentSource());\n+            return Content.Source.asInputStream(_part.newContentSource(null, 0L, -1L)); // TODO use a pool\n         }\n \n         @Override\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/MultiPartCaptureTest.java b/jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/MultiPartCaptureTest.java\nindex 171b9831261f..e31a458a6a9e 100644\n--- a/jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/MultiPartCaptureTest.java\n+++ b/jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/MultiPartCaptureTest.java\n@@ -139,16 +139,16 @@ public String getContentType()\n         @Override\n         public ByteBuffer asByteBuffer() throws IOException\n         {\n-            return Content.Source.asByteBuffer(namedPart.newContentSource());\n+            return Content.Source.asByteBuffer(namedPart.newContentSource(null, 0, -1));\n         }\n \n         @Override\n         public String asString(Charset charset) throws IOException\n         {\n             if (charset == null)\n-                return Content.Source.asString(namedPart.newContentSource());\n+                return Content.Source.asString(namedPart.newContentSource(null, 0, -1));\n             else\n-                return Content.Source.asString(namedPart.newContentSource(), charset);\n+                return Content.Source.asString(namedPart.newContentSource(null, 0, -1), charset);\n         }\n \n         @Override\n@@ -160,7 +160,7 @@ public String getFileName()\n         @Override\n         public InputStream asInputStream()\n         {\n-            return Content.Source.asInputStream(namedPart.newContentSource());\n+            return Content.Source.asInputStream(namedPart.newContentSource(null, 0, -1));\n         }\n     }\n \n\ndiff --git a/jetty-core/jetty-io/src/test/java/org/eclipse/jetty/io/IOResourcesTest.java b/jetty-core/jetty-io/src/test/java/org/eclipse/jetty/io/IOResourcesTest.java\nindex 8bbc13377601..d9925e329dce 100644\n--- a/jetty-core/jetty-io/src/test/java/org/eclipse/jetty/io/IOResourcesTest.java\n+++ b/jetty-core/jetty-io/src/test/java/org/eclipse/jetty/io/IOResourcesTest.java\n@@ -13,22 +13,32 @@\n \n package org.eclipse.jetty.io;\n \n+import java.io.InputStream;\n import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.util.List;\n+import java.util.concurrent.ExecutionException;\n import java.util.stream.Stream;\n \n import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n+import org.eclipse.jetty.util.BufferUtil;\n import org.eclipse.jetty.util.Callback;\n import org.eclipse.jetty.util.resource.Resource;\n import org.eclipse.jetty.util.resource.ResourceFactory;\n import org.eclipse.jetty.util.resource.URLResourceFactory;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.MethodSource;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.instanceOf;\n import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class IOResourcesTest\n {\n@@ -46,12 +56,95 @@ public void tearDown()\n         assertThat(\""Leaks: \"" + bufferPool.dumpLeaks(), bufferPool.getLeaks().size(), is(0));\n     }\n \n-    public static Stream<Resource> all()\n+    // This Resource impl has getPath() and newInputStream() throw so the only way for IOResources\n+    // to read its contents is to call newContentSource().\n+    private static class TestContentSourceFactoryResource extends Resource implements Content.Source.Factory\n     {\n-        URI resourceUri = MavenTestingUtils.getTestResourcePath(\""keystore.p12\"").toUri();\n+        private final URI uri;\n+        private final ByteBuffer buffer;\n+\n+        public TestContentSourceFactoryResource(URI uri, byte[] bytes)\n+        {\n+            this.uri = uri;\n+            this.buffer = ByteBuffer.wrap(bytes);\n+        }\n+\n+        @Override\n+        public boolean exists()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public long length()\n+        {\n+            return buffer.remaining();\n+        }\n+\n+        @Override\n+        public Path getPath()\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public InputStream newInputStream()\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean isDirectory()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isReadable()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public URI getURI()\n+        {\n+            return uri;\n+        }\n+\n+        @Override\n+        public String getName()\n+        {\n+            return uri.getPath();\n+        }\n+\n+        @Override\n+        public String getFileName()\n+        {\n+            return uri.getPath();\n+        }\n+\n+        @Override\n+        public Resource resolve(String subUriPath)\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public Content.Source newContentSource(ByteBufferPool.Sized bufferPool, long first, long length)\n+        {\n+            return Content.Source.from(BufferUtil.slice(buffer, Math.toIntExact(first), Math.toIntExact(length)));\n+        }\n+    }\n+\n+    public static Stream<Resource> all() throws Exception\n+    {\n+        Path testResourcePath = MavenTestingUtils.getTestResourcePath(\""keystore.p12\"");\n+        URI resourceUri = testResourcePath.toUri();\n         return Stream.of(\n             ResourceFactory.root().newResource(resourceUri),\n-            new URLResourceFactory().newResource(resourceUri)\n+            ResourceFactory.root().newMemoryResource(resourceUri.toURL()),\n+            new URLResourceFactory().newResource(resourceUri),\n+            new TestContentSourceFactoryResource(resourceUri, Files.readAllBytes(testResourcePath))\n         );\n     }\n \n@@ -100,7 +193,7 @@ public void testAsContentSourceWithLength(Resource resource) throws Exception\n     {\n         TestSink sink = new TestSink();\n         Callback.Completable callback = new Callback.Completable();\n-        Content.Source contentSource = IOResources.asContentSource(resource, bufferPool, 1, false, -1, 500);\n+        Content.Source contentSource = IOResources.asContentSource(resource, bufferPool, 1, false, 0, 500);\n         Content.copy(contentSource, sink, callback);\n         callback.get();\n         List<Content.Chunk> chunks = sink.takeAccumulatedChunks();\n@@ -158,7 +251,7 @@ public void testCopyWithLength(Resource resource) throws Exception\n     {\n         TestSink sink = new TestSink();\n         Callback.Completable callback = new Callback.Completable();\n-        IOResources.copy(resource, sink, bufferPool, 1, false, -1, 500, callback);\n+        IOResources.copy(resource, sink, bufferPool, 1, false, 0, 500, callback);\n         callback.get();\n         List<Content.Chunk> chunks = sink.takeAccumulatedChunks();\n         long sum = chunks.stream().mapToLong(Content.Chunk::remaining).sum();\n@@ -179,4 +272,28 @@ public void testCopyWithFirstAndLength(Resource resource) throws Exception\n         assertThat(sum, is(500L));\n         assertThat(chunks.get(chunks.size() - 1).isLast(), is(true));\n     }\n+\n+    @Test\n+    public void testCopyDirectory()\n+    {\n+        Resource resource = ResourceFactory.root().newResource(MavenTestingUtils.getTestResourcesPath());\n+        TestSink sink = new TestSink();\n+        Callback.Completable callback = new Callback.Completable();\n+        IOResources.copy(resource, sink, bufferPool, 1, false, callback);\n+        Throwable cause = assertThrows(ExecutionException.class, callback::get).getCause();\n+        assertThat(cause, instanceOf(IllegalArgumentException.class));\n+        assertThat(sink.takeAccumulatedChunks(), empty());\n+    }\n+\n+    @Test\n+    public void testCopyWithRangeDirectory()\n+    {\n+        Resource resource = ResourceFactory.root().newResource(MavenTestingUtils.getTestResourcesPath());\n+        TestSink sink = new TestSink();\n+        Callback.Completable callback = new Callback.Completable();\n+        IOResources.copy(resource, sink, bufferPool, 1, false, 0, -1, callback);\n+        Throwable cause = assertThrows(ExecutionException.class, callback::get).getCause();\n+        assertThat(cause, instanceOf(IllegalArgumentException.class));\n+        assertThat(sink.takeAccumulatedChunks(), empty());\n+    }\n }\n\ndiff --git a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/BufferUtilTest.java b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/BufferUtilTest.java\nindex 0e5d2cf44ef6..987a821cf1df 100644\n--- a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/BufferUtilTest.java\n+++ b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/BufferUtilTest.java\n@@ -17,6 +17,7 @@\n import java.io.IOException;\n import java.nio.BufferOverflowException;\n import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n import java.nio.file.Path;\n import java.util.Arrays;\n import java.util.concurrent.ThreadLocalRandom;\n@@ -57,6 +58,24 @@ public void afterEach()\n         assertThat(FileSystemPool.INSTANCE.mounts(), empty());\n     }\n \n+    @Test\n+    public void testSlice()\n+    {\n+        ByteBuffer byteBuffer = ByteBuffer.wrap(\""0123456789\"".getBytes(StandardCharsets.UTF_8));\n+        assertEquals(\""0123456789\"", BufferUtil.toString(BufferUtil.slice(byteBuffer, 0, -1)));\n+        assertEquals(\""3456789\"", BufferUtil.toString(BufferUtil.slice(byteBuffer, 3, -1)));\n+        assertEquals(\""01234567\"", BufferUtil.toString(BufferUtil.slice(byteBuffer, 0, 8)));\n+        assertEquals(\""5678\"", BufferUtil.toString(BufferUtil.slice(byteBuffer, 5, 4)));\n+        assertEquals(\""\"", BufferUtil.toString(BufferUtil.slice(byteBuffer, 1, 0)));\n+        assertEquals(\""\"", BufferUtil.toString(BufferUtil.slice(byteBuffer, 10, -1)));\n+        assertEquals(\""\"", BufferUtil.toString(BufferUtil.slice(byteBuffer, 1000, 0)));\n+\n+        assertThrows(IllegalArgumentException.class, () -> BufferUtil.slice(byteBuffer, 0, 11));\n+        assertThrows(IllegalArgumentException.class, () -> BufferUtil.slice(byteBuffer, 11, -1));\n+        assertThrows(IllegalArgumentException.class, () -> BufferUtil.slice(byteBuffer, 1, 10));\n+        assertThrows(IllegalArgumentException.class, () -> BufferUtil.slice(byteBuffer, -1, 1));\n+    }\n+\n     @Test\n     public void testToInt() throws Exception\n     {\n\ndiff --git a/jetty-ee10/jetty-ee10-webapp/src/test/java/org/eclipse/jetty/ee10/webapp/HugeResourceTest.java b/jetty-ee10/jetty-ee10-webapp/src/test/java/org/eclipse/jetty/ee10/webapp/HugeResourceTest.java\nindex ffd32a362032..1159abaacf1a 100644\n--- a/jetty-ee10/jetty-ee10-webapp/src/test/java/org/eclipse/jetty/ee10/webapp/HugeResourceTest.java\n+++ b/jetty-ee10/jetty-ee10-webapp/src/test/java/org/eclipse/jetty/ee10/webapp/HugeResourceTest.java\n@@ -444,7 +444,7 @@ public void testUploadMultipart(String filename, long expectedSize) throws Excep\n         MultiPartRequestContent multipart = new MultiPartRequestContent();\n         Path inputFile = staticBase.resolve(filename);\n         String name = String.format(\""file-%d\"", expectedSize);\n-        multipart.addPart(new MultiPart.PathPart(name, filename, HttpFields.EMPTY, inputFile));\n+        multipart.addPart(new MultiPart.PathPart(null, name, filename, HttpFields.EMPTY, inputFile));\n         multipart.close();\n \n         URI destUri = server.getURI().resolve(\""/multipart\"");\n@@ -487,7 +487,7 @@ public void demand(Runnable demandCallback)\n         };\n         Path inputFile = staticBase.resolve(filename);\n         String name = String.format(\""file-%d\"", expectedSize);\n-        multipart.addPart(new MultiPart.PathPart(name, filename, HttpFields.EMPTY, inputFile));\n+        multipart.addPart(new MultiPart.PathPart(null, name, filename, HttpFields.EMPTY, inputFile));\n         multipart.close();\n \n         URI destUri = server.getURI().resolve(\""/multipart\"");\n\ndiff --git a/jetty-ee9/jetty-ee9-webapp/src/test/java/org/eclipse/jetty/ee9/webapp/HugeResourceTest.java b/jetty-ee9/jetty-ee9-webapp/src/test/java/org/eclipse/jetty/ee9/webapp/HugeResourceTest.java\nindex 8f6faec75878..50b76116ae27 100644\n--- a/jetty-ee9/jetty-ee9-webapp/src/test/java/org/eclipse/jetty/ee9/webapp/HugeResourceTest.java\n+++ b/jetty-ee9/jetty-ee9-webapp/src/test/java/org/eclipse/jetty/ee9/webapp/HugeResourceTest.java\n@@ -362,7 +362,7 @@ public void testUploadMultipart(String filename, long expectedSize) throws Excep\n         MultiPartRequestContent multipart = new MultiPartRequestContent();\n         Path inputFile = staticBase.resolve(filename);\n         String name = String.format(\""file-%d\"", expectedSize);\n-        multipart.addPart(new MultiPart.PathPart(name, filename, HttpFields.EMPTY, inputFile));\n+        multipart.addPart(new MultiPart.PathPart(null, name, filename, HttpFields.EMPTY, inputFile));\n         multipart.close();\n \n         URI destUri = server.getURI().resolve(\""/multipart\"");\n\ndiff --git a/tests/test-integration/src/test/java/org/eclipse/jetty/test/CoreMultiPartTest.java b/tests/test-integration/src/test/java/org/eclipse/jetty/test/CoreMultiPartTest.java\nindex 2dab6c46acc2..cfeafd729220 100644\n--- a/tests/test-integration/src/test/java/org/eclipse/jetty/test/CoreMultiPartTest.java\n+++ b/tests/test-integration/src/test/java/org/eclipse/jetty/test/CoreMultiPartTest.java\n@@ -537,7 +537,7 @@ public boolean handle(Request request, Response response, Callback callback) thr\n                     writer.println(\""Part: name=\"" + part.getName() + \"", size=\"" + part.getLength() + \"", content=\"" + partContent);\n \n                     // We can only consume the getContentSource() once so we must use newContentSource().\n-                    partContent = IO.toString(Content.Source.asInputStream(part.newContentSource()));\n+                    partContent = IO.toString(Content.Source.asInputStream(part.newContentSource(null, 0, -1)));\n                     writer.println(\""Part: name=\"" + part.getName() + \"", size=\"" + part.getLength() + \"", content=\"" + partContent);\n                 }\n \n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-12865"", ""pr_id"": 12865, ""issue_id"": 12855, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""`ContentSourceTransformer.read()` may call `release()` more than once\n**Jetty version(s)**\n12.1.x\n\n**Description**\nAfter `ContentSourceTransformer.fail(x, true)` is called, each call to `ContentSourceTransformer.read()` calls `ContentSourceTransformer.release()`.\n\nIf the implementation does not implement `release()` in an idempotent way, `ContentSourceTransformer.read()` may throw or misbehave.\n\n**How to reproduce?**\n\nHere is a test to be added to `GzipDecoderSourceTest` that illustrates the bug for `GzipDecoderSource`:\n\n```java\n@ParameterizedTest\n@MethodSource(\""textResources\"")\npublic void testTransformerBug(String textResourceName) throws Exception\n{\n    startGzip();\n    String compressedName = String.format(\""%s.%s\"", textResourceName, gzip.getFileExtensionNames().get(0));\n    Path compressed = MavenPaths.findTestResourceFile(compressedName);\n\n    Content.Source fileSource = Content.Source.from(sizedPool, compressed);\n    Content.Source decoderSource = gzip.newDecoderSource(fileSource);\n\n    decoderSource.fail(new Throwable(), true);\n\n    Content.Chunk chunk1 = decoderSource.read();\n    Content.Chunk chunk2 = decoderSource.read();\n    Content.Chunk chunk3 = decoderSource.read(); // this throws NPE\n}\n```\n\nwhich fails with:\n```\njava.lang.NullPointerException: Inflater has been closed\n\n\tat java.base/java.util.zip.Inflater.ensureOpen(Inflater.java:714)\n\tat java.base/java.util.zip.Inflater.reset(Inflater.java:685)\n\tat org.eclipse.jetty.util@12.1.0-SNAPSHOT/org.eclipse.jetty.util.compression.InflaterPool.reset(InflaterPool.java:56)\n\tat org.eclipse.jetty.util@12.1.0-SNAPSHOT/org.eclipse.jetty.util.compression.InflaterPool.reset(InflaterPool.java:21)\n\tat org.eclipse.jetty.util@12.1.0-SNAPSHOT/org.eclipse.jetty.util.compression.CompressionPool$Entry.release(CompressionPool.java:142)\n\tat org.eclipse.jetty.compression.gzip@12.1.0-SNAPSHOT/org.eclipse.jetty.compression.gzip.internal.GzipDecoderSource.release(GzipDecoderSource.java:277)\n\tat org.eclipse.jetty.io@12.1.0-SNAPSHOT/org.eclipse.jetty.io.content.ContentSourceTransformer.read(ContentSourceTransformer.java:77)\n\tat org.eclipse.jetty.compression.gzip@12.1.0-SNAPSHOT/org.eclipse.jetty.compression.gzip.GzipDecoderSourceTest.testTransformerBug(GzipDecoderSourceTest.java:44)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:569)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)\n\tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\n\tat java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179)\n\tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)\n\tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)\n\tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\n```"", ""issue_word_count"": 408, ""test_files_count"": 6, ""non_test_files_count"": 3, ""pr_changed_files"": [""jetty-core/jetty-compression/jetty-compression-brotli/src/main/java/org/eclipse/jetty/compression/brotli/internal/BrotliDecoderSource.java"", ""jetty-core/jetty-compression/jetty-compression-brotli/src/test/java/org/eclipse/jetty/compression/brotli/AbstractBrotliTest.java"", ""jetty-core/jetty-compression/jetty-compression-brotli/src/test/java/org/eclipse/jetty/compression/brotli/BrotliDecoderSourceTest.java"", ""jetty-core/jetty-compression/jetty-compression-gzip/src/main/java/org/eclipse/jetty/compression/gzip/internal/GzipDecoderSource.java"", ""jetty-core/jetty-compression/jetty-compression-gzip/src/test/java/org/eclipse/jetty/compression/gzip/AbstractGzipTest.java"", ""jetty-core/jetty-compression/jetty-compression-gzip/src/test/java/org/eclipse/jetty/compression/gzip/GzipDecoderSourceTest.java"", ""jetty-core/jetty-compression/jetty-compression-zstandard/src/test/java/org/eclipse/jetty/compression/zstandard/AbstractZstdTest.java"", ""jetty-core/jetty-compression/jetty-compression-zstandard/src/test/java/org/eclipse/jetty/compression/zstandard/ZstandardDecoderSourceTest.java"", ""jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/content/ContentSourceTransformer.java""], ""pr_changed_test_files"": [""jetty-core/jetty-compression/jetty-compression-brotli/src/test/java/org/eclipse/jetty/compression/brotli/AbstractBrotliTest.java"", ""jetty-core/jetty-compression/jetty-compression-brotli/src/test/java/org/eclipse/jetty/compression/brotli/BrotliDecoderSourceTest.java"", ""jetty-core/jetty-compression/jetty-compression-gzip/src/test/java/org/eclipse/jetty/compression/gzip/AbstractGzipTest.java"", ""jetty-core/jetty-compression/jetty-compression-gzip/src/test/java/org/eclipse/jetty/compression/gzip/GzipDecoderSourceTest.java"", ""jetty-core/jetty-compression/jetty-compression-zstandard/src/test/java/org/eclipse/jetty/compression/zstandard/AbstractZstdTest.java"", ""jetty-core/jetty-compression/jetty-compression-zstandard/src/test/java/org/eclipse/jetty/compression/zstandard/ZstandardDecoderSourceTest.java""], ""base_commit"": ""0ee6bd8050fde4ebd3c2d27f616ba9dc04206776"", ""head_commit"": ""5ed88a1283b7958f412daa583b291d14f580c662"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/12865"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/12865"", ""dockerfile"": """", ""pr_merged_at"": ""2025-03-14T16:45:43.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-compression/jetty-compression-brotli/src/main/java/org/eclipse/jetty/compression/brotli/internal/BrotliDecoderSource.java b/jetty-core/jetty-compression/jetty-compression-brotli/src/main/java/org/eclipse/jetty/compression/brotli/internal/BrotliDecoderSource.java\nindex 47d63a41731d..6d359b637f55 100644\n--- a/jetty-core/jetty-compression/jetty-compression-brotli/src/main/java/org/eclipse/jetty/compression/brotli/internal/BrotliDecoderSource.java\n+++ b/jetty-core/jetty-compression/jetty-compression-brotli/src/main/java/org/eclipse/jetty/compression/brotli/internal/BrotliDecoderSource.java\n@@ -96,6 +96,7 @@ protected Content.Chunk transform(Content.Chunk inputChunk)\n     @Override\n     protected void release()\n     {\n+        super.release();\n         decoder.destroy();\n     }\n }\n\ndiff --git a/jetty-core/jetty-compression/jetty-compression-gzip/src/main/java/org/eclipse/jetty/compression/gzip/internal/GzipDecoderSource.java b/jetty-core/jetty-compression/jetty-compression-gzip/src/main/java/org/eclipse/jetty/compression/gzip/internal/GzipDecoderSource.java\nindex 85371bd3556c..070744f1979b 100644\n--- a/jetty-core/jetty-compression/jetty-compression-gzip/src/main/java/org/eclipse/jetty/compression/gzip/internal/GzipDecoderSource.java\n+++ b/jetty-core/jetty-compression/jetty-compression-gzip/src/main/java/org/eclipse/jetty/compression/gzip/internal/GzipDecoderSource.java\n@@ -274,6 +274,7 @@ else if (inflater.finished())\n     @Override\n     protected void release()\n     {\n+        super.release();\n         inflaterEntry.release();\n     }\n }\n\ndiff --git a/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/content/ContentSourceTransformer.java b/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/content/ContentSourceTransformer.java\nindex d3f78e368eb8..eedb5b24a8fa 100644\n--- a/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/content/ContentSourceTransformer.java\n+++ b/jetty-core/jetty-io/src/main/java/org/eclipse/jetty/io/content/ContentSourceTransformer.java\n@@ -13,6 +13,9 @@\n \n package org.eclipse.jetty.io.content;\n \n+import java.nio.channels.ReadPendingException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n import org.eclipse.jetty.io.Content;\n import org.eclipse.jetty.util.ExceptionUtil;\n import org.slf4j.Logger;\n@@ -31,11 +34,10 @@ public abstract class ContentSourceTransformer implements Content.Source\n {\n     private static final Logger LOG = LoggerFactory.getLogger(ContentSourceTransformer.class);\n \n+    private final AtomicReference<State> state = new AtomicReference<>(State.IDLE);\n     private final Content.Source rawSource;\n-    private Content.Chunk rawChunk;\n-    private Content.Chunk transformedChunk;\n+    private volatile Content.Chunk rawChunk;\n     private volatile boolean needsRawRead;\n-    private boolean finished;\n \n     protected ContentSourceTransformer(Content.Source rawSource)\n     {\n@@ -48,12 +50,42 @@ protected Content.Source getContentSource()\n         return rawSource;\n     }\n \n+    private Content.Chunk beforeRead()\n+    {\n+        while (true)\n+        {\n+            State current = state.get();\n+            switch (current.type)\n+            {\n+                case IDLE ->\n+                {\n+                    if (state.compareAndSet(current, State.READING))\n+                        return null;\n+                }\n+                case READING -> throw new ReadPendingException();\n+                case EOF ->\n+                {\n+                    return Content.Chunk.EOF;\n+                }\n+                case FAILING -> throw new IllegalStateException();\n+                case FAILED ->\n+                {\n+                    return ((State.Failed)current).chunk;\n+                }\n+            }\n+        }\n+    }\n+\n     @Override\n     public Content.Chunk read()\n     {\n         if (LOG.isDebugEnabled())\n             LOG.debug(\""Reading {}\"", this);\n \n+        Content.Chunk chunk = beforeRead();\n+        if (chunk != null)\n+            return chunk;\n+\n         while (true)\n         {\n             if (needsRawRead)\n@@ -63,31 +95,21 @@ public Content.Chunk read()\n                     LOG.debug(\""Raw chunk {} {}\"", rawChunk, this);\n                 needsRawRead = rawChunk == null;\n                 if (rawChunk == null)\n-                    return null;\n+                    return afterRead(State.Type.IDLE, null);\n             }\n \n             if (Content.Chunk.isFailure(rawChunk))\n             {\n-                Content.Chunk failure = rawChunk;\n-                rawChunk = Content.Chunk.next(rawChunk);\n-                needsRawRead = rawChunk == null;\n-                if (rawChunk != null)\n-                {\n-                    finished = true;\n-                    release();\n-                }\n-                return failure;\n+                Content.Chunk failureChunk = rawChunk;\n+                Content.Chunk nextChunk = Content.Chunk.next(failureChunk);\n+                needsRawRead = nextChunk == null;\n+                afterRead(nextChunk == null ? State.Type.IDLE : State.Type.FAILED, nextChunk);\n+                return failureChunk;\n             }\n \n-            if (Content.Chunk.isFailure(transformedChunk))\n-                return transformedChunk;\n-\n-            if (finished)\n-                return Content.Chunk.EOF;\n-\n             boolean rawLast = rawChunk != null && rawChunk.isLast();\n \n-            transformedChunk = process(rawChunk != null ? rawChunk : Content.Chunk.EMPTY);\n+            Content.Chunk transformedChunk = process(rawChunk != null ? rawChunk : Content.Chunk.EMPTY);\n             if (LOG.isDebugEnabled())\n                 LOG.debug(\""Transformed chunk {} {}\"", transformedChunk, this);\n \n@@ -122,25 +144,71 @@ public Content.Chunk read()\n                         transformedChunk = Content.Chunk.asChunk(transformedChunk.getByteBuffer(), false, transformedChunk);\n                 }\n \n-                boolean terminated = rawLast && transformedLast;\n-                boolean terminalFailure = transformedFailure && transformedLast;\n+                if (transformedFailure && transformedLast)\n+                    return afterRead(State.Type.FAILED, transformedChunk);\n \n-                Content.Chunk result = transformedChunk;\n-                transformedChunk = Content.Chunk.next(result);\n-\n-                if (terminated || terminalFailure)\n-                {\n-                    finished = true;\n-                    release();\n-                }\n+                if (rawLast && transformedLast)\n+                    return afterRead(State.Type.EOF, transformedChunk);\n \n-                return result;\n+                return afterRead(State.Type.IDLE, transformedChunk);\n             }\n \n             needsRawRead = rawChunk == null;\n         }\n     }\n \n+    private Content.Chunk afterRead(State.Type targetType, Content.Chunk chunk)\n+    {\n+        while (true)\n+        {\n+            State current = state.get();\n+            switch (current.type)\n+            {\n+                case IDLE, EOF, FAILED -> throw new IllegalStateException();\n+                case READING ->\n+                {\n+                    switch (targetType)\n+                    {\n+                        case IDLE ->\n+                        {\n+                            if (state.compareAndSet(current, State.IDLE))\n+                                return chunk;\n+                        }\n+                        case FAILED ->\n+                        {\n+                            if (state.compareAndSet(current, new State.Failed(chunk)))\n+                            {\n+                                dispose(chunk.getFailure());\n+                                return chunk;\n+                            }\n+                        }\n+                        case EOF ->\n+                        {\n+                            if (state.compareAndSet(current, State.EOF))\n+                            {\n+                                release();\n+                                return chunk;\n+                            }\n+                        }\n+                        default -> throw new IllegalStateException();\n+                    }\n+                }\n+                case FAILING ->\n+                {\n+                    Content.Chunk failedChunk = ((State.Failing)current).chunk;\n+                    Throwable failure = failedChunk.getFailure();\n+                    if (Content.Chunk.isFailure(chunk))\n+                        ExceptionUtil.addSuppressedIfNotAssociated(failure, chunk.getFailure());\n+                    if (state.compareAndSet(current, new State.Failed(failedChunk)))\n+                    {\n+                        dispose(failure);\n+                        return chunk;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     @Override\n     public void demand(Runnable demandCallback)\n     {\n@@ -158,7 +226,41 @@ public void fail(Throwable failure)\n     {\n         if (LOG.isDebugEnabled())\n             LOG.debug(\""Failing {}\"", this, failure);\n+\n+        while (true)\n+        {\n+            State current = state.get();\n+            switch (current.type)\n+            {\n+                case IDLE ->\n+                {\n+                    if (state.compareAndSet(current, new State.Failed(Content.Chunk.from(failure, true))))\n+                    {\n+                        dispose(failure);\n+                        return;\n+                    }\n+                }\n+                case READING ->\n+                {\n+                    if (state.compareAndSet(current, new State.Failing(Content.Chunk.from(failure, true))))\n+                        return;\n+                }\n+                default ->\n+                {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void dispose(Throwable failure)\n+    {\n         rawSource.fail(failure);\n+        needsRawRead = false;\n+        if (rawChunk != null)\n+            rawChunk.release();\n+        rawChunk = Content.Chunk.from(failure, true);\n+        release();\n     }\n \n     private Content.Chunk process(Content.Chunk rawChunk)\n@@ -213,14 +315,102 @@ protected void release()\n     {\n     }\n \n+    /**\n+     * @return whether the transformation is complete, either successfully or with a failure.\n+     */\n+    public boolean isComplete()\n+    {\n+        return switch (state.get().type)\n+        {\n+            case EOF, FAILED -> true;\n+            default -> false;\n+        };\n+    }\n+\n     @Override\n     public String toString()\n     {\n-        return \""%s@%x[finished=%b,source=%s]\"".formatted(\n+        return \""%s@%x[state=%s,source=%s]\"".formatted(\n             getClass().getSimpleName(),\n             hashCode(),\n-            finished,\n+            state.get(),\n             rawSource\n         );\n     }\n+\n+    /**\n+     * <p>State transitions are:</p>\n+     * <p>IDLE -> FAILED, when {@link #fail(Throwable)} is called</p>\n+     * <p>IDLE -> READING, when {@link #read()} is called</p>\n+     * <p>READING -> IDLE, when {@link #read()} returns a non-last chunk</p>\n+     * <p>READING -> EOF, when {@link #read()} returns a last chunk</p>\n+     * <p>READING -> FAILED, when reading from the raw source returns a failure chunk</p>\n+     * <p>READING -> FAILING, when a concurrent call to {@link #fail(Throwable)} happens during a read</p>\n+     * <p>FAILING -> FAILED, when just before returning, {@link #read()} detects a concurrent call to {@link #fail(Throwable)}</p>\n+     *\n+     */\n+    private static sealed class State\n+    {\n+        private static final State IDLE = new Idle();\n+        private static final State READING = new Reading();\n+        private static final State EOF = new EOF();\n+\n+        private final Type type;\n+\n+        private State(Type type)\n+        {\n+            this.type = type;\n+        }\n+\n+        private static final class Idle extends State\n+        {\n+            private Idle()\n+            {\n+                super(Type.IDLE);\n+            }\n+        }\n+\n+        private static final class Reading extends State\n+        {\n+            private Reading()\n+            {\n+                super(Type.READING);\n+            }\n+        }\n+\n+        private static final class EOF extends State\n+        {\n+            private EOF()\n+            {\n+                super(Type.EOF);\n+            }\n+        }\n+\n+        private static final class Failing extends State\n+        {\n+            private final Content.Chunk chunk;\n+\n+            private Failing(Content.Chunk chunk)\n+            {\n+                super(Type.FAILING);\n+                this.chunk = chunk;\n+            }\n+        }\n+\n+        private static final class Failed extends State\n+        {\n+            private final Content.Chunk chunk;\n+\n+            private Failed(Content.Chunk chunk)\n+            {\n+                super(Type.FAILED);\n+                this.chunk = chunk;\n+            }\n+        }\n+\n+        private enum Type\n+        {\n+            IDLE, READING, EOF, FAILING, FAILED\n+        }\n+    }\n }\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-compression/jetty-compression-brotli/src/test/java/org/eclipse/jetty/compression/brotli/AbstractBrotliTest.java b/jetty-core/jetty-compression/jetty-compression-brotli/src/test/java/org/eclipse/jetty/compression/brotli/AbstractBrotliTest.java\nindex bbe28fe5ae3f..55bc379e2f40 100644\n--- a/jetty-core/jetty-compression/jetty-compression-brotli/src/test/java/org/eclipse/jetty/compression/brotli/AbstractBrotliTest.java\n+++ b/jetty-core/jetty-compression/jetty-compression-brotli/src/test/java/org/eclipse/jetty/compression/brotli/AbstractBrotliTest.java\n@@ -17,28 +17,19 @@\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.nio.ByteBuffer;\n import java.util.List;\n \n import org.eclipse.jetty.io.ArrayByteBufferPool;\n import org.eclipse.jetty.io.ByteBufferPool;\n-import org.eclipse.jetty.util.BufferUtil;\n import org.eclipse.jetty.util.IO;\n import org.eclipse.jetty.util.component.LifeCycle;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n \n-import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n public abstract class AbstractBrotliTest\n {\n-    // Signed Integer Max\n-    protected static final long INT_MAX = Integer.MAX_VALUE;\n-    // Unsigned Integer Max == 2^32\n-    protected static final long UINT_MAX = 0xFFFFFFFFL;\n-\n     protected ArrayByteBufferPool.Tracking pool;\n     protected ByteBufferPool.Sized sizedPool;\n     protected BrotliCompression brotli;\n@@ -51,16 +42,8 @@ public void initPool()\n     }\n \n     protected void startBrotli() throws Exception\n-    {\n-        startBrotli(-1);\n-    }\n-\n-    protected void startBrotli(int bufferSize) throws Exception\n     {\n         brotli = new BrotliCompression();\n-        if (bufferSize > 0)\n-            brotli.setBufferSize(bufferSize);\n-\n         brotli.setByteBufferPool(pool);\n         brotli.start();\n     }\n@@ -77,26 +60,6 @@ public static List<String> textResources()\n         return List.of(\""texts/logo.svg\"", \""texts/long.txt\"", \""texts/quotes.txt\"");\n     }\n \n-    /**\n-     * Compress data using Brotli4j {@code BrotliOutputStream}.\n-     *\n-     * @param data the data to compress\n-     * @return the compressed bytes\n-     * @throws IOException if unable to compress input data\n-     */\n-    public byte[] compress(String data) throws IOException\n-    {\n-        BrotliEncoderConfig brotliEncoderConfig = new BrotliEncoderConfig();\n-        try (ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n-             OutputStream output = brotli.newEncoderOutputStream(bytesOut))\n-        {\n-            if (data != null)\n-                output.write(data.getBytes(UTF_8));\n-            output.close();\n-            return bytesOut.toByteArray();\n-        }\n-    }\n-\n     /**\n      * Decompress bytes using Brotli4j {@code BrotliInputStream}.\n      *\n@@ -115,17 +78,4 @@ public byte[] decompress(byte[] compressedBytes) throws IOException\n             return output.toByteArray();\n         }\n     }\n-\n-    /**\n-     * Decompress ByteBuffer using Brotli4j {@code BrotliInputStream}.\n-     *\n-     * @param compressedBytes the data to decompress\n-     * @return the decompressed bytes\n-     * @throws IOException if unable to decompress\n-     */\n-    public byte[] decompress(ByteBuffer compressedBytes) throws IOException\n-    {\n-        return decompress(BufferUtil.toArray(compressedBytes));\n-    }\n-\n }\n\ndiff --git a/jetty-core/jetty-compression/jetty-compression-brotli/src/test/java/org/eclipse/jetty/compression/brotli/BrotliDecoderSourceTest.java b/jetty-core/jetty-compression/jetty-compression-brotli/src/test/java/org/eclipse/jetty/compression/brotli/BrotliDecoderSourceTest.java\nindex c8c9d227f57f..95bfa56d5f01 100644\n--- a/jetty-core/jetty-compression/jetty-compression-brotli/src/test/java/org/eclipse/jetty/compression/brotli/BrotliDecoderSourceTest.java\n+++ b/jetty-core/jetty-compression/jetty-compression-brotli/src/test/java/org/eclipse/jetty/compression/brotli/BrotliDecoderSourceTest.java\n@@ -16,12 +16,16 @@\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n+import org.eclipse.jetty.compression.DecoderSource;\n import org.eclipse.jetty.io.Content;\n import org.eclipse.jetty.toolchain.test.MavenPaths;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.MethodSource;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assumptions.assumeFalse;\n \n public class BrotliDecoderSourceTest extends AbstractBrotliTest\n {\n@@ -35,10 +39,70 @@ public void testDecodeText(String textResourceName) throws Exception\n         Path uncompressed = MavenPaths.findTestResourceFile(textResourceName);\n \n         Content.Source fileSource = Content.Source.from(sizedPool, compressed);\n-        Content.Source decoderSource = brotli.newDecoderSource(fileSource);\n+        DecoderSource decoderSource = brotli.newDecoderSource(fileSource);\n+        assertFalse(decoderSource.isComplete());\n \n         String result = Content.Source.asString(decoderSource);\n         String expected = Files.readString(uncompressed);\n         assertEquals(expected, result);\n+        assertTrue(decoderSource.isComplete());\n+\n+        Content.Chunk eof = decoderSource.read();\n+        assertTrue(eof.isLast() && eof.isEmpty() && !Content.Chunk.isFailure(eof));\n+\n+        // Failed after EOF, too late.\n+        decoderSource.fail(new Throwable());\n+\n+        Content.Chunk chunk = decoderSource.read();\n+        assertTrue(chunk.isLast() && chunk.isEmpty() && !Content.Chunk.isFailure(chunk));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""textResources\"")\n+    public void testImmediateFailReleaseAllResources(String textResourceName) throws Exception\n+    {\n+        startBrotli();\n+        String compressedName = String.format(\""%s.%s\"", textResourceName, brotli.getFileExtensionNames().get(0));\n+        Path compressed = MavenPaths.findTestResourceFile(compressedName);\n+\n+        Content.Source fileSource = Content.Source.from(sizedPool, compressed);\n+        DecoderSource decoderSource = brotli.newDecoderSource(fileSource);\n+        assertFalse(decoderSource.isComplete());\n+\n+        decoderSource.fail(new Throwable());\n+        assertTrue(decoderSource.isComplete());\n+\n+        Content.Chunk err = decoderSource.read();\n+        assertTrue(Content.Chunk.isFailure(err));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""textResources\"")\n+    public void testFailAfterReadReleaseAllResources(String textResourceName) throws Exception\n+    {\n+        startBrotli();\n+        String compressedName = String.format(\""%s.%s\"", textResourceName, brotli.getFileExtensionNames().get(0));\n+        Path compressed = MavenPaths.findTestResourceFile(compressedName);\n+\n+        Content.Source fileSource = Content.Source.from(sizedPool, compressed);\n+        DecoderSource decoderSource = brotli.newDecoderSource(fileSource);\n+        assertFalse(decoderSource.isComplete());\n+\n+        Content.Chunk chunk = decoderSource.read();\n+        // skip empty chunks\n+        while (chunk.isEmpty() && !chunk.isLast())\n+            chunk = decoderSource.read();\n+        assertTrue(chunk.hasRemaining());\n+        chunk.release();\n+        // This test tests the behavior of\n+        // a failure before the last chunk.\n+        assumeFalse(chunk.isLast());\n+        assertFalse(decoderSource.isComplete());\n+\n+        decoderSource.fail(new Throwable());\n+        assertTrue(decoderSource.isComplete());\n+\n+        Content.Chunk err = decoderSource.read();\n+        assertTrue(Content.Chunk.isFailure(err));\n     }\n }\n\ndiff --git a/jetty-core/jetty-compression/jetty-compression-gzip/src/test/java/org/eclipse/jetty/compression/gzip/AbstractGzipTest.java b/jetty-core/jetty-compression/jetty-compression-gzip/src/test/java/org/eclipse/jetty/compression/gzip/AbstractGzipTest.java\nindex 4262a675f7a6..a3569d660b6f 100644\n--- a/jetty-core/jetty-compression/jetty-compression-gzip/src/test/java/org/eclipse/jetty/compression/gzip/AbstractGzipTest.java\n+++ b/jetty-core/jetty-compression/jetty-compression-gzip/src/test/java/org/eclipse/jetty/compression/gzip/AbstractGzipTest.java\n@@ -16,31 +16,22 @@\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n-import java.nio.ByteBuffer;\n import java.util.List;\n import java.util.zip.GZIPInputStream;\n import java.util.zip.GZIPOutputStream;\n \n import org.eclipse.jetty.io.ArrayByteBufferPool;\n import org.eclipse.jetty.io.ByteBufferPool;\n-import org.eclipse.jetty.util.BufferUtil;\n import org.eclipse.jetty.util.IO;\n import org.eclipse.jetty.util.component.LifeCycle;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n public abstract class AbstractGzipTest\n {\n-    // Signed Integer Max\n-    protected static final long INT_MAX = Integer.MAX_VALUE;\n-    // Unsigned Integer Max == 2^32\n-    protected static final long UINT_MAX = 0xFFFFFFFFL;\n-    private static final Logger LOG = LoggerFactory.getLogger(AbstractGzipTest.class);\n     protected ArrayByteBufferPool.Tracking pool;\n     protected ByteBufferPool.Sized sizedPool;\n     protected GzipCompression gzip;\n@@ -89,18 +80,6 @@ public byte[] decompress(byte[] compressedBytes) throws IOException\n         }\n     }\n \n-    /**\n-     * Decompress ByteBuffer using JVM Built-In GZIP features.\n-     *\n-     * @param compressedBytes the data to decompress\n-     * @return the decompressed bytes\n-     * @throws IOException if unable to decompress\n-     */\n-    public byte[] decompress(ByteBuffer compressedBytes) throws IOException\n-    {\n-        return decompress(BufferUtil.toArray(compressedBytes));\n-    }\n-\n     @BeforeEach\n     public void initPool()\n     {\n@@ -125,7 +104,6 @@ protected void startGzip(int bufferSize) throws Exception\n         gzip = new GzipCompression();\n         if (bufferSize > 0)\n             gzip.setBufferSize(bufferSize);\n-\n         gzip.setByteBufferPool(pool);\n         gzip.start();\n     }\n\ndiff --git a/jetty-core/jetty-compression/jetty-compression-gzip/src/test/java/org/eclipse/jetty/compression/gzip/GzipDecoderSourceTest.java b/jetty-core/jetty-compression/jetty-compression-gzip/src/test/java/org/eclipse/jetty/compression/gzip/GzipDecoderSourceTest.java\nindex 726b7a4b76ff..34f9b5bb07db 100644\n--- a/jetty-core/jetty-compression/jetty-compression-gzip/src/test/java/org/eclipse/jetty/compression/gzip/GzipDecoderSourceTest.java\n+++ b/jetty-core/jetty-compression/jetty-compression-gzip/src/test/java/org/eclipse/jetty/compression/gzip/GzipDecoderSourceTest.java\n@@ -16,12 +16,16 @@\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n+import org.eclipse.jetty.compression.DecoderSource;\n import org.eclipse.jetty.io.Content;\n import org.eclipse.jetty.toolchain.test.MavenPaths;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.MethodSource;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assumptions.assumeFalse;\n \n public class GzipDecoderSourceTest extends AbstractGzipTest\n {\n@@ -35,10 +39,67 @@ public void testDecodeText(String textResourceName) throws Exception\n         Path uncompressed = MavenPaths.findTestResourceFile(textResourceName);\n \n         Content.Source fileSource = Content.Source.from(sizedPool, compressed);\n-        Content.Source decoderSource = gzip.newDecoderSource(fileSource);\n+        DecoderSource decoderSource = gzip.newDecoderSource(fileSource);\n+        assertFalse(decoderSource.isComplete());\n \n         String result = Content.Source.asString(decoderSource);\n         String expected = Files.readString(uncompressed);\n         assertEquals(expected, result);\n+        assertTrue(decoderSource.isComplete());\n+\n+        Content.Chunk eof = decoderSource.read();\n+        assertTrue(eof.isLast() && eof.isEmpty() && !Content.Chunk.isFailure(eof));\n+\n+        // Failed after EOF, too late.\n+        decoderSource.fail(new Throwable());\n+\n+        Content.Chunk chunk = decoderSource.read();\n+        assertTrue(chunk.isLast() && chunk.isEmpty() && !Content.Chunk.isFailure(chunk));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""textResources\"")\n+    public void testImmediateFailReleaseAllResources(String textResourceName) throws Exception\n+    {\n+        startGzip();\n+        String compressedName = String.format(\""%s.%s\"", textResourceName, gzip.getFileExtensionNames().get(0));\n+        Path compressed = MavenPaths.findTestResourceFile(compressedName);\n+\n+        Content.Source fileSource = Content.Source.from(sizedPool, compressed);\n+        DecoderSource decoderSource = gzip.newDecoderSource(fileSource);\n+        assertFalse(decoderSource.isComplete());\n+\n+        decoderSource.fail(new Throwable());\n+        assertTrue(decoderSource.isComplete());\n+\n+        Content.Chunk err = decoderSource.read();\n+        assertTrue(Content.Chunk.isFailure(err));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""textResources\"")\n+    public void testFailAfterReadReleaseAllResources(String textResourceName) throws Exception\n+    {\n+        startGzip();\n+        String compressedName = String.format(\""%s.%s\"", textResourceName, gzip.getFileExtensionNames().get(0));\n+        Path compressed = MavenPaths.findTestResourceFile(compressedName);\n+\n+        Content.Source fileSource = Content.Source.from(sizedPool, compressed);\n+        DecoderSource decoderSource = gzip.newDecoderSource(fileSource);\n+        assertFalse(decoderSource.isComplete());\n+\n+        Content.Chunk chunk = decoderSource.read();\n+        assertTrue(chunk.hasRemaining());\n+        chunk.release();\n+        // This test tests the behavior of\n+        // a failure before the last chunk.\n+        assumeFalse(chunk.isLast());\n+        assertFalse(decoderSource.isComplete());\n+\n+        decoderSource.fail(new Throwable());\n+        assertTrue(decoderSource.isComplete());\n+\n+        Content.Chunk err = decoderSource.read();\n+        assertTrue(Content.Chunk.isFailure(err));\n     }\n }\n\ndiff --git a/jetty-core/jetty-compression/jetty-compression-zstandard/src/test/java/org/eclipse/jetty/compression/zstandard/AbstractZstdTest.java b/jetty-core/jetty-compression/jetty-compression-zstandard/src/test/java/org/eclipse/jetty/compression/zstandard/AbstractZstdTest.java\nindex 9aa94aa77104..27de5abaa9dd 100644\n--- a/jetty-core/jetty-compression/jetty-compression-zstandard/src/test/java/org/eclipse/jetty/compression/zstandard/AbstractZstdTest.java\n+++ b/jetty-core/jetty-compression/jetty-compression-zstandard/src/test/java/org/eclipse/jetty/compression/zstandard/AbstractZstdTest.java\n@@ -17,30 +17,19 @@\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.nio.ByteBuffer;\n-import java.nio.charset.StandardCharsets;\n import java.util.List;\n \n import org.eclipse.jetty.io.ArrayByteBufferPool;\n import org.eclipse.jetty.io.ByteBufferPool;\n-import org.eclipse.jetty.util.BufferUtil;\n import org.eclipse.jetty.util.IO;\n import org.eclipse.jetty.util.component.LifeCycle;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n \n-import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n public abstract class AbstractZstdTest\n {\n-    // Signed Integer Max\n-    protected static final long INT_MAX = Integer.MAX_VALUE;\n-    // Unsigned Integer Max == 2^32\n-    protected static final long UINT_MAX = 0xFFFFFFFFL;\n-    protected static final ByteBuffer EMPTY_DIRECT_BUFFER = ByteBuffer.allocateDirect(0);\n-\n     protected ArrayByteBufferPool.Tracking pool;\n     protected ByteBufferPool.Sized sizedPool;\n     protected ZstandardCompression zstd;\n@@ -50,56 +39,6 @@ public static List<String> textResources()\n         return List.of(\""texts/logo.svg\"", \""texts/long.txt\"", \""texts/quotes.txt\"");\n     }\n \n-    /**\n-     * Create a Direct ByteBuffer from a byte array.\n-     *\n-     * <p>\n-     * This is a replacement of {@link ByteBuffer#wrap(byte[])} but\n-     * for producing Direct {@link ByteBuffer} implementations that\n-     * {@code zstd-jni} require.\n-     * </p>\n-     *\n-     * @param arr the byte array to populate ByteBuffer.\n-     * @return the Direct ByteBuffer representing the byte array.\n-     */\n-    public ByteBuffer asDirect(byte[] arr)\n-    {\n-        ByteBuffer buf = ByteBuffer.allocateDirect(arr.length);\n-        buf.put(arr);\n-        buf.flip();\n-        return buf;\n-    }\n-\n-    /**\n-     * Create a Direct ByteBuffer from a String.\n-     *\n-     * @param str the string to use for bytes. (using {@link StandardCharsets#UTF_8})\n-     * @return the Direct ByteBuffer representing the byte array.\n-     */\n-    public ByteBuffer asDirect(String str)\n-    {\n-        return asDirect(str.getBytes(UTF_8));\n-    }\n-\n-    /**\n-     * Compress data using zstd-jni {@code ZstdOutputStream}.\n-     *\n-     * @param data the data to compress\n-     * @return the compressed bytes\n-     * @throws IOException if unable to compress input data\n-     */\n-    public byte[] compress(String data) throws IOException\n-    {\n-        try (ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n-             OutputStream output = zstd.newEncoderOutputStream(bytesOut))\n-        {\n-            if (data != null)\n-                output.write(data.getBytes(UTF_8));\n-            output.close();\n-            return bytesOut.toByteArray();\n-        }\n-    }\n-\n     /**\n      * Decompress bytes using zstd-jni {@code ZstdInputStream}.\n      *\n@@ -119,18 +58,6 @@ public byte[] decompress(byte[] compressedBytes) throws IOException\n         }\n     }\n \n-    /**\n-     * Decompress ByteBuffer using zstd-jni {@code ZstdInputStream}.\n-     *\n-     * @param compressedBytes the data to decompress\n-     * @return the decompressed bytes\n-     * @throws IOException if unable to decompress\n-     */\n-    public byte[] decompress(ByteBuffer compressedBytes) throws IOException\n-    {\n-        return decompress(BufferUtil.toArray(compressedBytes));\n-    }\n-\n     @BeforeEach\n     public void initPool()\n     {\n@@ -146,16 +73,8 @@ public void tearDown()\n     }\n \n     protected void startZstd() throws Exception\n-    {\n-        startZstd(-1);\n-    }\n-\n-    protected void startZstd(int bufferSize) throws Exception\n     {\n         zstd = new ZstandardCompression();\n-        if (bufferSize > 0)\n-            zstd.setBufferSize(bufferSize);\n-\n         zstd.setByteBufferPool(pool);\n         zstd.start();\n     }\n\ndiff --git a/jetty-core/jetty-compression/jetty-compression-zstandard/src/test/java/org/eclipse/jetty/compression/zstandard/ZstandardDecoderSourceTest.java b/jetty-core/jetty-compression/jetty-compression-zstandard/src/test/java/org/eclipse/jetty/compression/zstandard/ZstandardDecoderSourceTest.java\nindex 14d3b34efb97..66fadaafad47 100644\n--- a/jetty-core/jetty-compression/jetty-compression-zstandard/src/test/java/org/eclipse/jetty/compression/zstandard/ZstandardDecoderSourceTest.java\n+++ b/jetty-core/jetty-compression/jetty-compression-zstandard/src/test/java/org/eclipse/jetty/compression/zstandard/ZstandardDecoderSourceTest.java\n@@ -16,12 +16,17 @@\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n+import org.eclipse.jetty.compression.DecoderSource;\n+import org.eclipse.jetty.io.ByteBufferPool;\n import org.eclipse.jetty.io.Content;\n import org.eclipse.jetty.toolchain.test.MavenPaths;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.MethodSource;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assumptions.assumeFalse;\n \n public class ZstandardDecoderSourceTest extends AbstractZstdTest\n {\n@@ -34,12 +39,71 @@ public void testDecodeText(String textResourceName) throws Exception\n         Path compressed = MavenPaths.findTestResourceFile(compressedName);\n         Path uncompressed = MavenPaths.findTestResourceFile(textResourceName);\n \n-        // TODO: sizedPool config of size 1?\n-        Content.Source fileSource = Content.Source.from(sizedPool, compressed);\n-        Content.Source decoderSource = zstd.newDecoderSource(fileSource);\n+        Content.Source fileSource = Content.Source.from(new ByteBufferPool.Sized(pool, true, 256), compressed);\n+        DecoderSource decoderSource = zstd.newDecoderSource(fileSource);\n \n         String result = Content.Source.asString(decoderSource);\n         String expected = Files.readString(uncompressed);\n         assertEquals(expected, result);\n+        assertTrue(decoderSource.isComplete());\n+\n+        Content.Chunk eof = decoderSource.read();\n+        assertTrue(eof.isLast() && eof.isEmpty() && !Content.Chunk.isFailure(eof));\n+\n+        // Failed after EOF, too late.\n+        decoderSource.fail(new Throwable());\n+\n+        Content.Chunk chunk = decoderSource.read();\n+        assertTrue(chunk.isLast() && chunk.isEmpty() && !Content.Chunk.isFailure(chunk));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""textResources\"")\n+    public void testImmediateFailReleaseAllResources(String textResourceName) throws Exception\n+    {\n+        startZstd();\n+        String compressedName = String.format(\""%s.%s\"", textResourceName, zstd.getFileExtensionNames().get(0));\n+        Path compressed = MavenPaths.findTestResourceFile(compressedName);\n+\n+        // TODO: sizedPool config of size 1?\n+        Content.Source fileSource = Content.Source.from(sizedPool, compressed);\n+        DecoderSource decoderSource = zstd.newDecoderSource(fileSource);\n+        assertFalse(decoderSource.isComplete());\n+\n+        decoderSource.fail(new Throwable());\n+        assertTrue(decoderSource.isComplete());\n+\n+        Content.Chunk err = decoderSource.read();\n+        assertTrue(Content.Chunk.isFailure(err));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""textResources\"")\n+    public void testFailAfterReadReleaseAllResources(String textResourceName) throws Exception\n+    {\n+        startZstd();\n+        String compressedName = String.format(\""%s.%s\"", textResourceName, zstd.getFileExtensionNames().get(0));\n+        Path compressed = MavenPaths.findTestResourceFile(compressedName);\n+\n+        Content.Source fileSource = Content.Source.from(sizedPool, compressed);\n+        DecoderSource decoderSource = zstd.newDecoderSource(fileSource);\n+        assertFalse(decoderSource.isComplete());\n+\n+        Content.Chunk chunk = decoderSource.read();\n+        // skip empty chunks\n+        while (chunk.isEmpty() && !chunk.isLast())\n+            chunk = decoderSource.read();\n+        assertTrue(chunk.hasRemaining());\n+        chunk.release();\n+        // This test tests the behavior of\n+        // a failure before the last chunk.\n+        assumeFalse(chunk.isLast());\n+        assertFalse(decoderSource.isComplete());\n+\n+        decoderSource.fail(new Throwable());\n+        assertTrue(decoderSource.isComplete());\n+\n+        Content.Chunk err = decoderSource.read();\n+        assertTrue(Content.Chunk.isFailure(err));\n     }\n }\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-12854"", ""pr_id"": 12854, ""issue_id"": 12853, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Flaky `WebAppClassLoaderTest.testSystemServerClassDeprecated`\n**Jetty version(s)**\n12.1.x\n\n**Description**\n`org.eclipse.jetty.ee.WebAppClassLoaderTest.testSystemServerClassDeprecated` sometimes fails with:\n\n```\njava.util.ConcurrentModificationException\n\tat java.base/java.util.TreeMap.callMappingFunctionWithCheck(TreeMap.java:786)\n\tat java.base/java.util.TreeMap.computeIfAbsent(TreeMap.java:640)\n\tat org.eclipse.jetty.util@12.1.0-SNAPSHOT/org.eclipse.jetty.util.component.Environment.ensure(Environment.java:45)\n\tat org.eclipse.jetty.ee@12.1.0-SNAPSHOT/org.eclipse.jetty.ee.TestableWebAppClassLoaderContext.initEnvironment(TestableWebAppClassLoaderContext.java:36)\n\tat org.eclipse.jetty.ee@12.1.0-SNAPSHOT/org.eclipse.jetty.ee.WebAppClassLoaderTest.init(WebAppClassLoaderTest.java:60)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:580)\n\tat java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:507)\n\tat java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1458)\n\tat java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:2034)\n\tat java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:189)\n```\n\nSee: https://jenkins.webtide.net/job/jetty.project/job/jetty-12.1.x/479/testReport/junit/org.eclipse.jetty.ee/WebAppClassLoaderTest/Parallel_Stage___Build___Test___JDK23___testSystemServerClassDeprecated/"", ""issue_word_count"": 175, ""test_files_count"": 17, ""non_test_files_count"": 7, ""pr_changed_files"": [""jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentManagerLifeCycleRouteTest.java"", ""jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentManagerTest.java"", ""jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/MockAppProvider.java"", ""jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/TestableWebAppClassLoaderContext.java"", ""jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoaderTest.java"", ""jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoaderUrlStreamTest.java"", ""jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoadingTest.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/Environment.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/NamedEnvironment.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/EnvironmentTest.java"", ""jetty-core/jetty-xml/src/main/java/org/eclipse/jetty/xml/EnvironmentBuilder.java"", ""jetty-core/jetty-xml/src/main/java/org/eclipse/jetty/xml/XmlConfiguration.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextHandler.java"", ""jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/java/org/eclipse/jetty/ee10/test/DeploymentErrorTest.java"", ""jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/resources/RFC2616Base.xml"", ""jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/resources/deploy.xml"", ""jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletContextHandler.java"", ""jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/java/org/eclipse/jetty/ee11/test/DeploymentErrorTest.java"", ""jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/resources/RFC2616Base.xml"", ""jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/resources/deploy.xml"", ""jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java"", ""jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/java/org/eclipse/jetty/ee9/test/DeploymentErrorTest.java"", ""jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/resources/RFC2616Base.xml"", ""jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/resources/deploy.xml""], ""pr_changed_test_files"": [""jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentManagerLifeCycleRouteTest.java"", ""jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentManagerTest.java"", ""jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/MockAppProvider.java"", ""jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/TestableWebAppClassLoaderContext.java"", ""jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoaderTest.java"", ""jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoaderUrlStreamTest.java"", ""jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoadingTest.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/EnvironmentTest.java"", ""jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/java/org/eclipse/jetty/ee10/test/DeploymentErrorTest.java"", ""jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/resources/RFC2616Base.xml"", ""jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/resources/deploy.xml"", ""jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/java/org/eclipse/jetty/ee11/test/DeploymentErrorTest.java"", ""jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/resources/RFC2616Base.xml"", ""jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/resources/deploy.xml"", ""jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/java/org/eclipse/jetty/ee9/test/DeploymentErrorTest.java"", ""jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/resources/RFC2616Base.xml"", ""jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/resources/deploy.xml""], ""base_commit"": ""eadfa79ff73ec275d26f09084559c6f230ab2920"", ""head_commit"": ""224e4afcf9921983a3a50b2ef8963b102a633b02"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/12854"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/12854"", ""dockerfile"": """", ""pr_merged_at"": ""2025-03-11T09:15:19.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/Environment.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/Environment.java\nindex b2d7cca0bdcd..a2f670ad80af 100644\n--- a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/Environment.java\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/Environment.java\n@@ -13,14 +13,10 @@\n \n package org.eclipse.jetty.util.component;\n \n-import java.io.IOException;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Map;\n-import java.util.TreeMap;\n \n import org.eclipse.jetty.util.Attributes;\n-import org.eclipse.jetty.util.TypeUtil;\n \n /**\n  * A named runtime environment containing a {@link ClassLoader} and {@link Attributes}.\n@@ -28,26 +24,59 @@\n public interface Environment extends Attributes\n {\n     // Ensure there is a core environment for possible later deployments to it\n-    Environment CORE = ensure(\""core\"");\n+    Environment CORE = ensure(\""core\"", Environment.class.getClassLoader());\n \n+    /**\n+     * Gets all existing environments.\n+     * @return the environments\n+     */\n     static Collection<Environment> getAll()\n     {\n-        return Collections.unmodifiableCollection(Named.__environments.values());\n+        return Collections.unmodifiableCollection(NamedEnvironment.ENVIRONMENTS.values());\n     }\n-    \n+\n+    /**\n+     * Gets the environment with the given name.\n+     * @param name the environment name\n+     * @return the environment, or null if no environment with such name exists\n+     */\n     static Environment get(String name)\n     {\n-        return Named.__environments.get(name);\n+        return NamedEnvironment.ENVIRONMENTS.get(name);\n     }\n \n-    static Environment ensure(String name)\n+    /**\n+     * Gets the environment with the given name, creating it with the default classloader if necessary.\n+     *\n+     * @param name the environment name\n+     * @param classLoader The loader to either: use to create the environment; or to check the environments loader matches\n+     *                    the passed loader.\n+     * @return the environment\n+     * @throws IllegalArgumentException if an environment with the given name but a different classloader already exists\n+     */\n+    static Environment ensure(String name, ClassLoader classLoader) throws IllegalStateException\n     {\n-        return Named.__environments.computeIfAbsent(name, Named::new);\n+        Environment environment = NamedEnvironment.ENVIRONMENTS.computeIfAbsent(name, n -> new NamedEnvironment(n, classLoader));\n+        if (environment.getClassLoader() != classLoader)\n+            throw new IllegalArgumentException(\""%s has different classloader\"".formatted(name));\n+        return environment;\n     }\n \n-    static Environment set(Environment environment)\n+    /**\n+     * Creates an environment with the given name and classloader.\n+     * @param name the environment name\n+     * @param classLoader the environment classloader\n+     * @return the environment\n+     * @throws IllegalStateException if an environment with the given name already exists\n+     */\n+    static Environment create(String name, ClassLoader classLoader) throws IllegalStateException\n     {\n-        return Named.__environments.put(environment.getName(), environment);\n+        return NamedEnvironment.ENVIRONMENTS.compute(name, (n, environment) ->\n+        {\n+            if (environment != null)\n+                throw new IllegalStateException(\""Environment already exists: \"" + n);\n+            return new NamedEnvironment(n, classLoader);\n+        });\n     }\n \n     /**\n@@ -56,7 +85,7 @@ static Environment set(Environment environment)\n     String getName();\n \n     /**\n-     * @return The {@link ClassLoader} for the environment or if non set, then the {@link ClassLoader} that\n+     * @return The {@link ClassLoader} for the environment or if none set, then the {@link ClassLoader} that\n      * loaded the environment implementation.\n      */\n     ClassLoader getClassLoader();\n@@ -79,56 +108,4 @@ default void run(Runnable runnable)\n             Thread.currentThread().setContextClassLoader(old);\n         }\n     }\n-\n-    class Named extends Attributes.Mapped implements Environment, Dumpable\n-    {\n-        private static final Map<String, Environment> __environments = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n-        private final String _name;\n-        private final ClassLoader _classLoader;\n-\n-        public Named(String name)\n-        {\n-            this(name, null);\n-        }\n-\n-        public Named(String name, ClassLoader classLoader)\n-        {\n-            _name = name;\n-            _classLoader = classLoader == null ? this.getClass().getClassLoader() : classLoader;\n-        }\n-\n-        @Override\n-        public String getName()\n-        {\n-            return _name;\n-        }\n-\n-        @Override\n-        public ClassLoader getClassLoader()\n-        {\n-            return _classLoader;\n-        }\n-\n-        @Override\n-        public String dump()\n-        {\n-            return Dumpable.dump(this);\n-        }\n-\n-        @Override\n-        public void dump(Appendable out, String indent) throws IOException\n-        {\n-            Dumpable.dumpObjects(out, indent,\n-                this,\n-                new ClassLoaderDump(getClassLoader()),\n-                new DumpableCollection(\""Attributes \"" + _name, asAttributeMap().entrySet()));\n-        }\n-\n-        @Override\n-        public String toString()\n-        {\n-            return \""%s@%x{%s}\"".formatted(TypeUtil.toShortName(this.getClass()), hashCode(), _name);\n-        }\n-    }\n-\n }\n\ndiff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/NamedEnvironment.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/NamedEnvironment.java\nnew file mode 100644\nindex 000000000000..ed58c982ea1a\n--- /dev/null\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/component/NamedEnvironment.java\n@@ -0,0 +1,82 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.component;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+\n+import org.eclipse.jetty.util.Attributes;\n+import org.eclipse.jetty.util.TypeUtil;\n+\n+class NamedEnvironment extends Attributes.Mapped implements Environment, Dumpable\n+{\n+    static final Map<String, Environment> ENVIRONMENTS = new ConcurrentSkipListMap<>(String.CASE_INSENSITIVE_ORDER);\n+    static final ClassLoader DEFAULT_CLASSLOADER = NamedEnvironment.class.getClassLoader();\n+\n+    private final String _name;\n+    private final ClassLoader _classLoader;\n+\n+    NamedEnvironment(String name, ClassLoader classLoader)\n+    {\n+        _name = name;\n+        _classLoader = classLoader == null ? DEFAULT_CLASSLOADER : classLoader;\n+    }\n+\n+    @Override\n+    public String getName()\n+    {\n+        return _name;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader()\n+    {\n+        return _classLoader;\n+    }\n+\n+    @Override\n+    public String dump()\n+    {\n+        return Dumpable.dump(this);\n+    }\n+\n+    @Override\n+    public void dump(Appendable out, String indent) throws IOException\n+    {\n+        Dumpable.dumpObjects(out, indent,\n+            this,\n+            new ClassLoaderDump(getClassLoader()),\n+            new DumpableCollection(\""Attributes \"" + _name, asAttributeMap().entrySet()));\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return _name.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        // Only do instance equality\n+        return this == o;\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \""%s@%x{%s}\"".formatted(TypeUtil.toShortName(this.getClass()), hashCode(), _name);\n+    }\n+}\n\ndiff --git a/jetty-core/jetty-xml/src/main/java/org/eclipse/jetty/xml/EnvironmentBuilder.java b/jetty-core/jetty-xml/src/main/java/org/eclipse/jetty/xml/EnvironmentBuilder.java\nindex cbbd3569ce06..7d399c7a7f5a 100644\n--- a/jetty-core/jetty-xml/src/main/java/org/eclipse/jetty/xml/EnvironmentBuilder.java\n+++ b/jetty-core/jetty-xml/src/main/java/org/eclipse/jetty/xml/EnvironmentBuilder.java\n@@ -21,7 +21,6 @@\n \n import org.eclipse.jetty.util.annotation.Name;\n import org.eclipse.jetty.util.component.Environment;\n-import org.eclipse.jetty.util.resource.Resource;\n import org.eclipse.jetty.util.resource.ResourceFactory;\n \n /**\n@@ -61,6 +60,6 @@ public void addClassPath(String... classPaths)\n \n     public Environment build() throws Exception\n     {\n-        return new Environment.Named(_name, new URLClassLoader(_classpath.toArray(new URL[0]), EnvironmentBuilder.class.getClassLoader()));\n+        return Environment.create(_name, new URLClassLoader(_classpath.toArray(new URL[0]), EnvironmentBuilder.class.getClassLoader()));\n     }\n }\n\ndiff --git a/jetty-core/jetty-xml/src/main/java/org/eclipse/jetty/xml/XmlConfiguration.java b/jetty-core/jetty-xml/src/main/java/org/eclipse/jetty/xml/XmlConfiguration.java\nindex 9c45a486319d..8dc1c60975ce 100644\n--- a/jetty-core/jetty-xml/src/main/java/org/eclipse/jetty/xml/XmlConfiguration.java\n+++ b/jetty-core/jetty-xml/src/main/java/org/eclipse/jetty/xml/XmlConfiguration.java\n@@ -1990,7 +1990,6 @@ public static void main(final String... args) throws Exception\n                         if (envBuilder != null)\n                         {\n                             environment = envBuilder.build();\n-                            Environment.set(environment);\n                             envBuilder = null;\n                         }\n                     }\n@@ -2086,10 +2085,7 @@ else if (arg.toLowerCase(Locale.ENGLISH).endsWith(\"".xml\""))\n                 }\n             }\n             if (envBuilder != null)\n-            {\n-                environment = envBuilder.build();\n-                Environment.set(environment);\n-            }\n+                envBuilder.build();\n \n             if (LOG.isDebugEnabled())\n                 LOG.debug(\""objects={}\"", objects);\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextHandler.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextHandler.java\nindex b2e585c4197d..1211a2b99fbe 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextHandler.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextHandler.java\n@@ -133,7 +133,7 @@\n public class ServletContextHandler extends ContextHandler\n {\n     private static final Logger LOG = LoggerFactory.getLogger(ServletContextHandler.class);\n-    public static final Environment ENVIRONMENT = Environment.ensure(\""ee10\"");\n+    public static final Environment ENVIRONMENT = Environment.ensure(\""ee10\"", ServletContextHandler.class.getClassLoader());\n     /**\n      * @deprecated Use {@link ServletContextHandler#ENVIRONMENT} instead.\n      */\n\ndiff --git a/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletContextHandler.java b/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletContextHandler.java\nindex 36df041d8c46..fe1dd1255486 100644\n--- a/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletContextHandler.java\n+++ b/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletContextHandler.java\n@@ -133,7 +133,7 @@\n public class ServletContextHandler extends ContextHandler\n {\n     private static final Logger LOG = LoggerFactory.getLogger(ServletContextHandler.class);\n-    public static final Environment ENVIRONMENT = Environment.ensure(\""ee11\"");\n+    public static final Environment ENVIRONMENT = Environment.ensure(\""ee11\"", ServletContextHandler.class.getClassLoader());\n     /**\n      * @deprecated Use {@link ServletContextHandler#ENVIRONMENT} instead.\n      */\n\ndiff --git a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java\nindex 145163b21652..25d14725d4cb 100644\n--- a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java\n+++ b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/ContextHandler.java\n@@ -144,7 +144,7 @@\n @ManagedObject(\""EE9 Context\"")\n public class ContextHandler extends ScopedHandler implements Attributes, Supplier<Handler>\n {\n-    public static final Environment ENVIRONMENT = Environment.ensure(\""ee9\"");\n+    public static final Environment ENVIRONMENT = Environment.ensure(\""ee9\"", ContextHandler.class.getClassLoader());\n     public static final int SERVLET_MAJOR_VERSION = 5;\n     public static final int SERVLET_MINOR_VERSION = 0;\n     public static final Class<?>[] SERVLET_LISTENER_TYPES =\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentManagerLifeCycleRouteTest.java b/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentManagerLifeCycleRouteTest.java\nindex 21646d04e897..782a2e1abf86 100644\n--- a/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentManagerLifeCycleRouteTest.java\n+++ b/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentManagerLifeCycleRouteTest.java\n@@ -21,18 +21,28 @@\n \n import org.eclipse.jetty.jmx.MBeanContainer;\n import org.eclipse.jetty.server.handler.ContextHandlerCollection;\n+import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n \n public class DeploymentManagerLifeCycleRouteTest\n {\n+    private String environmentName;\n+\n+    @BeforeEach\n+    public void setUp(TestInfo testInfo)\n+    {\n+        environmentName = testInfo.getTestClass().orElseThrow().getName() + \"".\"" + testInfo.getTestMethod().orElseThrow().getName();\n+    }\n+\n     @Test\n-    public void testStateTransitionNewToDeployed() throws Exception\n+    public void testStateTransitionNewToDeployed(TestInfo testInfo) throws Exception\n     {\n         DeploymentManager depman = new DeploymentManager();\n         depman.setContexts(new ContextHandlerCollection());\n         depman.setDefaultLifeCycleGoal(null); // no default\n         AppLifeCyclePathCollector pathtracker = new AppLifeCyclePathCollector();\n-        MockAppProvider mockProvider = new MockAppProvider();\n+        MockAppProvider mockProvider = new MockAppProvider(environmentName);\n \n         depman.addLifeCycleBinding(pathtracker);\n         depman.addAppProvider(mockProvider);\n@@ -58,13 +68,13 @@ public void testStateTransitionNewToDeployed() throws Exception\n     }\n \n     @Test\n-    public void testStateTransitionReceive() throws Exception\n+    public void testStateTransitionReceive(TestInfo testInfo) throws Exception\n     {\n         DeploymentManager depman = new DeploymentManager();\n         depman.setContexts(new ContextHandlerCollection());\n         depman.setDefaultLifeCycleGoal(null); // no default\n         AppLifeCyclePathCollector pathtracker = new AppLifeCyclePathCollector();\n-        MockAppProvider mockProvider = new MockAppProvider();\n+        MockAppProvider mockProvider = new MockAppProvider(environmentName);\n \n         depman.addLifeCycleBinding(pathtracker);\n         depman.addAppProvider(mockProvider);\n@@ -84,12 +94,12 @@ public void testStateTransitionReceive() throws Exception\n     }\n \n     @Test\n-    public void testStateTransitionDeployedToUndeployed() throws Exception\n+    public void testStateTransitionDeployedToUndeployed(TestInfo testInfo) throws Exception\n     {\n         DeploymentManager depman = new DeploymentManager();\n         depman.setDefaultLifeCycleGoal(null); // no default\n         AppLifeCyclePathCollector pathtracker = new AppLifeCyclePathCollector();\n-        MockAppProvider mockProvider = new MockAppProvider();\n+        MockAppProvider mockProvider = new MockAppProvider(environmentName);\n \n         // Setup JMX\n         MBeanContainer mbContainer = new MBeanContainer(ManagementFactory.getPlatformMBeanServer());\n\ndiff --git a/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentManagerTest.java b/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentManagerTest.java\nindex 2bd5d43f3646..be7a9f0acf63 100644\n--- a/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentManagerTest.java\n+++ b/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/DeploymentManagerTest.java\n@@ -13,6 +13,8 @@\n \n package org.eclipse.jetty.deploy;\n \n+import java.net.URL;\n+import java.net.URLClassLoader;\n import java.nio.file.Path;\n import java.util.Collection;\n import java.util.Set;\n@@ -25,7 +27,9 @@\n import org.eclipse.jetty.util.component.Environment;\n import org.hamcrest.Matchers;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.parallel.Isolated;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.contains;\n@@ -35,17 +39,19 @@\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n \n @ExtendWith(WorkDirExtension.class)\n+@Isolated\n public class DeploymentManagerTest\n {\n \n     @Test\n-    public void testReceiveApp() throws Exception\n+    public void testReceiveApp(TestInfo testInfo) throws Exception\n     {\n         DeploymentManager depman = new DeploymentManager();\n         depman.setContexts(new ContextHandlerCollection());\n         depman.setDefaultLifeCycleGoal(null); // no default\n         AppLifeCyclePathCollector pathtracker = new AppLifeCyclePathCollector();\n-        MockAppProvider mockProvider = new MockAppProvider();\n+        String environmentName = testInfo.getTestClass().orElseThrow().getName() + \"".\"" + testInfo.getTestMethod().orElseThrow().getName();\n+        MockAppProvider mockProvider = new MockAppProvider(environmentName);\n \n         depman.addLifeCycleBinding(pathtracker);\n         depman.addAppProvider(mockProvider);\n@@ -90,60 +96,25 @@ public void testDefaultEnvironment()\n     {\n         DeploymentManager depman = new DeploymentManager();\n         assertThat(depman.getDefaultEnvironmentName(), Matchers.nullValue());\n-\n-        Environment.ensure(\""ee7\"");\n-        depman.addAppProvider(new MockAppProvider()\n-        {\n-            @Override\n-            public String getEnvironmentName()\n-            {\n-                return \""ee7\"";\n-            }\n-        });\n+        ClassLoader mockLoader = new URLClassLoader(new URL[0]);\n+        Environment.create(\""ee7\"", mockLoader);\n+        depman.addAppProvider(new MockAppProvider(\""ee7\""));\n         assertThat(depman.getDefaultEnvironmentName(), is(\""ee7\""));\n \n-        Environment.ensure(\""ee12\"");\n-        depman.addAppProvider(new MockAppProvider()\n-        {\n-            @Override\n-            public String getEnvironmentName()\n-            {\n-                return \""ee12\"";\n-            }\n-        });\n+        Environment.create(\""ee12\"", mockLoader);\n+        depman.addAppProvider(new MockAppProvider(\""ee12\""));\n         assertThat(depman.getDefaultEnvironmentName(), is(\""ee12\""));\n \n-        Environment.ensure(\""ee11\"");\n-        depman.addAppProvider(new MockAppProvider()\n-        {\n-            @Override\n-            public String getEnvironmentName()\n-            {\n-                return \""ee11\"";\n-            }\n-        });\n+        Environment.create(\""ee11\"", mockLoader);\n+        depman.addAppProvider(new MockAppProvider(\""ee11\""));\n         assertThat(depman.getDefaultEnvironmentName(), is(\""ee12\""));\n \n-        Environment.ensure(\""somethingElse\"");\n-        depman.addAppProvider(new MockAppProvider()\n-        {\n-            @Override\n-            public String getEnvironmentName()\n-            {\n-                return \""somethingElse\"";\n-            }\n-        });\n+        Environment.create(\""somethingElse\"", mockLoader);\n+        depman.addAppProvider(new MockAppProvider(\""somethingElse\""));\n         assertThat(depman.getDefaultEnvironmentName(), is(\""ee12\""));\n \n-        Environment.ensure(\""other\"");\n-        depman.addAppProvider(new MockAppProvider()\n-        {\n-            @Override\n-            public String getEnvironmentName()\n-            {\n-                return \""other\"";\n-            }\n-        });\n+        Environment.create(\""other\"", mockLoader);\n+        depman.addAppProvider(new MockAppProvider(\""other\""));\n \n         assertThat(depman.getAppProviders().stream().map(AppProvider::getEnvironmentName).sorted(Deployable.ENVIRONMENT_COMPARATOR).toList(),\n             contains(\n\ndiff --git a/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/MockAppProvider.java b/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/MockAppProvider.java\nindex 57af532999fc..d0068da3b216 100644\n--- a/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/MockAppProvider.java\n+++ b/jetty-core/jetty-deploy/src/test/java/org/eclipse/jetty/deploy/MockAppProvider.java\n@@ -19,17 +19,22 @@\n import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n import org.eclipse.jetty.util.FileID;\n import org.eclipse.jetty.util.component.AbstractLifeCycle;\n-import org.eclipse.jetty.util.component.Environment;\n \n public class MockAppProvider extends AbstractLifeCycle implements AppProvider\n {\n+    private final String environmentName;\n     private DeploymentManager deployMan;\n     private Path webappsDir;\n \n+    public MockAppProvider(String environmentName)\n+    {\n+        this.environmentName = environmentName;\n+    }\n+\n     @Override\n     public String getEnvironmentName()\n     {\n-        return Environment.ensure(\""mock\"").getName();\n+        return environmentName;\n     }\n \n     @Override\n\ndiff --git a/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/TestableWebAppClassLoaderContext.java b/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/TestableWebAppClassLoaderContext.java\nindex cb1da5ccc68a..f50ca247fe4b 100644\n--- a/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/TestableWebAppClassLoaderContext.java\n+++ b/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/TestableWebAppClassLoaderContext.java\n@@ -31,19 +31,12 @@ public class TestableWebAppClassLoaderContext implements WebAppClassLoader.Conte\n     private ClassMatcher hiddenClassMatcher;\n     private List<Resource> extraClasspath;\n \n-    public static void initEnvironment()\n+    public TestableWebAppClassLoaderContext(ResourceFactory resourceFactory, String environmentName)\n     {\n-        Environment environment = Environment.ensure(\""testable\"");\n+        this.resourceFactory = resourceFactory;\n+        Environment environment = Environment.create(environmentName, null);\n         environment.setAttribute(WebAppClassLoading.PROTECTED_CLASSES_ATTRIBUTE, \""\"");\n         environment.setAttribute(WebAppClassLoading.HIDDEN_CLASSES_ATTRIBUTE, \""\"");\n-    }\n-\n-    public TestableWebAppClassLoaderContext(ResourceFactory resourceFactory)\n-    {\n-        this.resourceFactory = resourceFactory;\n-        Environment environment = Environment.get(\""testable\"");\n-        if (environment == null)\n-            throw new IllegalStateException(\""The [testable] Environment hasn't been configured yet\"");\n \n         this.protectedClassMatcher = new ClassMatcher(WebAppClassLoading.getProtectedClasses(environment));\n         this.hiddenClassMatcher = new ClassMatcher(WebAppClassLoading.getHiddenClasses(environment));\n\ndiff --git a/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoaderTest.java b/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoaderTest.java\nindex 4e150787d136..147bc3fc9be1 100644\n--- a/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoaderTest.java\n+++ b/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoaderTest.java\n@@ -34,6 +34,7 @@\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n \n import static org.eclipse.jetty.toolchain.test.ExtraMatchers.ordered;\n import static org.hamcrest.MatcherAssert.assertThat;\n@@ -55,14 +56,13 @@ public class WebAppClassLoaderTest\n     private ContainerLifeCycle _container;\n \n     @BeforeEach\n-    public void init() throws Exception\n+    public void init(TestInfo testInfo) throws Exception\n     {\n-        TestableWebAppClassLoaderContext.initEnvironment();\n-\n         _container = new ContainerLifeCycle();\n         ResourceFactory resourceFactory = ResourceFactory.of(_container);\n \n-        _context = new TestableWebAppClassLoaderContext(resourceFactory);\n+        String environmentName = testInfo.getTestClass().orElseThrow().getName() + \"".\"" + testInfo.getTestMethod().orElseThrow().getName();\n+        _context = new TestableWebAppClassLoaderContext(resourceFactory, environmentName);\n \n         _testWebappDir = MavenTestingUtils.getProjectDirPath(\""src/test/webapp\"");\n         Resource webapp = resourceFactory.newResource(_testWebappDir);\n\ndiff --git a/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoaderUrlStreamTest.java b/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoaderUrlStreamTest.java\nindex c7791b3566a4..3798af673cf9 100644\n--- a/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoaderUrlStreamTest.java\n+++ b/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoaderUrlStreamTest.java\n@@ -100,10 +100,8 @@ public void cleanupURLStreamHandlerFactory()\n     }\n \n     @BeforeEach\n-    @Override\n-    public void init() throws Exception\n+    public void setUp() throws Exception\n     {\n-        super.init();\n         URLStreamHandlerUtil.setFactory(new URLHandlers(_loader));\n     }\n }\n\ndiff --git a/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoadingTest.java b/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoadingTest.java\nindex ae2d70dceed1..b13b628cc901 100644\n--- a/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoadingTest.java\n+++ b/jetty-core/jetty-ee/src/test/java/org/eclipse/jetty/ee/WebAppClassLoadingTest.java\n@@ -21,6 +21,7 @@\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.contains;\n@@ -32,18 +33,21 @@\n \n public class WebAppClassLoadingTest\n {\n+    private String environmentName;\n+\n     @BeforeEach\n-    public void beforeEach()\n+    public void beforeEach(TestInfo testInfo)\n     {\n-        Environment.ensure(\""Test\"");\n+        environmentName = testInfo.getTestClass().orElseThrow().getName() + \"".\"" + testInfo.getTestMethod().orElseThrow().getName();\n+        Environment.create(environmentName, null);\n     }\n \n     @AfterEach\n     public void afterEach()\n     {\n-        Environment.ensure(\""Test\"").clearAttributes();\n+        Environment.get(environmentName).clearAttributes();\n     }\n-    \n+\n     @Test\n     public void testServerDefaults()\n     {\n@@ -128,7 +132,7 @@ public void testServerAddPatterns()\n     @Test\n     public void testEnvironmentDefaults()\n     {\n-        Environment environment = Environment.get(\""Test\"");\n+        Environment environment = Environment.get(environmentName);\n         ClassMatcher protect = WebAppClassLoading.getProtectedClasses(environment);\n         assertThat(protect, equalTo(WebAppClassLoading.DEFAULT_PROTECTED_CLASSES));\n         assertThat(environment.getAttribute(WebAppClassLoading.PROTECTED_CLASSES_ATTRIBUTE), sameInstance(protect));\n@@ -140,7 +144,7 @@ public void testEnvironmentDefaults()\n     @Test\n     public void testEnvironmentAttributeDefaults()\n     {\n-        Environment environment = Environment.get(\""Test\"");\n+        Environment environment = Environment.get(environmentName);\n         ClassMatcher protect = new ClassMatcher(\""org.protect.\"");\n         environment.setAttribute(WebAppClassLoading.PROTECTED_CLASSES_ATTRIBUTE, protect);\n         ClassMatcher hide = new ClassMatcher(\""org.hide.\"");\n@@ -153,7 +157,7 @@ public void testEnvironmentAttributeDefaults()\n     @Test\n     public void testEnvironmentStringAttributeDefaults()\n     {\n-        Environment environment = Environment.get(\""Test\"");\n+        Environment environment = Environment.get(environmentName);\n         environment.setAttribute(WebAppClassLoading.PROTECTED_CLASSES_ATTRIBUTE, new String[] {\""org.protect.\""});\n         environment.setAttribute(WebAppClassLoading.HIDDEN_CLASSES_ATTRIBUTE, new String[] {\""org.hide.\""});\n \n@@ -170,7 +174,7 @@ public void testEnvironmentStringAttributeDefaults()\n     @Test\n     public void testEnvironmentProgrammaticDefaults()\n     {\n-        Environment environment = Environment.get(\""Test\"");\n+        Environment environment = Environment.get(environmentName);\n         WebAppClassLoading.addProtectedClasses(environment, \""org.protect.\"");\n         WebAppClassLoading.addHiddenClasses(environment, \""org.hide.\"");\n \n@@ -193,7 +197,7 @@ public void testEnvironmentProgrammaticDefaults()\n     @Test\n     public void testEnvironmentAddPatterns()\n     {\n-        Environment environment = Environment.get(\""Test\"");\n+        Environment environment = Environment.get(environmentName);\n         ClassMatcher protect = WebAppClassLoading.getProtectedClasses(environment);\n         ClassMatcher hide = WebAppClassLoading.getHiddenClasses(environment);\n \n\ndiff --git a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/EnvironmentTest.java b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/EnvironmentTest.java\nnew file mode 100644\nindex 000000000000..0e19002f47e2\n--- /dev/null\n+++ b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/component/EnvironmentTest.java\n@@ -0,0 +1,64 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.util.component;\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.sameInstance;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class EnvironmentTest\n+{\n+    @Test\n+    public void testCreate() throws Exception\n+    {\n+        ClassLoader loaderA = new URLClassLoader(new URL[0]);\n+        Environment envA = Environment.create(\""envA\"", loaderA);\n+        assertThat(envA.getClassLoader(), sameInstance(loaderA));\n+\n+        ClassLoader loaderB = new URLClassLoader(new URL[0]);\n+        Environment envB = Environment.create(\""envB\"", loaderB);\n+        assertThat(envB.getClassLoader(), sameInstance(loaderB));\n+\n+        assertThat(Environment.get(\""envA\""), sameInstance(envA));\n+        assertThat(Environment.get(\""envB\""), sameInstance(envB));\n+\n+        @SuppressWarnings(\""resource\"")\n+        ClassLoader loaderAX = new URLClassLoader(new URL[0]);\n+        assertThrows(IllegalStateException.class, () -> Environment.create(\""envA\"", loaderAX));\n+\n+        assertThat(Environment.getAll(), Matchers.hasItems(envA, envB));\n+    }\n+\n+    @Test\n+    public void testEnsure() throws Exception\n+    {\n+        ClassLoader loaderC = new URLClassLoader(new URL[0]);\n+        ClassLoader loaderD = new URLClassLoader(new URL[0]);\n+        Environment envC = Environment.create(\""envC\"", loaderC);\n+\n+        assertThat(Environment.ensure(\""envC\"", loaderC), sameInstance(envC));\n+        assertThrows(IllegalArgumentException.class, () -> Environment.ensure(\""envC\"", loaderD));\n+\n+        Environment envD = Environment.ensure(\""envD\"", loaderD);\n+        assertThat(envD.getClassLoader(), sameInstance(loaderD));\n+        assertThat(Environment.get(\""envD\""), sameInstance(envD));\n+        assertThat(Environment.getAll(), Matchers.hasItems(envC, envD));\n+    }\n+}\n\ndiff --git a/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/java/org/eclipse/jetty/ee10/test/DeploymentErrorTest.java b/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/java/org/eclipse/jetty/ee10/test/DeploymentErrorTest.java\nindex 89877be22cba..3d62fbbf5e82 100644\n--- a/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/java/org/eclipse/jetty/ee10/test/DeploymentErrorTest.java\n+++ b/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/java/org/eclipse/jetty/ee10/test/DeploymentErrorTest.java\n@@ -31,6 +31,7 @@\n import org.eclipse.jetty.deploy.DeploymentManager;\n import org.eclipse.jetty.deploy.graph.Node;\n import org.eclipse.jetty.deploy.providers.ContextProvider;\n+import org.eclipse.jetty.ee10.servlet.ServletContextHandler;\n import org.eclipse.jetty.ee10.webapp.AbstractConfiguration;\n import org.eclipse.jetty.ee10.webapp.Configuration;\n import org.eclipse.jetty.ee10.webapp.Configurations;\n@@ -51,7 +52,6 @@\n import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n import org.eclipse.jetty.toolchain.test.jupiter.WorkDir;\n import org.eclipse.jetty.toolchain.test.jupiter.WorkDirExtension;\n-import org.eclipse.jetty.util.component.Environment;\n import org.eclipse.jetty.util.component.LifeCycle;\n import org.eclipse.jetty.util.resource.ResourceFactory;\n import org.junit.jupiter.api.AfterEach;\n@@ -63,6 +63,7 @@\n import static org.hamcrest.Matchers.nullValue;\n import static org.hamcrest.core.Is.is;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n @ExtendWith(WorkDirExtension.class)\n public class DeploymentErrorTest\n@@ -88,8 +89,7 @@ public Path startServer(Consumer<Path> docrootSetupConsumer) throws Exception\n         ContextHandlerCollection contexts = new ContextHandlerCollection();\n \n         //Environment\n-        Environment ee10 = Environment.ensure(\""ee10\"");\n-        ee10.setAttribute(\""contextHandlerClass\"", \""org.eclipse.jetty.ee10.webapp.WebAppContext\"");\n+        ServletContextHandler.ENVIRONMENT.setAttribute(\""contextHandlerClass\"", \""org.eclipse.jetty.ee10.webapp.WebAppContext\"");\n \n         // Deployment Manager\n         deploymentManager = new DeploymentManager();\n@@ -131,7 +131,7 @@ public Path startServer(Consumer<Path> docrootSetupConsumer) throws Exception\n     }\n \n     @AfterEach\n-    public void tearDownServer() throws Exception\n+    public void tearDownServer()\n     {\n         if (stacklessLogging != null)\n             stacklessLogging.close();\n@@ -183,6 +183,7 @@ public void testInitialBadAppUnavailableFalse() throws Exception\n         assertThat(\""Apps tracked\"", apps.size(), is(1));\n         String contextPath = \""/badapp-uaf\"";\n         App app = findApp(contextPath, apps);\n+        assert app != null;\n         ContextHandler context = app.getContextHandler();\n         assertThat(\""ContextHandler.isStarted\"", context.isStarted(), is(true));\n         assertThat(\""ContextHandler.isFailed\"", context.isFailed(), is(false));\n@@ -228,6 +229,7 @@ public void testDelayedAddBadAppUnavailableTrue() throws Exception\n         List<App> apps = new ArrayList<>(deploymentManager.getApps());\n         assertThat(\""Apps tracked\"", apps.size(), is(1));\n         App app = findApp(contextPath, apps);\n+        assert app != null;\n         ContextHandler context = app.getContextHandler();\n         assertThat(\""ContextHandler.isStarted\"", context.isStarted(), is(false));\n         assertThat(\""ContextHandler.isFailed\"", context.isFailed(), is(true));\n@@ -268,11 +270,12 @@ public void testDelayedAddBadAppUnavailableFalse() throws Exception\n         copyBadApp(\""badapp-unavailable-false.xml\"", docroots);\n \n         // Wait for deployment manager to do its thing\n-        startTracking.startedLatch.await(3, TimeUnit.SECONDS);\n+        assertTrue(startTracking.startedLatch.await(3, TimeUnit.SECONDS));\n \n         List<App> apps = new ArrayList<>(deploymentManager.getApps());\n         assertThat(\""Apps tracked\"", apps.size(), is(1));\n         App app = findApp(contextPath, apps);\n+        assert app != null;\n         ContextHandler context = app.getContextHandler();\n         assertThat(\""ContextHandler.isStarted\"", context.isStarted(), is(true));\n         assertThat(\""ContextHandler.isFailed\"", context.isFailed(), is(false));\n@@ -296,17 +299,13 @@ public void testDelayedAddBadAppUnavailableFalse() throws Exception\n     private void assertHttpState(String contextPath, int expectedStatusCode) throws Exception\n     {\n         URI destURI = server.getURI().resolve(contextPath);\n-        HttpClient client = new HttpClient();\n-        try\n+\n+        try (HttpClient client = new HttpClient())\n         {\n             client.start();\n             ContentResponse response = client.newRequest(destURI).method(HttpMethod.GET).send();\n             assertThat(\""GET Response: \"" + destURI, response.getStatus(), is(expectedStatusCode));\n         }\n-        finally\n-        {\n-            client.stop();\n-        }\n     }\n \n     private App findApp(String contextPath, List<App> apps)\n\ndiff --git a/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/resources/RFC2616Base.xml b/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/resources/RFC2616Base.xml\nindex 7143ce867e21..a802723c4615 100644\n--- a/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/resources/RFC2616Base.xml\n+++ b/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/resources/RFC2616Base.xml\n@@ -81,9 +81,7 @@\n     </New>\n   </Set>\n \n-  <Call id=\""Environment\"" class=\""org.eclipse.jetty.util.component.Environment\"" name=\""ensure\"">\n-    <Arg>ee10</Arg>\n-  </Call>\n+  <Get id=\""Environment\"" class=\""org.eclipse.jetty.ee10.servlet.ServletContextHandler\"" name=\""ENVIRONMENT\""/>\n   <Ref refid=\""Environment\"">\n     <Call name=\""setAttribute\"">\n       <Arg>contextHandlerClass</Arg>\n\ndiff --git a/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/resources/deploy.xml b/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/resources/deploy.xml\nindex f04a2228c943..0623d2ffc215 100644\n--- a/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/resources/deploy.xml\n+++ b/jetty-ee10/jetty-ee10-tests/jetty-ee10-test-integration/src/test/resources/deploy.xml\n@@ -2,9 +2,8 @@\n <!DOCTYPE Configure PUBLIC \""-//Jetty//Configure//EN\"" \""https://jetty.org/configure_10_0.dtd\"">\n \n <Configure id=\""Server\"" class=\""org.eclipse.jetty.server.Server\"">\n-  <Call id=\""Environment\"" class=\""org.eclipse.jetty.util.component.Environment\"" name=\""ensure\"">\n-    <Arg>ee10</Arg>\n-  </Call>\n+\n+  <Get id=\""Environment\"" class=\""org.eclipse.jetty.ee10.servlet.ServletContextHandler\"" name=\""ENVIRONMENT\""/>\n   <Ref refid=\""Environment\"">\n     <Call name=\""setAttribute\"">\n       <Arg>contextHandlerClass</Arg>\n\ndiff --git a/jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/java/org/eclipse/jetty/ee11/test/DeploymentErrorTest.java b/jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/java/org/eclipse/jetty/ee11/test/DeploymentErrorTest.java\nindex 9a6e3ab00a7d..e58a4452d068 100644\n--- a/jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/java/org/eclipse/jetty/ee11/test/DeploymentErrorTest.java\n+++ b/jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/java/org/eclipse/jetty/ee11/test/DeploymentErrorTest.java\n@@ -31,6 +31,7 @@\n import org.eclipse.jetty.deploy.DeploymentManager;\n import org.eclipse.jetty.deploy.graph.Node;\n import org.eclipse.jetty.deploy.providers.ContextProvider;\n+import org.eclipse.jetty.ee11.servlet.ServletContextHandler;\n import org.eclipse.jetty.ee11.webapp.AbstractConfiguration;\n import org.eclipse.jetty.ee11.webapp.Configuration;\n import org.eclipse.jetty.ee11.webapp.Configurations;\n@@ -51,7 +52,6 @@\n import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n import org.eclipse.jetty.toolchain.test.jupiter.WorkDir;\n import org.eclipse.jetty.toolchain.test.jupiter.WorkDirExtension;\n-import org.eclipse.jetty.util.component.Environment;\n import org.eclipse.jetty.util.component.LifeCycle;\n import org.eclipse.jetty.util.resource.ResourceFactory;\n import org.junit.jupiter.api.AfterEach;\n@@ -88,8 +88,7 @@ public Path startServer(Consumer<Path> docrootSetupConsumer) throws Exception\n         ContextHandlerCollection contexts = new ContextHandlerCollection();\n \n         //Environment\n-        Environment ee11 = Environment.ensure(\""ee11\"");\n-        ee11.setAttribute(\""contextHandlerClass\"", \""org.eclipse.jetty.ee11.webapp.WebAppContext\"");\n+        ServletContextHandler.ENVIRONMENT.setAttribute(\""contextHandlerClass\"", \""org.eclipse.jetty.ee11.webapp.WebAppContext\"");\n \n         // Deployment Manager\n         deploymentManager = new DeploymentManager();\n\ndiff --git a/jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/resources/RFC2616Base.xml b/jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/resources/RFC2616Base.xml\nindex f16dcb4c5f4d..6bdb6a405423 100644\n--- a/jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/resources/RFC2616Base.xml\n+++ b/jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/resources/RFC2616Base.xml\n@@ -83,9 +83,7 @@\n     </New>\n   </Set>\n \n-  <Call id=\""Environment\"" class=\""org.eclipse.jetty.util.component.Environment\"" name=\""ensure\"">\n-    <Arg>ee11</Arg>\n-  </Call>\n+  <Get id=\""Environment\"" class=\""org.eclipse.jetty.ee11.servlet.ServletContextHandler\"" name=\""ENVIRONMENT\""/>\n   <Ref refid=\""Environment\"">\n     <Call name=\""setAttribute\"">\n       <Arg>contextHandlerClass</Arg>\n\ndiff --git a/jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/resources/deploy.xml b/jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/resources/deploy.xml\nindex a2537bf9e8a7..610fa30f8c9f 100644\n--- a/jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/resources/deploy.xml\n+++ b/jetty-ee11/jetty-ee11-tests/jetty-ee11-test-integration/src/test/resources/deploy.xml\n@@ -2,9 +2,7 @@\n <!DOCTYPE Configure PUBLIC \""-//Jetty//Configure//EN\"" \""https://jetty.org/configure_10_0.dtd\"">\n \n <Configure id=\""Server\"" class=\""org.eclipse.jetty.server.Server\"">\n-  <Call id=\""Environment\"" class=\""org.eclipse.jetty.util.component.Environment\"" name=\""ensure\"">\n-    <Arg>ee11</Arg>\n-  </Call>\n+  <Get id=\""Environment\"" class=\""org.eclipse.jetty.ee11.servlet.ServletContextHandler\"" name=\""ENVIRONMENT\""/>\n   <Ref refid=\""Environment\"">\n     <Call name=\""setAttribute\"">\n       <Arg>contextHandlerClass</Arg>\n\ndiff --git a/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/java/org/eclipse/jetty/ee9/test/DeploymentErrorTest.java b/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/java/org/eclipse/jetty/ee9/test/DeploymentErrorTest.java\nindex d9e73b607cbb..5c4535053d48 100644\n--- a/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/java/org/eclipse/jetty/ee9/test/DeploymentErrorTest.java\n+++ b/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/java/org/eclipse/jetty/ee9/test/DeploymentErrorTest.java\n@@ -31,6 +31,7 @@\n import org.eclipse.jetty.deploy.DeploymentManager;\n import org.eclipse.jetty.deploy.graph.Node;\n import org.eclipse.jetty.deploy.providers.ContextProvider;\n+import org.eclipse.jetty.ee9.servlet.ServletContextHandler;\n import org.eclipse.jetty.ee9.webapp.AbstractConfiguration;\n import org.eclipse.jetty.ee9.webapp.Configuration;\n import org.eclipse.jetty.ee9.webapp.Configurations;\n@@ -49,7 +50,6 @@\n import org.eclipse.jetty.toolchain.test.MavenTestingUtils;\n import org.eclipse.jetty.toolchain.test.jupiter.WorkDir;\n import org.eclipse.jetty.toolchain.test.jupiter.WorkDirExtension;\n-import org.eclipse.jetty.util.component.Environment;\n import org.eclipse.jetty.util.resource.ResourceFactory;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Test;\n@@ -61,15 +61,14 @@\n import static org.hamcrest.core.Is.is;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n @ExtendWith(WorkDirExtension.class)\n public class DeploymentErrorTest\n {\n-\n     private StacklessLogging stacklessLogging;\n     private Server server;\n     private DeploymentManager deploymentManager;\n-    private ContextHandlerCollection contexts;\n \n     public Path startServer(Consumer<Path> docrootSetupConsumer, Path docroots) throws Exception\n     {\n@@ -83,11 +82,10 @@ public Path startServer(Consumer<Path> docrootSetupConsumer, Path docroots) thro\n         ResourceFactory resourceFactory = ResourceFactory.of(server);\n \n         // Empty contexts collections\n-        contexts = new ContextHandlerCollection();\n+        ContextHandlerCollection contexts = new ContextHandlerCollection();\n \n         //Environment\n-        Environment ee9 = Environment.ensure(\""ee9\"");\n-        ee9.setAttribute(\""contextHandlerClass\"", \""org.eclipse.jetty.ee9.webapp.WebAppContext\"");\n+        ServletContextHandler.ENVIRONMENT.setAttribute(\""contextHandlerClass\"", \""org.eclipse.jetty.ee9.webapp.WebAppContext\"");\n         \n         // Deployment Manager\n         deploymentManager = new DeploymentManager();\n@@ -173,11 +171,11 @@ public void testInitialBadAppUnavailableFalse(WorkDir workDir) throws Exception\n     {\n         startServer(docroots -> copyBadApp(\""badapp-unavailable-false.xml\"", docroots), workDir.getEmptyPathDir());\n \n-        List<App> apps = new ArrayList<>();\n-        apps.addAll(deploymentManager.getApps());\n+        List<App> apps = new ArrayList<>(deploymentManager.getApps());\n         assertThat(\""Apps tracked\"", apps.size(), is(1));\n         String contextPath = \""/badapp-uaf\"";\n         App app = findApp(contextPath, apps);\n+        assert app != null;\n         ContextHandler coreContext = app.getContextHandler();\n         org.eclipse.jetty.ee9.nested.ContextHandler contextHandler = null;\n         if (coreContext instanceof org.eclipse.jetty.ee9.nested.ContextHandler.CoreContextHandler coreContextHandler)\n@@ -226,10 +224,10 @@ public void testDelayedAddBadAppUnavailableTrue(WorkDir workDir) throws Exceptio\n         // Wait for deployment manager to do its thing\n         assertThat(\""AppLifeCycle.FAILED event occurred\"", startTracking.failedLatch.await(3, TimeUnit.SECONDS), is(true));\n \n-        List<App> apps = new ArrayList<>();\n-        apps.addAll(deploymentManager.getApps());\n+        List<App> apps = new ArrayList<>(deploymentManager.getApps());\n         assertThat(\""Apps tracked\"", apps.size(), is(1));\n         App app = findApp(contextPath, apps);\n+        assert app != null;\n         ContextHandler coreContext = app.getContextHandler();\n         org.eclipse.jetty.ee9.nested.ContextHandler contextHandler = null;\n         if (coreContext instanceof org.eclipse.jetty.ee9.nested.ContextHandler.CoreContextHandler coreContextHandler)\n@@ -277,12 +275,12 @@ public void testDelayedAddBadAppUnavailableFalse(WorkDir workDir) throws Excepti\n         copyBadApp(\""badapp-unavailable-false.xml\"", docroots);\n \n         // Wait for deployment manager to do its thing\n-        startTracking.startedLatch.await(3, TimeUnit.SECONDS);\n+        assertTrue(startTracking.startedLatch.await(3, TimeUnit.SECONDS));\n \n-        List<App> apps = new ArrayList<>();\n-        apps.addAll(deploymentManager.getApps());\n+        List<App> apps = new ArrayList<>(deploymentManager.getApps());\n         assertThat(\""Apps tracked\"", apps.size(), is(1));\n         App app = findApp(contextPath, apps);\n+        assert app != null;\n         ContextHandler coreContext = app.getContextHandler();\n         org.eclipse.jetty.ee9.nested.ContextHandler contextHandler = null;\n         if (coreContext instanceof org.eclipse.jetty.ee9.nested.ContextHandler.CoreContextHandler coreContextHandler)\n@@ -313,17 +311,12 @@ public void testDelayedAddBadAppUnavailableFalse(WorkDir workDir) throws Excepti\n     private void assertHttpState(String contextPath, int expectedStatusCode) throws Exception\n     {\n         URI destURI = server.getURI().resolve(contextPath);\n-        HttpClient client = new HttpClient();\n-        try\n+        try (HttpClient client = new HttpClient())\n         {\n             client.start();\n             ContentResponse response = client.newRequest(destURI).method(HttpMethod.GET).send();\n             assertThat(\""GET Response: \"" + destURI, response.getStatus(), is(expectedStatusCode));\n         }\n-        finally\n-        {\n-            client.stop();\n-        }\n     }\n \n     private App findApp(String contextPath, List<App> apps)\n@@ -359,7 +352,7 @@ private void incrementCount(WebAppContext context, Map<String, Integer> contextC\n         }\n \n         @Override\n-        public void preConfigure(WebAppContext context) throws Exception\n+        public void preConfigure(WebAppContext context)\n         {\n             incrementCount(context, preConfigureCounts);\n         }\n@@ -371,7 +364,7 @@ public void configure(WebAppContext context) throws Exception\n         }\n \n         @Override\n-        public void postConfigure(WebAppContext context) throws Exception\n+        public void postConfigure(WebAppContext context)\n         {\n             incrementCount(context, postConfigureCounts);\n         }\n\ndiff --git a/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/resources/RFC2616Base.xml b/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/resources/RFC2616Base.xml\nindex ad292d8c06f3..77ebf37b3049 100644\n--- a/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/resources/RFC2616Base.xml\n+++ b/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/resources/RFC2616Base.xml\n@@ -76,10 +76,7 @@\n       </Arg>\n     </New>\n   </Set>\n-\n-  <Call id=\""Environment\"" class=\""org.eclipse.jetty.util.component.Environment\"" name=\""ensure\"">\n-    <Arg>ee9</Arg>\n-  </Call>\n+  <Get id=\""Environment\"" class=\""org.eclipse.jetty.ee9.nested.ContextHandler\"" name=\""ENVIRONMENT\""/>\n   <Ref refid=\""Environment\"">\n     <Call name=\""setAttribute\"">\n       <Arg>contextHandlerClass</Arg>\n\ndiff --git a/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/resources/deploy.xml b/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/resources/deploy.xml\nindex c9001de208fe..31a66d467bc2 100644\n--- a/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/resources/deploy.xml\n+++ b/jetty-ee9/jetty-ee9-tests/jetty-ee9-test-integration/src/test/resources/deploy.xml\n@@ -2,9 +2,8 @@\n <!DOCTYPE Configure PUBLIC \""-//Jetty//Configure//EN\"" \""https://jetty.org/configure_10_0.dtd\"">\n \n <Configure id=\""Server\"" class=\""org.eclipse.jetty.server.Server\"">\n-  <Call id=\""Environment\"" class=\""org.eclipse.jetty.util.component.Environment\"" name=\""ensure\"">\n-    <Arg>ee9</Arg>\n-  </Call>\n+\n+  <Get id=\""Environment\"" class=\""org.eclipse.jetty.ee9.nested.ContextHandler\"" name=\""ENVIRONMENT\""/>\n   <Ref refid=\""Environment\"">\n     <Call name=\""setAttribute\"">\n       <Arg>contextHandlerClass</Arg>\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-12827"", ""pr_id"": 12827, ""issue_id"": 12809, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Review `UriCompliance.LEGACY` and its omission of `SUSPICIOUS_PATH_CHARACTERS`\n**Jetty version(s)**\n12.0.16\n\n**Jetty Environment**\nAny\n\n**Java version/vendor**\nAny\n\n**OS type/version**\nAny\n\n**Description**\nThe current `UriCompliance.LEGACY` is missing behavior that is similar to the `SUSPICIOUS_PATH_CHARACTERS` (but not quite exactly that violation).\n\nTake for example, the following behavior on Jetty 11.0.24 ...\n\nConfigure a new jetty.base ...\n\n``` shell\n[bases]$ mkdir jetty-11-demos-legacy\n[bases]$ cd jetty-11-demos-legacy/\n\n[jetty-11-demos-legacy]$ java -jar ../../jetty-home-11.0.24/start.jar --add-modules=server,http,deploy,demo\nINFO  : mkdir ${jetty.base}/start.d\nINFO  : webapp          transitively enabled, ini template available with --add-module=webapp\n...(snip)...\nINFO  : copy ${jetty.home}/modules/demo.d/root/images/webtide_logo.jpg to ${jetty.base}/webapps/root/images/webtide_logo.jpg\nINFO  : Base directory was modified\n\n[jetty-11-demos-legacy]$ gvim start.d/server.ini \n[jetty-11-demos-legacy]$ grep uriCompliance start.d/server.ini \njetty.httpConfig.uriCompliance=LEGACY\n```\n\nRun that jetty.base ...\n\n``` shell\n[jetty-11-demos-legacy]$ java -jar ../../jetty-home-11.0.24/start.jar \n2025-02-20 11:03:22.427:WARN :oe.jetty:main: demo-realm is deployed. DO NOT USE IN PRODUCTION!\n2025-02-20 11:03:22.647:WARN :oejk.KeystoreGenerator:main: Generating Test Keystore: DO NOT USE IN PRODUCTION!\n2025-02-20 11:03:23.162:INFO :oejs.Server:main: jetty-11.0.24; built: 2024-08-26T18:11:22.448Z; git: 5dfc59a691b748796f922208956bd1f2794bcd16; jvm 17.0.11+9\n...(snip)...\n2025-02-20 11:03:25.193:INFO :oejs.AbstractConnector:main: Started ServerConnector@4defd42{HTTP/1.1, (http/1.1)}{0.0.0.0:8080}\n2025-02-20 11:03:25.201:INFO :oejs.Server:main: Started Server@79351f41{STARTING}[11.0.24,sto=5000] @3524ms\n```\n\nIn a different console test a few suspicious character scenarios.\n\n```\n$ curl --no-progress-meter http://localhost:8080/test/dump/info | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<th align=\""right\"">getRequestURI:&nbsp;</th><td>/test/dump/info</td></tr><tr>\n\n$ curl --no-progress-meter http://localhost:8080//test/dump/info | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<body><h2>HTTP ERROR 404 Not Found</h2>\n\n$ curl --no-progress-meter http://localhost:8080///test/dump/info | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<body><h2>HTTP ERROR 404 Not Found</h2>\n\n$ curl --no-progress-meter http://localhost:8080/test/dump/in%5Cfo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<th align=\""right\"">getRequestURI:&nbsp;</th><td>/test/dump/in%5Cfo</td></tr><tr>\n\n$ curl --no-progress-meter http://localhost:8080/test/dump/in%0Afo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<th align=\""right\"">getRequestURI:&nbsp;</th><td>/test/dump/in%0Afo</td></tr><tr>\n\n$ curl --no-progress-meter http://localhost:8080/test/dump/in%00fo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<h1>Bad Message 400</h1><pre>reason: Bad Request</pre>\n\n$ curl --no-progress-meter http://localhost:8080/test/dump/in%01fo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<th align=\""right\"">getRequestURI:&nbsp;</th><td>/test/dump/in%01fo</td></tr><tr>\n\n$ curl --no-progress-meter http://localhost:8080/test/dump/in%5Ffo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<th align=\""right\"">getRequestURI:&nbsp;</th><td>/test/dump/in_fo</td></tr><tr>\n\n$ curl --no-progress-meter http://localhost:8080/test/dump/in%2Ffo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<th align=\""right\"">getRequestURI:&nbsp;</th><td>/test/dump/in/fo</td></tr><tr>\n\n$ curl --no-progress-meter http://localhost:8080/test/dump/in%5C2Ffo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<th align=\""right\"">getRequestURI:&nbsp;</th><td>/test/dump/in%5C2Ffo</td></tr><tr>\n```\n\nNow lets do the same thing on Jetty 12.0.16\n\nSetup and Run ...\n\n``` shell\n[bases]$ mkdir jetty-12-demos-legacy\n[bases]$ cd jetty-12-demos-legacy/\n[jetty-12-demos-legacy]$ java -jar ../../jetty-home-12.0.16/start.jar --add-modules=server,http,ee10-deploy,ee10-demos\nINFO  : mkdir ${jetty.base}/start.d\nINFO  : alpn-java       transitively enabled\n...(snip)...\nINFO  : copy ${jetty.home}/modules/demo.d/demo-login.properties to ${jetty.base}/etc/demo-login.properties\nINFO  : Base directory was modified\n\n[jetty-12-demos-legacy]$ gvim start.d/server.ini \n[jetty-12-demos-legacy]$ grep uriCompliance start.d/server.ini \njetty.httpConfig.uriCompliance=LEGACY\n\n[jetty-12-demos-legacy]$ java -jar ../../jetty-home-12.0.16/start.jar\n2025-02-20 11:58:42.995:WARN :oejk.KeystoreGenerator:main: Generating Test Keystore: DO NOT USE IN PRODUCTION!\n2025-02-20 11:58:43.470:WARN :oejx.XmlConfiguration:main: Deprecated method public void org.eclipse.jetty.security.HashLoginService.setHotReload(boolean) in file:///home/joakim/code/jetty/distros/bases/jetty-12-demos-legacy/etc/jetty-demo-realm.xml\n2025-02-20 11:58:43.473:WARN :oe.jetty:main: demo-realm is deployed. DO NOT USE IN PRODUCTION!\n2025-02-20 11:58:43.551:INFO :oejs.Server:main: jetty-12.0.16; built: 2024-12-09T21:02:54.535Z; git: c3f88bafb4e393f23204dc14dc57b042e84debc7; jvm 17.0.11+9\n...(snip)...\n2025-02-20 11:58:46.286:INFO :oejs.AbstractConnector:main: Started ServerConnector@4d21c56e{HTTP/1.1, (http/1.1)}{0.0.0.0:8080}\n2025-02-20 11:58:46.292:INFO :oejs.Server:main: Started oejs.Server@3e821657{STARTING}[12.0.16,sto=0] @4401ms\n```\n\nDo some initial testing ...\n\n``` shell\n[~]$ curl --no-progress-meter http://localhost:8080/ee10-test/dump/info | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<th align=\""right\"">getRequestURI:&nbsp;</th><td>/ee10-test/dump/info</td></tr><tr>\n\n[~]$ curl --no-progress-meter http://localhost:8080/ee10-test/dump/in%5Cfo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<h2>HTTP ERROR 400 Suspicious Path Character</h2>\n```\n\nThe suspicious path characters are being rejected due to existing LEGACY behavior.\nSo lets add it via configuration.\n\n``` shell\n[jetty-12-demos-legacy]$ gvim start.d/server.ini \n[jetty-12-demos-legacy]$ grep uriCompliance start.d/server.ini \njetty.httpConfig.uriCompliance=LEGACY,SUSPICIOUS_PATH_CHARACTERS\n\n[jetty-12-demos-legacy]$ java -jar ../../jetty-home-12.0.16/start.jar\n```\n\nIt is now allowing suspicious path characters, but rejecting the other violations???\n\n``` shell\n[~]$ curl --no-progress-meter http://localhost:8080/ee10-test/dump/info | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<th align=\""right\"">getRequestURI:&nbsp;</th><td>/ee10-test/dump/info</td></tr><tr>\n\n[~]$ curl --no-progress-meter http://localhost:8080/ee10-test/dump/in%5Cfo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<th align=\""right\"">getRequestURI:&nbsp;</th><td>/ee10-test/dump/in%5Cfo</td></tr><tr>\n\n[~]$ curl --no-progress-meter http://localhost:8080/ee10-test/dump/in%5Ffo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<th align=\""right\"">getRequestURI:&nbsp;</th><td>/ee10-test/dump/in%5Ffo</td></tr><tr>\n\n[~]$ curl --no-progress-meter http://localhost:8080/ee10-test/dump/in%2Ffo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<body><h2>HTTP ERROR 400 Ambiguous URI encoding: AMBIGUOUS_PATH_SEPARATOR</h2>\n\n[~]$ curl --no-progress-meter http://localhost:8080/ee10-test/dump/in%252Ffo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<body><h2>HTTP ERROR 400 Ambiguous URI encoding: AMBIGUOUS_PATH_ENCODING</h2>\n\n[~]$ curl --no-progress-meter http://localhost:8080/ee10-test/dump/in%25fo | grep -E \""(Bad Message|ERROR|getRequestURI)\""\n<body><h2>HTTP ERROR 400 Ambiguous URI encoding: AMBIGUOUS_PATH_ENCODING</h2>\n```\n\nSo we have a few things to look into.\n\n1. do we want to add `SUSPICIOUS_PATH_CHARACTERS` to `LEGACY` (even though it doesn't decode like Jetty 9/10/11)\n2. do we want to add a new `SUSPICIOUS_PATH_CHARACTERS_WITH_AUTODECODE` (or some similar name) to have the behavior be the same as Jetty 9/10/11 ?\n3. why is the `jetty.httpConfig.uriCompliance=LEGACY,SUSPICIOUS_PATH_CHARACTERS` resetting the other prior LEGACY violations?"", ""issue_word_count"": 1244, ""test_files_count"": 5, ""non_test_files_count"": 5, ""pr_changed_files"": [""jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java"", ""jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Request.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/HttpConnectionTest.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/Utf8StringBuilder.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlEncodedUtf8Test.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/RequestTest.java"", ""jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java"", ""jetty-ee9/jetty-ee9-nested/src/test/java/org/eclipse/jetty/ee9/nested/RequestTest.java""], ""pr_changed_test_files"": [""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/HttpConnectionTest.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlEncodedUtf8Test.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/RequestTest.java"", ""jetty-ee9/jetty-ee9-nested/src/test/java/org/eclipse/jetty/ee9/nested/RequestTest.java""], ""base_commit"": ""6986b18ecb2d6d4ed7288cd92d9a0c1eb8a29d28"", ""head_commit"": ""4b88eaad9be7c3a5a46c2182985885d978fafa54"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/12827"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/12827"", ""dockerfile"": """", ""pr_merged_at"": ""2025-02-28T17:10:20.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java\nindex 708ea1c5db64..c31addf18f5b 100644\n--- a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java\n+++ b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java\n@@ -96,15 +96,20 @@ public enum Violation implements ComplianceViolation\n         UTF16_ENCODINGS(\""https://www.w3.org/International/iri-edit/draft-duerst-iri.html#anchor29\"", \""UTF-16 encoding\""),\n \n         /**\n-         * Allow Bad UTF-8 encodings to be substituted by the replacement character.\n+         * Allow Bad UTF-8 encodings to be substituted by the replacement character in query strings\n          */\n         BAD_UTF8_ENCODING(\""https://datatracker.ietf.org/doc/html/rfc5987#section-3.2.1\"", \""Bad UTF-8 encoding\""),\n \n         /**\n-         * Allow truncated UTF-8 encodings to be substituted by the replacement character.\n+         * Allow Truncated UTF-8 encodings to be substituted by the replacement character in query strings\n          */\n         TRUNCATED_UTF8_ENCODING(\""https://datatracker.ietf.org/doc/html/rfc5987#section-3.2.1\"", \""Truncated UTF-8 encoding\""),\n \n+        /**\n+         * Allow bad percent encodings such as %xx or %% in query strings\n+         */\n+        BAD_PERCENT_ENCODING(\""https://datatracker.ietf.org/doc/html/rfc5987#section-3.2.1\"", \""Bad percent encoding\""),\n+\n         /**\n          * Allow encoded path characters not allowed by the Servlet spec rules.\n          */\n@@ -192,13 +197,42 @@ public String getDescription()\n     public static final UriCompliance DEFAULT = new UriCompliance(\""DEFAULT\"", RFC3986.getAllowed());\n \n     /**\n-     * LEGACY compliance mode that models pre Jetty 12 behavior by allowing:\n+     * JETTY_11 compliance mode that models Jetty 11 DEFAULT behavior by allowing:\n+     * <ul>\n+     *     <li>{@link Violation#AMBIGUOUS_PATH_SEGMENT}</li>\n+     *     <li>{@link Violation#AMBIGUOUS_PATH_SEPARATOR}</li>\n+     *     <li>{@link Violation#AMBIGUOUS_PATH_ENCODING}</li>\n+     *     <li>{@link Violation#SUSPICIOUS_PATH_CHARACTERS}</li>\n+     *     <li>{@link Violation#TRUNCATED_UTF8_ENCODING}</li>\n+     *     <li>{@link Violation#UTF16_ENCODINGS}</li>\n+     *     <li>{@link Violation#USER_INFO}</li>\n+     * </ul>\n+     * <p>\n+     *     Note: this mode allows URL/URIs that the Servlet spec will reject.\n+     *     <br>\n+     *     See <a href=\""https://github.com/jakartaee/servlet/blob/6.0.0-RELEASE/spec/src/main/asciidoc/servlet-spec-body.adoc#352-uri-path-canonicalization\"">point 10 \""Rejecting Suspicious Sequences\"" in Section 3.5.2. URI Path Canonicalization</a>,\n+     *     <br>\n+     *     and <a href=\""https://jetty.org/docs/jetty/12/programming-guide/server/compliance.html#servleturi\"">Jetty Documentation: Servlet URI Compliance Modes.</a>\n+     * </p>\n+     */\n+    public static final UriCompliance JETTY_11 = new UriCompliance(\""JETTY_11\"",\n+        of(Violation.AMBIGUOUS_PATH_SEGMENT,\n+            Violation.AMBIGUOUS_PATH_SEPARATOR,\n+            Violation.AMBIGUOUS_PATH_ENCODING,\n+            Violation.SUSPICIOUS_PATH_CHARACTERS,\n+            Violation.TRUNCATED_UTF8_ENCODING,\n+            Violation.UTF16_ENCODINGS,\n+            Violation.USER_INFO));\n+\n+    /**\n+     * LEGACY compliance mode that models pre Jetty 12 LEGACY behaviors by allowing:\n      * <ul>\n      *     <li>{@link Violation#AMBIGUOUS_PATH_SEGMENT}</li>\n      *     <li>{@link Violation#AMBIGUOUS_PATH_SEPARATOR}</li>\n      *     <li>{@link Violation#AMBIGUOUS_PATH_ENCODING}</li>\n      *     <li>{@link Violation#AMBIGUOUS_EMPTY_SEGMENT}</li>\n-     *     <li>{@link Violation#BAD_UTF8_ENCODING}</li>\n+     *     <li>{@link Violation#SUSPICIOUS_PATH_CHARACTERS}</li>\n+     *     <li>{@link Violation#TRUNCATED_UTF8_ENCODING}</li>\n      *     <li>{@link Violation#UTF16_ENCODINGS}</li>\n      *     <li>{@link Violation#USER_INFO}</li>\n      * </ul>\n@@ -215,6 +249,7 @@ public String getDescription()\n             Violation.AMBIGUOUS_PATH_SEPARATOR,\n             Violation.AMBIGUOUS_PATH_ENCODING,\n             Violation.AMBIGUOUS_EMPTY_SEGMENT,\n+            Violation.SUSPICIOUS_PATH_CHARACTERS,\n             Violation.TRUNCATED_UTF8_ENCODING,\n             Violation.UTF16_ENCODINGS,\n             Violation.USER_INFO));\n@@ -232,7 +267,7 @@ public String getDescription()\n     public static final UriCompliance UNSAFE = new UriCompliance(\""UNSAFE\"", allOf(Violation.class));\n \n     private static final AtomicInteger __custom = new AtomicInteger();\n-    private static final List<UriCompliance> KNOWN_MODES = List.of(DEFAULT, LEGACY, RFC3986, UNAMBIGUOUS, UNSAFE);\n+    private static final List<UriCompliance> KNOWN_MODES = List.of(DEFAULT, JETTY_11, LEGACY, RFC3986, UNAMBIGUOUS, UNSAFE);\n \n     public static boolean isAmbiguous(Set<Violation> violations)\n     {\n\ndiff --git a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Request.java b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Request.java\nindex d67e998f451d..e203c33e6064 100644\n--- a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Request.java\n+++ b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/Request.java\n@@ -571,9 +571,10 @@ static Fields extractQueryParameters(Request request, Charset charset)\n             if (charset == null || StandardCharsets.UTF_8.equals(charset))\n             {\n                 uriCompliance = request.getConnectionMetaData().getHttpConfiguration().getUriCompliance();\n-                boolean allowTruncatedUtf8 = uriCompliance.allows(UriCompliance.Violation.TRUNCATED_UTF8_ENCODING);\n+                boolean allowBadPercent = uriCompliance.allows(UriCompliance.Violation.BAD_PERCENT_ENCODING);\n                 boolean allowBadUtf8 = uriCompliance.allows(UriCompliance.Violation.BAD_UTF8_ENCODING);\n-                if (!UrlEncoded.decodeUtf8To(query, 0, query.length(), fields::add, allowTruncatedUtf8, allowBadUtf8))\n+                boolean allowTruncatedUtf8 = uriCompliance.allows(UriCompliance.Violation.TRUNCATED_UTF8_ENCODING);\n+                if (!UrlEncoded.decodeUtf8To(query, 0, query.length(), fields::add, allowBadPercent, allowBadUtf8, allowTruncatedUtf8))\n                 {\n                     HttpChannel httpChannel = HttpChannel.from(request);\n                     if (httpChannel != null && httpChannel.getComplianceViolationListener() != null)\n@@ -588,8 +589,6 @@ static Fields extractQueryParameters(Request request, Charset charset)\n         }\n         catch (Throwable t)\n         {\n-//            if (uriCompliance == UriCompliance.LEGACY)\n-//                throw t;\n             throw new BadMessageException(\""Bad query\"", t);\n         }\n     }\n\ndiff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java\nindex 57a99baf42a7..a1aaf921f7aa 100644\n--- a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java\n@@ -348,7 +348,7 @@ public static void decodeUtf8To(String uri, int offset, int length, Fields field\n     public static boolean decodeUtf8To(String query, int offset, int length, BiConsumer<String, String> adder)\n         throws Utf8StringBuilder.Utf8IllegalArgumentException\n     {\n-        return decodeUtf8To(query, offset, length, adder, false, false);\n+        return decodeUtf8To(query, offset, length, adder, false, false, false);\n     }\n \n     /**\n@@ -358,12 +358,12 @@ public static boolean decodeUtf8To(String query, int offset, int length, BiConsu\n      * @param offset the offset at which query parameters start.\n      * @param length the length of query parameters string to parse.\n      * @param adder the method to call to add decoded parameters.\n-     * @param allowTruncatedUtf8 if {@code true} allow truncated UTF-8 and insert the replacement character.\n+     * @param allowBadPercent if {@code true} allow bad percent encoding.\n      * @param allowBadUtf8 if {@code true} allow bad UTF-8 and insert the replacement character.\n      * @return {@code true} if the string was decoded without any bad UTF-8\n      * @throws org.eclipse.jetty.util.Utf8StringBuilder.Utf8IllegalArgumentException if there is illegal UTF-8 and `allowsBadUtf8` is {@code false}\n      */\n-    public static boolean decodeUtf8To(String query, int offset, int length, BiConsumer<String, String> adder, boolean allowTruncatedUtf8, boolean allowBadUtf8)\n+    public static boolean decodeUtf8To(String query, int offset, int length, BiConsumer<String, String> adder, boolean allowBadPercent, boolean allowBadUtf8, boolean allowTruncatedUtf8)\n         throws Utf8StringBuilder.Utf8IllegalArgumentException\n     {\n         Utf8StringBuilder buffer = new Utf8StringBuilder();\n@@ -395,7 +395,7 @@ public static boolean decodeUtf8To(String query, int offset, int length, BiConsu\n             switch (c)\n             {\n                 case '&':\n-                    value = take(allowTruncatedUtf8, buffer, badUtf8, onCodingError);\n+                    value = take(allowBadUtf8, allowTruncatedUtf8, buffer, badUtf8, onCodingError);\n \n                     if (key != null)\n                     {\n@@ -415,7 +415,7 @@ else if (value != null && !value.isEmpty())\n                         break;\n                     }\n \n-                    key = take(allowTruncatedUtf8, buffer, badUtf8, onCodingError);\n+                    key = take(allowBadUtf8, allowTruncatedUtf8, buffer, badUtf8, onCodingError);\n                     break;\n \n                 case '+':\n@@ -433,34 +433,46 @@ else if (value != null && !value.isEmpty())\n                         }\n                         catch (NumberFormatException e)\n                         {\n-                            if (!allowBadUtf8)\n+                            boolean replaced = buffer.replaceIncomplete();\n+                            if (replaced && !allowBadUtf8 || !allowBadPercent)\n                                 throw e;\n \n-                            if (!buffer.replaceIncomplete())\n-                                buffer.append(Utf8StringBuilder.REPLACEMENT);\n-\n-                            if (key == null)\n+                            if (hi == '&' || key == null && hi == '=')\n+                            {\n+                                if (!replaced)\n+                                    buffer.append('%');\n+                                i = i - 2;\n+                            }\n+                            else if (lo == '&' || key == null && lo == '=')\n                             {\n-                                if (query.charAt(i - 1) == '=')\n-                                    i = i - 2;\n-                                else if (query.charAt(i) == '=')\n-                                    i = i - 1;\n+                                if (!replaced)\n+                                {\n+                                    buffer.append('%');\n+                                    buffer.append(hi);\n+                                }\n+                                i = i - 1;\n                             }\n                             else\n                             {\n-                                if (query.charAt(i - 1) == '&')\n-                                    i = i - 2;\n-                                else if (query.charAt(i) == '&')\n-                                    i = i - 1;\n+                                if (!replaced)\n+                                {\n+                                    buffer.append('%');\n+                                    buffer.append(hi);\n+                                    buffer.append(lo);\n+                                }\n                             }\n                         }\n                     }\n-                    else if (allowBadUtf8)\n+                    else if (buffer.replaceIncomplete())\n                     {\n-                        if (!buffer.replaceIncomplete())\n-                            buffer.append(Utf8StringBuilder.REPLACEMENT);\n+                        if (!allowBadUtf8 || !allowBadPercent)\n+                            throw new Utf8StringBuilder.Utf8IllegalArgumentException();\n                         i = end;\n                     }\n+                    else if (allowBadPercent)\n+                    {\n+                        buffer.append('%');\n+                    }\n                     else\n                     {\n                         throw new Utf8StringBuilder.Utf8IllegalArgumentException();\n@@ -475,26 +487,28 @@ else if (allowBadUtf8)\n \n         if (key != null)\n         {\n-            value = take(allowTruncatedUtf8, buffer, badUtf8, onCodingError);\n+            value = take(allowBadUtf8, allowTruncatedUtf8, buffer, badUtf8, onCodingError);\n             adder.accept(key, value);\n         }\n         else if (buffer.length() > 0)\n         {\n-            key = take(allowTruncatedUtf8, buffer, badUtf8, onCodingError);\n+            key = take(allowBadUtf8, allowTruncatedUtf8, buffer, badUtf8, onCodingError);\n             adder.accept(key, \""\"");\n         }\n \n         return badUtf8 == null || !badUtf8.get();\n     }\n \n-    private static <X extends Throwable> String take(boolean allowTrauncatedUtf8, Utf8StringBuilder buffer, AtomicBoolean badUtf8, Supplier<X> onCodingError) throws X\n+    private static <X extends Throwable> String take(boolean allowBadUtf8, Boolean allowTruncatedUtf8, Utf8StringBuilder buffer, AtomicBoolean badUtf8, Supplier<X> onCodingError) throws X\n     {\n-        if (!allowTrauncatedUtf8)\n+        if (!allowBadUtf8 && !allowTruncatedUtf8)\n             return buffer.takeCompleteString(onCodingError);\n \n         boolean codingError = buffer.hasCodingErrors();\n-        buffer.complete();\n-        if (codingError || !buffer.hasCodingErrors())\n+        if (codingError && !allowBadUtf8)\n+            return buffer.takeCompleteString(onCodingError);\n+\n+        if (buffer.replaceIncomplete() && !allowTruncatedUtf8)\n             return buffer.takeCompleteString(onCodingError);\n \n         String result = buffer.takeCompleteString(null);\n\ndiff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/Utf8StringBuilder.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/Utf8StringBuilder.java\nindex d97f04fbf449..6be07aeae501 100644\n--- a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/Utf8StringBuilder.java\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/Utf8StringBuilder.java\n@@ -145,6 +145,8 @@ public boolean replaceIncomplete()\n \n         bufferAppend(REPLACEMENT);\n         _state = UTF8_ACCEPT;\n+        _codep = 0;\n+        _codingErrors = true;\n         return true;\n     }\n \n\ndiff --git a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java\nindex ce7411f98ba6..5ce1512911a1 100644\n--- a/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java\n+++ b/jetty-ee9/jetty-ee9-nested/src/main/java/org/eclipse/jetty/ee9/nested/Request.java\n@@ -426,9 +426,10 @@ private void extractQueryParameters()\n                 if (StandardCharsets.UTF_8.equals(_queryEncoding) || _queryEncoding == null && UrlEncoded.ENCODING.equals(StandardCharsets.UTF_8))\n                 {\n                     UriCompliance uriCompliance = getHttpChannel().getHttpConfiguration().getUriCompliance();\n-                    boolean allowTruncatedUtf8 = uriCompliance.allows(UriCompliance.Violation.TRUNCATED_UTF8_ENCODING);\n+                    boolean allowBadPercent = uriCompliance.allows(UriCompliance.Violation.BAD_PERCENT_ENCODING);\n                     boolean allowBadUtf8 = uriCompliance.allows(UriCompliance.Violation.BAD_UTF8_ENCODING);\n-                    if (!UrlEncoded.decodeUtf8To(query, 0, query.length(), _queryParameters::add, allowTruncatedUtf8, allowBadUtf8))\n+                    boolean allowTruncatedUtf8 = uriCompliance.allows(UriCompliance.Violation.TRUNCATED_UTF8_ENCODING);\n+                    if (!UrlEncoded.decodeUtf8To(query, 0, query.length(), _queryParameters::add, allowBadPercent, allowBadUtf8, allowTruncatedUtf8))\n                     {\n                         ComplianceViolation.Listener complianceViolationListener = getComplianceViolationListener();\n                         if (complianceViolationListener != null)\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/HttpConnectionTest.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/HttpConnectionTest.java\nindex d39a62e12391..50e5b2e149be 100644\n--- a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/HttpConnectionTest.java\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/HttpConnectionTest.java\n@@ -1560,6 +1560,8 @@ public void testAmbiguousDoubleSlash() throws Exception\n             \""\""\"";\n         _connector.getBean(HttpConnectionFactory.class).getHttpConfiguration().setUriCompliance(UriCompliance.DEFAULT);\n         assertThat(_connector.getResponse(request), startsWith(\""HTTP/1.1 400\""));\n+        _connector.getBean(HttpConnectionFactory.class).getHttpConfiguration().setUriCompliance(UriCompliance.JETTY_11);\n+        assertThat(_connector.getResponse(request), startsWith(\""HTTP/1.1 400\""));\n         _connector.getBean(HttpConnectionFactory.class).getHttpConfiguration().setUriCompliance(UriCompliance.LEGACY);\n         assertThat(_connector.getResponse(request), startsWith(\""HTTP/1.1 200\""));\n         _connector.getBean(HttpConnectionFactory.class).getHttpConfiguration().setUriCompliance(UriCompliance.RFC3986);\n\ndiff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java\nindex 6c180692fa57..822fa4d20cfd 100644\n--- a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/RequestTest.java\n@@ -48,6 +48,7 @@\n import static org.hamcrest.Matchers.greaterThan;\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.Matchers.startsWith;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -632,10 +633,10 @@ public static Stream<Arguments> queryBehaviorsLegacy()\n         cases.add(Arguments.of(\""other=foo&%E5%B8%BD%E5%AD%90=Beret\"", 200, \""\u5e3d\u5b50\"", \""Beret\""));\n \n         // truncated pct-encoded parameter names\n-        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%9=Beret\"", 400, \""\ufffd\"", \""\"")); // different from 11\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%9=Beret\"", 400, \""\"", \""\"")); // Not LEGACY\n         cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%=Beret\"", 400, \""\u5e3d\u5b50\"", \""\""));\n         cases.add(Arguments.of(\""%E5%B8%BD%E5%AD=Beret\"", 200, \""\u5e3d\ufffd\"", \""Beret\""));\n-        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%9=Beret&other=foo\"", 400, \""\"", \""\"")); // different from 11\n+        cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%9=Beret&other=foo\"", 400, \""\u5e3d\u5b5dBeret\"", \""\"")); // Not LEGACY\n         cases.add(Arguments.of(\""%E5%B8%BD%E5%AD%=Beret&other=foo\"", 400, \""\u5e3d\u5b50\"", \""\""));\n         cases.add(Arguments.of(\""%E5%B8%BD%E5%AD=Beret&other=foo\"", 200, \""\u5e3d\ufffd\"", \""Beret\""));\n \n@@ -797,12 +798,12 @@ public static Stream<Arguments> queryBehaviorsBadUtf8Allowed()\n         cases.add(Arguments.of(\""param=%E2&other=foo\"", 200, \""param\"", \""\ufffd\""));\n \n         // Tokenized cases\n-        cases.add(Arguments.of(\""param=%%TOK%%\"", 200, \""param\"", \""\ufffdOK\ufffd\""));\n-        cases.add(Arguments.of(\""param=%%TOK%%&other=foo\"", 200, \""param\"", \""\ufffdOK\ufffd\""));\n+        cases.add(Arguments.of(\""param=%%TOK%%\"", 200, \""param\"", \""%%TOK%%\""));\n+        cases.add(Arguments.of(\""param=%%TOK%%&other=foo\"", 200, \""param\"", \""%%TOK%%\""));\n \n         // Bad Hex\n-        cases.add(Arguments.of(\""param=%xx\"", 200, \""param\"", \""\ufffd\""));\n-        cases.add(Arguments.of(\""param=%xx&other=foo\"", 200, \""param\"", \""\ufffd\""));\n+        cases.add(Arguments.of(\""param=%xx\"", 200, \""param\"", \""%xx\""));\n+        cases.add(Arguments.of(\""param=%xx&other=foo\"", 200, \""param\"", \""%xx\""));\n \n         // Overlong UTF-8 Encoding\n         cases.add(Arguments.of(\""param=%C0%AF\"", 200, \""param\"", \""\ufffd\ufffd\""));\n@@ -835,8 +836,10 @@ public static Stream<Arguments> queryBehaviorsBadUtf8Allowed()\n         // Community Examples\n         cases.add(Arguments.of(\""param=f_%e0%b8\"", 200, \""param\"", \""f_\ufffd\""));\n         cases.add(Arguments.of(\""param=f_%e0%b8&other=foo\"", 200, \""param\"", \""f_\ufffd\""));\n-        cases.add(Arguments.of(\""param=%\u00a3\"", 200, \""param\"", \""\ufffd\""));\n-        cases.add(Arguments.of(\""param=%\u00a3&other=foo\"", 200, \""param\"", \""\ufffd\""));\n+        cases.add(Arguments.of(\""param=%x\"", 200, \""param\"", \""%x\""));\n+        cases.add(Arguments.of(\""param=%\u00a3\"", 200, \""param\"", \""%\ufffd\""));\n+        cases.add(Arguments.of(\""param=%x&other=foo\"", 200, \""param\"", \""%x\""));\n+        cases.add(Arguments.of(\""param=%\u00a3&other=foo\"", 200, \""param\"", \""%\ufffd\""));\n \n         // Extra ampersands\n         cases.add(Arguments.of(\""param=aaa&&&\"", 200, \""param\"", \""aaa\""));\n@@ -868,8 +871,7 @@ public static Stream<Arguments> queryBehaviorsBadUtf8Allowed()\n     @MethodSource(\""queryBehaviorsBadUtf8Allowed\"")\n     public void testQueryExtractionBehaviorBadUtf8Allowed(String inputQuery, int expectedStatus, String expectedKey, String expectedValue) throws Exception\n     {\n-        UriCompliance uriCompliance = UriCompliance.DEFAULT.with(\""test\"",\n-            UriCompliance.Violation.BAD_UTF8_ENCODING, UriCompliance.Violation.TRUNCATED_UTF8_ENCODING);\n+        UriCompliance uriCompliance = UriCompliance.DEFAULT.with(\""test\"", UriCompliance.Violation.BAD_UTF8_ENCODING, UriCompliance.Violation.BAD_PERCENT_ENCODING);\n         testQueryExtractionBehavior(uriCompliance, inputQuery, expectedStatus, expectedKey, expectedValue);\n     }\n \n@@ -883,41 +885,39 @@ private void testQueryExtractionBehavior(UriCompliance uriCompliance, String inp\n             @Override\n             public boolean handle(Request request, Response response, Callback callback)\n             {\n-                switch (expectedStatus)\n+                if (expectedStatus == 200)\n                 {\n-                    case 200:\n+                    try\n                     {\n-                        try\n+                        Fields fields = Request.extractQueryParameters(request);\n+                        Fields.Field field = fields.get(expectedKey);\n+                        assertNotNull(field);\n+                        String value = field.getValue();\n+\n+                        if (expectedValue == null)\n                         {\n-                            Fields fields = Request.extractQueryParameters(request);\n-                            Fields.Field field = fields.get(expectedKey);\n-                            assertNotNull(field);\n-                            String value = field.getValue();\n-\n-                            if (expectedValue == null)\n-                            {\n-                                assertThat(field.getValue(), is(\""\""));\n-                            }\n-                            else\n-                            {\n-                                assertThat(value, is(expectedValue));\n-                            }\n-                            response.setStatus(200);\n-                            callback.succeeded();\n-                            return true;\n+                            assertThat(field.getValue(), is(\""\""));\n                         }\n-                        catch (Throwable t)\n+                        else\n                         {\n-                            callback.failed(t);\n-                            return true;\n+                            assertThat(value, is(expectedValue));\n                         }\n+                        response.setStatus(200);\n+                        callback.succeeded();\n+                        return true;\n                     }\n-                    default:\n+                    catch (Throwable t)\n                     {\n-                        RuntimeException e = assertThrows(RuntimeException.class, () -> Request.extractQueryParameters(request));\n-                        callback.failed(e);\n+                        callback.failed(t);\n+                        return true;\n                     }\n                 }\n+                else\n+                {\n+                    System.err.println(Request.extractQueryParameters(request));\n+                    RuntimeException e = assertThrows(RuntimeException.class, () -> Request.extractQueryParameters(request));\n+                    callback.failed(e);\n+                }\n                 return true;\n             }\n         });\n@@ -934,4 +934,74 @@ public boolean handle(Request request, Response response, Callback callback)\n         HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n         assertThat(response.getStatus(), is(expectedStatus));\n     }\n+\n+    static Stream<Arguments> suspiciousCharactersLegacy()\n+    {\n+        return Stream.of(\n+            Arguments.of(\""o\"", \""o\"", \""o\"", UriCompliance.DEFAULT),\n+            Arguments.of(\""%5C\"", \""400\"", \""400\"", UriCompliance.DEFAULT),\n+            Arguments.of(\""%0A\"", \""400\"", \""400\"", UriCompliance.DEFAULT),\n+            Arguments.of(\""%00\"", \""400\"", \""400\"", UriCompliance.DEFAULT),\n+            Arguments.of(\""%01\"", \""400\"", \""400\"", UriCompliance.DEFAULT),\n+            Arguments.of(\""%5F\"", \""_\"", \""_\"", UriCompliance.DEFAULT),\n+            Arguments.of(\""%2F\"", \""400\"", \""400\"", UriCompliance.DEFAULT),\n+            Arguments.of(\""%252F\"", \""400\"", \""400\"", UriCompliance.DEFAULT),\n+            Arguments.of(\""//\"", \""400\"", \""400\"", UriCompliance.DEFAULT),\n+\n+            // these results are from jetty-11 DEFAULT\n+            Arguments.of(\""o\"", \""o\"", \""o\"", UriCompliance.JETTY_11),\n+            Arguments.of(\""%5C\"", \""%5C\"", \""\\\\\"", UriCompliance.JETTY_11),\n+            Arguments.of(\""%0A\"", \""%0A\"", \""\\n\"", UriCompliance.JETTY_11),\n+            Arguments.of(\""%00\"", \""400\"", \""400\"", UriCompliance.JETTY_11),\n+            Arguments.of(\""%01\"", \""%01\"", \""\\u0001\"", UriCompliance.JETTY_11),\n+            Arguments.of(\""%5F\"", \""_\"", \""_\"", UriCompliance.JETTY_11),\n+            Arguments.of(\""%2F\"", \""%2F\"", \""/\"", UriCompliance.JETTY_11),\n+            Arguments.of(\""%252F\"", \""%252F\"", \""%2F\"", UriCompliance.JETTY_11),\n+            Arguments.of(\""//\"", \""400\"", \""400\"", UriCompliance.JETTY_11),\n+\n+            // these results are from jetty-11 LEGACY\n+            Arguments.of(\""o\"", \""o\"", \""o\"", UriCompliance.LEGACY),\n+            Arguments.of(\""%5C\"", \""%5C\"", \""\\\\\"", UriCompliance.LEGACY),\n+            Arguments.of(\""%0A\"", \""%0A\"", \""\\n\"", UriCompliance.LEGACY),\n+            Arguments.of(\""%00\"", \""400\"", \""400\"", UriCompliance.LEGACY),\n+            Arguments.of(\""%01\"", \""%01\"", \""\\u0001\"", UriCompliance.LEGACY),\n+            Arguments.of(\""%5F\"", \""_\"", \""_\"", UriCompliance.LEGACY),\n+            Arguments.of(\""%2F\"", \""%2F\"", \""/\"", UriCompliance.LEGACY),\n+            Arguments.of(\""%252F\"", \""%252F\"", \""%2F\"", UriCompliance.LEGACY),\n+            Arguments.of(\""//\"", \""//\"", \""//\"", UriCompliance.LEGACY)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""suspiciousCharactersLegacy\"")\n+    public void testSuspiciousCharactersLegacy(String suspect, String canonical, String decoded, UriCompliance compliance) throws Exception\n+    {\n+        server.stop();\n+        connector.getConnectionFactory(HttpConnectionFactory.class).getHttpConfiguration().setUriCompliance(compliance);\n+        server.setHandler(new Handler.Abstract.NonBlocking()\n+        {\n+            @Override\n+            public boolean handle(Request request, Response response, Callback callback)\n+            {\n+                if (decoded.length() != 3 || !Character.isDigit(decoded.charAt(0)))\n+                {\n+                    assertThat(request.getHttpURI().getCanonicalPath(), is(\""/test/fo\"" + canonical + \""bar\""));\n+                    assertThat(request.getHttpURI().getDecodedPath(), is(\""/test/fo\"" + decoded + \""bar\""));\n+                }\n+                callback.succeeded();\n+                return true;\n+            }\n+        });\n+        server.start();\n+\n+        String request = \""GET /test/fo\"" + suspect + \""bar HTTP/1.0\\r\\n\"" +\n+            \""Host: whatever\\r\\n\"" +\n+            \""\\r\\n\"";\n+        String response = connector.getResponse(request);\n+\n+        if (decoded.length() == 3 && Character.isDigit(decoded.charAt(0)))\n+            assertThat(response, startsWith(\""HTTP/1.1 \"" + decoded + \"" \""));\n+        else\n+            assertThat(response, startsWith(\""HTTP/1.1 200 OK\""));\n+    }\n }\n\\ No newline at end of file\n\ndiff --git a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlEncodedUtf8Test.java b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlEncodedUtf8Test.java\nindex f085dc754527..7cd9e9703118 100644\n--- a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlEncodedUtf8Test.java\n+++ b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlEncodedUtf8Test.java\n@@ -33,19 +33,19 @@ public class UrlEncodedUtf8Test\n         # query         | expectedName | expectedValue\n         a=bad_%e0%b     | a            | bad_\ufffd\n         b=bad_%e0%ba    | b            | bad_\ufffd\n-        c=short%a       | c            | short\ufffd\n+        c=short%a       | c            | short%a\n         d=b%aam         | d            | b\ufffdm\n-        e=%%TOK%%       | e            | \ufffdOK\ufffd\n+        e=%%TOK%%       | e            | %%TOK%%\n         f=%aardvark     | f            | \ufffdrdvark\n-        g=b%ar          | g            | b\ufffd\n-        h=end%          | h            | end\ufffd\n+        g=b%ar          | g            | b%ar\n+        h=end%          | h            | end%\n         # This shows how the '&' symbol does not get swallowed by a bad pct-encoding.\n-        i=%&z=2         | i            | \ufffd\n+        i=%&z=2         | i            | %\n         \""\""\"")\n     public void testDecodeAllowBadSequence(String query, String expectedName, String expectedValue)\n     {\n         Fields fields = new Fields();\n-        UrlEncoded.decodeUtf8To(query, 0, query.length(), fields::add, true, true);\n+        UrlEncoded.decodeUtf8To(query, 0, query.length(), fields::add, true, true, true);\n         Fields.Field field = fields.get(expectedName);\n         assertThat(\""Name exists\"", field, notNullValue());\n         assertThat(\""Value\"", field.getValue(), is(expectedValue));\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/RequestTest.java b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/RequestTest.java\nindex 05ed09cf4dff..7852df524147 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/RequestTest.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/RequestTest.java\n@@ -36,6 +36,7 @@\n import java.util.stream.Stream;\n \n import jakarta.servlet.MultipartConfigElement;\n+import jakarta.servlet.ServletException;\n import jakarta.servlet.http.Cookie;\n import jakarta.servlet.http.HttpServlet;\n import jakarta.servlet.http.HttpServletRequest;\n@@ -76,6 +77,7 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n import static org.hamcrest.Matchers.sameInstance;\n+import static org.hamcrest.Matchers.startsWith;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n@@ -636,8 +638,8 @@ protected void service(HttpServletRequest request, HttpServletResponse resp) thr\n         a=bad_%e0%b     | a            | bad_\ufffd\n         a=bad_%e0%b&b=2 | a            | bad_\ufffd\n         a=bad_%e0%ba    | a            | bad_\ufffd\n-        b=short%a       | b            | short\ufffd\n-        c=%%TOK%%       | c            | \ufffdOK\ufffd\n+        b=short%a       | b            | short%a\n+        c=%%TOK%%       | c            | %%TOK%%\n         \""\""\"")\n     public void testBadUtf8Query(String query, String expectedName, String expectedValue) throws Exception\n     {\n@@ -654,7 +656,7 @@ protected void doGet(HttpServletRequest request, HttpServletResponse resp)\n \n         startServer((server) ->\n                 _connector.getConnectionFactory(HttpConnectionFactory.class)\n-                    .getHttpConfiguration().setUriCompliance(UriCompliance.DEFAULT.with(\""test\"", UriCompliance.Violation.BAD_UTF8_ENCODING)),\n+                    .getHttpConfiguration().setUriCompliance(UriCompliance.DEFAULT.with(\""test\"", UriCompliance.Violation.BAD_UTF8_ENCODING, UriCompliance.Violation.TRUNCATED_UTF8_ENCODING, UriCompliance.Violation.BAD_PERCENT_ENCODING)),\n             servlet\n         );\n \n@@ -716,4 +718,73 @@ protected void service(HttpServletRequest request, HttpServletResponse resp) thr\n             [xyz]\n             \""\""\""));\n     }\n+\n+    static Stream<Arguments> suspiciousCharactersLegacy()\n+    {\n+        return Stream.of(\n+            Arguments.of(UriCompliance.DEFAULT, \""o\"", \""o\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%5C\"", \""400\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%0A\"", \""400\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%00\"", \""400\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%01\"", \""400\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%5F\"", \""_\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%2F\"", \""400\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%252F\"", \""400\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""//\"", \""400\""),\n+\n+            // these results are from jetty-11 DEFAULT\n+            Arguments.of(UriCompliance.JETTY_11, \""o\"", \""o\""),\n+            Arguments.of(UriCompliance.JETTY_11, \""%5C\"", \""\\\\\""),\n+            Arguments.of(UriCompliance.JETTY_11, \""%0A\"", \""\\n\""),\n+            Arguments.of(UriCompliance.JETTY_11, \""%00\"", \""400\""),\n+            Arguments.of(UriCompliance.JETTY_11, \""%01\"", \""\\u0001\""),\n+            Arguments.of(UriCompliance.JETTY_11, \""%5F\"", \""_\""),\n+            Arguments.of(UriCompliance.JETTY_11, \""%2F\"", \""/\""),\n+            Arguments.of(UriCompliance.JETTY_11, \""%252F\"", \""%2F\""),\n+            Arguments.of(UriCompliance.JETTY_11, \""//\"", \""400\""),\n+\n+            // these results are from jetty-11 LEGACY\n+            Arguments.of(UriCompliance.LEGACY, \""o\"", \""o\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%5C\"", \""\\\\\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%0A\"", \""\\n\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%00\"", \""400\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%01\"", \""\\u0001\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%5F\"", \""_\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%2F\"", \""/\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%252F\"", \""%2F\""),\n+            Arguments.of(UriCompliance.LEGACY, \""//\"", \""//\"")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""suspiciousCharactersLegacy\"")\n+    public void testSuspiciousCharactersLegacy(UriCompliance compliance, String suspect, String expected) throws Exception\n+    {\n+        startServer(new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                if (expected.length() != 3 || !Character.isDigit(expected.charAt(0)))\n+                    assertThat(request.getPathInfo(), is(\""/test/fo\"" + expected + \""bar\""));\n+            }\n+        });\n+\n+        _connector.getBean(HttpConnectionFactory.class).getHttpConfiguration().setUriCompliance(compliance);\n+        if (compliance != UriCompliance.DEFAULT)\n+            _server.getBean(ServletContextHandler.class).getServletHandler().setDecodeAmbiguousURIs(true);\n+        String request = \""GET /test/fo\"" + suspect + \""bar HTTP/1.0\\r\\n\"" +\n+            \""Host: whatever\\r\\n\"" +\n+            \""\\r\\n\"";\n+        String response = _connector.getResponse(request);\n+\n+        if (expected.length() == 3 && Character.isDigit(expected.charAt(0)))\n+        {\n+            assertThat(response, startsWith(\""HTTP/1.1 \"" + expected + \"" \""));\n+        }\n+        else\n+        {\n+            assertThat(response, startsWith(\""HTTP/1.1 200 OK\""));\n+        }\n+    }\n }\n\ndiff --git a/jetty-ee9/jetty-ee9-nested/src/test/java/org/eclipse/jetty/ee9/nested/RequestTest.java b/jetty-ee9/jetty-ee9-nested/src/test/java/org/eclipse/jetty/ee9/nested/RequestTest.java\nindex fe560a2ff6c5..b9f3356f8b73 100644\n--- a/jetty-ee9/jetty-ee9-nested/src/test/java/org/eclipse/jetty/ee9/nested/RequestTest.java\n+++ b/jetty-ee9/jetty-ee9-nested/src/test/java/org/eclipse/jetty/ee9/nested/RequestTest.java\n@@ -93,6 +93,8 @@\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n import org.junit.jupiter.params.provider.ValueSource;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -212,34 +214,6 @@ public void testRequestCharacterEncoding() throws Exception\n         assertEquals(\""utf-8\"", result.get());\n     }\n \n-    @Test\n-    public void testBadUtf8Query() throws Exception\n-    {\n-        _server.stop();\n-        _connector.getConnectionFactory(HttpConnectionFactory.class)\n-            .getHttpConfiguration().setUriCompliance(UriCompliance.DEFAULT.with(\""test\"", UriCompliance.Violation.BAD_UTF8_ENCODING));\n-        _server.start();\n-\n-        _handler._checker = (request, response) ->\n-        {\n-            String param = request.getParameter(\""param\"");\n-            String other = request.getParameter(\""other\"");\n-            return param != null && param.equals(\""bad_\ufffd\"") && other != null && other.equals(\""short\ufffd\"");\n-        };\n-\n-        //Send a request with query string with illegal hex code to cause\n-        //an exception parsing the params\n-        String request = \""\""\""\n-            GET /?param=bad_%e0%b8&other=short%a HTTP/1.1\\r\n-            Host: whatever\\r\n-            Connection: close\n-            \n-            \""\""\"";\n-\n-        String responses = _connector.getResponse(request);\n-        assertThat(responses, startsWith(\""HTTP/1.1 200\""));\n-    }\n-\n     @Test\n     public void testParamExtraction() throws Exception\n     {\n@@ -2571,4 +2545,57 @@ public void testUnknownCharacterEncoding() throws Exception\n         HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n         assertThat(response.getStatus(), is(HttpStatus.OK_200));\n     }\n+\n+    static Stream<Arguments> suspiciousCharactersLegacy()\n+    {\n+        return Stream.of(\n+            Arguments.of(UriCompliance.DEFAULT, \""o\"", \""o\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%5C\"", \""400\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%0A\"", \""400\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%00\"", \""400\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%01\"", \""400\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%5F\"", \""_\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%2F\"", \""400\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""%252F\"", \""400\""),\n+            Arguments.of(UriCompliance.DEFAULT, \""//\"", \""400\""),\n+\n+            // these results are from jetty-11 LEGACY\n+            Arguments.of(UriCompliance.LEGACY, \""o\"", \""o\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%5C\"", \""\\\\\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%0A\"", \""\\n\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%00\"", \""400\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%01\"", \""\\u0001\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%5F\"", \""_\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%2F\"", \""/\""),\n+            Arguments.of(UriCompliance.LEGACY, \""%252F\"", \""%2F\""),\n+            Arguments.of(UriCompliance.LEGACY, \""//\"", \""//\"")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\""suspiciousCharactersLegacy\"")\n+    public void testSuspiciousCharactersLegacy(UriCompliance compliance, String suspect, String expected) throws Exception\n+    {\n+        _connector.getBean(HttpConnectionFactory.class).getHttpConfiguration().setUriCompliance(compliance);\n+        _handler._checker = (request, response) ->\n+        {\n+            if (expected.length() != 3 || !Character.isDigit(expected.charAt(0)))\n+                assertThat(request.getPathInfo(), is(\""/test/fo\"" + expected + \""bar\""));\n+            return true;\n+        };\n+\n+        String request = \""GET /test/fo\"" + suspect + \""bar HTTP/1.0\\r\\n\"" +\n+            \""Host: whatever\\r\\n\"" +\n+            \""\\r\\n\"";\n+        String response = _connector.getResponse(request);\n+\n+        if (expected.length() == 3 && Character.isDigit(expected.charAt(0)))\n+        {\n+            assertThat(response, startsWith(\""HTTP/1.1 \"" + expected + \"" \""));\n+        }\n+        else\n+        {\n+            assertThat(response, startsWith(\""HTTP/1.1 200 OK\""));\n+        }\n+    }\n }\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-12770"", ""pr_id"": 12770, ""issue_id"": 12768, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Static HTML in demos still refer to Jetty 10/11 and earlier concepts.\n**Jetty version(s)**\n12.0.16\n\n**Jetty Environment**\nAll demos in all environments\n\n**Java version/vendor** `(use: java -version)`\nAny\n\n**OS type/version**\nAny\n\n**Description**\nWhile triaging issue #12767 it was noticed that the static HTML in the demos still refer to old concepts, versions, and directories.\nThis is bad/misleading and needs to be updated.\n\nExamples, seen during ee10-demo-jetty https://github.com/jetty/jetty.project/issues/12767#issuecomment-2636504830\n\n```\n<h1>Welcome to Jetty 11 - REMOTE ACCESS!!</h1>\n```\n\n```\nYou can disable the remote address checking by editing demo-base/webapps/demo-jetty.d/demo-jetty-override-web.xml\n```\n\nWe should review all of the static HTML for this kinds of forgotten updates."", ""issue_word_count"": 127, ""test_files_count"": 10, ""non_test_files_count"": 7, ""pr_changed_files"": [""jetty-core/jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/StdErrAppender.java"", ""jetty-core/jetty-start/src/main/java/org/eclipse/jetty/start/StartArgs.java"", ""jetty-core/jetty-start/src/test/java/org/eclipse/jetty/start/CommandLineBuilderTest.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/test/java/org/eclipse/jetty/websocket/client/WebSocketClientInitTest.java"", ""jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/main/java/org/eclipse/jetty/ee10/demos/LikeJettyXml.java"", ""jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/test/java/org/eclipse/jetty/ee10/demos/LikeJettyXmlTest.java"", ""jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/test/java/org/eclipse/jetty/ee10/demos/ManyConnectorsTest.java"", ""jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-jetty-webapp/src/main/webapp/remote.html"", ""jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-proxy-webapp/src/test/java/org/eclipse/jetty/ee10/demos/ProxyWebAppTest.java"", ""jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/main/java/org/eclipse/jetty/ee9/demos/LikeJettyXml.java"", ""jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/test/java/org/eclipse/jetty/ee9/demos/LikeJettyXmlTest.java"", ""jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/test/java/org/eclipse/jetty/ee9/demos/ManyConnectorsTest.java"", ""jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-jetty-webapp/src/main/webapp/remote.html"", ""jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-proxy-webapp/src/test/java/org/eclipse/jetty/ee9/demos/ProxyWebAppTest.java"", ""jetty-ee9/jetty-ee9-osgi/test-jetty-ee9-osgi/src/test/java/org/eclipse/jetty/ee9/osgi/test/TestOSGiUtil.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/test/java/org/eclipse/jetty/ee9/websocket/client/WebSocketClientInitTest.java"", ""jetty-home/src/main/resources/bin/jetty.sh""], ""pr_changed_test_files"": [""jetty-core/jetty-start/src/test/java/org/eclipse/jetty/start/CommandLineBuilderTest.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/test/java/org/eclipse/jetty/websocket/client/WebSocketClientInitTest.java"", ""jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/test/java/org/eclipse/jetty/ee10/demos/LikeJettyXmlTest.java"", ""jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/test/java/org/eclipse/jetty/ee10/demos/ManyConnectorsTest.java"", ""jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-proxy-webapp/src/test/java/org/eclipse/jetty/ee10/demos/ProxyWebAppTest.java"", ""jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/test/java/org/eclipse/jetty/ee9/demos/LikeJettyXmlTest.java"", ""jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/test/java/org/eclipse/jetty/ee9/demos/ManyConnectorsTest.java"", ""jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-proxy-webapp/src/test/java/org/eclipse/jetty/ee9/demos/ProxyWebAppTest.java"", ""jetty-ee9/jetty-ee9-osgi/test-jetty-ee9-osgi/src/test/java/org/eclipse/jetty/ee9/osgi/test/TestOSGiUtil.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/test/java/org/eclipse/jetty/ee9/websocket/client/WebSocketClientInitTest.java""], ""base_commit"": ""a171ad3a4d46bde2dfcc7cc5803f12f6919088fb"", ""head_commit"": ""07a6f45edc40cd166d747a2ff4a2b0a69d1b5464"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/12770"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/12770"", ""dockerfile"": """", ""pr_merged_at"": ""2025-02-06T11:48:44.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/StdErrAppender.java b/jetty-core/jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/StdErrAppender.java\nindex 719f2e7afd78..54d81ee7fc93 100644\n--- a/jetty-core/jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/StdErrAppender.java\n+++ b/jetty-core/jetty-slf4j-impl/src/main/java/org/eclipse/jetty/logging/StdErrAppender.java\n@@ -185,21 +185,15 @@ private void format(StringBuilder builder, JettyLogger logger, Level level, long\n \n     private String renderedLevel(Level level)\n     {\n-        switch (level)\n+        return switch (level)\n         {\n-            case ERROR:  // New for Jetty 10+\n-                return \""ERROR\"";\n-            case WARN:\n-                return \""WARN \"";\n-            case INFO:\n-                return \""INFO \"";\n-            case DEBUG:\n-                return \""DEBUG\"";\n-            case TRACE: // New for Jetty 10+\n-                return \""TRACE\"";\n-            default:\n-                return \""UNKNOWN\"";\n-        }\n+            case ERROR -> \""ERROR\"";\n+            case WARN -> \""WARN \"";\n+            case INFO -> \""INFO \"";\n+            case DEBUG -> \""DEBUG\"";\n+            case TRACE -> \""TRACE\"";\n+            default -> \""UNKNOWN\"";\n+        };\n     }\n \n     private void appendCause(StringBuilder builder, Throwable cause, String indent, Set<Throwable> visited)\n\ndiff --git a/jetty-core/jetty-start/src/main/java/org/eclipse/jetty/start/StartArgs.java b/jetty-core/jetty-start/src/main/java/org/eclipse/jetty/start/StartArgs.java\nindex 93e679f6b44b..7be6fdf5863d 100644\n--- a/jetty-core/jetty-start/src/main/java/org/eclipse/jetty/start/StartArgs.java\n+++ b/jetty-core/jetty-start/src/main/java/org/eclipse/jetty/start/StartArgs.java\n@@ -1468,11 +1468,6 @@ public void setProperty(StartEnvironment environment, String key, String value,\n                 JavaVersion ver = JavaVersion.parse(value);\n                 properties.setProperty(\""java.version.platform\"", Integer.toString(ver.getPlatform()), source);\n \n-                // @deprecated - below will be removed in Jetty 10.x\n-                properties.setProperty(\""java.version.major\"", Integer.toString(ver.getMajor()), \""Deprecated\"");\n-                properties.setProperty(\""java.version.minor\"", Integer.toString(ver.getMinor()), \""Deprecated\"");\n-                properties.setProperty(\""java.version.micro\"", Integer.toString(ver.getMicro()), \""Deprecated\"");\n-\n                 // ALPN feature exists\n                 properties.setProperty(\""runtime.feature.alpn\"", Boolean.toString(isMethodAvailable(javax.net.ssl.SSLParameters.class, \""getApplicationProtocols\"", null)), source);\n             }\n\ndiff --git a/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/main/java/org/eclipse/jetty/ee10/demos/LikeJettyXml.java b/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/main/java/org/eclipse/jetty/ee10/demos/LikeJettyXml.java\nindex b42cb0d662b3..000f93eb5450 100644\n--- a/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/main/java/org/eclipse/jetty/ee10/demos/LikeJettyXml.java\n+++ b/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/main/java/org/eclipse/jetty/ee10/demos/LikeJettyXml.java\n@@ -57,8 +57,9 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * Starts the Jetty Distribution's demo-base directory using entirely\n- * embedded jetty techniques.\n+ * Starts a new Jetty Base in the target/embedded/ directory using entirely\n+ * embedded jetty techniques, in ways similar to the various Jetty XML files\n+ * from {@code jetty-home}\n  */\n public class LikeJettyXml\n {\n\ndiff --git a/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-jetty-webapp/src/main/webapp/remote.html b/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-jetty-webapp/src/main/webapp/remote.html\nindex 276d96c353d5..5b52a10c7e85 100644\n--- a/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-jetty-webapp/src/main/webapp/remote.html\n+++ b/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-jetty-webapp/src/main/webapp/remote.html\n@@ -15,15 +15,18 @@\n     </div>\n \n     <div class=\""content\"">\n-      <h1>Welcome to Jetty 11 - REMOTE ACCESS!!</h1>\n+      <h1>Welcome to Jetty 12 (ee10) - REMOTE ACCESS!!</h1>\n       <p>\n        This is a demo webapp for the Eclipse Jetty HTTP Server and Servlet Container.\n       </p>\n       <p>\n-       This test context serves several demo filters and servlets that are not safe for deployment on the internet, since (by design) they contain cross domain scripting vulnerabilities and reveal private information.  This page is displayed because you have accessed this context from a non local IP address.\n+       This test context serves several demo filters and servlets that are not safe for deployment on the internet,\n+       since (by design) they contain cross domain scripting vulnerabilities and reveal private information.\n+       This page is displayed because you have accessed this context from a non local IP address.\n       </p>\n       <p>\n-       You can disable the remote address checking by editing demo-base/webapps/demo-jetty.d/demo-jetty-override-web.xml, uncommenting the declaration of the TestFilter, and changing the \""remote\"" init parameter to \""true\"".\n+       You can disable the remote address checking by editing webapps/ee10-demo-jetty.d/ee10-demo-jetty-override-web.xml,\n+       uncommenting the declaration of the TestFilter, and changing the \""remote\"" init parameter to \""true\"".\n       </p>\n     </div>\n \n\ndiff --git a/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/main/java/org/eclipse/jetty/ee9/demos/LikeJettyXml.java b/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/main/java/org/eclipse/jetty/ee9/demos/LikeJettyXml.java\nindex d188d3bd576a..9566fea0ab73 100644\n--- a/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/main/java/org/eclipse/jetty/ee9/demos/LikeJettyXml.java\n+++ b/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/main/java/org/eclipse/jetty/ee9/demos/LikeJettyXml.java\n@@ -14,8 +14,9 @@\n package org.eclipse.jetty.ee9.demos;\n \n /**\n- * Starts the Jetty Distribution's demo-base directory using entirely\n- * embedded jetty techniques.\n+ * Starts a new Jetty Base in the target/embedded/ directory using entirely\n+ * embedded jetty techniques, in ways similar to the various Jetty XML files\n+ * from {@code jetty-home}\n  */\n public class LikeJettyXml\n {\n\ndiff --git a/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-jetty-webapp/src/main/webapp/remote.html b/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-jetty-webapp/src/main/webapp/remote.html\nindex c5be4a415ad1..f3857096cc6d 100644\n--- a/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-jetty-webapp/src/main/webapp/remote.html\n+++ b/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-jetty-webapp/src/main/webapp/remote.html\n@@ -15,15 +15,18 @@\n     </div>\n \n     <div class=\""content\"">\n-      <h1>Welcome to Jetty 11 - REMOTE ACCESS!!</h1>\n+      <h1>Welcome to Jetty 12 (ee9) - REMOTE ACCESS!!</h1>\n       <p>\n        This is a demo webapp for the Eclipse Jetty HTTP Server and Servlet Container.\n       </p>\n       <p>\n-       This test context serves several demo filters and servlets that are not safe for deployment on the internet, since (by design) they contain cross domain scripting vulnerabilities and reveal private information.  This page is displayed because you have accessed this context from a non local IP address.\n+       This test context serves several demo filters and servlets that are not safe for deployment on the internet,\n+       since (by design) they contain cross domain scripting vulnerabilities and reveal private information.\n+       This page is displayed because you have accessed this context from a non local IP address.\n       </p>\n       <p>\n-       You can disable the remote address checking by editing demo-base/webapps/demo-jetty.d/demo-jetty-override-web.xml, uncommenting the declaration of the TestFilter, and changing the \""remote\"" init parameter to \""true\"".\n+       You can disable the remote address checking by editing webapps/ee9-demo-jetty.d/ee9-demo-jetty-override-web.xml,\n+       uncommenting the declaration of the TestFilter, and changing the \""remote\"" init parameter to \""true\"".\n       </p>\n     </div>\n \n\ndiff --git a/jetty-home/src/main/resources/bin/jetty.sh b/jetty-home/src/main/resources/bin/jetty.sh\nindex 618f11edd5f8..155283952a50 100755\n--- a/jetty-home/src/main/resources/bin/jetty.sh\n+++ b/jetty-home/src/main/resources/bin/jetty.sh\n@@ -22,7 +22,7 @@ NAME=$(echo $(basename $0) | sed -e 's/^[SK][0-9]*//' -e 's/\\.sh$//')\n # To get the service to restart correctly on reboot, uncomment below (3 lines):\n # ========================\n # chkconfig: 3 99 99\n-# description: Jetty 9 webserver\n+# description: Eclipse Jetty webserver\n # processname: jetty\n # ========================\n \n"", ""test_patch"": ""diff --git a/jetty-core/jetty-start/src/test/java/org/eclipse/jetty/start/CommandLineBuilderTest.java b/jetty-core/jetty-start/src/test/java/org/eclipse/jetty/start/CommandLineBuilderTest.java\nindex 6f938f7ae00a..da4b40f95f80 100644\n--- a/jetty-core/jetty-start/src/test/java/org/eclipse/jetty/start/CommandLineBuilderTest.java\n+++ b/jetty-core/jetty-start/src/test/java/org/eclipse/jetty/start/CommandLineBuilderTest.java\n@@ -49,8 +49,8 @@ public void testSimpleHomeWithSpace()\n     {\n         CommandLineBuilder cmd = new CommandLineBuilder();\n         cmd.addArg(\""java\"");\n-        cmd.addArg(\""-Djetty.home\"", \""/opt/jetty 10/home\"");\n-        assertThat(cmd.toCommandLine(), is(\""java -Djetty.home='/opt/jetty 10/home'\""));\n+        cmd.addArg(\""-Djetty.home\"", \""/opt/jetty 12/home\"");\n+        assertThat(cmd.toCommandLine(), is(\""java -Djetty.home='/opt/jetty 12/home'\""));\n     }\n \n     @Test\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/test/java/org/eclipse/jetty/websocket/client/WebSocketClientInitTest.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/test/java/org/eclipse/jetty/websocket/client/WebSocketClientInitTest.java\nindex 229509588e33..d797f654b9a5 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/test/java/org/eclipse/jetty/websocket/client/WebSocketClientInitTest.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/test/java/org/eclipse/jetty/websocket/client/WebSocketClientInitTest.java\n@@ -27,7 +27,7 @@\n public class WebSocketClientInitTest\n {\n     /**\n-     * This is the new Jetty 9.4 advanced usage mode of WebSocketClient,\n+     * Advanced usage mode of WebSocketClient,\n      * that allows for more robust HTTP configurations (such as authentication,\n      * cookies, and proxies)\n      *\n\ndiff --git a/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/test/java/org/eclipse/jetty/ee10/demos/LikeJettyXmlTest.java b/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/test/java/org/eclipse/jetty/ee10/demos/LikeJettyXmlTest.java\nindex 8330f9b7773e..136fecb67646 100644\n--- a/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/test/java/org/eclipse/jetty/ee10/demos/LikeJettyXmlTest.java\n+++ b/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/test/java/org/eclipse/jetty/ee10/demos/LikeJettyXmlTest.java\n@@ -44,7 +44,7 @@ public void startServer() throws Exception\n         Map<String, Integer> ports = ServerUtil.fixDynamicPortConfigurations(server);\n \n         // Establish base URI's that use \""localhost\"" to prevent tripping over\n-        // the \""REMOTE ACCESS\"" warnings in demo-base\n+        // the \""REMOTE ACCESS\"" warnings in webapps/ee#-demo-jetty.d/ee#-demo-jetty-override-web.xml\n         serverPlainUri = URI.create(\""http://localhost:\"" + ports.get(\""plain\"") + \""/\"");\n         serverSslUri = URI.create(\""https://localhost:\"" + ports.get(\""secure\"") + \""/\"");\n     }\n\ndiff --git a/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/test/java/org/eclipse/jetty/ee10/demos/ManyConnectorsTest.java b/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/test/java/org/eclipse/jetty/ee10/demos/ManyConnectorsTest.java\nindex 364241de6981..7a24117db5d1 100644\n--- a/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/test/java/org/eclipse/jetty/ee10/demos/ManyConnectorsTest.java\n+++ b/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-embedded/src/test/java/org/eclipse/jetty/ee10/demos/ManyConnectorsTest.java\n@@ -43,7 +43,7 @@ public void startServer() throws Exception\n         Map<String, Integer> ports = ServerUtil.fixDynamicPortConfigurations(server);\n \n         // Establish base URI's that use \""localhost\"" to prevent tripping over\n-        // the \""REMOTE ACCESS\"" warnings in demo-base\n+        // the \""REMOTE ACCESS\"" warnings in webapps/ee#-demo-jetty.d/ee#-demo-jetty-override-web.xml\n         serverPlainUri = URI.create(\""http://localhost:\"" + ports.get(\""plain\"") + \""/\"");\n         serverSslUri = URI.create(\""https://localhost:\"" + ports.get(\""secure\"") + \""/\"");\n     }\n\ndiff --git a/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-proxy-webapp/src/test/java/org/eclipse/jetty/ee10/demos/ProxyWebAppTest.java b/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-proxy-webapp/src/test/java/org/eclipse/jetty/ee10/demos/ProxyWebAppTest.java\nindex 79390bd4e4b0..7ab593bd8702 100644\n--- a/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-proxy-webapp/src/test/java/org/eclipse/jetty/ee10/demos/ProxyWebAppTest.java\n+++ b/jetty-ee10/jetty-ee10-demos/jetty-ee10-demo-proxy-webapp/src/test/java/org/eclipse/jetty/ee10/demos/ProxyWebAppTest.java\n@@ -34,7 +34,7 @@\n import static org.hamcrest.Matchers.is;\n \n /**\n- * Test the configuration found in WEB-INF/web.xml for purposes of the demo-base\n+ * Test the configuration found in WEB-INF/web.xml of ee10-demo-proxy.war\n  */\n public class ProxyWebAppTest\n {\n\ndiff --git a/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/test/java/org/eclipse/jetty/ee9/demos/LikeJettyXmlTest.java b/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/test/java/org/eclipse/jetty/ee9/demos/LikeJettyXmlTest.java\nindex 117e30bc6907..fddc054d35ff 100644\n--- a/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/test/java/org/eclipse/jetty/ee9/demos/LikeJettyXmlTest.java\n+++ b/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/test/java/org/eclipse/jetty/ee9/demos/LikeJettyXmlTest.java\n@@ -45,7 +45,7 @@ public void startServer() throws Exception\n         Map<String, Integer> ports = ServerUtil.fixDynamicPortConfigurations(server);\n \n         // Establish base URI's that use \""localhost\"" to prevent tripping over\n-        // the \""REMOTE ACCESS\"" warnings in demo-base\n+        // the \""REMOTE ACCESS\"" warnings in webapps/ee#-demo-jetty.d/ee#-demo-jetty-override-web.xml\n         serverPlainUri = URI.create(\""http://localhost:\"" + ports.get(\""plain\"") + \""/\"");\n         serverSslUri = URI.create(\""https://localhost:\"" + ports.get(\""secure\"") + \""/\"");\n     }\n\ndiff --git a/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/test/java/org/eclipse/jetty/ee9/demos/ManyConnectorsTest.java b/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/test/java/org/eclipse/jetty/ee9/demos/ManyConnectorsTest.java\nindex 7d3f8979ddf9..acf62d72d364 100644\n--- a/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/test/java/org/eclipse/jetty/ee9/demos/ManyConnectorsTest.java\n+++ b/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-embedded/src/test/java/org/eclipse/jetty/ee9/demos/ManyConnectorsTest.java\n@@ -43,7 +43,7 @@ public void startServer() throws Exception\n         Map<String, Integer> ports = ServerUtil.fixDynamicPortConfigurations(server);\n \n         // Establish base URI's that use \""localhost\"" to prevent tripping over\n-        // the \""REMOTE ACCESS\"" warnings in demo-base\n+        // the \""REMOTE ACCESS\"" warnings in webapps/ee#-demo-jetty.d/ee#-demo-jetty-override-web.xml\n         serverPlainUri = URI.create(\""http://localhost:\"" + ports.get(\""plain\"") + \""/\"");\n         serverSslUri = URI.create(\""https://localhost:\"" + ports.get(\""secure\"") + \""/\"");\n     }\n\ndiff --git a/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-proxy-webapp/src/test/java/org/eclipse/jetty/ee9/demos/ProxyWebAppTest.java b/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-proxy-webapp/src/test/java/org/eclipse/jetty/ee9/demos/ProxyWebAppTest.java\nindex 78ec5592f3b9..68d1115fa951 100644\n--- a/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-proxy-webapp/src/test/java/org/eclipse/jetty/ee9/demos/ProxyWebAppTest.java\n+++ b/jetty-ee9/jetty-ee9-demos/jetty-ee9-demo-proxy-webapp/src/test/java/org/eclipse/jetty/ee9/demos/ProxyWebAppTest.java\n@@ -37,7 +37,7 @@\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n /**\n- * Test the configuration found in WEB-INF/web.xml for purposes of the demo-base\n+ * Test the configuration found in WEB-INF/web.xml of ee9-demo-proxy.war\n  */\n public class ProxyWebAppTest\n {\n\ndiff --git a/jetty-ee9/jetty-ee9-osgi/test-jetty-ee9-osgi/src/test/java/org/eclipse/jetty/ee9/osgi/test/TestOSGiUtil.java b/jetty-ee9/jetty-ee9-osgi/test-jetty-ee9-osgi/src/test/java/org/eclipse/jetty/ee9/osgi/test/TestOSGiUtil.java\nindex 45cd52bc2a69..c01a9672946d 100644\n--- a/jetty-ee9/jetty-ee9-osgi/test-jetty-ee9-osgi/src/test/java/org/eclipse/jetty/ee9/osgi/test/TestOSGiUtil.java\n+++ b/jetty-ee9/jetty-ee9-osgi/test-jetty-ee9-osgi/src/test/java/org/eclipse/jetty/ee9/osgi/test/TestOSGiUtil.java\n@@ -142,7 +142,7 @@ public static void coreJettyDependencies(List<Option> res)\n         res.add(mavenBundle().groupId(\""org.slf4j\"").artifactId(\""slf4j-api\"").version(\""1.7.36\"").startLevel(START_LEVEL_SYSTEM_BUNDLES)); //.versionAsInProject().noStart());\n \n         /*\n-         * Jetty 11 uses slf4j 2.0.0 by default, however we want to test with slf4j 1.7.30 for backwards compatibility.\n+         * Jetty 12 uses slf4j 2.0.0 by default, however we want to test with slf4j 1.7.30 for backwards compatibility.\n          * To do that, we need to use slf4j-simple as the logging implementation. We make a simplelogger.properties\n          * file available so that jetty logging can be configured\n          */\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/test/java/org/eclipse/jetty/ee9/websocket/client/WebSocketClientInitTest.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/test/java/org/eclipse/jetty/ee9/websocket/client/WebSocketClientInitTest.java\nindex 70dac1eecb10..dfab3de7a5f6 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/test/java/org/eclipse/jetty/ee9/websocket/client/WebSocketClientInitTest.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/test/java/org/eclipse/jetty/ee9/websocket/client/WebSocketClientInitTest.java\n@@ -27,7 +27,7 @@\n public class WebSocketClientInitTest\n {\n     /**\n-     * This is the new Jetty 9.4 advanced usage mode of WebSocketClient,\n+     * Advanced usage mode of WebSocketClient,\n      * that allows for more robust HTTP configurations (such as authentication,\n      * cookies, and proxies)\n      *\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-12763"", ""pr_id"": 12763, ""issue_id"": 12750, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""UriCompliance is ignored for query string parsing\n**Jetty version(s)**\nJetty 10, 11, 12.0.16\n\n**Jetty Environment**\nEE 10\n\n**Description**\n\nWe have an application that was able to process URIs in the following format with Jetty 9:\n\n```\nhttp://localhost:8008/set?action=ADD&url=http://somedomain.com?us_options=%%US_OPTIONS%%\n```\n\nJetty 10 and 11 enforced stricter requirements for URIs but exposed `UriCompliance,` specifically `UriCompliance.LEGACY`, which should help us deal with the legacy apps / clients.\n\nBut the query string's deserialization code path seemingly doesn't respect the `UriCompliance.LEGACY` or any other custom `UriCompliance` setting.\n\nSo the URL above that was able to be processed by jetty 9, in jetty 12 (and also 10/11) leads to the following exception:\n\n```\njava.lang.IllegalArgumentException: Not valid encoding '%%U'\n\tat org.eclipse.jetty.util.UrlEncoded.decodeHexByte(UrlEncoded.java:974)\n\tat org.eclipse.jetty.util.UrlEncoded.decodeUtf8To(UrlEncoded.java:380)\n\tat org.eclipse.jetty.util.UrlEncoded.decodeTo(UrlEncoded.java:226)\n\tat org.eclipse.jetty.server.Request.extractQueryParameters(Request.java:569)\n\tat org.eclipse.jetty.ee10.servlet.ServletApiRequest.extractQueryParameters(ServletApiRequest.java:1071)\n\tat org.eclipse.jetty.ee10.servlet.ServletApiRequest.getParameters(ServletApiRequest.java:960)\n\tat org.eclipse.jetty.ee10.servlet.ServletApiRequest.getParameterNames(ServletApiRequest.java:934)\n\tat jakarta.servlet.ServletRequestWrapper.getParameterNames(ServletRequestWrapper.java:166)\n\tat jakarta.servlet.ServletRequestWrapper.getParameterNames(ServletRequestWrapper.java:166)\n```\n\nWould it be possible to respect `UriCompliance` for query strings so we can accept the same URIs on Jetty 12 that were acceptable on Jetty 9?"", ""issue_word_count"": 243, ""test_files_count"": 3, ""non_test_files_count"": 2, ""pr_changed_files"": [""jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/FormFieldsTest.java"", ""jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlEncodedUtf8Test.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/RequestTest.java""], ""pr_changed_test_files"": [""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/FormFieldsTest.java"", ""jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlEncodedUtf8Test.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/RequestTest.java""], ""base_commit"": ""e32b189929dd85f3e3767ec662eba0d34744fca9"", ""head_commit"": ""71b95ee7c845ad570c2ae1d75bdc2bb9292be73c"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/12763"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/12763"", ""dockerfile"": """", ""pr_merged_at"": ""2025-02-07T18:51:06.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java\nindex fb8dad6cd127..b5041d2d994f 100644\n--- a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java\n+++ b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java\n@@ -196,6 +196,7 @@ public String getDescription()\n             Violation.AMBIGUOUS_PATH_SEPARATOR,\n             Violation.AMBIGUOUS_PATH_ENCODING,\n             Violation.AMBIGUOUS_EMPTY_SEGMENT,\n+            Violation.BAD_UTF8_ENCODING,\n             Violation.UTF16_ENCODINGS,\n             Violation.USER_INFO));\n \n\ndiff --git a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java\nindex 5d2df9bef405..8da87792ca6b 100644\n--- a/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java\n+++ b/jetty-core/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java\n@@ -409,7 +409,7 @@ else if (value != null && !value.isEmpty())\n                     {\n                         char hi = query.charAt(++i);\n                         char lo = query.charAt(++i);\n-                        buffer.append(decodeHexByte(hi, lo));\n+                        decodeHexByteTo(buffer, hi, lo, allowBadUtf8);\n                     }\n                     else if (allowBadUtf8)\n                     {\n@@ -539,6 +539,21 @@ else if (buffer.length() > 0)\n         checkMaxKeys(keys, maxKeys);\n     }\n \n+    /**\n+     * Decoded parameters to Map.\n+     *\n+     * @param in InputSteam to read\n+     * @param fields the Fields to store the parameters\n+     * @param maxLength maximum form length to decode or -1 for no limit\n+     * @param maxKeys the maximum number of keys to read or -1 for no limit\n+     * @throws IOException if unable to decode the input stream\n+     */\n+    public static void decodeUtf8To(InputStream in, Fields fields, int maxLength, int maxKeys)\n+        throws IOException\n+    {\n+        decodeUtf8To(in, fields::add, maxLength, maxKeys);\n+    }\n+\n     /**\n      * Decoded parameters to Map.\n      *\n@@ -547,7 +562,9 @@ else if (buffer.length() > 0)\n      * @param maxLength maximum form length to decode or -1 for no limit\n      * @param maxKeys the maximum number of keys to read or -1 for no limit\n      * @throws IOException if unable to decode the input stream\n+     * @deprecated use {@link #decodeUtf8To(InputStream, Fields, int, int)} instead.\n      */\n+    @Deprecated(since = \""12.0.17\"", forRemoval = true)\n     public static void decodeUtf8To(InputStream in, MultiMap<String> map, int maxLength, int maxKeys)\n         throws IOException\n     {\n@@ -1014,6 +1031,21 @@ public static byte decodeHexByte(char hi, char lo)\n         }\n     }\n \n+    private static void decodeHexByteTo(Utf8StringBuilder buffer, char hi, char lo, boolean allowBadUtf8)\n+    {\n+        try\n+        {\n+            buffer.append((byte)((convertHexDigit(hi) << 4) + convertHexDigit(lo)));\n+        }\n+        catch (NumberFormatException e)\n+        {\n+            if (allowBadUtf8)\n+                buffer.append(Utf8StringBuilder.REPLACEMENT);\n+            else\n+                throw e;\n+        }\n+    }\n+\n     /**\n      * Perform URL encoding.\n      *\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/FormFieldsTest.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/FormFieldsTest.java\nindex c0d76c304ca6..c24c3c191841 100644\n--- a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/FormFieldsTest.java\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/FormFieldsTest.java\n@@ -111,7 +111,6 @@ public static Stream<Arguments> invalidData()\n             Arguments.of(List.of(\""name%\""), UTF_8, -1, -1, IllegalStateException.class),\n             Arguments.of(List.of(\""name%A\""), UTF_8, -1, -1, IllegalStateException.class),\n \n-            // TODO: these 2 should throw the same exception.\n             Arguments.of(List.of(\""name%A=\""), UTF_8, -1, -1, CharacterCodingException.class),\n             Arguments.of(List.of(\""name%A&\""), UTF_8, -1, -1, IllegalArgumentException.class),\n \n@@ -125,6 +124,7 @@ public static Stream<Arguments> invalidData()\n             Arguments.of(List.of(\""n=v&X=Y\""), UTF_8, -1, 3, IllegalStateException.class),\n             Arguments.of(List.of(\""n%AH=v\""), UTF_8, -1, -1, IllegalArgumentException.class),\n             Arguments.of(List.of(\""n=v%AH\""), UTF_8, -1, -1, IllegalArgumentException.class),\n+            Arguments.of(List.of(\""n=%%TOK%%\""), UTF_8, -1, -1, IllegalArgumentException.class),\n             Arguments.of(List.of(\""n=v%FF\""), UTF_8, -1, -1, CharacterCodingException.class)\n         );\n     }\n\ndiff --git a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlEncodedUtf8Test.java b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlEncodedUtf8Test.java\nindex 1cfb7bc4e499..6893e69eb633 100644\n--- a/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlEncodedUtf8Test.java\n+++ b/jetty-core/jetty-util/src/test/java/org/eclipse/jetty/util/UrlEncodedUtf8Test.java\n@@ -18,16 +18,38 @@\n import java.nio.charset.StandardCharsets;\n \n import org.junit.jupiter.api.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n-import static org.junit.jupiter.api.Assertions.fail;\n+import static org.hamcrest.Matchers.notNullValue;\n \n public class UrlEncodedUtf8Test\n {\n-    private static final Logger LOG = LoggerFactory.getLogger(UrlEncodedUtf8Test.class);\n+    @ParameterizedTest\n+    @CsvSource(delimiter = '|', useHeadersInDisplayName = false,\n+        textBlock = \""\""\""\n+        # query         | expectedName | expectedValue\n+        a=bad_%e0%b     | a            | bad_\ufffd\ufffd\n+        b=bad_%e0%ba    | b            | bad_\ufffd\n+        c=short%a       | c            | short\ufffd\n+        d=b%aam         | d            | b\ufffdm\n+        e=%%TOK%%       | e            | \ufffdOK\ufffd\n+        f=%aardvark     | f            | \ufffdrdvark\n+        g=b%ar          | g            | b\ufffd\n+        h=end%          | h            | end\ufffd\n+        # This shows how the '&' symbol gets swallowed by a pct-encoding effort.\n+        i=%&z=2         | i            | \ufffd=2\n+        \""\""\"")\n+    public void testDecodeAllowBadSequence(String query, String expectedName, String expectedValue)\n+    {\n+        Fields fields = new Fields();\n+        UrlEncoded.decodeUtf8To(query, 0, query.length(), fields::add, true);\n+        Fields.Field field = fields.get(expectedName);\n+        assertThat(\""Name exists\"", field, notNullValue());\n+        assertThat(\""Value\"", field.getValue(), is(expectedValue));\n+    }\n \n     @Test\n     public void testIncompleteSequestAtTheEnd() throws Exception\n@@ -36,8 +58,8 @@ public void testIncompleteSequestAtTheEnd() throws Exception\n         String test = new String(bytes, StandardCharsets.UTF_8);\n         String expected = \""c\"" + Utf8StringBuilder.REPLACEMENT;\n \n-        fromString(test, test, \""ab\"", expected, false);\n-        fromInputStream(test, bytes, \""ab\"", expected, false);\n+        fromString(test, test, \""ab\"", expected);\n+        fromInputStream(test, bytes, \""ab\"", expected);\n     }\n \n     @Test\n@@ -47,8 +69,8 @@ public void testIncompleteSequestAtTheEnd2() throws Exception\n         String test = new String(bytes, StandardCharsets.UTF_8);\n         String expected = \""\"" + Utf8StringBuilder.REPLACEMENT;\n \n-        fromString(test, test, \""ab\"", expected, false);\n-        fromInputStream(test, bytes, \""ab\"", expected, false);\n+        fromString(test, test, \""ab\"", expected);\n+        fromInputStream(test, bytes, \""ab\"", expected);\n     }\n \n     @Test\n@@ -59,8 +81,8 @@ public void testIncompleteSequestInName() throws Exception\n         String name = \""e\"" + Utf8StringBuilder.REPLACEMENT;\n         String value = \""fg\"";\n \n-        fromString(test, test, name, value, false);\n-        fromInputStream(test, bytes, name, value, false);\n+        fromString(test, test, name, value);\n+        fromInputStream(test, bytes, name, value);\n     }\n \n     @Test\n@@ -71,46 +93,24 @@ public void testIncompleteSequestInValue() throws Exception\n         String name = \""ef\"";\n         String value = \""g\"" + Utf8StringBuilder.REPLACEMENT;\n \n-        fromString(test, test, name, value, false);\n-        fromInputStream(test, bytes, name, value, false);\n+        fromString(test, test, name, value);\n+        fromInputStream(test, bytes, name, value);\n     }\n \n-    // TODO: Split thrown/not-thrown\n-    static void fromString(String test, String s, String field, String expected, boolean thrown) throws Exception\n+    static void fromString(String test, String s, String field, String expected)\n     {\n-        MultiMap<String> values = new MultiMap<>();\n-        try\n-        {\n-            UrlEncoded.decodeUtf8To(s, 0, s.length(), values);\n-            if (thrown)\n-                fail(\""Expected an exception\"");\n-            assertThat(test, values.getString(field), is(expected));\n-        }\n-        catch (Exception e)\n-        {\n-            if (!thrown)\n-                throw e;\n-            LOG.trace(\""IGNORED\"", e);\n-        }\n+        Fields values = new Fields();\n+        UrlEncoded.decodeUtf8To(s, 0, s.length(), values);\n+        assertThat(test, values.getValue(field), is(expected));\n     }\n \n-    // TODO: Split thrown/not-thrown\n-    static void fromInputStream(String test, byte[] b, String field, String expected, boolean thrown) throws Exception\n+    static void fromInputStream(String test, byte[] b, String field, String expected) throws Exception\n     {\n-        InputStream is = new ByteArrayInputStream(b);\n-        MultiMap<String> values = new MultiMap<>();\n-        try\n+        try (InputStream is = new ByteArrayInputStream(b))\n         {\n+            Fields values = new Fields();\n             UrlEncoded.decodeUtf8To(is, values, 1000000, -1);\n-            if (thrown)\n-                fail(\""Expected an exception\"");\n-            assertThat(test, values.getString(field), is(expected));\n-        }\n-        catch (Exception e)\n-        {\n-            if (!thrown)\n-                throw e;\n-            LOG.trace(\""IGNORED\"", e);\n+            assertThat(test, values.getValue(field), is(expected));\n         }\n     }\n }\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/RequestTest.java b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/RequestTest.java\nindex 4ee3dac98e9d..68dda8e593ee 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/RequestTest.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/RequestTest.java\n@@ -60,6 +60,7 @@\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.CsvSource;\n import org.junit.jupiter.params.provider.MethodSource;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -628,6 +629,48 @@ protected void service(HttpServletRequest request, HttpServletResponse resp) thr\n         }\n     }\n \n+    @ParameterizedTest\n+    @CsvSource(delimiter = '|', useHeadersInDisplayName = false,\n+        textBlock = \""\""\""\n+        # query         | expectedName | expectedValue\n+        a=bad_%e0%b     | a            | bad_\ufffd\ufffd\n+        a=bad_%e0%ba    | a            | bad_\ufffd\n+        b=short%a       | b            | short\ufffd\n+        c=%%TOK%%       | c            | \ufffdOK\ufffd\n+        \""\""\"")\n+    public void testBadUtf8Query(String query, String expectedName, String expectedValue) throws Exception\n+    {\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest request, HttpServletResponse resp)\n+            {\n+                String param = request.getParameter(expectedName);\n+                assertThat(param, is(expectedValue));\n+                resp.setStatus(200);\n+            }\n+        };\n+\n+        startServer((server) ->\n+                _connector.getConnectionFactory(HttpConnectionFactory.class)\n+                    .getHttpConfiguration().setUriCompliance(UriCompliance.DEFAULT.with(\""test\"", UriCompliance.Violation.BAD_UTF8_ENCODING)),\n+            servlet\n+        );\n+\n+        //Send a request with query string with illegal hex code to cause\n+        //an exception parsing the params\n+        String request = \""\""\""\n+            GET /?@QUERY@ HTTP/1.1\\r\n+            Host: whatever\\r\n+            Connection: close\n+            \n+            \""\""\"".replaceAll(\""@QUERY@\"", query);\n+\n+        String rawResponse = _connector.getResponse(request);\n+        HttpTester.Response response = HttpTester.parseResponse(rawResponse);\n+        assertThat(response.getStatus(), is(200));\n+    }\n+\n     @Test\n     public void testParameters() throws Exception\n     {\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-12622"", ""pr_id"": 12622, ""issue_id"": 11325, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Review content-length check in ServletChannel\n**Jetty version(s)**\r\n12+\r\n\r\n**Jetty Environment**\r\nee10, possibly others too\r\n\r\n**Description**\r\n`ServletChannel.handle()` in case `COMPLETE` performs a check on the content-length, to see if it the actual bytes written match the value of the header.\r\n\r\nUnfortunately, this check is performed too early in case of buffered content if looking at the bytes written to the `ServletContextResponse` (they are written to the `HttpOutput`, but not yet to the `ServletContextResponse`).\r\n\r\nHowever, we cannot look at the bytes written to `HttpOutput`, because currently the welcome files are written bypassing it, so content-length the check would fail.\r\nThis could be solved by always wrapping the Servlet response in `DefaultServlet`, so it never bypasses `HttpOutput` so the count is always correct.\r\n\r\nLastly, the solution needs to take into account the possibility of gzip being performed before or after the `ContextHandler`.\r\n"", ""issue_word_count"": 144, ""test_files_count"": 12, ""non_test_files_count"": 9, ""pr_changed_files"": [""jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/HttpOutput.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletApiResponse.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java"", ""jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextResponse.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/ContextScopeListenerTest.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/HttpOutputTest.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/big.txt"", ""jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/directory/content.txt"", ""jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/directory/welcome.txt"", ""jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/simple.txt"", ""jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/HttpOutput.java"", ""jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletApiResponse.java"", ""jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletChannel.java"", ""jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletContextResponse.java"", ""jetty-ee11/jetty-ee11-servlet/src/test/java/org/eclipse/jetty/ee11/servlet/ContextScopeListenerTest.java"", ""jetty-ee11/jetty-ee11-servlet/src/test/java/org/eclipse/jetty/ee11/servlet/HttpOutputTest.java"", ""jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/big.txt"", ""jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/directory/content.txt"", ""jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/directory/welcome.txt"", ""jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/simple.txt""], ""pr_changed_test_files"": [""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/ContextScopeListenerTest.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/HttpOutputTest.java"", ""jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/big.txt"", ""jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/directory/content.txt"", ""jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/directory/welcome.txt"", ""jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/simple.txt"", ""jetty-ee11/jetty-ee11-servlet/src/test/java/org/eclipse/jetty/ee11/servlet/ContextScopeListenerTest.java"", ""jetty-ee11/jetty-ee11-servlet/src/test/java/org/eclipse/jetty/ee11/servlet/HttpOutputTest.java"", ""jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/big.txt"", ""jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/directory/content.txt"", ""jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/directory/welcome.txt"", ""jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/simple.txt""], ""base_commit"": ""2c55f4de36f6bc75a3cc7b8852881b84a53bb514"", ""head_commit"": ""6637ed1761160cbccece7ea962c44fa28f107388"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/12622"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/12622"", ""dockerfile"": """", ""pr_merged_at"": ""2024-12-12T00:13:27.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java\nindex e09a9d9af9dd..735dfb47b863 100644\n--- a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java\n+++ b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/handler/ContextHandler.java\n@@ -589,11 +589,11 @@ public boolean addEventListener(EventListener listener)\n     {\n         if (super.addEventListener(listener))\n         {\n-            if (listener instanceof ContextScopeListener)\n+            if (listener instanceof ContextScopeListener contextScopeListener)\n             {\n-                _contextListeners.add((ContextScopeListener)listener);\n+                _contextListeners.add(contextScopeListener);\n                 if (__context.get() != null)\n-                    ((ContextScopeListener)listener).enterScope(__context.get(), null);\n+                    contextScopeListener.enterScope(__context.get(), null);\n             }\n             return true;\n         }\n@@ -605,9 +605,12 @@ public boolean removeEventListener(EventListener listener)\n     {\n         if (super.removeEventListener(listener))\n         {\n-            if (listener instanceof ContextScopeListener)\n-                _contextListeners.remove(listener);\n-\n+            if (listener instanceof ContextScopeListener contextScopeListener)\n+            {\n+                _contextListeners.remove(contextScopeListener);\n+                if (__context.get() != null)\n+                    contextScopeListener.exitScope(__context.get(), null);\n+            }\n             return true;\n         }\n         return false;\n@@ -1053,6 +1056,7 @@ public boolean handle(Request request, Response response, Callback callback) thr\n             return true;\n \n         // Past this point we are calling the downstream handler in scope.\n+        Context lastContext = getCurrentContext();\n         ClassLoader lastLoader = enterScope(contextRequest);\n         ContextResponse contextResponse = wrapResponse(contextRequest, response);\n         try\n@@ -1068,7 +1072,7 @@ public boolean handle(Request request, Response response, Callback callback) thr\n         {\n             // We exit scope here, even though handle() is asynchronous,\n             // as we have wrapped all our callbacks to re-enter the scope.\n-            exitScope(contextRequest, request.getContext(), lastLoader);\n+            exitScope(contextRequest, lastContext, lastLoader);\n         }\n     }\n \n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/HttpOutput.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/HttpOutput.java\nindex 83c960d4271c..baf55e2ac821 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/HttpOutput.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/HttpOutput.java\n@@ -140,6 +140,7 @@ enum ApiState\n     private WriteListener _writeListener;\n     private volatile Throwable _onError;\n     private Callback _closedCallback;\n+    private long _applicationContentLength = -1;\n \n     public HttpOutput(ServletChannel channel)\n     {\n@@ -174,6 +175,46 @@ public long getWritten()\n         return _written;\n     }\n \n+    /**\n+     * Set the content-length as set by the application.  This may not be the actual content length if compression or\n+     * similar handlers are used.\n+     * @param len The content-length as set by the application.\n+     */\n+    public void setApplicationContentLength(long len)\n+    {\n+        _applicationContentLength = len;\n+    }\n+\n+    /**\n+     * Get the content-length as set by the application.  This may not be the actual content length if compression or\n+     * similar handlers are used.\n+     * @return The content-length as set by the application.\n+     */\n+    public long getApplicationContentLength()\n+    {\n+        return _applicationContentLength;\n+    }\n+\n+    /**\n+     * @return {@code true} if a Content-Length has been set and insufficient content has been written.\n+     */\n+    public boolean isContentIncomplete()\n+    {\n+        long applicationContentLength = _applicationContentLength;\n+        return applicationContentLength >= 0 && _written < applicationContentLength;\n+    }\n+\n+    private boolean isAllContentWritten(long written)\n+    {\n+        if (_applicationContentLength >= 0)\n+        {\n+            if (written > _applicationContentLength)\n+                throw new IllegalStateException(\""too much content written\"");\n+            return written == _applicationContentLength;\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Used by ServletCoreResponse when it bypasses HttpOutput to update bytes written.\n      * @param written The bytes written\n@@ -352,7 +393,7 @@ public void complete(Callback callback)\n \n                 case PENDING: // an async write is pending and may complete at any time\n                     // If this is not the last write, then we must abort\n-                    if (_servletChannel.getServletContextResponse().isContentIncomplete(_written))\n+                    if (isContentIncomplete())\n                         error = new CancellationException(\""Completed whilst write pending\"");\n                     break;\n \n@@ -448,9 +489,9 @@ public void complete(Callback callback)\n     /**\n      * Called to indicate that the request cycle has been completed.\n      */\n-    public void completed(Throwable failure)\n+    public void completed(Throwable ignored)\n     {\n-        try (AutoLock ignored = _channelState.lock())\n+        try (AutoLock ignoredLock = _channelState.lock())\n         {\n             _state = State.CLOSED;\n             lockedReleaseBuffer();\n@@ -733,7 +774,10 @@ public void write(byte[] b, int off, int len) throws IOException\n             checkWritable();\n             long written = _written + len;\n             int space = maximizeAggregateSpace();\n-            last = _servletChannel.getServletContextResponse().isAllContentWritten(written);\n+\n+            // Is this the last write due to content-length?\n+            last = isAllContentWritten(written);\n+\n             // Write will be aggregated if:\n             //  + it is smaller than the commitSize\n             //  + is not the last one, or is last but will fit in an already allocated aggregate buffer.\n@@ -867,7 +911,10 @@ public void write(ByteBuffer buffer) throws IOException\n         {\n             checkWritable();\n             long written = _written + len;\n-            last = _servletChannel.getServletContextResponse().isAllContentWritten(written);\n+\n+            // Is this the last write due to content-length?\n+            last = isAllContentWritten(written);\n+\n             flush = last || len > 0 || (_aggregate != null && _aggregate.hasRemaining());\n \n             if (last && _state == State.OPEN)\n@@ -947,7 +994,10 @@ public void write(int b) throws IOException\n             checkWritable();\n             long written = _written + 1;\n             int space = maximizeAggregateSpace();\n-            last = _servletChannel.getServletContextResponse().isAllContentWritten(written);\n+\n+            // Is this the last write due to content-length?\n+            last = isAllContentWritten(written);\n+\n             flush = last || space == 1;\n \n             if (last && _state == State.OPEN)\n@@ -1269,6 +1319,7 @@ public void recycle()\n             _onError = null;\n             _firstByteNanoTime = -1;\n             _closedCallback = null;\n+            _applicationContentLength = -1;\n         }\n     }\n \n@@ -1279,6 +1330,7 @@ public void resetBuffer()\n             if (_aggregate != null)\n                 _aggregate.clear();\n             _written = 0;\n+            _applicationContentLength = -1;\n         }\n     }\n \n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletApiResponse.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletApiResponse.java\nindex c7e6d755be3b..1c53063dc7f4 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletApiResponse.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletApiResponse.java\n@@ -350,12 +350,18 @@ public void setContentLengthLong(long len)\n         if (isCommitted())\n             return;\n \n-        if (len > 0)\n-            getResponse().getHeaders().put(HttpHeader.CONTENT_LENGTH, len);\n-        else if (len == 0)\n-            getResponse().getHeaders().put(HttpFields.CONTENT_LENGTH_0);\n+        if (len >= 0)\n+        {\n+            getServletChannel().getHttpOutput().setApplicationContentLength(len);\n+            if (len > 0)\n+                getResponse().getHeaders().put(HttpHeader.CONTENT_LENGTH, len);\n+            else\n+                getResponse().getHeaders().put(HttpFields.CONTENT_LENGTH_0);\n+        }\n         else\n+        {\n             getResponse().getHeaders().remove(HttpHeader.CONTENT_LENGTH);\n+        }\n     }\n \n     @Override\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java\nindex 12e2b7967a40..8a81323cfb6c 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletChannel.java\n@@ -78,6 +78,7 @@ public class ServletChannel\n     private Request _request;\n     private Response _response;\n     private Callback _callback;\n+    private boolean _completeAttempted;\n \n     public ServletChannel(ServletContextHandler servletContextHandler, Request request)\n     {\n@@ -396,6 +397,7 @@ void recycle(Throwable x)\n         _request = null;\n         _response = null;\n         _callback = null;\n+        _completeAttempted = false;\n     }\n \n     /**\n@@ -564,14 +566,19 @@ public void handle()\n                         {\n                             // Compare the bytes written by the application, even if\n                             // they might be compressed (or changed) by child Handlers.\n-                            long written = response.getContentBytesWritten();\n-                            if (response.isContentIncomplete(written))\n+                            if (getHttpOutput().isContentIncomplete())\n                             {\n-                                sendErrorOrAbort(\""Insufficient content written %d < %d\"".formatted(written, response.getContentLength()));\n+                                String message = \""Insufficient content written %d < %d\"".formatted(getHttpOutput().getWritten(), getHttpOutput().getApplicationContentLength());\n+                                if (isCommitted() || _completeAttempted)\n+                                    abort(new IOException(message));\n+                                else\n+                                    getServletContextResponse().getServletApiResponse().sendError(HttpStatus.INTERNAL_SERVER_ERROR_500, message);\n                                 break;\n                             }\n                         }\n \n+                        _completeAttempted = true;\n+\n                         // Set a close callback on the HttpOutput to make it an async callback\n                         response.completeOutput(Callback.from(NON_BLOCKING, () -> _state.completed(null), _state::completed));\n                         break;\n@@ -602,31 +609,6 @@ private void reopen()\n         getHttpOutput().reopen();\n     }\n \n-    /**\n-     * @param message the error message.\n-     * @return true if we have sent an error, false if we have aborted.\n-     */\n-    private boolean sendErrorOrAbort(String message)\n-    {\n-        try\n-        {\n-            if (isCommitted())\n-            {\n-                abort(new IOException(message));\n-                return false;\n-            }\n-\n-            getServletContextResponse().getServletApiResponse().sendError(HttpStatus.INTERNAL_SERVER_ERROR_500, message);\n-            return true;\n-        }\n-        catch (Throwable x)\n-        {\n-            LOG.trace(\""IGNORED\"", x);\n-            abort(x);\n-        }\n-        return false;\n-    }\n-\n     /**\n      * <p>Sends an error 500, performing a special logic to detect whether the request is suspended,\n      * to avoid concurrent writes from the application.</p>\n@@ -664,7 +646,7 @@ else if (noStack != null)\n         try\n         {\n             boolean abort = _state.onError(failure);\n-            if (abort)\n+            if (abort || _completeAttempted)\n                 abort(failure);\n         }\n         catch (Throwable x)\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextResponse.java b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextResponse.java\nindex 975bc2933602..1a5894cdbde0 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextResponse.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/main/java/org/eclipse/jetty/ee10/servlet/ServletContextResponse.java\n@@ -34,11 +34,9 @@\n import org.eclipse.jetty.http.HttpStatus;\n import org.eclipse.jetty.http.HttpVersion;\n import org.eclipse.jetty.http.MimeTypes;\n-import org.eclipse.jetty.io.RuntimeIOException;\n import org.eclipse.jetty.server.Response;\n import org.eclipse.jetty.server.handler.ContextResponse;\n import org.eclipse.jetty.session.ManagedSession;\n-import org.eclipse.jetty.util.BufferUtil;\n import org.eclipse.jetty.util.Callback;\n \n /**\n@@ -64,9 +62,7 @@ public enum OutputType\n     private EncodingFrom _encodingFrom = EncodingFrom.NOT_SET;\n     private OutputType _outputType = OutputType.NONE;\n     private ResponseWriter _writer;\n-    private long _contentLength = -1;\n     private Supplier<Map<String, String>> _trailers;\n-    private long _written;\n \n     public static ServletContextResponse getServletContextResponse(ServletResponse response)\n     {\n@@ -216,93 +212,18 @@ public void completeOutput(Callback callback)\n         getHttpOutput().complete(callback);\n     }\n \n-    public boolean isAllContentWritten(long written)\n-    {\n-        return (_contentLength >= 0 && written >= _contentLength);\n-    }\n-\n-    public boolean isContentIncomplete(long written)\n-    {\n-        return (_contentLength >= 0 && written < _contentLength);\n-    }\n-\n-    public void setContentLength(int len)\n-    {\n-        setContentLength((long)len);\n-    }\n-\n     @Override\n     public HttpFields.Mutable getHeaders()\n     {\n         return _headers;\n     }\n \n-    public void setContentLength(long len)\n-    {\n-        // Protect from setting after committed as default handling\n-        // of a servlet HEAD request ALWAYS sets _content length, even\n-        // if the getHandling committed the response!\n-        if (isCommitted())\n-            return;\n-\n-        if (len > 0)\n-        {\n-            long written = getHttpOutput().getWritten();\n-            if (written > len)\n-                throw new IllegalArgumentException(\""setContentLength(\"" + len + \"") when already written \"" + written);\n-\n-            _contentLength = len;\n-            getHeaders().put(HttpHeader.CONTENT_LENGTH, len);\n-            if (isAllContentWritten(written))\n-            {\n-                try\n-                {\n-                    closeOutput();\n-                }\n-                catch (IOException e)\n-                {\n-                    throw new RuntimeIOException(e);\n-                }\n-            }\n-        }\n-        else if (len == 0)\n-        {\n-            long written = getHttpOutput().getWritten();\n-            if (written > 0)\n-                throw new IllegalArgumentException(\""setContentLength(0) when already written \"" + written);\n-            _contentLength = len;\n-            getHeaders().put(HttpFields.CONTENT_LENGTH_0);\n-        }\n-        else\n-        {\n-            _contentLength = len;\n-            getHeaders().remove(HttpHeader.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    public long getContentLength()\n-    {\n-        return _contentLength;\n-    }\n-\n     @Override\n     public void write(boolean last, ByteBuffer content, Callback callback)\n     {\n-        _written += BufferUtil.length(content);\n         super.write(last, content, callback);\n     }\n \n-    /**\n-     * <p>Returns the number of bytes written via this class {@link #write(boolean, ByteBuffer, Callback)} method.</p>\n-     * <p>The number of bytes written to the network may be different.</p>\n-     *\n-     * @return the number of bytes written via this class {@link #write(boolean, ByteBuffer, Callback)} method.\n-     */\n-    long getContentBytesWritten()\n-    {\n-        return _written;\n-    }\n-\n     public void closeOutput() throws IOException\n     {\n         if (_outputType == OutputType.WRITER)\n@@ -318,7 +239,6 @@ public void reset()\n \n         _servletApiResponse.resetBuffer();\n         _outputType = OutputType.NONE;\n-        _contentLength = -1;\n         _contentType = null;\n         _mimeType = null;\n         _characterEncoding = null;\n@@ -379,7 +299,6 @@ public void resetContent()\n             throw new IllegalStateException(\""Committed\"");\n         getHttpOutput().resetBuffer();\n         _outputType = OutputType.NONE;\n-        _contentLength = -1;\n         _contentType = null;\n         _mimeType = null;\n         _characterEncoding = null;\n@@ -573,7 +492,6 @@ public HttpField onAddField(HttpField field)\n \n             return switch (field.getHeader())\n             {\n-                case CONTENT_LENGTH -> setContentLength(field);\n                 case CONTENT_TYPE -> setContentType(field);\n                 default -> super.onAddField(field);\n             };\n@@ -584,23 +502,17 @@ public boolean onRemoveField(HttpField field)\n         {\n             if (isCommitted())\n                 return false;\n-            if (field.getHeader() == null)\n-                return true;\n-            switch (field.getHeader())\n+            if (field.getHeader() == HttpHeader.CONTENT_TYPE)\n             {\n-                case CONTENT_LENGTH -> _contentLength = -1;\n-                case CONTENT_TYPE ->\n+                _contentType = null;\n+                _mimeType = null;\n+                if (!isWriting())\n                 {\n-                    _contentType = null;\n-                    _mimeType = null;\n-                    if (!isWriting())\n+                    _characterEncoding = switch (_encodingFrom)\n                     {\n-                        _characterEncoding = switch (_encodingFrom)\n-                        {\n-                            case SET_CHARACTER_ENCODING, SET_LOCALE -> _characterEncoding;\n-                            default -> null;\n-                        };\n-                    }\n+                        case SET_CHARACTER_ENCODING, SET_LOCALE -> _characterEncoding;\n+                        default -> null;\n+                    };\n                 }\n             }\n \n@@ -618,39 +530,7 @@ public HttpField onReplaceField(HttpField oldField, HttpField newField)\n             if (newField.getHeader() == null)\n                 return newField;\n \n-            return switch (newField.getHeader())\n-            {\n-                case CONTENT_LENGTH -> setContentLength(newField);\n-                case CONTENT_TYPE -> setContentType(newField);\n-                default -> newField;\n-            };\n-        }\n-\n-        private HttpField setContentLength(HttpField field)\n-        {\n-            long len = field.getLongValue();\n-            long written = _servletChannel.getHttpOutput().getWritten();\n-\n-            if (len > 0 && written > len)\n-                throw new IllegalArgumentException(\""setContentLength(\"" + len + \"") when already written \"" + written);\n-            if (len == 0 && written > 0)\n-                throw new IllegalArgumentException(\""setContentLength(0) when already written \"" + written);\n-\n-            _contentLength = len;\n-\n-            if (len > 0 && isAllContentWritten(written))\n-            {\n-                try\n-                {\n-                    closeOutput();\n-                }\n-                catch (IOException e)\n-                {\n-                    throw new RuntimeIOException(e);\n-                }\n-            }\n-\n-            return field;\n+            return newField.getHeader() == HttpHeader.CONTENT_TYPE ?  setContentType(newField) : newField;\n         }\n \n         private HttpField setContentType(HttpField field)\n\ndiff --git a/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/HttpOutput.java b/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/HttpOutput.java\nindex 344c36aeb431..af7890f70302 100644\n--- a/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/HttpOutput.java\n+++ b/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/HttpOutput.java\n@@ -140,6 +140,7 @@ enum ApiState\n     private WriteListener _writeListener;\n     private volatile Throwable _onError;\n     private Callback _closedCallback;\n+    private long _applicationContentLength = -1;\n \n     public HttpOutput(ServletChannel channel)\n     {\n@@ -174,6 +175,46 @@ public long getWritten()\n         return _written;\n     }\n \n+    /**\n+     * Set the content-length as set by the application.  This may not be the actual content length if compression or\n+     * similar handlers are used.\n+     * @param len The content-length as set by the application.\n+     */\n+    public void setApplicationContentLength(long len)\n+    {\n+        _applicationContentLength = len;\n+    }\n+\n+    /**\n+     * Get the content-length as set by the application.  This may not be the actual content length if compression or\n+     * similar handlers are used.\n+     * @return The content-length as set by the application.\n+     */\n+    public long getApplicationContentLength()\n+    {\n+        return _applicationContentLength;\n+    }\n+\n+    /**\n+     * @return {@code true} if a Content-Length has been set and insufficient content has been written.\n+     */\n+    public boolean isContentIncomplete()\n+    {\n+        long applicationContentLength = _applicationContentLength;\n+        return applicationContentLength >= 0 && _written < applicationContentLength;\n+    }\n+\n+    private boolean isAllContentWritten(long written)\n+    {\n+        if (_applicationContentLength >= 0)\n+        {\n+            if (written > _applicationContentLength)\n+                throw new IllegalStateException(\""too much content written\"");\n+            return written == _applicationContentLength;\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Used by ServletCoreResponse when it bypasses HttpOutput to update bytes written.\n      * @param written The bytes written\n@@ -365,7 +406,7 @@ public void complete(Callback callback)\n \n                 case PENDING: // an async write is pending and may complete at any time\n                     // If this is not the last write, then we must abort\n-                    if (_servletChannel.getServletContextResponse().isContentIncomplete(_written))\n+                    if (isContentIncomplete())\n                         error = new CancellationException(\""Completed whilst write pending\"");\n                     break;\n \n@@ -461,9 +502,9 @@ public void complete(Callback callback)\n     /**\n      * Called to indicate that the request cycle has been completed.\n      */\n-    public void completed(Throwable failure)\n+    public void completed(Throwable ignored)\n     {\n-        try (AutoLock ignored = _channelState.lock())\n+        try (AutoLock ignoredLock = _channelState.lock())\n         {\n             _state = State.CLOSED;\n             lockedReleaseBuffer();\n@@ -746,7 +787,10 @@ public void write(byte[] b, int off, int len) throws IOException\n             checkWritable();\n             long written = _written + len;\n             int space = maximizeAggregateSpace();\n-            last = _servletChannel.getServletContextResponse().isAllContentWritten(written);\n+\n+            // Is this the last write due to content-length?\n+            last = isAllContentWritten(written);\n+\n             // Write will be aggregated if:\n             //  + it is smaller than the commitSize\n             //  + is not the last one, or is last but will fit in an already allocated aggregate buffer.\n@@ -880,7 +924,10 @@ public void write(ByteBuffer buffer) throws IOException\n         {\n             checkWritable();\n             long written = _written + len;\n-            last = _servletChannel.getServletContextResponse().isAllContentWritten(written);\n+\n+            // Is this the last write due to content-length?\n+            last = isAllContentWritten(written);\n+\n             flush = last || len > 0 || (_aggregate != null && _aggregate.hasRemaining());\n \n             if (last && _state == State.OPEN)\n@@ -960,7 +1007,10 @@ public void write(int b) throws IOException\n             checkWritable();\n             long written = _written + 1;\n             int space = maximizeAggregateSpace();\n-            last = _servletChannel.getServletContextResponse().isAllContentWritten(written);\n+\n+            // Is this the last write due to content-length?\n+            last = isAllContentWritten(written);\n+\n             flush = last || space == 1;\n \n             if (last && _state == State.OPEN)\n@@ -1282,6 +1332,7 @@ public void recycle()\n             _onError = null;\n             _firstByteNanoTime = -1;\n             _closedCallback = null;\n+            _applicationContentLength = -1;\n         }\n     }\n \n@@ -1292,6 +1343,7 @@ public void resetBuffer()\n             if (_aggregate != null)\n                 _aggregate.clear();\n             _written = 0;\n+            _applicationContentLength = -1;\n         }\n     }\n \n\ndiff --git a/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletApiResponse.java b/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletApiResponse.java\nindex 971872c3b425..e7472e9d3eb6 100644\n--- a/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletApiResponse.java\n+++ b/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletApiResponse.java\n@@ -387,12 +387,18 @@ public void setContentLengthLong(long len)\n         if (isCommitted())\n             return;\n \n-        if (len > 0)\n-            getResponse().getHeaders().put(HttpHeader.CONTENT_LENGTH, len);\n-        else if (len == 0)\n-            getResponse().getHeaders().put(HttpFields.CONTENT_LENGTH_0);\n+        if (len >= 0)\n+        {\n+            getServletChannel().getHttpOutput().setApplicationContentLength(len);\n+            if (len > 0)\n+                getResponse().getHeaders().put(HttpHeader.CONTENT_LENGTH, len);\n+            else\n+                getResponse().getHeaders().put(HttpFields.CONTENT_LENGTH_0);\n+        }\n         else\n+        {\n             getResponse().getHeaders().remove(HttpHeader.CONTENT_LENGTH);\n+        }\n     }\n \n     @Override\n\ndiff --git a/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletChannel.java b/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletChannel.java\nindex 99f2f572ddab..e34946c9bf22 100644\n--- a/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletChannel.java\n+++ b/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletChannel.java\n@@ -79,6 +79,7 @@ public class ServletChannel\n     private Request _request;\n     private Response _response;\n     private Callback _callback;\n+    private boolean _completeAttempted;\n \n     public ServletChannel(ServletContextHandler servletContextHandler, Request request)\n     {\n@@ -397,6 +398,7 @@ void recycle(Throwable x)\n         _request = null;\n         _response = null;\n         _callback = null;\n+        _completeAttempted = false;\n     }\n \n     /**\n@@ -565,14 +567,19 @@ public void handle()\n                         {\n                             // Compare the bytes written by the application, even if\n                             // they might be compressed (or changed) by child Handlers.\n-                            long written = response.getContentBytesWritten();\n-                            if (response.isContentIncomplete(written))\n+                            if (getHttpOutput().isContentIncomplete())\n                             {\n-                                sendErrorOrAbort(\""Insufficient content written %d < %d\"".formatted(written, response.getContentLength()));\n+                                String message = \""Insufficient content written %d < %d\"".formatted(getHttpOutput().getWritten(), getHttpOutput().getApplicationContentLength());\n+                                if (isCommitted() || _completeAttempted)\n+                                    abort(new IOException(message));\n+                                else\n+                                    getServletContextResponse().getServletApiResponse().sendError(HttpStatus.INTERNAL_SERVER_ERROR_500, message);\n                                 break;\n                             }\n                         }\n \n+                        _completeAttempted = true;\n+\n                         // Set a close callback on the HttpOutput to make it an async callback\n                         response.completeOutput(Callback.from(NON_BLOCKING, () -> _state.completed(null), _state::completed));\n                         break;\n@@ -603,31 +610,6 @@ private void reopen()\n         getHttpOutput().reopen();\n     }\n \n-    /**\n-     * @param message the error message.\n-     * @return true if we have sent an error, false if we have aborted.\n-     */\n-    private boolean sendErrorOrAbort(String message)\n-    {\n-        try\n-        {\n-            if (isCommitted())\n-            {\n-                abort(new IOException(message));\n-                return false;\n-            }\n-\n-            getServletContextResponse().getServletApiResponse().sendError(HttpStatus.INTERNAL_SERVER_ERROR_500, message);\n-            return true;\n-        }\n-        catch (Throwable x)\n-        {\n-            LOG.trace(\""IGNORED\"", x);\n-            abort(x);\n-        }\n-        return false;\n-    }\n-\n     /**\n      * <p>Sends an error 500, performing a special logic to detect whether the request is suspended,\n      * to avoid concurrent writes from the application.</p>\n@@ -665,7 +647,7 @@ else if (noStack != null)\n         try\n         {\n             boolean abort = _state.onError(failure);\n-            if (abort)\n+            if (abort || _completeAttempted)\n                 abort(failure);\n         }\n         catch (Throwable x)\n\ndiff --git a/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletContextResponse.java b/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletContextResponse.java\nindex 3c83c20304be..3c7698c8850d 100644\n--- a/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletContextResponse.java\n+++ b/jetty-ee11/jetty-ee11-servlet/src/main/java/org/eclipse/jetty/ee11/servlet/ServletContextResponse.java\n@@ -34,11 +34,9 @@\n import org.eclipse.jetty.http.HttpStatus;\n import org.eclipse.jetty.http.HttpVersion;\n import org.eclipse.jetty.http.MimeTypes;\n-import org.eclipse.jetty.io.RuntimeIOException;\n import org.eclipse.jetty.server.Response;\n import org.eclipse.jetty.server.handler.ContextResponse;\n import org.eclipse.jetty.session.ManagedSession;\n-import org.eclipse.jetty.util.BufferUtil;\n import org.eclipse.jetty.util.Callback;\n \n /**\n@@ -64,9 +62,7 @@ public enum OutputType\n     private EncodingFrom _encodingFrom = EncodingFrom.NOT_SET;\n     private OutputType _outputType = OutputType.NONE;\n     private ResponseWriter _writer;\n-    private long _contentLength = -1;\n     private Supplier<Map<String, String>> _trailers;\n-    private long _written;\n \n     public static ServletContextResponse getServletContextResponse(ServletResponse response)\n     {\n@@ -216,93 +212,18 @@ public void completeOutput(Callback callback)\n         getHttpOutput().complete(callback);\n     }\n \n-    public boolean isAllContentWritten(long written)\n-    {\n-        return (_contentLength >= 0 && written >= _contentLength);\n-    }\n-\n-    public boolean isContentIncomplete(long written)\n-    {\n-        return (_contentLength >= 0 && written < _contentLength);\n-    }\n-\n-    public void setContentLength(int len)\n-    {\n-        setContentLength((long)len);\n-    }\n-\n     @Override\n     public HttpFields.Mutable getHeaders()\n     {\n         return _headers;\n     }\n \n-    public void setContentLength(long len)\n-    {\n-        // Protect from setting after committed as default handling\n-        // of a servlet HEAD request ALWAYS sets _content length, even\n-        // if the getHandling committed the response!\n-        if (isCommitted())\n-            return;\n-\n-        if (len > 0)\n-        {\n-            long written = getHttpOutput().getWritten();\n-            if (written > len)\n-                throw new IllegalArgumentException(\""setContentLength(\"" + len + \"") when already written \"" + written);\n-\n-            _contentLength = len;\n-            getHeaders().put(HttpHeader.CONTENT_LENGTH, len);\n-            if (isAllContentWritten(written))\n-            {\n-                try\n-                {\n-                    closeOutput();\n-                }\n-                catch (IOException e)\n-                {\n-                    throw new RuntimeIOException(e);\n-                }\n-            }\n-        }\n-        else if (len == 0)\n-        {\n-            long written = getHttpOutput().getWritten();\n-            if (written > 0)\n-                throw new IllegalArgumentException(\""setContentLength(0) when already written \"" + written);\n-            _contentLength = len;\n-            getHeaders().put(HttpFields.CONTENT_LENGTH_0);\n-        }\n-        else\n-        {\n-            _contentLength = len;\n-            getHeaders().remove(HttpHeader.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    public long getContentLength()\n-    {\n-        return _contentLength;\n-    }\n-\n     @Override\n     public void write(boolean last, ByteBuffer content, Callback callback)\n     {\n-        _written += BufferUtil.length(content);\n         super.write(last, content, callback);\n     }\n \n-    /**\n-     * <p>Returns the number of bytes written via this class {@link #write(boolean, ByteBuffer, Callback)} method.</p>\n-     * <p>The number of bytes written to the network may be different.</p>\n-     *\n-     * @return the number of bytes written via this class {@link #write(boolean, ByteBuffer, Callback)} method.\n-     */\n-    long getContentBytesWritten()\n-    {\n-        return _written;\n-    }\n-\n     public void closeOutput() throws IOException\n     {\n         if (_outputType == OutputType.WRITER)\n@@ -318,7 +239,6 @@ public void reset()\n \n         _servletApiResponse.resetBuffer();\n         _outputType = OutputType.NONE;\n-        _contentLength = -1;\n         _contentType = null;\n         _mimeType = null;\n         _characterEncoding = null;\n@@ -379,7 +299,6 @@ public void resetContent()\n             throw new IllegalStateException(\""Committed\"");\n         getHttpOutput().resetBuffer();\n         _outputType = OutputType.NONE;\n-        _contentLength = -1;\n         _contentType = null;\n         _mimeType = null;\n         _characterEncoding = null;\n@@ -573,7 +492,6 @@ public HttpField onAddField(HttpField field)\n \n             return switch (field.getHeader())\n             {\n-                case CONTENT_LENGTH -> setContentLength(field);\n                 case CONTENT_TYPE -> setContentType(field);\n                 default -> super.onAddField(field);\n             };\n@@ -584,23 +502,17 @@ public boolean onRemoveField(HttpField field)\n         {\n             if (isCommitted())\n                 return false;\n-            if (field.getHeader() == null)\n-                return true;\n-            switch (field.getHeader())\n+            if (field.getHeader() == HttpHeader.CONTENT_TYPE)\n             {\n-                case CONTENT_LENGTH -> _contentLength = -1;\n-                case CONTENT_TYPE ->\n+                _contentType = null;\n+                _mimeType = null;\n+                if (!isWriting())\n                 {\n-                    _contentType = null;\n-                    _mimeType = null;\n-                    if (!isWriting())\n+                    _characterEncoding = switch (_encodingFrom)\n                     {\n-                        _characterEncoding = switch (_encodingFrom)\n-                        {\n-                            case SET_CHARACTER_ENCODING, SET_LOCALE -> _characterEncoding;\n-                            default -> null;\n-                        };\n-                    }\n+                        case SET_CHARACTER_ENCODING, SET_LOCALE -> _characterEncoding;\n+                        default -> null;\n+                    };\n                 }\n             }\n \n@@ -618,39 +530,7 @@ public HttpField onReplaceField(HttpField oldField, HttpField newField)\n             if (newField.getHeader() == null)\n                 return newField;\n \n-            return switch (newField.getHeader())\n-            {\n-                case CONTENT_LENGTH -> setContentLength(newField);\n-                case CONTENT_TYPE -> setContentType(newField);\n-                default -> newField;\n-            };\n-        }\n-\n-        private HttpField setContentLength(HttpField field)\n-        {\n-            long len = field.getLongValue();\n-            long written = _servletChannel.getHttpOutput().getWritten();\n-\n-            if (len > 0 && written > len)\n-                throw new IllegalArgumentException(\""setContentLength(\"" + len + \"") when already written \"" + written);\n-            if (len == 0 && written > 0)\n-                throw new IllegalArgumentException(\""setContentLength(0) when already written \"" + written);\n-\n-            _contentLength = len;\n-\n-            if (len > 0 && isAllContentWritten(written))\n-            {\n-                try\n-                {\n-                    closeOutput();\n-                }\n-                catch (IOException e)\n-                {\n-                    throw new RuntimeIOException(e);\n-                }\n-            }\n-\n-            return field;\n+            return newField.getHeader() == HttpHeader.CONTENT_TYPE ?  setContentType(newField) : newField;\n         }\n \n         private HttpField setContentType(HttpField field)\n"", ""test_patch"": ""diff --git a/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/ContextScopeListenerTest.java b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/ContextScopeListenerTest.java\nindex bdd08253fdfc..8df88e4d199d 100644\n--- a/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/ContextScopeListenerTest.java\n+++ b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/ContextScopeListenerTest.java\n@@ -201,7 +201,7 @@ public void exitScope(Context context, Request request)\n         ContentResponse response = _client.GET(uri);\n         assertThat(response.getStatus(), equalTo(HttpStatus.OK_200));\n \n-        Awaitility.waitAtMost(5, TimeUnit.SECONDS).pollInterval(100, TimeUnit.MILLISECONDS).until(() -> _history.size() == 9);\n+        Awaitility.waitAtMost(5, TimeUnit.SECONDS).pollInterval(100, TimeUnit.MILLISECONDS).until(() -> _history.size() >= 9);\n         assertHistory(\n             \""enterScope /initialPath\"",\n             \""doGet\"",\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/HttpOutputTest.java b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/HttpOutputTest.java\nnew file mode 100644\nindex 000000000000..690d1ba9b188\n--- /dev/null\n+++ b/jetty-ee10/jetty-ee10-servlet/src/test/java/org/eclipse/jetty/ee10/servlet/HttpOutputTest.java\n@@ -0,0 +1,1299 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.ee10.servlet;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintWriter;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import jakarta.servlet.AsyncContext;\n+import jakarta.servlet.ServletException;\n+import jakarta.servlet.WriteListener;\n+import jakarta.servlet.http.HttpServlet;\n+import jakarta.servlet.http.HttpServletRequest;\n+import jakarta.servlet.http.HttpServletResponse;\n+import org.eclipse.jetty.io.ByteBufferPool;\n+import org.eclipse.jetty.io.IOResources;\n+import org.eclipse.jetty.server.HttpConnectionFactory;\n+import org.eclipse.jetty.server.LocalConnector;\n+import org.eclipse.jetty.server.LocalConnector.LocalEndPoint;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.FuturePromise;\n+import org.eclipse.jetty.util.IO;\n+import org.eclipse.jetty.util.resource.Resource;\n+import org.eclipse.jetty.util.resource.ResourceFactory;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.endsWith;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ *\n+ */\n+public class HttpOutputTest\n+{\n+    public static final int OUTPUT_AGGREGATION_SIZE = 1024;\n+    public static final int OUTPUT_BUFFER_SIZE = 4096;\n+    private Server _server;\n+    private ServletContextHandler _servletContextHandler;\n+    private LocalConnector _connector;\n+    private ContentServlet _contentServlet;\n+\n+    @BeforeEach\n+    public void init() throws Exception\n+    {\n+        _server = new Server();\n+        _servletContextHandler = new ServletContextHandler(\""/\"");\n+\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+        http.getHttpConfiguration().setRequestHeaderSize(1024);\n+        http.getHttpConfiguration().setResponseHeaderSize(1024);\n+        http.getHttpConfiguration().setOutputBufferSize(OUTPUT_BUFFER_SIZE);\n+        http.getHttpConfiguration().setOutputAggregationSize(OUTPUT_AGGREGATION_SIZE);\n+\n+        _connector = new LocalConnector(_server, http, null);\n+        _server.addConnector(_connector);\n+        _server.setHandler(_servletContextHandler);\n+\n+        _contentServlet = new ContentServlet();\n+        _servletContextHandler.addServlet(_contentServlet, \""/*\"");\n+    }\n+\n+    @AfterEach\n+    public void destroy() throws Exception\n+    {\n+        IO.close(_contentServlet._contentInputStream);\n+        IO.close(_contentServlet._contentChannel);\n+        _server.stop();\n+        _server.join();\n+    }\n+\n+    @Test\n+    public void testSimple() throws Exception\n+    {\n+        _server.start();\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+    }\n+\n+    @Test\n+    public void testSendContentByteBuffer() throws Exception\n+    {\n+        _server.start();\n+        byte[] buffer = new byte[16 * 1024];\n+        Arrays.fill(buffer, 0, 4 * 1024, (byte)0x99);\n+        Arrays.fill(buffer, 4 * 1024, 12 * 1024, (byte)0x58);\n+        Arrays.fill(buffer, 12 * 1024, 16 * 1024, (byte)0x66);\n+        _contentServlet._content = ByteBuffer.wrap(buffer);\n+        _contentServlet._content.limit(12 * 1024);\n+        _contentServlet._content.position(4 * 1024);\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""\\r\\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\""));\n+\n+        for (int i = 0; i < 4 * 1024; i++)\n+        {\n+            assertEquals((byte)0x99, buffer[i], \""i=\"" + i);\n+        }\n+        for (int i = 12 * 1024; i < 16 * 1024; i++)\n+        {\n+            assertEquals((byte)0x66, buffer[i], \""i=\"" + i);\n+        }\n+    }\n+\n+    @Test\n+    public void testSendInputStreamSimple() throws Exception\n+    {\n+        _server.start();\n+        Resource simple = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/simple.txt\"", false);\n+        _contentServlet._contentInputStream = IOResources.asInputStream(simple);\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 11\""));\n+    }\n+\n+    @Test\n+    public void testSendInputStreamBig() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._contentInputStream = IOResources.asInputStream(big);\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testSendInputStreamBigChunked() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._contentInputStream = new FilterInputStream(IOResources.asInputStream(big))\n+        {\n+            @Override\n+            public int read(byte[] b, int off, int len) throws IOException\n+            {\n+                return super.read(b, off, Math.min(len, 2000));\n+            }\n+        };\n+        LocalEndPoint endp = _connector.executeRequest(\n+            \""\""\""\n+                GET / HTTP/1.1\n+                Host: localhost:80\n+                \n+                \""\""\"");\n+\n+        String response = endp.getResponse();\n+\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Transfer-Encoding: chunked\""));\n+        assertThat(response, containsString(\""1\\tThis is a big file\""));\n+        assertThat(response, containsString(\""400\\tThis is a big file\""));\n+        assertThat(response, containsString(\""\\r\\n0\\r\\n\""));\n+\n+        endp.close();\n+    }\n+\n+    @Test\n+    public void testSendChannelSimple() throws Exception\n+    {\n+        _server.start();\n+        Resource simple = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/simple.txt\"", false);\n+        _contentServlet._contentChannel = Files.newByteChannel(simple.getPath());\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 11\""));\n+    }\n+\n+    @Test\n+    public void testSendChannelBig() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._contentChannel = Files.newByteChannel(big.getPath());\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testSendResourceSimple() throws Exception\n+    {\n+        _server.start();\n+        Resource simple = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/simple.txt\"", false);\n+        _contentServlet._contentResource = simple;\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 11\""));\n+        assertThat(response, endsWith(toUTF8String(simple)));\n+    }\n+\n+    @Test\n+    public void testSendResourceBig() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._contentResource = big;\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testSendBigDirect() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testSendBigInDirect() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testSendChannelBigChunked() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        final ReadableByteChannel channel = Files.newByteChannel(big.getPath());\n+        _contentServlet._contentChannel = new ReadableByteChannel()\n+        {\n+            @Override\n+            public boolean isOpen()\n+            {\n+                return channel.isOpen();\n+            }\n+\n+            @Override\n+            public void close() throws IOException\n+            {\n+                channel.close();\n+            }\n+\n+            @Override\n+            public int read(ByteBuffer dst) throws IOException\n+            {\n+                int filled = 0;\n+                if (dst.position() == 0 && dst.limit() > 2000)\n+                {\n+                    int limit = dst.limit();\n+                    dst.limit(2000);\n+                    filled = channel.read(dst);\n+                    dst.limit(limit);\n+                }\n+                else\n+                    filled = channel.read(dst);\n+                return filled;\n+            }\n+        };\n+\n+        LocalEndPoint endp = _connector.executeRequest(\""GET / HTTP/1.1\\nHost: localhost:80\\n\\n\"");\n+\n+        String response = endp.getResponse();\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Transfer-Encoding: chunked\""));\n+        assertThat(response, containsString(\""1\\tThis is a big file\""));\n+        assertThat(response, containsString(\""400\\tThis is a big file\""));\n+        assertThat(response, containsString(\""\\r\\n0\\r\\n\""));\n+\n+        endp.close();\n+    }\n+\n+    @Test\n+    public void testWriteByte() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[1];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testWriteSmall() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[8];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testWriteMed() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[4000];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testWriteLarge() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[8192];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testWriteByteKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[1];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteSmallKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[8];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteMedKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[4000];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteLargeKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[8192];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteHugeKnown() throws Exception\n+    {\n+        _server.start();\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = BufferUtil.allocate(4 * 1024 * 1024);\n+        _contentServlet._content.limit(_contentServlet._content.capacity());\n+        for (int i = _contentServlet._content.capacity(); i-- > 0; )\n+        {\n+            _contentServlet._content.put(i, (byte)'x');\n+        }\n+        _contentServlet._arrayBuffer = new byte[8192];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteBufferSmall() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8);\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testWriteBufferMed() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(4000);\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testWriteBufferLarge() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8192);\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testWriteBufferSmallKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8);\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteBufferMedKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(4000);\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteBufferLargeKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8192);\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteByte() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[1];\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteSmall() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[8];\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteMed() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[4000];\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteLarge() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[8192];\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteHuge() throws Exception\n+    {\n+        _server.start();\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = BufferUtil.allocate(4 * 1024 * 1024);\n+        _contentServlet._content.limit(_contentServlet._content.capacity());\n+        for (int i = _contentServlet._content.capacity(); i-- > 0; )\n+        {\n+            _contentServlet._content.put(i, (byte)'x');\n+        }\n+        _contentServlet._arrayBuffer = new byte[8192];\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteBufferSmall() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8);\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteBufferMed() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(4000);\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteBufferLarge() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8192);\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteBufferLargeDirect()\n+        throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, new ByteBufferPool.Sized(ByteBufferPool.SIZED_NON_POOLING, true, ByteBufferPool.SIZED_NON_POOLING.getSize())).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocateDirect(8192);\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteBufferLargeHEAD() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8192);\n+        _contentServlet._async = true;\n+\n+        int start = _contentServlet._owp.get();\n+        String response = _connector.getResponse(\""HEAD / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(_contentServlet._owp.get() - start, Matchers.greaterThan(0));\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, Matchers.not(containsString(\""1\\tThis is a big file\"")));\n+        assertThat(response, Matchers.not(containsString(\""400\\tThis is a big file\"")));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteSimpleKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/simple.txt\"", false);\n+\n+        _contentServlet._async = true;\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[4000];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 11\""));\n+        assertThat(response, containsString(\""simple text\""));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteSimpleKnownHEAD() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/simple.txt\"", false);\n+\n+        _contentServlet._async = true;\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[4000];\n+\n+        int start = _contentServlet._owp.get();\n+        String response = _connector.getResponse(\""HEAD / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(_contentServlet._owp.get() - start, Matchers.equalTo(1));\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 11\""));\n+        assertThat(response, Matchers.not(containsString(\""simple text\"")));\n+    }\n+\n+    @Test\n+    public void testEmptyArray() throws Exception\n+    {\n+        FuturePromise<Boolean> committed = new FuturePromise<>();\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                response.setStatus(200);\n+                try\n+                {\n+                    response.getOutputStream().write(new byte[0]);\n+                    committed.succeeded(response.isCommitted());\n+                }\n+                catch (Throwable t)\n+                {\n+                    committed.failed(t);\n+                }\n+            }\n+        };\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(committed.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testEmptyArrayKnown() throws Exception\n+    {\n+        FuturePromise<Boolean> committed = new FuturePromise<>();\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                response.setStatus(200);\n+                response.setContentLength(0);\n+                try\n+                {\n+                    response.getOutputStream().write(new byte[0]);\n+                    committed.succeeded(response.isCommitted());\n+                }\n+                catch (Throwable t)\n+                {\n+                    committed.failed(t);\n+                }\n+            }\n+        };\n+\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 0\""));\n+        assertThat(committed.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testEmptyBuffer() throws Exception\n+    {\n+        FuturePromise<Boolean> committed = new FuturePromise<>();\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                response.setStatus(200);\n+                ((HttpOutput)response.getOutputStream()).write(ByteBuffer.wrap(new byte[0]));\n+                committed.succeeded(response.isCommitted());\n+            }\n+        };\n+\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(committed.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testEmptyBufferWithZeroContentLength() throws Exception\n+    {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                response.setStatus(200);\n+                response.setContentLength(0);\n+                ((HttpOutput)response.getOutputStream()).write(ByteBuffer.wrap(new byte[0]));\n+                assertThat(response.isCommitted(), is(true));\n+                latch.countDown();\n+            }\n+        };\n+\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 0\""));\n+        assertThat(latch.await(3, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testAggregation() throws Exception\n+    {\n+        AggregateServlet servlet = new AggregateServlet();\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(servlet.expected.toString()));\n+    }\n+\n+    static class AggregateServlet extends HttpServlet\n+    {\n+        ByteArrayOutputStream expected = new ByteArrayOutputStream();\n+\n+        @Override\n+        protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+        {\n+            HttpOutput out = (HttpOutput)response.getOutputStream();\n+\n+            int bufferSize = ServletContextRequest.getServletContextRequest(request).getRequest().getConnectionMetaData().getHttpConfiguration().getOutputBufferSize();\n+            int len = bufferSize * 3 / 2;\n+\n+            byte[] data = new byte[OUTPUT_AGGREGATION_SIZE / 2 - 1];\n+            int fill = 0;\n+            while (expected.size() < len)\n+            {\n+                Arrays.fill(data, (byte)('A' + (fill++ % 26)));\n+                expected.write(data);\n+                out.write(data);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testAsyncAggregation() throws Exception\n+    {\n+        AsyncAggregateServlet servlet = new AsyncAggregateServlet();\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(servlet.expected.toString()));\n+    }\n+\n+    static class AsyncAggregateServlet extends HttpServlet\n+    {\n+        ByteArrayOutputStream expected = new ByteArrayOutputStream();\n+\n+        @Override\n+        protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+        {\n+            HttpOutput out = (HttpOutput)response.getOutputStream();\n+\n+            int bufferSize = ServletContextRequest.getServletContextRequest(request).getRequest().getConnectionMetaData().getHttpConfiguration().getOutputBufferSize();\n+            int len = bufferSize * 3 / 2;\n+\n+            AsyncContext async = request.startAsync();\n+            out.setWriteListener(new WriteListener()\n+            {\n+                int fill = 0;\n+\n+                @Override\n+                public void onWritePossible() throws IOException\n+                {\n+                    byte[] data = new byte[OUTPUT_AGGREGATION_SIZE / 2 - 1];\n+                    while (out.isReady())\n+                    {\n+                        if (expected.size() >= len)\n+                        {\n+                            async.complete();\n+                            return;\n+                        }\n+\n+                        Arrays.fill(data, (byte)('A' + (fill++ % 26)));\n+                        expected.write(data);\n+                        out.write(data);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(Throwable t)\n+                {\n+                }\n+            });\n+        }\n+    }\n+\n+    @Test\n+    public void testAggregateResidue() throws Exception\n+    {\n+        AggregateResidueServlet servlet = new AggregateResidueServlet();\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(servlet.expected.toString()));\n+    }\n+\n+    static class AggregateResidueServlet extends HttpServlet\n+    {\n+        ByteArrayOutputStream expected = new ByteArrayOutputStream();\n+\n+        @Override\n+        protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+        {\n+            HttpOutput out = (HttpOutput)response.getOutputStream();\n+\n+            int bufferSize = ServletContextRequest.getServletContextRequest(request).getRequest().getConnectionMetaData().getHttpConfiguration().getOutputBufferSize();\n+            int commitSize = ServletContextRequest.getServletContextRequest(request).getRequest().getConnectionMetaData().getHttpConfiguration().getOutputAggregationSize();\n+            char fill = 'A';\n+\n+            // write data that will be aggregated\n+            byte[] data = new byte[commitSize - 1];\n+            Arrays.fill(data, (byte)(fill++));\n+            expected.write(data);\n+            out.write(data);\n+            int aggregated = data.length;\n+\n+            // write data that will almost fill the aggregate buffer\n+            while (aggregated < (bufferSize - 1))\n+            {\n+                data = new byte[Math.min(commitSize - 1, bufferSize - aggregated - 1)];\n+                Arrays.fill(data, (byte)(fill++));\n+                expected.write(data);\n+                out.write(data);\n+                aggregated += data.length;\n+            }\n+\n+            // write data that will not be aggregated because it is too large\n+            data = new byte[bufferSize + 1];\n+            Arrays.fill(data, (byte)(fill++));\n+            expected.write(data);\n+            out.write(data);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrint() throws Exception\n+    {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        PrintWriter exp = new PrintWriter(bout);\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                response.setCharacterEncoding(\""UTF8\"");\n+                HttpOutput out = (HttpOutput)response.getOutputStream();\n+\n+                // @checkstyle-disable-check : AvoidEscapedUnicodeCharactersCheck\n+                exp.print(\""\\u20AC\\u0939\\uD55C\"");\n+                out.print(\""\\u20AC\\u0939\\uD55C\"");\n+                exp.print(\""zero\"");\n+                out.print(\""zero\"");\n+                exp.print(1);\n+                out.print(1);\n+                exp.print(2L);\n+                out.print(2L);\n+                exp.print(3.0F);\n+                out.print(3.0F);\n+                exp.print('4');\n+                out.print('4');\n+                exp.print(5.0D);\n+                out.print(5.0D);\n+                exp.print(true);\n+                out.print(true);\n+                exp.println(\""zero\"");\n+                out.println(\""zero\"");\n+                exp.println(-1);\n+                out.println(-1);\n+                exp.println(-2L);\n+                out.println(-2L);\n+                exp.println(-3.0F);\n+                out.println(-3.0F);\n+                exp.println('4');\n+                out.println('4');\n+                exp.println(-5.0D);\n+                out.println(-5.0D);\n+                exp.println(false);\n+                out.println(false);\n+            }\n+        };\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(bout.toString()));\n+    }\n+\n+    @Test\n+    public void testReset() throws Exception\n+    {\n+        ByteArrayOutputStream exp = new ByteArrayOutputStream();\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                HttpOutput out = (HttpOutput)response.getOutputStream();\n+\n+                out.setBufferSize(128);\n+                out.println(\""NOT TO BE SEEN!\"");\n+                out.resetBuffer();\n+\n+                byte[] data = \""TO BE SEEN\\n\"".getBytes(StandardCharsets.ISO_8859_1);\n+                exp.write(data);\n+                out.write(data);\n+\n+                out.flush();\n+\n+                data = \""Reset after flush\\n\"".getBytes(StandardCharsets.ISO_8859_1);\n+                out.resetBuffer(); // Note that ISE would be thrown by ServletApiResponse.resetBuffer()\n+            }\n+        };\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(exp.toString()));\n+    }\n+\n+    @Test\n+    public void testZeroLengthWrite() throws Exception\n+    {\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                response.setContentLength(0);\n+                AsyncContext async = request.startAsync();\n+                response.getOutputStream().setWriteListener(new WriteListener()\n+                {\n+                    @Override\n+                    public void onWritePossible() throws IOException\n+                    {\n+                        response.getOutputStream().write(new byte[0]);\n+                        async.complete();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable t)\n+                    {\n+                    }\n+                });\n+            }\n+        };\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+    }\n+\n+    private static String toUTF8String(Resource resource)\n+    {\n+        return BufferUtil.toUTF8String(IOResources.toRetainableByteBuffer(resource, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer());\n+    }\n+\n+    static class ContentServlet extends HttpServlet\n+    {\n+        AtomicInteger _owp = new AtomicInteger();\n+        boolean _writeLengthIfKnown = true;\n+        boolean _async;\n+        ByteBuffer _byteBuffer;\n+        byte[] _arrayBuffer;\n+        InputStream _contentInputStream;\n+        ReadableByteChannel _contentChannel;\n+        Resource _contentResource;\n+        ByteBuffer _content;\n+        final FuturePromise<Boolean> _closedAfterWrite = new FuturePromise<>();\n+\n+        @Override\n+        protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+        {\n+            response.setContentType(\""text/plain\"");\n+\n+            final HttpOutput out = (HttpOutput)response.getOutputStream();\n+\n+            if (_contentInputStream != null)\n+            {\n+                out.sendContent(_contentInputStream);\n+                _contentInputStream = null;\n+                _closedAfterWrite.succeeded(out.isClosed());\n+                return;\n+            }\n+\n+            if (_contentChannel != null)\n+            {\n+                out.sendContent(_contentChannel);\n+                _contentChannel = null;\n+                _closedAfterWrite.succeeded(out.isClosed());\n+                return;\n+            }\n+\n+            if (_contentResource != null)\n+            {\n+                out.sendContent(_contentResource.newReadableByteChannel());\n+                _contentResource = null;\n+                _closedAfterWrite.succeeded(out.isClosed());\n+                return;\n+            }\n+\n+            if (_content != null && _writeLengthIfKnown)\n+                response.setContentLength(_content.remaining());\n+\n+            if (_arrayBuffer != null)\n+            {\n+                if (_async)\n+                {\n+                    final AsyncContext async = request.startAsync();\n+                    out.setWriteListener(new WriteListener()\n+                    {\n+                        @Override\n+                        public void onWritePossible() throws IOException\n+                        {\n+                            _owp.incrementAndGet();\n+\n+                            while (out.isReady())\n+                            {\n+                                assertTrue(out.isReady());\n+                                int len = _content.remaining();\n+                                if (len > _arrayBuffer.length)\n+                                    len = _arrayBuffer.length;\n+                                if (len == 0)\n+                                {\n+                                    _closedAfterWrite.succeeded(out.isClosed());\n+                                    async.complete();\n+                                    break;\n+                                }\n+\n+                                _content.get(_arrayBuffer, 0, len);\n+                                if (len == 1)\n+                                    out.write(_arrayBuffer[0]);\n+                                else\n+                                    out.write(_arrayBuffer, 0, len);\n+                            }\n+                        }\n+\n+                        @Override\n+                        public void onError(Throwable t)\n+                        {\n+                            t.printStackTrace();\n+                            async.complete();\n+                        }\n+                    });\n+\n+                    return;\n+                }\n+\n+                while (BufferUtil.hasContent(_content))\n+                {\n+                    int len = _content.remaining();\n+                    if (len > _arrayBuffer.length)\n+                        len = _arrayBuffer.length;\n+                    _content.get(_arrayBuffer, 0, len);\n+                    if (len == 1)\n+                        out.write(_arrayBuffer[0]);\n+                    else\n+                        out.write(_arrayBuffer, 0, len);\n+                }\n+                _closedAfterWrite.succeeded(out.isClosed());\n+                return;\n+            }\n+\n+            if (_byteBuffer != null)\n+            {\n+                if (_async)\n+                {\n+                    final AsyncContext async = request.startAsync();\n+                    out.setWriteListener(new WriteListener()\n+                    {\n+                        private boolean isFirstWrite = true;\n+\n+                        @Override\n+                        public void onWritePossible() throws IOException\n+                        {\n+                            _owp.incrementAndGet();\n+\n+                            while (out.isReady())\n+                            {\n+                                assertTrue(isFirstWrite || !_byteBuffer.hasRemaining());\n+                                assertTrue(out.isReady());\n+                                if (BufferUtil.isEmpty(_content))\n+                                {\n+                                    _closedAfterWrite.succeeded(out.isClosed());\n+                                    async.complete();\n+                                    break;\n+                                }\n+\n+                                BufferUtil.clearToFill(_byteBuffer);\n+                                BufferUtil.put(_content, _byteBuffer);\n+                                BufferUtil.flipToFlush(_byteBuffer, 0);\n+                                out.write(_byteBuffer);\n+                                isFirstWrite = false;\n+                            }\n+                        }\n+\n+                        @Override\n+                        public void onError(Throwable t)\n+                        {\n+                            t.printStackTrace();\n+                            async.complete();\n+                        }\n+                    });\n+\n+                    return;\n+                }\n+\n+                while (BufferUtil.hasContent(_content))\n+                {\n+                    BufferUtil.clearToFill(_byteBuffer);\n+                    BufferUtil.put(_content, _byteBuffer);\n+                    BufferUtil.flipToFlush(_byteBuffer, 0);\n+                    out.write(_byteBuffer);\n+                }\n+                _closedAfterWrite.succeeded(out.isClosed());\n+                return;\n+            }\n+\n+            if (_content != null)\n+            {\n+                if (_content.hasArray())\n+                    out.write(_content.array(), _content.arrayOffset() + _content.position(), _content.remaining());\n+                else\n+                    out.sendContent(_content);\n+                _content = null;\n+                _closedAfterWrite.succeeded(out.isClosed());\n+            }\n+        }\n+    }\n+}\n+\n+\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/big.txt b/jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/big.txt\nnew file mode 100644\nindex 000000000000..a6d57f05f623\n--- /dev/null\n+++ b/jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/big.txt\n@@ -0,0 +1,400 @@\n+     1\tThis is a big file\n+     2\tThis is a big file\n+     3\tThis is a big file\n+     4\tThis is a big file\n+     5\tThis is a big file\n+     6\tThis is a big file\n+     7\tThis is a big file\n+     8\tThis is a big file\n+     9\tThis is a big file\n+    10\tThis is a big file\n+    11\tThis is a big file\n+    12\tThis is a big file\n+    13\tThis is a big file\n+    14\tThis is a big file\n+    15\tThis is a big file\n+    16\tThis is a big file\n+    17\tThis is a big file\n+    18\tThis is a big file\n+    19\tThis is a big file\n+    20\tThis is a big file\n+    21\tThis is a big file\n+    22\tThis is a big file\n+    23\tThis is a big file\n+    24\tThis is a big file\n+    25\tThis is a big file\n+    26\tThis is a big file\n+    27\tThis is a big file\n+    28\tThis is a big file\n+    29\tThis is a big file\n+    30\tThis is a big file\n+    31\tThis is a big file\n+    32\tThis is a big file\n+    33\tThis is a big file\n+    34\tThis is a big file\n+    35\tThis is a big file\n+    36\tThis is a big file\n+    37\tThis is a big file\n+    38\tThis is a big file\n+    39\tThis is a big file\n+    40\tThis is a big file\n+    41\tThis is a big file\n+    42\tThis is a big file\n+    43\tThis is a big file\n+    44\tThis is a big file\n+    45\tThis is a big file\n+    46\tThis is a big file\n+    47\tThis is a big file\n+    48\tThis is a big file\n+    49\tThis is a big file\n+    50\tThis is a big file\n+    51\tThis is a big file\n+    52\tThis is a big file\n+    53\tThis is a big file\n+    54\tThis is a big file\n+    55\tThis is a big file\n+    56\tThis is a big file\n+    57\tThis is a big file\n+    58\tThis is a big file\n+    59\tThis is a big file\n+    60\tThis is a big file\n+    61\tThis is a big file\n+    62\tThis is a big file\n+    63\tThis is a big file\n+    64\tThis is a big file\n+    65\tThis is a big file\n+    66\tThis is a big file\n+    67\tThis is a big file\n+    68\tThis is a big file\n+    69\tThis is a big file\n+    70\tThis is a big file\n+    71\tThis is a big file\n+    72\tThis is a big file\n+    73\tThis is a big file\n+    74\tThis is a big file\n+    75\tThis is a big file\n+    76\tThis is a big file\n+    77\tThis is a big file\n+    78\tThis is a big file\n+    79\tThis is a big file\n+    80\tThis is a big file\n+    81\tThis is a big file\n+    82\tThis is a big file\n+    83\tThis is a big file\n+    84\tThis is a big file\n+    85\tThis is a big file\n+    86\tThis is a big file\n+    87\tThis is a big file\n+    88\tThis is a big file\n+    89\tThis is a big file\n+    90\tThis is a big file\n+    91\tThis is a big file\n+    92\tThis is a big file\n+    93\tThis is a big file\n+    94\tThis is a big file\n+    95\tThis is a big file\n+    96\tThis is a big file\n+    97\tThis is a big file\n+    98\tThis is a big file\n+    99\tThis is a big file\n+   100\tThis is a big file\n+   101\tThis is a big file\n+   102\tThis is a big file\n+   103\tThis is a big file\n+   104\tThis is a big file\n+   105\tThis is a big file\n+   106\tThis is a big file\n+   107\tThis is a big file\n+   108\tThis is a big file\n+   109\tThis is a big file\n+   110\tThis is a big file\n+   111\tThis is a big file\n+   112\tThis is a big file\n+   113\tThis is a big file\n+   114\tThis is a big file\n+   115\tThis is a big file\n+   116\tThis is a big file\n+   117\tThis is a big file\n+   118\tThis is a big file\n+   119\tThis is a big file\n+   120\tThis is a big file\n+   121\tThis is a big file\n+   122\tThis is a big file\n+   123\tThis is a big file\n+   124\tThis is a big file\n+   125\tThis is a big file\n+   126\tThis is a big file\n+   127\tThis is a big file\n+   128\tThis is a big file\n+   129\tThis is a big file\n+   130\tThis is a big file\n+   131\tThis is a big file\n+   132\tThis is a big file\n+   133\tThis is a big file\n+   134\tThis is a big file\n+   135\tThis is a big file\n+   136\tThis is a big file\n+   137\tThis is a big file\n+   138\tThis is a big file\n+   139\tThis is a big file\n+   140\tThis is a big file\n+   141\tThis is a big file\n+   142\tThis is a big file\n+   143\tThis is a big file\n+   144\tThis is a big file\n+   145\tThis is a big file\n+   146\tThis is a big file\n+   147\tThis is a big file\n+   148\tThis is a big file\n+   149\tThis is a big file\n+   150\tThis is a big file\n+   151\tThis is a big file\n+   152\tThis is a big file\n+   153\tThis is a big file\n+   154\tThis is a big file\n+   155\tThis is a big file\n+   156\tThis is a big file\n+   157\tThis is a big file\n+   158\tThis is a big file\n+   159\tThis is a big file\n+   160\tThis is a big file\n+   161\tThis is a big file\n+   162\tThis is a big file\n+   163\tThis is a big file\n+   164\tThis is a big file\n+   165\tThis is a big file\n+   166\tThis is a big file\n+   167\tThis is a big file\n+   168\tThis is a big file\n+   169\tThis is a big file\n+   170\tThis is a big file\n+   171\tThis is a big file\n+   172\tThis is a big file\n+   173\tThis is a big file\n+   174\tThis is a big file\n+   175\tThis is a big file\n+   176\tThis is a big file\n+   177\tThis is a big file\n+   178\tThis is a big file\n+   179\tThis is a big file\n+   180\tThis is a big file\n+   181\tThis is a big file\n+   182\tThis is a big file\n+   183\tThis is a big file\n+   184\tThis is a big file\n+   185\tThis is a big file\n+   186\tThis is a big file\n+   187\tThis is a big file\n+   188\tThis is a big file\n+   189\tThis is a big file\n+   190\tThis is a big file\n+   191\tThis is a big file\n+   192\tThis is a big file\n+   193\tThis is a big file\n+   194\tThis is a big file\n+   195\tThis is a big file\n+   196\tThis is a big file\n+   197\tThis is a big file\n+   198\tThis is a big file\n+   199\tThis is a big file\n+   200\tThis is a big file\n+   201\tThis is a big file\n+   202\tThis is a big file\n+   203\tThis is a big file\n+   204\tThis is a big file\n+   205\tThis is a big file\n+   206\tThis is a big file\n+   207\tThis is a big file\n+   208\tThis is a big file\n+   209\tThis is a big file\n+   210\tThis is a big file\n+   211\tThis is a big file\n+   212\tThis is a big file\n+   213\tThis is a big file\n+   214\tThis is a big file\n+   215\tThis is a big file\n+   216\tThis is a big file\n+   217\tThis is a big file\n+   218\tThis is a big file\n+   219\tThis is a big file\n+   220\tThis is a big file\n+   221\tThis is a big file\n+   222\tThis is a big file\n+   223\tThis is a big file\n+   224\tThis is a big file\n+   225\tThis is a big file\n+   226\tThis is a big file\n+   227\tThis is a big file\n+   228\tThis is a big file\n+   229\tThis is a big file\n+   230\tThis is a big file\n+   231\tThis is a big file\n+   232\tThis is a big file\n+   233\tThis is a big file\n+   234\tThis is a big file\n+   235\tThis is a big file\n+   236\tThis is a big file\n+   237\tThis is a big file\n+   238\tThis is a big file\n+   239\tThis is a big file\n+   240\tThis is a big file\n+   241\tThis is a big file\n+   242\tThis is a big file\n+   243\tThis is a big file\n+   244\tThis is a big file\n+   245\tThis is a big file\n+   246\tThis is a big file\n+   247\tThis is a big file\n+   248\tThis is a big file\n+   249\tThis is a big file\n+   250\tThis is a big file\n+   251\tThis is a big file\n+   252\tThis is a big file\n+   253\tThis is a big file\n+   254\tThis is a big file\n+   255\tThis is a big file\n+   256\tThis is a big file\n+   257\tThis is a big file\n+   258\tThis is a big file\n+   259\tThis is a big file\n+   260\tThis is a big file\n+   261\tThis is a big file\n+   262\tThis is a big file\n+   263\tThis is a big file\n+   264\tThis is a big file\n+   265\tThis is a big file\n+   266\tThis is a big file\n+   267\tThis is a big file\n+   268\tThis is a big file\n+   269\tThis is a big file\n+   270\tThis is a big file\n+   271\tThis is a big file\n+   272\tThis is a big file\n+   273\tThis is a big file\n+   274\tThis is a big file\n+   275\tThis is a big file\n+   276\tThis is a big file\n+   277\tThis is a big file\n+   278\tThis is a big file\n+   279\tThis is a big file\n+   280\tThis is a big file\n+   281\tThis is a big file\n+   282\tThis is a big file\n+   283\tThis is a big file\n+   284\tThis is a big file\n+   285\tThis is a big file\n+   286\tThis is a big file\n+   287\tThis is a big file\n+   288\tThis is a big file\n+   289\tThis is a big file\n+   290\tThis is a big file\n+   291\tThis is a big file\n+   292\tThis is a big file\n+   293\tThis is a big file\n+   294\tThis is a big file\n+   295\tThis is a big file\n+   296\tThis is a big file\n+   297\tThis is a big file\n+   298\tThis is a big file\n+   299\tThis is a big file\n+   300\tThis is a big file\n+   301\tThis is a big file\n+   302\tThis is a big file\n+   303\tThis is a big file\n+   304\tThis is a big file\n+   305\tThis is a big file\n+   306\tThis is a big file\n+   307\tThis is a big file\n+   308\tThis is a big file\n+   309\tThis is a big file\n+   310\tThis is a big file\n+   311\tThis is a big file\n+   312\tThis is a big file\n+   313\tThis is a big file\n+   314\tThis is a big file\n+   315\tThis is a big file\n+   316\tThis is a big file\n+   317\tThis is a big file\n+   318\tThis is a big file\n+   319\tThis is a big file\n+   320\tThis is a big file\n+   321\tThis is a big file\n+   322\tThis is a big file\n+   323\tThis is a big file\n+   324\tThis is a big file\n+   325\tThis is a big file\n+   326\tThis is a big file\n+   327\tThis is a big file\n+   328\tThis is a big file\n+   329\tThis is a big file\n+   330\tThis is a big file\n+   331\tThis is a big file\n+   332\tThis is a big file\n+   333\tThis is a big file\n+   334\tThis is a big file\n+   335\tThis is a big file\n+   336\tThis is a big file\n+   337\tThis is a big file\n+   338\tThis is a big file\n+   339\tThis is a big file\n+   340\tThis is a big file\n+   341\tThis is a big file\n+   342\tThis is a big file\n+   343\tThis is a big file\n+   344\tThis is a big file\n+   345\tThis is a big file\n+   346\tThis is a big file\n+   347\tThis is a big file\n+   348\tThis is a big file\n+   349\tThis is a big file\n+   350\tThis is a big file\n+   351\tThis is a big file\n+   352\tThis is a big file\n+   353\tThis is a big file\n+   354\tThis is a big file\n+   355\tThis is a big file\n+   356\tThis is a big file\n+   357\tThis is a big file\n+   358\tThis is a big file\n+   359\tThis is a big file\n+   360\tThis is a big file\n+   361\tThis is a big file\n+   362\tThis is a big file\n+   363\tThis is a big file\n+   364\tThis is a big file\n+   365\tThis is a big file\n+   366\tThis is a big file\n+   367\tThis is a big file\n+   368\tThis is a big file\n+   369\tThis is a big file\n+   370\tThis is a big file\n+   371\tThis is a big file\n+   372\tThis is a big file\n+   373\tThis is a big file\n+   374\tThis is a big file\n+   375\tThis is a big file\n+   376\tThis is a big file\n+   377\tThis is a big file\n+   378\tThis is a big file\n+   379\tThis is a big file\n+   380\tThis is a big file\n+   381\tThis is a big file\n+   382\tThis is a big file\n+   383\tThis is a big file\n+   384\tThis is a big file\n+   385\tThis is a big file\n+   386\tThis is a big file\n+   387\tThis is a big file\n+   388\tThis is a big file\n+   389\tThis is a big file\n+   390\tThis is a big file\n+   391\tThis is a big file\n+   392\tThis is a big file\n+   393\tThis is a big file\n+   394\tThis is a big file\n+   395\tThis is a big file\n+   396\tThis is a big file\n+   397\tThis is a big file\n+   398\tThis is a big file\n+   399\tThis is a big file\n+   400\tThis is a big file\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/directory/content.txt b/jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/directory/content.txt\nnew file mode 100644\nindex 000000000000..6b584e8ece56\n--- /dev/null\n+++ b/jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/directory/content.txt\n@@ -0,0 +1 @@\n+content\n\\ No newline at end of file\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/directory/welcome.txt b/jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/directory/welcome.txt\nnew file mode 100644\nindex 000000000000..5ab2f8a4323a\n--- /dev/null\n+++ b/jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/directory/welcome.txt\n@@ -0,0 +1 @@\n+Hello\n\\ No newline at end of file\n\ndiff --git a/jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/simple.txt b/jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/simple.txt\nnew file mode 100644\nindex 000000000000..f2403aead5a8\n--- /dev/null\n+++ b/jetty-ee10/jetty-ee10-servlet/src/test/resources/simple/simple.txt\n@@ -0,0 +1 @@\n+simple text\n\\ No newline at end of file\n\ndiff --git a/jetty-ee11/jetty-ee11-servlet/src/test/java/org/eclipse/jetty/ee11/servlet/ContextScopeListenerTest.java b/jetty-ee11/jetty-ee11-servlet/src/test/java/org/eclipse/jetty/ee11/servlet/ContextScopeListenerTest.java\nindex b5c55a70193d..832696bac597 100644\n--- a/jetty-ee11/jetty-ee11-servlet/src/test/java/org/eclipse/jetty/ee11/servlet/ContextScopeListenerTest.java\n+++ b/jetty-ee11/jetty-ee11-servlet/src/test/java/org/eclipse/jetty/ee11/servlet/ContextScopeListenerTest.java\n@@ -19,13 +19,13 @@\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.ReentrantLock;\n \n import jakarta.servlet.AsyncContext;\n import jakarta.servlet.DispatcherType;\n import jakarta.servlet.http.HttpServlet;\n import jakarta.servlet.http.HttpServletRequest;\n import jakarta.servlet.http.HttpServletResponse;\n+import org.awaitility.Awaitility;\n import org.eclipse.jetty.client.ContentResponse;\n import org.eclipse.jetty.client.HttpClient;\n import org.eclipse.jetty.http.HttpStatus;\n@@ -40,6 +40,7 @@\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.nullValue;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n public class ContextScopeListenerTest\n@@ -63,17 +64,19 @@ public void before() throws Exception\n \n         _client = new HttpClient();\n         _client.start();\n+        assertThat(ContextHandler.getCurrentContext(), nullValue());\n     }\n \n     @AfterEach\n     public void after() throws Exception\n     {\n+        assertThat(ContextHandler.getCurrentContext(), nullValue());\n         _client.stop();\n         _server.stop();\n     }\n \n     @Test\n-    public void testAsyncServlet() throws Exception\n+    public void testAsyncServletAsyncBeforeDoGetExit() throws Exception\n     {\n         _contextHandler.addServlet(new ServletHolder(new HttpServlet()\n         {\n@@ -87,26 +90,104 @@ protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                 }\n \n                 _history.add(\""doGet\"");\n+                CountDownLatch latch = new CountDownLatch(1);\n                 AsyncContext asyncContext = req.startAsync();\n                 asyncContext.start(() ->\n                 {\n                     _history.add(\""asyncRunnable\"");\n                     asyncContext.dispatch(\""/dispatch\"");\n+                    latch.countDown();\n+                    // wait until doGet call has exited\n+                    Awaitility.waitAtMost(5, TimeUnit.SECONDS).until(() -> _history.get(_history.size() - 1).equals(\""exitScope /initialPath\""));\n                 });\n+\n+                try\n+                {\n+                    assertTrue(latch.await(5, TimeUnit.SECONDS));\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new RuntimeException(e);\n+                }\n             }\n         }), \""/\"");\n \n-        CountDownLatch complete = new CountDownLatch(3);\n-\n         _contextHandler.addEventListener(new ContextHandler.ContextScopeListener()\n         {\n-            // Use a lock to prevent the async thread running the listener concurrently.\n-            private final ReentrantLock _lock = new ReentrantLock();\n+            @Override\n+            public void enterScope(Context context, Request request)\n+            {\n+                String pathInContext = (request == null) ? \""null\"" : Request.getPathInContext(request);\n+                _history.add(\""enterScope \"" + pathInContext);\n+            }\n+\n+            @Override\n+            public void exitScope(Context context, Request request)\n+            {\n+                String pathInContext = (request == null) ? \""null\"" : Request.getPathInContext(request);\n+                _history.add(\""exitScope \"" + pathInContext);\n+            }\n+        });\n+\n+        URI uri = URI.create(\""http://localhost:\"" + _connector.getLocalPort() + \""/initialPath\"");\n+        ContentResponse response = _client.GET(uri);\n+        assertThat(response.getStatus(), equalTo(HttpStatus.OK_200));\n+        Awaitility.waitAtMost(5, TimeUnit.SECONDS).pollInterval(100, TimeUnit.MILLISECONDS).until(() -> _history.size() == 7);\n+        assertHistory(\n+            \""enterScope /initialPath\"",\n+            \""doGet\"",\n+            \""enterScope /initialPath\"",\n+            \""asyncRunnable\"",\n+            \""asyncDispatch\"",\n+            \""exitScope /initialPath\"",\n+            \""exitScope /initialPath\""\n+        );\n+    }\n+\n+    @Test\n+    public void testAsyncServletAsyncAfterDoGetExit() throws Exception\n+    {\n+        _contextHandler.addServlet(new ServletHolder(new HttpServlet()\n+        {\n+            @Override\n+            protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+            {\n+                if  (req.getDispatcherType() == DispatcherType.ASYNC)\n+                {\n+                    _history.add(\""asyncDispatch\"");\n+                    return;\n+                }\n+\n+                _history.add(\""doGet\"");\n+                CountDownLatch latch = new CountDownLatch(1);\n+                AsyncContext asyncContext = req.startAsync();\n+                asyncContext.start(() ->\n+                {\n+                    latch.countDown();\n+                    // wait until doGet call has exited\n+                    Awaitility.waitAtMost(5, TimeUnit.SECONDS).until(() -> _history.get(_history.size() - 1).equals(\""exitScope /initialPath\""));\n+\n+                    _history.add(\""asyncRunnable\"");\n+                    asyncContext.dispatch(\""/dispatch\"");\n+                });\n \n+                try\n+                {\n+                    assertTrue(latch.await(5, TimeUnit.SECONDS));\n+                }\n+                catch (InterruptedException e)\n+                {\n+                    throw new RuntimeException(e);\n+                }\n+\n+            }\n+        }), \""/\"");\n+\n+        _contextHandler.addEventListener(new ContextHandler.ContextScopeListener()\n+        {\n             @Override\n             public void enterScope(Context context, Request request)\n             {\n-                _lock.lock();\n                 String pathInContext = (request == null) ? \""null\"" : Request.getPathInContext(request);\n                 _history.add(\""enterScope \"" + pathInContext);\n             }\n@@ -116,8 +197,6 @@ public void exitScope(Context context, Request request)\n             {\n                 String pathInContext = (request == null) ? \""null\"" : Request.getPathInContext(request);\n                 _history.add(\""exitScope \"" + pathInContext);\n-                _lock.unlock();\n-                complete.countDown();\n             }\n         });\n \n@@ -125,12 +204,12 @@ public void exitScope(Context context, Request request)\n         ContentResponse response = _client.GET(uri);\n         assertThat(response.getStatus(), equalTo(HttpStatus.OK_200));\n \n-        assertTrue(complete.await(5, TimeUnit.SECONDS));\n+        Awaitility.waitAtMost(5, TimeUnit.SECONDS).pollInterval(100, TimeUnit.MILLISECONDS).until(() -> _history.size() >= 9);\n         assertHistory(\n             \""enterScope /initialPath\"",\n             \""doGet\"",\n-            \""exitScope /initialPath\"",\n             \""enterScope /initialPath\"",\n+            \""exitScope /initialPath\"",\n             \""asyncRunnable\"",\n             \""exitScope /initialPath\"",\n             \""enterScope /initialPath\"",\n\ndiff --git a/jetty-ee11/jetty-ee11-servlet/src/test/java/org/eclipse/jetty/ee11/servlet/HttpOutputTest.java b/jetty-ee11/jetty-ee11-servlet/src/test/java/org/eclipse/jetty/ee11/servlet/HttpOutputTest.java\nnew file mode 100644\nindex 000000000000..569cb07db1ee\n--- /dev/null\n+++ b/jetty-ee11/jetty-ee11-servlet/src/test/java/org/eclipse/jetty/ee11/servlet/HttpOutputTest.java\n@@ -0,0 +1,1299 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.ee11.servlet;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintWriter;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import jakarta.servlet.AsyncContext;\n+import jakarta.servlet.ServletException;\n+import jakarta.servlet.WriteListener;\n+import jakarta.servlet.http.HttpServlet;\n+import jakarta.servlet.http.HttpServletRequest;\n+import jakarta.servlet.http.HttpServletResponse;\n+import org.eclipse.jetty.io.ByteBufferPool;\n+import org.eclipse.jetty.io.IOResources;\n+import org.eclipse.jetty.server.HttpConnectionFactory;\n+import org.eclipse.jetty.server.LocalConnector;\n+import org.eclipse.jetty.server.LocalConnector.LocalEndPoint;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.util.BufferUtil;\n+import org.eclipse.jetty.util.FuturePromise;\n+import org.eclipse.jetty.util.IO;\n+import org.eclipse.jetty.util.resource.Resource;\n+import org.eclipse.jetty.util.resource.ResourceFactory;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.endsWith;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ *\n+ */\n+public class HttpOutputTest\n+{\n+    public static final int OUTPUT_AGGREGATION_SIZE = 1024;\n+    public static final int OUTPUT_BUFFER_SIZE = 4096;\n+    private Server _server;\n+    private ServletContextHandler _servletContextHandler;\n+    private LocalConnector _connector;\n+    private ContentServlet _contentServlet;\n+\n+    @BeforeEach\n+    public void init() throws Exception\n+    {\n+        _server = new Server();\n+        _servletContextHandler = new ServletContextHandler(\""/\"");\n+\n+        HttpConnectionFactory http = new HttpConnectionFactory();\n+        http.getHttpConfiguration().setRequestHeaderSize(1024);\n+        http.getHttpConfiguration().setResponseHeaderSize(1024);\n+        http.getHttpConfiguration().setOutputBufferSize(OUTPUT_BUFFER_SIZE);\n+        http.getHttpConfiguration().setOutputAggregationSize(OUTPUT_AGGREGATION_SIZE);\n+\n+        _connector = new LocalConnector(_server, http, null);\n+        _server.addConnector(_connector);\n+        _server.setHandler(_servletContextHandler);\n+\n+        _contentServlet = new ContentServlet();\n+        _servletContextHandler.addServlet(_contentServlet, \""/*\"");\n+    }\n+\n+    @AfterEach\n+    public void destroy() throws Exception\n+    {\n+        IO.close(_contentServlet._contentInputStream);\n+        IO.close(_contentServlet._contentChannel);\n+        _server.stop();\n+        _server.join();\n+    }\n+\n+    @Test\n+    public void testSimple() throws Exception\n+    {\n+        _server.start();\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+    }\n+\n+    @Test\n+    public void testSendContentByteBuffer() throws Exception\n+    {\n+        _server.start();\n+        byte[] buffer = new byte[16 * 1024];\n+        Arrays.fill(buffer, 0, 4 * 1024, (byte)0x99);\n+        Arrays.fill(buffer, 4 * 1024, 12 * 1024, (byte)0x58);\n+        Arrays.fill(buffer, 12 * 1024, 16 * 1024, (byte)0x66);\n+        _contentServlet._content = ByteBuffer.wrap(buffer);\n+        _contentServlet._content.limit(12 * 1024);\n+        _contentServlet._content.position(4 * 1024);\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""\\r\\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\""));\n+\n+        for (int i = 0; i < 4 * 1024; i++)\n+        {\n+            assertEquals((byte)0x99, buffer[i], \""i=\"" + i);\n+        }\n+        for (int i = 12 * 1024; i < 16 * 1024; i++)\n+        {\n+            assertEquals((byte)0x66, buffer[i], \""i=\"" + i);\n+        }\n+    }\n+\n+    @Test\n+    public void testSendInputStreamSimple() throws Exception\n+    {\n+        _server.start();\n+        Resource simple = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/simple.txt\"", false);\n+        _contentServlet._contentInputStream = IOResources.asInputStream(simple);\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 11\""));\n+    }\n+\n+    @Test\n+    public void testSendInputStreamBig() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._contentInputStream = IOResources.asInputStream(big);\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testSendInputStreamBigChunked() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._contentInputStream = new FilterInputStream(IOResources.asInputStream(big))\n+        {\n+            @Override\n+            public int read(byte[] b, int off, int len) throws IOException\n+            {\n+                return super.read(b, off, Math.min(len, 2000));\n+            }\n+        };\n+        LocalEndPoint endp = _connector.executeRequest(\n+            \""\""\""\n+                GET / HTTP/1.1\n+                Host: localhost:80\n+                \n+                \""\""\"");\n+\n+        String response = endp.getResponse();\n+\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Transfer-Encoding: chunked\""));\n+        assertThat(response, containsString(\""1\\tThis is a big file\""));\n+        assertThat(response, containsString(\""400\\tThis is a big file\""));\n+        assertThat(response, containsString(\""\\r\\n0\\r\\n\""));\n+\n+        endp.close();\n+    }\n+\n+    @Test\n+    public void testSendChannelSimple() throws Exception\n+    {\n+        _server.start();\n+        Resource simple = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/simple.txt\"", false);\n+        _contentServlet._contentChannel = Files.newByteChannel(simple.getPath());\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 11\""));\n+    }\n+\n+    @Test\n+    public void testSendChannelBig() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._contentChannel = Files.newByteChannel(big.getPath());\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testSendResourceSimple() throws Exception\n+    {\n+        _server.start();\n+        Resource simple = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/simple.txt\"", false);\n+        _contentServlet._contentResource = simple;\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 11\""));\n+        assertThat(response, endsWith(toUTF8String(simple)));\n+    }\n+\n+    @Test\n+    public void testSendResourceBig() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._contentResource = big;\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testSendBigDirect() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testSendBigInDirect() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testSendChannelBigChunked() throws Exception\n+    {\n+        _server.start();\n+        Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        final ReadableByteChannel channel = Files.newByteChannel(big.getPath());\n+        _contentServlet._contentChannel = new ReadableByteChannel()\n+        {\n+            @Override\n+            public boolean isOpen()\n+            {\n+                return channel.isOpen();\n+            }\n+\n+            @Override\n+            public void close() throws IOException\n+            {\n+                channel.close();\n+            }\n+\n+            @Override\n+            public int read(ByteBuffer dst) throws IOException\n+            {\n+                int filled = 0;\n+                if (dst.position() == 0 && dst.limit() > 2000)\n+                {\n+                    int limit = dst.limit();\n+                    dst.limit(2000);\n+                    filled = channel.read(dst);\n+                    dst.limit(limit);\n+                }\n+                else\n+                    filled = channel.read(dst);\n+                return filled;\n+            }\n+        };\n+\n+        LocalEndPoint endp = _connector.executeRequest(\""GET / HTTP/1.1\\nHost: localhost:80\\n\\n\"");\n+\n+        String response = endp.getResponse();\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Transfer-Encoding: chunked\""));\n+        assertThat(response, containsString(\""1\\tThis is a big file\""));\n+        assertThat(response, containsString(\""400\\tThis is a big file\""));\n+        assertThat(response, containsString(\""\\r\\n0\\r\\n\""));\n+\n+        endp.close();\n+    }\n+\n+    @Test\n+    public void testWriteByte() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[1];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testWriteSmall() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[8];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testWriteMed() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[4000];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testWriteLarge() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[8192];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+    }\n+\n+    @Test\n+    public void testWriteByteKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[1];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteSmallKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[8];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteMedKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[4000];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteLargeKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[8192];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteHugeKnown() throws Exception\n+    {\n+        _server.start();\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = BufferUtil.allocate(4 * 1024 * 1024);\n+        _contentServlet._content.limit(_contentServlet._content.capacity());\n+        for (int i = _contentServlet._content.capacity(); i-- > 0; )\n+        {\n+            _contentServlet._content.put(i, (byte)'x');\n+        }\n+        _contentServlet._arrayBuffer = new byte[8192];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteBufferSmall() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8);\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testWriteBufferMed() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(4000);\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testWriteBufferLarge() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8192);\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testWriteBufferSmallKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8);\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteBufferMedKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(4000);\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testWriteBufferLargeKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8192);\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length\""));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteByte() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[1];\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteSmall() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[8];\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteMed() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[4000];\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteLarge() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[8192];\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteHuge() throws Exception\n+    {\n+        _server.start();\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = BufferUtil.allocate(4 * 1024 * 1024);\n+        _contentServlet._content.limit(_contentServlet._content.capacity());\n+        for (int i = _contentServlet._content.capacity(); i-- > 0; )\n+        {\n+            _contentServlet._content.put(i, (byte)'x');\n+        }\n+        _contentServlet._arrayBuffer = new byte[8192];\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteBufferSmall() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8);\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteBufferMed() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(4000);\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteBufferLarge() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8192);\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteBufferLargeDirect()\n+        throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, new ByteBufferPool.Sized(ByteBufferPool.SIZED_NON_POOLING, true, ByteBufferPool.SIZED_NON_POOLING.getSize())).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocateDirect(8192);\n+        _contentServlet._async = true;\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, endsWith(toUTF8String(big)));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteBufferLargeHEAD() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/big.txt\"", false);\n+        _contentServlet._writeLengthIfKnown = false;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._byteBuffer = BufferUtil.allocate(8192);\n+        _contentServlet._async = true;\n+\n+        int start = _contentServlet._owp.get();\n+        String response = _connector.getResponse(\""HEAD / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(_contentServlet._owp.get() - start, Matchers.greaterThan(0));\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, Matchers.not(containsString(\""Content-Length\"")));\n+        assertThat(response, Matchers.not(containsString(\""1\\tThis is a big file\"")));\n+        assertThat(response, Matchers.not(containsString(\""400\\tThis is a big file\"")));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteSimpleKnown() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/simple.txt\"", false);\n+\n+        _contentServlet._async = true;\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[4000];\n+\n+        String response = _connector.getResponse(\""GET / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 11\""));\n+        assertThat(response, containsString(\""simple text\""));\n+        assertThat(_contentServlet._closedAfterWrite.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testAsyncWriteSimpleKnownHEAD() throws Exception\n+    {\n+        _server.start();\n+        final Resource big = ResourceFactory.of(_servletContextHandler).newClassLoaderResource(\""simple/simple.txt\"", false);\n+\n+        _contentServlet._async = true;\n+        _contentServlet._writeLengthIfKnown = true;\n+        _contentServlet._content = IOResources.toRetainableByteBuffer(big, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer();\n+        _contentServlet._arrayBuffer = new byte[4000];\n+\n+        int start = _contentServlet._owp.get();\n+        String response = _connector.getResponse(\""HEAD / HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(_contentServlet._owp.get() - start, Matchers.equalTo(1));\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 11\""));\n+        assertThat(response, Matchers.not(containsString(\""simple text\"")));\n+    }\n+\n+    @Test\n+    public void testEmptyArray() throws Exception\n+    {\n+        FuturePromise<Boolean> committed = new FuturePromise<>();\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                response.setStatus(200);\n+                try\n+                {\n+                    response.getOutputStream().write(new byte[0]);\n+                    committed.succeeded(response.isCommitted());\n+                }\n+                catch (Throwable t)\n+                {\n+                    committed.failed(t);\n+                }\n+            }\n+        };\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(committed.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testEmptyArrayKnown() throws Exception\n+    {\n+        FuturePromise<Boolean> committed = new FuturePromise<>();\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                response.setStatus(200);\n+                response.setContentLength(0);\n+                try\n+                {\n+                    response.getOutputStream().write(new byte[0]);\n+                    committed.succeeded(response.isCommitted());\n+                }\n+                catch (Throwable t)\n+                {\n+                    committed.failed(t);\n+                }\n+            }\n+        };\n+\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 0\""));\n+        assertThat(committed.get(10, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testEmptyBuffer() throws Exception\n+    {\n+        FuturePromise<Boolean> committed = new FuturePromise<>();\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                response.setStatus(200);\n+                ((HttpOutput)response.getOutputStream()).write(ByteBuffer.wrap(new byte[0]));\n+                committed.succeeded(response.isCommitted());\n+            }\n+        };\n+\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(committed.get(10, TimeUnit.SECONDS), is(false));\n+    }\n+\n+    @Test\n+    public void testEmptyBufferWithZeroContentLength() throws Exception\n+    {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                response.setStatus(200);\n+                response.setContentLength(0);\n+                ((HttpOutput)response.getOutputStream()).write(ByteBuffer.wrap(new byte[0]));\n+                assertThat(response.isCommitted(), is(true));\n+                latch.countDown();\n+            }\n+        };\n+\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(\""Content-Length: 0\""));\n+        assertThat(latch.await(3, TimeUnit.SECONDS), is(true));\n+    }\n+\n+    @Test\n+    public void testAggregation() throws Exception\n+    {\n+        AggregateServlet servlet = new AggregateServlet();\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(servlet.expected.toString()));\n+    }\n+\n+    static class AggregateServlet extends HttpServlet\n+    {\n+        ByteArrayOutputStream expected = new ByteArrayOutputStream();\n+\n+        @Override\n+        protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+        {\n+            HttpOutput out = (HttpOutput)response.getOutputStream();\n+\n+            int bufferSize = ServletContextRequest.getServletContextRequest(request).getRequest().getConnectionMetaData().getHttpConfiguration().getOutputBufferSize();\n+            int len = bufferSize * 3 / 2;\n+\n+            byte[] data = new byte[OUTPUT_AGGREGATION_SIZE / 2 - 1];\n+            int fill = 0;\n+            while (expected.size() < len)\n+            {\n+                Arrays.fill(data, (byte)('A' + (fill++ % 26)));\n+                expected.write(data);\n+                out.write(data);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testAsyncAggregation() throws Exception\n+    {\n+        AsyncAggregateServlet servlet = new AsyncAggregateServlet();\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(servlet.expected.toString()));\n+    }\n+\n+    static class AsyncAggregateServlet extends HttpServlet\n+    {\n+        ByteArrayOutputStream expected = new ByteArrayOutputStream();\n+\n+        @Override\n+        protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+        {\n+            HttpOutput out = (HttpOutput)response.getOutputStream();\n+\n+            int bufferSize = ServletContextRequest.getServletContextRequest(request).getRequest().getConnectionMetaData().getHttpConfiguration().getOutputBufferSize();\n+            int len = bufferSize * 3 / 2;\n+\n+            AsyncContext async = request.startAsync();\n+            out.setWriteListener(new WriteListener()\n+            {\n+                int fill = 0;\n+\n+                @Override\n+                public void onWritePossible() throws IOException\n+                {\n+                    byte[] data = new byte[OUTPUT_AGGREGATION_SIZE / 2 - 1];\n+                    while (out.isReady())\n+                    {\n+                        if (expected.size() >= len)\n+                        {\n+                            async.complete();\n+                            return;\n+                        }\n+\n+                        Arrays.fill(data, (byte)('A' + (fill++ % 26)));\n+                        expected.write(data);\n+                        out.write(data);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(Throwable t)\n+                {\n+                }\n+            });\n+        }\n+    }\n+\n+    @Test\n+    public void testAggregateResidue() throws Exception\n+    {\n+        AggregateResidueServlet servlet = new AggregateResidueServlet();\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(servlet.expected.toString()));\n+    }\n+\n+    static class AggregateResidueServlet extends HttpServlet\n+    {\n+        ByteArrayOutputStream expected = new ByteArrayOutputStream();\n+\n+        @Override\n+        protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+        {\n+            HttpOutput out = (HttpOutput)response.getOutputStream();\n+\n+            int bufferSize = ServletContextRequest.getServletContextRequest(request).getRequest().getConnectionMetaData().getHttpConfiguration().getOutputBufferSize();\n+            int commitSize = ServletContextRequest.getServletContextRequest(request).getRequest().getConnectionMetaData().getHttpConfiguration().getOutputAggregationSize();\n+            char fill = 'A';\n+\n+            // write data that will be aggregated\n+            byte[] data = new byte[commitSize - 1];\n+            Arrays.fill(data, (byte)(fill++));\n+            expected.write(data);\n+            out.write(data);\n+            int aggregated = data.length;\n+\n+            // write data that will almost fill the aggregate buffer\n+            while (aggregated < (bufferSize - 1))\n+            {\n+                data = new byte[Math.min(commitSize - 1, bufferSize - aggregated - 1)];\n+                Arrays.fill(data, (byte)(fill++));\n+                expected.write(data);\n+                out.write(data);\n+                aggregated += data.length;\n+            }\n+\n+            // write data that will not be aggregated because it is too large\n+            data = new byte[bufferSize + 1];\n+            Arrays.fill(data, (byte)(fill++));\n+            expected.write(data);\n+            out.write(data);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrint() throws Exception\n+    {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        PrintWriter exp = new PrintWriter(bout);\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                response.setCharacterEncoding(\""UTF8\"");\n+                HttpOutput out = (HttpOutput)response.getOutputStream();\n+\n+                // @checkstyle-disable-check : AvoidEscapedUnicodeCharactersCheck\n+                exp.print(\""\\u20AC\\u0939\\uD55C\"");\n+                out.print(\""\\u20AC\\u0939\\uD55C\"");\n+                exp.print(\""zero\"");\n+                out.print(\""zero\"");\n+                exp.print(1);\n+                out.print(1);\n+                exp.print(2L);\n+                out.print(2L);\n+                exp.print(3.0F);\n+                out.print(3.0F);\n+                exp.print('4');\n+                out.print('4');\n+                exp.print(5.0D);\n+                out.print(5.0D);\n+                exp.print(true);\n+                out.print(true);\n+                exp.println(\""zero\"");\n+                out.println(\""zero\"");\n+                exp.println(-1);\n+                out.println(-1);\n+                exp.println(-2L);\n+                out.println(-2L);\n+                exp.println(-3.0F);\n+                out.println(-3.0F);\n+                exp.println('4');\n+                out.println('4');\n+                exp.println(-5.0D);\n+                out.println(-5.0D);\n+                exp.println(false);\n+                out.println(false);\n+            }\n+        };\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(bout.toString()));\n+    }\n+\n+    @Test\n+    public void testReset() throws Exception\n+    {\n+        ByteArrayOutputStream exp = new ByteArrayOutputStream();\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                HttpOutput out = (HttpOutput)response.getOutputStream();\n+\n+                out.setBufferSize(128);\n+                out.println(\""NOT TO BE SEEN!\"");\n+                out.resetBuffer();\n+\n+                byte[] data = \""TO BE SEEN\\n\"".getBytes(StandardCharsets.ISO_8859_1);\n+                exp.write(data);\n+                out.write(data);\n+\n+                out.flush();\n+\n+                data = \""Reset after flush\\n\"".getBytes(StandardCharsets.ISO_8859_1);\n+                out.resetBuffer(); // Note that ISE would be thrown by ServletApiResponse.resetBuffer()\n+            }\n+        };\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+        assertThat(response, containsString(exp.toString()));\n+    }\n+\n+    @Test\n+    public void testZeroLengthWrite() throws Exception\n+    {\n+        HttpServlet servlet = new HttpServlet()\n+        {\n+            @Override\n+            protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+            {\n+                response.setContentLength(0);\n+                AsyncContext async = request.startAsync();\n+                response.getOutputStream().setWriteListener(new WriteListener()\n+                {\n+                    @Override\n+                    public void onWritePossible() throws IOException\n+                    {\n+                        response.getOutputStream().write(new byte[0]);\n+                        async.complete();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable t)\n+                    {\n+                    }\n+                });\n+            }\n+        };\n+        _servletContextHandler.addServlet(servlet, \""/test\"");\n+        _server.start();\n+        String response = _connector.getResponse(\""GET /test HTTP/1.0\\nHost: localhost:80\\n\\n\"");\n+        assertThat(response, containsString(\""HTTP/1.1 200 OK\""));\n+    }\n+\n+    private static String toUTF8String(Resource resource)\n+    {\n+        return BufferUtil.toUTF8String(IOResources.toRetainableByteBuffer(resource, ByteBufferPool.SIZED_NON_POOLING).getByteBuffer());\n+    }\n+\n+    static class ContentServlet extends HttpServlet\n+    {\n+        AtomicInteger _owp = new AtomicInteger();\n+        boolean _writeLengthIfKnown = true;\n+        boolean _async;\n+        ByteBuffer _byteBuffer;\n+        byte[] _arrayBuffer;\n+        InputStream _contentInputStream;\n+        ReadableByteChannel _contentChannel;\n+        Resource _contentResource;\n+        ByteBuffer _content;\n+        final FuturePromise<Boolean> _closedAfterWrite = new FuturePromise<>();\n+\n+        @Override\n+        protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\n+        {\n+            response.setContentType(\""text/plain\"");\n+\n+            final HttpOutput out = (HttpOutput)response.getOutputStream();\n+\n+            if (_contentInputStream != null)\n+            {\n+                out.sendContent(_contentInputStream);\n+                _contentInputStream = null;\n+                _closedAfterWrite.succeeded(out.isClosed());\n+                return;\n+            }\n+\n+            if (_contentChannel != null)\n+            {\n+                out.sendContent(_contentChannel);\n+                _contentChannel = null;\n+                _closedAfterWrite.succeeded(out.isClosed());\n+                return;\n+            }\n+\n+            if (_contentResource != null)\n+            {\n+                out.sendContent(_contentResource.newReadableByteChannel());\n+                _contentResource = null;\n+                _closedAfterWrite.succeeded(out.isClosed());\n+                return;\n+            }\n+\n+            if (_content != null && _writeLengthIfKnown)\n+                response.setContentLength(_content.remaining());\n+\n+            if (_arrayBuffer != null)\n+            {\n+                if (_async)\n+                {\n+                    final AsyncContext async = request.startAsync();\n+                    out.setWriteListener(new WriteListener()\n+                    {\n+                        @Override\n+                        public void onWritePossible() throws IOException\n+                        {\n+                            _owp.incrementAndGet();\n+\n+                            while (out.isReady())\n+                            {\n+                                assertTrue(out.isReady());\n+                                int len = _content.remaining();\n+                                if (len > _arrayBuffer.length)\n+                                    len = _arrayBuffer.length;\n+                                if (len == 0)\n+                                {\n+                                    _closedAfterWrite.succeeded(out.isClosed());\n+                                    async.complete();\n+                                    break;\n+                                }\n+\n+                                _content.get(_arrayBuffer, 0, len);\n+                                if (len == 1)\n+                                    out.write(_arrayBuffer[0]);\n+                                else\n+                                    out.write(_arrayBuffer, 0, len);\n+                            }\n+                        }\n+\n+                        @Override\n+                        public void onError(Throwable t)\n+                        {\n+                            t.printStackTrace();\n+                            async.complete();\n+                        }\n+                    });\n+\n+                    return;\n+                }\n+\n+                while (BufferUtil.hasContent(_content))\n+                {\n+                    int len = _content.remaining();\n+                    if (len > _arrayBuffer.length)\n+                        len = _arrayBuffer.length;\n+                    _content.get(_arrayBuffer, 0, len);\n+                    if (len == 1)\n+                        out.write(_arrayBuffer[0]);\n+                    else\n+                        out.write(_arrayBuffer, 0, len);\n+                }\n+                _closedAfterWrite.succeeded(out.isClosed());\n+                return;\n+            }\n+\n+            if (_byteBuffer != null)\n+            {\n+                if (_async)\n+                {\n+                    final AsyncContext async = request.startAsync();\n+                    out.setWriteListener(new WriteListener()\n+                    {\n+                        private boolean isFirstWrite = true;\n+\n+                        @Override\n+                        public void onWritePossible() throws IOException\n+                        {\n+                            _owp.incrementAndGet();\n+\n+                            while (out.isReady())\n+                            {\n+                                assertTrue(isFirstWrite || !_byteBuffer.hasRemaining());\n+                                assertTrue(out.isReady());\n+                                if (BufferUtil.isEmpty(_content))\n+                                {\n+                                    _closedAfterWrite.succeeded(out.isClosed());\n+                                    async.complete();\n+                                    break;\n+                                }\n+\n+                                BufferUtil.clearToFill(_byteBuffer);\n+                                BufferUtil.put(_content, _byteBuffer);\n+                                BufferUtil.flipToFlush(_byteBuffer, 0);\n+                                out.write(_byteBuffer);\n+                                isFirstWrite = false;\n+                            }\n+                        }\n+\n+                        @Override\n+                        public void onError(Throwable t)\n+                        {\n+                            t.printStackTrace();\n+                            async.complete();\n+                        }\n+                    });\n+\n+                    return;\n+                }\n+\n+                while (BufferUtil.hasContent(_content))\n+                {\n+                    BufferUtil.clearToFill(_byteBuffer);\n+                    BufferUtil.put(_content, _byteBuffer);\n+                    BufferUtil.flipToFlush(_byteBuffer, 0);\n+                    out.write(_byteBuffer);\n+                }\n+                _closedAfterWrite.succeeded(out.isClosed());\n+                return;\n+            }\n+\n+            if (_content != null)\n+            {\n+                if (_content.hasArray())\n+                    out.write(_content.array(), _content.arrayOffset() + _content.position(), _content.remaining());\n+                else\n+                    out.sendContent(_content);\n+                _content = null;\n+                _closedAfterWrite.succeeded(out.isClosed());\n+            }\n+        }\n+    }\n+}\n+\n+\n\ndiff --git a/jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/big.txt b/jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/big.txt\nnew file mode 100644\nindex 000000000000..a6d57f05f623\n--- /dev/null\n+++ b/jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/big.txt\n@@ -0,0 +1,400 @@\n+     1\tThis is a big file\n+     2\tThis is a big file\n+     3\tThis is a big file\n+     4\tThis is a big file\n+     5\tThis is a big file\n+     6\tThis is a big file\n+     7\tThis is a big file\n+     8\tThis is a big file\n+     9\tThis is a big file\n+    10\tThis is a big file\n+    11\tThis is a big file\n+    12\tThis is a big file\n+    13\tThis is a big file\n+    14\tThis is a big file\n+    15\tThis is a big file\n+    16\tThis is a big file\n+    17\tThis is a big file\n+    18\tThis is a big file\n+    19\tThis is a big file\n+    20\tThis is a big file\n+    21\tThis is a big file\n+    22\tThis is a big file\n+    23\tThis is a big file\n+    24\tThis is a big file\n+    25\tThis is a big file\n+    26\tThis is a big file\n+    27\tThis is a big file\n+    28\tThis is a big file\n+    29\tThis is a big file\n+    30\tThis is a big file\n+    31\tThis is a big file\n+    32\tThis is a big file\n+    33\tThis is a big file\n+    34\tThis is a big file\n+    35\tThis is a big file\n+    36\tThis is a big file\n+    37\tThis is a big file\n+    38\tThis is a big file\n+    39\tThis is a big file\n+    40\tThis is a big file\n+    41\tThis is a big file\n+    42\tThis is a big file\n+    43\tThis is a big file\n+    44\tThis is a big file\n+    45\tThis is a big file\n+    46\tThis is a big file\n+    47\tThis is a big file\n+    48\tThis is a big file\n+    49\tThis is a big file\n+    50\tThis is a big file\n+    51\tThis is a big file\n+    52\tThis is a big file\n+    53\tThis is a big file\n+    54\tThis is a big file\n+    55\tThis is a big file\n+    56\tThis is a big file\n+    57\tThis is a big file\n+    58\tThis is a big file\n+    59\tThis is a big file\n+    60\tThis is a big file\n+    61\tThis is a big file\n+    62\tThis is a big file\n+    63\tThis is a big file\n+    64\tThis is a big file\n+    65\tThis is a big file\n+    66\tThis is a big file\n+    67\tThis is a big file\n+    68\tThis is a big file\n+    69\tThis is a big file\n+    70\tThis is a big file\n+    71\tThis is a big file\n+    72\tThis is a big file\n+    73\tThis is a big file\n+    74\tThis is a big file\n+    75\tThis is a big file\n+    76\tThis is a big file\n+    77\tThis is a big file\n+    78\tThis is a big file\n+    79\tThis is a big file\n+    80\tThis is a big file\n+    81\tThis is a big file\n+    82\tThis is a big file\n+    83\tThis is a big file\n+    84\tThis is a big file\n+    85\tThis is a big file\n+    86\tThis is a big file\n+    87\tThis is a big file\n+    88\tThis is a big file\n+    89\tThis is a big file\n+    90\tThis is a big file\n+    91\tThis is a big file\n+    92\tThis is a big file\n+    93\tThis is a big file\n+    94\tThis is a big file\n+    95\tThis is a big file\n+    96\tThis is a big file\n+    97\tThis is a big file\n+    98\tThis is a big file\n+    99\tThis is a big file\n+   100\tThis is a big file\n+   101\tThis is a big file\n+   102\tThis is a big file\n+   103\tThis is a big file\n+   104\tThis is a big file\n+   105\tThis is a big file\n+   106\tThis is a big file\n+   107\tThis is a big file\n+   108\tThis is a big file\n+   109\tThis is a big file\n+   110\tThis is a big file\n+   111\tThis is a big file\n+   112\tThis is a big file\n+   113\tThis is a big file\n+   114\tThis is a big file\n+   115\tThis is a big file\n+   116\tThis is a big file\n+   117\tThis is a big file\n+   118\tThis is a big file\n+   119\tThis is a big file\n+   120\tThis is a big file\n+   121\tThis is a big file\n+   122\tThis is a big file\n+   123\tThis is a big file\n+   124\tThis is a big file\n+   125\tThis is a big file\n+   126\tThis is a big file\n+   127\tThis is a big file\n+   128\tThis is a big file\n+   129\tThis is a big file\n+   130\tThis is a big file\n+   131\tThis is a big file\n+   132\tThis is a big file\n+   133\tThis is a big file\n+   134\tThis is a big file\n+   135\tThis is a big file\n+   136\tThis is a big file\n+   137\tThis is a big file\n+   138\tThis is a big file\n+   139\tThis is a big file\n+   140\tThis is a big file\n+   141\tThis is a big file\n+   142\tThis is a big file\n+   143\tThis is a big file\n+   144\tThis is a big file\n+   145\tThis is a big file\n+   146\tThis is a big file\n+   147\tThis is a big file\n+   148\tThis is a big file\n+   149\tThis is a big file\n+   150\tThis is a big file\n+   151\tThis is a big file\n+   152\tThis is a big file\n+   153\tThis is a big file\n+   154\tThis is a big file\n+   155\tThis is a big file\n+   156\tThis is a big file\n+   157\tThis is a big file\n+   158\tThis is a big file\n+   159\tThis is a big file\n+   160\tThis is a big file\n+   161\tThis is a big file\n+   162\tThis is a big file\n+   163\tThis is a big file\n+   164\tThis is a big file\n+   165\tThis is a big file\n+   166\tThis is a big file\n+   167\tThis is a big file\n+   168\tThis is a big file\n+   169\tThis is a big file\n+   170\tThis is a big file\n+   171\tThis is a big file\n+   172\tThis is a big file\n+   173\tThis is a big file\n+   174\tThis is a big file\n+   175\tThis is a big file\n+   176\tThis is a big file\n+   177\tThis is a big file\n+   178\tThis is a big file\n+   179\tThis is a big file\n+   180\tThis is a big file\n+   181\tThis is a big file\n+   182\tThis is a big file\n+   183\tThis is a big file\n+   184\tThis is a big file\n+   185\tThis is a big file\n+   186\tThis is a big file\n+   187\tThis is a big file\n+   188\tThis is a big file\n+   189\tThis is a big file\n+   190\tThis is a big file\n+   191\tThis is a big file\n+   192\tThis is a big file\n+   193\tThis is a big file\n+   194\tThis is a big file\n+   195\tThis is a big file\n+   196\tThis is a big file\n+   197\tThis is a big file\n+   198\tThis is a big file\n+   199\tThis is a big file\n+   200\tThis is a big file\n+   201\tThis is a big file\n+   202\tThis is a big file\n+   203\tThis is a big file\n+   204\tThis is a big file\n+   205\tThis is a big file\n+   206\tThis is a big file\n+   207\tThis is a big file\n+   208\tThis is a big file\n+   209\tThis is a big file\n+   210\tThis is a big file\n+   211\tThis is a big file\n+   212\tThis is a big file\n+   213\tThis is a big file\n+   214\tThis is a big file\n+   215\tThis is a big file\n+   216\tThis is a big file\n+   217\tThis is a big file\n+   218\tThis is a big file\n+   219\tThis is a big file\n+   220\tThis is a big file\n+   221\tThis is a big file\n+   222\tThis is a big file\n+   223\tThis is a big file\n+   224\tThis is a big file\n+   225\tThis is a big file\n+   226\tThis is a big file\n+   227\tThis is a big file\n+   228\tThis is a big file\n+   229\tThis is a big file\n+   230\tThis is a big file\n+   231\tThis is a big file\n+   232\tThis is a big file\n+   233\tThis is a big file\n+   234\tThis is a big file\n+   235\tThis is a big file\n+   236\tThis is a big file\n+   237\tThis is a big file\n+   238\tThis is a big file\n+   239\tThis is a big file\n+   240\tThis is a big file\n+   241\tThis is a big file\n+   242\tThis is a big file\n+   243\tThis is a big file\n+   244\tThis is a big file\n+   245\tThis is a big file\n+   246\tThis is a big file\n+   247\tThis is a big file\n+   248\tThis is a big file\n+   249\tThis is a big file\n+   250\tThis is a big file\n+   251\tThis is a big file\n+   252\tThis is a big file\n+   253\tThis is a big file\n+   254\tThis is a big file\n+   255\tThis is a big file\n+   256\tThis is a big file\n+   257\tThis is a big file\n+   258\tThis is a big file\n+   259\tThis is a big file\n+   260\tThis is a big file\n+   261\tThis is a big file\n+   262\tThis is a big file\n+   263\tThis is a big file\n+   264\tThis is a big file\n+   265\tThis is a big file\n+   266\tThis is a big file\n+   267\tThis is a big file\n+   268\tThis is a big file\n+   269\tThis is a big file\n+   270\tThis is a big file\n+   271\tThis is a big file\n+   272\tThis is a big file\n+   273\tThis is a big file\n+   274\tThis is a big file\n+   275\tThis is a big file\n+   276\tThis is a big file\n+   277\tThis is a big file\n+   278\tThis is a big file\n+   279\tThis is a big file\n+   280\tThis is a big file\n+   281\tThis is a big file\n+   282\tThis is a big file\n+   283\tThis is a big file\n+   284\tThis is a big file\n+   285\tThis is a big file\n+   286\tThis is a big file\n+   287\tThis is a big file\n+   288\tThis is a big file\n+   289\tThis is a big file\n+   290\tThis is a big file\n+   291\tThis is a big file\n+   292\tThis is a big file\n+   293\tThis is a big file\n+   294\tThis is a big file\n+   295\tThis is a big file\n+   296\tThis is a big file\n+   297\tThis is a big file\n+   298\tThis is a big file\n+   299\tThis is a big file\n+   300\tThis is a big file\n+   301\tThis is a big file\n+   302\tThis is a big file\n+   303\tThis is a big file\n+   304\tThis is a big file\n+   305\tThis is a big file\n+   306\tThis is a big file\n+   307\tThis is a big file\n+   308\tThis is a big file\n+   309\tThis is a big file\n+   310\tThis is a big file\n+   311\tThis is a big file\n+   312\tThis is a big file\n+   313\tThis is a big file\n+   314\tThis is a big file\n+   315\tThis is a big file\n+   316\tThis is a big file\n+   317\tThis is a big file\n+   318\tThis is a big file\n+   319\tThis is a big file\n+   320\tThis is a big file\n+   321\tThis is a big file\n+   322\tThis is a big file\n+   323\tThis is a big file\n+   324\tThis is a big file\n+   325\tThis is a big file\n+   326\tThis is a big file\n+   327\tThis is a big file\n+   328\tThis is a big file\n+   329\tThis is a big file\n+   330\tThis is a big file\n+   331\tThis is a big file\n+   332\tThis is a big file\n+   333\tThis is a big file\n+   334\tThis is a big file\n+   335\tThis is a big file\n+   336\tThis is a big file\n+   337\tThis is a big file\n+   338\tThis is a big file\n+   339\tThis is a big file\n+   340\tThis is a big file\n+   341\tThis is a big file\n+   342\tThis is a big file\n+   343\tThis is a big file\n+   344\tThis is a big file\n+   345\tThis is a big file\n+   346\tThis is a big file\n+   347\tThis is a big file\n+   348\tThis is a big file\n+   349\tThis is a big file\n+   350\tThis is a big file\n+   351\tThis is a big file\n+   352\tThis is a big file\n+   353\tThis is a big file\n+   354\tThis is a big file\n+   355\tThis is a big file\n+   356\tThis is a big file\n+   357\tThis is a big file\n+   358\tThis is a big file\n+   359\tThis is a big file\n+   360\tThis is a big file\n+   361\tThis is a big file\n+   362\tThis is a big file\n+   363\tThis is a big file\n+   364\tThis is a big file\n+   365\tThis is a big file\n+   366\tThis is a big file\n+   367\tThis is a big file\n+   368\tThis is a big file\n+   369\tThis is a big file\n+   370\tThis is a big file\n+   371\tThis is a big file\n+   372\tThis is a big file\n+   373\tThis is a big file\n+   374\tThis is a big file\n+   375\tThis is a big file\n+   376\tThis is a big file\n+   377\tThis is a big file\n+   378\tThis is a big file\n+   379\tThis is a big file\n+   380\tThis is a big file\n+   381\tThis is a big file\n+   382\tThis is a big file\n+   383\tThis is a big file\n+   384\tThis is a big file\n+   385\tThis is a big file\n+   386\tThis is a big file\n+   387\tThis is a big file\n+   388\tThis is a big file\n+   389\tThis is a big file\n+   390\tThis is a big file\n+   391\tThis is a big file\n+   392\tThis is a big file\n+   393\tThis is a big file\n+   394\tThis is a big file\n+   395\tThis is a big file\n+   396\tThis is a big file\n+   397\tThis is a big file\n+   398\tThis is a big file\n+   399\tThis is a big file\n+   400\tThis is a big file\n\ndiff --git a/jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/directory/content.txt b/jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/directory/content.txt\nnew file mode 100644\nindex 000000000000..6b584e8ece56\n--- /dev/null\n+++ b/jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/directory/content.txt\n@@ -0,0 +1 @@\n+content\n\\ No newline at end of file\n\ndiff --git a/jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/directory/welcome.txt b/jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/directory/welcome.txt\nnew file mode 100644\nindex 000000000000..5ab2f8a4323a\n--- /dev/null\n+++ b/jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/directory/welcome.txt\n@@ -0,0 +1 @@\n+Hello\n\\ No newline at end of file\n\ndiff --git a/jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/simple.txt b/jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/simple.txt\nnew file mode 100644\nindex 000000000000..f2403aead5a8\n--- /dev/null\n+++ b/jetty-ee11/jetty-ee11-servlet/src/test/resources/simple/simple.txt\n@@ -0,0 +1 @@\n+simple text\n\\ No newline at end of file\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-12504"", ""pr_id"": 12504, ""issue_id"": 11579, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Introduce `UriCompliance.Violation.FRAGMENT` to reject HTTP Request Line that includes fragment section.\n**Jetty version(s)**\r\n12.0.7\r\n\r\n**Jetty Environment**\r\nAll\r\n\r\n**Java version/vendor** `(use: java -version)`\r\nAll\r\n\r\n**OS type/version**\r\nAll\r\n\r\n**Description**\r\nWhile working PR #11496 the idea of not allowing FRAGMENT section in a Request Line was introduced.\r\n\r\nIt is good idea that seems to follow the HTTP spec.\r\n\r\n* https://datatracker.ietf.org/doc/html/rfc9110#section-4.1 - indicates that the relative URI shouldn't have the fragment component\r\n* https://datatracker.ietf.org/doc/html/rfc9110#section-4.2.5 - says that the fragment component is not part of the ABNF for http or https URIs\r\n* https://datatracker.ietf.org/doc/html/rfc9110#section-7.1 - says that the server should ignore/drop the fragment component, as the fragment component is reserved for client-side processing\r\n* https://datatracker.ietf.org/doc/html/rfc9110#section-10.2.2 - points out that a redirect `Location` response header can contain a fragment indicator\r\n* https://datatracker.ietf.org/doc/html/rfc9110#section-17.11 - there is a security concern as well with exposure of fragment after redirect\r\n\r\nIf we do this, we should be careful how we do it, and allow a configurable UriCompliance mode to configure the behavior.\r\n\r\nSee original commit (reverted in PR #11496):\r\n https://github.com/jetty/jetty.project/pull/11496/commits/fed10f79aacecfcb4118bcbe39fcb21d98666f25\r\n\r\n"", ""issue_word_count"": 226, ""test_files_count"": 2, ""non_test_files_count"": 2, ""pr_changed_files"": [""jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java"", ""jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java"", ""jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/HttpURITest.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/CustomRequestLogTest.java""], ""pr_changed_test_files"": [""jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/HttpURITest.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/CustomRequestLogTest.java""], ""base_commit"": ""537d019cee72426a058d60f232778d5f450b77dd"", ""head_commit"": ""99e816a4f1ae2a363369fb446977a7536985bd4f"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/12504"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/12504"", ""dockerfile"": """", ""pr_merged_at"": ""2024-11-11T20:37:18.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java\nindex db93704b3e09..f288c1cbd35b 100644\n--- a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java\n+++ b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpURI.java\n@@ -1242,6 +1242,7 @@ private void parse(State state, final String uri)\n                             case '#':\n                                 // must have been in a path\n                                 _path = uri.substring(mark, i);\n+                                addViolation(Violation.FRAGMENT);\n                                 state = State.FRAGMENT;\n                                 break;\n                             default:\n@@ -1303,7 +1304,11 @@ private void parse(State state, final String uri)\n                                     state = switch (c)\n                                     {\n                                         case '?' -> State.QUERY;\n-                                        case '#' -> State.FRAGMENT;\n+                                        case '#' ->\n+                                        {\n+                                            addViolation(Violation.FRAGMENT);\n+                                            yield State.FRAGMENT;\n+                                        }\n                                         default -> throw new IllegalArgumentException(\""Bad authority\"");\n                                     };\n                                 }\n@@ -1411,7 +1416,11 @@ else if (!isUnreservedPctEncodedOrSubDelim(c))\n                                 state = switch (c)\n                                 {\n                                     case '?' -> State.QUERY;\n-                                    case '#' -> State.FRAGMENT;\n+                                    case '#' ->\n+                                    {\n+                                        addViolation(Violation.FRAGMENT);\n+                                        yield State.FRAGMENT;\n+                                    }\n                                     default -> throw new IllegalStateException();\n                                 };\n                             }\n@@ -1494,6 +1503,7 @@ else if (!isUnreservedPctEncodedOrSubDelim(c))\n                                     checkSegment(uri, dot || encoded, segment, i, false);\n                                     _path = uri.substring(pathMark, i);\n                                     mark = i + 1;\n+                                    addViolation(Violation.FRAGMENT);\n                                     state = State.FRAGMENT;\n                                     break;\n                                 case '/':\n@@ -1536,6 +1546,7 @@ else if (!isUnreservedPctEncodedOrSubDelim(c))\n                                 _path = uri.substring(pathMark, i);\n                                 _param = uri.substring(mark, i);\n                                 mark = i + 1;\n+                                addViolation(Violation.FRAGMENT);\n                                 state = State.FRAGMENT;\n                                 break;\n                             case '/':\n@@ -1557,6 +1568,7 @@ else if (!isUnreservedPctEncodedOrSubDelim(c))\n                         {\n                             _query = uri.substring(mark, i);\n                             mark = i + 1;\n+                            addViolation(Violation.FRAGMENT);\n                             state = State.FRAGMENT;\n                         }\n                         break;\n\ndiff --git a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java\nindex fb8dad6cd127..0c4d26b314cd 100644\n--- a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java\n+++ b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/UriCompliance.java\n@@ -114,7 +114,12 @@ public enum Violation implements ComplianceViolation\n         /**\n          * Allow user info in the authority portion of the URI and HTTP specs.\n          */\n-        USER_INFO(\""https://datatracker.ietf.org/doc/html/rfc9110#name-deprecation-of-userinfo-in-\"", \""Deprecated User Info\"");\n+        USER_INFO(\""https://datatracker.ietf.org/doc/html/rfc9110#name-deprecation-of-userinfo-in-\"", \""Deprecated User Info\""),\n+\n+        /**\n+         * Allow a fragment in the URI.\n+         */\n+        FRAGMENT(\""https://www.rfc-editor.org/rfc/rfc9110.html#section-7.1\"", \""Fragment\"");\n \n         private final String _url;\n         private final String _description;\n@@ -166,7 +171,8 @@ public String getDescription()\n         Violation.AMBIGUOUS_PATH_SEGMENT,\n         Violation.AMBIGUOUS_PATH_SEPARATOR,\n         Violation.SUSPICIOUS_PATH_CHARACTERS,\n-        Violation.ILLEGAL_PATH_CHARACTERS));\n+        Violation.ILLEGAL_PATH_CHARACTERS,\n+        Violation.FRAGMENT));\n \n     /**\n      * Compliance mode that exactly follows <a href=\""https://tools.ietf.org/html/rfc3986\"">RFC3986</a>,\n@@ -197,7 +203,8 @@ public String getDescription()\n             Violation.AMBIGUOUS_PATH_ENCODING,\n             Violation.AMBIGUOUS_EMPTY_SEGMENT,\n             Violation.UTF16_ENCODINGS,\n-            Violation.USER_INFO));\n+            Violation.USER_INFO,\n+            Violation.FRAGMENT));\n \n     /**\n      * Compliance mode that allows all URI Violations, including allowing ambiguous paths in non-canonical form, and illegal characters\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/HttpURITest.java b/jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/HttpURITest.java\nindex 4fdf1acd6e5f..729c08e6f7de 100644\n--- a/jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/HttpURITest.java\n+++ b/jetty-core/jetty-http/src/test/java/org/eclipse/jetty/http/HttpURITest.java\n@@ -396,7 +396,9 @@ public static Stream<Arguments> decodePathTests()\n                 {\""/context/dir%3B/\"", \""/context/dir%3B/\"", \""/context/dir;/\"", EnumSet.noneOf(Violation.class)},\n                 {\""/f%u006f%u006F/bar\"", \""/foo/bar\"", \""/foo/bar\"", EnumSet.of(Violation.UTF16_ENCODINGS)},\n                 {\""/f%u0001%u0001/bar\"", \""/f%01%01/bar\"", \""/f\\001\\001/bar\"", EnumSet.of(Violation.UTF16_ENCODINGS)},\n+                // @checkstyle-disable-check : AvoidEscapedUnicodeCharactersCheck\n                 {\""/foo/%u20AC/bar\"", \""/foo/\\u20AC/bar\"", \""/foo/\\u20AC/bar\"", EnumSet.of(Violation.UTF16_ENCODINGS)},\n+                // @checkstyle-enable-check : AvoidEscapedUnicodeCharactersCheck\n \n                 // nfc encoded unicode path\n                 {\""/dir/swedish-%C3%A5.txt\"", \""/dir/swedish-\u00e5.txt\"", \""/dir/swedish-\u00e5.txt\"", EnumSet.noneOf(Violation.class)},\n@@ -497,6 +499,11 @@ public static Stream<Arguments> decodePathTests()\n                 {\""http://localhost:9000/x\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\"", \""/x\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\"", \""/x\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\"", EnumSet.noneOf(Violation.class)},\n                 {\""http://localhost:9000/\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\"", \""/\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\"", \""/\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\\uD83C\\uDF32\"", EnumSet.noneOf(Violation.class)},\n                 // @checkstyle-enable-check : AvoidEscapedUnicodeCharactersCheck\n+\n+                // Fragments\n+                {\""http://host/path/info#fragment\"", \""/path/info\"", \""/path/info\"", EnumSet.of(Violation.FRAGMENT)},\n+                {\""//host/path/info#frag/ment\"", \""/path/info\"", \""/path/info\"", EnumSet.of(Violation.FRAGMENT)},\n+                {\""/path/info#fragment\"", \""/path/info\"", \""/path/info\"", EnumSet.of(Violation.FRAGMENT)}\n             }).map(Arguments::of);\n     }\n \n@@ -511,7 +518,7 @@ public void testDecodedPath(String input, String canonicalPath, String decodedPa\n             assertThat(\""Decoded Path\"", uri.getDecodedPath(), is(decodedPath));\n \n             EnumSet<Violation> ambiguous = EnumSet.copyOf(expected);\n-            ambiguous.retainAll(EnumSet.complementOf(EnumSet.of(Violation.UTF16_ENCODINGS, Violation.BAD_UTF8_ENCODING)));\n+            ambiguous.retainAll(UriCompliance.AMBIGUOUS_VIOLATIONS);\n \n             assertThat(uri.isAmbiguous(), is(!ambiguous.isEmpty()));\n             assertThat(uri.hasAmbiguousSegment(), is(ambiguous.contains(Violation.AMBIGUOUS_PATH_SEGMENT)));\n@@ -913,9 +920,9 @@ public void testParseString(String input, String scheme, String host, Integer po\n \n     @ParameterizedTest\n     @MethodSource(\""parseData\"")\n-    public void testParseURI(String input, String scheme, String host, Integer port, String path, String param, String query, String fragment) throws Exception\n+    public void testParseURI(String input, String scheme, String host, Integer port, String path, String param, String query, String fragment)\n     {\n-        URI javaUri = null;\n+        URI javaUri;\n         try\n         {\n             javaUri = new URI(input);\n@@ -940,7 +947,7 @@ public void testParseURI(String input, String scheme, String host, Integer port,\n \n     @ParameterizedTest\n     @MethodSource(\""parseData\"")\n-    public void testCompareToJavaNetURI(String input, String scheme, String host, Integer port, String path, String param, String query, String fragment) throws Exception\n+    public void testCompareToJavaNetURI(String input, String scheme, String host, Integer port, String path, String param, String query, String fragment)\n     {\n         URI javaUri = null;\n         try\n\ndiff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/CustomRequestLogTest.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/CustomRequestLogTest.java\nindex 4dc588419188..944a99831e70 100644\n--- a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/CustomRequestLogTest.java\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/CustomRequestLogTest.java\n@@ -39,6 +39,7 @@\n import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.HttpStatus;\n import org.eclipse.jetty.http.HttpTester;\n+import org.eclipse.jetty.http.UriCompliance;\n import org.eclipse.jetty.io.Content;\n import org.eclipse.jetty.io.QuietException;\n import org.eclipse.jetty.util.BlockingArrayQueue;\n@@ -90,6 +91,7 @@ private void start(String formatString, Handler handler, Consumer<CustomRequestL\n     {\n         _server = new Server();\n         _httpConfig = new HttpConfiguration();\n+        _httpConfig.setUriCompliance(UriCompliance.DEFAULT.with(\""fragments\"", UriCompliance.Violation.FRAGMENT));\n         _serverConnector = new ServerConnector(_server, 1, 1, new HttpConnectionFactory(_httpConfig));\n         _server.addConnector(_serverConnector);\n         TestRequestLogWriter writer = new TestRequestLogWriter();\n@@ -165,10 +167,7 @@ public void testRequestFilter() throws Exception\n     public void testIgnorePaths(String testPath, boolean existsInLog) throws Exception\n     {\n         start(\""RequestPath: %U\"",\n-            customRequestLog ->\n-            {\n-                customRequestLog.setIgnorePaths(new String[]{\""/zed/*\"", \""/zee/*\""});\n-            });\n+            customRequestLog -> customRequestLog.setIgnorePaths(new String[]{\""/zed/*\"", \""/zee/*\""}));\n \n         HttpTester.Response response = getResponse(\""GET @PATH@ HTTP/1.0\\n\\n\"".replace(\""@PATH@\"", testPath));\n         assertEquals(HttpStatus.OK_200, response.getStatus());\n@@ -245,8 +244,7 @@ public void testDoublePercent() throws Exception\n     @Test\n     public void testLogAddress() throws Exception\n     {\n-        start(\""\"" +\n-              \""%{local}a|%{local}p|\"" +\n+        start(\""%{local}a|%{local}p|\"" +\n               \""%{remote}a|%{remote}p|\"" +\n               \""%{server}a|%{server}p|\"" +\n               \""%{client}a|%{client}p\"");\n@@ -337,7 +335,7 @@ public boolean handle(Request request, Response response, Callback callback)\n         HttpTester.Response response = getResponse(\""\""\""\n             GET / HTTP/1.0\n             Content-Length: %d\n-                                \n+            \n             %s\""\""\"".formatted(content.length(), content));\n         assertEquals(HttpStatus.OK_200, response.getStatus());\n         String log = _logs.poll(5, TimeUnit.SECONDS);\n@@ -449,9 +447,9 @@ public void testLogKeepAliveRequests() throws Exception\n \n             GET /a HTTP/1.1\n             Host: localhost\n-                        \n+            \n             GET /a HTTP/1.0\n-                        \n+            \n             \""\""\"", 3);\n \n         assertThat(_logs.poll(5, TimeUnit.SECONDS), is(\""KeepAliveRequests: 1\""));\n@@ -755,7 +753,7 @@ public boolean handle(Request request, Response response, Callback callback)\n             output.write(\""\""\""\n                 GET /abort HTTP/1.1\n                 Host: localhost\n-                    \n+                \n                 \""\""\"".getBytes(StandardCharsets.ISO_8859_1));\n             output.flush();\n \n@@ -764,7 +762,7 @@ public boolean handle(Request request, Response response, Callback callback)\n \n             String line = in.readLine();\n             assertThat(line, is(\""HTTP/1.1 200 OK\""));\n-            while (line != null && line.length() > 0)\n+            while (line != null && !line.isEmpty())\n                 line = in.readLine();\n \n             line = in.readLine();\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-12484"", ""pr_id"": 12484, ""issue_id"": 12481, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Exception when a Content-Length is set on a 304 response\n**Jetty version(s)**\r\n12\r\n\r\n**Jetty Environment**\r\nee8\r\n\r\n**Java version/vendor** `(use: java -version)`\r\nopenjdk version \""17.0.12\"" 2024-07-16\r\n\r\n**OS type/version**\r\nUbuntu 24.04\r\n\r\n**Description**\r\nWhen a Content-Length is set on a 304 response, the following exception occurs :\r\n```\r\njava.io.IOException: written 0 < 454 content-length\r\n        at org.eclipse.jetty.server.internal.HttpChannelState$ChannelResponse.write(HttpChannelState.java:1271)\r\n        at org.eclipse.jetty.server.Response$Wrapper.write(Response.java:768)\r\n        at org.eclipse.jetty.server.handler.ContextResponse.write(ContextResponse.java:56)\r\n        at org.eclipse.jetty.ee8.nested.HttpChannel.send(HttpChannel.java:837)\r\n        at org.eclipse.jetty.ee8.nested.HttpChannel.sendResponse(HttpChannel.java:822)\r\n        at org.eclipse.jetty.ee8.nested.HttpChannel.write(HttpChannel.java:891)\r\n        at org.eclipse.jetty.ee8.nested.HttpOutput.channelWrite(HttpOutput.java:286)\r\n        at org.eclipse.jetty.ee8.nested.HttpOutput.complete(HttpOutput.java:466)\r\n        at org.eclipse.jetty.ee8.nested.Response.completeOutput(Response.java:852)\r\n        at org.eclipse.jetty.ee8.nested.HttpChannel.handle(HttpChannel.java:553)\r\n        at org.eclipse.jetty.ee8.nested.ContextHandler$CoreContextHandler$CoreToNestedHandler.handle(ContextHandler.java:2376)\r\n        at org.eclipse.jetty.server.handler.ContextHandler.handle(ContextHandler.java:1060)\r\n        at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:151)\r\n        at org.eclipse.jetty.server.Server.handle(Server.java:182)\r\n        at org.eclipse.jetty.server.internal.HttpChannelState$HandlerInvoker.run(HttpChannelState.java:662)\r\n        at org.eclipse.jetty.server.internal.HttpConnection.onFillable(HttpConnection.java:414)\r\n        at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:322)\r\n        at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:99)\r\n        at org.eclipse.jetty.io.SelectableChannelEndPoint$1.run(SelectableChannelEndPoint.java:53)\r\n        at org.eclipse.jetty.util.thread.strategy.AdaptiveExecutionStrategy.runTask(AdaptiveExecutionStrategy.java:478)\r\n        at org.eclipse.jetty.util.thread.strategy.AdaptiveExecutionStrategy.consumeTask(AdaptiveExecutionStrategy.java:441)\r\n        at org.eclipse.jetty.util.thread.strategy.AdaptiveExecutionStrategy.tryProduce(AdaptiveExecutionStrategy.java:293)\r\n        at org.eclipse.jetty.util.thread.strategy.AdaptiveExecutionStrategy.run(AdaptiveExecutionStrategy.java:201)\r\n        at org.eclipse.jetty.util.thread.ReservedThreadExecutor$ReservedThread.run(ReservedThreadExecutor.java:311)\r\n        at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:979)\r\n        at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.doRunJob(QueuedThreadPool.java:1209)\r\n        at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:1164)\r\n        at java.base/java.lang.Thread.run(Thread.java:1583)\r\n```\r\nRFC7230 allows a Content-Length on 304 responses, see #4208.\r\nThe pull request that introduced this control: #10948.\r\n"", ""issue_word_count"": 395, ""test_files_count"": 2, ""non_test_files_count"": 2, ""pr_changed_files"": [""jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/ResourceService.java"", ""jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/internal/HttpChannelState.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/HttpServerTestBase.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/handler/ResourceHandlerTest.java""], ""pr_changed_test_files"": [""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/HttpServerTestBase.java"", ""jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/handler/ResourceHandlerTest.java""], ""base_commit"": ""51186eecca5a167e5eb9dd790b6121cc7a5d4231"", ""head_commit"": ""606c30cf0980001f7c450054e57190e0e0f0a08a"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/12484"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/12484"", ""dockerfile"": """", ""pr_merged_at"": ""2024-11-08T21:21:46.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/ResourceService.java b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/ResourceService.java\nindex 1dcdf600a9b5..b367f376ea01 100644\n--- a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/ResourceService.java\n+++ b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/ResourceService.java\n@@ -20,6 +20,7 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.EnumSet;\n import java.util.Enumeration;\n import java.util.List;\n import java.util.Map;\n@@ -58,6 +59,12 @@ public class ResourceService\n     private static final Logger LOG = LoggerFactory.getLogger(ResourceService.class);\n     private static final int NO_CONTENT_LENGTH = -1;\n     private static final int USE_KNOWN_CONTENT_LENGTH = -2;\n+    private static final EnumSet<HttpHeader> CONTENT_HEADERS = EnumSet.of(\n+        HttpHeader.LAST_MODIFIED,\n+        HttpHeader.CONTENT_LENGTH,\n+        HttpHeader.CONTENT_TYPE\n+    );\n+    private static final PreEncodedHttpField ACCEPT_RANGES_BYTES = new PreEncodedHttpField(HttpHeader.ACCEPT_RANGES, \""bytes\"");\n \n     private final List<CompressedContentFormat> _precompressedFormats = new ArrayList<>();\n     private final Map<String, List<String>> _preferredEncodingOrderCache = new ConcurrentHashMap<>();\n@@ -351,6 +358,7 @@ protected boolean passConditionalHeaders(Request request, Response response, Htt\n                         if (matched != null)\n                         {\n                             response.getHeaders().put(HttpHeader.ETAG, matched);\n+                            putNotModifiedHeaders(response, content);\n                             writeHttpError(request, response, callback, HttpStatus.NOT_MODIFIED_304);\n                             return true;\n                         }\n@@ -368,17 +376,18 @@ protected boolean passConditionalHeaders(Request request, Response response, Htt\n                 String mdlm = content.getLastModifiedValue();\n                 if (ifms.equals(mdlm))\n                 {\n+                    putNotModifiedHeaders(response, content);\n                     writeHttpError(request, response, callback, HttpStatus.NOT_MODIFIED_304);\n                     return true;\n                 }\n \n-                // TODO: what should we do when we get a crappy date?\n                 long ifmsl = HttpDateTime.parseToEpoch(ifms);\n                 if (ifmsl != -1)\n                 {\n                     long lm = content.getResource().lastModified().toEpochMilli();\n                     if (lm != -1 && lm / 1000 <= ifmsl / 1000)\n                     {\n+                        putNotModifiedHeaders(response, content);\n                         writeHttpError(request, response, callback, HttpStatus.NOT_MODIFIED_304);\n                         return true;\n                     }\n@@ -388,7 +397,6 @@ protected boolean passConditionalHeaders(Request request, Response response, Htt\n             // Parse the if[un]modified dates and compare to resource\n             if (ifums != null && ifm == null)\n             {\n-                // TODO: what should we do when we get a crappy date?\n                 long ifumsl = HttpDateTime.parseToEpoch(ifums);\n                 if (ifumsl != -1)\n                 {\n@@ -728,55 +736,55 @@ protected void writeHttpContent(Request request, Response response, Callback cal\n \n     protected void putHeaders(Response response, HttpContent content, long contentLength)\n     {\n-        // TODO it is very inefficient to do many put's to a HttpFields, as each put is a full iteration.\n-        //      it might be better remove headers en masse and then just add the extras:\n-        // NOTE: If these headers come from a Servlet Filter we shouldn't override them here.\n-//        headers.remove(EnumSet.of(\n-//            HttpHeader.LAST_MODIFIED,\n-//            HttpHeader.CONTENT_LENGTH,\n-//            HttpHeader.CONTENT_TYPE,\n-//            HttpHeader.CONTENT_ENCODING,\n-//            HttpHeader.ETAG,\n-//            HttpHeader.ACCEPT_RANGES,\n-//            HttpHeader.CACHE_CONTROL\n-//            ));\n-//        HttpField lm = content.getLastModified();\n-//        if (lm != null)\n-//            headers.add(lm);\n-//        etc.\n+        HttpFields.Mutable headers = response.getHeaders();\n \n+        // Existing etags have priority over content etags (often set by compression handler)\n+        if (_etags && !headers.contains(HttpHeader.ETAG))\n+        {\n+            HttpField et = content.getETag();\n+            if (et != null)\n+                headers.add(et);\n+        }\n+\n+        // Existing content encoding is kept only if not set for content.\n+        HttpField ce = content.getContentEncoding();\n+        if (ce != null)\n+            headers.put(ce);\n+\n+        // Remove content headers and re-add if we have them\n+        headers.remove(CONTENT_HEADERS);\n         HttpField lm = content.getLastModified();\n         if (lm != null)\n-            response.getHeaders().put(lm);\n-\n+            headers.add(lm);\n         if (contentLength == USE_KNOWN_CONTENT_LENGTH)\n-        {\n-            response.getHeaders().put(content.getContentLength());\n-        }\n+            headers.add(content.getContentLength());\n         else if (contentLength > NO_CONTENT_LENGTH)\n-        {\n-            response.getHeaders().put(HttpHeader.CONTENT_LENGTH, contentLength);\n-        }\n-\n+            headers.add(HttpHeader.CONTENT_LENGTH, contentLength);\n         HttpField ct = content.getContentType();\n         if (ct != null)\n-            response.getHeaders().put(ct);\n+            headers.add(ct);\n \n-        HttpField ce = content.getContentEncoding();\n-        if (ce != null)\n-            response.getHeaders().put(ce);\n+        putHeaders(response);\n+    }\n \n-        if (_etags)\n-        {\n-            HttpField et = content.getETag();\n-            if (et != null)\n-                response.getHeaders().put(et);\n-        }\n+    protected void putNotModifiedHeaders(Response response, HttpContent content)\n+    {\n+        HttpFields.Mutable headers = response.getHeaders();\n+        // send only lastModified, as it is too difficult to determine the etag with compression\n+        HttpField lm = content.getLastModified();\n+        if (lm != null)\n+            headers.put(lm);\n \n-        if (_acceptRanges && !response.getHeaders().contains(HttpHeader.ACCEPT_RANGES))\n-            response.getHeaders().put(new PreEncodedHttpField(HttpHeader.ACCEPT_RANGES, \""bytes\""));\n-        if (_cacheControl != null && !response.getHeaders().contains(HttpHeader.CACHE_CONTROL))\n-            response.getHeaders().put(_cacheControl);\n+        putHeaders(response);\n+    }\n+\n+    protected void putHeaders(Response response)\n+    {\n+        HttpFields.Mutable headers = response.getHeaders();\n+        if (_acceptRanges && !headers.contains(HttpHeader.ACCEPT_RANGES))\n+            headers.add(ACCEPT_RANGES_BYTES);\n+        if (_cacheControl != null && !headers.contains(HttpHeader.CACHE_CONTROL))\n+            headers.add(_cacheControl);\n     }\n \n     /**\n\ndiff --git a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/internal/HttpChannelState.java b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/internal/HttpChannelState.java\nindex f0758d5084ee..b315e9353806 100644\n--- a/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/internal/HttpChannelState.java\n+++ b/jetty-core/jetty-server/src/main/java/org/eclipse/jetty/server/internal/HttpChannelState.java\n@@ -1250,7 +1250,8 @@ public void write(boolean last, ByteBuffer content, Callback callback)\n                         long committedContentLength = httpChannelState._committedContentLength;\n                         long contentLength = committedContentLength >= 0 ? committedContentLength : getHeaders().getLongField(HttpHeader.CONTENT_LENGTH);\n \n-                        if (contentLength >= 0 && totalWritten != contentLength)\n+                        if (contentLength >= 0 && totalWritten != contentLength &&\n+                            !(totalWritten == 0 && (HttpMethod.HEAD.is(_request.getMethod()) || getStatus() == HttpStatus.NOT_MODIFIED_304)))\n                         {\n                             // If the content length were not compatible with what was written, then we need to abort.\n                             String lengthError = null;\n@@ -1525,7 +1526,9 @@ public void succeeded()\n                 long totalWritten = response._contentBytesWritten;\n                 long committedContentLength = httpChannelState._committedContentLength;\n \n-                if (committedContentLength >= 0 && committedContentLength != totalWritten && !(totalWritten == 0 && HttpMethod.HEAD.is(_request.getMethod())))\n+                if (committedContentLength >= 0 &&\n+                    committedContentLength != totalWritten &&\n+                    !(totalWritten == 0 && (HttpMethod.HEAD.is(_request.getMethod()) || response.getStatus() == HttpStatus.NOT_MODIFIED_304)))\n                     failure = ExceptionUtil.combine(failure, new IOException(\""content-length %d != %d written\"".formatted(committedContentLength, totalWritten)));\n \n                 // Is the request fully consumed?\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/HttpServerTestBase.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/HttpServerTestBase.java\nindex 2a2b1a6cedc9..a0a76f546884 100644\n--- a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/HttpServerTestBase.java\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/HttpServerTestBase.java\n@@ -1456,6 +1456,39 @@ public boolean handle(Request request, Response response, Callback callback) thr\n         }\n     }\n \n+    @Test\n+    public void test304WithContentLength() throws Exception\n+    {\n+        startServer(new Handler.Abstract()\n+        {\n+            @Override\n+            public boolean handle(Request request, Response response, Callback callback) throws Exception\n+            {\n+                response.setStatus(304);\n+                response.getHeaders().add(HttpHeader.CONTENT_LENGTH, 10);\n+                callback.succeeded();\n+                return true;\n+            }\n+        });\n+\n+        try (Socket client = newSocket(_serverURI.getHost(), _serverURI.getPort()))\n+        {\n+            OutputStream os = client.getOutputStream();\n+            InputStream is = client.getInputStream();\n+\n+            os.write((\""\""\""\n+                GET /R1 HTTP/1.1\\r\n+                Host: localhost\\r\n+                Connection: close\\r\n+                \n+                \""\""\"").getBytes(StandardCharsets.ISO_8859_1));\n+\n+            String in = IO.toString(is);\n+            assertThat(in, containsString(\""304 Not Modified\""));\n+            assertThat(in, containsString(\""Content-Length: 10\""));\n+        }\n+    }\n+\n     @Test\n     public void testBlockedClient() throws Exception\n     {\n\ndiff --git a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/handler/ResourceHandlerTest.java b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/handler/ResourceHandlerTest.java\nindex 6643cd6fbe0c..edadd36f69a6 100644\n--- a/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/handler/ResourceHandlerTest.java\n+++ b/jetty-core/jetty-server/src/test/java/org/eclipse/jetty/server/handler/ResourceHandlerTest.java\n@@ -1480,6 +1480,7 @@ public void testCachingPrecompressedFilesCachedEtagged() throws Exception\n                     \\r\n                     \""\""\"".formatted(eTag1)));\n             assertThat(response3.getStatus(), is(HttpStatus.NOT_MODIFIED_304));\n+            assertThat(response3.getField(ETAG), notNullValue());\n \n             HttpTester.Response response4 = HttpTester.parseResponse(\n                     _local.getResponse(\""\""\""\n@@ -1491,6 +1492,7 @@ public void testCachingPrecompressedFilesCachedEtagged() throws Exception\n                     \\r\n                     \""\""\"".formatted(eTag2)));\n             assertThat(response4.getStatus(), is(HttpStatus.NOT_MODIFIED_304));\n+            assertThat(response3.getField(ETAG), notNullValue());\n         }\n \n         assertThat(contentFactory.getCachedFiles(), is(2));\n@@ -1989,6 +1991,7 @@ public void testEtagIfNoneMatchNotModifiedFile() throws Exception\n                 \\r\n                 \""\""\"".formatted(etag)));\n         assertThat(response.getStatus(), is(HttpStatus.NOT_MODIFIED_304));\n+        assertThat(response.getField(ETAG), notNullValue());\n         assertThat(response.getContent(), is(\""\""));\n     }\n \n@@ -2346,6 +2349,7 @@ public void testIfETag(String content) throws Exception\n             \""\""\"".replace(\""@ETAG@\"", etag));\n         response = HttpTester.parseResponse(rawResponse);\n         assertThat(response.toString(), response.getStatus(), is(HttpStatus.NOT_MODIFIED_304));\n+        assertThat(response.getField(ETAG), notNullValue());\n \n         rawResponse = _local.getResponse(\""\""\""\n             GET /context/file.txt HTTP/1.1\\r\n@@ -2356,6 +2360,7 @@ public void testIfETag(String content) throws Exception\n             \""\""\"".replace(\""@ETAG@\"", etag));\n         response = HttpTester.parseResponse(rawResponse);\n         assertThat(response.toString(), response.getStatus(), is(HttpStatus.NOT_MODIFIED_304));\n+        assertThat(response.getField(ETAG), notNullValue());\n \n         rawResponse = _local.getResponse(\""\""\""\n             GET /context/file.txt HTTP/1.1\\r\n@@ -2468,6 +2473,7 @@ public void testIfModified(String content) throws Exception\n             \""\""\"".replace(\""@LASTMODIFIED@\"", lastModified));\n         response = HttpTester.parseResponse(rawResponse);\n         assertThat(response.toString(), response.getStatus(), is(HttpStatus.NOT_MODIFIED_304));\n+        assertThat(response.getField(LAST_MODIFIED), notNullValue());\n \n         rawResponse = _local.getResponse(\""\""\""\n             GET /context/file.txt HTTP/1.1\\r\n@@ -2488,6 +2494,7 @@ public void testIfModified(String content) throws Exception\n             \""\""\"".replace(\""@DATE@\"", DateGenerator.formatDate(System.currentTimeMillis() + 10000)));\n         response = HttpTester.parseResponse(rawResponse);\n         assertThat(response.toString(), response.getStatus(), is(HttpStatus.NOT_MODIFIED_304));\n+        assertThat(response.getField(LAST_MODIFIED), notNullValue());\n \n         rawResponse = _local.getResponse(\""\""\""\n             GET /context/file.txt HTTP/1.1\\r\n@@ -2537,6 +2544,7 @@ public void testIfModifiedSince() throws Exception\n                 \""\""\"".formatted(lastModified)));\n \n         assertThat(response.getStatus(), equalTo(304));\n+        assertThat(response.getField(LAST_MODIFIED), notNullValue());\n         assertThat(response.getContent(), is(\""\""));\n \n         response = HttpTester.parseResponse(\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-12449"", ""pr_id"": 12449, ""issue_id"": 12324, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Response compression does not work when the `Accept-Encoding: *` request header is used.\n**Jetty version(s)**\r\nUp to 12.0.x\r\n\r\n**Jetty Environment**\r\ncore\r\n\r\n**Java version/vendor** `(use: java -version)`\r\nNot relevant\r\n\r\n**OS type/version**\r\nNot relevant\r\n\r\n**Description**\r\nThis doesn't really affect anything, but it is unexpected. According to [RF9110 12.5.3](https://www.rfc-editor.org/rfc/rfc9110.html#section-12.5.3-6),\r\n> The asterisk \""*\"" symbol in an Accept-Encoding field matches any available content coding not explicitly listed in the field.\r\n\r\nHowever, the `HttpField` class' `contains` [method](https://github.com/jetty/jetty.project/blob/jetty-12.0.x/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpField.java#L203) does not check for a lone `*` character. So when `Accept-Encoding: *` is passed as a request header, the `GzipHandler`'s `getDeflaterEntry` believes that `gzip` is not accepted, and returns `null`. \r\n\r\n**How to reproduce?**\r\nRun a simple web server with the `GzipHandler` installed, and send a request with `Accept-Encoding: *`. The response will not contain the `Content-Encoding: gzip` header, and the body will not be compressed.\r\n\r\n\r\n"", ""issue_word_count"": 183, ""test_files_count"": 2, ""non_test_files_count"": 3, ""pr_changed_files"": [""jetty-core/jetty-compression/jetty-compression-server/pom.xml"", ""jetty-core/jetty-compression/jetty-compression-server/src/main/java/org/eclipse/jetty/compression/server/CompressionConfig.java"", ""jetty-core/jetty-compression/jetty-compression-server/src/main/java/org/eclipse/jetty/compression/server/CompressionHandler.java"", ""jetty-core/jetty-compression/jetty-compression-server/src/test/java/org/eclipse/jetty/compression/server/CompressionConfigTest.java"", ""jetty-core/jetty-compression/jetty-compression-tests/src/test/java/org/eclipse/jetty/compression/CompressionHandlerTest.java""], ""pr_changed_test_files"": [""jetty-core/jetty-compression/jetty-compression-server/src/test/java/org/eclipse/jetty/compression/server/CompressionConfigTest.java"", ""jetty-core/jetty-compression/jetty-compression-tests/src/test/java/org/eclipse/jetty/compression/CompressionHandlerTest.java""], ""base_commit"": ""d6eb403f5da6d3260bad33af07cf8466fef544a3"", ""head_commit"": ""b577942e84fe8a7d0761f3dec5347a3f09aa0235"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/12449"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/12449"", ""dockerfile"": """", ""pr_merged_at"": ""2024-11-11T15:24:29.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-compression/jetty-compression-server/pom.xml b/jetty-core/jetty-compression/jetty-compression-server/pom.xml\nindex b1365c9e5cc9..dc4e7fbc4567 100644\n--- a/jetty-core/jetty-compression/jetty-compression-server/pom.xml\n+++ b/jetty-core/jetty-compression/jetty-compression-server/pom.xml\n@@ -26,5 +26,10 @@\n       <artifactId>jetty-compression-api</artifactId>\n       <version>${project.version}</version>\n     </dependency>\n+    <dependency>\n+      <groupId>org.eclipse.jetty</groupId>\n+      <artifactId>jetty-slf4j-impl</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n   </dependencies>\n </project>\n\ndiff --git a/jetty-core/jetty-compression/jetty-compression-server/src/main/java/org/eclipse/jetty/compression/server/CompressionConfig.java b/jetty-core/jetty-compression/jetty-compression-server/src/main/java/org/eclipse/jetty/compression/server/CompressionConfig.java\nindex ffae8ed79d3f..eedfcffd0123 100644\n--- a/jetty-core/jetty-compression/jetty-compression-server/src/main/java/org/eclipse/jetty/compression/server/CompressionConfig.java\n+++ b/jetty-core/jetty-compression/jetty-compression-server/src/main/java/org/eclipse/jetty/compression/server/CompressionConfig.java\n@@ -13,6 +13,7 @@\n \n package org.eclipse.jetty.compression.server;\n \n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n@@ -35,13 +36,13 @@\n  * Configuration for a specific compression behavior per matching path from the {@link CompressionHandler}.\n  *\n  * <p>\n- *    Configuration is split between compression (of responses) and decompression (of requests).\n+ * Configuration is split between compression (of responses) and decompression (of requests).\n  * </p>\n  *\n  * <p>\n- *    Experimental Configuration, subject to change while the implementation is being settled.\n- *    Please provide feedback at the <a href=\""https://github.com/jetty/jetty.project/issues\"">Jetty Issue tracker</a>\n- *    to influence the direction / development of these experimental features.\n+ * Experimental Configuration, subject to change while the implementation is being settled.\n+ * Please provide feedback at the <a href=\""https://github.com/jetty/jetty.project/issues\"">Jetty Issue tracker</a>\n+ * to influence the direction / development of these experimental features.\n  * </p>\n  */\n @ManagedObject(\""Compression Configuration\"")\n@@ -79,11 +80,16 @@ public class CompressionConfig extends AbstractLifeCycle\n      * Set of paths that support decompressing Request content.\n      */\n     private final IncludeExcludeSet<String, String> decompressPaths;\n+    /**\n+     * Optional preferred order of encoders for compressing Response content.\n+     */\n+    private final List<String> compressPreferredEncoderOrder;\n \n     private final HttpField vary;\n \n     private CompressionConfig(Builder builder)\n     {\n+        this.compressPreferredEncoderOrder = builder.compressPreferredEncoderOrder;\n         this.compressEncodings = builder.compressEncodings.asImmutable();\n         this.decompressEncodings = builder.decompressEncodings.asImmutable();\n         this.compressMethods = builder.decompressMethods.asImmutable();\n@@ -178,20 +184,40 @@ public Set<String> getCompressPathIncludes()\n         return Collections.unmodifiableSet(includes);\n     }\n \n+    /**\n+     * Get the preferred order of encoders for compressing response content.\n+     *\n+     * <p>\n+     *     See {@link Builder#compressPreferredEncoderOrder(List)} for details\n+     *     on how the {@code Accept-Encoding} request header interacts with\n+     *     this configuration.\n+     * </p>\n+     *\n+     * @return the preferred order of encoders.\n+     * @see Builder#compressPreferredEncoderOrder(List)\n+     */\n+    @ManagedAttribute()\n+    public List<String> getCompressPreferredEncoderOrder()\n+    {\n+        return Collections.unmodifiableList(compressPreferredEncoderOrder);\n+    }\n+\n+    /**\n+     * Return the encoder that best matches the provided details.\n+     *\n+     * @param requestAcceptEncoding the HTTP {@code Accept-Encoding} header list (includes only supported encodings,\n+     *      and possibly the {@code *} glob value)\n+     * @param request the request itself\n+     * @param pathInContext the path in context\n+     * @return the selected compression encoding\n+     */\n     public String getCompressionEncoding(List<String> requestAcceptEncoding, Request request, String pathInContext)\n     {\n         if (requestAcceptEncoding == null || requestAcceptEncoding.isEmpty())\n             return null;\n \n-        String matchedEncoding = null;\n-\n-        for (String encoding : requestAcceptEncoding)\n-        {\n-            if (compressEncodings.test(encoding))\n-            {\n-                matchedEncoding = encoding;\n-            }\n-        }\n+        List<String> preferredEncoders = calcPreferredEncoders(requestAcceptEncoding);\n+        String matchedEncoding = selectEncoderMatch(preferredEncoders);\n \n         if (matchedEncoding == null)\n             return null;\n@@ -205,6 +231,44 @@ public String getCompressionEncoding(List<String> requestAcceptEncoding, Request\n         return matchedEncoding;\n     }\n \n+    protected List<String> calcPreferredEncoders(List<String> requestAcceptEncoding)\n+    {\n+        if (compressPreferredEncoderOrder.isEmpty())\n+        {\n+            List<String> result = new ArrayList<>(requestAcceptEncoding);\n+            result.removeIf((str) -> str.equals(\""*\""));\n+            return result;\n+        }\n+\n+        if (requestAcceptEncoding.contains(\""*\""))\n+        {\n+            // anything else in request Accept-Encoding is moot if glob exists.\n+            return compressPreferredEncoderOrder;\n+        }\n+\n+        List<String> preferredEncoderOrder = new ArrayList<>();\n+        for (String preferredEncoder: compressPreferredEncoderOrder)\n+        {\n+            if (requestAcceptEncoding.contains(preferredEncoder))\n+            {\n+                preferredEncoderOrder.add(preferredEncoder);\n+            }\n+        }\n+        return preferredEncoderOrder;\n+    }\n+\n+    protected String selectEncoderMatch(List<String> preferredEncoders)\n+    {\n+        for (String encoding : preferredEncoders)\n+        {\n+            if (compressEncodings.test(encoding))\n+            {\n+                return encoding;\n+            }\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Get the set of excluded HTTP methods for Request decompression.\n      *\n@@ -362,6 +426,11 @@ public static class Builder\n          * Mime-Types that support compressing Response content.\n          */\n         private final IncludeExclude<String> decompressMimeTypes = new IncludeExclude<>(AsciiLowerCaseSet.class);\n+        /**\n+         * Optional preferred order of encoders for compressing Response content.\n+         */\n+        private final List<String> compressPreferredEncoderOrder = new ArrayList<>();\n+\n         private HttpField vary = new PreEncodedHttpField(HttpHeader.VARY, HttpHeader.ACCEPT_ENCODING.asString());\n \n         public CompressionConfig build()\n@@ -485,6 +554,81 @@ public Builder compressPathInclude(String pathSpecString)\n             return this;\n         }\n \n+        /**\n+         * Control the preferred order of encoders when compressing response content.\n+         *\n+         * <p>\n+         *     If set to an empty List this preferred order is not considered\n+         *     when selecting the encoder from the {@code Accept-Encoding} Request header.\n+         * </p>\n+         * <p>\n+         *     If set, the union of matching encoders is the end result used to determine\n+         *     what encoder should be used for compressing response content.\n+         * </p>\n+         * <p>\n+         *     Of special note, the {@code Accept-Encoding: *} (glob) header value will\n+         *     return the {@code compressPreferredEncoderOrder} if provided here, otherwise\n+         *     the {@code *} (glob) header value will be ignored if this\n+         *     {@code compressPreferredEncoderOrder} is not provided.\n+         * </p>\n+         * <table style=\""border: 1px solid black; border-collapse: separate; border-spacing: 0px;\"">\n+         * <caption style=\""font-weight: bold; font-size: 1.2em\"">Encoder order resolution</caption>\n+         * <colgroup>\n+         *     <col><col><col>\n+         * </colgroup>\n+         * <thead style=\""background-color: lightgray\"">\n+         * <tr>\n+         *     <th>{@code compressPreferredEncoderOrder}</th>\n+         *     <th>{@code Accept-Encoding} header</th>\n+         *     <th>Resulting encoders considered</th>\n+         * </tr>\n+         * </thead>\n+         * <tbody style=\""text-align: left; vertical-align: top;\"">\n+         * <tr>\n+         *     <td>{@code <empty>}</td>\n+         *     <td>{@code gzip, br}</td>\n+         *     <td>{@code gzip, br}</td>\n+         * </tr>\n+         * <tr>\n+         *     <td>{@code <empty>}</td>\n+         *     <td>{@code br, gzip}</td>\n+         *     <td>{@code br, gzip}</td>\n+         * </tr>\n+         * <tr>\n+         *     <td>{@code br, gzip}</td>\n+         *     <td>{@code gzip, br, zstd}</td>\n+         *     <td>{@code br, gzip}</td>\n+         * </tr>\n+         * <tr>\n+         *     <td>{@code zstd, br}</td>\n+         *     <td>{@code gzip, br}</td>\n+         *     <td>{@code br}</td>\n+         * </tr>\n+         * <tr>\n+         *     <td>{@code zstd, br, gzip}</td>\n+         *     <td>{@code *}</td>\n+         *     <td>{@code zstd, br, gzip}</td>\n+         * </tr>\n+         * <tr>\n+         *     <td>{@code <empty>}</td>\n+         *     <td>{@code *}</td>\n+         *     <td>{@code <empty>}</td>\n+         * </tr>\n+         * </tbody>\n+         * </table>\n+         *\n+         * @param encoders the encoders, in order, to use for compressing response content.\n+         *   Will replace any previously set order.\n+         * @return this builder.\n+         */\n+        public Builder compressPreferredEncoderOrder(List<String> encoders)\n+        {\n+            this.compressPreferredEncoderOrder.clear();\n+            if (encoders != null)\n+                this.compressPreferredEncoderOrder.addAll(encoders);\n+            return this;\n+        }\n+\n         /**\n          * A {@code Content-Encoding} encoding to exclude.\n          *\n@@ -639,7 +783,7 @@ else if (type.startsWith(\""image/\"") ||\n                 \""application/zstd\"",\n                 // It is possible to use SSE with CompressionHandler, but only if you use `gzip` encoding with syncFlush to true which will impact performance.\n                 \""text/event-stream\""\n-                ).forEach((type) ->\n+            ).forEach((type) ->\n             {\n                 compressMimeTypeExclude(type);\n                 decompressMimeTypeExclude(type);\n\ndiff --git a/jetty-core/jetty-compression/jetty-compression-server/src/main/java/org/eclipse/jetty/compression/server/CompressionHandler.java b/jetty-core/jetty-compression/jetty-compression-server/src/main/java/org/eclipse/jetty/compression/server/CompressionHandler.java\nindex 35a180c46feb..e9e3b099324f 100644\n--- a/jetty-core/jetty-compression/jetty-compression-server/src/main/java/org/eclipse/jetty/compression/server/CompressionHandler.java\n+++ b/jetty-core/jetty-compression/jetty-compression-server/src/main/java/org/eclipse/jetty/compression/server/CompressionHandler.java\n@@ -14,10 +14,10 @@\n package org.eclipse.jetty.compression.server;\n \n import java.util.ArrayList;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.ListIterator;\n import java.util.Map;\n+import java.util.TreeMap;\n \n import org.eclipse.jetty.compression.Compression;\n import org.eclipse.jetty.http.EtagUtils;\n@@ -25,6 +25,7 @@\n import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.MimeTypes;\n+import org.eclipse.jetty.http.pathmap.MappedResource;\n import org.eclipse.jetty.http.pathmap.MatchedResource;\n import org.eclipse.jetty.http.pathmap.PathMappings;\n import org.eclipse.jetty.http.pathmap.PathSpec;\n@@ -63,8 +64,7 @@ public class CompressionHandler extends Handler.Wrapper\n     public static final String HANDLER_ETAGS = CompressionHandler.class.getPackageName() + \"".ETag\"";\n \n     private static final Logger LOG = LoggerFactory.getLogger(CompressionHandler.class);\n-    // TODO: make into a case-insensitive map\n-    private final Map<String, Compression> supportedEncodings = new HashMap<>();\n+    private final Map<String, Compression> supportedEncodings = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n     private final PathMappings<CompressionConfig> pathConfigs = new PathMappings<CompressionConfig>();\n \n     public CompressionHandler()\n@@ -228,7 +228,7 @@ public boolean handle(final Request request, final Response response, final Call\n                         {\n                             String lvalue = StringUtil.asciiToLowerCase(value);\n                             // only track encodings that are supported by this handler\n-                            if (supportedEncodings.containsKey(lvalue))\n+                            if (\""*\"".equals(value) || supportedEncodings.containsKey(lvalue))\n                             {\n                                 if (requestAcceptEncoding == null)\n                                     requestAcceptEncoding = new ArrayList<>();\n@@ -317,6 +317,26 @@ protected void doStart() throws Exception\n                     .build());\n         }\n \n+        // ensure that the preferred encoder order is sane for the configuration.\n+        for (MappedResource<CompressionConfig> pathConfig : pathConfigs)\n+        {\n+            List<String> preferredEncoders = pathConfig.getResource().getCompressPreferredEncoderOrder();\n+            if (preferredEncoders.isEmpty())\n+                continue;\n+            ListIterator<String> preferredIter = preferredEncoders.listIterator();\n+            while (preferredIter.hasNext())\n+            {\n+                String listedEncoder = preferredIter.next();\n+                if (!supportedEncodings.containsKey(listedEncoder))\n+                {\n+                    LOG.warn(\""Unable to find compression encoder {} from configuration for pathspec {} in registered compression encoders [{}]\"",\n+                        listedEncoder, pathConfig.getPathSpec(),\n+                        String.join(\"", \"", supportedEncodings.keySet()));\n+                    preferredIter.remove(); // remove bad encoding\n+                }\n+            }\n+        }\n+\n         super.doStart();\n     }\n \n"", ""test_patch"": ""diff --git a/jetty-core/jetty-compression/jetty-compression-server/src/test/java/org/eclipse/jetty/compression/server/CompressionConfigTest.java b/jetty-core/jetty-compression/jetty-compression-server/src/test/java/org/eclipse/jetty/compression/server/CompressionConfigTest.java\nnew file mode 100644\nindex 000000000000..b503bb25e135\n--- /dev/null\n+++ b/jetty-core/jetty-compression/jetty-compression-server/src/test/java/org/eclipse/jetty/compression/server/CompressionConfigTest.java\n@@ -0,0 +1,65 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.compression.server;\n+\n+import java.util.List;\n+\n+import org.eclipse.jetty.http.QuotedQualityCSV;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.hasSize;\n+\n+public class CompressionConfigTest\n+{\n+    private static List<String> qcsv(String rawheadervalue)\n+    {\n+        QuotedQualityCSV csv = new QuotedQualityCSV();\n+        csv.addValue(rawheadervalue);\n+        return csv.getValues();\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource(useHeadersInDisplayName = true, delimiterString = \""|\"", textBlock = \""\""\""\n+        PreferredEncoders | AcceptEncodings | ExpectedResult\n+                          | gzip, br        | gzip, br\n+                          | br, gzip        | br, gzip\n+        br, gzip          | gzip, br        | br, gzip\n+        zstd, br          | gzip, br, zstd  | zstd, br\n+        zstd, br, gzip    | *               | zstd, br, gzip\n+                          | *               |   \n+        \""\""\"")\n+    public void testCalcPreferredEncoders(String preferredEncoderOrderCsv, String acceptEncodingHeaderValuesCsv, String expectedEncodersCsv)\n+    {\n+        List<String> preferredEncoderOrder = qcsv(preferredEncoderOrderCsv);\n+        List<String> acceptEncodingHeaderValues = qcsv(acceptEncodingHeaderValuesCsv);\n+        List<String> expectedEncodersResult = qcsv(expectedEncodersCsv);\n+\n+        CompressionConfig config = CompressionConfig.builder()\n+            .compressPreferredEncoderOrder(preferredEncoderOrder)\n+            .build();\n+        List<String> result = config.calcPreferredEncoders(acceptEncodingHeaderValues);\n+        if (expectedEncodersResult.isEmpty())\n+        {\n+            assertThat(result, hasSize(0));\n+        }\n+        else\n+        {\n+            String[] expected = expectedEncodersResult.toArray(new String[0]);\n+            assertThat(result, contains(expected));\n+        }\n+    }\n+}\n\ndiff --git a/jetty-core/jetty-compression/jetty-compression-tests/src/test/java/org/eclipse/jetty/compression/CompressionHandlerTest.java b/jetty-core/jetty-compression/jetty-compression-tests/src/test/java/org/eclipse/jetty/compression/CompressionHandlerTest.java\nindex c5d96fe1ad41..ba4915549d06 100644\n--- a/jetty-core/jetty-compression/jetty-compression-tests/src/test/java/org/eclipse/jetty/compression/CompressionHandlerTest.java\n+++ b/jetty-core/jetty-compression/jetty-compression-tests/src/test/java/org/eclipse/jetty/compression/CompressionHandlerTest.java\n@@ -21,10 +21,15 @@\n import org.eclipse.jetty.client.BytesRequestContent;\n import org.eclipse.jetty.client.ContentResponse;\n import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.compression.brotli.BrotliCompression;\n+import org.eclipse.jetty.compression.gzip.GzipCompression;\n import org.eclipse.jetty.compression.server.CompressionConfig;\n import org.eclipse.jetty.compression.server.CompressionHandler;\n+import org.eclipse.jetty.compression.zstandard.ZstandardCompression;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.QuotedQualityCSV;\n+import org.eclipse.jetty.io.ArrayByteBufferPool;\n import org.eclipse.jetty.io.Content;\n import org.eclipse.jetty.server.Handler;\n import org.eclipse.jetty.server.Request;\n@@ -33,6 +38,7 @@\n import org.eclipse.jetty.server.ServerConnector;\n import org.eclipse.jetty.toolchain.test.MavenPaths;\n import org.eclipse.jetty.util.Callback;\n+import org.eclipse.jetty.util.StringUtil;\n import org.eclipse.jetty.util.component.LifeCycle;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n@@ -563,6 +569,90 @@ public boolean handle(Request request, Response response, Callback callback) thr\n         }\n     }\n \n+    /**\n+     * Testing how CompressionHandler acts with multiple compression implementation added\n+     * (brotli, gzip, and zstandard are all added enabled),\n+     * and the {@link CompressionConfig#getCompressPreferredEncoderOrder()} configuration.\n+     * Also tests the handling of {@code Accept-Encoding: *} request headers.\n+     */\n+    @ParameterizedTest\n+    @CsvSource(useHeadersInDisplayName = true, delimiterString = \""|\"", textBlock = \""\""\""\n+        acceptEncoding | preferredEncoding | expectedContentEncoding\n+        br             | gzip, br          | br\n+        br, gzip       | gzip, br          | gzip\n+                       | br, zstd          |\n+        *              | zstd, br, gzip    | zstd\n+        *              |                   | \n+        \""\""\"")\n+    public void testCompressPreferredEncoders(\n+        String acceptEncodingHeader,\n+        String preferredEncodingCsv,\n+        String expectedContentEncoding) throws Exception\n+    {\n+        pool = new ArrayByteBufferPool.Tracking();\n+        GzipCompression gzipCompression = new GzipCompression();\n+        gzipCompression.setByteBufferPool(pool);\n+        BrotliCompression brotliCompression = new BrotliCompression();\n+        brotliCompression.setByteBufferPool(pool);\n+        ZstandardCompression zstdCompression = new ZstandardCompression();\n+        zstdCompression.setByteBufferPool(pool);\n+\n+        String resourceName = \""texts/quotes.txt\"";\n+        String resourceContentType = \""text/plain;charset=utf-8\"";\n+        String requestedPath = \""/path/to/quotes.txt\"";\n+\n+        Path resourcePath = MavenPaths.findTestResourceFile(resourceName);\n+        byte[] resourceBody = Files.readAllBytes(resourcePath);\n+\n+        CompressionHandler compressionHandler = new CompressionHandler();\n+        compressionHandler.addCompression(gzipCompression);\n+        compressionHandler.addCompression(brotliCompression);\n+        compressionHandler.addCompression(zstdCompression);\n+\n+        QuotedQualityCSV qcsv = new QuotedQualityCSV();\n+        qcsv.addValue(preferredEncodingCsv);\n+        CompressionConfig config = CompressionConfig.builder()\n+            .compressPreferredEncoderOrder(qcsv.getValues())\n+            .build();\n+\n+        compressionHandler.putConfiguration(\""/\"", config);\n+        compressionHandler.setHandler(new Handler.Abstract()\n+        {\n+            @Override\n+            public boolean handle(Request request, Response response, Callback callback) throws Exception\n+            {\n+                response.setStatus(200);\n+                response.getHeaders().put(HttpHeader.CONTENT_TYPE, resourceContentType);\n+                response.write(true, ByteBuffer.wrap(resourceBody), callback);\n+                return true;\n+            }\n+        });\n+\n+        startServer(compressionHandler);\n+\n+        URI serverURI = server.getURI();\n+        client.getContentDecoderFactories().clear();\n+\n+        ContentResponse response = client.newRequest(serverURI.getHost(), serverURI.getPort())\n+            .method(HttpMethod.GET)\n+            .headers((headers) ->\n+            {\n+                headers.put(HttpHeader.ACCEPT_ENCODING, acceptEncodingHeader);\n+            })\n+            .path(requestedPath)\n+            .send();\n+        dumpResponse(response);\n+        assertThat(response.getStatus(), is(200));\n+        if (StringUtil.isNotBlank(expectedContentEncoding))\n+        {\n+            assertThat(response.getHeaders().get(HttpHeader.CONTENT_ENCODING), is(expectedContentEncoding));\n+        }\n+        else\n+        {\n+            assertFalse(response.getHeaders().contains(HttpHeader.CONTENT_ENCODING));\n+        }\n+    }\n+\n     private void dumpResponse(org.eclipse.jetty.client.Response response)\n     {\n         System.out.printf(\""  %s %d %s%n\"", response.getVersion(), response.getStatus(), response.getReason());\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-12441"", ""pr_id"": 12441, ""issue_id"": 12429, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""HandshakeRequest getHeaders are case sensitive.\n**Jetty version(s)**\r\n12.0.14\r\n\r\n**Jetty Environment**\r\nee8\r\n\r\n**Java version/vendor** `(use: java -version)`\r\n17.0.12\r\n\r\n**OS type/version**\r\nUbuntu 24.04.1 LTS\r\n\r\n**Description**\r\nIn JsrHandshakeRequest the method getHeaders() is case sensitive.\r\n\r\nIn JavaEE8 and JakartaEE9/10 \r\nhttps://javaee.github.io/javaee-spec/javadocs/javax/websocket/server/HandshakeRequest.html#getHeaders--\r\n_Return the read only Map of Http Headers that came with the handshake request. The header names are case insensitive._\r\n\r\n**How to reproduce?**\r\n\r\n* In Jetty 9.4.56 : \r\n  * hReq..getHeaders().get(\""cookie\"") return headers for Cookie\r\n  * hReq..getHeaders().get(\""Cookie\"")  return headers for Cookie\r\n* In Jetty 12.0.14 :\r\n  * hReq..getHeaders().get(\""cookie\"") is null\r\n  * hReq..getHeaders().get(\""Cookie\"") return headers for Cookie\r\n\r\n\r\n\r\n\r\n"", ""issue_word_count"": 122, ""test_files_count"": 6, ""non_test_files_count"": 28, ""pr_changed_files"": [""jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java"", ""jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpFieldsMap.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/internal/DelegatedJettyClientUpgradeRequest.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/internal/DelegatedJettyClientUpgradeResponse.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/ServerWebSocketContainer.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/internal/UpgradeRequestDelegate.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/internal/UpgradeResponseDelegate.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-client/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/client/internal/JsrUpgradeListener.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/JakartaWebSocketServerContainer.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JakartaWebSocketCreator.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JsrHandshakeRequest.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JsrHandshakeResponse.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/UpgradeHeadersTest.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/client/AnnotatedClientEndpointTest.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/JettyWebSocketServerContainer.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/JettyWebSocketServlet.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/DelegatedServerUpgradeRequest.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/DelegatedServerUpgradeResponse.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/JettyServerFrameHandlerFactory.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee10/websocket/tests/UpgradeHeadersTest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-client/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/client/internal/JsrUpgradeListener.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/JakartaWebSocketServerContainer.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JakartaWebSocketCreator.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JsrHandshakeRequest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JsrHandshakeResponse.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/UpgradeHeadersTest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/client/AnnotatedClientEndpointTest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/impl/DelegatedJettyClientUpgradeRequest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/impl/DelegatedJettyClientUpgradeResponse.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/JettyWebSocketServerContainer.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/JettyWebSocketServlet.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/internal/DelegatedServerUpgradeRequest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/internal/DelegatedServerUpgradeResponse.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/UpgradeHeadersTest.java""], ""pr_changed_test_files"": [""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/UpgradeHeadersTest.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/client/AnnotatedClientEndpointTest.java"", ""jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee10/websocket/tests/UpgradeHeadersTest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/UpgradeHeadersTest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/client/AnnotatedClientEndpointTest.java"", ""jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/UpgradeHeadersTest.java""], ""base_commit"": ""57f1313b36e73c31611a2806134c6edf53b10f78"", ""head_commit"": ""7eb54fa9aada3969dbc06998c0ee5ead1f95b3d4"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/12441"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/12441"", ""dockerfile"": """", ""pr_merged_at"": ""2024-11-12T03:56:12.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java\nindex 66db59325e36..c810498886b2 100644\n--- a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java\n+++ b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpFields.java\n@@ -927,6 +927,21 @@ default int size()\n         return size;\n     }\n \n+    /**\n+     * <p>Wraps an instance of {@link HttpFields} as a {@link Map}.</p>\n+     * <p>If the provided {@link HttpFields} is an instance of {@link HttpFields.Mutable} then changes to the\n+     * {@link Map} will be reflected in the underlying {@link HttpFields}.\n+     * Otherwise, any modification to the {@link Map} will throw {@link UnsupportedOperationException}.</p>\n+     * @param fields the {@link HttpFields} to convert to a {@link Map}.\n+     * @return an {@link Map} representing the contents of the {@link HttpFields}.\n+     */\n+    static Map<String, List<String>> asMap(HttpFields fields)\n+    {\n+        return (fields instanceof HttpFields.Mutable mutable)\n+            ? new HttpFieldsMap.Mutable(mutable)\n+            : new HttpFieldsMap.Immutable(fields);\n+    }\n+\n     /**\n      * @return a sequential stream of the {@link HttpField}s in this instance\n      */\n\ndiff --git a/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpFieldsMap.java b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpFieldsMap.java\nnew file mode 100644\nindex 000000000000..f5d19855d9fa\n--- /dev/null\n+++ b/jetty-core/jetty-http/src/main/java/org/eclipse/jetty/http/HttpFieldsMap.java\n@@ -0,0 +1,237 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.http;\n+\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.eclipse.jetty.util.StringUtil;\n+\n+/**\n+ * <p>A {@link java.util.Map} which is backed by an instance of {@link HttpFields.Mutable}.</p>\n+ * @see HttpFieldsMap.Mutable\n+ * @see HttpFieldsMap.Immutable\n+ */\n+abstract class HttpFieldsMap extends AbstractMap<String, List<String>>\n+{\n+    /**\n+     * <p>A {@link java.util.Map} which is backed by an instance of {@link HttpFields.Mutable}.</p>\n+     * <p>Any changes to the {@link java.util.Map} will be reflected in the underlying instance of {@link HttpFields.Mutable}.</p>\n+     */\n+    public static class Mutable extends HttpFieldsMap\n+    {\n+        private final HttpFields.Mutable httpFields;\n+\n+        public Mutable(HttpFields.Mutable httpFields)\n+        {\n+            this.httpFields = httpFields;\n+        }\n+\n+        @Override\n+        public List<String> get(Object key)\n+        {\n+            if (key instanceof String s)\n+                return httpFields.getValuesList(s);\n+            return null;\n+        }\n+\n+        @Override\n+        public List<String> put(String key, List<String> value)\n+        {\n+            List<String> oldValue = get(key);\n+            httpFields.put(key, value);\n+            return oldValue;\n+        }\n+\n+        @Override\n+        public List<String> remove(Object key)\n+        {\n+            if (key instanceof String s)\n+            {\n+                List<String> oldValue = get(s);\n+                httpFields.remove(s);\n+                return oldValue;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Set<Entry<String, List<String>>> entrySet()\n+        {\n+            return new AbstractSet<>()\n+            {\n+                @Override\n+                public Iterator<Entry<String, List<String>>> iterator()\n+                {\n+                    return new Iterator<>()\n+                    {\n+                        private final Iterator<String> iterator = httpFields.getFieldNamesCollection().iterator();\n+                        private String name = null;\n+\n+                        @Override\n+                        public boolean hasNext()\n+                        {\n+                            return iterator.hasNext();\n+                        }\n+\n+                        @Override\n+                        public Entry<String, List<String>> next()\n+                        {\n+                            name = iterator.next();\n+                            return new HttpFieldsEntry(name);\n+                        }\n+\n+                        @Override\n+                        public void remove()\n+                        {\n+                            if (name != null)\n+                            {\n+                                Mutable.this.remove(name);\n+                                name = null;\n+                            }\n+                        }\n+                    };\n+                }\n+\n+                @Override\n+                public int size()\n+                {\n+                    return httpFields.getFieldNamesCollection().size();\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * <p>A {@link java.util.Map} which is backed by an instance of {@link HttpFields.Mutable}.</p>\n+     * <p>Any attempt to modify the map will throw {@link UnsupportedOperationException}.</p>\n+     */\n+    public static class Immutable extends HttpFieldsMap\n+    {\n+        private final HttpFields httpFields;\n+\n+        public Immutable(HttpFields httpFields)\n+        {\n+            this.httpFields = httpFields;\n+        }\n+\n+        @Override\n+        public List<String> get(Object key)\n+        {\n+            if (key instanceof String s)\n+                return httpFields.getValuesList(s);\n+            return null;\n+        }\n+\n+        @Override\n+        public List<String> put(String key, List<String> value)\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public List<String> remove(Object key)\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Set<Entry<String, List<String>>> entrySet()\n+        {\n+            return new AbstractSet<>()\n+            {\n+                @Override\n+                public Iterator<Entry<String, List<String>>> iterator()\n+                {\n+                    return new Iterator<>()\n+                    {\n+                        private final Iterator<String> iterator = httpFields.getFieldNamesCollection().iterator();\n+\n+                        @Override\n+                        public boolean hasNext()\n+                        {\n+                            return iterator.hasNext();\n+                        }\n+\n+                        @Override\n+                        public Entry<String, List<String>> next()\n+                        {\n+                            return new HttpFieldsEntry(iterator.next());\n+                        }\n+\n+                        @Override\n+                        public void remove()\n+                        {\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    };\n+                }\n+\n+                @Override\n+                public int size()\n+                {\n+                    return httpFields.getFieldNamesCollection().size();\n+                }\n+            };\n+        }\n+    }\n+\n+    private class HttpFieldsEntry implements Entry<String, List<String>>\n+    {\n+        private final String _name;\n+\n+        public HttpFieldsEntry(String name)\n+        {\n+            _name = name;\n+        }\n+\n+        @Override\n+        public String getKey()\n+        {\n+            return _name;\n+        }\n+\n+        @Override\n+        public List<String> getValue()\n+        {\n+            return HttpFieldsMap.this.get(_name);\n+        }\n+\n+        @Override\n+        public List<String> setValue(List<String> value)\n+        {\n+            return HttpFieldsMap.this.put(_name, value);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (this == o)\n+                return true;\n+            if (o instanceof HttpFieldsEntry other)\n+                return StringUtil.asciiEqualsIgnoreCase(_name, other.getKey());\n+            return false;\n+        }\n+\n+        @Override\n+        public int hashCode()\n+        {\n+            return Objects.hash(StringUtil.asciiToLowerCase(_name));\n+        }\n+    }\n+}\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/internal/DelegatedJettyClientUpgradeRequest.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/internal/DelegatedJettyClientUpgradeRequest.java\nindex a76104afe63c..0d5d67e62bed 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/internal/DelegatedJettyClientUpgradeRequest.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/internal/DelegatedJettyClientUpgradeRequest.java\n@@ -22,6 +22,7 @@\n import java.util.stream.Collectors;\n \n import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpScheme;\n import org.eclipse.jetty.io.EndPoint;\n@@ -78,7 +79,7 @@ public List<String> getHeaders(String name)\n     @Override\n     public Map<String, List<String>> getHeaders()\n     {\n-        return null;\n+        return HttpFields.asMap(delegate.getHeaders());\n     }\n \n     @Override\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/internal/DelegatedJettyClientUpgradeResponse.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/internal/DelegatedJettyClientUpgradeResponse.java\nindex 1b93d80ba20f..0e05930cc2f7 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/internal/DelegatedJettyClientUpgradeResponse.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-client/src/main/java/org/eclipse/jetty/websocket/client/internal/DelegatedJettyClientUpgradeResponse.java\n@@ -13,7 +13,6 @@\n \n package org.eclipse.jetty.websocket.client.internal;\n \n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n@@ -21,6 +20,7 @@\n import java.util.stream.Collectors;\n \n import org.eclipse.jetty.client.Response;\n+import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.websocket.api.ExtensionConfig;\n import org.eclipse.jetty.websocket.api.UpgradeResponse;\n@@ -65,9 +65,7 @@ public List<String> getHeaders(String name)\n     @Override\n     public Map<String, List<String>> getHeaders()\n     {\n-        Map<String, List<String>> headers = getHeaderNames().stream()\n-            .collect(Collectors.toMap((name) -> name, (name) -> new ArrayList<>(getHeaders(name))));\n-        return Collections.unmodifiableMap(headers);\n+        return HttpFields.asMap(delegate.getHeaders());\n     }\n \n     @Override\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/ServerWebSocketContainer.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/ServerWebSocketContainer.java\nindex cf8a1755fad3..9d50cd242f5e 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/ServerWebSocketContainer.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/ServerWebSocketContainer.java\n@@ -359,13 +359,12 @@ private org.eclipse.jetty.websocket.core.server.WebSocketCreator newWebSocketCre\n         {\n             try\n             {\n-                Object webSocket = creator.createWebSocket(new ServerUpgradeRequestDelegate(rq), new ServerUpgradeResponseDelegate(rq, rs), cb);\n-                if (webSocket == null)\n-                    cb.succeeded();\n-                return webSocket;\n+                return creator.createWebSocket(new ServerUpgradeRequestDelegate(rq), new ServerUpgradeResponseDelegate(rq, rs), cb);\n             }\n             catch (Throwable x)\n             {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\""Could not create WebSocket endpoint\"", x);\n                 cb.failed(x);\n                 return null;\n             }\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/internal/UpgradeRequestDelegate.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/internal/UpgradeRequestDelegate.java\nindex 2006890f8010..921aea05a477 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/internal/UpgradeRequestDelegate.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/internal/UpgradeRequestDelegate.java\n@@ -21,7 +21,6 @@\n import java.util.Map;\n import java.util.stream.Collectors;\n \n-import org.eclipse.jetty.http.HttpField;\n import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpScheme;\n@@ -73,14 +72,7 @@ public int getHeaderInt(String name)\n     @Override\n     public Map<String, List<String>> getHeaders()\n     {\n-        Map<String, List<String>> result = new LinkedHashMap<>();\n-        HttpFields headers = request.getHeaders();\n-        for (HttpField header : headers)\n-        {\n-            String name = header.getName();\n-            result.put(name, headers.getValuesList(name));\n-        }\n-        return result;\n+        return HttpFields.asMap(request.getHeaders());\n     }\n \n     @Override\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/internal/UpgradeResponseDelegate.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/internal/UpgradeResponseDelegate.java\nindex c798e1e20a8f..46b704851647 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/internal/UpgradeResponseDelegate.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-server/src/main/java/org/eclipse/jetty/websocket/server/internal/UpgradeResponseDelegate.java\n@@ -13,13 +13,11 @@\n \n package org.eclipse.jetty.websocket.server.internal;\n \n-import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.stream.Collectors;\n \n-import org.eclipse.jetty.http.HttpField;\n import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.websocket.api.ExtensionConfig;\n import org.eclipse.jetty.websocket.api.UpgradeResponse;\n@@ -64,14 +62,7 @@ public Set<String> getHeaderNames()\n     @Override\n     public Map<String, List<String>> getHeaders()\n     {\n-        Map<String, List<String>> result = new LinkedHashMap<>();\n-        HttpFields.Mutable headers = response.getHeaders();\n-        for (HttpField header : headers)\n-        {\n-            String name = header.getName();\n-            result.put(name, headers.getValuesList(name));\n-        }\n-        return result;\n+        return HttpFields.asMap(response.getHeaders());\n     }\n \n     @Override\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-client/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/client/internal/JsrUpgradeListener.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-client/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/client/internal/JsrUpgradeListener.java\nindex 8406e494e4f5..5c14b0bd5e98 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-client/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/client/internal/JsrUpgradeListener.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-client/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/client/internal/JsrUpgradeListener.java\n@@ -13,9 +13,6 @@\n \n package org.eclipse.jetty.ee10.websocket.jakarta.client.internal;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n@@ -41,23 +38,11 @@ public void onHandshakeRequest(Request request)\n         if (configurator == null)\n             return;\n \n-        HttpFields fields = request.getHeaders();\n-        Map<String, List<String>> originalHeaders = new HashMap<>();\n-        fields.forEach(field ->\n-        {\n-            originalHeaders.putIfAbsent(field.getName(), new ArrayList<>());\n-            List<String> values = originalHeaders.get(field.getName());\n-            Collections.addAll(values, field.getValues());\n-        });\n-\n-        // Give headers to configurator\n-        configurator.beforeRequest(originalHeaders);\n-\n-        // Reset headers on HttpRequest per configurator\n         request.headers(headers ->\n         {\n-            headers.clear();\n-            originalHeaders.forEach(headers::put);\n+            // Give headers to configurator\n+            Map<String, List<String>> headersMap = HttpFields.asMap(headers);\n+            configurator.beforeRequest(headersMap);\n         });\n     }\n \n@@ -67,18 +52,7 @@ public void onHandshakeResponse(Request request, Response response)\n         if (configurator == null)\n             return;\n \n-        HandshakeResponse handshakeResponse = () ->\n-        {\n-            Map<String, List<String>> ret = new HashMap<>();\n-            response.getHeaders().forEach(field ->\n-            {\n-                ret.putIfAbsent(field.getName(), new ArrayList<>());\n-                List<String> values = ret.get(field.getName());\n-                Collections.addAll(values, field.getValues());\n-            });\n-            return ret;\n-        };\n-\n+        HandshakeResponse handshakeResponse = () -> HttpFields.asMap(response.getHeaders());\n         configurator.afterResponse(handshakeResponse);\n     }\n }\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/JakartaWebSocketServerContainer.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/JakartaWebSocketServerContainer.java\nindex 041bf6b427af..c576cb79e27d 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/JakartaWebSocketServerContainer.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/JakartaWebSocketServerContainer.java\n@@ -322,9 +322,9 @@ public void upgradeHttpToWebSocket(Object httpServletRequest, Object httpServlet\n             servletContextRequest.setAttribute(WebSocketConstants.WEBSOCKET_WRAPPED_RESPONSE_ATTRIBUTE, response);\n \n             if (handshaker.upgradeRequest(negotiator, servletContextRequest, servletContextResponse, callback, components, defaultCustomizer))\n-            {\n                 callback.block();\n-            }\n+            else\n+                throw new IllegalStateException(\""Invalid WebSocket Upgrade Request\"");\n         }\n         finally\n         {\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JakartaWebSocketCreator.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JakartaWebSocketCreator.java\nindex 6382b8c77ee1..994ec93a9162 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JakartaWebSocketCreator.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JakartaWebSocketCreator.java\n@@ -156,8 +156,6 @@ public Map<String, Object> getUserProperties()\n \n         // [JSR] Step 5: Call modifyHandshake\n         configurator.modifyHandshake(config, jsrHandshakeRequest, jsrHandshakeResponse);\n-        // Set modified headers Map back into response properly\n-        jsrHandshakeResponse.setHeaders(jsrHandshakeResponse.getHeaders());\n \n         try\n         {\n@@ -168,7 +166,8 @@ public Map<String, Object> getUserProperties()\n         }\n         catch (Throwable x)\n         {\n-            LOG.warn(\""Unable to create websocket: {}\"", config.getEndpointClass().getName(), x);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\""Unable to create websocket: {}\"", config.getEndpointClass().getName(), x);\n             callback.failed(x);\n             return null;\n         }\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JsrHandshakeRequest.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JsrHandshakeRequest.java\nindex a9f8ac6e7147..546794d54f5e 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JsrHandshakeRequest.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JsrHandshakeRequest.java\n@@ -15,16 +15,14 @@\n \n import java.net.URI;\n import java.security.Principal;\n-import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.stream.Collectors;\n \n import jakarta.servlet.http.HttpServletRequest;\n import jakarta.websocket.server.HandshakeRequest;\n import org.eclipse.jetty.ee10.websocket.jakarta.server.JakartaWebSocketServerContainer;\n+import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.pathmap.PathSpec;\n import org.eclipse.jetty.server.Request;\n import org.eclipse.jetty.util.Fields;\n@@ -47,9 +45,7 @@ public JsrHandshakeRequest(ServerUpgradeRequest req)\n     @Override\n     public Map<String, List<String>> getHeaders()\n     {\n-        Map<String, List<String>> headers = delegate.getHeaders().getFieldNamesCollection().stream()\n-            .collect(Collectors.toMap((name) -> name, (name) -> new ArrayList<>(delegate.getHeaders().getValuesList(name))));\n-        return Collections.unmodifiableMap(headers);\n+        return HttpFields.asMap(delegate.getHeaders());\n     }\n \n     @Override\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JsrHandshakeResponse.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JsrHandshakeResponse.java\nindex b4d5986dd106..c1d9b1dfff2a 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JsrHandshakeResponse.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee10/websocket/jakarta/server/internal/JsrHandshakeResponse.java\n@@ -13,24 +13,20 @@\n \n package org.eclipse.jetty.ee10.websocket.jakarta.server.internal;\n \n-import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n-import java.util.stream.Collectors;\n \n import jakarta.websocket.HandshakeResponse;\n+import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.websocket.core.server.ServerUpgradeResponse;\n \n public class JsrHandshakeResponse implements HandshakeResponse\n {\n-    private final ServerUpgradeResponse delegate;\n     private final Map<String, List<String>> headers;\n \n     public JsrHandshakeResponse(ServerUpgradeResponse resp)\n     {\n-        this.delegate = resp;\n-        this.headers = delegate.getHeaders().getFieldNamesCollection().stream()\n-            .collect(Collectors.toMap((name) -> name, (name) -> new ArrayList<>(delegate.getHeaders().getValuesList(name))));\n+        this.headers = HttpFields.asMap(resp.getHeaders());\n     }\n \n     @Override\n@@ -38,9 +34,4 @@ public Map<String, List<String>> getHeaders()\n     {\n         return headers;\n     }\n-\n-    public void setHeaders(Map<String, List<String>> headers)\n-    {\n-        headers.forEach((key, values) -> delegate.getHeaders().put(key, values));\n-    }\n }\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/JettyWebSocketServerContainer.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/JettyWebSocketServerContainer.java\nindex d9e329f0cdbb..9c896bebc301 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/JettyWebSocketServerContainer.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/JettyWebSocketServerContainer.java\n@@ -158,6 +158,8 @@ public void addMapping(String pathSpec, JettyWebSocketCreator creator)\n             }\n             catch (Throwable t)\n             {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\""Could not create WebSocket endpoint\"", t);\n                 cb.failed(t);\n                 return null;\n             }\n@@ -203,11 +205,14 @@ public boolean upgrade(JettyWebSocketCreator creator, HttpServletRequest request\n             try\n             {\n                 Object webSocket = creator.createWebSocket(new DelegatedServerUpgradeRequest(req), new DelegatedServerUpgradeResponse(resp));\n-                cb.succeeded();\n+                if (webSocket == null)\n+                    cb.succeeded();\n                 return webSocket;\n             }\n             catch (Throwable t)\n             {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\""Could not create WebSocket endpoint\"", t);\n                 cb.failed(t);\n                 return null;\n             }\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/JettyWebSocketServlet.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/JettyWebSocketServlet.java\nindex 9d412559321f..b3c7bf38fb51 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/JettyWebSocketServlet.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/JettyWebSocketServlet.java\n@@ -303,7 +303,8 @@ public Object createWebSocket(ServerUpgradeRequest upgradeRequest, ServerUpgrade\n             try\n             {\n                 Object webSocket = creator.createWebSocket(request, response);\n-                callback.succeeded();\n+                if (webSocket == null)\n+                    callback.succeeded();\n                 return webSocket;\n             }\n             catch (Throwable t)\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/DelegatedServerUpgradeRequest.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/DelegatedServerUpgradeRequest.java\nindex a5dc510102ad..3f8f0155fa45 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/DelegatedServerUpgradeRequest.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/DelegatedServerUpgradeRequest.java\n@@ -18,7 +18,6 @@\n import java.net.URI;\n import java.security.Principal;\n import java.security.cert.X509Certificate;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n@@ -33,6 +32,7 @@\n import jakarta.servlet.http.HttpSession;\n import org.eclipse.jetty.ee10.websocket.server.JettyServerUpgradeRequest;\n import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.websocket.api.ExtensionConfig;\n@@ -121,9 +121,7 @@ public int getHeaderInt(String name)\n     @Override\n     public Map<String, List<String>> getHeaders()\n     {\n-        Map<String, List<String>> headers = upgradeRequest.getHeaders().getFieldNamesCollection().stream()\n-            .collect(Collectors.toMap((name) -> name, (name) -> new ArrayList<>(getHeaders(name))));\n-        return Collections.unmodifiableMap(headers);\n+        return HttpFields.asMap(upgradeRequest.getHeaders());\n     }\n \n     @Override\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/DelegatedServerUpgradeResponse.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/DelegatedServerUpgradeResponse.java\nindex a1688d5749e0..51f0d8eed7f4 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/DelegatedServerUpgradeResponse.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/DelegatedServerUpgradeResponse.java\n@@ -14,7 +14,6 @@\n package org.eclipse.jetty.ee10.websocket.server.internal;\n \n import java.io.IOException;\n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n@@ -24,6 +23,7 @@\n import jakarta.servlet.http.HttpServletResponse;\n import org.eclipse.jetty.ee10.servlet.ServletContextResponse;\n import org.eclipse.jetty.ee10.websocket.server.JettyServerUpgradeResponse;\n+import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.HttpStatus;\n import org.eclipse.jetty.server.Response;\n import org.eclipse.jetty.websocket.api.ExtensionConfig;\n@@ -35,13 +35,22 @@ public class DelegatedServerUpgradeResponse implements JettyServerUpgradeRespons\n {\n     private final ServerUpgradeResponse upgradeResponse;\n     private final HttpServletResponse httpServletResponse;\n+    private final boolean isUpgraded;\n+    private final Map<String, List<String>> headers;\n \n     public DelegatedServerUpgradeResponse(ServerUpgradeResponse response)\n+    {\n+        this(response, false);\n+    }\n+\n+    public DelegatedServerUpgradeResponse(ServerUpgradeResponse response, boolean isUpgraded)\n     {\n         upgradeResponse = response;\n+        this.isUpgraded = isUpgraded;\n         ServletContextResponse servletContextResponse = Response.as(response, ServletContextResponse.class);\n         this.httpServletResponse = (HttpServletResponse)servletContextResponse.getRequest()\n             .getAttribute(WebSocketConstants.WEBSOCKET_WRAPPED_RESPONSE_ATTRIBUTE);\n+        headers = HttpFields.asMap(upgradeResponse.getHeaders());\n     }\n \n     @Override\n@@ -55,13 +64,13 @@ public void addHeader(String name, String value)\n     @Override\n     public void setHeader(String name, String value)\n     {\n-        upgradeResponse.getHeaders().put(name, value);\n+        headers.put(name, List.of(value));\n     }\n \n     @Override\n     public void setHeader(String name, List<String> values)\n     {\n-        upgradeResponse.getHeaders().put(name, values);\n+        headers.put(name, values);\n     }\n \n     @Override\n@@ -91,9 +100,7 @@ public Set<String> getHeaderNames()\n     @Override\n     public Map<String, List<String>> getHeaders()\n     {\n-        Map<String, List<String>> headers = getHeaderNames().stream()\n-            .collect(Collectors.toMap((name) -> name, (name) -> new ArrayList<>(getHeaders(name))));\n-        return Collections.unmodifiableMap(headers);\n+        return isUpgraded ? Collections.unmodifiableMap(headers) : headers;\n     }\n \n     @Override\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/JettyServerFrameHandlerFactory.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/JettyServerFrameHandlerFactory.java\nindex 17f50e82a461..5fd68de68f75 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/JettyServerFrameHandlerFactory.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee10/websocket/server/internal/JettyServerFrameHandlerFactory.java\n@@ -41,7 +41,7 @@ public FrameHandler newFrameHandler(Object websocketPojo, ServerUpgradeRequest u\n     {\n         JettyWebSocketFrameHandler frameHandler = super.newJettyFrameHandler(websocketPojo);\n         frameHandler.setUpgradeRequest(new DelegatedServerUpgradeRequest(upgradeRequest));\n-        frameHandler.setUpgradeResponse(new DelegatedServerUpgradeResponse(upgradeResponse));\n+        frameHandler.setUpgradeResponse(new DelegatedServerUpgradeResponse(upgradeResponse, true));\n         return frameHandler;\n     }\n }\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-client/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/client/internal/JsrUpgradeListener.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-client/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/client/internal/JsrUpgradeListener.java\nindex f2185174426b..35660cb92556 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-client/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/client/internal/JsrUpgradeListener.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-client/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/client/internal/JsrUpgradeListener.java\n@@ -13,9 +13,6 @@\n \n package org.eclipse.jetty.ee9.websocket.jakarta.client.internal;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n@@ -41,23 +38,11 @@ public void onHandshakeRequest(Request request)\n         if (configurator == null)\n             return;\n \n-        HttpFields fields = request.getHeaders();\n-        Map<String, List<String>> originalHeaders = new HashMap<>();\n-        fields.forEach(field ->\n-        {\n-            originalHeaders.putIfAbsent(field.getName(), new ArrayList<>());\n-            List<String> values = originalHeaders.get(field.getName());\n-            Collections.addAll(values, field.getValues());\n-        });\n-\n-        // Give headers to configurator\n-        configurator.beforeRequest(originalHeaders);\n-\n-        // Reset headers on HttpRequest per configurator\n         request.headers(headers ->\n         {\n-            headers.clear();\n-            originalHeaders.forEach(headers::put);\n+            // Give headers to configurator\n+            Map<String, List<String>> headersMap = HttpFields.asMap(headers);\n+            configurator.beforeRequest(headersMap);\n         });\n     }\n \n@@ -67,18 +52,7 @@ public void onHandshakeResponse(Request request, Response response)\n         if (configurator == null)\n             return;\n \n-        HandshakeResponse handshakeResponse = () ->\n-        {\n-            Map<String, List<String>> ret = new HashMap<>();\n-            response.getHeaders().forEach(field ->\n-            {\n-                ret.putIfAbsent(field.getName(), new ArrayList<>());\n-                List<String> values = ret.get(field.getName());\n-                Collections.addAll(values, field.getValues());\n-            });\n-            return ret;\n-        };\n-\n+        HandshakeResponse handshakeResponse = () -> HttpFields.asMap(response.getHeaders());\n         configurator.afterResponse(handshakeResponse);\n     }\n }\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/JakartaWebSocketServerContainer.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/JakartaWebSocketServerContainer.java\nindex e646f5eb141b..a0e2540450a0 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/JakartaWebSocketServerContainer.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/JakartaWebSocketServerContainer.java\n@@ -323,9 +323,9 @@ public void upgradeHttpToWebSocket(Object httpServletRequest, Object httpServlet\n             baseRequest.setAttribute(WebSocketConstants.WEBSOCKET_WRAPPED_RESPONSE_ATTRIBUTE, response);\n \n             if (handshaker.upgradeRequest(negotiator, baseRequest, baseResponse, callback, components, defaultCustomizer))\n-            {\n                 callback.block();\n-            }\n+            else\n+                throw new IllegalStateException(\""Invalid WebSocket Upgrade Request\"");\n         }\n         finally\n         {\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JakartaWebSocketCreator.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JakartaWebSocketCreator.java\nindex b2587594f6a0..1bde01dcbc95 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JakartaWebSocketCreator.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JakartaWebSocketCreator.java\n@@ -156,8 +156,6 @@ public Map<String, Object> getUserProperties()\n \n         // [JSR] Step 5: Call modifyHandshake\n         configurator.modifyHandshake(config, jsrHandshakeRequest, jsrHandshakeResponse);\n-        // Set modified headers Map back into response properly\n-        jsrHandshakeResponse.setHeaders(jsrHandshakeResponse.getHeaders());\n \n         try\n         {\n@@ -168,7 +166,8 @@ public Map<String, Object> getUserProperties()\n         }\n         catch (Throwable x)\n         {\n-            LOG.warn(\""Unable to create websocket: {}\"", config.getEndpointClass().getName(), x);\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\""Unable to create WebSocket: {}\"", config.getEndpointClass().getName(), x);\n             callback.failed(x);\n             return null;\n         }\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JsrHandshakeRequest.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JsrHandshakeRequest.java\nindex a0ff17b5c7f8..840d718512dc 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JsrHandshakeRequest.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JsrHandshakeRequest.java\n@@ -15,16 +15,14 @@\n \n import java.net.URI;\n import java.security.Principal;\n-import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.stream.Collectors;\n \n import jakarta.servlet.http.HttpServletRequest;\n import jakarta.websocket.server.HandshakeRequest;\n import org.eclipse.jetty.ee9.websocket.jakarta.server.JakartaWebSocketServerContainer;\n+import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.pathmap.PathSpec;\n import org.eclipse.jetty.server.Request;\n import org.eclipse.jetty.util.Fields;\n@@ -47,9 +45,7 @@ public JsrHandshakeRequest(ServerUpgradeRequest req)\n     @Override\n     public Map<String, List<String>> getHeaders()\n     {\n-        Map<String, List<String>> headers = delegate.getHeaders().getFieldNamesCollection().stream()\n-            .collect(Collectors.toMap((name) -> name, (name) -> new ArrayList<>(delegate.getHeaders().getValuesList(name))));\n-        return Collections.unmodifiableMap(headers);\n+        return HttpFields.asMap(delegate.getHeaders());\n     }\n \n     @Override\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JsrHandshakeResponse.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JsrHandshakeResponse.java\nindex 7be47d85817a..8de0a2d94bb7 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JsrHandshakeResponse.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-server/src/main/java/org/eclipse/jetty/ee9/websocket/jakarta/server/internal/JsrHandshakeResponse.java\n@@ -13,24 +13,20 @@\n \n package org.eclipse.jetty.ee9.websocket.jakarta.server.internal;\n \n-import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n-import java.util.stream.Collectors;\n \n import jakarta.websocket.HandshakeResponse;\n+import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.websocket.core.server.ServerUpgradeResponse;\n \n public class JsrHandshakeResponse implements HandshakeResponse\n {\n-    private final ServerUpgradeResponse delegate;\n     private final Map<String, List<String>> headers;\n \n     public JsrHandshakeResponse(ServerUpgradeResponse resp)\n     {\n-        this.delegate = resp;\n-        this.headers = delegate.getHeaders().getFieldNamesCollection().stream()\n-            .collect(Collectors.toMap((name) -> name, (name) -> new ArrayList<>(delegate.getHeaders().getValuesList(name))));\n+        this.headers = HttpFields.asMap(resp.getHeaders());\n     }\n \n     @Override\n@@ -38,9 +34,4 @@ public Map<String, List<String>> getHeaders()\n     {\n         return headers;\n     }\n-\n-    public void setHeaders(Map<String, List<String>> headers)\n-    {\n-        headers.forEach((key, values) -> delegate.getHeaders().put(key, values));\n-    }\n }\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/impl/DelegatedJettyClientUpgradeRequest.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/impl/DelegatedJettyClientUpgradeRequest.java\nindex 27deb9bb3684..d0388a1d0e8b 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/impl/DelegatedJettyClientUpgradeRequest.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/impl/DelegatedJettyClientUpgradeRequest.java\n@@ -24,6 +24,7 @@\n import org.eclipse.jetty.ee9.websocket.api.ExtensionConfig;\n import org.eclipse.jetty.ee9.websocket.api.UpgradeRequest;\n import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpScheme;\n import org.eclipse.jetty.io.EndPoint;\n@@ -78,7 +79,7 @@ public List<String> getHeaders(String name)\n     @Override\n     public Map<String, List<String>> getHeaders()\n     {\n-        return null;\n+        return HttpFields.asMap(delegate.getHeaders());\n     }\n \n     @Override\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/impl/DelegatedJettyClientUpgradeResponse.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/impl/DelegatedJettyClientUpgradeResponse.java\nindex 0c6c57b77dc3..2f14bce6288a 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/impl/DelegatedJettyClientUpgradeResponse.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-client/src/main/java/org/eclipse/jetty/ee9/websocket/client/impl/DelegatedJettyClientUpgradeResponse.java\n@@ -13,7 +13,6 @@\n \n package org.eclipse.jetty.ee9.websocket.client.impl;\n \n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n@@ -23,6 +22,7 @@\n import org.eclipse.jetty.client.Response;\n import org.eclipse.jetty.ee9.websocket.api.ExtensionConfig;\n import org.eclipse.jetty.ee9.websocket.api.UpgradeResponse;\n+import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.HttpHeader;\n \n /**\n@@ -65,9 +65,7 @@ public List<String> getHeaders(String name)\n     @Override\n     public Map<String, List<String>> getHeaders()\n     {\n-        Map<String, List<String>> headers = getHeaderNames().stream()\n-            .collect(Collectors.toMap((name) -> name, (name) -> new ArrayList<>(getHeaders(name))));\n-        return Collections.unmodifiableMap(headers);\n+        return HttpFields.asMap(delegate.getHeaders());\n     }\n \n     @Override\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/JettyWebSocketServerContainer.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/JettyWebSocketServerContainer.java\nindex f57c41314736..245fc7855641 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/JettyWebSocketServerContainer.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/JettyWebSocketServerContainer.java\n@@ -155,11 +155,14 @@ public void addMapping(String pathSpec, JettyWebSocketCreator creator)\n             try\n             {\n                 Object webSocket = creator.createWebSocket(new DelegatedServerUpgradeRequest(req), new DelegatedServerUpgradeResponse(resp));\n-                cb.succeeded();\n+                if (webSocket == null)\n+                    cb.succeeded();\n                 return webSocket;\n             }\n             catch (Throwable t)\n             {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\""Could not create WebSocket endpoint\"", t);\n                 cb.failed(t);\n                 return null;\n             }\n@@ -205,11 +208,14 @@ public boolean upgrade(JettyWebSocketCreator creator, HttpServletRequest request\n             try\n             {\n                 Object webSocket = creator.createWebSocket(new DelegatedServerUpgradeRequest(req), new DelegatedServerUpgradeResponse(resp));\n-                cb.succeeded();\n+                if (webSocket == null)\n+                    cb.succeeded();\n                 return webSocket;\n             }\n             catch (Throwable t)\n             {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\""Could not create WebSocket endpoint\"", t);\n                 cb.failed(t);\n                 return null;\n             }\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/JettyWebSocketServlet.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/JettyWebSocketServlet.java\nindex 1d8a8263f9ad..87d7c47a409f 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/JettyWebSocketServlet.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/JettyWebSocketServlet.java\n@@ -299,18 +299,22 @@ public boolean removeMapping(String pathSpec)\n \n     private record WrappedJettyCreator(JettyWebSocketCreator creator) implements WebSocketCreator\n     {\n+\n         private JettyWebSocketCreator getJettyWebSocketCreator()\n         {\n             return creator;\n         }\n \n         @Override\n-        public Object createWebSocket(ServerUpgradeRequest request, ServerUpgradeResponse response, Callback callback)\n+        public Object createWebSocket(ServerUpgradeRequest upgradeRequest, ServerUpgradeResponse upgradeResponse, Callback callback)\n         {\n+            DelegatedServerUpgradeRequest request = new DelegatedServerUpgradeRequest(upgradeRequest);\n+            DelegatedServerUpgradeResponse response = new DelegatedServerUpgradeResponse(upgradeResponse);\n             try\n             {\n-                Object webSocket = creator.createWebSocket(new DelegatedServerUpgradeRequest(request), new DelegatedServerUpgradeResponse(response));\n-                callback.succeeded();\n+                Object webSocket = creator.createWebSocket(request, response);\n+                if (webSocket == null)\n+                    callback.succeeded();\n                 return webSocket;\n             }\n             catch (Throwable t)\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/internal/DelegatedServerUpgradeRequest.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/internal/DelegatedServerUpgradeRequest.java\nindex 6f99d2229cb1..256a3451d9ec 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/internal/DelegatedServerUpgradeRequest.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/internal/DelegatedServerUpgradeRequest.java\n@@ -18,7 +18,6 @@\n import java.net.URI;\n import java.security.Principal;\n import java.security.cert.X509Certificate;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n@@ -35,6 +34,7 @@\n import org.eclipse.jetty.ee9.websocket.common.JettyExtensionConfig;\n import org.eclipse.jetty.ee9.websocket.server.JettyServerUpgradeRequest;\n import org.eclipse.jetty.http.BadMessageException;\n+import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.util.URIUtil;\n import org.eclipse.jetty.websocket.core.WebSocketConstants;\n@@ -114,9 +114,7 @@ public int getHeaderInt(String name)\n     @Override\n     public Map<String, List<String>> getHeaders()\n     {\n-        Map<String, List<String>> headers = upgradeRequest.getHeaders().getFieldNamesCollection().stream()\n-            .collect(Collectors.toMap((name) -> name, (name) -> new ArrayList<>(getHeaders(name))));\n-        return Collections.unmodifiableMap(headers);\n+        return HttpFields.asMap(upgradeRequest.getHeaders());\n     }\n \n     @Override\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/internal/DelegatedServerUpgradeResponse.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/internal/DelegatedServerUpgradeResponse.java\nindex 23af9f519bf7..f1a1ff95b377 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/internal/DelegatedServerUpgradeResponse.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-server/src/main/java/org/eclipse/jetty/ee9/websocket/server/internal/DelegatedServerUpgradeResponse.java\n@@ -14,8 +14,6 @@\n package org.eclipse.jetty.ee9.websocket.server.internal;\n \n import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -25,6 +23,7 @@\n import org.eclipse.jetty.ee9.websocket.api.ExtensionConfig;\n import org.eclipse.jetty.ee9.websocket.common.JettyExtensionConfig;\n import org.eclipse.jetty.ee9.websocket.server.JettyServerUpgradeResponse;\n+import org.eclipse.jetty.http.HttpFields;\n import org.eclipse.jetty.http.HttpStatus;\n import org.eclipse.jetty.websocket.core.WebSocketConstants;\n import org.eclipse.jetty.websocket.core.server.ServerUpgradeResponse;\n@@ -88,9 +87,7 @@ public Set<String> getHeaderNames()\n     @Override\n     public Map<String, List<String>> getHeaders()\n     {\n-        Map<String, List<String>> headers = getHeaderNames().stream()\n-            .collect(Collectors.toMap((name) -> name, (name) -> new ArrayList<>(getHeaders(name))));\n-        return Collections.unmodifiableMap(headers);\n+        return HttpFields.asMap(upgradeResponse.getHeaders());\n     }\n \n     @Override\n"", ""test_patch"": ""diff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/UpgradeHeadersTest.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/UpgradeHeadersTest.java\nnew file mode 100644\nindex 000000000000..d19b00d8ba66\n--- /dev/null\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/UpgradeHeadersTest.java\n@@ -0,0 +1,138 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.ee10.websocket.jakarta.tests;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import jakarta.websocket.ClientEndpointConfig;\n+import jakarta.websocket.Endpoint;\n+import jakarta.websocket.EndpointConfig;\n+import jakarta.websocket.HandshakeResponse;\n+import jakarta.websocket.Session;\n+import jakarta.websocket.server.HandshakeRequest;\n+import jakarta.websocket.server.ServerEndpointConfig;\n+import org.eclipse.jetty.ee10.servlet.ServletContextHandler;\n+import org.eclipse.jetty.ee10.websocket.jakarta.client.JakartaWebSocketClientContainer;\n+import org.eclipse.jetty.ee10.websocket.jakarta.server.config.JakartaWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class UpgradeHeadersTest\n+{\n+    private Server _server;\n+    private JakartaWebSocketClientContainer _client;\n+    private ServerConnector _connector;\n+\n+    public static class MyEndpoint extends Endpoint\n+    {\n+        @Override\n+        public void onOpen(Session session, EndpointConfig config)\n+        {\n+        }\n+    }\n+\n+    public void start(ServerEndpointConfig.Configurator configurator) throws Exception\n+    {\n+        _server = new Server();\n+        _connector = new ServerConnector(_server);\n+        _server.addConnector(_connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        _server.setHandler(contextHandler);\n+        JakartaWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+        {\n+            container.addEndpoint(ServerEndpointConfig.Builder\n+                .create(MyEndpoint.class, \""/\"")\n+                .configurator(configurator)\n+                .build());\n+        });\n+\n+        _server.start();\n+        _client = new JakartaWebSocketClientContainer();\n+        _client.start();\n+    }\n+\n+    @AfterEach\n+    public void after() throws Exception\n+    {\n+        _client.stop();\n+        _server.stop();\n+    }\n+\n+    @Test\n+    public void testCaseInsensitiveUpgradeHeaders() throws Exception\n+    {\n+        ClientEndpointConfig.Configurator configurator = new ClientEndpointConfig.Configurator()\n+        {\n+            @Override\n+            public void beforeRequest(Map<String, List<String>> headers)\n+            {\n+                // Verify that existing headers can be accessed in a case-insensitive way.\n+                if (headers.get(\""cOnnEcTiOn\"") == null)\n+                    throw new IllegalStateException(\""No Connection Header on client Request\"");\n+                headers.put(\""sentHeader\"", List.of(\""value123\""));\n+            }\n+\n+            @Override\n+            public void afterResponse(HandshakeResponse hr)\n+            {\n+                if (hr.getHeaders().get(\""MyHeAdEr\"") == null)\n+                    throw new IllegalStateException(\""No custom Header on HandshakeResponse\"");\n+                if (hr.getHeaders().get(\""cOnnEcTiOn\"") == null)\n+                    throw new IllegalStateException(\""No Connection Header on HandshakeRequest\"");\n+            }\n+        };\n+\n+        start(new ServerEndpointConfig.Configurator()\n+        {\n+            @Override\n+            public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)\n+            {\n+                // Verify that existing headers can be accessed in a case-insensitive way.\n+                if (request.getHeaders().get(\""cOnnEcTiOn\"") == null)\n+                    throw new IllegalStateException(\""No Connection Header on HandshakeRequest\"");\n+                if (response.getHeaders().get(\""sErVeR\"") == null)\n+                    throw new IllegalStateException(\""No Server Header on HandshakeResponse\"");\n+\n+                // Verify custom header sent from client.\n+                if (request.getHeaders().get(\""SeNtHeadEr\"") == null)\n+                    throw new IllegalStateException(\""No sent Header on HandshakeResponse\"");\n+\n+                // Add custom response header.\n+                response.getHeaders().put(\""myHeader\"", List.of(\""foobar\""));\n+                if (response.getHeaders().get(\""MyHeAdEr\"") == null)\n+                    throw new IllegalStateException(\""No custom Header on HandshakeResponse\"");\n+\n+                super.modifyHandshake(sec, request, response);\n+            }\n+        });\n+\n+        WSEndpointTracker clientEndpoint = new WSEndpointTracker(){};\n+        ClientEndpointConfig clientConfig = ClientEndpointConfig.Builder.create().configurator(configurator).build();\n+        URI uri = URI.create(\""ws://localhost:\"" + _connector.getLocalPort());\n+\n+        // If any of the above throw it would fail to upgrade to websocket.\n+        Session session = _client.connectToServer(clientEndpoint, clientConfig, uri);\n+        assertTrue(clientEndpoint.openLatch.await(5, TimeUnit.SECONDS));\n+        session.close();\n+        assertTrue(clientEndpoint.closeLatch.await(5, TimeUnit.SECONDS));\n+    }\n+}\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/client/AnnotatedClientEndpointTest.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/client/AnnotatedClientEndpointTest.java\nindex d68ff6bed0e2..83ac45d0cbee 100644\n--- a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/client/AnnotatedClientEndpointTest.java\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee10/websocket/jakarta/tests/client/AnnotatedClientEndpointTest.java\n@@ -15,14 +15,12 @@\n \n import java.io.IOException;\n import java.nio.ByteBuffer;\n-import java.util.Collections;\n import java.util.Date;\n \n import jakarta.websocket.ClientEndpoint;\n import jakarta.websocket.ClientEndpointConfig;\n import jakarta.websocket.ContainerProvider;\n import jakarta.websocket.EndpointConfig;\n-import jakarta.websocket.HandshakeResponse;\n import jakarta.websocket.OnMessage;\n import jakarta.websocket.OnOpen;\n import jakarta.websocket.Session;\n@@ -75,12 +73,6 @@ public Date onBinary(ByteBuffer buf)\n \n     public static class AnnotatedEndpointConfigurator extends ClientEndpointConfig.Configurator\n     {\n-        @Override\n-        public void afterResponse(HandshakeResponse hr)\n-        {\n-            hr.getHeaders().put(\""X-Test\"", Collections.singletonList(\""Extra\""));\n-            super.afterResponse(hr);\n-        }\n     }\n \n     private static CoreServer server;\n\ndiff --git a/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee10/websocket/tests/UpgradeHeadersTest.java b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee10/websocket/tests/UpgradeHeadersTest.java\nnew file mode 100644\nindex 000000000000..6d228db7475c\n--- /dev/null\n+++ b/jetty-ee10/jetty-ee10-websocket/jetty-ee10-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee10/websocket/tests/UpgradeHeadersTest.java\n@@ -0,0 +1,124 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.ee10.websocket.tests;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.client.Request;\n+import org.eclipse.jetty.client.Response;\n+import org.eclipse.jetty.ee10.servlet.ServletContextHandler;\n+import org.eclipse.jetty.ee10.websocket.server.JettyWebSocketCreator;\n+import org.eclipse.jetty.ee10.websocket.server.config.JettyWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.JettyUpgradeListener;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class UpgradeHeadersTest\n+{\n+    private Server _server;\n+    private WebSocketClient _client;\n+    private ServerConnector _connector;\n+\n+    public void start(JettyWebSocketCreator creator) throws Exception\n+    {\n+        _server = new Server();\n+        _connector = new ServerConnector(_server);\n+        _server.addConnector(_connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        JettyWebSocketServletContainerInitializer.configure(contextHandler, (servletContext, container) ->\n+            container.addMapping(\""/\"", creator));\n+        _server.setHandler(contextHandler);\n+\n+        _server.start();\n+        _client = new WebSocketClient();\n+        _client.start();\n+    }\n+\n+    @AfterEach\n+    public void after() throws Exception\n+    {\n+        _client.stop();\n+        _server.stop();\n+    }\n+\n+    @Test\n+    public void testCaseInsensitiveUpgradeHeaders() throws Exception\n+    {\n+        start((request, response) ->\n+        {\n+            // Verify that existing headers can be accessed in a case-insensitive way.\n+            if (request.getHeaders().get(\""cOnnEcTiOn\"") == null)\n+                throw new IllegalStateException(\""No Connection Header on HandshakeRequest\"");\n+            if (response.getHeaders().get(\""sErVeR\"") == null)\n+                throw new IllegalStateException(\""No Server Header on HandshakeResponse\"");\n+\n+            // Verify custom header sent from client.\n+            if (request.getHeaders().get(\""SeNtHeadEr\"") == null)\n+                throw new IllegalStateException(\""No sent Header on HandshakeResponse\"");\n+\n+            // Add custom response header.\n+            response.getHeaders().put(\""myHeader\"", List.of(\""foobar\""));\n+            if (response.getHeaders().get(\""MyHeAdEr\"") == null)\n+                throw new IllegalStateException(\""No custom Header on HandshakeResponse\"");\n+\n+            return new EchoSocket();\n+        });\n+\n+        EventSocket clientEndpoint = new EventSocket();\n+        URI uri = URI.create(\""ws://localhost:\"" + _connector.getLocalPort());\n+\n+        ClientUpgradeRequest clientUpgradeRequest = new ClientUpgradeRequest();\n+        clientUpgradeRequest.getHeaders().put(\""sentHeader\"", List.of(\""value123\""));\n+        if (clientUpgradeRequest.getHeaders().get(\""SenTHeaDer\"") == null)\n+            throw new IllegalStateException(\""No custom Header on ClientUpgradeRequest\"");\n+\n+        JettyUpgradeListener upgradeListener = new JettyUpgradeListener()\n+        {\n+            @Override\n+            public void onHandshakeRequest(Request request)\n+            {\n+                // Verify that existing headers can be accessed in a case-insensitive way.\n+                if (request.getHeaders().get(\""cOnnEcTiOn\"") == null)\n+                    throw new IllegalStateException(\""No Connection Header on client Request\"");\n+                if (request.getHeaders().get(\""SenTHeaDer\"") == null)\n+                    throw new IllegalStateException(\""No custom Header on ClientUpgradeRequest\"");\n+            }\n+\n+            @Override\n+            public void onHandshakeResponse(Request request, Response response)\n+            {\n+                if (response.getHeaders().get(\""MyHeAdEr\"") == null)\n+                    throw new IllegalStateException(\""No custom Header on HandshakeResponse\"");\n+                if (response.getHeaders().get(\""cOnnEcTiOn\"") == null)\n+                    throw new IllegalStateException(\""No Connection Header on HandshakeRequest\"");\n+            }\n+        };\n+\n+        // If any of the above throw it would fail to upgrade to websocket.\n+        assertNotNull(_client.connect(clientEndpoint, uri, clientUpgradeRequest, upgradeListener).get(5, TimeUnit.SECONDS));\n+        assertTrue(clientEndpoint.openLatch.await(5, TimeUnit.SECONDS));\n+        clientEndpoint.session.close();\n+        assertTrue(clientEndpoint.closeLatch.await(5, TimeUnit.SECONDS));\n+    }\n+}\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/UpgradeHeadersTest.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/UpgradeHeadersTest.java\nnew file mode 100644\nindex 000000000000..4f9b80c65bdb\n--- /dev/null\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/UpgradeHeadersTest.java\n@@ -0,0 +1,138 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.ee9.websocket.jakarta.tests;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import jakarta.websocket.ClientEndpointConfig;\n+import jakarta.websocket.Endpoint;\n+import jakarta.websocket.EndpointConfig;\n+import jakarta.websocket.HandshakeResponse;\n+import jakarta.websocket.Session;\n+import jakarta.websocket.server.HandshakeRequest;\n+import jakarta.websocket.server.ServerEndpointConfig;\n+import org.eclipse.jetty.ee9.servlet.ServletContextHandler;\n+import org.eclipse.jetty.ee9.websocket.jakarta.client.JakartaWebSocketClientContainer;\n+import org.eclipse.jetty.ee9.websocket.jakarta.server.config.JakartaWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class UpgradeHeadersTest\n+{\n+    private Server _server;\n+    private JakartaWebSocketClientContainer _client;\n+    private ServerConnector _connector;\n+\n+    public static class MyEndpoint extends Endpoint\n+    {\n+        @Override\n+        public void onOpen(Session session, EndpointConfig config)\n+        {\n+        }\n+    }\n+\n+    public void start(ServerEndpointConfig.Configurator configurator) throws Exception\n+    {\n+        _server = new Server();\n+        _connector = new ServerConnector(_server);\n+        _server.addConnector(_connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        _server.setHandler(contextHandler);\n+        JakartaWebSocketServletContainerInitializer.configure(contextHandler, (context, container) ->\n+        {\n+            container.addEndpoint(ServerEndpointConfig.Builder\n+                .create(MyEndpoint.class, \""/\"")\n+                .configurator(configurator)\n+                .build());\n+        });\n+\n+        _server.start();\n+        _client = new JakartaWebSocketClientContainer();\n+        _client.start();\n+    }\n+\n+    @AfterEach\n+    public void after() throws Exception\n+    {\n+        _client.stop();\n+        _server.stop();\n+    }\n+\n+    @Test\n+    public void testCaseInsensitiveUpgradeHeaders() throws Exception\n+    {\n+        ClientEndpointConfig.Configurator configurator = new ClientEndpointConfig.Configurator()\n+        {\n+            @Override\n+            public void beforeRequest(Map<String, List<String>> headers)\n+            {\n+                // Verify that existing headers can be accessed in a case-insensitive way.\n+                if (headers.get(\""cOnnEcTiOn\"") == null)\n+                    throw new IllegalStateException(\""No Connection Header on client Request\"");\n+                headers.put(\""sentHeader\"", List.of(\""value123\""));\n+            }\n+\n+            @Override\n+            public void afterResponse(HandshakeResponse hr)\n+            {\n+                if (hr.getHeaders().get(\""MyHeAdEr\"") == null)\n+                    throw new IllegalStateException(\""No custom Header on HandshakeResponse\"");\n+                if (hr.getHeaders().get(\""cOnnEcTiOn\"") == null)\n+                    throw new IllegalStateException(\""No Connection Header on HandshakeRequest\"");\n+            }\n+        };\n+\n+        start(new ServerEndpointConfig.Configurator()\n+        {\n+            @Override\n+            public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)\n+            {\n+                // Verify that existing headers can be accessed in a case-insensitive way.\n+                if (request.getHeaders().get(\""cOnnEcTiOn\"") == null)\n+                    throw new IllegalStateException(\""No Connection Header on HandshakeRequest\"");\n+                if (response.getHeaders().get(\""sErVeR\"") == null)\n+                    throw new IllegalStateException(\""No Server Header on HandshakeResponse\"");\n+\n+                // Verify custom header sent from client.\n+                if (request.getHeaders().get(\""SeNtHeadEr\"") == null)\n+                    throw new IllegalStateException(\""No sent Header on HandshakeResponse\"");\n+\n+                // Add custom response header.\n+                response.getHeaders().put(\""myHeader\"", List.of(\""foobar\""));\n+                if (response.getHeaders().get(\""MyHeAdEr\"") == null)\n+                    throw new IllegalStateException(\""No custom Header on HandshakeResponse\"");\n+\n+                super.modifyHandshake(sec, request, response);\n+            }\n+        });\n+\n+        WSEndpointTracker clientEndpoint = new WSEndpointTracker(){};\n+        ClientEndpointConfig clientConfig = ClientEndpointConfig.Builder.create().configurator(configurator).build();\n+        URI uri = URI.create(\""ws://localhost:\"" + _connector.getLocalPort());\n+\n+        // If any of the above throw it would fail to upgrade to websocket.\n+        Session session = _client.connectToServer(clientEndpoint, clientConfig, uri);\n+        assertTrue(clientEndpoint.openLatch.await(5, TimeUnit.SECONDS));\n+        session.close();\n+        assertTrue(clientEndpoint.closeLatch.await(5, TimeUnit.SECONDS));\n+    }\n+}\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/client/AnnotatedClientEndpointTest.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/client/AnnotatedClientEndpointTest.java\nindex 2fec835746dc..9e5b2d29853f 100644\n--- a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/client/AnnotatedClientEndpointTest.java\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jakarta-tests/src/test/java/org/eclipse/jetty/ee9/websocket/jakarta/tests/client/AnnotatedClientEndpointTest.java\n@@ -15,14 +15,12 @@\n \n import java.io.IOException;\n import java.nio.ByteBuffer;\n-import java.util.Collections;\n import java.util.Date;\n \n import jakarta.websocket.ClientEndpoint;\n import jakarta.websocket.ClientEndpointConfig;\n import jakarta.websocket.ContainerProvider;\n import jakarta.websocket.EndpointConfig;\n-import jakarta.websocket.HandshakeResponse;\n import jakarta.websocket.OnMessage;\n import jakarta.websocket.OnOpen;\n import jakarta.websocket.Session;\n@@ -75,12 +73,6 @@ public Date onBinary(ByteBuffer buf)\n \n     public static class AnnotatedEndpointConfigurator extends ClientEndpointConfig.Configurator\n     {\n-        @Override\n-        public void afterResponse(HandshakeResponse hr)\n-        {\n-            hr.getHeaders().put(\""X-Test\"", Collections.singletonList(\""Extra\""));\n-            super.afterResponse(hr);\n-        }\n     }\n \n     private static CoreServer server;\n\ndiff --git a/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/UpgradeHeadersTest.java b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/UpgradeHeadersTest.java\nnew file mode 100644\nindex 000000000000..efea1435f2a4\n--- /dev/null\n+++ b/jetty-ee9/jetty-ee9-websocket/jetty-ee9-websocket-jetty-tests/src/test/java/org/eclipse/jetty/ee9/websocket/tests/UpgradeHeadersTest.java\n@@ -0,0 +1,124 @@\n+//\n+// ========================================================================\n+// Copyright (c) 1995 Mort Bay Consulting Pty Ltd and others.\n+//\n+// This program and the accompanying materials are made available under the\n+// terms of the Eclipse Public License v. 2.0 which is available at\n+// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+// which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+//\n+// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+// ========================================================================\n+//\n+\n+package org.eclipse.jetty.ee9.websocket.tests;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.client.Request;\n+import org.eclipse.jetty.client.Response;\n+import org.eclipse.jetty.ee9.servlet.ServletContextHandler;\n+import org.eclipse.jetty.ee9.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.ee9.websocket.client.JettyUpgradeListener;\n+import org.eclipse.jetty.ee9.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.ee9.websocket.server.JettyWebSocketCreator;\n+import org.eclipse.jetty.ee9.websocket.server.config.JettyWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class UpgradeHeadersTest\n+{\n+    private Server _server;\n+    private WebSocketClient _client;\n+    private ServerConnector _connector;\n+\n+    public void start(JettyWebSocketCreator creator) throws Exception\n+    {\n+        _server = new Server();\n+        _connector = new ServerConnector(_server);\n+        _server.addConnector(_connector);\n+\n+        ServletContextHandler contextHandler = new ServletContextHandler();\n+        JettyWebSocketServletContainerInitializer.configure(contextHandler, (servletContext, container) ->\n+            container.addMapping(\""/\"", creator));\n+        _server.setHandler(contextHandler);\n+\n+        _server.start();\n+        _client = new WebSocketClient();\n+        _client.start();\n+    }\n+\n+    @AfterEach\n+    public void after() throws Exception\n+    {\n+        _client.stop();\n+        _server.stop();\n+    }\n+\n+    @Test\n+    public void testCaseInsensitiveUpgradeHeaders() throws Exception\n+    {\n+        start((request, response) ->\n+        {\n+            // Verify that existing headers can be accessed in a case-insensitive way.\n+            if (request.getHeaders().get(\""cOnnEcTiOn\"") == null)\n+                throw new IllegalStateException(\""No Connection Header on HandshakeRequest\"");\n+            if (response.getHeaders().get(\""sErVeR\"") == null)\n+                throw new IllegalStateException(\""No Server Header on HandshakeResponse\"");\n+\n+            // Verify custom header sent from client.\n+            if (request.getHeaders().get(\""SeNtHeadEr\"") == null)\n+                throw new IllegalStateException(\""No sent Header on HandshakeResponse\"");\n+\n+            // Add custom response header.\n+            response.getHeaders().put(\""myHeader\"", List.of(\""foobar\""));\n+            if (response.getHeaders().get(\""MyHeAdEr\"") == null)\n+                throw new IllegalStateException(\""No custom Header on HandshakeResponse\"");\n+\n+            return new EchoSocket();\n+        });\n+\n+        EventSocket clientEndpoint = new EventSocket();\n+        URI uri = URI.create(\""ws://localhost:\"" + _connector.getLocalPort());\n+\n+        ClientUpgradeRequest clientUpgradeRequest = new ClientUpgradeRequest();\n+        clientUpgradeRequest.getHeaders().put(\""sentHeader\"", List.of(\""value123\""));\n+        if (clientUpgradeRequest.getHeaders().get(\""SenTHeaDer\"") == null)\n+            throw new IllegalStateException(\""No custom Header on ClientUpgradeRequest\"");\n+\n+        JettyUpgradeListener upgradeListener = new JettyUpgradeListener()\n+        {\n+            @Override\n+            public void onHandshakeRequest(Request request)\n+            {\n+                // Verify that existing headers can be accessed in a case-insensitive way.\n+                if (request.getHeaders().get(\""cOnnEcTiOn\"") == null)\n+                    throw new IllegalStateException(\""No Connection Header on client Request\"");\n+                if (request.getHeaders().get(\""SenTHeaDer\"") == null)\n+                    throw new IllegalStateException(\""No custom Header on ClientUpgradeRequest\"");\n+            }\n+\n+            @Override\n+            public void onHandshakeResponse(Request request, Response response)\n+            {\n+                if (response.getHeaders().get(\""MyHeAdEr\"") == null)\n+                    throw new IllegalStateException(\""No custom Header on HandshakeResponse\"");\n+                if (response.getHeaders().get(\""cOnnEcTiOn\"") == null)\n+                    throw new IllegalStateException(\""No Connection Header on HandshakeRequest\"");\n+            }\n+        };\n+\n+        // If any of the above throw it would fail to upgrade to websocket.\n+        assertNotNull(_client.connect(clientEndpoint, uri, clientUpgradeRequest, upgradeListener).get(5, TimeUnit.SECONDS));\n+        assertTrue(clientEndpoint.openLatch.await(5, TimeUnit.SECONDS));\n+        clientEndpoint.session.close();\n+        assertTrue(clientEndpoint.closeLatch.await(5, TimeUnit.SECONDS));\n+    }\n+}\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
"{""instance_id"": ""eclipse__jetty.project-12342"", ""pr_id"": 12342, ""issue_id"": 11307, ""repo"": ""eclipse/jetty.project"", ""problem_statement"": ""Explicit demand control in WebSocket endpoints with only onWebSocketFrame()\n**Jetty version(s)**\r\n12+\r\n\r\n**Description**\r\nIf a WebSocket endpoint only overrides `onWebSocketFrame()` it currently has no explicit control over the demand, because the implementation expects other methods to be present, and the other methods to control the demand explicitly.\r\n\r\nThere should be a way to explicitly control the demand if an application want to deal only with frames.\r\n"", ""issue_word_count"": 67, ""test_files_count"": 4, ""non_test_files_count"": 6, ""pr_changed_files"": [""jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Callback.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Frame.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Session.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrame.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrameHandler.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrameHandlerMetadata.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/ExplicitDemandTest.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ClientCloseTest.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/proxy/WebSocketProxyTest.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/server/FrameListenerTest.java""], ""pr_changed_test_files"": [""jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/ExplicitDemandTest.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ClientCloseTest.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/proxy/WebSocketProxyTest.java"", ""jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/server/FrameListenerTest.java""], ""base_commit"": ""f5b24946ab6bee45e944ebb9858433eb333b9c8d"", ""head_commit"": ""8896b10fb30934dae8d2b60b17c9bc6052353b72"", ""repo_url"": ""https://github.com/eclipse/jetty.project/pull/12342"", ""swe_url"": ""https://swe-bench-plus.turing.com/repos/eclipse__jetty.project/12342"", ""dockerfile"": """", ""pr_merged_at"": ""2024-11-15T03:25:30.000Z"", ""patch"": ""diff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Callback.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Callback.java\nindex a07eca3e1258..759153dbfdab 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Callback.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Callback.java\n@@ -57,6 +57,46 @@ public void fail(Throwable x)\n         };\n     }\n \n+    /**\n+     * Creates a nested callback that runs completed after\n+     * completing the nested callback.\n+     *\n+     * @param callback The nested callback\n+     * @param completed The completion to run after the nested callback is completed\n+     * @return a new callback.\n+     */\n+    static Callback from(Callback callback, Runnable completed)\n+    {\n+        return new Callback()\n+        {\n+            @Override\n+            public void succeed()\n+            {\n+                try\n+                {\n+                    callback.succeed();\n+                }\n+                finally\n+                {\n+                    completed.run();\n+                }\n+            }\n+\n+            @Override\n+            public void fail(Throwable x)\n+            {\n+                try\n+                {\n+                    callback.fail(x);\n+                }\n+                finally\n+                {\n+                    completed.run();\n+                }\n+            }\n+        };\n+    }\n+\n     /**\n      * <p>Method to invoke to succeed the callback.</p>\n      *\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Frame.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Frame.java\nindex 0f5bd23923e9..5c347e2142b9 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Frame.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Frame.java\n@@ -101,4 +101,22 @@ public String toString()\n     boolean isRsv2();\n \n     boolean isRsv3();\n+\n+    default CloseStatus getCloseStatus()\n+    {\n+        return null;\n+    }\n+\n+    record CloseStatus(int statusCode, String reason)\n+    {\n+    }\n+\n+    /**\n+     * The effective opcode of the frame accounting for the CONTINUATION opcode.\n+     * If the frame is a CONTINUATION frame for a TEXT message, this will return TEXT.\n+     * If the frame is a CONTINUATION frame for a BINARY message, this will return BINARY.\n+     * Otherwise, this will return the same opcode as the frame.\n+     * @return the effective opcode of the frame.\n+     */\n+    byte getEffectiveOpCode();\n }\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Session.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Session.java\nindex aba060cb4a3c..ecd950ec44d2 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Session.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-api/src/main/java/org/eclipse/jetty/websocket/api/Session.java\n@@ -227,6 +227,7 @@ default void onWebSocketOpen(Session session)\n          * or data frames either BINARY or TEXT.</p>\n          *\n          * @param frame the received frame\n+         * @param callback the callback to complete once the frame has been processed.\n          */\n         default void onWebSocketFrame(Frame frame, Callback callback)\n         {\n@@ -284,6 +285,7 @@ default void onWebSocketPartialText(String payload, boolean last)\n          * <p>A WebSocket BINARY message has been received.</p>\n          *\n          * @param payload the raw payload array received\n+         * @param callback the callback to complete when the payload has been processed\n          */\n         default void onWebSocketBinary(ByteBuffer payload, Callback callback)\n         {\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrame.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrame.java\nindex ed0580d37201..317aff7507bb 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrame.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrame.java\n@@ -16,14 +16,32 @@\n import java.nio.ByteBuffer;\n \n import org.eclipse.jetty.websocket.core.Frame;\n+import org.eclipse.jetty.websocket.core.OpCode;\n \n public class JettyWebSocketFrame implements org.eclipse.jetty.websocket.api.Frame\n {\n     private final Frame frame;\n+    private final byte effectiveOpCode;\n \n+    /**\n+     * @param frame the core websocket {@link Frame} to wrap as a {@link org.eclipse.jetty.websocket.api.Frame}.\n+     * @deprecated there is no alternative intended to publicly construct a {@link JettyWebSocketFrame}.\n+     */\n+    @Deprecated(forRemoval = true, since = \""12.1.0\"")\n     public JettyWebSocketFrame(Frame frame)\n+    {\n+        this(frame, frame.getOpCode());\n+    }\n+\n+    /**\n+     * @param frame the core websocket {@link Frame} to wrap as a Jetty API {@link org.eclipse.jetty.websocket.api.Frame}.\n+     * @param effectiveOpCode the effective OpCode of the Frame, where any CONTINUATION should be replaced with the\n+     * initial opcode of that websocket message.\n+     */\n+    JettyWebSocketFrame(Frame frame, byte effectiveOpCode)\n     {\n         this.frame = frame;\n+        this.effectiveOpCode = effectiveOpCode;\n     }\n \n     @Override\n@@ -92,6 +110,21 @@ public boolean isRsv3()\n         return frame.isRsv3();\n     }\n \n+    @Override\n+    public byte getEffectiveOpCode()\n+    {\n+        return effectiveOpCode;\n+    }\n+\n+    @Override\n+    public CloseStatus getCloseStatus()\n+    {\n+        if (getOpCode() != OpCode.CLOSE)\n+            return null;\n+        org.eclipse.jetty.websocket.core.CloseStatus closeStatus = org.eclipse.jetty.websocket.core.CloseStatus.getCloseStatus(frame);\n+        return new CloseStatus(closeStatus.getCode(), closeStatus.getReason());\n+    }\n+\n     @Override\n     public String toString()\n     {\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrameHandler.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrameHandler.java\nindex 902784fda5d5..1b4e79e07a0f 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrameHandler.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrameHandler.java\n@@ -19,7 +19,6 @@\n import java.lang.reflect.InvocationTargetException;\n import java.nio.ByteBuffer;\n import java.nio.channels.ClosedChannelException;\n-import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.eclipse.jetty.util.BufferUtil;\n@@ -69,6 +68,7 @@ public class JettyWebSocketFrameHandler implements FrameHandler\n     private MessageSink binarySink;\n     private MessageSink activeMessageSink;\n     private WebSocketSession session;\n+    private byte messageType;\n \n     public JettyWebSocketFrameHandler(WebSocketContainer container, Object endpointInstance, JettyWebSocketFrameHandlerMetadata metadata)\n     {\n@@ -193,44 +193,36 @@ private static MessageSink createMessageSink(Class<? extends MessageSink> sinkCl\n     @Override\n     public void onFrame(Frame frame, Callback coreCallback)\n     {\n-        CompletableFuture<Void> frameCallback = null;\n+        if (frame.getOpCode() == OpCode.TEXT || frame.getOpCode() == OpCode.BINARY)\n+            messageType = frame.getOpCode();\n+\n         if (frameHandle != null)\n         {\n             try\n             {\n-                frameCallback = new org.eclipse.jetty.websocket.api.Callback.Completable();\n-                frameHandle.invoke(new JettyWebSocketFrame(frame), frameCallback);\n+                byte effectiveOpCode = frame.isDataFrame() ? messageType : frame.getOpCode();\n+                frameHandle.invoke(new JettyWebSocketFrame(frame, effectiveOpCode),\n+                    org.eclipse.jetty.websocket.api.Callback.from(coreCallback::succeeded, coreCallback::failed));\n             }\n             catch (Throwable cause)\n             {\n                 coreCallback.failed(new WebSocketException(endpointInstance.getClass().getSimpleName() + \"" FRAME method error: \"" + cause.getMessage(), cause));\n-                return;\n             }\n+\n+            autoDemand();\n+            return;\n         }\n \n-        Callback.Completable eventCallback = new Callback.Completable();\n         switch (frame.getOpCode())\n         {\n-            case OpCode.CLOSE -> onCloseFrame(frame, eventCallback);\n-            case OpCode.PING -> onPingFrame(frame, eventCallback);\n-            case OpCode.PONG -> onPongFrame(frame, eventCallback);\n-            case OpCode.TEXT -> onTextFrame(frame, eventCallback);\n-            case OpCode.BINARY -> onBinaryFrame(frame, eventCallback);\n-            case OpCode.CONTINUATION -> onContinuationFrame(frame, eventCallback);\n+            case OpCode.TEXT -> onTextFrame(frame, coreCallback);\n+            case OpCode.BINARY -> onBinaryFrame(frame, coreCallback);\n+            case OpCode.CONTINUATION -> onContinuationFrame(frame, coreCallback);\n+            case OpCode.PING -> onPingFrame(frame, coreCallback);\n+            case OpCode.PONG -> onPongFrame(frame, coreCallback);\n+            case OpCode.CLOSE -> onCloseFrame(frame, coreCallback);\n             default -> coreCallback.failed(new IllegalStateException());\n-        };\n-\n-        // Combine the callback from the frame handler and the event handler.\n-        CompletableFuture<Void> callback = eventCallback;\n-        if (frameCallback != null)\n-            callback = frameCallback.thenCompose(ignored -> eventCallback);\n-        callback.whenComplete((r, x) ->\n-        {\n-            if (x == null)\n-                coreCallback.succeeded();\n-            else\n-                coreCallback.failed(x);\n-        });\n+        }\n     }\n \n     @Override\n@@ -358,6 +350,7 @@ private void onPongFrame(Frame frame, Callback callback)\n         }\n         else\n         {\n+            callback.succeeded();\n             internalDemand();\n         }\n     }\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrameHandlerMetadata.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrameHandlerMetadata.java\nindex 0a5009558f8a..36724749ad0d 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrameHandlerMetadata.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-common/src/main/java/org/eclipse/jetty/websocket/common/JettyWebSocketFrameHandlerMetadata.java\n@@ -46,6 +46,7 @@ public void setAutoDemand(boolean autoDemand)\n     public void setBinaryHandle(Class<? extends MessageSink> sinkClass, MethodHandle binary, Object origin)\n     {\n         assertNotSet(this.binaryHandle, \""BINARY Handler\"", origin);\n+        assertNotSet(this.frameHandle, \""FRAME Handler\"", origin);\n         this.binaryHandle = binary;\n         this.binarySink = sinkClass;\n     }\n@@ -85,6 +86,10 @@ public MethodHandle getErrorHandle()\n     public void setFrameHandle(MethodHandle frame, Object origin)\n     {\n         assertNotSet(this.frameHandle, \""FRAME Handler\"", origin);\n+        assertNotSet(this.textHandle, \""TEXT Handler\"", origin);\n+        assertNotSet(this.binaryHandle, \""BINARY Handler\"", origin);\n+        assertNotSet(this.pingHandle, \""PING Handler\"", origin);\n+        assertNotSet(this.pongHandle, \""PONG Handler\"", origin);\n         this.frameHandle = frame;\n     }\n \n@@ -107,6 +112,7 @@ public MethodHandle getOpenHandle()\n     public void setPingHandle(MethodHandle ping, Object origin)\n     {\n         assertNotSet(this.pingHandle, \""PING Handler\"", origin);\n+        assertNotSet(this.frameHandle, \""FRAME Handler\"", origin);\n         this.pingHandle = ping;\n     }\n \n@@ -118,6 +124,7 @@ public MethodHandle getPingHandle()\n     public void setPongHandle(MethodHandle pong, Object origin)\n     {\n         assertNotSet(this.pongHandle, \""PONG Handler\"", origin);\n+        assertNotSet(this.frameHandle, \""FRAME Handler\"", origin);\n         this.pongHandle = pong;\n     }\n \n@@ -129,6 +136,7 @@ public MethodHandle getPongHandle()\n     public void setTextHandle(Class<? extends MessageSink> sinkClass, MethodHandle text, Object origin)\n     {\n         assertNotSet(this.textHandle, \""TEXT Handler\"", origin);\n+        assertNotSet(this.frameHandle, \""FRAME Handler\"", origin);\n         this.textHandle = text;\n         this.textSink = sinkClass;\n     }\n"", ""test_patch"": ""diff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/ExplicitDemandTest.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/ExplicitDemandTest.java\nindex 2994945b7c91..637f56251942 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/ExplicitDemandTest.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/ExplicitDemandTest.java\n@@ -44,6 +44,7 @@\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n@@ -72,12 +73,36 @@ public void onMessage(String message) throws IOException\n     public static class ListenerSocket implements Session.Listener\n     {\n         final List<Frame> frames = new CopyOnWriteArrayList<>();\n+        final List<Callback> callbacks = new CopyOnWriteArrayList<>();\n+        Session session;\n+\n+        @Override\n+        public void onWebSocketOpen(Session session)\n+        {\n+            this.session = session;\n+            session.demand();\n+        }\n \n         @Override\n         public void onWebSocketFrame(Frame frame, Callback callback)\n         {\n             frames.add(frame);\n-            callback.succeed();\n+            callbacks.add(callback);\n+\n+            // Because no pingListener is registered, the frameListener is responsible for handling pings.\n+            if (frame.getOpCode() == OpCode.PING)\n+            {\n+                session.sendPong(frame.getPayload(), Callback.from(session::demand, callback::fail));\n+                return;\n+            }\n+            else if (frame.getOpCode() == OpCode.CLOSE)\n+            {\n+                Frame.CloseStatus closeStatus = frame.getCloseStatus();\n+                session.close(closeStatus.statusCode(), closeStatus.reason(), Callback.NOOP);\n+                return;\n+            }\n+\n+            session.demand();\n         }\n     }\n \n@@ -109,27 +134,19 @@ public void onWebSocketFrame(Frame frame, Callback callback)\n             if (frame.getOpCode() == OpCode.TEXT)\n                 textMessages.add(BufferUtil.toString(frame.getPayload()));\n             callback.succeed();\n+            session.demand();\n         }\n     }\n \n     @WebSocket(autoDemand = false)\n     public static class PingSocket extends ListenerSocket\n     {\n-        Session session;\n-\n-        @Override\n-        public void onWebSocketOpen(Session session)\n-        {\n-            this.session = session;\n-            session.demand();\n-        }\n-\n         @Override\n         public void onWebSocketFrame(Frame frame, Callback callback)\n         {\n-            super.onWebSocketFrame(frame, callback);\n             if (frame.getType() == Frame.Type.TEXT)\n                 session.sendPing(ByteBuffer.wrap(\""server-ping\"".getBytes(StandardCharsets.UTF_8)), Callback.NOOP);\n+            super.onWebSocketFrame(frame, callback);\n         }\n     }\n \n@@ -217,13 +234,23 @@ public void testNoAutoDemand() throws Exception\n         Frame frame0 = listenerSocket.frames.get(0);\n         assertThat(frame0.getType(), is(Frame.Type.PONG));\n         assertThat(StandardCharsets.UTF_8.decode(frame0.getPayload()).toString(), is(\""ping-0\""));\n+        Callback callback0 = listenerSocket.callbacks.get(0);\n+        assertNotNull(callback0);\n+        callback0.succeed();\n+\n         Frame frame1 = listenerSocket.frames.get(1);\n         assertThat(frame1.getType(), is(Frame.Type.PONG));\n         assertThat(StandardCharsets.UTF_8.decode(frame1.getPayload()).toString(), is(\""ping-1\""));\n+        Callback callback1 = listenerSocket.callbacks.get(1);\n+        assertNotNull(callback1);\n+        callback1.succeed();\n \n         session.close();\n         await().atMost(5, TimeUnit.SECONDS).until(listenerSocket.frames::size, is(3));\n         assertThat(listenerSocket.frames.get(2).getType(), is(Frame.Type.CLOSE));\n+        Callback closeCallback = listenerSocket.callbacks.get(2);\n+        assertNotNull(closeCallback);\n+        closeCallback.succeed();\n     }\n \n     @Test\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ClientCloseTest.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ClientCloseTest.java\nindex 877d9bbae90b..aadda72bad8c 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ClientCloseTest.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/client/ClientCloseTest.java\n@@ -28,6 +28,7 @@\n import org.eclipse.jetty.server.ServerConnector;\n import org.eclipse.jetty.server.handler.ContextHandler;\n import org.eclipse.jetty.util.BlockingArrayQueue;\n+import org.eclipse.jetty.util.Utf8StringBuilder;\n import org.eclipse.jetty.websocket.api.Callback;\n import org.eclipse.jetty.websocket.api.Frame;\n import org.eclipse.jetty.websocket.api.Session;\n@@ -417,6 +418,7 @@ public static class ServerEndpoint implements Session.Listener.AutoDemanding\n         private static final Logger LOG = LoggerFactory.getLogger(ServerEndpoint.class);\n         private Session session;\n         CountDownLatch block = new CountDownLatch(1);\n+        Utf8StringBuilder stringBuilder = new Utf8StringBuilder();\n \n         @Override\n         public void onWebSocketOpen(Session session)\n@@ -424,8 +426,7 @@ public void onWebSocketOpen(Session session)\n             this.session = session;\n         }\n \n-        @Override\n-        public void onWebSocketText(String message)\n+        public void onText(String message)\n         {\n             try\n             {\n@@ -510,7 +511,23 @@ else if (reason.startsWith(\""sleep|\""))\n                         LOG.trace(\""IGNORED\"", x);\n                     }\n                 }\n+                else\n+                {\n+                    session.close(closeInfo.getCode(), reason, callback);\n+                    return;\n+                }\n             }\n+            else if (frame.getEffectiveOpCode() == OpCode.TEXT)\n+            {\n+                stringBuilder.append(frame.getPayload());\n+                if (frame.isFin())\n+                {\n+                    String completeString = stringBuilder.toCompleteString();\n+                    stringBuilder.reset();\n+                    onText(completeString);\n+                }\n+            }\n+\n             callback.succeed();\n         }\n     }\n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/proxy/WebSocketProxyTest.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/proxy/WebSocketProxyTest.java\nindex 62d8b8d100b4..e71dd5772b26 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/proxy/WebSocketProxyTest.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/proxy/WebSocketProxyTest.java\n@@ -18,6 +18,7 @@\n import java.nio.ByteBuffer;\n import java.time.Duration;\n import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jetty.logging.StacklessLogging;\n@@ -32,7 +33,10 @@\n import org.eclipse.jetty.websocket.api.Frame;\n import org.eclipse.jetty.websocket.api.Session;\n import org.eclipse.jetty.websocket.api.StatusCode;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketClose;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n import org.eclipse.jetty.websocket.api.annotations.OnWebSocketFrame;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketOpen;\n import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n import org.eclipse.jetty.websocket.api.exceptions.WebSocketException;\n import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n@@ -44,6 +48,8 @@\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsString;\n@@ -265,9 +271,6 @@ public void timeoutTest() throws Exception\n     @Test\n     public void testPingPong() throws Exception\n     {\n-        PingPongSocket serverEndpoint = new PingPongSocket();\n-        serverSocket = serverEndpoint;\n-\n         PingPongSocket clientSocket = new PingPongSocket();\n         client.connect(clientSocket, proxyUri);\n         assertTrue(clientSocket.openLatch.await(5, TimeUnit.SECONDS));\n@@ -276,12 +279,10 @@ public void testPingPong() throws Exception\n         // Test unsolicited pong from client.\n         ByteBuffer b2 = BufferUtil.toBuffer(\""unsolicited pong from client\"");\n         clientSocket.session.sendPong(b2, Callback.NOOP);\n-        assertThat(serverEndpoint.pingMessages.size(), is(0));\n-        assertThat(serverEndpoint.pongMessages.poll(5, TimeUnit.SECONDS), is(BufferUtil.toBuffer(\""unsolicited pong from client\"")));\n \n         // Test unsolicited pong from server.\n         ByteBuffer b1 = BufferUtil.toBuffer(\""unsolicited pong from server\"");\n-        serverEndpoint.session.sendPong(b1, Callback.NOOP);\n+        serverSocket.session.sendPong(b1, Callback.NOOP);\n         assertThat(clientSocket.pingMessages.size(), is(0));\n         assertThat(clientSocket.pongMessages.poll(5, TimeUnit.SECONDS), is(BufferUtil.toBuffer(\""unsolicited pong from server\"")));\n \n@@ -293,7 +294,6 @@ public void testPingPong() throws Exception\n         }\n         for (int i = 0; i < 15; i++)\n         {\n-            assertThat(serverEndpoint.pingMessages.poll(5, TimeUnit.SECONDS), is(intToStringByteBuffer(i)));\n             assertThat(clientSocket.pongMessages.poll(5, TimeUnit.SECONDS), is(intToStringByteBuffer(i)));\n         }\n \n@@ -301,12 +301,11 @@ public void testPingPong() throws Exception\n         for (int i = 0; i < 23; i++)\n         {\n             ByteBuffer b = intToStringByteBuffer(i);\n-            serverEndpoint.session.sendPing(b, Callback.NOOP);\n+            serverSocket.session.sendPing(b, Callback.NOOP);\n         }\n         for (int i = 0; i < 23; i++)\n         {\n             assertThat(clientSocket.pingMessages.poll(5, TimeUnit.SECONDS), is(intToStringByteBuffer(i)));\n-            assertThat(serverEndpoint.pongMessages.poll(5, TimeUnit.SECONDS), is(intToStringByteBuffer(i)));\n         }\n \n         clientSocket.session.close(StatusCode.NORMAL, \""closing from test\"", Callback.NOOP);\n@@ -328,7 +327,6 @@ public void testPingPong() throws Exception\n \n         // Check we had no unexpected pings or pongs sent.\n         assertThat(clientSocket.pingMessages.size(), is(0));\n-        assertThat(serverEndpoint.pingMessages.size(), is(0));\n     }\n \n     private ByteBuffer intToStringByteBuffer(int i)\n@@ -337,20 +335,74 @@ private ByteBuffer intToStringByteBuffer(int i)\n     }\n \n     @WebSocket\n-    public static class PingPongSocket extends EventSocket\n+    public static class PingPongSocket\n     {\n         public BlockingQueue<ByteBuffer> pingMessages = new BlockingArrayQueue<>();\n         public BlockingQueue<ByteBuffer> pongMessages = new BlockingArrayQueue<>();\n \n+        private static final Logger LOG = LoggerFactory.getLogger(EventSocket.class);\n+\n+        public Session session;\n+\n+        public volatile int closeCode = StatusCode.UNDEFINED;\n+        public volatile String closeReason;\n+        public volatile Throwable error = null;\n+\n+        public CountDownLatch openLatch = new CountDownLatch(1);\n+        public CountDownLatch errorLatch = new CountDownLatch(1);\n+        public CountDownLatch closeLatch = new CountDownLatch(1);\n+\n+        @OnWebSocketOpen\n+        public void onOpen(Session session)\n+        {\n+            this.session = session;\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\""{}  onOpen(): {}\"", this, session);\n+            openLatch.countDown();\n+        }\n+\n         @OnWebSocketFrame\n         public void onWebSocketFrame(Frame frame, Callback callback)\n         {\n             switch (frame.getOpCode())\n             {\n-                case OpCode.PING -> pingMessages.add(BufferUtil.copy(frame.getPayload()));\n-                case OpCode.PONG -> pongMessages.add(BufferUtil.copy(frame.getPayload()));\n+                case OpCode.PING ->\n+                {\n+                    pingMessages.add(BufferUtil.copy(frame.getPayload()));\n+                    session.sendPong(frame.getPayload(), callback);\n+                }\n+                case OpCode.PONG ->\n+                {\n+                    pongMessages.add(BufferUtil.copy(frame.getPayload()));\n+                    callback.succeed();\n+                }\n+                default -> callback.succeed();\n             }\n-            callback.succeed();\n+        }\n+\n+        @OnWebSocketClose\n+        public void onClose(int statusCode, String reason)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\""{}  onClose(): {}:{}\"", this, statusCode, reason);\n+            this.closeCode = statusCode;\n+            this.closeReason = reason;\n+            closeLatch.countDown();\n+        }\n+\n+        @OnWebSocketError\n+        public void onError(Throwable cause)\n+        {\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\""{}  onError(): {}\"", this, cause);\n+            error = cause;\n+            errorLatch.countDown();\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return String.format(\""[%s@%x]\"", getClass().getSimpleName(), hashCode());\n         }\n     }\n \n\ndiff --git a/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/server/FrameListenerTest.java b/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/server/FrameListenerTest.java\nindex 6378deb4128e..9adc5a28813e 100644\n--- a/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/server/FrameListenerTest.java\n+++ b/jetty-core/jetty-websocket/jetty-websocket-jetty-tests/src/test/java/org/eclipse/jetty/websocket/tests/server/FrameListenerTest.java\n@@ -131,10 +131,12 @@ public static class FrameEndpoint implements Session.Listener\n     {\n         public CountDownLatch closeLatch = new CountDownLatch(1);\n         public LinkedBlockingQueue<String> frameEvents = new LinkedBlockingQueue<>();\n+        public Session session;\n \n         @Override\n         public void onWebSocketOpen(Session session)\n         {\n+            this.session = session;\n             session.demand();\n         }\n \n@@ -147,6 +149,7 @@ public void onWebSocketFrame(Frame frame, Callback callback)\n                 BufferUtil.toUTF8String(frame.getPayload()),\n                 frame.getPayloadLength()));\n             callback.succeed();\n+            session.demand();\n         }\n \n         @Override\n"", ""agent_patch"": null, ""FAIL_TO_PASS"": [], ""PASS_TO_PASS"": [], ""test_output_before"": null, ""errors_before"": [], ""failed_before"": [], ""test_output_after"": null, ""errors_after"": [], ""failed_after"": []}"
