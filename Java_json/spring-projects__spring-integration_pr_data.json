[
  {
    "instance_id": "spring-projects__spring-integration-9493",
    "pr_id": 9493,
    "issue_id": 9455,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Application shuts down immediately after connecting to a websocket\nI wrote a simple Spring Integration app that connects to a websocket, using `spring-integration-websocket`.\r\n\r\n**Expected Behavior**\r\n\r\nThe app connects to the websocket and keeps listening for new messages.\r\n\r\n**Current Behavior**\r\n\r\nOnce connected the application shuts down immediately, since there is no non-daemon thread running, as pointed out by @artembilan on stackoverflow (https://stackoverflow.com/questions/78961574/why-does-my-spring-integration-app-just-shutdown-without-listening/) and the canonical way to keep this from happening is to use the property `spring.main.keep-alive=true`.\r\n\r\n**Context**\r\n\r\nIt seems like a strange convention to keep this as the default. I think it would make sense to make the default the inverse of the current behavior.\r\n\r\nA working example:\r\n\r\n```\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.integration.channel.PublishSubscribeChannel;\r\nimport org.springframework.integration.config.EnableIntegration;\r\nimport org.springframework.integration.dsl.IntegrationFlow;\r\nimport org.springframework.integration.handler.LoggingHandler;\r\nimport org.springframework.integration.websocket.ClientWebSocketContainer;\r\nimport org.springframework.integration.websocket.inbound.WebSocketInboundChannelAdapter;\r\nimport org.springframework.messaging.MessageChannel;\r\nimport org.springframework.web.socket.client.standard.StandardWebSocketClient;\r\n\r\n@SpringBootApplication\r\n@EnableIntegration\r\npublic class BinanceListenerApplication {\r\n\r\n    @Bean\r\n    MessageChannel rawAggTradeChannel(){\r\n        return new PublishSubscribeChannel();\r\n    }\r\n\r\n    @Bean\r\n    IntegrationFlow logging(){\r\n        return IntegrationFlow.from(rawAggTradeChannel()).handle(new LoggingHandler(LoggingHandler.Level.INFO)).get();\r\n    }\r\n\r\n    @Bean\r\n    IntegrationFlow binanceWebsocketAggTradeStream() {\r\n        var clientWebSocketContainer = new ClientWebSocketContainer(new StandardWebSocketClient(),\r\n                \"wss://stream.binance.com:9443/ws/avaxusdt@aggTrade\");\r\n        var websocketInboundChannelAdapter = new WebSocketInboundChannelAdapter(clientWebSocketContainer);\r\n        return IntegrationFlow\r\n                .from(websocketInboundChannelAdapter)\r\n                .channel(rawAggTradeChannel())\r\n                .get();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n\r\n        SpringApplication application = new SpringApplication(BinanceListenerApplication.class);\r\n        application.setWebApplicationType(WebApplicationType.NONE);\r\n        application.run(args);\r\n    }\r\n\r\n}\r\n```",
    "issue_word_count": 264,
    "test_files_count": 2,
    "non_test_files_count": 10,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/config/DefaultConfiguringBeanFactoryPostProcessor.java",
      "spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationContextUtils.java",
      "spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationProperties.java",
      "spring-integration-core/src/main/java/org/springframework/integration/endpoint/management/IntegrationKeepAlive.java",
      "spring-integration-core/src/main/java/org/springframework/integration/endpoint/management/package-info.java",
      "spring-integration-core/src/main/resources/META-INF/spring.integration.default.properties",
      "spring-integration-core/src/test/java/org/springframework/integration/context/IntegrationContextTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/endpoint/IntegrationKeepAliveTests.java",
      "src/reference/antora/modules/ROOT/nav.adoc",
      "src/reference/antora/modules/ROOT/pages/configuration/global-properties.adoc",
      "src/reference/antora/modules/ROOT/pages/keep-alive.adoc",
      "src/reference/antora/modules/ROOT/pages/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/context/IntegrationContextTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/endpoint/IntegrationKeepAliveTests.java"
    ],
    "base_commit": "430094f4b2f76b40dd544ab1dd2a5a5bc940392f",
    "head_commit": "2c2ed25d6594c3c95330661ebcea2aeacc08cbbe",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9493",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9493",
    "dockerfile": "",
    "pr_merged_at": "2024-09-25T18:31:41.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/DefaultConfiguringBeanFactoryPostProcessor.java b/spring-integration-core/src/main/java/org/springframework/integration/config/DefaultConfiguringBeanFactoryPostProcessor.java\nindex 136034b038e..dbe3e0c9118 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/DefaultConfiguringBeanFactoryPostProcessor.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/DefaultConfiguringBeanFactoryPostProcessor.java\n@@ -44,6 +44,7 @@\n import org.springframework.integration.config.xml.IntegrationNamespaceUtils;\n import org.springframework.integration.context.IntegrationContextUtils;\n import org.springframework.integration.context.IntegrationProperties;\n+import org.springframework.integration.endpoint.management.IntegrationKeepAlive;\n import org.springframework.integration.handler.LoggingHandler;\n import org.springframework.integration.handler.support.IntegrationMessageHandlerMethodFactory;\n import org.springframework.integration.json.JsonPathUtils;\n@@ -129,6 +130,7 @@ public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) t\n \t\tregisterListMessageHandlerMethodFactory();\n \t\tregisterIntegrationConfigurationReport();\n \t\tregisterControlBusCommandRegistry();\n+\t\tregisterKeepAlive();\n \t}\n \n \t@Override\n@@ -460,4 +462,15 @@ private static BeanDefinitionBuilder createMessageHandlerMethodFactoryBeanDefini\n \t\t\t\t\t\tIntegrationContextUtils.ARGUMENT_RESOLVER_MESSAGE_CONVERTER_BEAN_NAME);\n \t}\n \n+\tprivate void registerKeepAlive() {\n+\t\tif (!this.beanFactory.containsBean(IntegrationContextUtils.INTEGRATION_KEEP_ALIVE_BEAN_NAME)) {\n+\t\t\tBeanDefinitionBuilder builder =\n+\t\t\t\t\tBeanDefinitionBuilder.genericBeanDefinition(IntegrationKeepAlive.class)\n+\t\t\t\t\t\t\t.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n+\n+\t\t\tthis.registry.registerBeanDefinition(IntegrationContextUtils.INTEGRATION_KEEP_ALIVE_BEAN_NAME,\n+\t\t\t\t\tbuilder.getBeanDefinition());\n+\t\t}\n+\t}\n+\n }\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationContextUtils.java b/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationContextUtils.java\nindex f7d2f8a857c..b404c060323 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationContextUtils.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationContextUtils.java\n@@ -100,8 +100,18 @@ public abstract class IntegrationContextUtils {\n \n \tpublic static final String LIST_MESSAGE_HANDLER_FACTORY_BEAN_NAME = \"integrationListMessageHandlerMethodFactory\";\n \n+\t/**\n+\t * The bean name for the {@code org.springframework.integration.support.management.ControlBusCommandRegistry}.\n+\t * @since 6.4\n+\t */\n \tpublic static final String CONTROL_BUS_COMMAND_REGISTRY_BEAN_NAME = \"controlBusCommandRegistry\";\n \n+\t/**\n+\t * The bean name for the {@code org.springframework.integration.endpoint.management.IntegrationKeepAlive}.\n+\t * @since 6.4\n+\t */\n+\tpublic static final String INTEGRATION_KEEP_ALIVE_BEAN_NAME = \"integrationKeepAlive\";\n+\n \t/**\n \t * The default timeout for blocking operations like send and receive messages.\n \t * @since 6.1\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationProperties.java b/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationProperties.java\nindex d31bd8c9303..41c58b376e4 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationProperties.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationProperties.java\n@@ -25,7 +25,7 @@\n \n /**\n  * Utility class to encapsulate infrastructure Integration properties constants and their default values.\n- * The default values can be overridden by the {@code META-INF/spring.integration.properties} with this entries\n+ * The default values can be overridden by the {@code META-INF/spring.integration.properties} with these entries\n  * (includes their default values):\n  * <ul>\n  *   <li> {@code spring.integration.channels.autoCreate=true}\n@@ -38,6 +38,7 @@\n  *   <li> {@code spring.integration.channels.error.requireSubscribers=true}\n  *   <li> {@code spring.integration.channels.error.ignoreFailures=true}\n  *   <li> {@code spring.integration.endpoints.defaultTimeout=30000}\n+ *   <li> {@code spring.integration.keepAlive=true}\n  * </ul>\n  *\n  * @author Artem Bilan\n@@ -117,6 +118,12 @@ public final class IntegrationProperties {\n \t */\n \tpublic static final String ENDPOINTS_DEFAULT_TIMEOUT = INTEGRATION_PROPERTIES_PREFIX + \"endpoints.defaultTimeout\";\n \n+\t/**\n+\t * Set to {@code false} to fully disable Keep-Alive thread.\n+\t * @since 6.4\n+\t */\n+\tpublic static final String KEEP_ALIVE = INTEGRATION_PROPERTIES_PREFIX + \"keepAlive\";\n+\n \tprivate static final Properties DEFAULTS;\n \n \tprivate boolean channelsAutoCreate = true;\n@@ -139,6 +146,8 @@ public final class IntegrationProperties {\n \n \tprivate long endpointsDefaultTimeout = IntegrationContextUtils.DEFAULT_TIMEOUT;\n \n+\tprivate boolean keepAlive = true;\n+\n \tprivate volatile Properties properties;\n \n \tstatic {\n@@ -312,11 +321,30 @@ public long getEndpointsDefaultTimeout() {\n \t/**\n \t * Configure a value for {@link #ENDPOINTS_DEFAULT_TIMEOUT} option.\n \t * @param endpointsDefaultTimeout the value for {@link #ENDPOINTS_DEFAULT_TIMEOUT} option.\n+\t * @since 6.2\n \t */\n \tpublic void setEndpointsDefaultTimeout(long endpointsDefaultTimeout) {\n \t\tthis.endpointsDefaultTimeout = endpointsDefaultTimeout;\n \t}\n \n+\t/**\n+\t * Return the value of {@link #KEEP_ALIVE} option.\n+\t * @return the value of {@link #KEEP_ALIVE} option.\n+\t * @since 6.4\n+\t */\n+\tpublic boolean isKeepAlive() {\n+\t\treturn this.keepAlive;\n+\t}\n+\n+\t/**\n+\t * Configure a value for {@link #KEEP_ALIVE} option.\n+\t * Defaults {@code true} - set to {@code false} disable keep-alive thread.\n+\t * @param keepAlive {@code false} to disable keep-alive thread.\n+\t */\n+\tpublic void setKeepAlive(boolean keepAlive) {\n+\t\tthis.keepAlive = keepAlive;\n+\t}\n+\n \t/**\n \t * Represent the current instance as a {@link Properties}.\n \t * @return the {@link Properties} representation.\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/management/IntegrationKeepAlive.java b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/management/IntegrationKeepAlive.java\nnew file mode 100644\nindex 00000000000..33d7e0efe79\n--- /dev/null\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/management/IntegrationKeepAlive.java\n@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.endpoint.management;\n+\n+import java.time.Instant;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import org.springframework.beans.BeansException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.BeanFactoryAware;\n+import org.springframework.beans.factory.SmartInitializingSingleton;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.integration.context.IntegrationContextUtils;\n+import org.springframework.integration.context.IntegrationProperties;\n+import org.springframework.integration.endpoint.AbstractPollingEndpoint;\n+import org.springframework.scheduling.TaskScheduler;\n+\n+/**\n+ * The component to keep an application alive when there are no non-daemon threads.\n+ * Some application might just not rely on the loops in specific threads for their logic.\n+ * Or target protocol to integrate with communicates via daemon threads.\n+ * <p>\n+ * A bean for this class is registered automatically by Spring Integration infrastructure.\n+ * It is started by application context for a blocked keep-alive dedicated thread\n+ * only if there is no {@link AbstractPollingEndpoint} beans in the application context\n+ * or {@link TaskScheduler} is configured for daemon (or virtual) threads.\n+ * <p>\n+ * Can be stopped (or started respectively) manually after injection into some target service if found redundant.\n+ * <p>\n+ * The {@link IntegrationProperties#KEEP_ALIVE} integration global\n+ * property can be set to {@code false} to disable this component regardless of the application logic.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 6.4\n+ */\n+public class IntegrationKeepAlive implements SmartLifecycle, SmartInitializingSingleton, BeanFactoryAware {\n+\n+\tprivate static final Log LOG = LogFactory.getLog(IntegrationKeepAlive.class);\n+\n+\tprivate final AtomicBoolean running = new AtomicBoolean();\n+\n+\tprivate BeanFactory beanFactory;\n+\n+\tprivate boolean autoStartup;\n+\n+\tprivate volatile Thread keepAliveThread;\n+\n+\t@Override\n+\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n+\t\tthis.beanFactory = beanFactory;\n+\t}\n+\n+\t@Override\n+\tpublic void afterSingletonsInstantiated() {\n+\t\tIntegrationProperties integrationProperties = IntegrationContextUtils.getIntegrationProperties(this.beanFactory);\n+\t\tthis.autoStartup =\n+\t\t\t\tintegrationProperties.isKeepAlive()\n+\t\t\t\t\t\t&& (isTaskSchedulerDaemon() || !isAbstractPollingEndpointPresent());\n+\t}\n+\n+\tprivate boolean isTaskSchedulerDaemon() {\n+\t\tTaskScheduler taskScheduler = IntegrationContextUtils.getTaskScheduler(this.beanFactory);\n+\t\tAtomicBoolean isDaemon = new AtomicBoolean();\n+\t\tCountDownLatch checkDaemonThreadLatch = new CountDownLatch(1);\n+\t\ttaskScheduler.schedule(() -> {\n+\t\t\tisDaemon.set(Thread.currentThread().isDaemon());\n+\t\t\tcheckDaemonThreadLatch.countDown();\n+\t\t}, Instant.now());\n+\n+\t\tboolean logWarning = false;\n+\t\ttry {\n+\t\t\tif (!checkDaemonThreadLatch.await(10, TimeUnit.SECONDS)) {\n+\t\t\t\tlogWarning = true;\n+\t\t\t}\n+\t\t}\n+\t\tcatch (InterruptedException ex) {\n+\t\t\tlogWarning = true;\n+\t\t}\n+\t\tif (logWarning) {\n+\t\t\tLOG.warn(\"The 'IntegrationKeepAlive' cannot check a 'TaskScheduler' daemon threads status. \" +\n+\t\t\t\t\t\"Falling back to 'keep-alive'\");\n+\t\t}\n+\t\treturn isDaemon.get();\n+\t}\n+\n+\tprivate boolean isAbstractPollingEndpointPresent() {\n+\t\treturn this.beanFactory.getBeanProvider(AbstractPollingEndpoint.class)\n+\t\t\t\t.stream()\n+\t\t\t\t.findAny()\n+\t\t\t\t.isPresent();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isAutoStartup() {\n+\t\treturn this.autoStartup;\n+\t}\n+\n+\t@Override\n+\tpublic void start() {\n+\t\tif (this.running.compareAndSet(false, true)) {\n+\t\t\tthis.keepAliveThread =\n+\t\t\t\t\tnew Thread(() -> {\n+\t\t\t\t\t\twhile (true) {\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\tThread.sleep(Long.MAX_VALUE);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcatch (InterruptedException ex) {\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\tthis.keepAliveThread.setDaemon(false);\n+\t\t\tthis.keepAliveThread.setName(\"spring-integration-keep-alive\");\n+\t\t\tthis.keepAliveThread.start();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void stop() {\n+\t\tif (this.running.compareAndSet(true, false)) {\n+\t\t\tthis.keepAliveThread.interrupt();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRunning() {\n+\t\treturn this.running.get();\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/management/package-info.java b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/management/package-info.java\nindex 694a5401751..d92f03293e5 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/management/package-info.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/management/package-info.java\n@@ -1,4 +1,6 @@\n /**\n  * Provides classes related to endpoint management.\n  */\n+@org.springframework.lang.NonNullApi\n+@org.springframework.lang.NonNullFields\n package org.springframework.integration.endpoint.management;\n\ndiff --git a/spring-integration-core/src/main/resources/META-INF/spring.integration.default.properties b/spring-integration-core/src/main/resources/META-INF/spring.integration.default.properties\nindex 573f1916e63..7534067d513 100644\n--- a/spring-integration-core/src/main/resources/META-INF/spring.integration.default.properties\n+++ b/spring-integration-core/src/main/resources/META-INF/spring.integration.default.properties\n@@ -9,3 +9,4 @@ spring.integration.messagingTemplate.throwExceptionOnLateReply=false\n spring.integration.readOnly.headers=\n spring.integration.endpoints.noAutoStartup=\n spring.integration.endpoints.defaultTimeout=30000\n+spring.integration.keepAlive=true\n\ndiff --git a/src/reference/antora/modules/ROOT/nav.adoc b/src/reference/antora/modules/ROOT/nav.adoc\nindex 61e2b1e3279..16fde26c3d6 100644\n--- a/src/reference/antora/modules/ROOT/nav.adoc\n+++ b/src/reference/antora/modules/ROOT/nav.adoc\n@@ -99,6 +99,7 @@\n ** xref:shutdown.adoc[]\n ** xref:graph.adoc[]\n ** xref:integration-graph-controller.adoc[]\n+** xref:keep-alive.adoc[]\n * xref:reactive-streams.adoc[]\n * xref:native-aot.adoc[]\n * xref:endpoint-summary.adoc[]\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/configuration/global-properties.adoc b/src/reference/antora/modules/ROOT/pages/configuration/global-properties.adoc\nindex e631b390f2b..adb62534efb 100644\n--- a/src/reference/antora/modules/ROOT/pages/configuration/global-properties.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/configuration/global-properties.adoc\n@@ -19,6 +19,7 @@ spring.integration.endpoints.noAutoStartup= <7>\n spring.integration.channels.error.requireSubscribers=true <8>\n spring.integration.channels.error.ignoreFailures=true <9>\n spring.integration.endpoints.defaultTimeout=30000 <10>\n+spring.integration.keepAlive=true <11>\n ----\n \n <1> When true, `input-channel` instances are automatically declared as `DirectChannel` instances when not explicitly found in the application context.\n@@ -57,6 +58,11 @@ Since version 5.5.\n Default value is 30 seconds to avoid indefinite blocking.\n Can be configured to a negative value to restore infinite blocking behavior in endpoints.\n Since version 6.2.\n+\n+<11> Whether to start the `IntegrationKeepAlive`.\n+Default is `true`, however depends on the beans in the application context.\n+See xref:keep-alive.adoc[Keep Alive] for more information.\n+Since version 6.4.\n ====\n \n These properties can be overridden by adding a `/META-INF/spring.integration.properties` file to the classpath or an `IntegrationContextUtils.INTEGRATION_GLOBAL_PROPERTIES_BEAN_NAME` bean for the `org.springframework.integration.context.IntegrationProperties` instance.\n@@ -77,5 +83,6 @@ spring.integration.channels.maxBroadcastSubscribers=0x7fffffff\n spring.integration.readOnly.headers=\n spring.integration.messagingTemplate.throwExceptionOnLateReply=true\n spring.integration.endpoints.defaultTimeout=30000\n+spring.integration.keepAlive=false\n ----\n \n\ndiff --git a/src/reference/antora/modules/ROOT/pages/keep-alive.adoc b/src/reference/antora/modules/ROOT/pages/keep-alive.adoc\nnew file mode 100644\nindex 00000000000..623a47b5c1a\n--- /dev/null\n+++ b/src/reference/antora/modules/ROOT/pages/keep-alive.adoc\n@@ -0,0 +1,17 @@\n+[[keep-alive]]\n+= Integration Keep Alive\n+\n+Starting with version 6.4, Spring Integration provides an `IntegrationKeepAlive` infrastructure bean.\n+It manages an `spring-integration-keep-alive` non-daemon forever thread which keeps an application running.\n+In some use-cases, e.g. `WebSocketInboundChannelAdapter` based on the `StandardWebSocketClient` does not use non-daemon thread for session, therefore an application may exit prematurely.\n+Or an application logic may have only service activators or outbound channel adapters which rely on some other interaction, but not loops from executors like the one from Web server.\n+Or all the threads in the application are virtual.\n+\n+The `IntegrationKeepAlive` is started automatically only if `TaskScheduler` is configured for non-daemon threads and there is no `AbstractPollingEndpoint` beans in the application context.\n+In case of the `TaskScheduler` bean configured for daemon or virtual threads, the `IntegrationKeepAlive` is started regardless of the presence for `AbstractPollingEndpoint` beans.\n+\n+This component can be disabled by the `spring.integration.keepAlive` global property.\n+See xref:configuration/global-properties.adoc[Global Properties] for more information.\n+The `IntegrationKeepAlive` can be injected in some service and stopped manually if there is no need to keep an application alive or such a status is managed somewhere else.\n+\n+See also Spring Boot https://docs.spring.io/spring-boot/reference/features/spring-application.html#features.spring-application.virtual-threads[Virtual Threads] documentation for a `spring.main.keep-alive` property.\n\\ No newline at end of file\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/whats-new.adoc b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\nindex b5e22303c8c..7f1b9d2d81c 100644\n--- a/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n@@ -27,6 +27,10 @@ The SpEL evaluation infrastructure now supports configuration for `IndexAccessor\n Also, an out-of-the-box `JsonIndexAccessor` is provided.\n See xref:spel.adoc[SpEL Support] for more information.\n \n+The `IntegrationKeepAlive` component has been introduced.\n+See xref:keep-alive.adoc[Integration Keep Alive] for more information.\n+\n+\n [[x6.4-general]]\n === General Changes\n \n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/context/IntegrationContextTests.java b/spring-integration-core/src/test/java/org/springframework/integration/context/IntegrationContextTests.java\nindex 46aab1d3446..74ea143e26b 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/context/IntegrationContextTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/context/IntegrationContextTests.java\n@@ -21,6 +21,7 @@\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.integration.endpoint.AbstractEndpoint;\n+import org.springframework.integration.endpoint.management.IntegrationKeepAlive;\n import org.springframework.integration.test.util.TestUtils;\n import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;\n import org.springframework.test.annotation.DirtiesContext;\n@@ -52,6 +53,9 @@ public class IntegrationContextTests {\n \t@Autowired\n \tprivate ThreadPoolTaskScheduler taskScheduler;\n \n+\t@Autowired\n+\tprivate IntegrationKeepAlive integrationKeepAlive;\n+\n \t@Test\n \tpublic void testIntegrationContextComponents() {\n \t\tassertThat(this.integrationProperties.isMessagingTemplateThrowExceptionOnLateReply()).isTrue();\n@@ -62,6 +66,7 @@ public void testIntegrationContextComponents() {\n \t\tassertThat(this.serviceActivator.isRunning()).isFalse();\n \t\tassertThat(this.serviceActivatorExplicit.isAutoStartup()).isTrue();\n \t\tassertThat(this.serviceActivatorExplicit.isRunning()).isTrue();\n+\t\tassertThat(this.integrationKeepAlive.isRunning()).isTrue();\n \t}\n \n }\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/endpoint/IntegrationKeepAliveTests.java b/spring-integration-core/src/test/java/org/springframework/integration/endpoint/IntegrationKeepAliveTests.java\nnew file mode 100644\nindex 00000000000..f6b19c04385\n--- /dev/null\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/endpoint/IntegrationKeepAliveTests.java\n@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.endpoint;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.integration.config.EnableIntegration;\n+import org.springframework.integration.context.IntegrationContextUtils;\n+import org.springframework.integration.context.IntegrationProperties;\n+import org.springframework.integration.endpoint.management.IntegrationKeepAlive;\n+import org.springframework.integration.test.util.TestUtils;\n+import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * @author Artem Bilan\n+ *\n+ * @since 6.4\n+ */\n+@SpringJUnitConfig\n+@DirtiesContext\n+public class IntegrationKeepAliveTests {\n+\n+\t@Test\n+\tvoid keepAliveIsActive(@Autowired IntegrationKeepAlive integrationKeepAlive) {\n+\t\tassertThat(integrationKeepAlive.isRunning()).isTrue();\n+\t\tThread keepAliveThread = TestUtils.getPropertyValue(integrationKeepAlive, \"keepAliveThread\", Thread.class);\n+\t\tassertThat(keepAliveThread.isAlive()).isTrue();\n+\t\tintegrationKeepAlive.stop();\n+\t\tawait().untilAsserted(() -> assertThat(keepAliveThread.isAlive()).isFalse());\n+\t\tintegrationKeepAlive.start();\n+\t}\n+\n+\t@Configuration\n+\t@EnableIntegration\n+\tpublic static class TestConfiguration {\n+\n+\t}\n+\n+\t@Nested\n+\t@ContextConfiguration(classes = WithPollingEndpoint.WithPollingEndpointConfig.class)\n+\tclass WithPollingEndpoint {\n+\n+\t\t@Test\n+\t\tvoid keepAliveNotActive(@Autowired IntegrationKeepAlive integrationKeepAlive) {\n+\t\t\tassertThat(integrationKeepAlive.isRunning()).isFalse();\n+\t\t}\n+\n+\t\t@Configuration\n+\t\tstatic class WithPollingEndpointConfig {\n+\n+\t\t\t@Bean\n+\t\t\tAbstractPollingEndpoint mockPollingEndpoint() {\n+\t\t\t\treturn mock();\n+\t\t\t}\n+\n+\t\t}\n+\n+\t}\n+\n+\t@Nested\n+\t@ContextConfiguration(classes = WithDaemonTaskScheduler.WithDaemonTaskSchedulerConfig.class)\n+\tclass WithDaemonTaskScheduler {\n+\n+\t\t@Test\n+\t\tvoid keepAliveActive(@Autowired IntegrationKeepAlive integrationKeepAlive) {\n+\t\t\tassertThat(integrationKeepAlive.isRunning()).isTrue();\n+\t\t}\n+\n+\t\t@Configuration\n+\t\tstatic class WithDaemonTaskSchedulerConfig {\n+\n+\t\t\t@Bean\n+\t\t\tAbstractPollingEndpoint mockPollingEndpoint() {\n+\t\t\t\treturn mock();\n+\t\t\t}\n+\n+\t\t\t@Bean\n+\t\t\tString daemonSetter(ThreadPoolTaskScheduler taskScheduler) {\n+\t\t\t\ttaskScheduler.setDaemon(true);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t}\n+\n+\t@Nested\n+\t@ContextConfiguration(classes = WithGlobalProperty.WithGlobalPropertyConfig.class)\n+\tclass WithGlobalProperty {\n+\n+\t\t@Test\n+\t\tvoid keepAliveNotActive(@Autowired IntegrationKeepAlive integrationKeepAlive) {\n+\t\t\tassertThat(integrationKeepAlive.isRunning()).isFalse();\n+\t\t}\n+\n+\t\t@Configuration\n+\t\tstatic class WithGlobalPropertyConfig {\n+\n+\t\t\t@Bean(IntegrationContextUtils.INTEGRATION_GLOBAL_PROPERTIES_BEAN_NAME)\n+\t\t\tstatic IntegrationProperties integrationProperties() {\n+\t\t\t\tIntegrationProperties integrationProperties = new IntegrationProperties();\n+\t\t\t\tintegrationProperties.setKeepAlive(false);\n+\t\t\t\treturn integrationProperties;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t}\n+\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9451",
    "pr_id": 9451,
    "issue_id": 9436,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Provide first-class configuration support for SpEL `IndexAccessor`\n## Overview\r\n\r\nAs mentioned in https://github.com/spring-projects/spring-integration/pull/9429#issuecomment-2322883447, Spring Integration currently provides first-class support for registering a `PropertyAccessor` but not yet for an `IndexAccessor` (new SpEL API introduced in Spring Framework 6.2).\r\n\r\nFor example, one can currently register a `PropertyAccessor` for use with Spring Integration via the following.\r\n\r\n1. `IntegrationEvaluationContextFactoryBean` and `IntegrationSimpleEvaluationContextFactoryBean`\r\n2. the `<spel-property-accessors>` XML namespace element\r\n3. a `SpelPropertyAccessorRegistrar` bean in the `ApplicationContext`.\r\n\r\nHowever, there is currently no easy way for Spring Integration users to register an `IndexAccessor` (either a custom one of their own or the `JsonIndexAccessor` proposed in #9429).\r\n\r\nThus, the Spring Integration team should decide if it wants to provide similar configuration support for registering an `IndexAccessor`:\r\n\r\n- via `AbstractEvaluationContextFactoryBean` and its subclasses\r\n- via an XML namespace element\r\n- via an auto-detected bean in the `ApplicationContext` -- `SpelPropertyAccessorRegistrar` or a separate `SpelIndexAccessorRegistrar`\r\n\r\n## Side Note\r\n\r\n`IntegrationSimpleEvaluationContextFactoryBean` is not currently documented in the reference manual. If that warrants documentation, a new issue can be created to address that.\r\n\r\n## Related Issues\r\n\r\n- #9383\r\n- #9429\r\n",
    "issue_word_count": 182,
    "test_files_count": 4,
    "non_test_files_count": 8,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/config/AbstractEvaluationContextFactoryBean.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/IntegrationEvaluationContextFactoryBean.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/IntegrationSimpleEvaluationContextFactoryBean.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/xml/SpelPropertyAccessorsParser.java",
      "spring-integration-core/src/main/java/org/springframework/integration/expression/SpelPropertyAccessorRegistrar.java",
      "spring-integration-core/src/main/resources/org/springframework/integration/config/spring-integration.xsd",
      "spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/transformer/SpelTransformerIntegrationTests-context.xml",
      "spring-integration-core/src/test/java/org/springframework/integration/transformer/SpelTransformerIntegrationTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/transformer/property-accessor-import-context.xml",
      "src/reference/antora/modules/ROOT/pages/spel.adoc",
      "src/reference/antora/modules/ROOT/pages/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/transformer/SpelTransformerIntegrationTests-context.xml",
      "spring-integration-core/src/test/java/org/springframework/integration/transformer/SpelTransformerIntegrationTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/transformer/property-accessor-import-context.xml"
    ],
    "base_commit": "775bfd6168925c8fee94a22deec11ca84926550e",
    "head_commit": "b7e753d07cc6c9eaef391d8f98e3d5f47cea41d3",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9451",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9451",
    "dockerfile": "",
    "pr_merged_at": "2024-09-12T19:38:58.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractEvaluationContextFactoryBean.java b/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractEvaluationContextFactoryBean.java\nindex ff45ef133b7..af9e9cf194e 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractEvaluationContextFactoryBean.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractEvaluationContextFactoryBean.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018-2019 the original author or authors.\n+ * Copyright 2018-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -28,11 +28,13 @@\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.ApplicationContextAware;\n import org.springframework.core.convert.ConversionService;\n+import org.springframework.expression.IndexAccessor;\n import org.springframework.expression.PropertyAccessor;\n import org.springframework.expression.TypeConverter;\n import org.springframework.expression.spel.support.StandardTypeConverter;\n import org.springframework.integration.expression.SpelPropertyAccessorRegistrar;\n import org.springframework.integration.support.utils.IntegrationUtils;\n+import org.springframework.lang.Nullable;\n import org.springframework.util.Assert;\n \n /**\n@@ -45,14 +47,19 @@\n  */\n public abstract class AbstractEvaluationContextFactoryBean implements ApplicationContextAware, InitializingBean {\n \n-\tprivate Map<String, PropertyAccessor> propertyAccessors = new LinkedHashMap<String, PropertyAccessor>();\n+\tprivate Map<String, PropertyAccessor> propertyAccessors = new LinkedHashMap<>();\n \n-\tprivate Map<String, Method> functions = new LinkedHashMap<String, Method>();\n+\tprivate Map<String, IndexAccessor> indexAccessors = new LinkedHashMap<>();\n+\n+\tprivate Map<String, Method> functions = new LinkedHashMap<>();\n \n \tprivate TypeConverter typeConverter = new StandardTypeConverter();\n \n \tprivate ApplicationContext applicationContext;\n \n+\t@Nullable\n+\tprivate SpelPropertyAccessorRegistrar propertyAccessorRegistrar;\n+\n \tprivate boolean initialized;\n \n \tprotected TypeConverter getTypeConverter() {\n@@ -68,22 +75,45 @@ public void setApplicationContext(ApplicationContext applicationContext) throws\n \t\tthis.applicationContext = applicationContext;\n \t}\n \n-\tpublic void setPropertyAccessors(Map<String, PropertyAccessor> accessors) {\n+\tpublic void setPropertyAccessors(Map<String, PropertyAccessor> propertyAccessors) {\n \t\tAssert.isTrue(!this.initialized, \"'propertyAccessors' can't be changed after initialization.\");\n-\t\tAssert.notNull(accessors, \"'accessors' must not be null.\");\n-\t\tAssert.noNullElements(accessors.values().toArray(), \"'accessors' cannot have null values.\");\n-\t\tthis.propertyAccessors = new LinkedHashMap<String, PropertyAccessor>(accessors);\n+\t\tAssert.notNull(propertyAccessors, \"'propertyAccessors' must not be null.\");\n+\t\tAssert.noNullElements(propertyAccessors.values().toArray(), \"'propertyAccessors' cannot have null values.\");\n+\t\tthis.propertyAccessors = new LinkedHashMap<>(propertyAccessors);\n \t}\n \n \tpublic Map<String, PropertyAccessor> getPropertyAccessors() {\n \t\treturn this.propertyAccessors;\n \t}\n \n+\t/**\n+\t * Set a map of {@link IndexAccessor}s to use in the target {@link org.springframework.expression.EvaluationContext}\n+\t * @param indexAccessors the map of {@link IndexAccessor}s to use\n+\t * @since 6.4\n+\t * @see org.springframework.expression.EvaluationContext#getIndexAccessors()\n+\t */\n+\tpublic void setIndexAccessors(Map<String, IndexAccessor> indexAccessors) {\n+\t\tAssert.isTrue(!this.initialized, \"'indexAccessors' can't be changed after initialization.\");\n+\t\tAssert.notNull(indexAccessors, \"'indexAccessors' must not be null.\");\n+\t\tAssert.noNullElements(indexAccessors.values().toArray(), \"'indexAccessors' cannot have null values.\");\n+\t\tthis.indexAccessors = new LinkedHashMap<>(indexAccessors);\n+\t}\n+\n+\t/**\n+\t * Return the map of {@link IndexAccessor}s to use in the target {@link org.springframework.expression.EvaluationContext}\n+\t * @return the map of {@link IndexAccessor}s to use\n+\t * @since 6.4\n+\t * @see org.springframework.expression.EvaluationContext#getIndexAccessors()\n+\t */\n+\tpublic Map<String, IndexAccessor> getIndexAccessors() {\n+\t\treturn this.indexAccessors;\n+\t}\n+\n \tpublic void setFunctions(Map<String, Method> functionsArg) {\n \t\tAssert.isTrue(!this.initialized, \"'functions' can't be changed after initialization.\");\n \t\tAssert.notNull(functionsArg, \"'functions' must not be null.\");\n \t\tAssert.noNullElements(functionsArg.values().toArray(), \"'functions' cannot have null values.\");\n-\t\tthis.functions = new LinkedHashMap<String, Method>(functionsArg);\n+\t\tthis.functions = new LinkedHashMap<>(functionsArg);\n \t}\n \n \tpublic Map<String, Method> getFunctions() {\n@@ -94,7 +124,14 @@ protected void initialize(String beanName) {\n \t\tif (this.applicationContext != null) {\n \t\t\tconversionService();\n \t\t\tfunctions();\n+\t\t\ttry {\n+\t\t\t\tthis.propertyAccessorRegistrar = this.applicationContext.getBean(SpelPropertyAccessorRegistrar.class);\n+\t\t\t}\n+\t\t\tcatch (@SuppressWarnings(\"unused\") NoSuchBeanDefinitionException e) {\n+\t\t\t\t// There is no 'SpelPropertyAccessorRegistrar' bean in the application context.\n+\t\t\t}\n \t\t\tpropertyAccessors();\n+\t\t\tindexAccessors();\n \t\t\tprocessParentIfPresent(beanName);\n \t\t}\n \t\tthis.initialized = true;\n@@ -108,28 +145,43 @@ private void conversionService() {\n \t}\n \n \tprivate void functions() {\n-\t\tMap<String, SpelFunctionFactoryBean> functionFactoryBeanMap = BeanFactoryUtils\n-\t\t\t\t.beansOfTypeIncludingAncestors(this.applicationContext, SpelFunctionFactoryBean.class);\n-\t\tfor (SpelFunctionFactoryBean spelFunctionFactoryBean : functionFactoryBeanMap.values()) {\n-\t\t\tif (!getFunctions().containsKey(spelFunctionFactoryBean.getFunctionName())) {\n-\t\t\t\tgetFunctions().put(spelFunctionFactoryBean.getFunctionName(), spelFunctionFactoryBean.getObject());\n+\t\tMap<String, SpelFunctionFactoryBean> spelFunctions =\n+\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(this.applicationContext, SpelFunctionFactoryBean.class);\n+\t\tfor (SpelFunctionFactoryBean spelFunctionFactoryBean : spelFunctions.values()) {\n+\t\t\tString functionName = spelFunctionFactoryBean.getFunctionName();\n+\t\t\tif (!this.functions.containsKey(functionName)) {\n+\t\t\t\tthis.functions.put(functionName, spelFunctionFactoryBean.getObject());\n \t\t\t}\n \t\t}\n \t}\n \n \tprivate void propertyAccessors() {\n-\t\ttry {\n-\t\t\tSpelPropertyAccessorRegistrar propertyAccessorRegistrar =\n-\t\t\t\t\tthis.applicationContext.getBean(SpelPropertyAccessorRegistrar.class);\n-\t\t\tfor (Entry<String, PropertyAccessor> entry : propertyAccessorRegistrar.getPropertyAccessors()\n-\t\t\t\t\t.entrySet()) {\n-\t\t\t\tif (!getPropertyAccessors().containsKey(entry.getKey())) {\n-\t\t\t\t\tgetPropertyAccessors().put(entry.getKey(), entry.getValue());\n-\t\t\t\t}\n+\t\tif (this.propertyAccessorRegistrar != null) {\n+\t\t\tpropertyAccessors(this.propertyAccessorRegistrar.getPropertyAccessors());\n+\t\t}\n+\t}\n+\n+\tprivate void propertyAccessors(Map<String, PropertyAccessor> propertyAccessors) {\n+\t\tfor (Entry<String, PropertyAccessor> entry : propertyAccessors.entrySet()) {\n+\t\t\tString key = entry.getKey();\n+\t\t\tif (!this.propertyAccessors.containsKey(key)) {\n+\t\t\t\tthis.propertyAccessors.put(key, entry.getValue());\n \t\t\t}\n \t\t}\n-\t\tcatch (@SuppressWarnings(\"unused\") NoSuchBeanDefinitionException e) {\n-\t\t\t// There is no 'SpelPropertyAccessorRegistrar' bean in the application context.\n+\t}\n+\n+\tprivate void indexAccessors() {\n+\t\tif (this.propertyAccessorRegistrar != null) {\n+\t\t\tindexAccessors(this.propertyAccessorRegistrar.getIndexAccessors());\n+\t\t}\n+\t}\n+\n+\tprivate void indexAccessors(Map<String, IndexAccessor> indexAccessors) {\n+\t\tfor (Entry<String, IndexAccessor> entry : indexAccessors.entrySet()) {\n+\t\t\tString key = entry.getKey();\n+\t\t\tif (!this.indexAccessors.containsKey(key)) {\n+\t\t\t\tthis.indexAccessors.put(key, entry.getValue());\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -138,16 +190,12 @@ private void processParentIfPresent(String beanName) {\n \n \t\tif (parent != null && parent.containsBean(beanName)) {\n \t\t\tAbstractEvaluationContextFactoryBean parentFactoryBean = parent.getBean(\"&\" + beanName, getClass());\n-\n-\t\t\tfor (Entry<String, PropertyAccessor> entry : parentFactoryBean.getPropertyAccessors().entrySet()) {\n-\t\t\t\tif (!getPropertyAccessors().containsKey(entry.getKey())) {\n-\t\t\t\t\tgetPropertyAccessors().put(entry.getKey(), entry.getValue());\n-\t\t\t\t}\n-\t\t\t}\n-\n+\t\t\tpropertyAccessors(parentFactoryBean.getPropertyAccessors());\n+\t\t\tindexAccessors(parentFactoryBean.getIndexAccessors());\n \t\t\tfor (Entry<String, Method> entry : parentFactoryBean.getFunctions().entrySet()) {\n-\t\t\t\tif (!getFunctions().containsKey(entry.getKey())) {\n-\t\t\t\t\tgetFunctions().put(entry.getKey(), entry.getValue());\n+\t\t\t\tString key = entry.getKey();\n+\t\t\t\tif (!this.functions.containsKey(key)) {\n+\t\t\t\t\tthis.functions.put(key, entry.getValue());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/IntegrationEvaluationContextFactoryBean.java b/spring-integration-core/src/main/java/org/springframework/integration/config/IntegrationEvaluationContextFactoryBean.java\nindex 4b1816c0ecf..8101a522c55 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/IntegrationEvaluationContextFactoryBean.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/IntegrationEvaluationContextFactoryBean.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2019 the original author or authors.\n+ * Copyright 2013-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,6 +23,7 @@\n import org.springframework.context.expression.BeanFactoryResolver;\n import org.springframework.context.expression.MapAccessor;\n import org.springframework.expression.BeanResolver;\n+import org.springframework.expression.IndexAccessor;\n import org.springframework.expression.PropertyAccessor;\n import org.springframework.expression.TypeLocator;\n import org.springframework.expression.spel.support.StandardEvaluationContext;\n@@ -102,6 +103,10 @@ public StandardEvaluationContext getObject() {\n \n \t\tevaluationContext.addPropertyAccessor(new MapAccessor());\n \n+\t\tfor (IndexAccessor indexAccessor : getIndexAccessors().values()) {\n+\t\t\tevaluationContext.addIndexAccessor(indexAccessor);\n+\t\t}\n+\n \t\tfor (Entry<String, Method> functionEntry : getFunctions().entrySet()) {\n \t\t\tevaluationContext.registerFunction(functionEntry.getKey(), functionEntry.getValue());\n \t\t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/IntegrationSimpleEvaluationContextFactoryBean.java b/spring-integration-core/src/main/java/org/springframework/integration/config/IntegrationSimpleEvaluationContextFactoryBean.java\nindex 24f848d51de..051091d6d97 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/IntegrationSimpleEvaluationContextFactoryBean.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/IntegrationSimpleEvaluationContextFactoryBean.java\n@@ -22,6 +22,7 @@\n \n import org.springframework.beans.factory.FactoryBean;\n import org.springframework.context.expression.MapAccessor;\n+import org.springframework.expression.IndexAccessor;\n import org.springframework.expression.PropertyAccessor;\n import org.springframework.expression.spel.support.DataBindingPropertyAccessor;\n import org.springframework.expression.spel.support.SimpleEvaluationContext;\n@@ -80,6 +81,7 @@ public SimpleEvaluationContext getObject() {\n \t\taccessorArray[accessors.size() + 1] = DataBindingPropertyAccessor.forReadOnlyAccess();\n \t\tSimpleEvaluationContext evaluationContext =\n \t\t\t\tSimpleEvaluationContext.forPropertyAccessors(accessorArray)\n+\t\t\t\t\t\t.withIndexAccessors(getIndexAccessors().values().toArray(new IndexAccessor[0]))\n \t\t\t\t\t\t.withTypeConverter(getTypeConverter())\n \t\t\t\t\t\t.withInstanceMethods()\n \t\t\t\t\t\t.withAssignmentDisabled()\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/xml/SpelPropertyAccessorsParser.java b/spring-integration-core/src/main/java/org/springframework/integration/config/xml/SpelPropertyAccessorsParser.java\nindex 0e8c9cdf72e..5116444d5b5 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/xml/SpelPropertyAccessorsParser.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/xml/SpelPropertyAccessorsParser.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2023 the original author or authors.\n+ * Copyright 2013-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,13 +16,10 @@\n \n package org.springframework.integration.config.xml;\n \n+import java.util.List;\n import java.util.Map;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantLock;\n \n import org.w3c.dom.Element;\n-import org.w3c.dom.Node;\n-import org.w3c.dom.NodeList;\n \n import org.springframework.beans.factory.config.BeanDefinition;\n import org.springframework.beans.factory.config.BeanReference;\n@@ -33,7 +30,9 @@\n import org.springframework.beans.factory.xml.ParserContext;\n import org.springframework.integration.context.IntegrationContextUtils;\n import org.springframework.integration.expression.SpelPropertyAccessorRegistrar;\n+import org.springframework.util.CollectionUtils;\n import org.springframework.util.StringUtils;\n+import org.springframework.util.xml.DomUtils;\n \n /**\n  * Parser for the &lt;spel-property-accessors&gt; element.\n@@ -46,69 +45,61 @@\n  */\n public class SpelPropertyAccessorsParser implements BeanDefinitionParser {\n \n-\tprivate final Lock lock = new ReentrantLock();\n-\n-\tprivate final Map<String, Object> propertyAccessors = new ManagedMap<String, Object>();\n-\n \t@Override\n \tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n-\t\tinitializeSpelPropertyAccessorRegistrarIfNecessary(parserContext);\n-\n-\t\tBeanDefinitionParserDelegate delegate = parserContext.getDelegate();\n+\t\tMap<String, Object> propertyAccessors = new ManagedMap<>();\n+\t\tMap<String, Object> indexAccessors = new ManagedMap<>();\n+\t\tparseTargetedAccessors(element, parserContext, propertyAccessors);\n \n-\t\tNodeList children = element.getChildNodes();\n-\n-\t\tfor (int i = 0; i < children.getLength(); i++) {\n-\t\t\tNode node = children.item(i);\n-\t\t\tString propertyAccessorName;\n-\t\t\tObject propertyAccessor;\n-\t\t\tif (node instanceof Element &&\n-\t\t\t\t\t!delegate.nodeNameEquals(node, BeanDefinitionParserDelegate.DESCRIPTION_ELEMENT)) {\n-\t\t\t\tElement ele = (Element) node;\n+\t\tElement indexAccessorsElement = DomUtils.getChildElementByTagName(element, \"index-accessors\");\n+\t\tif (indexAccessorsElement != null) {\n+\t\t\tparseTargetedAccessors(indexAccessorsElement, parserContext, indexAccessors);\n+\t\t}\n \n-\t\t\t\tif (delegate.nodeNameEquals(ele, BeanDefinitionParserDelegate.BEAN_ELEMENT)) {\n-\t\t\t\t\tpropertyAccessorName = ele.getAttribute(BeanDefinitionParserDelegate.ID_ATTRIBUTE);\n-\t\t\t\t\tif (!StringUtils.hasText(propertyAccessorName)) {\n-\t\t\t\t\t\tparserContext.getReaderContext()\n-\t\t\t\t\t\t\t\t.error(\"The '<bean>' 'id' attribute is required within 'spel-property-accessors'.\", ele);\n-\t\t\t\t\t\treturn null;\n-\t\t\t\t\t}\n-\t\t\t\t\tpropertyAccessor = delegate.parseBeanDefinitionElement(ele);\n-\t\t\t\t}\n-\t\t\t\telse if (delegate.nodeNameEquals(ele, BeanDefinitionParserDelegate.REF_ELEMENT)) {\n-\t\t\t\t\tBeanReference propertyAccessorRef = (BeanReference) delegate.parsePropertySubElement(ele, null);\n-\t\t\t\t\tpropertyAccessorName = propertyAccessorRef.getBeanName(); // NOSONAR not null\n-\t\t\t\t\tpropertyAccessor = propertyAccessorRef;\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tparserContext.getReaderContext().error(\"Only '<bean>' and '<ref>' elements are allowed.\", element);\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n+\t\tBeanDefinitionBuilder registrarBuilder =\n+\t\t\t\tBeanDefinitionBuilder.genericBeanDefinition(SpelPropertyAccessorRegistrar.class)\n+\t\t\t\t\t\t.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n+\t\tif (!CollectionUtils.isEmpty(propertyAccessors)) {\n+\t\t\tregistrarBuilder.addConstructorArgValue(propertyAccessors);\n+\t\t}\n \n-\t\t\t\tthis.propertyAccessors.put(propertyAccessorName, propertyAccessor);\n-\t\t\t}\n+\t\tif (!CollectionUtils.isEmpty(indexAccessors)) {\n+\t\t\tregistrarBuilder.addPropertyValue(\"indexAccessors\", indexAccessors);\n \t\t}\n \n+\t\tparserContext.getRegistry()\n+\t\t\t\t.registerBeanDefinition(IntegrationContextUtils.SPEL_PROPERTY_ACCESSOR_REGISTRAR_BEAN_NAME,\n+\t\t\t\t\t\tregistrarBuilder.getBeanDefinition());\n+\n \t\treturn null;\n \t}\n \n-\tprivate void initializeSpelPropertyAccessorRegistrarIfNecessary(ParserContext parserContext) {\n-\t\tthis.lock.lock();\n-\t\ttry {\n-\t\t\tif (!parserContext.getRegistry()\n-\t\t\t\t\t.containsBeanDefinition(IntegrationContextUtils.SPEL_PROPERTY_ACCESSOR_REGISTRAR_BEAN_NAME)) {\n+\tprivate static void parseTargetedAccessors(Element accessorsElement, ParserContext parserContext,\n+\t\t\tMap<String, Object> accessorsMap) {\n \n-\t\t\t\tBeanDefinitionBuilder registrarBuilder = BeanDefinitionBuilder\n-\t\t\t\t\t\t.genericBeanDefinition(SpelPropertyAccessorRegistrar.class)\n-\t\t\t\t\t\t.setRole(BeanDefinition.ROLE_INFRASTRUCTURE)\n-\t\t\t\t\t\t.addConstructorArgValue(this.propertyAccessors);\n-\t\t\t\tparserContext.getRegistry()\n-\t\t\t\t\t\t.registerBeanDefinition(IntegrationContextUtils.SPEL_PROPERTY_ACCESSOR_REGISTRAR_BEAN_NAME,\n-\t\t\t\t\t\t\t\tregistrarBuilder.getBeanDefinition());\n+\t\tBeanDefinitionParserDelegate delegate = parserContext.getDelegate();\n+\t\tList<Element> accessorElements = DomUtils.getChildElementsByTagName(accessorsElement,\n+\t\t\t\tBeanDefinitionParserDelegate.BEAN_ELEMENT, BeanDefinitionParserDelegate.REF_ELEMENT);\n+\t\tfor (Element accessorElement : accessorElements) {\n+\t\t\tString accessorName;\n+\t\t\tObject accessor;\n+\t\t\tif (delegate.nodeNameEquals(accessorElement, BeanDefinitionParserDelegate.BEAN_ELEMENT)) {\n+\t\t\t\taccessorName = accessorElement.getAttribute(BeanDefinitionParserDelegate.ID_ATTRIBUTE);\n+\t\t\t\tif (!StringUtils.hasText(accessorName)) {\n+\t\t\t\t\tparserContext.getReaderContext()\n+\t\t\t\t\t\t\t.error(\"The '<bean>' 'id' attribute is required within 'spel-property-accessors'.\",\n+\t\t\t\t\t\t\t\t\taccessorElement);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\taccessor = delegate.parseBeanDefinitionElement(accessorElement);\n \t\t\t}\n-\t\t}\n-\t\tfinally {\n-\t\t\tthis.lock.unlock();\n+\t\t\telse {\n+\t\t\t\tBeanReference propertyAccessorRef =\n+\t\t\t\t\t\t(BeanReference) delegate.parsePropertySubElement(accessorElement, null);\n+\t\t\t\taccessorName = propertyAccessorRef.getBeanName(); // NOSONAR not null\n+\t\t\t\taccessor = propertyAccessorRef;\n+\t\t\t}\n+\t\t\taccessorsMap.put(accessorName, accessor);\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/expression/SpelPropertyAccessorRegistrar.java b/spring-integration-core/src/main/java/org/springframework/integration/expression/SpelPropertyAccessorRegistrar.java\nindex 5db0a43245c..a3d0dbd3283 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/expression/SpelPropertyAccessorRegistrar.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/expression/SpelPropertyAccessorRegistrar.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2017-2019 the original author or authors.\n+ * Copyright 2017-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,7 +20,9 @@\n import java.util.LinkedHashMap;\n import java.util.Map;\n \n+import org.springframework.expression.IndexAccessor;\n import org.springframework.expression.PropertyAccessor;\n+import org.springframework.expression.TargetedAccessor;\n import org.springframework.util.Assert;\n \n /**\n@@ -35,14 +37,16 @@\n  */\n public class SpelPropertyAccessorRegistrar {\n \n-\tprivate final Map<String, PropertyAccessor> propertyAccessors = new LinkedHashMap<String, PropertyAccessor>();\n+\tprivate final Map<String, PropertyAccessor> propertyAccessors = new LinkedHashMap<>();\n+\n+\tprivate final Map<String, IndexAccessor> indexAccessors = new LinkedHashMap<>();\n \n \tpublic SpelPropertyAccessorRegistrar() {\n \t}\n \n \t/**\n-\t * Create an instance with the provided property accessors. Each accessor name\n-\t * will be the class simple name.\n+\t * Create an instance with the provided {@link PropertyAccessor} instances.\n+\t * Each accessor name will be the class simple name.\n \t * @param propertyAccessors the accessors.\n \t * @since 4.3.8\n \t */\n@@ -54,7 +58,7 @@ public SpelPropertyAccessorRegistrar(PropertyAccessor... propertyAccessors) {\n \t}\n \n \t/**\n-\t * Create an instance with the provided named property accessors.\n+\t * Create an instance with the provided named {@link PropertyAccessor} instances.\n \t * @param propertyAccessors a map of name:accessor.\n \t * @since 4.3.8\n \t */\n@@ -64,7 +68,8 @@ public SpelPropertyAccessorRegistrar(Map<String, PropertyAccessor> propertyAcces\n \t}\n \n \t/**\n-\t * Return the registered accessors.\n+\t * Return the registered {@link PropertyAccessor} instances to use\n+\t * in the target {@link org.springframework.expression.EvaluationContext}.\n \t * @return the map of name:accessor.\n \t * @since 4.3.8\n \t */\n@@ -72,6 +77,26 @@ public Map<String, PropertyAccessor> getPropertyAccessors() {\n \t\treturn this.propertyAccessors;\n \t}\n \n+\t/**\n+\t * Add a map of {@link IndexAccessor} instances to use\n+\t * in the target {@link org.springframework.expression.EvaluationContext}.\n+\t * @param indexAccessors the map of name:accessor.\n+\t * @since 6.4\n+\t */\n+\tpublic void setIndexAccessors(Map<String, IndexAccessor> indexAccessors) {\n+\t\tAssert.notEmpty(indexAccessors, \"'indexAccessors' must not be empty\");\n+\t\tthis.indexAccessors.putAll(indexAccessors);\n+\t}\n+\n+\t/**\n+\t * Return the registered {@link IndexAccessor} instances.\n+\t * @return the map of name:accessor.\n+\t * @since 6.4\n+\t */\n+\tpublic Map<String, IndexAccessor> getIndexAccessors() {\n+\t\treturn this.indexAccessors;\n+\t}\n+\n \t/**\n \t * Add the provided named property accessor.\n \t * @param name the name.\n@@ -101,8 +126,37 @@ public SpelPropertyAccessorRegistrar add(PropertyAccessor... propertyAccessors)\n \t\treturn this;\n \t}\n \n-\tprivate static String obtainAccessorKey(PropertyAccessor propertyAccessor) {\n-\t\treturn Introspector.decapitalize(propertyAccessor.getClass().getSimpleName());\n+\t/**\n+\t * Add the provided named {@link IndexAccessor}.\n+\t * @param name the name.\n+\t * @param indexAccessor the accessor.\n+\t * @return this registrar.\n+\t * @since 6.4\n+\t */\n+\tpublic SpelPropertyAccessorRegistrar add(String name, IndexAccessor indexAccessor) {\n+\t\tAssert.hasText(name, \"'name' must not be empty\");\n+\t\tAssert.notNull(indexAccessor, \"'indexAccessor' must not be null\");\n+\t\tthis.indexAccessors.put(name, indexAccessor);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Add the provided {@link IndexAccessor} instances.\n+\t * Each accessor name will be the class simple name.\n+\t * @param indexAccessors the accessors.\n+\t * @return this registrar.\n+\t * @since 6.4\n+\t */\n+\tpublic SpelPropertyAccessorRegistrar add(IndexAccessor... indexAccessors) {\n+\t\tAssert.notEmpty(indexAccessors, \"'indexAccessors' must not be empty\");\n+\t\tfor (IndexAccessor indexAccessor : indexAccessors) {\n+\t\t\tthis.indexAccessors.put(obtainAccessorKey(indexAccessor), indexAccessor);\n+\t\t}\n+\t\treturn this;\n+\t}\n+\n+\tprivate static String obtainAccessorKey(TargetedAccessor targetedAccessor) {\n+\t\treturn Introspector.decapitalize(targetedAccessor.getClass().getSimpleName());\n \t}\n \n }\n\ndiff --git a/spring-integration-core/src/main/resources/org/springframework/integration/config/spring-integration.xsd b/spring-integration-core/src/main/resources/org/springframework/integration/config/spring-integration.xsd\nindex 38a89efd03a..403d1ce6d77 100644\n--- a/spring-integration-core/src/main/resources/org/springframework/integration/config/spring-integration.xsd\n+++ b/spring-integration-core/src/main/resources/org/springframework/integration/config/spring-integration.xsd\n@@ -4698,10 +4698,20 @@ The list of component name patterns you want to track (e.g.,  tracked-components\n \t\t\t</xsd:documentation>\n \t\t</xsd:annotation>\n \t\t<xsd:complexType>\n-\t\t\t<xsd:choice minOccurs=\"1\" maxOccurs=\"unbounded\">\n-\t\t\t\t<xsd:element ref=\"beans:bean\"/>\n-\t\t\t\t<xsd:element ref=\"beans:ref\"/>\n-\t\t\t</xsd:choice>\n+\t\t\t<xsd:sequence>\n+\t\t\t\t<xsd:element name=\"index-accessors\" minOccurs=\"0\">\n+\t\t\t\t\t<xsd:complexType>\n+\t\t\t\t\t\t<xsd:choice maxOccurs=\"unbounded\">\n+\t\t\t\t\t\t\t<xsd:element ref=\"beans:bean\"/>\n+\t\t\t\t\t\t\t<xsd:element ref=\"beans:ref\"/>\n+\t\t\t\t\t\t</xsd:choice>\n+\t\t\t\t\t</xsd:complexType>\n+\t\t\t\t</xsd:element>\n+\t\t\t\t<xsd:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n+\t\t\t\t\t<xsd:element ref=\"beans:bean\"/>\n+\t\t\t\t\t<xsd:element ref=\"beans:ref\"/>\n+\t\t\t\t</xsd:choice>\n+\t\t\t</xsd:sequence>\n \t\t</xsd:complexType>\n \t</xsd:element>\n \n\ndiff --git a/src/reference/antora/modules/ROOT/pages/spel.adoc b/src/reference/antora/modules/ROOT/pages/spel.adoc\nindex 2324d256385..2fe1ed424a1 100644\n--- a/src/reference/antora/modules/ROOT/pages/spel.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/spel.adoc\n@@ -20,6 +20,11 @@ Starting with Spring Integration 3.0, you can add additional `PropertyAccessor`\n The framework provides the (read-only) `JsonPropertyAccessor`, which you can use to access fields from a `JsonNode` or JSON in a `String`.\n You can also create your own `PropertyAccessor` if you have specific needs.\n \n+Starting with version 6.4, the `JsonIndexAccessor` implementation is provided that knows how to read indexes from JSON arrays, using Jackson's `ArrayNode` API.\n+Supports indexes supplied as an integer literal, for example, `myJsonArray[1]`.\n+Also supports negative indexes, for example, `myJsonArray[-1]` which equates to `myJsonArray[myJsonArray.length - 1]`.\n+Furthermore, `null` is returned for any index that is out of bounds (see `ArrayNode.get(int)` for details).\n+\n In addition, you can add custom functions.\n Custom functions are `static` methods declared on a class.\n Functions and property accessors are available in any SpEL expression used throughout the framework.\n@@ -45,6 +50,9 @@ The following configuration shows how to directly configure the `IntegrationEval\n </bean>\n ----\n \n+Starting with version 6.4, the `AbstractEvaluationContextFactoryBean` supports an injection of `IndexAccessor` instances.\n+See `AbstractEvaluationContextFactoryBean` method JavaDocs for more information.\n+\n For convenience, Spring Integration provides namespace support for both property accessors and functions, as described in the following sections.\n The framework automatically configures the factory bean on your behalf.\n \n@@ -122,7 +130,7 @@ Each context has its own instance of the `integrationEvaluationContext` factory\n [[built-in-spel-functions]]\n === Built-in SpEL Functions\n \n-Spring Integration provides the folloiwng  standard functions, which are registered with the application context automatically on start up:\n+Spring Integration provides the following standard functions, which are registered with the application context automatically on start up:\n \n * `#jsonPath`: Evaluates a 'jsonPath' on a specified object.\n This function invokes `JsonPathUtils.evaluate(...)`, which delegates to the https://github.com/json-path/JsonPath[Jayway JsonPath library].\n@@ -157,12 +165,16 @@ For more information regarding XML and XPath, see xref:xml.adoc[XML Support - De\n \n Spring Integration provides namespace support to let you create SpEL custom https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/expression/PropertyAccessor.html[`PropertyAccessor`] implementations.\n You can use the `<spel-property-accessors/>` component to provide a list of custom `PropertyAccessor` instances to the `EvaluationContext` used throughout the framework.\n-Instead of configuring the factory bean shown earlier, you can add one or more of these components, and the framework automatically adds the accessors to the default `integrationEvaluationContext` factory bean.\n+Instead of configuring the factory bean shown earlier, you can add this component, and the framework automatically adds the accessors to the default `integrationEvaluationContext` factory bean.\n+Also, starting with version 6.4, a dedicated `<index-accessors>` sub-element is provided to configure `IndexAccessor` beans similar way.\n The following example shows how to do so:\n \n [source,xml]\n ----\n <int:spel-property-accessors>\n+    <index-accessors>\n+        <beans:bean id=\"jsonIndex\" class=\"org.springframework.integration.json.JsonIndexAccessor\"/>\n+    </index-accessors>\n \t<bean id=\"jsonPA\" class=\"org.springframework.integration.json.JsonPropertyAccessor\"/>\n \t<ref bean=\"fooPropertyAccessor\"/>\n </int:spel-property-accessors>\n@@ -170,15 +182,17 @@ The following example shows how to do so:\n \n In the preceding example, two custom `PropertyAccessor` instances are injected into the `EvaluationContext` (in the order in which they are declared).\n \n+\n To provide `PropertyAccessor` instances by using Java Configuration, you should declare a `SpelPropertyAccessorRegistrar` bean with a name of `spelPropertyAccessorRegistrar` (dictated by the `IntegrationContextUtils.SPEL_PROPERTY_ACCESSOR_REGISTRAR_BEAN_NAME` constant).\n-The following example shows how to configure two custom `PropertyAccessor` instances with Java:\n+The following example shows how to configure two custom `PropertyAccessor` (and `IndexAccessor` starting with version 6.4) instances with Java:\n \n [source,java]\n ----\n @Bean\n public SpelPropertyAccessorRegistrar spelPropertyAccessorRegistrar() {\n     return new SpelPropertyAccessorRegistrar(new JsonPropertyAccessor())\n-                    .add(fooPropertyAccessor());\n+                    .add(fooPropertyAccessor())\n+                    .add(new JsonIndexAccessor());\n }\n ----\n \n\ndiff --git a/src/reference/antora/modules/ROOT/pages/whats-new.adoc b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\nindex d92bd74f9f1..c2868574834 100644\n--- a/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n@@ -23,6 +23,10 @@ See xref:control-bus.adoc[Control Bus] for more information.\n Also, a `ControlBusController` (together with an `@EnableControlBusController`) is introduced for managing exposed commands by the mentioned `ControlBusCommandRegistry`.\n See xref:http.adoc[HTTP Support] for more information.\n \n+The SpEL evaluation infrastructure now supports configuration for `IndexAccessor`.\n+Also, an out-of-the-box `JsonIndexAccessor` is provided.\n+See xref:spel.adoc[SpEL Support] for more information.\n+\n [[x6.4-general]]\n === General Changes\n \n@@ -74,4 +78,3 @@ See xref:sftp/session-factory.adoc[SFTP Session Factory] for more information.\n Multiple instances of `MqttPahoMessageDrivenChannelAdapter` and `Mqttv5PahoMessageDrivenChannelAdapter` can now be added at runtime using corresponding `ClientManager` through `IntegrationFlowContext`\n Also a `MqttMessageNotDeliveredEvent` event has been introduced to emit when action callback reacts to the delivery failure.\n See xref:mqtt.adoc[MQTT Support] for more information.\n-\n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.java b/spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.java\nindex 12a971b7a23..fd3dc152695 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.java\n@@ -64,7 +64,7 @@\n import org.springframework.core.log.LogAccessor;\n import org.springframework.core.serializer.support.SerializingConverter;\n import org.springframework.core.type.AnnotatedTypeMetadata;\n-import org.springframework.expression.EvaluationContext;\n+import org.springframework.expression.IndexAccessor;\n import org.springframework.expression.spel.support.ReflectivePropertyAccessor;\n import org.springframework.expression.spel.support.StandardEvaluationContext;\n import org.springframework.integration.annotation.Aggregator;\n@@ -112,6 +112,7 @@\n import org.springframework.integration.handler.advice.ExpressionEvaluatingRequestHandlerAdvice;\n import org.springframework.integration.history.MessageHistory;\n import org.springframework.integration.history.MessageHistoryConfigurer;\n+import org.springframework.integration.json.JsonIndexAccessor;\n import org.springframework.integration.json.JsonPropertyAccessor;\n import org.springframework.integration.scheduling.PollerMetadata;\n import org.springframework.integration.support.MessageBuilder;\n@@ -786,15 +787,17 @@ public void testSourcePollingChannelAdapterOutputChannelLateBinding() {\n \n \t@Test\n \tpublic void testIntegrationEvaluationContextCustomization() {\n-\t\tEvaluationContext evaluationContext = this.context.getBean(StandardEvaluationContext.class);\n-\t\tList<?> propertyAccessors = TestUtils.getPropertyValue(evaluationContext, \"propertyAccessors\", List.class);\n+\t\tStandardEvaluationContext evaluationContext = this.context.getBean(StandardEvaluationContext.class);\n+\t\tList<?> propertyAccessors = evaluationContext.getPropertyAccessors();\n \t\tassertThat(propertyAccessors.size()).isEqualTo(4);\n \t\tassertThat(propertyAccessors.get(0)).isInstanceOf(JsonPropertyAccessor.class);\n \t\tassertThat(propertyAccessors.get(1)).isInstanceOf(EnvironmentAccessor.class);\n \t\tassertThat(propertyAccessors.get(2)).isInstanceOf(MapAccessor.class);\n \t\tassertThat(propertyAccessors.get(3)).isInstanceOf(ReflectivePropertyAccessor.class);\n-\t\tMap<?, ?> variables = TestUtils.getPropertyValue(evaluationContext, \"variables\", Map.class);\n-\t\tObject testSpelFunction = variables.get(\"testSpelFunction\");\n+\t\tList<IndexAccessor> indexAccessors = evaluationContext.getIndexAccessors();\n+\t\tassertThat(indexAccessors.size()).isEqualTo(1);\n+\t\tassertThat(indexAccessors.get(0)).isInstanceOf(JsonIndexAccessor.class);\n+\t\tObject testSpelFunction = evaluationContext.lookupVariable(\"testSpelFunction\");\n \t\tassertThat(testSpelFunction).isEqualTo(ClassUtils.getStaticMethod(TestSpelFunction.class, \"bar\",\n \t\t\t\tObject.class));\n \t}\n@@ -1244,7 +1247,9 @@ public SpelFunctionFactoryBean testSpelFunction() {\n \n \t\t@Bean\n \t\tpublic SpelPropertyAccessorRegistrar spelPropertyAccessorRegistrar() {\n-\t\t\treturn new SpelPropertyAccessorRegistrar(new JsonPropertyAccessor(), new EnvironmentAccessor());\n+\t\t\treturn new SpelPropertyAccessorRegistrar(new JsonPropertyAccessor())\n+\t\t\t\t\t.add(new EnvironmentAccessor())\n+\t\t\t\t\t.add(new JsonIndexAccessor());\n \t\t}\n \n \t\t@Bean\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/transformer/SpelTransformerIntegrationTests-context.xml b/spring-integration-core/src/test/java/org/springframework/integration/transformer/SpelTransformerIntegrationTests-context.xml\nindex 97aee381f7d..a7af2dd863c 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/transformer/SpelTransformerIntegrationTests-context.xml\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/transformer/SpelTransformerIntegrationTests-context.xml\n@@ -42,10 +42,13 @@\n \t\t</beans:property>\n \t</beans:bean>\n \n-\t<beans:import resource=\"property-accessor-import-context.xml\" />\n-\n-\t<!-- import twice to verify override is ok -->\n-\t<beans:import resource=\"property-accessor-import-context.xml\" />\n+\t<spel-property-accessors>\n+\t\t<index-accessors>\n+\t\t\t<beans:bean id=\"jsonIndex\" class=\"org.springframework.integration.json.JsonIndexAccessor\"/>\n+\t\t</index-accessors>\n+\t\t<beans:bean id=\"fooAccessor1\" class=\"org.springframework.integration.transformer.SpelTransformerIntegrationTests$FooAccessor\"/>\n+\t\t<beans:ref bean=\"fooAccessor\"/>\n+\t</spel-property-accessors>\n \n \t<beans:bean id=\"fooAccessor\" class=\"org.springframework.integration.transformer.SpelTransformerIntegrationTests$FooAccessor\"/>\n \n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/transformer/SpelTransformerIntegrationTests.java b/spring-integration-core/src/test/java/org/springframework/integration/transformer/SpelTransformerIntegrationTests.java\nindex b4686493338..56a715088ba 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/transformer/SpelTransformerIntegrationTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/transformer/SpelTransformerIntegrationTests.java\n@@ -16,10 +16,7 @@\n \n package org.springframework.integration.transformer;\n \n-import java.util.Map;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Qualifier;\n@@ -33,13 +30,12 @@\n import org.springframework.integration.handler.AbstractReplyProducingMessageHandler;\n import org.springframework.integration.handler.ReplyRequiredException;\n import org.springframework.integration.support.MessageBuilder;\n-import org.springframework.integration.test.util.TestUtils;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.messaging.PollableChannel;\n import org.springframework.messaging.support.GenericMessage;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n import org.springframework.util.Assert;\n \n import static org.assertj.core.api.Assertions.assertThat;\n@@ -49,8 +45,8 @@\n  * @author Artem Bilan\n  * @author Gary Russell\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n+@DirtiesContext\n public class SpelTransformerIntegrationTests {\n \n \t@Autowired\n@@ -96,7 +92,7 @@ public void beanResolving() {\n \t@Test\n \tpublic void testInt2755ChainChildIdWithinExceptionMessage() {\n \t\ttry {\n-\t\t\tthis.transformerChainInput.send(new GenericMessage<String>(\"foo\"));\n+\t\t\tthis.transformerChainInput.send(new GenericMessage<>(\"foo\"));\n \t\t}\n \t\tcatch (ReplyRequiredException e) {\n \t\t\tassertThat(e.getMessage()).contains(\"No reply produced by handler 'transformerChain$child#0'\");\n@@ -108,20 +104,20 @@ public void testCustomAccessor() {\n \t\tQueueChannel outputChannel = new QueueChannel();\n \t\tfooHandler.setOutputChannel(outputChannel);\n \t\tFoo foo = new Foo(\"baz\");\n-\t\tfooHandler.handleMessage(new GenericMessage<Foo>(foo));\n+\t\tfooHandler.handleMessage(new GenericMessage<>(foo));\n \t\tMessage<?> reply = outputChannel.receive(0);\n \t\tassertThat(reply).isNotNull();\n \t\tassertThat(reply.getPayload() instanceof String).isTrue();\n \t\tassertThat(reply.getPayload()).isEqualTo(\"baz\");\n-\t\tassertThat(TestUtils.getPropertyValue(this.evaluationContextFactoryBean, \"propertyAccessors\", Map.class).size())\n-\t\t\t\t.isEqualTo(3);\n+\t\tassertThat(this.evaluationContextFactoryBean.getPropertyAccessors()).hasSize(3);\n+\t\tassertThat(this.evaluationContextFactoryBean.getIndexAccessors()).hasSize(1);\n \t}\n \n \t@Test\n \tpublic void testCustomFunction() {\n \t\tQueueChannel outputChannel = new QueueChannel();\n \t\tbarHandler.setOutputChannel(outputChannel);\n-\t\tbarHandler.handleMessage(new GenericMessage<String>(\"foo\"));\n+\t\tbarHandler.handleMessage(new GenericMessage<>(\"foo\"));\n \t\tMessage<?> reply = outputChannel.receive(0);\n \t\tassertThat(reply).isNotNull();\n \t\tassertThat(reply.getPayload()).isEqualTo(\"bar\");\n@@ -169,7 +165,7 @@ public Class<?>[] getSpecificTargetClasses() {\n \t\t}\n \n \t\t@Override\n-\t\tpublic boolean canRead(EvaluationContext context, Object target, String name) throws AccessException {\n+\t\tpublic boolean canRead(EvaluationContext context, Object target, String name) {\n \t\t\treturn \"bar\".equals(name);\n \t\t}\n \n@@ -180,7 +176,7 @@ public TypedValue read(EvaluationContext context, Object target, String name) th\n \t\t}\n \n \t\t@Override\n-\t\tpublic boolean canWrite(EvaluationContext context, Object target, String name) throws AccessException {\n+\t\tpublic boolean canWrite(EvaluationContext context, Object target, String name) {\n \t\t\treturn \"bar\".equals(name);\n \t\t}\n \n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/transformer/property-accessor-import-context.xml b/spring-integration-core/src/test/java/org/springframework/integration/transformer/property-accessor-import-context.xml\ndeleted file mode 100644\nindex b9b9d372a8c..00000000000\n--- a/spring-integration-core/src/test/java/org/springframework/integration/transformer/property-accessor-import-context.xml\n+++ /dev/null\n@@ -1,14 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<beans xmlns=\"http://www.springframework.org/schema/beans\"\n-\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-\txmlns:int=\"http://www.springframework.org/schema/integration\"\n-\txsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n-\t\thttp://www.springframework.org/schema/integration https://www.springframework.org/schema/integration/spring-integration.xsd\">\n-\n-\t<int:spel-property-accessors>\n-\t\t<bean id=\"fooAccessor1\" class=\"org.springframework.integration.transformer.SpelTransformerIntegrationTests$FooAccessor\"/>\n-\t\t<ref bean=\"fooAccessor\"/>\n-\t</int:spel-property-accessors>\n-\n-\n-</beans>\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9450",
    "pr_id": 9450,
    "issue_id": 9442,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Revise dynamic bean registrations with the `IntegrationFlowContext`\nMore info on StackOverflow: https://stackoverflow.com/questions/78933787/why-does-spring-not-clean-up-integrationflows-for-a-dynamic-tcp-client.\r\n\r\nApparently there is a memory leak when we remove bean definitions and the cache for their merged bean definition is not clear due to: https://github.com/spring-projects/spring-framework/issues/23336.\r\n\r\nThe problem has a big impact when random bean names are used for the `IntegrationFlowContext` interaction.\r\n\r\nNeed to look into a way to deal with a `SingletonBeanRegistry.registerSingleton()`  instead of a `BeanDefinitionRegistry.registerBeanDefinition()`.",
    "issue_word_count": 94,
    "test_files_count": 2,
    "non_test_files_count": 7,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/context/ComponentSourceAware.java",
      "spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationObjectSupport.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowAdapter.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/StandardIntegrationFlow.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/context/IntegrationFlowBeanPostProcessor.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/context/IntegrationFlowContext.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/context/StandardIntegrationFlowContext.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/gateway/GatewayDslTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/manualflow/ManualFlowTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/gateway/GatewayDslTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/manualflow/ManualFlowTests.java"
    ],
    "base_commit": "145a95b4e31354f730720f3f872a072043a9f35b",
    "head_commit": "3ef68fc8e277de14ea099e090c054cd275fd9edd",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9450",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9450",
    "dockerfile": "",
    "pr_merged_at": "2024-09-11T00:48:17.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/context/ComponentSourceAware.java b/spring-integration-core/src/main/java/org/springframework/integration/context/ComponentSourceAware.java\nnew file mode 100644\nindex 00000000000..af96a91c25f\n--- /dev/null\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/context/ComponentSourceAware.java\n@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.context;\n+\n+import org.springframework.beans.factory.BeanNameAware;\n+import org.springframework.lang.Nullable;\n+\n+/**\n+ * The contract to supply and provide useful information about\n+ * a bean definition (or singleton) source - the place where this bean is declared.\n+ * Usually populated from a respective {@link org.springframework.beans.factory.config.BeanDefinition}\n+ * or via Spring Integration infrastructure.\n+ * <p>\n+ * The information from this contract is typically used from exceptions to easy determine\n+ * the place in the application resources where this bean is declared.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 6.4\n+ *\n+ * @see org.springframework.beans.factory.config.BeanDefinition\n+ */\n+public interface ComponentSourceAware extends BeanNameAware {\n+\n+\t/**\n+\t * Set a configuration source {@code Object} for this bean definition.\n+\t * For normal {@link org.springframework.beans.factory.config.BeanDefinition} this is supplied\n+\t * by application context automatically.\n+\t * Could be useful when bean is registered at runtime via\n+\t * {@link org.springframework.beans.factory.config.SingletonBeanRegistry#registerSingleton(String, Object)}\n+\t * @param source the configuration source\n+\t */\n+\tvoid setComponentSource(Object source);\n+\n+\t/**\n+\t * Return the configuration source {@code Object} for this bean (maybe {@code null}).\n+\t * Usually (if not set explicitly) a {@link org.springframework.beans.factory.config.BeanDefinition#getSource()}.\n+\t * @return the configuration source for the bean (if any).\n+\t */\n+\t@Nullable\n+\tObject getComponentSource();\n+\n+\t/**\n+\t * Set a human-readable description of this bean.\n+\t * For normal bean definition a {@link org.springframework.beans.factory.config.BeanDefinition#getDescription()}\n+\t * is used.\n+\t * @param description the bean description\n+\t */\n+\tvoid setComponentDescription(String description);\n+\n+\t/**\n+\t * Return a human-readable description of this bean.\n+\t * Usually (if not set explicitly) a {@link org.springframework.beans.factory.config.BeanDefinition#getDescription()}.\n+\t * @return the bean description (if any).\n+\t */\n+\t@Nullable\n+\tString getComponentDescription();\n+\n+\t/**\n+\t * Return the bean name populated by the {@link BeanNameAware#setBeanName(String)}.\n+\t * @return the bean name.\n+\t */\n+\t@Nullable\n+\tString getBeanName();\n+\n+}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationObjectSupport.java b/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationObjectSupport.java\nindex f587156513e..377b958ce1c 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationObjectSupport.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationObjectSupport.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2023 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -22,7 +22,6 @@\n import org.springframework.beans.BeansException;\n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryAware;\n-import org.springframework.beans.factory.BeanNameAware;\n import org.springframework.beans.factory.InitializingBean;\n import org.springframework.beans.factory.config.BeanDefinition;\n import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n@@ -64,7 +63,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  */\n-public abstract class IntegrationObjectSupport implements BeanNameAware, NamedComponent,\n+public abstract class IntegrationObjectSupport implements ComponentSourceAware, NamedComponent,\n \t\tApplicationContextAware, BeanFactoryAware, InitializingBean, ExpressionCapable {\n \n \tprotected static final ExpressionParser EXPRESSION_PARSER = new SpelExpressionParser();\n@@ -95,6 +94,10 @@ public abstract class IntegrationObjectSupport implements BeanNameAware, NamedCo\n \n \tprivate Expression expression;\n \n+\tprivate Object beanSource;\n+\n+\tprivate String beanDescription;\n+\n \tprivate boolean initialized;\n \n \t@Override\n@@ -132,28 +135,41 @@ public String getComponentType() {\n \t\treturn null;\n \t}\n \n-\tpublic String getBeanDescription() {\n-\t\tString description = null;\n-\t\tObject source = null;\n-\n-\t\tif (this.beanFactory instanceof ConfigurableListableBeanFactory &&\n-\t\t\t\t((ConfigurableListableBeanFactory) this.beanFactory).containsBeanDefinition(this.beanName)) {\n-\t\t\tBeanDefinition beanDefinition =\n-\t\t\t\t\t((ConfigurableListableBeanFactory) this.beanFactory).getBeanDefinition(this.beanName);\n-\t\t\tdescription = beanDefinition.getResourceDescription();\n-\t\t\tsource = beanDefinition.getSource();\n-\t\t}\n+\t@Override\n+\tpublic void setComponentSource(Object source) {\n+\t\tthis.beanSource = source;\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object getComponentSource() {\n+\t\treturn this.beanSource;\n+\t}\n \n-\t\tStringBuilder sb = new StringBuilder(\"bean '\")\n-\t\t\t\t.append(this.beanName).append(\"'\");\n-\t\tif (!this.beanName.equals(getComponentName())) {\n-\t\t\tsb.append(\" for component '\").append(getComponentName()).append(\"'\");\n+\t@Override\n+\tpublic void setComponentDescription(String description) {\n+\t\tthis.beanDescription = description;\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic String getComponentDescription() {\n+\t\treturn this.beanDescription;\n+\t}\n+\n+\tpublic String getBeanDescription() {\n+\t\tStringBuilder sb =\n+\t\t\t\tnew StringBuilder(\"bean '\")\n+\t\t\t\t\t\t.append(this.beanName).append(\"'\");\n+\t\tString beanComponentName = getComponentName();\n+\t\tif (!this.beanName.equals(beanComponentName)) {\n+\t\t\tsb.append(\" for component '\").append(beanComponentName).append(\"'\");\n \t\t}\n-\t\tif (description != null) {\n-\t\t\tsb.append(\"; defined in: '\").append(description).append(\"'\");\n+\t\tif (this.beanDescription != null) {\n+\t\t\tsb.append(\"; defined in: '\").append(this.beanDescription).append(\"'\");\n \t\t}\n-\t\tif (source != null) {\n-\t\t\tsb.append(\"; from source: '\").append(source).append(\"'\");\n+\t\tif (this.beanSource != null) {\n+\t\t\tsb.append(\"; from source: '\").append(this.beanSource).append(\"'\");\n \t\t}\n \t\treturn sb.toString();\n \t}\n@@ -205,6 +221,15 @@ public final void afterPropertiesSet() {\n \t\t\t\tthis.messageBuilderFactory = new DefaultMessageBuilderFactory();\n \t\t\t}\n \t\t}\n+\t\tif (this.beanSource == null && this.beanName != null\n+\t\t\t\t&& this.beanFactory instanceof ConfigurableListableBeanFactory configurableListableBeanFactory\n+\t\t\t\t&& configurableListableBeanFactory.containsBeanDefinition(this.beanName)) {\n+\t\t\tBeanDefinition beanDefinition = configurableListableBeanFactory.getBeanDefinition(this.beanName);\n+\t\t\tthis.beanSource = beanDefinition.getSource();\n+\t\t\tif (this.beanDescription == null) {\n+\t\t\t\tthis.beanDescription = beanDefinition.getResourceDescription();\n+\t\t\t}\n+\t\t}\n \t\tonInit();\n \t\tthis.initialized = true;\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowAdapter.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowAdapter.java\nindex 1b30df054ec..74631924fb6 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowAdapter.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowAdapter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2023 the original author or authors.\n+ * Copyright 2016-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,6 +23,7 @@\n \n import org.reactivestreams.Publisher;\n \n+import org.springframework.integration.context.ComponentSourceAware;\n import org.springframework.integration.core.MessageSource;\n import org.springframework.integration.endpoint.MessageProducerSupport;\n import org.springframework.integration.gateway.MessagingGatewaySupport;\n@@ -59,18 +60,64 @@\n  *\n  * @since 5.0\n  */\n-public abstract class IntegrationFlowAdapter implements IntegrationFlow, ManageableSmartLifecycle {\n+public abstract class IntegrationFlowAdapter\n+\t\timplements IntegrationFlow, ManageableSmartLifecycle, ComponentSourceAware {\n \n \tprivate final AtomicBoolean running = new AtomicBoolean();\n \n \tprivate StandardIntegrationFlow targetIntegrationFlow;\n \n+\tprivate String beanName;\n+\n+\tprivate Object beanSource;\n+\n+\tprivate String beanDescription;\n+\n+\t@Override\n+\tpublic void setBeanName(String name) {\n+\t\tthis.beanName = name;\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic String getBeanName() {\n+\t\treturn this.beanName;\n+\t}\n+\n+\t@Override\n+\tpublic void setComponentSource(Object source) {\n+\t\tthis.beanSource = source;\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object getComponentSource() {\n+\t\treturn this.beanSource;\n+\t}\n+\n+\t@Override\n+\tpublic void setComponentDescription(String description) {\n+\t\tthis.beanDescription = description;\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic String getComponentDescription() {\n+\t\treturn this.beanDescription;\n+\t}\n+\n \t@Override\n \tpublic final void configure(IntegrationFlowDefinition<?> flow) {\n \t\tIntegrationFlowDefinition<?> targetFlow = buildFlow();\n \t\tflow.integrationComponents.clear();\n \t\tflow.integrationComponents.putAll(targetFlow.integrationComponents);\n \t\tthis.targetIntegrationFlow = flow.get();\n+\t\tif (this.beanSource != null) {\n+\t\t\tthis.targetIntegrationFlow.setComponentSource(this.beanSource);\n+\t\t}\n+\t\tif (this.beanDescription != null) {\n+\t\t\tthis.targetIntegrationFlow.setComponentDescription(this.beanDescription);\n+\t\t}\n \t}\n \n \t@Nullable\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/StandardIntegrationFlow.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/StandardIntegrationFlow.java\nindex f9dd9f72964..da8f18ffbff 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/StandardIntegrationFlow.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/StandardIntegrationFlow.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2023 the original author or authors.\n+ * Copyright 2016-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -24,8 +24,8 @@\n import java.util.Map;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-import org.springframework.beans.factory.BeanNameAware;\n import org.springframework.context.SmartLifecycle;\n+import org.springframework.integration.context.ComponentSourceAware;\n import org.springframework.integration.support.context.NamedComponent;\n import org.springframework.lang.Nullable;\n import org.springframework.messaging.MessageChannel;\n@@ -69,7 +69,7 @@\n  * @see SmartLifecycle\n  */\n public class StandardIntegrationFlow\n-\t\timplements IntegrationFlow, SmartLifecycle, BeanNameAware, NamedComponent {\n+\t\timplements IntegrationFlow, SmartLifecycle, ComponentSourceAware, NamedComponent {\n \n \tprivate final Map<Object, String> integrationComponents;\n \n@@ -79,6 +79,10 @@ public class StandardIntegrationFlow\n \n \tprivate String beanName;\n \n+\tprivate Object beanSource;\n+\n+\tprivate String beanDescription;\n+\n \tStandardIntegrationFlow(Map<Object, String> integrationComponents) {\n \t\tthis.integrationComponents = new LinkedHashMap<>(integrationComponents);\n \t}\n@@ -98,6 +102,34 @@ public String getComponentType() {\n \t\treturn \"integration-flow\";\n \t}\n \n+\t@Override\n+\tpublic void setComponentSource(Object source) {\n+\t\tthis.beanSource = source;\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object getComponentSource() {\n+\t\treturn this.beanSource;\n+\t}\n+\n+\t@Override\n+\tpublic void setComponentDescription(String description) {\n+\t\tthis.beanDescription = description;\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic String getComponentDescription() {\n+\t\treturn this.beanDescription;\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic String getBeanName() {\n+\t\treturn this.beanName;\n+\t}\n+\n \t@Override\n \tpublic void configure(IntegrationFlowDefinition<?> flow) {\n \t\tthrow new UnsupportedOperationException();\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/context/IntegrationFlowBeanPostProcessor.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/context/IntegrationFlowBeanPostProcessor.java\nindex b746627c833..d470d6a9159 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/context/IntegrationFlowBeanPostProcessor.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/context/IntegrationFlowBeanPostProcessor.java\n@@ -29,17 +29,18 @@\n import org.springframework.beans.factory.BeanFactoryAware;\n import org.springframework.beans.factory.BeanFactoryUtils;\n import org.springframework.beans.factory.BeanNameAware;\n+import org.springframework.beans.factory.NoSuchBeanDefinitionException;\n import org.springframework.beans.factory.SmartInitializingSingleton;\n import org.springframework.beans.factory.config.BeanDefinition;\n import org.springframework.beans.factory.config.BeanDefinitionCustomizer;\n import org.springframework.beans.factory.config.BeanPostProcessor;\n import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n-import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n import org.springframework.beans.factory.config.EmbeddedValueResolver;\n import org.springframework.beans.factory.support.AbstractBeanDefinition;\n import org.springframework.beans.factory.support.BeanDefinitionBuilder;\n import org.springframework.beans.factory.support.BeanDefinitionOverrideException;\n import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n+import org.springframework.beans.factory.support.DefaultListableBeanFactory;\n import org.springframework.beans.factory.support.RootBeanDefinition;\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.ApplicationContextAware;\n@@ -52,7 +53,6 @@\n import org.springframework.context.SmartLifecycle;\n import org.springframework.core.ResolvableType;\n import org.springframework.core.io.DescriptiveResource;\n-import org.springframework.core.type.MethodMetadata;\n import org.springframework.integration.channel.AbstractMessageChannel;\n import org.springframework.integration.channel.DirectChannel;\n import org.springframework.integration.channel.FixedSubscriberChannel;\n@@ -60,6 +60,7 @@\n import org.springframework.integration.config.ConsumerEndpointFactoryBean;\n import org.springframework.integration.config.IntegrationConfigUtils;\n import org.springframework.integration.config.SourcePollingChannelAdapterFactoryBean;\n+import org.springframework.integration.context.ComponentSourceAware;\n import org.springframework.integration.context.IntegrationContextUtils;\n import org.springframework.integration.core.MessageSource;\n import org.springframework.integration.dsl.ComponentsRegistration;\n@@ -97,7 +98,7 @@ public class IntegrationFlowBeanPostProcessor\n \n \tprivate StringValueResolver embeddedValueResolver;\n \n-\tprivate ConfigurableListableBeanFactory beanFactory;\n+\tprivate DefaultListableBeanFactory beanFactory;\n \n \tprivate volatile IntegrationFlowContext flowContext;\n \n@@ -109,7 +110,7 @@ public void setApplicationContext(ApplicationContext applicationContext) throws\n \t\t);\n \n \t\tthis.applicationContext = (ConfigurableApplicationContext) applicationContext;\n-\t\tthis.beanFactory = this.applicationContext.getBeanFactory();\n+\t\tthis.beanFactory = (DefaultListableBeanFactory) this.applicationContext.getBeanFactory();\n \t\tthis.embeddedValueResolver = new EmbeddedValueResolver(this.beanFactory);\n \t}\n \n@@ -142,8 +143,16 @@ public void afterSingletonsInstantiated() {\n \t\t}\n \t}\n \n-\tprivate Object processStandardIntegrationFlow(StandardIntegrationFlow flow, String flowBeanName) { // NOSONAR\n-\t\t// complexity\n+\tprivate Object processStandardIntegrationFlow(StandardIntegrationFlow flow, String flowBeanName) { // NOSONAR complexity\n+\t\tboolean registerBeanDefinitions = this.beanFactory.containsBeanDefinition(flowBeanName);\n+\t\tif (registerBeanDefinitions) {\n+\t\t\tBeanDefinition beanDefinition = this.beanFactory.getBeanDefinition(flowBeanName);\n+\t\t\tflow.setComponentSource(beanDefinition.getSource());\n+\t\t\tflow.setComponentDescription(beanDefinition.getDescription());\n+\t\t}\n+\t\tObject beanSource = flow.getComponentSource();\n+\t\tString beanDescription = flow.getComponentDescription();\n+\n \t\tString flowNamePrefix = flowBeanName + \".\";\n \t\tif (this.flowContext == null) {\n \t\t\tthis.flowContext = this.beanFactory.getBean(IntegrationFlowContext.class);\n@@ -172,18 +181,21 @@ else if (useFlowIdAsPrefix) {\n \t\t\t\tif (noBeanPresentForComponent(messageHandler, flowBeanName)) {\n \t\t\t\t\tString handlerBeanName = generateBeanName(messageHandler, flowNamePrefix);\n \n-\t\t\t\t\tregisterComponent(messageHandler, handlerBeanName, flowBeanName);\n+\t\t\t\t\tregisterComponent(registerBeanDefinitions, messageHandler, handlerBeanName,\n+\t\t\t\t\t\t\tbeanSource, beanDescription, flowBeanName);\n \t\t\t\t\tthis.beanFactory.registerAlias(handlerBeanName, id + IntegrationConfigUtils.HANDLER_ALIAS_SUFFIX);\n \t\t\t\t}\n \n-\t\t\t\tregisterComponent(endpoint, id, flowBeanName);\n+\t\t\t\tregisterComponent(registerBeanDefinitions, endpoint, id, beanSource,\n+\t\t\t\t\t\tbeanDescription, flowBeanName);\n \t\t\t\ttargetIntegrationComponents.put(endpoint, id);\n \t\t\t}\n \t\t\telse if (component instanceof MessageChannelReference messageChannelReference) {\n \t\t\t\tString channelBeanName = messageChannelReference.name();\n \t\t\t\tif (!this.beanFactory.containsBean(channelBeanName)) {\n \t\t\t\t\tDirectChannel directChannel = new DirectChannel();\n-\t\t\t\t\tregisterComponent(directChannel, channelBeanName, flowBeanName);\n+\t\t\t\t\tregisterComponent(registerBeanDefinitions, directChannel, channelBeanName,\n+\t\t\t\t\t\t\tbeanSource, beanDescription, flowBeanName);\n \t\t\t\t\ttargetIntegrationComponents.put(directChannel, channelBeanName);\n \t\t\t\t}\n \t\t\t}\n@@ -194,9 +206,9 @@ else if (component instanceof SourcePollingChannelAdapterSpec spec) {\n \t\t\t\t\t\t\t.stream()\n \t\t\t\t\t\t\t.filter(o -> noBeanPresentForComponent(o.getKey(), flowBeanName))\n \t\t\t\t\t\t\t.forEach(o ->\n-\t\t\t\t\t\t\t\t\tregisterComponent(o.getKey(),\n+\t\t\t\t\t\t\t\t\tregisterComponent(registerBeanDefinitions, o.getKey(),\n \t\t\t\t\t\t\t\t\t\t\tgenerateBeanName(o.getKey(), flowNamePrefix, o.getValue(),\n-\t\t\t\t\t\t\t\t\t\t\t\t\tuseFlowIdAsPrefix)));\n+\t\t\t\t\t\t\t\t\t\t\t\t\tuseFlowIdAsPrefix), beanSource, beanDescription, spec.getId()));\n \t\t\t\t}\n \t\t\t\tSourcePollingChannelAdapterFactoryBean pollingChannelAdapterFactoryBean = spec.getObject().getT1();\n \t\t\t\tString id = spec.getId();\n@@ -208,7 +220,8 @@ else if (useFlowIdAsPrefix) {\n \t\t\t\t\tid = flowNamePrefix + id;\n \t\t\t\t}\n \n-\t\t\t\tregisterComponent(pollingChannelAdapterFactoryBean, id, flowBeanName);\n+\t\t\t\tregisterComponent(registerBeanDefinitions, pollingChannelAdapterFactoryBean, id,\n+\t\t\t\t\t\tbeanSource, beanDescription, flowBeanName);\n \t\t\t\ttargetIntegrationComponents.put(pollingChannelAdapterFactoryBean, id);\n \n \t\t\t\tMessageSource<?> messageSource = spec.getObject().getT2();\n@@ -219,7 +232,8 @@ else if (useFlowIdAsPrefix) {\n \n \t\t\t\t\t\tmessageSourceId = namedComponent.getComponentName();\n \t\t\t\t\t}\n-\t\t\t\t\tregisterComponent(messageSource, messageSourceId, flowBeanName);\n+\t\t\t\t\tregisterComponent(registerBeanDefinitions, messageSource, messageSourceId,\n+\t\t\t\t\t\t\tbeanSource, beanDescription, flowBeanName);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n@@ -233,7 +247,8 @@ else if (useFlowIdAsPrefix) {\n \t\t\t\t\t\t\t\t\t\tBeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR + channelNameIndex++;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tregisterComponent(component, channelBeanName, flowBeanName);\n+\t\t\t\t\t\tregisterComponent(registerBeanDefinitions, component, channelBeanName,\n+\t\t\t\t\t\t\t\tbeanSource, beanDescription, flowBeanName);\n \t\t\t\t\t\ttargetIntegrationComponents.put(component, channelBeanName);\n \t\t\t\t\t}\n \t\t\t\t\telse if (component instanceof FixedSubscriberChannel fixedSubscriberChannel) {\n@@ -242,7 +257,8 @@ else if (component instanceof FixedSubscriberChannel fixedSubscriberChannel) {\n \t\t\t\t\t\t\tchannelBeanName = flowNamePrefix + \"channel\" +\n \t\t\t\t\t\t\t\t\tBeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR + channelNameIndex++;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tregisterComponent(component, channelBeanName, flowBeanName);\n+\t\t\t\t\t\tregisterComponent(registerBeanDefinitions, component, channelBeanName,\n+\t\t\t\t\t\t\t\tbeanSource, beanDescription, flowBeanName);\n \t\t\t\t\t\ttargetIntegrationComponents.put(component, channelBeanName);\n \t\t\t\t\t}\n \t\t\t\t\telse if (component instanceof StandardIntegrationFlow) {\n@@ -251,7 +267,8 @@ else if (component instanceof StandardIntegrationFlow) {\n \t\t\t\t\t\t\t\t\t\t? entry.getValue()\n \t\t\t\t\t\t\t\t\t\t: flowNamePrefix + \"subFlow\" +\n \t\t\t\t\t\t\t\t\t\tBeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR + subFlowNameIndex++;\n-\t\t\t\t\t\tregisterComponent(component, subFlowBeanName, flowBeanName);\n+\t\t\t\t\t\tregisterComponent(registerBeanDefinitions, component, subFlowBeanName,\n+\t\t\t\t\t\t\t\tbeanSource, beanDescription, flowBeanName);\n \t\t\t\t\t\ttargetIntegrationComponents.put(component, subFlowBeanName);\n \t\t\t\t\t}\n \t\t\t\t\telse if (component instanceof AnnotationGatewayProxyFactoryBean<?> gateway) {\n@@ -264,15 +281,21 @@ else if (component instanceof AnnotationGatewayProxyFactoryBean<?> gateway) {\n \t\t\t\t\t\t\tgatewayId = flowNamePrefix + \"gateway\";\n \t\t\t\t\t\t}\n \n-\t\t\t\t\t\tregisterComponent(gateway, gatewayId, flowBeanName,\n-\t\t\t\t\t\t\t\tbeanDefinition -> {\n-\t\t\t\t\t\t\t\t\tRootBeanDefinition definition = (RootBeanDefinition) beanDefinition;\n-\t\t\t\t\t\t\t\t\tClass<?> serviceInterface = gateway.getObjectType();\n-\t\t\t\t\t\t\t\t\tdefinition.setSource(new DescriptiveResource(\"\" + serviceInterface));\n-\t\t\t\t\t\t\t\t\tdefinition.setTargetType(\n-\t\t\t\t\t\t\t\t\t\t\tResolvableType.forClassWithGenerics(AnnotationGatewayProxyFactoryBean.class,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tserviceInterface));\n-\t\t\t\t\t\t\t\t});\n+\t\t\t\t\t\tif (registerBeanDefinitions) {\n+\t\t\t\t\t\t\tregisterBeanDefinition(gateway, gatewayId, beanSource,\n+\t\t\t\t\t\t\t\t\tbeanDescription, flowBeanName,\n+\t\t\t\t\t\t\t\t\tbeanDefinition -> {\n+\t\t\t\t\t\t\t\t\t\tRootBeanDefinition definition = (RootBeanDefinition) beanDefinition;\n+\t\t\t\t\t\t\t\t\t\tClass<?> serviceInterface = gateway.getObjectType();\n+\t\t\t\t\t\t\t\t\t\tdefinition.setSource(new DescriptiveResource(\"\" + serviceInterface));\n+\t\t\t\t\t\t\t\t\t\tdefinition.setTargetType(\n+\t\t\t\t\t\t\t\t\t\t\t\tResolvableType.forClassWithGenerics(AnnotationGatewayProxyFactoryBean.class,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tserviceInterface));\n+\t\t\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\tregisterSingleton(gateway, gatewayId, beanSource, beanDescription, flowBeanName);\n+\t\t\t\t\t\t}\n \n \t\t\t\t\t\ttargetIntegrationComponents.put(component, gatewayId);\n \t\t\t\t\t}\n@@ -280,7 +303,8 @@ else if (component instanceof AnnotationGatewayProxyFactoryBean<?> gateway) {\n \t\t\t\t\t\tString generatedBeanName =\n \t\t\t\t\t\t\t\tgenerateBeanName(component, flowNamePrefix, entry.getValue(), useFlowIdAsPrefix);\n \n-\t\t\t\t\t\tregisterComponent(component, generatedBeanName, flowBeanName);\n+\t\t\t\t\t\tregisterComponent(registerBeanDefinitions, component, generatedBeanName,\n+\t\t\t\t\t\t\t\tbeanSource, beanDescription, flowBeanName);\n \t\t\t\t\t\ttargetIntegrationComponents.put(component, generatedBeanName);\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -352,13 +376,20 @@ private void processIntegrationComponentSpec(String beanName, IntegrationCompone\n \t\tif (bean instanceof ComponentsRegistration componentsRegistration) {\n \t\t\tMap<Object, String> componentsToRegister = componentsRegistration.getComponentsToRegister();\n \t\t\tif (!CollectionUtils.isEmpty(componentsToRegister)) {\n+\t\t\t\tboolean registerBeanDefinitions = this.beanFactory.containsBeanDefinition(beanName);\n+\t\t\t\tBeanDefinition beanDefinition = null;\n+\t\t\t\tif (registerBeanDefinitions) {\n+\t\t\t\t\tbeanDefinition = this.beanFactory.getBeanDefinition(beanName);\n+\t\t\t\t}\n+\t\t\t\tObject beanDefinitionSource = registerBeanDefinitions ? beanDefinition.getSource() : null;\n+\t\t\t\tString beanDefinitionDescription = registerBeanDefinitions ? beanDefinition.getDescription() : null;\n \t\t\t\tcomponentsToRegister.entrySet()\n \t\t\t\t\t\t.stream()\n \t\t\t\t\t\t.filter(component -> noBeanPresentForComponent(component.getKey(), beanName))\n \t\t\t\t\t\t.forEach(component ->\n-\t\t\t\t\t\t\t\tregisterComponent(component.getKey(),\n-\t\t\t\t\t\t\t\t\t\tgenerateBeanName(component.getKey(), beanName, component.getValue(), false)));\n-\n+\t\t\t\t\t\t\t\tregisterComponent(registerBeanDefinitions, component.getKey(),\n+\t\t\t\t\t\t\t\t\t\tgenerateBeanName(component.getKey(), beanName, component.getValue(), false),\n+\t\t\t\t\t\t\t\t\t\tbeanDefinitionSource, beanDefinitionDescription, beanName));\n \t\t\t}\n \t\t}\n \t}\n@@ -405,21 +436,34 @@ private boolean noBeanPresentForComponent(Object instance, String parentBeanName\n \t\t\t\treturn true;\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tBeanDefinition existingBeanDefinition =\n-\t\t\t\t\t\tIntegrationContextUtils.getBeanDefinition(beanName, this.beanFactory);\n-\t\t\t\tif (!ConfigurableBeanFactory.SCOPE_PROTOTYPE.equals(existingBeanDefinition.getScope())\n-\t\t\t\t\t\t&& !instance.equals(this.beanFactory.getBean(beanName))) {\n-\n-\t\t\t\t\tAbstractBeanDefinition beanDefinition =\n-\t\t\t\t\t\t\tBeanDefinitionBuilder.genericBeanDefinition((Class<Object>) instance.getClass(),\n-\t\t\t\t\t\t\t\t\t\t\t() -> instance)\n-\t\t\t\t\t\t\t\t\t.getBeanDefinition();\n-\t\t\t\t\tbeanDefinition.setResourceDescription(\"the '\" + parentBeanName + \"' bean definition\");\n-\t\t\t\t\tthrow new BeanDefinitionOverrideException(beanName, beanDefinition, existingBeanDefinition);\n+\t\t\t\tBeanDefinition existingBeanDefinition = null;\n+\t\t\t\ttry {\n+\t\t\t\t\texistingBeanDefinition = IntegrationContextUtils.getBeanDefinition(beanName, this.beanFactory);\n \t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\treturn false;\n+\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n+\t\t\t\t\t// Ignore and move on as no bean definition (possibly just singleton?)\n \t\t\t\t}\n+\n+\t\t\t\tif (existingBeanDefinition == null\n+\t\t\t\t\t\t|| !ConfigurableBeanFactory.SCOPE_PROTOTYPE.equals(existingBeanDefinition.getScope())) {\n+\n+\t\t\t\t\tObject existingBean = this.beanFactory.getBean(beanName);\n+\t\t\t\t\tif (!instance.equals(existingBean)) {\n+\t\t\t\t\t\tAbstractBeanDefinition beanDefinition =\n+\t\t\t\t\t\t\t\tBeanDefinitionBuilder.genericBeanDefinition((Class<Object>) instance.getClass(),\n+\t\t\t\t\t\t\t\t\t\t\t\t() -> instance)\n+\t\t\t\t\t\t\t\t\t\t.getBeanDefinition();\n+\t\t\t\t\t\tbeanDefinition.setResourceDescription(\"the '\" + parentBeanName + \"' bean definition\");\n+\t\t\t\t\t\tif (existingBeanDefinition == null) {\n+\t\t\t\t\t\t\texistingBeanDefinition =\n+\t\t\t\t\t\t\t\t\tBeanDefinitionBuilder.genericBeanDefinition((Class<Object>) existingBean.getClass(),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t() -> existingBean)\n+\t\t\t\t\t\t\t\t\t\t\t.getBeanDefinition();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tthrow new BeanDefinitionOverrideException(beanName, beanDefinition, existingBeanDefinition);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn false;\n \t\t\t}\n \t\t}\n \n@@ -427,12 +471,21 @@ private boolean noBeanPresentForComponent(Object instance, String parentBeanName\n \t\t\t\t.containsValue(instance);\n \t}\n \n-\tprivate void registerComponent(Object component, String beanName) {\n-\t\tregisterComponent(component, beanName, null);\n+\tprivate void registerComponent(boolean registerBeanDefinition,\n+\t\t\tObject component, String beanName, @Nullable Object source,\n+\t\t\t@Nullable String description, @Nullable String parentName) {\n+\n+\t\tif (registerBeanDefinition) {\n+\t\t\tregisterBeanDefinition(component, beanName, source, description, parentName);\n+\t\t}\n+\t\telse {\n+\t\t\tregisterSingleton(component, beanName, source, description, parentName);\n+\t\t}\n \t}\n \n \t@SuppressWarnings(\"unchecked\")\n-\tprivate void registerComponent(Object component, String beanName, @Nullable String parentName,\n+\tprivate void registerBeanDefinition(Object component, String beanName, @Nullable Object source,\n+\t\t\t@Nullable String description, @Nullable String parentName,\n \t\t\tBeanDefinitionCustomizer... customizers) {\n \n \t\tAbstractBeanDefinition beanDefinition =\n@@ -440,20 +493,31 @@ private void registerComponent(Object component, String beanName, @Nullable Stri\n \t\t\t\t\t\t.applyCustomizers(customizers)\n \t\t\t\t\t\t.getRawBeanDefinition();\n \n-\t\tif (parentName != null && this.beanFactory.containsBeanDefinition(parentName)) {\n-\t\t\tAbstractBeanDefinition parentBeanDefinition =\n-\t\t\t\t\t(AbstractBeanDefinition) this.beanFactory.getBeanDefinition(parentName);\n-\t\t\tbeanDefinition.setResource(parentBeanDefinition.getResource());\n-\t\t\tObject source = parentBeanDefinition.getSource();\n-\t\t\tif (source instanceof MethodMetadata) {\n-\t\t\t\tsource = \"bean method \" + ((MethodMetadata) source).getMethodName();\n-\t\t\t}\n-\t\t\tbeanDefinition.setSource(source);\n+\t\tbeanDefinition.setSource(source);\n+\t\tbeanDefinition.setDescription(description);\n+\n+\t\tif (parentName != null) {\n \t\t\tthis.beanFactory.registerDependentBean(parentName, beanName);\n \t\t}\n \n \t\t((BeanDefinitionRegistry) this.beanFactory).registerBeanDefinition(beanName, beanDefinition);\n+\t\tthis.beanFactory.getBean(beanName);\n+\t}\n+\n+\tprivate void registerSingleton(Object component, String beanName, @Nullable Object source,\n+\t\t\t@Nullable String description, @Nullable String parentName) {\n+\n+\t\tif (component instanceof ComponentSourceAware componentSourceAware) {\n+\t\t\tcomponentSourceAware.setComponentSource(source);\n+\t\t\tcomponentSourceAware.setComponentDescription(description);\n+\t\t}\n+\n+\t\tif (parentName != null) {\n+\t\t\tthis.beanFactory.registerDependentBean(parentName, beanName);\n+\t\t}\n \n+\t\tthis.beanFactory.registerSingleton(beanName, component);\n+\t\tthis.beanFactory.initializeBean(component, beanName);\n \t\tthis.beanFactory.getBean(beanName);\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/context/IntegrationFlowContext.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/context/IntegrationFlowContext.java\nindex ea67587f614..5e0f3d81c46 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/context/IntegrationFlowContext.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/context/IntegrationFlowContext.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018-2023 the original author or authors.\n+ * Copyright 2018-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -214,6 +214,14 @@ interface IntegrationFlowRegistrationBuilder {\n \t\t */\n \t\tIntegrationFlowRegistrationBuilder setSource(Object source);\n \n+\t\t/**\n+\t\t * Set a human-readable description of this integration flow.\n+\t\t * @param description the description for integration flow instance.\n+\t\t * @return the current builder instance\n+\t\t * @since 6.4\n+\t\t */\n+\t\tIntegrationFlowRegistrationBuilder setDescription(String description);\n+\n \t\t/**\n \t\t * Invoke this method to prefix bean names in the flow with the (required) flow id\n \t\t * and a period. This is useful if you wish to register the same flow multiple times\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/context/StandardIntegrationFlowContext.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/context/StandardIntegrationFlowContext.java\nindex 5c7635b02fb..82a51af159a 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/context/StandardIntegrationFlowContext.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/context/StandardIntegrationFlowContext.java\n@@ -27,14 +27,15 @@\n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryAware;\n import org.springframework.beans.factory.BeanFactoryUtils;\n-import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n-import org.springframework.beans.factory.support.AbstractBeanDefinition;\n-import org.springframework.beans.factory.support.BeanDefinitionBuilder;\n-import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n+import org.springframework.beans.factory.support.DefaultListableBeanFactory;\n import org.springframework.context.SmartLifecycle;\n-import org.springframework.core.type.MethodMetadata;\n+import org.springframework.integration.context.ComponentSourceAware;\n import org.springframework.integration.core.MessagingTemplate;\n import org.springframework.integration.dsl.IntegrationFlow;\n+import org.springframework.integration.dsl.IntegrationFlowAdapter;\n+import org.springframework.integration.dsl.IntegrationFlowBuilder;\n+import org.springframework.integration.dsl.IntegrationFlowDefinition;\n+import org.springframework.integration.dsl.StandardIntegrationFlow;\n import org.springframework.integration.support.context.NamedComponent;\n import org.springframework.lang.Nullable;\n import org.springframework.util.Assert;\n@@ -59,21 +60,18 @@ public final class StandardIntegrationFlowContext implements IntegrationFlowCont\n \n \tprivate final Lock registerFlowsLock = new ReentrantLock();\n \n-\tprivate ConfigurableListableBeanFactory beanFactory;\n-\n-\tprivate BeanDefinitionRegistry beanDefinitionRegistry;\n+\tprivate DefaultListableBeanFactory beanFactory;\n \n \tStandardIntegrationFlowContext() {\n \t}\n \n \t@Override\n \tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n-\t\tAssert.isInstanceOf(ConfigurableListableBeanFactory.class, beanFactory,\n+\t\tAssert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory,\n \t\t\t\t\"To use Spring Integration Java DSL the 'beanFactory' has to be an instance of \" +\n \t\t\t\t\t\t\"'ConfigurableListableBeanFactory'. \" +\n \t\t\t\t\t\t\"Consider using 'GenericApplicationContext' implementation.\");\n-\t\tthis.beanFactory = (ConfigurableListableBeanFactory) beanFactory;\n-\t\tthis.beanDefinitionRegistry = (BeanDefinitionRegistry) this.beanFactory;\n+\t\tthis.beanFactory = (DefaultListableBeanFactory) beanFactory;\n \t}\n \n \t/**\n@@ -107,7 +105,7 @@ else if (this.registry.containsKey(flowId)) {\n \t\t\t\t\t\t\"An existing IntegrationFlowRegistration must be destroyed before overriding.\");\n \t\t\t}\n \n-\t\t\tintegrationFlow = registerFlowBean(integrationFlow, flowId, builder.source);\n+\t\t\tintegrationFlow = registerFlowBean(integrationFlow, flowId, builder.source, builder.description);\n \t\t}\n \t\tfinally {\n \t\t\tthis.registerFlowsLock.unlock();\n@@ -116,7 +114,8 @@ else if (this.registry.containsKey(flowId)) {\n \t\tbuilder.integrationFlow = integrationFlow;\n \n \t\tfinal String theFlowId = flowId;\n-\t\tbuilder.additionalBeans.forEach((key, value) -> registerBean(key, value, theFlowId));\n+\t\tbuilder.additionalBeans.forEach((key, value) ->\n+\t\t\t\tregisterBean(key, value, theFlowId, builder.source, builder.description));\n \n \t\tIntegrationFlowRegistration registration =\n \t\t\t\tnew StandardIntegrationFlowRegistration(integrationFlow, this, flowId);\n@@ -133,38 +132,37 @@ else if (this.registry.containsKey(flowId)) {\n \t\treturn registration;\n \t}\n \n-\tprivate IntegrationFlow registerFlowBean(IntegrationFlow flow, String flowId, @Nullable Object source) {\n-\t\tAbstractBeanDefinition beanDefinition =\n-\t\t\t\tBeanDefinitionBuilder.genericBeanDefinition(IntegrationFlow.class, () -> flow)\n-\t\t\t\t\t\t.getRawBeanDefinition();\n-\t\tbeanDefinition.setSource(source);\n-\t\tthis.beanDefinitionRegistry.registerBeanDefinition(flowId, beanDefinition);\n-\t\treturn this.beanFactory.getBean(flowId, IntegrationFlow.class);\n+\tprivate IntegrationFlow registerFlowBean(IntegrationFlow flow, @Nullable String beanName,\n+\t\t\t@Nullable Object source, @Nullable String description) {\n+\n+\t\tIntegrationFlow flowToRegister = flow;\n+\n+\t\tif (!(flow instanceof StandardIntegrationFlow) && !(flow instanceof IntegrationFlowAdapter)) {\n+\t\t\tflowToRegister = new IntegrationFlowComponentSourceAwareAdapter(flow);\n+\t\t}\n+\n+\t\treturn registerBean(flowToRegister, beanName, null, source, description);\n \t}\n \n \t@SuppressWarnings(\"unchecked\")\n-\tprivate void registerBean(Object bean, @Nullable String beanNameArg, String parentName) {\n-\t\tString beanName = beanNameArg;\n-\t\tif (beanName == null) {\n-\t\t\tbeanName = generateBeanName(bean, parentName);\n-\t\t}\n+\tprivate <B> B registerBean(B bean, @Nullable String beanNameArg, @Nullable String parentName,\n+\t\t\t@Nullable Object source, @Nullable String description) {\n \n-\t\tAbstractBeanDefinition beanDefinition =\n-\t\t\t\tBeanDefinitionBuilder.genericBeanDefinition((Class<Object>) bean.getClass(), () -> bean)\n-\t\t\t\t\t\t.getRawBeanDefinition();\n+\t\tString beanName = beanNameArg != null ? beanNameArg : generateBeanName(bean, parentName);\n \n \t\tif (parentName != null) {\n-\t\t\tAbstractBeanDefinition parentBeanDefinition =\n-\t\t\t\t\t(AbstractBeanDefinition) this.beanFactory.getBeanDefinition(parentName);\n-\t\t\tObject source = parentBeanDefinition.getSource();\n-\t\t\tif (source instanceof MethodMetadata) {\n-\t\t\t\tsource = \"bean method \" + ((MethodMetadata) source).getMethodName();\n-\t\t\t}\n-\t\t\tbeanDefinition.setSource(source);\n \t\t\tthis.beanFactory.registerDependentBean(parentName, beanName);\n \t\t}\n-\t\tthis.beanDefinitionRegistry.registerBeanDefinition(beanName, beanDefinition);\n-\t\tthis.beanFactory.getBean(beanName);\n+\t\tif (bean instanceof ComponentSourceAware componentSourceAware) {\n+\t\t\tif (source != null && componentSourceAware.getComponentSource() == null) {\n+\t\t\t\tcomponentSourceAware.setComponentSource(source);\n+\t\t\t}\n+\t\t\tif (description != null && componentSourceAware.getComponentDescription() == null) {\n+\t\t\t\tcomponentSourceAware.setComponentDescription(description);\n+\t\t\t}\n+\t\t}\n+\t\tthis.beanFactory.registerSingleton(beanName, bean);\n+\t\treturn (B) this.beanFactory.initializeBean(bean, beanName);\n \t}\n \n \t/**\n@@ -192,7 +190,7 @@ public void remove(String flowId) {\n \n \t\t\tremoveDependantBeans(flowId);\n \n-\t\t\tthis.beanDefinitionRegistry.removeBeanDefinition(flowId);\n+\t\t\tthis.beanFactory.destroySingleton(flowId);\n \t\t}\n \t\telse {\n \t\t\tthrow new IllegalStateException(\"An IntegrationFlow with the id \"\n@@ -203,12 +201,13 @@ public void remove(String flowId) {\n \tprivate void removeDependantBeans(String parentName) {\n \t\tString[] dependentBeans = this.beanFactory.getDependentBeans(parentName);\n \t\tfor (String beanName : dependentBeans) {\n-\t\t\tremoveDependantBeans(beanName);\n-\t\t\tthis.beanDefinitionRegistry.removeBeanDefinition(beanName);\n-\t\t\tString[] aliases = this.beanDefinitionRegistry.getAliases(beanName);\n+\t\t\tthis.beanFactory.destroyBean(this.beanFactory.getBean(beanName));\n+\t\t\tthis.beanFactory.destroySingleton(beanName);\n+\t\t\tString[] aliases = this.beanFactory.getAliases(beanName);\n \t\t\tfor (String alias : aliases) {\n-\t\t\t\tthis.beanDefinitionRegistry.removeAlias(alias);\n+\t\t\t\tthis.beanFactory.removeAlias(alias);\n \t\t\t}\n+\t\t\tremoveDependantBeans(beanName);\n \t\t}\n \t}\n \n@@ -216,9 +215,8 @@ private void removeDependantBeans(String parentName) {\n \t * Obtain a {@link MessagingTemplate} with its default destination set to the input channel\n \t * of the {@link IntegrationFlow} for provided {@code flowId}.\n \t * <p> Any {@link IntegrationFlow} bean (not only manually registered) can be used for this method.\n-\t * <p> If {@link IntegrationFlow} doesn't start with the\n-\t * {@link org.springframework.messaging.MessageChannel}, the\n-\t * {@link IllegalStateException} is thrown.\n+\t * <p> If {@link IntegrationFlow} doesn't start with the {@link org.springframework.messaging.MessageChannel},\n+\t * the {@link IllegalStateException} is thrown.\n \t * @param flowId the bean name to obtain the input channel from\n \t * @return the {@link MessagingTemplate} instance\n \t */\n@@ -275,6 +273,9 @@ public final class StandardIntegrationFlowRegistrationBuilder implements Integra\n \t\t@Nullable\n \t\tprivate Object source;\n \n+\t\t@Nullable\n+\t\tprivate String description;\n+\n \t\tStandardIntegrationFlowRegistrationBuilder(IntegrationFlow integrationFlow) {\n \t\t\tthis.integrationFlow = integrationFlow;\n \t\t}\n@@ -338,6 +339,12 @@ public IntegrationFlowRegistrationBuilder setSource(Object source) {\n \t\t\treturn this;\n \t\t}\n \n+\t\t@Override\n+\t\tpublic IntegrationFlowRegistrationBuilder setDescription(String description) {\n+\t\t\tthis.description = description;\n+\t\t\treturn this;\n+\t\t}\n+\n \t\t@Override\n \t\tpublic IntegrationFlowRegistrationBuilder useFlowIdAsPrefix() {\n \t\t\tthis.idAsPrefix = true;\n@@ -364,4 +371,62 @@ public IntegrationFlowRegistration register() {\n \n \t}\n \n+\tprivate static final class IntegrationFlowComponentSourceAwareAdapter\n+\t\t\timplements IntegrationFlow, ComponentSourceAware {\n+\n+\t\tprivate final IntegrationFlow delegate;\n+\n+\t\tprivate Object beanSource;\n+\n+\t\tprivate String beanDescription;\n+\n+\t\tIntegrationFlowComponentSourceAwareAdapter(IntegrationFlow delegate) {\n+\t\t\tthis.delegate = delegate;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void setComponentSource(Object source) {\n+\t\t\tthis.beanSource = source;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Object getComponentSource() {\n+\t\t\treturn this.beanSource;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void setComponentDescription(String description) {\n+\t\t\tthis.beanDescription = description;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getComponentDescription() {\n+\t\t\treturn this.beanDescription;\n+\t\t}\n+\n+\t\t@Nullable\n+\t\t@Override\n+\t\tpublic String getBeanName() {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void setBeanName(String name) {\n+\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void configure(IntegrationFlowDefinition<?> flow) {\n+\t\t\tthis.delegate.configure(flow);\n+\t\t\tStandardIntegrationFlow standardIntegrationFlow = ((IntegrationFlowBuilder) flow).get();\n+\t\t\tif (this.beanSource != null) {\n+\t\t\t\tstandardIntegrationFlow.setComponentSource(this.beanSource);\n+\t\t\t}\n+\t\t\tif (this.beanDescription != null) {\n+\t\t\t\tstandardIntegrationFlow.setComponentDescription(this.beanDescription);\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\n }\n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/dsl/gateway/GatewayDslTests.java b/spring-integration-core/src/test/java/org/springframework/integration/dsl/gateway/GatewayDslTests.java\nindex 4598c9439f1..200ccce6eff 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/dsl/gateway/GatewayDslTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/dsl/gateway/GatewayDslTests.java\n@@ -48,6 +48,7 @@\n import org.springframework.messaging.PollableChannel;\n import org.springframework.messaging.support.ErrorMessage;\n import org.springframework.messaging.support.GenericMessage;\n+import org.springframework.test.annotation.DirtiesContext;\n import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n@@ -59,6 +60,7 @@\n  * @since 5.1.3\n  */\n @SpringJUnitConfig\n+@DirtiesContext\n public class GatewayDslTests {\n \n \t@Autowired\n@@ -96,9 +98,8 @@ void testGatewayFlow() {\n \t\tString exceptionMessage = ((Exception) receive.getPayload()).getMessage();\n \t\tassertThat(exceptionMessage)\n \t\t\t\t.contains(\"message has been rejected in filter\")\n-\t\t\t\t.contains(\"defined in: \" +\n-\t\t\t\t\t\t\"'org.springframework.integration.dsl.gateway.GatewayDslTests$ContextConfiguration'; \" +\n-\t\t\t\t\t\t\"from source: 'bean method gatewayRequestFlow'\");\n+\t\t\t\t.contains(\"from source: 'public org.springframework.integration.dsl.IntegrationFlow \" +\n+\t\t\t\t\t\t\"org.springframework.integration.dsl.gateway.GatewayDslTests$ContextConfiguration.gatewayRequestFlow()'\");\n \t}\n \n \t@Autowired\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/dsl/manualflow/ManualFlowTests.java b/spring-integration-core/src/test/java/org/springframework/integration/dsl/manualflow/ManualFlowTests.java\nindex 4427905310f..8c5bf4282de 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/dsl/manualflow/ManualFlowTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/dsl/manualflow/ManualFlowTests.java\n@@ -21,8 +21,10 @@\n import java.util.Arrays;\n import java.util.Date;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.UUID;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n@@ -34,9 +36,7 @@\n import org.junit.jupiter.api.Test;\n import reactor.core.publisher.Flux;\n \n-import org.springframework.beans.factory.BeanCreationException;\n import org.springframework.beans.factory.BeanCreationNotAllowedException;\n-import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.ListableBeanFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.config.BeanFactoryPostProcessor;\n@@ -52,7 +52,6 @@\n import org.springframework.integration.config.EnableIntegration;\n import org.springframework.integration.config.EnableIntegrationManagement;\n import org.springframework.integration.config.EnableMessageHistory;\n-import org.springframework.integration.config.IntegrationManagementConfigurer;\n import org.springframework.integration.core.MessageProducer;\n import org.springframework.integration.core.MessagingTemplate;\n import org.springframework.integration.dsl.IntegrationFlow;\n@@ -112,9 +111,6 @@ public class ManualFlowTests {\n \t@Autowired\n \tprivate SmartLifecycleRoleController roleController;\n \n-\t@Autowired\n-\tprivate IntegrationManagementConfigurer integrationManagementConfigurer;\n-\n \t@Test\n \t@SuppressWarnings(\"unchecked\")\n \tpublic void testWithAnonymousMessageProducerStart() {\n@@ -212,7 +208,6 @@ public void testManualFlowRegistration() throws InterruptedException {\n \t\t\t\tthis.beanFactory.getBean(flowRegistrationId + BeanFactoryHandler.class.getName() + \"#0\",\n \t\t\t\t\t\tBeanFactoryHandler.class);\n \t\tassertThat(bean).isSameAs(additionalBean);\n-\t\tassertThat(bean.beanFactory).isSameAs(this.beanFactory);\n \t\tbean = this.beanFactory.getBean(flowRegistrationId + \".\" + \"anId.handler\", BeanFactoryHandler.class);\n \n \t\tMessagingTemplate messagingTemplate = flowRegistration.getMessagingTemplate();\n@@ -486,23 +481,28 @@ public void testConcurrentRegistration() throws InterruptedException {\n \n \t@Test\n \tpublic void testDisabledBeansOverride() {\n-\t\tassertThatExceptionOfType(BeanCreationException.class)\n+\t\tassertThatExceptionOfType(BeanDefinitionOverrideException.class)\n \t\t\t\t.isThrownBy(() ->\n \t\t\t\t\t\tthis.integrationFlowContext.registration(f -> f.channel(c -> c.direct(\"doNotOverrideChannel\")))\n \t\t\t\t\t\t\t\t.register())\n-\t\t\t\t.isExactlyInstanceOf(BeanCreationException.class)\n-\t\t\t\t.withCauseExactlyInstanceOf(BeanDefinitionOverrideException.class)\n \t\t\t\t.withMessageContaining(\"Invalid bean definition with name 'doNotOverrideChannel'\");\n \t}\n \n \t@Test\n \tpublic void testBeanDefinitionInfoInTheException() {\n+\t\tMap<?, ?> mergedBeanDefinitions =\n+\t\t\t\tTestUtils.getPropertyValue(this.beanFactory, \"mergedBeanDefinitions\", Map.class);\n+\n+\t\tint mergedBeanDefinitionsSizeBeforeRandomFlow = mergedBeanDefinitions.size();\n+\n \t\tIntegrationFlow testFlow = f -> f.<String, String>transform(String::toUpperCase);\n \t\tMethod source = ReflectionUtils.findMethod(ManualFlowTests.class, \"testBeanDefinitionInfoInTheException\");\n \t\tIntegrationFlowRegistration flowRegistration =\n \t\t\t\tthis.integrationFlowContext.registration(testFlow)\n \t\t\t\t\t\t.setSource(source)\n+\t\t\t\t\t\t.id(\"flow#\" + UUID.randomUUID())\n \t\t\t\t\t\t.register();\n+\n \t\tassertThatExceptionOfType(MessageTransformationException.class)\n \t\t\t\t.isThrownBy(() -> flowRegistration.getInputChannel().send(new GenericMessage<>(new Date())))\n \t\t\t\t.withCauseExactlyInstanceOf(ClassCastException.class)\n@@ -510,6 +510,8 @@ public void testBeanDefinitionInfoInTheException() {\n \t\t\t\t.withStackTraceContaining(\"java.util.Date cannot be cast to\");\n \n \t\tflowRegistration.destroy();\n+\n+\t\tassertThat(mergedBeanDefinitions.size()).isEqualTo(mergedBeanDefinitionsSizeBeforeRandomFlow);\n \t}\n \n \t@Configuration\n@@ -565,20 +567,17 @@ public IntegrationFlow wrongScopeFlow() {\n \n \tprivate final class BeanFactoryHandler extends AbstractReplyProducingMessageHandler {\n \n-\t\t@Autowired\n-\t\tprivate BeanFactory beanFactory;\n-\n \t\tprivate boolean destroyed;\n \n \t\t@Override\n \t\tprotected Object handleRequestMessage(Message<?> requestMessage) {\n-\t\t\tObjects.requireNonNull(this.beanFactory);\n+\t\t\tObjects.requireNonNull(getBeanFactory());\n \t\t\treturn requestMessage;\n \t\t}\n \n \t\t@Override\n \t\tprotected void doInit() {\n-\t\t\tthis.beanFactory.getClass(); // ensure wiring before afterPropertiesSet()\n+\t\t\tgetBeanFactory().getClass(); // ensure wiring before afterPropertiesSet()\n \t\t}\n \n \t\t@Override\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9435",
    "pr_id": 9435,
    "issue_id": 9428,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "MQTT MqttMessageDeliveredEvent  not publish\n**In what version(s) of Spring Integration are you seeing this issue?**\r\n\r\n6.3.3\r\n\r\n**Describe the bug**\r\n\r\nWhen integrating MQTT using the Shared MQTT Client Support method, the MqttMessageDeliveredEvent event will not be published.\r\nBecause the MQTT client's callback is no longer MqttPahoMessageHandler, the MqttMessageDeliveredEvent event is no longer triggered for publication.\r\n\r\n![image](https://github.com/user-attachments/assets/ded601c0-53ae-410a-8c5e-566039c6ce4c)\r\n",
    "issue_word_count": 70,
    "test_files_count": 2,
    "non_test_files_count": 6,
    "pr_changed_files": [
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/event/MqttMessageNotDeliveredEvent.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/MqttPahoMessageHandler.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/Mqttv5PahoMessageHandler.java",
      "spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java",
      "spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/MqttAdapterTests.java",
      "src/reference/antora/modules/ROOT/pages/mqtt.adoc",
      "src/reference/antora/modules/ROOT/pages/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java",
      "spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/MqttAdapterTests.java"
    ],
    "base_commit": "c27cc4b11cd5d59e779abb05d4a302418bdcca9f",
    "head_commit": "32536bbc3e9d4d31f3f45a8dee697a684a28a41a",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9435",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9435",
    "dockerfile": "",
    "pr_merged_at": "2024-09-04T19:31:01.000Z",
    "patch": "diff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/event/MqttMessageNotDeliveredEvent.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/event/MqttMessageNotDeliveredEvent.java\nnew file mode 100644\nindex 00000000000..4b1320b66e6\n--- /dev/null\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/event/MqttMessageNotDeliveredEvent.java\n@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.mqtt.event;\n+\n+import java.io.Serial;\n+\n+/**\n+ * An event emitted (when using aysnc) when the client indicates the message\n+ * was not delivered on publish operation.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 6.4\n+ *\n+ */\n+public class MqttMessageNotDeliveredEvent extends MqttMessageDeliveryEvent {\n+\n+\t@Serial\n+\tprivate static final long serialVersionUID = 8983514811627569920L;\n+\n+\tprivate final Throwable exception;\n+\n+\tpublic MqttMessageNotDeliveredEvent(Object source, int messageId, String clientId,\n+\t\t\tint clientInstance, Throwable exception) {\n+\n+\t\tsuper(source, messageId, clientId, clientInstance);\n+\t\tthis.exception = exception;\n+\t}\n+\n+\tpublic Throwable getException() {\n+\t\treturn this.exception;\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java\nindex 4b43a6722c9..fc1a1e36440 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2023 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -29,6 +29,9 @@\n import org.springframework.integration.handler.ExpressionEvaluatingMessageProcessor;\n import org.springframework.integration.handler.MessageProcessor;\n import org.springframework.integration.mqtt.core.ClientManager;\n+import org.springframework.integration.mqtt.event.MqttMessageDeliveredEvent;\n+import org.springframework.integration.mqtt.event.MqttMessageNotDeliveredEvent;\n+import org.springframework.integration.mqtt.event.MqttMessageSentEvent;\n import org.springframework.integration.mqtt.support.MqttHeaders;\n import org.springframework.integration.mqtt.support.MqttMessageConverter;\n import org.springframework.integration.support.management.ManageableLifecycle;\n@@ -76,6 +79,10 @@ public abstract class AbstractMqttMessageHandler<T, C> extends AbstractMessageHa\n \n \tprivate final ClientManager<T, C> clientManager;\n \n+\tprivate boolean async;\n+\n+\tprivate boolean asyncEvents;\n+\n \tprivate long completionTimeout = DEFAULT_COMPLETION_TIMEOUT;\n \n \tprivate long disconnectCompletionTimeout = DISCONNECT_COMPLETION_TIMEOUT;\n@@ -319,6 +326,32 @@ protected ClientManager<T, C> getClientManager() {\n \t\treturn this.clientManager;\n \t}\n \n+\t/**\n+\t * Set to true if you don't want to block when sending messages. Default false.\n+\t * When true, message sent/delivered events will be published for reception\n+\t * by a suitably configured 'ApplicationListener' or an event\n+\t * inbound-channel-adapter.\n+\t * @param async true for async.\n+\t * @see #setAsyncEvents(boolean)\n+\t */\n+\tpublic void setAsync(boolean async) {\n+\t\tthis.async = async;\n+\t}\n+\n+\tprotected boolean isAsync() {\n+\t\treturn this.async;\n+\t}\n+\n+\t/**\n+\t * When {@link #setAsync(boolean)} is true, setting this to true enables\n+\t * publication of {@link MqttMessageSentEvent} and {@link MqttMessageDeliveredEvent}\n+\t * to be emitted. Default false.\n+\t * @param asyncEvents the asyncEvents.\n+\t */\n+\tpublic void setAsyncEvents(boolean asyncEvents) {\n+\t\tthis.asyncEvents = asyncEvents;\n+\t}\n+\n \t@Override\n \tprotected void onInit() {\n \t\tsuper.onInit();\n@@ -372,6 +405,31 @@ protected void handleMessageInternal(Message<?> message) {\n \t\tpublish(topic, mqttMessage, message);\n \t}\n \n+\tprotected void messageSentEvent(Message<?> message, String topic, int messageId) {\n+\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n+\t\tif (this.async && this.asyncEvents && applicationEventPublisher != null) {\n+\t\t\tapplicationEventPublisher.publishEvent(\n+\t\t\t\t\tnew MqttMessageSentEvent(this, message, topic, messageId, getClientId(),\n+\t\t\t\t\t\t\tgetClientInstance()));\n+\t\t}\n+\t}\n+\n+\tprotected void sendDeliveryCompleteEvent(int messageId) {\n+\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n+\t\tif (this.async && this.asyncEvents && applicationEventPublisher != null) {\n+\t\t\tapplicationEventPublisher.publishEvent(\n+\t\t\t\t\tnew MqttMessageDeliveredEvent(this, messageId, getClientId(), getClientInstance()));\n+\t\t}\n+\t}\n+\n+\tprotected void sendFailedDeliveryEvent(int messageId, Throwable exception) {\n+\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n+\t\tif (this.async && this.asyncEvents && applicationEventPublisher != null) {\n+\t\t\tapplicationEventPublisher.publishEvent(\n+\t\t\t\t\tnew MqttMessageNotDeliveredEvent(this, messageId, getClientId(), getClientInstance(), exception));\n+\t\t}\n+\t}\n+\n \tprotected abstract void publish(String topic, Object mqttMessage, Message<?> message);\n \n }\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/MqttPahoMessageHandler.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/MqttPahoMessageHandler.java\nindex 3a565d76cc4..0e33d996cea 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/MqttPahoMessageHandler.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/MqttPahoMessageHandler.java\n@@ -16,8 +16,10 @@\n \n package org.springframework.integration.mqtt.outbound;\n \n+import org.eclipse.paho.client.mqttv3.IMqttActionListener;\n import org.eclipse.paho.client.mqttv3.IMqttAsyncClient;\n import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;\n+import org.eclipse.paho.client.mqttv3.IMqttToken;\n import org.eclipse.paho.client.mqttv3.MqttCallback;\n import org.eclipse.paho.client.mqttv3.MqttConnectOptions;\n import org.eclipse.paho.client.mqttv3.MqttException;\n@@ -29,8 +31,6 @@\n import org.springframework.integration.mqtt.core.MqttPahoClientFactory;\n import org.springframework.integration.mqtt.core.MqttPahoComponent;\n import org.springframework.integration.mqtt.event.MqttConnectionFailedEvent;\n-import org.springframework.integration.mqtt.event.MqttMessageDeliveredEvent;\n-import org.springframework.integration.mqtt.event.MqttMessageSentEvent;\n import org.springframework.integration.mqtt.support.DefaultPahoMessageConverter;\n import org.springframework.integration.mqtt.support.MqttMessageConverter;\n import org.springframework.integration.mqtt.support.MqttUtils;\n@@ -60,9 +60,7 @@ public class MqttPahoMessageHandler extends AbstractMqttMessageHandler<IMqttAsyn\n \n \tprivate final MqttPahoClientFactory clientFactory;\n \n-\tprivate boolean async;\n-\n-\tprivate boolean asyncEvents;\n+\tprivate final IMqttActionListener mqttPublishActionListener = new MqttPublishActionListener();\n \n \tprivate volatile IMqttAsyncClient client;\n \n@@ -113,29 +111,6 @@ public MqttPahoMessageHandler(ClientManager<IMqttAsyncClient, MqttConnectOptions\n \t\tthis.clientFactory = factory;\n \t}\n \n-\t/**\n-\t * Set to true if you don't want to block when sending messages. Default false.\n-\t * When true, message sent/delivered events will be published for reception\n-\t * by a suitably configured 'ApplicationListener' or an event\n-\t * inbound-channel-adapter.\n-\t * @param async true for async.\n-\t * @since 4.1\n-\t */\n-\tpublic void setAsync(boolean async) {\n-\t\tthis.async = async;\n-\t}\n-\n-\t/**\n-\t * When {@link #setAsync(boolean)} is true, setting this to true enables\n-\t * publication of {@link MqttMessageSentEvent} and {@link MqttMessageDeliveredEvent}\n-\t * to be emitted. Default false.\n-\t * @param asyncEvents the asyncEvents.\n-\t * @since 4.1\n-\t */\n-\tpublic void setAsyncEvents(boolean asyncEvents) {\n-\t\tthis.asyncEvents = asyncEvents;\n-\t}\n-\n \t@Override\n \tpublic MqttConnectOptions getConnectionInfo() {\n \t\tMqttConnectOptions options = this.clientFactory.getConnectionOptions();\n@@ -236,15 +211,12 @@ protected void publish(String topic, Object mqttMessage, Message<?> message) {\n \t\tAssert.isInstanceOf(MqttMessage.class, mqttMessage, \"The 'mqttMessage' must be an instance of 'MqttMessage'\");\n \t\ttry {\n \t\t\tIMqttDeliveryToken token = checkConnection()\n-\t\t\t\t\t.publish(topic, (MqttMessage) mqttMessage);\n-\t\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n-\t\t\tif (!this.async) {\n+\t\t\t\t\t.publish(topic, (MqttMessage) mqttMessage, null, this.mqttPublishActionListener);\n+\t\t\tif (!isAsync()) {\n \t\t\t\ttoken.waitForCompletion(getCompletionTimeout()); // NOSONAR (sync)\n \t\t\t}\n-\t\t\telse if (this.asyncEvents && applicationEventPublisher != null) {\n-\t\t\t\tapplicationEventPublisher.publishEvent(\n-\t\t\t\t\t\tnew MqttMessageSentEvent(this, message, topic, token.getMessageId(), getClientId(),\n-\t\t\t\t\t\t\t\tgetClientInstance()));\n+\t\t\telse {\n+\t\t\t\tmessageSentEvent(message, topic, token.getMessageId());\n \t\t\t}\n \t\t}\n \t\tcatch (MqttException e) {\n@@ -252,15 +224,6 @@ else if (this.asyncEvents && applicationEventPublisher != null) {\n \t\t}\n \t}\n \n-\tprivate void sendDeliveryComplete(IMqttDeliveryToken token) {\n-\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n-\t\tif (this.async && this.asyncEvents && applicationEventPublisher != null) {\n-\t\t\tapplicationEventPublisher.publishEvent(\n-\t\t\t\t\tnew MqttMessageDeliveredEvent(this, token.getMessageId(), getClientId(),\n-\t\t\t\t\t\t\tgetClientInstance()));\n-\t\t}\n-\t}\n-\n \t@Override\n \tpublic void connectionLost(Throwable cause) {\n \t\tthis.lock.lock();\n@@ -293,7 +256,24 @@ public void messageArrived(String topic, MqttMessage message) {\n \n \t@Override\n \tpublic void deliveryComplete(IMqttDeliveryToken token) {\n-\t\tsendDeliveryComplete(token);\n+\n+\t}\n+\n+\tprivate final class MqttPublishActionListener implements IMqttActionListener {\n+\n+\t\tMqttPublishActionListener() {\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onSuccess(IMqttToken asyncActionToken) {\n+\t\t\tsendDeliveryCompleteEvent(asyncActionToken.getMessageId());\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onFailure(IMqttToken asyncActionToken, Throwable exception) {\n+\t\t\tsendFailedDeliveryEvent(asyncActionToken.getMessageId(), exception);\n+\t\t}\n+\n \t}\n \n }\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/Mqttv5PahoMessageHandler.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/Mqttv5PahoMessageHandler.java\nindex 60ce021d45b..3b0af69ff2a 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/Mqttv5PahoMessageHandler.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/Mqttv5PahoMessageHandler.java\n@@ -20,6 +20,7 @@\n \n import org.eclipse.paho.mqttv5.client.IMqttAsyncClient;\n import org.eclipse.paho.mqttv5.client.IMqttToken;\n+import org.eclipse.paho.mqttv5.client.MqttActionListener;\n import org.eclipse.paho.mqttv5.client.MqttAsyncClient;\n import org.eclipse.paho.mqttv5.client.MqttCallback;\n import org.eclipse.paho.mqttv5.client.MqttClientPersistence;\n@@ -36,8 +37,6 @@\n import org.springframework.integration.mqtt.core.ClientManager;\n import org.springframework.integration.mqtt.core.MqttComponent;\n import org.springframework.integration.mqtt.event.MqttConnectionFailedEvent;\n-import org.springframework.integration.mqtt.event.MqttMessageDeliveredEvent;\n-import org.springframework.integration.mqtt.event.MqttMessageSentEvent;\n import org.springframework.integration.mqtt.event.MqttProtocolErrorEvent;\n import org.springframework.integration.mqtt.support.MqttHeaderMapper;\n import org.springframework.integration.mqtt.support.MqttMessageConverter;\n@@ -62,15 +61,13 @@ public class Mqttv5PahoMessageHandler extends AbstractMqttMessageHandler<IMqttAs\n \n \tprivate final MqttConnectionOptions connectionOptions;\n \n+\tprivate final MqttActionListener mqttPublishActionListener = new MqttPublishActionListener();\n+\n \tprivate IMqttAsyncClient mqttClient;\n \n \t@Nullable\n \tprivate MqttClientPersistence persistence;\n \n-\tprivate boolean async;\n-\n-\tprivate boolean asyncEvents;\n-\n \tprivate HeaderMapper<MqttProperties> headerMapper = new MqttHeaderMapper();\n \n \tpublic Mqttv5PahoMessageHandler(String url, String clientId) {\n@@ -118,28 +115,6 @@ public void setHeaderMapper(HeaderMapper<MqttProperties> headerMapper) {\n \t\tthis.headerMapper = headerMapper;\n \t}\n \n-\t/**\n-\t * Set to true if you don't want to block when sending messages. Default false.\n-\t * When true, message sent/delivered events will be published for reception\n-\t * by a suitably configured 'ApplicationListener' or an event\n-\t * inbound-channel-adapter.\n-\t * @param async true for async.\n-\t * @see #setAsyncEvents(boolean)\n-\t */\n-\tpublic void setAsync(boolean async) {\n-\t\tthis.async = async;\n-\t}\n-\n-\t/**\n-\t * When {@link #setAsync(boolean)} is true, setting this to true enables\n-\t * publication of {@link MqttMessageSentEvent} and {@link MqttMessageDeliveredEvent}\n-\t * to be emitted. Default false.\n-\t * @param asyncEvents the asyncEvents.\n-\t */\n-\tpublic void setAsyncEvents(boolean asyncEvents) {\n-\t\tthis.asyncEvents = asyncEvents;\n-\t}\n-\n \t@Override\n \tprotected void onInit() {\n \t\tsuper.onInit();\n@@ -268,15 +243,13 @@ protected void publish(String topic, Object mqttMessage, Message<?> message) {\n \t\t\tif (!this.mqttClient.isConnected()) {\n \t\t\t\tthis.mqttClient.connect(this.connectionOptions).waitForCompletion(completionTimeout);\n \t\t\t}\n-\t\t\tIMqttToken token = this.mqttClient.publish(topic, (MqttMessage) mqttMessage);\n-\t\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n-\t\t\tif (!this.async) {\n+\t\t\tIMqttToken token =\n+\t\t\t\t\tthis.mqttClient.publish(topic, (MqttMessage) mqttMessage, null, this.mqttPublishActionListener);\n+\t\t\tif (!isAsync()) {\n \t\t\t\ttoken.waitForCompletion(completionTimeout); // NOSONAR (sync)\n \t\t\t}\n-\t\t\telse if (this.asyncEvents && applicationEventPublisher != null) {\n-\t\t\t\tapplicationEventPublisher.publishEvent(\n-\t\t\t\t\t\tnew MqttMessageSentEvent(this, message, topic, token.getMessageId(), getClientId(),\n-\t\t\t\t\t\t\t\tgetClientInstance()));\n+\t\t\telse {\n+\t\t\t\tmessageSentEvent(message, topic, token.getMessageId());\n \t\t\t}\n \t\t}\n \t\tcatch (MqttException ex) {\n@@ -284,18 +257,9 @@ else if (this.asyncEvents && applicationEventPublisher != null) {\n \t\t}\n \t}\n \n-\tprivate void sendDeliveryComplete(IMqttToken token) {\n-\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n-\t\tif (this.async && this.asyncEvents && applicationEventPublisher != null) {\n-\t\t\tapplicationEventPublisher.publishEvent(\n-\t\t\t\t\tnew MqttMessageDeliveredEvent(this, token.getMessageId(), getClientId(),\n-\t\t\t\t\t\t\tgetClientInstance()));\n-\t\t}\n-\t}\n-\n \t@Override\n \tpublic void deliveryComplete(IMqttToken token) {\n-\t\tsendDeliveryComplete(token);\n+\n \t}\n \n \t@Override\n@@ -330,4 +294,21 @@ public void authPacketArrived(int reasonCode, MqttProperties properties) {\n \n \t}\n \n+\tprivate final class MqttPublishActionListener implements MqttActionListener {\n+\n+\t\tMqttPublishActionListener() {\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onSuccess(IMqttToken asyncActionToken) {\n+\t\t\tsendDeliveryCompleteEvent(asyncActionToken.getMessageId());\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onFailure(IMqttToken asyncActionToken, Throwable exception) {\n+\t\t\tsendFailedDeliveryEvent(asyncActionToken.getMessageId(), exception);\n+\t\t}\n+\n+\t}\n+\n }\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/mqtt.adoc b/src/reference/antora/modules/ROOT/pages/mqtt.adoc\nindex 3e0154a6262..ce0ba68ea13 100644\n--- a/src/reference/antora/modules/ROOT/pages/mqtt.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/mqtt.adoc\n@@ -399,6 +399,7 @@ Certain application events are published by the adapters.\n For the MQTT v5 Paho client, this event is also emitted when the server performs a normal disconnection, in which case the `cause` of the lost connection is `null`.\n * `MqttMessageSentEvent` - published by the outbound adapter when a message has been sent, if running in asynchronous mode.\n * `MqttMessageDeliveredEvent` - published by the outbound adapter when the client indicates that a message has been delivered, if running in asynchronous mode.\n+* `MqttMessageNotDeliveredEvent` - published by the outbound adapter when the client indicates that a message has not been delivered, if running in asynchronous mode.\n * `MqttSubscribedEvent` - published by the inbound adapter after subscribing to the topics.\n \n These events can be received by an `ApplicationListener<MqttIntegrationEvent>` or with an `@EventListener` method.\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/whats-new.adoc b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\nindex c3f3c50a62c..d92bd74f9f1 100644\n--- a/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n@@ -72,5 +72,6 @@ See xref:sftp/session-factory.adoc[SFTP Session Factory] for more information.\n === MQTT Support Changes\n \n Multiple instances of `MqttPahoMessageDrivenChannelAdapter` and `Mqttv5PahoMessageDrivenChannelAdapter` can now be added at runtime using corresponding `ClientManager` through `IntegrationFlowContext`\n+Also a `MqttMessageNotDeliveredEvent` event has been introduced to emit when action callback reacts to the delivery failure.\n See xref:mqtt.adoc[MQTT Support] for more information.\n \n",
    "test_patch": "diff --git a/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java b/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java\nindex 611fe10e37c..921e47089a6 100644\n--- a/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java\n+++ b/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java\n@@ -17,6 +17,8 @@\n package org.springframework.integration.mqtt;\n \n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n@@ -37,6 +39,7 @@\n import org.springframework.integration.endpoint.MessageProducerSupport;\n import org.springframework.integration.mqtt.core.Mqttv3ClientManager;\n import org.springframework.integration.mqtt.core.Mqttv5ClientManager;\n+import org.springframework.integration.mqtt.event.MqttMessageDeliveryEvent;\n import org.springframework.integration.mqtt.event.MqttSubscribedEvent;\n import org.springframework.integration.mqtt.inbound.MqttPahoMessageDrivenChannelAdapter;\n import org.springframework.integration.mqtt.inbound.Mqttv5PahoMessageDrivenChannelAdapter;\n@@ -49,6 +52,7 @@\n import org.springframework.messaging.PollableChannel;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n \n /**\n  * @author Artem Vozhdayenko\n@@ -92,6 +96,7 @@ void testV5ClientManagerRuntime() throws Exception {\n \t\t\t\tMqttv5ConfigRuntime.subscribedLatch);\n \t}\n \n+\t@SuppressWarnings(\"unchecked\")\n \tprivate void testSubscribeAndPublish(Class<?> configClass, String topicName, CountDownLatch subscribedLatch)\n \t\t\tthrows Exception {\n \n@@ -115,6 +120,12 @@ private void testSubscribeAndPublish(Class<?> configClass, String topicName, Cou\n \t\t\telse {\n \t\t\t\tassertThat(payload).isEqualTo(testPayload.getBytes(StandardCharsets.UTF_8));\n \t\t\t}\n+\n+\t\t\tif (ctx.containsBean(\"deliveryEvents\")) {\n+\t\t\t\tList<MqttMessageDeliveryEvent> deliveryEvents = ctx.getBean(\"deliveryEvents\", List.class);\n+\t\t\t\t// MqttMessageSentEvent and  MqttMessageDeliveredEvent\n+\t\t\t\tawait().untilAsserted(() -> assertThat(deliveryEvents).hasSize(2));\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -164,6 +175,16 @@ public void onSubscribed(MqttSubscribedEvent e) {\n \t\t\tsubscribedLatch.countDown();\n \t\t}\n \n+\t\t@EventListener\n+\t\tvoid mqttEvents(MqttMessageDeliveryEvent event) {\n+\t\t\tdeliveryEvents().add(event);\n+\t\t}\n+\n+\t\t@Bean\n+\t\tList<MqttMessageDeliveryEvent> deliveryEvents() {\n+\t\t\treturn new ArrayList<>();\n+\t\t}\n+\n \t\t@Bean\n \t\tpublic Mqttv3ClientManager mqttv3ClientManager() {\n \t\t\tMqttConnectOptions connectionOptions = new MqttConnectOptions();\n@@ -174,7 +195,10 @@ public Mqttv3ClientManager mqttv3ClientManager() {\n \n \t\t@Bean\n \t\tpublic IntegrationFlow mqttOutFlow(Mqttv3ClientManager mqttv3ClientManager) {\n-\t\t\treturn f -> f.handle(new MqttPahoMessageHandler(mqttv3ClientManager));\n+\t\t\tMqttPahoMessageHandler mqttPahoMessageHandler = new MqttPahoMessageHandler(mqttv3ClientManager);\n+\t\t\tmqttPahoMessageHandler.setAsync(true);\n+\t\t\tmqttPahoMessageHandler.setAsyncEvents(true);\n+\t\t\treturn f -> f.handle(mqttPahoMessageHandler);\n \t\t}\n \n \t\t@Bean\n@@ -257,6 +281,7 @@ public MessageProducerSupport createMessageDrivenAdapter(ApplicationContext ctx)\n \t\t\tvar clientManager = ctx.getBean(Mqttv3ClientManager.class);\n \t\t\treturn new MqttPahoMessageDrivenChannelAdapter(clientManager, TOPIC_NAME);\n \t\t}\n+\n \t}\n \n \t@Configuration\n@@ -272,6 +297,16 @@ public void onSubscribed(MqttSubscribedEvent e) {\n \t\t\tsubscribedLatch.countDown();\n \t\t}\n \n+\t\t@EventListener\n+\t\tvoid mqttEvents(MqttMessageDeliveryEvent event) {\n+\t\t\tdeliveryEvents().add(event);\n+\t\t}\n+\n+\t\t@Bean\n+\t\tList<MqttMessageDeliveryEvent> deliveryEvents() {\n+\t\t\treturn new ArrayList<>();\n+\t\t}\n+\n \t\t@Bean\n \t\tpublic Mqttv5ClientManager mqttv5ClientManager() {\n \t\t\treturn new Mqttv5ClientManager(MosquittoContainerTest.mqttUrl(), \"client-manager-client-id-v5\");\n@@ -280,7 +315,10 @@ public Mqttv5ClientManager mqttv5ClientManager() {\n \t\t@Bean\n \t\t@ServiceActivator(inputChannel = \"mqttOutFlow.input\")\n \t\tpublic Mqttv5PahoMessageHandler mqttv5PahoMessageHandler(Mqttv5ClientManager mqttv5ClientManager) {\n-\t\t\treturn new Mqttv5PahoMessageHandler(mqttv5ClientManager);\n+\t\t\tMqttv5PahoMessageHandler mqttPahoMessageHandler = new Mqttv5PahoMessageHandler(mqttv5ClientManager);\n+\t\t\tmqttPahoMessageHandler.setAsync(true);\n+\t\t\tmqttPahoMessageHandler.setAsyncEvents(true);\n+\t\t\treturn mqttPahoMessageHandler;\n \t\t}\n \n \t\t@Bean\n@@ -358,10 +396,13 @@ public MessageProducerSupport createMessageDrivenAdapter(ApplicationContext ctx)\n \t\t\tvar clientManager = ctx.getBean(Mqttv5ClientManager.class);\n \t\t\treturn new Mqttv5PahoMessageDrivenChannelAdapter(clientManager, TOPIC_NAME);\n \t\t}\n+\n \t}\n \n \tinterface MessageDrivenChannelAdapterFactory {\n+\n \t\tMessageProducerSupport createMessageDrivenAdapter(ApplicationContext ctx);\n+\n \t}\n \n \trecord ClientV3Disconnector(Mqttv3ClientManager clientManager) {\n\ndiff --git a/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/MqttAdapterTests.java b/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/MqttAdapterTests.java\nindex 8d14687a0ca..2a3588b67ba 100644\n--- a/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/MqttAdapterTests.java\n+++ b/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/MqttAdapterTests.java\n@@ -182,7 +182,7 @@ public void testOutboundOptionsApplied() throws Exception {\n \t\t\tassertThat(new String(message.getPayload())).isEqualTo(\"Hello, world!\");\n \t\t\tpublishCalled.set(true);\n \t\t\treturn deliveryToken;\n-\t\t}).given(client).publish(anyString(), any(MqttMessage.class));\n+\t\t}).given(client).publish(anyString(), any(), any(), any());\n \n \t\thandler.handleMessage(new GenericMessage<>(\"Hello, world!\"));\n \n@@ -204,7 +204,7 @@ void testClientManagerIsNotConnectedAndClosedInHandler() throws Exception {\n \t\tgiven(clientManager.getClient()).willReturn(client);\n \n \t\tvar deliveryToken = mock(MqttDeliveryToken.class);\n-\t\tgiven(client.publish(anyString(), any(MqttMessage.class))).willReturn(deliveryToken);\n+\t\tgiven(client.publish(anyString(), any(), any(), any())).willReturn(deliveryToken);\n \n \t\tvar handler = new MqttPahoMessageHandler(clientManager);\n \t\thandler.setDefaultTopic(\"mqtt-foo\");\n@@ -218,7 +218,7 @@ void testClientManagerIsNotConnectedAndClosedInHandler() throws Exception {\n \n \t\t// then\n \t\tverify(client, never()).connect(any(MqttConnectOptions.class));\n-\t\tverify(client).publish(anyString(), any(MqttMessage.class));\n+\t\tverify(client).publish(anyString(), any(), any(), any());\n \t\tverify(client, never()).disconnect();\n \t\tverify(client, never()).disconnect(anyLong());\n \t\tverify(client, never()).close();\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9431",
    "pr_id": 9431,
    "issue_id": 9430,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "TCP/IP: The cached connections are not freed when used with collaborating channel adapters on the client side\nSee more info on StackOverlfow: https://stackoverflow.com/questions/78916759/tcp-caching-connection-not-working-as-expected",
    "issue_word_count": 35,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractConnectionFactory.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/CachingClientConnectionFactory.java",
      "spring-integration-ip/src/test/java/org/springframework/integration/ip/dsl/IpIntegrationTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-ip/src/test/java/org/springframework/integration/ip/dsl/IpIntegrationTests.java"
    ],
    "base_commit": "f10fbca38ba4131f0c96c7479028fca4d21afbdd",
    "head_commit": "277947cd943ac72398499c29200dd623675fef58",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9431",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9431",
    "dockerfile": "",
    "pr_merged_at": "2024-08-30T00:39:09.000Z",
    "patch": "diff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractConnectionFactory.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractConnectionFactory.java\nindex 4007bf51331..d527f4835bd 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractConnectionFactory.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractConnectionFactory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2023 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -977,7 +977,7 @@ public boolean closeConnection(String connectionId) {\n \t\tthis.connectionsMonitor.lock();\n \t\ttry {\n \t\t\tboolean closed = false;\n-\t\t\tTcpConnectionSupport connection = this.connections.remove(connectionId);\n+\t\t\tTcpConnectionSupport connection = removeConnection(connectionId);\n \t\t\tif (connection != null) {\n \t\t\t\ttry {\n \t\t\t\t\tconnection.close();\n@@ -996,6 +996,11 @@ public boolean closeConnection(String connectionId) {\n \t\t}\n \t}\n \n+\t@Nullable\n+\tprotected TcpConnectionSupport removeConnection(String connectionId) {\n+\t\treturn this.connections.remove(connectionId);\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn super.toString()\n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/CachingClientConnectionFactory.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/CachingClientConnectionFactory.java\nindex 50c3f600bff..c5f9f65dfac 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/CachingClientConnectionFactory.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/CachingClientConnectionFactory.java\n@@ -358,6 +358,11 @@ public void enableManualListenerRegistration() {\n \t\tthis.targetConnectionFactory.enableManualListenerRegistration();\n \t}\n \n+\t@Override\n+\tprotected TcpConnectionSupport removeConnection(String connectionId) {\n+\t\treturn this.targetConnectionFactory.removeConnection(connectionId.replaceFirst(\"Cached:\", \"\"));\n+\t}\n+\n \t@Override\n \tpublic void start() {\n \t\tsetActive(true);\n",
    "test_patch": "diff --git a/spring-integration-ip/src/test/java/org/springframework/integration/ip/dsl/IpIntegrationTests.java b/spring-integration-ip/src/test/java/org/springframework/integration/ip/dsl/IpIntegrationTests.java\nindex b283e158f63..db18e206d54 100644\n--- a/spring-integration-ip/src/test/java/org/springframework/integration/ip/dsl/IpIntegrationTests.java\n+++ b/spring-integration-ip/src/test/java/org/springframework/integration/ip/dsl/IpIntegrationTests.java\n@@ -16,11 +16,14 @@\n \n package org.springframework.integration.ip.dsl;\n \n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.List;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n \n import org.aopalliance.intercept.MethodInterceptor;\n import org.junit.jupiter.api.Test;\n@@ -47,6 +50,7 @@\n import org.springframework.integration.ip.tcp.TcpSendingMessageHandler;\n import org.springframework.integration.ip.tcp.connection.AbstractClientConnectionFactory;\n import org.springframework.integration.ip.tcp.connection.AbstractServerConnectionFactory;\n+import org.springframework.integration.ip.tcp.connection.CachingClientConnectionFactory;\n import org.springframework.integration.ip.tcp.connection.TcpConnectionServerListeningEvent;\n import org.springframework.integration.ip.tcp.connection.TcpNetClientConnectionFactory;\n import org.springframework.integration.ip.tcp.connection.TcpNetServerConnectionFactory;\n@@ -55,12 +59,12 @@\n import org.springframework.integration.ip.udp.MulticastSendingMessageHandler;\n import org.springframework.integration.ip.udp.UdpServerListeningEvent;\n import org.springframework.integration.ip.udp.UnicastReceivingChannelAdapter;\n-import org.springframework.integration.ip.udp.UnicastSendingMessageHandler;\n import org.springframework.integration.ip.util.TestingUtilities;\n import org.springframework.integration.support.MessageBuilder;\n import org.springframework.integration.test.util.TestUtils;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageChannel;\n+import org.springframework.messaging.PollableChannel;\n import org.springframework.messaging.support.GenericMessage;\n import org.springframework.test.annotation.DirtiesContext;\n import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n@@ -102,9 +106,6 @@ public class IpIntegrationTests {\n \t@Autowired\n \tprivate UnicastReceivingChannelAdapter udpInbound;\n \n-\t@Autowired\n-\tprivate UnicastSendingMessageHandler udpOutbound;\n-\n \t@Autowired\n \tprivate QueueChannel udpIn;\n \n@@ -236,6 +237,45 @@ void async() {\n \t\tassertThat(TestUtils.getPropertyValue(this.tcpOutAsync, \"async\", Boolean.class)).isTrue();\n \t}\n \n+\t@Autowired\n+\tprivate AbstractServerConnectionFactory server2;\n+\n+\t@Autowired\n+\tprivate TcpNetClientConnectionFactory client3;\n+\n+\t@Autowired\n+\t@Qualifier(\"outboundFlow.input\")\n+\tMessageChannel outboundFlowInput;\n+\n+\t@Autowired\n+\tPollableChannel cachingRepliesChannel;\n+\n+\t@Test\n+\tvoid allRepliesAreReceivedViaLimitedCachingConnectionFactory() {\n+\t\tthis.client3.stop();\n+\t\tTestingUtilities.waitListening(this.server2, null);\n+\t\tthis.client3.setPort(this.server2.getPort());\n+\t\tthis.client3.start();\n+\n+\t\tList<String> expected =\n+\t\t\t\tIntStream.rangeClosed('a', 'z')\n+\t\t\t\t\t\t.mapToObj((characterCode) -> (char) characterCode)\n+\t\t\t\t\t\t.map((character) -> \"\" + character)\n+\t\t\t\t\t\t.peek((character) -> this.outboundFlowInput.send(new GenericMessage<>(character)))\n+\t\t\t\t\t\t.map(String::toUpperCase)\n+\t\t\t\t\t\t.toList();\n+\n+\t\tList<String> replies = new ArrayList<>();\n+\n+\t\tfor (int i = 0; i < expected.size(); i++) {\n+\t\t\tMessage<?> replyMessage = this.cachingRepliesChannel.receive(10_000);\n+\t\t\tassertThat(replyMessage).isNotNull();\n+\t\t\treplies.add(replyMessage.getPayload().toString());\n+\t\t}\n+\n+\t\tassertThat(replies).containsAll(expected);\n+\t}\n+\n \t@Configuration\n \t@EnableIntegration\n \tpublic static class Config {\n@@ -318,8 +358,9 @@ public ApplicationListener<UdpServerListeningEvent> events() {\n \t\t}\n \n \t\t@Bean\n-\t\tpublic TcpNetClientConnectionFactorySpec client1(TcpNetServerConnectionFactory server1) {\n-\t\t\treturn Tcp.netClient(\"localhost\", server1.getPort())\n+\t\tpublic TcpNetClientConnectionFactorySpec client1() {\n+\t\t\t// The port from server is assigned\n+\t\t\treturn Tcp.netClient(\"localhost\", 0)\n \t\t\t\t\t.serializer(TcpCodecs.crlf())\n \t\t\t\t\t.deserializer(TcpCodecs.lengthHeader1());\n \t\t}\n@@ -337,8 +378,9 @@ public QueueChannel unsolicited() {\n \t\t}\n \n \t\t@Bean\n-\t\tpublic TcpNetClientConnectionFactorySpec client2(TcpNetServerConnectionFactory server1) {\n-\t\t\treturn Tcp.netClient(\"localhost\", server1.getPort())\n+\t\tpublic TcpNetClientConnectionFactorySpec client2() {\n+\t\t\t// The port from server is assigned\n+\t\t\treturn Tcp.netClient(\"localhost\", 0)\n \t\t\t\t\t.serializer(TcpCodecs.crlf())\n \t\t\t\t\t.deserializer(TcpCodecs.lengthHeader1());\n \t\t}\n@@ -370,6 +412,45 @@ public IntegrationFlow clientTcpFlow(TcpOutboundGateway tcpOut) {\n \t\t\t\t\t.transform(Transformers.objectToString());\n \t\t}\n \n+\t\t@Bean\n+\t\tpublic TcpNetServerConnectionFactorySpec server2() {\n+\t\t\treturn Tcp.netServer(0);\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic IntegrationFlow server2Flow(TcpNetServerConnectionFactory server2) {\n+\t\t\treturn IntegrationFlow.from(Tcp.inboundGateway(server2))\n+\t\t\t\t\t.transform(Transformers.objectToString())\n+\t\t\t\t\t.<String, String>transform(String::toUpperCase)\n+\t\t\t\t\t.get();\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic TcpNetClientConnectionFactorySpec client3() {\n+\t\t\t// The port from server is assigned\n+\t\t\treturn Tcp.netClient(\"localhost\", 0);\n+\t\t}\n+\n+\t\t@Bean\n+\t\tCachingClientConnectionFactory cachingClient(TcpNetClientConnectionFactory client3) {\n+\t\t\tvar cachingClientConnectionFactory = new CachingClientConnectionFactory(client3, 10);\n+\t\t\tcachingClientConnectionFactory.setConnectionWaitTimeout(10_000);\n+\t\t\treturn cachingClientConnectionFactory;\n+\t\t}\n+\n+\t\t@Bean\n+\t\tIntegrationFlow outboundFlow(CachingClientConnectionFactory cachingClient) {\n+\t\t\treturn (flow) -> flow.handle(Tcp.outboundAdapter(cachingClient));\n+\t\t}\n+\n+\t\t@Bean\n+\t\tIntegrationFlow inboundFlow(CachingClientConnectionFactory cachingClient) {\n+\t\t\treturn IntegrationFlow.from(Tcp.inboundAdapter(cachingClient))\n+\t\t\t\t\t.transform(Transformers.objectToString())\n+\t\t\t\t\t.channel((channels) -> channels.queue(\"cachingRepliesChannel\"))\n+\t\t\t\t\t.get();\n+\t\t}\n+\n \t}\n \n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9429",
    "pr_id": 9429,
    "issue_id": 9383,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Introduce `JsonIndexAccessor`\nSpring Framework 6.2 introduces dedicated support for indexing into custom structures via a new `IndexAccessor` SPI, with a corresponding `CompilableIndexAccessor` SPI and a `ReflectiveIndexAccessor` implementation.\r\n\r\nSpring Integration should consider introducing a `JsonIndexAccessor` as a companion to the existing `JsonPropertyAccessor`, potentially removing some (if not all) of the \"indexing\" related functionality from `JsonPropertyAccessor`, thereby allowing the `JsonPropertyAccessor` to focus on property access while the `JsonIndexAccessor` focuses on index access.\r\n\r\nDocumentation on the new features in Spring Framework can be found in the [reference manual](https://docs.spring.io/spring-framework/reference/6.2/core/expressions/language-ref/properties-arrays.html#expressions-indexing-custom).\r\n\r\nIn addition, a proof-of-concept `JacksonArrayNodeIndexAccessor` can be found in Spring Framework's test suite:\r\n\r\nhttps://github.com/spring-projects/spring-framework/blob/a9a1798012242facac264cc468a23d01155f3e26/spring-expression/src/test/java/org/springframework/expression/spel/IndexingTests.java#L813-L850\r\n",
    "issue_word_count": 143,
    "test_files_count": 3,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/json/JsonIndexAccessor.java",
      "spring-integration-core/src/main/java/org/springframework/integration/json/JsonPropertyAccessor.java",
      "spring-integration-core/src/test/java/org/springframework/integration/json/AbstractJsonAccessorTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/json/JsonIndexAccessorTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/json/JsonPropertyAccessorTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/json/AbstractJsonAccessorTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/json/JsonIndexAccessorTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/json/JsonPropertyAccessorTests.java"
    ],
    "base_commit": "f10fbca38ba4131f0c96c7479028fca4d21afbdd",
    "head_commit": "aac854c31a587d53d131670dfbe1ce5a72a32359",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9429",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9429",
    "dockerfile": "",
    "pr_merged_at": "2024-09-04T14:25:46.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/json/JsonIndexAccessor.java b/spring-integration-core/src/main/java/org/springframework/integration/json/JsonIndexAccessor.java\nnew file mode 100644\nindex 00000000000..8a7270762a5\n--- /dev/null\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/json/JsonIndexAccessor.java\n@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2013-2024 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.json;\n+\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+\n+import org.springframework.expression.AccessException;\n+import org.springframework.expression.EvaluationContext;\n+import org.springframework.expression.IndexAccessor;\n+import org.springframework.expression.TypedValue;\n+import org.springframework.lang.Nullable;\n+\n+/**\n+ * A SpEL {@link IndexAccessor} that knows how to read indexes from JSON arrays, using\n+ * Jackson's {@link ArrayNode} API.\n+ *\n+ * <p>Supports indexes supplied as an integer literal &mdash; for example, {@code myJsonArray[1]}.\n+ * Also supports negative indexes &mdash; for example, {@code myJsonArray[-1]} which equates\n+ * to {@code myJsonArray[myJsonArray.length - 1]}. Furthermore, {@code null} is returned for\n+ * any index that is out of bounds (see {@link ArrayNode#get(int)} for details).\n+ *\n+ * @author Sam Brannen\n+ * @since 6.4\n+ * @see JsonPropertyAccessor\n+ */\n+public class JsonIndexAccessor implements IndexAccessor {\n+\n+\tprivate static final Class<?>[] SUPPORTED_CLASSES = { ArrayNode.class };\n+\n+\t@Override\n+\tpublic Class<?>[] getSpecificTargetClasses() {\n+\t\treturn SUPPORTED_CLASSES;\n+\t}\n+\n+\t@Override\n+\tpublic boolean canRead(EvaluationContext context, Object target, Object index) {\n+\t\treturn (target instanceof ArrayNode && index instanceof Integer);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValue read(EvaluationContext context, Object target, Object index) throws AccessException {\n+\t\tArrayNode arrayNode = (ArrayNode) target;\n+\t\tInteger intIndex = (Integer) index;\n+\t\tif (intIndex < 0) {\n+\t\t\t// negative index: get from the end of array, for compatibility with JsonPropertyAccessor.ArrayNodeAsList.\n+\t\t\tintIndex = arrayNode.size() + intIndex;\n+\t\t}\n+\t\treturn JsonPropertyAccessor.typedValue(arrayNode.get(intIndex));\n+\t}\n+\n+\t@Override\n+\tpublic boolean canWrite(EvaluationContext context, Object target, Object index) {\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic void write(EvaluationContext context, Object target, Object index, @Nullable Object newValue) {\n+\t\tthrow new UnsupportedOperationException(\"Write is not supported\");\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/json/JsonPropertyAccessor.java b/spring-integration-core/src/main/java/org/springframework/integration/json/JsonPropertyAccessor.java\nindex 966e3cc719d..feae2feafdb 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/json/JsonPropertyAccessor.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/json/JsonPropertyAccessor.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2023 the original author or authors.\n+ * Copyright 2013-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -24,6 +24,7 @@\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.NullNode;\n \n import org.springframework.expression.AccessException;\n import org.springframework.expression.EvaluationContext;\n@@ -35,7 +36,7 @@\n \n /**\n  * A SpEL {@link PropertyAccessor} that knows how to read properties from JSON objects.\n- * Uses Jackson {@link JsonNode} API for nested properties access.\n+ * <p>Uses Jackson {@link JsonNode} API for nested properties access.\n  *\n  * @author Eric Bottard\n  * @author Artem Bilan\n@@ -43,8 +44,10 @@\n  * @author Gary Russell\n  * @author Pierre Lakreb\n  * @author Vladislav Fefelov\n+ * @author Sam Brannen\n  *\n  * @since 3.0\n+ * @see JsonIndexAccessor\n  */\n public class JsonPropertyAccessor implements PropertyAccessor {\n \n@@ -80,23 +83,22 @@ public boolean canRead(EvaluationContext context, Object target, String name) th\n \t\t\t// Cannot parse - treat as not a JSON\n \t\t\treturn false;\n \t\t}\n-\t\tInteger index = maybeIndex(name);\n \t\tif (node instanceof ArrayNode) {\n-\t\t\treturn index != null;\n+\t\t\treturn maybeIndex(name) != null;\n \t\t}\n \t\treturn true;\n \t}\n \n \tprivate JsonNode asJson(Object target) throws AccessException {\n-\t\tif (target instanceof JsonNode) {\n-\t\t\treturn (JsonNode) target;\n+\t\tif (target instanceof JsonNode jsonNode) {\n+\t\t\treturn jsonNode;\n \t\t}\n-\t\telse if (target instanceof JsonNodeWrapper) {\n-\t\t\treturn ((JsonNodeWrapper<?>) target).getRealNode();\n+\t\telse if (target instanceof JsonNodeWrapper<?> jsonNodeWrapper) {\n+\t\t\treturn jsonNodeWrapper.getRealNode();\n \t\t}\n-\t\telse if (target instanceof String) {\n+\t\telse if (target instanceof String content) {\n \t\t\ttry {\n-\t\t\t\treturn this.objectMapper.readTree((String) target);\n+\t\t\t\treturn this.objectMapper.readTree(content);\n \t\t\t}\n \t\t\tcatch (JsonProcessingException e) {\n \t\t\t\tthrow new AccessException(\"Exception while trying to deserialize String\", e);\n@@ -160,8 +162,8 @@ private static boolean isNumeric(String str) {\n \t\treturn true;\n \t}\n \n-\tprivate static TypedValue typedValue(JsonNode json) throws AccessException {\n-\t\tif (json == null) {\n+\tstatic TypedValue typedValue(JsonNode json) throws AccessException {\n+\t\tif (json == null || json instanceof NullNode) {\n \t\t\treturn TypedValue.NULL;\n \t\t}\n \t\telse if (json.isValueNode()) {\n@@ -199,8 +201,8 @@ public static Object wrap(JsonNode json) throws AccessException {\n \t\tif (json == null) {\n \t\t\treturn null;\n \t\t}\n-\t\telse if (json instanceof ArrayNode) {\n-\t\t\treturn new ArrayNodeAsList((ArrayNode) json);\n+\t\telse if (json instanceof ArrayNode arrayNode) {\n+\t\t\treturn new ArrayNodeAsList(arrayNode);\n \t\t}\n \t\telse if (json.isValueNode()) {\n \t\t\treturn getValue(json);\n@@ -212,8 +214,6 @@ else if (json.isValueNode()) {\n \n \tinterface JsonNodeWrapper<T> extends Comparable<T> {\n \n-\t\tString toString();\n-\n \t\tJsonNode getRealNode();\n \n \t}\n@@ -309,10 +309,8 @@ public Object next() {\n \n \t\t@Override\n \t\tpublic int compareTo(Object o) {\n-\t\t\tif (o instanceof JsonNodeWrapper<?>) {\n-\t\t\t\treturn this.delegate.equals(((JsonNodeWrapper<?>) o).getRealNode()) ? 0 : 1;\n-\t\t\t}\n-\t\t\treturn this.delegate.equals(o) ? 0 : 1;\n+\t\t\tObject that = (o instanceof JsonNodeWrapper<?> wrapper ? wrapper.getRealNode() : o);\n+\t\t\treturn this.delegate.equals(that) ? 0 : 1;\n \t\t}\n \n \t}\n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/json/AbstractJsonAccessorTests.java b/spring-integration-core/src/test/java/org/springframework/integration/json/AbstractJsonAccessorTests.java\nnew file mode 100644\nindex 00000000000..c0d4c58e63a\n--- /dev/null\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/json/AbstractJsonAccessorTests.java\n@@ -0,0 +1,366 @@\n+/*\n+ * Copyright 2013-2024 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.json;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import org.springframework.core.convert.support.DefaultConversionService;\n+import org.springframework.expression.Expression;\n+import org.springframework.expression.spel.SpelEvaluationException;\n+import org.springframework.expression.spel.SpelMessage;\n+import org.springframework.expression.spel.standard.SpelExpressionParser;\n+import org.springframework.expression.spel.support.StandardEvaluationContext;\n+import org.springframework.expression.spel.support.StandardTypeConverter;\n+import org.springframework.integration.json.JsonPropertyAccessor.ArrayNodeAsList;\n+import org.springframework.integration.json.JsonPropertyAccessor.ComparableJsonNode;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+\n+/**\n+ * Abstract base class for tests involving {@link JsonPropertyAccessor} and {@link JsonIndexAccessor}.\n+ *\n+ * @author Eric Bottard\n+ * @author Artem Bilan\n+ * @author Paul Martin\n+ * @author Pierre Lakreb\n+ * @author Sam Brannen\n+ *\n+ * @since 3.0\n+ */\n+abstract class AbstractJsonAccessorTests {\n+\n+\tprotected final SpelExpressionParser parser = new SpelExpressionParser();\n+\n+\tprotected final ObjectMapper mapper = new ObjectMapper();\n+\n+\tprotected final StandardEvaluationContext context = new StandardEvaluationContext();\n+\n+\t@BeforeEach\n+\tvoid setUpEvaluationContext() {\n+\t\tDefaultConversionService conversionService = new DefaultConversionService();\n+\t\tconversionService.addConverter(new JsonNodeWrapperToJsonNodeConverter());\n+\t\tcontext.setTypeConverter(new StandardTypeConverter(conversionService));\n+\t}\n+\n+\t/**\n+\t * Tests for JSON accessors that use an instance of {@link JsonNode} as the\n+\t * root context object.\n+\t */\n+\t@Nested\n+\tclass JsonNodeTests {\n+\n+\t\t@Test\n+\t\tvoid textNode() throws Exception {\n+\t\t\tTextNode json = (TextNode) mapper.readTree(\"\\\"foo\\\"\");\n+\t\t\tString result = evaluate(json, \"#root\", String.class);\n+\t\t\tassertThat(result).isEqualTo(\"\\\"foo\\\"\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid nullProperty() throws Exception {\n+\t\t\tJsonNode json = mapper.readTree(\"{\\\"foo\\\": null}\");\n+\t\t\tassertThat(evaluate(json, \"foo\", String.class)).isNull();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid missingProperty() throws Exception {\n+\t\t\tJsonNode json = mapper.readTree(FOO_BAR_JSON);\n+\t\t\tassertThat(evaluate(json, \"fizz\", String.class)).isNull();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid propertyLookup() throws Exception {\n+\t\t\tJsonNode json1 = mapper.readTree(FOO_BAR_JSON);\n+\t\t\tString value1 = evaluate(json1, \"foo\", String.class);\n+\t\t\tassertThat(value1).isEqualTo(\"bar\");\n+\t\t\tJsonNode json2 = mapper.readTree(FOO_BAR_JSON);\n+\t\t\tString value2 = evaluate(json2, \"foo\", String.class);\n+\t\t\tassertThat(value1).isEqualTo(value2).hasSameHashCodeAs(value2);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid arrayLookupWithIntegerIndexAndExplicitWrapping() throws Exception {\n+\t\t\tArrayNode json = (ArrayNode) mapper.readTree(\"[3, 4, 5]\");\n+\t\t\t// Have to wrap the root array because ArrayNode itself is not a List\n+\t\t\tInteger actual = evaluate(JsonPropertyAccessor.wrap(json), \"[1]\", Integer.class);\n+\t\t\tassertThat(actual).isEqualTo(4);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid arrayLookupWithIntegerIndexForNullValueAndExplicitWrapping() throws Exception {\n+\t\t\tArrayNode json = (ArrayNode) mapper.readTree(\"[3, null, 5]\");\n+\t\t\t// Have to wrap the root array because ArrayNode itself is not a List\n+\t\t\tInteger actual = evaluate(JsonPropertyAccessor.wrap(json), \"[1]\", Integer.class);\n+\t\t\tassertThat(actual).isNull();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid arrayLookupWithNegativeIntegerIndex() throws Exception {\n+\t\t\tJsonNode json = mapper.readTree(\"{\\\"foo\\\": [3, 4, 5]}\");\n+\t\t\t// ArrayNodeAsList allows one to index into a JSON array via a negative index.\n+\t\t\tassertThat(evaluate(json, \"foo[-1]\", Integer.class)).isEqualTo(5);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid arrayLookupWithNegativeIntegerIndexGreaterThanArrayLength() throws Exception {\n+\t\t\tJsonNode json = mapper.readTree(\"{\\\"foo\\\": [3, 4, 5]}\");\n+\t\t\t// Although ArrayNodeAsList allows one to index into a JSON array via a negative\n+\t\t\t// index, if the result of (array.length - index) is still negative, Jackson's\n+\t\t\t// ArrayNode.get() method returns null instead of throwing an IndexOutOfBoundsException.\n+\t\t\tassertThat(evaluate(json, \"foo[-99]\", Integer.class)).isNull();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid arrayLookupWithNegativeIntegerIndexForNullValue() throws Exception {\n+\t\t\tJsonNode json = mapper.readTree(\"{\\\"foo\\\": [3, 4, null]}\");\n+\t\t\t// ArrayNodeAsList allows one to index into a JSON array via a negative index.\n+\t\t\tassertThat(evaluate(json, \"foo[-1]\", Integer.class)).isNull();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid arrayLookupWithIntegerIndexOutOfBounds() throws Exception {\n+\t\t\tJsonNode json = mapper.readTree(\"{\\\"foo\\\": [3, 4, 5]}\");\n+\t\t\tassertThatExceptionOfType(SpelEvaluationException.class)\n+\t\t\t\t\t.isThrownBy(() -> evaluate(json, \"foo[3]\", Object.class))\n+\t\t\t\t\t.satisfies(ex -> assertThat(ex.getMessageCode()).isEqualTo(SpelMessage.COLLECTION_INDEX_OUT_OF_BOUNDS));\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid arrayLookupWithStringIndex() throws Exception {\n+\t\t\tJsonNode json = mapper.readTree(\"[3, 4, 5]\");\n+\t\t\tInteger actual = evaluate(json, \"['1']\", Integer.class);\n+\t\t\tassertThat(actual).isEqualTo(4);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid nestedArrayLookupWithIntegerIndexAndExplicitWrapping() throws Exception {\n+\t\t\tArrayNode json = (ArrayNode) mapper.readTree(\"[[3], [4, 5], []]\");\n+\t\t\t// JsonNode actual = evaluate(json, \"1.1\", JsonNode.class); // Does not work\n+\t\t\tObject actual = evaluate(JsonPropertyAccessor.wrap(json), \"[1][1]\", Object.class);\n+\t\t\tassertThat(actual).isEqualTo(5);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid nestedArrayLookupWithStringIndex() throws Exception {\n+\t\t\tJsonNode json = mapper.readTree(\"[[3], [4, 5], []]\");\n+\t\t\tInteger actual = evaluate(json, \"['1']['1']\", Integer.class);\n+\t\t\tassertThat(actual).isEqualTo(5);\n+\t\t}\n+\n+\t\t@Test\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tvoid nestedArrayLookupWithStringIndexAndThenIntegerIndex() throws Exception {\n+\t\t\tArrayNode arrayNode = (ArrayNode) mapper.readTree(\"[[3], [4, 5], []]\");\n+\n+\t\t\tList<Integer> list = evaluate(arrayNode, \"['0']\", List.class);\n+\t\t\tassertThat(list).isInstanceOf(ArrayNodeAsList.class).containsExactly(3);\n+\t\t\tlist = evaluate(arrayNode, \"['2']\", List.class);\n+\t\t\tassertThat(list).isInstanceOf(ArrayNodeAsList.class).isEmpty();\n+\n+\t\t\tInteger number = evaluate(arrayNode, \"['0'][0]\", Integer.class);\n+\t\t\tassertThat(number).isEqualTo(3);\n+\t\t\tnumber = evaluate(arrayNode, \"['1'][1]\", Integer.class);\n+\t\t\tassertThat(number).isEqualTo(5);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid arrayProjection() throws Exception {\n+\t\t\tJsonNode json = mapper.readTree(FOO_BAR_ARRAY_FIZZ_JSON);\n+\n+\t\t\t// Filter the bar array to return only the fizz value of each element (to prove that SpEL considers bar\n+\t\t\t// an array/list)\n+\t\t\tList<?> actualArray = evaluate(json, \"foo.bar.![fizz]\", List.class);\n+\t\t\tassertThat(actualArray).hasSize(3);\n+\t\t\tassertThat(evaluate(actualArray, \"[0]\", Object.class)).isEqualTo(5);\n+\t\t\tassertThat(evaluate(actualArray, \"[1]\", Object.class)).isEqualTo(7);\n+\t\t\tassertThat(evaluate(actualArray, \"[2]\", Object.class)).isEqualTo(8);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid arraySelection() throws Exception {\n+\t\t\tJsonNode json = mapper.readTree(FOO_BAR_ARRAY_FIZZ_JSON);\n+\n+\t\t\t// Filter bar objects so that none match\n+\t\t\tList<?> actualArray = evaluate(json, \"foo.bar.?[fizz == 0]\", List.class);\n+\t\t\tassertThat(actualArray).isEmpty();\n+\n+\t\t\t// Filter bar objects so that one match\n+\t\t\tactualArray = evaluate(json, \"foo.bar.?[fizz == 8]\", List.class);\n+\t\t\tassertThat(actualArray).hasSize(1);\n+\t\t\tassertThat(((ComparableJsonNode) actualArray.get(0)).getRealNode()).isEqualTo(mapper.readTree(\"{\\\"fizz\\\": 8}\"));\n+\n+\t\t\t// Filter bar objects so several match\n+\t\t\tactualArray = evaluate(json, \"foo.bar.?[fizz > 6]\", List.class);\n+\t\t\tassertThat(actualArray).hasSize(2);\n+\t\t\tassertThat(((ComparableJsonNode) actualArray.get(0)).getRealNode()).isEqualTo(mapper.readTree(\"{\\\"fizz\\\": 7}\"));\n+\t\t\tassertThat(((ComparableJsonNode) actualArray.get(1)).getRealNode()).isEqualTo(mapper.readTree(\"{\\\"fizz\\\": 8}\"));\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid nestedPropertyAccessViaJsonNode() throws Exception {\n+\t\t\tJsonNode json = mapper.readTree(FOO_BAR_FIZZ_JSON);\n+\n+\t\t\tassertThat(evaluate(json, \"foo.bar\", Integer.class)).isEqualTo(4);\n+\t\t\tassertThat(evaluate(json, \"foo.fizz\", Integer.class)).isEqualTo(5);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid noNullPointerExceptionWithCachedReadAccessor() throws Exception {\n+\t\t\tExpression expression = parser.parseExpression(\"foo\");\n+\t\t\tJsonNode json1 = mapper.readTree(FOO_BAR_JSON);\n+\t\t\tString value1 = expression.getValue(context, json1, String.class);\n+\t\t\tassertThat(value1).isEqualTo(\"bar\");\n+\t\t\tJsonNode json2 = mapper.readTree(\"{}\");\n+\t\t\tObject value2 = expression.getValue(context, json2);\n+\t\t\tassertThat(value2).isNull();\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * Tests for JSON accessors that use a String-representation of a JSON document\n+\t * as the root context object.\n+\t */\n+\t@Nested\n+\tclass JsonAsStringTests {\n+\n+\t\t@Test\n+\t\tvoid selectorAccess() {\n+\t\t\tString actual = evaluate(PROPERTY_NAMES_JSON, \"property.^[name == 'value1'].name\", String.class);\n+\t\t\tassertThat(actual).isEqualTo(\"value1\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid nestedPropertyAccessViaJsonAsString() throws Exception {\n+\t\t\tString json = FOO_BAR_FIZZ_JSON;\n+\n+\t\t\tassertThat(evaluate(json, \"foo.bar\", Integer.class)).isEqualTo(4);\n+\t\t\tassertThat(evaluate(json, \"foo.fizz\", Integer.class)).isEqualTo(5);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid jsonGetValueConversionAsJsonNode() throws Exception {\n+\t\t\t// use JsonNode conversion\n+\t\t\tJsonNode node = evaluate(PROPERTY_NAMES_JSON, \"property.^[name == 'value1']\", JsonNode.class);\n+\t\t\tassertThat(node).isEqualTo(mapper.readTree(\"{\\\"name\\\":\\\"value1\\\"}\"));\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid jsonGetValueConversionAsObjectNode() throws Exception {\n+\t\t\t// use ObjectNode conversion\n+\t\t\tObjectNode node = evaluate(PROPERTY_NAMES_JSON, \"property.^[name == 'value1']\", ObjectNode.class);\n+\t\t\tassertThat(node).isEqualTo(mapper.readTree(\"{\\\"name\\\":\\\"value1\\\"}\"));\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid jsonGetValueConversionAsArrayNode() throws Exception {\n+\t\t\t// use ArrayNode conversion\n+\t\t\tArrayNode node = evaluate(PROPERTY_NAMES_JSON, \"property\", ArrayNode.class);\n+\t\t\tassertThat(node).isEqualTo(mapper.readTree(\"[{\\\"name\\\":\\\"value1\\\"},{\\\"name\\\":\\\"value2\\\"}]\"));\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid comparingArrayNode() throws Exception {\n+\t\t\tBoolean actual = evaluate(PROPERTIES_WITH_NAMES_JSON, \"property1 eq property2\", Boolean.class);\n+\t\t\tassertThat(actual).isTrue();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid comparingJsonNode() throws Exception {\n+\t\t\tBoolean actual = evaluate(PROPERTIES_WITH_NAMES_JSON, \"property1[0] eq property2[0]\", Boolean.class);\n+\t\t\tassertThat(actual).isTrue();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid unsupportedString() {\n+\t\t\tString xml = \"<what>?</what>\";\n+\t\t\tassertThatExceptionOfType(SpelEvaluationException.class)\n+\t\t\t\t\t.isThrownBy(() -> evaluate(xml, \"what\", Object.class));\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid unsupportedJson() {\n+\t\t\tString json = \"\\\"literal\\\"\";\n+\t\t\tassertThat(evaluate(json, \"foo\", Object.class)).isNull();\n+\t\t}\n+\n+\t}\n+\n+\tprotected <T> T evaluate(Object rootObject, String expression, Class<T> expectedType) {\n+\t\treturn parser.parseExpression(expression).getValue(context, rootObject, expectedType);\n+\t}\n+\n+\tprivate static final String FOO_BAR_JSON = \"\"\"\n+\t\t\t{\n+\t\t\t\t\"foo\": \"bar\"\n+\t\t\t}\n+\t\t\t\"\"\";\n+\n+\tprivate static final String FOO_BAR_FIZZ_JSON = \"\"\"\n+\t\t\t{\n+\t\t\t\t\"foo\": {\n+\t\t\t\t\t\"bar\":  4,\n+\t\t\t\t\t\"fizz\": 5\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\"\"\";\n+\n+\tprivate static final String FOO_BAR_ARRAY_FIZZ_JSON = \"\"\"\n+\t\t\t{\n+\t\t\t\t\"foo\": {\n+\t\t\t\t\t\"bar\": [\n+\t\t\t\t\t\t{\"fizz\": 5, \"buzz\": 6},\n+\t\t\t\t\t\t{\"fizz\": 7},\n+\t\t\t\t\t\t{\"fizz\": 8}\n+\t\t\t\t\t]\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\"\"\";\n+\n+\tprivate static final String PROPERTY_NAMES_JSON = \"\"\"\n+\t\t\t{\n+\t\t\t\t\"property\" : [\n+\t\t\t\t\t{\"name\": \"value1\"},\n+\t\t\t\t\t{\"name\": \"value2\"}\n+\t\t\t\t]\n+\t\t\t}\n+\t\t\t\"\"\";\n+\n+\tprivate static final String PROPERTIES_WITH_NAMES_JSON = \"\"\"\n+\t\t\t{\n+\t\t\t\t\"property1\": [\n+\t\t\t\t\t{\"name\": \"value1\"},\n+\t\t\t\t\t{\"name\": \"value2\"}\n+\t\t\t\t],\n+\t\t\t\t\"property2\": [\n+\t\t\t\t\t{\"name\": \"value1\"},\n+\t\t\t\t\t{\"name\": \"value2\"}\n+\t\t\t\t]\n+\t\t\t}\n+\t\t\t\"\"\";\n+\n+}\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/json/JsonIndexAccessorTests.java b/spring-integration-core/src/test/java/org/springframework/integration/json/JsonIndexAccessorTests.java\nnew file mode 100644\nindex 00000000000..250a2c2142d\n--- /dev/null\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/json/JsonIndexAccessorTests.java\n@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2013-2024 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.json;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import org.springframework.integration.json.JsonPropertyAccessor.ArrayNodeAsList;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+/**\n+ * Tests for {@link JsonIndexAccessor} combined with {@link JsonPropertyAccessor}.\n+ *\n+ * @author Sam Brannen\n+ * @since 6.4\n+ * @see JsonPropertyAccessorTests\n+ */\n+class JsonIndexAccessorTests extends AbstractJsonAccessorTests {\n+\n+\t@BeforeEach\n+\tvoid registerJsonAccessors() {\n+\t\tcontext.addIndexAccessor(new JsonIndexAccessor());\n+\t\t// We also register a JsonPropertyAccessor to ensure that the JsonIndexAccessor\n+\t\t// does not interfere with the feature set of the JsonPropertyAccessor.\n+\t\tcontext.addPropertyAccessor(new JsonPropertyAccessor());\n+\t}\n+\n+\t/**\n+\t * Tests which index directly into a Jackson {@link ArrayNode}, which is only supported\n+\t * by {@link JsonIndexAccessor}.\n+\t */\n+\t@Nested\n+\tclass ArrayNodeTests {\n+\n+\t\t@Test\n+\t\tvoid indexDirectlyIntoArrayNodeWithIntegerIndex() throws Exception {\n+\t\t\tArrayNode arrayNode = (ArrayNode) mapper.readTree(\"[3, 4, 5]\");\n+\t\t\tInteger actual = evaluate(arrayNode, \"[1]\", Integer.class);\n+\t\t\tassertThat(actual).isEqualTo(4);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid indexDirectlyIntoArrayNodeWithIntegerIndexForNullValue() throws Exception {\n+\t\t\tArrayNode arrayNode = (ArrayNode) mapper.readTree(\"[3, null, 5]\");\n+\t\t\tInteger actual = evaluate(arrayNode, \"[1]\", Integer.class);\n+\t\t\tassertThat(actual).isNull();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid indexDirectlyIntoArrayNodeWithNegativeIntegerIndex() throws Exception {\n+\t\t\tArrayNode arrayNode = (ArrayNode) mapper.readTree(\"[3, 4, 5]\");\n+\t\t\tInteger actual = evaluate(arrayNode, \"[-1]\", Integer.class);\n+\t\t\t// JsonIndexAccessor allows one to index into a JSON array via a negative index.\n+\t\t\tassertThat(actual).isEqualTo(5);\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid indexDirectlyIntoArrayNodeWithNegativeIntegerIndexGreaterThanArrayLength() throws Exception {\n+\t\t\tArrayNode arrayNode = (ArrayNode) mapper.readTree(\"[3, 4, 5]\");\n+\t\t\tInteger actual = evaluate(arrayNode, \"[-99]\", Integer.class);\n+\t\t\t// Although JsonIndexAccessor allows one to index into a JSON array via a negative\n+\t\t\t// index, if the result of (array.length - index) is still negative, Jackson's\n+\t\t\t// ArrayNode.get() method returns null instead of throwing an IndexOutOfBoundsException.\n+\t\t\tassertThat(actual).isNull();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid indexDirectlyIntoArrayNodeWithIntegerIndexOutOfBounds() throws Exception {\n+\t\t\tArrayNode arrayNode = (ArrayNode) mapper.readTree(\"[3, 4, 5]\");\n+\t\t\tInteger actual = evaluate(arrayNode, \"[9999]\", Integer.class);\n+\t\t\t// Jackson's ArrayNode.get() method always returns null instead of throwing an IndexOutOfBoundsException.\n+\t\t\tassertThat(actual).isNull();\n+\t\t}\n+\n+\t\t/**\n+\t\t * @see AbstractJsonAccessorTests.JsonNodeTests#nestedArrayLookupWithStringIndexAndThenIntegerIndex()\n+\t\t */\n+\t\t@Test\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tvoid nestedArrayLookupsWithIntegerIndexes() throws Exception {\n+\t\t\tArrayNode arrayNode = (ArrayNode) mapper.readTree(\"[[3], [4, 5], []]\");\n+\n+\t\t\tList<Integer> list = evaluate(arrayNode, \"[0]\", List.class);\n+\t\t\tassertThat(list).isInstanceOf(ArrayNodeAsList.class).containsExactly(3);\n+\t\t\tlist = evaluate(arrayNode, \"[2]\", List.class);\n+\t\t\tassertThat(list).isInstanceOf(ArrayNodeAsList.class).isEmpty();\n+\n+\t\t\tInteger number = evaluate(arrayNode, \"[0][0]\", Integer.class);\n+\t\t\tassertThat(number).isEqualTo(3);\n+\t\t\tnumber = evaluate(arrayNode, \"[1][1]\", Integer.class);\n+\t\t\tassertThat(number).isEqualTo(5);\n+\t\t}\n+\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/json/JsonPropertyAccessorTests.java b/spring-integration-core/src/test/java/org/springframework/integration/json/JsonPropertyAccessorTests.java\nindex 0a425fbf1d5..2cdf158b6dc 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/json/JsonPropertyAccessorTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/json/JsonPropertyAccessorTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2022 the original author or authors.\n+ * Copyright 2013-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,22 +16,13 @@\n \n package org.springframework.integration.json;\n \n-import java.util.List;\n-\n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.node.ArrayNode;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n \n-import org.springframework.core.convert.converter.ConverterRegistry;\n-import org.springframework.core.convert.support.DefaultConversionService;\n-import org.springframework.expression.Expression;\n import org.springframework.expression.spel.SpelEvaluationException;\n-import org.springframework.expression.spel.standard.SpelExpressionParser;\n-import org.springframework.expression.spel.support.StandardEvaluationContext;\n-import org.springframework.integration.json.JsonPropertyAccessor.ComparableJsonNode;\n+import org.springframework.expression.spel.SpelMessage;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n@@ -43,232 +34,64 @@\n  * @author Artem Bilan\n  * @author Paul Martin\n  * @author Pierre Lakreb\n+ * @author Sam Brannen\n  *\n  * @since 3.0\n+ * @see JsonIndexAccessorTests\n  */\n-public class JsonPropertyAccessorTests {\n-\n-\tprivate final SpelExpressionParser parser = new SpelExpressionParser();\n-\n-\tprivate final StandardEvaluationContext context = new StandardEvaluationContext();\n-\n-\tprivate final ObjectMapper mapper = new ObjectMapper();\n+class JsonPropertyAccessorTests extends AbstractJsonAccessorTests {\n \n \t@BeforeEach\n-\tpublic void setup() {\n+\tvoid registerJsonPropertyAccessor() {\n \t\tcontext.addPropertyAccessor(new JsonPropertyAccessor());\n-\t\tConverterRegistry converterRegistry = (ConverterRegistry) DefaultConversionService.getSharedInstance();\n-\t\tconverterRegistry.addConverter(new JsonNodeWrapperToJsonNodeConverter());\n-\t}\n-\n-\t@Test\n-\tpublic void testSimpleLookup() throws Exception {\n-\t\tJsonNode json = mapper.readTree(\"{\\\"foo\\\": \\\"bar\\\"}\");\n-\t\tString value = evaluate(json, \"foo\", String.class);\n-\t\tassertThat(value).isInstanceOf(String.class);\n-\t\tassertThat(value).isEqualTo(\"bar\");\n-\t\tJsonNode json2 = mapper.readTree(\"{\\\"foo\\\": \\\"bar\\\"}\");\n-\t\tString value2 = evaluate(json2, \"foo\", String.class);\n-\t\tassertThat(value2).isInstanceOf(String.class);\n-\t\tassertThat(value.equals(value2)).isTrue();\n-\t\tassertThat(value2.hashCode()).isEqualTo(value.hashCode());\n-\t}\n-\n-\t@Test\n-\tpublic void testTextNode() throws Exception {\n-\t\tJsonNode json = mapper.readTree(\"\\\"foo\\\"\");\n-\t\tString result = evaluate(json, \"#root\", String.class);\n-\t\tassertThat(result).isEqualTo(\"\\\"foo\\\"\");\n-\t}\n-\n-\t@Test\n-\tpublic void testMissingProperty() throws Exception {\n-\t\tJsonNode json = mapper.readTree(\"{\\\"foo\\\": \\\"bar\\\"}\");\n-\t\tassertThat(evaluate(json, \"fizz\", String.class)).isNull();\n-\t}\n-\n-\t@Test\n-\tpublic void testArrayLookup() throws Exception {\n-\t\tArrayNode json = (ArrayNode) mapper.readTree(\"[3, 4, 5]\");\n-\t\t// Have to wrap the root array because ArrayNode itself is not a List\n-\t\tInteger actual = evaluate(JsonPropertyAccessor.wrap(json), \"[1]\", Integer.class);\n-\t\tassertThat(actual).isEqualTo(4);\n-\t}\n-\n-\t@Test\n-\tpublic void testArrayNegativeIndex() throws Exception {\n-\t\tJsonNode json = mapper.readTree(\"{\\\"foo\\\":[3, 4, 5]}\");\n-\t\t// help access json list items with json-path negative index\n-\t\tassertThat(evaluate(json, \"foo[-1]\", Integer.class)).isEqualTo(5);\n-\t}\n-\n-\t@Test\n-\tpublic void testArrayIndexOutOfBounds() throws Exception {\n-\t\tJsonNode json = mapper.readTree(\"{\\\"foo\\\":[3, 4, 5]}\");\n-\t\tassertThatExceptionOfType(SpelEvaluationException.class)\n-\t\t\t\t.isThrownBy(() -> evaluate(json, \"foo[3]\", Object.class));\n-\t}\n-\n-\t@Test\n-\tpublic void testArrayLookupWithStringIndex() throws Exception {\n-\t\tJsonNode json = mapper.readTree(\"[3, 4, 5]\");\n-\t\tInteger actual = evaluate(json, \"['1']\", Integer.class);\n-\t\tassertThat(actual).isEqualTo(4);\n-\t}\n-\n-\t@Test\n-\tpublic void testNestedArrayConstruct() throws Exception {\n-\t\tArrayNode json = (ArrayNode) mapper.readTree(\"[[3], [4, 5], []]\");\n-\t\t// JsonNode actual = evaluate(\"1.1\", json, JsonNode.class); // Does not work\n-\t\tObject actual = evaluate(JsonPropertyAccessor.wrap(json), \"[1][1]\", Object.class);\n-\t\tassertThat(actual).isEqualTo(5);\n-\t}\n-\n-\t@Test\n-\tpublic void testNestedArrayConstructWithStringIndex() throws Exception {\n-\t\tObject json = mapper.readTree(\"[[3], [4, 5], []]\");\n-\t\tObject actual = evaluate(json, \"['1']['1']\", Object.class);\n-\t\tassertThat(actual).isEqualTo(5);\n-\t}\n-\n-\t@Test\n-\tpublic void testArrayProjectionResult() throws Exception {\n-\t\tObject json = mapper.readTree(\n-\t\t\t\t\"{\\\"foo\\\": {\\\"bar\\\": [ { \\\"fizz\\\": 5, \\\"buzz\\\": 6 }, {\\\"fizz\\\": 7}, {\\\"fizz\\\": 8} ] } }\");\n-\t\t// Filter the bar array to return only the fizz value of each element (to prove that SPeL considers bar\n-\t\t// an array/list)\n-\t\tList<?> actualArray = evaluate(json, \"foo.bar.![fizz]\", List.class);\n-\t\tassertThat(actualArray).hasSize(3);\n-\t\tassertThat(evaluate(actualArray, \"[0]\", Object.class)).isEqualTo(5);\n-\t\tassertThat(evaluate(actualArray, \"[1]\", Object.class)).isEqualTo(7);\n-\t\tassertThat(evaluate(actualArray, \"[2]\", Object.class)).isEqualTo(8);\n-\t}\n-\n-\t@Test\n-\tpublic void testFilterOnArraySelection() throws Exception {\n-\t\tObject json = mapper.readTree(\n-\t\t\t\t\"{\\\"foo\\\": {\\\"bar\\\": [ { \\\"fizz\\\": 5, \\\"buzz\\\": 6 }, {\\\"fizz\\\": 7}, {\\\"fizz\\\": 8} ] } }\");\n-\n-\t\t// Filter bar objects so that none match\n-\t\tList<?> actualArray = evaluate(json, \"foo.bar.?[fizz == 0]\", List.class);\n-\t\tassertThat(actualArray).hasSize(0);\n-\n-\t\t// Filter bar objects so that one match\n-\t\tactualArray = evaluate(json, \"foo.bar.?[fizz == 8]\", List.class);\n-\t\tassertThat(actualArray).hasSize(1);\n-\t\tassertThat(((ComparableJsonNode) actualArray.get(0)).getRealNode()).isEqualTo(mapper.readTree(\"{\\\"fizz\\\": 8}\"));\n-\n-\t\t// Filter bar objects so several match\n-\t\tactualArray = evaluate(json, \"foo.bar.?[fizz > 6]\", List.class);\n-\t\tassertThat(actualArray).hasSize(2);\n-\t\tassertThat(((ComparableJsonNode) actualArray.get(0)).getRealNode()).isEqualTo(mapper.readTree(\"{\\\"fizz\\\": 7}\"));\n-\t\tassertThat(((ComparableJsonNode) actualArray.get(1)).getRealNode()).isEqualTo(mapper.readTree(\"{\\\"fizz\\\": 8}\"));\n-\t}\n-\n-\t@Test\n-\tpublic void testNestedHashConstruct() throws Exception {\n-\t\tObject json = mapper.readTree(\"{\\\"foo\\\": {\\\"bar\\\": 4, \\\"fizz\\\": 5} }\");\n-\t\tObject actual = evaluate(json, \"foo.fizz\", Object.class);\n-\t\tassertThat(actual).isEqualTo(5);\n-\t}\n-\n-\t@Test\n-\tpublic void testImplicitStringConversion() {\n-\t\tString json = \"{\\\"foo\\\": {\\\"bar\\\": 4, \\\"fizz\\\": 5} }\";\n-\t\tObject actual = evaluate(json, \"foo.fizz\", Object.class);\n-\t\tassertThat(actual).isEqualTo(5);\n-\t}\n-\n-\t@Test\n-\tpublic void testSelectorAccess() {\n-\t\tString json = \"{\\\"property\\\":[{\\\"name\\\":\\\"value1\\\"},{\\\"name\\\":\\\"value2\\\"}]}\";\n-\t\tObject actual = evaluate(json, \"property.^[name == 'value1'].name\", Object.class);\n-\t\tassertThat(actual).isEqualTo(\"value1\");\n-\t}\n-\n-\t@Test\n-\tpublic void testJsonGetValueConversionAsJsonNode() throws Exception {\n-\t\tString json = \"{\\\"property\\\":[{\\\"name\\\":\\\"value1\\\"},{\\\"name\\\":\\\"value2\\\"}]}\";\n-\n-\t\t// use JsonNode conversion\n-\t\tObject node = evaluate(json, \"property.^[name == 'value1']\", JsonNode.class);\n-\t\tassertThat(node).isInstanceOf(JsonNode.class);\n-\t\tassertThat(((JsonNode) node)).isEqualTo(mapper.readTree(\"{\\\"name\\\":\\\"value1\\\"}\"));\n-\t}\n-\n-\t@Test\n-\tpublic void testJsonGetValueConversionAsObjectNode() throws Exception {\n-\t\tString json = \"{\\\"property\\\":[{\\\"name\\\":\\\"value1\\\"},{\\\"name\\\":\\\"value2\\\"}]}\";\n-\n-\t\t// use ObjectNode conversion\n-\t\tObject node = evaluate(json, \"property.^[name == 'value1']\", JsonNode.class);\n-\t\tassertThat(node).isInstanceOf(ObjectNode.class);\n-\t\tassertThat(((ObjectNode) node)).isEqualTo(mapper.readTree(\"{\\\"name\\\":\\\"value1\\\"}\"));\n-\t}\n-\n-\t@Test\n-\tpublic void testJsonGetValueConversionAsArrayNode() throws Exception {\n-\t\tString json = \"{\\\"property\\\":[{\\\"name\\\":\\\"value1\\\"},{\\\"name\\\":\\\"value2\\\"}]}\";\n-\n-\t\t// use ArrayNode conversion\n-\t\tObject node = evaluate(json, \"property\", ArrayNode.class);\n-\t\tassertThat(node).isInstanceOf(ArrayNode.class);\n-\t\tassertThat(((ArrayNode) node)).isEqualTo(mapper.readTree(\"[{\\\"name\\\":\\\"value1\\\"},{\\\"name\\\":\\\"value2\\\"}]\"));\n-\t}\n-\n-\t@Test\n-\tpublic void testJsonGetValueConversionAsString() {\n-\t\tString json = \"{\\\"property\\\":[{\\\"name\\\":\\\"value1\\\"},{\\\"name\\\":\\\"value2\\\"}]}\";\n-\n-\t\t// use ArrayNode conversion\n-\t\tObject node = evaluate(json, \"#root\", String.class);\n-\t\tassertThat(node).isInstanceOf(String.class);\n-\t\tassertThat(((String) node)).isEqualTo(\"{\\\"property\\\":[{\\\"name\\\":\\\"value1\\\"},{\\\"name\\\":\\\"value2\\\"}]}\");\n-\t}\n-\n-\t@Test\n-\tpublic void testSelectorComparingJsonNode() throws Exception {\n-\t\tString json = \"{\\\"property\\\":[{\\\"name\\\":\\\"value1\\\"},{\\\"name\\\":\\\"value2\\\"}], \" +\n-\t\t\t\t\"\\\"property2\\\":[{\\\"name\\\":\\\"value1\\\"},{\\\"name\\\":\\\"value2\\\"}]}\";\n-\t\tObject actual = evaluate(json, \"property[0] eq property2[0]\", Object.class);\n-\t\tassertThat(actual).isEqualTo(true);\n \t}\n \n-\t@Test\n-\tpublic void testSelectorComparingArrayNode() throws Exception {\n-\t\tString json = \"{\\\"property\\\":[{\\\"name\\\":\\\"value1\\\"},{\\\"name\\\":\\\"value2\\\"}], \" +\n-\t\t\t\t\"\\\"property2\\\":[{\\\"name\\\":\\\"value1\\\"},{\\\"name\\\":\\\"value2\\\"}]}\";\n-\t\tObject actual = evaluate(json, \"property eq property2\", Object.class);\n-\t\tassertThat(actual).isEqualTo(true);\n-\t}\n-\n-\t@Test\n-\tpublic void testUnsupportedString() {\n-\t\tString xml = \"<what>?</what>\";\n-\t\tassertThatExceptionOfType(SpelEvaluationException.class)\n-\t\t\t\t.isThrownBy(() -> evaluate(xml, \"what\", Object.class));\n-\t}\n-\n-\t@Test\n-\tpublic void testUnsupportedJson() {\n-\t\tString json = \"\\\"literal\\\"\";\n-\t\tassertThat(evaluate(json, \"foo\", Object.class)).isNull();\n-\t}\n-\n-\t@Test\n-\tpublic void testNoNullPointerWithCachedReadAccessor() throws Exception {\n-\t\tExpression expression = parser.parseExpression(\"foo\");\n-\t\tObject json = mapper.readTree(\"{\\\"foo\\\": \\\"bar\\\"}\");\n-\t\tObject value = expression.getValue(this.context, json);\n-\t\tassertThat(value).isInstanceOf(String.class);\n-\t\tassertThat(value).isEqualTo(\"bar\");\n-\t\tObject json2 = mapper.readTree(\"{}\");\n-\t\tObject value2 = expression.getValue(this.context, json2);\n-\t\tassertThat(value2).isNull();\n-\t}\n+\t/**\n+\t * Tests which index directly into a Jackson {@link ArrayNode}, which is not supported\n+\t * by {@link JsonPropertyAccessor}.\n+\t */\n+\t@Nested\n+\tclass ArrayNodeTests {\n+\n+\t\t@Test\n+\t\tvoid indexDirectlyIntoArrayNodeWithIntegerIndex() throws Exception {\n+\t\t\tArrayNode arrayNode = (ArrayNode) mapper.readTree(\"[3, 4, 5]\");\n+\t\t\tassertIndexingNotSupported(arrayNode, \"[1]\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid indexDirectlyIntoArrayNodeWithIntegerIndexForNullValue() throws Exception {\n+\t\t\tArrayNode arrayNode = (ArrayNode) mapper.readTree(\"[3, null, 5]\");\n+\t\t\tassertIndexingNotSupported(arrayNode, \"[1]\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid indexDirectlyIntoArrayNodeWithNegativeIntegerIndex() throws Exception {\n+\t\t\tArrayNode arrayNode = (ArrayNode) mapper.readTree(\"[3, 4, 5]\");\n+\t\t\tassertIndexingNotSupported(arrayNode, \"[-1]\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid indexDirectlyIntoArrayNodeWithIntegerIndexOutOfBounds() throws Exception {\n+\t\t\tArrayNode arrayNode = (ArrayNode) mapper.readTree(\"[3, 4, 5]\");\n+\t\t\tassertIndexingNotSupported(arrayNode, \"[9999]\");\n+\t\t}\n+\n+\t\t/**\n+\t\t * @see AbstractJsonAccessorTests.JsonNodeTests#nestedArrayLookupWithStringIndexAndThenIntegerIndex()\n+\t\t */\n+\t\t@Test\n+\t\tvoid nestedArrayLookupWithIntegerIndexAndThenIntegerIndex() throws Exception {\n+\t\t\tArrayNode arrayNode = (ArrayNode) mapper.readTree(\"[[3], [4, 5], []]\");\n+\t\t\tassertIndexingNotSupported(arrayNode, \"[1][1]\");\n+\t\t}\n+\n+\t\tprivate void assertIndexingNotSupported(ArrayNode arrayNode, String expression) {\n+\t\t\tassertThatExceptionOfType(SpelEvaluationException.class)\n+\t\t\t\t\t.isThrownBy(() -> parser.parseExpression(expression).getValue(context, arrayNode))\n+\t\t\t\t\t.satisfies(ex -> assertThat(ex.getMessageCode()).isEqualTo(SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE));\n+\t\t}\n \n-\tprivate <T> T evaluate(Object target, String expression, Class<T> expectedType) {\n-\t\treturn parser.parseExpression(expression).getValue(context, target, expectedType);\n \t}\n \n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9382",
    "pr_id": 9382,
    "issue_id": 9368,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Adding Mqttv5PahoMessageDrivenChannelAdapter to running Mqttv5ClientManager\nversion 6.3.1\r\n\r\n**Description**\r\nI want to add multiple instances of Mqttv5PahoMessageDrivenChannelAdapter (on demand, when application is running) using already running client in Mqttv5ClientManager as constructor parameter. When I try, it does not work. \r\nCause seams to be MqttCallback:: connectComplete ,which sets the readyToSubscribeOnStart property.\r\nThat obviously cant trigger because client is already connected.\r\n\r\n**To Reproduce**\r\n1.\tCreate an instance of Mqttv5ClientManager\r\n2.\tStart clientManager\r\n3.\tcreate an instance of Mqttv5PahoMessageDrivenChannelAdapter with clientManager\r\n4.\tregister adapter in IntegrationFlow using IntegrationFlowContext\r\n5.\tTry to send messages to it\r\n\r\n\r\n**Possible Fix**\r\nhttps://github.com/Ricore72/spring-integration\r\nThe fix does not work completely.\r\n\r\nIt only works if Handlers and adapters using same clientManager have the same Qos.\r\n\r\n**Note** \r\nI am not sure if this is the proper way to do this. This is my first issue to public project. So sorry if it is incorrect in any way.\r\n",
    "issue_word_count": 152,
    "test_files_count": 1,
    "non_test_files_count": 6,
    "pr_changed_files": [
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/ClientManager.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/AbstractMqttMessageDrivenChannelAdapter.java",
      "spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java",
      "src/reference/antora/modules/ROOT/pages/mqtt.adoc",
      "src/reference/antora/modules/ROOT/pages/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java"
    ],
    "base_commit": "f49dcc0a2df87ea641a91f02b34f85c60603c74c",
    "head_commit": "22089802dd5375109c63fefa6ed6dc9582773d50",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9382",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9382",
    "dockerfile": "",
    "pr_merged_at": "2024-08-19T15:48:02.000Z",
    "patch": "diff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/ClientManager.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/ClientManager.java\nindex 00692df436f..06019560b8c 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/ClientManager.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/ClientManager.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2022-2023 the original author or authors.\n+ * Copyright 2022-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -28,6 +28,7 @@\n  *\n  * @author Artem Vozhdayenko\n  * @author Artem Bilan\n+ * @author Jiri Soucek\n  *\n  * @since 6.0\n  */\n@@ -68,6 +69,13 @@ public interface ClientManager<T, C> extends SmartLifecycle, MqttComponent<C> {\n \t */\n \tboolean removeCallback(ConnectCallback connectCallback);\n \n+\t/**\n+\t * Return the managed clients isConnected.\n+\t * @return the managed clients isConnected.\n+\t * @since 6.4\n+\t */\n+\tboolean isConnected();\n+\n \t/**\n \t * A contract for a custom callback on {@code connectComplete} event from the client.\n \t *\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java\nindex 8fb3f991827..0936bfadeb0 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java\n@@ -38,6 +38,7 @@\n  * @author Artem Vozhdayenko\n  * @author Artem Bilan\n  * @author Christian Tzolov\n+ * @author Jiri Soucek\n  *\n  * @since 6.0\n  */\n@@ -198,4 +199,19 @@ public void deliveryComplete(IMqttDeliveryToken token) {\n \t\t// nor this manager concern\n \t}\n \n+\t@Override\n+\tpublic boolean isConnected() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tIMqttAsyncClient client = getClient();\n+\t\t\tif (client != null) {\n+\t\t\t\treturn client.isConnected();\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n+\n+\t}\n }\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java\nindex 36bc028b70a..3bcbcca520d 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java\n@@ -40,6 +40,7 @@\n  * @author Artem Vozhdayenko\n  * @author Artem Bilan\n  * @author Christian Tzolov\n+ * @author Jiri Soucek\n  *\n  * @since 6.0\n  */\n@@ -206,4 +207,18 @@ public void mqttErrorOccurred(MqttException exception) {\n \t\tlogger.error(\"MQTT error occurred\", exception);\n \t}\n \n+\t@Override\n+\tpublic boolean isConnected() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tIMqttAsyncClient client = getClient();\n+\t\t\tif (client != null) {\n+\t\t\t\treturn client.isConnected();\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n+\t}\n }\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/AbstractMqttMessageDrivenChannelAdapter.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/AbstractMqttMessageDrivenChannelAdapter.java\nindex a6f76bdfd18..26a66304015 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/AbstractMqttMessageDrivenChannelAdapter.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/AbstractMqttMessageDrivenChannelAdapter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2023 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -49,6 +49,7 @@\n  * @author Trung Pham\n  * @author Mikhail Polivakha\n  * @author Artem Vozhdayenko\n+ * @author Jiri Soucek\n  *\n  * @since 4.0\n  *\n@@ -203,6 +204,9 @@ protected void onInit() {\n \t\tsuper.onInit();\n \t\tif (this.clientManager != null) {\n \t\t\tthis.clientManager.addCallback(this);\n+\t\t\tif (this.clientManager.isConnected()) {\n+\t\t\t\tconnectComplete(false);\n+\t\t\t}\n \t\t}\n \t}\n \n\ndiff --git a/src/reference/antora/modules/ROOT/pages/mqtt.adoc b/src/reference/antora/modules/ROOT/pages/mqtt.adoc\nindex 3c2486d7eeb..3e0154a6262 100644\n--- a/src/reference/antora/modules/ROOT/pages/mqtt.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/mqtt.adoc\n@@ -382,9 +382,9 @@ public class MqttJavaApplication {\n             .run(args);\n     }\n \n-   \t@Bean\n-   \tpublic IntegrationFlow mqttOutboundFlow() {\n-   \t    return f -> f.handle(new MqttPahoMessageHandler(\"tcp://host1:1883\", \"someMqttClient\"));\n+       @Bean\n+       public IntegrationFlow mqttOutboundFlow() {\n+           return f -> f.handle(new MqttPahoMessageHandler(\"tcp://host1:1883\", \"someMqttClient\"));\n     }\n \n }\n@@ -548,3 +548,19 @@ public IntegrationFlow mqttOutFlow(\n     return f -> f.handle(new Mqttv5PahoMessageHandler(clientManager));\n }\n ----\n+\n+NOTE: Starting with version 6.4, multiple instances of `MqttPahoMessageDrivenChannelAdapter` and `Mqttv5PahoMessageDrivenChannelAdapter` can now be added at runtime using corresponding `ClientManager` through `IntegrationFlowContext`\n+\n+[source,java]\n+----\n+private void addAddRuntimeAdapter(IntegrationFlowContext flowContext, Mqttv5ClientManager clientManager,\n+                                  String topic, MessageChannel channel) {\n+    flowContext\n+        .registration(\n+            IntegrationFlow\n+                .from(new Mqttv5PahoMessageDrivenChannelAdapter(clientManager, topic))\n+                .channel(channel)\n+                .get())\n+        .register();\n+}\n+----\n\\ No newline at end of file\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/whats-new.adoc b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\nindex 691b6a35b19..c3f3c50a62c 100644\n--- a/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n@@ -61,8 +61,16 @@ See xref:redis.adoc[Redis Support] for more information.\n The `ControlBusFactoryBean` (and respective `<int-groovy:control-bus>` XML tag) has been deprecated (for removal) in favor of new introduced `ControlBusFactoryBean` based on a new model implemented in the `ControlBusCommandRegistry`.\n See xref:control-bus.adoc[Control Bus] for more information.\n \n+\n [[x6.4-sftp-changes]]\n === SFTP Support Changes\n \n The `DefaultSftpSessionFactory` now exposes a `Consumer<SshClient>` configurer property to further customize an internal `SshClient`.\n-See xref:sftp/session-factory.adoc[SFTP Session Factory] for more information.\n\\ No newline at end of file\n+See xref:sftp/session-factory.adoc[SFTP Session Factory] for more information.\n+\n+[[x6.4-mqtt-support-changes]]\n+=== MQTT Support Changes\n+\n+Multiple instances of `MqttPahoMessageDrivenChannelAdapter` and `Mqttv5PahoMessageDrivenChannelAdapter` can now be added at runtime using corresponding `ClientManager` through `IntegrationFlowContext`\n+See xref:mqtt.adoc[MQTT Support] for more information.\n+\n",
    "test_patch": "diff --git a/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java b/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java\nindex 46013a8b131..611fe10e37c 100644\n--- a/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java\n+++ b/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java\n@@ -24,13 +24,17 @@\n import org.eclipse.paho.client.mqttv3.MqttException;\n import org.junit.jupiter.api.Test;\n \n+import org.springframework.context.ApplicationContext;\n import org.springframework.context.annotation.AnnotationConfigApplicationContext;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.context.event.EventListener;\n import org.springframework.integration.annotation.ServiceActivator;\n+import org.springframework.integration.channel.QueueChannel;\n import org.springframework.integration.config.EnableIntegration;\n import org.springframework.integration.dsl.IntegrationFlow;\n+import org.springframework.integration.dsl.context.IntegrationFlowContext;\n+import org.springframework.integration.endpoint.MessageProducerSupport;\n import org.springframework.integration.mqtt.core.Mqttv3ClientManager;\n import org.springframework.integration.mqtt.core.Mqttv5ClientManager;\n import org.springframework.integration.mqtt.event.MqttSubscribedEvent;\n@@ -70,12 +74,24 @@ void testV3ClientManagerReconnect() throws Exception {\n \t\t\t\tMqttv3ConfigWithDisconnect.subscribedLatch);\n \t}\n \n+\t@Test\n+\tvoid testV3ClientManagerRuntime() throws Exception {\n+\t\ttestSubscribeAndPublishRuntime(Mqttv3ConfigRuntime.class, Mqttv3ConfigRuntime.TOPIC_NAME,\n+\t\t\t\tMqttv3ConfigRuntime.subscribedLatch);\n+\t}\n+\n \t@Test\n \tvoid testV5ClientManagerReconnect() throws Exception {\n \t\ttestSubscribeAndPublish(Mqttv5ConfigWithDisconnect.class, Mqttv5ConfigWithDisconnect.TOPIC_NAME,\n \t\t\t\tMqttv5ConfigWithDisconnect.subscribedLatch);\n \t}\n \n+\t@Test\n+\tvoid testV5ClientManagerRuntime() throws Exception {\n+\t\ttestSubscribeAndPublishRuntime(Mqttv5ConfigRuntime.class, Mqttv5ConfigRuntime.TOPIC_NAME,\n+\t\t\t\tMqttv5ConfigRuntime.subscribedLatch);\n+\t}\n+\n \tprivate void testSubscribeAndPublish(Class<?> configClass, String topicName, CountDownLatch subscribedLatch)\n \t\t\tthrows Exception {\n \n@@ -102,6 +118,39 @@ private void testSubscribeAndPublish(Class<?> configClass, String topicName, Cou\n \t\t}\n \t}\n \n+\tprivate void testSubscribeAndPublishRuntime(Class<?> configClass, String topicName, CountDownLatch subscribedLatch)\n+\t\t\tthrows Exception {\n+\n+\t\ttry (var ctx = new AnnotationConfigApplicationContext(configClass)) {\n+\t\t\t// given\n+\t\t\tvar input = ctx.getBean(\"mqttOutFlow.input\", MessageChannel.class);\n+\t\t\tvar flowContext = ctx.getBean(IntegrationFlowContext.class);\n+\t\t\tvar factory = ctx.getBean(MessageDrivenChannelAdapterFactory.class);\n+\t\t\tvar output = new QueueChannel();\n+\n+\t\t\tflowContext.registration(IntegrationFlow\n+\t\t\t\t\t.from(factory.createMessageDrivenAdapter(ctx))\n+\t\t\t\t\t.channel(output)\n+\t\t\t\t\t.get()).register();\n+\t\t\tString testPayload = \"foo\";\n+\t\t\tassertThat(subscribedLatch.await(20, TimeUnit.SECONDS)).isTrue();\n+\n+\t\t\t// when\n+\t\t\tinput.send(MessageBuilder.withPayload(testPayload).setHeader(MqttHeaders.TOPIC, topicName).build());\n+\t\t\tMessage<?> receive = output.receive(20_000);\n+\n+\t\t\t// then\n+\t\t\tassertThat(receive).isNotNull();\n+\t\t\tObject payload = receive.getPayload();\n+\t\t\tif (payload instanceof String sp) {\n+\t\t\t\tassertThat(sp).isEqualTo(testPayload);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tassertThat(payload).isEqualTo(testPayload.getBytes(StandardCharsets.UTF_8));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t@Configuration\n \t@EnableIntegration\n \tpublic static class Mqttv3Config {\n@@ -177,6 +226,39 @@ public IntegrationFlow mqttInFlow(Mqttv3ClientManager mqttv3ClientManager) {\n \n \t}\n \n+\t@Configuration\n+\t@EnableIntegration\n+\tpublic static class Mqttv3ConfigRuntime implements MessageDrivenChannelAdapterFactory {\n+\n+\t\tstatic final String TOPIC_NAME = \"test-topic-v3\";\n+\n+\t\tstatic final CountDownLatch subscribedLatch = new CountDownLatch(1);\n+\n+\t\t@EventListener\n+\t\tpublic void onSubscribed(MqttSubscribedEvent e) {\n+\t\t\tsubscribedLatch.countDown();\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic Mqttv3ClientManager mqttv3ClientManager() {\n+\t\t\tMqttConnectOptions connectionOptions = new MqttConnectOptions();\n+\t\t\tconnectionOptions.setServerURIs(new String[] {MosquittoContainerTest.mqttUrl()});\n+\t\t\tconnectionOptions.setAutomaticReconnect(true);\n+\t\t\treturn new Mqttv3ClientManager(connectionOptions, \"client-manager-client-id-v3\");\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic IntegrationFlow mqttOutFlow(Mqttv3ClientManager mqttv3ClientManager) {\n+\t\t\treturn f -> f.handle(new MqttPahoMessageHandler(mqttv3ClientManager));\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic MessageProducerSupport createMessageDrivenAdapter(ApplicationContext ctx) {\n+\t\t\tvar clientManager = ctx.getBean(Mqttv3ClientManager.class);\n+\t\t\treturn new MqttPahoMessageDrivenChannelAdapter(clientManager, TOPIC_NAME);\n+\t\t}\n+\t}\n+\n \t@Configuration\n \t@EnableIntegration\n \tpublic static class Mqttv5Config {\n@@ -247,6 +329,41 @@ public IntegrationFlow mqttInFlow(Mqttv5ClientManager mqttv5ClientManager) {\n \n \t}\n \n+\t@Configuration\n+\t@EnableIntegration\n+\tpublic static class Mqttv5ConfigRuntime implements MessageDrivenChannelAdapterFactory {\n+\n+\t\tstatic final String TOPIC_NAME = \"test-topic-v5\";\n+\n+\t\tstatic final CountDownLatch subscribedLatch = new CountDownLatch(1);\n+\n+\t\t@EventListener\n+\t\tpublic void onSubscribed(MqttSubscribedEvent e) {\n+\t\t\tsubscribedLatch.countDown();\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic Mqttv5ClientManager mqttv5ClientManager() {\n+\t\t\treturn new Mqttv5ClientManager(MosquittoContainerTest.mqttUrl(), \"client-manager-client-id-v5\");\n+\t\t}\n+\n+\t\t@Bean\n+\t\t@ServiceActivator(inputChannel = \"mqttOutFlow.input\")\n+\t\tpublic Mqttv5PahoMessageHandler mqttv5PahoMessageHandler(Mqttv5ClientManager mqttv5ClientManager) {\n+\t\t\treturn new Mqttv5PahoMessageHandler(mqttv5ClientManager);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic MessageProducerSupport createMessageDrivenAdapter(ApplicationContext ctx) {\n+\t\t\tvar clientManager = ctx.getBean(Mqttv5ClientManager.class);\n+\t\t\treturn new Mqttv5PahoMessageDrivenChannelAdapter(clientManager, TOPIC_NAME);\n+\t\t}\n+\t}\n+\n+\tinterface MessageDrivenChannelAdapterFactory {\n+\t\tMessageProducerSupport createMessageDrivenAdapter(ApplicationContext ctx);\n+\t}\n+\n \trecord ClientV3Disconnector(Mqttv3ClientManager clientManager) {\n \n \t\t@EventListener(MqttSubscribedEvent.class)\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9370",
    "pr_id": 9370,
    "issue_id": 9369,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Serializing MutableMessageHeaders containing a non-serializable header property results in serializer incorrectly serializing the 'headers' property on the class\n**In what version(s) of Spring Integration are you seeing this issue?**\r\n\r\nv6.2.7\r\n\r\n**Describe the bug**\r\n\r\nWhen MutableMessageHeaders is serialized using Spring Cores DefaultSerializer with a header that is not serializable it can result in the 'headers' property on the class being serialized as the superclass (MessageHeaders) instead of a HashMap. When deserialized this causes the 'headers' property to be an instance of MessageHeaders which prevents callers from adding properties to the MutableMessageHeaders class (When they should be able to). The following error is observed\r\n\r\n```\r\nException in thread \"main\" java.lang.UnsupportedOperationException: MessageHeaders is immutable\r\n\tat org.springframework.messaging.MessageHeaders.put(MessageHeaders.java:274)\r\n\tat org.springframework.messaging.MessageHeaders.put(MessageHeaders.java:73)\r\n\tat org.springframework.integration.support.MutableMessageHeaders.put(MutableMessageHeaders.java:63)\r\n```\r\n\r\nThis looks to be related to the `writeObject` on the MessageHeaders class which will instantiate a new instance of the MessageHeaders class if there is a non-serializable object in the headers. Its likely that similar functionality needs to be overridden in the MutableMessageHeaders class in order to serialize it correctly. (See https://github.com/spring-projects/spring-framework/blob/main/spring-messaging/src/main/java/org/springframework/messaging/MessageHeaders.java#L307)\r\n\r\nIf there is no non-serializable objects in the headers then the MutableMessageHeaders works as expected when deserialized, this is because it just writes the object directly in the `writeObject` method rather than creating a new instance of MessageHeaders\r\n\r\nThis issue was originally observed when using the RedisMessageStore with an aggregator which under the hood makes use of the DefaultSerializer class, when I enabled observations it attempted to add the traceparent to the message header after it had been deserialized which then resulted in a failure.\r\n\r\n**To Reproduce**\r\n\r\n1. Create a MutableMessageHeaders instance with a header value containing a non-serializable instance\r\n2. Serialize the class using the SerializingConverter\r\n3. Deserialize the class using the DeserializingConverter using the output from step 2\r\n4. Attempt to put a header into the deserialized MutableMessageHeaders instance\r\n\r\n**Expected behavior**\r\n\r\nIts expected that when MutableMessageHeaders is deserialized back into the object that it should be able to behave as normal and allow headers to be added using the classes 'put' method.\r\n\r\n**Sample**\r\n\r\nLink to sample showing bug: https://github.com/mitchmcd18/spring-messageheader-bug\r\n\r\n\r\n**Related links**\r\nhttps://github.com/spring-projects/spring-framework/blob/main/spring-core/src/main/java/org/springframework/core/serializer/support/SerializingConverter.java\r\nhttps://github.com/spring-projects/spring-framework/blob/main/spring-core/src/main/java/org/springframework/core/serializer/support/DeserializingConverter.java\r\nhttps://github.com/spring-projects/spring-integration/blob/main/spring-integration-core/src/main/java/org/springframework/integration/support/MutableMessageHeaders.java\r\n",
    "issue_word_count": 460,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/support/MutableMessageHeaders.java",
      "spring-integration-core/src/test/java/org/springframework/integration/support/MutableMessageTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/support/MutableMessageTests.java"
    ],
    "base_commit": "8df5c43a76e189d22cea79d74504b81f65c34a6d",
    "head_commit": "943e2af2e40e4774e65a1ca8799f4c5fc18950e2",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9370",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9370",
    "dockerfile": "",
    "pr_merged_at": "2024-08-08T17:16:50.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/support/MutableMessageHeaders.java b/spring-integration-core/src/main/java/org/springframework/integration/support/MutableMessageHeaders.java\nindex 45b14f05307..5b876b1580a 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/support/MutableMessageHeaders.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/support/MutableMessageHeaders.java\n@@ -16,6 +16,8 @@\n \n package org.springframework.integration.support;\n \n+import java.io.ObjectStreamException;\n+import java.io.Serial;\n import java.nio.ByteBuffer;\n import java.util.Map;\n import java.util.UUID;\n@@ -31,6 +33,7 @@\n  * @author David Turanski\n  * @author Artem Bilan\n  * @author Nathan Kurtyka\n+ * @author Mitchell McDonald\n  *\n  * @since 4.2\n  */\n@@ -73,6 +76,11 @@ public Object remove(Object key) {\n \t\treturn super.getRawHeaders().remove(key);\n \t}\n \n+\t@Serial\n+\tprivate Object readResolve() throws ObjectStreamException {\n+\t\treturn new MutableMessageHeaders(this);\n+\t}\n+\n \t@Nullable\n \tprivate static UUID extractId(@Nullable Map<String, Object> headers) {\n \t\tif (headers != null && headers.containsKey(MessageHeaders.ID)) {\n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/support/MutableMessageTests.java b/spring-integration-core/src/test/java/org/springframework/integration/support/MutableMessageTests.java\nindex 99612a45090..9b1eb07ee4f 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/support/MutableMessageTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/support/MutableMessageTests.java\n@@ -16,6 +16,11 @@\n \n package org.springframework.integration.support;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.nio.ByteBuffer;\n import java.util.HashMap;\n import java.util.Map;\n@@ -26,10 +31,12 @@\n import org.springframework.messaging.MessageHeaders;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatNoException;\n \n /**\n  * @author Stuart Williams\n  * @author Nathan Kurtyka\n+ * @author Mitchell McDonald\n  *\n  * @since 4.2\n  */\n@@ -104,4 +111,34 @@ public void testMessageHeaderIsSerializable() {\n \t\tassertThat(mutableMessageBytes.getHeaders().getTimestamp()).isEqualTo(timestamp);\n \t}\n \n+\t@Test\n+\tpublic void testMessageHeaderIsSerializableAndDeserializableWithNonSerializableValues()\n+\t\t\tthrows IOException, ClassNotFoundException {\n+\n+\t\tString payload = \"payload\";\n+\n+\t\tMap<String, Object> headerMap = new HashMap<>();\n+\t\theaderMap.put(\"header1\", \"serializableValue\");\n+\t\theaderMap.put(\"header2\", new Object()); // Non-Serializable value\n+\n+\t\tMutableMessage<String> mutableMessage = new MutableMessage<>(payload, headerMap);\n+\n+\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+\t\tObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);\n+\t\toutputStream.writeObject(mutableMessage);\n+\t\toutputStream.flush();\n+\n+\t\tByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());\n+\t\tObjectInputStream inputStream = new ObjectInputStream(byteArrayInputStream);\n+\t\tObject deserializedObject = inputStream.readObject();\n+\n+\t\tassertThat(deserializedObject).isInstanceOf(MutableMessage.class);\n+\t\tMutableMessage<?> deserializedMessage =\n+\t\t\t\t(MutableMessage<?>) deserializedObject;\n+\n+\t\tassertThat(deserializedMessage.getHeaders().get(\"header2\")).isNull(); // Non-serializable value removed\n+\t\tassertThat(deserializedMessage.getHeaders().get(\"header1\")).isEqualTo(\"serializableValue\");\n+\t\tassertThatNoException().isThrownBy(() -> deserializedMessage.getRawHeaders().put(\"header3\", \"newValue\"));\n+\t}\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9300",
    "pr_id": 9300,
    "issue_id": 9294,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "When deleteSourceFiles is true, the setPermissions method of FileWritingMessageHandler should be called.\n**Expected Behavior**\r\n\r\n<!--- Tell us how it should work -->\r\nchmod should need to work when the FileWritingMessageHandler's deleteSourceFiles property is true.\r\n**Current Behavior**\r\n\r\n<!--- Explain the difference from current behavior -->\r\nWhen the deleteSourceFiles property of FileWritingMessageHandler is true, chmod does not work.\r\n**Context**\r\n\r\n<!--- \r\nHow has this issue affected you?\r\nWhat are you trying to accomplish?\r\nWhat other alternatives have you considered?\r\nAre you aware of any workarounds?\r\n-->\r\nMy code is as follows:\r\n```java\r\n@Bean\r\npublic IntegrationFlow pacToZipFlow(MessageChannel packToZipChannel,  FileSynchronizerProperties fileSynchronizerProperties) {\r\n\treturn IntegrationFlow\r\n\t\t\t.from(packToZipChannel)\r\n\t\t\t.transformWith(transformer -> transformer.transformer(new ZipTransformer()))\r\n\t\t\t.handle(Files\r\n\t\t\t\t\t.outboundAdapter(new File(fileSynchronizerProperties.outputDirectory()))\r\n\t\t\t\t\t.fileNameGenerator(message -> System.currentTimeMillis() + FileConsts.ZIP_FILE_SUFFIX)\r\n\t\t\t\t\t.deleteSourceFiles(true)\r\n\t\t\t\t\t.chmod(0700)\r\n\t\t\t)\r\n\t\t\t.get();\r\n}\r\n```\r\nWhen deleteSourceFiles is true, the setPermissions(resultFile) method is not called in the handleFileMessage method of FileWritingMessageHandler. ",
    "issue_word_count": 137,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java",
      "spring-integration-file/src/test/java/org/springframework/integration/file/FileWritingMessageHandlerTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-file/src/test/java/org/springframework/integration/file/FileWritingMessageHandlerTests.java"
    ],
    "base_commit": "4e7caed9799cf79ed43b0d645cba1e444f78b9ff",
    "head_commit": "dfbdd7f9ce3b971a28fa4bdf9ff2ad42e2ddfc0b",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9300",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9300",
    "dockerfile": "",
    "pr_merged_at": "2024-07-08T14:03:12.000Z",
    "patch": "diff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java b/spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java\nindex 6568e2656db..0a24b651eb2 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java\n@@ -629,6 +629,7 @@ private File handleFileMessage(File sourceFile, File tempFile, File resultFile,\n \n \t\tif (!FileExistsMode.APPEND.equals(this.fileExistsMode) && this.deleteSourceFiles) {\n \t\t\trename(sourceFile, resultFile);\n+\t\t\tsetPermissions(resultFile);\n \t\t\treturn resultFile;\n \t\t}\n \t\telse {\n",
    "test_patch": "diff --git a/spring-integration-file/src/test/java/org/springframework/integration/file/FileWritingMessageHandlerTests.java b/spring-integration-file/src/test/java/org/springframework/integration/file/FileWritingMessageHandlerTests.java\nindex b006fa0336f..a6492c3569a 100644\n--- a/spring-integration-file/src/test/java/org/springframework/integration/file/FileWritingMessageHandlerTests.java\n+++ b/spring-integration-file/src/test/java/org/springframework/integration/file/FileWritingMessageHandlerTests.java\n@@ -36,6 +36,8 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.DisabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n import org.junit.jupiter.api.io.TempDir;\n \n import org.springframework.beans.DirectFieldAccessor;\n@@ -301,6 +303,23 @@ public void deleteFilesTrueWithFilePayload() throws Exception {\n \t\tassertThat(sourceFile.exists()).isFalse();\n \t}\n \n+\t@Test\n+\t@DisabledOnOs(OS.WINDOWS)\n+\tpublic void deleteFilesWithChmod() throws Exception {\n+\t\tQueueChannel output = new QueueChannel();\n+\t\thandler.setDeleteSourceFiles(true);\n+\t\thandler.setOutputChannel(output);\n+\t\thandler.setChmod(0400);\n+\t\tMessage<?> message = MessageBuilder.withPayload(sourceFile).build();\n+\t\thandler.handleMessage(message);\n+\t\tMessage<?> result = output.receive(0);\n+\t\tassertFileContentIsMatching(result);\n+\t\tFile resultFile = messageToFile(result);\n+\t\tSet<PosixFilePermission> posixFilePermissions = Files.getPosixFilePermissions(resultFile.toPath());\n+\t\tassertThat(posixFilePermissions).containsOnly(PosixFilePermission.OWNER_READ);\n+\t\tassertThat(sourceFile.exists()).isFalse();\n+\t}\n+\n \t@Test\n \tpublic void deleteSourceFileWithStringPayloadAndFileInstanceHeader() throws Exception {\n \t\tQueueChannel output = new QueueChannel();\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9292",
    "pr_id": 9292,
    "issue_id": 9291,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Enhanced unlock() method of JdbcLock to verify successful unlocking\n**Expected Behavior**\r\n\r\n* The `unlock()` method of `JdbcLock` should verify the execution result of releasing the lock ownership.\r\n* If the ownership can not be removed due to data expiration, a `ConcurrentModificationException` should be thrown.\r\n* `The RedisLock` implementation should also throw a `ConcurrentModificationException` in similar scenarios.\r\n\r\n**Current Behavior**\r\n\r\n* The `unlock()` method does not verify the execution result of releasing the lock ownership. \r\n* The `RedisLock` throws an `IllegalStateException` when attempting to release the lock after the ownership has expired.\r\n\r\n**Context**\r\n\r\nIf the `unlock()` method does not verify the execution result of releasing the lock ownership, users might face concurrency issues without being notified. For example:\r\n1. Process A and process B are operating in the same region. Process A acquires the distributed lock with lock_key: 'key'.\r\n2. Due to prolonged work, the ownership of the lock held by process A expires.\r\n3. Before process A releases the lock, process B also acquires the distributed lock with same lock_key.\r\n4. When process A attempts to release the distributed lock, the current implementation does not inform the user that the integrity of data protected by this lock may have been compromised.\r\n\r\nTo address this, it is proposed that the `unlock()` method be enhanced to verify if the ownership of lock has been removed successfully.  If the ownership cannot be removed due to data expiration, a `ConcurrentModificationException` will be thrown.  This approach maintains the integrity of the distributed lock mechanism.\r\n",
    "issue_word_count": 243,
    "test_files_count": 4,
    "non_test_files_count": 7,
    "pr_changed_files": [
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/JdbcLockRegistry.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/LockRepository.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryDelegateTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryDifferentClientTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryTests.java",
      "spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java",
      "spring-integration-redis/src/test/java/org/springframework/integration/redis/util/RedisLockRegistryTests.java",
      "src/reference/antora/modules/ROOT/pages/jdbc/lock-registry.adoc",
      "src/reference/antora/modules/ROOT/pages/redis.adoc",
      "src/reference/antora/modules/ROOT/pages/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryDelegateTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryDifferentClientTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryTests.java",
      "spring-integration-redis/src/test/java/org/springframework/integration/redis/util/RedisLockRegistryTests.java"
    ],
    "base_commit": "7974f9c5b6c8db98bbae0329cb13ae99d7d3f33a",
    "head_commit": "1f5b7a9cd27f717ee2da784573c45a841d6b6382",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9292",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9292",
    "dockerfile": "",
    "pr_merged_at": "2024-07-02T19:48:07.000Z",
    "patch": "diff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java\nindex e442a6d1259..d8dd4ee94a6 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java\n@@ -62,6 +62,7 @@\n  * @author Gary Russell\n  * @author Alexandre Strubel\n  * @author Ruslan Stelmachenko\n+ * @author Eddie Cho\n  *\n  * @since 4.3\n  */\n@@ -389,9 +390,9 @@ public void close() {\n \t}\n \n \t@Override\n-\tpublic void delete(String lock) {\n-\t\tthis.defaultTransactionTemplate.executeWithoutResult(\n-\t\t\t\ttransactionStatus -> this.template.update(this.deleteQuery, this.region, lock, this.id));\n+\tpublic boolean delete(String lock) {\n+\t\treturn this.defaultTransactionTemplate.execute(\n+\t\t\t\ttransactionStatus -> this.template.update(this.deleteQuery, this.region, lock, this.id)) > 0;\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/JdbcLockRegistry.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/JdbcLockRegistry.java\nindex cae7d922d7f..e966d6bb428 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/JdbcLockRegistry.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/JdbcLockRegistry.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2023 the original author or authors.\n+ * Copyright 2016-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,6 +17,7 @@\n package org.springframework.integration.jdbc.lock;\n \n import java.time.Duration;\n+import java.util.ConcurrentModificationException;\n import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Map.Entry;\n@@ -56,6 +57,7 @@\n  * @author Unseok Kim\n  * @author Christian Tzolov\n  * @author Myeonghyeon Lee\n+ * @author Eddie Cho\n  *\n  * @since 4.3\n  */\n@@ -305,12 +307,20 @@ public void unlock() {\n \t\t\ttry {\n \t\t\t\twhile (true) {\n \t\t\t\t\ttry {\n-\t\t\t\t\t\tthis.mutex.delete(this.path);\n-\t\t\t\t\t\treturn;\n+\t\t\t\t\t\tif (this.mutex.delete(this.path)) {\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\tthrow new ConcurrentModificationException(\"Lock was released in the store due to expiration. \" +\n+\t\t\t\t\t\t\t\t\t\"The integrity of data protected by this lock may have been compromised.\");\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tcatch (TransientDataAccessException | TransactionTimedOutException | TransactionSystemException e) {\n \t\t\t\t\t\t// try again\n \t\t\t\t\t}\n+\t\t\t\t\tcatch (ConcurrentModificationException e) {\n+\t\t\t\t\t\tthrow e;\n+\t\t\t\t\t}\n \t\t\t\t\tcatch (Exception e) {\n \t\t\t\t\t\tthrow new DataAccessResourceFailureException(\"Failed to release mutex at \" + this.path, e);\n \t\t\t\t\t}\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/LockRepository.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/LockRepository.java\nindex b0a6a902fda..247e6fccb5e 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/LockRepository.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/LockRepository.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2021 the original author or authors.\n+ * Copyright 2016-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -26,6 +26,7 @@\n  * @author Dave Syer\n  * @author Alexandre Strubel\n  * @author Artem Bilan\n+ * @author Eddie Cho\n  *\n  * @since 4.3\n  */\n@@ -41,8 +42,9 @@ public interface LockRepository extends Closeable {\n \t/**\n \t * Remove a lock from this repository.\n \t * @param lock the lock to remove.\n+\t * @return deleted or not.\n \t */\n-\tvoid delete(String lock);\n+\tboolean delete(String lock);\n \n \t/**\n \t * Remove all the expired locks.\n\ndiff --git a/spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java b/spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java\nindex 7f73eebbc7c..1b420adea7f 100644\n--- a/spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java\n+++ b/spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java\n@@ -18,6 +18,7 @@\n \n import java.text.SimpleDateFormat;\n import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n import java.util.Date;\n import java.util.LinkedHashMap;\n import java.util.Map;\n@@ -500,12 +501,12 @@ private void removeLockKey() {\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t\telse if (Boolean.FALSE.equals(unlinkResult)) {\n-\t\t\t\t\tthrow new IllegalStateException(\"Lock was released in the store due to expiration. \" +\n+\t\t\t\t\tthrow new ConcurrentModificationException(\"Lock was released in the store due to expiration. \" +\n \t\t\t\t\t\t\t\"The integrity of data protected by this lock may have been compromised.\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (!removeLockKeyInnerDelete()) {\n-\t\t\t\tthrow new IllegalStateException(\"Lock was released in the store due to expiration. \" +\n+\t\t\t\tthrow new ConcurrentModificationException(\"Lock was released in the store due to expiration. \" +\n \t\t\t\t\t\t\"The integrity of data protected by this lock may have been compromised.\");\n \t\t\t}\n \t\t}\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/jdbc/lock-registry.adoc b/src/reference/antora/modules/ROOT/pages/jdbc/lock-registry.adoc\nindex 1147b5263fb..067a3e6c66e 100644\n--- a/src/reference/antora/modules/ROOT/pages/jdbc/lock-registry.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/jdbc/lock-registry.adoc\n@@ -57,3 +57,5 @@ For example, an insert query for PostgreSQL hint can be configured like this:\n lockRepository.setInsertQuery(lockRepository.getInsertQuery() + \" ON CONFLICT DO NOTHING\");\n ----\n \n+Starting with version 6.4, the `LockRepository.delete()` method return the result of removing ownership of a distributed lock.\n+And the `JdbcLockRegistry.JdbcLock.unlock()` method throws `ConcurrentModificationException` if the ownership of the lock is expired.\n\\ No newline at end of file\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/redis.adoc b/src/reference/antora/modules/ROOT/pages/redis.adoc\nindex 251d27026ef..545777fb361 100644\n--- a/src/reference/antora/modules/ROOT/pages/redis.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/redis.adoc\n@@ -855,3 +855,5 @@ Default.\n \n The pub-sub is preferred mode - less network chatter between client Redis server, and more performant - the lock is acquired immediately when subscription is notified about unlocking in the other process.\n However, the Redis does not support pub-sub in the Master/Replica connections (for example in AWS ElastiCache environment), therefore a busy-spin mode is chosen as a default to make the registry working in any environment.\n+\n+Starting with version 6.4, instead of throwing `IllegalStateException`, the `RedisLockRegistry.RedisLock.unlock()` method throws `ConcurrentModificationException` if the ownership of the lock is expired.\n\\ No newline at end of file\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/whats-new.adoc b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\nindex 9328aec8297..02dd1c76b81 100644\n--- a/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n@@ -32,7 +32,15 @@ The `LobHandler` (and respective API) has been deprecated for removal in Spring\n Respective option on `JdbcMessageStore` (and similar) have been deprecated as well.\n The byte array handling for serialized message is fully deferred to JDBC driver.\n \n+The `LockRepository.delete()` method return the result of removing ownership of a distributed lock.\n+And the `JdbcLockRegistry.JdbcLock.unlock()` method throws `ConcurrentModificationException` if the ownership of the lock is expired.\n+\n [[x6.4-zeromq-changes]]\n === ZeroMQ Changes\n \n-The outbound component `ZeroMqMessageHandler` (and respective API) can now bind a TCP port instead of connecting to a given URL.\n\\ No newline at end of file\n+The outbound component `ZeroMqMessageHandler` (and respective API) can now bind a TCP port instead of connecting to a given URL.\n+\n+[[x6.4-redis-changes]]\n+=== Redis Changes\n+\n+Instead of throwing `IllegalStateException`, the `RedisLockRegistry.RedisLock.unlock()` method throws `ConcurrentModificationException` if the ownership of the lock is expired.\n\\ No newline at end of file\n",
    "test_patch": "diff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryDelegateTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryDelegateTests.java\nindex 2ff6a720d8c..28f5db6ffff 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryDelegateTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryDelegateTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2022 the original author or authors.\n+ * Copyright 2020-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,7 +17,6 @@\n package org.springframework.integration.jdbc.lock;\n \n import java.util.Random;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n \n@@ -31,17 +30,17 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.ArgumentMatchers.anyString;\n-import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n /**\n  * @author Olivier Hubaut\n  * @author Fran Aranda\n+ * @author Eddie Cho\n  *\n  * @since 5.2.11\n  */\n-public class JdbcLockRegistryDelegateTests {\n+class JdbcLockRegistryDelegateTests {\n \n \tprivate JdbcLockRegistry registry;\n \n@@ -56,7 +55,7 @@ public void clear() {\n \t}\n \n \t@Test\n-\tpublic void testLessAmountOfUnlockThanLock() {\n+\tvoid testLessAmountOfUnlockThanLock() {\n \t\tfinal Random random = new Random();\n \t\tfinal int lockCount = random.nextInt(5) + 1;\n \t\tfinal int unlockCount = random.nextInt(lockCount);\n@@ -73,11 +72,13 @@ public void testLessAmountOfUnlockThanLock() {\n \t}\n \n \t@Test\n-\tpublic void testSameAmountOfUnlockThanLock() {\n+\tvoid testSameAmountOfUnlockThanLock() {\n \t\tfinal Random random = new Random();\n \t\tfinal int lockCount = random.nextInt(5) + 1;\n \n \t\tfinal Lock lock = registry.obtain(\"foo\");\n+\t\twhen(repository.delete(anyString())).thenReturn(true);\n+\n \t\tfor (int i = 0; i < lockCount; i++) {\n \t\t\tlock.tryLock();\n \t\t}\n@@ -89,17 +90,13 @@ public void testSameAmountOfUnlockThanLock() {\n \t}\n \n \t@Test\n-\tpublic void testTransientDataAccessException() {\n+\tvoid testTransientDataAccessException() {\n \t\tfinal Lock lock = registry.obtain(\"foo\");\n \t\tlock.tryLock();\n \n-\t\tfinal AtomicBoolean shouldThrow = new AtomicBoolean(true);\n-\t\tdoAnswer(invocation -> {\n-\t\t\tif (shouldThrow.getAndSet(false)) {\n-\t\t\t\tthrow mock(TransientDataAccessException.class);\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}).when(repository).delete(anyString());\n+\t\twhen(repository.delete(anyString()))\n+\t\t\t\t.thenThrow(mock(TransientDataAccessException.class))\n+\t\t\t\t.thenReturn(true);\n \n \t\tlock.unlock();\n \n@@ -107,17 +104,13 @@ public void testTransientDataAccessException() {\n \t}\n \n \t@Test\n-\tpublic void testTransactionTimedOutException() {\n+\tvoid testTransactionTimedOutException() {\n \t\tfinal Lock lock = registry.obtain(\"foo\");\n \t\tlock.tryLock();\n \n-\t\tfinal AtomicBoolean shouldThrow = new AtomicBoolean(true);\n-\t\tdoAnswer(invocation -> {\n-\t\t\tif (shouldThrow.getAndSet(false)) {\n-\t\t\t\tthrow mock(TransactionTimedOutException.class);\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}).when(repository).delete(anyString());\n+\t\twhen(repository.delete(anyString()))\n+\t\t\t\t.thenThrow(TransactionTimedOutException.class)\n+\t\t\t\t.thenReturn(true);\n \n \t\tlock.unlock();\n \n@@ -125,17 +118,13 @@ public void testTransactionTimedOutException() {\n \t}\n \n \t@Test\n-\tpublic void testTransactionSystemException() {\n+\tvoid testTransactionSystemException() {\n \t\tfinal Lock lock = registry.obtain(\"foo\");\n \t\tlock.tryLock();\n \n-\t\tfinal AtomicBoolean shouldThrow = new AtomicBoolean(true);\n-\t\tdoAnswer(invocation -> {\n-\t\t\tif (shouldThrow.getAndSet(false)) {\n-\t\t\t\tthrow mock(TransactionSystemException.class);\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}).when(repository).delete(anyString());\n+\t\twhen(repository.delete(anyString()))\n+\t\t\t\t.thenThrow(TransactionSystemException.class)\n+\t\t\t\t.thenReturn(true);\n \n \t\tlock.unlock();\n \n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryDifferentClientTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryDifferentClientTests.java\nindex bcd040e6514..394bf935e24 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryDifferentClientTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryDifferentClientTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2022 the original author or authors.\n+ * Copyright 2016-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,6 +17,7 @@\n package org.springframework.integration.jdbc.lock;\n \n import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n import java.util.List;\n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.Callable;\n@@ -45,18 +46,20 @@\n import org.springframework.util.StopWatch;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n /**\n  * @author Dave Syer\n  * @author Artem Bilan\n  * @author Glenn Renfro\n  * @author Alexandre Strubel\n+ * @author Eddie Cho\n  *\n  * @since 4.3\n  */\n @SpringJUnitConfig(locations = \"JdbcLockRegistryTests-context.xml\")\n @DirtiesContext\n-public class JdbcLockRegistryDifferentClientTests {\n+class JdbcLockRegistryDifferentClientTests {\n \n \tprivate static final Log LOGGER = LogFactory.getLog(JdbcLockRegistryDifferentClientTests.class);\n \n@@ -92,7 +95,7 @@ public void close() {\n \t}\n \n \t@Test\n-\tpublic void testSecondThreadLoses() throws Exception {\n+\tvoid testSecondThreadLoses() throws Exception {\n \t\tfor (int i = 0; i < 100; i++) {\n \t\t\tfinal JdbcLockRegistry registry1 = this.registry;\n \t\t\tfinal JdbcLockRegistry registry2 = this.child.getBean(JdbcLockRegistry.class);\n@@ -129,7 +132,7 @@ public void testSecondThreadLoses() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testBothLock() throws Exception {\n+\tvoid testBothLock() throws Exception {\n \t\tfor (int i = 0; i < 100; i++) {\n \t\t\tfinal JdbcLockRegistry registry1 = this.registry;\n \t\t\tfinal JdbcLockRegistry registry2 = this.child.getBean(JdbcLockRegistry.class);\n@@ -185,7 +188,7 @@ public void testBothLock() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testOnlyOneLock() throws Exception {\n+\tvoid testOnlyOneLock() throws Exception {\n \t\tfor (int i = 0; i < 100; i++) {\n \t\t\tfinal BlockingQueue<String> locked = new LinkedBlockingQueue<>();\n \t\t\tfinal CountDownLatch latch = new CountDownLatch(20);\n@@ -231,7 +234,7 @@ public void testOnlyOneLock() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testExclusiveAccess() throws Exception {\n+\tvoid testExclusiveAccess() throws Exception {\n \t\tDefaultLockRepository client1 = new DefaultLockRepository(dataSource);\n \t\tclient1.setApplicationContext(this.context);\n \t\tclient1.afterPropertiesSet();\n@@ -281,7 +284,7 @@ public void testExclusiveAccess() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testOutOfDateLockTaken() throws Exception {\n+\tvoid testOutOfDateLockTaken() throws Exception {\n \t\tDefaultLockRepository client1 = new DefaultLockRepository(dataSource);\n \t\tclient1.setTimeToLive(100);\n \t\tclient1.setApplicationContext(this.context);\n@@ -314,7 +317,7 @@ public void testOutOfDateLockTaken() throws Exception {\n \t\t\t\t});\n \t\tassertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();\n \t\tdata.add(2);\n-\t\tlock1.unlock();\n+\t\tassertThatThrownBy(lock1::unlock).isInstanceOf(ConcurrentModificationException.class);\n \t\tfor (int i = 0; i < 2; i++) {\n \t\t\tInteger integer = data.poll(10, TimeUnit.SECONDS);\n \t\t\tassertThat(integer).isNotNull();\n@@ -323,7 +326,7 @@ public void testOutOfDateLockTaken() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testRenewLock() throws Exception {\n+\tvoid testRenewLock() throws Exception {\n \t\tDefaultLockRepository client1 = new DefaultLockRepository(dataSource);\n \t\tclient1.setTimeToLive(500);\n \t\tclient1.setApplicationContext(this.context);\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryTests.java\nindex 85879f923ac..e4190770f96 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryTests.java\n@@ -16,6 +16,7 @@\n \n package org.springframework.integration.jdbc.lock;\n \n+import java.util.ConcurrentModificationException;\n import java.util.Map;\n import java.util.Queue;\n import java.util.concurrent.CountDownLatch;\n@@ -53,12 +54,13 @@\n  * @author Stefan Vassilev\n  * @author Alexandre Strubel\n  * @author Unseok Kim\n+ * @author Eddie Cho\n  *\n  * @since 4.3\n  */\n @SpringJUnitConfig\n @DirtiesContext\n-public class JdbcLockRegistryTests {\n+class JdbcLockRegistryTests {\n \n \tprivate final AsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor();\n \n@@ -84,7 +86,7 @@ public void clear() {\n \t}\n \n \t@Test\n-\tpublic void testLock() throws Exception {\n+\tvoid testLock() throws Exception {\n \t\tfor (int i = 0; i < 10; i++) {\n \t\t\tLock lock = this.registry.obtain(\"foo\");\n \t\t\tlock.lock();\n@@ -102,7 +104,7 @@ public void testLock() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testLockInterruptibly() throws Exception {\n+\tvoid testLockInterruptibly() throws Exception {\n \t\tfor (int i = 0; i < 10; i++) {\n \t\t\tLock lock = this.registry.obtain(\"foo\");\n \t\t\tlock.lockInterruptibly();\n@@ -116,7 +118,7 @@ public void testLockInterruptibly() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testReentrantLock() {\n+\tvoid testReentrantLock() {\n \t\tfor (int i = 0; i < 10; i++) {\n \t\t\tLock lock1 = this.registry.obtain(\"foo\");\n \t\t\tlock1.lock();\n@@ -133,7 +135,7 @@ public void testReentrantLock() {\n \t}\n \n \t@Test\n-\tpublic void testReentrantLockInterruptibly() throws Exception {\n+\tvoid testReentrantLockInterruptibly() throws Exception {\n \t\tfor (int i = 0; i < 10; i++) {\n \t\t\tLock lock1 = this.registry.obtain(\"foo\");\n \t\t\tlock1.lockInterruptibly();\n@@ -150,7 +152,7 @@ public void testReentrantLockInterruptibly() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testReentrantLockAfterExpiration() throws Exception {\n+\tvoid testReentrantLockAfterExpiration() throws Exception {\n \t\tDefaultLockRepository client = new DefaultLockRepository(dataSource);\n \t\tclient.setTimeToLive(1);\n \t\tclient.setApplicationContext(this.context);\n@@ -172,7 +174,7 @@ public void testReentrantLockAfterExpiration() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testTwoLocks() throws Exception {\n+\tvoid testTwoLocks() throws Exception {\n \t\tfor (int i = 0; i < 10; i++) {\n \t\t\tLock lock1 = this.registry.obtain(\"foo\");\n \t\t\tlock1.lockInterruptibly();\n@@ -189,7 +191,7 @@ public void testTwoLocks() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testTwoThreadsSecondFailsToGetLock() throws Exception {\n+\tvoid testTwoThreadsSecondFailsToGetLock() throws Exception {\n \t\tfinal Lock lock1 = this.registry.obtain(\"foo\");\n \t\tlock1.lockInterruptibly();\n \t\tfinal AtomicBoolean locked = new AtomicBoolean();\n@@ -215,7 +217,7 @@ public void testTwoThreadsSecondFailsToGetLock() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testTwoThreads() throws Exception {\n+\tvoid testTwoThreads() throws Exception {\n \t\tfinal Lock lock1 = this.registry.obtain(\"foo\");\n \t\tfinal AtomicBoolean locked = new AtomicBoolean();\n \t\tfinal CountDownLatch latch1 = new CountDownLatch(1);\n@@ -247,7 +249,7 @@ public void testTwoThreads() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testTwoThreadsDifferentRegistries() throws Exception {\n+\tvoid testTwoThreadsDifferentRegistries() throws Exception {\n \t\tfor (int i = 0; i < 100; i++) {\n \n \t\t\tfinal JdbcLockRegistry registry1 = new JdbcLockRegistry(this.client);\n@@ -289,7 +291,7 @@ public void testTwoThreadsDifferentRegistries() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testTwoThreadsWrongOneUnlocks() throws Exception {\n+\tvoid testTwoThreadsWrongOneUnlocks() throws Exception {\n \t\tfinal Lock lock = this.registry.obtain(\"foo\");\n \t\tlock.lockInterruptibly();\n \t\tfinal AtomicBoolean locked = new AtomicBoolean();\n@@ -314,7 +316,7 @@ public void testTwoThreadsWrongOneUnlocks() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testLockRenew() {\n+\tvoid testLockRenew() {\n \t\tfinal Lock lock = this.registry.obtain(\"foo\");\n \n \t\tassertThat(lock.tryLock()).isTrue();\n@@ -327,7 +329,7 @@ public void testLockRenew() {\n \t}\n \n \t@Test\n-\tpublic void testLockRenewLockNotOwned() {\n+\tvoid testLockRenewLockNotOwned() {\n \t\tthis.registry.obtain(\"foo\");\n \n \t\tassertThatExceptionOfType(IllegalMonitorStateException.class)\n@@ -335,7 +337,7 @@ public void testLockRenewLockNotOwned() {\n \t}\n \n \t@Test\n-\tpublic void concurrentObtainCapacityTest() throws InterruptedException {\n+\tvoid concurrentObtainCapacityTest() throws InterruptedException {\n \t\tfinal int KEY_CNT = 500;\n \t\tfinal int CAPACITY_CNT = 179;\n \t\tfinal int THREAD_CNT = 4;\n@@ -371,7 +373,7 @@ public void concurrentObtainCapacityTest() throws InterruptedException {\n \t}\n \n \t@Test\n-\tpublic void concurrentObtainRemoveOrderTest() throws InterruptedException {\n+\tvoid concurrentObtainRemoveOrderTest() throws InterruptedException {\n \t\tfinal int THREAD_CNT = 2;\n \t\tfinal int DUMMY_LOCK_CNT = 3;\n \n@@ -415,7 +417,7 @@ public void concurrentObtainRemoveOrderTest() throws InterruptedException {\n \t}\n \n \t@Test\n-\tpublic void concurrentObtainAccessRemoveOrderTest() throws InterruptedException {\n+\tvoid concurrentObtainAccessRemoveOrderTest() throws InterruptedException {\n \t\tfinal int THREAD_CNT = 2;\n \t\tfinal int DUMMY_LOCK_CNT = 3;\n \n@@ -465,7 +467,7 @@ public void concurrentObtainAccessRemoveOrderTest() throws InterruptedException\n \t}\n \n \t@Test\n-\tpublic void setCapacityTest() {\n+\tvoid setCapacityTest() {\n \t\tfinal int CAPACITY_CNT = 4;\n \t\tregistry.setCacheCapacity(CAPACITY_CNT);\n \n@@ -506,6 +508,51 @@ void noTableThrowsExceptionOnStart() {\n \t\t}\n \t}\n \n+\t@Test\n+\tvoid testUnlockAfterLockStatusHasBeenExpiredAndLockHasBeenAcquiredByAnotherProcess() throws Exception {\n+\t\tint ttl = 100;\n+\t\tDefaultLockRepository client1 = new DefaultLockRepository(dataSource);\n+\t\tclient1.setApplicationContext(this.context);\n+\t\tclient1.setTimeToLive(ttl);\n+\t\tclient1.afterPropertiesSet();\n+\t\tclient1.afterSingletonsInstantiated();\n+\t\tDefaultLockRepository client2 = new DefaultLockRepository(dataSource);\n+\t\tclient2.setApplicationContext(this.context);\n+\t\tclient2.setTimeToLive(ttl);\n+\t\tclient2.afterPropertiesSet();\n+\t\tclient2.afterSingletonsInstantiated();\n+\t\tJdbcLockRegistry process1Registry = new JdbcLockRegistry(client1);\n+\t\tJdbcLockRegistry process2Registry = new JdbcLockRegistry(client2);\n+\t\tLock lock1 = process1Registry.obtain(\"foo\");\n+\t\tLock lock2 = process2Registry.obtain(\"foo\");\n+\n+\t\tlock1.lock();\n+\t\tThread.sleep(ttl);\n+\t\tassertThat(lock2.tryLock()).isTrue();\n+\n+\t\tassertThatExceptionOfType(ConcurrentModificationException.class)\n+\t\t\t\t.isThrownBy(lock1::unlock);\n+\t\tlock2.unlock();\n+\t}\n+\n+\t@Test\n+\tvoid testUnlockAfterLockStatusHasBeenExpiredAndDeleted() throws Exception {\n+\t\tDefaultLockRepository client = new DefaultLockRepository(dataSource);\n+\t\tclient.setApplicationContext(this.context);\n+\t\tclient.setTimeToLive(100);\n+\t\tclient.afterPropertiesSet();\n+\t\tclient.afterSingletonsInstantiated();\n+\t\tJdbcLockRegistry registry = new JdbcLockRegistry(client);\n+\t\tLock lock = registry.obtain(\"foo\");\n+\n+\t\tlock.lock();\n+\t\tThread.sleep(200);\n+\t\tclient.deleteExpired();\n+\n+\t\tassertThatExceptionOfType(ConcurrentModificationException.class)\n+\t\t\t\t.isThrownBy(lock::unlock);\n+\t}\n+\n \t@SuppressWarnings(\"unchecked\")\n \tprivate static Map<String, Lock> getRegistryLocks(JdbcLockRegistry registry) {\n \t\treturn TestUtils.getPropertyValue(registry, \"locks\", Map.class);\n\ndiff --git a/spring-integration-redis/src/test/java/org/springframework/integration/redis/util/RedisLockRegistryTests.java b/spring-integration-redis/src/test/java/org/springframework/integration/redis/util/RedisLockRegistryTests.java\nindex a0874de6202..b04659b6d0d 100644\n--- a/spring-integration-redis/src/test/java/org/springframework/integration/redis/util/RedisLockRegistryTests.java\n+++ b/spring-integration-redis/src/test/java/org/springframework/integration/redis/util/RedisLockRegistryTests.java\n@@ -16,6 +16,7 @@\n \n package org.springframework.integration.redis.util;\n \n+import java.util.ConcurrentModificationException;\n import java.util.List;\n import java.util.Map;\n import java.util.Queue;\n@@ -52,8 +53,8 @@\n import org.springframework.integration.test.util.TestUtils;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatIllegalStateException;\n import static org.assertj.core.api.Assertions.assertThatNoException;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n import static org.mockito.Mockito.mock;\n \n /**\n@@ -64,6 +65,7 @@\n  * @author Unseok Kim\n  * @author Artem Vozhdayenko\n  * @author Anton Gabov\n+ * @author Eddie Cho\n  *\n  * @since 4.0\n  *\n@@ -115,6 +117,19 @@ void testLock(RedisLockType testRedisLockType) {\n \t\tregistry.destroy();\n \t}\n \n+\t@ParameterizedTest\n+\t@EnumSource(RedisLockType.class)\n+\tvoid testUnlockAfterLockStatusHasBeenExpired(RedisLockType testRedisLockType) throws InterruptedException {\n+\t\tRedisLockRegistry registry = new RedisLockRegistry(redisConnectionFactory, this.registryKey, 100);\n+\t\tregistry.setRedisLockType(testRedisLockType);\n+\t\tLock lock = registry.obtain(\"foo\");\n+\t\tlock.lock();\n+\t\tThread.sleep(200);\n+\n+\t\tassertThatThrownBy(lock::unlock).isInstanceOf(ConcurrentModificationException.class);\n+\t\tregistry.destroy();\n+\t}\n+\n \t@ParameterizedTest\n \t@EnumSource(RedisLockType.class)\n \tvoid testLockInterruptibly(RedisLockType testRedisLockType) throws Exception {\n@@ -398,9 +413,9 @@ void testExceptionOnExpire(RedisLockType testRedisLockType) throws Exception {\n \t\tLock lock1 = registry.obtain(\"foo\");\n \t\tassertThat(lock1.tryLock()).isTrue();\n \t\twaitForExpire(\"foo\");\n-\t\tassertThatIllegalStateException()\n-\t\t\t\t.isThrownBy(lock1::unlock)\n-\t\t\t\t.withMessageContaining(\"Lock was released in the store due to expiration.\");\n+\t\tassertThatThrownBy(lock1::unlock)\n+\t\t\t\t.isInstanceOf(ConcurrentModificationException.class)\n+\t\t\t\t.hasMessageContaining(\"Lock was released in the store due to expiration.\");\n \t\tregistry.destroy();\n \t}\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9284",
    "pr_id": 9284,
    "issue_id": 9259,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Restore ReactorContext into Imperative Processing\n`ReactorContext` is NOT carried onto the following Imperative processing and this results in a new ObservationContext (change in traceId)\r\n\r\nSO reference - https://stackoverflow.com/questions/78653090/spring-integration-restore-reactorcontext-into-imperative-processing\r\n\r\nIssue happening with **Spring Boot v3.3.0**",
    "issue_word_count": 46,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java",
      "spring-integration-webflux/src/test/java/org/springframework/integration/webflux/observation/WebFluxObservationPropagationTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-webflux/src/test/java/org/springframework/integration/webflux/observation/WebFluxObservationPropagationTests.java"
    ],
    "base_commit": "7a371d637b09a48d9fb0f53b3da708ce2a5b0963",
    "head_commit": "b1873f7756b3378491b03db135ba2d4ac9e3d001",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9284",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9284",
    "dockerfile": "",
    "pr_merged_at": "2024-06-28T18:01:46.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java\nindex 021b81e714c..5838ad7f9fa 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2023 the original author or authors.\n+ * Copyright 2014-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -30,6 +30,7 @@\n import java.util.function.BiConsumer;\n \n import org.reactivestreams.Publisher;\n+import reactor.core.Exceptions;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n import reactor.core.scheduler.Schedulers;\n@@ -47,6 +48,7 @@\n import org.springframework.integration.routingslip.RoutingSlipRouteStrategy;\n import org.springframework.integration.support.AbstractIntegrationMessageBuilder;\n import org.springframework.integration.support.utils.IntegrationUtils;\n+import org.springframework.integration.util.IntegrationReactiveUtils;\n import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageChannel;\n@@ -366,6 +368,7 @@ private static Publisher<?> toPublisherReply(Object reply, @Nullable ReactiveAda\n \t\t}\n \t}\n \n+\t@SuppressWarnings(\"try\")\n \tprivate static CompletableFuture<?> toFutureReply(Object reply, @Nullable ReactiveAdapter reactiveAdapter) {\n \t\tif (reactiveAdapter != null) {\n \t\t\tMono<?> reactiveReply;\n@@ -377,7 +380,31 @@ private static CompletableFuture<?> toFutureReply(Object reply, @Nullable Reacti\n \t\t\t\treactiveReply = Mono.from(publisher);\n \t\t\t}\n \n-\t\t\treturn reactiveReply.publishOn(Schedulers.boundedElastic()).toFuture();\n+\t\t\tCompletableFuture<Object> replyFuture = new CompletableFuture<>();\n+\n+\t\t\treactiveReply\n+\t\t\t\t\t.publishOn(Schedulers.boundedElastic())\n+\t\t\t\t\t// TODO until Reactor supports context propagation from the MonoToCompletableFuture\n+\t\t\t\t\t.doOnEach((signal) -> {\n+\t\t\t\t\t\ttry (AutoCloseable scope = IntegrationReactiveUtils\n+\t\t\t\t\t\t\t\t.setThreadLocalsFromReactorContext(signal.getContextView())) {\n+\n+\t\t\t\t\t\t\tif (signal.isOnError()) {\n+\t\t\t\t\t\t\t\treplyFuture.completeExceptionally(signal.getThrowable());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\treplyFuture.complete(signal.get());\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\t\tthrow Exceptions.bubble(ex);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t})\n+\t\t\t\t\t.contextCapture()\n+\t\t\t\t\t.subscribe();\n+\n+\t\t\treturn replyFuture;\n \t\t}\n \t\telse {\n \t\t\treturn toCompletableFuture(reply);\n",
    "test_patch": "diff --git a/spring-integration-webflux/src/test/java/org/springframework/integration/webflux/observation/WebFluxObservationPropagationTests.java b/spring-integration-webflux/src/test/java/org/springframework/integration/webflux/observation/WebFluxObservationPropagationTests.java\nindex 4050d0a8521..92a985c5f73 100644\n--- a/spring-integration-webflux/src/test/java/org/springframework/integration/webflux/observation/WebFluxObservationPropagationTests.java\n+++ b/spring-integration-webflux/src/test/java/org/springframework/integration/webflux/observation/WebFluxObservationPropagationTests.java\n@@ -36,26 +36,33 @@\n import io.micrometer.tracing.test.simple.SpansAssert;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import reactor.core.publisher.Mono;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.io.buffer.DataBuffer;\n import org.springframework.http.HttpMethod;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.client.reactive.ClientHttpConnector;\n import org.springframework.http.server.reactive.HttpHandler;\n import org.springframework.integration.channel.FluxMessageChannel;\n import org.springframework.integration.config.EnableIntegration;\n import org.springframework.integration.config.EnableIntegrationManagement;\n+import org.springframework.integration.core.MessagingTemplate;\n import org.springframework.integration.dsl.IntegrationFlow;\n import org.springframework.integration.webflux.dsl.WebFlux;\n import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageChannel;\n import org.springframework.messaging.PollableChannel;\n import org.springframework.test.annotation.DirtiesContext;\n import org.springframework.test.context.junit.jupiter.web.SpringJUnitWebConfig;\n import org.springframework.test.web.reactive.server.HttpHandlerConnector;\n import org.springframework.test.web.reactive.server.WebTestClient;\n import org.springframework.web.reactive.config.EnableWebFlux;\n+import org.springframework.web.reactive.function.client.WebClient;\n import org.springframework.web.server.adapter.WebHttpHandlerBuilder;\n \n import static org.assertj.core.api.Assertions.assertThat;\n@@ -81,6 +88,10 @@ public class WebFluxObservationPropagationTests {\n \t@Autowired\n \tprivate PollableChannel testChannel;\n \n+\t@Autowired\n+\t@Qualifier(\"webFluxRequestReplyClientFlow.input\")\n+\tprivate MessageChannel webFluxRequestReplyClientFlowInput;\n+\n \t@BeforeEach\n \tvoid setup() {\n \t\tSPANS.clear();\n@@ -122,6 +133,20 @@ void observationIsPropagatedWebFluxRequestReply() {\n \t\t\t\t.haveSameTraceId();\n \t}\n \n+\t@Test\n+\tvoid observationIsPropagatedWebFluxClientRequestReply() {\n+\t\tString result =\n+\t\t\t\tnew MessagingTemplate()\n+\t\t\t\t\t\t.convertSendAndReceive(this.webFluxRequestReplyClientFlowInput, \"test\", String.class);\n+\n+\t\tassertThat(result).isEqualTo(\"SOME REPLY\");\n+\n+\t\t// There is a race condition when we already have a reply, but the span in the last channel is not closed yet.\n+\t\tawait().untilAsserted(() -> assertThat(SPANS.spans()).hasSize(5));\n+\t\tSpansAssert.assertThat(SPANS.spans().stream().map(BraveFinishedSpan::fromBrave).collect(Collectors.toList()))\n+\t\t\t\t.haveSameTraceId();\n+\t}\n+\n \t@Configuration\n \t@EnableWebFlux\n \t@EnableIntegration\n@@ -188,6 +213,29 @@ FluxMessageChannel webFluxRequestChannel() {\n \t\t\treturn new FluxMessageChannel();\n \t\t}\n \n+\t\t@Bean\n+\t\tIntegrationFlow webFluxRequestReplyClientFlow(ObservationRegistry registry) {\n+\t\t\tClientHttpConnector httpConnector =\n+\t\t\t\t\tnew HttpHandlerConnector((request, response) -> {\n+\t\t\t\t\t\tresponse.setStatusCode(HttpStatus.OK);\n+\n+\t\t\t\t\t\tMono<DataBuffer> replyData = Mono.just(response.bufferFactory().wrap(\"some reply\".getBytes()));\n+\n+\t\t\t\t\t\treturn response.writeWith(replyData)\n+\t\t\t\t\t\t\t\t.then(Mono.defer(response::setComplete));\n+\t\t\t\t\t});\n+\t\t\tWebClient webClient =\n+\t\t\t\t\tWebClient.builder()\n+\t\t\t\t\t\t\t.clientConnector(httpConnector)\n+\t\t\t\t\t\t\t.observationRegistry(registry)\n+\t\t\t\t\t\t\t.build();\n+\n+\t\t\treturn f -> f\n+\t\t\t\t\t.handle(WebFlux.outboundGateway(message -> \"/someRequest\", webClient)\n+\t\t\t\t\t\t\t.expectedResponseType(String.class))\n+\t\t\t\t\t.<String, String>transform(String::toUpperCase);\n+\t\t}\n+\n \t\t@Bean\n \t\tIntegrationFlow webFluxRequestReplyFlow(\n \t\t\t\t@Qualifier(\"webFluxRequestChannel\") FluxMessageChannel webFluxRequestChannel) {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9277",
    "pr_id": 9277,
    "issue_id": 9271,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Refactor to Eliminate Repetitive Mock Object Creation in TcpMessageMapperTests.java\nHi there!\r\n\r\nWhile working with the `TcpMessageMapperTests` class, I noticed two mock variables repeatedly created across various tests. To simplify the code, I propose a small refactor to eliminate these redundancies, which could reduce the code by 41 lines.\r\n\r\n1. **Repetitive Mock TcpConnection Creation**: The creation of a mock `TcpConnection` object repeated in 7 test cases.\r\n\r\n2. **Repetitive Mock Socket Creation**: The creation of a mock `Socket` object repeated in 3 test cases.\r\n\r\nSpecifically, here is the refactoring method I propose:\r\n\r\nCreating a mock for `TcpConnection` currently looks like this:\r\n\r\n```java\r\nTcpConnection connection = mock(TcpConnection.class);\r\n//other code...\r\nwhen(connection.getPayload()).thenReturn(TEST_PAYLOAD.getBytes());\r\nwhen(connection.getHostName()).thenReturn(\"MyHost\");\r\nwhen(connection.getHostAddress()).thenReturn(\"1.1.1.1\");\r\nwhen(connection.getPort()).thenReturn(1234);\r\n```\r\n\r\nI introduced a method, `CreatMockTcpConnection`:\r\n\r\n```java\r\npublic TcpConnection CreatMockTcpConnection(Object bytes, String hostName, String ipAdress, int port){\r\n    TcpConnection connection = mock(TcpConnection.class);\r\n    when(connection.getPayload()).thenReturn(bytes);\r\n    when(connection.getHostName()).thenReturn(hostName);\r\n    when(connection.getHostAddress()).thenReturn(ipAdress);\r\n    when(connection.getPort()).thenReturn(port);\r\n    return connection;\r\n}\r\n```\r\n\r\nWith this method, creating a mock `TcpConnection` becomes:\r\n\r\n```java\r\nTcpConnection connection = CreatMockTcpConnection(map, \"someHost\", \"1.1.1.1\", 1234);\r\n```\r\n\r\n\r\nSimilarly, for `Socket`, I introduced a method, `creatMockSocket` as follows:\r\n\r\n```java\r\npublic Socket creatMockSocket(InetAddress local){\r\n    Socket socket = mock(Socket.class);\r\n    when(socket.getLocalAddress()).thenReturn(local);\r\n    return socket;\r\n}\r\n```\r\n\r\nThis allows us to create mocks on one line as well\r\n\r\n\r\n```java\r\nSocket socket = creatMockSocket(local);\r\n```\r\n\r\nI created a draft of the PR, you can see the details file changes  [here](https://github.com/gzhao9/spring-integration/pull/1/files).\r\n\r\n---\r\n\r\nThe refactor reduced the test cases by 41 lines of code, and I believe these changes will improve code readability.",
    "issue_word_count": 283,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "spring-integration-ip/src/test/java/org/springframework/integration/ip/tcp/connection/TcpMessageMapperTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-ip/src/test/java/org/springframework/integration/ip/tcp/connection/TcpMessageMapperTests.java"
    ],
    "base_commit": "12fc353db13db5e4b8a69424520c772704634853",
    "head_commit": "9ab1eea8bc747e2ad0ef7beedd401fc651e20f40",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9277",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9277",
    "dockerfile": "",
    "pr_merged_at": "2024-06-27T15:04:49.000Z",
    "patch": "",
    "test_patch": "diff --git a/spring-integration-ip/src/test/java/org/springframework/integration/ip/tcp/connection/TcpMessageMapperTests.java b/spring-integration-ip/src/test/java/org/springframework/integration/ip/tcp/connection/TcpMessageMapperTests.java\nindex 8e8b73d38da..eb1597f37af 100644\n--- a/spring-integration-ip/src/test/java/org/springframework/integration/ip/tcp/connection/TcpMessageMapperTests.java\n+++ b/spring-integration-ip/src/test/java/org/springframework/integration/ip/tcp/connection/TcpMessageMapperTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -55,7 +55,7 @@\n /**\n  * @author Gary Russell\n  * @author Artem Bilan\n- *\n+ * @author Gengwu Zhao\n  * @since 2.0\n  *\n  */\n@@ -74,15 +74,10 @@ public void setup() {\n \t@Test\n \tpublic void testToMessage() {\n \t\tTcpMessageMapper mapper = new TcpMessageMapper();\n-\t\tTcpConnection connection = mock(TcpConnection.class);\n-\t\tSocket socket = mock(Socket.class);\n+\t\tTcpConnection connection = creatMockTcpConcnection(TEST_PAYLOAD.getBytes(), \"MyHost\", \"1.1.1.1\", 1234);\n \t\tInetAddress local = mock(InetAddress.class);\n+\t\tSocket socket = creatMockSocket(local);\n \t\tSocketInfo info = new SocketInfo(socket);\n-\t\twhen(socket.getLocalAddress()).thenReturn(local);\n-\t\twhen(connection.getPayload()).thenReturn(TEST_PAYLOAD.getBytes());\n-\t\twhen(connection.getHostName()).thenReturn(\"MyHost\");\n-\t\twhen(connection.getHostAddress()).thenReturn(\"1.1.1.1\");\n-\t\twhen(connection.getPort()).thenReturn(1234);\n \t\twhen(connection.getSocketInfo()).thenReturn(info);\n \t\tMessage<?> message = mapper.toMessage(connection);\n \t\tassertThat(new String((byte[]) message.getPayload())).isEqualTo(TEST_PAYLOAD);\n@@ -97,15 +92,10 @@ public void testToMessage() {\n \tpublic void testToMessageWithContentType() {\n \t\tTcpMessageMapper mapper = new TcpMessageMapper();\n \t\tmapper.setAddContentTypeHeader(true);\n-\t\tTcpConnection connection = mock(TcpConnection.class);\n-\t\tSocket socket = mock(Socket.class);\n+\t\tTcpConnection connection = creatMockTcpConcnection(TEST_PAYLOAD.getBytes(), \"MyHost\", \"1.1.1.1\", 1234);\n \t\tInetAddress local = mock(InetAddress.class);\n+\t\tSocket socket = creatMockSocket(local);\n \t\tSocketInfo info = new SocketInfo(socket);\n-\t\twhen(socket.getLocalAddress()).thenReturn(local);\n-\t\twhen(connection.getPayload()).thenReturn(TEST_PAYLOAD.getBytes());\n-\t\twhen(connection.getHostName()).thenReturn(\"MyHost\");\n-\t\twhen(connection.getHostAddress()).thenReturn(\"1.1.1.1\");\n-\t\twhen(connection.getPort()).thenReturn(1234);\n \t\twhen(connection.getSocketInfo()).thenReturn(info);\n \t\tMessage<?> message = mapper.toMessage(connection);\n \t\tassertThat(new String((byte[]) message.getPayload())).isEqualTo(TEST_PAYLOAD);\n@@ -124,15 +114,10 @@ public void testToMessageWithCustomContentType() {\n \t\tTcpMessageMapper mapper = new TcpMessageMapper();\n \t\tmapper.setAddContentTypeHeader(true);\n \t\tmapper.setContentType(\"application/octet-stream;charset=ISO-8859-1\");\n-\t\tTcpConnection connection = mock(TcpConnection.class);\n-\t\tSocket socket = mock(Socket.class);\n+\t\tTcpConnection connection = creatMockTcpConcnection(TEST_PAYLOAD.getBytes(), \"MyHost\", \"1.1.1.1\", 1234);\n \t\tInetAddress local = mock(InetAddress.class);\n+\t\tSocket socket = creatMockSocket(local);\n \t\tSocketInfo info = new SocketInfo(socket);\n-\t\twhen(socket.getLocalAddress()).thenReturn(local);\n-\t\twhen(connection.getPayload()).thenReturn(TEST_PAYLOAD.getBytes());\n-\t\twhen(connection.getHostName()).thenReturn(\"MyHost\");\n-\t\twhen(connection.getHostAddress()).thenReturn(\"1.1.1.1\");\n-\t\twhen(connection.getPort()).thenReturn(1234);\n \t\twhen(connection.getSocketInfo()).thenReturn(info);\n \t\tMessage<?> message = mapper.toMessage(connection);\n \t\tassertThat(new String((byte[]) message.getPayload())).isEqualTo(TEST_PAYLOAD);\n@@ -366,11 +351,7 @@ public void testMapMessageConvertingInboundJson() throws Exception {\n \t\tMapJsonSerializer deserializer = new MapJsonSerializer();\n \t\tMap<?, ?> map = deserializer.deserialize(new ByteArrayInputStream(json.getBytes(\"UTF-8\")));\n \n-\t\tTcpConnection connection = mock(TcpConnection.class);\n-\t\twhen(connection.getPayload()).thenReturn(map);\n-\t\twhen(connection.getHostName()).thenReturn(\"someHost\");\n-\t\twhen(connection.getHostAddress()).thenReturn(\"1.1.1.1\");\n-\t\twhen(connection.getPort()).thenReturn(1234);\n+\t\tTcpConnection connection = creatMockTcpConcnection(map, \"someHost\", \"1.1.1.1\", 1234);\n \t\twhen(connection.getConnectionId()).thenReturn(\"someId\");\n \t\tMessage<?> message = mapper.toMessage(connection);\n \t\tassertThat(message.getPayload()).isEqualTo(\"foo\");\n@@ -396,11 +377,7 @@ public void testMapMessageConvertingBothWaysJava() throws Exception {\n \n \t\tDefaultDeserializer deserializer = new DefaultDeserializer();\n \t\tmap = (Map<?, ?>) deserializer.deserialize(new ByteArrayInputStream(baos.toByteArray()));\n-\t\tTcpConnection connection = mock(TcpConnection.class);\n-\t\twhen(connection.getPayload()).thenReturn(map);\n-\t\twhen(connection.getHostName()).thenReturn(\"someHost\");\n-\t\twhen(connection.getHostAddress()).thenReturn(\"1.1.1.1\");\n-\t\twhen(connection.getPort()).thenReturn(1234);\n+\t\tTcpConnection connection = creatMockTcpConcnection(map, \"someHost\", \"1.1.1.1\", 1234);\n \t\twhen(connection.getConnectionId()).thenReturn(\"someId\");\n \t\tMessage<?> message = mapper.toMessage(connection);\n \t\tassertThat(message.getPayload()).isEqualTo(\"foo\");\n@@ -420,11 +397,7 @@ public void testCodecMessageConvertingBothWaysJava() {\n \t\tMessageConvertingTcpMessageMapper mapper = new MessageConvertingTcpMessageMapper(converter);\n \t\tbyte[] bytes = (byte[]) mapper.fromMessage(outMessage);\n \n-\t\tTcpConnection connection = mock(TcpConnection.class);\n-\t\twhen(connection.getPayload()).thenReturn(bytes);\n-\t\twhen(connection.getHostName()).thenReturn(\"someHost\");\n-\t\twhen(connection.getHostAddress()).thenReturn(\"1.1.1.1\");\n-\t\twhen(connection.getPort()).thenReturn(1234);\n+\t\tTcpConnection connection = creatMockTcpConcnection(bytes, \"someHost\", \"1.1.1.1\", 1234);\n \t\twhen(connection.getConnectionId()).thenReturn(\"someId\");\n \t\tMessage<?> message = mapper.toMessage(connection);\n \t\tassertThat(message.getPayload()).isEqualTo(\"foo\");\n@@ -444,11 +417,7 @@ public void testWithBytesMapper() {\n \t\tmapper.setBytesMessageMapper(new EmbeddedJsonHeadersMessageMapper());\n \t\tbyte[] bytes = (byte[]) mapper.fromMessage(outMessage);\n \n-\t\tTcpConnection connection = mock(TcpConnection.class);\n-\t\twhen(connection.getPayload()).thenReturn(bytes);\n-\t\twhen(connection.getHostName()).thenReturn(\"someHost\");\n-\t\twhen(connection.getHostAddress()).thenReturn(\"1.1.1.1\");\n-\t\twhen(connection.getPort()).thenReturn(1234);\n+\t\tTcpConnection connection = creatMockTcpConcnection(bytes, \"someHost\", \"1.1.1.1\", 1234);\n \t\twhen(connection.getConnectionId()).thenReturn(\"someId\");\n \t\tMessage<?> message = mapper.toMessage(connection);\n \t\tassertThat(message.getPayload()).isEqualTo(\"foo\");\n@@ -459,4 +428,19 @@ public void testWithBytesMapper() {\n \t\tassertThat(message.getHeaders().get(IpHeaders.CONNECTION_ID)).isEqualTo(\"someId\");\n \t}\n \n+\tprivate static TcpConnection creatMockTcpConcnection(Object bytes, String hostName, String ipAdress, int port) {\n+\t\tTcpConnection connection = mock(TcpConnection.class);\n+\t\twhen(connection.getPayload()).thenReturn(bytes);\n+\t\twhen(connection.getHostName()).thenReturn(hostName);\n+\t\twhen(connection.getHostAddress()).thenReturn(ipAdress);\n+\t\twhen(connection.getPort()).thenReturn(port);\n+\t\treturn connection;\n+\t}\n+\n+\tprivate static Socket creatMockSocket(InetAddress local) {\n+\t\tSocket socket = mock(Socket.class);\n+\t\twhen(socket.getLocalAddress()).thenReturn(local);\n+\t\treturn socket;\n+\t}\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9273",
    "pr_id": 9273,
    "issue_id": 9272,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "SFTP: ClientSession associated with SftpSession is never closed. \n**In what version(s) of Spring Integration are you seeing this issue?**\r\n\r\n6.3.1\r\n\r\n**Describe the bug**\r\n\r\nClientSession associated with SftpSession is never closed. If the SFTP server is not setup to timeout these connections eventually no more connections can be made to the SFTP server. \r\n\r\nAlso described here: [https://stackoverflow.com/questions/78226325/spring-integration-open-a-new-ssh-connection-after-each-sftpexception](https://stackoverflow.com/questions/78226325/spring-integration-open-a-new-ssh-connection-after-each-sftpexception)\r\n\r\n",
    "issue_word_count": 88,
    "test_files_count": 8,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java",
      "spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/dsl/SftpTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/inbound/SftpInboundRemoteFileSystemSynchronizerTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/inbound/SftpMessageSourceTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/outbound/SftpOutboundTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/outbound/SftpServerOutboundTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplateTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpServerTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/dsl/SftpTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/inbound/SftpInboundRemoteFileSystemSynchronizerTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/inbound/SftpMessageSourceTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/outbound/SftpOutboundTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/outbound/SftpServerOutboundTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplateTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpServerTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java"
    ],
    "base_commit": "f2399a4e13ed2a66e5ff1d91e0da70bc00c57d41",
    "head_commit": "a46221e176bdaf66fbe3e3cf08bb4e86942bdb74",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9273",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9273",
    "dockerfile": "",
    "pr_merged_at": "2024-07-01T17:02:35.000Z",
    "patch": "diff --git a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java\nindex da50831a722..c38c1ddfc0a 100644\n--- a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java\n+++ b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2023 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -49,6 +49,7 @@\n import org.apache.sshd.sftp.client.impl.AbstractSftpClient;\n import org.apache.sshd.sftp.client.impl.DefaultSftpClient;\n \n+import org.springframework.beans.factory.DisposableBean;\n import org.springframework.core.io.Resource;\n import org.springframework.integration.context.IntegrationContextUtils;\n import org.springframework.integration.file.remote.session.SessionFactory;\n@@ -74,10 +75,11 @@\n  * @author Auke Zaaiman\n  * @author Christian Tzolov\n  * @author Adama Sorho\n+ * @author Darryl Smith\n  *\n  * @since 2.0\n  */\n-public class DefaultSftpSessionFactory implements SessionFactory<SftpClient.DirEntry>, SharedSessionCapable {\n+public class DefaultSftpSessionFactory implements SessionFactory<SftpClient.DirEntry>, SharedSessionCapable, DisposableBean {\n \n \tprivate final Lock lock = new ReentrantLock();\n \n@@ -421,6 +423,13 @@ protected SftpClient createSftpClient(\n \t\treturn new ConcurrentSftpClient(clientSession, initialVersionSelector, errorDataHandler);\n \t}\n \n+\t@Override\n+\tpublic void destroy() throws Exception {\n+\t\tif (this.isInnerClient && this.sshClient != null && this.sshClient.isStarted()) {\n+\t\t\tthis.sshClient.stop();\n+\t\t}\n+\t}\n+\n \t/**\n \t * The {@link DefaultSftpClient} extension to lock the {@link #send(int, Buffer)}\n \t * for concurrent interaction.\n\ndiff --git a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java\nindex 414cd2fa5de..94d1af1d4b1 100644\n--- a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java\n+++ b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java\n@@ -25,6 +25,7 @@\n import java.util.stream.Stream;\n import java.util.stream.StreamSupport;\n \n+import org.apache.sshd.client.session.ClientSession;\n import org.apache.sshd.common.util.net.SshdSocketAddress;\n import org.apache.sshd.sftp.SftpModuleProperties;\n import org.apache.sshd.sftp.client.SftpClient;\n@@ -47,6 +48,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Christian Tzolov\n+ * @author Darryl Smith\n  * @since 2.0\n  */\n public class SftpSession implements Session<SftpClient.DirEntry> {\n@@ -156,6 +158,16 @@ public void close() {\n \t\tcatch (IOException ex) {\n \t\t\tthrow new UncheckedIOException(\"failed to close an SFTP client\", ex);\n \t\t}\n+\n+\t\ttry {\n+\t\t\tClientSession session = this.sftpClient.getSession();\n+\t\t\tif (session != null && session.isOpen()) {\n+\t\t\t\tsession.close();\n+\t\t\t}\n+\t\t}\n+\t\tcatch (IOException ex) {\n+\t\t\tthrow new UncheckedIOException(\"failed to close an SFTP client (session)\", ex);\n+\t\t}\n \t}\n \n \t@Override\n",
    "test_patch": "diff --git a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/dsl/SftpTests.java b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/dsl/SftpTests.java\nindex 15a7a49922f..f9762a33044 100644\n--- a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/dsl/SftpTests.java\n+++ b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/dsl/SftpTests.java\n@@ -31,6 +31,7 @@\n import org.junit.jupiter.api.condition.OS;\n \n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.integration.IntegrationMessageHeaderAccessor;\n import org.springframework.integration.channel.QueueChannel;\n@@ -43,6 +44,7 @@\n import org.springframework.integration.file.FileHeaders;\n import org.springframework.integration.file.remote.RemoteFileTemplate;\n import org.springframework.integration.file.remote.gateway.AbstractRemoteFileOutboundGateway;\n+import org.springframework.integration.file.remote.session.SessionFactory;\n import org.springframework.integration.file.support.FileExistsMode;\n import org.springframework.integration.sftp.SftpTestSupport;\n import org.springframework.integration.sftp.session.SftpRemoteFileTemplate;\n@@ -59,6 +61,7 @@\n  * @author Gary Russell\n  * @author Joaquin Santana\n  * @author Deepak Gunasekaran\n+ * @author Darryl Smith\n  *\n  * @since 5.0\n  */\n@@ -69,11 +72,14 @@ public class SftpTests extends SftpTestSupport {\n \t@Autowired\n \tprivate IntegrationFlowContext flowContext;\n \n+\t@Autowired\n+\tprivate SessionFactory<SftpClient.DirEntry> sessionFactory;\n+\n \t@Test\n \tpublic void testSftpInboundFlow() {\n \t\tQueueChannel out = new QueueChannel();\n \t\tIntegrationFlow flow = IntegrationFlow\n-\t\t\t\t.from(Sftp.inboundAdapter(sessionFactory())\n+\t\t\t\t.from(Sftp.inboundAdapter(sessionFactory)\n \t\t\t\t\t\t\t\t.preserveTimestamp(true)\n \t\t\t\t\t\t\t\t.remoteDirectory(\"/sftpSource\")\n \t\t\t\t\t\t\t\t.regexFilter(\".*\\\\.txt$\")\n@@ -106,7 +112,7 @@ public void testSftpInboundFlow() {\n \tpublic void testSftpInboundStreamFlow() throws Exception {\n \t\tQueueChannel out = new QueueChannel();\n \t\tStandardIntegrationFlow flow = IntegrationFlow.from(\n-\t\t\t\t\t\tSftp.inboundStreamingAdapter(new SftpRemoteFileTemplate(sessionFactory()))\n+\t\t\t\t\t\tSftp.inboundStreamingAdapter(new SftpRemoteFileTemplate(sessionFactory))\n \t\t\t\t\t\t\t\t.remoteDirectory(\"sftpSource\")\n \t\t\t\t\t\t\t\t.regexFilter(\".*\\\\.txt$\"),\n \t\t\t\t\t\te -> e.id(\"sftpInboundAdapter\").poller(Pollers.fixedDelay(100)))\n@@ -133,7 +139,7 @@ public void testSftpInboundStreamFlow() throws Exception {\n \n \t@Test\n \tpublic void testSftpOutboundFlow() {\n-\t\tIntegrationFlow flow = f -> f.handle(Sftp.outboundAdapter(sessionFactory(), FileExistsMode.FAIL)\n+\t\tIntegrationFlow flow = f -> f.handle(Sftp.outboundAdapter(sessionFactory, FileExistsMode.FAIL)\n \t\t\t\t.useTemporaryFileName(false)\n \t\t\t\t.fileNameExpression(\"headers['\" + FileHeaders.FILENAME + \"']\")\n \t\t\t\t.remoteDirectory(\"sftpTarget\"));\n@@ -143,7 +149,7 @@ public void testSftpOutboundFlow() {\n \t\t\t\t.setHeader(FileHeaders.FILENAME, fileName)\n \t\t\t\t.build());\n \n-\t\tRemoteFileTemplate<SftpClient.DirEntry> template = new RemoteFileTemplate<>(sessionFactory());\n+\t\tRemoteFileTemplate<SftpClient.DirEntry> template = new RemoteFileTemplate<>(sessionFactory);\n \t\tSftpClient.DirEntry[] files =\n \t\t\t\ttemplate.execute(session -> session.list(getTargetRemoteDirectory().getName() + \"/\" + fileName));\n \t\tassertThat(files.length).isEqualTo(1);\n@@ -154,7 +160,7 @@ public void testSftpOutboundFlow() {\n \n \t@Test\n \tpublic void testSftpOutboundFlowSftpTemplate() {\n-\t\tSftpRemoteFileTemplate sftpTemplate = new SftpRemoteFileTemplate(sessionFactory());\n+\t\tSftpRemoteFileTemplate sftpTemplate = new SftpRemoteFileTemplate(sessionFactory);\n \t\tIntegrationFlow flow = f -> f.handle(Sftp.outboundAdapter(sftpTemplate)\n \t\t\t\t.useTemporaryFileName(false)\n \t\t\t\t.fileNameExpression(\"headers['\" + FileHeaders.FILENAME + \"']\")\n@@ -175,7 +181,7 @@ public void testSftpOutboundFlowSftpTemplate() {\n \n \t@Test\n \tpublic void testSftpOutboundFlowSftpTemplateAndMode() {\n-\t\tSftpRemoteFileTemplate sftpTemplate = new SftpRemoteFileTemplate(sessionFactory());\n+\t\tSftpRemoteFileTemplate sftpTemplate = new SftpRemoteFileTemplate(sessionFactory);\n \t\tIntegrationFlow flow = f -> f.handle(Sftp.outboundAdapter(sftpTemplate, FileExistsMode.APPEND)\n \t\t\t\t.useTemporaryFileName(false)\n \t\t\t\t.fileNameExpression(\"headers['\" + FileHeaders.FILENAME + \"']\")\n@@ -200,7 +206,7 @@ public void testSftpOutboundFlowSftpTemplateAndMode() {\n \t@Test\n \t@DisabledOnOs(OS.WINDOWS)\n \tpublic void testSftpOutboundFlowWithChmod() {\n-\t\tIntegrationFlow flow = f -> f.handle(Sftp.outboundAdapter(sessionFactory(), FileExistsMode.FAIL)\n+\t\tIntegrationFlow flow = f -> f.handle(Sftp.outboundAdapter(sessionFactory, FileExistsMode.FAIL)\n \t\t\t\t.useTemporaryFileName(false)\n \t\t\t\t.fileNameExpression(\"headers['\" + FileHeaders.FILENAME + \"']\")\n \t\t\t\t.chmod(0644)\n@@ -211,7 +217,7 @@ public void testSftpOutboundFlowWithChmod() {\n \t\t\t\t.setHeader(FileHeaders.FILENAME, fileName)\n \t\t\t\t.build());\n \n-\t\tRemoteFileTemplate<SftpClient.DirEntry> template = new RemoteFileTemplate<>(sessionFactory());\n+\t\tRemoteFileTemplate<SftpClient.DirEntry> template = new RemoteFileTemplate<>(sessionFactory);\n \t\tSftpClient.DirEntry[] files =\n \t\t\t\ttemplate.execute(session -> session.list(getTargetRemoteDirectory().getName() + \"/\" + fileName));\n \t\tassertThat(files.length).isEqualTo(1);\n@@ -230,7 +236,7 @@ public void testSftpOutboundFlowWithChmod() {\n \tpublic void testSftpMgetFlow() {\n \t\tQueueChannel out = new QueueChannel();\n \t\tIntegrationFlow flow = f -> f\n-\t\t\t\t.handle(Sftp.outboundGateway(sessionFactory(), AbstractRemoteFileOutboundGateway.Command.MGET,\n+\t\t\t\t.handle(Sftp.outboundGateway(sessionFactory, AbstractRemoteFileOutboundGateway.Command.MGET,\n \t\t\t\t\t\t\t\t\"payload\")\n \t\t\t\t\t\t.options(AbstractRemoteFileOutboundGateway.Option.RECURSIVE)\n \t\t\t\t\t\t.regexFileNameFilter(\"(subSftpSource|.*1.txt)\")\n@@ -259,7 +265,7 @@ public void testSftpMgetFlow() {\n \tpublic void testSftpSessionCallback() {\n \t\tQueueChannel out = new QueueChannel();\n \t\tIntegrationFlow flow = f -> f\n-\t\t\t\t.<String>handle((p, h) -> new SftpRemoteFileTemplate(sessionFactory()).execute(s -> s.list(p)))\n+\t\t\t\t.<String>handle((p, h) -> new SftpRemoteFileTemplate(sessionFactory).execute(s -> s.list(p)))\n \t\t\t\t.channel(out);\n \t\tIntegrationFlowRegistration registration = this.flowContext.registration(flow).register();\n \t\tregistration.getInputChannel().send(new GenericMessage<>(\"sftpSource\"));\n@@ -277,7 +283,7 @@ public void testSftpSessionCallback() {\n \tpublic void testSftpMv() {\n \t\tQueueChannel out = new QueueChannel();\n \t\tIntegrationFlow flow = f -> f\n-\t\t\t\t.handle(Sftp.outboundGateway(sessionFactory(), AbstractRemoteFileOutboundGateway.Command.MV, \"payload\")\n+\t\t\t\t.handle(Sftp.outboundGateway(sessionFactory, AbstractRemoteFileOutboundGateway.Command.MV, \"payload\")\n \t\t\t\t\t\t.renameExpression(\"payload.concat('.done')\")\n \t\t\t\t\t\t.remoteDirectoryExpression(\"'sftpSource'\"))\n \t\t\t\t.channel(out);\n@@ -301,6 +307,11 @@ public void testSftpMv() {\n \t@EnableIntegration\n \tpublic static class ContextConfiguration {\n \n+\t\t@Bean\n+\t\tpublic SessionFactory<SftpClient.DirEntry> ftpsessionFactory() {\n+\t\t\treturn SftpTests.sessionFactory();\n+\t\t}\n+\n \t}\n \n }\n\ndiff --git a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/inbound/SftpInboundRemoteFileSystemSynchronizerTests.java b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/inbound/SftpInboundRemoteFileSystemSynchronizerTests.java\nindex acb1383ea7e..1b6cda0141a 100644\n--- a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/inbound/SftpInboundRemoteFileSystemSynchronizerTests.java\n+++ b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/inbound/SftpInboundRemoteFileSystemSynchronizerTests.java\n@@ -61,6 +61,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Joaquin Santana\n+ * @author Darryl Smith\n  *\n  * @since 2.0\n  */\n@@ -160,6 +161,8 @@ public void testCopyFileToLocalDir() throws Exception {\n \t\tms.stop();\n \t\tverify(synchronizer).close();\n \t\tverify(store).close();\n+\n+\t\tftpSessionFactory.destroy();\n \t}\n \n \tpublic static class TestSftpSessionFactory extends DefaultSftpSessionFactory {\n\ndiff --git a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/inbound/SftpMessageSourceTests.java b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/inbound/SftpMessageSourceTests.java\nindex 399738e9cd3..72303bd1df6 100644\n--- a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/inbound/SftpMessageSourceTests.java\n+++ b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/inbound/SftpMessageSourceTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018-2022 the original author or authors.\n+ * Copyright 2018-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,12 +16,15 @@\n \n package org.springframework.integration.sftp.inbound;\n \n+import org.apache.sshd.sftp.client.SftpClient;\n import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.context.ApplicationContext;\n+import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.integration.file.FileHeaders;\n+import org.springframework.integration.file.remote.session.SessionFactory;\n import org.springframework.integration.sftp.SftpTestSupport;\n import org.springframework.messaging.Message;\n import org.springframework.test.annotation.DirtiesContext;\n@@ -32,6 +35,7 @@\n /**\n  * @author Gary Russell\n  * @author Artem bilan\n+ * @author Darryl Smith\n  *\n  * @since 5.0.7\n  *\n@@ -43,6 +47,9 @@ public class SftpMessageSourceTests extends SftpTestSupport {\n \t@Autowired\n \tprivate ApplicationContext context;\n \n+\t@Autowired\n+\tprivate SessionFactory<SftpClient.DirEntry> sessionFactory;\n+\n \t@Test\n \tpublic void testMaxFetch() {\n \t\tSftpInboundFileSynchronizingMessageSource messageSource = buildSource();\n@@ -53,7 +60,7 @@ public void testMaxFetch() {\n \t}\n \n \tprivate SftpInboundFileSynchronizingMessageSource buildSource() {\n-\t\tSftpInboundFileSynchronizer sync = new SftpInboundFileSynchronizer(sessionFactory());\n+\t\tSftpInboundFileSynchronizer sync = new SftpInboundFileSynchronizer(sessionFactory);\n \t\tsync.setRemoteDirectory(\"/sftpSource/\");\n \t\tsync.setBeanFactory(this.context);\n \t\tSftpInboundFileSynchronizingMessageSource messageSource = new SftpInboundFileSynchronizingMessageSource(sync);\n@@ -68,6 +75,11 @@ private SftpInboundFileSynchronizingMessageSource buildSource() {\n \t@Configuration\n \tpublic static class Config {\n \n+\t\t@Bean\n+\t\tpublic SessionFactory<SftpClient.DirEntry> ftpSessionFactory() {\n+\t\t\treturn SftpMessageSourceTests.sessionFactory();\n+\t\t}\n+\n \t}\n \n }\n\ndiff --git a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/outbound/SftpOutboundTests.java b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/outbound/SftpOutboundTests.java\nindex 695b90400a2..6ebf61fd32a 100644\n--- a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/outbound/SftpOutboundTests.java\n+++ b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/outbound/SftpOutboundTests.java\n@@ -76,6 +76,7 @@\n  * @author Gary Russell\n  * @author Gunnar Hillert\n  * @author Artem Bilan\n+ * @author Darryl Smith\n  */\n public class SftpOutboundTests {\n \n@@ -84,7 +85,7 @@ public void testHandleFileMessage() throws Exception {\n \t\tFile targetDir = new File(\"remote-target-dir\");\n \t\tassertThat(targetDir.exists()).as(\"target directory does not exist: \" + targetDir.getName()).isTrue();\n \n-\t\tSessionFactory<SftpClient.DirEntry> sessionFactory = new TestSftpSessionFactory();\n+\t\tTestSftpSessionFactory sessionFactory = new TestSftpSessionFactory();\n \t\tFileTransferringMessageHandler<SftpClient.DirEntry> handler =\n \t\t\t\tnew FileTransferringMessageHandler<>(sessionFactory);\n \t\thandler.setRemoteDirectoryExpression(new LiteralExpression(targetDir.getName()));\n@@ -103,6 +104,8 @@ public void testHandleFileMessage() throws Exception {\n \n \t\thandler.handleMessage(new GenericMessage<>(srcFile));\n \t\tassertThat(destFile.exists()).as(\"destination file was not created\").isTrue();\n+\n+\t\tsessionFactory.destroy();\n \t}\n \n \t@Test\n@@ -111,7 +114,7 @@ public void testHandleStringMessage() throws Exception {\n \t\tif (file.exists()) {\n \t\t\tfile.delete();\n \t\t}\n-\t\tSessionFactory<SftpClient.DirEntry> sessionFactory = new TestSftpSessionFactory();\n+\t\tTestSftpSessionFactory sessionFactory = new TestSftpSessionFactory();\n \t\tFileTransferringMessageHandler<SftpClient.DirEntry> handler =\n \t\t\t\tnew FileTransferringMessageHandler<>(sessionFactory);\n \t\tDefaultFileNameGenerator fGenerator = new DefaultFileNameGenerator();\n@@ -127,6 +130,8 @@ public void testHandleStringMessage() throws Exception {\n \t\tbyte[] inFile = FileCopyUtils.copyToByteArray(file);\n \t\tassertThat(new String(inFile)).isEqualTo(\"String data\");\n \t\tfile.delete();\n+\n+\t\tsessionFactory.destroy();\n \t}\n \n \t@Test\n@@ -135,7 +140,7 @@ public void testHandleBytesMessage() throws Exception {\n \t\tif (file.exists()) {\n \t\t\tfile.delete();\n \t\t}\n-\t\tSessionFactory<SftpClient.DirEntry> sessionFactory = new TestSftpSessionFactory();\n+\t\tTestSftpSessionFactory sessionFactory = new TestSftpSessionFactory();\n \t\tFileTransferringMessageHandler<SftpClient.DirEntry> handler =\n \t\t\t\tnew FileTransferringMessageHandler<>(sessionFactory);\n \t\tDefaultFileNameGenerator fGenerator = new DefaultFileNameGenerator();\n@@ -151,6 +156,8 @@ public void testHandleBytesMessage() throws Exception {\n \t\tbyte[] inFile = FileCopyUtils.copyToByteArray(file);\n \t\tassertThat(new String(inFile)).isEqualTo(\"byte[] data\");\n \t\tfile.delete();\n+\n+\t\tsessionFactory.destroy();\n \t}\n \n \t@Test //INT-2275\n@@ -225,7 +232,7 @@ public void testMkDir() throws Exception {\n \n \t@ParameterizedTest\n \t@ValueSource(booleans = {true, false})\n-\tpublic void testSharedSession(boolean sharedSession) throws IOException {\n+\tpublic void testSharedSession(boolean sharedSession) throws Exception {\n \t\ttry (SshServer server = SshServer.setUpDefaultServer()) {\n \t\t\tserver.setPasswordAuthenticator((arg0, arg1, arg2) -> true);\n \t\t\tserver.setPort(0);\n@@ -253,6 +260,8 @@ public void testSharedSession(boolean sharedSession) throws IOException {\n \t\t\t\tassertThat(TestUtils.getPropertyValue(s2, \"sftpClient\"))\n \t\t\t\t\t\t.isNotSameAs(TestUtils.getPropertyValue(s1, \"sftpClient\"));\n \t\t\t}\n+\n+\t\t\tf.destroy();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/outbound/SftpServerOutboundTests.java b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/outbound/SftpServerOutboundTests.java\nindex 4974abc275c..51924d064cd 100644\n--- a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/outbound/SftpServerOutboundTests.java\n+++ b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/outbound/SftpServerOutboundTests.java\n@@ -86,6 +86,7 @@\n /**\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Darryl Smith\n  *\n  * @since 3.0\n  */\n@@ -684,7 +685,7 @@ private void assertLength6(SftpRemoteFileTemplate template) {\n \t}\n \n \t@Test\n-\tpublic void testSessionExists() throws IOException {\n+\tpublic void testSessionExists() throws Exception {\n \t\tDefaultSftpSessionFactory sessionFactory = new DefaultSftpSessionFactory();\n \t\tsessionFactory.setHost(\"localhost\");\n \t\tsessionFactory.setPort(port);\n@@ -702,6 +703,8 @@ public void testSessionExists() throws IOException {\n \t\t\t\t.isThrownBy(() -> session.exists(\"any\"))\n \t\t\t\t.withRootCauseInstanceOf(IOException.class)\n \t\t\t\t.withStackTraceContaining(\"canonicalPath(any) client is closed\");\n+\n+\t\tsessionFactory.destroy();\n \t}\n \n \t@SuppressWarnings(\"unused\")\n\ndiff --git a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplateTests.java b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplateTests.java\nindex acfed39d75e..9511f52c555 100644\n--- a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplateTests.java\n+++ b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplateTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2023 the original author or authors.\n+ * Copyright 2014-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -54,6 +54,7 @@\n /**\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Darryl Smith\n  * @since 4.1\n  */\n @SpringJUnitConfig\n@@ -138,7 +139,7 @@ public void lsUserHome() throws IOException {\n \t}\n \n \t@Test\n-\tpublic void renameWithOldSftpVersion() {\n+\tpublic void renameWithOldSftpVersion() throws Exception {\n \t\tDefaultSftpSessionFactory factory = new DefaultSftpSessionFactory(false);\n \t\tfactory.setHost(\"localhost\");\n \t\tfactory.setPort(port);\n@@ -162,6 +163,8 @@ public void renameWithOldSftpVersion() {\n \t\t\t\t\t\t\t\t\"sftpSource/subSftpSource/subSftpSource1.txt\"));\n \n \t\toldVersionSession.close();\n+\n+\t\tfactory.destroy();\n \t}\n \n \t@Test\n\ndiff --git a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpServerTests.java b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpServerTests.java\nindex 1134ec420d9..0ad10e3eb69 100644\n--- a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpServerTests.java\n+++ b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpServerTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2023 the original author or authors.\n+ * Copyright 2014-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -50,6 +50,7 @@\n  * @author Gary Russell\n  * @author David Liu\n  * @author Artem Bilan\n+ * @author Darryl Smith\n  *\n  * @since 4.1\n  *\n@@ -76,6 +77,8 @@ public void testUcPw() throws Exception {\n \t\t\tf.setAllowUnknownKeys(true);\n \t\t\tSession<SftpClient.DirEntry> session = f.getSession();\n \t\t\tdoTest(server, session);\n+\n+\t\t\tf.destroy();\n \t\t}\n \t}\n \n@@ -111,6 +114,8 @@ private void testKeyExchange(String pubKey, String privKey, String passphrase) t\n \t\t\tf.setPrivateKeyPassphrase(passphrase);\n \t\t\tSession<SftpClient.DirEntry> session = f.getSession();\n \t\t\tdoTest(server, session);\n+\n+\t\t\tf.destroy();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java\nindex 4c81103a1c9..f17045e3df3 100644\n--- a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java\n+++ b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2023 the original author or authors.\n+ * Copyright 2014-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -30,6 +30,7 @@\n import org.apache.sshd.client.auth.password.PasswordIdentityProvider;\n import org.apache.sshd.client.channel.ClientChannel;\n import org.apache.sshd.client.keyverifier.AcceptAllServerKeyVerifier;\n+import org.apache.sshd.client.session.ClientSession;\n import org.apache.sshd.common.SshException;\n import org.apache.sshd.server.SshServer;\n import org.apache.sshd.server.keyprovider.SimpleGeneratorHostKeyProvider;\n@@ -50,6 +51,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Auke Zaaiman\n+ * @author Darryl Smith\n  *\n  * @since 3.0.2\n  */\n@@ -101,11 +103,13 @@ public void testConnectFailSocketOpen() throws Exception {\n \t\t\t}\n \n \t\t\tassertThat(server.getActiveSessions().size()).isEqualTo(0);\n+\n+\t\t\tf.destroy();\n \t\t}\n \t}\n \n \t@Test\n-\tpublic void concurrentGetSessionDoesntCauseFailure() throws IOException {\n+\tpublic void concurrentGetSessionDoesntCauseFailure() throws Exception {\n \t\ttry (SshServer server = SshServer.setUpDefaultServer()) {\n \t\t\tserver.setPasswordAuthenticator((arg0, arg1, arg2) -> true);\n \t\t\tserver.setPort(0);\n@@ -134,11 +138,13 @@ public void concurrentGetSessionDoesntCauseFailure() throws IOException {\n \t\t\t\t\t.isNotEqualTo(concurrentSessions.get(2));\n \n \t\t\tassertThat(concurrentSessions.get(1)).isNotEqualTo(concurrentSessions.get(2));\n+\n+\t\t\tsftpSessionFactory.destroy();\n \t\t}\n \t}\n \n \t@Test\n-\tvoid externallyProvidedSshClientShouldNotHaveItsConfigurationOverwritten() throws IOException {\n+\tvoid externallyProvidedSshClientShouldNotHaveItsConfigurationOverwritten() throws Exception {\n \t\ttry (SshServer server = SshServer.setUpDefaultServer()) {\n \t\t\tserver.setPasswordAuthenticator((arg0, arg1, arg2) -> true);\n \t\t\tserver.setPort(0);\n@@ -156,11 +162,13 @@ void externallyProvidedSshClientShouldNotHaveItsConfigurationOverwritten() throw\n \t\t\tsftpSessionFactory.setUser(\"user\");\n \n \t\t\tassertThatNoException().isThrownBy(sftpSessionFactory::getSession);\n+\n+\t\t\tsftpSessionFactory.destroy();\n \t\t}\n \t}\n \n \t@Test\n-\tvoid concurrentSessionListDoesntCauseFailure() throws IOException {\n+\tvoid concurrentSessionListDoesntCauseFailure() throws Exception {\n \t\ttry (SshServer server = SshServer.setUpDefaultServer()) {\n \t\t\tserver.setPasswordAuthenticator((arg0, arg1, arg2) -> true);\n \t\t\tserver.setPort(0);\n@@ -192,11 +200,13 @@ void concurrentSessionListDoesntCauseFailure() throws IOException {\n \t\t\t\t\t\t\t.toList();\n \n \t\t\tassertThat(dirEntries).hasSize(10);\n+\n+\t\t\tsftpSessionFactory.destroy();\n \t\t}\n \t}\n \n \t@Test\n-\tvoid customTimeoutIsApplied() throws IOException {\n+\tvoid customTimeoutIsApplied() throws Exception {\n \t\ttry (SshServer server = SshServer.setUpDefaultServer()) {\n \t\t\tserver.setPasswordAuthenticator((arg0, arg1, arg2) -> true);\n \t\t\tserver.setPort(0);\n@@ -215,7 +225,39 @@ void customTimeoutIsApplied() throws IOException {\n \t\t\tClientChannel clientChannel = sftpSessionFactory.getSession().getClientInstance().getClientChannel();\n \n \t\t\tassertThat(AbstractSftpClient.SFTP_CLIENT_CMD_TIMEOUT.getRequired(clientChannel)).hasSeconds(15);\n+\n+\t\t\tsftpSessionFactory.destroy();\n \t\t}\n \t}\n \n+\t@Test\n+\tvoid clientSessionIsClosedOnSessionClose() throws Exception {\n+\t\ttry (SshServer server = SshServer.setUpDefaultServer()) {\n+\t\t\tserver.setPasswordAuthenticator((arg0, arg1, arg2) -> true);\n+\t\t\tserver.setPort(0);\n+\t\t\tserver.setKeyPairProvider(new SimpleGeneratorHostKeyProvider(new File(\"hostkey.ser\").toPath()));\n+\t\t\tserver.setSubsystemFactories(Collections.singletonList(new SftpSubsystemFactory()));\n+\t\t\tserver.start();\n+\n+\t\t\tDefaultSftpSessionFactory sftpSessionFactory = new DefaultSftpSessionFactory();\n+\t\t\tsftpSessionFactory.setHost(\"localhost\");\n+\t\t\tsftpSessionFactory.setPort(server.getPort());\n+\t\t\tsftpSessionFactory.setUser(\"user\");\n+\t\t\tsftpSessionFactory.setPassword(\"pass\");\n+\t\t\tsftpSessionFactory.setAllowUnknownKeys(true);\n+\n+\t\t\tSftpSession session = sftpSessionFactory.getSession();\n+\t\t\tClientSession clientSession = session.getClientInstance().getClientSession();\n+\n+\t\t\tassertThat(session.isOpen()).isTrue();\n+\t\t\tassertThat(clientSession.isOpen()).isTrue();\n+\n+\t\t\tsession.close();\n+\n+\t\t\tassertThat(session.isOpen()).isFalse();\n+\t\t\tassertThat(clientSession.isClosed()).isTrue();\n+\n+\t\t\tsftpSessionFactory.destroy();\n+\t\t}\n+\t}\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9229",
    "pr_id": 9229,
    "issue_id": 9228,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "ZeroMQ: ZeroMQMessageHandler with bind capability\n**Expected Behavior**\r\n\r\nThe expected behaviour is that the ZeroMqMessageHandler could bind a port when the other part (a ZeroMqMessageProducer or whatever out of Spring world) connects to that port.\r\n\r\n**Current Behavior**\r\n\r\nAs for now, the ZeroMqMessageHandler can only connect to a specific URL, while [no binding is allowed](https://github.com/spring-projects/spring-integration/blob/afb87d45e82cd6ad3ea02a87758701310b08e473/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/outbound/ZeroMqMessageHandler.java#L53).\r\n\r\n**Context**\r\n\r\nAs per ZeroMQ philosophy, binding or connecting to a socket is completely decoupled from sender/receiver abstraction.\r\n\r\nMy question is: Is there any reason behind the current limitation? Something I'm missing out?\r\nIf you agree, I could make a PR to add this functionality",
    "issue_word_count": 122,
    "test_files_count": 1,
    "non_test_files_count": 8,
    "pr_changed_files": [
      "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqHeaders.java",
      "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqUtils.java",
      "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/dsl/ZeroMq.java",
      "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/dsl/ZeroMqMessageHandlerSpec.java",
      "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/inbound/ZeroMqMessageProducer.java",
      "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/outbound/ZeroMqMessageHandler.java",
      "spring-integration-zeromq/src/test/java/org/springframework/integration/zeromq/outbound/ZeroMqMessageHandlerTests.java",
      "src/reference/antora/modules/ROOT/pages/whats-new.adoc",
      "src/reference/antora/modules/ROOT/pages/zeromq.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-zeromq/src/test/java/org/springframework/integration/zeromq/outbound/ZeroMqMessageHandlerTests.java"
    ],
    "base_commit": "4a77dbcc461f5a10ee10583009ec7758034a9b3b",
    "head_commit": "920c1279475db8897344a907d438f84bb4ad717b",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9229",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9229",
    "dockerfile": "",
    "pr_merged_at": "2024-07-01T17:00:26.000Z",
    "patch": "diff --git a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqHeaders.java b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqHeaders.java\nindex 838ed6be9d5..506e68e00b1 100644\n--- a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqHeaders.java\n+++ b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqHeaders.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020 the original author or authors.\n+ * Copyright 2020-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,7 +17,7 @@\n package org.springframework.integration.zeromq;\n \n /**\n- * The message headers constants to repsent ZeroMq message attributes.\n+ * The message headers constants to represent ZeroMq message attributes.\n  *\n  * @author Artem Bilan\n  *\n\ndiff --git a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqUtils.java b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqUtils.java\nnew file mode 100644\nindex 00000000000..4863f7329b1\n--- /dev/null\n+++ b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqUtils.java\n@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020-2024 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq;\n+\n+import org.zeromq.ZMQ;\n+\n+/**\n+ * Module that wraps common methods of ZeroMq integration classes\n+ *\n+ * @author Alessio Matricardi\n+ *\n+ * @since 6.4\n+ *\n+ */\n+public final class ZeroMqUtils {\n+\n+\t/**\n+\t * Bind the ZeroMq socket to the given port over the TCP transport protocol.\n+\t * @param socket the ZeroMq socket\n+\t * @param port the port to bind ZeroMq socket to over TCP. If equal to 0, the socket will bind to a random port.\n+\t * @return the effectively bound port\n+\t */\n+\tpublic static int bindSocket(ZMQ.Socket socket, int port) {\n+\t\tif (port == 0) {\n+\t\t\treturn socket.bindToRandomPort(\"tcp://*\");\n+\t\t}\n+\t\telse {\n+\t\t\tboolean bound = socket.bind(\"tcp://*:\" + port);\n+\t\t\tif (!bound) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Cannot bind ZeroMQ socket to port: \" + port);\n+\t\t\t}\n+\t\t\treturn port;\n+\t\t}\n+\t}\n+\n+\tprivate ZeroMqUtils() {\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/dsl/ZeroMq.java b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/dsl/ZeroMq.java\nindex 74a2c530f9f..8aa72615f47 100644\n--- a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/dsl/ZeroMq.java\n+++ b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/dsl/ZeroMq.java\n@@ -25,6 +25,7 @@\n  * Factory class for ZeroMq components DSL.\n  *\n  * @author Artem Bilan\n+ * @author Alessio Matricardi\n  *\n  * @since 5.4\n  */\n@@ -58,6 +59,17 @@ public static ZeroMqMessageHandlerSpec outboundChannelAdapter(ZContext context,\n \t\treturn outboundChannelAdapter(context, () -> connectUrl);\n \t}\n \n+\t/**\n+\t * Create an instance of {@link ZeroMqMessageHandlerSpec} for the provided {@link ZContext} and binding port.\n+\t * @param context the {@link ZContext} to use.\n+\t * @param port the port to bind ZeroMq socket to over TCP.\n+\t * @return the spec.\n+\t * @since 6.4\n+\t */\n+\tpublic static ZeroMqMessageHandlerSpec outboundChannelAdapter(ZContext context, int port) {\n+\t\treturn new ZeroMqMessageHandlerSpec(context, port);\n+\t}\n+\n \t/**\n \t * Create an instance of {@link ZeroMqMessageHandlerSpec} for the provided {@link ZContext}\n \t * and connection URL supplier.\n@@ -84,6 +96,43 @@ public static ZeroMqMessageHandlerSpec outboundChannelAdapter(ZContext context,\n \t\treturn new ZeroMqMessageHandlerSpec(context, connectUrl, socketType);\n \t}\n \n+\t/**\n+\t * Create an instance of {@link ZeroMqMessageHandlerSpec} for the provided {@link ZContext}.\n+\t * The created socket will be bound to a random port.\n+\t * @param context the {@link ZContext} to use.\n+\t * @return the spec.\n+\t * @since 6.4\n+\t */\n+\tpublic static ZeroMqMessageHandlerSpec outboundChannelAdapter(ZContext context) {\n+\t\treturn new ZeroMqMessageHandlerSpec(context);\n+\t}\n+\n+\t/**\n+\t * Create an instance of {@link ZeroMqMessageHandlerSpec} for the provided {@link ZContext} and {@link SocketType}.\n+\t * The created socket will be bound to a random port.\n+\t * @param context the {@link ZContext} to use.\n+\t * @param socketType the {@link SocketType} for ZeroMq socket.\n+\t * @return the spec.\n+\t * @since 6.4\n+\t */\n+\tpublic static ZeroMqMessageHandlerSpec outboundChannelAdapter(ZContext context, SocketType socketType) {\n+\t\treturn new ZeroMqMessageHandlerSpec(context, socketType);\n+\t}\n+\n+\t/**\n+\t * Create an instance of {@link ZeroMqMessageHandlerSpec} for the provided {@link ZContext}, binding port\n+\t * and {@link SocketType}.\n+\t * @param context the {@link ZContext} to use.\n+\t * @param port the port to bind ZeroMq socket to over TCP.\n+\t * @param socketType the {@link SocketType} for ZeroMq socket.\n+\t * @return the spec.\n+\t * @since 6.4\n+\t */\n+\tpublic static ZeroMqMessageHandlerSpec outboundChannelAdapter(ZContext context, int port,\n+\t\t\tSocketType socketType) {\n+\t\treturn new ZeroMqMessageHandlerSpec(context, port, socketType);\n+\t}\n+\n \t/**\n \t * Create an instance of {@link ZeroMqMessageHandlerSpec} for the provided {@link ZContext},\n \t * connection URL supplier and {@link SocketType}.\n\ndiff --git a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/dsl/ZeroMqMessageHandlerSpec.java b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/dsl/ZeroMqMessageHandlerSpec.java\nindex b99fe26996c..393d1ca3bc4 100644\n--- a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/dsl/ZeroMqMessageHandlerSpec.java\n+++ b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/dsl/ZeroMqMessageHandlerSpec.java\n@@ -52,6 +52,26 @@ protected ZeroMqMessageHandlerSpec(ZContext context, String connectUrl) {\n \t\tthis(context, () -> connectUrl);\n \t}\n \n+\t/**\n+\t * Create an instance based on the provided {@link ZContext}.\n+\t * The created socket will be bound to a random port.\n+\t * @param context the {@link ZContext} to use for creating sockets.\n+\t * @since 6.4\n+\t */\n+\tprotected ZeroMqMessageHandlerSpec(ZContext context) {\n+\t\tthis(context, SocketType.PAIR);\n+\t}\n+\n+\t/**\n+\t * Create an instance based on the provided {@link ZContext} and binding port.\n+\t * @param context the {@link ZContext} to use for creating sockets.\n+\t * @param port the port to bind ZeroMq socket to over TCP.\n+\t * @since 6.4\n+\t */\n+\tprotected ZeroMqMessageHandlerSpec(ZContext context, int port) {\n+\t\tthis(context, port, SocketType.PAIR);\n+\t}\n+\n \t/**\n \t * Create an instance based on the provided {@link ZContext} and connection string supplier.\n \t * @param context the {@link ZContext} to use for creating sockets.\n@@ -73,6 +93,30 @@ protected ZeroMqMessageHandlerSpec(ZContext context, String connectUrl, SocketTy\n \t\tthis(context, () -> connectUrl, socketType);\n \t}\n \n+\t/**\n+\t * Create an instance based on the provided {@link ZContext} and {@link SocketType}.\n+\t * The created socket will be bound to a random port.\n+\t * @param context the {@link ZContext} to use for creating sockets.\n+\t * @param socketType the {@link SocketType} to use;\n+\t *    only {@link SocketType#PAIR}, {@link SocketType#PUB} and {@link SocketType#PUSH} are supported.\n+\t * @since 6.4\n+\t */\n+\tprotected ZeroMqMessageHandlerSpec(ZContext context, SocketType socketType) {\n+\t\tsuper(new ZeroMqMessageHandler(context, socketType));\n+\t}\n+\n+\t/**\n+\t * Create an instance based on the provided {@link ZContext}, binding port and {@link SocketType}.\n+\t * @param context the {@link ZContext} to use for creating sockets.\n+\t * @param port the port to bind ZeroMq socket to over TCP.\n+\t * @param socketType the {@link SocketType} to use;\n+\t *    only {@link SocketType#PAIR}, {@link SocketType#PUB} and {@link SocketType#PUSH} are supported.\n+\t * @since 6.4\n+\t */\n+\tprotected ZeroMqMessageHandlerSpec(ZContext context, int port, SocketType socketType) {\n+\t\tsuper(new ZeroMqMessageHandler(context, port, socketType));\n+\t}\n+\n \t/**\n \t * Create an instance based on the provided {@link ZContext}, connection string supplier and {@link SocketType}.\n \t * @param context the {@link ZContext} to use for creating sockets.\n\ndiff --git a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/inbound/ZeroMqMessageProducer.java b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/inbound/ZeroMqMessageProducer.java\nindex d2c484c3e19..1d203315916 100644\n--- a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/inbound/ZeroMqMessageProducer.java\n+++ b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/inbound/ZeroMqMessageProducer.java\n@@ -40,6 +40,7 @@\n import org.springframework.integration.support.converter.ConfigurableCompositeMessageConverter;\n import org.springframework.integration.support.management.IntegrationManagedResource;\n import org.springframework.integration.zeromq.ZeroMqHeaders;\n+import org.springframework.integration.zeromq.ZeroMqUtils;\n import org.springframework.jmx.export.annotation.ManagedOperation;\n import org.springframework.jmx.export.annotation.ManagedResource;\n import org.springframework.lang.Nullable;\n@@ -263,7 +264,7 @@ protected void doStart() {\n \t\t\t\t\t\t\t\tsocket.connect(this.connectUrl);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\tthis.bindPort.set(bindSocket(socket, this.bindPort.get()));\n+\t\t\t\t\t\t\t\tthis.bindPort.set(ZeroMqUtils.bindSocket(socket, this.bindPort.get()));\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t})\n \t\t\t\t\t\t.cache()\n@@ -319,17 +320,4 @@ public void destroy() {\n \t\tthis.socketMono.doOnNext(ZMQ.Socket::close).block();\n \t}\n \n-\tprivate static int bindSocket(ZMQ.Socket socket, int port) {\n-\t\tif (port == 0) {\n-\t\t\treturn socket.bindToRandomPort(\"tcp://*\");\n-\t\t}\n-\t\telse {\n-\t\t\tboolean bound = socket.bind(\"tcp://*:\" + port);\n-\t\t\tif (!bound) {\n-\t\t\t\tthrow new IllegalArgumentException(\"Cannot bind ZeroMQ socket to port: \" + port);\n-\t\t\t}\n-\t\t\treturn port;\n-\t\t}\n-\t}\n-\n }\n\ndiff --git a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/outbound/ZeroMqMessageHandler.java b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/outbound/ZeroMqMessageHandler.java\nindex 2a668148318..8074d860d4a 100644\n--- a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/outbound/ZeroMqMessageHandler.java\n+++ b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/outbound/ZeroMqMessageHandler.java\n@@ -18,6 +18,7 @@\n \n import java.util.List;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Consumer;\n import java.util.function.Supplier;\n \n@@ -43,6 +44,8 @@\n import org.springframework.integration.mapping.OutboundMessageMapper;\n import org.springframework.integration.support.converter.ConfigurableCompositeMessageConverter;\n import org.springframework.integration.support.management.ManageableLifecycle;\n+import org.springframework.integration.zeromq.ZeroMqUtils;\n+import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.converter.MessageConverter;\n import org.springframework.util.Assert;\n@@ -50,14 +53,14 @@\n /**\n  * The {@link AbstractReactiveMessageHandler} implementation for publishing messages over ZeroMq socket.\n  * Only {@link SocketType#PAIR}, {@link SocketType#PUB} and {@link SocketType#PUSH} are supported.\n- * This component is only connecting (no Binding) to another side, e.g. ZeroMq proxy.\n+ * This component can bind or connect the socket.\n  * <p>\n  * When the {@link SocketType#PUB} is used, the {@link #topicExpression} is evaluated against a\n  * request message to inject a topic frame into a ZeroMq message if it is not {@code null}.\n  * The subscriber side must receive the topic frame first before parsing the actual data.\n  * <p>\n  * When the payload of the request message is a {@link ZMsg}, no any conversion and topic extraction happen:\n- * the {@link ZMsg} is sent into a socket as is and it is not destroyed for possible further reusing.\n+ * the {@link ZMsg} is sent into a socket as is, and it is not destroyed for possible further reusing.\n  *\n  * @author Artem Bilan\n  * @author Alessio Matricardi\n@@ -74,7 +77,7 @@ public class ZeroMqMessageHandler extends AbstractReactiveMessageHandler\n \n \tprivate final Scheduler publisherScheduler = Schedulers.newSingle(\"zeroMqMessageHandlerScheduler\");\n \n-\tprivate final Mono<ZMQ.Socket> socketMono;\n+\tprivate volatile Mono<ZMQ.Socket> socketMono;\n \n \tprivate OutboundMessageMapper<byte[]> messageMapper;\n \n@@ -91,6 +94,38 @@ public class ZeroMqMessageHandler extends AbstractReactiveMessageHandler\n \n \tprivate volatile boolean wrapTopic = true;\n \n+\tprivate final ZContext context;\n+\n+\tprivate final SocketType socketType;\n+\n+\tprivate final AtomicInteger bindPort = new AtomicInteger();\n+\n+\t@Nullable\n+\tprivate Supplier<String> connectUrl;\n+\n+\t/**\n+\t * Create an instance based on the provided {@link ZContext}.\n+\t * @param context the {@link ZContext} to use for creating sockets.\n+\t * @since 6.4\n+\t */\n+\tpublic ZeroMqMessageHandler(ZContext context) {\n+\t\tthis(context, SocketType.PAIR);\n+\t}\n+\n+\t/**\n+\t * Create an instance based on the provided {@link ZContext} and {@link SocketType}.\n+\t * @param context the {@link ZContext} to use for creating sockets.\n+\t * @param socketType the {@link SocketType} to use;\n+\t *    only {@link SocketType#PAIR}, {@link SocketType#PUB} and {@link SocketType#PUSH} are supported.\n+\t */\n+\tpublic ZeroMqMessageHandler(ZContext context, SocketType socketType) {\n+\t\tAssert.notNull(context, \"'context' must not be null\");\n+\t\tAssert.state(VALID_SOCKET_TYPES.contains(socketType),\n+\t\t\t\t() -> \"'socketType' can only be one of the: \" + VALID_SOCKET_TYPES);\n+\t\tthis.context = context;\n+\t\tthis.socketType = socketType;\n+\t}\n+\n \t/**\n \t * Create an instance based on the provided {@link ZContext} and connection string.\n \t * @param context the {@link ZContext} to use for creating sockets.\n@@ -100,6 +135,16 @@ public ZeroMqMessageHandler(ZContext context, String connectUrl) {\n \t\tthis(context, connectUrl, SocketType.PAIR);\n \t}\n \n+\t/**\n+\t * Create an instance based on the provided {@link ZContext} and binding port.\n+\t * @param context the {@link ZContext} to use for creating sockets.\n+\t * @param port the port to bind ZeroMq socket to over TCP.\n+\t * @since 6.4\n+\t */\n+\tpublic ZeroMqMessageHandler(ZContext context, int port) {\n+\t\tthis(context, port, SocketType.PAIR);\n+\t}\n+\n \t/**\n \t * Create an instance based on the provided {@link ZContext} and connection string supplier.\n \t * @param context the {@link ZContext} to use for creating sockets.\n@@ -122,6 +167,20 @@ public ZeroMqMessageHandler(ZContext context, String connectUrl, SocketType sock\n \t\tAssert.hasText(connectUrl, \"'connectUrl' must not be empty\");\n \t}\n \n+\t/**\n+\t * Create an instance based on the provided {@link ZContext}, binding port and {@link SocketType}.\n+\t * @param context the {@link ZContext} to use for creating sockets.\n+\t * @param port the port to bind ZeroMq socket to over TCP.\n+\t * @param socketType the {@link SocketType} to use;\n+\t *    only {@link SocketType#PAIR}, {@link SocketType#PUB} and {@link SocketType#PUSH} are supported.\n+\t * @since 6.4\n+\t */\n+\tpublic ZeroMqMessageHandler(ZContext context, int port, SocketType socketType) {\n+\t\tthis(context, socketType);\n+\t\tAssert.isTrue(port > 0, \"'port' must not be zero or negative\");\n+\t\tthis.bindPort.set(port);\n+\t}\n+\n \t/**\n \t * Create an instance based on the provided {@link ZContext}, connection string supplier and {@link SocketType}.\n \t * @param context the {@link ZContext} to use for creating sockets.\n@@ -131,17 +190,9 @@ public ZeroMqMessageHandler(ZContext context, String connectUrl, SocketType sock\n \t * @since 5.5.9\n \t */\n \tpublic ZeroMqMessageHandler(ZContext context, Supplier<String> connectUrl, SocketType socketType) {\n-\t\tAssert.notNull(context, \"'context' must not be null\");\n+\t\tthis(context, socketType);\n \t\tAssert.notNull(connectUrl, \"'connectUrl' must not be null\");\n-\t\tAssert.state(VALID_SOCKET_TYPES.contains(socketType),\n-\t\t\t\t() -> \"'socketType' can only be one of the: \" + VALID_SOCKET_TYPES);\n-\t\tthis.socketMono =\n-\t\t\t\tMono.just(context.createSocket(socketType))\n-\t\t\t\t\t\t.publishOn(this.publisherScheduler)\n-\t\t\t\t\t\t.doOnNext((socket) -> this.socketConfigurer.accept(socket))\n-\t\t\t\t\t\t.doOnNext((socket) -> socket.connect(connectUrl.get()))\n-\t\t\t\t\t\t.cache()\n-\t\t\t\t\t\t.publishOn(this.publisherScheduler);\n+\t\tthis.connectUrl = connectUrl;\n \t}\n \n \t/**\n@@ -206,6 +257,16 @@ public void wrapTopic(boolean wrapTopic) {\n \t\tthis.wrapTopic = wrapTopic;\n \t}\n \n+\t/**\n+\t * Return the port a socket is bound or 0 if this message producer has not been started yet\n+\t * or the socket is connected - not bound.\n+\t * @return the port for a socket or 0.\n+\t * @since 6.4\n+\t */\n+\tpublic int getBoundPort() {\n+\t\treturn this.bindPort.get();\n+\t}\n+\n \t@Override\n \tpublic String getComponentType() {\n \t\treturn \"zeromq:outbound-channel-adapter\";\n@@ -228,6 +289,20 @@ protected void onInit() {\n \t@Override\n \tpublic void start() {\n \t\tif (!this.running.getAndSet(true)) {\n+\t\t\tthis.socketMono =\n+\t\t\t\t\tMono.just(this.context.createSocket(this.socketType))\n+\t\t\t\t\t\t\t.publishOn(this.publisherScheduler)\n+\t\t\t\t\t\t\t.doOnNext((socket) -> this.socketConfigurer.accept(socket))\n+\t\t\t\t\t\t\t.doOnNext((socket) -> {\n+\t\t\t\t\t\t\t\tif (this.connectUrl != null) {\n+\t\t\t\t\t\t\t\t\tsocket.connect(this.connectUrl.get());\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\t\tthis.bindPort.set(ZeroMqUtils.bindSocket(socket, this.bindPort.get()));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t})\n+\t\t\t\t\t\t\t.cache()\n+\t\t\t\t\t\t\t.publishOn(this.publisherScheduler);\n \t\t\tthis.socketMonoSubscriber = this.socketMono.subscribe();\n \t\t}\n \t}\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/whats-new.adoc b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\nindex 51e10351291..9328aec8297 100644\n--- a/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n@@ -30,4 +30,9 @@ The references stay in cache because polling configuration does not allow to pro\n \n The `LobHandler` (and respective API) has been deprecated for removal in Spring Framework `6.2`.\n Respective option on `JdbcMessageStore` (and similar) have been deprecated as well.\n-The byte array handling for serialized message is fully deferred to JDBC driver.\n\\ No newline at end of file\n+The byte array handling for serialized message is fully deferred to JDBC driver.\n+\n+[[x6.4-zeromq-changes]]\n+=== ZeroMQ Changes\n+\n+The outbound component `ZeroMqMessageHandler` (and respective API) can now bind a TCP port instead of connecting to a given URL.\n\\ No newline at end of file\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/zeromq.adoc b/src/reference/antora/modules/ROOT/pages/zeromq.adoc\nindex a0b85efdfee..8d9d8442719 100644\n--- a/src/reference/antora/modules/ROOT/pages/zeromq.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/zeromq.adoc\n@@ -146,7 +146,9 @@ ZeroMqMessageProducer zeroMqMessageProducer(ZContext context, MessageChannel out\n \n The `ZeroMqMessageHandler` is a `ReactiveMessageHandler` implementation to produce publish messages into a ZeroMQ socket.\n Only `SocketType.PAIR`, `SocketType.PUSH` and `SocketType.PUB` are supported.\n-The `ZeroMqMessageHandler` only supports connecting the ZeroMQ socket; binding is not supported.\n+This component can connect to the remote socket or bind onto TCP protocol with the provided or random port.\n+The actual port can be obtained via `getBoundPort()` after this component is started and ZeroMQ socket is bound.\n+\n When the `SocketType.PUB` is used, the `topicExpression` is evaluated against a request message to inject a topic frame into a ZeroMQ message if it is not null.\n The subscriber side (`SocketType.SUB`) must receive the topic frame first before parsing the actual data.\n \n@@ -158,7 +160,7 @@ Otherwise, an `OutboundMessageMapper<byte[]>` is used to convert a request messa\n By default, a `ConvertingBytesMessageMapper` is used supplied with a `ConfigurableCompositeMessageConverter`.\n The socket options (e.g. security or write timeout) can be configured via `setSocketConfigurer(Consumer<ZMQ.Socket> socketConfigurer)` callback.\n \n-Here is a sample of `ZeroMqMessageHandler` configuration:\n+Here is a sample of `ZeroMqMessageHandler` configuration which connect to a socket:\n \n [source,java]\n ----\n@@ -173,6 +175,21 @@ ZeroMqMessageHandler zeroMqMessageHandler(ZContext context) {\n }\n ----\n \n+Here is a sample of `ZeroMqMessageHandler` configuration which bind to a provided port:\n+\n+[source,java]\n+----\n+@Bean\n+@ServiceActivator(inputChannel = \"zeroMqPublisherChannel\")\n+ZeroMqMessageHandler zeroMqMessageHandler(ZContext context) {\n+    ZeroMqMessageHandler messageHandler =\n+                  new ZeroMqMessageHandler(context, 7070, SocketType.PUB);\n+    messageHandler.setTopicExpression(\n+                  new FunctionExpression<Message<?>>((message) -> message.getHeaders().get(\"topic\")));\n+    messageHandler.setMessageMapper(new EmbeddedJsonHeadersMessageMapper());\n+}\n+----\n+\n [[zeromq-dsl]]\n == ZeroMQ Java DSL Support\n \n",
    "test_patch": "diff --git a/spring-integration-zeromq/src/test/java/org/springframework/integration/zeromq/outbound/ZeroMqMessageHandlerTests.java b/spring-integration-zeromq/src/test/java/org/springframework/integration/zeromq/outbound/ZeroMqMessageHandlerTests.java\nindex 1431047c437..79920c8b5aa 100644\n--- a/spring-integration-zeromq/src/test/java/org/springframework/integration/zeromq/outbound/ZeroMqMessageHandlerTests.java\n+++ b/spring-integration-zeromq/src/test/java/org/springframework/integration/zeromq/outbound/ZeroMqMessageHandlerTests.java\n@@ -35,6 +35,7 @@\n import org.springframework.messaging.Message;\n import org.springframework.messaging.converter.ByteArrayMessageConverter;\n import org.springframework.messaging.support.GenericMessage;\n+import org.springframework.test.util.TestSocketUtils;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.awaitility.Awaitility.await;\n@@ -65,12 +66,12 @@ void testMessageHandlerForPair() {\n \t\tmessageHandler.setBeanFactory(mock(BeanFactory.class));\n \t\tmessageHandler.setSocketConfigurer(s -> s.setZapDomain(\"global\"));\n \t\tmessageHandler.afterPropertiesSet();\n+\t\tmessageHandler.start();\n \n \t\t@SuppressWarnings(\"unchecked\")\n \t\tMono<ZMQ.Socket> socketMono = TestUtils.getPropertyValue(messageHandler, \"socketMono\", Mono.class);\n \t\tZMQ.Socket socketInUse = socketMono.block(Duration.ofSeconds(10));\n \t\tassertThat(socketInUse.getZapDomain()).isEqualTo(\"global\");\n-\t\tmessageHandler.start();\n \n \t\tMessage<?> testMessage = new GenericMessage<>(\"test\");\n \t\tmessageHandler.handleMessage(testMessage).subscribe();\n@@ -187,4 +188,41 @@ void testMessageHandlerForPubSubDisabledWrapTopic() {\n \t\tsubSocket.close();\n \t}\n \n+\t@Test\n+\tvoid testMessageHandlerForPubSubWithBind() {\n+\t\tint boundPort = TestSocketUtils.findAvailableTcpPort();\n+\t\tZeroMqMessageHandler messageHandler =\n+\t\t\t\tnew ZeroMqMessageHandler(CONTEXT, boundPort, SocketType.PUB);\n+\t\tmessageHandler.setBeanFactory(mock(BeanFactory.class));\n+\t\tmessageHandler.setTopicExpression(\n+\t\t\t\tnew FunctionExpression<Message<?>>((message) -> message.getHeaders().get(\"topic\")));\n+\t\tmessageHandler.setMessageMapper(new EmbeddedJsonHeadersMessageMapper());\n+\t\tmessageHandler.wrapTopic(false);\n+\t\tmessageHandler.afterPropertiesSet();\n+\t\tmessageHandler.start();\n+\n+\t\tZMQ.Socket subSocket = CONTEXT.createSocket(SocketType.SUB);\n+\t\tsubSocket.setReceiveTimeOut(0);\n+\t\tsubSocket.connect(\"tcp://localhost:\" + boundPort);\n+\t\tsubSocket.subscribe(\"test\");\n+\n+\t\tMessage<?> testMessage = MessageBuilder.withPayload(\"test\").setHeader(\"topic\", \"testTopic\").build();\n+\n+\t\tawait().atMost(Duration.ofSeconds(20)).pollDelay(Duration.ofMillis(100))\n+\t\t\t\t.untilAsserted(() -> {\n+\t\t\t\t\tsubSocket.subscribe(\"test\");\n+\t\t\t\t\tmessageHandler.handleMessage(testMessage).subscribe();\n+\t\t\t\t\tZMsg msg = ZMsg.recvMsg(subSocket);\n+\t\t\t\t\tassertThat(msg).isNotNull();\n+\t\t\t\t\tassertThat(msg.pop().getString(ZMQ.CHARSET)).isEqualTo(\"testTopic\");\n+\t\t\t\t\tMessage<?> capturedMessage =\n+\t\t\t\t\t\t\tnew EmbeddedJsonHeadersMessageMapper().toMessage(msg.getFirst().getData());\n+\t\t\t\t\tassertThat(capturedMessage).isEqualTo(testMessage);\n+\t\t\t\t\tmsg.destroy();\n+\t\t\t\t});\n+\n+\t\tmessageHandler.destroy();\n+\t\tsubSocket.close();\n+\t}\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-9062",
    "pr_id": 9062,
    "issue_id": 9061,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "PostgresChannelMessageTableSubscriber not properly handling Database Failover\n**In what version(s) of Spring Integration are you seeing this issue?**\r\n\r\n6.x\r\n\r\n**Describe the bug**\r\n\r\nWhen the database is doing a failover the `PostgresChannelMessageTableSubscriber` doesn't notice and will never receive new notifications.\r\nFor example on AWS RDS instance with multi-AZ standby, when performing a failover the IP address for the DNS does change. But `PostgresChannelMessageTableSubscriber` never re-establishes a connection, nor has some other measurement in place to validate that the connection is still valid.\r\n\r\n**To Reproduce**\r\n\r\nPerform a DB failover. After this no more messages will be processed.\r\n\r\n**Expected behavior**\r\n\r\nEventually the `PostgresChannelMessageTableSubscriber` obtains a new connection after failover, and message processing will work again.\r\n\r\n**Sample**\r\n\r\nSorry, not being able to provide a complete sample, as this involves infrastructure \r\n",
    "issue_word_count": 130,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java"
    ],
    "base_commit": "627cde2050da92f41767243c64be6d815d6b417f",
    "head_commit": "e30bebddc3c6013d809f432b8bc9ce26bf766e44",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/9062",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/9062",
    "dockerfile": "",
    "pr_merged_at": "2024-04-01T17:05:57.000Z",
    "patch": "diff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java\nindex 96f8ccc0f64..4b72c138eed 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java\n@@ -18,6 +18,7 @@\n \n import java.sql.SQLException;\n import java.sql.Statement;\n+import java.time.Duration;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n@@ -62,6 +63,7 @@\n  * @author Artem Bilan\n  * @author Igor Lovich\n  * @author Christian Tzolov\n+ * @author Johannes Edmeier\n  *\n  * @since 6.0\n  */\n@@ -86,6 +88,8 @@ public final class PostgresChannelMessageTableSubscriber implements SmartLifecyc\n \t@Nullable\n \tprivate volatile PgConnection connection;\n \n+\tprivate Duration notificationTimeout = Duration.ofSeconds(60);\n+\n \t/**\n \t * Create a new subscriber using the {@link JdbcChannelMessageStore#DEFAULT_TABLE_PREFIX}.\n \t * @param connectionSupplier The connection supplier for the targeted Postgres database.\n@@ -116,6 +120,19 @@ public void setTaskExecutor(AsyncTaskExecutor taskExecutor) {\n \t\tthis.taskExecutor = taskExecutor;\n \t}\n \n+\t/**\n+\t * Set the timeout for the notification polling.\n+\t * If for the specified duration no notificiation are received the underlying connection is closed and re-established.\n+\t * Setting a value of {@code Duration.ZERO} will disable the timeout and wait forever.\n+\t * This might cause problems in DB failover scenarios.\n+\t * @param notificationTimeout the timeout for the notification polling.\n+\t * @since 6.1.8\n+\t */\n+\tpublic void setNotificationTimeout(Duration notificationTimeout) {\n+\t\tAssert.notNull(notificationTimeout, \"'notificationTimeout' must not be null.\");\n+\t\tthis.notificationTimeout = notificationTimeout;\n+\t}\n+\n \t/**\n \t * Add a new subscription to this subscriber.\n \t * @param subscription The subscription to register.\n@@ -193,24 +210,28 @@ private void doStart(CountDownLatch startingLatch) {\n \t\t\t\t\t\twhile (isActive()) {\n \t\t\t\t\t\t\tstartingLatch.countDown();\n \n-\t\t\t\t\t\t\tPGNotification[] notifications = conn.getNotifications(0);\n+\t\t\t\t\t\t\tPGNotification[] notifications = conn.getNotifications((int) this.notificationTimeout.toMillis());\n \t\t\t\t\t\t\t// Unfortunately, there is no good way of interrupting a notification\n \t\t\t\t\t\t\t// poll but by closing its connection.\n \t\t\t\t\t\t\tif (!isActive()) {\n \t\t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif (notifications != null) {\n-\t\t\t\t\t\t\t\tfor (PGNotification notification : notifications) {\n-\t\t\t\t\t\t\t\t\tString parameter = notification.getParameter();\n-\t\t\t\t\t\t\t\t\tSet<Subscription> subscriptions = this.subscriptionsMap.get(parameter);\n-\t\t\t\t\t\t\t\t\tif (subscriptions == null) {\n-\t\t\t\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\tfor (Subscription subscription : subscriptions) {\n-\t\t\t\t\t\t\t\t\t\tsubscription.notifyUpdate();\n-\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (notifications == null || notifications.length == 0) {\n+\t\t\t\t\t\t\t\t//We did not receive any notifications within the timeout period.\n+\t\t\t\t\t\t\t\t//We will close the connection and re-establish it.\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tfor (PGNotification notification : notifications) {\n+\t\t\t\t\t\t\t\tString parameter = notification.getParameter();\n+\t\t\t\t\t\t\t\tSet<Subscription> subscriptions = this.subscriptionsMap.get(parameter);\n+\t\t\t\t\t\t\t\tif (subscriptions == null) {\n+\t\t\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tfor (Subscription subscription : subscriptions) {\n+\t\t\t\t\t\t\t\t\tsubscription.notifyUpdate();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n+\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tfinally {\n",
    "test_patch": "diff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java\nindex d5f50bb9ed7..99120ca127a 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java\n@@ -17,6 +17,8 @@\n package org.springframework.integration.jdbc.channel;\n \n import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.time.Duration;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.CountDownLatch;\n@@ -62,6 +64,7 @@\n  * @author Artem Bilan\n  * @author Igor Lovich\n  * @author Adama Sorho\n+ * @author Johannes Edmeier\n  *\n  * @since 6.0\n  */\n@@ -102,15 +105,14 @@ CREATE FUNCTION INT_CHANNEL_MESSAGE_NOTIFY_FCT()\n \n \tprivate String groupId;\n \n+\tprivate ConnectionSupplier connectionSupplier;\n+\n \t@BeforeEach\n \tvoid setUp(TestInfo testInfo) {\n \t\t// Not initiated as a bean to allow for registrations prior and post the life cycle\n-\t\tthis.postgresChannelMessageTableSubscriber =\n-\t\t\t\tnew PostgresChannelMessageTableSubscriber(() ->\n-\t\t\t\t\t\tDriverManager.getConnection(POSTGRES_CONTAINER.getJdbcUrl(),\n-\t\t\t\t\t\t\t\t\t\tPOSTGRES_CONTAINER.getUsername(),\n-\t\t\t\t\t\t\t\t\t\tPOSTGRES_CONTAINER.getPassword())\n-\t\t\t\t\t\t\t\t.unwrap(PgConnection.class));\n+\t\tthis.connectionSupplier = new ConnectionSupplier();\n+\t\tthis.postgresChannelMessageTableSubscriber = new PostgresChannelMessageTableSubscriber(connectionSupplier);\n+\t\tthis.postgresChannelMessageTableSubscriber.setNotificationTimeout(Duration.ofSeconds(5));\n \n \t\tthis.taskExecutor = new ThreadPoolTaskExecutor();\n \t\tthis.taskExecutor.setCorePoolSize(10);\n@@ -261,6 +263,26 @@ void testRetryOnErrorDuringDispatch(boolean transactionsEnabled) throws Interrup\n \t\tassertThat(payloads).containsExactly(\"1\");\n \t}\n \n+\t@Test\n+\tpublic void testRenewConnection() throws Exception {\n+\t\tCountDownLatch latch = new CountDownLatch(2);\n+\t\tList<Object> payloads = new ArrayList<>();\n+\t\tCountDownLatch connectionLatch = new CountDownLatch(2);\n+\t\tconnectionSupplier.onGetConnection = connectionLatch::countDown;\n+\t\tpostgresChannelMessageTableSubscriber.start();\n+\t\tpostgresSubscribableChannel.subscribe(message -> {\n+\t\t\tpayloads.add(message.getPayload());\n+\t\t\tlatch.countDown();\n+\t\t});\n+\n+\t\tassertThat(connectionLatch.await(10, TimeUnit.SECONDS)).isTrue();\n+\n+\t\tmessageStore.addMessageToGroup(groupId, new GenericMessage<>(\"1\"));\n+\t\tmessageStore.addMessageToGroup(groupId, new GenericMessage<>(\"2\"));\n+\t\tassertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();\n+\t\tassertThat(payloads).containsExactlyInAnyOrder(\"1\", \"2\");\n+\t}\n+\n \t@Configuration\n \t@EnableIntegration\n \tpublic static class Config {\n@@ -300,4 +322,21 @@ public JdbcChannelMessageStore jdbcChannelMessageStore(DataSource dataSource) {\n \n \t}\n \n+\tprivate static class ConnectionSupplier implements PgConnectionSupplier {\n+\n+\t\tRunnable onGetConnection;\n+\n+\t\t@Override\n+\t\tpublic PgConnection get() throws SQLException {\n+\t\t\tvar conn = DriverManager.getConnection(POSTGRES_CONTAINER.getJdbcUrl(),\n+\t\t\t\t\t\t\tPOSTGRES_CONTAINER.getUsername(),\n+\t\t\t\t\t\t\tPOSTGRES_CONTAINER.getPassword())\n+\t\t\t\t\t.unwrap(PgConnection.class);\n+\t\t\tif (this.onGetConnection != null) {\n+\t\t\t\tthis.onGetConnection.run();\n+\t\t\t}\n+\t\t\treturn conn;\n+\t\t}\n+\n+\t}\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8982",
    "pr_id": 8982,
    "issue_id": 8981,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Conditional failover in Direct Channel - Introduce Predicate<Exception> failoverStrategy into DirectChannel and its UnicastingDispatcher ( and in ExecutorChannel if possible)\n**Expected Behavior**\r\n\r\n  If I use DirectChannel and subscribe to it many ServiceActivators I would like to handle error - by failover strategy on DirectChannel level - not on ErrorChannel.  Reason of having many subscribes on one channel is having load balancing.  \r\n\r\n  So if there will be expected Exception I could stop processing and pass it to error channel instead of passing message to other subscriber.\r\n\r\n  Example - to one Direct channel I have connected two JmsOutboundGateway - both have same logic but they are connected to different mq servers - to have load balancing.\r\n\r\n  I have request that I process in my app and if I'm sending something via JmsOutboundGateway in case of MessageTimeoutException - due to long timeout I want to stop processing whole request in my app ( timeout for whole request is short). But in case its different error for example problem with connection JmsOutboundGateway to mq I want to use other subscribers connected to different server (use failover strategy).\r\n\r\n**Current Behavior**\r\n  \r\nCurrently I can't do conditional failover - if something fails other subscribers will be involved. I can turn off failover in channel and build some flows with ErrorMessageExceptionTypeRouter  but then I will have to implement by my own round robin and failover strategy.\r\n\r\n**Context**\r\n\r\nHow has this issue affected you?\r\nA lot of custom development.\r\n\r\nWhat are you trying to accomplish?\r\nApp with high volume of request with load balancing.\r\n\r\nWhat other alternatives have you considered?\r\nCoding everything myself.\r\n\r\nAre you aware of any workarounds?\r\nYes. I'd like to avoid them.\r\n",
    "issue_word_count": 270,
    "test_files_count": 3,
    "non_test_files_count": 11,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/channel/DirectChannel.java",
      "spring-integration-core/src/main/java/org/springframework/integration/channel/ExecutorChannel.java",
      "spring-integration-core/src/main/java/org/springframework/integration/channel/PartitionedChannel.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dispatcher/PartitionedDispatcher.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dispatcher/UnicastingDispatcher.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/DirectChannelSpec.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/ExecutorChannelSpec.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/LoadBalancingChannelSpec.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/PartitionedChannelSpec.java",
      "spring-integration-core/src/test/java/org/springframework/integration/channel/PartitionedChannelTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/channel/config/DispatchingChannelParserTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dispatcher/FailOverDispatcherTests.java",
      "src/reference/antora/modules/ROOT/pages/channel/configuration.adoc",
      "src/reference/antora/modules/ROOT/pages/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/channel/PartitionedChannelTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/channel/config/DispatchingChannelParserTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dispatcher/FailOverDispatcherTests.java"
    ],
    "base_commit": "809d1396af18ee423c8d09f342e47b4e37553f75",
    "head_commit": "fbe6c34943cb23f7b675d45d5ad8d8feb9140f8f",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8982",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8982",
    "dockerfile": "",
    "pr_merged_at": "2024-03-12T22:16:02.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/channel/DirectChannel.java b/spring-integration-core/src/main/java/org/springframework/integration/channel/DirectChannel.java\nindex 21169c47777..7707b1ff113 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/channel/DirectChannel.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/channel/DirectChannel.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,8 @@\n \n package org.springframework.integration.channel;\n \n+import java.util.function.Predicate;\n+\n import org.springframework.integration.dispatcher.LoadBalancingStrategy;\n import org.springframework.integration.dispatcher.RoundRobinLoadBalancingStrategy;\n import org.springframework.integration.dispatcher.UnicastingDispatcher;\n@@ -60,12 +62,26 @@ public DirectChannel(@Nullable LoadBalancingStrategy loadBalancingStrategy) {\n \t/**\n \t * Specify whether the channel's dispatcher should have failover enabled.\n \t * By default, it will. Set this value to 'false' to disable it.\n+\t * Overrides {@link #setFailoverStrategy(Predicate)} option.\n+\t * In other words: or this, or that option has to be set.\n \t * @param failover The failover boolean.\n \t */\n \tpublic void setFailover(boolean failover) {\n \t\tthis.dispatcher.setFailover(failover);\n \t}\n \n+\t/**\n+\t * Configure a strategy whether the channel's dispatcher should have failover enabled\n+\t * for the exception thrown.\n+\t * Overrides {@link #setFailover(boolean)} option.\n+\t * In other words: or this, or that option has to be set.\n+\t * @param failoverStrategy The failover boolean.\n+\t * @since 6.3\n+\t */\n+\tpublic void setFailoverStrategy(Predicate<Exception> failoverStrategy) {\n+\t\tthis.dispatcher.setFailoverStrategy(failoverStrategy);\n+\t}\n+\n \t/**\n \t * Specify the maximum number of subscribers supported by the\n \t * channel's dispatcher.\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/channel/ExecutorChannel.java b/spring-integration-core/src/main/java/org/springframework/integration/channel/ExecutorChannel.java\nindex 2a90db4b2f7..0c674e36fdb 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/channel/ExecutorChannel.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/channel/ExecutorChannel.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,6 +17,7 @@\n package org.springframework.integration.channel;\n \n import java.util.concurrent.Executor;\n+import java.util.function.Predicate;\n \n import org.springframework.integration.dispatcher.LoadBalancingStrategy;\n import org.springframework.integration.dispatcher.RoundRobinLoadBalancingStrategy;\n@@ -49,7 +50,7 @@ public class ExecutorChannel extends AbstractExecutorChannel {\n \n \tprivate final LoadBalancingStrategy loadBalancingStrategy;\n \n-\tprivate boolean failover = true;\n+\tprivate Predicate<Exception> failoverStrategy = (exception) -> true;\n \n \t/**\n \t * Create an ExecutorChannel that delegates to the provided\n@@ -88,8 +89,20 @@ public ExecutorChannel(Executor executor, @Nullable LoadBalancingStrategy loadBa\n \t * @param failover The failover boolean.\n \t */\n \tpublic void setFailover(boolean failover) {\n-\t\tthis.failover = failover;\n-\t\tgetDispatcher().setFailover(failover);\n+\t\tsetFailoverStrategy((exception) -> failover);\n+\t}\n+\n+\t/**\n+\t * Configure a strategy whether the channel's dispatcher should have failover enabled\n+\t * for the exception thrown.\n+\t * Overrides {@link #setFailover(boolean)} option.\n+\t * In other words: or this, or that option has to be set.\n+\t * @param failoverStrategy The failover boolean.\n+\t * @since 6.3\n+\t */\n+\tpublic void setFailoverStrategy(Predicate<Exception> failoverStrategy) {\n+\t\tthis.failoverStrategy = failoverStrategy;\n+\t\tgetDispatcher().setFailoverStrategy(failoverStrategy);\n \t}\n \n \t@Override\n@@ -107,7 +120,7 @@ public final void onInit() {\n \t\t\tthis.executor = new ErrorHandlingTaskExecutor(this.executor, errorHandler);\n \t\t}\n \t\tUnicastingDispatcher unicastingDispatcher = new UnicastingDispatcher(this.executor);\n-\t\tunicastingDispatcher.setFailover(this.failover);\n+\t\tunicastingDispatcher.setFailoverStrategy(this.failoverStrategy);\n \t\tif (this.maxSubscribers == null) {\n \t\t\tthis.maxSubscribers = getIntegrationProperties().getChannelsMaxUnicastSubscribers();\n \t\t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/channel/PartitionedChannel.java b/spring-integration-core/src/main/java/org/springframework/integration/channel/PartitionedChannel.java\nindex f8bc59ea98b..2dabfd5d887 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/channel/PartitionedChannel.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/channel/PartitionedChannel.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2023 the original author or authors.\n+ * Copyright 2023-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,6 +18,7 @@\n \n import java.util.concurrent.ThreadFactory;\n import java.util.function.Function;\n+import java.util.function.Predicate;\n \n import org.springframework.integration.IntegrationMessageHeaderAccessor;\n import org.springframework.integration.dispatcher.LoadBalancingStrategy;\n@@ -99,6 +100,18 @@ public void setFailover(boolean failover) {\n \t\tgetDispatcher().setFailover(failover);\n \t}\n \n+\t/**\n+\t * Configure a strategy whether the channel's dispatcher should have failover enabled\n+\t * for the exception thrown.\n+\t * Overrides {@link #setFailover(boolean)} option.\n+\t * In other words: or this, or that option has to be set.\n+\t * @param failoverStrategy The failover boolean.\n+\t * @since 6.3\n+\t */\n+\tpublic void setFailoverStrategy(Predicate<Exception> failoverStrategy) {\n+\t\tgetDispatcher().setFailoverStrategy(failoverStrategy);\n+\t}\n+\n \t/**\n \t * Provide a {@link LoadBalancingStrategy} for the {@link PartitionedDispatcher}.\n \t * @param loadBalancingStrategy The load balancing strategy implementation.\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/PartitionedDispatcher.java b/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/PartitionedDispatcher.java\nindex afb8de28595..9b19885830e 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/PartitionedDispatcher.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/PartitionedDispatcher.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2023 the original author or authors.\n+ * Copyright 2023-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -28,6 +28,7 @@\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.Function;\n+import java.util.function.Predicate;\n \n import org.springframework.integration.util.ErrorHandlingTaskExecutor;\n import org.springframework.lang.Nullable;\n@@ -67,7 +68,7 @@ public class PartitionedDispatcher extends AbstractDispatcher {\n \n \tprivate ThreadFactory threadFactory = new CustomizableThreadFactory(\"partition-thread-\");\n \n-\tprivate boolean failover = true;\n+\tprivate Predicate<Exception> failoverStrategy = (exception) -> true;\n \n \t@Nullable\n \tprivate LoadBalancingStrategy loadBalancingStrategy;\n@@ -108,7 +109,20 @@ public void setThreadFactory(ThreadFactory threadFactory) {\n \t * @param failover The failover boolean.\n \t */\n \tpublic void setFailover(boolean failover) {\n-\t\tthis.failover = failover;\n+\t\tsetFailoverStrategy((exception) -> failover);\n+\t}\n+\n+\t/**\n+\t * Configure a strategy whether the channel's dispatcher should have failover enabled\n+\t * for the exception thrown.\n+\t * Overrides {@link #setFailover(boolean)} option.\n+\t * In other words: or this, or that option has to be set.\n+\t * @param failoverStrategy The failover boolean.\n+\t * @since 6.3\n+\t */\n+\tpublic void setFailoverStrategy(Predicate<Exception> failoverStrategy) {\n+\t\tAssert.notNull(failoverStrategy, \"'failoverStrategy' must not be null\");\n+\t\tthis.failoverStrategy = failoverStrategy;\n \t}\n \n \t/**\n@@ -179,7 +193,7 @@ private UnicastingDispatcher newPartition() {\n \t\tthis.executors.add(executor);\n \t\tDelegateDispatcher delegateDispatcher =\n \t\t\t\tnew DelegateDispatcher(new ErrorHandlingTaskExecutor(executor, this.errorHandler));\n-\t\tdelegateDispatcher.setFailover(this.failover);\n+\t\tdelegateDispatcher.setFailoverStrategy(this.failoverStrategy);\n \t\tdelegateDispatcher.setLoadBalancingStrategy(this.loadBalancingStrategy);\n \t\tdelegateDispatcher.setMessageHandlingTaskDecorator(this.messageHandlingTaskDecorator);\n \t\treturn delegateDispatcher;\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/UnicastingDispatcher.java b/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/UnicastingDispatcher.java\nindex 6988bab6939..699aed54981 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/UnicastingDispatcher.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/UnicastingDispatcher.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,6 +21,7 @@\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.Executor;\n+import java.util.function.Predicate;\n \n import org.springframework.integration.MessageDispatchingException;\n import org.springframework.integration.support.utils.IntegrationUtils;\n@@ -58,7 +59,7 @@ public class UnicastingDispatcher extends AbstractDispatcher {\n \n \tprivate final Executor executor;\n \n-\tprivate boolean failover = true;\n+\tprivate Predicate<Exception> failoverStrategy = (exception) -> true;\n \n \tprivate LoadBalancingStrategy loadBalancingStrategy;\n \n@@ -77,10 +78,25 @@ public UnicastingDispatcher(@Nullable Executor executor) {\n \t * Specify whether this dispatcher should failover when a single\n \t * {@link MessageHandler} throws an Exception. The default value is\n \t * <code>true</code>.\n+\t * Overrides {@link #setFailoverStrategy(Predicate)} option.\n+\t * In other words: or this, or that option has to be set.\n \t * @param failover The failover boolean.\n \t */\n \tpublic void setFailover(boolean failover) {\n-\t\tthis.failover = failover;\n+\t\tsetFailoverStrategy((exception) -> failover);\n+\t}\n+\n+\t/**\n+\t * Configure a strategy whether the channel's dispatcher should have failover enabled\n+\t * for the exception thrown.\n+\t * Overrides {@link #setFailover(boolean)} option.\n+\t * In other words: or this, or that option has to be set.\n+\t * @param failoverStrategy The failover boolean.\n+\t * @since 6.3\n+\t */\n+\tpublic void setFailoverStrategy(Predicate<Exception> failoverStrategy) {\n+\t\tAssert.notNull(failoverStrategy, \"'failoverStrategy' must not be null\");\n+\t\tthis.failoverStrategy = failoverStrategy;\n \t}\n \n \t/**\n@@ -154,10 +170,15 @@ private boolean doDispatch(Message<?> message) {\n \t\t\t\t}\n \t\t\t\texceptions.add(runtimeException);\n \t\t\t\tboolean isLast = !handlerIterator.hasNext();\n-\t\t\t\tif (!isLast && this.failover) {\n+\t\t\t\tboolean failover = this.failoverStrategy.test(ex);\n+\n+\t\t\t\tif (!isLast && failover) {\n \t\t\t\t\tlogExceptionBeforeFailOver(ex, handler, message);\n \t\t\t\t}\n-\t\t\t\thandleExceptions(exceptions, message, isLast);\n+\n+\t\t\t\tif (isLast || !failover) {\n+\t\t\t\t\thandleExceptions(exceptions, message);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn success;\n@@ -187,22 +208,12 @@ else if (this.logger.isInfoEnabled()) {\n \t\t}\n \t}\n \n-\t/**\n-\t * Handles Exceptions that occur while dispatching. If this dispatcher has\n-\t * failover enabled, it will only throw an Exception when the handler list\n-\t * is exhausted. The 'isLast' flag will be <em>true</em> if the\n-\t * Exception occurred during the final iteration of the MessageHandlers.\n-\t * If failover is disabled for this dispatcher, it will re-throw any\n-\t * Exception immediately.\n-\t */\n-\tprivate void handleExceptions(List<RuntimeException> allExceptions, Message<?> message, boolean isLast) {\n-\t\tif (isLast || !this.failover) {\n-\t\t\tif (allExceptions.size() == 1) {\n-\t\t\t\tthrow allExceptions.get(0);\n-\t\t\t}\n-\t\t\tthrow new AggregateMessageDeliveryException(message,\n-\t\t\t\t\t\"All attempts to deliver Message to MessageHandlers failed.\", allExceptions);\n+\tprivate void handleExceptions(List<RuntimeException> allExceptions, Message<?> message) {\n+\t\tif (allExceptions.size() == 1) {\n+\t\t\tthrow allExceptions.get(0);\n \t\t}\n+\t\tthrow new AggregateMessageDeliveryException(message,\n+\t\t\t\t\"All attempts to deliver Message to MessageHandlers failed.\", allExceptions);\n \t}\n \n }\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/DirectChannelSpec.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/DirectChannelSpec.java\nindex 74e956fe24e..8fc58f51b68 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/DirectChannelSpec.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/DirectChannelSpec.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2020 the original author or authors.\n+ * Copyright 2016-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -28,8 +28,8 @@ public class DirectChannelSpec extends LoadBalancingChannelSpec<DirectChannelSpe\n \t@Override\n \tprotected DirectChannel doGet() {\n \t\tthis.channel = new DirectChannel(this.loadBalancingStrategy);\n-\t\tif (this.failover != null) {\n-\t\t\tthis.channel.setFailover(this.failover);\n+\t\tif (this.failoverStrategy != null) {\n+\t\t\tthis.channel.setFailoverStrategy(this.failoverStrategy);\n \t\t}\n \t\tif (this.maxSubscribers != null) {\n \t\t\tthis.channel.setMaxSubscribers(this.maxSubscribers);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/ExecutorChannelSpec.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/ExecutorChannelSpec.java\nindex d27a8fe08af..005e4b0cfe9 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/ExecutorChannelSpec.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/ExecutorChannelSpec.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2020 the original author or authors.\n+ * Copyright 2016-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -36,8 +36,8 @@ protected ExecutorChannelSpec(Executor executor) {\n \t@Override\n \tprotected ExecutorChannel doGet() {\n \t\tthis.channel = new ExecutorChannel(this.executor, this.loadBalancingStrategy);\n-\t\tif (this.failover != null) {\n-\t\t\tthis.channel.setFailover(this.failover);\n+\t\tif (this.failoverStrategy != null) {\n+\t\t\tthis.channel.setFailoverStrategy(this.failoverStrategy);\n \t\t}\n \t\tif (this.maxSubscribers != null) {\n \t\t\tthis.channel.setMaxSubscribers(this.maxSubscribers);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/LoadBalancingChannelSpec.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/LoadBalancingChannelSpec.java\nindex 6f6c4252f62..061662d83aa 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/LoadBalancingChannelSpec.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/LoadBalancingChannelSpec.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2019 the original author or authors.\n+ * Copyright 2016-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,8 @@\n \n package org.springframework.integration.dsl;\n \n+import java.util.function.Predicate;\n+\n import org.springframework.integration.channel.AbstractMessageChannel;\n import org.springframework.integration.dispatcher.LoadBalancingStrategy;\n import org.springframework.integration.dispatcher.RoundRobinLoadBalancingStrategy;\n@@ -34,7 +36,7 @@ public abstract class LoadBalancingChannelSpec<S extends MessageChannelSpec<S, C\n \n \tprotected LoadBalancingStrategy loadBalancingStrategy = new RoundRobinLoadBalancingStrategy(); // NOSONAR\n \n-\tprotected Boolean failover; // NOSONAR\n+\tprotected Predicate<Exception> failoverStrategy; // NOSONAR\n \n \tprotected Integer maxSubscribers; // NOSONAR\n \n@@ -46,8 +48,20 @@ public S loadBalancer(LoadBalancingStrategy loadBalancingStrategyToSet) {\n \t\treturn _this();\n \t}\n \n-\tpublic S failover(Boolean failoverToSet) {\n-\t\tthis.failover = failoverToSet;\n+\tpublic S failover(boolean failoverToSet) {\n+\t\treturn failoverStrategy((exception) -> failoverToSet);\n+\t}\n+\n+\t/**\n+\t * Configure a strategy whether the channel's dispatcher should have failover enabled\n+\t * for the exception thrown.\n+\t * Overrides {@link #failover(boolean)} option.\n+\t * In other words: or this, or that option has to be set.\n+\t * @param failoverStrategy The failover boolean.\n+\t * @since 6.3\n+\t */\n+\tpublic S failoverStrategy(Predicate<Exception> failoverStrategy) {\n+\t\tthis.failoverStrategy = failoverStrategy;\n \t\treturn _this();\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/PartitionedChannelSpec.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/PartitionedChannelSpec.java\nindex 0e8d31ee834..bc7d66bba3d 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/PartitionedChannelSpec.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/PartitionedChannelSpec.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2023 the original author or authors.\n+ * Copyright 2023-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -63,8 +63,8 @@ protected PartitionedChannel doGet() {\n \t\t\tthis.channel = new PartitionedChannel(this.partitionCount);\n \t\t}\n \t\tthis.channel.setLoadBalancingStrategy(this.loadBalancingStrategy);\n-\t\tif (this.failover != null) {\n-\t\t\tthis.channel.setFailover(this.failover);\n+\t\tif (this.failoverStrategy != null) {\n+\t\t\tthis.channel.setFailoverStrategy(this.failoverStrategy);\n \t\t}\n \t\tif (this.maxSubscribers != null) {\n \t\t\tthis.channel.setMaxSubscribers(this.maxSubscribers);\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc b/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc\nindex bfc957c9c2f..b34d9cfc394 100644\n--- a/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc\n@@ -112,6 +112,10 @@ XML::\n ----\n ======\n \n+Starting with version 6.3, all the `MessageChannel` implementations based on the `UnicastingDispatcher` can be configured with a `Predicate<Exception> failoverStrategy` instead of plain `failover` option.\n+This predicate makes a decision to failover or not to the next `MessageHandler` based on an exception thrown from the current one.\n+The more complex error analysis should be done using xref:router/implementations.adoc#router-implementations-exception-router[`ErrorMessageExceptionTypeRouter`].\n+\n [[channel-datatype-channel]]\n == Datatype Channel Configuration\n \n\ndiff --git a/src/reference/antora/modules/ROOT/pages/whats-new.adoc b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\nindex 73400235dd9..3fb6bc06de4 100644\n--- a/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n@@ -23,6 +23,9 @@ The `MessageHistory` header is now mutable, append-only container.\n And all the subsequent tracks don't create new message - only their entry is added to existing message history header.\n See xref:message-history.adoc[Message History Chapter] for more information.\n \n+All the `MessageChannel` implementations based on the `UnicastingDispatcher` now can be configured with a `Predicate<Exception> failoverStrategy` for dynamic decision for the failover on the exception thrown from the current `MessageHandler`.\n+See xref:channel/configuration.adoc[Message Channel Configuration] for more information.\n+\n [[x6.3-security-changes]]\n === Security Support Changes\n \n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/channel/PartitionedChannelTests.java b/spring-integration-core/src/test/java/org/springframework/integration/channel/PartitionedChannelTests.java\nindex 6aed78cf8ef..23e773c6adb 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/channel/PartitionedChannelTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/channel/PartitionedChannelTests.java\n@@ -21,6 +21,8 @@\n import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.stream.IntStream;\n \n import org.assertj.core.api.InstanceOfAssertFactories;\n@@ -76,7 +78,16 @@ public void afterMessageHandled(Message<?> message, MessageChannel ch, MessageHa\n \n \t\tMultiValueMap<String, Message<?>> partitionedMessages = new LinkedMultiValueMap<>();\n \n-\t\tpartitionedChannel.subscribe((message) -> partitionedMessages.add(Thread.currentThread().getName(), message));\n+\t\tLock partitionsLock = new ReentrantLock();\n+\t\tpartitionedChannel.subscribe((message) -> {\n+\t\t\tpartitionsLock.lock();\n+\t\t\ttry {\n+\t\t\t\tpartitionedMessages.add(Thread.currentThread().getName(), message);\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tpartitionsLock.unlock();\n+\t\t\t}\n+\t\t});\n \n \t\tpartitionedChannel.send(MessageBuilder.withPayload(\"test1\").setHeader(\"partitionKey\", \"1\").build());\n \t\tpartitionedChannel.send(MessageBuilder.withPayload(\"test2\").setHeader(\"partitionKey\", \"2\").build());\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/channel/config/DispatchingChannelParserTests.java b/spring-integration-core/src/test/java/org/springframework/integration/channel/config/DispatchingChannelParserTests.java\nindex c8f65a7a142..8d7e31ff730 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/channel/config/DispatchingChannelParserTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/channel/config/DispatchingChannelParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,9 +19,9 @@\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.Map;\n+import java.util.function.Predicate;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.DirectFieldAccessor;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -37,18 +37,20 @@\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.messaging.MessageHandler;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.mockito.Mockito.mock;\n \n /**\n  * @author Mark Fisher\n  * @author Oleg Zhurakousky\n+ * @author Artem Bilan\n+ *\n  * @since 1.0.3\n  */\n-@RunWith(SpringJUnit4ClassRunner.class)\n-@ContextConfiguration\n+@SpringJUnitConfig\n public class DispatchingChannelParserTests {\n \n \t@Autowired\n@@ -60,50 +62,60 @@ public class DispatchingChannelParserTests {\n \t@Test\n \tpublic void taskExecutorOnly() {\n \t\tMessageChannel channel = channels.get(\"taskExecutorOnly\");\n-\t\tassertThat(channel.getClass()).isEqualTo(ExecutorChannel.class);\n+\t\tassertThat(channel).isInstanceOf(ExecutorChannel.class);\n \t\tObject executor = getDispatcherProperty(\"executor\", channel);\n-\t\tassertThat(executor.getClass()).isEqualTo(ErrorHandlingTaskExecutor.class);\n+\t\tassertThat(executor).isInstanceOf(ErrorHandlingTaskExecutor.class);\n \t\tassertThat(new DirectFieldAccessor(executor).getPropertyValue(\"executor\"))\n \t\t\t\t.isSameAs(context.getBean(\"taskExecutor\"));\n-\t\tassertThat((Boolean) getDispatcherProperty(\"failover\", channel)).isTrue();\n-\t\tassertThat(getDispatcherProperty(\"loadBalancingStrategy\", channel).getClass())\n-\t\t\t\t.isEqualTo(RoundRobinLoadBalancingStrategy.class);\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tPredicate<Exception> failoverStrategy = (Predicate<Exception>) getDispatcherProperty(\"failoverStrategy\", channel);\n+\t\tassertThat(failoverStrategy.test(mock())).isTrue();\n+\t\tassertThat(getDispatcherProperty(\"loadBalancingStrategy\", channel))\n+\t\t\t\t.isInstanceOf(RoundRobinLoadBalancingStrategy.class);\n \t}\n \n \t@Test\n \tpublic void failoverFalse() {\n \t\tMessageChannel channel = channels.get(\"failoverFalse\");\n-\t\tassertThat(channel.getClass()).isEqualTo(DirectChannel.class);\n-\t\tassertThat((Boolean) getDispatcherProperty(\"failover\", channel)).isFalse();\n-\t\tassertThat(getDispatcherProperty(\"loadBalancingStrategy\", channel).getClass())\n-\t\t\t\t.isEqualTo(RoundRobinLoadBalancingStrategy.class);\n+\t\tassertThat(channel).isInstanceOf(DirectChannel.class);\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tPredicate<Exception> failoverStrategy = (Predicate<Exception>) getDispatcherProperty(\"failoverStrategy\", channel);\n+\t\tassertThat(failoverStrategy.test(mock())).isFalse();\n+\t\tassertThat(getDispatcherProperty(\"loadBalancingStrategy\", channel))\n+\t\t\t\t.isInstanceOf(RoundRobinLoadBalancingStrategy.class);\n \t}\n \n \t@Test\n \tpublic void failoverTrue() {\n \t\tMessageChannel channel = channels.get(\"failoverTrue\");\n-\t\tassertThat(channel.getClass()).isEqualTo(DirectChannel.class);\n-\t\tassertThat((Boolean) getDispatcherProperty(\"failover\", channel)).isTrue();\n-\t\tassertThat(getDispatcherProperty(\"loadBalancingStrategy\", channel).getClass())\n-\t\t\t\t.isEqualTo(RoundRobinLoadBalancingStrategy.class);\n+\t\tassertThat(channel).isInstanceOf(DirectChannel.class);\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tPredicate<Exception> failoverStrategy = (Predicate<Exception>) getDispatcherProperty(\"failoverStrategy\", channel);\n+\t\tassertThat(failoverStrategy.test(mock())).isTrue();\n+\t\tassertThat(getDispatcherProperty(\"loadBalancingStrategy\", channel))\n+\t\t\t\t.isInstanceOf(RoundRobinLoadBalancingStrategy.class);\n \t}\n \n \t@Test\n \tpublic void loadBalancerDisabled() {\n \t\tMessageChannel channel = channels.get(\"loadBalancerDisabled\");\n-\t\tassertThat(channel.getClass()).isEqualTo(DirectChannel.class);\n-\t\tassertThat((Boolean) getDispatcherProperty(\"failover\", channel)).isTrue();\n+\t\tassertThat(channel).isInstanceOf(DirectChannel.class);\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tPredicate<Exception> failoverStrategy = (Predicate<Exception>) getDispatcherProperty(\"failoverStrategy\", channel);\n+\t\tassertThat(failoverStrategy.test(mock())).isTrue();\n \t\tassertThat(getDispatcherProperty(\"loadBalancingStrategy\", channel)).isNull();\n \t}\n \n \t@Test\n \tpublic void loadBalancerDisabledAndTaskExecutor() {\n \t\tMessageChannel channel = channels.get(\"loadBalancerDisabledAndTaskExecutor\");\n-\t\tassertThat(channel.getClass()).isEqualTo(ExecutorChannel.class);\n-\t\tassertThat((Boolean) getDispatcherProperty(\"failover\", channel)).isTrue();\n+\t\tassertThat(channel).isInstanceOf(ExecutorChannel.class);\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tPredicate<Exception> failoverStrategy = (Predicate<Exception>) getDispatcherProperty(\"failoverStrategy\", channel);\n+\t\tassertThat(failoverStrategy.test(mock())).isTrue();\n \t\tassertThat(getDispatcherProperty(\"loadBalancingStrategy\", channel)).isNull();\n \t\tObject executor = getDispatcherProperty(\"executor\", channel);\n-\t\tassertThat(executor.getClass()).isEqualTo(ErrorHandlingTaskExecutor.class);\n+\t\tassertThat(executor).isInstanceOf(ErrorHandlingTaskExecutor.class);\n \t\tassertThat(new DirectFieldAccessor(executor).getPropertyValue(\"executor\"))\n \t\t\t\t.isSameAs(context.getBean(\"taskExecutor\"));\n \t}\n@@ -111,12 +123,14 @@ public void loadBalancerDisabledAndTaskExecutor() {\n \t@Test\n \tpublic void roundRobinLoadBalancerAndTaskExecutor() {\n \t\tMessageChannel channel = channels.get(\"roundRobinLoadBalancerAndTaskExecutor\");\n-\t\tassertThat(channel.getClass()).isEqualTo(ExecutorChannel.class);\n-\t\tassertThat((Boolean) getDispatcherProperty(\"failover\", channel)).isTrue();\n-\t\tassertThat(getDispatcherProperty(\"loadBalancingStrategy\", channel).getClass())\n-\t\t\t\t.isEqualTo(RoundRobinLoadBalancingStrategy.class);\n+\t\tassertThat(channel).isInstanceOf(ExecutorChannel.class);\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tPredicate<Exception> failoverStrategy = (Predicate<Exception>) getDispatcherProperty(\"failoverStrategy\", channel);\n+\t\tassertThat(failoverStrategy.test(mock())).isTrue();\n+\t\tassertThat(getDispatcherProperty(\"loadBalancingStrategy\", channel))\n+\t\t\t\t.isInstanceOf(RoundRobinLoadBalancingStrategy.class);\n \t\tObject executor = getDispatcherProperty(\"executor\", channel);\n-\t\tassertThat(executor.getClass()).isEqualTo(ErrorHandlingTaskExecutor.class);\n+\t\tassertThat(executor).isInstanceOf(ErrorHandlingTaskExecutor.class);\n \t\tassertThat(new DirectFieldAccessor(executor).getPropertyValue(\"executor\"))\n \t\t\t\t.isSameAs(context.getBean(\"taskExecutor\"));\n \t}\n@@ -126,19 +140,15 @@ public void loadBalancerRef() {\n \t\tMessageChannel channel = channels.get(\"lbRefChannel\");\n \t\tLoadBalancingStrategy lbStrategy = TestUtils.getPropertyValue(channel, \"dispatcher.loadBalancingStrategy\",\n \t\t\t\tLoadBalancingStrategy.class);\n-\t\tassertThat(lbStrategy instanceof SampleLoadBalancingStrategy).isTrue();\n+\t\tassertThat(lbStrategy).isInstanceOf(SampleLoadBalancingStrategy.class);\n \t}\n \n \t@Test\n \tpublic void loadBalancerRefFailWithLoadBalancer() {\n-\n-\t\ttry {\n-\t\t\tnew ClassPathXmlApplicationContext(\"ChannelWithLoadBalancerRef-fail-config.xml\", this.getClass()).close();\n-\t\t}\n-\t\tcatch (BeanDefinitionParsingException e) {\n-\t\t\tassertThat(e.getMessage()).contains(\"'load-balancer' and 'load-balancer-ref' are mutually exclusive\");\n-\t\t}\n-\n+\t\tassertThatExceptionOfType(BeanDefinitionParsingException.class)\n+\t\t\t\t.isThrownBy(() -> new ClassPathXmlApplicationContext(\"ChannelWithLoadBalancerRef-fail-config.xml\",\n+\t\t\t\t\t\tgetClass()))\n+\t\t\t\t.withMessageContaining(\"'load-balancer' and 'load-balancer-ref' are mutually exclusive\");\n \t}\n \n \tprivate static Object getDispatcherProperty(String propertyName, MessageChannel channel) {\n@@ -153,5 +163,7 @@ public static class SampleLoadBalancingStrategy implements LoadBalancingStrategy\n \t\tpublic Iterator<MessageHandler> getHandlerIterator(Message<?> message, Collection<MessageHandler> handlers) {\n \t\t\treturn handlers.iterator();\n \t\t}\n+\n \t}\n+\n }\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/dispatcher/FailOverDispatcherTests.java b/spring-integration-core/src/test/java/org/springframework/integration/dispatcher/FailOverDispatcherTests.java\nindex e7d5f114428..4db091f5698 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/dispatcher/FailOverDispatcherTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/dispatcher/FailOverDispatcherTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,7 +20,7 @@\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.integration.MessageRejectedException;\n@@ -32,6 +32,7 @@\n import org.springframework.messaging.support.GenericMessage;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n import static org.mockito.Mockito.mock;\n \n /**\n@@ -69,12 +70,8 @@ public void noDuplicateSubscriptions() {\n \t\tMessageHandler target = new CountingTestEndpoint(counter, false);\n \t\tdispatcher.addHandler(target);\n \t\tdispatcher.addHandler(target);\n-\t\ttry {\n-\t\t\tdispatcher.dispatch(new GenericMessage<>(\"test\"));\n-\t\t}\n-\t\tcatch (Exception e) {\n-\t\t\t// ignore\n-\t\t}\n+\t\tassertThatExceptionOfType(MessageRejectedException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(new GenericMessage<>(\"test\")));\n \t\tassertThat(counter.get()).as(\"target should not have duplicate subscriptions\").isEqualTo(1);\n \t}\n \n@@ -89,12 +86,8 @@ public void removeConsumerBeforeSend() {\n \t\tdispatcher.addHandler(target2);\n \t\tdispatcher.addHandler(target3);\n \t\tdispatcher.removeHandler(target2);\n-\t\ttry {\n-\t\t\tdispatcher.dispatch(new GenericMessage<>(\"test\"));\n-\t\t}\n-\t\tcatch (Exception e) {\n-\t\t\t// ignore\n-\t\t}\n+\t\tassertThatExceptionOfType(AggregateMessageDeliveryException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(new GenericMessage<>(\"test\")));\n \t\tassertThat(counter.get()).isEqualTo(2);\n \t}\n \n@@ -108,46 +101,31 @@ public void removeConsumerBetweenSends() {\n \t\tdispatcher.addHandler(target1);\n \t\tdispatcher.addHandler(target2);\n \t\tdispatcher.addHandler(target3);\n-\t\ttry {\n-\t\t\tdispatcher.dispatch(new GenericMessage<>(\"test1\"));\n-\t\t}\n-\t\tcatch (Exception e) {\n-\t\t\t// ignore\n-\t\t}\n+\t\tassertThatExceptionOfType(AggregateMessageDeliveryException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(new GenericMessage<>(\"test1\")));\n \t\tassertThat(counter.get()).isEqualTo(3);\n \t\tdispatcher.removeHandler(target2);\n-\t\ttry {\n-\t\t\tdispatcher.dispatch(new GenericMessage<>(\"test2\"));\n-\t\t}\n-\t\tcatch (Exception e) {\n-\t\t\t// ignore\n-\t\t}\n+\t\tassertThatExceptionOfType(AggregateMessageDeliveryException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(new GenericMessage<>(\"test2\")));\n \t\tassertThat(counter.get()).isEqualTo(5);\n \t\tdispatcher.removeHandler(target1);\n-\t\ttry {\n-\t\t\tdispatcher.dispatch(new GenericMessage<>(\"test3\"));\n-\t\t}\n-\t\tcatch (Exception e) {\n-\t\t\t// ignore\n-\t\t}\n+\t\tassertThatExceptionOfType(MessageRejectedException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(new GenericMessage<>(\"test3\")));\n \t\tassertThat(counter.get()).isEqualTo(6);\n \t}\n \n-\t@Test(expected = MessageDeliveryException.class)\n+\t@Test\n \tpublic void removeConsumerLastTargetCausesDeliveryException() {\n \t\tUnicastingDispatcher dispatcher = new UnicastingDispatcher();\n \t\tfinal AtomicInteger counter = new AtomicInteger();\n \t\tMessageHandler target = new CountingTestEndpoint(counter, false);\n \t\tdispatcher.addHandler(target);\n-\t\ttry {\n-\t\t\tdispatcher.dispatch(new GenericMessage<>(\"test1\"));\n-\t\t}\n-\t\tcatch (Exception e) {\n-\t\t\t// ignore\n-\t\t}\n+\t\tassertThatExceptionOfType(MessageRejectedException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(new GenericMessage<>(\"test1\")));\n \t\tassertThat(counter.get()).isEqualTo(1);\n \t\tdispatcher.removeHandler(target);\n-\t\tdispatcher.dispatch(new GenericMessage<>(\"test2\"));\n+\t\tassertThatExceptionOfType(MessageDeliveryException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(new GenericMessage<>(\"test2\")));\n \t}\n \n \t@Test\n@@ -188,15 +166,26 @@ public void allHandlersReturnFalse() {\n \t\tdispatcher.addHandler(target1);\n \t\tdispatcher.addHandler(target2);\n \t\tdispatcher.addHandler(target3);\n-\t\ttry {\n-\t\t\tassertThat(dispatcher.dispatch(new GenericMessage<>(\"test\"))).isFalse();\n-\t\t}\n-\t\tcatch (Exception e) {\n-\t\t\t// ignore\n-\t\t}\n+\t\tassertThatExceptionOfType(AggregateMessageDeliveryException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(new GenericMessage<>(\"test\")));\n \t\tassertThat(counter.get()).as(\"each target should have been invoked\").isEqualTo(3);\n \t}\n \n+\t@Test\n+\tpublic void failoverStrategyRejects() {\n+\t\tUnicastingDispatcher dispatcher = new UnicastingDispatcher();\n+\t\tdispatcher.setFailoverStrategy((exception) -> !(exception instanceof MessageRejectedException));\n+\t\tAtomicInteger counter = new AtomicInteger();\n+\t\tMessageHandler target1 = new CountingTestEndpoint(counter, false);\n+\t\tMessageHandler target2 = new CountingTestEndpoint(counter, true);\n+\t\tMessageHandler target3 = new CountingTestEndpoint(counter, true);\n+\t\tdispatcher.addHandler(target1);\n+\t\tdispatcher.addHandler(target2);\n+\t\tdispatcher.addHandler(target3);\n+\t\tassertThatExceptionOfType(MessageRejectedException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(new GenericMessage<>(\"test\")));\n+\t\tassertThat(counter.get()).as(\"only first should have been invoked\").isEqualTo(1);\n+\t}\n \n \tprivate static ServiceActivatingHandler createConsumer(Object object) {\n \t\tServiceActivatingHandler handler = new ServiceActivatingHandler(object);\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8980",
    "pr_id": 8980,
    "issue_id": 7925,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Consider a Mechanism to Avoid Message Rebuilding on Every Track [INT-3983]\n**[Gary Russell](https://jira.spring.io/secure/ViewProfile.jspa?name=grussell)** opened **[INT-3983](https://jira.spring.io/browse/INT-3983?redirect=false)** and commented\n\nSee the discussion on https://github.com/spring-projects/spring-integration/pull/1764\n\n\n---\nNo further details from [INT-3983](https://jira.spring.io/browse/INT-3983?redirect=false)",
    "issue_word_count": 65,
    "test_files_count": 3,
    "non_test_files_count": 9,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/channel/interceptor/WireTap.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dispatcher/BroadcastingDispatcher.java",
      "spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java",
      "spring-integration-core/src/main/java/org/springframework/integration/history/MessageHistory.java",
      "spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java",
      "spring-integration-core/src/main/java/org/springframework/integration/splitter/AbstractMessageSplitter.java",
      "spring-integration-core/src/main/java/org/springframework/integration/support/AbstractIntegrationMessageBuilder.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/annotation/MessagingAnnotationsWithBeanAnnotationTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/core/MessageHistoryTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dispatcher/BroadcastingDispatcherTests.java",
      "src/reference/antora/modules/ROOT/pages/message-history.adoc",
      "src/reference/antora/modules/ROOT/pages/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/config/annotation/MessagingAnnotationsWithBeanAnnotationTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/core/MessageHistoryTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dispatcher/BroadcastingDispatcherTests.java"
    ],
    "base_commit": "3fbe917e6c43e30c8c7bef1e6f3b39aa5c99f4ce",
    "head_commit": "ffa2c7bb9b08d4ad383ba970a961a3db95835de5",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8980",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8980",
    "dockerfile": "",
    "pr_merged_at": "2024-03-05T20:05:34.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/channel/interceptor/WireTap.java b/spring-integration-core/src/main/java/org/springframework/integration/channel/interceptor/WireTap.java\nindex 038b4b6d559..4b6005a9130 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/channel/interceptor/WireTap.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/channel/interceptor/WireTap.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2020 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,8 +23,11 @@\n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryAware;\n import org.springframework.integration.core.MessageSelector;\n+import org.springframework.integration.history.MessageHistory;\n+import org.springframework.integration.support.MessageBuilderFactory;\n import org.springframework.integration.support.channel.ChannelResolverUtils;\n import org.springframework.integration.support.management.ManageableLifecycle;\n+import org.springframework.integration.support.utils.IntegrationUtils;\n import org.springframework.jmx.export.annotation.ManagedAttribute;\n import org.springframework.jmx.export.annotation.ManagedOperation;\n import org.springframework.jmx.export.annotation.ManagedResource;\n@@ -57,6 +60,8 @@ public class WireTap implements ChannelInterceptor, ManageableLifecycle, VetoCap\n \n \tprivate BeanFactory beanFactory;\n \n+\tprivate MessageBuilderFactory messageBuilderFactory;\n+\n \tprivate volatile boolean running = true;\n \n \n@@ -162,9 +167,19 @@ public Message<?> preSend(Message<?> message, MessageChannel channel) {\n \t\t\treturn message;\n \t\t}\n \t\tif (this.running && (this.selector == null || this.selector.accept(message))) {\n-\t\t\tboolean sent = (this.timeout >= 0)\n-\t\t\t\t\t? wireTapChannel.send(message, this.timeout)\n-\t\t\t\t\t: wireTapChannel.send(message);\n+\t\t\tMessage<?> messageToSend = message;\n+\t\t\tif (message.getHeaders().containsKey(MessageHistory.HEADER_NAME)) {\n+\t\t\t\tmessageToSend =\n+\t\t\t\t\t\tgetMessageBuilderFactory()\n+\t\t\t\t\t\t\t\t.fromMessage(message)\n+\t\t\t\t\t\t\t\t.cloneMessageHistoryIfAny()\n+\t\t\t\t\t\t\t\t.build();\n+\t\t\t}\n+\t\t\tboolean sent =\n+\t\t\t\t\t(this.timeout >= 0)\n+\t\t\t\t\t\t\t? wireTapChannel.send(messageToSend, this.timeout)\n+\t\t\t\t\t\t\t: wireTapChannel.send(messageToSend);\n+\n \t\t\tif (!sent && LOGGER.isWarnEnabled()) {\n \t\t\t\tLOGGER.warn(\"failed to send message to WireTap channel '\" + wireTapChannel + \"'\");\n \t\t\t}\n@@ -174,7 +189,6 @@ public Message<?> preSend(Message<?> message, MessageChannel channel) {\n \n \t@Override\n \tpublic boolean shouldIntercept(String beanName, InterceptableChannel channel) {\n-\n \t\treturn !getChannel().equals(channel);\n \t}\n \n@@ -189,4 +203,11 @@ private MessageChannel getChannel() {\n \t\treturn this.channel;\n \t}\n \n+\tprivate MessageBuilderFactory getMessageBuilderFactory() {\n+\t\tif (this.messageBuilderFactory == null) {\n+\t\t\tthis.messageBuilderFactory = IntegrationUtils.getMessageBuilderFactory(this.beanFactory);\n+\t\t}\n+\t\treturn this.messageBuilderFactory;\n+\t}\n+\n }\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/BroadcastingDispatcher.java b/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/BroadcastingDispatcher.java\nindex 43dec106abb..9f025a2e86d 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/BroadcastingDispatcher.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/BroadcastingDispatcher.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2023 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,18 +17,23 @@\n package org.springframework.integration.dispatcher;\n \n import java.util.Collection;\n+import java.util.UUID;\n import java.util.concurrent.Executor;\n \n import org.springframework.beans.BeansException;\n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryAware;\n import org.springframework.integration.MessageDispatchingException;\n+import org.springframework.integration.context.IntegrationObjectSupport;\n+import org.springframework.integration.history.MessageHistory;\n+import org.springframework.integration.support.AbstractIntegrationMessageBuilder;\n import org.springframework.integration.support.DefaultMessageBuilderFactory;\n import org.springframework.integration.support.MessageBuilderFactory;\n import org.springframework.integration.support.MessageDecorator;\n import org.springframework.integration.support.utils.IntegrationUtils;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.MessageHeaders;\n import org.springframework.messaging.MessagingException;\n import org.springframework.messaging.support.MessageHandlingRunnable;\n import org.springframework.util.Assert;\n@@ -153,13 +158,28 @@ public boolean dispatch(Message<?> message) {\n \t\t}\n \t\tint sequenceSize = handlers.size();\n \t\tMessage<?> messageToSend = message;\n+\t\tMessageHeaders messageHeaders = message.getHeaders();\n+\t\tUUID correlationKey = messageHeaders.getId();\n+\t\tboolean hasMessageHistory = messageHeaders.containsKey(MessageHistory.HEADER_NAME) && sequenceSize > 1;\n \t\tfor (MessageHandler handler : handlers) {\n-\t\t\tif (this.applySequence) {\n-\t\t\t\tmessageToSend = getMessageBuilderFactory()\n-\t\t\t\t\t\t.fromMessage(message)\n-\t\t\t\t\t\t.pushSequenceDetails(message.getHeaders().getId(), sequenceNumber++, sequenceSize)\n-\t\t\t\t\t\t.build();\n+\t\t\tif (this.applySequence || hasMessageHistory) {\n+\t\t\t\tAbstractIntegrationMessageBuilder<?> builder =\n+\t\t\t\t\t\tgetMessageBuilderFactory()\n+\t\t\t\t\t\t\t\t.fromMessage(message);\n+\n+\t\t\t\tif (this.applySequence) {\n+\t\t\t\t\tbuilder.pushSequenceDetails(\n+\t\t\t\t\t\t\tcorrelationKey == null ? IntegrationObjectSupport.generateId() : correlationKey,\n+\t\t\t\t\t\t\tsequenceNumber++, sequenceSize);\n+\t\t\t\t}\n+\n+\t\t\t\tif (hasMessageHistory) {\n+\t\t\t\t\tbuilder.cloneMessageHistoryIfAny();\n+\t\t\t\t}\n+\n+\t\t\t\tmessageToSend = builder.build();\n \t\t\t}\n+\n \t\t\tif (message instanceof MessageDecorator messageDecorator) {\n \t\t\t\tmessageToSend = messageDecorator.decorateMessage(messageToSend);\n \t\t\t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java\nindex 6bf0d3432ed..021b81e714c 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java\n@@ -20,6 +20,7 @@\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -465,6 +466,13 @@ else if (output instanceof AbstractIntegrationMessageBuilder) {\n \t\t}\n \t\telse {\n \t\t\tbuilder = getMessageBuilderFactory().withPayload(output);\n+\t\t\t// Assuming that message in the payload collection is a copy of request message.\n+\t\t\tif (output instanceof Iterable<?> iterable) {\n+\t\t\t\tIterator<?> iterator = iterable.iterator();\n+\t\t\t\tif (iterator.hasNext() && iterator.next() instanceof Message<?>) {\n+\t\t\t\t\tbuilder = builder.cloneMessageHistoryIfAny();\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tif (!this.noHeadersPropagation &&\n \t\t\t\t(shouldCopyRequestHeaders() ||\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/history/MessageHistory.java b/spring-integration-core/src/main/java/org/springframework/integration/history/MessageHistory.java\nindex 63ce9737c75..2dfb4bba942 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/history/MessageHistory.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/history/MessageHistory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,7 @@\n \n package org.springframework.integration.history;\n \n+import java.io.Serial;\n import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.Collection;\n@@ -52,8 +53,9 @@\n  *\n  * @since 2.0\n  */\n-public final class MessageHistory implements List<Properties>, Serializable {\n+public final class MessageHistory implements List<Properties>, Serializable, Cloneable {\n \n+\t@Serial\n \tprivate static final long serialVersionUID = -2340400235574314134L;\n \n \tprivate static final Log LOGGER = LogFactory.getLog(MessageHistory.class);\n@@ -94,51 +96,52 @@ public static <T> Message<T> write(Message<T> messageArg, NamedComponent compone\n \t\tAssert.notNull(component, \"Component must not be null\");\n \t\tProperties metadata = extractMetadata(component);\n \t\tif (!metadata.isEmpty()) {\n-\t\t\tMessageHistory previousHistory = message.getHeaders().get(HEADER_NAME, MessageHistory.class);\n-\t\t\tList<Properties> components =\n-\t\t\t\t\tpreviousHistory != null\n-\t\t\t\t\t\t\t? new ArrayList<>(previousHistory)\n-\t\t\t\t\t\t\t: new ArrayList<>();\n-\t\t\tcomponents.add(metadata);\n-\t\t\tMessageHistory history = new MessageHistory(components);\n-\n-\t\t\tif (message instanceof MutableMessage) {\n-\t\t\t\tmessage.getHeaders().put(HEADER_NAME, history);\n+\t\t\tMessageHistory messageHistory = message.getHeaders().get(HEADER_NAME, MessageHistory.class);\n+\t\t\tif (messageHistory != null) {\n+\t\t\t\tmessageHistory.components.add(metadata);\n \t\t\t}\n-\t\t\telse if (message instanceof ErrorMessage) {\n-\t\t\t\tErrorMessage errorMessage = (ErrorMessage) message;\n-\t\t\t\tIntegrationMessageHeaderAccessor headerAccessor = new IntegrationMessageHeaderAccessor(message);\n-\t\t\t\theaderAccessor.setHeader(HEADER_NAME, history);\n-\t\t\t\tThrowable payload = errorMessage.getPayload();\n-\t\t\t\tMessage<?> originalMessage = errorMessage.getOriginalMessage();\n-\t\t\t\tif (originalMessage != null) {\n-\t\t\t\t\terrorMessage = new ErrorMessage(payload, headerAccessor.toMessageHeaders(), originalMessage);\n+\t\t\telse {\n+\t\t\t\tList<Properties> components = new ArrayList<>();\n+\t\t\t\tcomponents.add(metadata);\n+\t\t\t\tmessageHistory = new MessageHistory(components);\n+\n+\t\t\t\tif (message instanceof MutableMessage) {\n+\t\t\t\t\tmessage.getHeaders().put(HEADER_NAME, messageHistory);\n \t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\terrorMessage = new ErrorMessage(payload, headerAccessor.toMessageHeaders());\n+\t\t\t\telse if (message instanceof ErrorMessage errorMessage) {\n+\t\t\t\t\tIntegrationMessageHeaderAccessor headerAccessor = new IntegrationMessageHeaderAccessor(message);\n+\t\t\t\t\theaderAccessor.setHeader(HEADER_NAME, messageHistory);\n+\t\t\t\t\tThrowable payload = errorMessage.getPayload();\n+\t\t\t\t\tMessage<?> originalMessage = errorMessage.getOriginalMessage();\n+\t\t\t\t\tif (originalMessage != null) {\n+\t\t\t\t\t\terrorMessage = new ErrorMessage(payload, headerAccessor.toMessageHeaders(), originalMessage);\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\terrorMessage = new ErrorMessage(payload, headerAccessor.toMessageHeaders());\n+\t\t\t\t\t}\n+\t\t\t\t\tmessage = (Message<T>) errorMessage;\n \t\t\t\t}\n-\t\t\t\tmessage = (Message<T>) errorMessage;\n-\t\t\t}\n-\t\t\telse if (message instanceof AdviceMessage) {\n-\t\t\t\tIntegrationMessageHeaderAccessor headerAccessor = new IntegrationMessageHeaderAccessor(message);\n-\t\t\t\theaderAccessor.setHeader(HEADER_NAME, history);\n-\t\t\t\tmessage = new AdviceMessage<T>(message.getPayload(), headerAccessor.toMessageHeaders(),\n-\t\t\t\t\t\t((AdviceMessage<?>) message).getInputMessage());\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif (!(message instanceof GenericMessage) &&\n-\t\t\t\t\t\t(messageBuilderFactory instanceof DefaultMessageBuilderFactory ||\n-\t\t\t\t\t\t\t\tmessageBuilderFactory instanceof MutableMessageBuilderFactory)\n-\t\t\t\t\t\t&& LOGGER.isWarnEnabled()) {\n-\n-\t\t\t\t\tLOGGER.warn(\"MessageHistory rebuilds the message and produces the result of the [\" +\n-\t\t\t\t\t\t\tmessageBuilderFactory + \"], not an instance of the provided type [\" +\n-\t\t\t\t\t\t\tmessage.getClass() + \"]. Consider to supply a custom MessageBuilderFactory \" +\n-\t\t\t\t\t\t\t\"to retain custom messages during MessageHistory tracking.\");\n+\t\t\t\telse if (message instanceof AdviceMessage<?> adviceMessage) {\n+\t\t\t\t\tIntegrationMessageHeaderAccessor headerAccessor = new IntegrationMessageHeaderAccessor(message);\n+\t\t\t\t\theaderAccessor.setHeader(HEADER_NAME, messageHistory);\n+\t\t\t\t\tmessage = new AdviceMessage<>(message.getPayload(), headerAccessor.toMessageHeaders(),\n+\t\t\t\t\t\t\tadviceMessage.getInputMessage());\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tif (!(message instanceof GenericMessage) &&\n+\t\t\t\t\t\t\t(messageBuilderFactory instanceof DefaultMessageBuilderFactory ||\n+\t\t\t\t\t\t\t\t\tmessageBuilderFactory instanceof MutableMessageBuilderFactory)\n+\t\t\t\t\t\t\t&& LOGGER.isWarnEnabled()) {\n+\n+\t\t\t\t\t\tLOGGER.warn(\"MessageHistory rebuilds the message and produces the result of the [\" +\n+\t\t\t\t\t\t\t\tmessageBuilderFactory + \"], not an instance of the provided type [\" +\n+\t\t\t\t\t\t\t\tmessage.getClass() + \"]. Consider to supply a custom MessageBuilderFactory \" +\n+\t\t\t\t\t\t\t\t\"to retain custom messages during MessageHistory tracking.\");\n+\t\t\t\t\t}\n+\t\t\t\t\tmessage = messageBuilderFactory.fromMessage(message)\n+\t\t\t\t\t\t\t.setHeader(HEADER_NAME, messageHistory)\n+\t\t\t\t\t\t\t.build();\n \t\t\t\t}\n-\t\t\t\tmessage = messageBuilderFactory.fromMessage(message)\n-\t\t\t\t\t\t.setHeader(HEADER_NAME, history)\n-\t\t\t\t\t\t.build();\n \t\t\t}\n \t\t}\n \t\treturn message;\n@@ -216,15 +219,19 @@ public int lastIndexOf(Object o) {\n \t\treturn this.components.lastIndexOf(o);\n \t}\n \n+\t@Override\n+\tpublic Object clone() {\n+\t\treturn new MessageHistory(new ArrayList<>(this.components));\n+\t}\n+\n \t@Override\n \tpublic boolean equals(Object o) {\n \t\tif (this == o) {\n \t\t\treturn true;\n \t\t}\n-\t\tif (!(o instanceof MessageHistory)) {\n+\t\tif (!(o instanceof MessageHistory that)) {\n \t\t\treturn false;\n \t\t}\n-\t\tMessageHistory that = (MessageHistory) o;\n \t\treturn this.components.equals(that.components);\n \t}\n \n@@ -318,6 +325,7 @@ private static Properties extractMetadata(NamedComponent component) {\n \t */\n \tpublic static class Entry extends Properties {\n \n+\t\t@Serial\n \t\tprivate static final long serialVersionUID = -8225834391885601079L;\n \n \t\tpublic String getName() {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java b/spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java\nindex a174708c957..6f044c94464 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2023 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -27,6 +27,8 @@\n import org.springframework.integration.IntegrationPatternType;\n import org.springframework.integration.core.MessagingTemplate;\n import org.springframework.integration.handler.AbstractMessageHandler;\n+import org.springframework.integration.history.MessageHistory;\n+import org.springframework.integration.support.AbstractIntegrationMessageBuilder;\n import org.springframework.integration.support.management.IntegrationManagedResource;\n import org.springframework.jmx.export.annotation.ManagedResource;\n import org.springframework.messaging.Message;\n@@ -193,19 +195,27 @@ protected void handleMessageInternal(Message<?> message) {\n \t\tif (results != null) {\n \t\t\tint sequenceSize = results.size();\n \t\t\tint sequenceNumber = 1;\n+\t\t\tMessage<?> messageToSend = message;\n+\t\t\tUUID correlationKey = message.getHeaders().getId();\n+\t\t\tboolean hasMessageHistory = message.getHeaders().containsKey(MessageHistory.HEADER_NAME) && sequenceSize > 1;\n \t\t\tfor (MessageChannel channel : results) {\n-\t\t\t\tfinal Message<?> messageToSend;\n-\t\t\t\tif (!this.applySequence) {\n-\t\t\t\t\tmessageToSend = message;\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tUUID id = message.getHeaders().getId();\n-\t\t\t\t\tmessageToSend = getMessageBuilderFactory()\n-\t\t\t\t\t\t\t.fromMessage(message)\n-\t\t\t\t\t\t\t.pushSequenceDetails(id == null ? generateId() : id,\n-\t\t\t\t\t\t\t\t\tsequenceNumber++, sequenceSize)\n-\t\t\t\t\t\t\t.build();\n+\t\t\t\tif (this.applySequence || hasMessageHistory) {\n+\t\t\t\t\tAbstractIntegrationMessageBuilder<?> builder =\n+\t\t\t\t\t\t\tgetMessageBuilderFactory()\n+\t\t\t\t\t\t\t\t\t.fromMessage(message);\n+\n+\t\t\t\t\tif (this.applySequence) {\n+\t\t\t\t\t\tbuilder.pushSequenceDetails(correlationKey == null ? generateId() : correlationKey,\n+\t\t\t\t\t\t\t\tsequenceNumber++, sequenceSize);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (hasMessageHistory) {\n+\t\t\t\t\t\tbuilder.cloneMessageHistoryIfAny();\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tmessageToSend = builder.build();\n \t\t\t\t}\n+\n \t\t\t\tif (channel != null) {\n \t\t\t\t\tsent |= doSend(channel, messageToSend);\n \t\t\t\t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/splitter/AbstractMessageSplitter.java b/spring-integration-core/src/main/java/org/springframework/integration/splitter/AbstractMessageSplitter.java\nindex 92f1a616206..b6717c293bd 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/splitter/AbstractMessageSplitter.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/splitter/AbstractMessageSplitter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2023 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -35,6 +35,7 @@\n import org.springframework.integration.channel.ReactiveStreamsSubscribableChannel;\n import org.springframework.integration.handler.AbstractReplyProducingMessageHandler;\n import org.springframework.integration.handler.DiscardingMessageHandler;\n+import org.springframework.integration.history.MessageHistory;\n import org.springframework.integration.support.AbstractIntegrationMessageBuilder;\n import org.springframework.integration.support.json.JacksonPresent;\n import org.springframework.integration.util.FunctionIterator;\n@@ -276,10 +277,14 @@ private AbstractIntegrationMessageBuilder<?> createBuilder(Object item, Map<Stri\n \t\t\tObject correlationId, int sequenceNumber, int sequenceSize) {\n \n \t\tAbstractIntegrationMessageBuilder<?> builder = messageBuilderForReply(item);\n-\t\tbuilder.copyHeadersIfAbsent(headers);\n+\t\tbuilder.setHeader(MessageHistory.HEADER_NAME, headers.get(MessageHistory.HEADER_NAME))\n+\t\t\t\t.copyHeadersIfAbsent(headers)\n+\t\t\t\t.cloneMessageHistoryIfAny();\n+\n \t\tif (this.applySequence) {\n \t\t\tbuilder.pushSequenceDetails(correlationId, sequenceNumber, sequenceSize);\n \t\t}\n+\n \t\treturn builder;\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/support/AbstractIntegrationMessageBuilder.java b/spring-integration-core/src/main/java/org/springframework/integration/support/AbstractIntegrationMessageBuilder.java\nindex d16f7dc8d28..393cfb1822c 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/support/AbstractIntegrationMessageBuilder.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/support/AbstractIntegrationMessageBuilder.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2021 the original author or authors.\n+ * Copyright 2014-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -25,6 +25,7 @@\n import java.util.Map;\n \n import org.springframework.integration.IntegrationMessageHeaderAccessor;\n+import org.springframework.integration.history.MessageHistory;\n import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageChannel;\n@@ -165,6 +166,22 @@ public AbstractIntegrationMessageBuilder<T> filterAndCopyHeadersIfAbsent(Map<Str\n \t\treturn copyHeadersIfAbsent(headers);\n \t}\n \n+\t/**\n+\t * Make a copy of {@link MessageHistory} header (if present) for a new message to build.\n+\t * @return the current {@link AbstractIntegrationMessageBuilder}.\n+\t * @since 6.3\n+\t */\n+\tpublic AbstractIntegrationMessageBuilder<T> cloneMessageHistoryIfAny() {\n+\t\tMessageHistory messageHistory = getHeader(MessageHistory.HEADER_NAME, MessageHistory.class);\n+\n+\t\tif (messageHistory != null) {\n+\t\t\treturn removeHeader(MessageHistory.HEADER_NAME)\n+\t\t\t\t\t.setHeader(MessageHistory.HEADER_NAME, messageHistory.clone());\n+\t\t}\n+\n+\t\treturn this;\n+\t}\n+\n \t@Nullable\n \tprotected abstract List<List<Object>> getSequenceDetails();\n \n\ndiff --git a/src/reference/antora/modules/ROOT/pages/message-history.adoc b/src/reference/antora/modules/ROOT/pages/message-history.adoc\nindex da6a209e3dd..2aea2f51743 100644\n--- a/src/reference/antora/modules/ROOT/pages/message-history.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/message-history.adoc\n@@ -129,7 +129,9 @@ The MBean's object name is `<domain>:name=messageHistoryConfigurer,type=MessageH\n IMPORTANT: Only one `@EnableMessageHistory` (or `<message-history/>`) must be declared in the application context as single source for components tracking configuration.\n Do not use a generic bean definition for the `MessageHistoryConfigurer`.\n \n-NOTE: By definition, the message history header is immutable (you cannot re-write history).\n-Therefore, when writing message history values, the components either create new messages (when the component is an origin) or they copy the history from a request message, modifying it and setting the new list on a reply message.\n-In either case, the values can be appended even if the message itself is crossing thread boundaries.\n-That means that the history values can greatly simplify debugging in an asynchronous message flow.\n+NOTE: Prior to version 6.3, the message history header was immutable (you cannot re-write history): every single track created not only new instance of the `MessageHistory`, but a fully new message copy.\n+Now it works in append-only mode: the first track creates a new message with a new `MessageHistory` container.\n+All the rest `MessageHistory.write()` calls add new entries to existing header - and no new message created.\n+This significantly improves the application performance.\n+All the components in the framework, where same message can be sent to several consumers (`PublishSubscribeChannel`, `AbstractMessageRouter`, `WireTap` etc.), or splitter produces several outputs based on the input message, are now cloning an existing `MessageHistory` header into those new messages.\n+For any other multi-producing use-cases, outside the framework scope, the `AbstractIntegrationMessageBuilder.cloneMessageHistoryIfAny()` API is recommended to ensure that parallel downstream sub-flows contribute their own message history traces.\n\\ No newline at end of file\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/whats-new.adoc b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\nindex 11ff43c9d2d..73400235dd9 100644\n--- a/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n@@ -19,6 +19,10 @@ In general the project has been moved to the latest dependency versions.\n [[x6.3-general]]\n === General Changes\n \n+The `MessageHistory` header is now mutable, append-only container.\n+And all the subsequent tracks don't create new message - only their entry is added to existing message history header.\n+See xref:message-history.adoc[Message History Chapter] for more information.\n+\n [[x6.3-security-changes]]\n === Security Support Changes\n \n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/MessagingAnnotationsWithBeanAnnotationTests.java b/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/MessagingAnnotationsWithBeanAnnotationTests.java\nindex 290d1f96bbc..71ad8049ad4 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/MessagingAnnotationsWithBeanAnnotationTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/MessagingAnnotationsWithBeanAnnotationTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2022 the original author or authors.\n+ * Copyright 2014-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -186,10 +186,8 @@ public void testMessagingAnnotationsFlow() throws InterruptedException {\n \t\t\tassertThat(messageHistory).isNotNull();\n \t\t\tString messageHistoryString = messageHistory.toString();\n \t\t\tassertThat(messageHistoryString)\n-\t\t\t\t\t.contains(\"routerChannel\", \"filterChannel\", \"aggregatorChannel\", \"serviceChannel\")\n-\t\t\t\t\t.doesNotContain(\"discardChannel\")\n-\t\t\t\t\t// history header is not overridden in splitter for individual message from message group emitted before\n-\t\t\t\t\t.doesNotContain(\"splitterChannel\");\n+\t\t\t\t\t.contains(\"routerChannel\", \"filterChannel\", \"aggregatorChannel\", \"splitterChannel\", \"serviceChannel\")\n+\t\t\t\t\t.doesNotContain(\"discardChannel\");\n \t\t}\n \n \t\tassertThat(this.skippedServiceActivator).isNull();\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/core/MessageHistoryTests.java b/spring-integration-core/src/test/java/org/springframework/integration/core/MessageHistoryTests.java\nindex 392029e7830..f5de05e838d 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/core/MessageHistoryTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/core/MessageHistoryTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -96,7 +96,7 @@ public void testCorrectErrorMessageAfterWrite() {\n \t\tMessage<Throwable> result2 = MessageHistory.write(result1, new TestComponent(2));\n \t\tassertThat(result2).isInstanceOf(ErrorMessage.class);\n \t\tassertThat(result2).isNotSameAs(original);\n-\t\tassertThat(result2).isNotSameAs(result1);\n+\t\tassertThat(result2).isSameAs(result1);\n \t\tassertThat(result2.getPayload()).isSameAs(original.getPayload());\n \t\tassertThat(result1).extracting(\"originalMessage\").isSameAs(originalMessage);\n \t\tMessageHistory history2 = MessageHistory.read(result2);\n@@ -122,20 +122,14 @@ public void testCorrectAdviceMessageAfterWrite() {\n \t\tassertThat(result2).isNotSameAs(original);\n \t\tassertThat(result2.getPayload()).isSameAs(original.getPayload());\n \t\tassertThat(((AdviceMessage<?>) result2).getInputMessage()).isSameAs(original.getInputMessage());\n-\t\tassertThat(result2).isNotSameAs(result1);\n+\t\tassertThat(result2).isSameAs(result1);\n \t\tMessageHistory history2 = MessageHistory.read(result2);\n \t\tassertThat(history2).isNotNull();\n \t\tassertThat(history2.toString()).isEqualTo(\"testComponent-1,testComponent-2\");\n \t}\n \n \n-\tprivate static class TestComponent implements NamedComponent {\n-\n-\t\tprivate final int id;\n-\n-\t\tTestComponent(int id) {\n-\t\t\tthis.id = id;\n-\t\t}\n+\tprivate record TestComponent(int id) implements NamedComponent {\n \n \t\t@Override\n \t\tpublic String getComponentName() {\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/dispatcher/BroadcastingDispatcherTests.java b/spring-integration-core/src/test/java/org/springframework/integration/dispatcher/BroadcastingDispatcherTests.java\nindex 38fd8bec788..26406ed4c5b 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/dispatcher/BroadcastingDispatcherTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/dispatcher/BroadcastingDispatcherTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2024 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,8 +21,8 @@\n import java.util.List;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-import org.junit.Before;\n-import org.junit.Test;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n import org.mockito.Mockito;\n \n import org.springframework.core.task.TaskExecutor;\n@@ -35,10 +35,12 @@\n import org.springframework.messaging.support.GenericMessage;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.fail;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.BDDMockito.given;\n import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n \n /**\n@@ -52,26 +54,27 @@ public class BroadcastingDispatcherTests {\n \n \tprivate BroadcastingDispatcher dispatcher;\n \n-\tprivate final TaskExecutor taskExecutorMock = Mockito.mock(TaskExecutor.class);\n+\tprivate final TaskExecutor taskExecutorMock = Mockito.mock();\n \n-\tprivate final Message<?> messageMock = Mockito.mock(Message.class);\n+\tprivate final Message<?> messageMock = Mockito.mock();\n \n-\tprivate final MessageHandler targetMock1 = Mockito.mock(MessageHandler.class);\n+\tprivate final MessageHandler targetMock1 = Mockito.mock();\n \n-\tprivate final MessageHandler targetMock2 = Mockito.mock(MessageHandler.class);\n+\tprivate final MessageHandler targetMock2 = Mockito.mock();\n \n-\tprivate final MessageHandler targetMock3 = Mockito.mock(MessageHandler.class);\n+\tprivate final MessageHandler targetMock3 = Mockito.mock();\n \n \n-\t@Before\n+\t@BeforeEach\n \tpublic void init() {\n \t\tMockito.reset(taskExecutorMock, messageMock, taskExecutorMock, targetMock1, targetMock2, targetMock3);\n+\t\tgiven(messageMock.getHeaders()).willReturn(mock());\n \t\tdefaultTaskExecutorMock();\n \t}\n \n \n \t@Test\n-\tpublic void singleTargetWithoutTaskExecutor() throws Exception {\n+\tpublic void singleTargetWithoutTaskExecutor() {\n \t\tdispatcher = new BroadcastingDispatcher();\n \t\tdispatcher.addHandler(targetMock1);\n \t\tdispatcher.dispatch(messageMock);\n@@ -79,7 +82,7 @@ public void singleTargetWithoutTaskExecutor() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void singleTargetWithTaskExecutor() throws Exception {\n+\tpublic void singleTargetWithTaskExecutor() {\n \t\tdispatcher = new BroadcastingDispatcher(taskExecutorMock);\n \t\tdispatcher.addHandler(targetMock1);\n \t\tdispatcher.dispatch(messageMock);\n@@ -202,12 +205,12 @@ public void removeConsumerBetweenSends() {\n \t@Test\n \tpublic void applySequenceDisabledByDefault() {\n \t\tBroadcastingDispatcher dispatcher = new BroadcastingDispatcher();\n-\t\tfinal List<Message<?>> messages = Collections.synchronizedList(new ArrayList<Message<?>>());\n+\t\tfinal List<Message<?>> messages = Collections.synchronizedList(new ArrayList<>());\n \t\tMessageHandler target1 = new MessageStoringTestEndpoint(messages);\n \t\tMessageHandler target2 = new MessageStoringTestEndpoint(messages);\n \t\tdispatcher.addHandler(target1);\n \t\tdispatcher.addHandler(target2);\n-\t\tdispatcher.dispatch(new GenericMessage<String>(\"test\"));\n+\t\tdispatcher.dispatch(new GenericMessage<>(\"test\"));\n \t\tassertThat(messages.size()).isEqualTo(2);\n \t\tassertThat(new IntegrationMessageHeaderAccessor(messages.get(0)).getSequenceNumber()).isEqualTo(0);\n \t\tassertThat(new IntegrationMessageHeaderAccessor(messages.get(0)).getSequenceSize()).isEqualTo(0);\n@@ -219,14 +222,14 @@ public void applySequenceDisabledByDefault() {\n \tpublic void applySequenceEnabled() {\n \t\tBroadcastingDispatcher dispatcher = new BroadcastingDispatcher();\n \t\tdispatcher.setApplySequence(true);\n-\t\tfinal List<Message<?>> messages = Collections.synchronizedList(new ArrayList<Message<?>>());\n+\t\tfinal List<Message<?>> messages = Collections.synchronizedList(new ArrayList<>());\n \t\tMessageHandler target1 = new MessageStoringTestEndpoint(messages);\n \t\tMessageHandler target2 = new MessageStoringTestEndpoint(messages);\n \t\tMessageHandler target3 = new MessageStoringTestEndpoint(messages);\n \t\tdispatcher.addHandler(target1);\n \t\tdispatcher.addHandler(target2);\n \t\tdispatcher.addHandler(target3);\n-\t\tMessage<?> inputMessage = new GenericMessage<String>(\"test\");\n+\t\tMessage<?> inputMessage = new GenericMessage<>(\"test\");\n \t\tObject originalId = inputMessage.getHeaders().getId();\n \t\tdispatcher.dispatch(inputMessage);\n \t\tassertThat(messages.size()).isEqualTo(3);\n@@ -251,13 +254,11 @@ public void testExceptionEnhancement() {\n \t\tdispatcher.addHandler(targetMock1);\n \t\tdoThrow(new MessagingException(\"Mock Exception\"))\n \t\t\t\t.when(targetMock1).handleMessage(eq(messageMock));\n-\t\ttry {\n-\t\t\tdispatcher.dispatch(messageMock);\n-\t\t\tfail(\"Expected Exception\");\n-\t\t}\n-\t\tcatch (MessagingException e) {\n-\t\t\tassertThat(e.getFailedMessage()).isEqualTo(messageMock);\n-\t\t}\n+\n+\t\tassertThatExceptionOfType(MessagingException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(messageMock))\n+\t\t\t\t.extracting(MessagingException::getFailedMessage)\n+\t\t\t\t.isEqualTo(messageMock);\n \t}\n \n \t/**\n@@ -272,13 +273,11 @@ public void testNoExceptionEnhancement() {\n \t\tMessage<String> dontReplaceThisMessage = MessageBuilder.withPayload(\"x\").build();\n \t\tdoThrow(new MessagingException(dontReplaceThisMessage, \"Mock Exception\"))\n \t\t\t\t.when(targetMock1).handleMessage(eq(messageMock));\n-\t\ttry {\n-\t\t\tdispatcher.dispatch(messageMock);\n-\t\t\tfail(\"Expected Exception\");\n-\t\t}\n-\t\tcatch (MessagingException e) {\n-\t\t\tassertThat(e.getFailedMessage()).isEqualTo(dontReplaceThisMessage);\n-\t\t}\n+\n+\t\tassertThatExceptionOfType(MessagingException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(messageMock))\n+\t\t\t\t.extracting(MessagingException::getFailedMessage)\n+\t\t\t\t.isEqualTo(dontReplaceThisMessage);\n \t}\n \n \t/**\n@@ -306,13 +305,10 @@ public void testNoHandlerWithExecutor() {\n \t@Test\n \tpublic void testNoHandlerWithRequiredSubscriber() {\n \t\tdispatcher = new BroadcastingDispatcher(true);\n-\t\ttry {\n-\t\t\tdispatcher.dispatch(messageMock);\n-\t\t\tfail(\"Expected Exception\");\n-\t\t}\n-\t\tcatch (MessageDispatchingException exception) {\n-\t\t\tassertThat(exception.getFailedMessage()).isEqualTo(messageMock);\n-\t\t}\n+\t\tassertThatExceptionOfType(MessageDispatchingException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(messageMock))\n+\t\t\t\t.extracting(MessagingException::getFailedMessage)\n+\t\t\t\t.isEqualTo(messageMock);\n \t}\n \n \t/**\n@@ -322,13 +318,10 @@ public void testNoHandlerWithRequiredSubscriber() {\n \t@Test\n \tpublic void testNoHandlerWithExecutorWithRequiredSubscriber() {\n \t\tdispatcher = new BroadcastingDispatcher(taskExecutorMock, true);\n-\t\ttry {\n-\t\t\tdispatcher.dispatch(messageMock);\n-\t\t\tfail(\"Expected Exception\");\n-\t\t}\n-\t\tcatch (MessageDispatchingException exception) {\n-\t\t\tassertThat(exception.getFailedMessage()).isEqualTo(messageMock);\n-\t\t}\n+\t\tassertThatExceptionOfType(MessageDispatchingException.class)\n+\t\t\t\t.isThrownBy(() -> dispatcher.dispatch(messageMock))\n+\t\t\t\t.extracting(MessagingException::getFailedMessage)\n+\t\t\t\t.isEqualTo(messageMock);\n \t}\n \n \tprivate void defaultTaskExecutorMock() {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8781",
    "pr_id": 8781,
    "issue_id": 8779,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "ConfigurableMongoDbMessageStore iterator doesn't handle id types other than String\n**In what version(s) of Spring Integration are you seeing this issue?**\r\n6.1.4\r\n\r\n**Describe the bug**\r\nSo here (in ConfigurableMongoDbMessageStore) the resultClass is hardcoded to String but it could be for example UUID.\r\n```java\r\n@Override\r\npublic Iterator<MessageGroup> iterator() {\r\n  Query query = Query.query(Criteria.where(MessageDocumentFields.GROUP_ID).exists(true));\r\n  Iterable<String> groupIds = getMongoTemplate().getCollection(collectionName)\r\n\t\t  .distinct(MessageDocumentFields.GROUP_ID, query.getQueryObject(), String.class);\r\n  \r\n  return StreamSupport.stream(groupIds.spliterator(), false)\r\n\t\t  .map(this::getMessageGroup)\r\n\t\t  .iterator();\r\n\r\n}\r\n``` \r\nThe stack trace when using the UUID as id below:\r\n```java\r\norg.bson.BsonInvalidOperationException: readString can only be called when CurrentBSONType is STRING, not when CurrentBSONType is BINARY.\r\n\tat org.bson.AbstractBsonReader.verifyBSONType(AbstractBsonReader.java:689)\r\n\tat org.bson.AbstractBsonReader.checkPreconditions(AbstractBsonReader.java:721)\r\n\tat org.bson.AbstractBsonReader.readString(AbstractBsonReader.java:456)\r\n\tat org.bson.codecs.StringCodec.decode(StringCodec.java:80)\r\n\tat org.bson.codecs.StringCodec.decode(StringCodec.java:31)\r\n\tat com.mongodb.internal.operation.CommandResultArrayCodec.decode(CommandResultArrayCodec.java:52)\r\n\tat com.mongodb.internal.operation.CommandResultDocumentCodec.readValue(CommandResultDocumentCodec.java:60)\r\n\tat org.bson.codecs.BsonDocumentCodec.decode(BsonDocumentCodec.java:87)\r\n\tat org.bson.codecs.BsonDocumentCodec.decode(BsonDocumentCodec.java:42)\r\n\tat com.mongodb.internal.connection.ReplyMessage.<init>(ReplyMessage.java:48)\r\n\tat com.mongodb.internal.connection.InternalStreamConnection.getCommandResult(InternalStreamConnection.java:560)\r\n\tat com.mongodb.internal.connection.InternalStreamConnection.receiveCommandMessageResponse(InternalStreamConnection.java:450)\r\n\tat com.mongodb.internal.connection.InternalStreamConnection.sendAndReceive(InternalStreamConnection.java:365)\r\n\tat com.mongodb.internal.connection.UsageTrackingInternalConnection.sendAndReceive(UsageTrackingInternalConnection.java:114)\r\n\tat com.mongodb.internal.connection.DefaultConnectionPool$PooledConnection.sendAndReceive(DefaultConnectionPool.java:643)\r\n\tat com.mongodb.internal.connection.CommandProtocolImpl.execute(CommandProtocolImpl.java:73)\r\n\tat com.mongodb.internal.connection.DefaultServer$DefaultServerProtocolExecutor.execute(DefaultServer.java:204)\r\n\tat com.mongodb.internal.connection.DefaultServerConnection.executeProtocol(DefaultServerConnection.java:122)\r\n\tat com.mongodb.internal.connection.DefaultServerConnection.command(DefaultServerConnection.java:87)\r\n\tat com.mongodb.internal.connection.DefaultServerConnection.command(DefaultServerConnection.java:76)\r\n\tat com.mongodb.internal.connection.DefaultServer$OperationCountTrackingConnection.command(DefaultServer.java:288)\r\n\tat com.mongodb.internal.operation.CommandOperationHelper.createReadCommandAndExecute(CommandOperationHelper.java:239)\r\n\tat com.mongodb.internal.operation.CommandOperationHelper.lambda$executeRetryableRead$4(CommandOperationHelper.java:220)\r\n\tat com.mongodb.internal.operation.OperationHelper.lambda$withSourceAndConnection$0(OperationHelper.java:358)\r\n\tat com.mongodb.internal.operation.OperationHelper.withSuppliedResource(OperationHelper.java:383)\r\n\tat com.mongodb.internal.operation.OperationHelper.lambda$withSourceAndConnection$1(OperationHelper.java:357)\r\n\tat com.mongodb.internal.operation.OperationHelper.withSuppliedResource(OperationHelper.java:383)\r\n\tat com.mongodb.internal.operation.OperationHelper.withSourceAndConnection(OperationHelper.java:356)\r\n\tat com.mongodb.internal.operation.CommandOperationHelper.lambda$executeRetryableRead$5(CommandOperationHelper.java:218)\r\n\tat com.mongodb.internal.async.function.RetryingSyncSupplier.get(RetryingSyncSupplier.java:67)\r\n\tat com.mongodb.internal.operation.CommandOperationHelper.executeRetryableRead(CommandOperationHelper.java:223)\r\n\tat com.mongodb.internal.operation.CommandOperationHelper.executeRetryableRead(CommandOperationHelper.java:204)\r\n\tat com.mongodb.internal.operation.DistinctOperation.execute(DistinctOperation.java:122)\r\n\tat com.mongodb.internal.operation.DistinctOperation.execute(DistinctOperation.java:54)\r\n\tat com.mongodb.client.internal.MongoClientDelegate$DelegateOperationExecutor.execute(MongoClientDelegate.java:185)\r\n\tat com.mongodb.client.internal.MongoIterableImpl.execute(MongoIterableImpl.java:130)\r\n\tat com.mongodb.client.internal.MongoIterableImpl.iterator(MongoIterableImpl.java:90)\r\n\tat com.mongodb.client.internal.MongoIterableImpl.iterator(MongoIterableImpl.java:37)\r\n\tat java.base/java.lang.Iterable.spliterator(Iterable.java:101)\r\n\tat org.springframework.integration.mongodb.store.ConfigurableMongoDbMessageStore.iterator(ConfigurableMongoDbMessageStore.java:245)\r\n\tat org.springframework.integration.store.AbstractMessageGroupStore.expireMessageGroups(AbstractMessageGroupStore.java:128)\r\n``` \r\n\r\n**To Reproduce**\r\nIn CorrelationStrategy -> Object getCorrelationKey(Message<?> message) return UUID.\r\n\r\n**Expected behavior**\r\nIt should be able to handle different types of IDs.\r\n\r\n",
    "issue_word_count": 548,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageStore.java",
      "spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/MongoDbMessageStore.java",
      "spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/AbstractMongoDbMessageGroupStoreTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/AbstractMongoDbMessageGroupStoreTests.java"
    ],
    "base_commit": "769367deeaa11883b5e72bb96de0ed529302e6ce",
    "head_commit": "ca9aef4167ef8e4b8f646870b9540e0bd4226a59",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8781",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8781",
    "dockerfile": "",
    "pr_merged_at": "2023-10-26T19:29:03.000Z",
    "patch": "diff --git a/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageStore.java b/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageStore.java\nindex df6ab0363cb..7999232f6cc 100644\n--- a/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageStore.java\n+++ b/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageStore.java\n@@ -240,8 +240,9 @@ public void completeGroup(Object groupId) {\n \t@Override\n \tpublic Iterator<MessageGroup> iterator() {\n \t\tQuery query = Query.query(Criteria.where(MessageDocumentFields.GROUP_ID).exists(true));\n-\t\tIterable<String> groupIds = getMongoTemplate().getCollection(collectionName)\n-\t\t\t\t.distinct(MessageDocumentFields.GROUP_ID, query.getQueryObject(), String.class);\n+\t\tIterable<Object> groupIds =\n+\t\t\t\tgetMongoTemplate()\n+\t\t\t\t\t\t.findDistinct(query, MessageDocumentFields.GROUP_ID, this.collectionName, Object.class);\n \n \t\treturn StreamSupport.stream(groupIds.spliterator(), false)\n \t\t\t\t.map(this::getMessageGroup)\n\ndiff --git a/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/MongoDbMessageStore.java b/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/MongoDbMessageStore.java\nindex 81e68d6620a..14cfd7d53bc 100644\n--- a/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/MongoDbMessageStore.java\n+++ b/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/MongoDbMessageStore.java\n@@ -368,8 +368,7 @@ public Iterator<MessageGroup> iterator() {\n \n \t\tQuery query = Query.query(Criteria.where(GROUP_ID_KEY).exists(true));\n \n-\t\tIterable<String> groupIds = this.template.getCollection(this.collectionName)\n-\t\t\t\t.distinct(GROUP_ID_KEY, query.getQueryObject(), String.class);\n+\t\tIterable<Object> groupIds = this.template.findDistinct(query, GROUP_ID_KEY, this.collectionName, Object.class);\n \n \t\tfor (Object groupId : groupIds) {\n \t\t\tmessageGroups.add(getMessageGroup(groupId));\n",
    "test_patch": "diff --git a/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/AbstractMongoDbMessageGroupStoreTests.java b/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/AbstractMongoDbMessageGroupStoreTests.java\nindex 0c94b46eb13..68045cc351c 100644\n--- a/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/AbstractMongoDbMessageGroupStoreTests.java\n+++ b/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/AbstractMongoDbMessageGroupStoreTests.java\n@@ -374,7 +374,7 @@ void testMessageGroupIterator() {\n \t\tMessage<?> message = new GenericMessage<>(\"1\");\n \t\tstore2.addMessagesToGroup(\"1\", message);\n \t\tstore1.addMessagesToGroup(\"2\", new GenericMessage<>(\"2\"));\n-\t\tstore2.addMessagesToGroup(\"3\", new GenericMessage<>(\"3\"));\n+\t\tstore2.addMessagesToGroup(UUID.randomUUID(), new GenericMessage<>(\"3\"));\n \n \t\tMessageGroupStore store3 = this.getMessageGroupStore();\n \t\tIterator<MessageGroup> iterator = store3.iterator();\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8777",
    "pr_id": 8777,
    "issue_id": 8770,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "PostgresSubscribableChannel initial message polling dies due to exception\nCurrently, on the first subscribe of a MessageHandler, `notifyUpdate()` is called to process messages already in the message store.\r\nThe problem with `notifyUpdate()` is that the try-catch block is outside the loop, so the loop will die on an exception, leaving further messages unprocessed.\r\nWhen it receives notifications for inserted messages, this is not a problem because those notifications will submit a new task to poll further messages.\r\n\r\nWe could move the try-catch inside the loop to prevent it from dying. (If we don't do this, we might as well remove the try-catch, as it's good for nothing) \r\nThis would be fine for **non-transactional** usage. Messages are all processed and removed, and eventually, the loop stops.\r\n\r\nThis solution is a problem for **transactional** usage: The loop will never terminate, and the same message will be read repeatedly. For incoming notifications, we'd start further tasks that will go looping and exhaust the thread pool.\r\nAs of today, with transactional usage and without any other measures, messages producing an exception will also effectively block the channel (but not exhaust the thread pool)\r\n\r\n[Here is a reproducing test case and the mentioned solution](https://github.com/joshiste/spring-integration/commit/08839725100c9aaf62c4ae4384b234876ff1c566). I'm not very lucky with that solution but currently have no better idea.",
    "issue_word_count": 227,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresSubscribableChannel.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java"
    ],
    "base_commit": "4b27a3c521486ed63f79ea578e52813b77118318",
    "head_commit": "97d12c61703866e3975fdc21c230f3b8e54039c3",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8777",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8777",
    "dockerfile": "",
    "pr_merged_at": "2023-10-25T17:26:24.000Z",
    "patch": "diff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresSubscribableChannel.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresSubscribableChannel.java\nindex 44aee3daf8e..d1d04360db7 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresSubscribableChannel.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresSubscribableChannel.java\n@@ -31,6 +31,8 @@\n import org.springframework.transaction.PlatformTransactionManager;\n import org.springframework.transaction.support.TransactionTemplate;\n import org.springframework.util.Assert;\n+import org.springframework.util.ErrorHandler;\n+import org.springframework.util.ReflectionUtils;\n \n /**\n  * An {@link AbstractSubscribableChannel} for receiving push notifications for\n@@ -53,6 +55,8 @@ public class PostgresSubscribableChannel extends AbstractSubscribableChannel\n \n \tprivate static final LogAccessor LOGGER = new LogAccessor(PostgresSubscribableChannel.class);\n \n+\tprivate static final Optional<?> FALLBACK_STUB = Optional.of(new Object());\n+\n \tprivate final JdbcChannelMessageStore jdbcChannelMessageStore;\n \n \tprivate final Object groupId;\n@@ -65,6 +69,8 @@ public class PostgresSubscribableChannel extends AbstractSubscribableChannel\n \n \tprivate RetryTemplate retryTemplate = RetryTemplate.builder().maxAttempts(1).build();\n \n+\tprivate ErrorHandler errorHandler = ReflectionUtils::rethrowRuntimeException;\n+\n \tprivate Executor executor;\n \n \tprivate volatile boolean hasHandlers;\n@@ -77,6 +83,7 @@ public class PostgresSubscribableChannel extends AbstractSubscribableChannel\n \t */\n \tpublic PostgresSubscribableChannel(JdbcChannelMessageStore jdbcChannelMessageStore,\n \t\t\tObject groupId, PostgresChannelMessageTableSubscriber messageTableSubscriber) {\n+\n \t\tAssert.notNull(jdbcChannelMessageStore, \"A jdbcChannelMessageStore must be provided.\");\n \t\tAssert.notNull(groupId, \"A groupId must be set.\");\n \t\tAssert.notNull(messageTableSubscriber, \"A messageTableSubscriber must be set.\");\n@@ -117,6 +124,17 @@ public void setRetryTemplate(RetryTemplate retryTemplate) {\n \t\tthis.retryTemplate = retryTemplate;\n \t}\n \n+\t/**\n+\t * Set a {@link ErrorHandler} for messages which cannot be dispatched by this channel.\n+\t * Used as a recovery callback after {@link RetryTemplate} execution throws an exception.\n+\t * @param errorHandler the {@link ErrorHandler} to use.\n+\t * @since 6.0.9\n+\t */\n+\tpublic void setErrorHandler(ErrorHandler errorHandler) {\n+\t\tAssert.notNull(errorHandler, \"'errorHandler' must not be null.\");\n+\t\tthis.errorHandler = errorHandler;\n+\t}\n+\n \t@Override\n \tprotected void onInit() {\n \t\tsuper.onInit();\n@@ -160,19 +178,29 @@ protected boolean doSend(Message<?> message, long timeout) {\n \t@Override\n \tpublic void notifyUpdate() {\n \t\tthis.executor.execute(() -> {\n+\t\t\tOptional<?> dispatchedMessage;\n+\t\t\tdo {\n+\t\t\t\tdispatchedMessage = pollAndDispatchMessage();\n+\t\t\t} while (dispatchedMessage.isPresent());\n+\t\t});\n+\t}\n+\n+\tprivate Optional<?> pollAndDispatchMessage() {\n+\t\ttry {\n+\t\t\treturn doPollAndDispatchMessage();\n+\t\t}\n+\t\tcatch (Exception ex) {\n \t\t\ttry {\n-\t\t\t\tOptional<Message<?>> dispatchedMessage;\n-\t\t\t\tdo {\n-\t\t\t\t\tdispatchedMessage = askForMessage();\n-\t\t\t\t} while (dispatchedMessage.isPresent());\n+\t\t\t\tthis.errorHandler.handleError(ex);\n \t\t\t}\n-\t\t\tcatch (Exception ex) {\n+\t\t\tcatch (Exception ex1) {\n \t\t\t\tLOGGER.error(ex, \"Exception during message dispatch\");\n \t\t\t}\n-\t\t});\n+\t\t\treturn FALLBACK_STUB;\n+\t\t}\n \t}\n \n-\tprivate Optional<Message<?>> askForMessage() {\n+\tprivate Optional<?> doPollAndDispatchMessage() {\n \t\tif (this.hasHandlers) {\n \t\t\tif (this.transactionTemplate != null) {\n \t\t\t\treturn this.retryTemplate.execute(context ->\n",
    "test_patch": "diff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java\nindex 09d0dad75c0..bf88968390d 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java\n@@ -22,6 +22,7 @@\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import javax.sql.DataSource;\n \n@@ -46,6 +47,7 @@\n import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n import org.springframework.jdbc.datasource.init.ScriptUtils;\n import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.MessagingException;\n import org.springframework.messaging.support.GenericMessage;\n import org.springframework.retry.support.RetryTemplate;\n import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;\n@@ -196,6 +198,34 @@ void testMessagesDispatchedInTransaction() throws InterruptedException {\n \t\tassertThat(messageStore.pollMessageFromGroup(groupId).getPayload()).isEqualTo(\"2\");\n \t}\n \n+\t@ParameterizedTest\n+\t@ValueSource(booleans = {true, false})\n+\tvoid errorHandlerIsCalled(boolean transactionsEnabled) throws InterruptedException {\n+\t\tif (transactionsEnabled) {\n+\t\t\tpostgresSubscribableChannel.setTransactionManager(transactionManager);\n+\t\t}\n+\n+\t\tAtomicReference<Throwable> exceptionReference = new AtomicReference<>();\n+\t\tCountDownLatch errorHandlerLatch = new CountDownLatch(1);\n+\t\tpostgresSubscribableChannel.setErrorHandler(ex -> {\n+\t\t\texceptionReference.set(ex);\n+\t\t\terrorHandlerLatch.countDown();\n+\t\t});\n+\n+\t\tpostgresChannelMessageTableSubscriber.start();\n+\n+\t\tpostgresSubscribableChannel.subscribe(message -> {\n+\t\t\tthrow new RuntimeException(\"An error has occurred\");\n+\t\t});\n+\n+\t\tmessageStore.addMessageToGroup(groupId, new GenericMessage<>(\"1\"));\n+\n+\t\tassertThat(errorHandlerLatch.await(10, TimeUnit.SECONDS)).isTrue();\n+\t\tassertThat(exceptionReference.get())\n+\t\t\t\t.isInstanceOf(MessagingException.class)\n+\t\t\t\t.hasStackTraceContaining(\"An error has occurred\");\n+\t}\n+\n \t@ParameterizedTest\n \t@ValueSource(booleans = {true, false})\n \tvoid testRetryOnErrorDuringDispatch(boolean transactionsEnabled) throws InterruptedException {\n@@ -253,8 +283,7 @@ DataSourceInitializer dataSourceInitializer(DataSource dataSource) {\n \t\t\tResourceDatabasePopulator databasePopulator =\n \t\t\t\t\tnew ResourceDatabasePopulator(new ByteArrayResource(INTEGRATION_DB_SCRIPTS.getBytes()));\n \t\t\tdatabasePopulator.setSeparator(ScriptUtils.EOF_STATEMENT_SEPARATOR);\n-\t\t\tdataSourceInitializer.setDatabasePopulator(\n-\t\t\t\t\tdatabasePopulator);\n+\t\t\tdataSourceInitializer.setDatabasePopulator(databasePopulator);\n \t\t\treturn dataSourceInitializer;\n \t\t}\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8764",
    "pr_id": 8764,
    "issue_id": 8734,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "With new JMS Observability integration, JmsDefaultListenerContainerSpec could support a builder setter for new ObservationRegistry attribute\nSpring Boot is adding Observability and Traceability to JMS on the new micrometer-tracing layer.\r\nSo as soon as this is available in 3.2.0, we will miss a way to pass it in the JmsDefaultListenerContainerSpec builder when creating it like:\r\n\r\n\r\n```\r\n Jms.container(jmsContainerFactory, topicDestination)\r\n         .pubSubDomain(isTopic)\r\n         .sessionAcknowledgeMode(Session.SESSION_TRANSACTED)\r\n         .sessionTransacted(true)\r\n          .cacheLevel(DefaultMessageListenerContainer.CACHE_AUTO)\r\n          .taskExecutor(Executors.newCachedThreadPool())\r\n          **.observarionRegistry(...)**\r\n          .getObject()\r\n\r\n```\r\n\r\nSee reference ticket: https://github.com/spring-projects/spring-framework/issues/30335#issuecomment-1719430775\r\n",
    "issue_word_count": 90,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "spring-integration-jms/src/main/java/org/springframework/integration/jms/dsl/JmsListenerContainerSpec.java",
      "spring-integration-jms/src/test/java/org/springframework/integration/jms/dsl/JmsTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-jms/src/test/java/org/springframework/integration/jms/dsl/JmsTests.java"
    ],
    "base_commit": "f819f4b0b7e7d787f7bb84ebfbea30f26b042b40",
    "head_commit": "6b94dbfc0fa8d82bbccf3e7016ca667abd551038",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8764",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8764",
    "dockerfile": "",
    "pr_merged_at": "2023-10-16T16:57:29.000Z",
    "patch": "diff --git a/spring-integration-jms/src/main/java/org/springframework/integration/jms/dsl/JmsListenerContainerSpec.java b/spring-integration-jms/src/main/java/org/springframework/integration/jms/dsl/JmsListenerContainerSpec.java\nindex d4bf5857bdb..e3c54682bea 100644\n--- a/spring-integration-jms/src/main/java/org/springframework/integration/jms/dsl/JmsListenerContainerSpec.java\n+++ b/spring-integration-jms/src/main/java/org/springframework/integration/jms/dsl/JmsListenerContainerSpec.java\n@@ -16,6 +16,7 @@\n \n package org.springframework.integration.jms.dsl;\n \n+import io.micrometer.observation.ObservationRegistry;\n import jakarta.jms.Destination;\n import jakarta.jms.ExceptionListener;\n \n@@ -158,4 +159,16 @@ public S clientId(String clientId) {\n \t\treturn _this();\n \t}\n \n+\t/**\n+\t * Configure an {@link ObservationRegistry} to use in the target listener container.\n+\t * @param observationRegistry the observationRegistry.\n+\t * @return the spec.\n+\t * @since 6.2\n+\t * @see AbstractMessageListenerContainer#setObservationRegistry(ObservationRegistry)\n+\t */\n+\tpublic S observationRegistry(ObservationRegistry observationRegistry) {\n+\t\tthis.target.setObservationRegistry(observationRegistry);\n+\t\treturn _this();\n+\t}\n+\n }\n",
    "test_patch": "diff --git a/spring-integration-jms/src/test/java/org/springframework/integration/jms/dsl/JmsTests.java b/spring-integration-jms/src/test/java/org/springframework/integration/jms/dsl/JmsTests.java\nindex 4924cdb2a98..19066acea23 100644\n--- a/spring-integration-jms/src/test/java/org/springframework/integration/jms/dsl/JmsTests.java\n+++ b/spring-integration-jms/src/test/java/org/springframework/integration/jms/dsl/JmsTests.java\n@@ -22,6 +22,7 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n+import io.micrometer.observation.ObservationRegistry;\n import io.micrometer.observation.tck.TestObservationRegistry;\n import io.micrometer.observation.tck.TestObservationRegistryAssert;\n import jakarta.jms.JMSException;\n@@ -56,6 +57,7 @@\n import org.springframework.integration.handler.AbstractReplyProducingMessageHandler;\n import org.springframework.integration.jms.ActiveMQMultiContextTests;\n import org.springframework.integration.jms.JmsDestinationPollingSource;\n+import org.springframework.integration.jms.JmsMessageDrivenEndpoint;\n import org.springframework.integration.jms.SubscribableJmsChannel;\n import org.springframework.integration.scheduling.PollerMetadata;\n import org.springframework.integration.support.MessageBuilder;\n@@ -129,6 +131,9 @@ public class JmsTests extends ActiveMQMultiContextTests {\n \t@Qualifier(\"jmsOutboundGateway.handler\")\n \tprivate MessageHandler jmsOutboundGatewayHandler;\n \n+\t@Autowired\n+\tJmsMessageDrivenEndpoint containerWithObservation;\n+\n \t@Autowired\n \tprivate AtomicBoolean jmsMessageDrivenChannelCalled;\n \n@@ -192,6 +197,9 @@ public void testJmsOutboundInboundFlow() {\n \t\t\t\t.extracting(Message::getPayload)\n \t\t\t\t.isEqualTo(\"HELLO THROUGH THE JMS\");\n \n+\t\tassertThat(TestUtils.getPropertyValue(this.containerWithObservation, \"listenerContainer.observationRegistry\"))\n+\t\t\t\t.isSameAs(this.observationRegistry);\n+\n \t\tthis.jmsOutboundInboundChannel.send(MessageBuilder.withPayload(\"hello THROUGH the JMS\")\n \t\t\t\t.setHeader(SimpMessageHeaderAccessor.DESTINATION_HEADER, \"jmsMessageDriven\")\n \t\t\t\t.build());\n@@ -406,13 +414,16 @@ public IntegrationFlow pubSubFlow(SubscribableJmsChannel jmsPublishSubscribeChan\n \t\t}\n \n \t\t@Bean\n-\t\tpublic IntegrationFlow jmsMessageDrivenFlow() {\n+\t\tpublic IntegrationFlow jmsMessageDrivenFlow(ObservationRegistry observationRegistry) {\n \t\t\treturn IntegrationFlow\n \t\t\t\t\t.from(Jms.messageDrivenChannelAdapter(amqFactory,\n \t\t\t\t\t\t\t\t\tDefaultMessageListenerContainer.class)\n \t\t\t\t\t\t\t.outputChannel(jmsMessageDrivenInputChannel())\n \t\t\t\t\t\t\t.destination(\"jmsMessageDriven\")\n-\t\t\t\t\t\t\t.configureListenerContainer(c -> c.clientId(\"foo\")))\n+\t\t\t\t\t\t\t.configureListenerContainer(c -> c\n+\t\t\t\t\t\t\t\t\t.clientId(\"foo\")\n+\t\t\t\t\t\t\t\t\t.observationRegistry(observationRegistry))\n+\t\t\t\t\t\t\t.id(\"containerWithObservation\"))\n \t\t\t\t\t.<String, String>transform(String::toLowerCase)\n \t\t\t\t\t.channel(jmsOutboundInboundReplyChannel())\n \t\t\t\t\t.get();\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8759",
    "pr_id": 8759,
    "issue_id": 8745,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "RemoteFileTemplate needlessly marks session dirty in case of no such file error\n**In what version(s) of Spring Integration are you seeing this issue?**\r\n\r\n6.1.3\r\n\r\n**Describe the bug**\r\n\r\nThe issue applies to all classes which extend `org.springframework.integration.file.remote.RemoteFileTemplate`.  The description below uses `SftpRemoteFileTemplate` from `spring-integration-sftp` as an example.\r\n\r\n`RemoteFileTemplate::execute` method marks session dirty in case of any exception.\r\nIt prevents session to be reused and makes `CachingSessionFactory` inefficient.\r\nAs a result, too many sessions are created and SFTP server may reject new connections.\r\nCertain exceptions, like `SftpConstants.SSH_FX_NO_SUCH_FILE `, should not cause session to be marked dirty.\r\n\r\n**To Reproduce**\r\n\r\n1. Configure `DefaultSftpSessionFactory` to point to some valid SFTP\r\n2. Wrap the factory with `CachingSessionFactory`\r\n3. Configure `SftpRemoteFileTemplate` to use created `CachingSessionFactory`\r\n4. Use `SftpRemoteFileTemplate::list` method with some path that does not exist on the server\r\n\r\n**Expected behavior**\r\n\r\n1. SftpRemoteFileTemplate::list throws exception (the current behaviour)\r\n2. Session is not marked dirty and can be reused by further calls (currently it is marked dirty and cannot be reused)\r\n\r\nProbably each class that extends `RemoteFileTemplate` should be able to define strategy for differentiating if an exception should mark session dirty.\r\n\r\n**Workaround**\r\nUse `SftpRemoteFileTemplate::exists` before each `SftpRemoteFileTemplate::list` (call `list` only when `exists` returns `true`)\r\n\r\n\r\n",
    "issue_word_count": 212,
    "test_files_count": 3,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "spring-integration-file/src/main/java/org/springframework/integration/file/remote/RemoteFileTemplate.java",
      "spring-integration-ftp/src/main/java/org/springframework/integration/ftp/session/FtpRemoteFileTemplate.java",
      "spring-integration-ftp/src/test/java/org/springframework/integration/ftp/session/FtpRemoteFileTemplateTests.java",
      "spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplate.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplateTests.java",
      "spring-integration-smb/src/main/java/org/springframework/integration/smb/session/SmbRemoteFileTemplate.java",
      "spring-integration-smb/src/test/java/org/springframework/integration/smb/session/SmbSessionTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-ftp/src/test/java/org/springframework/integration/ftp/session/FtpRemoteFileTemplateTests.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplateTests.java",
      "spring-integration-smb/src/test/java/org/springframework/integration/smb/session/SmbSessionTests.java"
    ],
    "base_commit": "098ba3e495bee491739712e8dea4d8f1ef6234e3",
    "head_commit": "bb7a8722f5767c333d6dbfd6dcb54c91952cd2cf",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8759",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8759",
    "dockerfile": "",
    "pr_merged_at": "2023-10-11T14:52:49.000Z",
    "patch": "diff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/remote/RemoteFileTemplate.java b/spring-integration-file/src/main/java/org/springframework/integration/file/remote/RemoteFileTemplate.java\nindex 00fc723ac01..ac70c06ab7a 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/remote/RemoteFileTemplate.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/remote/RemoteFileTemplate.java\n@@ -451,27 +451,42 @@ public <T> T execute(SessionCallback<F, T> callback) {\n \t\t\t}\n \t\t\treturn callback.doInSession(session);\n \t\t}\n-\t\tcatch (Exception e) {\n-\t\t\tif (session != null) {\n+\t\tcatch (Exception ex) {\n+\t\t\tif (session != null && shouldMarkSessionAsDirty(ex)) {\n \t\t\t\tsession.dirty();\n \t\t\t}\n-\t\t\tif (e instanceof MessagingException) { // NOSONAR\n-\t\t\t\tthrow (MessagingException) e;\n+\t\t\tif (ex instanceof MessagingException messagingException) { // NOSONAR\n+\t\t\t\tthrow messagingException;\n \t\t\t}\n-\t\t\tthrow new MessagingException(\"Failed to execute on session\", e);\n+\t\t\tthrow new MessagingException(\"Failed to execute on session\", ex);\n \t\t}\n \t\tfinally {\n \t\t\tif (!invokeScope && session != null) {\n \t\t\t\ttry {\n \t\t\t\t\tsession.close();\n \t\t\t\t}\n-\t\t\t\tcatch (Exception ignored) {\n-\t\t\t\t\tthis.logger.debug(\"failed to close Session\", ignored);\n+\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\tthis.logger.debug(\"failed to close Session\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n+\t/**\n+\t * Determine whether {@link Session#dirty()} should be called\n+\t * in the {@link #execute(SessionCallback)} when an exception is thrown from the callback.\n+\t * By default, this method returns {@code true}.\n+\t * Remote file protocol extensions can override this method to provide\n+\t * a specific strategy against the thrown exception, e.g. {@code file not found} error\n+\t * is not a signal that session is broken.\n+\t * @param ex the exception to check if {@link Session} must be marked as dirty.\n+\t * @return true if {@link Session#dirty()} should be called.\n+\t * @since 6.0.8\n+\t */\n+\tprotected boolean shouldMarkSessionAsDirty(Exception ex) {\n+\t\treturn true;\n+\t}\n+\n \t@Override\n \tpublic <T> T invoke(OperationsCallback<F, T> action) {\n \t\tSession<F> contextSession = this.contextSessions.get();\n@@ -503,8 +518,7 @@ public <T, C> T executeWithClient(ClientCallback<C, T> callback) {\n \tprivate StreamHolder payloadToInputStream(Message<?> message) throws MessageDeliveryException {\n \t\tObject payload = message.getPayload();\n \t\ttry {\n-\t\t\tif (payload instanceof File) {\n-\t\t\t\tFile inputFile = (File) payload;\n+\t\t\tif (payload instanceof File inputFile) {\n \t\t\t\tif (inputFile.exists()) {\n \t\t\t\t\treturn new StreamHolder(\n \t\t\t\t\t\t\tnew BufferedInputStream(new FileInputStream(inputFile)), inputFile.getAbsolutePath());\n@@ -526,8 +540,7 @@ else if (payload instanceof byte[] || payload instanceof String) {\n \t\t\telse if (payload instanceof InputStream) {\n \t\t\t\treturn new StreamHolder((InputStream) payload, \"InputStream payload\");\n \t\t\t}\n-\t\t\telse if (payload instanceof Resource) {\n-\t\t\t\tResource resource = (Resource) payload;\n+\t\t\telse if (payload instanceof Resource resource) {\n \t\t\t\tString filename = resource.getFilename();\n \t\t\t\treturn new StreamHolder(resource.getInputStream(), filename != null ? filename : \"Resource payload\");\n \t\t\t}\n@@ -619,16 +632,7 @@ else if (!directoryPath.endsWith(this.remoteFileSeparator)) {\n \t\t}\n \t}\n \n-\tprivate static final class StreamHolder {\n-\n-\t\tprivate final InputStream stream;\n-\n-\t\tprivate final String name;\n-\n-\t\tStreamHolder(InputStream stream, String name) {\n-\t\t\tthis.stream = stream;\n-\t\t\tthis.name = name;\n-\t\t}\n+\tprivate record StreamHolder(InputStream stream, String name) {\n \n \t}\n \n\ndiff --git a/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/session/FtpRemoteFileTemplate.java b/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/session/FtpRemoteFileTemplate.java\nindex 142ea47ad2f..2690d8f1ab3 100644\n--- a/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/session/FtpRemoteFileTemplate.java\n+++ b/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/session/FtpRemoteFileTemplate.java\n@@ -20,10 +20,12 @@\n \n import org.apache.commons.net.ftp.FTPClient;\n import org.apache.commons.net.ftp.FTPFile;\n+import org.apache.commons.net.ftp.FTPReply;\n \n import org.springframework.integration.file.remote.ClientCallback;\n import org.springframework.integration.file.remote.RemoteFileTemplate;\n import org.springframework.integration.file.remote.session.SessionFactory;\n+import org.springframework.lang.Nullable;\n import org.springframework.messaging.MessagingException;\n import org.springframework.util.Assert;\n import org.springframework.util.ObjectUtils;\n@@ -34,6 +36,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ *\n  * @since 4.1\n  *\n  */\n@@ -82,22 +85,11 @@ protected <T> T doExecuteWithClient(final ClientCallback<FTPClient, T> callback)\n \tpublic boolean exists(final String path) {\n \t\treturn doExecuteWithClient(client -> {\n \t\t\ttry {\n-\t\t\t\tswitch (FtpRemoteFileTemplate.this.existsMode) {\n-\n-\t\t\t\t\tcase STAT:\n-\t\t\t\t\t\treturn client.getStatus(path) != null;\n-\n-\t\t\t\t\tcase NLST:\n-\t\t\t\t\t\tString[] names = client.listNames(path);\n-\t\t\t\t\t\treturn !ObjectUtils.isEmpty(names);\n-\n-\t\t\t\t\tcase NLST_AND_DIRS:\n-\t\t\t\t\t\treturn FtpRemoteFileTemplate.super.exists(path);\n-\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new IllegalStateException(\"Unsupported 'existsMode': \" +\n-\t\t\t\t\t\t\t\tFtpRemoteFileTemplate.this.existsMode);\n-\t\t\t\t}\n+\t\t\t\treturn switch (FtpRemoteFileTemplate.this.existsMode) {\n+\t\t\t\t\tcase STAT -> client.getStatus(path) != null;\n+\t\t\t\t\tcase NLST -> !ObjectUtils.isEmpty(client.listNames(path));\n+\t\t\t\t\tcase NLST_AND_DIRS -> FtpRemoteFileTemplate.super.exists(path);\n+\t\t\t\t};\n \t\t\t}\n \t\t\tcatch (IOException e) {\n \t\t\t\tthrow new MessagingException(\"Failed to check the remote path for \" + path, e);\n@@ -105,6 +97,38 @@ public boolean exists(final String path) {\n \t\t});\n \t}\n \n+\t@Override\n+\tprotected boolean shouldMarkSessionAsDirty(Exception ex) {\n+\t\tIOException ftpException = findIoException(ex);\n+\t\tif (ftpException != null) {\n+\t\t\treturn isStatusDirty(ftpException.getMessage());\n+\t\t}\n+\t\telse {\n+\t\t\treturn super.shouldMarkSessionAsDirty(ex);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Check if {@link IOException#getMessage()} is treated as fatal.\n+\t * @param ftpErrorMessage the value from {@link IOException#getMessage()}.\n+\t * @return true if {@link IOException#getMessage()} is treated as fatal.\n+\t * @since 6.0.8\n+\t */\n+\tprotected boolean isStatusDirty(String ftpErrorMessage) {\n+\t\treturn !ftpErrorMessage.contains(\"\" + FTPReply.FILE_UNAVAILABLE)\n+\t\t\t\t&& !ftpErrorMessage.contains(\"\" + FTPReply.FILE_NAME_NOT_ALLOWED);\n+\t}\n+\n+\t@Nullable\n+\tprivate static IOException findIoException(Throwable ex) {\n+\t\tif (ex == null || ex instanceof IOException) {\n+\t\t\treturn (IOException) ex;\n+\t\t}\n+\t\telse {\n+\t\t\treturn findIoException(ex.getCause());\n+\t\t}\n+\t}\n+\n \t/**\n \t * The {@link #exists(String)} operation mode.\n \t * @since 4.1.9\n\ndiff --git a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplate.java b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplate.java\nindex 77a8405da01..c3fe937fc6c 100644\n--- a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplate.java\n+++ b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplate.java\n@@ -16,11 +16,16 @@\n \n package org.springframework.integration.sftp.session;\n \n+import java.util.List;\n+\n import org.apache.sshd.sftp.client.SftpClient;\n+import org.apache.sshd.sftp.common.SftpConstants;\n+import org.apache.sshd.sftp.common.SftpException;\n \n import org.springframework.integration.file.remote.ClientCallback;\n import org.springframework.integration.file.remote.RemoteFileTemplate;\n import org.springframework.integration.file.remote.session.SessionFactory;\n+import org.springframework.lang.Nullable;\n \n /**\n  * SFTP version of {@code RemoteFileTemplate} providing type-safe access to\n@@ -34,6 +39,21 @@\n  */\n public class SftpRemoteFileTemplate extends RemoteFileTemplate<SftpClient.DirEntry> {\n \n+\tprotected static final List<Integer> NOT_DIRTY_STATUSES = // NOSONAR\n+\t\t\tList.of(\n+\t\t\t\t\tSftpConstants.SSH_FX_NO_SUCH_FILE,\n+\t\t\t\t\tSftpConstants.SSH_FX_NO_SUCH_PATH,\n+\t\t\t\t\tSftpConstants.SSH_FX_INVALID_FILENAME,\n+\t\t\t\t\tSftpConstants.SSH_FX_INVALID_HANDLE,\n+\t\t\t\t\tSftpConstants.SSH_FX_FILE_ALREADY_EXISTS,\n+\t\t\t\t\tSftpConstants.SSH_FX_DIR_NOT_EMPTY,\n+\t\t\t\t\tSftpConstants.SSH_FX_NOT_A_DIRECTORY,\n+\t\t\t\t\tSftpConstants.SSH_FX_EOF,\n+\t\t\t\t\tSftpConstants.SSH_FX_CANNOT_DELETE,\n+\t\t\t\t\tSftpConstants.SSH_FX_FILE_IS_A_DIRECTORY,\n+\t\t\t\t\tSftpConstants.SSH_FX_FILE_CORRUPT\n+\t\t\t);\n+\n \tpublic SftpRemoteFileTemplate(SessionFactory<SftpClient.DirEntry> sessionFactory) {\n \t\tsuper(sessionFactory);\n \t}\n@@ -48,4 +68,35 @@ protected <T> T doExecuteWithClient(final ClientCallback<SftpClient, T> callback\n \t\treturn execute(session -> callback.doWithClient((SftpClient) session.getClientInstance()));\n \t}\n \n+\t@Override\n+\tprotected boolean shouldMarkSessionAsDirty(Exception ex) {\n+\t\tSftpException sftpException = findSftpException(ex);\n+\t\tif (sftpException != null) {\n+\t\t\treturn isStatusDirty(sftpException.getStatus());\n+\t\t}\n+\t\telse {\n+\t\t\treturn super.shouldMarkSessionAsDirty(ex);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Check if {@link SftpException#getStatus()} is treated as fatal.\n+\t * @param status the value from {@link SftpException#getStatus()}.\n+\t * @return true if {@link SftpException#getStatus()} is treated as fatal.\n+\t * @since 6.0.8\n+\t */\n+\tprotected boolean isStatusDirty(int status) {\n+\t\treturn !NOT_DIRTY_STATUSES.contains(status);\n+\t}\n+\n+\t@Nullable\n+\tprivate static SftpException findSftpException(Throwable ex) {\n+\t\tif (ex == null || ex instanceof SftpException) {\n+\t\t\treturn (SftpException) ex;\n+\t\t}\n+\t\telse {\n+\t\t\treturn findSftpException(ex.getCause());\n+\t\t}\n+\t}\n+\n }\n\ndiff --git a/spring-integration-smb/src/main/java/org/springframework/integration/smb/session/SmbRemoteFileTemplate.java b/spring-integration-smb/src/main/java/org/springframework/integration/smb/session/SmbRemoteFileTemplate.java\nindex 21de1767879..8a1c34211ba 100644\n--- a/spring-integration-smb/src/main/java/org/springframework/integration/smb/session/SmbRemoteFileTemplate.java\n+++ b/spring-integration-smb/src/main/java/org/springframework/integration/smb/session/SmbRemoteFileTemplate.java\n@@ -16,10 +16,15 @@\n \n package org.springframework.integration.smb.session;\n \n+import java.util.List;\n+\n+import jcifs.smb.NtStatus;\n+import jcifs.smb.SmbException;\n import jcifs.smb.SmbFile;\n \n import org.springframework.integration.file.remote.RemoteFileTemplate;\n import org.springframework.integration.file.remote.session.SessionFactory;\n+import org.springframework.lang.Nullable;\n \n /**\n  * The SMB-specific {@link RemoteFileTemplate} implementation.\n@@ -30,12 +35,61 @@\n  */\n public class SmbRemoteFileTemplate extends RemoteFileTemplate<SmbFile> {\n \n+\tprotected static final List<Integer> NOT_DIRTY_STATUSES = // NOSONAR\n+\t\t\tList.of(\n+\t\t\t\t\tNtStatus.NT_STATUS_INVALID_HANDLE,\n+\t\t\t\t\tNtStatus.NT_STATUS_END_OF_FILE,\n+\t\t\t\t\tNtStatus.NT_STATUS_NO_SUCH_FILE,\n+\t\t\t\t\tNtStatus.NT_STATUS_DUPLICATE_NAME,\n+\t\t\t\t\tNtStatus.NT_STATUS_FILE_IS_A_DIRECTORY,\n+\t\t\t\t\tNtStatus.NT_STATUS_NOT_A_DIRECTORY,\n+\t\t\t\t\tNtStatus.NT_STATUS_NOT_FOUND,\n+\t\t\t\t\tNtStatus.NT_STATUS_OBJECT_NAME_COLLISION,\n+\t\t\t\t\tNtStatus.NT_STATUS_OBJECT_NAME_INVALID,\n+\t\t\t\t\tNtStatus.NT_STATUS_OBJECT_NAME_NOT_FOUND,\n+\t\t\t\t\tNtStatus.NT_STATUS_OBJECT_PATH_INVALID,\n+\t\t\t\t\tNtStatus.NT_STATUS_OBJECT_PATH_NOT_FOUND,\n+\t\t\t\t\tNtStatus.NT_STATUS_OBJECT_PATH_SYNTAX_BAD,\n+\t\t\t\t\tNtStatus.NT_STATUS_CANNOT_DELETE\n+\t\t\t);\n+\n \t/**\n \t * Construct a {@link SmbRemoteFileTemplate} with the supplied session factory.\n+\t *\n \t * @param sessionFactory the session factory.\n \t */\n \tpublic SmbRemoteFileTemplate(SessionFactory<SmbFile> sessionFactory) {\n \t\tsuper(sessionFactory);\n \t}\n \n+\t@Override\n+\tprotected boolean shouldMarkSessionAsDirty(Exception ex) {\n+\t\tSmbException smbException = findSmbException(ex);\n+\t\tif (smbException != null) {\n+\t\t\treturn isStatusDirty(smbException.getNtStatus());\n+\t\t}\n+\t\telse {\n+\t\t\treturn super.shouldMarkSessionAsDirty(ex);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Check if {@link SmbException#getNtStatus()} is treated as fatal.\n+\t * @param status the value from {@link SmbException#getNtStatus()}.\n+\t * @return true if {@link SmbException#getNtStatus()} is treated as fatal.\n+\t * @since 6.0.8\n+\t */\n+\tprotected boolean isStatusDirty(int status) {\n+\t\treturn !NOT_DIRTY_STATUSES.contains(status);\n+\t}\n+\n+\t@Nullable\n+\tprivate static SmbException findSmbException(Throwable ex) {\n+\t\tif (ex == null || ex instanceof SmbException) {\n+\t\t\treturn (SmbException) ex;\n+\t\t}\n+\t\telse {\n+\t\t\treturn findSmbException(ex.getCause());\n+\t\t}\n+\t}\n }\n",
    "test_patch": "diff --git a/spring-integration-ftp/src/test/java/org/springframework/integration/ftp/session/FtpRemoteFileTemplateTests.java b/spring-integration-ftp/src/test/java/org/springframework/integration/ftp/session/FtpRemoteFileTemplateTests.java\nindex e1b482ee803..69edd377c79 100644\n--- a/spring-integration-ftp/src/test/java/org/springframework/integration/ftp/session/FtpRemoteFileTemplateTests.java\n+++ b/spring-integration-ftp/src/test/java/org/springframework/integration/ftp/session/FtpRemoteFileTemplateTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2022 the original author or authors.\n+ * Copyright 2014-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -34,6 +34,7 @@\n import org.springframework.integration.file.DefaultFileNameGenerator;\n import org.springframework.integration.file.remote.ClientCallbackWithoutResult;\n import org.springframework.integration.file.remote.SessionCallbackWithoutResult;\n+import org.springframework.integration.file.remote.session.Session;\n import org.springframework.integration.file.remote.session.SessionFactory;\n import org.springframework.integration.file.support.FileExistsMode;\n import org.springframework.integration.ftp.FtpTestSupport;\n@@ -53,9 +54,7 @@\n /**\n  * @author Gary Russell\n  * @author Artem Bilan\n- *\n  * @since 4.1\n- *\n  */\n @SpringJUnitConfig\n @DirtiesContext\n@@ -142,6 +141,25 @@ public void testConnectionClosedAfterExists() throws Exception {\n \t\tassertThat(pool.getActiveCount()).isEqualTo(0);\n \t}\n \n+\t@Test\n+\tpublic void sessionIsNotDirtyOnNoSuchFileError() {\n+\t\tSession<FTPFile> session = this.sessionFactory.getSession();\n+\t\tsession.close();\n+\n+\t\tFtpRemoteFileTemplate template = new FtpRemoteFileTemplate(this.sessionFactory);\n+\n+\t\tassertThatExceptionOfType(MessagingException.class)\n+\t\t\t\t.isThrownBy(() -> template.rename(\"No_such_file1\", \"No_such_file2\"))\n+\t\t\t\t.withRootCauseInstanceOf(IOException.class)\n+\t\t\t\t.withStackTraceContaining(\"553 : No such file or directory\");\n+\n+\t\tSession<FTPFile> newSession = this.sessionFactory.getSession();\n+\t\tassertThat(TestUtils.getPropertyValue(newSession, \"targetSession\"))\n+\t\t\t\t.isSameAs(TestUtils.getPropertyValue(session, \"targetSession\"));\n+\n+\t\tnewSession.close();\n+\t}\n+\n \t@Configuration\n \tpublic static class Config {\n \n\ndiff --git a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplateTests.java b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplateTests.java\nindex d44f2446529..acfed39d75e 100644\n--- a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplateTests.java\n+++ b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpRemoteFileTemplateTests.java\n@@ -22,6 +22,7 @@\n \n import org.apache.sshd.sftp.client.SftpClient;\n import org.apache.sshd.sftp.client.SftpVersionSelector;\n+import org.apache.sshd.sftp.common.SftpException;\n import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.BeanFactory;\n@@ -38,6 +39,7 @@\n import org.springframework.integration.file.support.FileExistsMode;\n import org.springframework.integration.sftp.SftpTestSupport;\n import org.springframework.integration.test.condition.LogLevels;\n+import org.springframework.integration.test.util.TestUtils;\n import org.springframework.messaging.MessageDeliveryException;\n import org.springframework.messaging.MessagingException;\n import org.springframework.messaging.support.GenericMessage;\n@@ -52,9 +54,7 @@\n /**\n  * @author Gary Russell\n  * @author Artem Bilan\n- *\n  * @since 4.1\n- *\n  */\n @SpringJUnitConfig\n @DirtiesContext\n@@ -63,7 +63,7 @@ public class SftpRemoteFileTemplateTests extends SftpTestSupport {\n \t@Autowired\n \tprivate CachingSessionFactory<SftpClient.DirEntry> sessionFactory;\n \n-\t@LogLevels(level = \"trace\", categories = { \"org.apache.sshd\", \"org.springframework.integration.sftp\" })\n+\t@LogLevels(level = \"trace\", categories = {\"org.apache.sshd\", \"org.springframework.integration.sftp\"})\n \t@Test\n \tpublic void testINT3412AppendStatRmdir() {\n \t\tSftpRemoteFileTemplate template = new SftpRemoteFileTemplate(sessionFactory);\n@@ -164,6 +164,25 @@ public void renameWithOldSftpVersion() {\n \t\toldVersionSession.close();\n \t}\n \n+\t@Test\n+\tpublic void sessionIsNotDirtyOnNoSuchFileError() {\n+\t\tSession<SftpClient.DirEntry> session = this.sessionFactory.getSession();\n+\t\tsession.close();\n+\n+\t\tSftpRemoteFileTemplate template = new SftpRemoteFileTemplate(this.sessionFactory);\n+\n+\t\tassertThatExceptionOfType(MessagingException.class)\n+\t\t\t\t.isThrownBy(() -> template.list(\"No_such_dir\"))\n+\t\t\t\t.withRootCauseInstanceOf(SftpException.class)\n+\t\t\t\t.withStackTraceContaining(\"(SSH_FX_NO_SUCH_FILE): No such file or directory\");\n+\n+\t\tSession<SftpClient.DirEntry> newSession = this.sessionFactory.getSession();\n+\t\tassertThat(TestUtils.getPropertyValue(newSession, \"targetSession\"))\n+\t\t\t\t.isSameAs(TestUtils.getPropertyValue(session, \"targetSession\"));\n+\n+\t\tnewSession.close();\n+\t}\n+\n \t@Configuration\n \tpublic static class Config {\n \n\ndiff --git a/spring-integration-smb/src/test/java/org/springframework/integration/smb/session/SmbSessionTests.java b/spring-integration-smb/src/test/java/org/springframework/integration/smb/session/SmbSessionTests.java\nindex a8b8c3157c8..49f7caf2280 100644\n--- a/spring-integration-smb/src/test/java/org/springframework/integration/smb/session/SmbSessionTests.java\n+++ b/spring-integration-smb/src/test/java/org/springframework/integration/smb/session/SmbSessionTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2012-2022 the original author or authors.\n+ * Copyright 2012-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,9 +21,14 @@\n import jcifs.smb.SmbFile;\n import org.junit.jupiter.api.Test;\n \n+import org.springframework.integration.file.remote.session.CachingSessionFactory;\n+import org.springframework.integration.file.remote.session.Session;\n import org.springframework.integration.smb.SmbTestSupport;\n+import org.springframework.integration.test.util.TestUtils;\n+import org.springframework.messaging.MessagingException;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n \n /**\n  *\n@@ -85,4 +90,24 @@ public void testCreateSmbFileObjectWithMissingTrailingSlash3() throws IOExceptio\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void sessionIsNotDirtyOnNoSuchFileError() {\n+\t\tCachingSessionFactory<SmbFile> cachingSessionFactory = new CachingSessionFactory<>(smbSessionFactory);\n+\t\tSession<SmbFile> session = cachingSessionFactory.getSession();\n+\t\tsession.close();\n+\n+\t\tSmbRemoteFileTemplate template = new SmbRemoteFileTemplate(cachingSessionFactory);\n+\n+\t\tassertThatExceptionOfType(MessagingException.class)\n+\t\t\t\t.isThrownBy(() -> template.rename(\"No_such_file1\", \"No_such_file2\"))\n+\t\t\t\t.withRootCauseInstanceOf(IOException.class)\n+\t\t\t\t.withStackTraceContaining(\"The system cannot find the file specified\");\n+\n+\t\tSession<SmbFile> newSession = cachingSessionFactory.getSession();\n+\t\tassertThat(TestUtils.getPropertyValue(newSession, \"targetSession\"))\n+\t\t\t\t.isSameAs(TestUtils.getPropertyValue(session, \"targetSession\"));\n+\n+\t\tnewSession.close();\n+\t}\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8749",
    "pr_id": 8749,
    "issue_id": 8748,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "JDBC Lock Registry not working with Oracle\n**In what version(s) of Spring Integration are you seeing this issue?**\r\n\r\n6.1.3\r\n\r\n**Describe the bug**\r\nUsing JDBC Lock Registry on Oracle always throws java.lang.IllegalMonitorStateException: The current thread doesn't own mutex at ...\r\n\r\n**To Reproduce**\r\n\r\n```\r\n Lock lock = lockRegistry.obtain(foo);\r\n        try {\r\n            if (lock.tryLock(2, TimeUnit.MINUTES)) {\r\n                specialService.special(foo, bar);\r\n            } else {\r\n                throw new RuntimeException(\"Lock not obtained\");\r\n            }\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n```\r\n**Expected behavior**\r\n\r\nJDBC Lock Registry on Oracle does not throw exception.\r\n\r\n**Sample**\r\n\r\nhttps://github.com/uebelack/spring-integration-lock-oracle\r\n\r\n**Workaround**\r\n```\r\nList.of(\"serializableTransactionTemplate\", \"defaultTransactionTemplate\", \"readOnlyTransactionTemplate\").forEach(templateName -> {\r\n            try {\r\n                Field declaredField = DefaultLockRepository.class.getDeclaredField(templateName);\r\n                declaredField.setAccessible(true);\r\n                TransactionTemplate transactionTemplate = (TransactionTemplate) declaredField.get(lockRegistry);\r\n                transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);\r\n            } catch (NoSuchFieldException | IllegalAccessException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        });\r\n```",
    "issue_word_count": 135,
    "test_files_count": 2,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "build.gradle",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/oracle/OracleContainerTest.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/oracle/OracleLockRegistryTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/oracle/OracleContainerTest.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/oracle/OracleLockRegistryTests.java"
    ],
    "base_commit": "ad01c4498023b2b958b1a3048d1eb9a9cedf34b5",
    "head_commit": "01c8e32d0a2deb44e53de3a78a4eee7c644dc7ec",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8749",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8749",
    "dockerfile": "",
    "pr_merged_at": "2023-10-09T15:52:41.000Z",
    "patch": "diff --git a/build.gradle b/build.gradle\nindex 7c47ea41af4..1f624e42d1d 100644\n--- a/build.gradle\n+++ b/build.gradle\n@@ -95,6 +95,7 @@ ext {\n     mockitoVersion = '5.5.0'\n     mongoDriverVersion = '4.10.2'\n     mysqlVersion = '8.0.33'\n+    oracleVersion = '23.3.0.23.09'\n     pahoMqttClientVersion = '1.2.5'\n     postgresVersion = '42.6.0'\n     protobufVersion = '3.24.3'\n@@ -748,8 +749,10 @@ project('spring-integration-jdbc') {\n         }\n         testImplementation 'org.testcontainers:mysql'\n         testImplementation 'org.testcontainers:postgresql'\n+        testImplementation 'org.testcontainers:oracle-xe'\n \n         testRuntimeOnly 'com.fasterxml.jackson.core:jackson-databind'\n+        testRuntimeOnly \"com.oracle.database.jdbc:ojdbc11:$oracleVersion\"\n     }\n }\n \n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java\nindex 4b977ff6dfd..cb560358611 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java\n@@ -142,7 +142,7 @@ SELECT COUNT(REGION) FROM %sLOCK\n \n \tprivate TransactionTemplate readOnlyTransactionTemplate;\n \n-\tprivate TransactionTemplate serializableTransactionTemplate;\n+\tprivate TransactionTemplate readCommittedTransactionTemplate;\n \n \tprivate boolean checkDatabaseOnStart = true;\n \n@@ -341,9 +341,9 @@ public void afterSingletonsInstantiated() {\n \t\tthis.readOnlyTransactionTemplate = new TransactionTemplate(this.transactionManager, transactionDefinition);\n \n \t\ttransactionDefinition.setReadOnly(false);\n-\t\ttransactionDefinition.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);\n+\t\ttransactionDefinition.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);\n \n-\t\tthis.serializableTransactionTemplate = new TransactionTemplate(this.transactionManager, transactionDefinition);\n+\t\tthis.readCommittedTransactionTemplate = new TransactionTemplate(this.transactionManager, transactionDefinition);\n \t}\n \n \t/**\n@@ -396,7 +396,7 @@ public void delete(String lock) {\n \t@Override\n \tpublic boolean acquire(String lock) {\n \t\tBoolean result =\n-\t\t\t\tthis.serializableTransactionTemplate.execute(\n+\t\t\t\tthis.readCommittedTransactionTemplate.execute(\n \t\t\t\t\t\ttransactionStatus -> {\n \t\t\t\t\t\t\tif (this.template.update(this.updateQuery, this.id, epochMillis(),\n \t\t\t\t\t\t\t\t\tthis.region, lock, this.id, ttlEpochMillis()) > 0) {\n",
    "test_patch": "diff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/oracle/OracleContainerTest.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/oracle/OracleContainerTest.java\nnew file mode 100644\nindex 00000000000..94623a1bd91\n--- /dev/null\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/oracle/OracleContainerTest.java\n@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.jdbc.oracle;\n+\n+import javax.sql.DataSource;\n+\n+import org.apache.commons.dbcp2.BasicDataSource;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.testcontainers.containers.OracleContainer;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+import org.testcontainers.utility.DockerImageName;\n+\n+/**\n+ * The base contract for JUnit tests based on the container for Oracle.\n+ * The Testcontainers 'reuse' option must be disabled,so, Ryuk container is started\n+ * and will clean all the containers up from this test suite after JVM exit.\n+ * Since the Oracle container instance is shared via static property, it is going to be\n+ * started only once per JVM, therefore the target Docker container is reused automatically.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 6.0.8\n+ */\n+@Testcontainers(disabledWithoutDocker = true)\n+public interface OracleContainerTest {\n+\n+\tOracleContainer ORACLE_CONTAINER =\n+\t\t\tnew OracleContainer(DockerImageName.parse(\"gvenzl/oracle-xe:21-slim-faststart\"))\n+\t\t\t\t\t.withInitScript(\"org/springframework/integration/jdbc/schema-oracle.sql\");\n+\n+\t@BeforeAll\n+\tstatic void startContainer() {\n+\t\tORACLE_CONTAINER.start();\n+\t}\n+\n+\tstatic DataSource dataSource() {\n+\t\tBasicDataSource dataSource = new BasicDataSource();\n+\t\tdataSource.setDriverClassName(ORACLE_CONTAINER.getDriverClassName());\n+\t\tdataSource.setUrl(ORACLE_CONTAINER.getJdbcUrl());\n+\t\tdataSource.setUsername(ORACLE_CONTAINER.getUsername());\n+\t\tdataSource.setPassword(ORACLE_CONTAINER.getPassword());\n+\t\treturn dataSource;\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/oracle/OracleLockRegistryTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/oracle/OracleLockRegistryTests.java\nnew file mode 100644\nindex 00000000000..bf92fb54cff\n--- /dev/null\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/oracle/OracleLockRegistryTests.java\n@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.jdbc.oracle;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.Lock;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.task.AsyncTaskExecutor;\n+import org.springframework.core.task.SimpleAsyncTaskExecutor;\n+import org.springframework.integration.jdbc.lock.DefaultLockRepository;\n+import org.springframework.integration.jdbc.lock.JdbcLockRegistry;\n+import org.springframework.integration.jdbc.lock.LockRepository;\n+import org.springframework.jdbc.support.JdbcTransactionManager;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n+import org.springframework.transaction.PlatformTransactionManager;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.assertThatNoException;\n+\n+/**\n+ * @author Artem Bilan\n+ *\n+ * @since 6.0.8\n+ */\n+@SpringJUnitConfig\n+@DirtiesContext\n+public class OracleLockRegistryTests implements OracleContainerTest {\n+\n+\t@Autowired\n+\tAsyncTaskExecutor taskExecutor;\n+\n+\t@Autowired\n+\tJdbcLockRegistry registry;\n+\n+\t@Test\n+\tpublic void twoThreadsSameLock() throws Exception {\n+\t\tfinal Lock lock1 = this.registry.obtain(\"foo\");\n+\t\tfinal AtomicBoolean locked = new AtomicBoolean();\n+\t\tfinal CountDownLatch latch1 = new CountDownLatch(1);\n+\t\tfinal CountDownLatch latch2 = new CountDownLatch(1);\n+\t\tfinal CountDownLatch latch3 = new CountDownLatch(1);\n+\t\tlock1.lockInterruptibly();\n+\t\tthis.taskExecutor.execute(() -> {\n+\t\t\tLock lock2 = this.registry.obtain(\"foo\");\n+\t\t\ttry {\n+\t\t\t\tlatch1.countDown();\n+\t\t\t\tlock2.lockInterruptibly();\n+\t\t\t\tlatch2.await(10, TimeUnit.SECONDS);\n+\t\t\t\tlocked.set(true);\n+\t\t\t}\n+\t\t\tcatch (InterruptedException e) {\n+\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tlock2.unlock();\n+\t\t\t\tlatch3.countDown();\n+\t\t\t}\n+\t\t});\n+\t\tassertThat(latch1.await(10, TimeUnit.SECONDS)).isTrue();\n+\t\tassertThat(locked.get()).isFalse();\n+\t\tlock1.unlock();\n+\t\tlatch2.countDown();\n+\t\tassertThat(latch3.await(10, TimeUnit.SECONDS)).isTrue();\n+\t\tassertThat(locked.get()).isTrue();\n+\t}\n+\n+\t@Test\n+\tpublic void twoThreadsSecondFailsToGetLock() throws Exception {\n+\t\tfinal Lock lock1 = this.registry.obtain(\"foo\");\n+\t\tlock1.lockInterruptibly();\n+\t\tfinal AtomicBoolean locked = new AtomicBoolean();\n+\t\tfinal CountDownLatch latch = new CountDownLatch(1);\n+\t\tFuture<Object> result = taskExecutor.submit(() -> {\n+\t\t\tLock lock2 = this.registry.obtain(\"foo\");\n+\t\t\tlocked.set(lock2.tryLock(200, TimeUnit.MILLISECONDS));\n+\t\t\tlatch.countDown();\n+\t\t\ttry {\n+\t\t\t\tlock2.unlock();\n+\t\t\t}\n+\t\t\tcatch (Exception e) {\n+\t\t\t\treturn e;\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t});\n+\t\tassertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();\n+\t\tassertThat(locked.get()).isFalse();\n+\t\tlock1.unlock();\n+\t\tObject ise = result.get(10, TimeUnit.SECONDS);\n+\t\tassertThat(ise).isInstanceOf(IllegalMonitorStateException.class);\n+\t\tassertThat(((Exception) ise).getMessage()).contains(\"own\");\n+\t}\n+\n+\t@Test\n+\tpublic void lockRenewed() {\n+\t\tLock lock = this.registry.obtain(\"foo\");\n+\n+\t\tassertThat(lock.tryLock()).isTrue();\n+\n+\t\tassertThatNoException()\n+\t\t\t\t.isThrownBy(() -> this.registry.renewLock(\"foo\"));\n+\n+\t\tlock.unlock();\n+\t}\n+\n+\t@Test\n+\tpublic void lockRenewExceptionNotOwned() {\n+\t\tthis.registry.obtain(\"foo\");\n+\n+\t\tassertThatExceptionOfType(IllegalMonitorStateException.class)\n+\t\t\t\t.isThrownBy(() -> this.registry.renewLock(\"foo\"));\n+\t}\n+\n+\t@Configuration\n+\tpublic static class Config {\n+\n+\t\t@Bean\n+\t\tAsyncTaskExecutor taskExecutor() {\n+\t\t\treturn new SimpleAsyncTaskExecutor();\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic PlatformTransactionManager transactionManager() {\n+\t\t\treturn new JdbcTransactionManager(OracleContainerTest.dataSource());\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic DefaultLockRepository defaultLockRepository() {\n+\t\t\treturn new DefaultLockRepository(OracleContainerTest.dataSource());\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic JdbcLockRegistry jdbcLockRegistry(LockRepository lockRepository) {\n+\t\t\treturn new JdbcLockRegistry(lockRepository);\n+\t\t}\n+\n+\t}\n+\n+}\n+\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8737",
    "pr_id": 8737,
    "issue_id": 8732,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Messages deleted too early in JdbcMessageStore when using a message in multiple groups\n**In what version(s) of Spring Integration are you seeing this issue?**\r\n\r\n6.1.2 \r\n\r\n**Describe the bug**\r\n\r\nWhen using a `JdbcMessageStore` and one group completes (or expires), the group is removed. This removal also removes the messages that were linked to that group, even when the same message is still linked to other groups.  \r\nThe link (`int_group_to_message`) for that other group is not removed, so there's a mapping entry to a message that no longer exists in the database. Also, the size attribute of the other group is not updated, so it still shows a count that suggests the message is still present, while it can't be retrieved via `getMessages()` or `streamMessages()`\r\n\r\n**To Reproduce**\r\n\r\nSet up two flows listening on different channels. Both flows have an aggregator and use the `JdbcMessageStore`. Define different release strategies for each flow, but make sure there is an overlap in the \"required messages\" for each flow.  \r\nNow send the message that is required in both flows to both channels. After that, send a message that completes one of the groups. Then send a message that should complete the other group. It will not complete, since the first message is now missing from the group.\r\n\r\n**Expected behavior**\r\n\r\nThe message should only be deleted from the `int_message` table, when it's not linked to any other group. \r\n\r\n**Sample**\r\nhttps://github.com/nschoellhorn/spring-integration-jdbc-repro\r\n\r\nIn [SpringIntegrationJdbcReproApplication](https://github.com/nschoellhorn/spring-integration-jdbc-repro/blob/master/src/main/kotlin/de/kopf3/springintegrationjdbcrepro/SpringIntegrationJdbcReproApplication.kt#L27), I have implemented a CommandLineRunner that simulates the flow of events/messages as described above.  \r\nThe flow setup can be found in [Flows.kt](https://github.com/nschoellhorn/spring-integration-jdbc-repro/blob/master/src/main/kotlin/de/kopf3/springintegrationjdbcrepro/Flows.kt)\r\n\r\nThe Release strategy has some logging that should visualize the problem:\r\n![image](https://github.com/spring-projects/spring-integration/assets/3925180/822187e5-d6d5-4abf-bec3-badcc7db7690)\r\n\r\nIf my assumption is correct that this is a bug, I would be happy to assist in providing a patch to achieve the expected behavior.",
    "issue_word_count": 360,
    "test_files_count": 3,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/store/AbstractKeyValueMessageStore.java",
      "spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/store/HazelcastMessageStore.java",
      "spring-integration-hazelcast/src/test/java/org/springframework/integration/hazelcast/store/HazelcastMessageStoreTests.java",
      "spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageStore.java",
      "spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/MongoDbMessageStore.java",
      "spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/AbstractMongoDbMessageGroupStoreTests.java",
      "spring-integration-redis/src/test/java/org/springframework/integration/redis/store/RedisMessageGroupStoreTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-hazelcast/src/test/java/org/springframework/integration/hazelcast/store/HazelcastMessageStoreTests.java",
      "spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/AbstractMongoDbMessageGroupStoreTests.java",
      "spring-integration-redis/src/test/java/org/springframework/integration/redis/store/RedisMessageGroupStoreTests.java"
    ],
    "base_commit": "10e79ba618e10f39b15631503b0b3732e328a32b",
    "head_commit": "cdcdecc8911a39bd3d450011afa33f0099308941",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8737",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8737",
    "dockerfile": "",
    "pr_merged_at": "2023-09-19T18:13:05.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/store/AbstractKeyValueMessageStore.java b/spring-integration-core/src/main/java/org/springframework/integration/store/AbstractKeyValueMessageStore.java\nindex 68505a830b9..1f5eac29f68 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/store/AbstractKeyValueMessageStore.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/store/AbstractKeyValueMessageStore.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -27,6 +27,7 @@\n import java.util.stream.Stream;\n \n import org.springframework.jmx.export.annotation.ManagedAttribute;\n+import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.util.Assert;\n \n@@ -45,7 +46,7 @@ public abstract class AbstractKeyValueMessageStore extends AbstractMessageGroupS\n \n \tprotected static final String MESSAGE_KEY_PREFIX = \"MESSAGE_\";\n \n-\tprotected static final String MESSAGE_GROUP_KEY_PREFIX = \"MESSAGE_GROUP_\";\n+\tprotected static final String MESSAGE_GROUP_KEY_PREFIX = \"GROUP_OF_MESSAGES_\";\n \n \tprivate final String messagePrefix;\n \n@@ -57,9 +58,9 @@ protected AbstractKeyValueMessageStore() {\n \n \t/**\n \t * Construct an instance based on the provided prefix for keys to distinguish between\n-\t * different store instances in the same target key-value data base. Defaults to an\n+\t * different store instances in the same target key-value database. Defaults to an\n \t * empty string - no prefix. The actual prefix for messages is\n-\t * {@code prefix + MESSAGE_}; for message groups - {@code prefix + MESSAGE_GROUP_}\n+\t * {@code prefix + MESSAGE_}; for message groups - {@code prefix + GROUP_OF_MESSAGES_}\n \t * @param prefix the prefix to use\n \t * @since 4.3.12\n \t */\n@@ -71,18 +72,18 @@ protected AbstractKeyValueMessageStore(String prefix) {\n \n \t/**\n \t * Return the configured prefix for message keys to distinguish between different\n-\t * store instances in the same target key-value data base. Defaults to the\n+\t * store instances in the same target key-value database. Defaults to the\n \t * {@value MESSAGE_KEY_PREFIX} - without a custom prefix.\n \t * @return the prefix for keys\n \t * @since 4.3.12\n \t */\n-\tprotected String getMessagePrefix() {\n+\tpublic String getMessagePrefix() {\n \t\treturn this.messagePrefix;\n \t}\n \n \t/**\n \t * Return the configured prefix for message group keys to distinguish between\n-\t * different store instances in the same target key-value data base. Defaults to the\n+\t * different store instances in the same target key-value database. Defaults to the\n \t * {@value MESSAGE_GROUP_KEY_PREFIX} - without custom prefix.\n \t * @return the prefix for keys\n \t * @since 4.3.12\n@@ -140,10 +141,15 @@ public <T> Message<T> addMessage(Message<T> message) {\n \t}\n \n \tprotected void doAddMessage(Message<?> message) {\n+\t\tdoAddMessage(message, null);\n+\t}\n+\n+\tprotected void doAddMessage(Message<?> message, @Nullable Object groupId) {\n \t\tAssert.notNull(message, \"'message' must not be null\");\n \t\tUUID messageId = message.getHeaders().getId();\n \t\tAssert.notNull(messageId, \"Cannot store messages without an ID header\");\n-\t\tdoStoreIfAbsent(this.messagePrefix + messageId, new MessageHolder(message));\n+\t\tString messageKey = this.messagePrefix + (groupId != null ? groupId.toString() + '_' : \"\") + messageId;\n+\t\tdoStoreIfAbsent(messageKey, new MessageHolder(message));\n \t}\n \n \t@Override\n@@ -165,7 +171,6 @@ public long getMessageCount() {\n \t\treturn (messageIds != null) ? messageIds.size() : 0;\n \t}\n \n-\n \t// MessageGroupStore methods\n \n \t/**\n@@ -211,7 +216,7 @@ public void addMessagesToGroup(Object groupId, Message<?>... messages) {\n \t\t}\n \n \t\tfor (Message<?> message : messages) {\n-\t\t\tdoAddMessage(message);\n+\t\t\tdoAddMessage(message, groupId);\n \t\t\tif (metadata != null) {\n \t\t\t\tmetadata.add(message.getHeaders().getId());\n \t\t\t}\n@@ -253,7 +258,7 @@ public void removeMessagesFromGroup(Object groupId, Collection<Message<?>> messa\n \n \t\t\tList<Object> messageIds = new ArrayList<>();\n \t\t\tfor (UUID id : ids) {\n-\t\t\t\tmessageIds.add(this.messagePrefix + id);\n+\t\t\t\tmessageIds.add(this.messagePrefix + groupId + '_' + id);\n \t\t\t}\n \n \t\t\tdoRemoveAll(messageIds);\n@@ -288,7 +293,7 @@ public void removeMessageGroup(Object groupId) {\n \t\t\tList<Object> messageIds =\n \t\t\t\t\tmessageGroupMetadata.getMessageIds()\n \t\t\t\t\t\t\t.stream()\n-\t\t\t\t\t\t\t.map(id -> this.messagePrefix + id)\n+\t\t\t\t\t\t\t.map(id -> this.messagePrefix + groupId + '_' + id)\n \t\t\t\t\t\t\t.collect(Collectors.toList());\n \n \t\t\tdoRemoveAll(messageIds);\n@@ -326,24 +331,47 @@ public Message<?> pollMessageFromGroup(Object groupId) {\n \t\t\t\tgroupMetadata.remove(firstId);\n \t\t\t\tgroupMetadata.setLastModified(System.currentTimeMillis());\n \t\t\t\tdoStore(this.groupPrefix + groupId, groupMetadata);\n-\t\t\t\treturn removeMessage(firstId);\n+\t\t\t\treturn removeMessageFromGroup(firstId, groupId);\n \t\t\t}\n \t\t}\n \t\treturn null;\n \t}\n \n+\tprivate Message<?> removeMessageFromGroup(UUID id, Object groupId) {\n+\t\tAssert.notNull(id, \"'id' must not be null\");\n+\t\tObject object = doRemove(this.messagePrefix + groupId + '_' + id);\n+\t\tif (object != null) {\n+\t\t\treturn extractMessage(object);\n+\t\t}\n+\t\telse {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n \t@Override\n \tpublic Message<?> getOneMessageFromGroup(Object groupId) {\n \t\tMessageGroupMetadata groupMetadata = getGroupMetadata(groupId);\n \t\tif (groupMetadata != null) {\n \t\t\tUUID messageId = groupMetadata.firstId();\n \t\t\tif (messageId != null) {\n-\t\t\t\treturn getMessage(messageId);\n+\t\t\t\treturn getMessageFromGroup(messageId, groupId);\n \t\t\t}\n \t\t}\n \t\treturn null;\n \t}\n \n+\t@Nullable\n+\tprivate Message<?> getMessageFromGroup(UUID messageId, Object groupId) {\n+\t\tAssert.notNull(messageId, \"'messageId' must not be null\");\n+\t\tObject object = doRetrieve(this.messagePrefix + groupId + '_' + messageId);\n+\t\tif (object != null) {\n+\t\t\treturn extractMessage(object);\n+\t\t}\n+\t\telse {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n \t@Override\n \tpublic Collection<Message<?>> getMessagesForGroup(Object groupId) {\n \t\tMessageGroupMetadata groupMetadata = getGroupMetadata(groupId);\n@@ -351,7 +379,7 @@ public Collection<Message<?>> getMessagesForGroup(Object groupId) {\n \t\tif (groupMetadata != null) {\n \t\t\tIterator<UUID> messageIds = groupMetadata.messageIdIterator();\n \t\t\twhile (messageIds.hasNext()) {\n-\t\t\t\tmessages.add(getMessage(messageIds.next()));\n+\t\t\t\tmessages.add(getMessageFromGroup(messageIds.next(), groupId));\n \t\t\t}\n \t\t}\n \t\treturn messages;\n@@ -362,7 +390,7 @@ public Stream<Message<?>> streamMessagesForGroup(Object groupId) {\n \t\treturn getGroupMetadata(groupId)\n \t\t\t\t.getMessageIds()\n \t\t\t\t.stream()\n-\t\t\t\t.map(this::getMessage);\n+\t\t\t\t.map((messageId) -> getMessageFromGroup(messageId, groupId));\n \t}\n \n \t@Override\n@@ -376,8 +404,8 @@ public Iterator<MessageGroup> iterator() {\n \n \tprivate Collection<String> normalizeKeys(Collection<String> keys) {\n \t\tSet<String> normalizedKeys = new HashSet<>();\n-\t\tfor (Object key : keys) {\n-\t\t\tString strKey = (String) key;\n+\t\tfor (String key : keys) {\n+\t\t\tString strKey = key;\n \t\t\tif (strKey.startsWith(this.groupPrefix)) {\n \t\t\t\tstrKey = strKey.replace(this.groupPrefix, \"\");\n \t\t\t}\n\ndiff --git a/spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/store/HazelcastMessageStore.java b/spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/store/HazelcastMessageStore.java\nindex a6e3cb51db9..b58a20927cf 100644\n--- a/spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/store/HazelcastMessageStore.java\n+++ b/spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/store/HazelcastMessageStore.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2017-2022 the original author or authors.\n+ * Copyright 2017-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n\ndiff --git a/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageStore.java b/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageStore.java\nindex cb6c809f8fb..df6ab0363cb 100644\n--- a/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageStore.java\n+++ b/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageStore.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2022 the original author or authors.\n+ * Copyright 2013-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -101,7 +101,8 @@ public <T> Message<T> addMessage(Message<T> message) {\n \t@Override\n \tpublic Message<?> removeMessage(UUID id) {\n \t\tAssert.notNull(id, \"'id' must not be null\");\n-\t\tQuery query = Query.query(Criteria.where(MessageDocumentFields.MESSAGE_ID).is(id));\n+\t\tQuery query = Query.query(Criteria.where(MessageDocumentFields.MESSAGE_ID).is(id)\n+\t\t\t\t.and(MessageDocumentFields.GROUP_ID).exists(false));\n \t\tMessageDocument document = getMongoTemplate().findAndRemove(query, MessageDocument.class, this.collectionName);\n \t\treturn (document != null) ? document.getMessage() : null;\n \t}\n\ndiff --git a/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/MongoDbMessageStore.java b/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/MongoDbMessageStore.java\nindex 9696ffa387e..81e68d6620a 100644\n--- a/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/MongoDbMessageStore.java\n+++ b/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/MongoDbMessageStore.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -258,14 +258,15 @@ public MessageMetadata getMessageMetadata(UUID id) {\n \t@Override\n \t@ManagedAttribute\n \tpublic long getMessageCount() {\n-\t\treturn this.template.getCollection(this.collectionName).countDocuments();\n+\t\tQuery query = Query.query(Criteria.where(\"headers.id\").exists(true).and(GROUP_ID_KEY).exists(false));\n+\t\treturn this.template.getCollection(this.collectionName).countDocuments(query.getQueryObject());\n \t}\n \n \t@Override\n \tpublic Message<?> removeMessage(UUID id) {\n \t\tAssert.notNull(id, \"'id' must not be null\");\n-\t\tMessageWrapper messageWrapper =\n-\t\t\t\tthis.template.findAndRemove(whereMessageIdIs(id), MessageWrapper.class, this.collectionName);\n+\t\tQuery query = Query.query(Criteria.where(\"headers.id\").is(id).and(GROUP_ID_KEY).exists(false));\n+\t\tMessageWrapper messageWrapper = this.template.findAndRemove(query, MessageWrapper.class, this.collectionName);\n \t\treturn (messageWrapper != null ? messageWrapper.getMessage() : null);\n \t}\n \n",
    "test_patch": "diff --git a/spring-integration-hazelcast/src/test/java/org/springframework/integration/hazelcast/store/HazelcastMessageStoreTests.java b/spring-integration-hazelcast/src/test/java/org/springframework/integration/hazelcast/store/HazelcastMessageStoreTests.java\nindex 23cd21d10cf..d2b88a377e6 100644\n--- a/spring-integration-hazelcast/src/test/java/org/springframework/integration/hazelcast/store/HazelcastMessageStoreTests.java\n+++ b/spring-integration-hazelcast/src/test/java/org/springframework/integration/hazelcast/store/HazelcastMessageStoreTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2017-2022 the original author or authors.\n+ * Copyright 2017-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,10 +23,10 @@\n import com.hazelcast.core.Hazelcast;\n import com.hazelcast.core.HazelcastInstance;\n import com.hazelcast.map.IMap;\n-import org.junit.AfterClass;\n-import org.junit.Before;\n-import org.junit.BeforeClass;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.integration.channel.DirectChannel;\n import org.springframework.integration.history.MessageHistory;\n@@ -50,26 +50,25 @@ public class HazelcastMessageStoreTests {\n \n \tprivate static IMap<Object, Object> map;\n \n-\t@BeforeClass\n+\t@BeforeAll\n \tpublic static void init() {\n \t\tinstance = Hazelcast.newHazelcastInstance();\n \t\tmap = instance.getMap(\"customTestsMessageStore\");\n \t\tstore = new HazelcastMessageStore(map);\n \t}\n \n-\t@AfterClass\n+\t@AfterAll\n \tpublic static void destroy() {\n \t\tinstance.shutdown();\n \t}\n \n-\t@Before\n+\t@BeforeEach\n \tpublic void clean() {\n \t\tmap.clear();\n \t}\n \n \t@Test\n \tpublic void testWithMessageHistory() {\n-\n \t\tMessage<?> message = new GenericMessage<>(\"Hello\");\n \t\tDirectChannel fooChannel = new DirectChannel();\n \t\tfooChannel.setBeanName(\"fooChannel\");\n@@ -107,7 +106,6 @@ public void testAddAndRemoveMessagesFromMessageGroup() {\n \n \t@Test\n \tpublic void addAndGetMessage() {\n-\n \t\tMessage<?> message = MessageBuilder.withPayload(\"test\").build();\n \t\tstore.addMessage(message);\n \t\tMessage<?> retrieved = store.getMessage(message.getHeaders().getId());\n@@ -145,4 +143,34 @@ public void messageStoreIterator() {\n \t\tassertThat(groupCount).isEqualTo(1);\n \t}\n \n+\t@Test\n+\tpublic void sameMessageInTwoGroupsNotRemovedByFirstGroup() {\n+\t\tGenericMessage<String> testMessage = new GenericMessage<>(\"test data\");\n+\n+\t\tstore.addMessageToGroup(\"1\", testMessage);\n+\t\tstore.addMessageToGroup(\"2\", testMessage);\n+\n+\t\tstore.removeMessageGroup(\"1\");\n+\n+\t\tassertThat(store.getMessageCount()).isEqualTo(1);\n+\n+\t\tstore.removeMessageGroup(\"2\");\n+\n+\t\tassertThat(store.getMessageCount()).isEqualTo(0);\n+\t}\n+\n+\t@Test\n+\tpublic void removeMessagesFromGroupDontRemoveSameMessageInOtherGroup() {\n+\t\tGenericMessage<String> testMessage = new GenericMessage<>(\"test data\");\n+\n+\t\tstore.addMessageToGroup(\"1\", testMessage);\n+\t\tstore.addMessageToGroup(\"2\", testMessage);\n+\n+\t\tstore.removeMessagesFromGroup(\"1\", testMessage);\n+\n+\t\tassertThat(store.getMessageCount()).isEqualTo(1);\n+\t\tassertThat(store.messageGroupSize(\"1\")).isEqualTo(0);\n+\t\tassertThat(store.messageGroupSize(\"2\")).isEqualTo(1);\n+\t}\n+\n }\n\ndiff --git a/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/AbstractMongoDbMessageGroupStoreTests.java b/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/AbstractMongoDbMessageGroupStoreTests.java\nindex d8385cc1781..0c94b46eb13 100644\n--- a/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/AbstractMongoDbMessageGroupStoreTests.java\n+++ b/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/AbstractMongoDbMessageGroupStoreTests.java\n@@ -536,6 +536,28 @@ void testWithMessageHistory() {\n \t\t\t\t.containsEntry(\"type\", \"channel\");\n \t}\n \n+\t@Test\n+\tpublic void removeMessageDoesntRemoveSameMessageInTheGroup() {\n+\t\tGenericMessage<String> testMessage = new GenericMessage<>(\"test data\");\n+\n+\t\tMessageGroupStore store = getMessageGroupStore();\n+\n+\t\tstore.addMessageToGroup(\"1\", testMessage);\n+\n+\t\tMessageStore messageStore = (MessageStore) store;\n+\n+\t\tmessageStore.removeMessage(testMessage.getHeaders().getId());\n+\n+\t\tassertThat(messageStore.getMessageCount()).isEqualTo(0);\n+\t\tassertThat(store.getMessageCountForAllMessageGroups()).isEqualTo(1);\n+\t\tassertThat(store.messageGroupSize(\"1\")).isEqualTo(1);\n+\n+\t\tstore.removeMessageGroup(\"1\");\n+\n+\t\tassertThat(store.getMessageCountForAllMessageGroups()).isEqualTo(0);\n+\t\tassertThat(store.messageGroupSize(\"1\")).isEqualTo(0);\n+\t}\n+\n \tprotected abstract MessageGroupStore getMessageGroupStore();\n \n \tprotected abstract MessageStore getMessageStore();\n\ndiff --git a/spring-integration-redis/src/test/java/org/springframework/integration/redis/store/RedisMessageGroupStoreTests.java b/spring-integration-redis/src/test/java/org/springframework/integration/redis/store/RedisMessageGroupStoreTests.java\nindex e70bf2c741c..1da003ac884 100644\n--- a/spring-integration-redis/src/test/java/org/springframework/integration/redis/store/RedisMessageGroupStoreTests.java\n+++ b/spring-integration-redis/src/test/java/org/springframework/integration/redis/store/RedisMessageGroupStoreTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2007-2022 the original author or authors.\n+ * Copyright 2007-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -56,6 +56,7 @@\n import org.springframework.messaging.support.GenericMessage;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatNoException;\n import static org.assertj.core.api.Assertions.fail;\n \n /**\n@@ -65,6 +66,7 @@\n  * @author Artem Vozhdayenko\n  */\n class RedisMessageGroupStoreTests implements RedisContainerTest {\n+\n \tprivate static RedisConnectionFactory redisConnectionFactory;\n \n \t@BeforeAll\n@@ -74,17 +76,18 @@ static void setupConnection() {\n \n \tprivate final UUID groupId = UUID.randomUUID();\n \n+\tRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\n+\n \t@BeforeEach\n \t@AfterEach\n \tvoid setUpTearDown() {\n \t\tStringRedisTemplate template = RedisContainerTest.createStringRedisTemplate(redisConnectionFactory);\n-\t\ttemplate.delete(template.keys(\"MESSAGE_GROUP_*\"));\n+\t\ttemplate.delete(template.keys(\"MESSAGE_*\"));\n+\t\ttemplate.delete(template.keys(\"GROUP_OF_MESSAGES_*\"));\n \t}\n \n \t@Test\n \tvoid testNonExistingEmptyMessageGroup() {\n-\t\tRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\n-\n \t\tMessageGroup messageGroup = store.getMessageGroup(this.groupId);\n \t\tassertThat(messageGroup).isNotNull();\n \t\tassertThat(messageGroup).isInstanceOf(SimpleMessageGroup.class);\n@@ -93,8 +96,6 @@ void testNonExistingEmptyMessageGroup() {\n \n \t@Test\n \tvoid testMessageGroupUpdatedDateChangesWithEachAddedMessage() throws Exception {\n-\t\tRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\n-\n \t\tMessage<?> message = new GenericMessage<>(\"Hello\");\n \t\tMessageGroup messageGroup = store.addMessageToGroup(this.groupId, message);\n \t\tassertThat(messageGroup.size()).isEqualTo(1);\n@@ -117,8 +118,6 @@ void testMessageGroupUpdatedDateChangesWithEachAddedMessage() throws Exception {\n \n \t@Test\n \tvoid testMessageGroupWithAddedMessage() {\n-\t\tRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\n-\n \t\tMessage<?> message = new GenericMessage<>(\"Hello\");\n \t\tMessageGroup messageGroup = store.addMessageToGroup(this.groupId, message);\n \t\tassertThat(messageGroup.size()).isEqualTo(1);\n@@ -132,8 +131,6 @@ void testMessageGroupWithAddedMessage() {\n \n \t@Test\n \tvoid testRemoveMessageGroup() {\n-\t\tRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\n-\n \t\tMessageGroup messageGroup = store.getMessageGroup(this.groupId);\n \t\tMessage<?> message = new GenericMessage<>(\"Hello\");\n \t\tmessageGroup = store.addMessageToGroup(messageGroup.getGroupId(), message);\n@@ -157,8 +154,6 @@ void testRemoveMessageGroup() {\n \n \t@Test\n \tvoid testCompleteMessageGroup() {\n-\t\tRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\n-\n \t\tMessageGroup messageGroup = store.getMessageGroup(this.groupId);\n \t\tMessage<?> message = new GenericMessage<>(\"Hello\");\n \t\tmessageGroup = store.addMessageToGroup(messageGroup.getGroupId(), message);\n@@ -169,8 +164,6 @@ void testCompleteMessageGroup() {\n \n \t@Test\n \tvoid testLastReleasedSequenceNumber() {\n-\t\tRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\n-\n \t\tMessageGroup messageGroup = store.getMessageGroup(this.groupId);\n \t\tMessage<?> message = new GenericMessage<>(\"Hello\");\n \t\tmessageGroup = store.addMessageToGroup(messageGroup.getGroupId(), message);\n@@ -181,8 +174,6 @@ void testLastReleasedSequenceNumber() {\n \n \t@Test\n \tvoid testRemoveMessageFromTheGroup() {\n-\t\tRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\n-\n \t\tMessageGroup messageGroup = store.getMessageGroup(this.groupId);\n \t\tMessage<?> message = new GenericMessage<>(\"2\");\n \t\tstore.addMessagesToGroup(messageGroup.getGroupId(), new GenericMessage<>(\"1\"), message);\n@@ -202,8 +193,6 @@ void testRemoveMessageFromTheGroup() {\n \n \t@Test\n \tvoid testWithMessageHistory() {\n-\t\tRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\n-\n \t\tMessage<?> message = new GenericMessage<>(\"Hello\");\n \t\tDirectChannel fooChannel = new DirectChannel();\n \t\tfooChannel.setBeanName(\"fooChannel\");\n@@ -227,17 +216,16 @@ void testWithMessageHistory() {\n \n \t@Test\n \tvoid testRemoveNonExistingMessageFromTheGroup() {\n-\t\tRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\n-\n \t\tMessageGroup messageGroup = store.getMessageGroup(this.groupId);\n \t\tstore.addMessagesToGroup(messageGroup.getGroupId(), new GenericMessage<>(\"1\"));\n-\t\tstore.removeMessagesFromGroup(this.groupId, new GenericMessage<>(\"2\"));\n+\t\tassertThatNoException()\n+\t\t\t\t.isThrownBy(() -> store.removeMessagesFromGroup(this.groupId, new GenericMessage<>(\"2\")));\n \t}\n \n \t@Test\n \tvoid testRemoveNonExistingMessageFromNonExistingTheGroup() {\n-\t\tRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\n-\t\tstore.removeMessagesFromGroup(this.groupId, new GenericMessage<>(\"2\"));\n+\t\tassertThatNoException()\n+\t\t\t\t.isThrownBy(() -> store.removeMessagesFromGroup(this.groupId, new GenericMessage<>(\"2\")));\n \t}\n \n \n@@ -283,14 +271,9 @@ void testIteratorOfMessageGroups() {\n \t\twhile (messageGroups.hasNext()) {\n \t\t\tMessageGroup group = messageGroups.next();\n \t\t\tString groupId = (String) group.getGroupId();\n-\t\t\tif (groupId.equals(\"1\")) {\n-\t\t\t\tassertThat(group.getMessages().size()).isEqualTo(1);\n-\t\t\t}\n-\t\t\telse if (groupId.equals(\"2\")) {\n-\t\t\t\tassertThat(group.getMessages().size()).isEqualTo(1);\n-\t\t\t}\n-\t\t\telse if (groupId.equals(\"3\")) {\n-\t\t\t\tassertThat(group.getMessages().size()).isEqualTo(2);\n+\t\t\tswitch (groupId) {\n+\t\t\t\tcase \"1\", \"2\" -> assertThat(group.getMessages().size()).isEqualTo(1);\n+\t\t\t\tcase \"3\" -> assertThat(group.getMessages().size()).isEqualTo(2);\n \t\t\t}\n \t\t\tcounter++;\n \t\t}\n@@ -390,25 +373,22 @@ void testWithAggregatorWithShutdown() {\n \n \t@Test\n \tvoid testAddAndRemoveMessagesFromMessageGroup() {\n-\t\tRedisMessageStore messageStore = new RedisMessageStore(redisConnectionFactory);\n-\t\tList<Message<?>> messages = new ArrayList<Message<?>>();\n+\t\tList<Message<?>> messages = new ArrayList<>();\n \t\tfor (int i = 0; i < 25; i++) {\n \t\t\tMessage<String> message = MessageBuilder.withPayload(\"foo\").setCorrelationId(this.groupId).build();\n-\t\t\tmessageStore.addMessagesToGroup(this.groupId, message);\n+\t\t\tstore.addMessagesToGroup(this.groupId, message);\n \t\t\tmessages.add(message);\n \t\t}\n-\t\tMessageGroup group = messageStore.getMessageGroup(this.groupId);\n+\t\tMessageGroup group = store.getMessageGroup(this.groupId);\n \t\tassertThat(group.size()).isEqualTo(25);\n-\t\tmessageStore.removeMessagesFromGroup(this.groupId, messages);\n-\t\tgroup = messageStore.getMessageGroup(this.groupId);\n+\t\tstore.removeMessagesFromGroup(this.groupId, messages);\n+\t\tgroup = store.getMessageGroup(this.groupId);\n \t\tassertThat(group.size()).isZero();\n-\t\tmessageStore.removeMessageGroup(this.groupId);\n+\t\tstore.removeMessageGroup(this.groupId);\n \t}\n \n \t@Test\n \tvoid testJsonSerialization() {\n-\t\tRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\n-\n \t\tObjectMapper mapper = JacksonJsonUtils.messagingAwareMapper();\n \n \t\tGenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(mapper);\n@@ -476,6 +456,36 @@ void testJsonSerialization() {\n \t\tassertThat(messageGroup.getMessages().iterator().next()).isEqualTo(fooMessage);\n \t}\n \n+\t@Test\n+\tpublic void sameMessageInTwoGroupsNotRemovedByFirstGroup() {\n+\t\tGenericMessage<String> testMessage = new GenericMessage<>(\"test data\");\n+\n+\t\tstore.addMessageToGroup(\"1\", testMessage);\n+\t\tstore.addMessageToGroup(\"2\", testMessage);\n+\n+\t\tstore.removeMessageGroup(\"1\");\n+\n+\t\tassertThat(store.getMessageCount()).isEqualTo(1);\n+\n+\t\tstore.removeMessageGroup(\"2\");\n+\n+\t\tassertThat(store.getMessageCount()).isEqualTo(0);\n+\t}\n+\n+\t@Test\n+\tpublic void removeMessagesFromGroupDontRemoveSameMessageInOtherGroup() {\n+\t\tGenericMessage<String> testMessage = new GenericMessage<>(\"test data\");\n+\n+\t\tstore.addMessageToGroup(\"1\", testMessage);\n+\t\tstore.addMessageToGroup(\"2\", testMessage);\n+\n+\t\tstore.removeMessagesFromGroup(\"1\", testMessage);\n+\n+\t\tassertThat(store.getMessageCount()).isEqualTo(1);\n+\t\tassertThat(store.messageGroupSize(\"1\")).isEqualTo(0);\n+\t\tassertThat(store.messageGroupSize(\"2\")).isEqualTo(1);\n+\t}\n+\n \tprivate static class Foo {\n \n \t\tprivate String foo;\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8733",
    "pr_id": 8733,
    "issue_id": 8732,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Messages deleted too early in JdbcMessageStore when using a message in multiple groups\n**In what version(s) of Spring Integration are you seeing this issue?**\r\n\r\n6.1.2 \r\n\r\n**Describe the bug**\r\n\r\nWhen using a `JdbcMessageStore` and one group completes (or expires), the group is removed. This removal also removes the messages that were linked to that group, even when the same message is still linked to other groups.  \r\nThe link (`int_group_to_message`) for that other group is not removed, so there's a mapping entry to a message that no longer exists in the database. Also, the size attribute of the other group is not updated, so it still shows a count that suggests the message is still present, while it can't be retrieved via `getMessages()` or `streamMessages()`\r\n\r\n**To Reproduce**\r\n\r\nSet up two flows listening on different channels. Both flows have an aggregator and use the `JdbcMessageStore`. Define different release strategies for each flow, but make sure there is an overlap in the \"required messages\" for each flow.  \r\nNow send the message that is required in both flows to both channels. After that, send a message that completes one of the groups. Then send a message that should complete the other group. It will not complete, since the first message is now missing from the group.\r\n\r\n**Expected behavior**\r\n\r\nThe message should only be deleted from the `int_message` table, when it's not linked to any other group. \r\n\r\n**Sample**\r\nhttps://github.com/nschoellhorn/spring-integration-jdbc-repro\r\n\r\nIn [SpringIntegrationJdbcReproApplication](https://github.com/nschoellhorn/spring-integration-jdbc-repro/blob/master/src/main/kotlin/de/kopf3/springintegrationjdbcrepro/SpringIntegrationJdbcReproApplication.kt#L27), I have implemented a CommandLineRunner that simulates the flow of events/messages as described above.  \r\nThe flow setup can be found in [Flows.kt](https://github.com/nschoellhorn/spring-integration-jdbc-repro/blob/master/src/main/kotlin/de/kopf3/springintegrationjdbcrepro/Flows.kt)\r\n\r\nThe Release strategy has some logging that should visualize the problem:\r\n![image](https://github.com/spring-projects/spring-integration/assets/3925180/822187e5-d6d5-4abf-bec3-badcc7db7690)\r\n\r\nIf my assumption is correct that this is a bug, I would be happy to assist in providing a patch to achieve the expected behavior.",
    "issue_word_count": 360,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/store/MessageStore.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcMessageStore.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlJdbcMessageStoreTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlJdbcMessageStoreTests.java"
    ],
    "base_commit": "f3d0441a38d542d6b8c478dd68adb77a8c4330a4",
    "head_commit": "89cb95c7e0d97372e5d6e77a0a72923827d2d484",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8733",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8733",
    "dockerfile": "",
    "pr_merged_at": "2023-09-14T16:58:07.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/store/MessageStore.java b/spring-integration-core/src/main/java/org/springframework/integration/store/MessageStore.java\nindex 503e05b1fd8..1e8060947ff 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/store/MessageStore.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/store/MessageStore.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -62,11 +62,12 @@ public interface MessageStore {\n \t<T> Message<T> addMessage(Message<T> message);\n \n \t/**\n-\t * Remove the Message with the given id from the MessageStore, if present, and return it. If no Message with that id\n-\t * is present in the store, this will return <i>null</i>.\n-\t *\n-\t * @param id THe message identifier.\n-\t * @return The message.\n+\t * Remove the Message with the given id from the MessageStore, if present, and return it.\n+\t * If no Message with that id is present in the store, this will return {@code null}.\n+\t * If this method is implemented on a {@link MessageGroupStore},\n+\t * the message is removed from the store only if no groups holding this message.\n+\t * @param id the message identifier.\n+\t * @return the message (if any).\n \t */\n \tMessage<?> removeMessage(UUID id);\n \n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcMessageStore.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcMessageStore.java\nindex 26f1fb8c148..2f9b2150b26 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcMessageStore.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcMessageStore.java\n@@ -172,6 +172,9 @@ SELECT COUNT(MESSAGE_ID)\n \t\tDELETE_MESSAGE(\"\"\"\n \t\t\t\tDELETE from %PREFIX%MESSAGE\n \t\t\t\twhere MESSAGE_ID=? and REGION=?\n+\t\t\t\t\tand MESSAGE_ID not in (\n+\t\t\t\t\t\t\t\t\t\tSELECT MESSAGE_ID from %PREFIX%GROUP_TO_MESSAGE\n+\t\t\t\t\t\t\t\t\t\t\t\t\twhere MESSAGE_ID=? and REGION = ?)\n \t\t\t\t\"\"\"),\n \n \t\tCREATE_MESSAGE(\"\"\"\n@@ -199,7 +202,12 @@ SELECT COUNT(GROUP_KEY)\n \n \t\tDELETE_MESSAGES_FROM_GROUP(\"\"\"\n \t\t\t\tDELETE from %PREFIX%MESSAGE\n-\t\t\t\twhere MESSAGE_ID in (SELECT MESSAGE_ID from %PREFIX%GROUP_TO_MESSAGE where GROUP_KEY = ? and REGION = ?)\n+\t\t\t\twhere MESSAGE_ID in (\n+\t\t\t\t\t\t\t\tSELECT MESSAGE_ID from %PREFIX%GROUP_TO_MESSAGE where GROUP_KEY = ? and REGION = ?\n+\t\t\t\t\t\t\t\t\t\t\t\tand MESSAGE_ID not in (\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSELECT MESSAGE_ID from %PREFIX%GROUP_TO_MESSAGE\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhere GROUP_KEY != ? and REGION = ?)\n+\t\t\t\t\t\t\t\t)\n \t\t\t\t\tand REGION = ?\n \t\t\t\t\"\"\"),\n \n@@ -384,7 +392,8 @@ public Message<?> removeMessage(UUID id) {\n \t\tif (message == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tint updated = this.jdbcTemplate.update(getQuery(Query.DELETE_MESSAGE), getKey(id), this.region);\n+\t\tString key = getKey(id);\n+\t\tint updated = this.jdbcTemplate.update(getQuery(Query.DELETE_MESSAGE), key, this.region, key, this.region);\n \t\tif (updated != 0) {\n \t\t\treturn message;\n \t\t}\n@@ -575,15 +584,18 @@ public void removeMessagesFromGroup(Object groupId, Collection<Message<?>> messa\n \t\t\t\t(ps, messageToRemove) -> {\n \t\t\t\t\tps.setString(1, groupKey); // NOSONAR - magic number\n \t\t\t\t\tps.setString(2, getKey(messageToRemove.getHeaders().getId())); // NOSONAR - magic number\n-\t\t\t\t\tps.setString(3, JdbcMessageStore.this.region); // NOSONAR - magic number\n+\t\t\t\t\tps.setString(3, this.region); // NOSONAR - magic number\n \t\t\t\t});\n \n \t\tthis.jdbcTemplate.batchUpdate(getQuery(Query.DELETE_MESSAGE),\n \t\t\t\tmessages,\n \t\t\t\tgetRemoveBatchSize(),\n \t\t\t\t(ps, messageToRemove) -> {\n-\t\t\t\t\tps.setString(1, getKey(messageToRemove.getHeaders().getId())); // NOSONAR - magic number\n-\t\t\t\t\tps.setString(2, JdbcMessageStore.this.region); // NOSONAR - magic number\n+\t\t\t\t\tString key = getKey(messageToRemove.getHeaders().getId());\n+\t\t\t\t\tps.setString(1, key); // NOSONAR - magic number\n+\t\t\t\t\tps.setString(2, this.region); // NOSONAR - magic number\n+\t\t\t\t\tps.setString(3, key); // NOSONAR - magic number\n+\t\t\t\t\tps.setString(4, this.region); // NOSONAR - magic number\n \t\t\t\t});\n \n \t\tupdateMessageGroup(groupKey);\n@@ -593,7 +605,8 @@ public void removeMessagesFromGroup(Object groupId, Collection<Message<?>> messa\n \tpublic void removeMessageGroup(Object groupId) {\n \t\tString groupKey = getKey(groupId);\n \n-\t\tthis.jdbcTemplate.update(getQuery(Query.DELETE_MESSAGES_FROM_GROUP), groupKey, this.region, this.region);\n+\t\tthis.jdbcTemplate.update(getQuery(Query.DELETE_MESSAGES_FROM_GROUP),\n+\t\t\t\tgroupKey, this.region, groupKey, this.region, this.region);\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(\"Removing relationships for the group with group key=\" + groupKey);\n",
    "test_patch": "diff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlJdbcMessageStoreTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlJdbcMessageStoreTests.java\nindex 979ad02c7bb..1f8f5d67eff 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlJdbcMessageStoreTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlJdbcMessageStoreTests.java\n@@ -497,6 +497,36 @@ public void testMessageGroupCondition() {\n \t\tassertThat(this.messageStore.getMessageGroup(groupId).getCondition()).isEqualTo(\"testCondition\");\n \t}\n \n+\t@Test\n+\tpublic void sameMessageInTwoGroupsNotRemovedByFirstGroup() {\n+\t\tGenericMessage<String> testMessage = new GenericMessage<>(\"test data\");\n+\n+\t\tmessageStore.addMessageToGroup(\"1\", testMessage);\n+\t\tmessageStore.addMessageToGroup(\"2\", testMessage);\n+\n+\t\tmessageStore.removeMessageGroup(\"1\");\n+\n+\t\tassertThat(messageStore.getMessageCount()).isEqualTo(1);\n+\n+\t\tmessageStore.removeMessageGroup(\"2\");\n+\n+\t\tassertThat(messageStore.getMessageCount()).isEqualTo(0);\n+\t}\n+\n+\t@Test\n+\tpublic void removeMessagesFromGroupDontRemoveSameMessageInOtherGroup() {\n+\t\tGenericMessage<String> testMessage = new GenericMessage<>(\"test data\");\n+\n+\t\tmessageStore.addMessageToGroup(\"1\", testMessage);\n+\t\tmessageStore.addMessageToGroup(\"2\", testMessage);\n+\n+\t\tmessageStore.removeMessagesFromGroup(\"1\", testMessage);\n+\n+\t\tassertThat(messageStore.getMessageCount()).isEqualTo(1);\n+\t\tassertThat(messageStore.messageGroupSize(\"1\")).isEqualTo(0);\n+\t\tassertThat(messageStore.messageGroupSize(\"2\")).isEqualTo(1);\n+\t}\n+\n \t@Configuration\n \tpublic static class Config {\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8729",
    "pr_id": 8729,
    "issue_id": 2971,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "add a `LockTemplate` to simplify working with distributed Locks in Spring Integration\nPlease add a `LockTemplate` or something to make using the `LockRegistry` easier. It took a lot of attempts before I figured out the right combination of objects was. I've encapsulated it into a `LockTemplate`, as shown below, but I'm sure might see use cases I haven't yet addressed here.  \r\n\r\n``` java\r\n\r\nimport org.springframework.integration.support.locks.LockRegistry;\r\nimport org.springframework.util.ReflectionUtils;\r\n\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.locks.Lock;\r\n\r\npublic class LockTemplate {\r\n\r\n\tprivate final LockRegistry registry;\r\n\r\n\tpublic LockTemplate(LockRegistry registry) {\r\n\t\tthis.registry = registry;\r\n\t}\r\n\r\n\tpublic <T> T executeWithLock(String key, int timeoutDuration, TimeUnit tu, Callable<T> callable) {\r\n\t\treturn this.doExecuteWithLock(key, lock -> lock.tryLock(timeoutDuration, tu), callable);\r\n\t}\r\n\r\n\tpublic <T> T executeWithLock(String key, Callable<T> callable) {\r\n\t\treturn this.doExecuteWithLock(key, Lock::tryLock, callable);\r\n\t}\r\n\r\n\tprivate <T> T doExecuteWithLock(\r\n\t\tString key, ExceptionSwallowingFunction<Lock, Boolean> lockProducer, Callable<T> callable) {\r\n\r\n\t\ttry {\r\n\t\t\tLock lock = registry.obtain(key);\r\n\t\t\tboolean lockAcquired = lockProducer.apply(lock);\r\n\t\t\tif (lockAcquired) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn callable.call();\r\n\t\t\t\t}\r\n\t\t\t\tfinally {\r\n\t\t\t\t\tlock.unlock();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch (Exception e) {\r\n\t\t\tReflectionUtils.rethrowRuntimeException(e);\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate interface ExceptionSwallowingFunction<I, O> {\r\n\t\tO apply(I i) throws Exception;\r\n\t}\r\n}\r\n```",
    "issue_word_count": 198,
    "test_files_count": 1,
    "non_test_files_count": 15,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/support/locks/LockRegistry.java",
      "spring-integration-core/src/main/java/org/springframework/integration/util/CheckedCallable.java",
      "spring-integration-core/src/main/java/org/springframework/integration/util/CheckedFunction.java",
      "spring-integration-core/src/main/java/org/springframework/integration/util/CheckedRunnable.java",
      "spring-integration-core/src/main/java/org/springframework/integration/util/WhileLockedProcessor.java",
      "spring-integration-core/src/test/java/org/springframework/integration/support/locks/DefaultLockRegistryTests.java",
      "spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java",
      "spring-integration-jms/src/main/java/org/springframework/integration/jms/dsl/JmsInboundGatewaySpec.java",
      "src/reference/antora/modules/ROOT/nav.adoc",
      "src/reference/antora/modules/ROOT/pages/distributed-locks.adoc",
      "src/reference/antora/modules/ROOT/pages/message-store.adoc",
      "src/reference/antora/modules/ROOT/pages/meta-data-store.adoc",
      "src/reference/antora/modules/ROOT/pages/router/namespace.adoc",
      "src/reference/antora/modules/ROOT/pages/router/spel.adoc",
      "src/reference/antora/modules/ROOT/pages/scatter-gather.adoc",
      "src/reference/antora/modules/ROOT/pages/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/support/locks/DefaultLockRegistryTests.java"
    ],
    "base_commit": "ce5fabb22a63c0cc5c170d9a5a6764a374f1d67a",
    "head_commit": "7567c9b19bbe71f0fd0957ac3d67140d8ea77305",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8729",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8729",
    "dockerfile": "",
    "pr_merged_at": "2023-09-11T17:22:26.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/support/locks/LockRegistry.java b/spring-integration-core/src/main/java/org/springframework/integration/support/locks/LockRegistry.java\nindex 7fa229fb995..74d3cb80bbd 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/support/locks/LockRegistry.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/support/locks/LockRegistry.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,13 +16,20 @@\n \n package org.springframework.integration.support.locks;\n \n+import java.time.Duration;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.locks.Lock;\n \n+import org.springframework.integration.util.CheckedCallable;\n+import org.springframework.integration.util.CheckedRunnable;\n+\n /**\n  * Strategy for maintaining a registry of shared locks.\n  *\n  * @author Oleg Zhurakousky\n  * @author Gary Russell\n+ * @author Artem Bilan\n  *\n  * @since 2.1.1\n  */\n@@ -30,10 +37,98 @@\n public interface LockRegistry {\n \n \t/**\n-\t * Obtains the lock associated with the parameter object.\n+\t * Obtain the lock associated with the parameter object.\n \t * @param lockKey The object with which the lock is associated.\n \t * @return The associated lock.\n \t */\n \tLock obtain(Object lockKey);\n \n+\t/**\n+\t * Perform the provided task when the lock for the key is locked.\n+\t * @param lockKey the lock key to use\n+\t * @param runnable the {@link CheckedRunnable} to execute within a lock\n+\t * @param <E> type of exception runnable throws\n+\t * @throws InterruptedException from a lock operation\n+\t * @since 6.2\n+\t */\n+\tdefault <E extends Throwable> void executeLocked(Object lockKey, CheckedRunnable<E> runnable)\n+\t\t\tthrows E, InterruptedException {\n+\n+\t\texecuteLocked(lockKey,\n+\t\t\t\t() -> {\n+\t\t\t\t\trunnable.run();\n+\t\t\t\t\treturn null;\n+\t\t\t\t});\n+\t}\n+\n+\t/**\n+\t * Perform the provided task when the lock for the key is locked.\n+\t * @param lockKey the lock key to use\n+\t * @param callable the {@link CheckedCallable} to execute within a lock\n+\t * @param <T> type of callable result\n+\t * @param <E> type of exception callable throws\n+\t * @return the result of callable\n+\t * @throws InterruptedException from a lock operation\n+\t * @since 6.2\n+\t */\n+\tdefault <T, E extends Throwable> T executeLocked(Object lockKey, CheckedCallable<T, E> callable)\n+\t\t\tthrows E, InterruptedException {\n+\n+\t\tLock lock = obtain(lockKey);\n+\t\tlock.lockInterruptibly();\n+\t\ttry {\n+\t\t\treturn callable.call();\n+\t\t}\n+\t\tfinally {\n+\t\t\tlock.unlock();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Perform the provided task when the lock for the key is locked.\n+\t * @param lockKey the lock key to use\n+\t * @param waitLockDuration the {@link Duration} for {@link Lock#tryLock(long, TimeUnit)}\n+\t * @param runnable the {@link CheckedRunnable} to execute within a lock\n+\t * @param <E> type of exception runnable throws\n+\t * @throws InterruptedException from a lock operation\n+\t * @throws TimeoutException when {@link Lock#tryLock(long, TimeUnit)} has elapsed\n+\t * @since 6.2\n+\t */\n+\tdefault <E extends Throwable> void executeLocked(Object lockKey, Duration waitLockDuration,\n+\t\t\tCheckedRunnable<E> runnable) throws E, InterruptedException, TimeoutException {\n+\n+\t\texecuteLocked(lockKey, waitLockDuration,\n+\t\t\t\t() -> {\n+\t\t\t\t\trunnable.run();\n+\t\t\t\t\treturn null;\n+\t\t\t\t});\n+\t}\n+\n+\t/**\n+\t * Perform the provided task when the lock for the key is locked.\n+\t * @param lockKey the lock key to use\n+\t * @param waitLockDuration the {@link Duration} for {@link Lock#tryLock(long, TimeUnit)}\n+\t * @param callable the {@link CheckedCallable} to execute within a lock\n+\t * @param <E> type of exception callable throws\n+\t * @throws InterruptedException from a lock operation\n+\t * @throws TimeoutException when {@link Lock#tryLock(long, TimeUnit)} has elapsed\n+\t * @since 6.2\n+\t */\n+\tdefault <T, E extends Throwable> T executeLocked(Object lockKey, Duration waitLockDuration,\n+\t\t\tCheckedCallable<T, E> callable) throws E, InterruptedException, TimeoutException {\n+\n+\t\tLock lock = obtain(lockKey);\n+\t\tif (!lock.tryLock(waitLockDuration.toMillis(), TimeUnit.MILLISECONDS)) {\n+\t\t\tthrow new TimeoutException(\n+\t\t\t\t\t\"The lock [%s] was not acquired in time: %s\".formatted(lockKey, waitLockDuration));\n+\t\t}\n+\n+\t\ttry {\n+\t\t\treturn callable.call();\n+\t\t}\n+\t\tfinally {\n+\t\t\tlock.unlock();\n+\t\t}\n+\t}\n+\n }\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/util/CheckedCallable.java b/spring-integration-core/src/main/java/org/springframework/integration/util/CheckedCallable.java\nnew file mode 100644\nindex 00000000000..cb6200926f4\n--- /dev/null\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/util/CheckedCallable.java\n@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.util;\n+\n+/**\n+ * A Callable-like interface which allows throwing any Throwable.\n+ * Checked exceptions are wrapped in an IllegalStateException.\n+ *\n+ * @param <T> the output type.\n+ * @param <E> the throwable type.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 6.2\n+ */\n+@FunctionalInterface\n+public interface CheckedCallable<T, E extends Throwable> {\n+\n+\tT call() throws E;\n+\n+\tdefault Runnable unchecked() {\n+\t\treturn () -> {\n+\t\t\ttry {\n+\t\t\t\tcall();\n+\t\t\t}\n+\t\t\tcatch (Throwable t) { // NOSONAR\n+\t\t\t\tif (t instanceof RuntimeException runtimeException) { // NOSONAR\n+\t\t\t\t\tthrow runtimeException;\n+\t\t\t\t}\n+\t\t\t\telse if (t instanceof Error error) { // NOSONAR\n+\t\t\t\t\tthrow error;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthrow new IllegalStateException(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/util/CheckedFunction.java b/spring-integration-core/src/main/java/org/springframework/integration/util/CheckedFunction.java\nindex 72f18dc9743..d3890ab1d2a 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/util/CheckedFunction.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/util/CheckedFunction.java\n@@ -23,15 +23,16 @@\n  *\n  * @param <T> the input type.\n  * @param <R> the output type.\n+ * @param <E> the throwable type.\n  *\n  * @author Artem Bilan\n  *\n  * @since 6.1\n  */\n @FunctionalInterface\n-public interface CheckedFunction<T, R> {\n+public interface CheckedFunction<T, R, E extends Throwable> {\n \n-\tR apply(T t) throws Throwable; // NOSONAR\n+\tR apply(T t) throws E;\n \n \tdefault Function<T, R> unchecked() {\n \t\treturn t1 -> {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/util/CheckedRunnable.java b/spring-integration-core/src/main/java/org/springframework/integration/util/CheckedRunnable.java\nnew file mode 100644\nindex 00000000000..12b7ee757e5\n--- /dev/null\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/util/CheckedRunnable.java\n@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.util;\n+\n+/**\n+ * A Runnable-like interface which allows throwing any Throwable.\n+ * Checked exceptions are wrapped in an IllegalStateException.\n+ *\n+ * @param <E> the throwable type.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 6.2\n+ */\n+@FunctionalInterface\n+public interface CheckedRunnable<E extends Throwable> {\n+\n+\tvoid run() throws E;\n+\n+\tdefault Runnable unchecked() {\n+\t\treturn () -> {\n+\t\t\ttry {\n+\t\t\t\trun();\n+\t\t\t}\n+\t\t\tcatch (Throwable t) { // NOSONAR\n+\t\t\t\tif (t instanceof RuntimeException runtimeException) { // NOSONAR\n+\t\t\t\t\tthrow runtimeException;\n+\t\t\t\t}\n+\t\t\t\telse if (t instanceof Error error) { // NOSONAR\n+\t\t\t\t\tthrow error;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthrow new IllegalStateException(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/util/WhileLockedProcessor.java b/spring-integration-core/src/main/java/org/springframework/integration/util/WhileLockedProcessor.java\nindex 7f9d1fbd9cf..c076a0f76ba 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/util/WhileLockedProcessor.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/util/WhileLockedProcessor.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -30,10 +30,13 @@\n  * then call {@link #doWhileLocked()}.\n  *\n  * @author Oleg Zhurakousky\n+ * @author Artem Bilan\n  *\n  * @since 2.2\n  *\n+ * @deprecated since 6.2 in favor of {@link LockRegistry#executeLocked}.\n  */\n+@Deprecated(since = \"6.2\", forRemoval = true)\n public abstract class WhileLockedProcessor {\n \n \tprivate final Object key;\n\ndiff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java b/spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java\nindex 66225d26c26..7d6f9f7ba6c 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java\n@@ -19,6 +19,7 @@\n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n import java.io.BufferedWriter;\n+import java.io.Closeable;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n@@ -61,9 +62,9 @@\n import org.springframework.integration.support.locks.PassThruLockRegistry;\n import org.springframework.integration.support.management.ManageableLifecycle;\n import org.springframework.integration.support.utils.IntegrationUtils;\n-import org.springframework.integration.util.WhileLockedProcessor;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageHandlingException;\n+import org.springframework.messaging.MessagingException;\n import org.springframework.scheduling.TaskScheduler;\n import org.springframework.util.Assert;\n import org.springframework.util.StreamUtils;\n@@ -644,28 +645,29 @@ private File handleInputStreamMessage(InputStream sourceFileInputStream, File or\n \t\t\t\tFileExistsMode.APPEND.equals(this.fileExistsMode)\n \t\t\t\t\t\t|| FileExistsMode.APPEND_NO_FLUSH.equals(this.fileExistsMode);\n \n-\t\tif (append) {\n-\t\t\tfinal File fileToWriteTo = determineFileToWrite(resultFile, tempFile);\n-\n-\t\t\tWhileLockedProcessor whileLockedProcessor = new WhileLockedProcessor(this.lockRegistry,\n-\t\t\t\t\tfileToWriteTo.getAbsolutePath()) {\n+\t\tFile fileToCleanUpAfterCopy = tempFile;\n \n-\t\t\t\t@Override\n-\t\t\t\tprotected void whileLocked() throws IOException {\n-\t\t\t\t\tif (FileWritingMessageHandler.this.newFileCallback != null && !fileToWriteTo.exists()) {\n-\t\t\t\t\t\tFileWritingMessageHandler.this.newFileCallback.accept(fileToWriteTo, requestMessage);\n-\t\t\t\t\t}\n+\t\tif (append) {\n+\t\t\tFile fileToWriteTo = determineFileToWrite(resultFile, tempFile);\n \n-\t\t\t\t\tappendStreamToFile(fileToWriteTo, sourceFileInputStream);\n-\t\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tthis.lockRegistry.executeLocked(fileToWriteTo.getAbsolutePath(),\n+\t\t\t\t\t\t() -> {\n+\t\t\t\t\t\t\tif (this.newFileCallback != null && !fileToWriteTo.exists()) {\n+\t\t\t\t\t\t\t\tthis.newFileCallback.accept(fileToWriteTo, requestMessage);\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tappendStreamToFile(fileToWriteTo, sourceFileInputStream);\n+\t\t\t\t\t\t});\n+\t\t\t}\n+\t\t\tcatch (InterruptedException ex) {\n+\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t\tthrow new MessagingException(requestMessage, \"Thread was interrupted while performing task\", ex);\n+\t\t\t}\n \n-\t\t\t};\n-\t\t\twhileLockedProcessor.doWhileLocked();\n-\t\t\tcleanUpAfterCopy(fileToWriteTo, resultFile, originalFile);\n-\t\t\treturn resultFile;\n+\t\t\tfileToCleanUpAfterCopy = fileToWriteTo;\n \t\t}\n \t\telse {\n-\n \t\t\ttry (InputStream inputStream = sourceFileInputStream; OutputStream outputStream =\n \t\t\t\t\tnew BufferedOutputStream(new FileOutputStream(tempFile), this.bufferSize)) {\n \n@@ -679,9 +681,10 @@ protected void whileLocked() throws IOException {\n \t\t\t\t}\n \t\t\t\toutputStream.flush();\n \t\t\t}\n-\t\t\tcleanUpAfterCopy(tempFile, resultFile, originalFile);\n-\t\t\treturn resultFile;\n \t\t}\n+\n+\t\tcleanUpAfterCopy(fileToCleanUpAfterCopy, resultFile, originalFile);\n+\t\treturn resultFile;\n \t}\n \n \tprivate void appendStreamToFile(File fileToWriteTo, InputStream sourceFileInputStream) throws IOException {\n@@ -694,25 +697,29 @@ private void appendStreamToFile(File fileToWriteTo, InputStream sourceFileInputS\n \t\t\twhile ((bytesRead = inputStream.read(buffer)) != -1) { // NOSONAR\n \t\t\t\tbos.write(buffer, 0, bytesRead);\n \t\t\t}\n-\t\t\tif (FileWritingMessageHandler.this.appendNewLine) {\n+\t\t\tif (this.appendNewLine) {\n \t\t\t\tbos.write(System.lineSeparator().getBytes());\n \t\t\t}\n \t\t}\n \t\tfinally {\n-\t\t\ttry {\n-\t\t\t\tif (state == null || FileWritingMessageHandler.this.flushTask == null) {\n-\t\t\t\t\tif (bos != null) {\n-\t\t\t\t\t\tbos.close();\n-\t\t\t\t\t}\n-\t\t\t\t\tclearState(fileToWriteTo, state);\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tstate.lastWrite = System.currentTimeMillis();\n+\t\t\tcleanUpFileState(fileToWriteTo, state, bos);\n+\t\t}\n+\t}\n+\n+\tprivate void cleanUpFileState(File fileToWriteTo, FileState state, Closeable closeable) {\n+\t\ttry {\n+\t\t\tif (state == null || this.flushTask == null) {\n+\t\t\t\tif (closeable != null) {\n+\t\t\t\t\tcloseable.close();\n \t\t\t\t}\n+\t\t\t\tclearState(fileToWriteTo, state);\n \t\t\t}\n-\t\t\tcatch (IOException ex) {\n+\t\t\telse {\n+\t\t\t\tstate.lastWrite = System.currentTimeMillis();\n \t\t\t}\n \t\t}\n+\t\tcatch (IOException ex) {\n+\t\t}\n \t}\n \n \tprivate File handleByteArrayMessage(byte[] bytes, File originalFile, File tempFile, File resultFile,\n@@ -723,20 +730,21 @@ private File handleByteArrayMessage(byte[] bytes, File originalFile, File tempFi\n \t\tboolean append = FileExistsMode.APPEND.equals(this.fileExistsMode)\n \t\t\t\t|| FileExistsMode.APPEND_NO_FLUSH.equals(this.fileExistsMode);\n \n-\t\tWhileLockedProcessor whileLockedProcessor = new WhileLockedProcessor(this.lockRegistry,\n-\t\t\t\tfileToWriteTo.getAbsolutePath()) {\n-\n-\t\t\t@Override\n-\t\t\tprotected void whileLocked() throws IOException {\n-\t\t\t\tif (append && FileWritingMessageHandler.this.newFileCallback != null && !fileToWriteTo.exists()) {\n-\t\t\t\t\tFileWritingMessageHandler.this.newFileCallback.accept(fileToWriteTo, requestMessage);\n-\t\t\t\t}\n-\n-\t\t\t\twriteBytesToFile(fileToWriteTo, append, bytes);\n-\t\t\t}\n+\t\ttry {\n+\t\t\tthis.lockRegistry.executeLocked(fileToWriteTo.getAbsolutePath(),\n+\t\t\t\t\t() -> {\n+\t\t\t\t\t\tif (append && this.newFileCallback != null && !fileToWriteTo.exists()) {\n+\t\t\t\t\t\t\tthis.newFileCallback.accept(fileToWriteTo, requestMessage);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\twriteBytesToFile(fileToWriteTo, append, bytes);\n+\t\t\t\t\t});\n+\t\t}\n+\t\tcatch (InterruptedException ex) {\n+\t\t\tThread.currentThread().interrupt();\n+\t\t\tthrow new MessagingException(requestMessage, \"Thread was interrupted while performing task\", ex);\n+\t\t}\n \n-\t\t};\n-\t\twhileLockedProcessor.doWhileLocked();\n \t\tcleanUpAfterCopy(fileToWriteTo, resultFile, originalFile);\n \t\treturn resultFile;\n \t}\n@@ -752,19 +760,7 @@ private void writeBytesToFile(File fileToWriteTo, boolean append, byte[] bytes)\n \t\t\t}\n \t\t}\n \t\tfinally {\n-\t\t\ttry {\n-\t\t\t\tif (state == null || this.flushTask == null) {\n-\t\t\t\t\tif (bos != null) {\n-\t\t\t\t\t\tbos.close();\n-\t\t\t\t\t}\n-\t\t\t\t\tclearState(fileToWriteTo, state);\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tstate.lastWrite = System.currentTimeMillis();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcatch (IOException ex) {\n-\t\t\t}\n+\t\t\tcleanUpFileState(fileToWriteTo, state, bos);\n \t\t}\n \t}\n \n@@ -776,20 +772,21 @@ private File handleStringMessage(String content, File originalFile, File tempFil\n \t\tboolean append = FileExistsMode.APPEND.equals(this.fileExistsMode)\n \t\t\t\t|| FileExistsMode.APPEND_NO_FLUSH.equals(this.fileExistsMode);\n \n-\t\tWhileLockedProcessor whileLockedProcessor = new WhileLockedProcessor(this.lockRegistry,\n-\t\t\t\tfileToWriteTo.getAbsolutePath()) {\n-\n-\t\t\t@Override\n-\t\t\tprotected void whileLocked() throws IOException {\n-\t\t\t\tif (append && FileWritingMessageHandler.this.newFileCallback != null && !fileToWriteTo.exists()) {\n-\t\t\t\t\tFileWritingMessageHandler.this.newFileCallback.accept(fileToWriteTo, requestMessage);\n-\t\t\t\t}\n-\n-\t\t\t\twriteStringToFile(fileToWriteTo, append, content);\n-\t\t\t}\n \n-\t\t};\n-\t\twhileLockedProcessor.doWhileLocked();\n+\t\ttry {\n+\t\t\tthis.lockRegistry.executeLocked(fileToWriteTo.getAbsolutePath(),\n+\t\t\t\t\t() -> {\n+\t\t\t\t\t\tif (append && this.newFileCallback != null && !fileToWriteTo.exists()) {\n+\t\t\t\t\t\t\tthis.newFileCallback.accept(fileToWriteTo, requestMessage);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\twriteStringToFile(fileToWriteTo, append, content);\n+\t\t\t\t\t});\n+\t\t}\n+\t\tcatch (InterruptedException ex) {\n+\t\t\tThread.currentThread().interrupt();\n+\t\t\tthrow new MessagingException(requestMessage, \"Thread was interrupted while performing task\", ex);\n+\t\t}\n \n \t\tcleanUpAfterCopy(fileToWriteTo, resultFile, originalFile);\n \t\treturn resultFile;\n@@ -806,19 +803,7 @@ private void writeStringToFile(File fileToWriteTo, boolean append, String conten\n \t\t\t}\n \t\t}\n \t\tfinally {\n-\t\t\ttry {\n-\t\t\t\tif (state == null || FileWritingMessageHandler.this.flushTask == null) {\n-\t\t\t\t\tif (writer != null) {\n-\t\t\t\t\t\twriter.close();\n-\t\t\t\t\t}\n-\t\t\t\t\tclearState(fileToWriteTo, state);\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tstate.lastWrite = System.currentTimeMillis();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcatch (IOException ex) {\n-\t\t\t}\n+\t\t\tcleanUpFileState(fileToWriteTo, state, writer);\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-jms/src/main/java/org/springframework/integration/jms/dsl/JmsInboundGatewaySpec.java b/spring-integration-jms/src/main/java/org/springframework/integration/jms/dsl/JmsInboundGatewaySpec.java\nindex d84d45a7033..22e1d4548ec 100644\n--- a/spring-integration-jms/src/main/java/org/springframework/integration/jms/dsl/JmsInboundGatewaySpec.java\n+++ b/spring-integration-jms/src/main/java/org/springframework/integration/jms/dsl/JmsInboundGatewaySpec.java\n@@ -19,6 +19,7 @@\n import java.util.function.Consumer;\n \n import jakarta.jms.Destination;\n+import jakarta.jms.JMSException;\n import jakarta.jms.Message;\n \n import org.springframework.expression.Expression;\n@@ -162,7 +163,7 @@ public S replyToExpression(String replyToExpression) {\n \t * @since 6.1\n \t * @see ChannelPublishingJmsMessageListener#setReplyToExpression(Expression)\n \t */\n-\tpublic S replyToFunction(CheckedFunction<Message, ?> replyToFunction) {\n+\tpublic S replyToFunction(CheckedFunction<Message, ?, JMSException> replyToFunction) {\n \t\treturn replyToExpression(new FunctionExpression<>(replyToFunction.unchecked()));\n \t}\n \n\ndiff --git a/src/reference/antora/modules/ROOT/nav.adoc b/src/reference/antora/modules/ROOT/nav.adoc\nindex 3fa30b40deb..e641cfacb6b 100644\n--- a/src/reference/antora/modules/ROOT/nav.adoc\n+++ b/src/reference/antora/modules/ROOT/nav.adoc\n@@ -94,6 +94,7 @@\n ** xref:message-history.adoc[]\n ** xref:message-store.adoc[]\n ** xref:meta-data-store.adoc[]\n+** xref:distributed-locks.adoc[]\n ** xref:control-bus.adoc[]\n ** xref:shutdown.adoc[]\n ** xref:graph.adoc[]\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/distributed-locks.adoc b/src/reference/antora/modules/ROOT/pages/distributed-locks.adoc\nnew file mode 100644\nindex 00000000000..fca279b8f46\n--- /dev/null\n+++ b/src/reference/antora/modules/ROOT/pages/distributed-locks.adoc\n@@ -0,0 +1,37 @@\n+[[distributed-locks]]\n+= Distributed Locks\n+\n+In many situations the action against some context (or even single message) has to be performed in an exclusive manner.\n+One example is an aggregator component where we have to check the message group state for the current message to determine whether we can release the group or just add that message for future consideration.\n+For this purpose Java provides an API with `java.util.concurrent.locks.Lock` implementations.\n+However, the problem becomes more complex when an application is distributed and/or run in the cluster.\n+The locking in this case is challenging and requires some shared state and its specific approach to achieve the exclusivity requirement.\n+\n+Spring Integration provides a `LockRegistrty` abstraction with an in-memory `DefaultLockRegistry` implementation based on the `ReentrantLock` API.\n+The `obtain(Object)` method of the `LockRegistrty` requires a `lock key` for specific context.\n+For example, an aggregator uses a `correlationKey` to lock operations around its group.\n+This way different locks can be used concurrently.\n+This `obtain(Object)` method returns a `java.util.concurrent.locks.Lock` instance (depending on the `LockRegistry` implementation), therefore the rest of the logic is the same as standard Java Concurrency algorithm.\n+\n+Starting with version 6.2, the `LockRegistry` provides an `executeLocked()` API (`default` methods in this interface) to perform some task while locked.\n+The behavior of this API is similar to well-known `JdbcTemplate`, `JmsTemplate` or `RestTemplate`.\n+The following example demonstrates the usage of this API:\n+\n+[source,java]\n+----\n+LockRegistry registry = new DefaultLockRegistry();\n+...\n+registry.executeLocked(\"someLockKey\", () -> someExclusiveResourceCall());\n+----\n+\n+The method rethrows an exception from the task call, throws an `InterruptedException` if `Lock` is interrupted.\n+In addition, a variant with `Duration` throws a `java.util.concurrent.TimeoutException` when `lock.tryLock()` returns `false`.\n+\n+Spring Integration provides these `LockRegistrty` implementations for distributed locks:\n+\n+* xref:hazelcast.adoc#hazelcast-lock-registry[Hazelcast]\n+* xref:jdbc/lock-registry.adoc[JDBC]\n+* xref:redis.adoc#redis-lock-registry[Redis]\n+* xref:zookeeper.adoc#zk-lock-registry[Zookeeper]\n+\n+https://github.com/spring-projects/spring-integration-aws[Spring Integration AWS] extension also implements a `DynamoDbLockRegistry`.\n\\ No newline at end of file\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/message-store.adoc b/src/reference/antora/modules/ROOT/pages/message-store.adoc\nindex 8c8d5f26a3d..3688e452bdf 100644\n--- a/src/reference/antora/modules/ROOT/pages/message-store.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/message-store.adoc\n@@ -27,7 +27,7 @@ The following pair of examples show how to add a reference to a message store fo\n .Aggregator\n [source,xml]\n ----\n-<int:aggregator  message-store=\"refToMessageStore\"/>\n+<int:aggregator message-store=\"refToMessageStore\"/>\n ----\n \n By default, messages are stored in-memory by using `o.s.i.store.SimpleMessageStore`, an implementation of `MessageStore`.\n@@ -151,7 +151,7 @@ The `MessageGroupStore` exposes a `setGroupCondition(Object groupId, String cond\n For this purpose a `setGroupConditionSupplier(BiFunction<Message<?>, String, String>)` option has been added to the `AbstractCorrelatingMessageHandler`.\n This function is evaluated against each message after it has been added to the group as well as the existing condition of the group.\n The implementation may decide to return a new value, the existing value, or reset the target condition to `null`.\n-The value for a `condition` can be a JSON, SpEL expression, number or anything what can be serialized as a string and parsed afterwards.\n+The value for a `condition` can be a JSON, SpEL expression, number or anything what can be serialized as a string and parsed afterward.\n For example, the `FileMarkerReleaseStrategy` from the xref:file/aggregator.adoc[File Aggregator] component, populates a condition into a group from the `FileHeaders.LINE_COUNT` header of the `FileSplitter.FileMarker.Mark.END` message and consults with it from its `canRelease()` comparing a group size with the value in this condition.\n This way it doesn't iterate all the messages in group to find a `FileSplitter.FileMarker.Mark.END` message with the `FileHeaders.LINE_COUNT` header.\n It also allows the end marker to arrive at the aggregator before all the other records; for example when processing a file in a multi-threaded environment.\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/meta-data-store.adoc b/src/reference/antora/modules/ROOT/pages/meta-data-store.adoc\nindex 33c06004f7a..6d99d43b831 100644\n--- a/src/reference/antora/modules/ROOT/pages/meta-data-store.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/meta-data-store.adoc\n@@ -15,7 +15,7 @@ If you need to persist metadata between application context restarts, the framew\n \n * `PropertiesPersistingMetadataStore`\n * xref:hazelcast.adoc#hazelcast-metadata-store[Hazelcast Metadata Store]\n-* xref:jdbc.adoc#jdbc-metadata-store[JDBC Metadata Store]\n+* xref:jdbc/metadata-store.adoc[JDBC Metadata Store]\n * xref:mongodb.adoc#mongodb-metadata-store[MongoDB Metadata Store]\n * xref:redis.adoc#redis-metadata-store[Redis Metadata Store]\n * xref:zookeeper.adoc#zk-metadata-store[Zookeeper Metadata Store]\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/router/namespace.adoc b/src/reference/antora/modules/ROOT/pages/router/namespace.adoc\nindex 441cb882ee7..854804f55f4 100644\n--- a/src/reference/antora/modules/ROOT/pages/router/namespace.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/router/namespace.adoc\n@@ -4,8 +4,7 @@\n Spring Integration provides a generic router.\n You can use it for general-purpose routing (as opposed to the other routers provided by Spring Integration, each of which has some form of specialization).\n \n-[[configuring-a-content-based-router-with-xml]]\n-== Configuring a Content-based Router with XML\n+The following section explains a router configuration with an XML components.\n \n The `router` element provides a way to connect a router to an input channel and also accepts the optional `default-output-channel` attribute.\n The `ref` attribute references the bean name of a custom router implementation (which must extend `AbstractMessageRouter`).\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/router/spel.adoc b/src/reference/antora/modules/ROOT/pages/router/spel.adoc\nindex 5e3ebee298c..994f629c86a 100644\n--- a/src/reference/antora/modules/ROOT/pages/router/spel.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/router/spel.adoc\n@@ -4,7 +4,7 @@\n Sometimes, the routing logic may be simple, and writing a separate class for it and configuring it as a bean may seem like overkill.\n As of Spring Integration 2.0, we offer an alternative that lets you use SpEL to implement simple computations that previously required a custom POJO router.\n \n-NOTE: For more information about the Spring Expression Language, see the https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions[relevant chapter in the Spring Framework Reference Guide].\n+NOTE: For more information about the Spring Expression Language, see the https://docs.spring.io/spring-framework/reference/core/expressions.html[relevant chapter in the Spring Framework Reference Guide].\n \n Generally, a SpEL expression is evaluated and its result is mapped to a channel, as the following example shows:\n \n@@ -69,6 +69,6 @@ In the above configuration, if the message includes a header with a name of 'cha\n You may also find collection projection and collection selection expressions useful when you need to select multiple channels.\n For further information, see:\n \n-* https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#expressions-collection-projection[Collection Projection]\n-* https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#expressions-collection-selection[Collection Selection]\n+* https://docs.spring.io/spring-framework/reference/core/expressions/language-ref/collection-projection.html[Collection Projection]\n+* https://docs.spring.io/spring-framework/reference/core/expressions/language-ref/collection-selection.html[Collection Selection]\n \n\ndiff --git a/src/reference/antora/modules/ROOT/pages/scatter-gather.adoc b/src/reference/antora/modules/ROOT/pages/scatter-gather.adoc\nindex 7137846eaa3..9f78c5e2595 100644\n--- a/src/reference/antora/modules/ROOT/pages/scatter-gather.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/scatter-gather.adoc\n@@ -108,7 +108,7 @@ The following example shows how to configure the `<scatter-gather>` endpoint by\n <1> The id of the endpoint.\n The `ScatterGatherHandler` bean is registered with an alias of `id + '.handler'`.\n The `RecipientListRouter` bean is registered with an alias of `id + '.scatterer'`.\n-The `AggregatingMessageHandler`bean is registered with an alias of `id + '.gatherer'`.\n+The `AggregatingMessageHandler` bean is registered with an alias of `id + '.gatherer'`.\n Optional.\n (The `BeanFactory` generates a default `id` value.)\n <2> Lifecycle attribute signaling whether the endpoint should be started during application context initialization.\n@@ -171,7 +171,7 @@ This way all other sub-flows will work for nothing and their replies are going t\n This might be an expected behavior sometimes, but in most cases it would be better to handle the error in the particular sub-flow without impacting all others and the expectations in the gatherer.\n \n Starting with version 5.1.3, the `ScatterGatherHandler` is supplied with the `errorChannelName` option.\n-It is populated to the `errorChannel` header of the scatter message and is used in the  when async error happens or can be used in the regular synchronous sub-flow for directly sending an error message.\n+It is populated to the `errorChannel` header of the scatter message and is used when an async error happens or can be used in the regular synchronous sub-flow for directly sending an error message.\n \n The sample configuration below demonstrates async error handling by returning a compensation message:\n \n\ndiff --git a/src/reference/antora/modules/ROOT/pages/whats-new.adoc b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\nindex c7fd7eb5f5d..d3c28f2578f 100644\n--- a/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n@@ -31,13 +31,16 @@ See xref:debezium.adoc[Debezium Support] for more information.\n See xref:endpoint.adoc#endpoint-pollingconsumer[Polling Consumer] for more information.\n \n - Java, Groovy and Kotlin DSLs have now context-specific methods in the `IntegrationFlowDefinition` with a single `Consumer` argument to configure an endpoint and its handler with one builder and readable options.\n-See, for example, `transformWith()`, `splitWith()` in xref:dsl.adoc#java-dsl[ Java DSL Chapter].\n+See, for example, `transformWith()`, `splitWith()` in xref:dsl.adoc#java-dsl[Java DSL Chapter].\n \n - A new `spring.integration.endpoints.defaultTimeout` global property has been introduced to override the default 30 seconds timeout for all the endpoints in the application.\n See xref:configuration/global-properties.adoc[Global Properties] for more information.\n \n - The `@MessagingGateway` and `GatewayEndpointSpec` provided by the Java DSL now expose the `errorOnTimeout` property of the internal `MethodInvocationGateway` extension of the `MessagingGatewaySupport`.\n-See xref:gateway.adoc#gateway-no-response[ Gateway Behavior When No response Arrives] for more information.\n+See xref:gateway.adoc#gateway-no-response[Gateway Behavior When No response Arrives] for more information.\n+\n+- The `LockRegistry` provides template-like API to execute provided task while locked.\n+See xref:distributed-locks.adoc[Distributed Locks] for more information.\n \n [[x6.2-websockets]]\n === WebSockets Changes\n@@ -55,7 +58,7 @@ See xref:kafka.adoc#kafka-inbound-pollable[Kafka Inbound Channel Adapter] for mo\n [[x6.2-jdbc]]\n === JDBC Support Changes\n \n-The `JdbcMessageStore`, `JdbcChannelMessageStore`, `JdbcMetadataStore`, and `DefaultLockRepository` implement `SmartLifecycle` and perform a`SELECT COUNT` query, on their respective tables, in the `start()` method to ensure that the required table (according to the provided prefix) is present in the target database.\n+The `JdbcMessageStore`, `JdbcChannelMessageStore`, `JdbcMetadataStore`, and `DefaultLockRepository` implement `SmartLifecycle` and perform a `SELECT COUNT` query, on their respective tables, in the `start()` method to ensure that the required table (according to the provided prefix) is present in the target database.\n See xref:jdbc/message-store.adoc#jdbc-db-init[Initializing the Database] for more information.\n \n [[x6.2-mongodb]]\n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/support/locks/DefaultLockRegistryTests.java b/spring-integration-core/src/test/java/org/springframework/integration/support/locks/DefaultLockRegistryTests.java\nindex d9de078724d..c6420e500b5 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/support/locks/DefaultLockRegistryTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/support/locks/DefaultLockRegistryTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,28 +16,42 @@\n \n package org.springframework.integration.support.locks;\n \n+import java.time.Duration;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n import java.util.concurrent.locks.Lock;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n \n /**\n  * @author Gary Russell\n  * @author Oleg Zhurakousky\n+ * @author Artem Bilan\n+ *\n  * @since 2.1.1\n  *\n  */\n public class DefaultLockRegistryTests {\n \n-\t@Test(expected = IllegalArgumentException.class)\n+\t@Test\n \tpublic void testBadMask() {\n-\t\tnew DefaultLockRegistry(4);\n+\t\tassertThatIllegalArgumentException()\n+\t\t\t\t.isThrownBy(() -> new DefaultLockRegistry(4));\n \t}\n \n-\t@Test(expected = IllegalArgumentException.class)\n+\t@Test\n \tpublic void testBadMaskOutOfRange() { // 32bits\n-\t\tnew DefaultLockRegistry(0xffffffff);\n+\t\tassertThatIllegalArgumentException()\n+\t\t\t\t.isThrownBy(() -> new DefaultLockRegistry(0xffffffff));\n \t}\n \n \t@Test\n@@ -197,4 +211,70 @@ public int hashCode() {\n \t\tassertThat(moreLocks[3]).isSameAs(locks[3]);\n \t}\n \n+\t@Test\n+\tpublic void cyclicBarrierIsBrokenWhenExecutedConcurrentlyInLock() throws Exception {\n+\t\tLockRegistry registry = new DefaultLockRegistry(1);\n+\n+\t\tCyclicBarrier cyclicBarrier = new CyclicBarrier(2);\n+\t\tCountDownLatch brokenBarrierLatch = new CountDownLatch(2);\n+\n+\t\tRunnable runnableLocked = () -> {\n+\t\t\ttry {\n+\t\t\t\tregistry.executeLocked(\"lockKey\",\n+\t\t\t\t\t\t() -> {\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\tcyclicBarrier.await(1, TimeUnit.SECONDS);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcatch (BrokenBarrierException | TimeoutException e) {\n+\t\t\t\t\t\t\t\tbrokenBarrierLatch.countDown();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t}\n+\t\t\tcatch (Exception e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t};\n+\n+\t\tExecutorService executorService = Executors.newCachedThreadPool();\n+\n+\t\texecutorService.execute(runnableLocked);\n+\t\texecutorService.execute(runnableLocked);\n+\n+\t\tassertThat(brokenBarrierLatch.await(10, TimeUnit.SECONDS)).isTrue();\n+\t}\n+\n+\t@Test\n+\tpublic void executeLockedIsTimedOutInOtherThread() throws Exception {\n+\t\tLockRegistry registry = new DefaultLockRegistry(1);\n+\n+\t\tString lockKey = \"lockKey\";\n+\t\tDuration waitLockDuration = Duration.ofMillis(100);\n+\n+\t\tCountDownLatch timeoutExceptionLatch = new CountDownLatch(1);\n+\t\tAtomicReference<TimeoutException> exceptionAtomicReference = new AtomicReference<>();\n+\n+\t\tRunnable runnable = () -> {\n+\t\t\ttry {\n+\t\t\t\tregistry.executeLocked(lockKey, waitLockDuration, () -> Thread.sleep(200));\n+\t\t\t}\n+\t\t\tcatch (TimeoutException e) {\n+\t\t\t\texceptionAtomicReference.set(e);\n+\t\t\t\ttimeoutExceptionLatch.countDown();\n+\t\t\t}\n+\t\t\tcatch (Exception e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t};\n+\n+\t\tExecutorService executorService = Executors.newCachedThreadPool();\n+\n+\t\texecutorService.execute(runnable);\n+\t\texecutorService.execute(runnable);\n+\n+\t\tassertThat(timeoutExceptionLatch.await(10, TimeUnit.SECONDS)).isTrue();\n+\t\tassertThat(exceptionAtomicReference.get())\n+\t\t\t\t.hasMessage(\"The lock [%s] was not acquired in time: %s\".formatted(lockKey, waitLockDuration));\n+\t}\n+\n }\n+\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8722",
    "pr_id": 8722,
    "issue_id": 8720,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "The MQTT protocol doesn't allow an empty topic value nor for publisihng neither for subscribing\n**In what version(s) of Spring Integration are you seeing this issue?**\r\n\r\nFor example:\r\n\r\n6.0.7\r\n\r\n**Describe the bug**\r\n\r\nA clear and concise description of what the bug is.\r\n\r\n**To Reproduce**\r\n\r\nAbstractMqttMessageDrivenChannelAdapter#initTopics\r\nThe initTopics method of the AbstractMqttMessageDrivenChannelAdapter class does not check if the topic is an empty string\r\n\r\nif empty string\r\n\r\nMqttPahoMessageDrivenChannelAdapter#subscribe\r\nThe subscription part in the subscribe method in the MqttPahoMessageDrivenChannelAdapter class will report an error\r\n`IMqttToken subscribeToken = this.client.subscribe(topics, requestedQos, listeners);`\r\n\r\n**Expected behavior**\r\n\r\nA verification mechanism should be added\r\n\r\n**Sample**\r\n\r\n\r\n\r\n\r\nIMqttToken subscribeToken = this.client.subscribe(topics, requestedQos, listeners);    \r\nWill report an error",
    "issue_word_count": 116,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/AbstractMqttMessageDrivenChannelAdapter.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java",
      "spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/MqttAdapterTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/MqttAdapterTests.java"
    ],
    "base_commit": "7d4e7e9779bef847049cce5749670ecb01f7695a",
    "head_commit": "932a633c7b9e8b4b0ca6886da6bf821c2d0e65d3",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8722",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8722",
    "dockerfile": "",
    "pr_merged_at": "2023-09-13T13:43:36.000Z",
    "patch": "diff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/AbstractMqttMessageDrivenChannelAdapter.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/AbstractMqttMessageDrivenChannelAdapter.java\nindex 6712b00687d..a6f76bdfd18 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/AbstractMqttMessageDrivenChannelAdapter.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/AbstractMqttMessageDrivenChannelAdapter.java\n@@ -94,14 +94,22 @@ public AbstractMqttMessageDrivenChannelAdapter(ClientManager<T, C> clientManager\n \t\tthis.clientId = null;\n \t}\n \n-\tprivate static Map<String, Integer> initTopics(String[] topic) {\n-\t\tAssert.notNull(topic, \"'topics' cannot be null\");\n-\t\tAssert.noNullElements(topic, \"'topics' cannot have null elements\");\n+\tprivate static Map<String, Integer> initTopics(String[] topics) {\n+\t\tvalidateTopics(topics);\n \n-\t\treturn Arrays.stream(topic)\n+\t\treturn Arrays.stream(topics)\n \t\t\t\t.collect(Collectors.toMap(Function.identity(), (key) -> 1, (x, y) -> y, LinkedHashMap::new));\n \t}\n \n+\tprivate static void validateTopics(String[] topics) {\n+\t\tAssert.notNull(topics, \"'topics' cannot be null\");\n+\t\tAssert.noNullElements(topics, \"'topics' cannot have null elements\");\n+\n+\t\tfor (String topic : topics) {\n+\t\t\tAssert.hasText(topic, \"The topic to subscribe cannot be empty string\");\n+\t\t}\n+\t}\n+\n \tpublic void setConverter(MqttMessageConverter converter) {\n \t\tAssert.notNull(converter, \"'converter' cannot be null\");\n \t\tthis.converter = converter;\n@@ -178,7 +186,7 @@ public String[] getTopic() {\n \n \t/**\n \t * Set the completion timeout when disconnecting.\n-\t * Default {@value #DISCONNECT_COMPLETION_TIMEOUT} milliseconds.\n+\t * Default {@value ClientManager#DISCONNECT_COMPLETION_TIMEOUT} milliseconds.\n \t * @param completionTimeout The timeout.\n \t * @since 5.1.10\n \t */\n@@ -256,6 +264,7 @@ protected long getCompletionTimeout() {\n \t */\n \t@ManagedOperation\n \tpublic void addTopic(String topic, int qos) {\n+\t\tvalidateTopics(new String[] {topic});\n \t\tthis.topicLock.lock();\n \t\ttry {\n \t\t\tif (this.topics.containsKey(topic)) {\n@@ -271,16 +280,16 @@ public void addTopic(String topic, int qos) {\n \n \t/**\n \t * Add a topic (or topics) to the subscribed list (qos=1).\n-\t * @param topic The topics.\n-\t * @throws MessagingException if the topic is already in the list.\n+\t * @param topics The topics.\n+\t * @throws MessagingException if the topics is already in the list.\n \t * @since 4.1\n \t */\n \t@ManagedOperation\n-\tpublic void addTopic(String... topic) {\n-\t\tAssert.notNull(topic, \"'topic' cannot be null\");\n+\tpublic void addTopic(String... topics) {\n+\t\tvalidateTopics(topics);\n \t\tthis.topicLock.lock();\n \t\ttry {\n-\t\t\tfor (String t : topic) {\n+\t\t\tfor (String t : topics) {\n \t\t\t\taddTopic(t, 1);\n \t\t\t}\n \t\t}\n@@ -291,25 +300,24 @@ public void addTopic(String... topic) {\n \n \t/**\n \t * Add topics to the subscribed list.\n-\t * @param topic The topics.\n+\t * @param topics The topics.\n \t * @param qos The qos for each topic.\n-\t * @throws MessagingException if a topic is already in the list.\n+\t * @throws MessagingException if a topics is already in the list.\n \t * @since 4.1\n \t */\n \t@ManagedOperation\n-\tpublic void addTopics(String[] topic, int[] qos) {\n-\t\tAssert.notNull(topic, \"'topic' cannot be null.\");\n-\t\tAssert.noNullElements(topic, \"'topic' cannot contain any null elements.\");\n-\t\tAssert.isTrue(topic.length == qos.length, \"topic and qos arrays must the be the same length.\");\n+\tpublic void addTopics(String[] topics, int[] qos) {\n+\t\tvalidateTopics(topics);\n+\t\tAssert.isTrue(topics.length == qos.length, \"topics and qos arrays must the be the same length.\");\n \t\tthis.topicLock.lock();\n \t\ttry {\n-\t\t\tfor (String newTopic : topic) {\n+\t\t\tfor (String newTopic : topics) {\n \t\t\t\tif (this.topics.containsKey(newTopic)) {\n \t\t\t\t\tthrow new MessagingException(\"Topic '\" + newTopic + \"' is already subscribed.\");\n \t\t\t\t}\n \t\t\t}\n-\t\t\tfor (int i = 0; i < topic.length; i++) {\n-\t\t\t\taddTopic(topic[i], qos[i]);\n+\t\t\tfor (int i = 0; i < topics.length; i++) {\n+\t\t\t\taddTopic(topics[i], qos[i]);\n \t\t\t}\n \t\t}\n \t\tfinally {\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java\nindex 6054f6b7fe3..4b43a6722c9 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,6 +20,7 @@\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n \n+import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryAware;\n import org.springframework.context.ApplicationEventPublisher;\n import org.springframework.context.ApplicationEventPublisherAware;\n@@ -126,6 +127,7 @@ protected ApplicationEventPublisher getApplicationEventPublisher() {\n \t * @param defaultTopic the default topic.\n \t */\n \tpublic void setDefaultTopic(String defaultTopic) {\n+\t\tAssert.hasText(defaultTopic, \"'defaultTopic' must not be empty\");\n \t\tthis.defaultTopic = defaultTopic;\n \t}\n \n@@ -320,14 +322,17 @@ protected ClientManager<T, C> getClientManager() {\n \t@Override\n \tprotected void onInit() {\n \t\tsuper.onInit();\n-\t\tif (this.topicProcessor instanceof BeanFactoryAware && getBeanFactory() != null) {\n-\t\t\t((BeanFactoryAware) this.topicProcessor).setBeanFactory(getBeanFactory());\n-\t\t}\n-\t\tif (this.qosProcessor instanceof BeanFactoryAware && getBeanFactory() != null) {\n-\t\t\t((BeanFactoryAware) this.qosProcessor).setBeanFactory(getBeanFactory());\n-\t\t}\n-\t\tif (this.retainedProcessor instanceof BeanFactoryAware && getBeanFactory() != null) {\n-\t\t\t((BeanFactoryAware) this.retainedProcessor).setBeanFactory(getBeanFactory());\n+\t\tBeanFactory beanFactory = getBeanFactory();\n+\t\tif (beanFactory != null) {\n+\t\t\tif (this.topicProcessor instanceof BeanFactoryAware beanFactoryAware) {\n+\t\t\t\tbeanFactoryAware.setBeanFactory(beanFactory);\n+\t\t\t}\n+\t\t\tif (this.qosProcessor instanceof BeanFactoryAware beanFactoryAware) {\n+\t\t\t\tbeanFactoryAware.setBeanFactory(beanFactory);\n+\t\t\t}\n+\t\t\tif (this.retainedProcessor instanceof BeanFactoryAware beanFactoryAware) {\n+\t\t\t\tbeanFactoryAware.setBeanFactory(beanFactory);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -358,11 +363,13 @@ public boolean isRunning() {\n \tprotected void handleMessageInternal(Message<?> message) {\n \t\tObject mqttMessage = this.converter.fromMessage(message, Object.class);\n \t\tString topic = this.topicProcessor.processMessage(message);\n-\t\tif (topic == null && this.defaultTopic == null) {\n-\t\t\tthrow new IllegalStateException(\n-\t\t\t\t\t\"No topic could be determined from the message and no default topic defined\");\n+\t\tif (topic == null) {\n+\t\t\ttopic = this.defaultTopic;\n \t\t}\n-\t\tpublish(topic == null ? this.defaultTopic : topic, mqttMessage, message);\n+\n+\t\tAssert.state(topic != null, \"No topic could be determined from the message and no default topic defined\");\n+\n+\t\tpublish(topic, mqttMessage, message);\n \t}\n \n \tprotected abstract void publish(String topic, Object mqttMessage, Message<?> message);\n",
    "test_patch": "diff --git a/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/MqttAdapterTests.java b/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/MqttAdapterTests.java\nindex ed82b6f6e43..501f37ef659 100644\n--- a/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/MqttAdapterTests.java\n+++ b/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/MqttAdapterTests.java\n@@ -54,6 +54,7 @@\n import org.springframework.integration.channel.QueueChannel;\n import org.springframework.integration.handler.MessageProcessor;\n import org.springframework.integration.mqtt.core.DefaultMqttPahoClientFactory;\n+import org.springframework.integration.mqtt.core.MqttPahoClientFactory;\n import org.springframework.integration.mqtt.core.Mqttv3ClientManager;\n import org.springframework.integration.mqtt.event.MqttConnectionFailedEvent;\n import org.springframework.integration.mqtt.event.MqttIntegrationEvent;\n@@ -73,6 +74,7 @@\n import org.springframework.util.ReflectionUtils;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n import static org.assertj.core.api.Assertions.fail;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyLong;\n@@ -515,6 +517,19 @@ public void testDifferentQos() throws Exception {\n \t\tverify(client).disconnectForcibly(5_000L);\n \t}\n \n+\t@Test\n+\tpublic void emptyTopicNotAllowed() {\n+\t\tassertThatIllegalArgumentException()\n+\t\t\t\t.isThrownBy(() ->\n+\t\t\t\t\t\tnew MqttPahoMessageDrivenChannelAdapter(\"client_id\", mock(MqttPahoClientFactory.class), \"\"))\n+\t\t\t\t.withMessage(\"The topic to subscribe cannot be empty string\");\n+\n+\t\tvar adapter = new MqttPahoMessageDrivenChannelAdapter(\"client_id\", mock(MqttPahoClientFactory.class), \"topic1\");\n+\t\tassertThatIllegalArgumentException()\n+\t\t\t\t.isThrownBy(() -> adapter.addTopic(\"\"))\n+\t\t\t\t.withMessage(\"The topic to subscribe cannot be empty string\");\n+\t}\n+\n \tprivate MqttPahoMessageDrivenChannelAdapter buildAdapterIn(final IMqttAsyncClient client, Boolean cleanSession)\n \t\t\tthrows MqttException {\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8709",
    "pr_id": 8709,
    "issue_id": 8708,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "spring-integration-sftp: org.apache.sshd.common.io.WritePendingException: A write operation is already pending; \n### Discussed in https://github.com/spring-projects/spring-integration/discussions/8707\r\n\r\nWhen we upgraded out application to Spring boot 3 we started getting issues like this: \r\n\r\n```\r\nCaused by: org.apache.sshd.common.io.WritePendingException: A write operation is already pending; cannot write 21 bytes\r\n\tat org.apache.sshd.common.channel.ChannelAsyncOutputStream.writeBuffer(ChannelAsyncOutputStream.java:102)\r\n\tat org.apache.sshd.sftp.client.impl.DefaultSftpClient.send(DefaultSftpClient.java:299)\r\n\tat org.apache.sshd.sftp.client.impl.AbstractSftpClient.checkHandle(AbstractSftpClient.java:230)\r\n\tat org.apache.sshd.sftp.client.impl.AbstractSftpClient.openDir(AbstractSftpClient.java:829)\r\n\tat org.apache.sshd.sftp.client.impl.SftpDirEntryIterator.<init>(SftpDirEntryIterator.java:60)\r\n\tat org.apache.sshd.sftp.client.impl.SftpIterableDirEntry.iterator(SftpIterableDirEntry.java:64)\r\n\tat org.apache.sshd.sftp.client.impl.SftpIterableDirEntry.iterator(SftpIterableDirEntry.java:34)\r\n\tat java.base/java.lang.Iterable.spliterator(Iterable.java:101)\r\n\tat org.springframework.integration.sftp.session.SftpSession.doList(SftpSession.java:103)\r\n\tat org.springframework.integration.sftp.session.SftpSession.list(SftpSession.java:69)\r\n\tat org.springframework.integration.sftp.session.SftpSession.list(SftpSession.java:52)\r\n\tat org.springframework.integration.file.remote.session.CachingSessionFactory$CachedSession.list(CachingSessionFactory.java:227)\r\n\tat org.springframework.integration.file.remote.RemoteFileTemplate.lambda$list$5(RemoteFileTemplate.java:422)\r\n\tat org.springframework.integration.file.remote.RemoteFileTemplate.execute(RemoteFileTemplate.java:452)\r\n\t... 18 common frames omitted\r\n```\r\n\r\nWe found out that issues is when you call `RemoteFileTemplate.list()` method concurrently. Since `ChannelAsyncOutputStream.writeBuffer()` cannot be caller concurrently. \r\n\r\nBefore upgrading to SB3 we had no issues like this. \r\n\r\nSo my question is, is this a bug in new implementation in SB3 using apache mina SSHD or is this expected behaviour and we should not call this method from different threads?",
    "issue_word_count": 288,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java",
      "spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java"
    ],
    "base_commit": "ef5db3059d631c04ab11fd62dfea4cefe9fa0f46",
    "head_commit": "0db929ce4974f16d4f994a8debd15b764a48ce5d",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8709",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8709",
    "dockerfile": "",
    "pr_merged_at": "2023-08-22T18:00:34.000Z",
    "patch": "diff --git a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java\nindex 782223a87e8..21bcf80ba1a 100644\n--- a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java\n+++ b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java\n@@ -36,13 +36,15 @@\n import org.apache.sshd.common.SshConstants;\n import org.apache.sshd.common.config.keys.FilePasswordProvider;\n import org.apache.sshd.common.keyprovider.KeyIdentityProvider;\n+import org.apache.sshd.common.util.buffer.Buffer;\n import org.apache.sshd.common.util.io.resource.AbstractIoResource;\n import org.apache.sshd.common.util.io.resource.IoResource;\n import org.apache.sshd.common.util.net.SshdSocketAddress;\n import org.apache.sshd.common.util.security.SecurityUtils;\n import org.apache.sshd.sftp.client.SftpClient;\n-import org.apache.sshd.sftp.client.SftpClientFactory;\n+import org.apache.sshd.sftp.client.SftpErrorDataHandler;\n import org.apache.sshd.sftp.client.SftpVersionSelector;\n+import org.apache.sshd.sftp.client.impl.DefaultSftpClient;\n \n import org.springframework.core.io.Resource;\n import org.springframework.integration.file.remote.session.SessionFactory;\n@@ -281,8 +283,8 @@ public SftpSession getSession() {\n \t\t\tboolean freshSftpClient = false;\n \t\t\tif (sftpClient == null || !sftpClient.isOpen()) {\n \t\t\t\tsftpClient =\n-\t\t\t\t\t\tSftpClientFactory.instance()\n-\t\t\t\t\t\t\t\t.createSftpClient(initClientSession(), this.sftpVersionSelector);\n+\t\t\t\t\t\tnew ConcurrentSftpClient(initClientSession(), this.sftpVersionSelector,\n+\t\t\t\t\t\t\t\tSftpErrorDataHandler.EMPTY);\n \t\t\t\tfreshSftpClient = true;\n \t\t\t}\n \t\t\tsftpSession = new SftpSession(sftpClient);\n@@ -395,4 +397,31 @@ public void resetSharedSession() {\n \t\tthis.sharedSftpClient = null;\n \t}\n \n+\t/**\n+\t * The {@link DefaultSftpClient} extension to lock the {@link #send(int, Buffer)}\n+\t * for concurrent interaction.\n+\t */\n+\tprivate static class ConcurrentSftpClient extends DefaultSftpClient {\n+\n+\t\tprivate final Lock sendLock = new ReentrantLock();\n+\n+\t\tConcurrentSftpClient(ClientSession clientSession, SftpVersionSelector initialVersionSelector,\n+\t\t\t\tSftpErrorDataHandler errorDataHandler) throws IOException {\n+\n+\t\t\tsuper(clientSession, initialVersionSelector, errorDataHandler);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int send(int cmd, Buffer buffer) throws IOException {\n+\t\t\tthis.sendLock.lock();\n+\t\t\ttry {\n+\t\t\t\treturn super.send(cmd, buffer);\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.sendLock.unlock();\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\n }\n\ndiff --git a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java\nindex ddbeae10d36..80883331af7 100644\n--- a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java\n+++ b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java\n@@ -22,8 +22,6 @@\n import java.io.UncheckedIOException;\n import java.net.SocketAddress;\n import java.time.Duration;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantLock;\n import java.util.stream.Stream;\n import java.util.stream.StreamSupport;\n \n@@ -49,13 +47,10 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Christian Tzolov\n- *\n  * @since 2.0\n  */\n public class SftpSession implements Session<SftpClient.DirEntry> {\n \n-\tprivate final Lock lock = new ReentrantLock();\n-\n \tprivate final SftpClient sftpClient;\n \n \tpublic SftpSession(SftpClient sftpClient) {\n@@ -113,7 +108,7 @@ public Stream<SftpClient.DirEntry> doList(String path) throws IOException {\n \t\t\t}\n \t\t}\n \t\tremoteDir =\n-\t\t\t\tremoteDir.length() > 0 && remoteDir.charAt(0) == '/'\n+\t\t\t\t!remoteDir.isEmpty() && remoteDir.charAt(0) == '/'\n \t\t\t\t\t\t? remoteDir\n \t\t\t\t\t\t: this.sftpClient.canonicalPath(remoteDir);\n \t\treturn StreamSupport.stream(this.sftpClient.readDir(remoteDir).spliterator(), false)\n@@ -138,30 +133,18 @@ public boolean finalizeRaw() {\n \n \t@Override\n \tpublic void write(InputStream inputStream, String destination) throws IOException {\n-\t\tthis.lock.lock();\n-\t\ttry {\n-\t\t\tOutputStream outputStream = this.sftpClient.write(destination);\n-\t\t\tFileCopyUtils.copy(inputStream, outputStream);\n-\t\t}\n-\t\tfinally {\n-\t\t\tthis.lock.unlock();\n-\t\t}\n+\t\tOutputStream outputStream = this.sftpClient.write(destination);\n+\t\tFileCopyUtils.copy(inputStream, outputStream);\n \t}\n \n \t@Override\n \tpublic void append(InputStream inputStream, String destination) throws IOException {\n-\t\tthis.lock.lock();\n-\t\ttry {\n-\t\t\tOutputStream outputStream =\n-\t\t\t\t\tthis.sftpClient.write(destination,\n-\t\t\t\t\t\t\tSftpClient.OpenMode.Create,\n-\t\t\t\t\t\t\tSftpClient.OpenMode.Write,\n-\t\t\t\t\t\t\tSftpClient.OpenMode.Append);\n-\t\t\tFileCopyUtils.copy(inputStream, outputStream);\n-\t\t}\n-\t\tfinally {\n-\t\t\tthis.lock.unlock();\n-\t\t}\n+\t\tOutputStream outputStream =\n+\t\t\t\tthis.sftpClient.write(destination,\n+\t\t\t\t\t\tSftpClient.OpenMode.Create,\n+\t\t\t\t\t\tSftpClient.OpenMode.Write,\n+\t\t\t\t\t\tSftpClient.OpenMode.Append);\n+\t\tFileCopyUtils.copy(inputStream, outputStream);\n \t}\n \n \t@Override\n",
    "test_patch": "diff --git a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java\nindex 187beee44bd..80578d29663 100644\n--- a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java\n+++ b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java\n@@ -18,11 +18,13 @@\n \n import java.io.File;\n import java.io.IOException;\n+import java.io.UncheckedIOException;\n import java.net.ConnectException;\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n+import java.util.stream.IntStream;\n \n import org.apache.sshd.client.SshClient;\n import org.apache.sshd.client.auth.password.PasswordIdentityProvider;\n@@ -30,6 +32,7 @@\n import org.apache.sshd.common.SshException;\n import org.apache.sshd.server.SshServer;\n import org.apache.sshd.server.keyprovider.SimpleGeneratorHostKeyProvider;\n+import org.apache.sshd.sftp.client.SftpClient;\n import org.apache.sshd.sftp.server.SftpSubsystemFactory;\n import org.junit.jupiter.api.Test;\n \n@@ -45,7 +48,6 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Auke Zaaiman\n- *\n  * @since 3.0.2\n  */\n public class SftpSessionFactoryTests {\n@@ -154,4 +156,40 @@ void externallyProvidedSshClientShouldNotHaveItsConfigurationOverwritten() throw\n \t\t}\n \t}\n \n+\t@Test\n+\tvoid concurrentSessionListDoesntCauseFailure() throws IOException {\n+\t\ttry (SshServer server = SshServer.setUpDefaultServer()) {\n+\t\t\tserver.setPasswordAuthenticator((arg0, arg1, arg2) -> true);\n+\t\t\tserver.setPort(0);\n+\t\t\tserver.setKeyPairProvider(new SimpleGeneratorHostKeyProvider(new File(\"hostkey.ser\").toPath()));\n+\t\t\tserver.setSubsystemFactories(Collections.singletonList(new SftpSubsystemFactory()));\n+\t\t\tserver.start();\n+\n+\t\t\tDefaultSftpSessionFactory sftpSessionFactory = new DefaultSftpSessionFactory();\n+\t\t\tsftpSessionFactory.setHost(\"localhost\");\n+\t\t\tsftpSessionFactory.setPort(server.getPort());\n+\t\t\tsftpSessionFactory.setUser(\"user\");\n+\t\t\tsftpSessionFactory.setPassword(\"pass\");\n+\t\t\tsftpSessionFactory.setAllowUnknownKeys(true);\n+\n+\t\t\tSftpSession session = sftpSessionFactory.getSession();\n+\n+\t\t\tList<SftpClient.DirEntry[]> dirEntries =\n+\t\t\t\t\tIntStream.range(0, 10)\n+\t\t\t\t\t\t\t.boxed()\n+\t\t\t\t\t\t\t.parallel()\n+\t\t\t\t\t\t\t.map(i -> {\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\treturn session.list(\".\");\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcatch (IOException e) {\n+\t\t\t\t\t\t\t\t\tthrow new UncheckedIOException(e);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t})\n+\t\t\t\t\t\t\t.toList();\n+\n+\t\t\tassertThat(dirEntries).hasSize(10);\n+\t\t}\n+\t}\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8706",
    "pr_id": 8706,
    "issue_id": 8704,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Provide properties to block threads by default (again) \n**Expected Behavior**\r\n\r\nUsers of Spring Integration can configure the new timeout defaults (for details, see below) globally instead of sprinkling new boilerplate timeout code throughout the application.\r\n\r\nHere's an example of how such a configuration could look in application.properties (or yaml).\r\n- spring.integration.thread-blocking-timeout=-1s\r\n- spring.integration.thread-blocking-timeout-enabled=false\r\n\r\n**Current Behavior**\r\n\r\nAccording to https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-6.0-to-6.1-Migration-Guide#do-not-block-by-default, the default timeout for various SI operations has been changed from disabled to 30s. This breaks multiple SI projects in our team/company.\r\n\r\n**Context**\r\n\r\nWe have several Spring Integration projects which are negatively affected by this change. We currently have 2 possibilities to fix our code. \r\n- Either we look for every `gateway()` and every `scatterGather()` call and pre-emptively disable the timeout in all these places. Today we looked at an application with 28 gateway() calls. Disadvantage: Lots of boilerplate code -> not Spring-like.\r\n- Or we take the time to analyse each `gateway()` and each `scatterGather()` call and only disable the timeout where we have decided the call could take more than 30s. Disadvantage: requires more time to do.\r\n\r\nHere's an example of the kind of code I'm talking about.\r\n\r\n```\r\n.scatterGather(\r\n  scatterer -> scatterer\r\n    .recipientFlow(flow -> flow\r\n      .gateway(flow -> flow\r\n        .gateway(subflow, \r\n          spec -> spec.replyTimeout(-1L)),\r\n        spec -> spec.replyTimeout(-1L))\r\n  gatherer -> gatherer.doSomething(),\r\n  spec -> spec.gatherTimeout(-1L)\r\n)\r\n```",
    "issue_word_count": 248,
    "test_files_count": 14,
    "non_test_files_count": 9,
    "pr_changed_files": [
      "spring-integration-amqp/src/test/java/org/springframework/integration/amqp/config/AmqpInboundGatewayParserTests.java",
      "spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationProperties.java",
      "spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java",
      "spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java",
      "spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java",
      "spring-integration-core/src/main/java/org/springframework/integration/scattergather/ScatterGatherHandler.java",
      "spring-integration-core/src/main/resources/META-INF/spring.integration.default.properties",
      "spring-integration-core/src/test/java/org/springframework/integration/aggregator/CorrelatingMessageHandlerTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/ResequencerParserTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/annotation/AggregatorAnnotationTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/xml/HeaderEnricherParserTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/gateway/GatewayXmlAndAnnotationTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/handler/AbstractReplyProducingMessageHandlerTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/router/config/RecipientListRouterParserTests.java",
      "spring-integration-core/src/test/resources/META-INF/spring.integration.properties",
      "spring-integration-ip/src/test/java/org/springframework/integration/ip/config/ParserUnitTests.java",
      "spring-integration-jpa/src/main/java/org/springframework/integration/jpa/outbound/JpaOutboundGatewayFactoryBean.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/config/xml/KafkaInboundGatewayTests.java",
      "spring-integration-redis/src/test/java/org/springframework/integration/redis/config/RedisQueueInboundGatewayParserTests.java",
      "spring-integration-ws/src/test/java/org/springframework/integration/ws/config/WebServiceInboundGatewayParserTests.java",
      "src/reference/antora/modules/ROOT/pages/configuration/global-properties.adoc",
      "src/reference/antora/modules/ROOT/pages/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-amqp/src/test/java/org/springframework/integration/amqp/config/AmqpInboundGatewayParserTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/aggregator/CorrelatingMessageHandlerTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/ResequencerParserTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/annotation/AggregatorAnnotationTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/xml/HeaderEnricherParserTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/gateway/GatewayXmlAndAnnotationTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/handler/AbstractReplyProducingMessageHandlerTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/router/config/RecipientListRouterParserTests.java",
      "spring-integration-core/src/test/resources/META-INF/spring.integration.properties",
      "spring-integration-ip/src/test/java/org/springframework/integration/ip/config/ParserUnitTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/config/xml/KafkaInboundGatewayTests.java",
      "spring-integration-redis/src/test/java/org/springframework/integration/redis/config/RedisQueueInboundGatewayParserTests.java",
      "spring-integration-ws/src/test/java/org/springframework/integration/ws/config/WebServiceInboundGatewayParserTests.java"
    ],
    "base_commit": "ef5db3059d631c04ab11fd62dfea4cefe9fa0f46",
    "head_commit": "8bb25ecfbb65e75224e7940a64ce13b122fdf34a",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8706",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8706",
    "dockerfile": "",
    "pr_merged_at": "2023-08-22T22:04:31.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationProperties.java b/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationProperties.java\nindex 8cf47678aa7..6af3f6de76c 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationProperties.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/context/IntegrationProperties.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2022 the original author or authors.\n+ * Copyright 2014-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -37,6 +37,7 @@\n  *   <li> {@code spring.integration.endpoints.noAutoStartup=}\n  *   <li> {@code spring.integration.channels.error.requireSubscribers=true}\n  *   <li> {@code spring.integration.channels.error.ignoreFailures=true}\n+ *   <li> {@code spring.integration.endpoints.defaultTimeout=30000}\n  * </ul>\n  *\n  * @author Artem Bilan\n@@ -112,6 +113,12 @@ public final class IntegrationProperties {\n \t */\n \tpublic static final String ENDPOINTS_NO_AUTO_STARTUP = INTEGRATION_PROPERTIES_PREFIX + \"endpoints.noAutoStartup\";\n \n+\t/**\n+\t * Specifies the default timeout for blocking operations like send and receive messages.\n+\t * @since 6.2\n+\t */\n+\tpublic static final String ENDPOINTS_DEFAULT_TIMEOUT = INTEGRATION_PROPERTIES_PREFIX + \"endpoints.defaultTimeout\";\n+\n \tprivate static final Properties DEFAULTS;\n \n \tprivate boolean channelsAutoCreate = true;\n@@ -132,6 +139,8 @@ public final class IntegrationProperties {\n \n \tprivate String[] noAutoStartupEndpoints = {};\n \n+\tprivate long endpointsDefaultTimeout = IntegrationContextUtils.DEFAULT_TIMEOUT;\n+\n \tprivate volatile Properties properties;\n \n \tstatic {\n@@ -293,6 +302,23 @@ public String[] getNoAutoStartupEndpoints() {\n \t\treturn Arrays.copyOf(this.noAutoStartupEndpoints, this.noAutoStartupEndpoints.length);\n \t}\n \n+\t/**\n+\t * Return the value of {@link #ENDPOINTS_DEFAULT_TIMEOUT} option.\n+\t * @return the value of {@link #ENDPOINTS_DEFAULT_TIMEOUT} option.\n+\t * @since 6.2\n+\t */\n+\tpublic long getEndpointsDefaultTimeout() {\n+\t\treturn this.endpointsDefaultTimeout;\n+\t}\n+\n+\t/**\n+\t * Configure a value for {@link #ENDPOINTS_DEFAULT_TIMEOUT} option.\n+\t * @param endpointsDefaultTimeout the value for {@link #ENDPOINTS_DEFAULT_TIMEOUT} option.\n+\t */\n+\tpublic void setEndpointsDefaultTimeout(long endpointsDefaultTimeout) {\n+\t\tthis.endpointsDefaultTimeout = endpointsDefaultTimeout;\n+\t}\n+\n \t/**\n \t * Represent the current instance as a {@link Properties}.\n \t * @return the {@link Properties} representation.\n@@ -312,6 +338,7 @@ public Properties toProperties() {\n \t\t\tprops.setProperty(READ_ONLY_HEADERS, StringUtils.arrayToCommaDelimitedString(this.readOnlyHeaders));\n \t\t\tprops.setProperty(ENDPOINTS_NO_AUTO_STARTUP,\n \t\t\t\t\tStringUtils.arrayToCommaDelimitedString(this.noAutoStartupEndpoints));\n+\t\t\tprops.setProperty(ENDPOINTS_DEFAULT_TIMEOUT, \"\" + this.endpointsDefaultTimeout);\n \n \t\t\tthis.properties = props;\n \t\t}\n@@ -348,7 +375,9 @@ public static IntegrationProperties parse(Properties properties) {\n \t\t\t\t\t\t\t\tStringUtils.commaDelimitedListToStringArray(value)))\n \t\t\t\t.acceptIfHasText(properties.getProperty(ENDPOINTS_NO_AUTO_STARTUP),\n \t\t\t\t\t\t(value) -> integrationProperties.setNoAutoStartupEndpoints(\n-\t\t\t\t\t\t\t\tStringUtils.commaDelimitedListToStringArray(value)));\n+\t\t\t\t\t\t\t\tStringUtils.commaDelimitedListToStringArray(value)))\n+\t\t\t\t.acceptIfHasText(properties.getProperty(ENDPOINTS_DEFAULT_TIMEOUT),\n+\t\t\t\t\t\t(value) -> integrationProperties.setEndpointsDefaultTimeout(Long.parseLong(value)));\n \t\treturn integrationProperties;\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java b/spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java\nindex 98c4f9e86cf..dfd358fc23f 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java\n@@ -35,7 +35,6 @@\n import org.springframework.integration.IntegrationPatternType;\n import org.springframework.integration.MessageTimeoutException;\n import org.springframework.integration.channel.ReactiveStreamsSubscribableChannel;\n-import org.springframework.integration.context.IntegrationContextUtils;\n import org.springframework.integration.core.MessagingTemplate;\n import org.springframework.integration.endpoint.AbstractEndpoint;\n import org.springframework.integration.endpoint.EventDrivenConsumer;\n@@ -124,7 +123,9 @@ public abstract class MessagingGatewaySupport extends AbstractEndpoint\n \n \tprivate String errorChannelName;\n \n-\tprivate long replyTimeout = IntegrationContextUtils.DEFAULT_TIMEOUT;\n+\tprivate boolean requestTimeoutSet;\n+\n+\tprivate boolean replyTimeoutSet;\n \n \tprivate InboundMessageMapper<Object> requestMapper = new DefaultRequestMapper();\n \n@@ -167,8 +168,6 @@ public MessagingGatewaySupport() {\n \tpublic MessagingGatewaySupport(boolean errorOnTimeout) {\n \t\tConvertingMessagingTemplate template = new ConvertingMessagingTemplate();\n \t\ttemplate.setMessageConverter(this.messageConverter);\n-\t\ttemplate.setSendTimeout(IntegrationContextUtils.DEFAULT_TIMEOUT);\n-\t\ttemplate.setReceiveTimeout(this.replyTimeout);\n \t\tthis.messagingTemplate = template;\n \t\tthis.errorOnTimeout = errorOnTimeout;\n \t}\n@@ -252,6 +251,7 @@ public void setErrorChannelName(String errorChannelName) {\n \t */\n \tpublic void setRequestTimeout(long requestTimeout) {\n \t\tthis.messagingTemplate.setSendTimeout(requestTimeout);\n+\t\tthis.requestTimeoutSet = true;\n \t}\n \n \t/**\n@@ -260,8 +260,8 @@ public void setRequestTimeout(long requestTimeout) {\n \t * @param replyTimeout the timeout value in milliseconds\n \t */\n \tpublic void setReplyTimeout(long replyTimeout) {\n-\t\tthis.replyTimeout = replyTimeout;\n \t\tthis.messagingTemplate.setReceiveTimeout(replyTimeout);\n+\t\tthis.replyTimeoutSet = true;\n \t}\n \n \t/**\n@@ -406,6 +406,13 @@ protected void onInit() {\n \t\t\t}\n \t\t\tthis.messageConverter.setBeanFactory(beanFactory);\n \t\t}\n+\t\tlong endpointsDefaultTimeout = getIntegrationProperties().getEndpointsDefaultTimeout();\n+\t\tif (!this.requestTimeoutSet) {\n+\t\t\tthis.messagingTemplate.setSendTimeout(endpointsDefaultTimeout);\n+\t\t}\n+\t\tif (!this.replyTimeoutSet) {\n+\t\t\tthis.messagingTemplate.setReceiveTimeout(endpointsDefaultTimeout);\n+\t\t}\n \t\tthis.initialized = true;\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java\nindex 20f139c1215..6bf0d3432ed 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractMessageProducingHandler.java\n@@ -89,9 +89,7 @@ public abstract class AbstractMessageProducingHandler extends AbstractMessageHan\n \n \tprivate boolean noHeadersPropagation;\n \n-\t{\n-\t\tthis.messagingTemplate.setSendTimeout(IntegrationContextUtils.DEFAULT_TIMEOUT);\n-\t}\n+\tprivate boolean sendTimeoutSet;\n \n \t/**\n \t * Set the timeout for sending reply Messages.\n@@ -99,6 +97,7 @@ public abstract class AbstractMessageProducingHandler extends AbstractMessageHan\n \t */\n \tpublic void setSendTimeout(long sendTimeout) {\n \t\tthis.messagingTemplate.setSendTimeout(sendTimeout);\n+\t\tthis.sendTimeoutSet = true;\n \t}\n \n \t@Override\n@@ -189,7 +188,7 @@ protected final void updateNotPropagatedHeaders(String[] headers, boolean merge)\n \t@Override\n \tpublic Collection<String> getNotPropagatedHeaders() {\n \t\treturn this.notPropagatedHeaders != null\n-\t\t\t\t? Collections.unmodifiableSet(new HashSet<>(Arrays.asList(this.notPropagatedHeaders)))\n+\t\t\t\t? Set.of(this.notPropagatedHeaders)\n \t\t\t\t: Collections.emptyList();\n \t}\n \n@@ -217,6 +216,9 @@ protected void onInit() {\n \t\t}\n \t\tthis.messagingTemplate.setDestinationResolver(getChannelResolver());\n \t\tsetAsyncIfCan();\n+\t\tif (!this.sendTimeoutSet) {\n+\t\t\tthis.messagingTemplate.setSendTimeout(getIntegrationProperties().getEndpointsDefaultTimeout());\n+\t\t}\n \t}\n \n \tprivate void setAsyncIfCan() {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java b/spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java\nindex 2a89d13dabb..a174708c957 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java\n@@ -25,7 +25,6 @@\n import org.springframework.core.convert.ConversionService;\n import org.springframework.core.convert.support.DefaultConversionService;\n import org.springframework.integration.IntegrationPatternType;\n-import org.springframework.integration.context.IntegrationContextUtils;\n import org.springframework.integration.core.MessagingTemplate;\n import org.springframework.integration.handler.AbstractMessageHandler;\n import org.springframework.integration.support.management.IntegrationManagedResource;\n@@ -63,9 +62,7 @@ public abstract class AbstractMessageRouter extends AbstractMessageHandler imple\n \n \tprivate volatile boolean applySequence;\n \n-\t{\n-\t\tthis.messagingTemplate.setSendTimeout(IntegrationContextUtils.DEFAULT_TIMEOUT);\n-\t}\n+\tprivate boolean sendTimeoutSet;\n \n \t/**\n \t * Set the default channel where Messages should be sent if channel resolution\n@@ -115,10 +112,11 @@ public void setDefaultOutputChannelName(String defaultOutputChannelName) {\n \t */\n \tpublic void setSendTimeout(long timeout) {\n \t\tthis.messagingTemplate.setSendTimeout(timeout);\n+\t\tthis.sendTimeoutSet = true;\n \t}\n \n \t/**\n-\t * Specify whether send failures for one or more of the recipients should be ignored. By default this is\n+\t * Specify whether send failures for one or more of the recipients should be ignored. By default, this is\n \t * <code>false</code> meaning that an Exception will be thrown whenever a send fails. To override this and suppress\n \t * Exceptions, set the value to <code>true</code>.\n \t * @param ignoreSendFailures true to ignore send failures.\n@@ -174,6 +172,10 @@ protected void onInit() {\n \t\tif (beanFactory != null) {\n \t\t\tthis.messagingTemplate.setBeanFactory(beanFactory);\n \t\t}\n+\n+\t\tif (!this.sendTimeoutSet) {\n+\t\t\tthis.messagingTemplate.setSendTimeout(getIntegrationProperties().getEndpointsDefaultTimeout());\n+\t\t}\n \t}\n \n \t/**\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/scattergather/ScatterGatherHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/scattergather/ScatterGatherHandler.java\nindex e565eabc273..35d17eec846 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/scattergather/ScatterGatherHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/scattergather/ScatterGatherHandler.java\n@@ -67,7 +67,7 @@ public class ScatterGatherHandler extends AbstractReplyProducingMessageHandler i\n \n \tprivate String errorChannelName = IntegrationContextUtils.ERROR_CHANNEL_BEAN_NAME;\n \n-\tprivate long gatherTimeout = IntegrationContextUtils.DEFAULT_TIMEOUT;\n+\tprivate Long gatherTimeout;\n \n \tprivate AbstractEndpoint gatherEndpoint;\n \n@@ -119,6 +119,10 @@ public IntegrationPatternType getIntegrationPatternType() {\n \n \t@Override\n \tprotected void doInit() {\n+\t\tif (this.gatherTimeout == null) {\n+\t\t\tthis.gatherTimeout = getIntegrationProperties().getEndpointsDefaultTimeout();\n+\t\t}\n+\n \t\tBeanFactory beanFactory = getBeanFactory();\n \t\tif (this.gatherChannel == null) {\n \t\t\tthis.gatherChannel =\n\ndiff --git a/spring-integration-core/src/main/resources/META-INF/spring.integration.default.properties b/spring-integration-core/src/main/resources/META-INF/spring.integration.default.properties\nindex 23243f2f49e..573f1916e63 100644\n--- a/spring-integration-core/src/main/resources/META-INF/spring.integration.default.properties\n+++ b/spring-integration-core/src/main/resources/META-INF/spring.integration.default.properties\n@@ -8,3 +8,4 @@ spring.integration.messagingTemplate.throwExceptionOnLateReply=false\n # Defaults to MessageHeaders.ID and MessageHeaders.TIMESTAMP\n spring.integration.readOnly.headers=\n spring.integration.endpoints.noAutoStartup=\n+spring.integration.endpoints.defaultTimeout=30000\n\ndiff --git a/spring-integration-jpa/src/main/java/org/springframework/integration/jpa/outbound/JpaOutboundGatewayFactoryBean.java b/spring-integration-jpa/src/main/java/org/springframework/integration/jpa/outbound/JpaOutboundGatewayFactoryBean.java\nindex 11f546201f8..6f768d2b505 100644\n--- a/spring-integration-jpa/src/main/java/org/springframework/integration/jpa/outbound/JpaOutboundGatewayFactoryBean.java\n+++ b/spring-integration-jpa/src/main/java/org/springframework/integration/jpa/outbound/JpaOutboundGatewayFactoryBean.java\n@@ -17,9 +17,9 @@\n package org.springframework.integration.jpa.outbound;\n \n import org.springframework.integration.config.AbstractSimpleMessageHandlerFactoryBean;\n-import org.springframework.integration.context.IntegrationContextUtils;\n import org.springframework.integration.jpa.core.JpaExecutor;\n import org.springframework.integration.jpa.support.OutboundGatewayType;\n+import org.springframework.lang.Nullable;\n \n /**\n  * The {@link JpaOutboundGatewayFactoryBean} creates instances of the\n@@ -44,7 +44,8 @@ public class JpaOutboundGatewayFactoryBean extends AbstractSimpleMessageHandlerF\n \n \tprivate boolean producesReply = true;\n \n-\tprivate long replyTimeout = IntegrationContextUtils.DEFAULT_TIMEOUT;\n+\t@Nullable\n+\tprivate Long replyTimeout;\n \n \tprivate boolean requiresReply = false;\n \n@@ -79,7 +80,9 @@ protected JpaOutboundGateway createHandler() {\n \t\tJpaOutboundGateway jpaOutboundGateway = new JpaOutboundGateway(this.jpaExecutor);\n \t\tjpaOutboundGateway.setGatewayType(this.gatewayType);\n \t\tjpaOutboundGateway.setProducesReply(this.producesReply);\n-\t\tjpaOutboundGateway.setSendTimeout(this.replyTimeout);\n+\t\tif (this.replyTimeout != null) {\n+\t\t\tjpaOutboundGateway.setSendTimeout(this.replyTimeout);\n+\t\t}\n \t\tjpaOutboundGateway.setRequiresReply(this.requiresReply);\n \t\treturn jpaOutboundGateway;\n \t}\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/configuration/global-properties.adoc b/src/reference/antora/modules/ROOT/pages/configuration/global-properties.adoc\nindex 33271e3565c..acae7aa00a9 100644\n--- a/src/reference/antora/modules/ROOT/pages/configuration/global-properties.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/configuration/global-properties.adoc\n@@ -6,6 +6,7 @@ Certain global framework properties can be overridden by providing a properties\n The default properties can be found in `org.springframework.integration.context.IntegrationProperties` class.\n The following listing shows the default values:\n \n+====\n [source]\n ----\n spring.integration.channels.autoCreate=true <1>\n@@ -17,6 +18,7 @@ spring.integration.readOnly.headers= <6>\n spring.integration.endpoints.noAutoStartup= <7>\n spring.integration.channels.error.requireSubscribers=true <8>\n spring.integration.channels.error.ignoreFailures=true <9>\n+spring.integration.endpoints.defaultTimeout=30000 <10>\n ----\n \n <1> When true, `input-channel` instances are automatically declared as `DirectChannel` instances when not explicitly found in the application context.\n@@ -51,11 +53,18 @@ See xref:scatter-gather.adoc#scatter-gather-error-handling[Error Handling] for m\n <9> A boolean flag to indicate that default global `errorChannel` must ignore dispatching errors and pass the message to the next handler.\n Since version 5.5.\n \n+<10> The default number of milliseconds for request and reply timeouts in endpoints.\n+Default value is 30 seconds to avoid indefinite blocking.\n+Can be configured to a negative value to restore infinite blocking behavior in endpoints.\n+Since version 6.2.\n+====\n+\n These properties can be overridden by adding a `/META-INF/spring.integration.properties` file to the classpath or an `IntegrationContextUtils.INTEGRATION_GLOBAL_PROPERTIES_BEAN_NAME` bean for the `org.springframework.integration.context.IntegrationProperties` instance.\n You need not provide all the properties -- only those that you want to override.\n \n Starting with version 5.1, all the merged global properties are printed in the logs after application context startup when a `DEBUG` logic level is turned on for the `org.springframework.integration` category.\n The output looks like this:\n+\n [source]\n ----\n Spring Integration global properties:\n@@ -67,5 +76,6 @@ spring.integration.channels.autoCreate=true\n spring.integration.channels.maxBroadcastSubscribers=0x7fffffff\n spring.integration.readOnly.headers=\n spring.integration.messagingTemplate.throwExceptionOnLateReply=true\n+spring.integration.endpoints.defaultTimeout=-1\n ----\n \n\ndiff --git a/src/reference/antora/modules/ROOT/pages/whats-new.adoc b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\nindex 5862dee65a0..f7d37c348ca 100644\n--- a/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n@@ -22,7 +22,7 @@ In general the project has been moved to the latest dependency versions.\n ==== Debezium Inbound Channel Adapter\n \n The Debezium Engine based Change Data Capture (CDC) channel adapter, that allows capturing database change events, converting them into Messages and streaming those to the outbound channels.\n-See xref:debezium.adoc[Debezium Support]  for more information.\n+See xref:debezium.adoc[Debezium Support] for more information.\n \n [[x6.2-general]]\n === General Changes\n@@ -33,6 +33,9 @@ See xref:endpoint.adoc#endpoint-pollingconsumer[Polling Consumer] for more infor\n - Java, Groovy and Kotlin DSLs have now context-specific methods in the `IntegrationFlowDefinition` with a single `Consumer` argument to configure an endpoint and its handler with one builder and readable options.\n See, for example, `transformWith()`, `splitWith()` in xref:dsl.adoc#java-dsl[ Java DSL Chapter].\n \n+- A new `spring.integration.endpoints.defaultTimeout` global property has been introduced to override the default 30 seconds timeout for all the endpoints in the application.\n+See xref:configuration/global-properties.adoc[Global Properties] for more information.\n+\n [[x6.2-websockets]]\n === WebSockets Changes\n \n",
    "test_patch": "diff --git a/spring-integration-amqp/src/test/java/org/springframework/integration/amqp/config/AmqpInboundGatewayParserTests.java b/spring-integration-amqp/src/test/java/org/springframework/integration/amqp/config/AmqpInboundGatewayParserTests.java\nindex ee4ff131b96..d1c1c6a42ca 100644\n--- a/spring-integration-amqp/src/test/java/org/springframework/integration/amqp/config/AmqpInboundGatewayParserTests.java\n+++ b/spring-integration-amqp/src/test/java/org/springframework/integration/amqp/config/AmqpInboundGatewayParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,8 +18,7 @@\n \n import java.lang.reflect.Field;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n import org.mockito.Mockito;\n \n import org.springframework.amqp.core.Address;\n@@ -40,11 +39,11 @@\n import org.springframework.integration.test.util.TestUtils;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n import org.springframework.util.ReflectionUtils;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n import static org.mockito.ArgumentMatchers.isNull;\n \n /**\n@@ -55,8 +54,7 @@\n  *\n  * @since 2.1\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class AmqpInboundGatewayParserTests {\n \n@@ -66,16 +64,16 @@ public class AmqpInboundGatewayParserTests {\n \t@Test\n \tpublic void customMessageConverter() {\n \t\tObject gateway = context.getBean(\"gateway\");\n-\t\tMessageConverter gatewayConverter = TestUtils.getPropertyValue(gateway, \"amqpMessageConverter\", MessageConverter.class);\n-\t\tMessageConverter templateConverter = TestUtils.getPropertyValue(gateway, \"amqpTemplate.messageConverter\", MessageConverter.class);\n+\t\tMessageConverter gatewayConverter =\n+\t\t\t\tTestUtils.getPropertyValue(gateway, \"amqpMessageConverter\", MessageConverter.class);\n+\t\tMessageConverter templateConverter =\n+\t\t\t\tTestUtils.getPropertyValue(gateway, \"amqpTemplate.messageConverter\", MessageConverter.class);\n \t\tTestConverter testConverter = context.getBean(\"testConverter\", TestConverter.class);\n \t\tassertThat(gatewayConverter).isSameAs(testConverter);\n \t\tassertThat(templateConverter).isSameAs(testConverter);\n \t\tassertThat(TestUtils.getPropertyValue(gateway, \"autoStartup\")).isEqualTo(Boolean.TRUE);\n \t\tassertThat(TestUtils.getPropertyValue(gateway, \"phase\")).isEqualTo(0);\n-\t\tassertThat(TestUtils.getPropertyValue(gateway, \"replyTimeout\", Long.class)).isEqualTo(Long.valueOf(1234L));\n-\t\tassertThat(TestUtils.getPropertyValue(gateway, \"messagingTemplate.receiveTimeout\", Long.class))\n-\t\t\t\t.isEqualTo(Long.valueOf(1234L));\n+\t\tassertThat(TestUtils.getPropertyValue(gateway, \"messagingTemplate.receiveTimeout\")).isEqualTo(1234L);\n \t\tassertThat(TestUtils.getPropertyValue(gateway, \"messageListenerContainer.missingQueuesFatal\", Boolean.class))\n \t\t\t\t.isTrue();\n \t}\n@@ -145,14 +143,12 @@ public void verifyUsageWithHeaderMapper() throws Exception {\n \n \t@Test\n \tpublic void testInt2971HeaderMapperAndMappedHeadersExclusivity() {\n-\t\ttry {\n-\t\t\tnew ClassPathXmlApplicationContext(\"AmqpInboundGatewayParserTests-headerMapper-fail-context.xml\",\n-\t\t\t\t\tthis.getClass()).close();\n-\t\t}\n-\t\tcatch (BeanDefinitionParsingException e) {\n-\t\t\tassertThat(e.getMessage().startsWith(\"Configuration problem: The 'header-mapper' attribute \" +\n-\t\t\t\t\t\"is mutually exclusive with 'mapped-request-headers' or 'mapped-reply-headers'\")).isTrue();\n-\t\t}\n+\t\tassertThatExceptionOfType(BeanDefinitionParsingException.class)\n+\t\t\t\t.isThrownBy(() ->\n+\t\t\t\t\t\tnew ClassPathXmlApplicationContext(\"AmqpInboundGatewayParserTests-headerMapper-fail-context.xml\",\n+\t\t\t\t\t\t\t\tgetClass()))\n+\t\t\t\t.withMessageStartingWith(\"Configuration problem: The 'header-mapper' attribute \" +\n+\t\t\t\t\t\t\"is mutually exclusive with 'mapped-request-headers' or 'mapped-reply-headers'\");\n \t}\n \n \tprivate static class TestConverter extends SimpleMessageConverter {\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/aggregator/CorrelatingMessageHandlerTests.java b/spring-integration-core/src/test/java/org/springframework/integration/aggregator/CorrelatingMessageHandlerTests.java\nindex db5f376e99e..e83d9702cbd 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/aggregator/CorrelatingMessageHandlerTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/aggregator/CorrelatingMessageHandlerTests.java\n@@ -71,9 +71,10 @@ public void initializeSubject() {\n \t\toutputChannel = mock(MessageChannel.class);\n \t\thandler = new AggregatingMessageHandler(processor, store, correlationStrategy, ReleaseStrategy);\n \t\thandler.setOutputChannel(outputChannel);\n+\t\thandler.setBeanFactory(mock());\n+\t\thandler.afterPropertiesSet();\n \t}\n \n-\n \t@Test\n \tpublic void bufferCompletesNormally() {\n \t\tString correlationKey = \"key\";\n@@ -95,7 +96,7 @@ public void bufferCompletesNormally() {\n \t}\n \n \t@Test\n-\tpublic void bufferCompletesWithException() throws Exception {\n+\tpublic void bufferCompletesWithException() {\n \n \t\tdoAnswer(new ThrowsException(new RuntimeException(\"Planned test exception\")))\n \t\t\t\t.when(processor).processMessageGroup(isA(SimpleMessageGroup.class));\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/config/ResequencerParserTests.java b/spring-integration-core/src/test/java/org/springframework/integration/config/ResequencerParserTests.java\nindex 16e9cb6a226..429e141b85b 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/config/ResequencerParserTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/config/ResequencerParserTests.java\n@@ -59,7 +59,7 @@ void testDefaultResequencerProperties() {\n \t\tResequencingMessageHandler resequencer = TestUtils.getPropertyValue(endpoint, \"handler\",\n \t\t\t\tResequencingMessageHandler.class);\n \t\tassertThat(getPropertyValue(resequencer, \"outputChannel\")).isNull();\n-\t\tassertThat(getPropertyValue(resequencer, \"messagingTemplate.sendTimeout\")).isEqualTo(30000L);\n+\t\tassertThat(getPropertyValue(resequencer, \"messagingTemplate.sendTimeout\")).isEqualTo(45000L);\n \t\tassertThat(getPropertyValue(resequencer, \"sendPartialResultOnExpiry\"))\n \t\t\t\t.as(\"The ResequencerEndpoint is not configured with the appropriate 'send partial results on \" +\n \t\t\t\t\t\t\"timeout'\" +\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/AggregatorAnnotationTests.java b/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/AggregatorAnnotationTests.java\nindex 3493d977906..04bb0410de8 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/AggregatorAnnotationTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/AggregatorAnnotationTests.java\n@@ -51,7 +51,7 @@ public void testAnnotationWithDefaultSettings() {\n \t\tassertThat(getPropertyValue(aggregator, \"releaseStrategy\") instanceof SimpleSequenceSizeReleaseStrategy)\n \t\t\t\t.isTrue();\n \t\tassertThat(getPropertyValue(aggregator, \"outputChannel\")).isNull();\n-\t\tassertThat(getPropertyValue(aggregator, \"messagingTemplate.sendTimeout\")).isEqualTo(30000L);\n+\t\tassertThat(getPropertyValue(aggregator, \"messagingTemplate.sendTimeout\")).isEqualTo(45000L);\n \t\tassertThat(getPropertyValue(aggregator, \"sendPartialResultOnExpiry\")).isEqualTo(false);\n \t\tcontext.close();\n \t}\n@@ -72,7 +72,7 @@ public void testAnnotationWithCustomSettings() {\n \t}\n \n \t@Test\n-\tpublic void testAnnotationWithCustomReleaseStrategy() throws Exception {\n+\tpublic void testAnnotationWithCustomReleaseStrategy() {\n \t\tConfigurableApplicationContext context = new ClassPathXmlApplicationContext(\n \t\t\t\tnew String[] {\"classpath:/org/springframework/integration/config/annotation/testAnnotatedAggregator.xml\"});\n \t\tfinal String endpointName = \"endpointWithDefaultAnnotationAndCustomReleaseStrategy\";\n@@ -90,7 +90,7 @@ public void testAnnotationWithCustomReleaseStrategy() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testAnnotationWithCustomCorrelationStrategy() throws Exception {\n+\tpublic void testAnnotationWithCustomCorrelationStrategy() {\n \t\tConfigurableApplicationContext context = new ClassPathXmlApplicationContext(\n \t\t\t\tnew String[] {\"classpath:/org/springframework/integration/config/annotation/testAnnotatedAggregator.xml\"});\n \t\tfinal String endpointName = \"endpointWithCorrelationStrategy\";\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/config/xml/HeaderEnricherParserTests.java b/spring-integration-core/src/test/java/org/springframework/integration/config/xml/HeaderEnricherParserTests.java\nindex 07b1380be75..0b0fa1e157c 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/config/xml/HeaderEnricherParserTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/config/xml/HeaderEnricherParserTests.java\n@@ -49,7 +49,7 @@ class HeaderEnricherParserTests {\n \tvoid sendTimeoutDefault() {\n \t\tObject endpoint = context.getBean(\"headerEnricherWithDefaults\");\n \t\tlong sendTimeout = TestUtils.getPropertyValue(endpoint, \"handler.messagingTemplate.sendTimeout\", Long.class);\n-\t\tassertThat(sendTimeout).isEqualTo(30000L);\n+\t\tassertThat(sendTimeout).isEqualTo(45000L);\n \t}\n \n \t@Test\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.java b/spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.java\nindex e56b3b6fd75..0af3d08404a 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.java\n@@ -640,7 +640,7 @@ public void testMetaAnnotations() {\n \t\tassertThat(TestUtils.getPropertyValue(consumer, \"handler.outputChannelName\")).isEqualTo(\"annOutput\");\n \t\tassertThat(TestUtils.getPropertyValue(consumer, \"handler.discardChannelName\")).isEqualTo(\"annOutput\");\n \t\tassertThat(TestUtils.getPropertyValue(consumer, \"trigger.period\")).isEqualTo(Duration.ofSeconds(1));\n-\t\tassertThat(TestUtils.getPropertyValue(consumer, \"handler.messagingTemplate.sendTimeout\")).isEqualTo(30000L);\n+\t\tassertThat(TestUtils.getPropertyValue(consumer, \"handler.messagingTemplate.sendTimeout\")).isEqualTo(45000L);\n \t\tassertThat(TestUtils.getPropertyValue(consumer, \"handler.sendPartialResultOnExpiry\", Boolean.class)).isFalse();\n \n \t\tconsumer = this.context.getBean(\"annotationTestService.annAgg2.aggregator\", PollingConsumer.class);\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/gateway/GatewayXmlAndAnnotationTests.java b/spring-integration-core/src/test/java/org/springframework/integration/gateway/GatewayXmlAndAnnotationTests.java\nindex 1dde2909674..527e51965d9 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/gateway/GatewayXmlAndAnnotationTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/gateway/GatewayXmlAndAnnotationTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -58,22 +58,22 @@ public void test() {\n \t\t\tswitch (entry.getKey().getName()) {\n \t\t\t\tcase \"annotationShouldNotOverrideDefault\" -> {\n \t\t\t\t\tassertThat(TestUtils.getPropertyValue(entry.getValue(),\n-\t\t\t\t\t\t\t\"replyTimeout\")).isEqualTo(123L);\n+\t\t\t\t\t\t\t\"messagingTemplate.receiveTimeout\")).isEqualTo(123L);\n \t\t\t\t\tassertions++;\n \t\t\t\t}\n \t\t\t\tcase \"annotationShouldOverrideDefault\" -> {\n \t\t\t\t\tassertThat(TestUtils.getPropertyValue(entry.getValue(),\n-\t\t\t\t\t\t\t\"replyTimeout\")).isEqualTo(234L);\n+\t\t\t\t\t\t\t\"messagingTemplate.receiveTimeout\")).isEqualTo(234L);\n \t\t\t\t\tassertions++;\n \t\t\t\t}\n \t\t\t\tcase \"annotationShouldOverrideDefaultToInfinity\" -> {\n \t\t\t\t\tassertThat(TestUtils.getPropertyValue(entry.getValue(),\n-\t\t\t\t\t\t\t\"replyTimeout\")).isEqualTo(-1L);\n+\t\t\t\t\t\t\t\"messagingTemplate.receiveTimeout\")).isEqualTo(-1L);\n \t\t\t\t\tassertions++;\n \t\t\t\t}\n \t\t\t\tcase \"explicitTimeoutShouldOverrideDefault\" -> {\n \t\t\t\t\tassertThat(TestUtils.getPropertyValue(entry.getValue(),\n-\t\t\t\t\t\t\t\"replyTimeout\")).isEqualTo(456L);\n+\t\t\t\t\t\t\t\"messagingTemplate.receiveTimeout\")).isEqualTo(456L);\n \t\t\t\t\tassertions++;\n \t\t\t\t}\n \t\t\t}\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/handler/AbstractReplyProducingMessageHandlerTests.java b/spring-integration-core/src/test/java/org/springframework/integration/handler/AbstractReplyProducingMessageHandlerTests.java\nindex 25604ab17d7..7e3fb1eb74e 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/handler/AbstractReplyProducingMessageHandlerTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/handler/AbstractReplyProducingMessageHandlerTests.java\n@@ -61,6 +61,8 @@ protected Object handleRequestMessage(Message<?> requestMessage) {\n \t@BeforeEach\n \tvoid setup() {\n \t\tchannel = mock(MessageChannel.class);\n+\t\thandler.setBeanFactory(mock());\n+\t\thandler.afterPropertiesSet();\n \t}\n \n \t@Test\n@@ -91,6 +93,9 @@ protected Object handleRequestMessage(Message<?> requestMessage) {\n \t\tassertThat(handler.getNotPropagatedHeaders()).isEmpty();\n \t\thandler.setNotPropagatedHeaders(\"f*\", \"*r\");\n \t\thandler.setOutputChannel(this.channel);\n+\t\thandler.setBeanFactory(mock());\n+\t\thandler.afterPropertiesSet();\n+\n \t\tassertThat(handler.getNotPropagatedHeaders()).contains(\"f*\", \"*r\");\n \t\tArgumentCaptor<Message<?>> captor = ArgumentCaptor.forClass(Message.class);\n \t\twillReturn(true).given(this.channel).send(captor.capture(), eq(30000L));\n@@ -120,6 +125,9 @@ protected Object handleRequestMessage(Message<?> requestMessage) {\n \t\thandler.addNotPropagatedHeaders(\"boom\");\n \t\tassertThat(handler.getNotPropagatedHeaders()).contains(\"boom\");\n \t\thandler.setOutputChannel(this.channel);\n+\t\thandler.setBeanFactory(mock());\n+\t\thandler.afterPropertiesSet();\n+\n \t\tArgumentCaptor<Message<?>> captor = ArgumentCaptor.forClass(Message.class);\n \t\twillReturn(true).given(this.channel).send(captor.capture(), eq(30000L));\n \t\thandler.handleMessage(MessageBuilder.withPayload(\"hello\")\n@@ -149,6 +157,9 @@ protected Object handleRequestMessage(Message<?> requestMessage) {\n \t\thandler.setNotPropagatedHeaders(\"foo\");\n \t\thandler.addNotPropagatedHeaders(\"b*r\");\n \t\thandler.setOutputChannel(this.channel);\n+\t\thandler.setBeanFactory(mock());\n+\t\thandler.afterPropertiesSet();\n+\n \t\tassertThat(handler.getNotPropagatedHeaders()).contains(\"foo\", \"b*r\");\n \t\tArgumentCaptor<Message<?>> captor = ArgumentCaptor.forClass(Message.class);\n \t\twillReturn(true).given(this.channel).send(captor.capture(), eq(30000L));\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/router/config/RecipientListRouterParserTests.java b/spring-integration-core/src/test/java/org/springframework/integration/router/config/RecipientListRouterParserTests.java\nindex c232d68c0be..c5c85292ed1 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/router/config/RecipientListRouterParserTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/router/config/RecipientListRouterParserTests.java\n@@ -73,7 +73,7 @@ public void simpleRouter() {\n \t\tassertThat(handler.getClass()).isEqualTo(RecipientListRouter.class);\n \t\tRecipientListRouter router = (RecipientListRouter) handler;\n \t\tDirectFieldAccessor accessor = new DirectFieldAccessor(router);\n-\t\tassertThat(TestUtils.getPropertyValue(router, \"messagingTemplate.sendTimeout\")).isEqualTo(30000L);\n+\t\tassertThat(TestUtils.getPropertyValue(router, \"messagingTemplate.sendTimeout\")).isEqualTo(45000L);\n \t\tassertThat(accessor.getPropertyValue(\"applySequence\")).isEqualTo(Boolean.FALSE);\n \t\tassertThat(accessor.getPropertyValue(\"ignoreSendFailures\")).isEqualTo(Boolean.FALSE);\n \t}\n\ndiff --git a/spring-integration-core/src/test/resources/META-INF/spring.integration.properties b/spring-integration-core/src/test/resources/META-INF/spring.integration.properties\nindex 3f18726a704..0298eb27188 100644\n--- a/spring-integration-core/src/test/resources/META-INF/spring.integration.properties\n+++ b/spring-integration-core/src/test/resources/META-INF/spring.integration.properties\n@@ -4,3 +4,4 @@\n spring.integration.taskScheduler.poolSize=20\n spring.integration.messagingTemplate.throwExceptionOnLateReply=true\n spring.integration.endpoints.noAutoStartup=fooService*,stringSupplierEndpoint\n+spring.integration.endpoints.defaultTimeout=45000\n\ndiff --git a/spring-integration-ip/src/test/java/org/springframework/integration/ip/config/ParserUnitTests.java b/spring-integration-ip/src/test/java/org/springframework/integration/ip/config/ParserUnitTests.java\nindex 14288841149..8f106d27bc6 100644\n--- a/spring-integration-ip/src/test/java/org/springframework/integration/ip/config/ParserUnitTests.java\n+++ b/spring-integration-ip/src/test/java/org/springframework/integration/ip/config/ParserUnitTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -447,7 +447,7 @@ public void testOutTcp() {\n \tpublic void testInGateway1() {\n \t\tDirectFieldAccessor dfa = new DirectFieldAccessor(tcpInboundGateway1);\n \t\tassertThat(dfa.getPropertyValue(\"serverConnectionFactory\")).isSameAs(cfS2);\n-\t\tassertThat(dfa.getPropertyValue(\"replyTimeout\")).isEqualTo(456L);\n+\t\tassertThat(TestUtils.getPropertyValue(tcpInboundGateway1, \"messagingTemplate.receiveTimeout\")).isEqualTo(456L);\n \t\tassertThat(tcpInboundGateway1.getComponentName()).isEqualTo(\"inGateway1\");\n \t\tassertThat(tcpInboundGateway1.getComponentType()).isEqualTo(\"ip:tcp-inbound-gateway\");\n \t\tassertThat(tcpInboundGateway1.getErrorChannel()).isEqualTo(errorChannel);\n@@ -463,7 +463,7 @@ public void testInGateway1() {\n \tpublic void testInGateway2() {\n \t\tDirectFieldAccessor dfa = new DirectFieldAccessor(tcpInboundGateway2);\n \t\tassertThat(dfa.getPropertyValue(\"serverConnectionFactory\")).isSameAs(cfS3);\n-\t\tassertThat(dfa.getPropertyValue(\"replyTimeout\")).isEqualTo(456L);\n+\t\tassertThat(TestUtils.getPropertyValue(tcpInboundGateway2, \"messagingTemplate.receiveTimeout\")).isEqualTo(456L);\n \t\tassertThat(tcpInboundGateway2.getComponentName()).isEqualTo(\"inGateway2\");\n \t\tassertThat(tcpInboundGateway2.getComponentType()).isEqualTo(\"ip:tcp-inbound-gateway\");\n \t\tassertThat(dfa.getPropertyValue(\"errorChannel\")).isNull();\n\ndiff --git a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/config/xml/KafkaInboundGatewayTests.java b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/config/xml/KafkaInboundGatewayTests.java\nindex ff885b5f043..da03ee622ac 100644\n--- a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/config/xml/KafkaInboundGatewayTests.java\n+++ b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/config/xml/KafkaInboundGatewayTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2019-2022 the original author or authors.\n+ * Copyright 2019-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -67,7 +67,7 @@ public void testProps() {\n \t\tassertThat(TestUtils.getPropertyValue(this.gateway1, \"onPartitionsAssignedSeekCallback\"))\n \t\t\t\t.isSameAs(this.context.getBean(\"onPartitionsAssignedSeekCallback\"));\n \t\tassertThat(TestUtils.getPropertyValue(this.gateway1, \"messagingTemplate.sendTimeout\")).isEqualTo(5000L);\n-\t\tassertThat(TestUtils.getPropertyValue(this.gateway1, \"replyTimeout\")).isEqualTo(43L);\n+\t\tassertThat(TestUtils.getPropertyValue(this.gateway1, \"messagingTemplate.receiveTimeout\")).isEqualTo(43L);\n \t\tassertThat(TestUtils.getPropertyValue(this.gateway1, \"bindSourceRecord\", Boolean.class)).isTrue();\n \t}\n \n\ndiff --git a/spring-integration-redis/src/test/java/org/springframework/integration/redis/config/RedisQueueInboundGatewayParserTests.java b/spring-integration-redis/src/test/java/org/springframework/integration/redis/config/RedisQueueInboundGatewayParserTests.java\nindex ac6e65adc66..ee95a08c6a6 100644\n--- a/spring-integration-redis/src/test/java/org/springframework/integration/redis/config/RedisQueueInboundGatewayParserTests.java\n+++ b/spring-integration-redis/src/test/java/org/springframework/integration/redis/config/RedisQueueInboundGatewayParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2022 the original author or authors.\n+ * Copyright 2014-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,8 +16,8 @@\n \n package org.springframework.integration.redis.config;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Qualifier;\n@@ -26,8 +26,7 @@\n import org.springframework.integration.test.util.TestUtils;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -39,8 +38,7 @@\n  *\n  * since 4.1\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class RedisQueueInboundGatewayParserTests {\n \n@@ -65,20 +63,20 @@ public class RedisQueueInboundGatewayParserTests {\n \n \n \t@Test\n-\tpublic void testDefaultConfig() throws Exception {\n+\tpublic void testDefaultConfig() {\n \t\tassertThat(TestUtils.getPropertyValue(this.defaultGateway, \"extractPayload\", Boolean.class)).isFalse();\n \t\tassertThat(TestUtils.getPropertyValue(this.defaultGateway, \"serializer\")).isSameAs(this.serializer);\n \t\tassertThat(TestUtils.getPropertyValue(this.defaultGateway, \"serializerExplicitlySet\", Boolean.class)).isTrue();\n \t\tassertThat(this.defaultGateway.getReplyChannel()).isSameAs(this.receiveChannel);\n \t\tassertThat(this.defaultGateway.getRequestChannel()).isSameAs(this.requestChannel);\n-\t\tassertThat(TestUtils.getPropertyValue(this.defaultGateway, \"replyTimeout\")).isEqualTo(2000L);\n+\t\tassertThat(TestUtils.getPropertyValue(this.defaultGateway, \"messagingTemplate.receiveTimeout\")).isEqualTo(2000L);\n \t\tassertThat(TestUtils.getPropertyValue(this.defaultGateway, \"taskExecutor\")).isNotNull();\n \t\tassertThat(TestUtils.getPropertyValue(this.defaultGateway, \"autoStartup\", Boolean.class)).isFalse();\n \t\tassertThat(TestUtils.getPropertyValue(this.defaultGateway, \"phase\")).isEqualTo(3);\n \t}\n \n \t@Test\n-\tpublic void testZeroReceiveTimeoutConfig() throws Exception {\n+\tpublic void testZeroReceiveTimeoutConfig() {\n \t\tassertThat(TestUtils.getPropertyValue(this.zeroReceiveTimeoutGateway, \"receiveTimeout\")).isEqualTo(0L);\n \t}\n \n\ndiff --git a/spring-integration-ws/src/test/java/org/springframework/integration/ws/config/WebServiceInboundGatewayParserTests.java b/spring-integration-ws/src/test/java/org/springframework/integration/ws/config/WebServiceInboundGatewayParserTests.java\nindex 217434b75de..5041cb3ba2a 100644\n--- a/spring-integration-ws/src/test/java/org/springframework/integration/ws/config/WebServiceInboundGatewayParserTests.java\n+++ b/spring-integration-ws/src/test/java/org/springframework/integration/ws/config/WebServiceInboundGatewayParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,8 +20,7 @@\n import java.util.Map;\n import java.util.Properties;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n import org.mockito.Mockito;\n \n import org.springframework.beans.DirectFieldAccessor;\n@@ -39,8 +38,7 @@\n import org.springframework.messaging.PollableChannel;\n import org.springframework.oxm.Unmarshaller;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n import org.springframework.ws.context.DefaultMessageContext;\n import org.springframework.ws.context.MessageContext;\n import org.springframework.ws.soap.SoapMessage;\n@@ -57,8 +55,7 @@\n  * @author Stephane Nicoll\n  * @author Artem Bilan\n  */\n-@RunWith(SpringJUnit4ClassRunner.class)\n-@ContextConfiguration\n+@SpringJUnitConfig\n @DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)\n public class WebServiceInboundGatewayParserTests {\n \n@@ -179,9 +176,7 @@ public void testHeaderMapperReference() {\n \n \t@Test\n \tpublic void testReplyTimeout() {\n-\t\tDirectFieldAccessor accessor = new DirectFieldAccessor(replyTimeoutGateway);\n-\t\tObject replyTimeout = accessor.getPropertyValue(\"replyTimeout\");\n-\t\tassertThat(replyTimeout).isEqualTo(1234L);\n+\t\tassertThat(TestUtils.getPropertyValue(replyTimeoutGateway, \"messagingTemplate.receiveTimeout\")).isEqualTo(1234L);\n \t}\n \n \n@@ -189,8 +184,7 @@ public void testReplyTimeout() {\n \tprivate static class TestHeaderMapper implements SoapHeaderMapper {\n \n \t\t@Override\n-\t\tpublic void fromHeadersToRequest(MessageHeaders headers,\n-\t\t\t\tSoapMessage target) {\n+\t\tpublic void fromHeadersToRequest(MessageHeaders headers, SoapMessage target) {\n \t\t}\n \n \t\t@Override\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8690",
    "pr_id": 8690,
    "issue_id": 8680,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Jdbc Backed QueueChannel fail fast if DB is not initialized properly\n`JDBC` backed `MessageChannels` that aren't DB initialized properly are continuing to run on an infinite loop. It would help if it **fails fast** when the DB is not initialized properly\r\n\r\nFor more information, please refer the below SO\r\n\r\nhttps://stackoverflow.com/questions/76697482/spring-integration-jdbc-backed-queuechannel-delayed-delivery",
    "issue_word_count": 62,
    "test_files_count": 18,
    "non_test_files_count": 7,
    "pr_changed_files": [
      "build.gradle",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/metadata/JdbcMetadataStore.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcChannelMessageStore.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcMessageStore.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/JdbcMessageStoreParserTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/StoredProcMessageHandlerParserTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/advisedStoredProcOutboundChannelAdapterTest.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/basicStoredProcOutboundChannelAdapterTest.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/defaultJdbcMessageStore.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/jdbcOperationsJdbcMessageStore.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/serializerJdbcMessageStore.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/soupedUpJdbcMessageStore.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/metadata/JdbcMetadataStoreTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlContainerTest.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlJdbcMessageStoreTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/JdbcMessageStoreTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/AbstractJdbcChannelMessageStoreTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/DataSource-common-context.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/DataSource-mysql-context.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/H2JdbcChannelMessageStoreTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/MySqlJdbcChannelMessageStoreTests.java",
      "src/reference/asciidoc/jdbc.adoc",
      "src/reference/asciidoc/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/JdbcMessageStoreParserTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/StoredProcMessageHandlerParserTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/advisedStoredProcOutboundChannelAdapterTest.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/basicStoredProcOutboundChannelAdapterTest.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/defaultJdbcMessageStore.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/jdbcOperationsJdbcMessageStore.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/serializerJdbcMessageStore.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/soupedUpJdbcMessageStore.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/metadata/JdbcMetadataStoreTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlContainerTest.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlJdbcMessageStoreTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/JdbcMessageStoreTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/AbstractJdbcChannelMessageStoreTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/DataSource-common-context.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/DataSource-mysql-context.xml",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/H2JdbcChannelMessageStoreTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/MySqlJdbcChannelMessageStoreTests.java"
    ],
    "base_commit": "abcc115c2195f135c8c426920079f7593e1bf868",
    "head_commit": "b496616d6ca2bf4c10eadc17e77e29267ab2847c",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8690",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8690",
    "dockerfile": "",
    "pr_merged_at": "2023-07-28T18:47:50.000Z",
    "patch": "diff --git a/build.gradle b/build.gradle\nindex 4d4cb73d5b6..069988cd88d 100644\n--- a/build.gradle\n+++ b/build.gradle\n@@ -740,7 +740,9 @@ project('spring-integration-jdbc') {\n         testImplementation \"org.apache.derby:derbyclient:$derbyVersion\"\n         testImplementation \"org.postgresql:postgresql:$postgresVersion\"\n         testImplementation \"mysql:mysql-connector-java:$mysqlVersion\"\n-        testImplementation \"org.apache.commons:commons-dbcp2:$commonsDbcp2Version\"\n+        testImplementation (\"org.apache.commons:commons-dbcp2:$commonsDbcp2Version\") {\n+            exclude group: 'commons-logging'\n+        }\n         testImplementation 'org.testcontainers:mysql'\n         testImplementation 'org.testcontainers:postgresql'\n \n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java\nindex 7d317bbb855..4b977ff6dfd 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/DefaultLockRepository.java\n@@ -20,6 +20,7 @@\n import java.time.LocalDateTime;\n import java.time.ZoneOffset;\n import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n import javax.sql.DataSource;\n \n@@ -29,6 +30,8 @@\n import org.springframework.beans.factory.SmartInitializingSingleton;\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.core.log.LogAccessor;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.jdbc.core.JdbcTemplate;\n import org.springframework.transaction.PlatformTransactionManager;\n@@ -45,6 +48,12 @@\n  * Otherwise, it opens a possibility to break {@link java.util.concurrent.locks.Lock} contract,\n  * where {@link JdbcLockRegistry} uses non-shared {@link java.util.concurrent.locks.ReentrantLock}s\n  * for local synchronizations.\n+ * <p>\n+ * This class implements {@link SmartLifecycle} and calls\n+ * {@code SELECT COUNT(REGION) FROM %sLOCK} query\n+ * according to the provided prefix on {@link #start()} to check if required table is present in DB.\n+ * The application context will fail to start if the table is not present.\n+ * This check can be disabled via {@link #setCheckDatabaseOnStart(boolean)}.\n  *\n  * @author Dave Syer\n  * @author Artem Bilan\n@@ -56,7 +65,10 @@\n  * @since 4.3\n  */\n public class DefaultLockRepository\n-\t\timplements LockRepository, InitializingBean, ApplicationContextAware, SmartInitializingSingleton {\n+\t\timplements LockRepository, InitializingBean, ApplicationContextAware, SmartInitializingSingleton,\n+\t\tSmartLifecycle {\n+\n+\tprivate static final LogAccessor LOGGER = new LogAccessor(DefaultLockRepository.class);\n \n \t/**\n \t * Default value for the table prefix property.\n@@ -72,6 +84,8 @@ public class DefaultLockRepository\n \n \tprivate final JdbcTemplate template;\n \n+\tprivate final AtomicBoolean started = new AtomicBoolean();\n+\n \tprivate Duration ttl = DEFAULT_TTL;\n \n \tprivate String prefix = DEFAULT_TABLE_PREFIX;\n@@ -116,6 +130,10 @@ SELECT COUNT(REGION)\n \t\t\tWHERE REGION=? AND LOCK_KEY=? AND CLIENT_ID=?\n \t\t\t\"\"\";\n \n+\tprivate String countAllQuery = \"\"\"\n+\t\t\tSELECT COUNT(REGION) FROM %sLOCK\n+\t\t\t\"\"\";\n+\n \tprivate ApplicationContext applicationContext;\n \n \tprivate PlatformTransactionManager transactionManager;\n@@ -126,6 +144,8 @@ SELECT COUNT(REGION)\n \n \tprivate TransactionTemplate serializableTransactionTemplate;\n \n+\tprivate boolean checkDatabaseOnStart = true;\n+\n \t/**\n \t * Constructor that initializes the client id that will be associated for\n \t * all the locks persisted by the store instance to a random {@link UUID}.\n@@ -293,6 +313,7 @@ public void afterPropertiesSet() {\n \t\tthis.insertQuery = String.format(this.insertQuery, this.prefix);\n \t\tthis.countQuery = String.format(this.countQuery, this.prefix);\n \t\tthis.renewQuery = String.format(this.renewQuery, this.prefix);\n+\t\tthis.countAllQuery = String.format(this.countAllQuery, this.prefix);\n \t}\n \n \t@Override\n@@ -325,6 +346,41 @@ public void afterSingletonsInstantiated() {\n \t\tthis.serializableTransactionTemplate = new TransactionTemplate(this.transactionManager, transactionDefinition);\n \t}\n \n+\t/**\n+\t * The flag to perform a database check query on start or not.\n+\t * @param checkDatabaseOnStart false to not perform the database check.\n+\t * @since 6.2\n+\t */\n+\tpublic void setCheckDatabaseOnStart(boolean checkDatabaseOnStart) {\n+\t\tthis.checkDatabaseOnStart = checkDatabaseOnStart;\n+\t\tif (!checkDatabaseOnStart) {\n+\t\t\tLOGGER.info(\"The 'DefaultLockRepository' won't be started automatically \" +\n+\t\t\t\t\t\"and required table is not going be checked.\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean isAutoStartup() {\n+\t\treturn this.checkDatabaseOnStart;\n+\t}\n+\n+\t@Override\n+\tpublic void start() {\n+\t\tif (this.started.compareAndSet(false, true) && this.checkDatabaseOnStart) {\n+\t\t\tthis.template.queryForObject(this.countAllQuery, Integer.class); // If no table in DB, an exception is thrown\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void stop() {\n+\t\tthis.started.set(false);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRunning() {\n+\t\treturn this.started.get();\n+\t}\n+\n \t@Override\n \tpublic void close() {\n \t\tthis.defaultTransactionTemplate.executeWithoutResult(\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/metadata/JdbcMetadataStore.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/metadata/JdbcMetadataStore.java\nindex f27b28578d4..41d4dc7b922 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/metadata/JdbcMetadataStore.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/metadata/JdbcMetadataStore.java\n@@ -16,9 +16,13 @@\n \n package org.springframework.integration.jdbc.metadata;\n \n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import javax.sql.DataSource;\n \n import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.core.log.LogAccessor;\n import org.springframework.dao.DuplicateKeyException;\n import org.springframework.dao.EmptyResultDataAccessException;\n import org.springframework.integration.metadata.ConcurrentMetadataStore;\n@@ -34,6 +38,12 @@\n  * where <code>*</code> is the target database type.\n  * <p>\n  * The transaction management is required to use this {@link ConcurrentMetadataStore}.\n+ * <p>\n+ * This class implements {@link SmartLifecycle} and calls\n+ * {@code SELECT COUNT(METADATA_KEY) FROM %sMETADATA_STORE} query\n+ * according to the provided prefix on {@link #start()} to check if required table is present in DB.\n+ * The application context will fail to start if the table is not present.\n+ * This check can be disabled via {@link #setCheckDatabaseOnStart(boolean)}.\n  *\n  * @author Bojan Vukasovic\n  * @author Artem Bilan\n@@ -41,7 +51,9 @@\n  *\n  * @since 5.0\n  */\n-public class JdbcMetadataStore implements ConcurrentMetadataStore, InitializingBean {\n+public class JdbcMetadataStore implements ConcurrentMetadataStore, InitializingBean, SmartLifecycle {\n+\n+\tprivate static final LogAccessor LOGGER = new LogAccessor(JdbcMetadataStore.class);\n \n \tprivate static final String KEY_CANNOT_BE_NULL = \"'key' cannot be null\";\n \n@@ -52,6 +64,8 @@ public class JdbcMetadataStore implements ConcurrentMetadataStore, InitializingB\n \n \tprivate final JdbcOperations jdbcTemplate;\n \n+\tprivate final AtomicBoolean started = new AtomicBoolean();\n+\n \tprivate String tablePrefix = DEFAULT_TABLE_PREFIX;\n \n \tprivate String region = \"DEFAULT\";\n@@ -93,6 +107,12 @@ public class JdbcMetadataStore implements ConcurrentMetadataStore, InitializingB\n \t\t\tHAVING COUNT(*)=0\n \t\t\t\"\"\";\n \n+\tprivate String countQuery = \"\"\"\n+\t\t\tSELECT COUNT(METADATA_KEY) FROM %sMETADATA_STORE\n+\t\t\t\"\"\";\n+\n+\tprivate boolean checkDatabaseOnStart = true;\n+\n \t/**\n \t * Instantiate a {@link JdbcMetadataStore} using provided dataSource {@link DataSource}.\n \t * @param dataSource a {@link DataSource}\n@@ -137,7 +157,7 @@ public void setRegion(String region) {\n \t * Specify a row lock hint for the query in the lock-based operations.\n \t * Defaults to {@code FOR UPDATE}. Can be specified as an empty string,\n \t * if the target RDBMS doesn't support locking on tables from queries.\n-\t * The value depends from RDBMS vendor, e.g. SQL Server requires {@code WITH (ROWLOCK)}.\n+\t * The value depends on the RDBMS vendor, e.g. SQL Server requires {@code WITH (ROWLOCK)}.\n \t * @param lockHint the RDBMS vendor-specific lock hint.\n \t * @since 5.0.7\n \t */\n@@ -154,6 +174,42 @@ public void afterPropertiesSet() {\n \t\tthis.replaceValueByKeyQuery = String.format(this.replaceValueByKeyQuery, this.tablePrefix);\n \t\tthis.removeValueQuery = String.format(this.removeValueQuery, this.tablePrefix);\n \t\tthis.putIfAbsentValueQuery = String.format(this.putIfAbsentValueQuery, this.tablePrefix, this.tablePrefix);\n+\t\tthis.countQuery = String.format(this.putIfAbsentValueQuery, this.tablePrefix);\n+\t}\n+\n+\t/**\n+\t * The flag to perform a database check query on start or not.\n+\t * @param checkDatabaseOnStart false to not perform the database check.\n+\t * @since 6.2\n+\t */\n+\tpublic void setCheckDatabaseOnStart(boolean checkDatabaseOnStart) {\n+\t\tthis.checkDatabaseOnStart = checkDatabaseOnStart;\n+\t\tif (!checkDatabaseOnStart) {\n+\t\t\tLOGGER.info(\"The 'DefaultLockRepository' won't be started automatically \" +\n+\t\t\t\t\t\"and required table is not going be checked.\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean isAutoStartup() {\n+\t\treturn this.checkDatabaseOnStart;\n+\t}\n+\n+\t@Override\n+\tpublic void start() {\n+\t\tif (this.started.compareAndSet(false, true) && this.checkDatabaseOnStart) {\n+\t\t\tthis.jdbcTemplate.queryForObject(this.countQuery, Integer.class); // If no table in DB, an exception is thrown\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void stop() {\n+\t\tthis.started.set(false);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRunning() {\n+\t\treturn this.started.get();\n \t}\n \n \t@Override\n@@ -162,7 +218,7 @@ public String putIfAbsent(String key, String value) {\n \t\tAssert.notNull(key, KEY_CANNOT_BE_NULL);\n \t\tAssert.notNull(value, \"'value' cannot be null\");\n \t\twhile (true) {\n-\t\t\t//try to insert if does not exists\n+\t\t\t//try to insert if the entry does not exist\n \t\t\tint affectedRows = tryToPutIfAbsent(key, value);\n \t\t\tif (affectedRows > 0) {\n \t\t\t\t//it was not in the table, so we have just inserted\n@@ -218,7 +274,7 @@ public void put(String key, String value) {\n \t\tAssert.notNull(key, KEY_CANNOT_BE_NULL);\n \t\tAssert.notNull(value, \"'value' cannot be null\");\n \t\twhile (true) {\n-\t\t\t//try to insert if does not exist, if exists we will try to update it\n+\t\t\t//try to insert if the entry does not exist, if it exists we will try to update it\n \t\t\tint affectedRows = tryToPutIfAbsent(key, value);\n \t\t\tif (affectedRows == 0) {\n \t\t\t\t//since value is not inserted, means it is already present\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcChannelMessageStore.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcChannelMessageStore.java\nindex 6f179626eb4..cde3b6c546a 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcChannelMessageStore.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcChannelMessageStore.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,6 +23,7 @@\n import java.util.Set;\n import java.util.UUID;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReadWriteLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n@@ -31,6 +32,7 @@\n import javax.sql.DataSource;\n \n import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.SmartLifecycle;\n import org.springframework.core.log.LogAccessor;\n import org.springframework.core.log.LogMessage;\n import org.springframework.core.serializer.Deserializer;\n@@ -73,6 +75,11 @@\n  * The SQL scripts for creating the table are packaged\n  * under {@code org/springframework/integration/jdbc/schema-*.sql},\n  * where {@code *} denotes the target database type.\n+ * <p>\n+ * This class implements {@link SmartLifecycle} and calls {@link #getMessageGroupCount()}\n+ * on {@link #start()} to check if required table is present in DB.\n+ * The application context will fail to start if the table is not present.\n+ * This check can be disabled via {@link #setCheckDatabaseOnStart(boolean)}.\n  *\n  * @author Gunnar Hillert\n  * @author Artem Bilan\n@@ -83,7 +90,7 @@\n  * @since 2.2\n  */\n @ManagedResource\n-public class JdbcChannelMessageStore implements PriorityCapableChannelMessageStore, InitializingBean {\n+public class JdbcChannelMessageStore implements PriorityCapableChannelMessageStore, InitializingBean, SmartLifecycle {\n \n \tprivate static final LogAccessor LOGGER = new LogAccessor(JdbcChannelMessageStore.class);\n \n@@ -121,6 +128,8 @@ private enum Query {\n \n \tprivate final Lock idCacheWriteLock = this.idCacheLock.writeLock();\n \n+\tprivate final AtomicBoolean started = new AtomicBoolean();\n+\n \tprivate ChannelMessageStoreQueryProvider channelMessageStoreQueryProvider;\n \n \tprivate String region = DEFAULT_REGION;\n@@ -145,6 +154,8 @@ private enum Query {\n \n \tprivate boolean priorityEnabled;\n \n+\tprivate boolean checkDatabaseOnStart = true;\n+\n \t/**\n \t * Convenient constructor for configuration use.\n \t */\n@@ -411,6 +422,41 @@ public void afterPropertiesSet() {\n \t\tthis.jdbcTemplate.afterPropertiesSet();\n \t}\n \n+\t/**\n+\t * The flag to perform a database check query on start or not.\n+\t * @param checkDatabaseOnStart false to not perform the database check.\n+\t * @since 6.2\n+\t */\n+\tpublic void setCheckDatabaseOnStart(boolean checkDatabaseOnStart) {\n+\t\tthis.checkDatabaseOnStart = checkDatabaseOnStart;\n+\t\tif (!checkDatabaseOnStart) {\n+\t\t\tLOGGER.info(\"The 'DefaultLockRepository' won't be started automatically \" +\n+\t\t\t\t\t\"and required table is not going be checked.\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean isAutoStartup() {\n+\t\treturn this.checkDatabaseOnStart;\n+\t}\n+\n+\t@Override\n+\tpublic void start() {\n+\t\tif (this.started.compareAndSet(false, true) && this.checkDatabaseOnStart) {\n+\t\t\tgetMessageGroupCount(); // If no table in DB, an exception is thrown\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void stop() {\n+\t\tthis.started.set(false);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRunning() {\n+\t\treturn this.started.get();\n+\t}\n+\n \t/**\n \t * Store a message in the database. The groupId identifies the channel for which\n \t * the message is to be stored.\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcMessageStore.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcMessageStore.java\nindex 2f708537580..26f1fb8c148 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcMessageStore.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/store/JdbcMessageStore.java\n@@ -26,11 +26,13 @@\n import java.util.Map;\n import java.util.UUID;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.stream.Stream;\n \n import javax.sql.DataSource;\n \n import org.springframework.beans.factory.BeanClassLoaderAware;\n+import org.springframework.context.SmartLifecycle;\n import org.springframework.core.serializer.Deserializer;\n import org.springframework.core.serializer.Serializer;\n import org.springframework.core.serializer.support.SerializingConverter;\n@@ -66,6 +68,11 @@\n  * please consider using the channel-specific {@link JdbcChannelMessageStore} instead.\n  * This implementation is intended for correlation components (e.g. {@code <aggregator>}),\n  * {@code <delayer>} and similar.\n+ * <p>\n+ * This class implements {@link SmartLifecycle} and calls {@link #getMessageGroupCount()}\n+ * on {@link #start()} to check if required tables are present in DB.\n+ * The application context will fail to start if the table is not present.\n+ * This check can be disabled via {@link #setCheckDatabaseOnStart(boolean)}.\n  *\n  * @author Dave Syer\n  * @author Oleg Zhurakousky\n@@ -77,7 +84,8 @@\n  *\n  * @since 2.0\n  */\n-public class JdbcMessageStore extends AbstractMessageGroupStore implements MessageStore, BeanClassLoaderAware {\n+public class JdbcMessageStore extends AbstractMessageGroupStore\n+\t\timplements MessageStore, BeanClassLoaderAware, SmartLifecycle {\n \n \t/**\n \t * Default value for the table prefix property.\n@@ -234,6 +242,8 @@ public String getSql() {\n \n \tprivate final Map<Query, String> queryCache = new ConcurrentHashMap<>();\n \n+\tprivate final AtomicBoolean started = new AtomicBoolean();\n+\n \tprivate String region = \"DEFAULT\";\n \n \tprivate String tablePrefix = DEFAULT_TABLE_PREFIX;\n@@ -247,6 +257,8 @@ public String getSql() {\n \n \tprivate LobHandler lobHandler = new DefaultLobHandler();\n \n+\tprivate boolean checkDatabaseOnStart = true;\n+\n \t/**\n \t * Create a {@link MessageStore} with all mandatory properties.\n \t * @param dataSource a {@link DataSource}\n@@ -331,6 +343,41 @@ public void addAllowedPatterns(String... patterns) {\n \t\tthis.deserializer.addAllowedPatterns(patterns);\n \t}\n \n+\t/**\n+\t * The flag to perform a database check query on start or not.\n+\t * @param checkDatabaseOnStart false to not perform the database check.\n+\t * @since 6.2\n+\t */\n+\tpublic void setCheckDatabaseOnStart(boolean checkDatabaseOnStart) {\n+\t\tthis.checkDatabaseOnStart = checkDatabaseOnStart;\n+\t\tif (!checkDatabaseOnStart) {\n+\t\t\tlogger.info(\"The 'DefaultLockRepository' won't be started automatically \" +\n+\t\t\t\t\t\"and required table is not going be checked.\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean isAutoStartup() {\n+\t\treturn this.checkDatabaseOnStart;\n+\t}\n+\n+\t@Override\n+\tpublic void start() {\n+\t\tif (this.started.compareAndSet(false, true) && this.checkDatabaseOnStart) {\n+\t\t\tgetMessageGroupCount(); // If no table in DB, an exception is thrown\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void stop() {\n+\t\tthis.started.set(false);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isRunning() {\n+\t\treturn this.started.get();\n+\t}\n+\n \t@Override\n \tpublic Message<?> removeMessage(UUID id) {\n \t\tMessage<?> message = getMessage(id);\n\ndiff --git a/src/reference/asciidoc/jdbc.adoc b/src/reference/asciidoc/jdbc.adoc\nindex 39e4464261d..868ecc83b7a 100644\n--- a/src/reference/asciidoc/jdbc.adoc\n+++ b/src/reference/asciidoc/jdbc.adoc\n@@ -386,6 +386,7 @@ Furthermore, the index for `PriorityChannel` is commented out because it is not\n \n NOTE: When using the `OracleChannelMessageStoreQueryProvider`, the priority channel index **must** be added because it is included in a hint in the query.\n \n+[[jdbc-db-init]]\n ==== Initializing the Database\n \n Before starting to use JDBC message store components, you should provision a target database with the appropriate objects.\n@@ -397,6 +398,10 @@ A common way to use these scripts is to reference them in a https://docs.spring.\n Note that the scripts are provided as samples and as specifications of the required table and column names.\n You may find that you need to enhance them for production use (for, example, by adding index declarations).\n \n+Starting with version 6.2, the `JdbcMessageStore`, `JdbcChannelMessageStore`, `JdbcMetadataStore`, and `DefaultLockRepository` implement `SmartLifecycle` and perform a`SELECT COUNT` query, on their respective tables, in the `start()` method to ensure that the required table (according to the provided prefix) is present in the target database.\n+If the required table does not exist, the application context fails to start.\n+The check can be disabled via `setCheckDatabaseOnStart(false)`.\n+\n [[jdbc-message-store-generic]]\n ==== The Generic JDBC Message Store\n \n\ndiff --git a/src/reference/asciidoc/whats-new.adoc b/src/reference/asciidoc/whats-new.adoc\nindex ddde6a9abe7..4ede4b68b81 100644\n--- a/src/reference/asciidoc/whats-new.adoc\n+++ b/src/reference/asciidoc/whats-new.adoc\n@@ -45,3 +45,9 @@ See <<./web-sockets.adoc#websocket-client-container-attributes, WebSockets Suppo\n \n The `KafkaMessageSource` now extracts an `ErrorHandlingDeserializer` configuration from the consumer properties and re-throws `DeserializationException` extracted from failed record headers.\n See <<./kafka.adoc#kafka-inbound-pollable, Kafka Inbound Channel Adapter>> for more information.\n+\n+[[x6.2-jdbc]]\n+=== JDBC Support Changes\n+\n+The `JdbcMessageStore`, `JdbcChannelMessageStore`, `JdbcMetadataStore`, and `DefaultLockRepository` implement `SmartLifecycle` and perform a`SELECT COUNT` query, on their respective tables, in the `start()` method to ensure that the required table (according to the provided prefix) is present in the target database.\n+See <<./jdbc.adoc#jdbc-db-init, Initializing the Database>> for more information.\n",
    "test_patch": "diff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/JdbcMessageStoreParserTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/JdbcMessageStoreParserTests.java\nindex cf4ca64767c..4fa54f2889f 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/JdbcMessageStoreParserTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/JdbcMessageStoreParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2022 the original author or authors.\n+ * Copyright 2016-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,8 +20,8 @@\n import java.io.InputStream;\n import java.io.OutputStream;\n \n-import org.junit.After;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.context.support.ClassPathXmlApplicationContext;\n import org.springframework.core.serializer.DefaultDeserializer;\n@@ -81,7 +81,7 @@ public void testMessageStoreWithAttributes() {\n \t\tassertThat(ReflectionTestUtils.getField(store, \"lobHandler\")).isEqualTo(context.getBean(LobHandler.class));\n \t}\n \n-\t@After\n+\t@AfterEach\n \tpublic void tearDown() {\n \t\tif (context != null) {\n \t\t\tcontext.close();\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/StoredProcMessageHandlerParserTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/StoredProcMessageHandlerParserTests.java\nindex a1f527c4bb0..6871b58f013 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/StoredProcMessageHandlerParserTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/StoredProcMessageHandlerParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,8 +19,8 @@\n import java.sql.Types;\n import java.util.List;\n \n-import org.junit.After;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.DirectFieldAccessor;\n import org.springframework.context.ConfigurableApplicationContext;\n@@ -42,6 +42,8 @@\n /**\n  * @author Gunnar Hillert\n  * @author Gary Russell\n+ * @author Artem Bilan\n+ *\n  * @since 2.1\n  *\n  */\n@@ -54,7 +56,7 @@ public class StoredProcMessageHandlerParserTests {\n \tprivate static volatile int adviceCalled;\n \n \t@Test\n-\tpublic void testProcedureNameIsSet() throws Exception {\n+\tpublic void testProcedureNameIsSet() {\n \t\tsetUp(\"basicStoredProcOutboundChannelAdapterTest.xml\", getClass());\n \n \t\tDirectFieldAccessor accessor = new DirectFieldAccessor(this.consumer);\n@@ -72,7 +74,7 @@ public void testProcedureNameIsSet() throws Exception {\n \n \t@SuppressWarnings(\"unchecked\")\n \t@Test\n-\tpublic void testProcedurepParametersAreSet() throws Exception {\n+\tpublic void testProcedureParametersAreSet() {\n \t\tsetUp(\"basicStoredProcOutboundChannelAdapterTest.xml\", getClass());\n \n \t\tDirectFieldAccessor accessor = new DirectFieldAccessor(this.consumer);\n@@ -114,7 +116,7 @@ public void testProcedurepParametersAreSet() throws Exception {\n \n \t@SuppressWarnings(\"unchecked\")\n \t@Test\n-\tpublic void testSqlParametersAreSet() throws Exception {\n+\tpublic void testSqlParametersAreSet() {\n \t\tsetUp(\"basicStoredProcOutboundChannelAdapterTest.xml\", getClass());\n \n \t\tDirectFieldAccessor accessor = new DirectFieldAccessor(this.consumer);\n@@ -161,15 +163,15 @@ public void testSqlParametersAreSet() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void adviceCalled() throws Exception {\n+\tpublic void adviceCalled() {\n \t\tsetUp(\"advisedStoredProcOutboundChannelAdapterTest.xml\", getClass());\n \n \t\tMessageHandler handler = TestUtils.getPropertyValue(this.consumer, \"handler\", MessageHandler.class);\n-\t\thandler.handleMessage(new GenericMessage<String>(\"foo\"));\n+\t\thandler.handleMessage(new GenericMessage<>(\"foo\"));\n \t\tassertThat(adviceCalled).isEqualTo(1);\n \t}\n \n-\t@After\n+\t@AfterEach\n \tpublic void tearDown() {\n \t\tif (context != null) {\n \t\t\tcontext.close();\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/advisedStoredProcOutboundChannelAdapterTest.xml b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/advisedStoredProcOutboundChannelAdapterTest.xml\nindex dc654431e10..09ff1757b30 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/advisedStoredProcOutboundChannelAdapterTest.xml\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/advisedStoredProcOutboundChannelAdapterTest.xml\n@@ -12,9 +12,7 @@\n <int:channel id=\"target\"/>\n     <jdbc:embedded-database id=\"dataSource\" type=\"HSQL\"/>\n     \n-    <int-jdbc:message-store id=\"messageStore\" data-source=\"dataSource\"/>\n-\n-\t<int-jdbc:stored-proc-outbound-channel-adapter id=\"storedProcedureOutboundChannelAdapter\" \n+\t<int-jdbc:stored-proc-outbound-channel-adapter id=\"storedProcedureOutboundChannelAdapter\"\n \t                                               data-source=\"dataSource\" channel=\"target\"\n \t                                               stored-procedure-name=\"testProcedure1\">\n \t    <int-jdbc:sql-parameter-definition name=\"username\" direction=\"IN\"    type=\"VARCHAR\"/>\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/basicStoredProcOutboundChannelAdapterTest.xml b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/basicStoredProcOutboundChannelAdapterTest.xml\nindex e0535239ca9..f7f61e4755c 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/basicStoredProcOutboundChannelAdapterTest.xml\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/basicStoredProcOutboundChannelAdapterTest.xml\n@@ -1,30 +1,29 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <beans xmlns=\"http://www.springframework.org/schema/beans\"\n-\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-\txmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n-\txmlns:int-jdbc=\"http://www.springframework.org/schema/integration/jdbc\"\n-\txmlns:int=\"http://www.springframework.org/schema/integration\"\n-\txsi:schemaLocation=\"http://www.springframework.org/schema/jdbc https://www.springframework.org/schema/jdbc/spring-jdbc.xsd\n+\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t   xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n+\t   xmlns:int-jdbc=\"http://www.springframework.org/schema/integration/jdbc\"\n+\t   xmlns:int=\"http://www.springframework.org/schema/integration\"\n+\t   xsi:schemaLocation=\"http://www.springframework.org/schema/jdbc https://www.springframework.org/schema/jdbc/spring-jdbc.xsd\n \t\thttp://www.springframework.org/schema/integration https://www.springframework.org/schema/integration/spring-integration.xsd\n \t\thttp://www.springframework.org/schema/integration/jdbc https://www.springframework.org/schema/integration/jdbc/spring-integration-jdbc.xsd\n \t\thttp://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\">\n \n-<int:channel id=\"target\"/>\n-    <jdbc:embedded-database id=\"dataSource\" type=\"HSQL\"/>\n-    \n-    <int-jdbc:message-store id=\"messageStore\" data-source=\"dataSource\"/>\n+\t<int:channel id=\"target\"/>\n \n-\t<int-jdbc:stored-proc-outbound-channel-adapter id=\"storedProcedureOutboundChannelAdapter\" \n-\t                                               data-source=\"dataSource\" channel=\"target\"\n-\t                                               stored-procedure-name=\"testProcedure1\">\n-\t    <int-jdbc:sql-parameter-definition name=\"username\" direction=\"IN\"    type=\"VARCHAR\"/>\n-\t    <int-jdbc:sql-parameter-definition name=\"password\" direction=\"OUT\"                            />\n-\t    <int-jdbc:sql-parameter-definition name=\"age\"      direction=\"INOUT\" type=\"INTEGER\"  scale=\"5\"/>    \n-\t    <int-jdbc:sql-parameter-definition name=\"description\" />                                          \n-\t    <int-jdbc:parameter name=\"username\"    value=\"kenny\"   type=\"java.lang.String\"/>\n-\t    <int-jdbc:parameter name=\"description\" value=\"Who killed Kenny?\"/>\n-\t    <int-jdbc:parameter name=\"password\"    expression=\"payload.username\"/>\n-\t    <int-jdbc:parameter name=\"age\"         value=\"30\"      type=\"java.lang.Integer\"/>\n+\t<jdbc:embedded-database id=\"dataSource\" type=\"HSQL\"/>\n+\n+\t<int-jdbc:stored-proc-outbound-channel-adapter id=\"storedProcedureOutboundChannelAdapter\"\n+\t\t\t\t\t\t\t\t\t\t\t\t   data-source=\"dataSource\" channel=\"target\"\n+\t\t\t\t\t\t\t\t\t\t\t\t   stored-procedure-name=\"testProcedure1\">\n+\t\t<int-jdbc:sql-parameter-definition name=\"username\" direction=\"IN\" type=\"VARCHAR\"/>\n+\t\t<int-jdbc:sql-parameter-definition name=\"password\" direction=\"OUT\"/>\n+\t\t<int-jdbc:sql-parameter-definition name=\"age\" direction=\"INOUT\" type=\"INTEGER\" scale=\"5\"/>\n+\t\t<int-jdbc:sql-parameter-definition name=\"description\"/>\n+\t\t<int-jdbc:parameter name=\"username\" value=\"kenny\" type=\"java.lang.String\"/>\n+\t\t<int-jdbc:parameter name=\"description\" value=\"Who killed Kenny?\"/>\n+\t\t<int-jdbc:parameter name=\"password\" expression=\"payload.username\"/>\n+\t\t<int-jdbc:parameter name=\"age\" value=\"30\" type=\"java.lang.Integer\"/>\n \t</int-jdbc:stored-proc-outbound-channel-adapter>\n-\t\n+\n </beans>\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/defaultJdbcMessageStore.xml b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/defaultJdbcMessageStore.xml\nindex c0b59d2d158..41b9ddb10fe 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/defaultJdbcMessageStore.xml\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/defaultJdbcMessageStore.xml\n@@ -7,7 +7,10 @@\n \t\t\thttp://www.springframework.org/schema/integration/jdbc https://www.springframework.org/schema/integration/jdbc/spring-integration-jdbc.xsd\r\n \t\t\thttp://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n \r\n-\t<jdbc:embedded-database id=\"dataSource\" type=\"HSQL\"/>\r\n+\t<jdbc:embedded-database id=\"dataSource\">\r\n+\t\t<jdbc:script location=\"org/springframework/integration/jdbc/schema-drop-h2.sql\"/>\r\n+\t\t<jdbc:script location=\"org/springframework/integration/jdbc/schema-h2.sql\" />\r\n+\t</jdbc:embedded-database>\r\n \t\r\n \t<int-jdbc:message-store id=\"messageStore\" data-source=\"dataSource\"/>\r\n \r\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/jdbcOperationsJdbcMessageStore.xml b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/jdbcOperationsJdbcMessageStore.xml\nindex 2861735b432..10833741baa 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/jdbcOperationsJdbcMessageStore.xml\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/jdbcOperationsJdbcMessageStore.xml\n@@ -7,8 +7,11 @@\n \t\t\thttp://www.springframework.org/schema/integration/jdbc https://www.springframework.org/schema/integration/jdbc/spring-integration-jdbc.xsd\r\n \t\t\thttp://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n \r\n-\t<jdbc:embedded-database id=\"dataSource\" type=\"HSQL\"/>\r\n-\t\r\n+\t<jdbc:embedded-database id=\"dataSource\">\r\n+\t\t<jdbc:script location=\"org/springframework/integration/jdbc/schema-drop-h2.sql\"/>\r\n+\t\t<jdbc:script location=\"org/springframework/integration/jdbc/schema-h2.sql\" />\r\n+\t</jdbc:embedded-database>\r\n+\r\n \t<bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\r\n \t\t<constructor-arg ref=\"dataSource\"/>\r\n \t</bean>\r\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/serializerJdbcMessageStore.xml b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/serializerJdbcMessageStore.xml\nindex d02a3d824f9..54b5bb7bc04 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/serializerJdbcMessageStore.xml\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/serializerJdbcMessageStore.xml\n@@ -5,7 +5,10 @@\n \t\t\thttp://www.springframework.org/schema/integration/jdbc https://www.springframework.org/schema/integration/jdbc/spring-integration-jdbc.xsd\r\n \t\t\thttp://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n \r\n-\t<jdbc:embedded-database id=\"dataSource\" type=\"HSQL\" />\r\n+\t<jdbc:embedded-database id=\"dataSource\">\r\n+\t\t<jdbc:script location=\"org/springframework/integration/jdbc/schema-drop-h2.sql\"/>\r\n+\t\t<jdbc:script location=\"org/springframework/integration/jdbc/schema-h2.sql\" />\r\n+\t</jdbc:embedded-database>\r\n \r\n \t<bean id=\"serializer\" class=\"org.springframework.integration.jdbc.config.JdbcMessageStoreParserTests$EnhancedSerializer\" />\r\n \r\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/soupedUpJdbcMessageStore.xml b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/soupedUpJdbcMessageStore.xml\nindex c614b7cb7c5..d5e6a890021 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/soupedUpJdbcMessageStore.xml\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/config/soupedUpJdbcMessageStore.xml\n@@ -2,15 +2,19 @@\n <beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n \txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n \txmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\r\n-\txmlns:int-jdbc=\"http://www.springframework.org/schema/integration/jdbc\"\r\n \txsi:schemaLocation=\"http://www.springframework.org/schema/jdbc https://www.springframework.org/schema/jdbc/spring-jdbc.xsd\r\n-\t\t\thttp://www.springframework.org/schema/integration/jdbc https://www.springframework.org/schema/integration/jdbc/spring-integration-jdbc.xsd\r\n \t\t\thttp://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n \r\n \t<jdbc:embedded-database id=\"dataSource\" type=\"HSQL\"/>\r\n-\t\r\n-\t<int-jdbc:message-store id=\"messageStore\" data-source=\"dataSource\" lob-handler=\"lobHandler\" region=\"FOO\" table-prefix=\"BAR_\"/>\r\n-\t\r\n+\r\n+\t<bean id=\"messageStore\" class=\"org.springframework.integration.jdbc.store.JdbcMessageStore\">\r\n+\t\t<constructor-arg ref=\"dataSource\"/>\r\n+\t\t<property name=\"lobHandler\" ref=\"lobHandler\"/>\r\n+\t\t<property name=\"region\" value=\"FOO\"/>\r\n+\t\t<property name=\"tablePrefix\" value=\"BAR_\"/>\r\n+\t\t<property name=\"checkDatabaseOnStart\" value=\"false\"/>\r\n+\t</bean>\r\n+\r\n \t<bean id=\"lobHandler\" class=\"org.springframework.jdbc.support.lob.DefaultLobHandler\"/>\r\n \r\n </beans>\r\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryTests.java\nindex f9ac8fe0e32..0e6be45ac13 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/lock/JdbcLockRegistryTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2022 the original author or authors.\n+ * Copyright 2016-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -29,17 +29,20 @@\n \n import javax.sql.DataSource;\n \n+import org.h2.jdbc.JdbcSQLSyntaxErrorException;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextException;\n import org.springframework.core.task.AsyncTaskExecutor;\n import org.springframework.core.task.SimpleAsyncTaskExecutor;\n import org.springframework.integration.test.util.TestUtils;\n import org.springframework.integration.util.UUIDConverter;\n import org.springframework.test.annotation.DirtiesContext;\n import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n+import org.springframework.transaction.PlatformTransactionManager;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n@@ -68,6 +71,9 @@ public class JdbcLockRegistryTests {\n \t@Autowired\n \tprivate DataSource dataSource;\n \n+\t@Autowired\n+\tprivate PlatformTransactionManager transactionManager;\n+\n \t@Autowired\n \tprivate ApplicationContext context;\n \n@@ -483,6 +489,20 @@ public void setCapacityTest() {\n \t\t\t\ttoUUID(\"foo:5\"));\n \t}\n \n+\t@Test\n+\tvoid noTableThrowsExceptionOnStart() {\n+\t\ttry (TestUtils.TestApplicationContext testApplicationContext = TestUtils.createTestApplicationContext()) {\n+\t\t\tDefaultLockRepository client = new DefaultLockRepository(this.dataSource);\n+\t\t\tclient.setPrefix(\"TEST_\");\n+\t\t\tclient.setTransactionManager(this.transactionManager);\n+\t\t\ttestApplicationContext.registerBean(\"client\", client);\n+\t\t\tassertThatExceptionOfType(ApplicationContextException.class)\n+\t\t\t\t\t.isThrownBy(testApplicationContext::refresh)\n+\t\t\t\t\t.withRootCauseExactlyInstanceOf(JdbcSQLSyntaxErrorException.class)\n+\t\t\t\t\t.withStackTraceContaining(\"Table \\\"TEST_LOCK\\\" not found\");\n+\t\t}\n+\t}\n+\n \t@SuppressWarnings(\"unchecked\")\n \tprivate static Map<String, Lock> getRegistryLocks(JdbcLockRegistry registry) {\n \t\treturn TestUtils.getPropertyValue(registry, \"locks\", Map.class);\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/metadata/JdbcMetadataStoreTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/metadata/JdbcMetadataStoreTests.java\nindex effbc22ee3b..bb637ad3763 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/metadata/JdbcMetadataStoreTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/metadata/JdbcMetadataStoreTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2017-2022 the original author or authors.\n+ * Copyright 2017-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,15 +18,19 @@\n \n import javax.sql.DataSource;\n \n+import org.apache.derby.shared.common.error.StandardException;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.ApplicationContextException;\n+import org.springframework.integration.test.util.TestUtils;\n import org.springframework.test.annotation.DirtiesContext;\n import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n import org.springframework.transaction.annotation.Transactional;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n \n /**\n  * @author Bojan Vukasovic\n@@ -105,4 +109,17 @@ public void existingKeyValueIsNotReplacedWithNewValueWhenOldValueDoesNotMatch()\n \t\tassertThat(bar).isEqualTo(\"bar\");\n \t}\n \n+\t@Test\n+\tvoid noTableThrowsExceptionOnStart() {\n+\t\ttry (TestUtils.TestApplicationContext testApplicationContext = TestUtils.createTestApplicationContext()) {\n+\t\t\tJdbcMetadataStore jdbcMetadataStore = new JdbcMetadataStore(this.dataSource);\n+\t\t\tjdbcMetadataStore.setTablePrefix(\"TEST_\");\n+\t\t\ttestApplicationContext.registerBean(\"jdbcMetadataStore\", jdbcMetadataStore);\n+\t\t\tassertThatExceptionOfType(ApplicationContextException.class)\n+\t\t\t\t\t.isThrownBy(testApplicationContext::refresh)\n+\t\t\t\t\t.withRootCauseExactlyInstanceOf(StandardException.class)\n+\t\t\t\t\t.withStackTraceContaining(\"Table/View 'TEST_METADATA_STORE' does not exist\");\n+\t\t}\n+\t}\n+\n }\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlContainerTest.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlContainerTest.java\nindex 69c5e3b9643..b5089d985a5 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlContainerTest.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlContainerTest.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2021-2022 the original author or authors.\n+ * Copyright 2021-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,9 @@\n \n package org.springframework.integration.jdbc.mysql;\n \n+import javax.sql.DataSource;\n+\n+import org.apache.commons.dbcp2.BasicDataSource;\n import org.junit.jupiter.api.BeforeAll;\n import org.testcontainers.containers.MySQLContainer;\n import org.testcontainers.junit.jupiter.Testcontainers;\n@@ -57,4 +60,13 @@ static String getPassword() {\n \t\treturn MY_SQL_CONTAINER.getPassword();\n \t}\n \n+\tstatic DataSource dataSource() {\n+\t\tBasicDataSource dataSource = new BasicDataSource();\n+\t\tdataSource.setDriverClassName(getDriverClassName());\n+\t\tdataSource.setUrl(getJdbcUrl());\n+\t\tdataSource.setUsername(getUsername());\n+\t\tdataSource.setPassword(getPassword());\n+\t\treturn dataSource;\n+\t}\n+\n }\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlJdbcMessageStoreTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlJdbcMessageStoreTests.java\nindex 7c6b3d3718d..979ad02c7bb 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlJdbcMessageStoreTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/mysql/MySqlJdbcMessageStoreTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,7 +23,6 @@\n \n import javax.sql.DataSource;\n \n-import org.apache.commons.dbcp2.BasicDataSource;\n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n import org.junit.jupiter.api.AfterEach;\n@@ -509,12 +508,7 @@ public static class Config {\n \n \t\t@Bean\n \t\tDataSource dataSource() {\n-\t\t\tBasicDataSource dataSource = new BasicDataSource();\n-\t\t\tdataSource.setDriverClassName(MySqlContainerTest.getDriverClassName());\n-\t\t\tdataSource.setUrl(MySqlContainerTest.getJdbcUrl());\n-\t\t\tdataSource.setUsername(MySqlContainerTest.getUsername());\n-\t\t\tdataSource.setPassword(MySqlContainerTest.getPassword());\n-\t\t\treturn dataSource;\n+\t\t\treturn MySqlContainerTest.dataSource();\n \t\t}\n \n \t\t@Bean\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/JdbcMessageStoreTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/JdbcMessageStoreTests.java\nindex 4734b020213..5976824b547 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/JdbcMessageStoreTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/JdbcMessageStoreTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -37,11 +37,13 @@\n import org.apache.commons.pool2.ObjectPool;\n import org.apache.commons.pool2.impl.GenericObjectPool;\n import org.apache.commons.pool2.impl.GenericObjectPoolConfig;\n+import org.hsqldb.HsqlException;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.support.DefaultListableBeanFactory;\n+import org.springframework.context.ApplicationContextException;\n import org.springframework.core.MethodParameter;\n import org.springframework.core.annotation.SynthesizingMethodParameter;\n import org.springframework.integration.IntegrationMessageHeaderAccessor;\n@@ -51,6 +53,7 @@\n import org.springframework.integration.store.MessageGroup;\n import org.springframework.integration.support.MessageBuilder;\n import org.springframework.integration.test.predicate.MessagePredicate;\n+import org.springframework.integration.test.util.TestUtils;\n import org.springframework.integration.util.UUIDConverter;\n import org.springframework.jdbc.core.JdbcTemplate;\n import org.springframework.jdbc.core.PreparedStatementSetter;\n@@ -62,6 +65,7 @@\n import org.springframework.transaction.annotation.Transactional;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n \n /**\n  * @author Dave Syer\n@@ -577,6 +581,19 @@ public void testMessageGroupStreamNoConnectionPoolLeak() throws NoSuchMethodExce\n \t\tpooledMessageStore.removeMessageGroup(groupId);\n \t}\n \n+\t@Test\n+\tvoid noTableThrowsExceptionOnStart() {\n+\t\ttry (TestUtils.TestApplicationContext testApplicationContext = TestUtils.createTestApplicationContext()) {\n+\t\t\tJdbcMessageStore jdbcMessageStore = new JdbcMessageStore(this.dataSource);\n+\t\t\tjdbcMessageStore.setTablePrefix(\"TEST_\");\n+\t\t\ttestApplicationContext.registerBean(\"jdbcMessageStore\", jdbcMessageStore);\n+\t\t\tassertThatExceptionOfType(ApplicationContextException.class)\n+\t\t\t\t\t.isThrownBy(testApplicationContext::refresh)\n+\t\t\t\t\t.withRootCauseExactlyInstanceOf(HsqlException.class)\n+\t\t\t\t\t.withStackTraceContaining(\"user lacks privilege or object not found: TEST_MESSAGE_GROUP\");\n+\t\t}\n+\t}\n+\n \tpublic void methodForCollectionOfPayloads(Collection<String> payloads) {\n \t}\n \n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/AbstractJdbcChannelMessageStoreTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/AbstractJdbcChannelMessageStoreTests.java\nindex 54e540d7769..ea8e3db81bc 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/AbstractJdbcChannelMessageStoreTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/AbstractJdbcChannelMessageStoreTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,9 +21,8 @@\n \n import javax.sql.DataSource;\n \n-import org.junit.Before;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.core.serializer.support.SerializingConverter;\n@@ -33,7 +32,7 @@\n import org.springframework.jdbc.support.lob.LobHandler;\n import org.springframework.messaging.Message;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.junit4.SpringRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n import org.springframework.transaction.PlatformTransactionManager;\n import org.springframework.transaction.TransactionDefinition;\n import org.springframework.transaction.TransactionStatus;\n@@ -50,13 +49,13 @@\n  * @author Artem Bilan\n  */\n \n-@RunWith(SpringRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public abstract class AbstractJdbcChannelMessageStoreTests {\n \n \tprotected static final String TEST_MESSAGE_GROUP = \"AbstractJdbcChannelMessageStoreTests\";\n \n-\tprivate static final String REGION = \"AbstractJdbcChannelMessageStoreTests\";\n+\tprotected static final String REGION = \"AbstractJdbcChannelMessageStoreTests\";\n \n \t@Autowired\n \tprotected DataSource dataSource;\n@@ -69,8 +68,8 @@ public abstract class AbstractJdbcChannelMessageStoreTests {\n \t@Autowired\n \tprotected ChannelMessageStoreQueryProvider queryProvider;\n \n-\t@Before\n-\tpublic void init() throws Exception {\n+\t@BeforeEach\n+\tpublic void init() {\n \t\tmessageStore = new JdbcChannelMessageStore(dataSource);\n \t\tmessageStore.setRegion(REGION);\n \t\tmessageStore.setChannelMessageStoreQueryProvider(queryProvider);\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/DataSource-common-context.xml b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/DataSource-common-context.xml\nindex d3590a290e2..5291a91ffd6 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/DataSource-common-context.xml\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/DataSource-common-context.xml\n@@ -1,16 +1,11 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <beans xmlns=\"http://www.springframework.org/schema/beans\"\n \txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-\txmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n-\txsi:schemaLocation=\"http://www.springframework.org/schema/jdbc https://www.springframework.org/schema/jdbc/spring-jdbc.xsd\n-\t\t\thttp://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\">\n+\txsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\">\n \n \t<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n \t\t<property name=\"dataSource\" ref=\"dataSource\" />\n-\t\t<!-- <property name=\"defaultTimeout\" value=\"2000\" /> -->\n-\t\t<!-- Postgres 9 does not support send timeouts. You may see an exception like:\n-\t\t\"java.sql.SQLFeatureNotSupportedException: Method org.postgresql.jdbc4.Jdbc4PreparedStatement.setQueryTimeout(int) is not yet implemented.\"\n-\t\t-->\n+\t\t <property name=\"defaultTimeout\" value=\"2000\" />\n \t</bean>\n \n </beans>\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/DataSource-mysql-context.xml b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/DataSource-mysql-context.xml\nindex 64be219c5c7..9c00bb28dbc 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/DataSource-mysql-context.xml\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/DataSource-mysql-context.xml\n@@ -1,22 +1,22 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <beans xmlns=\"http://www.springframework.org/schema/beans\"\n-\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-\txmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n-\txsi:schemaLocation=\"\n-\t\thttp://www.springframework.org/schema/jdbc https://www.springframework.org/schema/jdbc/spring-jdbc.xsd\n-\t\thttp://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\">\n+\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t   xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n+\t   xsi:schemaLocation=\"\n+\t   http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n+\t   http://www.springframework.org/schema/jdbc https://www.springframework.org/schema/jdbc/spring-jdbc.xsd\">\n \n-\t<import resource=\"classpath:org/springframework/integration/jdbc/store/channel/DataSource-common-context.xml\" />\n+\t<import resource=\"classpath:org/springframework/integration/jdbc/store/channel/DataSource-common-context.xml\"/>\n \n-\t<bean id=\"dataSource\" destroy-method=\"close\"\n-\t\tclass=\"org.apache.commons.dbcp2.BasicDataSource\">\n-\t\t<property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" />\n-\t\t<property name=\"url\" value=\"jdbc:mysql://localhost/test\" />\n-\t\t<property name=\"username\" value=\"root\" />\n-\t\t<property name=\"password\" value=\"\" />\n-\t\t<property name=\"initialSize\" value=\"10\" />\n-\t</bean>\n+\t<bean id=\"dataSource\" class=\"org.springframework.integration.jdbc.mysql.MySqlContainerTest\"\n+\t\t  factory-method=\"dataSource\"/>\n \n-\t<bean id=\"queryProvider\" class=\"org.springframework.integration.jdbc.store.channel.MySqlChannelMessageStoreQueryProvider\"/>\n+\t<jdbc:initialize-database ignore-failures=\"ALL\">\n+\t\t<jdbc:script location=\"classpath:org/springframework/integration/jdbc/schema-drop-mysql.sql\" />\n+\t\t<jdbc:script location=\"classpath:org/springframework/integration/jdbc/schema-mysql.sql\" />\n+\t</jdbc:initialize-database>\n+\n+\t<bean id=\"queryProvider\"\n+\t\t  class=\"org.springframework.integration.jdbc.store.channel.MySqlChannelMessageStoreQueryProvider\"/>\n \n </beans>\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/H2JdbcChannelMessageStoreTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/H2JdbcChannelMessageStoreTests.java\nindex c750dd4be00..b19112f38fc 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/H2JdbcChannelMessageStoreTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/H2JdbcChannelMessageStoreTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2019 the original author or authors.\n+ * Copyright 2016-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,11 +16,37 @@\n \n package org.springframework.integration.jdbc.store.channel;\n \n+import org.h2.jdbc.JdbcSQLSyntaxErrorException;\n+import org.junit.jupiter.api.Test;\n+\n+import org.springframework.context.ApplicationContextException;\n+import org.springframework.integration.jdbc.store.JdbcChannelMessageStore;\n+import org.springframework.integration.test.util.TestUtils;\n+import org.springframework.test.context.ContextConfiguration;\n+\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+\n /**\n  * @author Gunnar Hillert\n  * @author Manuel Jordan\n  * @since 4.3\n  */\n+@ContextConfiguration\n public class H2JdbcChannelMessageStoreTests extends AbstractJdbcChannelMessageStoreTests {\n \n+\t@Test\n+\tvoid noTableThrowsExceptionOnStart() {\n+\t\ttry (TestUtils.TestApplicationContext testApplicationContext = TestUtils.createTestApplicationContext()) {\n+\t\t\tJdbcChannelMessageStore jdbcChannelMessageStore = new JdbcChannelMessageStore(this.dataSource);\n+\t\t\tjdbcChannelMessageStore.setTablePrefix(\"TEST_\");\n+\t\t\tjdbcChannelMessageStore.setRegion(REGION);\n+\t\t\tjdbcChannelMessageStore.setChannelMessageStoreQueryProvider(this.queryProvider);\n+\t\t\ttestApplicationContext.registerBean(\"jdbcChannelMessageStore\", jdbcChannelMessageStore);\n+\t\t\tassertThatExceptionOfType(ApplicationContextException.class)\n+\t\t\t\t\t.isThrownBy(testApplicationContext::refresh)\n+\t\t\t\t\t.withRootCauseExactlyInstanceOf(JdbcSQLSyntaxErrorException.class)\n+\t\t\t\t\t.withStackTraceContaining(\"Table \\\"TEST_CHANNEL_MESSAGE\\\" not found\");\n+\t\t}\n+\t}\n+\n }\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/MySqlJdbcChannelMessageStoreTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/MySqlJdbcChannelMessageStoreTests.java\nindex 7bcdae182d6..e90a8a2a602 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/MySqlJdbcChannelMessageStoreTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/store/channel/MySqlJdbcChannelMessageStoreTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,15 +16,15 @@\n \n package org.springframework.integration.jdbc.store.channel;\n \n-import org.junit.Ignore;\n-\n+import org.springframework.integration.jdbc.mysql.MySqlContainerTest;\n import org.springframework.test.context.ContextConfiguration;\n \n /**\n  * @author Gunnar Hillert\n+ * @author Artem Bilan\n  */\n-@Ignore\n @ContextConfiguration\n-public class MySqlJdbcChannelMessageStoreTests extends AbstractJdbcChannelMessageStoreTests {\n+public class MySqlJdbcChannelMessageStoreTests extends AbstractJdbcChannelMessageStoreTests\n+\t\timplements MySqlContainerTest {\n \n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8689",
    "pr_id": 8689,
    "issue_id": 3696,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Support ErrorHandlingDeserializer in KafkaMessageSource\n**Expected Behavior**\r\n\r\nSimilar logic to the listener container - send deserialization exceptions to the error channel.\r\n\r\n**Current Behavior**\r\n\r\nUser has to manually move past the bad record by setting the offset.\r\n\r\n**Context**\r\n",
    "issue_word_count": 35,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "build.gradle",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceIntegrationTests.java",
      "src/reference/asciidoc/kafka.adoc",
      "src/reference/asciidoc/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceIntegrationTests.java"
    ],
    "base_commit": "bd013e095cad2be4045c19e5917a4d8c50154faf",
    "head_commit": "d5a8f24dc5576e40f1acf85aaaa7b6d58b4c4851",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8689",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8689",
    "dockerfile": "",
    "pr_merged_at": "2023-07-26T20:19:44.000Z",
    "patch": "diff --git a/build.gradle b/build.gradle\nindex 2eda6459de9..4d4cb73d5b6 100644\n--- a/build.gradle\n+++ b/build.gradle\n@@ -105,7 +105,7 @@ ext {\n     springAmqpVersion = '3.0.6'\n     springDataVersion = '2023.1.0-M1'\n     springGraphqlVersion = '1.2.2'\n-    springKafkaVersion = '3.0.9'\n+    springKafkaVersion = '3.0.10-SNAPSHOT'\n     springRetryVersion = '2.0.2'\n     springSecurityVersion = '6.2.0-M1'\n     springVersion = '6.1.0-M2'\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java\nindex 96d1e18180e..40b08c7028a 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java\n@@ -26,6 +26,7 @@\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Properties;\n import java.util.Set;\n import java.util.TreeSet;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -46,6 +47,7 @@\n import org.apache.kafka.common.TopicPartition;\n import org.apache.kafka.common.errors.WakeupException;\n \n+import org.springframework.beans.factory.BeanClassLoaderAware;\n import org.springframework.core.log.LogAccessor;\n import org.springframework.integration.IntegrationMessageHeaderAccessor;\n import org.springframework.integration.acks.AcknowledgmentCallback;\n@@ -58,6 +60,8 @@\n import org.springframework.kafka.core.DefaultKafkaConsumerFactory;\n import org.springframework.kafka.listener.ConsumerAwareRebalanceListener;\n import org.springframework.kafka.listener.ConsumerProperties;\n+import org.springframework.kafka.listener.ErrorHandlingUtils;\n+import org.springframework.kafka.listener.ListenerUtils;\n import org.springframework.kafka.listener.LoggingCommitCallback;\n import org.springframework.kafka.support.Acknowledgment;\n import org.springframework.kafka.support.DefaultKafkaHeaderMapper;\n@@ -69,6 +73,8 @@\n import org.springframework.kafka.support.converter.KafkaMessageHeaders;\n import org.springframework.kafka.support.converter.MessagingMessageConverter;\n import org.springframework.kafka.support.converter.RecordMessageConverter;\n+import org.springframework.kafka.support.serializer.DeserializationException;\n+import org.springframework.kafka.support.serializer.SerializationUtils;\n import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.util.Assert;\n@@ -102,7 +108,8 @@\n  * @since 5.4\n  *\n  */\n-public class KafkaMessageSource<K, V> extends AbstractMessageSource<Object> implements Pausable {\n+public class KafkaMessageSource<K, V> extends AbstractMessageSource<Object>\n+\t\timplements Pausable, BeanClassLoaderAware {\n \n \tprivate static final long MIN_ASSIGN_TIMEOUT = 2000L;\n \n@@ -146,6 +153,10 @@ public class KafkaMessageSource<K, V> extends AbstractMessageSource<Object> impl\n \n \tprivate Duration closeTimeout = Duration.ofSeconds(DEFAULT_CLOSE_TIMEOUT);\n \n+\tprivate boolean checkNullKeyForExceptions;\n+\n+\tprivate boolean checkNullValueForExceptions;\n+\n \tprivate volatile Consumer<K, V> consumer;\n \n \tprivate volatile boolean pausing;\n@@ -158,6 +169,8 @@ public class KafkaMessageSource<K, V> extends AbstractMessageSource<Object> impl\n \n \tpublic volatile boolean newAssignment; // NOSONAR - direct access from inner\n \n+\tprivate ClassLoader classLoader;\n+\n \t/**\n \t * Construct an instance with the supplied parameters. Fetching multiple\n \t * records per poll will be disabled.\n@@ -257,11 +270,27 @@ public Collection<TopicPartition> getAssignedPartitions() {\n \t\treturn Collections.unmodifiableCollection(this.assignedPartitions);\n \t}\n \n+\t@Override\n+\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n+\t\tthis.classLoader = classLoader;\n+\t}\n+\n \t@Override\n \tprotected void onInit() {\n \t\tif (!StringUtils.hasText(this.consumerProperties.getClientId())) {\n \t\t\tthis.consumerProperties.setClientId(getComponentName());\n \t\t}\n+\n+\t\tMap<String, Object> props = this.consumerFactory.getConfigurationProperties();\n+\t\tProperties kafkaConsumerProperties = this.consumerProperties.getKafkaConsumerProperties();\n+\t\tthis.checkNullKeyForExceptions =\n+\t\t\t\tthis.consumerProperties.isCheckDeserExWhenKeyNull() ||\n+\t\t\t\t\t\tErrorHandlingUtils.checkDeserializer(this.consumerFactory, kafkaConsumerProperties, false,\n+\t\t\t\t\t\t\t\tthis.classLoader);\n+\t\tthis.checkNullValueForExceptions =\n+\t\t\t\tthis.consumerProperties.isCheckDeserExWhenValueNull() ||\n+\t\t\t\t\t\tErrorHandlingUtils.checkDeserializer(this.consumerFactory, kafkaConsumerProperties, true,\n+\t\t\t\t\t\t\t\tthis.classLoader);\n \t}\n \n \t/**\n@@ -609,6 +638,13 @@ record = this.recordsIterator.next();\n \t}\n \n \tprivate Object recordToMessage(ConsumerRecord<K, V> record) {\n+\t\tif (record.value() == null && this.checkNullValueForExceptions) {\n+\t\t\tcheckDeserializationException(record, SerializationUtils.VALUE_DESERIALIZER_EXCEPTION_HEADER);\n+\t\t}\n+\t\tif (record.key() == null && this.checkNullKeyForExceptions) {\n+\t\t\tcheckDeserializationException(record, SerializationUtils.KEY_DESERIALIZER_EXCEPTION_HEADER);\n+\t\t}\n+\n \t\tTopicPartition topicPartition = new TopicPartition(record.topic(), record.partition());\n \t\tKafkaAckInfo<K, V> ackInfo = new KafkaAckInfoImpl(record, topicPartition);\n \t\tAcknowledgmentCallback ackCallback = this.ackCallbackFactory.createCallback(ackInfo);\n@@ -639,6 +675,13 @@ private Object recordToMessage(ConsumerRecord<K, V> record) {\n \t\t}\n \t}\n \n+\tprivate void checkDeserializationException(ConsumerRecord<K, V> cRecord, String headerName) {\n+\t\tDeserializationException exception = ListenerUtils.getExceptionFromHeader(cRecord, headerName, this.logger);\n+\t\tif (exception != null) {\n+\t\t\tthrow exception;\n+\t\t}\n+\t}\n+\n \t@Override\n \tpublic void destroy() {\n \t\tthis.lock.lock();\n\ndiff --git a/src/reference/asciidoc/kafka.adoc b/src/reference/asciidoc/kafka.adoc\nindex 33f7d746d92..650b18d08f8 100644\n--- a/src/reference/asciidoc/kafka.adoc\n+++ b/src/reference/asciidoc/kafka.adoc\n@@ -436,6 +436,11 @@ If you set `allowMultiFetch` to `true` you must process all the retrieved record\n \n Messages emitted by this adapter contain a header `kafka_remainingRecords` with a count of records remaining from the previous poll.\n \n+Starting with version `6.2`, the `KafkaMessageSource` supports an `ErrorHandlingDeserializer` provided in the consumer properties.\n+A `DeserializationException` is extracted from record headers and thrown to the called.\n+With a `SourcePollingChannelAdapter` this exception is wrapped into an `ErrorMessage` and published to its `errorChannel`.\n+See https://docs.spring.io/spring-kafka/reference/html/#error-handling-deserializer[`ErrorHandlingDeserializer`] documentation for more information.\n+\n [[kafka-outbound-gateway]]\n === Outbound Gateway\n \n@@ -448,7 +453,7 @@ It is suggested that you add a `ConsumerRebalanceListener` to the template's rep\n \n The `KafkaProducerMessageHandler` `sendTimeoutExpression` default is `delivery.timeout.ms` Kafka producer property `+ 5000` so that the actual Kafka error after a timeout is propagated to the application, instead of a timeout generated by this framework.\n This has been changed for consistency because you may get unexpected behavior (Spring may time out the `send()`, while it is actually, eventually, successful).\n-IMPORTANT: That timeout is 120 seconds by default so you may wish to reduce it to get more timely failures.\n+IMPORTANT: That timeout is 120 seconds by default, so you may wish to reduce it to get more timely failures.\n \n [[kafka-outbound-gateway-configuration]]\n ==== Configuration\n\ndiff --git a/src/reference/asciidoc/whats-new.adoc b/src/reference/asciidoc/whats-new.adoc\nindex 17250f46b5e..ddde6a9abe7 100644\n--- a/src/reference/asciidoc/whats-new.adoc\n+++ b/src/reference/asciidoc/whats-new.adoc\n@@ -38,3 +38,10 @@ See, for example, `transformWith()`, `splitWith()` in <<./dsl.adoc#java-dsl, Jav\n - For the server and client WebSocket containers, the send buffer overflow strategy is now configurable in `IntegrationWebSocketContainer` and in XML via `send-buffer-overflow-strategy`.\n This strategy determines the behavior when a session's outbound message buffer has reached the configured limit.\n See <<./web-sockets.adoc#websocket-client-container-attributes, WebSockets Support>> for more information.\n+\n+\n+[[x6.2-kafka]]\n+=== Apache Kafka Support Changes\n+\n+The `KafkaMessageSource` now extracts an `ErrorHandlingDeserializer` configuration from the consumer properties and re-throws `DeserializationException` extracted from failed record headers.\n+See <<./kafka.adoc#kafka-inbound-pollable, Kafka Inbound Channel Adapter>> for more information.\n",
    "test_patch": "diff --git a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceIntegrationTests.java b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceIntegrationTests.java\nindex dbcfeee8579..573cbd12594 100644\n--- a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceIntegrationTests.java\n+++ b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceIntegrationTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018-2022 the original author or authors.\n+ * Copyright 2018-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -24,6 +24,8 @@\n import org.apache.kafka.clients.consumer.ConsumerConfig;\n import org.apache.kafka.clients.consumer.ConsumerRebalanceListener;\n import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n \n import org.springframework.integration.channel.NullChannel;\n@@ -32,11 +34,17 @@\n import org.springframework.kafka.core.DefaultKafkaProducerFactory;\n import org.springframework.kafka.core.KafkaTemplate;\n import org.springframework.kafka.listener.ConsumerProperties;\n+import org.springframework.kafka.support.serializer.DeserializationException;\n+import org.springframework.kafka.support.serializer.ErrorHandlingDeserializer;\n import org.springframework.kafka.test.utils.KafkaTestUtils;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.support.GenericMessage;\n+import org.springframework.util.ClassUtils;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.awaitility.Awaitility.await;\n+import static org.mockito.Mockito.mock;\n \n /**\n  * @author Gary Russell\n@@ -50,9 +58,17 @@ class MessageSourceIntegrationTests {\n \n \tstatic final String TOPIC1 = \"MessageSourceIntegrationTests1\";\n \n+\tstatic final String TOPIC2 = \"MessageSourceIntegrationTests2\";\n+\n+\tstatic String brokers;\n+\n+\t@BeforeAll\n+\tstatic void setup() {\n+\t\tbrokers = System.getProperty(\"spring.global.embedded.kafka.brokers\");\n+\t}\n+\n \t@Test\n \tvoid testSource() throws Exception {\n-\t\tString brokers = System.getProperty(\"spring.global.embedded.kafka.brokers\");\n \t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(brokers, \"testSource\", \"false\");\n \t\tconsumerProps.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 2);\n \t\tconsumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n@@ -122,4 +138,48 @@ public void onPartitionsAssigned(Collection<TopicPartition> partitions) {\n \t\ttemplate.destroy();\n \t}\n \n+\t@Test\n+\tvoid deserializationErrorIsThrownFromSource() throws Exception {\n+\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(brokers, \"testErrorChannelSource\", \"false\");\n+\t\tconsumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);\n+\t\tconsumerProps.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, FailingDeserializer.class);\n+\n+\t\tDefaultKafkaConsumerFactory<Integer, String> consumerFactory = new DefaultKafkaConsumerFactory<>(consumerProps);\n+\t\tConsumerProperties consumerProperties = new ConsumerProperties(TOPIC2);\n+\n+\t\tconsumerProperties.setPollTimeout(10);\n+\n+\t\tKafkaMessageSource<Integer, String> source = new KafkaMessageSource<>(consumerFactory, consumerProperties);\n+\t\tsource.setBeanClassLoader(ClassUtils.getDefaultClassLoader());\n+\t\tsource.setBeanFactory(mock());\n+\t\tsource.afterPropertiesSet();\n+\t\tsource.start();\n+\n+\t\tMap<String, Object> producerProps = KafkaTestUtils.producerProps(brokers);\n+\t\tDefaultKafkaProducerFactory<Object, Object> producerFactory = new DefaultKafkaProducerFactory<>(producerProps);\n+\t\tKafkaTemplate<Object, Object> template = new KafkaTemplate<>(producerFactory);\n+\n+\t\tString testData = \"test data\";\n+\t\ttemplate.send(TOPIC2, testData);\n+\n+\t\tawait().untilAsserted(() ->\n+\t\t\t\tassertThatExceptionOfType(DeserializationException.class)\n+\t\t\t\t\t\t.isThrownBy(source::receive)\n+\t\t\t\t\t\t.hasFieldOrPropertyWithValue(\"data\", testData.getBytes())\n+\t\t\t\t\t\t.withMessage(\"failed to deserialize\")\n+\t\t\t\t\t\t.withStackTraceContaining(\"failed deserialization\"));\n+\n+\t\tsource.destroy();\n+\t\ttemplate.destroy();\n+\t}\n+\n+\tpublic static class FailingDeserializer implements Deserializer<String> {\n+\n+\t\t@Override\n+\t\tpublic String deserialize(String topic, byte[] data) {\n+\t\t\tthrow new RuntimeException(\"failed deserialization\");\n+\t\t}\n+\n+\t}\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8686",
    "pr_id": 8686,
    "issue_id": 8685,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "ForceReleaseProcessor will never be run when group condition is used and MongoDbMessageStore\n**In what version(s) of Spring Integration are you seeing this issue?**\r\n\r\n6.1.0\r\n\r\n**To Reproduce**\r\nUse `MongoDbMessageStore` or `ConfigurableMongoDbMessageStore` as the `MessageGroupStore` implementation.\r\nCreate aggregator:\r\n- Provide the `groupConditionSupplier` for the `AbstractCorrelatingMessageHandler`.\r\n- Provide the `groupTimeoutExpression` for the `AbstractCorrelatingMessageHandler` with a positive value of 5-10 seconds.\r\n\r\n**Describe the bug**\r\n\r\nLet's take a look at this function from AbstractCorrelatingMessageHandler:\r\n```java\r\n\tprivate void processForceRelease(Object groupId, long timestamp, long lastModified) {\r\n\t\tMessageGroup messageGroup = this.messageStore.getMessageGroup(groupId);\r\n\t\tif (messageGroup.getTimestamp() == timestamp && messageGroup.getLastModified() == lastModified) {\r\n\t\t\tthis.forceReleaseProcessor.processMessageGroup(messageGroup);\r\n\t\t}\r\n\t}\r\n``` \r\nTo run the `forceReleaseProcessor` the `timestamp` and `lastModified` must be the same as the corresponding properties from the message group that was fetched at the beginning of this function.\r\nThe `timestamp` and `lastModified` parameters come from the message group that was fetched in the `processMessageForGroup` function.\r\n\r\nThe problem is that after fetching the message group in the `processMessageForGroup` we do a call to `setGroupConditionIfAny(message, messageGroup)`. And if we are using the group condition, this function will call `messageStore.setGroupCondition()` which will update the message group condition and its `lastModifiedTime` property in MongoDB implementation.\r\n```java\r\npublic void setGroupCondition(Object groupId, String condition) {\r\n\tupdateGroup(groupId, lastModifiedUpdate().set(\"condition\", condition));\r\n}\r\n``` \r\n\r\nSo we end up in a situation where the `lastModifiedTime` is newer in the database but the message group fetched in the `processMessageForGroup` has an old value. This means that the condition in the `forceReleaseProcessor` will never be true if we are using the group condition.\r\n\r\n**Expected behavior**\r\n\r\nThe message group instance in the `processMessageForGroup` should be updated after a call to `setGroupConditionIfAny`.\r\n",
    "issue_word_count": 270,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/aggregator/AbstractCorrelatingMessageHandler.java",
      "spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageGroupStoreTests.java",
      "spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/mongo-aggregator-configurable-config.xml"
    ],
    "pr_changed_test_files": [
      "spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageGroupStoreTests.java",
      "spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/mongo-aggregator-configurable-config.xml"
    ],
    "base_commit": "4e464e9ce5129c9098163857ebd62060e8b57e6a",
    "head_commit": "119ae0d7a06a3e26e13d59fe59c1ccde1cae6ad5",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8686",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8686",
    "dockerfile": "",
    "pr_merged_at": "2023-07-24T13:10:45.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/aggregator/AbstractCorrelatingMessageHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/aggregator/AbstractCorrelatingMessageHandler.java\nindex ac7324918a5..198058db7db 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/aggregator/AbstractCorrelatingMessageHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/aggregator/AbstractCorrelatingMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -566,7 +566,7 @@ private boolean processMessageForGroup(Message<?> message, Object correlationKey\n \t\t\tthis.logger.trace(() -> \"Adding message to group [ \" + messageGroupToLog + \"]\");\n \t\t\tmessageGroup = store(correlationKey, message);\n \n-\t\t\tsetGroupConditionIfAny(message, messageGroup);\n+\t\t\tmessageGroup = setGroupConditionIfAny(message, messageGroup);\n \n \t\t\tif (this.releaseStrategy.canRelease(messageGroup)) {\n \t\t\t\tCollection<Message<?>> completedMessages = null;\n@@ -605,12 +605,19 @@ private void cancelScheduledFutureIfAny(Object correlationKey, UUID groupIdUuid,\n \t\t}\n \t}\n \n-\tprivate void setGroupConditionIfAny(Message<?> message, MessageGroup messageGroup) {\n+\tprivate MessageGroup setGroupConditionIfAny(Message<?> message, MessageGroup messageGroup) {\n+\t\tMessageGroup messageGroupToUse = messageGroup;\n+\n \t\tif (this.groupConditionSupplier != null) {\n-\t\t\tString condition = this.groupConditionSupplier.apply(message, messageGroup.getCondition());\n-\t\t\tthis.messageStore.setGroupCondition(messageGroup.getGroupId(), condition);\n-\t\t\tmessageGroup.setCondition(condition);\n+\t\t\tString condition = this.groupConditionSupplier.apply(message, messageGroupToUse.getCondition());\n+\t\t\tthis.messageStore.setGroupCondition(messageGroupToUse.getGroupId(), condition);\n+\t\t\tmessageGroupToUse = this.messageStore.getMessageGroup(messageGroupToUse.getGroupId());\n+\t\t\tif (this.sequenceAware) {\n+\t\t\t\tmessageGroupToUse = new SequenceAwareMessageGroup(messageGroupToUse);\n+\t\t\t}\n \t\t}\n+\n+\t\treturn messageGroupToUse;\n \t}\n \n \tprotected boolean isExpireGroupsUponCompletion() {\n",
    "test_patch": "diff --git a/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageGroupStoreTests.java b/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageGroupStoreTests.java\nindex 62e2453e5f4..d4c74e47073 100644\n--- a/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageGroupStoreTests.java\n+++ b/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/ConfigurableMongoDbMessageGroupStoreTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -65,6 +65,29 @@ void testWithAggregatorWithShutdown() {\n \t\tsuper.testWithAggregatorWithShutdown(\"mongo-aggregator-configurable-config.xml\");\n \t}\n \n+\t@Test\n+\tvoid groupIsForceReleaseAfterTimeoutWhenGroupConditionIsSet() {\n+\t\ttry (var context = new ClassPathXmlApplicationContext(\"mongo-aggregator-configurable-config.xml\", getClass())) {\n+\t\t\tMessageChannel input = context.getBean(\"inputChannel\", MessageChannel.class);\n+\t\t\tQueueChannel output = context.getBean(\"outputChannel\", QueueChannel.class);\n+\n+\t\t\tMessage<?> message = MessageBuilder.withPayload(\"test\")\n+\t\t\t\t\t.setSequenceNumber(1)\n+\t\t\t\t\t.setSequenceSize(10)\n+\t\t\t\t\t.setCorrelationId(\"test\")\n+\t\t\t\t\t.build();\n+\n+\t\t\tinput.send(message);\n+\n+\t\t\tMessage<?> receive = output.receive(10_000);\n+\n+\t\t\tassertThat(receive)\n+\t\t\t\t\t.extracting(\"payload\")\n+\t\t\t\t\t.asList()\n+\t\t\t\t\t.hasSize(1);\n+\t\t}\n+\t}\n+\n \t@Test\n \t@Disabled(\"The performance test. Enough slow. Also needs the release strategy changed to size() == 1000\")\n \tvoid messageGroupStoreLazyLoadPerformance() {\n\ndiff --git a/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/mongo-aggregator-configurable-config.xml b/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/mongo-aggregator-configurable-config.xml\nindex 552b5ec7787..4a407d8429b 100644\n--- a/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/mongo-aggregator-configurable-config.xml\n+++ b/spring-integration-mongodb/src/test/java/org/springframework/integration/mongodb/store/mongo-aggregator-configurable-config.xml\n@@ -11,6 +11,8 @@\n \n \t<int:aggregator input-channel=\"inputChannel\" output-channel=\"outputChannel\" message-store=\"mongoStore\"\n \t\t\t\t\trelease-strategy=\"releaseStrategy\"\n+\t\t\t\t\tgroup-timeout=\"500\"\n+\t\t\t\t\tsend-partial-result-on-expiry=\"true\"\n \t\t\t\t\tgroup-condition-supplier=\"conditionSupplier\"/>\n \n \t<util:constant id=\"releaseStrategy\"\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8682",
    "pr_id": 8682,
    "issue_id": 8681,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "WebSocket XML Config: Make Send Buffer Overflow Strategy Configurable\nWith #8678 (implemented in #8679), `IntegrationWebSocketContainer` got a new configurable attribute `sendBufferOverflowStrategy`. However, unlike the analogous `sendTimeLimit` and `sendBufferSizeLimit`, it doesn't expose an XML attribute.\r\n\r\nThis ticket is for adding that attribute.",
    "issue_word_count": 42,
    "test_files_count": 2,
    "non_test_files_count": 5,
    "pr_changed_files": [
      "spring-integration-websocket/src/main/java/org/springframework/integration/websocket/config/ClientWebSocketContainerParser.java",
      "spring-integration-websocket/src/main/java/org/springframework/integration/websocket/config/ServerWebSocketContainerParser.java",
      "spring-integration-websocket/src/main/resources/org/springframework/integration/websocket/config/spring-integration-websocket.xsd",
      "spring-integration-websocket/src/test/java/org/springframework/integration/websocket/config/WebSocketParserTests-context.xml",
      "spring-integration-websocket/src/test/java/org/springframework/integration/websocket/config/WebSocketParserTests.java",
      "src/reference/asciidoc/web-sockets.adoc",
      "src/reference/asciidoc/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-websocket/src/test/java/org/springframework/integration/websocket/config/WebSocketParserTests-context.xml",
      "spring-integration-websocket/src/test/java/org/springframework/integration/websocket/config/WebSocketParserTests.java"
    ],
    "base_commit": "79139915e80e483ac568ad83da4b7b2e26410ac2",
    "head_commit": "b7473f36b4dc8b05a920e0fd74c4d6c276fa97c7",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8682",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8682",
    "dockerfile": "",
    "pr_merged_at": "2023-07-24T15:03:50.000Z",
    "patch": "diff --git a/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/config/ClientWebSocketContainerParser.java b/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/config/ClientWebSocketContainerParser.java\nindex 2e780bd8b9a..94403aa9928 100644\n--- a/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/config/ClientWebSocketContainerParser.java\n+++ b/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/config/ClientWebSocketContainerParser.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2019 the original author or authors.\n+ * Copyright 2014-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -33,6 +33,7 @@\n  * the {@code <websocket:client-container/>} element.\n  *\n  * @author Artem Bilan\n+ * @author Julian Koch\n  * @since 4.1\n  */\n public class ClientWebSocketContainerParser extends AbstractSingleBeanDefinitionParser {\n@@ -55,6 +56,7 @@ protected void doParse(Element element, ParserContext parserContext, BeanDefinit\n \n \t\tIntegrationNamespaceUtils.setValueIfAttributeDefined(builder, element, \"send-buffer-size-limit\");\n \t\tIntegrationNamespaceUtils.setValueIfAttributeDefined(builder, element, \"send-time-limit\");\n+\t\tIntegrationNamespaceUtils.setValueIfAttributeDefined(builder, element, \"send-buffer-overflow-strategy\");\n \t\tIntegrationNamespaceUtils.setValueIfAttributeDefined(builder, element, \"origin\");\n \t\tIntegrationNamespaceUtils.setValueIfAttributeDefined(builder, element, IntegrationNamespaceUtils.AUTO_STARTUP);\n \t\tIntegrationNamespaceUtils.setValueIfAttributeDefined(builder, element, IntegrationNamespaceUtils.PHASE);\n\ndiff --git a/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/config/ServerWebSocketContainerParser.java b/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/config/ServerWebSocketContainerParser.java\nindex 4fb26db248b..0a047e6470d 100644\n--- a/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/config/ServerWebSocketContainerParser.java\n+++ b/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/config/ServerWebSocketContainerParser.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2019 the original author or authors.\n+ * Copyright 2014-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -36,6 +36,7 @@\n  * the {@code <websocket:server-container/>} element.\n  *\n  * @author Artem Bilan\n+ * @author Julian Koch\n  * @since 4.1\n  */\n public class ServerWebSocketContainerParser extends AbstractSingleBeanDefinitionParser {\n@@ -104,6 +105,7 @@ protected void doParse(Element element, ParserContext parserContext, BeanDefinit\n \t\tIntegrationNamespaceUtils.setReferenceIfAttributeDefined(builder, element, \"handshake-handler\");\n \t\tIntegrationNamespaceUtils.setValueIfAttributeDefined(builder, element, \"send-buffer-size-limit\");\n \t\tIntegrationNamespaceUtils.setValueIfAttributeDefined(builder, element, \"send-time-limit\");\n+\t\tIntegrationNamespaceUtils.setValueIfAttributeDefined(builder, element, \"send-buffer-overflow-strategy\");\n \t\tIntegrationNamespaceUtils.setValueIfAttributeDefined(builder, element, \"allowed-origins\");\n \t}\n \n\ndiff --git a/spring-integration-websocket/src/main/resources/org/springframework/integration/websocket/config/spring-integration-websocket.xsd b/spring-integration-websocket/src/main/resources/org/springframework/integration/websocket/config/spring-integration-websocket.xsd\nindex 79f79f0bbf0..89cfb50eadc 100644\n--- a/spring-integration-websocket/src/main/resources/org/springframework/integration/websocket/config/spring-integration-websocket.xsd\n+++ b/spring-integration-websocket/src/main/resources/org/springframework/integration/websocket/config/spring-integration-websocket.xsd\n@@ -94,6 +94,20 @@\n \t\t\t\t\t<xsd:union memberTypes=\"xsd:int xsd:string\"/>\n \t\t\t\t</xsd:simpleType>\n \t\t\t</xsd:attribute>\n+\t\t\t<xsd:attribute name=\"send-buffer-overflow-strategy\">\n+\t\t\t\t<xsd:annotation>\n+\t\t\t\t\t<xsd:documentation>\n+\t\t\t\t\t\tThe WebSocket session's outbound message buffer overflow strategy.\n+\n+\t\t\t\t\t\tConcurrently generated outbound messages are buffered if sending is slow.\n+\t\t\t\t\t\tThis strategy determines the behavior when the buffer has reached the limit\n+\t\t\t\t\t\tconfigured with &lt;send-buffer-size-limit&gt;.\n+\t\t\t\t\t</xsd:documentation>\n+\t\t\t\t</xsd:annotation>\n+\t\t\t\t<xsd:simpleType>\n+\t\t\t\t\t<xsd:union memberTypes=\"overflowStrategyEnumeration xsd:string\"/>\n+\t\t\t\t</xsd:simpleType>\n+\t\t\t</xsd:attribute>\n \t\t\t<xsd:attributeGroup ref=\"integration:smartLifeCycleAttributeGroup\"/>\n \t\t</xsd:complexType>\n \t</xsd:element>\n@@ -320,6 +334,20 @@\n \t\t\t\t\t<xsd:union memberTypes=\"xsd:int xsd:string\"/>\n \t\t\t\t</xsd:simpleType>\n \t\t\t</xsd:attribute>\n+\t\t\t<xsd:attribute name=\"send-buffer-overflow-strategy\">\n+\t\t\t\t<xsd:annotation>\n+\t\t\t\t\t<xsd:documentation>\n+\t\t\t\t\t\tThe WebSocket session's outbound message buffer overflow strategy.\n+\n+\t\t\t\t\t\tConcurrently generated outbound messages are buffered if sending is slow.\n+\t\t\t\t\t\tThis strategy determines the behavior when the buffer has reached the limit\n+\t\t\t\t\t\tconfigured with &lt;send-buffer-size-limit&gt;.\n+\t\t\t\t\t</xsd:documentation>\n+\t\t\t\t</xsd:annotation>\n+\t\t\t\t<xsd:simpleType>\n+\t\t\t\t\t<xsd:union memberTypes=\"overflowStrategyEnumeration xsd:string\"/>\n+\t\t\t\t</xsd:simpleType>\n+\t\t\t</xsd:attribute>\n \t\t\t<xsd:attribute name=\"allowed-origins\" type=\"xsd:string\">\n \t\t\t\t<xsd:annotation>\n \t\t\t\t\t<xsd:documentation>\n@@ -505,4 +533,11 @@\n \t\t<xsd:attributeGroup ref=\"integration:channelAdapterAttributes\"/>\n \t</xsd:complexType>\n \n+\t<xsd:simpleType name=\"overflowStrategyEnumeration\">\n+\t\t<xsd:restriction base=\"xsd:token\">\n+\t\t\t<xsd:enumeration value=\"TERMINATE\"/>\n+\t\t\t<xsd:enumeration value=\"DROP\"/>\n+\t\t</xsd:restriction>\n+\t</xsd:simpleType>\n+\n </xsd:schema>\n\ndiff --git a/src/reference/asciidoc/web-sockets.adoc b/src/reference/asciidoc/web-sockets.adoc\nindex cdf0ee3057e..a32d2fd4b43 100644\n--- a/src/reference/asciidoc/web-sockets.adoc\n+++ b/src/reference/asciidoc/web-sockets.adoc\n@@ -171,18 +171,19 @@ The following listing shows the attributes available for the `<int-websocket:cli\n [source,xml]\n ----\n <int-websocket:client-container\n-                  id=\"\"                        <1>\n-                  client=\"\"                    <2>\n-                  uri=\"\"                       <3>\n-                  uri-variables=\"\"             <4>\n-                  origin=\"\"                    <5>\n-                  send-time-limit=\"\"           <6>\n-                  send-buffer-size-limit=\"\"    <7>\n-                  auto-startup=\"\"              <8>\n-                  phase=\"\">                    <9>\n+                  id=\"\"                             <1>\n+                  client=\"\"                         <2>\n+                  uri=\"\"                            <3>\n+                  uri-variables=\"\"                  <4>\n+                  origin=\"\"                         <5>\n+                  send-time-limit=\"\"                <6>\n+                  send-buffer-size-limit=\"\"         <7>\n+                  send-buffer-overflow-strategy=\"\"  <8>\n+                  auto-startup=\"\"                   <9>\n+                  phase=\"\">                        <10>\n                 <int-websocket:http-headers>\n                   <entry key=\"\" value=\"\"/>\n-                </int-websocket:http-headers>  <10>\n+                </int-websocket:http-headers>      <11>\n </int-websocket:client-container>\n ----\n \n@@ -198,14 +199,17 @@ See https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/w\n Defaults to `10000`.\n <7> The WebSocket session 'send' message size limit.\n Defaults to `524288`.\n-<8> Boolean value indicating whether this endpoint should start automatically.\n+<8> The WebSocket session send buffer overflow strategy\n+determines the behavior when a session's outbound message buffer has reached the `send-buffer-size-limit`.\n+See `ConcurrentWebSocketSessionDecorator.OverflowStrategy` for possible values and more details.\n+<9> Boolean value indicating whether this endpoint should start automatically.\n Defaults to `false`, assuming that this container is started from the <<web-socket-inbound-adapter, WebSocket inbound adapter>>.\n-<9> The lifecycle phase within which this endpoint should start and stop.\n+<10> The lifecycle phase within which this endpoint should start and stop.\n The lower the value, the earlier this endpoint starts and the later it stops.\n The default is `Integer.MAX_VALUE`.\n Values can be negative.\n See https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/SmartLifecycle.html[`SmartLifeCycle`].\n-<10> A `Map` of `HttpHeaders` to be used with the Handshake request.\n+<11> A `Map` of `HttpHeaders` to be used with the Handshake request.\n ====\n \n ==== `<int-websocket:server-container>` Attributes\n@@ -216,26 +220,27 @@ The following listing shows the attributes available for the `<int-websocket:ser\n [source,xml]\n ----\n <int-websocket:server-container\n-          id=\"\"                         <1>\n-          path=\"\"                       <2>\n-          handshake-handler=\"\"          <3>\n-          handshake-interceptors=\"\"     <4>\n-          decorator-factories=\"\"        <5>\n-          send-time-limit=\"\"            <6>\n-          send-buffer-size-limit=\"\"     <7>\n-          allowed-origins=\"\">           <8>\n+          id=\"\"                             <1>\n+          path=\"\"                           <2>\n+          handshake-handler=\"\"              <3>\n+          handshake-interceptors=\"\"         <4>\n+          decorator-factories=\"\"            <5>\n+          send-time-limit=\"\"                <6>\n+          send-buffer-size-limit=\"\"         <7>\n+          send-buffer-overflow-strategy=\"\"  <8>\n+          allowed-origins=\"\">               <9>\n           <int-websocket:sockjs\n-            client-library-url=\"\"       <9>\n-            stream-bytes-limit=\"\"       <10>\n-            session-cookie-needed=\"\"    <11>\n-            heartbeat-time=\"\"           <12>\n-            disconnect-delay=\"\"         <13>\n-            message-cache-size=\"\"       <14>\n-            websocket-enabled=\"\"        <15>\n-            scheduler=\"\"                <16>\n-            message-codec=\"\"            <17>\n-            transport-handlers=\"\"       <18>\n-            suppress-cors=\"true\"=\"\" />  <19>\n+            client-library-url=\"\"          <10>\n+            stream-bytes-limit=\"\"          <11>\n+            session-cookie-needed=\"\"       <12>\n+            heartbeat-time=\"\"              <13>\n+            disconnect-delay=\"\"            <14>\n+            message-cache-size=\"\"          <15>\n+            websocket-enabled=\"\"           <16>\n+            scheduler=\"\"                   <17>\n+            message-codec=\"\"               <18>\n+            transport-handlers=\"\"          <19>\n+            suppress-cors=\"true\" />        <20>\n </int-websocket:server-container>\n ----\n \n@@ -251,41 +256,44 @@ the WebSocket session when the corresponding HTTP session expires).\n See the https://docs.spring.io/spring-session/docs/current/reference/html5/#websocket[Spring Session Project] for more information.\n <6> See the same option on the <<websocket-client-container-attributes,`<int-websocket:client-container>`>>.\n <7> See the same option on the <<websocket-client-container-attributes,`<int-websocket:client-container>`>>.\n-<8> The allowed origin header values.\n+<8> The WebSocket session send buffer overflow strategy\n+determines the behavior when a session's outbound message buffer has reached the `send-buffer-size-limit`.\n+See `ConcurrentWebSocketSessionDecorator.OverflowStrategy` for possible values and more details.\n+<9> The allowed origin header values.\n You can specify multiple origins as a comma-separated list.\n This check is mostly designed for browser clients.\n There is nothing preventing other types of client from modifying the origin header value.\n When SockJS is enabled and allowed origins are restricted, transport types that do not use origin headers for cross-origin requests (`jsonp-polling`, `iframe-xhr-polling`, `iframe-eventsource`, and `iframe-htmlfile`) are disabled.\n As a consequence, IE6 and IE7 are not supported, and IE8 and IE9 are supported only without cookies.\n By default, all origins are allowed.\n-<9> Transports with no native cross-domain communication (such as `eventsource` and `htmlfile`) must get a simple page from the \"`foreign`\" domain in an invisible iframe so that code in the iframe can run from a domain local to the SockJS server.\n+<10> Transports with no native cross-domain communication (such as `eventsource` and `htmlfile`) must get a simple page from the \"`foreign`\" domain in an invisible iframe so that code in the iframe can run from a domain local to the SockJS server.\n Since the iframe needs to load the SockJS javascript client library, this property lets you specify the location from which to load it.\n By default, it points to `https://d1fxtkz8shb9d2.cloudfront.net/sockjs-0.3.4.min.js`.\n However, you can also set it to point to a URL served by the application.\n Note that it is possible to specify a relative URL, in which case the URL must be relative to the iframe URL.\n For example, assuming a SockJS endpoint mapped to `/sockjs` and the resulting iframe URL is `/sockjs/iframe.html`, the relative URL must start with \"../../\" to traverse up to the location above the SockJS mapping.\n For prefix-based servlet mapping, you may need one more traversal.\n-<10> Minimum number of bytes that can be sent over a single HTTP streaming request before it is closed.\n+<11> Minimum number of bytes that can be sent over a single HTTP streaming request before it is closed.\n Defaults to `128K` (that is, 128*1024 or 131072 bytes).\n-<11> The `cookie_needed` value in the response from the SockJs `/info` endpoint.\n+<12> The `cookie_needed` value in the response from the SockJs `/info` endpoint.\n This property indicates whether a `JSESSIONID` cookie is required for the application to function correctly (for example, for load balancing or in Java Servlet containers for the use of an HTTP session).\n-<12> The amount of time (in milliseconds) when the server has not sent any messages and after which the server should\n+<13> The amount of time (in milliseconds) when the server has not sent any messages and after which the server should\n send a heartbeat frame to the client in order to keep the connection from breaking.\n The default value is `25,000` (25 seconds).\n-<13> The amount of time (in milliseconds) before a client is considered disconnected after not having a receiving connection (that is, an active connection over which the server can send data to the client).\n+<14> The amount of time (in milliseconds) before a client is considered disconnected after not having a receiving connection (that is, an active connection over which the server can send data to the client).\n The default value is `5000`.\n-<14> The number of server-to-client messages that a session can cache while waiting for the next HTTP polling request from the client.\n+<15> The number of server-to-client messages that a session can cache while waiting for the next HTTP polling request from the client.\n The default size is `100`.\n-<15> Some load balancers do not support WebSockets.\n+<16> Some load balancers do not support WebSockets.\n Set this option to `false` to disable the WebSocket transport on the server side.\n The default value is `true`.\n-<16> The `TaskScheduler` bean reference.\n+<17> The `TaskScheduler` bean reference.\n A new `ThreadPoolTaskScheduler` instance is created if no value is provided.\n This scheduler instance is used for scheduling heart-beat messages.\n-<17> The `SockJsMessageCodec` bean reference to use for encoding and decoding SockJS messages.\n+<18> The `SockJsMessageCodec` bean reference to use for encoding and decoding SockJS messages.\n By default, `Jackson2SockJsMessageCodec` is used, which requires the Jackson library to be present on the classpath.\n-<18> List of `TransportHandler` bean references.\n-<19> Whether to disable automatic addition of CORS headers for SockJS requests.\n+<19> List of `TransportHandler` bean references.\n+<20> Whether to disable automatic addition of CORS headers for SockJS requests.\n The default value is `false`.\n ====\n \n\ndiff --git a/src/reference/asciidoc/whats-new.adoc b/src/reference/asciidoc/whats-new.adoc\nindex f5be700435a..17250f46b5e 100644\n--- a/src/reference/asciidoc/whats-new.adoc\n+++ b/src/reference/asciidoc/whats-new.adoc\n@@ -31,3 +31,10 @@ See <<./endpoint.adoc#endpoint-pollingconsumer, Polling Consumer>> for more info\n \n - Java, Groovy and Kotlin DSLs have now context-specific methods in the `IntegationFlowDefinition` with a single `Consumer` argument to configure an endpoint and its handler with one builder and readable options.\n See, for example, `transformWith()`, `splitWith()` in <<./dsl.adoc#java-dsl, Java DSL Chapter>>.\n+\n+[[x6.2-websockets]]\n+=== WebSockets Changes\n+\n+- For the server and client WebSocket containers, the send buffer overflow strategy is now configurable in `IntegrationWebSocketContainer` and in XML via `send-buffer-overflow-strategy`.\n+This strategy determines the behavior when a session's outbound message buffer has reached the configured limit.\n+See <<./web-sockets.adoc#websocket-client-container-attributes, WebSockets Support>> for more information.\n",
    "test_patch": "diff --git a/spring-integration-websocket/src/test/java/org/springframework/integration/websocket/config/WebSocketParserTests-context.xml b/spring-integration-websocket/src/test/java/org/springframework/integration/websocket/config/WebSocketParserTests-context.xml\nindex bbe0660f1f4..60a0ae3bfce 100644\n--- a/spring-integration-websocket/src/test/java/org/springframework/integration/websocket/config/WebSocketParserTests-context.xml\n+++ b/spring-integration-websocket/src/test/java/org/springframework/integration/websocket/config/WebSocketParserTests-context.xml\n@@ -17,6 +17,7 @@\n \t\t\t\t\t\t\t\t\tpath=\"/ws\"\n \t\t\t\t\t\t\t\t\tsend-buffer-size-limit=\"100000\"\n \t\t\t\t\t\t\t\t\tsend-time-limit=\"100\"\n+\t\t\t\t\t\t\t\t\tsend-buffer-overflow-strategy=\"DROP\"\n \t\t\t\t\t\t\t\t\thandshake-handler=\"handshakeHandler\"\n \t\t\t\t\t\t\t\t\thandshake-interceptors=\"handshakeInterceptor\"\n \t\t\t\t\t\t\t\t\tdecorator-factories=\"decoratorFactory\"\n@@ -66,6 +67,7 @@\n \t\t\t\t\t\t\t\t\turi-variables=\"ws,user\"\n \t\t\t\t\t\t\t\t\tsend-buffer-size-limit=\"1000\"\n \t\t\t\t\t\t\t\t\tsend-time-limit=\"100\"\n+\t\t\t\t\t\t\t\t\tsend-buffer-overflow-strategy=\"DROP\"\n \t\t\t\t\t\t\t\t\torigin=\"FOO\"\n \t\t\t\t\t\t\t\t\tphase=\"100\">\n \t\t<int-websocket:http-headers>\n\ndiff --git a/spring-integration-websocket/src/test/java/org/springframework/integration/websocket/config/WebSocketParserTests.java b/spring-integration-websocket/src/test/java/org/springframework/integration/websocket/config/WebSocketParserTests.java\nindex 84b72728144..0b97d9219d1 100644\n--- a/spring-integration-websocket/src/test/java/org/springframework/integration/websocket/config/WebSocketParserTests.java\n+++ b/spring-integration-websocket/src/test/java/org/springframework/integration/websocket/config/WebSocketParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2022 the original author or authors.\n+ * Copyright 2014-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -47,6 +47,7 @@\n import org.springframework.web.socket.WebSocketHandler;\n import org.springframework.web.socket.WebSocketHttpHeaders;\n import org.springframework.web.socket.client.WebSocketClient;\n+import org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator;\n import org.springframework.web.socket.handler.WebSocketHandlerDecoratorFactory;\n import org.springframework.web.socket.messaging.StompSubProtocolHandler;\n import org.springframework.web.socket.server.HandshakeHandler;\n@@ -60,6 +61,7 @@\n \n /**\n  * @author Artem Bilan\n+ * @author Julian Koch\n  *\n  * @since 4.1\n  */\n@@ -155,6 +157,8 @@ public void testDefaultInboundChannelAdapterAndServerContainer() {\n \t\tassertThat(interceptors[0]).isSameAs(this.handshakeInterceptor);\n \t\tassertThat(TestUtils.getPropertyValue(this.serverWebSocketContainer, \"sendTimeLimit\")).isEqualTo(100);\n \t\tassertThat(TestUtils.getPropertyValue(this.serverWebSocketContainer, \"sendBufferSizeLimit\")).isEqualTo(100000);\n+\t\tassertThat(TestUtils.getPropertyValue(this.serverWebSocketContainer, \"sendBufferOverflowStrategy\"))\n+\t\t\t\t.isEqualTo(ConcurrentWebSocketSessionDecorator.OverflowStrategy.DROP);\n \t\tassertThat(TestUtils.getPropertyValue(this.serverWebSocketContainer, \"origins\", String[].class))\n \t\t\t\t.isEqualTo(new String[] {\"https://foo.com\"});\n \n@@ -244,6 +248,8 @@ public void testCustomInboundChannelAdapterAndClientContainer() throws URISyntax\n \t\t\t\t.isSameAs(this.customInboundAdapter);\n \t\tassertThat(TestUtils.getPropertyValue(this.clientWebSocketContainer, \"sendTimeLimit\")).isEqualTo(100);\n \t\tassertThat(TestUtils.getPropertyValue(this.clientWebSocketContainer, \"sendBufferSizeLimit\")).isEqualTo(1000);\n+\t\tassertThat(TestUtils.getPropertyValue(this.clientWebSocketContainer, \"sendBufferOverflowStrategy\"))\n+\t\t\t\t.isEqualTo(ConcurrentWebSocketSessionDecorator.OverflowStrategy.DROP);\n \t\tassertThat(TestUtils.getPropertyValue(this.clientWebSocketContainer, \"connectionManager.uri\", URI.class))\n \t\t\t\t.isEqualTo(new URI(\"ws://foo.bar/ws?service=user\"));\n \t\tassertThat(TestUtils.getPropertyValue(this.clientWebSocketContainer, \"connectionManager.client\"))\n@@ -258,6 +264,8 @@ public void testCustomInboundChannelAdapterAndClientContainer() throws URISyntax\n \t\t\t\t.isEqualTo(10 * 1000);\n \t\tassertThat(TestUtils.getPropertyValue(this.simpleClientWebSocketContainer, \"sendBufferSizeLimit\"))\n \t\t\t\t.isEqualTo(512 * 1024);\n+\t\tassertThat(TestUtils.getPropertyValue(this.simpleClientWebSocketContainer, \"sendBufferOverflowStrategy\"))\n+\t\t\t\t.isNull();\n \t\tassertThat(TestUtils.getPropertyValue(this.simpleClientWebSocketContainer, \"connectionManager.uri\", URI.class))\n \t\t\t\t.isEqualTo(new URI(\"ws://foo.bar\"));\n \t\tassertThat(TestUtils.getPropertyValue(this.simpleClientWebSocketContainer, \"connectionManager.client\"))\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8675",
    "pr_id": 8675,
    "issue_id": 8674,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "ResourceKnownHostsServerKeyVerifier does not consider the specified keytypes\n**In what version(s) of Spring Integration are you seeing this issue?**\r\n6.0.5.\r\n6.1.1 should still be affected as the code was not changed\r\n\r\n**Describe the bug**\r\nThe ResourceKnownHostsServerKeyVerifier in Spring Integration Sftp seems to always select the first matching key from the provided known_host file and seems not to take into account the specified keytype.\r\n\r\n**To Reproduce**\r\n\r\nTo reproduce the issue, add multiple keytypes for the same host and port. Then experiment with the order.\r\n\r\n**Expected behavior**\r\n\r\nThe keytype should be considered, and the [findKnownHostEntry method](\r\nhttps://github.com/spring-projects/spring-integration/blob/v6.1.1/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/ResourceKnownHostsServerKeyVerifier.java#L109) should select the matching host, port and keytype.\r\n\r\n**Related Code **\r\nYou can refer to the code at https://github.com/spring-projects/spring-integration/blob/v6.1.1/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/ResourceKnownHostsServerKeyVerifier.java#L122\r\n\r\n\r\n\r\n",
    "issue_word_count": 165,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/ResourceKnownHostsServerKeyVerifier.java",
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java"
    ],
    "base_commit": "20d5f628bc08a3077367a1766a81fe98ae9b7a50",
    "head_commit": "d77f6f498ea5420326317420d3bb97d5b60c2086",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8675",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8675",
    "dockerfile": "",
    "pr_merged_at": "2023-07-17T18:26:40.000Z",
    "patch": "diff --git a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/ResourceKnownHostsServerKeyVerifier.java b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/ResourceKnownHostsServerKeyVerifier.java\nindex 9d6a852a574..7a17f61c2fd 100644\n--- a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/ResourceKnownHostsServerKeyVerifier.java\n+++ b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/ResourceKnownHostsServerKeyVerifier.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2022 the original author or authors.\n+ * Copyright 2022-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -66,18 +66,19 @@ public ResourceKnownHostsServerKeyVerifier(Resource knownHostsResource) {\n \t@Override\n \tpublic boolean verifyServerKey(ClientSession clientSession, SocketAddress remoteAddress, PublicKey serverKey) {\n \t\tCollection<KnownHostsServerKeyVerifier.HostEntryPair> knownHosts = this.keysSupplier.get();\n-\t\tKnownHostsServerKeyVerifier.HostEntryPair match = findKnownHostEntry(clientSession, remoteAddress, knownHosts);\n-\t\tif (match == null) {\n+\t\tList<KnownHostsServerKeyVerifier.HostEntryPair> matches =\n+\t\t\t\tfindKnownHostEntries(clientSession, remoteAddress, knownHosts);\n+\n+\t\tif (matches.isEmpty()) {\n \t\t\treturn false;\n \t\t}\n \n-\t\tKnownHostEntry entry = match.getHostEntry();\n-\t\tPublicKey expected = match.getServerKey();\n-\t\tif (KeyUtils.compareKeys(expected, serverKey)) {\n-\t\t\treturn !\"revoked\".equals(entry.getMarker());\n-\t\t}\n+\t\tString serverKeyType = KeyUtils.getKeyType(serverKey);\n \n-\t\treturn false;\n+\t\treturn matches.stream()\n+\t\t\t\t.filter(match -> serverKeyType.equals(match.getHostEntry().getKeyEntry().getKeyType()))\n+\t\t\t\t.filter(match -> KeyUtils.compareKeys(match.getServerKey(), serverKey))\n+\t\t\t\t.anyMatch(match -> !\"revoked\".equals(match.getHostEntry().getMarker()));\n \t}\n \n \tprivate static Supplier<Collection<KnownHostsServerKeyVerifier.HostEntryPair>> getKnownHostSupplier(\n@@ -106,26 +107,32 @@ private static PublicKey resolveHostKey(KnownHostEntry entry) throws IOException\n \t\treturn authEntry.resolvePublicKey(null, PublicKeyEntryResolver.IGNORING);\n \t}\n \n-\tprivate static KnownHostsServerKeyVerifier.HostEntryPair findKnownHostEntry(\n+\tprivate static List<KnownHostsServerKeyVerifier.HostEntryPair> findKnownHostEntries(\n \t\t\tClientSession clientSession, SocketAddress remoteAddress,\n \t\t\tCollection<KnownHostsServerKeyVerifier.HostEntryPair> knownHosts) {\n \n+\t\tif (GenericUtils.isEmpty(knownHosts)) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n \t\tCollection<SshdSocketAddress> candidates = resolveHostNetworkIdentities(clientSession, remoteAddress);\n \n \t\tif (GenericUtils.isEmpty(candidates)) {\n-\t\t\treturn null;\n+\t\t\treturn Collections.emptyList();\n \t\t}\n \n+\t\tList<KnownHostsServerKeyVerifier.HostEntryPair> matches = new ArrayList<>();\n \t\tfor (KnownHostsServerKeyVerifier.HostEntryPair match : knownHosts) {\n \t\t\tKnownHostEntry entry = match.getHostEntry();\n \t\t\tfor (SshdSocketAddress host : candidates) {\n \t\t\t\tif (entry.isHostMatch(host.getHostName(), host.getPort())) {\n-\t\t\t\t\treturn match;\n+\t\t\t\t\tmatches.add(match);\n+\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\treturn null; // no match found\n+\t\treturn matches;\n \t}\n \n \tprivate static Collection<SshdSocketAddress> resolveHostNetworkIdentities(\n",
    "test_patch": "diff --git a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java\nindex f03798a8568..187beee44bd 100644\n--- a/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java\n+++ b/spring-integration-sftp/src/test/java/org/springframework/integration/sftp/session/SftpSessionFactoryTests.java\n@@ -19,6 +19,7 @@\n import java.io.File;\n import java.io.IOException;\n import java.net.ConnectException;\n+import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -121,7 +122,7 @@ public void concurrentGetSessionDoesntCauseFailure() throws IOException {\n \t\t\t\tasyncTaskExecutor.execute(() -> concurrentSessions.add(sftpSessionFactory.getSession()));\n \t\t\t}\n \n-\t\t\tawait().until(() -> concurrentSessions.size() == 3);\n+\t\t\tawait().atMost(Duration.ofSeconds(30)).until(() -> concurrentSessions.size() == 3);\n \n \t\t\tassertThat(concurrentSessions.get(0))\n \t\t\t\t\t.isNotEqualTo(concurrentSessions.get(1))\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8665",
    "pr_id": 8665,
    "issue_id": 8664,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Spring integration error when using MessageRequestReplyReceiverContext data in observation predicate\n**In what version(s) of Spring Integration are you seeing this issue?**\r\n\r\n`id 'org.springframework.boot' version '3.1.1'`\r\n\r\n`implementation(\"org.springframework.integration:spring-integration-ip\")`\r\n\r\n**Describe the bug**\r\n\r\nWhen using the `ObservationPredicate` with Spring boot micrometer, I created some rules in order to observe certain contexts. But when using the context `MessageRequestReplyReceiverContext` and using some of its data in order to create a predicate, the rest of the chain of the application just fails with the exception:\r\n```\r\njava.lang.ClassCastException: class io.micrometer.observation.Observation$Context cannot be cast to class org.springframework.integration.support.management.observation.MessageRequestReplyReceiverContext (io.micrometer.observation.Observation$Context and org.springframework.integration.support.management.observation.MessageRequestReplyReceiverContext are in unnamed module of loader 'app')\r\n```\r\n\r\nOur application flow is just a simple TCP nio inbound, with a broker outbound. But it seems to be going wrong before we receive it in the the TCP inbound.\r\n\r\n\r\n```\r\n        observationRegistry.observationConfig()\r\n                .observationPredicate((name, context) -> shouldBeObserved(context));\r\n\r\n```\r\n\r\n\r\nExample of usage in observation predicate when using headers: \r\n```\r\n        ...\r\n        \r\n        if (context instanceof MessageRequestReplyReceiverContext messageRequestReplyReceiverContext) {\r\n            return Optional.ofNullable(messageRequestReplyReceiverContext.getCarrier())\r\n                    .map(Message::getHeaders)\r\n                    .map(headers -> !headers.containsKey(\"SOMEKEY\"))\r\n                    .orElse(true);\r\n        }\r\n\r\n       ...\r\n```\r\n\r\nExample of usage in observation predicate when using payload: \r\n\r\n```\r\n        ...\r\n        \r\n        if (context instanceof MessageRequestReplyReceiverContext messageRequestReplyReceiverContext) {\r\n            return Optional.ofNullable(messageRequestReplyReceiverContext.getCarrier())\r\n                    .map(Message::getPayload)\r\n                    .map(payload -> new String((byte[]) payload, StandardCharsets.UTF_8))\r\n                    .map(payload -> !payload.equals(SOMEDATA))\r\n                    .orElse(true);\r\n        }\r\n\r\n       ...\r\n```\r\n\r\nException:\r\n![image](https://github.com/spring-projects/spring-integration/assets/25689471/74e7cd68-2ca5-490a-9913-f02c81fb398d)\r\n\r\n**Expected behavior**\r\n\r\nExpected to not break the application when simply casting the payload or using the headers in the generic message.\r\n",
    "issue_word_count": 270,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java",
      "spring-integration-core/src/test/java/org/springframework/integration/support/management/observation/IntegrationObservabilityZipkinTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/support/management/observation/IntegrationObservabilityZipkinTests.java"
    ],
    "base_commit": "019e96c92577444b815f283e29b09d787e8c05bb",
    "head_commit": "767d7f514755ddfcab9e465eded7719ed004e617",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8665",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8665",
    "dockerfile": "",
    "pr_merged_at": "2023-07-12T18:51:24.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java b/spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java\nindex a8cfcbc3448..98c4f9e86cf 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java\n@@ -595,14 +595,16 @@ private Message<?> convertToRequestMessage(Object object, boolean shouldConvert)\n \tprivate Message<?> sendAndReceiveWithObservation(MessageChannel requestChannel, Object object,\n \t\t\tMessage<?> requestMessage) {\n \n+\t\tMessageRequestReplyReceiverContext context =\n+\t\t\t\tnew MessageRequestReplyReceiverContext(requestMessage, getComponentName());\n+\n \t\treturn IntegrationObservation.GATEWAY.observation(this.observationConvention,\n \t\t\t\t\t\tDefaultMessageRequestReplyReceiverObservationConvention.INSTANCE,\n-\t\t\t\t\t\t() -> new MessageRequestReplyReceiverContext(requestMessage, getComponentName()),\n-\t\t\t\t\t\tthis.observationRegistry)\n-\t\t\t\t.<MessageRequestReplyReceiverContext, Message<?>>observeWithContext((ctx) -> {\n+\t\t\t\t\t\t() -> context, this.observationRegistry)\n+\t\t\t\t.observe(() -> {\n \t\t\t\t\tMessage<?> replyMessage = doSendAndReceive(requestChannel, object, requestMessage);\n \t\t\t\t\tif (replyMessage != null) {\n-\t\t\t\t\t\tctx.setResponse(replyMessage);\n+\t\t\t\t\t\tcontext.setResponse(replyMessage);\n \t\t\t\t\t}\n \t\t\t\t\treturn replyMessage;\n \t\t\t\t});\n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/support/management/observation/IntegrationObservabilityZipkinTests.java b/spring-integration-core/src/test/java/org/springframework/integration/support/management/observation/IntegrationObservabilityZipkinTests.java\nindex 9f464ce2d91..e572ebf29d1 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/support/management/observation/IntegrationObservabilityZipkinTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/support/management/observation/IntegrationObservabilityZipkinTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2022 the original author or authors.\n+ * Copyright 2022-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -26,12 +26,14 @@\n import io.micrometer.tracing.test.SampleTestRunner;\n import io.micrometer.tracing.test.simple.SpansAssert;\n \n+import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.context.annotation.AnnotationConfigApplicationContext;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.integration.annotation.EndpointId;\n import org.springframework.integration.annotation.Poller;\n import org.springframework.integration.annotation.ServiceActivator;\n+import org.springframework.integration.channel.NullChannel;\n import org.springframework.integration.channel.QueueChannel;\n import org.springframework.integration.channel.interceptor.ObservationPropagationChannelInterceptor;\n import org.springframework.integration.config.EnableIntegration;\n@@ -64,13 +66,20 @@ public TracingSetup[] getTracingSetup() {\n \tpublic SampleTestRunnerConsumer yourCode() {\n \t\treturn (bb, meterRegistry) -> {\n \t\t\tObservationRegistry observationRegistry = getObservationRegistry();\n+\n+\t\t\tobservationRegistry.observationConfig()\n+\t\t\t\t\t.observationPredicate((name, context) ->\n+\t\t\t\t\t\t\t!(context instanceof MessageRequestReplyReceiverContext messageRequestReplyReceiverContext)\n+\t\t\t\t\t\t\t\t\t|| !messageRequestReplyReceiverContext.getGatewayName()\n+\t\t\t\t\t\t\t\t\t.equals(\"skippedObservationInboundGateway\"));\n+\n \t\t\ttry (AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext()) {\n \t\t\t\tapplicationContext.registerBean(ObservationRegistry.class, () -> observationRegistry);\n \t\t\t\tapplicationContext.register(ObservationIntegrationTestConfiguration.class);\n \t\t\t\tapplicationContext.refresh();\n \n \t\t\t\tTestMessagingGatewaySupport messagingGateway =\n-\t\t\t\t\t\tapplicationContext.getBean(TestMessagingGatewaySupport.class);\n+\t\t\t\t\t\tapplicationContext.getBean(\"testInboundGateway\", TestMessagingGatewaySupport.class);\n \n \t\t\t\tMessage<?> receive = messagingGateway.process(new GenericMessage<>(\"test data\"));\n \n@@ -78,6 +87,14 @@ public SampleTestRunnerConsumer yourCode() {\n \t\t\t\t\t\t.extracting(\"payload\").isEqualTo(\"test data\");\n \t\t\t\tvar configuration = applicationContext.getBean(ObservationIntegrationTestConfiguration.class);\n \n+\t\t\t\tmessagingGateway =\n+\t\t\t\t\t\tapplicationContext.getBean(\"skippedObservationInboundGateway\",\n+\t\t\t\t\t\t\t\tTestMessagingGatewaySupport.class);\n+\n+\t\t\t\treceive = messagingGateway.process(new GenericMessage<>(\"void data\"));\n+\n+\t\t\t\tassertThat(receive).isNull();\n+\n \t\t\t\tassertThat(configuration.observedHandlerLatch.await(10, TimeUnit.SECONDS)).isTrue();\n \t\t\t}\n \n@@ -112,7 +129,7 @@ public SampleTestRunnerConsumer yourCode() {\n \t@EnableIntegration\n \t@EnableIntegrationManagement(\n \t\t\tobservationPatterns = {\n-\t\t\t\t\t\"${spring.integration.management.observation-patterns:testInboundGateway,queueChannel,observedEndpoint}\",\n+\t\t\t\t\t\"${spring.integration.management.observation-patterns:testInboundGateway,skippedObservationInboundGateway,queueChannel,observedEndpoint}\",\n \t\t\t\t\t\"${spring.integration.management.observation-patterns:}\"\n \t\t\t})\n \tpublic static class ObservationIntegrationTestConfiguration {\n@@ -126,7 +143,7 @@ public ChannelInterceptor observationPropagationInterceptor(ObservationRegistry\n \t\t}\n \n \t\t@Bean\n-\t\tTestMessagingGatewaySupport testInboundGateway(PollableChannel queueChannel) {\n+\t\tTestMessagingGatewaySupport testInboundGateway(@Qualifier(\"queueChannel\") PollableChannel queueChannel) {\n \t\t\tTestMessagingGatewaySupport messagingGatewaySupport = new TestMessagingGatewaySupport();\n \t\t\tmessagingGatewaySupport.setObservationConvention(\n \t\t\t\t\tnew DefaultMessageRequestReplyReceiverObservationConvention() {\n@@ -146,6 +163,15 @@ public PollableChannel queueChannel() {\n \t\t\treturn new QueueChannel();\n \t\t}\n \n+\n+\t\t@Bean\n+\t\tTestMessagingGatewaySupport skippedObservationInboundGateway() {\n+\t\t\tTestMessagingGatewaySupport messagingGatewaySupport = new TestMessagingGatewaySupport();\n+\t\t\tmessagingGatewaySupport.setRequestChannel(new NullChannel());\n+\t\t\tmessagingGatewaySupport.setReplyTimeout(0);\n+\t\t\treturn messagingGatewaySupport;\n+\t\t}\n+\n \t\t@Bean\n \t\t@EndpointId(\"observedEndpoint\")\n \t\t@ServiceActivator(inputChannel = \"queueChannel\",\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8661",
    "pr_id": 8661,
    "issue_id": 8611,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Decouple `BeanDefinitionRegistryPostProcessor` implementations\nWhile reviewing [an issue in Spring Framework](https://github.com/spring-projects/spring-framework/issues/30411#issuecomment-1532798212), I've noticed that Spring Integration has BeanDefinitionRegistryPostProcessor implementations that are also doing something else. \r\n\r\nWe're considering reviewing this contract so that such post-processors are automatically excluded from AOT processing (as they operation on the bean factory that's pre-processed by it). Can you please review `DefaultConfiguringBeanFactoryPostProcessor` and `MessagingAnnotationPostProcessor` so that they only perform bean definition registry post-processing and nothing else?",
    "issue_word_count": 86,
    "test_files_count": 5,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/config/MessagingAnnotationBeanPostProcessor.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/MessagingAnnotationPostProcessor.java",
      "spring-integration-core/src/test/java/org/springframework/integration/bus/DirectChannelSubscriptionTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/annotation/FilterAnnotationPostProcessorTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/annotation/MessagingAnnotationPostProcessorTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/annotation/RouterAnnotationPostProcessorTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/annotation/SplitterAnnotationPostProcessorTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/bus/DirectChannelSubscriptionTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/annotation/FilterAnnotationPostProcessorTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/annotation/MessagingAnnotationPostProcessorTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/annotation/RouterAnnotationPostProcessorTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/annotation/SplitterAnnotationPostProcessorTests.java"
    ],
    "base_commit": "13980af1e1f500757b142d5480ca86321f6e1985",
    "head_commit": "981bcb557c7648e753cf3960e97ecb35da912b48",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8661",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8661",
    "dockerfile": "",
    "pr_merged_at": "2023-06-28T12:59:37.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/MessagingAnnotationBeanPostProcessor.java b/spring-integration-core/src/main/java/org/springframework/integration/config/MessagingAnnotationBeanPostProcessor.java\nnew file mode 100644\nindex 00000000000..e9554ebc66d\n--- /dev/null\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/MessagingAnnotationBeanPostProcessor.java\n@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.config;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.springframework.aop.support.AopUtils;\n+import org.springframework.beans.BeansException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.BeanFactoryAware;\n+import org.springframework.beans.factory.SmartInitializingSingleton;\n+import org.springframework.beans.factory.config.BeanPostProcessor;\n+import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n+import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n+import org.springframework.beans.factory.support.RootBeanDefinition;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.core.annotation.AnnotationUtils;\n+import org.springframework.core.annotation.MergedAnnotation;\n+import org.springframework.core.annotation.MergedAnnotations;\n+import org.springframework.integration.annotation.EndpointId;\n+import org.springframework.integration.annotation.Role;\n+import org.springframework.integration.config.annotation.MethodAnnotationPostProcessor;\n+import org.springframework.integration.endpoint.AbstractEndpoint;\n+import org.springframework.integration.util.MessagingAnnotationUtils;\n+import org.springframework.util.Assert;\n+import org.springframework.util.ClassUtils;\n+import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.StringUtils;\n+\n+/**\n+ * An infrastructure {@link BeanPostProcessor} implementation that processes method-level\n+ * messaging annotations such as @Transformer, @Splitter, @Router, and @Filter.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 6.2\n+ */\n+public class MessagingAnnotationBeanPostProcessor\n+\t\timplements BeanPostProcessor, BeanFactoryAware, SmartInitializingSingleton {\n+\n+\tprivate final Set<Class<?>> noAnnotationsCache = Collections.newSetFromMap(new ConcurrentHashMap<>(256));\n+\n+\tprivate final Map<Class<? extends Annotation>, MethodAnnotationPostProcessor<?>> postProcessors;\n+\n+\tprivate final List<Runnable> methodsToPostProcessAfterContextInitialization = new ArrayList<>();\n+\n+\tprivate final BeanDefinitionRegistry registry;\n+\n+\tprivate ConfigurableListableBeanFactory beanFactory;\n+\n+\tprivate volatile boolean initialized;\n+\n+\tpublic MessagingAnnotationBeanPostProcessor(BeanDefinitionRegistry registry,\n+\t\t\tMap<Class<? extends Annotation>, MethodAnnotationPostProcessor<?>> postProcessors) {\n+\n+\t\tthis.registry = registry;\n+\t\tthis.postProcessors = postProcessors;\n+\t}\n+\n+\t@Override\n+\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n+\t\tthis.beanFactory = (ConfigurableListableBeanFactory) beanFactory;\n+\t}\n+\n+\t@Override\n+\tpublic Object postProcessAfterInitialization(final Object bean, final String beanName) throws BeansException {\n+\t\tAssert.notNull(this.beanFactory, \"BeanFactory must not be null\");\n+\n+\t\tClass<?> beanClass = AopUtils.getTargetClass(bean);\n+\n+\t\t// the set will hold records of prior class scans and indicate if no messaging annotations were found\n+\t\tif (this.noAnnotationsCache.contains(beanClass)) {\n+\t\t\treturn bean;\n+\t\t}\n+\n+\t\tReflectionUtils.doWithMethods(beanClass,\n+\t\t\t\tmethod -> doWithMethod(method, bean, beanName, beanClass),\n+\t\t\t\tReflectionUtils.USER_DECLARED_METHODS);\n+\n+\t\treturn bean;\n+\t}\n+\n+\tprivate void doWithMethod(Method method, Object bean, String beanName, Class<?> beanClass) {\n+\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(method);\n+\n+\t\tboolean noMessagingAnnotations = true;\n+\n+\t\t// See MessagingAnnotationPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry)\n+\t\tif (!mergedAnnotations.isPresent(Bean.class)) {\n+\t\t\tList<MessagingMetaAnnotation> messagingAnnotations =\n+\t\t\t\t\tobtainMessagingAnnotations(this.postProcessors.keySet(), mergedAnnotations,\n+\t\t\t\t\t\t\tmethod.toGenericString());\n+\n+\t\t\tfor (MessagingMetaAnnotation messagingAnnotation : messagingAnnotations) {\n+\t\t\t\tnoMessagingAnnotations = false;\n+\t\t\t\tClass<? extends Annotation> annotationType = messagingAnnotation.annotationType;\n+\t\t\t\tList<Annotation> annotationChain =\n+\t\t\t\t\t\tMessagingAnnotationUtils.getAnnotationChain(messagingAnnotation.annotation, annotationType);\n+\t\t\t\tprocessAnnotationTypeOnMethod(bean, beanName, method, annotationType, annotationChain);\n+\t\t\t}\n+\t\t}\n+\t\tif (noMessagingAnnotations) {\n+\t\t\tthis.noAnnotationsCache.add(beanClass);\n+\t\t}\n+\t}\n+\n+\tprivate void processAnnotationTypeOnMethod(Object bean, String beanName, Method method,\n+\t\t\tClass<? extends Annotation> annotationType, List<Annotation> annotations) {\n+\n+\t\tMethodAnnotationPostProcessor<?> postProcessor = this.postProcessors.get(annotationType);\n+\t\tif (postProcessor != null && postProcessor.supportsPojoMethod()\n+\t\t\t\t&& postProcessor.shouldCreateEndpoint(method, annotations)) {\n+\n+\t\t\tMethod targetMethod = method;\n+\t\t\tif (AopUtils.isJdkDynamicProxy(bean)) {\n+\t\t\t\ttry {\n+\t\t\t\t\ttargetMethod = bean.getClass().getMethod(method.getName(), method.getParameterTypes());\n+\t\t\t\t}\n+\t\t\t\tcatch (NoSuchMethodException e) {\n+\t\t\t\t\tthrow new IllegalArgumentException(\"Service methods must be extracted to the service \"\n+\t\t\t\t\t\t\t+ \"interface for JdkDynamicProxy. The affected bean is: '\" + beanName + \"' \"\n+\t\t\t\t\t\t\t+ \"and its method: '\" + method + \"'\", e);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (this.initialized) {\n+\t\t\t\tpostProcessMethodAndRegisterEndpointIfAny(bean, beanName, method, annotationType, annotations,\n+\t\t\t\t\t\tpostProcessor, targetMethod);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tMethod methodToPostProcess = targetMethod;\n+\t\t\t\tthis.methodsToPostProcessAfterContextInitialization.add(() ->\n+\t\t\t\t\t\tpostProcessMethodAndRegisterEndpointIfAny(bean, beanName, method, annotationType, annotations,\n+\t\t\t\t\t\t\t\tpostProcessor, methodToPostProcess));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate void postProcessMethodAndRegisterEndpointIfAny(Object bean, String beanName, Method method,\n+\t\t\tClass<? extends Annotation> annotationType, List<Annotation> annotations,\n+\t\t\tMethodAnnotationPostProcessor<?> postProcessor, Method targetMethod) {\n+\n+\t\tObject result = postProcessor.postProcess(bean, beanName, targetMethod, annotations);\n+\t\tif (result instanceof AbstractEndpoint endpoint) {\n+\t\t\tString autoStartup = MessagingAnnotationUtils.resolveAttribute(annotations, \"autoStartup\", String.class);\n+\t\t\tif (StringUtils.hasText(autoStartup)) {\n+\t\t\t\tautoStartup = this.beanFactory.resolveEmbeddedValue(autoStartup);\n+\t\t\t\tif (StringUtils.hasText(autoStartup)) {\n+\t\t\t\t\tendpoint.setAutoStartup(Boolean.parseBoolean(autoStartup));\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tString phase = MessagingAnnotationUtils.resolveAttribute(annotations, \"phase\", String.class);\n+\t\t\tif (StringUtils.hasText(phase)) {\n+\t\t\t\tphase = this.beanFactory.resolveEmbeddedValue(phase);\n+\t\t\t\tif (StringUtils.hasText(phase)) {\n+\t\t\t\t\tendpoint.setPhase(Integer.parseInt(phase));\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tRole role = AnnotationUtils.findAnnotation(method, Role.class);\n+\t\t\tif (role != null) {\n+\t\t\t\tendpoint.setRole(role.value());\n+\t\t\t}\n+\n+\t\t\tString endpointBeanName = generateBeanName(beanName, method, annotationType);\n+\t\t\tendpoint.setBeanName(endpointBeanName);\n+\t\t\tthis.registry.registerBeanDefinition(endpointBeanName,\n+\t\t\t\t\tnew RootBeanDefinition((Class<AbstractEndpoint>) endpoint.getClass(), () -> endpoint));\n+\t\t\tthis.beanFactory.getBean(endpointBeanName);\n+\t\t}\n+\t}\n+\n+\n+\tprotected String generateBeanName(String originalBeanName, Method method,\n+\t\t\tClass<? extends Annotation> annotationType) {\n+\n+\t\tString name = MessagingAnnotationUtils.endpointIdValue(method);\n+\t\tif (!StringUtils.hasText(name)) {\n+\t\t\tString baseName = originalBeanName + \".\" + method.getName() + \".\"\n+\t\t\t\t\t+ ClassUtils.getShortNameAsProperty(annotationType);\n+\t\t\tname = baseName;\n+\t\t\tint count = 1;\n+\t\t\twhile (this.beanFactory.containsBean(name)) {\n+\t\t\t\tname = baseName + \"#\" + (++count);\n+\t\t\t}\n+\t\t}\n+\t\treturn name;\n+\t}\n+\n+\t@Override\n+\tpublic void afterSingletonsInstantiated() {\n+\t\tthis.initialized = true;\n+\t\tthis.methodsToPostProcessAfterContextInitialization.forEach(Runnable::run);\n+\t\tthis.methodsToPostProcessAfterContextInitialization.clear();\n+\t}\n+\n+\tprotected static List<MessagingMetaAnnotation> obtainMessagingAnnotations(\n+\t\t\tSet<Class<? extends Annotation>> postProcessors, MergedAnnotations annotations, String identified) {\n+\n+\t\tList<MessagingMetaAnnotation> messagingAnnotations = new ArrayList<>();\n+\n+\t\tfor (Class<? extends Annotation> annotationType : postProcessors) {\n+\t\t\tannotations.stream()\n+\t\t\t\t\t.filter((ann) -> ann.getType().equals(annotationType))\n+\t\t\t\t\t.map(MergedAnnotation::getRoot)\n+\t\t\t\t\t.map(MergedAnnotation::synthesize)\n+\t\t\t\t\t.map((ann) -> new MessagingMetaAnnotation(ann, annotationType))\n+\t\t\t\t\t.forEach(messagingAnnotations::add);\n+\t\t}\n+\n+\t\tif (annotations.get(EndpointId.class, (ann) -> ann.hasNonDefaultValue(\"value\")).isPresent()\n+\t\t\t\t&& messagingAnnotations.size() > 1) {\n+\n+\t\t\tthrow new IllegalStateException(\"@EndpointId on \" + identified\n+\t\t\t\t\t+ \" can only have one EIP annotation, found: \" + messagingAnnotations.size());\n+\t\t}\n+\n+\t\treturn messagingAnnotations;\n+\t}\n+\n+\tpublic record MessagingMetaAnnotation(Annotation annotation, Class<? extends Annotation> annotationType) {\n+\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/MessagingAnnotationPostProcessor.java b/spring-integration-core/src/main/java/org/springframework/integration/config/MessagingAnnotationPostProcessor.java\nindex 766ad1a2518..8813a1a3717 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/MessagingAnnotationPostProcessor.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/MessagingAnnotationPostProcessor.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,58 +16,38 @@\n \n package org.springframework.integration.config;\n \n+import java.beans.Introspector;\n import java.lang.annotation.Annotation;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n \n-import org.apache.commons.logging.Log;\n-import org.apache.commons.logging.LogFactory;\n-\n-import org.springframework.aop.support.AopUtils;\n-import org.springframework.aot.AotDetector;\n import org.springframework.beans.BeansException;\n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryAware;\n-import org.springframework.beans.factory.SmartInitializingSingleton;\n import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\n import org.springframework.beans.factory.config.BeanDefinition;\n import org.springframework.beans.factory.config.BeanPostProcessor;\n import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n+import org.springframework.beans.factory.support.BeanDefinitionBuilder;\n import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\n import org.springframework.beans.factory.support.BeanDefinitionValidationException;\n-import org.springframework.beans.factory.support.RootBeanDefinition;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.core.annotation.AnnotationUtils;\n-import org.springframework.core.annotation.MergedAnnotation;\n import org.springframework.core.annotation.MergedAnnotations;\n import org.springframework.core.type.MethodMetadata;\n import org.springframework.core.type.StandardMethodMetadata;\n import org.springframework.integration.annotation.Aggregator;\n import org.springframework.integration.annotation.BridgeFrom;\n import org.springframework.integration.annotation.BridgeTo;\n-import org.springframework.integration.annotation.EndpointId;\n import org.springframework.integration.annotation.Filter;\n import org.springframework.integration.annotation.InboundChannelAdapter;\n-import org.springframework.integration.annotation.Role;\n import org.springframework.integration.annotation.Router;\n import org.springframework.integration.annotation.ServiceActivator;\n import org.springframework.integration.annotation.Splitter;\n import org.springframework.integration.annotation.Transformer;\n import org.springframework.integration.config.annotation.MethodAnnotationPostProcessor;\n-import org.springframework.integration.endpoint.AbstractEndpoint;\n import org.springframework.integration.util.MessagingAnnotationUtils;\n-import org.springframework.util.Assert;\n-import org.springframework.util.ClassUtils;\n import org.springframework.util.CollectionUtils;\n-import org.springframework.util.ReflectionUtils;\n-import org.springframework.util.StringUtils;\n \n /**\n  * A {@link BeanPostProcessor} implementation that processes method-level\n@@ -79,26 +59,18 @@\n  * @author Gary Russell\n  * @author Rick Hogge\n  */\n-public class MessagingAnnotationPostProcessor\n-\t\timplements BeanDefinitionRegistryPostProcessor, BeanPostProcessor, SmartInitializingSingleton {\n-\n-\tprotected final Log logger = LogFactory.getLog(this.getClass()); // NOSONAR\n+public class MessagingAnnotationPostProcessor implements BeanDefinitionRegistryPostProcessor {\n \n \tprivate final Map<Class<? extends Annotation>, MethodAnnotationPostProcessor<?>> postProcessors = new HashMap<>();\n \n-\tprivate final Set<Class<?>> noAnnotationsCache = Collections.newSetFromMap(new ConcurrentHashMap<>(256));\n-\n-\tprivate final List<Runnable> methodsToPostProcessAfterContextInitialization = new ArrayList<>();\n-\n \tprivate BeanDefinitionRegistry registry;\n \n \tprivate ConfigurableListableBeanFactory beanFactory;\n \n-\tprivate volatile boolean initialized;\n-\n \t@Override\n \tpublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n \t\tthis.registry = registry;\n+\n \t\tthis.postProcessors.put(Filter.class, new FilterAnnotationPostProcessor());\n \t\tthis.postProcessors.put(Router.class, new RouterAnnotationPostProcessor());\n \t\tthis.postProcessors.put(Transformer.class, new TransformerAnnotationPostProcessor());\n@@ -108,6 +80,7 @@ public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) t\n \t\tthis.postProcessors.put(InboundChannelAdapter.class, new InboundChannelAdapterAnnotationPostProcessor());\n \t\tthis.postProcessors.put(BridgeFrom.class, new BridgeFromAnnotationPostProcessor());\n \t\tthis.postProcessors.put(BridgeTo.class, new BridgeToAnnotationPostProcessor());\n+\n \t\tMap<Class<? extends Annotation>, MethodAnnotationPostProcessor<?>> customPostProcessors =\n \t\t\t\tsetupCustomPostProcessors();\n \t\tif (!CollectionUtils.isEmpty(customPostProcessors)) {\n@@ -118,16 +91,22 @@ public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) t\n \t\t\t\t.map(BeanFactoryAware.class::cast)\n \t\t\t\t.forEach((processor) -> processor.setBeanFactory((BeanFactory) this.registry));\n \n-\t\tif (!AotDetector.useGeneratedArtifacts()) {\n-\t\t\tString[] beanNames = registry.getBeanDefinitionNames();\n+\t\tthis.registry.registerBeanDefinition(\n+\t\t\t\tIntrospector.decapitalize(MessagingAnnotationBeanPostProcessor.class.getName()),\n+\t\t\t\tBeanDefinitionBuilder.rootBeanDefinition(MessagingAnnotationBeanPostProcessor.class)\n+\t\t\t\t\t\t.setRole(BeanDefinition.ROLE_INFRASTRUCTURE)\n+\t\t\t\t\t\t.addConstructorArgValue(this.registry)\n+\t\t\t\t\t\t.addConstructorArgValue(this.postProcessors)\n+\t\t\t\t\t\t.getBeanDefinition());\n \n-\t\t\tfor (String beanName : beanNames) {\n-\t\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n-\t\t\t\tif (beanDef instanceof AnnotatedBeanDefinition annotatedBeanDefinition\n-\t\t\t\t\t\t&& annotatedBeanDefinition.getFactoryMethodMetadata() != null) {\n+\t\tString[] beanNames = registry.getBeanDefinitionNames();\n \n-\t\t\t\t\tprocessCandidate(beanName, annotatedBeanDefinition);\n-\t\t\t\t}\n+\t\tfor (String beanName : beanNames) {\n+\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n+\t\t\tif (beanDef instanceof AnnotatedBeanDefinition annotatedBeanDefinition\n+\t\t\t\t\t&& annotatedBeanDefinition.getFactoryMethodMetadata() != null) {\n+\n+\t\t\t\tprocessCandidate(beanName, annotatedBeanDefinition);\n \t\t\t}\n \t\t}\n \t}\n@@ -139,39 +118,19 @@ private void processCandidate(String beanName, AnnotatedBeanDefinition beanDefin\n \t\t\tannotations = MergedAnnotations.from(standardMethodMetadata.getIntrospectedMethod());\n \t\t}\n \n-\t\tList<MessagingMetaAnnotation> messagingAnnotations = obtainMessagingAnnotations(annotations, beanName);\n+\t\tList<MessagingAnnotationBeanPostProcessor.MessagingMetaAnnotation> messagingAnnotations =\n+\t\t\t\tMessagingAnnotationBeanPostProcessor.obtainMessagingAnnotations(this.postProcessors.keySet(),\n+\t\t\t\t\t\tannotations, beanName);\n \n-\t\tfor (MessagingMetaAnnotation messagingAnnotation : messagingAnnotations) {\n-\t\t\tClass<? extends Annotation> annotationType = messagingAnnotation.annotationType;\n+\t\tfor (MessagingAnnotationBeanPostProcessor.MessagingMetaAnnotation messagingAnnotation : messagingAnnotations) {\n+\t\t\tClass<? extends Annotation> annotationType = messagingAnnotation.annotationType();\n \t\t\tList<Annotation> annotationChain =\n-\t\t\t\t\tMessagingAnnotationUtils.getAnnotationChain(messagingAnnotation.annotation, annotationType);\n+\t\t\t\t\tMessagingAnnotationUtils.getAnnotationChain(messagingAnnotation.annotation(), annotationType);\n \n \t\t\tprocessMessagingAnnotationOnBean(beanName, beanDefinition, annotationType, annotationChain);\n \t\t}\n \t}\n \n-\tprivate List<MessagingMetaAnnotation> obtainMessagingAnnotations(MergedAnnotations annotations, String identified) {\n-\t\tList<MessagingMetaAnnotation> messagingAnnotations = new ArrayList<>();\n-\n-\t\tfor (Class<? extends Annotation> annotationType : this.postProcessors.keySet()) {\n-\t\t\tannotations.stream()\n-\t\t\t\t\t.filter((ann) -> ann.getType().equals(annotationType))\n-\t\t\t\t\t.map(MergedAnnotation::getRoot)\n-\t\t\t\t\t.map(MergedAnnotation::synthesize)\n-\t\t\t\t\t.map((ann) -> new MessagingMetaAnnotation(ann, annotationType))\n-\t\t\t\t\t.forEach(messagingAnnotations::add);\n-\t\t}\n-\n-\t\tif (annotations.get(EndpointId.class, (ann) -> ann.hasNonDefaultValue(\"value\")).isPresent()\n-\t\t\t\t&& messagingAnnotations.size() > 1) {\n-\n-\t\t\tthrow new IllegalStateException(\"@EndpointId on \" + identified\n-\t\t\t\t\t+ \" can only have one EIP annotation, found: \" + messagingAnnotations.size());\n-\t\t}\n-\n-\t\treturn messagingAnnotations;\n-\t}\n-\n \tprivate void processMessagingAnnotationOnBean(String beanName, AnnotatedBeanDefinition beanDefinition,\n \t\t\tClass<? extends Annotation> annotationType, List<Annotation> annotationChain) {\n \n@@ -220,150 +179,8 @@ public <A extends Annotation> void addMessagingAnnotationPostProcessor(Class<A>\n \t\tthis.postProcessors.put(annotation, postProcessor);\n \t}\n \n-\t@Override\n-\tpublic void afterSingletonsInstantiated() {\n-\t\tthis.initialized = true;\n-\t\tthis.methodsToPostProcessAfterContextInitialization.forEach(Runnable::run);\n-\t\tthis.methodsToPostProcessAfterContextInitialization.clear();\n-\t}\n-\n-\t@Override\n-\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n-\t\treturn bean;\n-\t}\n-\n-\t@Override\n-\tpublic Object postProcessAfterInitialization(final Object bean, final String beanName) throws BeansException {\n-\t\tAssert.notNull(this.beanFactory, \"BeanFactory must not be null\");\n-\n-\t\tClass<?> beanClass = AopUtils.getTargetClass(bean);\n-\n-\t\t// the set will hold records of prior class scans and indicate if no messaging annotations were found\n-\t\tif (this.noAnnotationsCache.contains(beanClass)) {\n-\t\t\treturn bean;\n-\t\t}\n-\n-\t\tReflectionUtils.doWithMethods(beanClass,\n-\t\t\t\tmethod -> doWithMethod(method, bean, beanName, beanClass),\n-\t\t\t\tReflectionUtils.USER_DECLARED_METHODS);\n-\n-\t\treturn bean;\n-\t}\n-\n-\tprivate void doWithMethod(Method method, Object bean, String beanName, Class<?> beanClass) {\n-\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(method);\n-\n-\t\tboolean noMessagingAnnotations = true;\n-\n-\t\tif (!mergedAnnotations.isPresent(Bean.class)) { // See postProcessBeanDefinitionRegistry(BeanDefinitionRegistry)\n-\t\t\tList<MessagingMetaAnnotation> messagingAnnotations =\n-\t\t\t\t\tobtainMessagingAnnotations(mergedAnnotations, method.toGenericString());\n-\n-\t\t\tfor (MessagingMetaAnnotation messagingAnnotation : messagingAnnotations) {\n-\t\t\t\tnoMessagingAnnotations = false;\n-\t\t\t\tClass<? extends Annotation> annotationType = messagingAnnotation.annotationType;\n-\t\t\t\tList<Annotation> annotationChain =\n-\t\t\t\t\t\tMessagingAnnotationUtils.getAnnotationChain(messagingAnnotation.annotation, annotationType);\n-\t\t\t\tprocessAnnotationTypeOnMethod(bean, beanName, method, annotationType, annotationChain);\n-\t\t\t}\n-\t\t}\n-\t\tif (noMessagingAnnotations) {\n-\t\t\tthis.noAnnotationsCache.add(beanClass);\n-\t\t}\n-\t}\n-\n-\tprotected void processAnnotationTypeOnMethod(Object bean, String beanName, Method method,\n-\t\t\tClass<? extends Annotation> annotationType, List<Annotation> annotations) {\n-\n-\t\tMethodAnnotationPostProcessor<?> postProcessor =\n-\t\t\t\tMessagingAnnotationPostProcessor.this.postProcessors.get(annotationType);\n-\t\tif (postProcessor != null && postProcessor.supportsPojoMethod()\n-\t\t\t\t&& postProcessor.shouldCreateEndpoint(method, annotations)) {\n-\n-\t\t\tMethod targetMethod = method;\n-\t\t\tif (AopUtils.isJdkDynamicProxy(bean)) {\n-\t\t\t\ttry {\n-\t\t\t\t\ttargetMethod = bean.getClass().getMethod(method.getName(), method.getParameterTypes());\n-\t\t\t\t}\n-\t\t\t\tcatch (NoSuchMethodException e) {\n-\t\t\t\t\tthrow new IllegalArgumentException(\"Service methods must be extracted to the service \"\n-\t\t\t\t\t\t\t+ \"interface for JdkDynamicProxy. The affected bean is: '\" + beanName + \"' \"\n-\t\t\t\t\t\t\t+ \"and its method: '\" + method + \"'\", e);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (this.initialized) {\n-\t\t\t\tpostProcessMethodAndRegisterEndpointIfAny(bean, beanName, method, annotationType, annotations,\n-\t\t\t\t\t\tpostProcessor, targetMethod);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tMethod methodToPostProcess = targetMethod;\n-\t\t\t\tthis.methodsToPostProcessAfterContextInitialization.add(() ->\n-\t\t\t\t\t\tpostProcessMethodAndRegisterEndpointIfAny(bean, beanName, method, annotationType, annotations,\n-\t\t\t\t\t\t\t\tpostProcessor, methodToPostProcess));\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@SuppressWarnings(\"unchecked\")\n-\tprivate void postProcessMethodAndRegisterEndpointIfAny(Object bean, String beanName, Method method,\n-\t\t\tClass<? extends Annotation> annotationType, List<Annotation> annotations,\n-\t\t\tMethodAnnotationPostProcessor<?> postProcessor, Method targetMethod) {\n-\n-\t\tObject result = postProcessor.postProcess(bean, beanName, targetMethod, annotations);\n-\t\tif (result instanceof AbstractEndpoint endpoint) {\n-\t\t\tString autoStartup = MessagingAnnotationUtils.resolveAttribute(annotations, \"autoStartup\", String.class);\n-\t\t\tif (StringUtils.hasText(autoStartup)) {\n-\t\t\t\tautoStartup = this.beanFactory.resolveEmbeddedValue(autoStartup);\n-\t\t\t\tif (StringUtils.hasText(autoStartup)) {\n-\t\t\t\t\tendpoint.setAutoStartup(Boolean.parseBoolean(autoStartup));\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tString phase = MessagingAnnotationUtils.resolveAttribute(annotations, \"phase\", String.class);\n-\t\t\tif (StringUtils.hasText(phase)) {\n-\t\t\t\tphase = this.beanFactory.resolveEmbeddedValue(phase);\n-\t\t\t\tif (StringUtils.hasText(phase)) {\n-\t\t\t\t\tendpoint.setPhase(Integer.parseInt(phase));\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tRole role = AnnotationUtils.findAnnotation(method, Role.class);\n-\t\t\tif (role != null) {\n-\t\t\t\tendpoint.setRole(role.value());\n-\t\t\t}\n-\n-\t\t\tString endpointBeanName = generateBeanName(beanName, method, annotationType);\n-\t\t\tendpoint.setBeanName(endpointBeanName);\n-\t\t\tgetBeanDefinitionRegistry()\n-\t\t\t\t\t.registerBeanDefinition(endpointBeanName,\n-\t\t\t\t\t\t\tnew RootBeanDefinition((Class<AbstractEndpoint>) endpoint.getClass(), () -> endpoint));\n-\t\t\tthis.beanFactory.getBean(endpointBeanName);\n-\t\t}\n-\t}\n-\n-\tprotected String generateBeanName(String originalBeanName, Method method,\n-\t\t\tClass<? extends Annotation> annotationType) {\n-\n-\t\tString name = MessagingAnnotationUtils.endpointIdValue(method);\n-\t\tif (!StringUtils.hasText(name)) {\n-\t\t\tString baseName = originalBeanName + \".\" + method.getName() + \".\"\n-\t\t\t\t\t+ ClassUtils.getShortNameAsProperty(annotationType);\n-\t\t\tname = baseName;\n-\t\t\tint count = 1;\n-\t\t\twhile (this.beanFactory.containsBean(name)) {\n-\t\t\t\tname = baseName + \"#\" + (++count);\n-\t\t\t}\n-\t\t}\n-\t\treturn name;\n-\t}\n-\n \tprotected Map<Class<? extends Annotation>, MethodAnnotationPostProcessor<?>> getPostProcessors() {\n \t\treturn this.postProcessors;\n \t}\n \n-\tprotected record MessagingMetaAnnotation(Annotation annotation, Class<? extends Annotation> annotationType) {\n-\n-\t}\n-\n }\n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/bus/DirectChannelSubscriptionTests.java b/spring-integration-core/src/test/java/org/springframework/integration/bus/DirectChannelSubscriptionTests.java\nindex 17708cb9708..d037d92733f 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/bus/DirectChannelSubscriptionTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/bus/DirectChannelSubscriptionTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,7 +20,6 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n \n-import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n import org.springframework.integration.annotation.MessageEndpoint;\n import org.springframework.integration.annotation.ServiceActivator;\n import org.springframework.integration.channel.DirectChannel;\n@@ -55,6 +54,7 @@ public class DirectChannelSubscriptionTests {\n \n \t@BeforeEach\n \tpublic void setupChannels() {\n+\t\tthis.context.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tthis.context.registerChannel(\"sourceChannel\", this.sourceChannel);\n \t\tthis.context.registerChannel(\"targetChannel\", this.targetChannel);\n \t}\n@@ -80,13 +80,9 @@ public void sendAndReceiveForRegisteredEndpoint() {\n \n \t@Test\n \tpublic void sendAndReceiveForAnnotatedEndpoint() {\n-\t\tMessagingAnnotationPostProcessor postProcessor = new MessagingAnnotationPostProcessor();\n-\t\tpostProcessor.postProcessBeanDefinitionRegistry((BeanDefinitionRegistry) this.context.getBeanFactory());\n-\t\tpostProcessor.postProcessBeanFactory(this.context.getBeanFactory());\n-\t\tpostProcessor.afterSingletonsInstantiated();\n-\t\tTestEndpoint endpoint = new TestEndpoint();\n-\t\tpostProcessor.postProcessAfterInitialization(endpoint, \"testEndpoint\");\n+\t\tthis.context.registerEndpoint(\"testEndpoint\", new TestEndpoint());\n \t\tthis.context.refresh();\n+\n \t\tthis.sourceChannel.send(new GenericMessage<>(\"foo\"));\n \t\tMessage<?> response = this.targetChannel.receive();\n \t\tassertThat(response.getPayload()).isEqualTo(\"foo-from-annotated-endpoint\");\n@@ -113,11 +109,7 @@ public Object handleRequestMessage(Message<?> message) {\n \tpublic void exceptionThrownFromAnnotatedEndpoint() {\n \t\tQueueChannel errorChannel = new QueueChannel();\n \t\tthis.context.registerChannel(IntegrationContextUtils.ERROR_CHANNEL_BEAN_NAME, errorChannel);\n-\t\tMessagingAnnotationPostProcessor postProcessor = new MessagingAnnotationPostProcessor();\n-\t\tpostProcessor.postProcessBeanFactory(this.context.getBeanFactory());\n-\t\tpostProcessor.afterSingletonsInstantiated();\n-\t\tFailingTestEndpoint endpoint = new FailingTestEndpoint();\n-\t\tpostProcessor.postProcessAfterInitialization(endpoint, \"testEndpoint\");\n+\t\tthis.context.registerEndpoint(\"testEndpoint\", new FailingTestEndpoint());\n \t\tthis.context.refresh();\n \t\tassertThatExceptionOfType(MessagingException.class)\n \t\t\t\t.isThrownBy(() -> this.sourceChannel.send(new GenericMessage<>(\"foo\")));\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/FilterAnnotationPostProcessorTests.java b/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/FilterAnnotationPostProcessorTests.java\nindex e894d5026ee..76047981a9f 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/FilterAnnotationPostProcessorTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/FilterAnnotationPostProcessorTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,11 +23,11 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n \n-import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n import org.springframework.integration.annotation.Filter;\n import org.springframework.integration.annotation.MessageEndpoint;\n import org.springframework.integration.channel.DirectChannel;\n import org.springframework.integration.channel.QueueChannel;\n+import org.springframework.integration.config.MessagingAnnotationBeanPostProcessor;\n import org.springframework.integration.config.MessagingAnnotationPostProcessor;\n import org.springframework.integration.endpoint.EventDrivenConsumer;\n import org.springframework.integration.handler.advice.AbstractRequestHandlerAdvice;\n@@ -50,19 +50,15 @@ public class FilterAnnotationPostProcessorTests {\n \n \tprivate final TestApplicationContext context = TestUtils.createTestApplicationContext();\n \n-\tprivate final MessagingAnnotationPostProcessor postProcessor = new MessagingAnnotationPostProcessor();\n-\n \tprivate final DirectChannel inputChannel = new DirectChannel();\n \n \tprivate final QueueChannel outputChannel = new QueueChannel();\n \n \t@BeforeEach\n \tpublic void init() {\n+\t\tthis.context.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tthis.context.registerChannel(\"input\", this.inputChannel);\n \t\tthis.context.registerChannel(\"output\", this.outputChannel);\n-\t\tthis.postProcessor.postProcessBeanDefinitionRegistry((BeanDefinitionRegistry) this.context.getBeanFactory());\n-\t\tthis.postProcessor.postProcessBeanFactory(this.context.getBeanFactory());\n-\t\tthis.postProcessor.afterSingletonsInstantiated();\n \t}\n \n \t@AfterEach\n@@ -175,21 +171,26 @@ public void filterAnnotationWithBooleanWrapperClass() {\n \n \t@Test\n \tpublic void invalidMethodWithStringReturnType() {\n-\t\tObject filter = new TestFilterWithStringReturnType();\n+\t\tcontext.refresh();\n+\t\tvar postProcessor = context.getBean(MessagingAnnotationBeanPostProcessor.class);\n \t\tassertThatIllegalArgumentException()\n-\t\t\t\t.isThrownBy(() -> this.postProcessor.postProcessAfterInitialization(filter, \"testFilter\"));\n+\t\t\t\t.isThrownBy(() ->\n+\t\t\t\t\t\tpostProcessor.postProcessAfterInitialization(\n+\t\t\t\t\t\t\t\tnew TestFilterWithStringReturnType(), \"testFilter\"));\n \t}\n \n \t@Test\n \tpublic void invalidMethodWithVoidReturnType() {\n-\t\tObject filter = new TestFilterWithVoidReturnType();\n+\t\tcontext.refresh();\n+\t\tvar postProcessor = context.getBean(MessagingAnnotationBeanPostProcessor.class);\n \t\tassertThatIllegalArgumentException()\n-\t\t\t\t.isThrownBy(() -> postProcessor.postProcessAfterInitialization(filter, \"testFilter\"));\n+\t\t\t\t.isThrownBy(() ->\n+\t\t\t\t\t\tpostProcessor.postProcessAfterInitialization(new TestFilterWithVoidReturnType(), \"testFilter\"));\n \t}\n \n \n \tprivate void testValidFilter(Object filter) {\n-\t\tpostProcessor.postProcessAfterInitialization(filter, \"testFilter\");\n+\t\tcontext.registerEndpoint(\"testFilter\", filter);\n \t\tcontext.refresh();\n \t\tinputChannel.send(new GenericMessage<>(\"good\"));\n \t\tMessage<?> passed = outputChannel.receive(0);\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/MessagingAnnotationPostProcessorTests.java b/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/MessagingAnnotationPostProcessorTests.java\nindex b12505c12e0..be954f5c38c 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/MessagingAnnotationPostProcessorTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/MessagingAnnotationPostProcessorTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -27,8 +27,6 @@\n import org.junit.jupiter.api.Test;\n \n import org.springframework.aop.framework.ProxyFactory;\n-import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n-import org.springframework.context.ConfigurableApplicationContext;\n import org.springframework.context.support.AbstractApplicationContext;\n import org.springframework.context.support.ClassPathXmlApplicationContext;\n import org.springframework.integration.annotation.MessageEndpoint;\n@@ -36,6 +34,7 @@\n import org.springframework.integration.annotation.Transformer;\n import org.springframework.integration.channel.DirectChannel;\n import org.springframework.integration.channel.QueueChannel;\n+import org.springframework.integration.config.MessagingAnnotationBeanPostProcessor;\n import org.springframework.integration.config.MessagingAnnotationPostProcessor;\n import org.springframework.integration.endpoint.AbstractEndpoint;\n import org.springframework.integration.handler.advice.AbstractRequestHandlerAdvice;\n@@ -63,9 +62,10 @@ public void serviceActivatorAnnotation() {\n \t\tTestApplicationContext context = TestUtils.createTestApplicationContext();\n \t\tDirectChannel inputChannel = new DirectChannel();\n \t\tcontext.registerChannel(\"inputChannel\", inputChannel);\n+\t\tcontext.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tcontext.refresh();\n \n-\t\tMessagingAnnotationPostProcessor postProcessor = prepareMessagingAnnotationPostProcessor(context);\n+\t\tMessagingAnnotationBeanPostProcessor postProcessor = context.getBean(MessagingAnnotationBeanPostProcessor.class);\n \t\tServiceActivatorAnnotatedBean bean = new ServiceActivatorAnnotatedBean();\n \t\tpostProcessor.postProcessAfterInitialization(bean, \"testBean\");\n \t\tassertThat(context.containsBean(\"testBean.test.serviceActivator\")).isTrue();\n@@ -135,11 +135,11 @@ public void typeConvertingHandler() {\n \t@Test\n \tpublic void outboundOnlyServiceActivator() throws InterruptedException {\n \t\tTestApplicationContext context = TestUtils.createTestApplicationContext();\n+\t\tcontext.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tcontext.registerChannel(\"testChannel\", new DirectChannel());\n-\t\tMessagingAnnotationPostProcessor postProcessor = prepareMessagingAnnotationPostProcessor(context);\n \t\tCountDownLatch latch = new CountDownLatch(1);\n \t\tOutboundOnlyTestBean testBean = new OutboundOnlyTestBean(latch);\n-\t\tpostProcessor.postProcessAfterInitialization(testBean, \"testBean\");\n+\t\tcontext.registerEndpoint(\"testBean\", testBean);\n \t\tcontext.refresh();\n \t\tDestinationResolver<MessageChannel> channelResolver = new BeanFactoryChannelResolver(context);\n \t\tMessageChannel testChannel = channelResolver.resolveDestination(\"testChannel\");\n@@ -153,15 +153,15 @@ public void outboundOnlyServiceActivator() throws InterruptedException {\n \t@Test\n \tpublic void testChannelResolution() {\n \t\tTestApplicationContext context = TestUtils.createTestApplicationContext();\n+\t\tcontext.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tDirectChannel inputChannel = new DirectChannel();\n \t\tQueueChannel outputChannel = new QueueChannel();\n \t\tDirectChannel eventBus = new DirectChannel();\n \t\tcontext.registerChannel(\"inputChannel\", inputChannel);\n \t\tcontext.registerChannel(\"outputChannel\", outputChannel);\n \t\tcontext.registerChannel(\"eventBus\", eventBus);\n-\t\tMessagingAnnotationPostProcessor postProcessor = prepareMessagingAnnotationPostProcessor(context);\n \t\tServiceActivatorAnnotatedBean bean = new ServiceActivatorAnnotatedBean();\n-\t\tpostProcessor.postProcessAfterInitialization(bean, \"testBean\");\n+\t\tcontext.registerEndpoint(\"testBean\", bean);\n \t\tcontext.refresh();\n \t\tMessage<?> message = MessageBuilder.withPayload(\"test\")\n \t\t\t\t.setReplyChannelName(\"outputChannel\").build();\n@@ -178,14 +178,14 @@ public void testChannelResolution() {\n \t@Test\n \tpublic void testProxiedMessageEndpointAnnotation() {\n \t\tTestApplicationContext context = TestUtils.createTestApplicationContext();\n+\t\tcontext.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tDirectChannel inputChannel = new DirectChannel();\n \t\tQueueChannel outputChannel = new QueueChannel();\n \t\tcontext.registerChannel(\"inputChannel\", inputChannel);\n \t\tcontext.registerChannel(\"outputChannel\", outputChannel);\n-\t\tMessagingAnnotationPostProcessor postProcessor = prepareMessagingAnnotationPostProcessor(context);\n \t\tProxyFactory proxyFactory = new ProxyFactory(new AnnotatedTestService());\n \t\tObject proxy = proxyFactory.getProxy();\n-\t\tpostProcessor.postProcessAfterInitialization(proxy, \"proxy\");\n+\t\tcontext.registerEndpoint(\"proxy\", proxy);\n \t\tcontext.refresh();\n \t\tinputChannel.send(new GenericMessage<>(\"world\"));\n \t\tMessage<?> message = outputChannel.receive(1000);\n@@ -196,12 +196,12 @@ public void testProxiedMessageEndpointAnnotation() {\n \t@Test\n \tpublic void testMessageEndpointAnnotationInherited() {\n \t\tTestApplicationContext context = TestUtils.createTestApplicationContext();\n+\t\tcontext.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tDirectChannel inputChannel = new DirectChannel();\n \t\tQueueChannel outputChannel = new QueueChannel();\n \t\tcontext.registerChannel(\"inputChannel\", inputChannel);\n \t\tcontext.registerChannel(\"outputChannel\", outputChannel);\n-\t\tMessagingAnnotationPostProcessor postProcessor = prepareMessagingAnnotationPostProcessor(context);\n-\t\tpostProcessor.postProcessAfterInitialization(new SimpleAnnotatedEndpointSubclass(), \"subclass\");\n+\t\tcontext.registerEndpoint(\"subclass\", new SimpleAnnotatedEndpointSubclass());\n \t\tcontext.refresh();\n \t\tinputChannel.send(new GenericMessage<>(\"world\"));\n \t\tMessage<?> message = outputChannel.receive(1000);\n@@ -212,14 +212,14 @@ public void testMessageEndpointAnnotationInherited() {\n \t@Test\n \tpublic void testMessageEndpointAnnotationInheritedWithProxy() {\n \t\tTestApplicationContext context = TestUtils.createTestApplicationContext();\n+\t\tcontext.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tDirectChannel inputChannel = new DirectChannel();\n \t\tQueueChannel outputChannel = new QueueChannel();\n \t\tcontext.registerChannel(\"inputChannel\", inputChannel);\n \t\tcontext.registerChannel(\"outputChannel\", outputChannel);\n-\t\tMessagingAnnotationPostProcessor postProcessor = prepareMessagingAnnotationPostProcessor(context);\n \t\tProxyFactory proxyFactory = new ProxyFactory(new SimpleAnnotatedEndpointSubclass());\n \t\tObject proxy = proxyFactory.getProxy();\n-\t\tpostProcessor.postProcessAfterInitialization(proxy, \"proxy\");\n+\t\tcontext.registerEndpoint(\"proxy\", proxy);\n \t\tcontext.refresh();\n \t\tinputChannel.send(new GenericMessage<>(\"world\"));\n \t\tMessage<?> message = outputChannel.receive(1000);\n@@ -230,12 +230,12 @@ public void testMessageEndpointAnnotationInheritedWithProxy() {\n \t@Test\n \tpublic void testMessageEndpointAnnotationInheritedFromInterface() {\n \t\tTestApplicationContext context = TestUtils.createTestApplicationContext();\n+\t\tcontext.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tDirectChannel inputChannel = new DirectChannel();\n \t\tQueueChannel outputChannel = new QueueChannel();\n \t\tcontext.registerChannel(\"inputChannel\", inputChannel);\n \t\tcontext.registerChannel(\"outputChannel\", outputChannel);\n-\t\tMessagingAnnotationPostProcessor postProcessor = prepareMessagingAnnotationPostProcessor(context);\n-\t\tpostProcessor.postProcessAfterInitialization(new SimpleAnnotatedEndpointImplementation(), \"impl\");\n+\t\tcontext.registerEndpoint(\"impl\", new SimpleAnnotatedEndpointImplementation());\n \t\tcontext.refresh();\n \t\tinputChannel.send(new GenericMessage<>(\"ABC\"));\n \t\tMessage<?> message = outputChannel.receive(1000);\n@@ -246,12 +246,12 @@ public void testMessageEndpointAnnotationInheritedFromInterface() {\n \t@Test\n \tpublic void testMessageEndpointAnnotationInheritedFromInterfaceWithAutoCreatedChannels() {\n \t\tTestApplicationContext context = TestUtils.createTestApplicationContext();\n+\t\tcontext.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tDirectChannel inputChannel = new DirectChannel();\n \t\tQueueChannel outputChannel = new QueueChannel();\n \t\tcontext.registerChannel(\"inputChannel\", inputChannel);\n \t\tcontext.registerChannel(\"outputChannel\", outputChannel);\n-\t\tMessagingAnnotationPostProcessor postProcessor = prepareMessagingAnnotationPostProcessor(context);\n-\t\tpostProcessor.postProcessAfterInitialization(new SimpleAnnotatedEndpointImplementation(), \"impl\");\n+\t\tcontext.registerEndpoint(\"impl\", new SimpleAnnotatedEndpointImplementation());\n \t\tcontext.refresh();\n \t\tinputChannel.send(new GenericMessage<>(\"ABC\"));\n \t\tMessage<?> message = outputChannel.receive(1000);\n@@ -262,14 +262,13 @@ public void testMessageEndpointAnnotationInheritedFromInterfaceWithAutoCreatedCh\n \t@Test\n \tpublic void testMessageEndpointAnnotationInheritedFromInterfaceWithProxy() {\n \t\tTestApplicationContext context = TestUtils.createTestApplicationContext();\n+\t\tcontext.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tDirectChannel inputChannel = new DirectChannel();\n \t\tQueueChannel outputChannel = new QueueChannel();\n \t\tcontext.registerChannel(\"inputChannel\", inputChannel);\n \t\tcontext.registerChannel(\"outputChannel\", outputChannel);\n-\t\tMessagingAnnotationPostProcessor postProcessor = prepareMessagingAnnotationPostProcessor(context);\n \t\tProxyFactory proxyFactory = new ProxyFactory(new SimpleAnnotatedEndpointImplementation());\n-\t\tObject proxy = proxyFactory.getProxy();\n-\t\tpostProcessor.postProcessAfterInitialization(proxy, \"proxy\");\n+\t\tcontext.registerEndpoint(\"proxy\", proxyFactory.getProxy());\n \t\tcontext.refresh();\n \t\tinputChannel.send(new GenericMessage<>(\"ABC\"));\n \t\tMessage<?> message = outputChannel.receive(1000);\n@@ -280,13 +279,12 @@ public void testMessageEndpointAnnotationInheritedFromInterfaceWithProxy() {\n \t@Test\n \tpublic void testTransformer() {\n \t\tTestApplicationContext context = TestUtils.createTestApplicationContext();\n+\t\tcontext.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tDirectChannel inputChannel = new DirectChannel();\n \t\tcontext.registerChannel(\"inputChannel\", inputChannel);\n \t\tQueueChannel outputChannel = new QueueChannel();\n \t\tcontext.registerChannel(\"outputChannel\", outputChannel);\n-\t\tMessagingAnnotationPostProcessor postProcessor = prepareMessagingAnnotationPostProcessor(context);\n-\t\tTransformerAnnotationTestBean testBean = new TransformerAnnotationTestBean();\n-\t\tpostProcessor.postProcessAfterInitialization(testBean, \"testBean\");\n+\t\tcontext.registerEndpoint(\"testBean\", new TransformerAnnotationTestBean());\n \t\tcontext.refresh();\n \t\tinputChannel.send(new GenericMessage<>(\"foo\"));\n \t\tMessage<?> reply = outputChannel.receive(0);\n@@ -300,16 +298,6 @@ public void testTransformer() {\n \t\tcontext.close();\n \t}\n \n-\tprivate static MessagingAnnotationPostProcessor prepareMessagingAnnotationPostProcessor(\n-\t\t\tConfigurableApplicationContext context) {\n-\n-\t\tMessagingAnnotationPostProcessor postProcessor = new MessagingAnnotationPostProcessor();\n-\t\tpostProcessor.postProcessBeanDefinitionRegistry((BeanDefinitionRegistry) context.getBeanFactory());\n-\t\tpostProcessor.postProcessBeanFactory(context.getBeanFactory());\n-\t\tpostProcessor.afterSingletonsInstantiated();\n-\t\treturn postProcessor;\n-\t}\n-\n \t@MessageEndpoint\n \tpublic static class OutboundOnlyTestBean {\n \n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/RouterAnnotationPostProcessorTests.java b/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/RouterAnnotationPostProcessorTests.java\nindex 9baae7bc94c..9fe68682c1d 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/RouterAnnotationPostProcessorTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/RouterAnnotationPostProcessorTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,7 +23,6 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n \n-import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n import org.springframework.integration.annotation.MessageEndpoint;\n import org.springframework.integration.annotation.Router;\n import org.springframework.integration.channel.DirectChannel;\n@@ -44,8 +43,6 @@ public class RouterAnnotationPostProcessorTests {\n \n \tprivate final TestApplicationContext context = TestUtils.createTestApplicationContext();\n \n-\tprivate final MessagingAnnotationPostProcessor postProcessor = new MessagingAnnotationPostProcessor();\n-\n \tprivate final DirectChannel inputChannel = new DirectChannel();\n \n \tprivate final QueueChannel outputChannel = new QueueChannel();\n@@ -59,14 +56,12 @@ public class RouterAnnotationPostProcessorTests {\n \n \t@BeforeEach\n \tpublic void init() {\n+\t\tthis.context.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tcontext.registerChannel(\"input\", inputChannel);\n \t\tcontext.registerChannel(\"output\", outputChannel);\n \t\tcontext.registerChannel(\"routingChannel\", routingChannel);\n \t\tcontext.registerChannel(\"integerChannel\", integerChannel);\n \t\tcontext.registerChannel(\"stringChannel\", stringChannel);\n-\t\tthis.postProcessor.postProcessBeanDefinitionRegistry((BeanDefinitionRegistry) this.context.getBeanFactory());\n-\t\tthis.postProcessor.postProcessBeanFactory(this.context.getBeanFactory());\n-\t\tthis.postProcessor.afterSingletonsInstantiated();\n \t}\n \n \t@AfterEach\n@@ -76,8 +71,7 @@ public void tearDown() {\n \n \t@Test\n \tpublic void testRouter() {\n-\t\tTestRouter testRouter = new TestRouter();\n-\t\tpostProcessor.postProcessAfterInitialization(testRouter, \"test\");\n+\t\tcontext.registerEndpoint(\"test\", new TestRouter());\n \t\tcontext.refresh();\n \t\tinputChannel.send(new GenericMessage<>(\"foo\"));\n \t\tMessage<?> replyMessage = outputChannel.receive(0);\n@@ -87,8 +81,7 @@ public void testRouter() {\n \n \t@Test\n \tpublic void testRouterWithListParam() {\n-\t\tTestRouter testRouter = new TestRouter();\n-\t\tpostProcessor.postProcessAfterInitialization(testRouter, \"test\");\n+\t\tcontext.registerEndpoint(\"test\", new TestRouter());\n \t\tcontext.refresh();\n \n \t\troutingChannel.send(new GenericMessage<>(Collections.singletonList(\"foo\")));\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/SplitterAnnotationPostProcessorTests.java b/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/SplitterAnnotationPostProcessorTests.java\nindex abe52ccb351..bcdd6a7ef8a 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/SplitterAnnotationPostProcessorTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/config/annotation/SplitterAnnotationPostProcessorTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,7 +20,6 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n \n-import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n import org.springframework.context.Lifecycle;\n import org.springframework.integration.annotation.MessageEndpoint;\n import org.springframework.integration.annotation.Splitter;\n@@ -50,6 +49,7 @@ public class SplitterAnnotationPostProcessorTests {\n \n \t@BeforeEach\n \tpublic void init() {\n+\t\tthis.context.registerBean(MessagingAnnotationPostProcessor.class);\n \t\tthis.context.registerChannel(\"input\", this.inputChannel);\n \t\tthis.context.registerChannel(\"output\", this.outputChannel);\n \t}\n@@ -61,12 +61,8 @@ public void tearDown() {\n \n \t@Test\n \tpublic void testSplitterAnnotation() {\n-\t\tMessagingAnnotationPostProcessor postProcessor = new MessagingAnnotationPostProcessor();\n-\t\tpostProcessor.postProcessBeanDefinitionRegistry((BeanDefinitionRegistry) this.context.getBeanFactory());\n-\t\tpostProcessor.postProcessBeanFactory(this.context.getBeanFactory());\n-\t\tpostProcessor.afterSingletonsInstantiated();\n \t\tTestSplitter splitter = new TestSplitter();\n-\t\tpostProcessor.postProcessAfterInitialization(splitter, \"testSplitter\");\n+\t\tcontext.registerEndpoint(\"testSplitter\", splitter);\n \t\tcontext.refresh();\n \t\tinputChannel.send(new GenericMessage<>(\"this.is.a.test\"));\n \t\tMessage<?> message1 = outputChannel.receive(500);\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8657",
    "pr_id": 8657,
    "issue_id": 8654,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Fix dependency registration for Messaging annotation parsers\n**Expected Behavior**\r\n\r\nI'm building an application which transfers/transforms messages between TCP and MQTT.\r\nI would like to monitor the connections, to be able to configure some alerts when connections stay down for a certain amount of time/consecutive negative checks.\r\n\r\n**Current Behavior**\r\n\r\nI implemented multiple @Scheduled methods with a fixed delay of x seconds to check both the status of Tcp and Mqtt connections. For Tcp I'm checking if there are open connections by calling `getOpenConnectionIds()` on either `AbstractClientConnectionFactory` or `AbstractServerConnectionFactory` which works fine and does the job.\r\n\r\nI'm trying to do something similar for checking the connection (NOT subscription) with the Mqtt-broker but without success. The most obvious way would be to call the `isConnected()` method on `IMqttAsyncClient` in either `Mqttv5PahoMessageDrivenChannelAdapter` or `Mqttv5PahoMessageHandler`, but since this client has private access, I'm not able to check the connection.\r\n\r\n**Context**\r\n\r\nIs there any way of achieving this with the existing codebase? If not, would it be possible to:\r\n\r\n- provide a getter which returns if the client is connected in both `Mqttv5PahoMessageDrivenChannelAdapter` and `Mqttv5PahoMessageHandler`\r\n```\r\n\tpublic boolean isConnected() {\r\n\t\treturn mqttClient.isConnected();\r\n\t}\r\n\r\n```\r\n- publish internal application events similar to the `TcpConnectionOpenEvent` once the Mqtt client is connected successfully to the broker?\r\n",
    "issue_word_count": 209,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/config/AbstractMethodAnnotationPostProcessor.java",
      "spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java"
    ],
    "base_commit": "ceb3daec8ef52e3160176a98c14178358068d0f0",
    "head_commit": "97c8a066d63598dfaa1cb8020848031ca85fdfde",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8657",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8657",
    "dockerfile": "",
    "pr_merged_at": "2023-06-26T18:59:56.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractMethodAnnotationPostProcessor.java b/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractMethodAnnotationPostProcessor.java\nindex bb075afb285..dd452ba1a4b 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractMethodAnnotationPostProcessor.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractMethodAnnotationPostProcessor.java\n@@ -270,6 +270,7 @@ else if (reactive != null) {\n \t\tString endpointBeanName =\n \t\t\t\tgenerateHandlerBeanName(beanName, mergedAnnotations)\n \t\t\t\t\t\t.replaceFirst(\"\\\\.(handler|source)$\", \"\");\n+\t\tthis.beanFactory.registerDependentBean(beanName, endpointBeanName);\n \t\tthis.definitionRegistry.registerBeanDefinition(endpointBeanName, endpointBeanDefinition);\n \t}\n \n",
    "test_patch": "diff --git a/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java b/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java\nindex d745fed94a0..8337699565b 100644\n--- a/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java\n+++ b/spring-integration-mqtt/src/test/java/org/springframework/integration/mqtt/ClientManagerBackToBackTests.java\n@@ -28,6 +28,7 @@\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.context.event.EventListener;\n+import org.springframework.integration.annotation.ServiceActivator;\n import org.springframework.integration.config.EnableIntegration;\n import org.springframework.integration.dsl.IntegrationFlow;\n import org.springframework.integration.mqtt.core.Mqttv3ClientManager;\n@@ -195,8 +196,9 @@ public Mqttv5ClientManager mqttv5ClientManager() {\n \t\t}\n \n \t\t@Bean\n-\t\tpublic IntegrationFlow mqttOutFlow(Mqttv5ClientManager mqttv5ClientManager) {\n-\t\t\treturn f -> f.handle(new Mqttv5PahoMessageHandler(mqttv5ClientManager));\n+\t\t@ServiceActivator(inputChannel = \"mqttOutFlow.input\")\n+\t\tpublic Mqttv5PahoMessageHandler mqttv5PahoMessageHandler(Mqttv5ClientManager mqttv5ClientManager) {\n+\t\t\treturn new Mqttv5PahoMessageHandler(mqttv5ClientManager);\n \t\t}\n \n \t\t@Bean\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8653",
    "pr_id": 8653,
    "issue_id": 8626,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Add DSL transform() variant overload for accepting a bean name \nAs discussed on thread for Issue #8625, there is a utility to have IntegrationFlows methods that accept a bean name, as is the case for \r\n\r\n```split(String beanName, @Nullable String methodName)``` \r\n\r\nThe ```transform()``` method does not have such a bean-name overload.  It can be useful to have this in order to avoid the boilerplate injection of the bean via construction or bean method.\r\n",
    "issue_word_count": 74,
    "test_files_count": 8,
    "non_test_files_count": 12,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/BaseIntegrationFlowDefinition.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowDefinition.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/TransformerEndpointSpec.java",
      "spring-integration-core/src/main/java/org/springframework/integration/transformer/MessageTransformingHandler.java",
      "spring-integration-core/src/main/java/org/springframework/integration/util/ClassUtils.java",
      "spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinIntegrationFlowDefinition.kt",
      "spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinTransformerEndpointSpec.kt",
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/flows/IntegrationFlowTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/manualflow/ManualFlowTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/reactivestreams/ReactiveStreamsTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/transformers/TransformerTests.java",
      "spring-integration-core/src/test/kotlin/org/springframework/integration/dsl/KotlinDslTests.kt",
      "spring-integration-file/src/test/java/org/springframework/integration/file/dsl/FileTests.java",
      "spring-integration-groovy/src/main/groovy/org/springframework/integration/groovy/dsl/GroovyIntegrationFlowDefinition.groovy",
      "spring-integration-groovy/src/test/groovy/org/springframework/integration/groovy/dsl/test/GroovyDslTests.groovy",
      "spring-integration-webflux/src/test/java/org/springframework/integration/webflux/observation/WebFluxObservationPropagationTests.java",
      "src/reference/asciidoc/dsl.adoc",
      "src/reference/asciidoc/groovy-dsl.adoc",
      "src/reference/asciidoc/kotlin-dsl.adoc",
      "src/reference/asciidoc/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/flows/IntegrationFlowTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/manualflow/ManualFlowTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/reactivestreams/ReactiveStreamsTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/transformers/TransformerTests.java",
      "spring-integration-core/src/test/kotlin/org/springframework/integration/dsl/KotlinDslTests.kt",
      "spring-integration-file/src/test/java/org/springframework/integration/file/dsl/FileTests.java",
      "spring-integration-groovy/src/test/groovy/org/springframework/integration/groovy/dsl/test/GroovyDslTests.groovy",
      "spring-integration-webflux/src/test/java/org/springframework/integration/webflux/observation/WebFluxObservationPropagationTests.java"
    ],
    "base_commit": "881893dbca90d5941ff8b6563eb1b37cb47d6a36",
    "head_commit": "aa219bf2e6ca28b964dc5df951152abbd6958608",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8653",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8653",
    "dockerfile": "",
    "pr_merged_at": "2023-06-26T16:01:13.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/BaseIntegrationFlowDefinition.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/BaseIntegrationFlowDefinition.java\nindex 86ffacafaa7..9447f575928 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/BaseIntegrationFlowDefinition.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/BaseIntegrationFlowDefinition.java\n@@ -538,12 +538,18 @@ public B controlBus(@Nullable Consumer<GenericEndpointSpec<ServiceActivatingHand\n \t/**\n \t * Populate the {@code Transformer} EI Pattern specific {@link MessageHandler} implementation\n \t * for the SpEL {@link Expression}.\n+\t * Shortcut for:\n+\t * <pre class=\"code\">\n+\t * {@code\n+\t *  .transformWith((transformerSpec) -> transformerSpec.expression(expression))\n+\t * }\n+\t * </pre>\n \t * @param expression the {@code Transformer} {@link Expression}.\n \t * @return the current {@link BaseIntegrationFlowDefinition}.\n \t * @see ExpressionEvaluatingTransformer\n \t */\n \tpublic B transform(String expression) {\n-\t\treturn transform(expression, (Consumer<GenericEndpointSpec<MessageTransformingHandler>>) null);\n+\t\treturn transformWith((transformerSpec) -> transformerSpec.expression(expression));\n \t}\n \n \t/**\n@@ -552,8 +558,10 @@ public B transform(String expression) {\n \t * @param expression the {@code Transformer} {@link Expression}.\n \t * @param endpointConfigurer the {@link Consumer} to provide integration endpoint options.\n \t * @return the current {@link BaseIntegrationFlowDefinition}.\n+\t * @deprecated since 6.2 in favor of {@link #transformWith(Consumer)}.\n \t * @see ExpressionEvaluatingTransformer\n \t */\n+\t@Deprecated(since = \"6.2\", forRemoval = true)\n \tpublic B transform(String expression,\n \t\t\t@Nullable Consumer<GenericEndpointSpec<MessageTransformingHandler>> endpointConfigurer) {\n \n@@ -566,9 +574,15 @@ public B transform(String expression,\n \t/**\n \t * Populate the {@code MessageTransformingHandler} for the {@link MethodInvokingTransformer}\n \t * to invoke the discovered service method at runtime.\n+\t * Shortcut for:\n+\t * <pre class=\"code\">\n+\t * {@code\n+\t *  .transformWith((transformerSpec) -> transformerSpec.ref(service))\n+\t * }\n+\t * </pre>\n \t * @param service the service to use.\n \t * @return the current {@link BaseIntegrationFlowDefinition}.\n-\t * @see ExpressionEvaluatingTransformer\n+\t * @see MethodInvokingTransformer\n \t */\n \tpublic B transform(Object service) {\n \t\treturn transform(service, null);\n@@ -577,13 +591,36 @@ public B transform(Object service) {\n \t/**\n \t * Populate the {@code MessageTransformingHandler} for the {@link MethodInvokingTransformer}\n \t * to invoke the service method at runtime.\n+\t * <pre class=\"code\">\n+\t * {@code\n+\t *  .transformWith((transformerSpec) -> transformerSpec.ref(service).method(methodName))\n+\t * }\n+\t * </pre>\n \t * @param service the service to use.\n \t * @param methodName the method to invoke.\n \t * @return the current {@link BaseIntegrationFlowDefinition}.\n \t * @see MethodInvokingTransformer\n \t */\n \tpublic B transform(Object service, @Nullable String methodName) {\n-\t\treturn transform(service, methodName, null);\n+\t\treturn transformWith((transformerSpec) -> transformerSpec.ref(service).method(methodName));\n+\t}\n+\n+\t/**\n+\t * Populate the {@code MessageTransformingHandler} for the {@link MethodInvokingTransformer}\n+\t * to invoke the bean method at runtime.\n+\t * <pre class=\"code\">\n+\t * {@code\n+\t *  .transformWith((transformerSpec) -> transformerSpec.refName(beanName).method(methodName))\n+\t * }\n+\t * </pre>\n+\t * @param beanName the name for bean to resolve lazily.\n+\t * @param methodName the method to invoke.\n+\t * @return the current {@link BaseIntegrationFlowDefinition}.\n+\t * @since 6.2\n+\t * @see MethodInvokingTransformer\n+\t */\n+\tpublic B transform(String beanName, @Nullable String methodName) {\n+\t\treturn transformWith((transformerSpec) -> transformerSpec.refName(beanName).method(methodName));\n \t}\n \n \t/**\n@@ -593,8 +630,10 @@ public B transform(Object service, @Nullable String methodName) {\n \t * @param methodName the method to invoke.\n \t * @param endpointConfigurer the {@link Consumer} to provide integration endpoint options.\n \t * @return the current {@link BaseIntegrationFlowDefinition}.\n-\t * @see ExpressionEvaluatingTransformer\n+\t * @deprecated since 6.2 in favor of {@link #transformWith(Consumer)}.\n+\t * @see MethodInvokingTransformer\n \t */\n+\t@Deprecated(since = \"6.2\", forRemoval = true)\n \tpublic B transform(Object service, @Nullable String methodName,\n \t\t\t@Nullable Consumer<GenericEndpointSpec<MessageTransformingHandler>> endpointConfigurer) {\n \n@@ -617,12 +656,18 @@ public B transform(Object service, @Nullable String methodName,\n \t *  .transform(Scripts.script(\"classpath:myScript.py\").variable(\"foo\", bar()))\n \t * }\n \t * </pre>\n+\t * Shortcut for:\n+\t * <pre class=\"code\">\n+\t * {@code\n+\t *  .transformWith((transformerSpec) -> transformerSpec.processor(messageProcessorSpec))\n+\t * }\n+\t * </pre>\n \t * @param messageProcessorSpec the {@link MessageProcessorSpec} to use.\n \t * @return the current {@link BaseIntegrationFlowDefinition}.\n \t * @see MethodInvokingTransformer\n \t */\n \tpublic B transform(MessageProcessorSpec<?> messageProcessorSpec) {\n-\t\treturn transform(messageProcessorSpec, (Consumer<GenericEndpointSpec<MessageTransformingHandler>>) null);\n+\t\treturn transformWith((transformerSpec) -> transformerSpec.processor(messageProcessorSpec));\n \t}\n \n \t/**\n@@ -638,8 +683,10 @@ public B transform(MessageProcessorSpec<?> messageProcessorSpec) {\n \t * @param messageProcessorSpec the {@link MessageProcessorSpec} to use.\n \t * @param endpointConfigurer the {@link Consumer} to provide integration endpoint options.\n \t * @return the current {@link BaseIntegrationFlowDefinition}.\n+\t * @deprecated since 6.2 in favor of {@link #transformWith(Consumer)}.\n \t * @see MethodInvokingTransformer\n \t */\n+\t@Deprecated(since = \"6.2\", forRemoval = true)\n \tpublic B transform(MessageProcessorSpec<?> messageProcessorSpec,\n \t\t\t@Nullable Consumer<GenericEndpointSpec<MessageTransformingHandler>> endpointConfigurer) {\n \n@@ -679,7 +726,8 @@ public <P> B convert(Class<P> payloadType) {\n \t * @see LambdaMessageProcessor\n \t */\n \tpublic <P, T> B transform(@Nullable Class<P> expectedType, GenericTransformer<P, T> genericTransformer) {\n-\t\treturn transform(expectedType, genericTransformer, null);\n+\t\treturn transformWith((transformerSpec) ->\n+\t\t\t\ttransformerSpec.transformer(genericTransformer).expectedType(expectedType));\n \t}\n \n \t/**\n@@ -714,10 +762,12 @@ public <P> B convert(Class<P> payloadType,\n \t * @param <P> the payload type - 'transform from', or {@code Message.class}.\n \t * @param <T> the target type - 'transform to'.\n \t * @return the current {@link BaseIntegrationFlowDefinition}.\n+\t * @deprecated since 6.2 in favor of {@link #transformWith(Consumer)}\n \t * @see MethodInvokingTransformer\n \t * @see LambdaMessageProcessor\n \t * @see GenericEndpointSpec\n \t */\n+\t@Deprecated(since = \"6.2\", forRemoval = true)\n \tpublic <P, T> B transform(@Nullable Class<P> expectedType, GenericTransformer<P, T> genericTransformer,\n \t\t\t@Nullable Consumer<GenericEndpointSpec<MessageTransformingHandler>> endpointConfigurer) {\n \n@@ -730,6 +780,16 @@ public <P, T> B transform(@Nullable Class<P> expectedType, GenericTransformer<P,\n \t\t\t\t.handle(new MessageTransformingHandler(transformer), endpointConfigurer);\n \t}\n \n+\t/**\n+\t * Populate a {@link MessageTransformingHandler} into the endpoint with provided {@link TransformerEndpointSpec} options.\n+\t * One of the 'expression', 'ref', 'refName', 'processor' or 'function' must be provided.\n+\t * @return the current {@link BaseIntegrationFlowDefinition}.\n+\t * @since 6.2\n+\t */\n+\tpublic B transformWith(Consumer<TransformerEndpointSpec> transformerConfigurer) {\n+\t\treturn register(new TransformerEndpointSpec(), transformerConfigurer);\n+\t}\n+\n \t/**\n \t * Populate a {@link MessageFilter} with {@link MessageSelector} for the provided SpEL expression.\n \t * @param expression the SpEL expression.\n@@ -2787,7 +2847,7 @@ protected <T> Publisher<Message<T>> toReactivePublisher(boolean autoStartOnSubsc\n \t}\n \n \tprotected <S extends ConsumerEndpointSpec<? super S, ? extends MessageHandler>> B register(S endpointSpec,\n-\t\t\t@Nullable Consumer<S> endpointConfigurer) {\n+\t\t\t@Nullable Consumer<? super S> endpointConfigurer) {\n \n \t\tif (endpointConfigurer != null) {\n \t\t\tendpointConfigurer.accept(endpointSpec);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowDefinition.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowDefinition.java\nindex de2ce2ca78b..8f3f6e3bfd5 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowDefinition.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowDefinition.java\n@@ -50,6 +50,12 @@ public abstract class IntegrationFlowDefinition<B extends IntegrationFlowDefinit\n \t * Populate the {@link MessageTransformingHandler} instance for the provided\n \t * {@link GenericTransformer}. Use {@link #transform(Class, GenericTransformer)} if\n \t * you need to access the entire message.\n+\t * Shortcut for:\n+\t * <pre class=\"code\">\n+\t * {@code\n+\t *  .transformWith((transformerSpec) -> transformerSpec.function(genericTransformer))\n+\t * }\n+\t * </pre>\n \t * @param genericTransformer the {@link GenericTransformer} to populate.\n \t * @param <S> the source type - 'transform from'.\n \t * @param <T> the target type - 'transform to'.\n@@ -58,7 +64,7 @@ public abstract class IntegrationFlowDefinition<B extends IntegrationFlowDefinit\n \t * @see org.springframework.integration.handler.LambdaMessageProcessor\n \t */\n \tpublic <S, T> B transform(GenericTransformer<S, T> genericTransformer) {\n-\t\treturn transform(null, genericTransformer);\n+\t\treturn transformWith((transformerSpec) -> transformerSpec.transformer(genericTransformer));\n \t}\n \n \n@@ -66,18 +72,21 @@ public <S, T> B transform(GenericTransformer<S, T> genericTransformer) {\n \t * Populate the {@link MessageTransformingHandler} instance for the provided\n \t * {@link GenericTransformer}. In addition, accept options for the integration endpoint\n \t * using {@link GenericEndpointSpec}. Use\n-\t * {@link #transform(Class, GenericTransformer, Consumer)} if you need to access the\n-\t * entire message.\n+\t * {@code .transform((transformerSpec) -> transformerSpec.function(genericTransformer).expectedType(Message.class))}\n+\t * if you need to access the entire message.\n \t * @param genericTransformer the {@link GenericTransformer} to populate.\n \t * @param endpointConfigurer the {@link Consumer} to provide integration endpoint\n \t * options.\n \t * @param <S> the source type - 'transform from'.\n \t * @param <T> the target type - 'transform to'.\n \t * @return the current {@link IntegrationFlowDefinition}.\n+\t * @deprecated since 6.2 in favor of {@link #transformWith(Consumer)}\n \t * @see org.springframework.integration.transformer.MethodInvokingTransformer\n \t * @see org.springframework.integration.handler.LambdaMessageProcessor\n \t * @see GenericEndpointSpec\n \t */\n+\t@Deprecated(since = \"6.2\", forRemoval = true)\n+\t@SuppressWarnings(\"removal\")\n \tpublic <S, T> B transform(GenericTransformer<S, T> genericTransformer,\n \t\t\tConsumer<GenericEndpointSpec<MessageTransformingHandler>> endpointConfigurer) {\n \n@@ -108,7 +117,7 @@ public <P> B filter(GenericSelector<P> genericSelector) {\n \t * Populate a {@link org.springframework.integration.filter.MessageFilter}\n \t * with {@link org.springframework.integration.filter.MethodInvokingSelector}\n \t * for the provided {@link GenericSelector}.\n-\t * In addition accept options for the integration endpoint using {@link FilterEndpointSpec}.\n+\t * In addition, accept options for the integration endpoint using {@link FilterEndpointSpec}.\n \t * Typically used with a Java 8 Lambda expression:\n \t * <pre class=\"code\">\n \t * {@code\n@@ -152,7 +161,7 @@ public <P> B handle(GenericHandler<P> handler) {\n \t * Populate a {@link ServiceActivatingHandler} for the\n \t * {@link org.springframework.integration.handler.MethodInvokingMessageProcessor}\n \t * to invoke the provided {@link GenericHandler} at runtime.\n-\t * In addition accept options for the integration endpoint using {@link GenericEndpointSpec}.\n+\t * In addition, accept options for the integration endpoint using {@link GenericEndpointSpec}.\n \t * Typically used with a Java 8 Lambda expression:\n \t * <pre class=\"code\">\n \t * {@code\n@@ -177,7 +186,7 @@ public <P> B handle(GenericHandler<P> handler,\n \t/**\n \t * Populate the {@link MethodInvokingSplitter} to evaluate the provided\n \t * {@link Function} at runtime.\n-\t * In addition accept options for the integration endpoint using {@link GenericEndpointSpec}.\n+\t * In addition, accept options for the integration endpoint using {@link GenericEndpointSpec}.\n \t * Typically used with a Java 8 Lambda expression:\n \t * <pre class=\"code\">\n \t * {@code\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/TransformerEndpointSpec.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/TransformerEndpointSpec.java\nnew file mode 100644\nindex 00000000000..8ccb8fc1d52\n--- /dev/null\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/TransformerEndpointSpec.java\n@@ -0,0 +1,227 @@\n+/*\n+ * Copyright 2023-2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.dsl;\n+\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.springframework.expression.Expression;\n+import org.springframework.integration.core.GenericTransformer;\n+import org.springframework.integration.handler.BeanNameMessageProcessor;\n+import org.springframework.integration.handler.LambdaMessageProcessor;\n+import org.springframework.integration.handler.MessageProcessor;\n+import org.springframework.integration.transformer.ExpressionEvaluatingTransformer;\n+import org.springframework.integration.transformer.MessageTransformingHandler;\n+import org.springframework.integration.transformer.MethodInvokingTransformer;\n+import org.springframework.integration.transformer.Transformer;\n+import org.springframework.integration.util.ClassUtils;\n+import org.springframework.lang.Nullable;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * A {@link ConsumerEndpointSpec} for a {@link MessageTransformingHandler} options.\n+ * One of the {@link #expression(String)}, {@link #ref(Object)}, {@link #refName(String)},\n+ * {@link #processor(MessageProcessorSpec)} or {@link #transformer(GenericTransformer)} must be provided.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 6.2\n+ */\n+public class TransformerEndpointSpec extends ConsumerEndpointSpec<TransformerEndpointSpec, MessageTransformingHandler> {\n+\n+\tprivate final AtomicBoolean transformerSet = new AtomicBoolean();\n+\n+\tprivate Expression expression;\n+\n+\tprivate Object ref;\n+\n+\tprivate String refName;\n+\n+\t@Nullable\n+\tprivate String method;\n+\n+\tprivate GenericTransformer<?, ?> transformer;\n+\n+\t@Nullable\n+\tprivate Class<?> expectedType;\n+\n+\tprivate MessageProcessorSpec<?> processor;\n+\n+\tprotected TransformerEndpointSpec() {\n+\t\tsuper(new MessageTransformingHandler());\n+\t}\n+\n+\t/**\n+\t * Provide an expression to use an {@link ExpressionEvaluatingTransformer} for the target handler.\n+\t * @param expression the SpEL expression to use.\n+\t * @return the TransformerSpec\n+\t */\n+\tpublic TransformerEndpointSpec expression(String expression) {\n+\t\treturn expression(PARSER.parseExpression(expression));\n+\t}\n+\n+\t/**\n+\t * Provide an expression to use an {@link ExpressionEvaluatingTransformer} for the target handler.\n+\t * @param expression the SpEL expression to use.\n+\t * @return the TransformerSpec\n+\t */\n+\tpublic TransformerEndpointSpec expression(Expression expression) {\n+\t\tassertTransformerSet();\n+\t\tthis.expression = expression;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Provide a service to use a {@link MethodInvokingTransformer} for the target handler.\n+\t * @param ref the service to call as a transformer POJO.\n+\t * @return the TransformerSpec\n+\t */\n+\tpublic TransformerEndpointSpec ref(Object ref) {\n+\t\tassertTransformerSet();\n+\t\tthis.ref = ref;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Provide a bean name to use a {@link MethodInvokingTransformer}\n+\t * (based on {@link BeanNameMessageProcessor}) for the target handler.\n+\t * @param refName the bean name for service to call as a transformer POJO.\n+\t * @return the TransformerSpec\n+\t */\n+\tpublic TransformerEndpointSpec refName(String refName) {\n+\t\tassertTransformerSet();\n+\t\tthis.refName = refName;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Provide a service method name to call. Optional.\n+\t * Use only together with {@link #ref(Object)} or {@link #refName(String)}.\n+\t * @param method the service method name to call.\n+\t * @return the TransformerSpec\n+\t */\n+\tpublic TransformerEndpointSpec method(@Nullable String method) {\n+\t\tthis.method = method;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Provide a {@link GenericTransformer} as a direct delegate for {@link MessageTransformingHandler}.\n+\t * @param transformer the {@link GenericTransformer} instance to use.\n+\t * @param <P> the input type.\n+\t * @param <T> the output type.\n+\t * @return the TransformerSpec\n+\t */\n+\tpublic <P, T> TransformerEndpointSpec transformer(GenericTransformer<P, T> transformer) {\n+\t\tassertTransformerSet();\n+\t\tthis.transformer = transformer;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Set a {@link GenericTransformer} input argument type.\n+\t * Can be a {@link org.springframework.messaging.Message}.\n+\t * Ignored for all other transformers, but {@link #transformer(GenericTransformer)}.\n+\t * @param expectedType the {@link GenericTransformer} input argument type.\n+\t * @param <P> the type ot expect.\n+\t * @return the spec.\n+\t */\n+\tpublic <P> TransformerEndpointSpec expectedType(@Nullable Class<P> expectedType) {\n+\t\tthis.expectedType = expectedType;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * Provide a {@link MessageProcessorSpec} as a factory for {@link MethodInvokingTransformer} delegate.\n+\t * @param processor the {@link MessageProcessorSpec} to use.\n+\t * @return the TransformerSpec\n+\t */\n+\tpublic TransformerEndpointSpec processor(MessageProcessorSpec<?> processor) {\n+\t\tassertTransformerSet();\n+\t\tthis.processor = processor;\n+\t\treturn this;\n+\t}\n+\n+\tprivate void assertTransformerSet() {\n+\t\tAssert.isTrue(this.transformerSet.compareAndSet(false, true), this::assertMessage);\n+\t}\n+\n+\tprivate String assertMessage() {\n+\t\tString currentTransformerValue = null;\n+\t\tif (this.expression != null) {\n+\t\t\tcurrentTransformerValue = \"'expression'=\" + this.expression;\n+\t\t}\n+\t\telse if (this.ref != null) {\n+\t\t\tcurrentTransformerValue = \"'ref'=\" + this.ref;\n+\t\t}\n+\t\telse if (this.refName != null) {\n+\t\t\tcurrentTransformerValue = \"'refName'=\" + this.refName;\n+\t\t}\n+\t\telse if (this.transformer != null) {\n+\t\t\tcurrentTransformerValue = \"'transformer'=\" + this.transformer;\n+\t\t}\n+\t\telse if (this.processor != null) {\n+\t\t\tcurrentTransformerValue = \"'processor'=\" + this.processor;\n+\t\t}\n+\t\treturn \"Only one of the 'expression', 'ref', 'refName', 'processor' or 'transformer' can be set. \" +\n+\t\t\t\t\"Current one is \" + currentTransformerValue;\n+\t}\n+\n+\t@Override\n+\tpublic Map<Object, String> getComponentsToRegister() {\n+\t\tTransformer transformer;\n+\t\tif (this.expression != null) {\n+\t\t\ttransformer = new ExpressionEvaluatingTransformer(this.expression);\n+\t\t}\n+\t\telse if (this.ref != null) {\n+\t\t\tif (this.method != null) {\n+\t\t\t\ttransformer = new MethodInvokingTransformer(this.ref, this.method);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\ttransformer = new MethodInvokingTransformer(this.ref);\n+\t\t\t}\n+\t\t}\n+\t\telse if (this.refName != null) {\n+\t\t\ttransformer = new MethodInvokingTransformer(new BeanNameMessageProcessor<>(this.refName, this.method));\n+\t\t}\n+\t\telse if (this.processor != null) {\n+\t\t\tMessageProcessor<?> targetProcessor = this.processor.getObject();\n+\t\t\tthis.componentsToRegister.put(targetProcessor, null);\n+\t\t\ttransformer = new MethodInvokingTransformer(targetProcessor);\n+\t\t}\n+\t\telse if (this.transformer != null) {\n+\t\t\ttransformer = wrapToTransformerIfAny();\n+\t\t}\n+\t\telse {\n+\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\"One of the 'expression', 'ref', 'refName', 'processor' or 'transformer' must be provided.\");\n+\t\t}\n+\n+\t\tthis.handler.setTransformer(transformer);\n+\n+\t\tthis.componentsToRegister.put(transformer, null);\n+\t\treturn super.getComponentsToRegister();\n+\t}\n+\n+\tprivate Transformer wrapToTransformerIfAny() {\n+\t\treturn this.transformer instanceof Transformer ? (Transformer) this.transformer :\n+\t\t\t\t(ClassUtils.isLambda(this.transformer)\n+\t\t\t\t\t\t? new MethodInvokingTransformer(new LambdaMessageProcessor(this.transformer, this.expectedType))\n+\t\t\t\t\t\t: new MethodInvokingTransformer(this.transformer, ClassUtils.TRANSFORMER_TRANSFORM_METHOD));\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/transformer/MessageTransformingHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/transformer/MessageTransformingHandler.java\nindex 4948e8230be..96987516b97 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/transformer/MessageTransformingHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/transformer/MessageTransformingHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2020 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -41,7 +41,16 @@\n  */\n public class MessageTransformingHandler extends AbstractReplyProducingMessageHandler implements ManageableLifecycle {\n \n-\tprivate final Transformer transformer;\n+\tprivate Transformer transformer;\n+\n+\t/**\n+\t * Create a {@link MessageTransformingHandler} instance.\n+\t * The target delegate {@link Transformer} must be provided then via setter.\n+\t * @since 6.2\n+\t */\n+\tpublic MessageTransformingHandler() {\n+\t\tsetRequiresReply(true);\n+\t}\n \n \t/**\n \t * Create a {@link MessageTransformingHandler} instance that delegates to\n@@ -49,11 +58,20 @@ public class MessageTransformingHandler extends AbstractReplyProducingMessageHan\n \t * @param transformer The transformer.\n \t */\n \tpublic MessageTransformingHandler(Transformer transformer) {\n+\t\tthis();\n \t\tAssert.notNull(transformer, \"transformer must not be null\");\n \t\tthis.transformer = transformer;\n-\t\tthis.setRequiresReply(true);\n \t}\n \n+\t/**\n+\t * Provide a {@link Transformer} delegate.\n+\t * @param transformer the {@link Transformer} to use.\n+\t * @since 6.2\n+\t */\n+\tpublic void setTransformer(Transformer transformer) {\n+\t\tAssert.notNull(transformer, \"transformer must not be null\");\n+\t\tthis.transformer = transformer;\n+\t}\n \n \t@Override\n \tpublic String getComponentType() {\n@@ -77,6 +95,7 @@ public void addNotPropagatedHeaders(String... headers) {\n \n \t@Override\n \tprotected void doInit() {\n+\t\tAssert.notNull(this.transformer, \"transformer must not be null\");\n \t\tBeanFactory beanFactory = getBeanFactory();\n \t\tif (beanFactory != null && this.transformer instanceof BeanFactoryAware) {\n \t\t\t((BeanFactoryAware) this.transformer).setBeanFactory(beanFactory);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/util/ClassUtils.java b/spring-integration-core/src/main/java/org/springframework/integration/util/ClassUtils.java\nindex c42bf1f904a..947c565fd82 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/util/ClassUtils.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/util/ClassUtils.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,6 +17,7 @@\n package org.springframework.integration.util;\n \n import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Set;\n@@ -223,6 +224,19 @@ public static Class<?> resolvePrimitiveType(Class<?> clazz) {\n \t\treturn PRIMITIVE_WRAPPER_TYPE_MAP.get(clazz);\n \t}\n \n+\t/**\n+\t * Check if object is Java, Kotlin or Groovy lambda.\n+\t * @param candidate the {@link Object} to check.\n+\t * @return true if object is a Java, Kotlin or Groovy lambda.\n+\t * @since 6.2\n+\t */\n+\tpublic static boolean isLambda(Object candidate) {\n+\t\tClass<?> aClass = candidate.getClass();\n+\t\treturn isLambda(aClass) ||\n+\t\t\t\t(Proxy.isProxyClass(aClass)  // Groovy Closure is a Lambda in Java terms\n+\t\t\t\t\t\t&& Proxy.getInvocationHandler(candidate).getClass().getSimpleName().equals(\"ConvertedClosure\"));\n+\t}\n+\n \t/**\n \t * Check if class is Java or Kotlin lambda.\n \t * @param aClass the {@link Class} to check.\n\ndiff --git a/spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinIntegrationFlowDefinition.kt b/spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinIntegrationFlowDefinition.kt\nindex 1dab770f789..4d81bac3216 100644\n--- a/spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinIntegrationFlowDefinition.kt\n+++ b/spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinIntegrationFlowDefinition.kt\n@@ -92,9 +92,16 @@ class KotlinIntegrationFlowDefinition(@PublishedApi internal val delegate: Integ\n \t}\n \n \t/**\n-\t * Inline function for [IntegrationFlowDefinition.transform] providing a `transform<MyTypeIn, MyTypeOut>()` variant\n+\t * Inline function for [IntegrationFlowDefinition.transform] providing a `transform<MyTypeIn>()` variant\n \t * with reified generic type.\n \t */\n+\t@Deprecated(\"since 6.2\",\n+\t\t\tReplaceWith(\"\"\"\n+\t\t\t\ttransformWith { \n+\t\t\t\t\ttransformer<Type> { }\n+\t\t\t\t\tid(\"value\")\n+\t\t\t\t}\"\"\"))\n+\t@Suppress(\"DEPRECATION\", \"REMOVAL\")\n \tinline fun <reified P> transform(\n \t\tcrossinline function: (P) -> Any,\n \t\tcrossinline configurer: GenericEndpointSpec<MessageTransformingHandler>.() -> Unit\n@@ -103,6 +110,16 @@ class KotlinIntegrationFlowDefinition(@PublishedApi internal val delegate: Integ\n \t\tthis.delegate.transform(P::class.java, { function(it) }) { configurer(it) }\n \t}\n \n+\t/**\n+\t * Inline function for [IntegrationFlowDefinition.transformWith]\n+\t * providing a `transform<MyTypeIn>()` variant\n+\t * with reified generic type.\n+\t * @since 6.2\n+\t */\n+\tfun transformWith(configurer: KotlinTransformerEndpointSpec.() -> Unit) {\n+\t\tthis.delegate.register(KotlinTransformerEndpointSpec(), configurer)\n+\t}\n+\n \t/**\n \t * Inline function for [IntegrationFlowDefinition.split] providing a `split<MyTypeIn>()` variant\n \t * with reified generic type.\n@@ -305,6 +322,13 @@ class KotlinIntegrationFlowDefinition(@PublishedApi internal val delegate: Integ\n \t * for the provided `Transformer` instance.\n \t * @since 5.3.1\n \t */\n+\t@Deprecated(\"since 6.2\",\n+\t\t\tReplaceWith(\"\"\"\n+\t\t\t\ttransformWith { \n+\t\t\t\t\ttransformer(transformer)\n+\t\t\t\t\tid(\"value\")\n+\t\t\t\t}\"\"\"))\n+\t@Suppress(\"DEPRECATION\", \"REMOVAL\")\n \tfun transform(\n \t\ttransformer: Transformer,\n \t\tendpointConfigurer: GenericEndpointSpec<MessageTransformingHandler>.() -> Unit = {}\n@@ -313,10 +337,26 @@ class KotlinIntegrationFlowDefinition(@PublishedApi internal val delegate: Integ\n \t\tthis.delegate.transform(transformer) { endpointConfigurer(it) }\n \t}\n \n+\t/**\n+\t * Populate the [Transformer] EI Pattern specific [MessageHandler] implementation\n+\t * for the provided [Transformer] instance.\n+\t * @since 6.2\n+\t */\n+\tfun transform(transformer: Transformer) {\n+\t\tthis.delegate.transform(transformer)\n+\t}\n+\n \t/**\n \t * Populate the [Transformer] EI Pattern specific [MessageHandler] implementation\n \t * for the SpEL [Expression].\n \t */\n+\t@Deprecated(\"since 6.2\",\n+\t\t\tReplaceWith(\"\"\"\n+\t\t\t\ttransformWith { \n+\t\t\t\t\texpression(\"value\")\n+\t\t\t\t\tid(\"value\")\n+\t\t\t\t}\"\"\"))\n+\t@Suppress(\"DEPRECATION\", \"REMOVAL\")\n \tfun transform(\n \t\texpression: String,\n \t\tendpointConfigurer: GenericEndpointSpec<MessageTransformingHandler>.() -> Unit = {}\n@@ -325,6 +365,16 @@ class KotlinIntegrationFlowDefinition(@PublishedApi internal val delegate: Integ\n \t\tthis.delegate.transform(expression, endpointConfigurer)\n \t}\n \n+\n+\t/**\n+\t * Populate the [Transformer] EI Pattern specific [MessageHandler] implementation\n+\t * for the SpEL [Expression].\n+\t * @since 6.2\n+\t */\n+\tfun transform(expression: String) {\n+\t\tthis.delegate.transform(expression)\n+\t}\n+\n \t/**\n \t * Populate the [MessageTransformingHandler] for the [MethodInvokingTransformer]\n \t * to invoke the service method at runtime.\n@@ -337,6 +387,14 @@ class KotlinIntegrationFlowDefinition(@PublishedApi internal val delegate: Integ\n \t * Populate the [MessageTransformingHandler] for the [MethodInvokingTransformer]\n \t * to invoke the service method at runtime.\n \t */\n+\t@Deprecated(\"since 6.2\",\n+\t\t\tReplaceWith(\"\"\"\n+\t\t\t\ttransformWith { \n+\t\t\t\t\tref(\"value\")\n+\t\t\t\t\tmethod(\"value\")\n+\t\t\t\t\tid(\"value\")\n+\t\t\t\t}\"\"\"))\n+\t@Suppress(\"DEPRECATION\", \"REMOVAL\")\n \tfun transform(\n \t\tservice: Any, methodName: String?,\n \t\tendpointConfigurer: GenericEndpointSpec<MessageTransformingHandler>.() -> Unit\n@@ -350,6 +408,13 @@ class KotlinIntegrationFlowDefinition(@PublishedApi internal val delegate: Integ\n \t * [org.springframework.integration.handler.MessageProcessor] from provided [MessageProcessorSpec].\n \t * In addition, accept options for the integration endpoint using [GenericEndpointSpec].\n \t */\n+\t@Deprecated(\"since 6.2\",\n+\t\t\tReplaceWith(\"\"\"\n+\t\t\t\ttransformWith { \n+\t\t\t\t\tprocessor(\"value\")\n+\t\t\t\t\tid(\"value\")\n+\t\t\t\t}\"\"\"))\n+\t@Suppress(\"DEPRECATION\", \"REMOVAL\")\n \tfun transform(\n \t\tmessageProcessorSpec: MessageProcessorSpec<*>,\n \t\tendpointConfigurer: GenericEndpointSpec<MessageTransformingHandler>.() -> Unit = {}\n@@ -358,6 +423,15 @@ class KotlinIntegrationFlowDefinition(@PublishedApi internal val delegate: Integ\n \t\tthis.delegate.transform(messageProcessorSpec, endpointConfigurer)\n \t}\n \n+\t/**\n+\t * Populate the [MessageTransformingHandler] instance for the\n+\t * [org.springframework.integration.handler.MessageProcessor] from provided [MessageProcessorSpec].\n+\t * @since 6.2\n+\t */\n+\tfun transform(messageProcessorSpec: MessageProcessorSpec<*>) {\n+\t\tthis.delegate.transform(messageProcessorSpec)\n+\t}\n+\n \t/**\n \t * Populate a [MessageFilter] with [MessageSelector] for the provided SpEL expression.\n \t * In addition, accept options for the integration endpoint using [KotlinFilterEndpointSpec]:\n@@ -566,7 +640,7 @@ class KotlinIntegrationFlowDefinition(@PublishedApi internal val delegate: Integ\n \t\t\t\tdelay { \n \t\t\t\t\tmessageGroupId(groupId) \n \t\t\t\t}\"\"\"))\n-\t@Suppress(\"DEPRECATION\")\n+\t@Suppress(\"DEPRECATION\", \"REMOVAL\")\n \tfun delay(groupId: String, endpointConfigurer: DelayerEndpointSpec.() -> Unit = {}) {\n \t\tthis.delegate.delay(groupId, endpointConfigurer)\n \t}\n\ndiff --git a/spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinTransformerEndpointSpec.kt b/spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinTransformerEndpointSpec.kt\nnew file mode 100644\nindex 00000000000..c997a59020e\n--- /dev/null\n+++ b/spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinTransformerEndpointSpec.kt\n@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.dsl\n+\n+import org.springframework.integration.transformer.MessageTransformingHandler\n+\n+/**\n+ * A [TransformerEndpointSpec] wrapped for Kotlin DSL.\n+ *\n+ * @property delegate the [TransformerEndpointSpec] this instance is delegating to.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 6.2\n+ */\n+class KotlinTransformerEndpointSpec : TransformerEndpointSpec() {\n+\n+\t/**\n+\t * Provide a Kotlin function as a direct delegate for [MessageTransformingHandler].\n+\t * @param function the function instance to use.\n+\t * @param <P> the input type.\n+\t */\n+\tinline fun <reified P> transformer(crossinline function: (P) -> Any) {\n+\t\texpectedType(P::class.java)\n+\t\ttransformer<P, Any> { function(it) }\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-groovy/src/main/groovy/org/springframework/integration/groovy/dsl/GroovyIntegrationFlowDefinition.groovy b/spring-integration-groovy/src/main/groovy/org/springframework/integration/groovy/dsl/GroovyIntegrationFlowDefinition.groovy\nindex a6c0a48ed89..401f13f0951 100644\n--- a/spring-integration-groovy/src/main/groovy/org/springframework/integration/groovy/dsl/GroovyIntegrationFlowDefinition.groovy\n+++ b/spring-integration-groovy/src/main/groovy/org/springframework/integration/groovy/dsl/GroovyIntegrationFlowDefinition.groovy\n@@ -47,6 +47,7 @@ import org.springframework.integration.dsl.ResequencerSpec\n import org.springframework.integration.dsl.RouterSpec\n import org.springframework.integration.dsl.ScatterGatherSpec\n import org.springframework.integration.dsl.SplitterEndpointSpec\n+import org.springframework.integration.dsl.TransformerEndpointSpec\n import org.springframework.integration.dsl.WireTapSpec\n import org.springframework.integration.filter.MethodInvokingSelector\n import org.springframework.integration.handler.BridgeHandler\n@@ -289,8 +290,10 @@ class GroovyIntegrationFlowDefinition {\n \t * for the SpEL {@link org.springframework.expression.Expression}.\n \t * @param expression the {@code Transformer} {@link org.springframework.expression.Expression}.\n \t * @param endpointConfigurer the {@link Consumer} to provide integration endpoint options.\n+\t * @param endpointConfigurer the {@link Consumer} to provide integration endpoint options.\n \t * @see org.springframework.integration.transformer.ExpressionEvaluatingTransformer\n \t */\n+\t@Deprecated(since = '6.2', forRemoval = true)\n \tGroovyIntegrationFlowDefinition transform(\n \t\t\tString expression,\n \t\t\t@DelegatesTo(value = GenericEndpointSpec<MessageTransformingHandler>, strategy = Closure.DELEGATE_FIRST)\n@@ -308,8 +311,10 @@ class GroovyIntegrationFlowDefinition {\n \t * @param service the service to use.\n \t * @param methodName the method to invoke.\n \t * @param endpointConfigurer the {@link Consumer} to provide integration endpoint options.\n+\t * @deprecated since 6.2 in favor of {@link #transform(Closure)}\n \t * @see ExpressionEvaluatingTransformer\n \t */\n+\t@Deprecated(since = '6.2', forRemoval = true)\n \tGroovyIntegrationFlowDefinition transform(\n \t\t\tObject service, String methodName = null,\n \t\t\t@DelegatesTo(value = GenericEndpointSpec<MessageTransformingHandler>, strategy = Closure.DELEGATE_FIRST)\n@@ -326,8 +331,10 @@ class GroovyIntegrationFlowDefinition {\n \t * In addition accept options for the integration endpoint using {@link GenericEndpointSpec}.\n \t * @param messageProcessorSpec the {@link MessageProcessorSpec} to use.\n \t * @param endpointConfigurer the {@link Consumer} to provide integration endpoint options.\n+\t * @deprecated since 6.2 in favor of {@link #transform(Closure)}\n \t * @see MethodInvokingTransformer\n \t */\n+\t@Deprecated(since = '6.2', forRemoval = true)\n \tGroovyIntegrationFlowDefinition transform(\n \t\t\tMessageProcessorSpec<?> messageProcessorSpec,\n \t\t\t@DelegatesTo(value = GenericEndpointSpec<MessageTransformingHandler>, strategy = Closure.DELEGATE_FIRST)\n@@ -338,6 +345,24 @@ class GroovyIntegrationFlowDefinition {\n \t\tthis\n \t}\n \n+\t/**\n+\t * Populate the {@link MessageTransformingHandler} instance for the\n+\t * {@link org.springframework.integration.handler.MessageProcessor} from provided {@link MessageProcessorSpec}.\n+\t * In addition accept options for the integration endpoint using {@link GenericEndpointSpec}.\n+\t * @param messageProcessorSpec the {@link MessageProcessorSpec} to use.\n+\t * @param transformerConfigurer the {@link Consumer} to provide integration endpoint options.\n+\t * @see MethodInvokingTransformer\n+\t * @since 6.2\n+\t */\n+\tGroovyIntegrationFlowDefinition transform(\n+\t\t\t@DelegatesTo(value = TransformerEndpointSpec, strategy = Closure.DELEGATE_FIRST)\n+\t\t\t@ClosureParams(value = SimpleType.class, options = 'org.springframework.integration.dsl.TransformerEndpointSpec')\n+\t\t\t\t\tClosure<?> transformerConfigurer) {\n+\n+\t\tthis.delegate.transformWith createConfigurerIfAny(transformerConfigurer)\n+\t\tthis\n+\t}\n+\n \t/**\n \t * Populate the {@link MessageTransformingHandler} instance\n \t * for the provided {@code payloadType} to convert at runtime.\n@@ -367,7 +392,9 @@ class GroovyIntegrationFlowDefinition {\n \t * @param endpointConfigurer the {@link Consumer} to provide integration endpoint options.\n \t * @param < P >                                                  the payload type - 'transform from', or {@code Message.class}.\n \t * @param < T >                                                  the target type - 'transform to'.\n+\t * @deprecated since 6.2 in favor of {@link #transform(Closure)}\n \t */\n+\t@Deprecated(since = '6.2', forRemoval = true)\n \t<P, T> GroovyIntegrationFlowDefinition transform(\n \t\t\tGenericTransformer<P, T> genericTransformer,\n \t\t\t@DelegatesTo(value = GenericEndpointSpec<MessageTransformingHandler>, strategy = Closure.DELEGATE_FIRST)\n@@ -389,7 +416,9 @@ class GroovyIntegrationFlowDefinition {\n \t * @param endpointConfigurer the {@link Consumer} to provide integration endpoint options.\n \t * @param < P >                                                  the payload type - 'transform from', or {@code Message.class}.\n \t * @param < T >                                                  the target type - 'transform to'.\n+\t * @deprecated since 6.2 in favor of {@link #transform(Closure)}\n \t */\n+\t@Deprecated(since = '6.2', forRemoval = true)\n \t<P, T> GroovyIntegrationFlowDefinition transform(\n \t\t\tClass<P> expectedType,\n \t\t\tGenericTransformer<P, T> genericTransformer,\n@@ -1336,7 +1365,7 @@ class GroovyIntegrationFlowDefinition {\n \t\t\treturn {\n \t\t\t\tclosure.delegate = it\n \t\t\t\tclosure.resolveStrategy = Closure.DELEGATE_FIRST\n-\t\t\t\tclosure()\n+\t\t\t\tclosure(it)\n \t\t\t} as Consumer<T>\n \t\t}\n \t\tnull\n\ndiff --git a/src/reference/asciidoc/dsl.adoc b/src/reference/asciidoc/dsl.adoc\nindex afa066b53a0..7afc3ffc48f 100644\n--- a/src/reference/asciidoc/dsl.adoc\n+++ b/src/reference/asciidoc/dsl.adoc\n@@ -283,8 +283,10 @@ The following example demonstrates how to change the publishing thread from the\n public IntegrationFlow reactiveEndpointFlow() {\n     return IntegrationFlow\n             .from(\"inputChannel\")\n-            .<String, Integer>transform(Integer::parseInt,\n-                    e -> e.reactive(flux -> flux.publishOn(Schedulers.parallel())))\n+            .transformWith(t -> t\n+                              .<String, Integer>transformer(Integer::parseInt)\n+                              .reactive(flux -> flux.publishOn(Schedulers.parallel()))\n+            )\n             .get();\n }\n ----\n@@ -304,9 +306,13 @@ Each of them has generic arguments, so it lets you configure an endpoint and eve\n @Bean\n public IntegrationFlow flow2() {\n     return IntegrationFlow.from(this.inputChannel)\n-                .transform(new PayloadSerializingTransformer(),\n-                       c -> c.autoStartup(false).id(\"payloadSerializingTransformer\"))\n-                .transform((Integer p) -> p * 2, c -> c.advice(this.expressionAdvice()))\n+                .transformWith(t -> t\n+                              .transformer(new PayloadSerializingTransformer())\n+                              .autoStartup(false)\n+                              .id(\"payloadSerializingTransformer\"))\n+                .transformWith(t -> t\n+                              .transformer((Integer p) -> p * 2)\n+                              .advice(expressionAdvice()))\n                 .get();\n }\n ----\n@@ -361,6 +367,10 @@ Nevertheless, the DSL parser takes care of bean declarations for inline objects,\n \n See https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/Transformers.html[Transformers] in the Javadoc for more information and supported factory methods.\n \n+Starting with version 6.2, a `transformWith(Consumer<TransformerEndpointSpec>)` variant has been introduced to have all the transformer and its endpoint options to be configured via single builder argument.\n+This style gives DSL more readability and increases developer experience while modifying code.\n+This also make Groovy and Kotlin DSLs more straightforward.\n+\n Also see <<java-dsl-class-cast>>.\n \n [[java-dsl-inbound-adapters]]\n@@ -1428,4 +1438,4 @@ IntegrationFlow otherFlow() {\n \n The composition in the middle of the flow is simply achievable with an existing `gateway(IntegrationFlow)` EIP-method.\n This way we can build flows with any complexity by composing them from simpler, reusable logical blocks.\n-For example, you may add a library of `IntegrationFlow` beans as a dependency and it is just enough to have their configuration classes imported to the final project and autowired for your `IntegrationFlow` definitions.\n+For example, you may add a library of `IntegrationFlow` beans as a dependency, and it is just enough to have their configuration classes imported to the final project and autowired for your `IntegrationFlow` definitions.\n\ndiff --git a/src/reference/asciidoc/groovy-dsl.adoc b/src/reference/asciidoc/groovy-dsl.adoc\nindex c9a9b57d28e..cc3ba66af4e 100644\n--- a/src/reference/asciidoc/groovy-dsl.adoc\n+++ b/src/reference/asciidoc/groovy-dsl.adoc\n@@ -39,7 +39,10 @@ flowLambda() {\n \t\t    messageGroupId 'delayGroup'\n \t\t    defaultDelay 100\n         }\n-        transform String, { it.toUpperCase() }\n+        transform {\n+\t\t    transformer { it.toUpperCase() }\n+            expectedType String\n+        }\n     }\n }\n ----\n@@ -78,8 +81,14 @@ functionFlow() {\n     integrationFlow Function<byte[], String>,\n             { beanName 'functionGateway' },\n             {\n-                transform Transformers.objectToString(), { id 'objectToStringTransformer' }\n-                transform String, { it.toUpperCase() }\n+                transform {\n+\t\t            transformer Transformers.objectToString()\n+                    id 'objectToStringTransformer'\n+                }\n+                transform {\n+\t\t            transformer { it.toUpperCase() }\n+                    expectedType String\n+                }\n                 split Message<?>, { it.payload }\n                 split Object, { it }, { id 'splitterEndpoint' }\n                 resequence()\n\ndiff --git a/src/reference/asciidoc/kotlin-dsl.adoc b/src/reference/asciidoc/kotlin-dsl.adoc\nindex f08881dbb53..e78fd690844 100644\n--- a/src/reference/asciidoc/kotlin-dsl.adoc\n+++ b/src/reference/asciidoc/kotlin-dsl.adoc\n@@ -32,7 +32,7 @@ fun flowLambda() =\n         wireTap {\n                     handle { println(it.payload) }\n                 }\n-        transform<String, String> { it.toUpperCase() }\n+        transform<String> { it.toUpperCase() }\n     }\n ----\n ====\n@@ -67,7 +67,7 @@ For example:\n @Bean\n fun functionFlow() =\n         integrationFlow<Function<String, String>>({ beanName(\"functionGateway\") }) {\n-            transform<String, String> { it.toUpperCase() }\n+            transform<String> { it.toUpperCase() }\n         }\n \n @Bean\n\ndiff --git a/src/reference/asciidoc/whats-new.adoc b/src/reference/asciidoc/whats-new.adoc\nindex 84149fd0903..17c6dbb83c4 100644\n--- a/src/reference/asciidoc/whats-new.adoc\n+++ b/src/reference/asciidoc/whats-new.adoc\n@@ -28,3 +28,6 @@ See <<./debezium.adoc#debezium, Debezium Support>>  for more information.\n \n - The XML configuration for `<poller>` and `@Poller` annotation now support ISO 8601 duration format for `fixed-delay`, `fixed-rate` and `initial-delay` options.\n See <<./endpoint.adoc#endpoint-pollingconsumer, Polling Consumer>> for more information.\n+\n+- Java, Groovy and Kotlin DSLs have now context-specific methods in the `IntegationFlowDefinition` with a single `Consumer` argument to configure an endpoint and its handler with one builder and readable options.\n+See, for example, `transformWith()` in <<./dsl.adoc#java-dsl, Java DSL Chapter>>.\n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/dsl/flows/IntegrationFlowTests.java b/spring-integration-core/src/test/java/org/springframework/integration/dsl/flows/IntegrationFlowTests.java\nindex 79bb09afe96..e0f4547e25d 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/dsl/flows/IntegrationFlowTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/dsl/flows/IntegrationFlowTests.java\n@@ -64,6 +64,7 @@\n import org.springframework.integration.dsl.PollerSpec;\n import org.springframework.integration.dsl.Pollers;\n import org.springframework.integration.dsl.QueueChannelSpec;\n+import org.springframework.integration.dsl.TransformerEndpointSpec;\n import org.springframework.integration.dsl.Transformers;\n import org.springframework.integration.endpoint.AbstractEndpoint;\n import org.springframework.integration.endpoint.EventDrivenConsumer;\n@@ -671,17 +672,24 @@ public IntegrationFlow flow2() {\n \t\t\t\t\t.fixedSubscriberChannel()\n \t\t\t\t\t.<String, Integer>transform(Integer::parseInt)\n \t\t\t\t\t.transform(Foo::new)\n-\t\t\t\t\t.transform(new PayloadSerializingTransformer(),\n-\t\t\t\t\t\t\tc -> c.autoStartup(false).id(\"payloadSerializingTransformer\"))\n+\t\t\t\t\t.transformWith(this::payloadSerializingTransformer)\n \t\t\t\t\t.channel(MessageChannels.queue(new SimpleMessageStore(), \"fooQueue\"))\n \t\t\t\t\t.transform(Transformers.deserializer(Foo.class.getName()))\n \t\t\t\t\t.<Foo, Integer>transform(f -> f.value)\n \t\t\t\t\t.filter(\"true\", e -> e.id(\"expressionFilter\"))\n \t\t\t\t\t.channel(publishSubscribeChannel())\n-\t\t\t\t\t.transform((Integer p) -> p * 2, c -> c.advice(this.expressionAdvice()))\n+\t\t\t\t\t.transformWith(t -> t\n+\t\t\t\t\t\t\t.transformer((Integer p) -> p * 2)\n+\t\t\t\t\t\t\t.advice(expressionAdvice()))\n \t\t\t\t\t.get();\n \t\t}\n \n+\t\tprivate void payloadSerializingTransformer(TransformerEndpointSpec spec) {\n+\t\t\tspec.transformer(new PayloadSerializingTransformer())\n+\t\t\t\t\t.autoStartup(false)\n+\t\t\t\t\t.id(\"payloadSerializingTransformer\");\n+\t\t}\n+\n \t\t@Bean\n \t\tpublic MessageChannel publishSubscribeChannel() {\n \t\t\treturn new PublishSubscribeChannel();\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/dsl/manualflow/ManualFlowTests.java b/spring-integration-core/src/test/java/org/springframework/integration/dsl/manualflow/ManualFlowTests.java\nindex 694d62de371..646eb01ffc1 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/dsl/manualflow/ManualFlowTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/dsl/manualflow/ManualFlowTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2022 the original author or authors.\n+ * Copyright 2016-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -190,7 +190,8 @@ public void testManualFlowRegistration() throws InterruptedException {\n \t\tIntegrationFlow myFlow = f -> f\n \t\t\t\t.<String, String>transform(String::toUpperCase)\n \t\t\t\t.channel(MessageChannels.queue())\n-\t\t\t\t.transform(\"Hello, \"::concat, e -> e\n+\t\t\t\t.transformWith(t -> t\n+\t\t\t\t\t\t.transformer(\"Hello, \"::concat)\n \t\t\t\t\t\t.poller(p -> p\n \t\t\t\t\t\t\t\t.fixedDelay(10)\n \t\t\t\t\t\t\t\t.maxMessagesPerPoll(1)\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/dsl/reactivestreams/ReactiveStreamsTests.java b/spring-integration-core/src/test/java/org/springframework/integration/dsl/reactivestreams/ReactiveStreamsTests.java\nindex 4af374c7110..ef32cf87af6 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/dsl/reactivestreams/ReactiveStreamsTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/dsl/reactivestreams/ReactiveStreamsTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2022 the original author or authors.\n+ * Copyright 2016-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -262,8 +262,10 @@ public Publisher<Message<Integer>> pollableReactiveFlow() {\n \t\t\treturn IntegrationFlow\n \t\t\t\t\t.from(\"inputChannel\")\n \t\t\t\t\t.split(s -> s.delimiters(\",\"))\n-\t\t\t\t\t.<String, Integer>transform(Integer::parseInt,\n-\t\t\t\t\t\t\te -> e.reactive(flux -> flux.publishOn(Schedulers.parallel())).id(\"reactiveTransformer\"))\n+\t\t\t\t\t.transformWith(t -> t\n+\t\t\t\t\t\t\t.<String, Integer>transformer(Integer::parseInt)\n+\t\t\t\t\t\t\t.reactive(flux -> flux.publishOn(Schedulers.parallel()))\n+\t\t\t\t\t\t\t.id(\"reactiveTransformer\"))\n \t\t\t\t\t.channel(MessageChannels.queue())\n \t\t\t\t\t.log()\n \t\t\t\t\t.toReactivePublisher();\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/dsl/transformers/TransformerTests.java b/spring-integration-core/src/test/java/org/springframework/integration/dsl/transformers/TransformerTests.java\nindex 4bdaeb1401a..5b86c9e3c21 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/dsl/transformers/TransformerTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/dsl/transformers/TransformerTests.java\n@@ -460,10 +460,11 @@ public ExpressionEvaluatingRequestHandlerAdvice expressionAdvice() {\n \t\t@Bean\n \t\tpublic IntegrationFlow transformFlowWithError() {\n \t\t\treturn f -> f\n-\t\t\t\t\t.transform(p -> {\n-\t\t\t\t\t\t\t\tthrow new RuntimeException(\"intentional\");\n-\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\te -> e.advice(expressionAdvice()))\n+\t\t\t\t\t.transformWith((t) ->\n+\t\t\t\t\t\t\tt.transformer(p -> {\n+\t\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\"intentional\");\n+\t\t\t\t\t\t\t\t\t})\n+\t\t\t\t\t\t\t\t\t.advice(expressionAdvice()))\n \t\t\t\t\t.log();\n \t\t}\n \n\ndiff --git a/spring-integration-core/src/test/kotlin/org/springframework/integration/dsl/KotlinDslTests.kt b/spring-integration-core/src/test/kotlin/org/springframework/integration/dsl/KotlinDslTests.kt\nindex 94dc725e6c5..83fce807f10 100644\n--- a/spring-integration-core/src/test/kotlin/org/springframework/integration/dsl/KotlinDslTests.kt\n+++ b/spring-integration-core/src/test/kotlin/org/springframework/integration/dsl/KotlinDslTests.kt\n@@ -161,7 +161,10 @@ class KotlinDslTests {\n \n \t\tval integrationFlow =\n \t\t\tintegrationFlow(publisher) {\n-\t\t\t\ttransform<Message<Int>>({ it.payload * 2 }) { id(\"foo\") }\n+\t\t\t\ttransformWith {\n+\t\t\t\t\ttransformer<Message<Int>> { it.payload * 2 }\n+\t\t\t\t\tid(\"foo\")\n+\t\t\t\t}\n \t\t\t\tchannel(fluxChannel)\n \t\t\t}\n \n@@ -249,7 +252,10 @@ class KotlinDslTests {\n \t\t@Bean\n \t\tfun functionFlow() =\n \t\t\tintegrationFlow<Function<ByteArray, String>>({ beanName(\"functionGateway\") }) {\n-\t\t\t\ttransform(Transformers.objectToString()) { id(\"objectToStringTransformer\") }\n+\t\t\t\ttransformWith {\n+\t\t\t\t\ttransformer(Transformers.objectToString())\n+\t\t\t\t\tid(\"objectToStringTransformer\")\n+\t\t\t\t}\n \t\t\t\ttransform<String> { it.uppercase() }\n \t\t\t\tsplit<Message<*>> { it.payload }\n \t\t\t\tsplit<String>({ it }) { id(\"splitterEndpoint\") }\n@@ -292,7 +298,10 @@ class KotlinDslTests {\n \t\tfun fixedSubscriberFlow() =\n \t\t\tintegrationFlow(\"fixedSubscriberInput\", true) {\n \t\t\t\tlog<Any>(LoggingHandler.Level.WARN) { it.payload }\n-\t\t\t\ttransform(\"payload\") { id(\"spelTransformer\") }\n+\t\t\t\ttransformWith {\n+\t\t\t\t\texpression(\"payload\")\n+\t\t\t\t\tid(\"spelTransformer\")\n+\t\t\t\t}\n \t\t\t}\n \n \t\t@Bean\n\ndiff --git a/spring-integration-file/src/test/java/org/springframework/integration/file/dsl/FileTests.java b/spring-integration-file/src/test/java/org/springframework/integration/file/dsl/FileTests.java\nindex ae24e92c88e..8bfc11d62ac 100644\n--- a/spring-integration-file/src/test/java/org/springframework/integration/file/dsl/FileTests.java\n+++ b/spring-integration-file/src/test/java/org/springframework/integration/file/dsl/FileTests.java\n@@ -448,8 +448,9 @@ void pollDirectories(File... directories) {\n \t\t\t\t\t\t.from(Files.inboundAdapter(directory).recursive(true),\n \t\t\t\t\t\t\t\te -> e.poller(p -> p.fixedDelay(1000))\n \t\t\t\t\t\t\t\t\t\t.id(directory.getName() + \".adapter\"))\n-\t\t\t\t\t\t.transform(Files.toStringTransformer(),\n-\t\t\t\t\t\t\t\te -> e.id(directory.getName() + \".transformer\"))\n+\t\t\t\t\t\t.transformWith(t -> t\n+\t\t\t\t\t\t\t\t.transformer(Files.toStringTransformer())\n+\t\t\t\t\t\t\t\t.id(directory.getName() + \".transformer\"))\n \t\t\t\t\t\t.channel(this.dynamicAdaptersResult)\n \t\t\t\t\t\t.get();\n \t\t\t\tthis.beanFactory.initializeBean(integrationFlow, directory.getName());\n\ndiff --git a/spring-integration-groovy/src/test/groovy/org/springframework/integration/groovy/dsl/test/GroovyDslTests.groovy b/spring-integration-groovy/src/test/groovy/org/springframework/integration/groovy/dsl/test/GroovyDslTests.groovy\nindex 9b3c671c581..76399d3fbb5 100644\n--- a/spring-integration-groovy/src/test/groovy/org/springframework/integration/groovy/dsl/test/GroovyDslTests.groovy\n+++ b/spring-integration-groovy/src/test/groovy/org/springframework/integration/groovy/dsl/test/GroovyDslTests.groovy\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2022 the original author or authors.\n+ * Copyright 2022-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -130,11 +130,14 @@ class GroovyDslTests {\n \t\tdef publisher = Flux.just(2, 3).map { new GenericMessage<>(it) }\n \n \t\tdef integrationFlow =\n-\t\t\t\tintegrationFlow(publisher)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\ttransform Message<Integer>, { it.payload * 2 }, { id 'foo' }\n-\t\t\t\t\t\t\tchannel fluxChannel\n-\t\t\t\t\t\t}\n+\t\t\t\tintegrationFlow(publisher) {\n+\t\t\t\t\ttransform {\n+\t\t\t\t\t\tit.<Message<Integer>, Integer>transformer { it.payload * 2 }\n+\t\t\t\t\t\texpectedType Message<Integer>\n+\t\t\t\t\t\tid 'foo'\n+\t\t\t\t\t}\n+\t\t\t\t\tchannel fluxChannel\n+\t\t\t\t}\n \n \t\tdef registration = this.integrationFlowContext.registration(integrationFlow).register()\n \n@@ -217,7 +220,7 @@ class GroovyDslTests {\n \t\tassert groovyTestService.result.get() == 'TEST'\n \t}\n \n-\t@Configuration\n+\t@Configuration(proxyBeanMethods = false)\n \t@EnableIntegration\n \tstatic class Config {\n \n@@ -240,7 +243,9 @@ class GroovyDslTests {\n \t\trequestReplyFlow() {\n \t\t\tintegrationFlow {\n \t\t\t\tfluxTransform { it.map { it } }\n-\t\t\t\ttransform String, { it.toUpperCase() }\n+\t\t\t\ttransform {\n+\t\t\t\t\ttransformer { it.toUpperCase() }\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n@@ -257,8 +262,13 @@ class GroovyDslTests {\n \t\t\tintegrationFlow Function<byte[], String>,\n \t\t\t\t\t{ beanName 'functionGateway' },\n \t\t\t\t\t{\n-\t\t\t\t\t\ttransform Transformers.objectToString(), { id 'objectToStringTransformer' }\n-\t\t\t\t\t\ttransform String, { it.toUpperCase() }\n+\t\t\t\t\t\ttransform {\n+\t\t\t\t\t\t\ttransformer Transformers.objectToString()\n+\t\t\t\t\t\t\tid 'objectToStringTransformer'\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\ttransform {\n+\t\t\t\t\t\t\ttransformer { it.toUpperCase() }\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tsplit Message<?>, { it.payload }\n \t\t\t\t\t\tsplit Object, { it }, { id 'splitterEndpoint' }\n \t\t\t\t\t\tresequence()\n@@ -314,11 +324,13 @@ class GroovyDslTests {\n \t\t\t\twireTap integrationFlow {\n \t\t\t\t\tchannel { queue 'wireTapChannel' }\n \t\t\t\t}\n-\t\t\t\tdelay  {\n+\t\t\t\tdelay {\n \t\t\t\t\tmessageGroupId 'delayGroup'\n \t\t\t\t\tdefaultDelay 100\n \t\t\t\t}\n-\t\t\t\ttransform String, { it.toUpperCase() }\n+\t\t\t\ttransform {\n+\t\t\t\t\ttransformer { it.toUpperCase() }\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n\ndiff --git a/spring-integration-webflux/src/test/java/org/springframework/integration/webflux/observation/WebFluxObservationPropagationTests.java b/spring-integration-webflux/src/test/java/org/springframework/integration/webflux/observation/WebFluxObservationPropagationTests.java\nindex 7588c62c6c0..fcfa5edaa21 100644\n--- a/spring-integration-webflux/src/test/java/org/springframework/integration/webflux/observation/WebFluxObservationPropagationTests.java\n+++ b/spring-integration-webflux/src/test/java/org/springframework/integration/webflux/observation/WebFluxObservationPropagationTests.java\n@@ -212,7 +212,9 @@ IntegrationFlow webFluxRequestReplyFlow(\n \t\t\t\t\t\t\t.payloadExpression(\"#requestParams.name[0]\")\n \t\t\t\t\t\t\t.requestChannel(webFluxRequestChannel)\n \t\t\t\t\t\t\t.id(\"webFluxGateway\"))\n-\t\t\t\t\t.<String, String>transform(String::toLowerCase, e -> e.id(\"testTransformer\"))\n+\t\t\t\t\t.transformWith(t -> t\n+\t\t\t\t\t\t\t.<String, String>transformer(String::toLowerCase)\n+\t\t\t\t\t\t\t.id(\"testTransformer\"))\n \t\t\t\t\t.get();\n \t\t}\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8652",
    "pr_id": 8652,
    "issue_id": 8643,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Revise synchronized blocks/methods in critical code path to avoid virtual threads pinning\n",
    "issue_word_count": 13,
    "test_files_count": 3,
    "non_test_files_count": 97,
    "pr_changed_files": [
      "spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AbstractAmqpOutboundEndpoint.java",
      "spring-integration-core/src/main/java/org/springframework/integration/channel/AbstractMessageChannel.java",
      "spring-integration-core/src/main/java/org/springframework/integration/channel/DefaultHeaderChannelRegistry.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/AbstractSimpleMessageHandlerFactoryBean.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/ConsumerEndpointFactoryBean.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/IdGeneratorConfigurer.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/IdempotentReceiverAutoProxyCreator.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/SourcePollingChannelAdapterFactoryBean.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/xml/SpelPropertyAccessorsParser.java",
      "spring-integration-core/src/main/java/org/springframework/integration/core/MessagingTemplate.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dispatcher/AbstractDispatcher.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dispatcher/PartitionedDispatcher.java",
      "spring-integration-core/src/main/java/org/springframework/integration/endpoint/AbstractPollingEndpoint.java",
      "spring-integration-core/src/main/java/org/springframework/integration/endpoint/MethodInvokingMessageSource.java",
      "spring-integration-core/src/main/java/org/springframework/integration/endpoint/SourcePollingChannelAdapter.java",
      "spring-integration-core/src/main/java/org/springframework/integration/expression/ReloadableResourceBundleExpressionSource.java",
      "spring-integration-core/src/main/java/org/springframework/integration/gateway/GatewayMessageHandler.java",
      "spring-integration-core/src/main/java/org/springframework/integration/gateway/GatewayProxyFactoryBean.java",
      "spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java",
      "spring-integration-core/src/main/java/org/springframework/integration/graph/IntegrationGraphServer.java",
      "spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractReplyProducingMessageHandler.java",
      "spring-integration-core/src/main/java/org/springframework/integration/handler/DelayHandler.java",
      "spring-integration-core/src/main/java/org/springframework/integration/handler/MessageHandlerChain.java",
      "spring-integration-core/src/main/java/org/springframework/integration/handler/support/MessagingMethodInvokerHelper.java",
      "spring-integration-core/src/main/java/org/springframework/integration/history/MessageHistoryConfigurer.java",
      "spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java",
      "spring-integration-core/src/main/java/org/springframework/integration/selector/MessageSelectorChain.java",
      "spring-integration-core/src/main/java/org/springframework/integration/selector/MetadataStoreSelector.java",
      "spring-integration-core/src/main/java/org/springframework/integration/store/AbstractMessageGroupStore.java",
      "spring-integration-core/src/main/java/org/springframework/integration/store/PersistentMessageGroup.java",
      "spring-integration-core/src/main/java/org/springframework/integration/store/SimpleMessageGroup.java",
      "spring-integration-core/src/main/java/org/springframework/integration/support/SmartLifecycleRoleController.java",
      "spring-integration-core/src/main/java/org/springframework/integration/support/channel/BeanFactoryChannelResolver.java",
      "spring-integration-core/src/main/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiator.java",
      "spring-integration-core/src/main/java/org/springframework/integration/transformer/support/RoutingSlipHeaderValueMessageProcessor.java",
      "spring-integration-core/src/main/java/org/springframework/integration/util/AcceptOnceCollectionFilter.java",
      "spring-integration-core/src/main/java/org/springframework/integration/util/SimplePool.java",
      "spring-integration-feed/src/main/java/org/springframework/integration/feed/inbound/FeedEntryMessageSource.java",
      "spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java",
      "spring-integration-file/src/main/java/org/springframework/integration/file/config/FileListFilterFactoryBean.java",
      "spring-integration-file/src/main/java/org/springframework/integration/file/filters/AcceptOnceFileListFilter.java",
      "spring-integration-file/src/main/java/org/springframework/integration/file/filters/CompositeFileListFilter.java",
      "spring-integration-file/src/main/java/org/springframework/integration/file/remote/session/CachingSessionFactory.java",
      "spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/leader/LeaderInitiator.java",
      "spring-integration-http/src/main/java/org/springframework/integration/http/outbound/AbstractHttpRequestExecutingMessageHandler.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/AbstractInternetProtocolSendingMessageHandler.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/TcpSendingMessageHandler.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractConnectionFactory.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractServerConnectionFactory.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/CachingClientConnectionFactory.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/ClientModeConnectionManager.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/FailoverClientConnectionFactory.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpConnectionInterceptorSupport.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNetConnection.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioClientConnectionFactory.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioConnection.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioSSLConnection.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/MulticastReceivingChannelAdapter.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/MulticastSendingMessageHandler.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/UnicastReceivingChannelAdapter.java",
      "spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/UnicastSendingMessageHandler.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/StoredProcExecutor.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/JdbcLockRegistry.java",
      "spring-integration-jms/src/main/java/org/springframework/integration/jms/JmsOutboundGateway.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/AbstractMqttClientManager.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/MqttPahoMessageDrivenChannelAdapter.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/Mqttv5PahoMessageDrivenChannelAdapter.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/MqttPahoMessageHandler.java",
      "spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java",
      "spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java",
      "spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java",
      "spring-integration-smb/src/main/java/org/springframework/integration/smb/session/SmbShare.java",
      "spring-integration-stomp/src/main/java/org/springframework/integration/stomp/AbstractStompSessionManager.java",
      "spring-integration-stomp/src/main/java/org/springframework/integration/stomp/outbound/StompMessageHandler.java",
      "spring-integration-stomp/src/test/java/org/springframework/integration/stomp/inbound/StompInboundChannelAdapterWebSocketIntegrationTests.java",
      "spring-integration-stream/src/main/java/org/springframework/integration/stream/ByteStreamReadingMessageSource.java",
      "spring-integration-stream/src/main/java/org/springframework/integration/stream/CharacterStreamReadingMessageSource.java",
      "spring-integration-test/src/main/java/org/springframework/integration/test/mock/MockMessageHandler.java",
      "spring-integration-websocket/src/main/java/org/springframework/integration/websocket/ClientWebSocketContainer.java",
      "spring-integration-websocket/src/main/java/org/springframework/integration/websocket/IntegrationWebSocketContainer.java",
      "spring-integration-websocket/src/main/java/org/springframework/integration/websocket/ServerWebSocketContainer.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/AbstractWebServiceOutboundGateway.java",
      "spring-integration-xml/src/main/java/org/springframework/integration/xml/DefaultXmlPayloadConverter.java",
      "spring-integration-xml/src/main/java/org/springframework/integration/xml/result/DomResultFactory.java",
      "spring-integration-xml/src/main/java/org/springframework/integration/xml/source/DomSourceFactory.java",
      "spring-integration-xml/src/main/java/org/springframework/integration/xml/source/StringSourceFactory.java",
      "spring-integration-xml/src/main/java/org/springframework/integration/xml/splitter/XPathMessageSplitter.java",
      "spring-integration-xml/src/main/java/org/springframework/integration/xml/transformer/ResultToDocumentTransformer.java",
      "spring-integration-xml/src/main/java/org/springframework/integration/xml/transformer/ResultToStringTransformer.java",
      "spring-integration-xmpp/src/main/java/org/springframework/integration/xmpp/config/XmppConnectionFactoryBean.java",
      "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java",
      "spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/config/CuratorFrameworkFactoryBean.java",
      "spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/config/LeaderInitiatorFactoryBean.java",
      "spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/leader/LeaderInitiator.java",
      "spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/lock/ZookeeperLockRegistry.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-stomp/src/test/java/org/springframework/integration/stomp/inbound/StompInboundChannelAdapterWebSocketIntegrationTests.java",
      "spring-integration-stream/src/main/java/org/springframework/integration/stream/ByteStreamReadingMessageSource.java",
      "spring-integration-test/src/main/java/org/springframework/integration/test/mock/MockMessageHandler.java"
    ],
    "base_commit": "8a29c1e60bc186b8fced4abed7e6b73d45db9416",
    "head_commit": "17b3894ebd94574e32b9ac73acbd130d10f8ee04",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8652",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8652",
    "dockerfile": "",
    "pr_merged_at": "2023-06-21T17:25:46.000Z",
    "patch": "diff --git a/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AbstractAmqpOutboundEndpoint.java b/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AbstractAmqpOutboundEndpoint.java\nindex b55f77c8707..171c53c4f12 100644\n--- a/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AbstractAmqpOutboundEndpoint.java\n+++ b/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AbstractAmqpOutboundEndpoint.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2022 the original author or authors.\n+ * Copyright 2016-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,6 +23,8 @@\n import java.util.UUID;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.amqp.core.MessageDeliveryMode;\n import org.springframework.amqp.core.ReturnedMessage;\n@@ -58,6 +60,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 4.3\n  *\n@@ -115,6 +118,8 @@ public abstract class AbstractAmqpOutboundEndpoint extends AbstractReplyProducin\n \n \tprivate volatile ScheduledFuture<?> confirmChecker;\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \t/**\n \t * Set a custom {@link AmqpHeaderMapper} for mapping request and reply headers.\n \t * Defaults to {@link DefaultAmqpHeaderMapper#outboundMapper()}.\n@@ -336,8 +341,14 @@ public void setConfirmTimeout(long confirmTimeout) {\n \t\tthis.confirmTimeout = Duration.ofMillis(confirmTimeout); // NOSONAR sync inconsistency\n \t}\n \n-\tprotected final synchronized void setConnectionFactory(ConnectionFactory connectionFactory) {\n-\t\tthis.connectionFactory = connectionFactory;\n+\tprotected final void setConnectionFactory(ConnectionFactory connectionFactory) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tthis.connectionFactory = connectionFactory;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \tprotected String getExchangeName() {\n@@ -487,26 +498,33 @@ protected void endpointInit() {\n \t}\n \n \t@Override\n-\tpublic synchronized void start() {\n-\t\tif (!this.running) {\n-\t\t\tif (!this.lazyConnect && this.connectionFactory != null) {\n-\t\t\t\ttry {\n-\t\t\t\t\tConnection connection = this.connectionFactory.createConnection(); // NOSONAR (close)\n-\t\t\t\t\tif (connection != null) {\n-\t\t\t\t\t\tconnection.close();\n+\tpublic void start() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (!this.running) {\n+\t\t\t\tif (!this.lazyConnect && this.connectionFactory != null) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tConnection connection = this.connectionFactory.createConnection(); // NOSONAR (close)\n+\t\t\t\t\t\tif (connection != null) {\n+\t\t\t\t\t\t\tconnection.close();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (RuntimeException ex) {\n+\t\t\t\t\t\tlogger.error(ex, \"Failed to eagerly establish the connection.\");\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tcatch (RuntimeException ex) {\n-\t\t\t\t\tlogger.error(ex, \"Failed to eagerly establish the connection.\");\n+\t\t\t\tdoStart();\n+\t\t\t\tif (this.confirmTimeout != null && getConfirmNackChannel() != null && getRabbitTemplate() != null) {\n+\t\t\t\t\tthis.confirmChecker = getTaskScheduler()\n+\t\t\t\t\t\t\t.scheduleAtFixedRate(checkUnconfirmed(), this.confirmTimeout.dividedBy(2L));\n \t\t\t\t}\n+\t\t\t\tthis.running = true;\n \t\t\t}\n-\t\t\tdoStart();\n-\t\t\tif (this.confirmTimeout != null && getConfirmNackChannel() != null && getRabbitTemplate() != null) {\n-\t\t\t\tthis.confirmChecker = getTaskScheduler()\n-\t\t\t\t\t\t.scheduleAtFixedRate(checkUnconfirmed(), this.confirmTimeout.dividedBy(2L));\n-\t\t\t}\n-\t\t\tthis.running = true;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n+\n \t}\n \n \tprivate Runnable checkUnconfirmed() {\n@@ -526,14 +544,20 @@ private Runnable checkUnconfirmed() {\n \tprotected abstract RabbitTemplate getRabbitTemplate();\n \n \t@Override\n-\tpublic synchronized void stop() {\n-\t\tif (this.running) {\n-\t\t\tdoStop();\n-\t\t}\n-\t\tthis.running = false;\n-\t\tif (this.confirmChecker != null) {\n-\t\t\tthis.confirmChecker.cancel(false);\n-\t\t\tthis.confirmChecker = null;\n+\tpublic void stop() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.running) {\n+\t\t\t\tdoStop();\n+\t\t\t}\n+\t\t\tthis.running = false;\n+\t\t\tif (this.confirmChecker != null) {\n+\t\t\t\tthis.confirmChecker.cancel(false);\n+\t\t\t\tthis.confirmChecker = null;\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/channel/AbstractMessageChannel.java b/spring-integration-core/src/main/java/org/springframework/integration/channel/AbstractMessageChannel.java\nindex 3d0b48dca9e..1517392ed36 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/channel/AbstractMessageChannel.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/channel/AbstractMessageChannel.java\n@@ -26,6 +26,8 @@\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import io.micrometer.observation.ObservationRegistry;\n \n@@ -70,6 +72,7 @@\n  * @author Oleg Zhurakousky\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n @IntegrationManagedResource\n public abstract class AbstractMessageChannel extends IntegrationObjectSupport\n@@ -475,6 +478,8 @@ public void destroy() {\n \t */\n \tprotected static class ChannelInterceptorList {\n \n+\t\tprivate final Lock lock = new ReentrantLock();\n+\n \t\tprotected final List<ChannelInterceptor> interceptors = new CopyOnWriteArrayList<>(); // NOSONAR\n \n \t\tprivate final LogAccessor logger;\n@@ -486,11 +491,15 @@ public ChannelInterceptorList(LogAccessor logger) {\n \t\t}\n \n \t\tpublic boolean set(List<ChannelInterceptor> interceptors) {\n-\t\t\tsynchronized (this.interceptors) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tthis.interceptors.clear();\n \t\t\t\tthis.size = interceptors.size();\n \t\t\t\treturn this.interceptors.addAll(interceptors);\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \n \t\tpublic int getSize() {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/channel/DefaultHeaderChannelRegistry.java b/spring-integration-core/src/main/java/org/springframework/integration/channel/DefaultHeaderChannelRegistry.java\nindex 1e09738224b..8efc15dc6c2 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/channel/DefaultHeaderChannelRegistry.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/channel/DefaultHeaderChannelRegistry.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2022 the original author or authors.\n+ * Copyright 2013-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -24,6 +24,8 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.integration.context.IntegrationObjectSupport;\n import org.springframework.integration.support.channel.HeaderChannelRegistry;\n@@ -44,6 +46,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Trung Pham\n+ * @author Christian Tzolov\n  *\n  * @since 3.0\n  *\n@@ -69,6 +72,8 @@ public class DefaultHeaderChannelRegistry extends IntegrationObjectSupport\n \n \tprivate volatile boolean explicitlyStopped;\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \t/**\n \t * Construct a registry with the default delay for channel expiry.\n \t */\n@@ -120,25 +125,37 @@ protected void onInit() {\n \t}\n \n \t@Override\n-\tpublic synchronized void start() {\n-\t\tif (!this.running) {\n-\t\t\tAssert.notNull(getTaskScheduler(), \"a task scheduler is required\");\n-\t\t\tthis.reaperScheduledFuture =\n-\t\t\t\t\tgetTaskScheduler()\n-\t\t\t\t\t\t\t.schedule(this, Instant.now().plusMillis(this.reaperDelay));\n-\n-\t\t\tthis.running = true;\n+\tpublic void start() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (!this.running) {\n+\t\t\t\tAssert.notNull(getTaskScheduler(), \"a task scheduler is required\");\n+\t\t\t\tthis.reaperScheduledFuture = getTaskScheduler()\n+\t\t\t\t\t\t.schedule(this, Instant.now().plusMillis(this.reaperDelay));\n+\n+\t\t\t\tthis.running = true;\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n \t@Override\n-\tpublic synchronized void stop() {\n-\t\tthis.running = false;\n-\t\tif (this.reaperScheduledFuture != null) {\n-\t\t\tthis.reaperScheduledFuture.cancel(true);\n-\t\t\tthis.reaperScheduledFuture = null;\n+\tpublic void stop() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tthis.running = false;\n+\t\t\tif (this.reaperScheduledFuture != null) {\n+\t\t\t\tthis.reaperScheduledFuture.cancel(true);\n+\t\t\t\tthis.reaperScheduledFuture = null;\n+\t\t\t}\n+\t\t\tthis.explicitlyStopped = true;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\tthis.explicitlyStopped = true;\n+\n \t}\n \n \tpublic void stop(Runnable callback) {\n@@ -200,35 +217,45 @@ public MessageChannel channelNameToChannel(@Nullable String name) {\n \t * Cancel the scheduled reap task and run immediately; then reschedule.\n \t */\n \t@Override\n-\tpublic synchronized void runReaper() {\n-\t\tif (this.reaperScheduledFuture != null) {\n-\t\t\tthis.reaperScheduledFuture.cancel(true);\n-\t\t\tthis.reaperScheduledFuture = null;\n-\t\t}\n+\tpublic void runReaper() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.reaperScheduledFuture != null) {\n+\t\t\t\tthis.reaperScheduledFuture.cancel(true);\n+\t\t\t\tthis.reaperScheduledFuture = null;\n+\t\t\t}\n \n-\t\trun();\n+\t\t\trun();\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic synchronized void run() {\n-\t\tlogger.trace(() -> \"Reaper started; channels size=\" + this.channels.size());\n-\t\tIterator<Entry<String, MessageChannelWrapper>> iterator = this.channels.entrySet().iterator();\n-\t\tlong now = System.currentTimeMillis();\n-\t\twhile (iterator.hasNext()) {\n-\t\t\tEntry<String, MessageChannelWrapper> entry = iterator.next();\n-\t\t\tif (entry.getValue().expireAt() < now) {\n-\t\t\t\tlogger.debug(() -> \"Expiring \" + entry.getKey() + \" (\" + entry.getValue().channel() + \")\");\n-\t\t\t\titerator.remove();\n+\tpublic void run() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tlogger.trace(() -> \"Reaper started; channels size=\" + this.channels.size());\n+\t\t\tIterator<Entry<String, MessageChannelWrapper>> iterator = this.channels.entrySet().iterator();\n+\t\t\tlong now = System.currentTimeMillis();\n+\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\tEntry<String, MessageChannelWrapper> entry = iterator.next();\n+\t\t\t\tif (entry.getValue().expireAt() < now) {\n+\t\t\t\t\tlogger.debug(() -> \"Expiring \" + entry.getKey() + \" (\" + entry.getValue().channel() + \")\");\n+\t\t\t\t\titerator.remove();\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n-\t\tthis.reaperScheduledFuture =\n-\t\t\t\tgetTaskScheduler()\n-\t\t\t\t\t\t.schedule(this, Instant.now().plusMillis(this.reaperDelay));\n+\t\t\tthis.reaperScheduledFuture = getTaskScheduler()\n+\t\t\t\t\t.schedule(this, Instant.now().plusMillis(this.reaperDelay));\n \n-\t\tlogger.trace(() -> \"Reaper completed; channels size=\" + this.channels.size());\n+\t\t\tlogger.trace(() -> \"Reaper completed; channels size=\" + this.channels.size());\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n-\n \tprotected record MessageChannelWrapper(MessageChannel channel, long expireAt) {\n \n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractSimpleMessageHandlerFactoryBean.java b/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractSimpleMessageHandlerFactoryBean.java\nindex 6784a0a9beb..44ef9096dbe 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractSimpleMessageHandlerFactoryBean.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractSimpleMessageHandlerFactoryBean.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,6 +17,8 @@\n package org.springframework.integration.config;\n \n import java.util.List;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.aopalliance.aop.Advice;\n import org.apache.commons.logging.Log;\n@@ -58,6 +60,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author David Liu\n+ * @author Christian Tzolov\n  */\n public abstract class AbstractSimpleMessageHandlerFactoryBean<H extends MessageHandler>\n \t\timplements FactoryBean<MessageHandler>, ApplicationContextAware, BeanFactoryAware, BeanNameAware,\n@@ -65,7 +68,7 @@ public abstract class AbstractSimpleMessageHandlerFactoryBean<H extends MessageH\n \n \tprotected final Log logger = LogFactory.getLog(getClass()); //NOSONAR protected with final\n \n-\tprivate final Object initializationMonitor = new Object();\n+\tprivate final Lock initializationMonitor = new ReentrantLock();\n \n \tprivate BeanFactory beanFactory;\n \n@@ -192,7 +195,8 @@ public H getObject() {\n \t}\n \n \tprotected final H createHandlerInternal() {\n-\t\tsynchronized (this.initializationMonitor) {\n+\t\tthis.initializationMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.initialized) {\n \t\t\t\t// There was a problem when this method was called already\n \t\t\t\treturn null;\n@@ -228,6 +232,9 @@ protected final H createHandlerInternal() {\n \t\t\t\t\t\t\tthis.order, theOrder -> ((Orderable) this.handler).setOrder(theOrder));\n \t\t\tthis.initialized = true;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.initializationMonitor.unlock();\n+\t\t}\n \t\tinitializingBean();\n \t\treturn this.handler;\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/ConsumerEndpointFactoryBean.java b/spring-integration-core/src/main/java/org/springframework/integration/config/ConsumerEndpointFactoryBean.java\nindex 809e8b70e5c..89df271895e 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/ConsumerEndpointFactoryBean.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/ConsumerEndpointFactoryBean.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,6 +17,8 @@\n package org.springframework.integration.config;\n \n import java.util.List;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.Function;\n \n import org.aopalliance.aop.Advice;\n@@ -77,6 +79,7 @@\n  * @author Josh Long\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class ConsumerEndpointFactoryBean\n \t\timplements FactoryBean<AbstractEndpoint>, BeanFactoryAware, BeanNameAware, BeanClassLoaderAware,\n@@ -84,9 +87,9 @@ public class ConsumerEndpointFactoryBean\n \n \tprivate static final LogAccessor LOGGER = new LogAccessor(LogFactory.getLog(ConsumerEndpointFactoryBean.class));\n \n-\tprivate final Object initializationMonitor = new Object();\n+\tprivate final Lock initializationMonitor = new ReentrantLock();\n \n-\tprivate final Object handlerMonitor = new Object();\n+\tprivate final Lock handlerMonitor = new ReentrantLock();\n \n \tprivate MessageHandler handler;\n \n@@ -127,7 +130,8 @@ public class ConsumerEndpointFactoryBean\n \tpublic void setHandler(Object handler) {\n \t\tAssert.isTrue(handler instanceof MessageHandler || handler instanceof ReactiveMessageHandler,\n \t\t\t\t\"'handler' must be an instance of 'MessageHandler' or 'ReactiveMessageHandler'\");\n-\t\tsynchronized (this.handlerMonitor) {\n+\t\tthis.handlerMonitor.lock();\n+\t\ttry {\n \t\t\tAssert.isNull(this.handler, \"handler cannot be overridden\");\n \t\t\tif (handler instanceof ReactiveMessageHandler) {\n \t\t\t\tthis.handler = new ReactiveMessageHandlerAdapter((ReactiveMessageHandler) handler);\n@@ -136,6 +140,9 @@ public void setHandler(Object handler) {\n \t\t\t\tthis.handler = (MessageHandler) handler;\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.handlerMonitor.unlock();\n+\t\t}\n \t}\n \n \tpublic MessageHandler getHandler() {\n@@ -303,7 +310,8 @@ public Class<?> getObjectType() {\n \t}\n \n \tprivate void initializeEndpoint() {\n-\t\tsynchronized (this.initializationMonitor) {\n+\t\tthis.initializationMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.initialized) {\n \t\t\t\treturn;\n \t\t\t}\n@@ -340,6 +348,9 @@ else if (channel instanceof PollableChannel) {\n \t\t\tthis.endpoint.afterPropertiesSet();\n \t\t\tthis.initialized = true;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.initializationMonitor.unlock();\n+\t\t}\n \t}\n \n \tprivate MessageChannel resolveInputChannel() {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/IdGeneratorConfigurer.java b/spring-integration-core/src/main/java/org/springframework/integration/config/IdGeneratorConfigurer.java\nindex 15faf354dba..b26cfc98b18 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/IdGeneratorConfigurer.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/IdGeneratorConfigurer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2020 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,6 +19,8 @@\n import java.lang.reflect.Field;\n import java.util.HashSet;\n import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n@@ -39,11 +41,14 @@\n  * @author Mark Fisher\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0.4\n  */\n public final class IdGeneratorConfigurer implements ApplicationListener<ApplicationContextEvent> {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate static final Set<String> GENERATOR_CONTEXT_ID = new HashSet<>();\n \n \tprivate static volatile IdGenerator theIdGenerator;\n@@ -51,21 +56,28 @@ public final class IdGeneratorConfigurer implements ApplicationListener<Applicat\n \tprivate final Log logger = LogFactory.getLog(getClass());\n \n \t@Override\n-\tpublic synchronized void onApplicationEvent(ApplicationContextEvent event) {\n-\t\tApplicationContext context = event.getApplicationContext();\n-\t\tif (event instanceof ContextRefreshedEvent) {\n-\t\t\tboolean contextHasIdGenerator = context.getBeanNamesForType(IdGenerator.class).length > 0;\n-\t\t\tif (contextHasIdGenerator && setIdGenerator(context)) {\n-\t\t\t\tIdGeneratorConfigurer.GENERATOR_CONTEXT_ID.add(context.getId());\n+\tpublic void onApplicationEvent(ApplicationContextEvent event) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\n+\t\t\tApplicationContext context = event.getApplicationContext();\n+\t\t\tif (event instanceof ContextRefreshedEvent) {\n+\t\t\t\tboolean contextHasIdGenerator = context.getBeanNamesForType(IdGenerator.class).length > 0;\n+\t\t\t\tif (contextHasIdGenerator && setIdGenerator(context)) {\n+\t\t\t\t\tIdGeneratorConfigurer.GENERATOR_CONTEXT_ID.add(context.getId());\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n-\t\telse if (event instanceof ContextClosedEvent\n-\t\t\t\t&& IdGeneratorConfigurer.GENERATOR_CONTEXT_ID.contains(context.getId())) {\n+\t\t\telse if (event instanceof ContextClosedEvent\n+\t\t\t\t\t&& IdGeneratorConfigurer.GENERATOR_CONTEXT_ID.contains(context.getId())) {\n \n-\t\t\tif (IdGeneratorConfigurer.GENERATOR_CONTEXT_ID.size() == 1) {\n-\t\t\t\tunsetIdGenerator();\n+\t\t\t\tif (IdGeneratorConfigurer.GENERATOR_CONTEXT_ID.size() == 1) {\n+\t\t\t\t\tunsetIdGenerator();\n+\t\t\t\t}\n+\t\t\t\tIdGeneratorConfigurer.GENERATOR_CONTEXT_ID.remove(context.getId());\n \t\t\t}\n-\t\t\tIdGeneratorConfigurer.GENERATOR_CONTEXT_ID.remove(context.getId());\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/IdempotentReceiverAutoProxyCreator.java b/spring-integration-core/src/main/java/org/springframework/integration/config/IdempotentReceiverAutoProxyCreator.java\nindex 4c92d03479f..5259640b627 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/IdempotentReceiverAutoProxyCreator.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/IdempotentReceiverAutoProxyCreator.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2019 the original author or authors.\n+ * Copyright 2014-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,6 +20,8 @@\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.aop.Advisor;\n import org.springframework.aop.TargetSource;\n@@ -38,6 +40,8 @@\n  *\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n+ *\n  * @since 4.1\n  */\n @SuppressWarnings(\"serial\")\n@@ -47,6 +51,8 @@ class IdempotentReceiverAutoProxyCreator extends AbstractAutoProxyCreator {\n \n \tprivate volatile Map<String, List<String>> idempotentEndpoints; // double check locking requires volatile\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tpublic void setIdempotentEndpointsMapping(List<Map<String, String>> idempotentEndpointsMapping) {\n \t\tAssert.notEmpty(idempotentEndpointsMapping, \"'idempotentEndpointsMapping' must not be empty\");\n \t\tthis.idempotentEndpointsMapping = idempotentEndpointsMapping; //NOSONAR (inconsistent sync)\n@@ -85,8 +91,9 @@ protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanN\n \t}\n \n \tprivate void initIdempotentEndpointsIfNecessary() {\n-\t\tif (this.idempotentEndpoints == null) { //NOSONAR (inconsistent sync)\n-\t\t\tsynchronized (this) {\n+\t\tif (this.idempotentEndpoints == null) { // NOSONAR (inconsistent sync)\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (this.idempotentEndpoints == null) {\n \t\t\t\t\tthis.idempotentEndpoints = new LinkedHashMap<String, List<String>>();\n \t\t\t\t\tfor (Map<String, String> mapping : this.idempotentEndpointsMapping) {\n@@ -104,6 +111,9 @@ private void initIdempotentEndpointsIfNecessary() {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/SourcePollingChannelAdapterFactoryBean.java b/spring-integration-core/src/main/java/org/springframework/integration/config/SourcePollingChannelAdapterFactoryBean.java\nindex 899365a3389..b273a893a71 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/SourcePollingChannelAdapterFactoryBean.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/SourcePollingChannelAdapterFactoryBean.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,9 @@\n \n package org.springframework.integration.config;\n \n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n import org.springframework.beans.factory.BeanClassLoaderAware;\n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryAware;\n@@ -41,11 +44,12 @@\n  * @author Oleg Zhurakousky\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class SourcePollingChannelAdapterFactoryBean implements FactoryBean<SourcePollingChannelAdapter>,\n \t\tBeanFactoryAware, BeanNameAware, BeanClassLoaderAware, InitializingBean, SmartLifecycle, DisposableBean {\n \n-\tprivate final Object initializationMonitor = new Object();\n+\tprivate final Lock initializationMonitor = new ReentrantLock();\n \n \tprivate MessageSource<?> source;\n \n@@ -158,7 +162,8 @@ public Class<?> getObjectType() {\n \t}\n \n \tprivate void initializeAdapter() {\n-\t\tsynchronized (this.initializationMonitor) {\n+\t\tthis.initializationMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.initialized) {\n \t\t\t\treturn;\n \t\t\t}\n@@ -207,6 +212,9 @@ private void initializeAdapter() {\n \t\t\tthis.adapter = spca;\n \t\t\tthis.initialized = true;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.initializationMonitor.unlock();\n+\t\t}\n \t}\n \n \t/*\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/xml/SpelPropertyAccessorsParser.java b/spring-integration-core/src/main/java/org/springframework/integration/config/xml/SpelPropertyAccessorsParser.java\nindex dbe624f5b60..0e8c9cdf72e 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/xml/SpelPropertyAccessorsParser.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/xml/SpelPropertyAccessorsParser.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2019 the original author or authors.\n+ * Copyright 2013-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,6 +17,8 @@\n package org.springframework.integration.config.xml;\n \n import java.util.Map;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.w3c.dom.Element;\n import org.w3c.dom.Node;\n@@ -38,10 +40,14 @@\n  *\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n+ *\n  * @since 3.0\n  */\n public class SpelPropertyAccessorsParser implements BeanDefinitionParser {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final Map<String, Object> propertyAccessors = new ManagedMap<String, Object>();\n \n \t@Override\n@@ -86,17 +92,23 @@ else if (delegate.nodeNameEquals(ele, BeanDefinitionParserDelegate.REF_ELEMENT))\n \t\treturn null;\n \t}\n \n-\tprivate synchronized void initializeSpelPropertyAccessorRegistrarIfNecessary(ParserContext parserContext) {\n-\t\tif (!parserContext.getRegistry()\n-\t\t\t\t.containsBeanDefinition(IntegrationContextUtils.SPEL_PROPERTY_ACCESSOR_REGISTRAR_BEAN_NAME)) {\n-\n-\t\t\tBeanDefinitionBuilder registrarBuilder = BeanDefinitionBuilder\n-\t\t\t\t\t.genericBeanDefinition(SpelPropertyAccessorRegistrar.class)\n-\t\t\t\t\t.setRole(BeanDefinition.ROLE_INFRASTRUCTURE)\n-\t\t\t\t\t.addConstructorArgValue(this.propertyAccessors);\n-\t\t\tparserContext.getRegistry()\n-\t\t\t\t\t.registerBeanDefinition(IntegrationContextUtils.SPEL_PROPERTY_ACCESSOR_REGISTRAR_BEAN_NAME,\n-\t\t\t\t\t\t\tregistrarBuilder.getBeanDefinition());\n+\tprivate void initializeSpelPropertyAccessorRegistrarIfNecessary(ParserContext parserContext) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (!parserContext.getRegistry()\n+\t\t\t\t\t.containsBeanDefinition(IntegrationContextUtils.SPEL_PROPERTY_ACCESSOR_REGISTRAR_BEAN_NAME)) {\n+\n+\t\t\t\tBeanDefinitionBuilder registrarBuilder = BeanDefinitionBuilder\n+\t\t\t\t\t\t.genericBeanDefinition(SpelPropertyAccessorRegistrar.class)\n+\t\t\t\t\t\t.setRole(BeanDefinition.ROLE_INFRASTRUCTURE)\n+\t\t\t\t\t\t.addConstructorArgValue(this.propertyAccessors);\n+\t\t\t\tparserContext.getRegistry()\n+\t\t\t\t\t\t.registerBeanDefinition(IntegrationContextUtils.SPEL_PROPERTY_ACCESSOR_REGISTRAR_BEAN_NAME,\n+\t\t\t\t\t\t\t\tregistrarBuilder.getBeanDefinition());\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/core/MessagingTemplate.java b/spring-integration-core/src/main/java/org/springframework/integration/core/MessagingTemplate.java\nindex c0180fafb84..e4dcca64aad 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/core/MessagingTemplate.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/core/MessagingTemplate.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,9 @@\n \n package org.springframework.integration.core;\n \n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n import org.springframework.beans.BeansException;\n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.integration.context.IntegrationContextUtils;\n@@ -31,12 +34,15 @@\n  * @author Oleg Zhurakousky\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 1.0\n  *\n  */\n public class MessagingTemplate extends GenericMessagingTemplate {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate BeanFactory beanFactory;\n \n \tprivate volatile boolean throwExceptionOnLateReplySet;\n@@ -84,15 +90,19 @@ public void setDefaultChannel(MessageChannel channel) {\n \t@Nullable\n \tpublic Message<?> sendAndReceive(MessageChannel destination, Message<?> requestMessage) {\n \t\tif (!this.throwExceptionOnLateReplySet) {\n-\t\t\tsynchronized (this) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (!this.throwExceptionOnLateReplySet) {\n-\t\t\t\t\tIntegrationProperties integrationProperties =\n-\t\t\t\t\t\t\tIntegrationContextUtils.getIntegrationProperties(this.beanFactory);\n+\t\t\t\t\tIntegrationProperties integrationProperties = IntegrationContextUtils\n+\t\t\t\t\t\t\t.getIntegrationProperties(this.beanFactory);\n \t\t\t\t\tsuper.setThrowExceptionOnLateReply(\n \t\t\t\t\t\t\tintegrationProperties.isMessagingTemplateThrowExceptionOnLateReply());\n \t\t\t\t\tthis.throwExceptionOnLateReplySet = true;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t\treturn super.sendAndReceive(destination, requestMessage);\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/AbstractDispatcher.java b/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/AbstractDispatcher.java\nindex a44984d88c5..f9277568db2 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/AbstractDispatcher.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/AbstractDispatcher.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2020 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,6 +17,8 @@\n package org.springframework.integration.dispatcher;\n \n import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n@@ -41,6 +43,7 @@\n  * @author Gary Russell\n  * @author Diego Belfer\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public abstract class AbstractDispatcher implements MessageDispatcher {\n \n@@ -52,6 +55,8 @@ public abstract class AbstractDispatcher implements MessageDispatcher {\n \n \tprivate volatile MessageHandler theOneHandler;\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \t/**\n \t * Set the maximum subscribers allowed by this dispatcher.\n \t * @param maxSubscribers The maximum number of subscribers allowed.\n@@ -77,17 +82,23 @@ protected Set<MessageHandler> getHandlers() {\n \t * @return the result of {@link Set#add(Object)}\n \t */\n \t@Override\n-\tpublic synchronized boolean addHandler(MessageHandler handler) {\n-\t\tAssert.notNull(handler, \"handler must not be null\");\n-\t\tAssert.isTrue(this.handlers.size() < this.maxSubscribers, \"Maximum subscribers exceeded\");\n-\t\tboolean added = this.handlers.add(handler);\n-\t\tif (this.handlers.size() == 1) {\n-\t\t\tthis.theOneHandler = handler;\n+\tpublic boolean addHandler(MessageHandler handler) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tAssert.notNull(handler, \"handler must not be null\");\n+\t\t\tAssert.isTrue(this.handlers.size() < this.maxSubscribers, \"Maximum subscribers exceeded\");\n+\t\t\tboolean added = this.handlers.add(handler);\n+\t\t\tif (this.handlers.size() == 1) {\n+\t\t\t\tthis.theOneHandler = handler;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.theOneHandler = null;\n+\t\t\t}\n+\t\t\treturn added;\n \t\t}\n-\t\telse {\n-\t\t\tthis.theOneHandler = null;\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\treturn added;\n \t}\n \n \t/**\n@@ -96,16 +107,22 @@ public synchronized boolean addHandler(MessageHandler handler) {\n \t * @return the result of {@link Set#remove(Object)}\n \t */\n \t@Override\n-\tpublic synchronized boolean removeHandler(MessageHandler handler) {\n-\t\tAssert.notNull(handler, \"handler must not be null\");\n-\t\tboolean removed = this.handlers.remove(handler);\n-\t\tif (this.handlers.size() == 1) {\n-\t\t\tthis.theOneHandler = this.handlers.iterator().next();\n+\tpublic boolean removeHandler(MessageHandler handler) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tAssert.notNull(handler, \"handler must not be null\");\n+\t\t\tboolean removed = this.handlers.remove(handler);\n+\t\t\tif (this.handlers.size() == 1) {\n+\t\t\t\tthis.theOneHandler = this.handlers.iterator().next();\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.theOneHandler = null;\n+\t\t\t}\n+\t\t\treturn removed;\n \t\t}\n-\t\telse {\n-\t\t\tthis.theOneHandler = null;\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\treturn removed;\n \t}\n \n \tprotected boolean tryOptimizedDispatch(Message<?> message) {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/PartitionedDispatcher.java b/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/PartitionedDispatcher.java\nindex 1883f190fa1..afb8de28595 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/PartitionedDispatcher.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/PartitionedDispatcher.java\n@@ -25,6 +25,8 @@\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.Function;\n \n import org.springframework.integration.util.ErrorHandlingTaskExecutor;\n@@ -49,6 +51,7 @@\n  * The rest of the logic is similar to {@link UnicastingDispatcher} behavior.\n  *\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 6.1\n  */\n@@ -73,6 +76,8 @@ public class PartitionedDispatcher extends AbstractDispatcher {\n \n \tprivate MessageHandlingTaskDecorator messageHandlingTaskDecorator = task -> task;\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \t/**\n \t * Instantiate based on a provided number of partitions and function for partition key against\n \t * the message to dispatch.\n@@ -153,7 +158,8 @@ public boolean dispatch(Message<?> message) {\n \n \tprivate void populatedPartitions() {\n \t\tif (this.partitions.isEmpty()) {\n-\t\t\tsynchronized (this.partitions) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (this.partitions.isEmpty()) {\n \t\t\t\t\tMap<Integer, UnicastingDispatcher> partitionsToUse = new HashMap<>();\n \t\t\t\t\tfor (int i = 0; i < this.partitionCount; i++) {\n@@ -162,6 +168,9 @@ private void populatedPartitions() {\n \t\t\t\t\tthis.partitions.putAll(partitionsToUse);\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/AbstractPollingEndpoint.java b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/AbstractPollingEndpoint.java\nindex 68cafafc58e..ad8acb75365 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/AbstractPollingEndpoint.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/AbstractPollingEndpoint.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -24,6 +24,8 @@\n import java.util.concurrent.Callable;\n import java.util.concurrent.Executor;\n import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.stream.Collectors;\n \n import org.aopalliance.aop.Advice;\n@@ -78,6 +80,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Andreas Baer\n+ * @author Christian Tzolov\n  */\n public abstract class AbstractPollingEndpoint extends AbstractEndpoint implements BeanClassLoaderAware {\n \n@@ -88,7 +91,7 @@ public abstract class AbstractPollingEndpoint extends AbstractEndpoint implement\n \n \tprivate final Collection<Advice> appliedAdvices = new HashSet<>();\n \n-\tprivate final Object initializationMonitor = new Object();\n+\tprivate final Lock initializationMonitor = new ReentrantLock();\n \n \tprivate Executor taskExecutor = new SyncTaskExecutor();\n \n@@ -262,7 +265,8 @@ protected void setReceiveMessageSource(Object source) {\n \n \t@Override\n \tprotected void onInit() {\n-\t\tsynchronized (this.initializationMonitor) {\n+\t\tthis.initializationMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.initialized) {\n \t\t\t\treturn;\n \t\t\t}\n@@ -280,6 +284,9 @@ protected void onInit() {\n \t\t\t}\n \t\t\tthis.initialized = true;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.initializationMonitor.unlock();\n+\t\t}\n \t\ttry {\n \t\t\tsuper.onInit();\n \t\t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/MethodInvokingMessageSource.java b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/MethodInvokingMessageSource.java\nindex e535ee92e63..f54ee39aaba 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/MethodInvokingMessageSource.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/MethodInvokingMessageSource.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,6 +17,8 @@\n package org.springframework.integration.endpoint;\n \n import java.lang.reflect.Method;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.context.Lifecycle;\n import org.springframework.integration.support.management.ManageableLifecycle;\n@@ -31,6 +33,7 @@\n  * @author Mark Fisher\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class MethodInvokingMessageSource extends AbstractMessageSource<Object> implements ManageableLifecycle {\n \n@@ -42,7 +45,7 @@ public class MethodInvokingMessageSource extends AbstractMessageSource<Object> i\n \n \tprivate volatile boolean initialized;\n \n-\tprivate final Object initializationMonitor = new Object();\n+\tprivate final Lock initializationMonitor = new ReentrantLock();\n \n \n \tpublic void setObject(Object object) {\n@@ -67,7 +70,8 @@ public String getComponentType() {\n \n \t@Override\n \tprotected void onInit() {\n-\t\tsynchronized (this.initializationMonitor) {\n+\t\tthis.initializationMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.initialized) {\n \t\t\t\treturn;\n \t\t\t}\n@@ -83,6 +87,9 @@ protected void onInit() {\n \t\t\tReflectionUtils.makeAccessible(this.method);\n \t\t\tthis.initialized = true;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.initializationMonitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/SourcePollingChannelAdapter.java b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/SourcePollingChannelAdapter.java\nindex 1c4c5090c82..b76b69e76cf 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/SourcePollingChannelAdapter.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/SourcePollingChannelAdapter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,9 @@\n \n package org.springframework.integration.endpoint;\n \n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n import org.springframework.aop.framework.Advised;\n import org.springframework.beans.factory.BeanCreationException;\n import org.springframework.context.Lifecycle;\n@@ -43,6 +46,7 @@\n  * @author Oleg Zhurakousky\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class SourcePollingChannelAdapter extends AbstractPollingEndpoint\n \t\timplements TrackableComponent {\n@@ -59,6 +63,8 @@ public class SourcePollingChannelAdapter extends AbstractPollingEndpoint\n \n \tprivate volatile boolean shouldTrack;\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \t/**\n \t * Specify the source to be polled for Messages.\n \t *\n@@ -175,12 +181,16 @@ protected void onInit() {\n \n \tpublic MessageChannel getOutputChannel() {\n \t\tif (this.outputChannelName != null) {\n-\t\t\tsynchronized (this) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (this.outputChannelName != null) {\n \t\t\t\t\tthis.outputChannel = getChannelResolver().resolveDestination(this.outputChannelName);\n \t\t\t\t\tthis.outputChannelName = null;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t\treturn this.outputChannel;\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/expression/ReloadableResourceBundleExpressionSource.java b/spring-integration-core/src/main/java/org/springframework/integration/expression/ReloadableResourceBundleExpressionSource.java\nindex a9957ca0954..37d3d7fb339 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/expression/ReloadableResourceBundleExpressionSource.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/expression/ReloadableResourceBundleExpressionSource.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -25,6 +25,8 @@\n import java.util.Locale;\n import java.util.Map;\n import java.util.Properties;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n@@ -53,6 +55,7 @@\n  * @author Mark Fisher\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  *\n@@ -80,16 +83,22 @@ public class ReloadableResourceBundleExpressionSource implements ExpressionSourc\n \t */\n \tprivate final Map<String, Map<Locale, List<String>>> cachedFilenames = new HashMap<>();\n \n+\tprivate final Lock cachedFilenamesMonitor = new ReentrantLock();\n+\n \t/**\n \t * Cache to hold already loaded properties per filename.\n \t */\n \tprivate final Map<String, PropertiesHolder> cachedProperties = new HashMap<>();\n \n+\tprivate final Lock cachedPropertiesMonitor = new ReentrantLock();\n+\n \t/**\n \t * Cache to hold merged loaded properties per locale.\n \t */\n \tprivate final Map<Locale, PropertiesHolder> cachedMergedProperties = new HashMap<>();\n \n+\tprivate final Lock cachedMergedPropertiesMonitor = new ReentrantLock();\n+\n \tprivate final ExpressionParser parser = new SpelExpressionParser(new SpelParserConfiguration(true, true));\n \n \tprivate String[] basenames = {};\n@@ -282,7 +291,8 @@ private String getExpressionString(String key, Locale locale) {\n \t * cached forever.\n \t */\n \tprivate PropertiesHolder getMergedProperties(Locale locale) {\n-\t\tsynchronized (this.cachedMergedProperties) {\n+\t\tthis.cachedMergedPropertiesMonitor.lock();\n+\t\ttry {\n \t\t\tPropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale);\n \t\t\tif (mergedHolder != null) {\n \t\t\t\treturn mergedHolder;\n@@ -303,6 +313,9 @@ private PropertiesHolder getMergedProperties(Locale locale) {\n \t\t\tthis.cachedMergedProperties.put(locale, mergedHolder);\n \t\t\treturn mergedHolder;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.cachedMergedPropertiesMonitor.unlock();\n+\t\t}\n \t}\n \n \t/**\n@@ -316,7 +329,8 @@ private PropertiesHolder getMergedProperties(Locale locale) {\n \t * @see #calculateFilenamesForLocale\n \t */\n \tprivate List<String> calculateAllFilenames(String basename, Locale locale) {\n-\t\tsynchronized (this.cachedFilenames) {\n+\t\tthis.cachedFilenamesMonitor.lock();\n+\t\ttry {\n \t\t\tMap<Locale, List<String>> localeMap = this.cachedFilenames.get(basename);\n \t\t\tif (localeMap != null) {\n \t\t\t\tList<String> filenames = localeMap.get(locale);\n@@ -345,6 +359,9 @@ private List<String> calculateAllFilenames(String basename, Locale locale) {\n \t\t\t}\n \t\t\treturn filenames;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.cachedFilenamesMonitor.unlock();\n+\t\t}\n \t}\n \n \t/**\n@@ -392,7 +409,8 @@ private List<String> calculateFilenamesForLocale(String basename, Locale locale)\n \t * @return the current PropertiesHolder for the bundle\n \t */\n \tprivate PropertiesHolder getProperties(String filename) {\n-\t\tsynchronized (this.cachedProperties) {\n+\t\tthis.cachedPropertiesMonitor.lock();\n+\t\ttry {\n \t\t\tPropertiesHolder propHolder = this.cachedProperties.get(filename);\n \t\t\tif (propHolder != null &&\n \t\t\t\t\t(propHolder.getRefreshTimestamp() < 0 ||\n@@ -401,6 +419,9 @@ private PropertiesHolder getProperties(String filename) {\n \t\t\t}\n \t\t\treturn refreshProperties(filename, propHolder);\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.cachedPropertiesMonitor.unlock();\n+\t\t}\n \t}\n \n \t/**\n@@ -539,12 +560,21 @@ private void loadFromProperties(Resource resource, String filename, InputStream\n \t */\n \tpublic void clearCache() {\n \t\tLOGGER.debug(\"Clearing entire resource bundle cache\");\n-\t\tsynchronized (this.cachedProperties) {\n+\t\tthis.cachedPropertiesMonitor.lock();\n+\t\ttry {\n \t\t\tthis.cachedProperties.clear();\n \t\t}\n-\t\tsynchronized (this.cachedMergedProperties) {\n+\t\tfinally {\n+\t\t\tthis.cachedPropertiesMonitor.unlock();\n+\t\t}\n+\n+\t\tthis.cachedMergedPropertiesMonitor.lock();\n+\t\ttry {\n \t\t\tthis.cachedMergedProperties.clear();\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.cachedMergedPropertiesMonitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/gateway/GatewayMessageHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/gateway/GatewayMessageHandler.java\nindex 4293fe14472..76cc64400a7 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/gateway/GatewayMessageHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/gateway/GatewayMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2022 the original author or authors.\n+ * Copyright 2016-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,9 @@\n \n package org.springframework.integration.gateway;\n \n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n import org.springframework.beans.factory.BeanCreationException;\n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n@@ -28,6 +31,7 @@\n  * The {@link AbstractReplyProducingMessageHandler} implementation for mid-flow Gateway.\n  *\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 5.0\n  */\n@@ -39,6 +43,8 @@ public class GatewayMessageHandler extends AbstractReplyProducingMessageHandler\n \n \tprivate volatile boolean running;\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tpublic GatewayMessageHandler() {\n \t\tthis.gatewayProxyFactoryBean = new GatewayProxyFactoryBean<>();\n \t}\n@@ -78,11 +84,15 @@ public void setReplyTimeout(Long replyTimeout) {\n \t@Override\n \tprotected Object handleRequestMessage(Message<?> requestMessage) {\n \t\tif (this.exchanger == null) {\n-\t\t\tsynchronized (this) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (this.exchanger == null) {\n \t\t\t\t\tinitialize();\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t\treturn this.exchanger.exchange(requestMessage);\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/gateway/GatewayProxyFactoryBean.java b/spring-integration-core/src/main/java/org/springframework/integration/gateway/GatewayProxyFactoryBean.java\nindex bdb953d78dc..4e980042932 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/gateway/GatewayProxyFactoryBean.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/gateway/GatewayProxyFactoryBean.java\n@@ -29,6 +29,8 @@\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Executor;\n import java.util.concurrent.Future;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.Consumer;\n import java.util.function.Function;\n import java.util.function.Supplier;\n@@ -106,12 +108,13 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author JingPeng Xie\n+ * @author Christian Tzolov\n  */\n public class GatewayProxyFactoryBean<T> extends AbstractEndpoint\n \t\timplements TrackableComponent, FactoryBean<T>, MethodInterceptor, BeanClassLoaderAware,\n \t\tIntegrationManagement {\n \n-\tprivate final Object initializationMonitor = new Object();\n+\tprivate final Lock initializationMonitor = new ReentrantLock();\n \n \tprivate final Map<Method, MethodInvocationGateway> gatewayMap = new HashMap<>();\n \n@@ -455,7 +458,8 @@ public void registerMetricsCaptor(MetricsCaptor metricsCaptorToRegister) {\n \t@Override\n \t@SuppressWarnings(\"unchecked\")\n \tprotected void onInit() {\n-\t\tsynchronized (this.initializationMonitor) {\n+\t\tthis.initializationMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.initialized) {\n \t\t\t\treturn;\n \t\t\t}\n@@ -466,13 +470,15 @@ protected void onInit() {\n \n \t\t\tpopulateMethodInvocationGateways();\n \n-\t\t\tProxyFactory gatewayProxyFactory =\n-\t\t\t\t\tnew ProxyFactory(this.serviceInterface, this);\n+\t\t\tProxyFactory gatewayProxyFactory = new ProxyFactory(this.serviceInterface, this);\n \t\t\tgatewayProxyFactory.addAdvice(new DefaultMethodInvokingMethodInterceptor());\n \t\t\tthis.serviceProxy = (T) gatewayProxyFactory.getProxy(this.beanClassLoader);\n \t\t\tthis.evaluationContext = ExpressionUtils.createStandardEvaluationContext(beanFactory);\n \t\t\tthis.initialized = true;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.initializationMonitor.unlock();\n+\t\t}\n \t}\n \n \tprivate void populateMethodInvocationGateways() {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java b/spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java\nindex 5f048953637..a8cfcbc3448 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/gateway/MessagingGatewaySupport.java\n@@ -19,6 +19,8 @@\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import io.micrometer.observation.ObservationRegistry;\n import org.reactivestreams.Publisher;\n@@ -86,6 +88,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Trung Pham\n+ * @author Christian Tzolov\n  */\n @IntegrationManagedResource\n public abstract class MessagingGatewaySupport extends AbstractEndpoint\n@@ -99,7 +102,7 @@ public abstract class MessagingGatewaySupport extends AbstractEndpoint\n \tprivate final HistoryWritingMessagePostProcessor historyWritingPostProcessor =\n \t\t\tnew HistoryWritingMessagePostProcessor();\n \n-\tprivate final Object replyMessageCorrelatorMonitor = new Object();\n+\tprivate final Lock replyMessageCorrelatorMonitor = new ReentrantLock();\n \n \tprivate final ManagementOverrides managementOverrides = new ManagementOverrides();\n \n@@ -892,7 +895,8 @@ private RuntimeException wrapExceptionIfNecessary(Throwable t, String descriptio\n \tprotected void registerReplyMessageCorrelatorIfNecessary() {\n \t\tMessageChannel replyChan = getReplyChannel();\n \t\tif (replyChan != null && this.replyMessageCorrelator == null) {\n-\t\t\tsynchronized (this.replyMessageCorrelatorMonitor) {\n+\t\t\tthis.replyMessageCorrelatorMonitor.lock();\n+\t\t\ttry {\n \t\t\t\tif (this.replyMessageCorrelator != null) {\n \t\t\t\t\treturn;\n \t\t\t\t}\n@@ -923,6 +927,9 @@ else if (replyChan instanceof ReactiveStreamsSubscribableChannel) {\n \t\t\t\tcorrelator.afterPropertiesSet();\n \t\t\t\tthis.replyMessageCorrelator = correlator;\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.replyMessageCorrelatorMonitor.unlock();\n+\t\t\t}\n \t\t\tif (isRunning()) {\n \t\t\t\tthis.replyMessageCorrelator.start();\n \t\t\t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/graph/IntegrationGraphServer.java b/spring-integration-core/src/main/java/org/springframework/integration/graph/IntegrationGraphServer.java\nindex 1cd1ecd56ef..1e11a2c8c86 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/graph/IntegrationGraphServer.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/graph/IntegrationGraphServer.java\n@@ -26,6 +26,8 @@\n import java.util.Map.Entry;\n import java.util.Objects;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n@@ -61,6 +63,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 4.3\n  *\n@@ -70,6 +73,8 @@ public class IntegrationGraphServer implements ApplicationContextAware, Applicat\n \n \tprivate static final float GRAPH_VERSION = 1.2f;\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final NodeFactory nodeFactory = new NodeFactory(this::enhance);\n \n \tprivate MicrometerNodeEnhancer micrometerEnhancer;\n@@ -127,12 +132,16 @@ public void onApplicationEvent(ContextRefreshedEvent event) {\n \t * @see #rebuild()\n \t */\n \tpublic Graph getGraph() {\n-\t\tif (this.graph == null) { //NOSONAR (sync)\n-\t\t\tsynchronized (this) {\n+\t\tif (this.graph == null) { // NOSONAR (sync)\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (this.graph == null) {\n \t\t\t\t\tbuildGraph();\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t\treturn this.graph;\n \t}\n@@ -169,35 +178,41 @@ private <T extends IntegrationNode> T enhance(T node) {\n \t\t}\n \t}\n \n-\tprivate synchronized Graph buildGraph() {\n-\t\tif (this.micrometerEnhancer == null && MicrometerMetricsCaptorConfiguration.METER_REGISTRY_PRESENT) {\n-\t\t\tthis.micrometerEnhancer = new MicrometerNodeEnhancer(this.applicationContext);\n-\t\t}\n-\t\tString implementationVersion = IntegrationGraphServer.class.getPackage().getImplementationVersion();\n-\t\tif (implementationVersion == null) {\n-\t\t\timplementationVersion = \"unknown - is Spring Integration running from the distribution jar?\";\n-\t\t}\n-\t\tMap<String, Object> descriptor = new HashMap<>();\n-\t\tdescriptor.put(\"provider\", \"spring-integration\");\n-\t\tdescriptor.put(\"providerVersion\", implementationVersion);\n-\t\tdescriptor.put(\"providerFormatVersion\", GRAPH_VERSION);\n-\t\tString name = this.applicationName;\n-\t\tif (name == null) {\n-\t\t\tname = this.applicationContext.getEnvironment().getProperty(\"spring.application.name\");\n+\tprivate Graph buildGraph() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.micrometerEnhancer == null && MicrometerMetricsCaptorConfiguration.METER_REGISTRY_PRESENT) {\n+\t\t\t\tthis.micrometerEnhancer = new MicrometerNodeEnhancer(this.applicationContext);\n+\t\t\t}\n+\t\t\tString implementationVersion = IntegrationGraphServer.class.getPackage().getImplementationVersion();\n+\t\t\tif (implementationVersion == null) {\n+\t\t\t\timplementationVersion = \"unknown - is Spring Integration running from the distribution jar?\";\n+\t\t\t}\n+\t\t\tMap<String, Object> descriptor = new HashMap<>();\n+\t\t\tdescriptor.put(\"provider\", \"spring-integration\");\n+\t\t\tdescriptor.put(\"providerVersion\", implementationVersion);\n+\t\t\tdescriptor.put(\"providerFormatVersion\", GRAPH_VERSION);\n+\t\t\tString name = this.applicationName;\n+\t\t\tif (name == null) {\n+\t\t\t\tname = this.applicationContext.getEnvironment().getProperty(\"spring.application.name\");\n+\t\t\t}\n+\t\t\tif (name != null) {\n+\t\t\t\tdescriptor.put(\"name\", name);\n+\t\t\t}\n+\t\t\tthis.nodeFactory.reset();\n+\t\t\tCollection<IntegrationNode> nodes = new ArrayList<>();\n+\t\t\tCollection<LinkNode> links = new ArrayList<>();\n+\t\t\tMap<String, MessageChannelNode> channelNodes = channels(nodes);\n+\t\t\tpollingAdapters(nodes, links, channelNodes);\n+\t\t\tgateways(nodes, links, channelNodes);\n+\t\t\tproducers(nodes, links, channelNodes);\n+\t\t\tconsumers(nodes, links, channelNodes);\n+\t\t\tthis.graph = new Graph(descriptor, nodes, links);\n+\t\t\treturn this.graph;\n \t\t}\n-\t\tif (name != null) {\n-\t\t\tdescriptor.put(\"name\", name);\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\tthis.nodeFactory.reset();\n-\t\tCollection<IntegrationNode> nodes = new ArrayList<>();\n-\t\tCollection<LinkNode> links = new ArrayList<>();\n-\t\tMap<String, MessageChannelNode> channelNodes = channels(nodes);\n-\t\tpollingAdapters(nodes, links, channelNodes);\n-\t\tgateways(nodes, links, channelNodes);\n-\t\tproducers(nodes, links, channelNodes);\n-\t\tconsumers(nodes, links, channelNodes);\n-\t\tthis.graph = new Graph(descriptor, nodes, links);\n-\t\treturn this.graph;\n \t}\n \n \tprivate Map<String, MessageChannelNode> channels(Collection<IntegrationNode> nodes) {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractReplyProducingMessageHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractReplyProducingMessageHandler.java\nindex d6134f07764..3a2086e614d 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractReplyProducingMessageHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/handler/AbstractReplyProducingMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,6 +18,8 @@\n \n import java.util.LinkedList;\n import java.util.List;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.aopalliance.aop.Advice;\n \n@@ -41,10 +43,13 @@\n  * @author Artem Bilan\n  * @author David Liu\n  * @author Trung Pham\n+ * @author Christian Tzolov\n  */\n public abstract class AbstractReplyProducingMessageHandler extends AbstractMessageProducingHandler\n \t\timplements BeanClassLoaderAware {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final List<Advice> adviceChain = new LinkedList<>();\n \n \tprivate ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();\n@@ -72,13 +77,17 @@ protected boolean getRequiresReply() {\n \t */\n \tpublic void setAdviceChain(List<Advice> adviceChain) {\n \t\tAssert.notEmpty(adviceChain, \"adviceChain cannot be empty\");\n-\t\tsynchronized (this.adviceChain) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tthis.adviceChain.clear();\n \t\t\tthis.adviceChain.addAll(adviceChain);\n \t\t\tif (isInitialized()) {\n \t\t\t\tinitAdvisedRequestHandlerIfAny();\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \tprotected boolean hasAdviceChain() {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/handler/DelayHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/handler/DelayHandler.java\nindex 74a619faa30..690c1a18a97 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/handler/DelayHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/handler/DelayHandler.java\n@@ -98,6 +98,7 @@\n  * @author Mark Fisher\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n  *\n  * @since 1.0.3\n  */\n@@ -110,6 +111,8 @@ public class DelayHandler extends AbstractReplyProducingMessageHandler implement\n \n \tpublic static final long DEFAULT_RETRY_DELAY = 1_000;\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final ConcurrentMap<String, AtomicInteger> deliveries = new ConcurrentHashMap<>();\n \n \tprivate final Lock removeReleasedMessageLock = new ReentrantLock();\n@@ -618,22 +621,28 @@ public int getDelayedMessageCount() {\n \t * behavior is dictated by the avoidance of invocation thread overload.\n \t */\n \t@Override\n-\tpublic synchronized void reschedulePersistedMessages() {\n-\t\tMessageGroup messageGroup = this.messageStore.getMessageGroup(this.messageGroupId);\n-\t\ttry (Stream<Message<?>> messageStream = messageGroup.streamMessages()) {\n-\t\t\tTaskScheduler taskScheduler = getTaskScheduler();\n-\t\t\tmessageStream.forEach((message) -> // NOSONAR\n-\t\t\t\t\ttaskScheduler.schedule(() -> {\n-\t\t\t\t\t\t// This is fine to keep the reference to the message,\n-\t\t\t\t\t\t// because the scheduled task is performed immediately.\n-\t\t\t\t\t\tlong delay = determineDelayForMessage(message);\n-\t\t\t\t\t\tif (delay > 0) {\n-\t\t\t\t\t\t\treleaseMessageAfterDelay(message, delay);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\treleaseMessage(message);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}, Instant.now()));\n+\tpublic void reschedulePersistedMessages() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tMessageGroup messageGroup = this.messageStore.getMessageGroup(this.messageGroupId);\n+\t\t\ttry (Stream<Message<?>> messageStream = messageGroup.streamMessages()) {\n+\t\t\t\tTaskScheduler taskScheduler = getTaskScheduler();\n+\t\t\t\tmessageStream.forEach((message) -> // NOSONAR\n+\t\t\t\ttaskScheduler.schedule(() -> {\n+\t\t\t\t\t// This is fine to keep the reference to the message,\n+\t\t\t\t\t// because the scheduled task is performed immediately.\n+\t\t\t\t\tlong delay = determineDelayForMessage(message);\n+\t\t\t\t\tif (delay > 0) {\n+\t\t\t\t\t\treleaseMessageAfterDelay(message, delay);\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treleaseMessage(message);\n+\t\t\t\t\t}\n+\t\t\t\t}, Instant.now()));\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/handler/MessageHandlerChain.java b/spring-integration-core/src/main/java/org/springframework/integration/handler/MessageHandlerChain.java\nindex 431a9f8f870..3f08fb285a1 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/handler/MessageHandlerChain.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/handler/MessageHandlerChain.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,6 +20,7 @@\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.context.Lifecycle;\n@@ -66,11 +67,12 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Trung Pham\n+ * @author Christian Tzolov\n  */\n public class MessageHandlerChain extends AbstractMessageProducingHandler\n \t\timplements CompositeMessageHandler, ManageableLifecycle {\n \n-\tprivate final Object initializationMonitor = new Object();\n+\tprivate final Lock initializationMonitor = new ReentrantLock();\n \n \tprivate final ReentrantLock lifecycleLock = new ReentrantLock();\n \n@@ -102,13 +104,17 @@ public IntegrationPatternType getIntegrationPatternType() {\n \t@Override\n \tprotected void onInit() {\n \t\tsuper.onInit();\n-\t\tsynchronized (this.initializationMonitor) {\n+\t\tthis.initializationMonitor.lock();\n+\t\ttry {\n \t\t\tif (!this.initialized) {\n \t\t\t\tAssert.notEmpty(this.handlers, \"handler list must not be empty\");\n \t\t\t\tconfigureChain();\n \t\t\t\tthis.initialized = true;\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.initializationMonitor.unlock();\n+\t\t}\n \t}\n \n \tprivate void configureChain() {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/handler/support/MessagingMethodInvokerHelper.java b/spring-integration-core/src/main/java/org/springframework/integration/handler/support/MessagingMethodInvokerHelper.java\nindex f2b2453ce09..10ea3db87c6 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/handler/support/MessagingMethodInvokerHelper.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/handler/support/MessagingMethodInvokerHelper.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -34,6 +34,8 @@\n import java.util.Properties;\n import java.util.Set;\n import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n@@ -119,6 +121,8 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Trung Pham\n+ * @author Christian Tzolov\n+ *\n  * @since 2.0\n  */\n public class MessagingMethodInvokerHelper extends AbstractExpressionEvaluator implements ManageableLifecycle {\n@@ -160,6 +164,8 @@ public class MessagingMethodInvokerHelper extends AbstractExpressionEvaluator im\n \t\tSPEL_COMPILERS.put(SpelCompilerMode.MIXED, EXPRESSION_PARSER_MIXED);\n \t}\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final Object targetObject;\n \n \tprivate final JsonObjectMapper<?, ?> jsonObjectMapper;\n@@ -486,23 +492,28 @@ private Object processInternal(ParametersWrapper parameters) {\n \t\t}\n \t}\n \n-\tprivate synchronized void initialize() {\n-\t\tif (isProvidedMessageHandlerFactoryBean()) {\n-\t\t\tLOGGER.trace(\"Overriding default instance of MessageHandlerMethodFactory with the one provided.\");\n-\t\t\tthis.messageHandlerMethodFactory =\n-\t\t\t\t\tgetBeanFactory()\n-\t\t\t\t\t\t\t.getBean(\n-\t\t\t\t\t\t\t\t\tthis.canProcessMessageList\n-\t\t\t\t\t\t\t\t\t\t\t? IntegrationContextUtils.LIST_MESSAGE_HANDLER_FACTORY_BEAN_NAME\n-\t\t\t\t\t\t\t\t\t\t\t: IntegrationContextUtils.MESSAGE_HANDLER_FACTORY_BEAN_NAME,\n-\t\t\t\t\t\t\t\t\tMessageHandlerMethodFactory.class);\n+\tprivate void initialize() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (isProvidedMessageHandlerFactoryBean()) {\n+\t\t\t\tLOGGER.trace(\"Overriding default instance of MessageHandlerMethodFactory with the one provided.\");\n+\t\t\t\tthis.messageHandlerMethodFactory = getBeanFactory()\n+\t\t\t\t\t\t.getBean(\n+\t\t\t\t\t\t\t\tthis.canProcessMessageList\n+\t\t\t\t\t\t\t\t\t\t? IntegrationContextUtils.LIST_MESSAGE_HANDLER_FACTORY_BEAN_NAME\n+\t\t\t\t\t\t\t\t\t\t: IntegrationContextUtils.MESSAGE_HANDLER_FACTORY_BEAN_NAME,\n+\t\t\t\t\t\t\t\tMessageHandlerMethodFactory.class);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tconfigureLocalMessageHandlerFactory();\n+\t\t\t}\n+\n+\t\t\tprepareEvaluationContext();\n+\t\t\tthis.initialized = true;\n \t\t}\n-\t\telse {\n-\t\t\tconfigureLocalMessageHandlerFactory();\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\n-\t\tprepareEvaluationContext();\n-\t\tthis.initialized = true;\n \t}\n \n \tprivate boolean isProvidedMessageHandlerFactoryBean() {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/history/MessageHistoryConfigurer.java b/spring-integration-core/src/main/java/org/springframework/integration/history/MessageHistoryConfigurer.java\nindex 721fffe5fdb..18e3a96af8f 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/history/MessageHistoryConfigurer.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/history/MessageHistoryConfigurer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,6 +20,8 @@\n import java.util.Collection;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n@@ -44,6 +46,7 @@\n  * @author Mark Fisher\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n@@ -54,6 +57,8 @@ public class MessageHistoryConfigurer implements ManageableSmartLifecycle, BeanF\n \n \tprivate static final Log LOGGER = LogFactory.getLog(MessageHistoryConfigurer.class);\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final Set<TrackableComponent> currentlyTrackedComponents = ConcurrentHashMap.newKeySet();\n \n \tprivate String[] componentNamePatterns = {\"*\"};\n@@ -180,7 +185,8 @@ public int getPhase() {\n \t@ManagedOperation\n \t@Override\n \tpublic void start() {\n-\t\tsynchronized (this.currentlyTrackedComponents) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tif (!this.running) {\n \t\t\t\tfor (TrackableComponent component : getTrackableComponents(this.beanFactory)) {\n \t\t\t\t\ttrackComponentIfAny(component);\n@@ -188,12 +194,16 @@ public void start() {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@ManagedOperation\n \t@Override\n \tpublic void stop() {\n-\t\tsynchronized (this.currentlyTrackedComponents) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tif (this.running) {\n \t\t\t\tthis.currentlyTrackedComponents.forEach(component -> {\n \t\t\t\t\tcomponent.setShouldTrack(false);\n@@ -207,6 +217,9 @@ public void stop() {\n \t\t\t\tthis.running = false;\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \tprivate static Collection<TrackableComponent> getTrackableComponents(ListableBeanFactory beanFactory) {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java b/spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java\nindex f412c9ad386..2a89d13dabb 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/router/AbstractMessageRouter.java\n@@ -18,6 +18,8 @@\n \n import java.util.Collection;\n import java.util.UUID;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.core.convert.ConversionService;\n@@ -43,11 +45,14 @@\n  * @author Soby Chacko\n  * @author Stefan Ferstl\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n @ManagedResource\n @IntegrationManagedResource\n public abstract class AbstractMessageRouter extends AbstractMessageHandler implements MessageRouter {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final MessagingTemplate messagingTemplate = new MessagingTemplate();\n \n \tprivate volatile MessageChannel defaultOutputChannel;\n@@ -83,12 +88,16 @@ public void setDefaultOutputChannel(MessageChannel defaultOutputChannel) {\n \t@Override\n \tpublic MessageChannel getDefaultOutputChannel() {\n \t\tif (this.defaultOutputChannelName != null) {\n-\t\t\tsynchronized (this) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (this.defaultOutputChannelName != null) {\n \t\t\t\t\tthis.defaultOutputChannel = getChannelResolver().resolveDestination(this.defaultOutputChannelName);\n \t\t\t\t\tthis.defaultOutputChannelName = null;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t\treturn this.defaultOutputChannel;\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/selector/MessageSelectorChain.java b/spring-integration-core/src/main/java/org/springframework/integration/selector/MessageSelectorChain.java\nindex f4824fc7f39..b3faa24eaa4 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/selector/MessageSelectorChain.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/selector/MessageSelectorChain.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,6 +18,8 @@\n \n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.integration.core.MessageSelector;\n import org.springframework.messaging.Message;\n@@ -32,9 +34,12 @@\n  * @author Mark Fisher\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class MessageSelectorChain implements MessageSelector {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate volatile VotingStrategy votingStrategy = VotingStrategy.ALL;\n \n \tprivate final List<MessageSelector> selectors = new CopyOnWriteArrayList<>();\n@@ -72,10 +77,14 @@ public void add(int index, MessageSelector selector) {\n \t */\n \tpublic void setSelectors(List<MessageSelector> selectors) {\n \t\tAssert.notEmpty(selectors, \"selectors must not be empty\");\n-\t\tsynchronized (this.selectors) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tthis.selectors.clear();\n \t\t\tthis.selectors.addAll(selectors);\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t/**\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/selector/MetadataStoreSelector.java b/spring-integration-core/src/main/java/org/springframework/integration/selector/MetadataStoreSelector.java\nindex 4ec2ac066e5..094973a8060 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/selector/MetadataStoreSelector.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/selector/MetadataStoreSelector.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2020 the original author or authors.\n+ * Copyright 2014-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,8 @@\n \n package org.springframework.integration.selector;\n \n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.BiPredicate;\n \n import org.springframework.integration.core.MessageSelector;\n@@ -50,11 +52,14 @@\n  *\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n  *\n  * @since 4.1\n  */\n public class MetadataStoreSelector implements MessageSelector {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final ConcurrentMetadataStore metadataStore;\n \n \tprivate final MessageProcessor<String> keyStrategy;\n@@ -119,7 +124,8 @@ public boolean accept(Message<?> message) {\n \t\t\treturn this.metadataStore.putIfAbsent(key, value) == null;\n \t\t}\n \t\telse {\n-\t\t\tsynchronized (this) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tString oldValue = this.metadataStore.get(key);\n \t\t\t\tif (oldValue == null) {\n \t\t\t\t\treturn this.metadataStore.putIfAbsent(key, value) == null;\n@@ -129,6 +135,9 @@ public boolean accept(Message<?> message) {\n \t\t\t\t}\n \t\t\t\treturn false;\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/store/AbstractMessageGroupStore.java b/spring-integration-core/src/main/java/org/springframework/integration/store/AbstractMessageGroupStore.java\nindex bb9c7cc727b..8496a51bf1a 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/store/AbstractMessageGroupStore.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/store/AbstractMessageGroupStore.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,6 +19,8 @@\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.LinkedHashSet;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n@@ -33,6 +35,7 @@\n  * @author Oleg Zhurakousky\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n@@ -42,6 +45,8 @@ public abstract class AbstractMessageGroupStore extends AbstractBatchingMessageG\n \n \tprotected final Log logger = LogFactory.getLog(getClass()); // NOSONAR final\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final Collection<MessageGroupCallback> expiryCallbacks = new LinkedHashSet<>();\n \n \tprivate final MessageGroupFactory persistentMessageGroupFactory =\n@@ -122,22 +127,28 @@ public void registerMessageGroupExpiryCallback(MessageGroupCallback callback) {\n \n \t@Override\n \t@ManagedOperation\n-\tpublic synchronized int expireMessageGroups(long timeout) {\n-\t\tint count = 0;\n-\t\tlong threshold = System.currentTimeMillis() - timeout;\n-\t\tfor (MessageGroup group : this) {\n-\n-\t\t\tlong timestamp = group.getTimestamp();\n-\t\t\tif (this.isTimeoutOnIdle() && group.getLastModified() > 0) {\n-\t\t\t\ttimestamp = group.getLastModified();\n-\t\t\t}\n+\tpublic int expireMessageGroups(long timeout) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tint count = 0;\n+\t\t\tlong threshold = System.currentTimeMillis() - timeout;\n+\t\t\tfor (MessageGroup group : this) {\n+\n+\t\t\t\tlong timestamp = group.getTimestamp();\n+\t\t\t\tif (this.isTimeoutOnIdle() && group.getLastModified() > 0) {\n+\t\t\t\t\ttimestamp = group.getLastModified();\n+\t\t\t\t}\n \n-\t\t\tif (timestamp <= threshold) {\n-\t\t\t\tcount++;\n-\t\t\t\texpire(copy(group));\n+\t\t\t\tif (timestamp <= threshold) {\n+\t\t\t\t\tcount++;\n+\t\t\t\t\texpire(copy(group));\n+\t\t\t\t}\n \t\t\t}\n+\t\t\treturn count;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\treturn count;\n \t}\n \n \t/**\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/store/PersistentMessageGroup.java b/spring-integration-core/src/main/java/org/springframework/integration/store/PersistentMessageGroup.java\nindex 4e1cd00efb4..68e245a4f17 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/store/PersistentMessageGroup.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/store/PersistentMessageGroup.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2021 the original author or authors.\n+ * Copyright 2016-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,6 +21,8 @@\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.Spliterator;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.stream.Stream;\n \n import org.apache.commons.logging.Log;\n@@ -32,6 +34,7 @@\n \n /**\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 4.3\n  */\n@@ -39,6 +42,8 @@ class PersistentMessageGroup implements MessageGroup {\n \n \tprivate static final Log LOGGER = LogFactory.getLog(PersistentMessageGroup.class);\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final MessageGroupStore messageGroupStore;\n \n \tprivate final Collection<Message<?>> messages = new PersistentCollection();\n@@ -76,7 +81,8 @@ public Stream<Message<?>> streamMessages() {\n \t@Override\n \tpublic Message<?> getOne() {\n \t\tif (this.oneMessage == null) {\n-\t\t\tsynchronized (this) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (this.oneMessage == null) {\n \t\t\t\t\tif (LOGGER.isDebugEnabled()) {\n \t\t\t\t\t\tLOGGER.debug(\"Lazy loading of one message for messageGroup: \" + this.original.getGroupId());\n@@ -84,6 +90,9 @@ public Message<?> getOne() {\n \t\t\t\t\tthis.oneMessage = this.messageGroupStore.getOneMessageFromGroup(this.original.getGroupId());\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t\treturn this.oneMessage;\n \t}\n@@ -109,7 +118,8 @@ public int getSequenceSize() {\n \t@Override\n \tpublic int size() {\n \t\tif (this.size == 0) {\n-\t\t\tsynchronized (this) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (this.size == 0) {\n \t\t\t\t\tif (LOGGER.isDebugEnabled()) {\n \t\t\t\t\t\tLOGGER.debug(\"Lazy loading of group size for messageGroup: \" + this.original.getGroupId());\n@@ -117,6 +127,9 @@ public int size() {\n \t\t\t\t\tthis.size = this.messageGroupStore.messageGroupSize(this.original.getGroupId());\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t\treturn this.size;\n \t}\n@@ -195,6 +208,8 @@ public void clear() {\n \n \tprivate final class PersistentCollection extends AbstractCollection<Message<?>> {\n \n+\t\tprivate final Lock innerLock = new ReentrantLock();\n+\n \t\tprivate volatile Collection<Message<?>> collection;\n \n \t\tPersistentCollection() {\n@@ -202,7 +217,8 @@ private final class PersistentCollection extends AbstractCollection<Message<?>>\n \n \t\tprivate void load() {\n \t\t\tif (this.collection == null) {\n-\t\t\t\tsynchronized (this) {\n+\t\t\t\tthis.innerLock.lock();\n+\t\t\t\ttry {\n \t\t\t\t\tif (this.collection == null) {\n \t\t\t\t\t\tObject groupId = PersistentMessageGroup.this.original.getGroupId();\n \t\t\t\t\t\tif (LOGGER.isDebugEnabled()) {\n@@ -211,6 +227,9 @@ private void load() {\n \t\t\t\t\t\tthis.collection = PersistentMessageGroup.this.messageGroupStore.getMessagesForGroup(groupId);\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\tthis.innerLock.unlock();\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/store/SimpleMessageGroup.java b/spring-integration-core/src/main/java/org/springframework/integration/store/SimpleMessageGroup.java\nindex dc48b6e7252..2b878ef991e 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/store/SimpleMessageGroup.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/store/SimpleMessageGroup.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -22,6 +22,8 @@\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.integration.IntegrationMessageHeaderAccessor;\n import org.springframework.lang.Nullable;\n@@ -38,11 +40,14 @@\n  * @author Dave Syer\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n public class SimpleMessageGroup implements MessageGroup {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final Object groupId;\n \n \tprivate final Collection<Message<?>> messages;\n@@ -189,10 +194,14 @@ public String getCondition() {\n \n \t@Override\n \tpublic Message<?> getOne() {\n-\t\tsynchronized (this.messages) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tIterator<Message<?>> iterator = this.messages.iterator();\n \t\t\treturn iterator.hasNext() ? iterator.next() : null;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/support/SmartLifecycleRoleController.java b/spring-integration-core/src/main/java/org/springframework/integration/support/SmartLifecycleRoleController.java\nindex e122610a42c..5e4c72d6bae 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/support/SmartLifecycleRoleController.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/support/SmartLifecycleRoleController.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2015-2021 the original author or authors.\n+ * Copyright 2015-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -24,6 +24,8 @@\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n@@ -52,6 +54,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 4.2\n  *\n@@ -63,6 +66,8 @@ public class SmartLifecycleRoleController implements ApplicationListener<Abstrac\n \n \tprivate static final String IN_ROLE = \" in role \";\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final MultiValueMap<String, SmartLifecycle> lifecycles = new LinkedMultiValueMap<>();\n \n \tprivate final MultiValueMap<String, String> lazyLifecycles = new LinkedMultiValueMap<>();\n@@ -283,9 +288,15 @@ public Map<String, Boolean> getEndpointsRunningStatus(String role) {\n \t\t\t\t\t\tLifecycle::isRunning));\n \t}\n \n-\tprivate synchronized void addLazyLifecycles() {\n-\t\tthis.lazyLifecycles.forEach(this::doAddLifecyclesToRole);\n-\t\tthis.lazyLifecycles.clear();\n+\tprivate void addLazyLifecycles() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tthis.lazyLifecycles.forEach(this::doAddLifecyclesToRole);\n+\t\t\tthis.lazyLifecycles.clear();\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \tprivate void doAddLifecyclesToRole(String role, List<String> lifecycleBeanNames) {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/support/channel/BeanFactoryChannelResolver.java b/spring-integration-core/src/main/java/org/springframework/integration/support/channel/BeanFactoryChannelResolver.java\nindex 1817685c692..30428f34e37 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/support/channel/BeanFactoryChannelResolver.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/support/channel/BeanFactoryChannelResolver.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,9 @@\n \n package org.springframework.integration.support.channel;\n \n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n \n@@ -39,6 +42,7 @@\n  * @author Mark Fisher\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @see BeanFactory\n  */\n@@ -46,6 +50,8 @@ public class BeanFactoryChannelResolver implements DestinationResolver<MessageCh\n \n \tprivate static final Log LOGGER = LogFactory.getLog(BeanFactoryChannelResolver.class);\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate BeanFactory beanFactory;\n \n \tprivate HeaderChannelRegistry replyChannelRegistry;\n@@ -93,12 +99,12 @@ public MessageChannel resolveDestination(String name) {\n \t\t\t\t\t\t+ name + \"' exists, but failed to be created\", e);\n \t\t\t}\n \t\t\tif (!this.initialized) {\n-\t\t\t\tsynchronized (this) {\n+\t\t\t\tthis.lock.lock();\n+\t\t\t\ttry {\n \t\t\t\t\tif (!this.initialized) {\n \t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tthis.replyChannelRegistry =\n-\t\t\t\t\t\t\t\t\tthis.beanFactory.getBean(\"integrationHeaderChannelRegistry\",\n-\t\t\t\t\t\t\t\t\t\t\tHeaderChannelRegistry.class);\n+\t\t\t\t\t\t\tthis.replyChannelRegistry = this.beanFactory.getBean(\"integrationHeaderChannelRegistry\",\n+\t\t\t\t\t\t\t\t\tHeaderChannelRegistry.class);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tLOGGER.debug(\"No HeaderChannelRegistry found\");\n@@ -106,6 +112,9 @@ public MessageChannel resolveDestination(String name) {\n \t\t\t\t\t\tthis.initialized = true;\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\tthis.lock.unlock();\n+\t\t\t\t}\n \t\t\t}\n \t\t\tif (this.replyChannelRegistry != null) {\n \t\t\t\tMessageChannel channel = this.replyChannelRegistry.channelNameToChannel(name);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiator.java b/spring-integration-core/src/main/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiator.java\nindex 777dbdf3012..a20f0f9d9fd 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiator.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiator.java\n@@ -21,6 +21,7 @@\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.beans.factory.DisposableBean;\n import org.springframework.context.ApplicationEventPublisher;\n@@ -56,6 +57,7 @@\n  * @author Glenn Renfro\n  * @author Kiel Boatman\n  * @author Gary Russell\n+ * @author Christian Tzolov\n  *\n  * @since 4.3.1\n  */\n@@ -68,6 +70,8 @@ public class LockRegistryLeaderInitiator implements SmartLifecycle, DisposableBe\n \n \tprivate static final LogAccessor LOGGER = new LogAccessor(LockRegistryLeaderInitiator.class);\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \t/**\n \t * A lock registry. The locks it manages should be global (whatever that means for the\n \t * system) and expiring, in case the holder dies without notifying anyone.\n@@ -286,15 +290,21 @@ public void setPublishFailedEvents(boolean publishFailedEvents) {\n \t * Start the registration of the {@link #candidate} for leader election.\n \t */\n \t@Override\n-\tpublic synchronized void start() {\n-\t\tif (this.leaderEventPublisher == null && this.applicationEventPublisher != null) {\n-\t\t\tthis.leaderEventPublisher = new DefaultLeaderEventPublisher(this.applicationEventPublisher);\n+\tpublic void start() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.leaderEventPublisher == null && this.applicationEventPublisher != null) {\n+\t\t\t\tthis.leaderEventPublisher = new DefaultLeaderEventPublisher(this.applicationEventPublisher);\n+\t\t\t}\n+\t\t\tif (!this.running) {\n+\t\t\t\tthis.leaderSelector = new LeaderSelector(buildLeaderPath());\n+\t\t\t\tthis.running = true;\n+\t\t\t\tthis.future = this.taskExecutor.submit(this.leaderSelector);\n+\t\t\t\tLOGGER.debug(\"Started LeaderInitiator\");\n+\t\t\t}\n \t\t}\n-\t\tif (!this.running) {\n-\t\t\tthis.leaderSelector = new LeaderSelector(buildLeaderPath());\n-\t\t\tthis.running = true;\n-\t\t\tthis.future = this.taskExecutor.submit(this.leaderSelector);\n-\t\t\tLOGGER.debug(\"Started LeaderInitiator\");\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n@@ -308,14 +318,20 @@ public void destroy() {\n \t * candidate is currently leader, its leadership will be revoked.\n \t */\n \t@Override\n-\tpublic synchronized void stop() {\n-\t\tif (this.running) {\n-\t\t\tthis.running = false;\n-\t\t\tif (this.future != null) {\n-\t\t\t\tthis.future.cancel(true);\n+\tpublic void stop() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.running) {\n+\t\t\t\tthis.running = false;\n+\t\t\t\tif (this.future != null) {\n+\t\t\t\t\tthis.future.cancel(true);\n+\t\t\t\t}\n+\t\t\t\tthis.future = null;\n+\t\t\t\tLOGGER.debug(() -> \"Stopped LeaderInitiator for \" + getContext());\n \t\t\t}\n-\t\t\tthis.future = null;\n-\t\t\tLOGGER.debug(() -> \"Stopped LeaderInitiator for \" + getContext());\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/transformer/support/RoutingSlipHeaderValueMessageProcessor.java b/spring-integration-core/src/main/java/org/springframework/integration/transformer/support/RoutingSlipHeaderValueMessageProcessor.java\nindex b5277da2173..e554157f864 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/transformer/support/RoutingSlipHeaderValueMessageProcessor.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/transformer/support/RoutingSlipHeaderValueMessageProcessor.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2019 the original author or authors.\n+ * Copyright 2014-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,6 +21,8 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.beans.BeansException;\n import org.springframework.beans.factory.BeanFactory;\n@@ -41,12 +43,16 @@\n  *\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n+ *\n  * @since 4.1\n  */\n public class RoutingSlipHeaderValueMessageProcessor\n \t\textends AbstractHeaderValueMessageProcessor<Map<List<Object>, Integer>>\n \t\timplements BeanFactoryAware {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final List<Object> routingSlipPath;\n \n \tprivate volatile Map<List<Object>, Integer> routingSlip;\n@@ -79,7 +85,8 @@ public Map<List<Object>, Integer> processMessage(Message<?> message) {\n \t\t// use a local variable to avoid the second access to volatile field on the happy path\n \t\tMap<List<Object>, Integer> slip = this.routingSlip;\n \t\tif (slip == null) {\n-\t\t\tsynchronized (this) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tslip = this.routingSlip;\n \t\t\t\tif (slip == null) {\n \t\t\t\t\tList<Object> slipPath = this.routingSlipPath;\n@@ -118,6 +125,9 @@ public Map<List<Object>, Integer> processMessage(Message<?> message) {\n \t\t\t\t\tthis.routingSlip = slip;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t\treturn slip;\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/util/AcceptOnceCollectionFilter.java b/spring-integration-core/src/main/java/org/springframework/integration/util/AcceptOnceCollectionFilter.java\nindex 3506ddf74a8..26e49a9cff0 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/util/AcceptOnceCollectionFilter.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/util/AcceptOnceCollectionFilter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,6 +20,8 @@\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n /**\n  * An implementation of {@link CollectionFilter} that remembers the elements passed in\n@@ -28,6 +30,7 @@\n  * @param <T> the collection element type.\n  *\n  * @author Mark Fisher\n+ * @author Christian Tzolov\n  *\n  * @since 2.1\n  */\n@@ -35,15 +38,23 @@ public class AcceptOnceCollectionFilter<T> implements CollectionFilter<T> {\n \n \tprivate volatile Collection<T> lastSeenElements = Collections.emptyList();\n \n-\tpublic synchronized Collection<T> filter(Collection<T> unfilteredElements) {\n-\t\tList<T> filteredElements = new ArrayList<>();\n-\t\tfor (T element : unfilteredElements) {\n-\t\t\tif (!this.lastSeenElements.contains(element)) {\n-\t\t\t\tfilteredElements.add(element);\n+\tprivate final Lock lock = new ReentrantLock();\n+\n+\tpublic Collection<T> filter(Collection<T> unfilteredElements) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tList<T> filteredElements = new ArrayList<>();\n+\t\t\tfor (T element : unfilteredElements) {\n+\t\t\t\tif (!this.lastSeenElements.contains(element)) {\n+\t\t\t\t\tfilteredElements.add(element);\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tthis.lastSeenElements = unfilteredElements;\n+\t\t\treturn filteredElements;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\tthis.lastSeenElements = unfilteredElements;\n-\t\treturn filteredElements;\n \t}\n \n }\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/util/SimplePool.java b/spring-integration-core/src/main/java/org/springframework/integration/util/SimplePool.java\nindex 1154d54e14a..1658ff8c636 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/util/SimplePool.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/util/SimplePool.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -24,6 +24,8 @@\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n@@ -40,6 +42,7 @@\n  * @author Gary Russell\n  * @author Sergey Bogatyrev\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.2\n  *\n@@ -48,6 +51,8 @@ public class SimplePool<T> implements Pool<T> {\n \n \tprotected final Log logger = LogFactory.getLog(getClass()); // NOSONAR final\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final PoolSemaphore permits = new PoolSemaphore(0);\n \n \tprivate final AtomicInteger poolSize = new AtomicInteger();\n@@ -93,40 +98,46 @@ public SimplePool(int poolSize, PoolItemCallback<T> callback) {\n \t * items are returned.\n \t * @param poolSize The desired target pool size.\n \t */\n-\tpublic synchronized void setPoolSize(int poolSize) {\n-\t\tint delta = poolSize - this.poolSize.get();\n-\t\tthis.targetPoolSize.addAndGet(delta);\n-\t\tif (this.logger.isDebugEnabled()) {\n-\t\t\tthis.logger.debug(String.format(\"Target pool size changed by %d, now %d\", delta,\n-\t\t\t\t\tthis.targetPoolSize.get()));\n-\t\t}\n-\t\tif (delta > 0) {\n-\t\t\tthis.poolSize.addAndGet(delta);\n-\t\t\tthis.permits.release(delta);\n-\t\t}\n-\t\telse {\n-\t\t\tthis.permits.reducePermits(-delta);\n-\n-\t\t\tint inUseSize = this.inUse.size();\n-\t\t\tint newPoolSize = Math.max(poolSize, inUseSize);\n-\t\t\tthis.poolSize.set(newPoolSize);\n-\n-\t\t\tfor (int i = this.available.size(); i > newPoolSize - inUseSize; i--) {\n-\t\t\t\tT item = this.available.poll();\n-\t\t\t\tif (item != null) {\n-\t\t\t\t\tdoRemoveItem(item);\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tpublic void setPoolSize(int poolSize) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tint delta = poolSize - this.poolSize.get();\n+\t\t\tthis.targetPoolSize.addAndGet(delta);\n+\t\t\tif (this.logger.isDebugEnabled()) {\n+\t\t\t\tthis.logger.debug(String.format(\"Target pool size changed by %d, now %d\", delta,\n+\t\t\t\t\t\tthis.targetPoolSize.get()));\n \t\t\t}\n+\t\t\tif (delta > 0) {\n+\t\t\t\tthis.poolSize.addAndGet(delta);\n+\t\t\t\tthis.permits.release(delta);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.permits.reducePermits(-delta);\n+\n+\t\t\t\tint inUseSize = this.inUse.size();\n+\t\t\t\tint newPoolSize = Math.max(poolSize, inUseSize);\n+\t\t\t\tthis.poolSize.set(newPoolSize);\n+\n+\t\t\t\tfor (int i = this.available.size(); i > newPoolSize - inUseSize; i--) {\n+\t\t\t\t\tT item = this.available.poll();\n+\t\t\t\t\tif (item != null) {\n+\t\t\t\t\t\tdoRemoveItem(item);\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n \n-\t\t\tint inUseDelta = poolSize - inUseSize;\n-\t\t\tif (inUseDelta < 0 && this.logger.isDebugEnabled()) {\n-\t\t\t\tthis.logger.debug(String.format(\"Pool is overcommitted by %d; items will be removed when returned\",\n-\t\t\t\t\t\t-inUseDelta));\n+\t\t\t\tint inUseDelta = poolSize - inUseSize;\n+\t\t\t\tif (inUseDelta < 0 && this.logger.isDebugEnabled()) {\n+\t\t\t\t\tthis.logger.debug(String.format(\"Pool is overcommitted by %d; items will be removed when returned\",\n+\t\t\t\t\t\t\t-inUseDelta));\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t/**\n@@ -135,8 +146,14 @@ public synchronized void setPoolSize(int poolSize) {\n \t * to be set.\n \t */\n \t@Override\n-\tpublic synchronized int getPoolSize() {\n-\t\treturn this.poolSize.get();\n+\tpublic int getPoolSize() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\treturn this.poolSize.get();\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n@@ -224,36 +241,48 @@ else if (this.callback.isStale(item)) {\n \t * Return an item to the pool.\n \t */\n \t@Override\n-\tpublic synchronized void releaseItem(T item) {\n-\t\tAssert.notNull(item, \"Item cannot be null\");\n-\t\tAssert.isTrue(this.allocated.contains(item),\n-\t\t\t\t\"You can only release items that were obtained from the pool\");\n-\t\tif (this.inUse.contains(item)) {\n-\t\t\tif (this.poolSize.get() > this.targetPoolSize.get() || this.closed) {\n-\t\t\t\tthis.poolSize.decrementAndGet();\n-\t\t\t\tdoRemoveItem(item);\n+\tpublic void releaseItem(T item) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tAssert.notNull(item, \"Item cannot be null\");\n+\t\t\tAssert.isTrue(this.allocated.contains(item),\n+\t\t\t\t\t\"You can only release items that were obtained from the pool\");\n+\t\t\tif (this.inUse.contains(item)) {\n+\t\t\t\tif (this.poolSize.get() > this.targetPoolSize.get() || this.closed) {\n+\t\t\t\t\tthis.poolSize.decrementAndGet();\n+\t\t\t\t\tdoRemoveItem(item);\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tif (this.logger.isDebugEnabled()) {\n+\t\t\t\t\t\tthis.logger.debug(\"Releasing \" + item + \" back to the pool\");\n+\t\t\t\t\t}\n+\t\t\t\t\tthis.available.add(item);\n+\t\t\t\t\tthis.inUse.remove(item);\n+\t\t\t\t\tthis.permits.release();\n+\t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif (this.logger.isDebugEnabled()) {\n-\t\t\t\t\tthis.logger.debug(\"Releasing \" + item + \" back to the pool\");\n+\t\t\t\t\tthis.logger.debug(\"Ignoring release of \" + item + \" back to the pool - not in use\");\n \t\t\t\t}\n-\t\t\t\tthis.available.add(item);\n-\t\t\t\tthis.inUse.remove(item);\n-\t\t\t\tthis.permits.release();\n \t\t\t}\n \t\t}\n-\t\telse {\n-\t\t\tif (this.logger.isDebugEnabled()) {\n-\t\t\t\tthis.logger.debug(\"Ignoring release of \" + item + \" back to the pool - not in use\");\n-\t\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n \t@Override\n-\tpublic synchronized void removeAllIdleItems() {\n-\t\tT item;\n-\t\twhile ((item = this.available.poll()) != null) {\n-\t\t\tdoRemoveItem(item);\n+\tpublic void removeAllIdleItems() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tT item;\n+\t\t\twhile ((item = this.available.poll()) != null) {\n+\t\t\t\tdoRemoveItem(item);\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n@@ -267,9 +296,15 @@ private void doRemoveItem(T item) {\n \t}\n \n \t@Override\n-\tpublic synchronized void close() {\n-\t\tthis.closed = true;\n-\t\tremoveAllIdleItems();\n+\tpublic void close() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tthis.closed = true;\n+\t\t\tremoveAllIdleItems();\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@SuppressWarnings(\"serial\")\n\ndiff --git a/spring-integration-feed/src/main/java/org/springframework/integration/feed/inbound/FeedEntryMessageSource.java b/spring-integration-feed/src/main/java/org/springframework/integration/feed/inbound/FeedEntryMessageSource.java\nindex bb3c0978d9e..229451fc4ec 100644\n--- a/spring-integration-feed/src/main/java/org/springframework/integration/feed/inbound/FeedEntryMessageSource.java\n+++ b/spring-integration-feed/src/main/java/org/springframework/integration/feed/inbound/FeedEntryMessageSource.java\n@@ -28,6 +28,8 @@\n import java.util.List;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import com.rometools.rome.feed.synd.SyndEntry;\n import com.rometools.rome.feed.synd.SyndFeed;\n@@ -56,6 +58,7 @@\n  * @author Oleg Zhurakousky\n  * @author Artem Bilan\n  * @author Aaron Loes\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n@@ -69,13 +72,13 @@ public class FeedEntryMessageSource extends AbstractMessageSource<SyndEntry> {\n \n \tprivate final Queue<SyndEntry> entries = new ConcurrentLinkedQueue<>();\n \n-\tprivate final Object monitor = new Object();\n+\tprivate final Lock monitor = new ReentrantLock();\n \n \tprivate final Comparator<SyndEntry> syndEntryComparator =\n \t\t\tComparator.comparing(FeedEntryMessageSource::getLastModifiedDate,\n \t\t\t\t\tComparator.nullsFirst(Comparator.naturalOrder()));\n \n-\tprivate final Object feedMonitor = new Object();\n+\tprivate final Lock feedMonitor = new ReentrantLock();\n \n \tprivate SyndFeedInput syndFeedInput = new SyndFeedInput();\n \n@@ -176,7 +179,8 @@ protected SyndEntry doReceive() {\n \t\tAssert.isTrue(this.initialized,\n \t\t\t\t\"'FeedEntryReaderMessageSource' must be initialized before it can produce Messages.\");\n \t\tSyndEntry nextEntry;\n-\t\tsynchronized (this.monitor) {\n+\t\tthis.monitor.lock();\n+\t\ttry {\n \t\t\tnextEntry = getNextEntry();\n \t\t\tif (nextEntry == null) {\n \t\t\t\t// read feed and try again\n@@ -184,6 +188,9 @@ protected SyndEntry doReceive() {\n \t\t\t\tnextEntry = getNextEntry();\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.monitor.unlock();\n+\t\t}\n \t\treturn nextEntry;\n \t}\n \n@@ -225,7 +232,8 @@ private void populateEntryList() {\n \n \tprivate SyndFeed getFeed() {\n \t\ttry {\n-\t\t\tsynchronized (this.feedMonitor) {\n+\t\t\tthis.feedMonitor.lock();\n+\t\t\ttry {\n \t\t\t\tSyndFeed feed = buildSyndFeed();\n \t\t\t\tlogger.debug(() -> \"Retrieved feed for [\" + this + \"]\");\n \t\t\t\tif (feed == null) {\n@@ -233,6 +241,9 @@ private SyndFeed getFeed() {\n \t\t\t\t}\n \t\t\t\treturn feed;\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.feedMonitor.unlock();\n+\t\t\t}\n \t\t}\n \t\tcatch (Exception e) {\n \t\t\tthrow new MessagingException(\"Failed to retrieve feed for '\" + this + \"'\", e);\n\ndiff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java b/spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java\nindex a8b7bad8e40..66225d26c26 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/FileWritingMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -40,6 +40,7 @@\n import java.util.Set;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.BiConsumer;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n@@ -109,6 +110,7 @@\n  * @author Tony Falabella\n  * @author Alen Turkovic\n  * @author Trung Pham\n+ * @author Christian Tzolov\n  */\n public class FileWritingMessageHandler extends AbstractReplyProducingMessageHandler\n \t\timplements ManageableLifecycle, MessageTriggerAction {\n@@ -130,6 +132,8 @@ public class FileWritingMessageHandler extends AbstractReplyProducingMessageHand\n \t\t\t\t\tPosixFilePermission.OWNER_READ\n \t\t\t};\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final Map<String, FileState> fileStates = new HashMap<>();\n \n \tprivate final Expression destinationDirectoryExpression;\n@@ -459,12 +463,16 @@ public void start() {\n \n \t@Override\n \tpublic void stop() {\n-\t\tsynchronized (this) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tif (this.flushTask != null) {\n \t\t\t\tthis.flushTask.cancel(true);\n \t\t\t\tthis.flushTask = null;\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t\tFlusher flusher = new Flusher();\n \t\tflusher.run();\n \t\tboolean needInterrupt = this.fileStates.size() > 0;\n@@ -873,37 +881,42 @@ private File evaluateDestinationDirectoryExpression(Message<?> message) {\n \t\treturn destinationDirectory;\n \t}\n \n-\tprivate synchronized FileState getFileState(File fileToWriteTo, boolean isString)\n+\tprivate FileState getFileState(File fileToWriteTo, boolean isString)\n \t\t\tthrows FileNotFoundException {\n-\n-\t\tFileState state;\n-\t\tboolean appendNoFlush = FileExistsMode.APPEND_NO_FLUSH.equals(this.fileExistsMode);\n-\t\tif (appendNoFlush) {\n-\t\t\tString absolutePath = fileToWriteTo.getAbsolutePath();\n-\t\t\tstate = this.fileStates.get(absolutePath);\n-\t\t\tif (state != null // NOSONAR\n-\t\t\t\t\t&& ((isString && state.stream != null) || (!isString && state.writer != null))) {\n-\t\t\t\tstate.close();\n-\t\t\t\tstate = null;\n-\t\t\t\tthis.fileStates.remove(absolutePath);\n-\t\t\t}\n-\t\t\tif (state == null) {\n-\t\t\t\tif (isString) {\n-\t\t\t\t\tstate = new FileState(createWriter(fileToWriteTo, true),\n-\t\t\t\t\t\t\tthis.lockRegistry.obtain(fileToWriteTo.getAbsolutePath()));\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tFileState state;\n+\t\t\tboolean appendNoFlush = FileExistsMode.APPEND_NO_FLUSH.equals(this.fileExistsMode);\n+\t\t\tif (appendNoFlush) {\n+\t\t\t\tString absolutePath = fileToWriteTo.getAbsolutePath();\n+\t\t\t\tstate = this.fileStates.get(absolutePath);\n+\t\t\t\tif (state != null // NOSONAR\n+\t\t\t\t\t\t&& ((isString && state.stream != null) || (!isString && state.writer != null))) {\n+\t\t\t\t\tstate.close();\n+\t\t\t\t\tstate = null;\n+\t\t\t\t\tthis.fileStates.remove(absolutePath);\n \t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tstate = new FileState(createOutputStream(fileToWriteTo, true),\n-\t\t\t\t\t\t\tthis.lockRegistry.obtain(fileToWriteTo.getAbsolutePath()));\n+\t\t\t\tif (state == null) {\n+\t\t\t\t\tif (isString) {\n+\t\t\t\t\t\tstate = new FileState(createWriter(fileToWriteTo, true),\n+\t\t\t\t\t\t\t\tthis.lockRegistry.obtain(fileToWriteTo.getAbsolutePath()));\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tstate = new FileState(createOutputStream(fileToWriteTo, true),\n+\t\t\t\t\t\t\t\tthis.lockRegistry.obtain(fileToWriteTo.getAbsolutePath()));\n+\t\t\t\t\t}\n+\t\t\t\t\tthis.fileStates.put(absolutePath, state);\n \t\t\t\t}\n-\t\t\t\tthis.fileStates.put(absolutePath, state);\n+\t\t\t\tstate.lastWrite = Long.MAX_VALUE; // prevent flush while we write\n \t\t\t}\n-\t\t\tstate.lastWrite = Long.MAX_VALUE; // prevent flush while we write\n+\t\t\telse {\n+\t\t\t\tstate = null;\n+\t\t\t}\n+\t\t\treturn state;\n \t\t}\n-\t\telse {\n-\t\t\tstate = null;\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\treturn state;\n \t}\n \n \t/**\n@@ -975,7 +988,8 @@ public void flushIfNeeded(MessageFlushPredicate flushPredicate, Message<?> filte\n \n \tprivate Map<String, FileState> findFilesToFlush(MessageFlushPredicate flushPredicate, Message<?> filterMessage) {\n \t\tMap<String, FileState> toRemove = new HashMap<>();\n-\t\tsynchronized (this) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tIterator<Entry<String, FileState>> iterator = this.fileStates.entrySet().iterator();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tEntry<String, FileState> entry = iterator.next();\n@@ -986,12 +1000,21 @@ private Map<String, FileState> findFilesToFlush(MessageFlushPredicate flushPredi\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t\treturn toRemove;\n \t}\n \n-\tprivate synchronized void clearState(final File fileToWriteTo, final FileState state) {\n+\tprivate void clearState(final File fileToWriteTo, final FileState state) {\n \t\tif (state != null) {\n-\t\t\tthis.fileStates.remove(fileToWriteTo.getAbsolutePath());\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n+\t\t\t\tthis.fileStates.remove(fileToWriteTo.getAbsolutePath());\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -1014,11 +1037,15 @@ private void doFlush(Map<String, FileState> toRemove) {\n \t\t\t\tFileWritingMessageHandler.this.logger\n \t\t\t\t\t\t.debug(\"Interrupted during flush; not flushed: \" + toRestore.keySet());\n \t\t\t}\n-\t\t\tsynchronized (this) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tfor (Entry<String, FileState> entry : toRestore.entrySet()) {\n \t\t\t\t\tthis.fileStates.putIfAbsent(entry.getKey(), entry.getValue());\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -1085,11 +1112,12 @@ private final class Flusher implements Runnable {\n \t\t@Override\n \t\tpublic void run() {\n \t\t\tMap<String, FileState> toRemove = new HashMap<>();\n-\t\t\tsynchronized (FileWritingMessageHandler.this) {\n+\t\t\tFileWritingMessageHandler.this.lock.lock();\n+\t\t\ttry {\n \t\t\t\tlong expired = FileWritingMessageHandler.this.flushTask == null ? Long.MAX_VALUE\n \t\t\t\t\t\t: (System.currentTimeMillis() - FileWritingMessageHandler.this.flushInterval);\n-\t\t\t\tIterator<Entry<String, FileState>> iterator =\n-\t\t\t\t\t\tFileWritingMessageHandler.this.fileStates.entrySet().iterator();\n+\t\t\t\tIterator<Entry<String, FileState>> iterator = FileWritingMessageHandler.this.fileStates.entrySet()\n+\t\t\t\t\t\t.iterator();\n \t\t\t\twhile (iterator.hasNext()) {\n \t\t\t\t\tEntry<String, FileState> entry = iterator.next();\n \t\t\t\t\tFileState state = entry.getValue();\n@@ -1100,6 +1128,9 @@ public void run() {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tFileWritingMessageHandler.this.lock.unlock();\n+\t\t\t}\n \t\t\tdoFlush(toRemove);\n \t\t}\n \n\ndiff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/config/FileListFilterFactoryBean.java b/spring-integration-file/src/main/java/org/springframework/integration/file/config/FileListFilterFactoryBean.java\nindex a35c19eb0b8..8216721a7eb 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/config/FileListFilterFactoryBean.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/config/FileListFilterFactoryBean.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,6 +19,8 @@\n import java.io.File;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.beans.factory.FactoryBean;\n import org.springframework.integration.file.filters.AcceptAllFileListFilter;\n@@ -34,6 +36,8 @@\n  * @author Mark Fisher\n  * @author Gunnar Hillert\n  * @author Gary Russell\n+ * @author Christian Tzolov\n+ *\n  * @since 1.0.3\n  */\n public class FileListFilterFactoryBean implements FactoryBean<FileListFilter<File>> {\n@@ -52,7 +56,7 @@ public class FileListFilterFactoryBean implements FactoryBean<FileListFilter<Fil\n \n \tprivate volatile Boolean alwaysAcceptDirectories;\n \n-\tprivate final Object monitor = new Object();\n+\tprivate final Lock monitor = new ReentrantLock();\n \n \tpublic void setFilter(FileListFilter<File> filter) {\n \t\tthis.filter = filter;\n@@ -95,9 +99,13 @@ public void setAlwaysAcceptDirectories(Boolean alwaysAcceptDirectories) {\n \t@NonNull\n \tpublic FileListFilter<File> getObject() {\n \t\tif (this.result == null) {\n-\t\t\tsynchronized (this.monitor) {\n+\t\t\tthis.monitor.lock();\n+\t\t\ttry {\n \t\t\t\tthis.initializeFileListFilter();\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.monitor.unlock();\n+\t\t\t}\n \t\t}\n \t\treturn this.result;\n \t}\n\ndiff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/filters/AcceptOnceFileListFilter.java b/spring-integration-file/src/main/java/org/springframework/integration/file/filters/AcceptOnceFileListFilter.java\nindex f1c4d565167..a839ed848de 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/filters/AcceptOnceFileListFilter.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/filters/AcceptOnceFileListFilter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,6 +21,8 @@\n import java.util.Queue;\n import java.util.Set;\n import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.lang.Nullable;\n \n@@ -37,6 +39,7 @@\n  * @author Josh Long\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class AcceptOnceFileListFilter<F> extends AbstractFileListFilter<F> implements ReversibleFileListFilter<F>,\n \t\tResettableFileListFilter<F> {\n@@ -46,7 +49,7 @@ public class AcceptOnceFileListFilter<F> extends AbstractFileListFilter<F> imple\n \n \tprivate final Set<F> seenSet = new HashSet<F>();\n \n-\tprivate final Object monitor = new Object();\n+\tprivate final Lock monitor = new ReentrantLock();\n \n \n \t/**\n@@ -69,7 +72,8 @@ public AcceptOnceFileListFilter() {\n \n \t@Override\n \tpublic boolean accept(F file) {\n-\t\tsynchronized (this.monitor) {\n+\t\tthis.monitor.lock();\n+\t\ttry {\n \t\t\tif (this.seenSet.contains(file)) {\n \t\t\t\treturn false;\n \t\t\t}\n@@ -81,11 +85,15 @@ public boolean accept(F file) {\n \t\t\tthis.seenSet.add(file);\n \t\t\treturn true;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.monitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic void rollback(F file, List<F> files) {\n-\t\tsynchronized (this.monitor) {\n+\t\tthis.monitor.lock();\n+\t\ttry {\n \t\t\tboolean rollingBack = false;\n \t\t\tfor (F fileToRollback : files) {\n \t\t\t\tif (fileToRollback.equals(file)) {\n@@ -96,6 +104,9 @@ public void rollback(F file, List<F> files) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.monitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/filters/CompositeFileListFilter.java b/spring-integration-file/src/main/java/org/springframework/integration/file/filters/CompositeFileListFilter.java\nindex 3eacbcc72a8..5b10ddbf26f 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/filters/CompositeFileListFilter.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/filters/CompositeFileListFilter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -26,6 +26,8 @@\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.Consumer;\n \n import org.springframework.beans.factory.InitializingBean;\n@@ -46,6 +48,7 @@\n  * @author Josh Long\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class CompositeFileListFilter<F>\n \t\timplements ReversibleFileListFilter<F>, ResettableFileListFilter<F>, DiscardAwareFileListFilter<F>, Closeable {\n@@ -58,6 +61,7 @@ public class CompositeFileListFilter<F>\n \n \tprivate boolean oneIsForRecursion;\n \n+\tprivate final Lock lock = new ReentrantLock();\n \n \tpublic CompositeFileListFilter() {\n \t\tthis.fileFilters = new LinkedHashSet<>();\n@@ -104,24 +108,30 @@ public final CompositeFileListFilter<F> addFilters(FileListFilter<F>... filters)\n \t * @param filtersToAdd a list of filters to add\n \t * @return this CompositeFileListFilter instance with the added filters\n \t */\n-\tpublic synchronized CompositeFileListFilter<F> addFilters(Collection<? extends FileListFilter<F>> filtersToAdd) {\n-\t\tfor (FileListFilter<F> elf : filtersToAdd) {\n-\t\t\tif (elf instanceof DiscardAwareFileListFilter) {\n-\t\t\t\t((DiscardAwareFileListFilter<F>) elf).addDiscardCallback(this.discardCallback);\n-\t\t\t}\n-\t\t\tif (elf instanceof InitializingBean) {\n-\t\t\t\ttry {\n-\t\t\t\t\t((InitializingBean) elf).afterPropertiesSet();\n+\tpublic CompositeFileListFilter<F> addFilters(Collection<? extends FileListFilter<F>> filtersToAdd) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tfor (FileListFilter<F> elf : filtersToAdd) {\n+\t\t\t\tif (elf instanceof DiscardAwareFileListFilter) {\n+\t\t\t\t\t((DiscardAwareFileListFilter<F>) elf).addDiscardCallback(this.discardCallback);\n \t\t\t\t}\n-\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\tthrow new IllegalStateException(e);\n+\t\t\t\tif (elf instanceof InitializingBean) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\t((InitializingBean) elf).afterPropertiesSet();\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (Exception e) {\n+\t\t\t\t\t\tthrow new IllegalStateException(e);\n+\t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tthis.allSupportAccept = this.allSupportAccept && elf.supportsSingleFileFiltering();\n+\t\t\t\tthis.oneIsForRecursion |= elf.isForRecursion();\n \t\t\t}\n-\t\t\tthis.allSupportAccept = this.allSupportAccept && elf.supportsSingleFileFiltering();\n-\t\t\tthis.oneIsForRecursion |= elf.isForRecursion();\n+\t\t\tthis.fileFilters.addAll(filtersToAdd);\n+\t\t\treturn this;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\tthis.fileFilters.addAll(filtersToAdd);\n-\t\treturn this;\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/remote/session/CachingSessionFactory.java b/spring-integration-file/src/main/java/org/springframework/integration/file/remote/session/CachingSessionFactory.java\nindex 2ab2f38416c..be98c5f96ea 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/remote/session/CachingSessionFactory.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/remote/session/CachingSessionFactory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,6 +19,8 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n@@ -40,6 +42,7 @@\n  * @author Gary Russell\n  * @author Alen Turkovic\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n@@ -47,6 +50,8 @@ public class CachingSessionFactory<F> implements SessionFactory<F>, DisposableBe\n \n \tprivate static final Log LOGGER = LogFactory.getLog(CachingSessionFactory.class);\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final SessionFactory<F> sessionFactory;\n \n \tprivate final SimplePool<Session<F>> pool;\n@@ -146,24 +151,29 @@ public void destroy() {\n \t * Clear the cache of sessions; also any in-use sessions will be closed when\n \t * returned to the cache.\n \t */\n-\tpublic synchronized void resetCache() {\n-\t\tLOGGER.debug(\"Cache reset; idle sessions will be removed, in-use sessions will be closed when returned\");\n-\t\tif (this.isSharedSessionCapable && ((SharedSessionCapable) this.sessionFactory).isSharedSession()) {\n-\t\t\t((SharedSessionCapable) this.sessionFactory).resetSharedSession();\n+\tpublic void resetCache() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tLOGGER.debug(\"Cache reset; idle sessions will be removed, in-use sessions will be closed when returned\");\n+\t\t\tif (this.isSharedSessionCapable && ((SharedSessionCapable) this.sessionFactory).isSharedSession()) {\n+\t\t\t\t((SharedSessionCapable) this.sessionFactory).resetSharedSession();\n+\t\t\t}\n+\t\t\tlong epoch = System.nanoTime();\n+\t\t\t/*\n+\t\t\t * Spin until we get a new value - nano precision but may be lower resolution. We reset the epoch AFTER\n+\t\t\t * resetting the shared session so there is no possibility of an \"old\" session being created in the new\n+\t\t\t * epoch. There is a slight possibility that a \"new\" session might appear in the old epoch and thus be\n+\t\t\t * closed when returned to the cache.\n+\t\t\t */\n+\t\t\twhile (epoch == this.sharedSessionEpoch) {\n+\t\t\t\tepoch = System.nanoTime();\n+\t\t\t}\n+\t\t\tthis.sharedSessionEpoch = epoch;\n+\t\t\tthis.pool.removeAllIdleItems();\n \t\t}\n-\t\tlong epoch = System.nanoTime();\n-\t\t/*\n-\t\t * Spin until we get a new value - nano precision but may be lower resolution.\n-\t\t * We reset the epoch AFTER resetting the shared session so there is no possibility\n-\t\t * of an \"old\" session being created in the new epoch. There is a slight possibility\n-\t\t * that a \"new\" session might appear in the old epoch and thus be closed when returned to\n-\t\t * the cache.\n-\t\t */\n-\t\twhile (epoch == this.sharedSessionEpoch) {\n-\t\t\tepoch = System.nanoTime();\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\tthis.sharedSessionEpoch = epoch;\n-\t\tthis.pool.removeAllIdleItems();\n \t}\n \n \tpublic class CachedSession implements Session<F> { //NOSONAR must be final, but can't for mocking in tests\n@@ -174,6 +184,8 @@ public class CachedSession implements Session<F> { //NOSONAR must be final, but\n \n \t\tprivate boolean dirty;\n \n+\t\tprivate final Lock lock = new ReentrantLock();\n+\n \t\t/**\n \t\t * The epoch in which this session was created.\n \t\t */\n@@ -185,35 +197,42 @@ private CachedSession(Session<F> targetSession, long sharedSessionEpoch) {\n \t\t}\n \n \t\t@Override\n-\t\tpublic synchronized void close() {\n-\t\t\tif (this.released) {\n-\t\t\t\tif (LOGGER.isDebugEnabled()) {\n-\t\t\t\t\tLOGGER.debug(\"Session \" + this.targetSession + \" already released.\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif (LOGGER.isDebugEnabled()) {\n-\t\t\t\t\tLOGGER.debug(\"Releasing Session \" + this.targetSession + \" back to the pool.\");\n-\t\t\t\t}\n-\t\t\t\tif (this.sharedSessionEpoch != CachingSessionFactory.this.sharedSessionEpoch) {\n+\t\tpublic void close() {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n+\n+\t\t\t\tif (this.released) {\n \t\t\t\t\tif (LOGGER.isDebugEnabled()) {\n-\t\t\t\t\t\tLOGGER.debug(\"Closing session \" + this.targetSession + \" after reset.\");\n+\t\t\t\t\t\tLOGGER.debug(\"Session \" + this.targetSession + \" already released.\");\n \t\t\t\t\t}\n-\t\t\t\t\tthis.targetSession.close();\n \t\t\t\t}\n-\t\t\t\telse if (this.dirty) {\n-\t\t\t\t\tthis.targetSession.close();\n-\t\t\t\t}\n-\t\t\t\tif (this.targetSession.isOpen()) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tthis.targetSession.finalizeRaw();\n+\t\t\t\telse {\n+\t\t\t\t\tif (LOGGER.isDebugEnabled()) {\n+\t\t\t\t\t\tLOGGER.debug(\"Releasing Session \" + this.targetSession + \" back to the pool.\");\n \t\t\t\t\t}\n-\t\t\t\t\tcatch (IOException e) {\n-\t\t\t\t\t\t//No-op in this context\n+\t\t\t\t\tif (this.sharedSessionEpoch != CachingSessionFactory.this.sharedSessionEpoch) {\n+\t\t\t\t\t\tif (LOGGER.isDebugEnabled()) {\n+\t\t\t\t\t\t\tLOGGER.debug(\"Closing session \" + this.targetSession + \" after reset.\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tthis.targetSession.close();\n \t\t\t\t\t}\n+\t\t\t\t\telse if (this.dirty) {\n+\t\t\t\t\t\tthis.targetSession.close();\n+\t\t\t\t\t}\n+\t\t\t\t\tif (this.targetSession.isOpen()) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tthis.targetSession.finalizeRaw();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcatch (IOException e) {\n+\t\t\t\t\t\t\t// No-op in this context\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tCachingSessionFactory.this.pool.releaseItem(this.targetSession);\n+\t\t\t\t\tthis.released = true;\n \t\t\t\t}\n-\t\t\t\tCachingSessionFactory.this.pool.releaseItem(this.targetSession);\n-\t\t\t\tthis.released = true;\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n \t\t\t}\n \t\t}\n \n\ndiff --git a/spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/leader/LeaderInitiator.java b/spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/leader/LeaderInitiator.java\nindex 2a843119cf3..1db7a909ea5 100644\n--- a/spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/leader/LeaderInitiator.java\n+++ b/spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/leader/LeaderInitiator.java\n@@ -21,6 +21,8 @@\n import java.util.concurrent.Future;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import com.hazelcast.core.HazelcastInstance;\n import com.hazelcast.cp.CPSubsystem;\n@@ -54,6 +56,7 @@\n  * @author Mael Le Guvel\n  * @author Alexey Tsoy\n  * @author Robert Hglund\n+ * @author Christian Tzolov\n  */\n public class LeaderInitiator implements SmartLifecycle, DisposableBean, ApplicationEventPublisherAware {\n \n@@ -61,6 +64,8 @@ public class LeaderInitiator implements SmartLifecycle, DisposableBean, Applicat\n \n \tprivate static final Context NULL_CONTEXT = new NullContext();\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \t/*** Hazelcast client.\n \t */\n \tprivate final HazelcastInstance client;\n@@ -208,11 +213,17 @@ public Context getContext() {\n \t * Start the registration of the {@link #candidate} for leader election.\n \t */\n \t@Override\n-\tpublic synchronized void start() {\n-\t\tif (!this.running) {\n-\t\t\tthis.leaderSelector = new LeaderSelector();\n-\t\t\tthis.running = true;\n-\t\t\tthis.future = this.taskExecutor.submit(this.leaderSelector);\n+\tpublic void start() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (!this.running) {\n+\t\t\t\tthis.leaderSelector = new LeaderSelector();\n+\t\t\t\tthis.running = true;\n+\t\t\t\tthis.future = this.taskExecutor.submit(this.leaderSelector);\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n@@ -227,13 +238,19 @@ public void stop(Runnable callback) {\n \t * If the candidate is currently leader, its leadership will be revoked.\n \t */\n \t@Override\n-\tpublic synchronized void stop() {\n-\t\tif (this.running) {\n-\t\t\tthis.running = false;\n-\t\t\tif (this.future != null) {\n-\t\t\t\tthis.future.cancel(true);\n+\tpublic void stop() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.running) {\n+\t\t\t\tthis.running = false;\n+\t\t\t\tif (this.future != null) {\n+\t\t\t\t\tthis.future.cancel(true);\n+\t\t\t\t}\n+\t\t\t\tthis.future = null;\n \t\t\t}\n-\t\t\tthis.future = null;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-http/src/main/java/org/springframework/integration/http/outbound/AbstractHttpRequestExecutingMessageHandler.java b/spring-integration-http/src/main/java/org/springframework/integration/http/outbound/AbstractHttpRequestExecutingMessageHandler.java\nindex b36ad1e93ba..e279004c21a 100644\n--- a/spring-integration-http/src/main/java/org/springframework/integration/http/outbound/AbstractHttpRequestExecutingMessageHandler.java\n+++ b/spring-integration-http/src/main/java/org/springframework/integration/http/outbound/AbstractHttpRequestExecutingMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2017-2022 the original author or authors.\n+ * Copyright 2017-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -26,6 +26,8 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.xml.transform.Source;\n \n@@ -71,6 +73,7 @@\n  * @author Wallace Wadge\n  * @author Shiliang Li\n  * @author Florian Schffl\n+ * @author Christian Tzolov\n  *\n  * @since 5.0\n  */\n@@ -81,6 +84,8 @@ public abstract class AbstractHttpRequestExecutingMessageHandler extends Abstrac\n \n \tprotected final DefaultUriBuilderFactory uriFactory = new DefaultUriBuilderFactory(); // NOSONAR - final\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final Map<String, Expression> uriVariableExpressions = new HashMap<>();\n \n \tprivate final Expression uriExpression;\n@@ -226,10 +231,14 @@ public void setHeaderMapper(HeaderMapper<HttpHeaders> headerMapper) {\n \t * @param uriVariableExpressions The URI variable expressions.\n \t */\n \tpublic void setUriVariableExpressions(Map<String, Expression> uriVariableExpressions) {\n-\t\tsynchronized (this.uriVariableExpressions) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tthis.uriVariableExpressions.clear();\n \t\t\tthis.uriVariableExpressions.putAll(uriVariableExpressions);\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t/**\n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/AbstractInternetProtocolSendingMessageHandler.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/AbstractInternetProtocolSendingMessageHandler.java\nindex ef5ff630dd1..1f9049be2c8 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/AbstractInternetProtocolSendingMessageHandler.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/AbstractInternetProtocolSendingMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,6 +18,8 @@\n \n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.integration.handler.AbstractMessageHandler;\n import org.springframework.integration.support.management.ManageableLifecycle;\n@@ -27,11 +29,15 @@\n  * Base class for UDP MessageHandlers.\n  *\n  * @author Gary Russell\n+ * @author Christian Tzolov\n+ *\n  * @since 2.0\n  */\n public abstract class AbstractInternetProtocolSendingMessageHandler extends AbstractMessageHandler\n \t\timplements CommonSocketOptions, ManageableLifecycle {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final SocketAddress destinationAddress;\n \n \tprivate final String host;\n@@ -119,20 +125,32 @@ public int getSoSendBufferSize() {\n \n \n \t@Override\n-\tpublic synchronized void start() {\n-\t\tif (!this.running) {\n-\t\t\tthis.doStart();\n-\t\t\tthis.running = true;\n+\tpublic void start() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (!this.running) {\n+\t\t\t\tthis.doStart();\n+\t\t\t\tthis.running = true;\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n \tprotected abstract void doStart();\n \n \t@Override\n-\tpublic synchronized void stop() {\n-\t\tif (this.running) {\n-\t\t\tthis.doStop();\n-\t\t\tthis.running = false;\n+\tpublic void stop() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.running) {\n+\t\t\t\tthis.doStop();\n+\t\t\t\tthis.running = false;\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/TcpSendingMessageHandler.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/TcpSendingMessageHandler.java\nindex 15b3d195218..fe33345b7f3 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/TcpSendingMessageHandler.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/TcpSendingMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,6 +21,8 @@\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.context.ApplicationEventPublisher;\n import org.springframework.integration.handler.AbstractMessageHandler;\n@@ -48,6 +50,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  *\n@@ -60,7 +63,7 @@ public class TcpSendingMessageHandler extends AbstractMessageHandler implements\n \t */\n \tpublic static final long DEFAULT_RETRY_INTERVAL = 60000;\n \n-\tprotected final Object lifecycleMonitor = new Object(); // NOSONAR\n+\tprotected final Lock lifecycleMonitor = new ReentrantLock(); // NOSONAR\n \n \tprivate final Map<String, TcpConnection> connections = new ConcurrentHashMap<>();\n \n@@ -251,7 +254,8 @@ protected void onInit() {\n \n \t@Override\n \tpublic void start() {\n-\t\tsynchronized (this.lifecycleMonitor) {\n+\t\tthis.lifecycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (!this.active) {\n \t\t\t\tthis.active = true;\n \t\t\t\tif (this.clientConnectionFactory != null) {\n@@ -273,11 +277,15 @@ public void start() {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleMonitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic void stop() {\n-\t\tsynchronized (this.lifecycleMonitor) {\n+\t\tthis.lifecycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.active) {\n \t\t\t\tthis.active = false;\n \t\t\t\tif (this.scheduledFuture != null) {\n@@ -292,6 +300,9 @@ public void stop() {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleMonitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractConnectionFactory.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractConnectionFactory.java\nindex d7f365e6c7b..55c6da1f631 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractConnectionFactory.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractConnectionFactory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -42,6 +42,8 @@\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.context.ApplicationEventPublisher;\n import org.springframework.context.ApplicationEventPublisherAware;\n@@ -58,6 +60,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  *\n@@ -73,10 +76,12 @@ public abstract class AbstractConnectionFactory extends IntegrationObjectSupport\n \n \tprivate static final int DEFAULT_READ_DELAY = 100;\n \n-\tprotected final Object lifecycleMonitor = new Object(); // NOSONAR final\n+\tprotected final Lock lifecycleMonitor = new ReentrantLock(); // NOSONAR final\n \n \tprivate final Map<String, TcpConnectionSupport> connections = new ConcurrentHashMap<>();\n \n+\tprivate final Lock connectionsMonitor = new ReentrantLock();\n+\n \tprivate final BlockingQueue<PendingIO> delayedReads = new LinkedBlockingQueue<>();\n \n \tprivate final List<TcpSender> senders = Collections.synchronizedList(new ArrayList<>());\n@@ -546,13 +551,17 @@ protected Executor getTaskExecutor() {\n \t\tif (!this.active) {\n \t\t\tthrow new MessagingException(\"Connection Factory not started\");\n \t\t}\n-\t\tsynchronized (this.lifecycleMonitor) {\n+\t\tthis.lifecycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.taskExecutor == null) {\n \t\t\t\tthis.privateExecutor = true;\n \t\t\t\tthis.taskExecutor = Executors.newCachedThreadPool();\n \t\t\t}\n \t\t\treturn this.taskExecutor;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleMonitor.unlock();\n+\t\t}\n \t}\n \n \t/**\n@@ -561,7 +570,8 @@ protected Executor getTaskExecutor() {\n \t@Override\n \tpublic void stop() {\n \t\tthis.active = false;\n-\t\tsynchronized (this.connections) {\n+\t\tthis.connectionsMonitor.lock();\n+\t\ttry {\n \t\t\tIterator<Entry<String, TcpConnectionSupport>> iterator = this.connections.entrySet().iterator();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tTcpConnectionSupport connection = iterator.next().getValue();\n@@ -575,7 +585,12 @@ public void stop() {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tsynchronized (this.lifecycleMonitor) {\n+\t\tfinally {\n+\t\t\tthis.connectionsMonitor.unlock();\n+\t\t}\n+\n+\t\tthis.lifecycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.privateExecutor) {\n \t\t\t\tExecutorService executorService = (ExecutorService) this.taskExecutor;\n \t\t\t\texecutorService.shutdown();\n@@ -598,6 +613,9 @@ public void stop() {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleMonitor.unlock();\n+\t\t}\n \t\tlogger.info(() -> \"stopped \" + this);\n \t}\n \n@@ -849,7 +867,8 @@ protected void doAccept(final Selector selector, ServerSocketChannel server, lon\n \t}\n \n \tprotected void addConnection(TcpConnectionSupport connection) {\n-\t\tsynchronized (this.connections) {\n+\t\tthis.connectionsMonitor.lock();\n+\t\ttry {\n \t\t\tif (!this.active) {\n \t\t\t\tconnection.close();\n \t\t\t\treturn;\n@@ -857,6 +876,9 @@ protected void addConnection(TcpConnectionSupport connection) {\n \t\t\tthis.connections.put(connection.getConnectionId(), connection);\n \t\t\tlogger.debug(() -> getComponentName() + \": Added new connection: \" + connection.getConnectionId());\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.connectionsMonitor.unlock();\n+\t\t}\n \t}\n \n \t/**\n@@ -864,7 +886,8 @@ protected void addConnection(TcpConnectionSupport connection) {\n \t * @return a list of open connection ids.\n \t */\n \tprivate List<String> removeClosedConnectionsAndReturnOpenConnectionIds() {\n-\t\tsynchronized (this.connections) {\n+\t\tthis.connectionsMonitor.lock();\n+\t\ttry {\n \t\t\tList<String> openConnectionIds = new ArrayList<>();\n \t\t\tIterator<Entry<String, TcpConnectionSupport>> iterator = this.connections.entrySet().iterator();\n \t\t\twhile (iterator.hasNext()) {\n@@ -888,6 +911,9 @@ private List<String> removeClosedConnectionsAndReturnOpenConnectionIds() {\n \t\t\t}\n \t\t\treturn openConnectionIds;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.connectionsMonitor.unlock();\n+\t\t}\n \t}\n \n \t/**\n@@ -948,7 +974,8 @@ public List<String> getOpenConnectionIds() {\n \tpublic boolean closeConnection(String connectionId) {\n \t\tAssert.notNull(connectionId, \"'connectionId' to close must not be null\");\n \t\t// closed connections are removed from #connections in #harvestClosedConnections()\n-\t\tsynchronized (this.connections) {\n+\t\tthis.connectionsMonitor.lock();\n+\t\ttry {\n \t\t\tboolean closed = false;\n \t\t\tTcpConnectionSupport connection = this.connections.remove(connectionId);\n \t\t\tif (connection != null) {\n@@ -964,6 +991,9 @@ public boolean closeConnection(String connectionId) {\n \t\t\t}\n \t\t\treturn closed;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.connectionsMonitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractServerConnectionFactory.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractServerConnectionFactory.java\nindex 6080df8960b..dba39b669f6 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractServerConnectionFactory.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/AbstractServerConnectionFactory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2001-2022 the original author or authors.\n+ * Copyright 2001-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -37,6 +37,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n@@ -75,13 +76,17 @@ public SocketAddress getServerSocketAddress() {\n \n \t@Override\n \tpublic void start() {\n-\t\tsynchronized (this.lifecycleMonitor) {\n+\t\tthis.lifecycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (!isActive()) {\n \t\t\t\tthis.setActive(true);\n \t\t\t\tthis.shuttingDown = false;\n \t\t\t\tgetTaskExecutor().execute(this);\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleMonitor.unlock();\n+\t\t}\n \t\tsuper.start();\n \t}\n \n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/CachingClientConnectionFactory.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/CachingClientConnectionFactory.java\nindex b667976f0d7..f8ef6f00c29 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/CachingClientConnectionFactory.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/CachingClientConnectionFactory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,6 +20,8 @@\n import java.util.Map;\n import java.util.concurrent.Executor;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.beans.factory.DisposableBean;\n import org.springframework.core.serializer.Deserializer;\n@@ -39,11 +41,15 @@\n  * false, or cache starvation will result.\n  *\n  * @author Gary Russell\n+ * @author Christian Tzolov\n+ *\n  * @since 2.2\n  *\n  */\n public class CachingClientConnectionFactory extends AbstractClientConnectionFactory implements DisposableBean {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final AbstractClientConnectionFactory targetConnectionFactory;\n \n \tprivate final SimplePool<TcpConnectionSupport> pool;\n@@ -385,9 +391,15 @@ public void start() {\n \t}\n \n \t@Override\n-\tpublic synchronized void stop() {\n-\t\tthis.targetConnectionFactory.stop();\n-\t\tthis.pool.removeAllIdleItems();\n+\tpublic void stop() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tthis.targetConnectionFactory.stop();\n+\t\t\tthis.pool.removeAllIdleItems();\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/ClientModeConnectionManager.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/ClientModeConnectionManager.java\nindex 663f3223e21..be92fce3970 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/ClientModeConnectionManager.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/ClientModeConnectionManager.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,6 +17,8 @@\n package org.springframework.integration.ip.tcp.connection;\n \n import java.util.Objects;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n@@ -31,6 +33,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.1\n  *\n@@ -39,6 +42,8 @@ public class ClientModeConnectionManager implements Runnable {\n \n \tprivate final Log logger = LogFactory.getLog(this.getClass());\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final AbstractConnectionFactory clientConnectionFactory;\n \n \tprivate volatile TcpConnection lastConnection;\n@@ -54,7 +59,8 @@ public ClientModeConnectionManager(\n \n \t@Override\n \tpublic void run() {\n-\t\tsynchronized (this.clientConnectionFactory) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\ttry {\n \t\t\t\tTcpConnection connection = this.clientConnectionFactory.getConnection();\n \t\t\t\tif (!Objects.equals(connection, this.lastConnection)) {\n@@ -73,6 +79,9 @@ public void run() {\n \t\t\t\tthis.logger.error(\"Could not establish connection using \" + this.clientConnectionFactory, ex);\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \tpublic boolean isConnected() {\n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/FailoverClientConnectionFactory.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/FailoverClientConnectionFactory.java\nindex 74da615ec37..3bb492fa023 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/FailoverClientConnectionFactory.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/FailoverClientConnectionFactory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,6 +21,8 @@\n import java.util.List;\n import java.util.UUID;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.net.ssl.SSLSession;\n \n@@ -37,6 +39,8 @@\n  * succeeds or the list is exhausted.\n  *\n  * @author Gary Russell\n+ * @author Christian Tzolov\n+ *\n  * @since 2.2\n  *\n  */\n@@ -224,6 +228,8 @@ public boolean isRunning() {\n \t */\n \tprivate final class FailoverTcpConnection extends TcpConnectionSupport implements TcpListener {\n \n+\t\tprivate final Lock lock = new ReentrantLock();\n+\n \t\tprivate final List<AbstractClientConnectionFactory> connectionFactories;\n \n \t\tprivate final String connectionId;\n@@ -257,46 +263,51 @@ void incrementEpoch() {\n \t\t * factories are down.\n \t\t * @throws InterruptedException if interrupted.\n \t\t */\n-\t\tprivate synchronized void findAConnection() throws InterruptedException {\n-\t\t\tboolean success = false;\n-\t\t\tAbstractClientConnectionFactory lastFactoryToTry = this.currentFactory;\n-\t\t\tAbstractClientConnectionFactory nextFactory = null;\n-\t\t\tif (!this.factoryIterator.hasNext()) {\n-\t\t\t\tthis.factoryIterator = this.connectionFactories.iterator();\n-\t\t\t}\n-\t\t\tboolean restartedList = false;\n-\t\t\twhile (!success) {\n-\t\t\t\ttry {\n-\t\t\t\t\tnextFactory = this.factoryIterator.next();\n-\t\t\t\t\tthis.delegate = nextFactory.getConnection();\n-\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tlogger.debug(\"Got \" + this.delegate.getConnectionId() + \" from \" + nextFactory);\n-\t\t\t\t\t}\n-\t\t\t\t\tthis.delegate.registerListener(this);\n-\t\t\t\t\tthis.currentFactory = nextFactory;\n-\t\t\t\t\tsuccess = this.delegate.isOpen();\n+\t\tprivate void findAConnection() throws InterruptedException {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n+\t\t\t\tboolean success = false;\n+\t\t\t\tAbstractClientConnectionFactory lastFactoryToTry = this.currentFactory;\n+\t\t\t\tAbstractClientConnectionFactory nextFactory = null;\n+\t\t\t\tif (!this.factoryIterator.hasNext()) {\n+\t\t\t\t\tthis.factoryIterator = this.connectionFactories.iterator();\n \t\t\t\t}\n-\t\t\t\tcatch (RuntimeException e) {\n-\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tlogger.debug(nextFactory + \" failed with \"\n-\t\t\t\t\t\t\t\t+ e.toString()\n-\t\t\t\t\t\t\t\t+ \", trying another\");\n-\t\t\t\t\t}\n-\t\t\t\t\tif (restartedList && (lastFactoryToTry == null || lastFactoryToTry.equals(nextFactory))) {\n-\t\t\t\t\t\tlogger.debug(\"Failover failed to find a connection\");\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t *  We've tried every factory including the\n-\t\t\t\t\t\t *  one the current connection was on.\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tthis.open = false;\n-\t\t\t\t\t\tthrow e;\n+\t\t\t\tboolean restartedList = false;\n+\t\t\t\twhile (!success) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tnextFactory = this.factoryIterator.next();\n+\t\t\t\t\t\tthis.delegate = nextFactory.getConnection();\n+\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\tlogger.debug(\"Got \" + this.delegate.getConnectionId() + \" from \" + nextFactory);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tthis.delegate.registerListener(this);\n+\t\t\t\t\t\tthis.currentFactory = nextFactory;\n+\t\t\t\t\t\tsuccess = this.delegate.isOpen();\n \t\t\t\t\t}\n-\t\t\t\t\tif (!this.factoryIterator.hasNext()) {\n-\t\t\t\t\t\tthis.factoryIterator = this.connectionFactories.iterator();\n-\t\t\t\t\t\trestartedList = true;\n+\t\t\t\t\tcatch (RuntimeException e) {\n+\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\tlogger.debug(nextFactory + \" failed with \"\n+\t\t\t\t\t\t\t\t\t+ e.toString()\n+\t\t\t\t\t\t\t\t\t+ \", trying another\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (restartedList && (lastFactoryToTry == null || lastFactoryToTry.equals(nextFactory))) {\n+\t\t\t\t\t\t\tlogger.debug(\"Failover failed to find a connection\");\n+\t\t\t\t\t\t\t/*\n+\t\t\t\t\t\t\t * We've tried every factory including the one the current connection was on.\n+\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\tthis.open = false;\n+\t\t\t\t\t\t\tthrow e;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (!this.factoryIterator.hasNext()) {\n+\t\t\t\t\t\t\tthis.factoryIterator = this.connectionFactories.iterator();\n+\t\t\t\t\t\t\trestartedList = true;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \n \t\t@Override\n@@ -316,39 +327,46 @@ public boolean isOpen() {\n \t\t * If send fails on a connection from every factory, we give up.\n \t\t */\n \t\t@Override\n-\t\tpublic synchronized void send(Message<?> message) {\n-\t\t\tboolean success = false;\n-\t\t\tAbstractClientConnectionFactory lastFactoryToTry = this.currentFactory;\n-\t\t\tAbstractClientConnectionFactory lastFactoryTried = null;\n-\t\t\tboolean retried = false;\n-\t\t\twhile (!success) {\n-\t\t\t\ttry {\n-\t\t\t\t\tlastFactoryTried = this.currentFactory;\n-\t\t\t\t\tthis.delegate.send(message);\n-\t\t\t\t\tsuccess = true;\n-\t\t\t\t}\n-\t\t\t\tcatch (RuntimeException e) {\n-\t\t\t\t\tif (retried && lastFactoryTried.equals(lastFactoryToTry)) {\n-\t\t\t\t\t\tlogger.error(\"All connection factories exhausted\", e);\n-\t\t\t\t\t\tthis.open = false;\n-\t\t\t\t\t\tthrow e;\n-\t\t\t\t\t}\n-\t\t\t\t\tretried = true;\n-\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tlogger.debug(\"Send to \" + this.delegate.getConnectionId() + \" failed; attempting failover\", e);\n-\t\t\t\t\t}\n-\t\t\t\t\tthis.delegate.close();\n+\t\tpublic void send(Message<?> message) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n+\t\t\t\tboolean success = false;\n+\t\t\t\tAbstractClientConnectionFactory lastFactoryToTry = this.currentFactory;\n+\t\t\t\tAbstractClientConnectionFactory lastFactoryTried = null;\n+\t\t\t\tboolean retried = false;\n+\t\t\t\twhile (!success) {\n \t\t\t\t\ttry {\n-\t\t\t\t\t\tfindAConnection();\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (@SuppressWarnings(\"unused\") InterruptedException e1) {\n-\t\t\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t\t\t\tlastFactoryTried = this.currentFactory;\n+\t\t\t\t\t\tthis.delegate.send(message);\n+\t\t\t\t\t\tsuccess = true;\n \t\t\t\t\t}\n-\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tlogger.debug(\"Failing over to \" + this.delegate.getConnectionId());\n+\t\t\t\t\tcatch (RuntimeException e) {\n+\t\t\t\t\t\tif (retried && lastFactoryTried.equals(lastFactoryToTry)) {\n+\t\t\t\t\t\t\tlogger.error(\"All connection factories exhausted\", e);\n+\t\t\t\t\t\t\tthis.open = false;\n+\t\t\t\t\t\t\tthrow e;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tretried = true;\n+\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\tlogger.debug(\"Send to \" + this.delegate.getConnectionId() + \" failed; attempting failover\",\n+\t\t\t\t\t\t\t\t\te);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tthis.delegate.close();\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tfindAConnection();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcatch (@SuppressWarnings(\"unused\") InterruptedException e1) {\n+\t\t\t\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\tlogger.debug(\"Failing over to \" + this.delegate.getConnectionId());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \n \t\t@Override\n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpConnectionInterceptorSupport.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpConnectionInterceptorSupport.java\nindex 8bde317cc05..08a8d8539fd 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpConnectionInterceptorSupport.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpConnectionInterceptorSupport.java\n@@ -18,6 +18,8 @@\n \n import java.util.Collections;\n import java.util.List;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.net.ssl.SSLSession;\n \n@@ -34,11 +36,14 @@\n  *\n  * @author Gary Russell\n  * @author Kazuki Shimizu\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n public abstract class TcpConnectionInterceptorSupport extends TcpConnectionSupport implements TcpConnectionInterceptor {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate TcpConnectionSupport theConnection;\n \n \tprivate TcpListener tcpListener;\n@@ -238,17 +243,23 @@ public void addNewConnection(TcpConnection connection) {\n \t}\n \n \t@Override\n-\tpublic synchronized void removeDeadConnection(TcpConnection connection) {\n-\t\tif (this.removed) {\n-\t\t\treturn;\n-\t\t}\n-\t\tthis.removed = true;\n-\t\tif (this.theConnection instanceof TcpConnectionInterceptorSupport && !this.theConnection.equals(this)) {\n-\t\t\t((TcpConnectionInterceptorSupport) this.theConnection).removeDeadConnection(this);\n+\tpublic void removeDeadConnection(TcpConnection connection) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.removed) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tthis.removed = true;\n+\t\t\tif (this.theConnection instanceof TcpConnectionInterceptorSupport && !this.theConnection.equals(this)) {\n+\t\t\t\t((TcpConnectionInterceptorSupport) this.theConnection).removeDeadConnection(this);\n+\t\t\t}\n+\t\t\tTcpSender sender = getSender();\n+\t\t\tif (sender != null && !(sender instanceof TcpConnectionInterceptorSupport)) {\n+\t\t\t\tthis.interceptedSenders.forEach(snder -> snder.removeDeadConnection(connection));\n+\t\t\t}\n \t\t}\n-\t\tTcpSender sender = getSender();\n-\t\tif (sender != null && !(sender instanceof TcpConnectionInterceptorSupport)) {\n-\t\t\tthis.interceptedSenders.forEach(snder -> snder.removeDeadConnection(connection));\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNetConnection.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNetConnection.java\nindex b7defc78e8e..22e16e0c6b6 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNetConnection.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNetConnection.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2001-2021 the original author or authors.\n+ * Copyright 2001-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -24,6 +24,8 @@\n import java.net.Socket;\n import java.net.SocketException;\n import java.net.SocketTimeoutException;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.Supplier;\n \n import javax.net.ssl.SSLSession;\n@@ -43,12 +45,15 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  *\n  */\n public class TcpNetConnection extends TcpConnectionSupport implements SchedulingAwareRunnable {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final Socket socket;\n \n \tprivate volatile OutputStream socketOutputStream;\n@@ -102,7 +107,8 @@ public boolean isOpen() {\n \n \t@Override\n \t@SuppressWarnings(\"unchecked\")\n-\tpublic synchronized void send(Message<?> message) {\n+\tpublic void send(Message<?> message) {\n+\t\tthis.lock.lock();\n \t\ttry {\n \t\t\tif (this.socketOutputStream == null) {\n \t\t\t\tint writeBufferSize = this.socket.getSendBufferSize();\n@@ -121,6 +127,9 @@ public synchronized void send(Message<?> message) {\n \t\t\tcloseConnection(true);\n \t\t\tthrow mex;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(getConnectionId() + \" Message sent \" + message);\n \t\t}\n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioClientConnectionFactory.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioClientConnectionFactory.java\nindex 6764db6d349..446d335f38d 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioClientConnectionFactory.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioClientConnectionFactory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -39,6 +39,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  *\n@@ -170,12 +171,16 @@ public void stop() {\n \n \t@Override\n \tpublic void start() {\n-\t\tsynchronized (this.lifecycleMonitor) {\n+\t\tthis.lifecycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (!isActive()) {\n \t\t\t\tsetActive(true);\n \t\t\t\tgetTaskExecutor().execute(this);\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleMonitor.unlock();\n+\t\t}\n \t\tsuper.start();\n \t}\n \n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioConnection.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioConnection.java\nindex fa7c2df42c4..21afc3979d1 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioConnection.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioConnection.java\n@@ -37,6 +37,8 @@\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.net.ssl.SSLSession;\n \n@@ -56,6 +58,7 @@\n  * @author John Anderson\n  * @author Artem Bilan\n  * @author David Herschler Shvo\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  *\n@@ -72,14 +75,20 @@ public class TcpNioConnection extends TcpConnectionSupport {\n \n \tprivate static final byte[] EOF = new byte[0]; // EOF marker buffer\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final SocketChannel socketChannel;\n \n+\tprivate final Lock socketChannelMonitor = new ReentrantLock();\n+\n \tprivate final ChannelOutputStream channelOutputStream = new ChannelOutputStream();\n \n \tprivate final ChannelInputStream channelInputStream = new ChannelInputStream();\n \n \tprivate final AtomicInteger executionControl = new AtomicInteger();\n \n+\tprivate final Lock executionControlMonitor = new ReentrantLock();\n+\n \tprivate boolean usingDirectBuffers;\n \n \tprivate long pipeTimeout = DEFAULT_PIPE_TIMEOUT;\n@@ -154,7 +163,8 @@ public boolean isOpen() {\n \t@Override\n \t@SuppressWarnings(\"unchecked\")\n \tpublic void send(Message<?> message) {\n-\t\tsynchronized (this.socketChannel) {\n+\t\tthis.socketChannelMonitor.lock();\n+\t\ttry {\n \t\t\ttry {\n \t\t\t\tif (this.bufferedOutputStream == null) {\n \t\t\t\t\tint writeBufferSize = this.socketChannel.socket().getSendBufferSize();\n@@ -177,6 +187,9 @@ public void send(Message<?> message) {\n \t\t\t\tlogger.debug(getConnectionId() + \" Message sent \" + message);\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.socketChannelMonitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n@@ -311,7 +324,8 @@ private boolean checkForMoreData() {\n \t\t// timing was such that we were the last assembler and\n \t\t// a new one wasn't run\n \t\tif (dataAvailable()) {\n-\t\t\tsynchronized (this.executionControl) {\n+\t\t\tthis.executionControlMonitor.lock();\n+\t\t\ttry {\n \t\t\t\tif (this.executionControl.incrementAndGet() <= 1) {\n \t\t\t\t\t// only continue if we don't already have another assembler running\n \t\t\t\t\tthis.executionControl.set(1);\n@@ -322,6 +336,9 @@ private boolean checkForMoreData() {\n \t\t\t\t\tthis.executionControl.decrementAndGet();\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.executionControlMonitor.unlock();\n+\t\t\t}\n \t\t}\n \t\tif (moreDataAvailable) {\n \t\t\tif (logger.isTraceEnabled()) {\n@@ -352,43 +369,50 @@ private boolean dataAvailable() {\n \t * @throws IOException an IO exception\n \t */\n \t@Nullable\n-\tprivate synchronized Message<?> convert() throws IOException {\n-\t\tif (logger.isTraceEnabled()) {\n-\t\t\tlogger.trace(getConnectionId() + \" checking data avail (convert): \" + this.channelInputStream.available() +\n-\t\t\t\t\t\" pending: \" + (this.writingToPipe));\n-\t\t}\n-\t\tif (this.channelInputStream.available() <= 0) {\n-\t\t\ttry {\n-\t\t\t\tif (this.writingLatch.await(SIXTY, TimeUnit.SECONDS)) {\n-\t\t\t\t\tif (this.channelInputStream.available() <= 0) {\n-\t\t\t\t\t\treturn null;\n+\tprivate Message<?> convert() throws IOException {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (logger.isTraceEnabled()) {\n+\t\t\t\tlogger.trace(\n+\t\t\t\t\t\tgetConnectionId() + \" checking data avail (convert): \" + this.channelInputStream.available() +\n+\t\t\t\t\t\t\t\t\" pending: \" + (this.writingToPipe));\n+\t\t\t}\n+\t\t\tif (this.channelInputStream.available() <= 0) {\n+\t\t\t\ttry {\n+\t\t\t\t\tif (this.writingLatch.await(SIXTY, TimeUnit.SECONDS)) {\n+\t\t\t\t\t\tif (this.channelInputStream.available() <= 0) {\n+\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\telse { // should never happen\n+\t\t\t\t\t\tthrow new IOException(\"Timed out waiting for IO\");\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\telse { // should never happen\n-\t\t\t\t\tthrow new IOException(\"Timed out waiting for IO\");\n+\t\t\t\tcatch (InterruptedException e) {\n+\t\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t\t\tthrow new IOException(\"Interrupted waiting for IO\", e);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcatch (InterruptedException e) {\n-\t\t\t\tThread.currentThread().interrupt();\n-\t\t\t\tthrow new IOException(\"Interrupted waiting for IO\", e);\n+\t\t\ttry {\n+\t\t\t\treturn getMapper().toMessage(this);\n \t\t\t}\n-\t\t}\n-\t\ttry {\n-\t\t\treturn getMapper().toMessage(this);\n-\t\t}\n-\t\tcatch (Exception e) {\n-\t\t\tcloseConnection(true);\n-\t\t\tif (e instanceof SocketTimeoutException) { // NOSONAR instanceof\n-\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\tlogger.debug(\"Closing socket after timeout \" + getConnectionId());\n+\t\t\tcatch (Exception e) {\n+\t\t\t\tcloseConnection(true);\n+\t\t\t\tif (e instanceof SocketTimeoutException) { // NOSONAR instanceof\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\tlogger.debug(\"Closing socket after timeout \" + getConnectionId());\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif (!(e instanceof SoftEndOfStreamException)) { // NOSONAR instanceof\n-\t\t\t\t\tthrow e;\n+\t\t\t\telse {\n+\t\t\t\t\tif (!(e instanceof SoftEndOfStreamException)) { // NOSONAR instanceof\n+\t\t\t\t\t\tthrow e;\n+\t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\treturn null;\n \t\t\t}\n-\t\t\treturn null;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n@@ -468,7 +492,8 @@ protected void sendToPipe(ByteBuffer rawBufferToSend) throws IOException {\n \t}\n \n \tprivate void checkForAssembler() {\n-\t\tsynchronized (this.executionControl) {\n+\t\tthis.executionControlMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.executionControl.incrementAndGet() <= 1) {\n \t\t\t\t// only execute run() if we don't already have one running\n \t\t\t\tthis.executionControl.set(1);\n@@ -489,6 +514,9 @@ private void checkForAssembler() {\n \t\t\t\tthis.executionControl.decrementAndGet();\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.executionControlMonitor.unlock();\n+\t\t}\n \t}\n \n \t/**\n@@ -605,6 +633,8 @@ class ChannelOutputStream extends OutputStream {\n \n \t\tprivate int soTimeout;\n \n+\t\tprivate final Lock innerLock = new ReentrantLock();\n+\n \t\t@Override\n \t\tpublic void write(int b) throws IOException {\n \t\t\tbyte[] bytes = new byte[1];\n@@ -632,28 +662,35 @@ public void write(byte[] b) throws IOException {\n \t\t\tdoWrite(buffer);\n \t\t}\n \n-\t\tprotected synchronized void doWrite(ByteBuffer buffer) throws IOException {\n-\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\tlogger.debug(getConnectionId() + \" writing \" + buffer.remaining());\n-\t\t\t}\n-\t\t\tTcpNioConnection.this.socketChannel.write(buffer);\n-\t\t\tint remaining = buffer.remaining();\n-\t\t\tif (remaining == 0) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tif (this.selector == null) {\n-\t\t\t\tthis.selector = Selector.open();\n-\t\t\t\tthis.soTimeout = TcpNioConnection.this.socketChannel.socket().getSoTimeout();\n-\t\t\t}\n-\t\t\tTcpNioConnection.this.socketChannel.register(this.selector, SelectionKey.OP_WRITE);\n-\t\t\twhile (remaining > 0) {\n-\t\t\t\tint selectionCount = this.selector.select(this.soTimeout);\n-\t\t\t\tif (selectionCount == 0) {\n-\t\t\t\t\tthrow new SocketTimeoutException(\"Timeout on write\");\n+\t\tprotected void doWrite(ByteBuffer buffer) throws IOException {\n+\t\t\tthis.innerLock.lock();\n+\t\t\ttry {\n+\n+\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\tlogger.debug(getConnectionId() + \" writing \" + buffer.remaining());\n \t\t\t\t}\n-\t\t\t\tthis.selector.selectedKeys().clear();\n \t\t\t\tTcpNioConnection.this.socketChannel.write(buffer);\n-\t\t\t\tremaining = buffer.remaining();\n+\t\t\t\tint remaining = buffer.remaining();\n+\t\t\t\tif (remaining == 0) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tif (this.selector == null) {\n+\t\t\t\t\tthis.selector = Selector.open();\n+\t\t\t\t\tthis.soTimeout = TcpNioConnection.this.socketChannel.socket().getSoTimeout();\n+\t\t\t\t}\n+\t\t\t\tTcpNioConnection.this.socketChannel.register(this.selector, SelectionKey.OP_WRITE);\n+\t\t\t\twhile (remaining > 0) {\n+\t\t\t\t\tint selectionCount = this.selector.select(this.soTimeout);\n+\t\t\t\t\tif (selectionCount == 0) {\n+\t\t\t\t\t\tthrow new SocketTimeoutException(\"Timeout on write\");\n+\t\t\t\t\t}\n+\t\t\t\t\tthis.selector.selectedKeys().clear();\n+\t\t\t\t\tTcpNioConnection.this.socketChannel.write(buffer);\n+\t\t\t\t\tremaining = buffer.remaining();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.innerLock.unlock();\n \t\t\t}\n \t\t}\n \n@@ -680,6 +717,8 @@ class ChannelInputStream extends InputStream {\n \n \t\tprivate volatile boolean isClosed;\n \n+\t\tprivate final Lock innerLock = new ReentrantLock();\n+\n \t\t@Override\n \t\tpublic int read(byte[] b, int off, int len) throws IOException {\n \t\t\tAssert.notNull(b, \"byte[] cannot be null\");\n@@ -708,30 +747,36 @@ else if (len == 0) {\n \t\t}\n \n \t\t@Override\n-\t\tpublic synchronized int read() throws IOException {\n-\t\t\tif (this.isClosed && this.available.get() == 0) {\n-\t\t\t\tif (TcpNioConnection.this.timedOut) {\n-\t\t\t\t\tthrow new SocketTimeoutException(\"Connection has timed out\");\n-\t\t\t\t}\n-\t\t\t\treturn -1;\n-\t\t\t}\n-\t\t\tif (this.currentBuffer == null) {\n-\t\t\t\tthis.currentBuffer = getNextBuffer();\n-\t\t\t\tthis.currentOffset = 0;\n-\t\t\t\tif (this.currentBuffer == null) {\n+\t\tpublic int read() throws IOException {\n+\t\t\tthis.innerLock.lock();\n+\t\t\ttry {\n+\t\t\t\tif (this.isClosed && this.available.get() == 0) {\n \t\t\t\t\tif (TcpNioConnection.this.timedOut) {\n \t\t\t\t\t\tthrow new SocketTimeoutException(\"Connection has timed out\");\n \t\t\t\t\t}\n \t\t\t\t\treturn -1;\n \t\t\t\t}\n+\t\t\t\tif (this.currentBuffer == null) {\n+\t\t\t\t\tthis.currentBuffer = getNextBuffer();\n+\t\t\t\t\tthis.currentOffset = 0;\n+\t\t\t\t\tif (this.currentBuffer == null) {\n+\t\t\t\t\t\tif (TcpNioConnection.this.timedOut) {\n+\t\t\t\t\t\t\tthrow new SocketTimeoutException(\"Connection has timed out\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn -1;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tint bite;\n+\t\t\t\tbite = this.currentBuffer[this.currentOffset++] & 0xff; // NOSONAR\n+\t\t\t\tthis.available.decrementAndGet();\n+\t\t\t\tif (this.currentOffset >= this.currentBuffer.length) {\n+\t\t\t\t\tthis.currentBuffer = null;\n+\t\t\t\t}\n+\t\t\t\treturn bite;\n \t\t\t}\n-\t\t\tint bite;\n-\t\t\tbite = this.currentBuffer[this.currentOffset++] & 0xff; // NOSONAR\n-\t\t\tthis.available.decrementAndGet();\n-\t\t\tif (this.currentOffset >= this.currentBuffer.length) {\n-\t\t\t\tthis.currentBuffer = null;\n+\t\t\tfinally {\n+\t\t\t\tthis.innerLock.unlock();\n \t\t\t}\n-\t\t\treturn bite;\n \t\t}\n \n \t\t@Nullable\n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioSSLConnection.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioSSLConnection.java\nindex 48c36881d90..0486f9dd43c 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioSSLConnection.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/tcp/connection/TcpNioSSLConnection.java\n@@ -21,6 +21,8 @@\n import java.nio.channels.SocketChannel;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.net.ssl.SSLEngine;\n import javax.net.ssl.SSLEngineResult;\n@@ -51,6 +53,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.2\n  *\n@@ -67,7 +70,7 @@ public class TcpNioSSLConnection extends TcpNioConnection {\n \n \tprivate final Semaphore semaphore = new Semaphore(0);\n \n-\tprivate final Object monitorLock = new Object();\n+\tprivate final Lock monitorLock = new ReentrantLock();\n \n \tprivate int handshakeTimeout = DEFAULT_HANDSHAKE_TIMEOUT;\n \n@@ -285,12 +288,16 @@ private void initializeEngine() {\n \n \t@Override\n \tprotected ChannelOutputStream getChannelOutputStream() {\n-\t\tsynchronized (this.monitorLock) {\n+\t\tthis.monitorLock.lock();\n+\t\ttry {\n \t\t\tif (this.sslChannelOutputStream == null) {\n \t\t\t\tthis.sslChannelOutputStream = new SSLChannelOutputStream(super.getChannelOutputStream());\n \t\t\t}\n \t\t\treturn this.sslChannelOutputStream;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.monitorLock.unlock();\n+\t\t}\n \t}\n \n \tprotected SSLChannelOutputStream getSSLChannelOutputStream() {\n@@ -318,6 +325,8 @@ public void close() {\n \t */\n \tfinal class SSLChannelOutputStream extends ChannelOutputStream {\n \n+\t\tprivate final Lock lock = new ReentrantLock();\n+\n \t\tprivate final ChannelOutputStream channelOutputStream;\n \n \t\tSSLChannelOutputStream(ChannelOutputStream channelOutputStream) {\n@@ -331,7 +340,8 @@ final class SSLChannelOutputStream extends ChannelOutputStream {\n \t\t * and multiple writes will be necessary.\n \t\t */\n \t\t@Override\n-\t\tprotected synchronized void doWrite(ByteBuffer plainText) throws IOException {\n+\t\tprotected void doWrite(ByteBuffer plainText) throws IOException {\n+\t\t\tthis.lock.lock();\n \t\t\ttry {\n \t\t\t\tTcpNioSSLConnection.this.writerActive = true;\n \t\t\t\tint remaining = plainText.remaining();\n@@ -357,6 +367,7 @@ protected synchronized void doWrite(ByteBuffer plainText) throws IOException {\n \t\t\t}\n \t\t\tfinally {\n \t\t\t\tTcpNioSSLConnection.this.writerActive = false;\n+\t\t\t\tthis.lock.unlock();\n \t\t\t}\n \t\t}\n \n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/MulticastReceivingChannelAdapter.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/MulticastReceivingChannelAdapter.java\nindex 74552990099..0dbaa0b064e 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/MulticastReceivingChannelAdapter.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/MulticastReceivingChannelAdapter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2020 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -32,6 +32,7 @@\n  * @author Gary Russell\n  * @author Marcin Pilaczynski\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n@@ -39,7 +40,6 @@ public class MulticastReceivingChannelAdapter extends UnicastReceivingChannelAda\n \n \tprivate final String group;\n \n-\n \t/**\n \t * Constructs a MulticastReceivingChannelAdapter that listens for packets on the\n \t * specified multichannel address (group) and port.\n@@ -65,24 +65,31 @@ public MulticastReceivingChannelAdapter(String group, int port, boolean lengthCh\n \t}\n \n \t@Override\n-\tpublic synchronized DatagramSocket getSocket() {\n-\t\tif (getTheSocket() == null) {\n-\t\t\ttry {\n-\t\t\t\tint port = getPort();\n-\t\t\t\tMulticastSocket socket = port == 0 ? new MulticastSocket() : new MulticastSocket(port);\n-\t\t\t\tString localAddress = getLocalAddress();\n-\t\t\t\tif (localAddress != null) {\n-\t\t\t\t\tsocket.setNetworkInterface(NetworkInterface.getByInetAddress(InetAddress.getByName(localAddress)));\n+\tpublic DatagramSocket getSocket() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (getTheSocket() == null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tint port = getPort();\n+\t\t\t\t\tMulticastSocket socket = port == 0 ? new MulticastSocket() : new MulticastSocket(port);\n+\t\t\t\t\tString localAddress = getLocalAddress();\n+\t\t\t\t\tif (localAddress != null) {\n+\t\t\t\t\t\tsocket.setNetworkInterface(\n+\t\t\t\t\t\t\t\tNetworkInterface.getByInetAddress(InetAddress.getByName(localAddress)));\n+\t\t\t\t\t}\n+\t\t\t\t\tsetSocketAttributes(socket);\n+\t\t\t\t\tsocket.joinGroup(new InetSocketAddress(this.group, 0), null);\n+\t\t\t\t\tsetSocket(socket);\n+\t\t\t\t}\n+\t\t\t\tcatch (IOException e) {\n+\t\t\t\t\tthrow new MessagingException(\"failed to create DatagramSocket\", e);\n \t\t\t\t}\n-\t\t\t\tsetSocketAttributes(socket);\n-\t\t\t\tsocket.joinGroup(new InetSocketAddress(this.group, 0), null);\n-\t\t\t\tsetSocket(socket);\n-\t\t\t}\n-\t\t\tcatch (IOException e) {\n-\t\t\t\tthrow new MessagingException(\"failed to create DatagramSocket\", e);\n \t\t\t}\n+\t\t\treturn super.getSocket();\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\treturn super.getSocket();\n \t}\n \n }\n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/MulticastSendingMessageHandler.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/MulticastSendingMessageHandler.java\nindex e863c3b8821..b6b57190fc1 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/MulticastSendingMessageHandler.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/MulticastSendingMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2001-2020 the original author or authors.\n+ * Copyright 2001-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -37,6 +37,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n@@ -129,11 +130,17 @@ public MulticastSendingMessageHandler(String destinationExpression) {\n \t}\n \n \t@Override\n-\tprotected synchronized DatagramSocket getSocket() throws IOException {\n-\t\tif (getTheSocket() == null) {\n-\t\t\tcreateSocket();\n+\tprotected DatagramSocket getSocket() throws IOException {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (getTheSocket() == null) {\n+\t\t\t\tcreateSocket();\n+\t\t\t}\n+\t\t\treturn super.getSocket();\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\treturn super.getSocket();\n \t}\n \n \tprivate void createSocket() throws IOException {\n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/UnicastReceivingChannelAdapter.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/UnicastReceivingChannelAdapter.java\nindex 1f045c7e70b..db8b380c3e1 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/UnicastReceivingChannelAdapter.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/UnicastReceivingChannelAdapter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -25,6 +25,8 @@\n import java.net.SocketTimeoutException;\n import java.util.concurrent.Executor;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n@@ -44,6 +46,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n@@ -53,6 +56,8 @@ public class UnicastReceivingChannelAdapter extends AbstractInternetProtocolRece\n \n \tprivate final DatagramPacketMessageMapper mapper = new DatagramPacketMessageMapper();\n \n+\tprotected final Lock lock = new ReentrantLock();\n+\n \tprivate DatagramSocket socket;\n \n \tprivate boolean socketExplicitlySet;\n@@ -248,27 +253,33 @@ protected DatagramSocket getTheSocket() {\n \t\treturn this.socket;\n \t}\n \n-\tpublic synchronized DatagramSocket getSocket() {\n-\t\tif (this.socket == null) {\n-\t\t\ttry {\n-\t\t\t\tDatagramSocket datagramSocket;\n-\t\t\t\tString localAddress = getLocalAddress();\n-\t\t\t\tint port = super.getPort();\n-\t\t\t\tif (localAddress == null) {\n-\t\t\t\t\tdatagramSocket = port == 0 ? new DatagramSocket() : new DatagramSocket(port);\n+\tpublic DatagramSocket getSocket() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.socket == null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tDatagramSocket datagramSocket;\n+\t\t\t\t\tString localAddress = getLocalAddress();\n+\t\t\t\t\tint port = super.getPort();\n+\t\t\t\t\tif (localAddress == null) {\n+\t\t\t\t\t\tdatagramSocket = port == 0 ? new DatagramSocket() : new DatagramSocket(port);\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tInetAddress whichNic = InetAddress.getByName(localAddress);\n+\t\t\t\t\t\tdatagramSocket = new DatagramSocket(new InetSocketAddress(whichNic, port));\n+\t\t\t\t\t}\n+\t\t\t\t\tsetSocketAttributes(datagramSocket);\n+\t\t\t\t\tthis.socket = datagramSocket;\n \t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tInetAddress whichNic = InetAddress.getByName(localAddress);\n-\t\t\t\t\tdatagramSocket = new DatagramSocket(new InetSocketAddress(whichNic, port));\n+\t\t\t\tcatch (IOException e) {\n+\t\t\t\t\tthrow new MessagingException(\"failed to create DatagramSocket\", e);\n \t\t\t\t}\n-\t\t\t\tsetSocketAttributes(datagramSocket);\n-\t\t\t\tthis.socket = datagramSocket;\n-\t\t\t}\n-\t\t\tcatch (IOException e) {\n-\t\t\t\tthrow new MessagingException(\"failed to create DatagramSocket\", e);\n \t\t\t}\n+\t\t\treturn this.socket;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\treturn this.socket;\n \t}\n \n \t/**\n\ndiff --git a/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/UnicastSendingMessageHandler.java b/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/UnicastSendingMessageHandler.java\nindex a5a8c40aa92..ba638af6ae0 100644\n--- a/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/UnicastSendingMessageHandler.java\n+++ b/spring-integration-ip/src/main/java/org/springframework/integration/ip/udp/UnicastSendingMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2001-2022 the original author or authors.\n+ * Copyright 2001-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -34,6 +34,8 @@\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.expression.EvaluationContext;\n import org.springframework.expression.Expression;\n@@ -58,6 +60,7 @@\n  * @author Gary Russell\n  * @author Marcin Pilaczynski\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n@@ -66,6 +69,8 @@ public class UnicastSendingMessageHandler extends\n \n \tprivate static final int DEFAULT_ACK_TIMEOUT = 5000;\n \n+\tprotected final Lock lock = new ReentrantLock();\n+\n \tprivate final DatagramPacketMessageMapper mapper = new DatagramPacketMessageMapper();\n \n \tprivate final Map<String, CountDownLatch> ackControl = Collections.synchronizedMap(new HashMap<>());\n@@ -316,7 +321,8 @@ public void handleMessageInternal(Message<?> message) {\n \n \tpublic void startAckThread() {\n \t\tif (!this.ackThreadRunning) {\n-\t\t\tsynchronized (this) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (!this.ackThreadRunning) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tgetSocket();\n@@ -334,6 +340,9 @@ public void startAckThread() {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -386,28 +395,34 @@ protected DatagramSocket getTheSocket() {\n \t\treturn this.socket;\n \t}\n \n-\tprotected synchronized DatagramSocket getSocket() throws IOException {\n-\t\tif (this.socket == null) {\n-\t\t\tif (this.acknowledge) {\n-\t\t\t\tif (this.localAddress == null) {\n-\t\t\t\t\tthis.socket = this.ackPort == 0 ? new DatagramSocket() : new DatagramSocket(this.ackPort);\n+\tprotected DatagramSocket getSocket() throws IOException {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.socket == null) {\n+\t\t\t\tif (this.acknowledge) {\n+\t\t\t\t\tif (this.localAddress == null) {\n+\t\t\t\t\t\tthis.socket = this.ackPort == 0 ? new DatagramSocket() : new DatagramSocket(this.ackPort);\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tInetAddress whichNic = InetAddress.getByName(this.localAddress);\n+\t\t\t\t\t\tthis.socket = new DatagramSocket(new InetSocketAddress(whichNic, this.ackPort));\n+\t\t\t\t\t}\n+\t\t\t\t\tif (this.soReceiveBufferSize > 0) {\n+\t\t\t\t\t\tthis.socket.setReceiveBufferSize(this.soReceiveBufferSize);\n+\t\t\t\t\t}\n+\t\t\t\t\tlogger.debug(() -> \"Listening for acks on port: \" + getAckPort());\n+\t\t\t\t\tupdateAckAddress();\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tInetAddress whichNic = InetAddress.getByName(this.localAddress);\n-\t\t\t\t\tthis.socket = new DatagramSocket(new InetSocketAddress(whichNic, this.ackPort));\n+\t\t\t\t\tthis.socket = new DatagramSocket();\n \t\t\t\t}\n-\t\t\t\tif (this.soReceiveBufferSize > 0) {\n-\t\t\t\t\tthis.socket.setReceiveBufferSize(this.soReceiveBufferSize);\n-\t\t\t\t}\n-\t\t\t\tlogger.debug(() -> \"Listening for acks on port: \" + getAckPort());\n-\t\t\t\tupdateAckAddress();\n+\t\t\t\tsetSocketAttributes(this.socket);\n \t\t\t}\n-\t\t\telse {\n-\t\t\t\tthis.socket = new DatagramSocket();\n-\t\t\t}\n-\t\t\tsetSocketAttributes(this.socket);\n+\t\t\treturn this.socket;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\treturn this.socket;\n \t}\n \n \tprotected void updateAckAddress() {\n@@ -424,8 +439,14 @@ public void setSoReceiveBufferSize(int size) {\n \t}\n \n \t@Override\n-\tpublic synchronized void setLocalAddress(String localAddress) {\n-\t\tthis.localAddress = localAddress;\n+\tpublic void setLocalAddress(String localAddress) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tthis.localAddress = localAddress;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \tpublic void setTaskExecutor(Executor taskExecutor) {\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/StoredProcExecutor.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/StoredProcExecutor.java\nindex 294e0c789d1..7b2b95e2cbf 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/StoredProcExecutor.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/StoredProcExecutor.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,6 +23,8 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.sql.DataSource;\n \n@@ -51,6 +53,7 @@\n  * @author Gunnar Hillert\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n  *\n  * @since 2.1\n  *\n@@ -63,7 +66,7 @@ public class StoredProcExecutor implements BeanFactoryAware, InitializingBean {\n \n \tprivate final DataSource dataSource;\n \n-\tprivate final Object jdbcCallOperationsMapMonitor = new Object();\n+\tprivate final Lock jdbcCallOperationsMapMonitor = new ReentrantLock();\n \n \tprivate Map<String, RowMapper<?>> returningResultSetRowMappers = new HashMap<>(0);\n \n@@ -301,10 +304,14 @@ private Map<String, Object> executeStoredProcedureInternal(Object input, String\n \tprivate SimpleJdbcCallOperations obtainSimpleJdbcCall(String storedProcedureName) {\n \t\tSimpleJdbcCallOperations operations = this.jdbcCallOperationsMap.get(storedProcedureName);\n \t\tif (operations == null) {\n-\t\t\tsynchronized (this.jdbcCallOperationsMapMonitor) {\n+\t\t\tthis.jdbcCallOperationsMapMonitor.lock();\n+\t\t\ttry {\n \t\t\t\toperations =\n \t\t\t\t\t\tthis.jdbcCallOperationsMap.computeIfAbsent(storedProcedureName, this::createSimpleJdbcCall);\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.jdbcCallOperationsMapMonitor.unlock();\n+\t\t\t}\n \t\t}\n \t\treturn operations;\n \t}\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java\nindex 08d0c74b4f0..d0a5cd82902 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java\n@@ -26,6 +26,8 @@\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.postgresql.PGNotification;\n import org.postgresql.jdbc.PgConnection;\n@@ -61,6 +63,7 @@\n  * @author Rafael Winterhalter\n  * @author Artem Bilan\n  * @author Igor Lovich\n+ * @author Christian Tzolov\n  *\n  * @since 6.0\n  */\n@@ -68,6 +71,8 @@ public final class PostgresChannelMessageTableSubscriber implements SmartLifecyc\n \n \tprivate static final LogAccessor LOGGER = new LogAccessor(PostgresChannelMessageTableSubscriber.class);\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final Map<String, Set<Subscription>> subscriptionsMap = new ConcurrentHashMap<>();\n \n \tprivate final PgConnectionSupplier connectionSupplier;\n@@ -111,8 +116,14 @@ public PostgresChannelMessageTableSubscriber(PgConnectionSupplier connectionSupp\n \t * @deprecated since 6.2 in favor of {@link #setTaskExecutor(AsyncTaskExecutor)}\n \t */\n \t@Deprecated(since = \"6.2\", forRemoval = true)\n-\tpublic synchronized void setExecutor(ExecutorService executor) {\n-\t\tsetTaskExecutor(new TaskExecutorAdapter(executor));\n+\tpublic void setExecutor(ExecutorService executor) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tsetTaskExecutor(new TaskExecutorAdapter(executor));\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t/**\n@@ -149,85 +160,96 @@ public boolean unsubscribe(Subscription subscription) {\n \t}\n \n \t@Override\n-\tpublic synchronized void start() {\n-\t\tif (this.latch.getCount() > 0) {\n-\t\t\treturn;\n-\t\t}\n+\tpublic void start() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.latch.getCount() > 0) {\n+\t\t\t\treturn;\n+\t\t\t}\n \n-\t\tthis.latch = new CountDownLatch(1);\n+\t\t\tthis.latch = new CountDownLatch(1);\n+\n+\t\t\tCountDownLatch startingLatch = new CountDownLatch(1);\n+\t\t\tthis.future = this.taskExecutor.submit(() -> {\n+\t\t\t\tdoStart(startingLatch);\n+\t\t\t});\n \n-\t\tCountDownLatch startingLatch = new CountDownLatch(1);\n-\t\tthis.future = this.taskExecutor.submit(() -> {\n \t\t\ttry {\n-\t\t\t\twhile (isActive()) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tPgConnection conn = this.connectionSupplier.get();\n-\t\t\t\t\t\ttry (Statement stmt = conn.createStatement()) {\n-\t\t\t\t\t\t\tstmt.execute(\"LISTEN \" + this.tablePrefix.toLowerCase() + \"channel_message_notify\");\n+\t\t\t\tif (!startingLatch.await(5, TimeUnit.SECONDS)) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Failed to start \" + this);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcatch (InterruptedException ex) {\n+\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t\tthrow new IllegalStateException(\"Failed to start \" + this, ex);\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n+\t}\n+\n+\tprivate void doStart(CountDownLatch startingLatch) {\n+\t\ttry {\n+\t\t\twhile (isActive()) {\n+\t\t\t\ttry {\n+\t\t\t\t\tPgConnection conn = this.connectionSupplier.get();\n+\t\t\t\t\ttry (Statement stmt = conn.createStatement()) {\n+\t\t\t\t\t\tstmt.execute(\"LISTEN \" + this.tablePrefix.toLowerCase() + \"channel_message_notify\");\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tconn.close();\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (Exception ex) {\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tconn.close();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (Exception suppressed) {\n-\t\t\t\t\t\t\t\tex.addSuppressed(suppressed);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tthrow ex;\n+\t\t\t\t\t\tcatch (Exception suppressed) {\n+\t\t\t\t\t\t\tex.addSuppressed(suppressed);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tthis.subscriptionsMap.values()\n-\t\t\t\t\t\t\t\t.forEach(subscriptions -> subscriptions.forEach(Subscription::notifyUpdate));\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tthis.connection = conn;\n-\t\t\t\t\t\t\twhile (isActive()) {\n-\t\t\t\t\t\t\t\tstartingLatch.countDown();\n-\n-\t\t\t\t\t\t\t\tPGNotification[] notifications = conn.getNotifications(0);\n-\t\t\t\t\t\t\t\t// Unfortunately, there is no good way of interrupting a notification\n-\t\t\t\t\t\t\t\t// poll but by closing its connection.\n-\t\t\t\t\t\t\t\tif (!isActive()) {\n-\t\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tif (notifications != null) {\n-\t\t\t\t\t\t\t\t\tfor (PGNotification notification : notifications) {\n-\t\t\t\t\t\t\t\t\t\tString parameter = notification.getParameter();\n-\t\t\t\t\t\t\t\t\t\tSet<Subscription> subscriptions = this.subscriptionsMap.get(parameter);\n-\t\t\t\t\t\t\t\t\t\tif (subscriptions == null) {\n-\t\t\t\t\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\tfor (Subscription subscription : subscriptions) {\n-\t\t\t\t\t\t\t\t\t\t\tsubscription.notifyUpdate();\n-\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\tthrow ex;\n+\t\t\t\t\t}\n+\t\t\t\t\tthis.subscriptionsMap.values()\n+\t\t\t\t\t\t\t.forEach(subscriptions -> subscriptions.forEach(Subscription::notifyUpdate));\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tthis.connection = conn;\n+\t\t\t\t\t\twhile (isActive()) {\n+\t\t\t\t\t\t\tstartingLatch.countDown();\n+\n+\t\t\t\t\t\t\tPGNotification[] notifications = conn.getNotifications(0);\n+\t\t\t\t\t\t\t// Unfortunately, there is no good way of interrupting a notification\n+\t\t\t\t\t\t\t// poll but by closing its connection.\n+\t\t\t\t\t\t\tif (!isActive()) {\n+\t\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (notifications != null) {\n+\t\t\t\t\t\t\t\tfor (PGNotification notification : notifications) {\n+\t\t\t\t\t\t\t\t\tString parameter = notification.getParameter();\n+\t\t\t\t\t\t\t\t\tSet<Subscription> subscriptions = this.subscriptionsMap.get(parameter);\n+\t\t\t\t\t\t\t\t\tif (subscriptions == null) {\n+\t\t\t\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tfor (Subscription subscription : subscriptions) {\n+\t\t\t\t\t\t\t\t\t\tsubscription.notifyUpdate();\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tfinally {\n-\t\t\t\t\t\t\tconn.close();\n-\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\t\t// The getNotifications method does not throw a meaningful message on interruption.\n-\t\t\t\t\t\t// Therefore, we do not log an error, unless it occurred while active.\n-\t\t\t\t\t\tif (isActive()) {\n-\t\t\t\t\t\t\tLOGGER.error(e, \"Failed to poll notifications from Postgres database\");\n-\t\t\t\t\t\t}\n+\t\t\t\t\tfinally {\n+\t\t\t\t\t\tconn.close();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tcatch (Exception e) {\n+\t\t\t\t\t// The getNotifications method does not throw a meaningful message on interruption.\n+\t\t\t\t\t// Therefore, we do not log an error, unless it occurred while active.\n+\t\t\t\t\tif (isActive()) {\n+\t\t\t\t\t\tLOGGER.error(e, \"Failed to poll notifications from Postgres database\");\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n-\t\t\tfinally {\n-\t\t\t\tthis.latch.countDown();\n-\t\t\t}\n-\t\t});\n-\n-\t\ttry {\n-\t\t\tif (!startingLatch.await(5, TimeUnit.SECONDS)) {\n-\t\t\t\tthrow new IllegalStateException(\"Failed to start \" + this);\n \t\t\t}\n \t\t}\n-\t\tcatch (InterruptedException ex) {\n-\t\t\tThread.currentThread().interrupt();\n-\t\t\tthrow new IllegalStateException(\"Failed to start \" + this, ex);\n+\t\tfinally {\n+\t\t\tthis.latch.countDown();\n \t\t}\n+\n \t}\n \n \tprivate boolean isActive() {\n@@ -239,25 +261,31 @@ private boolean isActive() {\n \t}\n \n \t@Override\n-\tpublic synchronized void stop() {\n-\t\tif (this.future.isDone()) {\n-\t\t\treturn;\n-\t\t}\n-\t\tthis.future.cancel(true);\n-\t\tPgConnection conn = this.connection;\n-\t\tif (conn != null) {\n-\t\t\ttry {\n-\t\t\t\tconn.close();\n+\tpublic void stop() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.future.isDone()) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tthis.future.cancel(true);\n+\t\t\tPgConnection conn = this.connection;\n+\t\t\tif (conn != null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tconn.close();\n+\t\t\t\t}\n+\t\t\t\tcatch (SQLException ignored) {\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tcatch (SQLException ignored) {\n+\t\t\ttry {\n+\t\t\t\tif (!this.latch.await(5, TimeUnit.SECONDS)) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Failed to stop \" + this);\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n-\t\ttry {\n-\t\t\tif (!this.latch.await(5, TimeUnit.SECONDS)) {\n-\t\t\t\tthrow new IllegalStateException(\"Failed to stop \" + this);\n+\t\t\tcatch (InterruptedException ignored) {\n \t\t\t}\n \t\t}\n-\t\tcatch (InterruptedException ignored) {\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/JdbcLockRegistry.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/JdbcLockRegistry.java\nindex f4f01af77a1..215f89875cc 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/JdbcLockRegistry.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/lock/JdbcLockRegistry.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2022 the original author or authors.\n+ * Copyright 2016-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -54,6 +54,7 @@\n  * @author Olivier Hubaut\n  * @author Fran Aranda\n  * @author Unseok Kim\n+ * @author Christian Tzolov\n  *\n  * @since 4.3\n  */\n@@ -63,6 +64,8 @@ public class JdbcLockRegistry implements ExpirableLockRegistry, RenewableLockReg\n \n \tprivate static final int DEFAULT_CAPACITY = 100_000;\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final Map<String, JdbcLock> locks =\n \t\t\tnew LinkedHashMap<String, JdbcLock>(16, 0.75F, true) {\n \n@@ -111,9 +114,13 @@ public void setCacheCapacity(int cacheCapacity) {\n \tpublic Lock obtain(Object lockKey) {\n \t\tAssert.isInstanceOf(String.class, lockKey);\n \t\tString path = pathFor((String) lockKey);\n-\t\tsynchronized (this.locks) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\treturn this.locks.computeIfAbsent(path, key -> new JdbcLock(this.client, this.idleBetweenTries, key));\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \tprivate String pathFor(String input) {\n@@ -123,13 +130,17 @@ private String pathFor(String input) {\n \t@Override\n \tpublic void expireUnusedOlderThan(long age) {\n \t\tlong now = System.currentTimeMillis();\n-\t\tsynchronized (this.locks) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tthis.locks.entrySet()\n \t\t\t\t\t.removeIf(entry -> {\n \t\t\t\t\t\tJdbcLock lock = entry.getValue();\n \t\t\t\t\t\treturn now - lock.getLastUsed() > age && !lock.isAcquiredInThisProcess();\n \t\t\t\t\t});\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n@@ -137,9 +148,14 @@ public void renewLock(Object lockKey) {\n \t\tAssert.isInstanceOf(String.class, lockKey);\n \t\tString path = pathFor((String) lockKey);\n \t\tJdbcLock jdbcLock;\n-\t\tsynchronized (this.locks) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tjdbcLock = this.locks.get(path);\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n+\n \t\tif (jdbcLock == null) {\n \t\t\tthrow new IllegalStateException(\"Could not found mutex at \" + path);\n \t\t}\n\ndiff --git a/spring-integration-jms/src/main/java/org/springframework/integration/jms/JmsOutboundGateway.java b/spring-integration-jms/src/main/java/org/springframework/integration/jms/JmsOutboundGateway.java\nindex 59de0f8f644..8a07a7860bf 100644\n--- a/spring-integration-jms/src/main/java/org/springframework/integration/jms/JmsOutboundGateway.java\n+++ b/spring-integration-jms/src/main/java/org/springframework/integration/jms/JmsOutboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -29,6 +29,8 @@\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import jakarta.jms.Connection;\n import jakarta.jms.ConnectionFactory;\n@@ -81,6 +83,7 @@\n  * @author Oleg Zhurakousky\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class JmsOutboundGateway extends AbstractReplyProducingMessageHandler\n \t\timplements ManageableLifecycle, MessageListener {\n@@ -90,7 +93,7 @@ public class JmsOutboundGateway extends AbstractReplyProducingMessageHandler\n \t */\n \tpublic static final long DEFAULT_RECEIVE_TIMEOUT = 5000L;\n \n-\tprivate final Object initializationMonitor = new Object();\n+\tprivate final Lock initializationMonitor = new ReentrantLock();\n \n \tprivate final AtomicLong correlationId = new AtomicLong();\n \n@@ -100,10 +103,12 @@ public class JmsOutboundGateway extends AbstractReplyProducingMessageHandler\n \n \tprivate final ConcurrentHashMap<String, TimedReply> earlyOrLateReplies = new ConcurrentHashMap<>();\n \n+\tprivate final Lock earlyOrLateRepliesMonitor = new ReentrantLock();\n+\n \tprivate final Map<String, CompletableFuture<AbstractIntegrationMessageBuilder<?>>> futures =\n \t\t\tnew ConcurrentHashMap<>();\n \n-\tprivate final Object lifeCycleMonitor = new Object();\n+\tprivate final Lock lifeCycleMonitor = new ReentrantLock();\n \n \tprivate Destination requestDestination;\n \n@@ -512,7 +517,8 @@ private Destination resolveReplyDestination(String repDestinationName, Session s\n \n \t@Override\n \tprotected void doInit() {\n-\t\tsynchronized (this.initializationMonitor) {\n+\t\tthis.initializationMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.initialized) {\n \t\t\t\treturn;\n \t\t\t}\n@@ -539,6 +545,9 @@ protected void doInit() {\n \t\t\tinitializeReplyContainer();\n \t\t\tthis.initialized = true;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.initializationMonitor.unlock();\n+\t\t}\n \t}\n \n \tprivate void initializeReplyContainer() {\n@@ -667,7 +676,8 @@ private void applyReplyContainerProperties(GatewayReplyListenerContainer contain\n \n \t@Override\n \tpublic void start() {\n-\t\tsynchronized (this.lifeCycleMonitor) {\n+\t\tthis.lifeCycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (!this.active) {\n \t\t\t\tif (this.replyContainer != null) {\n \t\t\t\t\tTaskScheduler taskScheduler = getTaskScheduler();\n@@ -689,11 +699,15 @@ public void start() {\n \t\t\t\tthis.active = true;\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifeCycleMonitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic void stop() {\n-\t\tsynchronized (this.lifeCycleMonitor) {\n+\t\tthis.lifeCycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.replyContainer != null) {\n \t\t\t\tthis.replyContainer.shutdown();\n \t\t\t\tthis.wasStopped = true;\n@@ -708,6 +722,10 @@ public void stop() {\n \t\t\t}\n \t\t\tthis.active = false;\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifeCycleMonitor.unlock();\n+\t\t}\n+\n \t}\n \n \t@Override\n@@ -727,7 +745,8 @@ protected Object handleRequestMessage(final Message<?> requestMessage) {\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif (this.idleReplyContainerTimeout > 0) {\n-\t\t\t\t\tsynchronized (this.lifeCycleMonitor) {\n+\t\t\t\t\tthis.lifeCycleMonitor.lock();\n+\t\t\t\t\ttry {\n \t\t\t\t\t\tthis.lastSend = System.currentTimeMillis();\n \t\t\t\t\t\tif (!this.replyContainer.isRunning()) {\n \t\t\t\t\t\t\tlogger.debug(() -> getComponentName() + \": Starting reply container.\");\n@@ -738,6 +757,9 @@ protected Object handleRequestMessage(final Message<?> requestMessage) {\n \t\t\t\t\t\t\t\t\t\t\t\t\tDuration.ofMillis(this.idleReplyContainerTimeout / 2));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tfinally {\n+\t\t\t\t\t\tthis.lifeCycleMonitor.unlock();\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\treply = sendAndReceiveWithContainer(requestMessage);\n \t\t\t}\n@@ -1121,13 +1143,17 @@ private jakarta.jms.Message doSendAndReceiveAsyncDefaultCorrelation(Destination\n \t\t\t/*\n \t\t\t * Check to see if the reply arrived before we obtained the correlationId\n \t\t\t */\n-\t\t\tsynchronized (this.earlyOrLateReplies) {\n+\t\t\tthis.earlyOrLateRepliesMonitor.lock();\n+\t\t\ttry {\n \t\t\t\tTimedReply timedReply = this.earlyOrLateReplies.remove(correlation);\n \t\t\t\tif (timedReply != null) {\n \t\t\t\t\tlogger.debug(() -> \"Found early reply with correlationId \" + correlationToLog);\n \t\t\t\t\treplyQueue.add(timedReply.getReply());\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.earlyOrLateRepliesMonitor.unlock();\n+\t\t\t}\n \n \t\t\treturn obtainReplyFromContainer(correlation, replyQueue);\n \t\t}\n@@ -1298,13 +1324,17 @@ private void onMessageSync(jakarta.jms.Message message, String correlationId) {\n \t\t\t\t\t}\n \t\t\t\t\tthrow new IllegalStateException(\"No sender waiting for reply\");\n \t\t\t\t}\n-\t\t\t\tsynchronized (this.earlyOrLateReplies) {\n+\t\t\t\tthis.earlyOrLateRepliesMonitor.lock();\n+\t\t\t\ttry {\n \t\t\t\t\tqueue = this.replies.get(correlationId);\n \t\t\t\t\tif (queue == null) {\n \t\t\t\t\t\tlogger.debug(() -> \"Reply for correlationId \" + correlationId + \" received early or late\");\n \t\t\t\t\t\tthis.earlyOrLateReplies.put(correlationId, new TimedReply(message));\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\tthis.earlyOrLateRepliesMonitor.unlock();\n+\t\t\t\t}\n \t\t\t}\n \t\t\tif (queue != null) {\n \t\t\t\tlogger.debug(() -> \"Received reply with correlationId \" + correlationId);\n@@ -1466,7 +1496,8 @@ private class IdleContainerStopper implements Runnable {\n \n \t\t@Override\n \t\tpublic void run() {\n-\t\t\tsynchronized (JmsOutboundGateway.this.lifeCycleMonitor) {\n+\t\t\tJmsOutboundGateway.this.lifeCycleMonitor.lock();\n+\t\t\ttry {\n \t\t\t\tif (System.currentTimeMillis() - JmsOutboundGateway.this.lastSend >\n \t\t\t\t\t\tJmsOutboundGateway.this.idleReplyContainerTimeout\n \t\t\t\t\t\t&& JmsOutboundGateway.this.replies.size() == 0 &&\n@@ -1478,6 +1509,9 @@ public void run() {\n \t\t\t\t\tJmsOutboundGateway.this.idleTask = null;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tJmsOutboundGateway.this.lifeCycleMonitor.unlock();\n+\t\t\t}\n \t\t}\n \n \t}\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java\nindex 7f621e0264a..96d1e18180e 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018-2022 the original author or authors.\n+ * Copyright 2018-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -30,6 +30,8 @@\n import java.util.TreeSet;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n@@ -95,6 +97,7 @@\n  * @author Mark Norkin\n  * @author Artem Bilan\n  * @author Anshul Mehra\n+ * @author Christian Tzolov\n  *\n  * @since 5.4\n  *\n@@ -111,11 +114,13 @@ public class KafkaMessageSource<K, V> extends AbstractMessageSource<Object> impl\n \t */\n \tpublic static final String REMAINING_RECORDS = KafkaHeaders.PREFIX + \"remainingRecords\";\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final ConsumerFactory<K, V> consumerFactory;\n \n \tprivate final KafkaAckCallbackFactory<K, V> ackCallbackFactory;\n \n-\tprivate final Object consumerMonitor = new Object();\n+\tprivate final Lock consumerMonitor = new ReentrantLock();\n \n \tprivate final Map<TopicPartition, Set<KafkaAckInfo<K, V>>> inflightRecords = new ConcurrentHashMap<>();\n \n@@ -385,31 +390,61 @@ private boolean maxPollStringGtr1(Object maxPoll) {\n \t}\n \n \t@Override\n-\tpublic synchronized boolean isRunning() {\n-\t\treturn this.running;\n+\tpublic boolean isRunning() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\treturn this.running;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic synchronized void start() {\n-\t\tthis.running = true;\n-\t\tthis.stopped = false;\n+\tpublic void start() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tthis.running = true;\n+\t\t\tthis.stopped = false;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic synchronized void stop() {\n-\t\tstopConsumer();\n-\t\tthis.running = false;\n-\t\tthis.stopped = true;\n+\tpublic void stop() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tstopConsumer();\n+\t\t\tthis.running = false;\n+\t\t\tthis.stopped = true;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic synchronized void pause() {\n-\t\tthis.pausing = true;\n+\tpublic void pause() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tthis.pausing = true;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic synchronized void resume() {\n-\t\tthis.pausing = false;\n+\tpublic void resume() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tthis.pausing = false;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n@@ -418,35 +453,43 @@ public boolean isPaused() {\n \t}\n \n \t@Override // NOSONAR - not so complex\n-\tprotected synchronized Object doReceive() {\n-\t\tif (this.stopped) {\n-\t\t\tthis.logger.debug(\"Message source is stopped; no records will be returned\");\n-\t\t\treturn null;\n-\t\t}\n-\t\tif (this.consumer == null) {\n-\t\t\tcreateConsumer();\n-\t\t\tthis.running = true;\n-\t\t}\n-\t\tif (this.pausing && !this.paused && this.assignedPartitions.size() > 0) {\n-\t\t\tthis.consumer.pause(this.assignedPartitions);\n-\t\t\tthis.paused = true;\n-\t\t}\n-\t\telse if (this.paused && !this.pausing) {\n-\t\t\tthis.consumer.resume(this.assignedPartitions);\n-\t\t\tthis.paused = false;\n+\tprotected Object doReceive() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\n+\t\t\tif (this.stopped) {\n+\t\t\t\tthis.logger.debug(\"Message source is stopped; no records will be returned\");\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tif (this.consumer == null) {\n+\t\t\t\tcreateConsumer();\n+\t\t\t\tthis.running = true;\n+\t\t\t}\n+\t\t\tif (this.pausing && !this.paused && this.assignedPartitions.size() > 0) {\n+\t\t\t\tthis.consumer.pause(this.assignedPartitions);\n+\t\t\t\tthis.paused = true;\n+\t\t\t}\n+\t\t\telse if (this.paused && !this.pausing) {\n+\t\t\t\tthis.consumer.resume(this.assignedPartitions);\n+\t\t\t\tthis.paused = false;\n+\t\t\t}\n+\t\t\tif (this.paused && this.recordsIterator == null) {\n+\t\t\t\tthis.logger.debug(\"Consumer is paused; no records will be returned\");\n+\t\t\t}\n+\t\t\tConsumerRecord<K, V> record = pollRecord();\n+\n+\t\t\treturn record != null\n+\t\t\t\t\t? recordToMessage(record)\n+\t\t\t\t\t: null;\n \t\t}\n-\t\tif (this.paused && this.recordsIterator == null) {\n-\t\t\tthis.logger.debug(\"Consumer is paused; no records will be returned\");\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\tConsumerRecord<K, V> record = pollRecord();\n-\n-\t\treturn record != null\n-\t\t\t\t? recordToMessage(record)\n-\t\t\t\t: null;\n \t}\n \n \tprotected void createConsumer() {\n-\t\tsynchronized (this.consumerMonitor) {\n+\t\tthis.consumerMonitor.lock();\n+\t\ttry {\n \t\t\tthis.consumer = this.consumerFactory.createConsumer(this.consumerProperties.getGroupId(),\n \t\t\t\t\tthis.consumerProperties.getClientId(), null, this.consumerProperties.getKafkaConsumerProperties());\n \n@@ -466,6 +509,9 @@ else if (partitions != null) {\n \t\t\t\t\t\trebalanceCallback);\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.consumerMonitor.unlock();\n+\t\t}\n \t}\n \n \tprivate void assignAndSeekPartitions(TopicPartitionOffset[] partitions) {\n@@ -522,7 +568,8 @@ private ConsumerRecord<K, V> pollRecord() {\n \t\t\treturn nextRecord();\n \t\t}\n \t\telse {\n-\t\t\tsynchronized (this.consumerMonitor) {\n+\t\t\tthis.consumerMonitor.lock();\n+\t\t\ttry {\n \t\t\t\ttry {\n \t\t\t\t\tConsumerRecords<K, V> records = this.consumer\n \t\t\t\t\t\t\t.poll(this.assignedPartitions.isEmpty() ? this.assignTimeout : this.pollTimeout);\n@@ -545,6 +592,9 @@ private ConsumerRecord<K, V> pollRecord() {\n \t\t\t\t\treturn null;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.consumerMonitor.unlock();\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -590,18 +640,28 @@ private Object recordToMessage(ConsumerRecord<K, V> record) {\n \t}\n \n \t@Override\n-\tpublic synchronized void destroy() {\n-\t\tstopConsumer();\n+\tpublic void destroy() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tstopConsumer();\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \tprivate void stopConsumer() {\n-\t\tsynchronized (this.consumerMonitor) {\n+\t\tthis.consumerMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.consumer != null) {\n \t\t\t\tthis.consumer.close(this.closeTimeout);\n \t\t\t\tthis.consumer = null;\n \t\t\t\tthis.assignedPartitions.clear();\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.consumerMonitor.unlock();\n+\t\t}\n \t}\n \n \tprivate class IntegrationConsumerRebalanceListener implements ConsumerRebalanceListener {\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/AbstractMqttClientManager.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/AbstractMqttClientManager.java\nindex 2fd2e6b2060..0a5e2a9012a 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/AbstractMqttClientManager.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/AbstractMqttClientManager.java\n@@ -19,6 +19,8 @@\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n@@ -38,6 +40,7 @@\n  *\n  * @author Artem Vozhdayenko\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 6.0\n  */\n@@ -47,6 +50,8 @@ public abstract class AbstractMqttClientManager<T, C> implements ClientManager<T\n \n \tprivate static final int DEFAULT_MANAGER_PHASE = 0;\n \n+\tprotected final Lock lock = new ReentrantLock();\n+\n \tprivate final Set<ConnectCallback> connectCallbacks = Collections.synchronizedSet(new HashSet<>());\n \n \tprivate final String clientId;\n@@ -92,8 +97,14 @@ protected ApplicationEventPublisher getApplicationEventPublisher() {\n \t\treturn this.applicationEventPublisher;\n \t}\n \n-\tprotected synchronized void setClient(T client) {\n-\t\tthis.client = client;\n+\tprotected void setClient(T client) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tthis.client = client;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \tprotected Set<ConnectCallback> getCallbacks() {\n@@ -134,8 +145,14 @@ public boolean isManualAcks() {\n \t}\n \n \t@Override\n-\tpublic synchronized T getClient() {\n-\t\treturn this.client;\n+\tpublic T getClient() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\treturn this.client;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n@@ -177,8 +194,14 @@ public boolean removeCallback(ConnectCallback connectCallback) {\n \t\treturn this.connectCallbacks.remove(connectCallback);\n \t}\n \n-\tpublic synchronized boolean isRunning() {\n-\t\treturn this.client != null;\n+\tpublic boolean isRunning() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\treturn this.client != null;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t/**\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java\nindex b88416aa803..6a9a0249e14 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java\n@@ -36,6 +36,7 @@\n  *\n  * @author Artem Vozhdayenko\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 6.0\n  */\n@@ -87,40 +88,46 @@ public MqttConnectOptions getConnectionInfo() {\n \t}\n \n \t@Override\n-\tpublic synchronized void start() {\n-\t\tvar client = getClient();\n-\t\tif (client == null) {\n-\t\t\ttry {\n-\t\t\t\tclient = createClient();\n-\t\t\t}\n-\t\t\tcatch (MqttException e) {\n-\t\t\t\tthrow new IllegalStateException(\"could not start client manager\", e);\n-\t\t\t}\n-\t\t}\n-\t\tsetClient(client);\n+\tpublic void start() {\n+\t\tthis.lock.lock();\n \t\ttry {\n-\t\t\tclient.connect(this.connectionOptions).waitForCompletion(getCompletionTimeout());\n-\t\t}\n-\t\tcatch (MqttException ex) {\n-\t\t\t// See GH-3822\n-\t\t\tif (this.connectionOptions.isAutomaticReconnect()) {\n+\t\t\tvar client = getClient();\n+\t\t\tif (client == null) {\n \t\t\t\ttry {\n-\t\t\t\t\tclient.reconnect();\n+\t\t\t\t\tclient = createClient();\n \t\t\t\t}\n-\t\t\t\tcatch (MqttException re) {\n-\t\t\t\t\tlogger.error(\"MQTT client failed to connect. Never happens.\", re);\n+\t\t\t\tcatch (MqttException e) {\n+\t\t\t\t\tthrow new IllegalStateException(\"could not start client manager\", e);\n \t\t\t\t}\n \t\t\t}\n-\t\t\telse {\n-\t\t\t\tvar applicationEventPublisher = getApplicationEventPublisher();\n-\t\t\t\tif (applicationEventPublisher != null) {\n-\t\t\t\t\tapplicationEventPublisher.publishEvent(new MqttConnectionFailedEvent(this, ex));\n+\t\t\tsetClient(client);\n+\t\t\ttry {\n+\t\t\t\tclient.connect(this.connectionOptions).waitForCompletion(getCompletionTimeout());\n+\t\t\t}\n+\t\t\tcatch (MqttException ex) {\n+\t\t\t\t// See GH-3822\n+\t\t\t\tif (this.connectionOptions.isAutomaticReconnect()) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tclient.reconnect();\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (MqttException re) {\n+\t\t\t\t\t\tlogger.error(\"MQTT client failed to connect. Never happens.\", re);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tlogger.error(\"Could not start client manager, client_id=\" + getClientId(), ex);\n+\t\t\t\t\tvar applicationEventPublisher = getApplicationEventPublisher();\n+\t\t\t\t\tif (applicationEventPublisher != null) {\n+\t\t\t\t\t\tapplicationEventPublisher.publishEvent(new MqttConnectionFailedEvent(this, ex));\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tlogger.error(\"Could not start client manager, client_id=\" + getClientId(), ex);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \tprivate IMqttAsyncClient createClient() throws MqttException {\n@@ -133,31 +140,43 @@ private IMqttAsyncClient createClient() throws MqttException {\n \t}\n \n \t@Override\n-\tpublic synchronized void stop() {\n-\t\tvar client = getClient();\n-\t\tif (client == null) {\n-\t\t\treturn;\n-\t\t}\n+\tpublic void stop() {\n+\t\tthis.lock.lock();\n \t\ttry {\n-\t\t\tclient.disconnectForcibly(getDisconnectCompletionTimeout());\n-\t\t}\n-\t\tcatch (MqttException e) {\n-\t\t\tlogger.error(\"Could not disconnect from the client\", e);\n-\t\t}\n-\t\tfinally {\n+\t\t\tvar client = getClient();\n+\t\t\tif (client == null) {\n+\t\t\t\treturn;\n+\t\t\t}\n \t\t\ttry {\n-\t\t\t\tclient.close();\n+\t\t\t\tclient.disconnectForcibly(getDisconnectCompletionTimeout());\n \t\t\t}\n \t\t\tcatch (MqttException e) {\n-\t\t\t\tlogger.error(\"Could not close the client\", e);\n+\t\t\t\tlogger.error(\"Could not disconnect from the client\", e);\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\ttry {\n+\t\t\t\t\tclient.close();\n+\t\t\t\t}\n+\t\t\t\tcatch (MqttException e) {\n+\t\t\t\t\tlogger.error(\"Could not close the client\", e);\n+\t\t\t\t}\n+\t\t\t\tsetClient(null);\n \t\t\t}\n-\t\t\tsetClient(null);\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n \t@Override\n-\tpublic synchronized void connectionLost(Throwable cause) {\n-\t\tlogger.error(\"Connection lost, client_id=\" + getClientId(), cause);\n+\tpublic void connectionLost(Throwable cause) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tlogger.error(\"Connection lost, client_id=\" + getClientId(), cause);\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java\nindex 72ec62472d9..a89b34aa609 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java\n@@ -38,6 +38,7 @@\n  *\n  * @author Artem Vozhdayenko\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 6.0\n  */\n@@ -89,39 +90,45 @@ public MqttConnectionOptions getConnectionInfo() {\n \t}\n \n \t@Override\n-\tpublic synchronized void start() {\n-\t\tvar client = getClient();\n-\t\tif (client == null) {\n-\t\t\ttry {\n-\t\t\t\tclient = createClient();\n-\t\t\t}\n-\t\t\tcatch (MqttException e) {\n-\t\t\t\tthrow new IllegalStateException(\"Could not start client manager\", e);\n-\t\t\t}\n-\t\t}\n-\t\tsetClient(client);\n+\tpublic void start() {\n+\t\tthis.lock.lock();\n \t\ttry {\n-\t\t\tclient.connect(this.connectionOptions).waitForCompletion(getCompletionTimeout());\n-\t\t}\n-\t\tcatch (MqttException ex) {\n-\t\t\tif (this.connectionOptions.isAutomaticReconnect()) {\n+\t\t\tvar client = getClient();\n+\t\t\tif (client == null) {\n \t\t\t\ttry {\n-\t\t\t\t\tclient.reconnect();\n+\t\t\t\t\tclient = createClient();\n \t\t\t\t}\n-\t\t\t\tcatch (MqttException re) {\n-\t\t\t\t\tlogger.error(\"MQTT client failed to connect. Never happens.\", re);\n+\t\t\t\tcatch (MqttException e) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Could not start client manager\", e);\n \t\t\t\t}\n \t\t\t}\n-\t\t\telse {\n-\t\t\t\tvar applicationEventPublisher = getApplicationEventPublisher();\n-\t\t\t\tif (applicationEventPublisher != null) {\n-\t\t\t\t\tapplicationEventPublisher.publishEvent(new MqttConnectionFailedEvent(this, ex));\n+\t\t\tsetClient(client);\n+\t\t\ttry {\n+\t\t\t\tclient.connect(this.connectionOptions).waitForCompletion(getCompletionTimeout());\n+\t\t\t}\n+\t\t\tcatch (MqttException ex) {\n+\t\t\t\tif (this.connectionOptions.isAutomaticReconnect()) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tclient.reconnect();\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (MqttException re) {\n+\t\t\t\t\t\tlogger.error(\"MQTT client failed to connect. Never happens.\", re);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tlogger.error(\"Could not start client manager, client_id=\" + getClientId(), ex);\n+\t\t\t\t\tvar applicationEventPublisher = getApplicationEventPublisher();\n+\t\t\t\t\tif (applicationEventPublisher != null) {\n+\t\t\t\t\t\tapplicationEventPublisher.publishEvent(new MqttConnectionFailedEvent(this, ex));\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tlogger.error(\"Could not start client manager, client_id=\" + getClientId(), ex);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \tprivate MqttAsyncClient createClient() throws MqttException {\n@@ -134,26 +141,32 @@ private MqttAsyncClient createClient() throws MqttException {\n \t}\n \n \t@Override\n-\tpublic synchronized void stop() {\n-\t\tvar client = getClient();\n-\t\tif (client == null) {\n-\t\t\treturn;\n-\t\t}\n-\n+\tpublic void stop() {\n+\t\tthis.lock.lock();\n \t\ttry {\n-\t\t\tclient.disconnectForcibly(getDisconnectCompletionTimeout());\n-\t\t}\n-\t\tcatch (MqttException e) {\n-\t\t\tlogger.error(\"Could not disconnect from the client\", e);\n-\t\t}\n-\t\tfinally {\n+\t\t\tvar client = getClient();\n+\t\t\tif (client == null) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n \t\t\ttry {\n-\t\t\t\tclient.close();\n+\t\t\t\tclient.disconnectForcibly(getDisconnectCompletionTimeout());\n \t\t\t}\n \t\t\tcatch (MqttException e) {\n-\t\t\t\tlogger.error(\"Could not close the client\", e);\n+\t\t\t\tlogger.error(\"Could not disconnect from the client\", e);\n \t\t\t}\n-\t\t\tsetClient(null);\n+\t\t\tfinally {\n+\t\t\t\ttry {\n+\t\t\t\t\tclient.close();\n+\t\t\t\t}\n+\t\t\t\tcatch (MqttException e) {\n+\t\t\t\t\tlogger.error(\"Could not close the client\", e);\n+\t\t\t\t}\n+\t\t\t\tsetClient(null);\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/MqttPahoMessageDrivenChannelAdapter.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/MqttPahoMessageDrivenChannelAdapter.java\nindex 26a8f29c89e..f28df29eb99 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/MqttPahoMessageDrivenChannelAdapter.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/MqttPahoMessageDrivenChannelAdapter.java\n@@ -17,6 +17,8 @@\n package org.springframework.integration.mqtt.inbound;\n \n import java.util.Arrays;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.stream.Stream;\n \n import org.eclipse.paho.client.mqttv3.IMqttAsyncClient;\n@@ -64,6 +66,8 @@ public class MqttPahoMessageDrivenChannelAdapter\n \t\textends AbstractMqttMessageDrivenChannelAdapter<IMqttAsyncClient, MqttConnectOptions>\n \t\timplements MqttCallbackExtended, MqttPahoComponent {\n \n+\tprivate final Lock lock =  new ReentrantLock();\n+\n \tprivate final MqttPahoClientFactory clientFactory;\n \n \tprivate volatile IMqttAsyncClient client;\n@@ -179,46 +183,58 @@ protected void doStart() {\n \t}\n \n \t@SuppressWarnings(\"deprecation\")\n-\tprivate synchronized void connect() throws MqttException {\n-\t\tMqttConnectOptions connectionOptions = this.clientFactory.getConnectionOptions();\n-\t\tvar clientManager = getClientManager();\n-\t\tif (clientManager == null) {\n-\t\t\tAssert.state(getUrl() != null || connectionOptions.getServerURIs() != null,\n-\t\t\t\t\t\"If no 'url' provided, connectionOptions.getServerURIs() must not be null\");\n-\t\t\tthis.client = this.clientFactory.getAsyncClientInstance(getUrl(), getClientId());\n-\t\t\tthis.client.setCallback(this);\n-\t\t\tthis.client.connect(connectionOptions).waitForCompletion(getCompletionTimeout());\n-\t\t\tthis.client.setManualAcks(isManualAcks());\n+\tprivate void connect() throws MqttException {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tMqttConnectOptions connectionOptions = this.clientFactory.getConnectionOptions();\n+\t\t\tvar clientManager = getClientManager();\n+\t\t\tif (clientManager == null) {\n+\t\t\t\tAssert.state(getUrl() != null || connectionOptions.getServerURIs() != null,\n+\t\t\t\t\t\t\"If no 'url' provided, connectionOptions.getServerURIs() must not be null\");\n+\t\t\t\tthis.client = this.clientFactory.getAsyncClientInstance(getUrl(), getClientId());\n+\t\t\t\tthis.client.setCallback(this);\n+\t\t\t\tthis.client.connect(connectionOptions).waitForCompletion(getCompletionTimeout());\n+\t\t\t\tthis.client.setManualAcks(isManualAcks());\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.client = clientManager.getClient();\n+\t\t\t}\n \t\t}\n-\t\telse {\n-\t\t\tthis.client = clientManager.getClient();\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n \t@Override\n-\tprotected synchronized void doStop() {\n-\t\tthis.readyToSubscribeOnStart = false;\n+\tprotected void doStop() {\n+\t\tthis.lock.lock();\n \t\ttry {\n-\t\t\tif (this.clientFactory.getConnectionOptions().isCleanSession()) {\n-\t\t\t\tthis.client.unsubscribe(getTopic());\n-\t\t\t\t// Have to re-subscribe on next start if connection is not lost.\n-\t\t\t\tthis.readyToSubscribeOnStart = true;\n+\t\t\tthis.readyToSubscribeOnStart = false;\n+\t\t\ttry {\n+\t\t\t\tif (this.clientFactory.getConnectionOptions().isCleanSession()) {\n+\t\t\t\t\tthis.client.unsubscribe(getTopic());\n+\t\t\t\t\t// Have to re-subscribe on next start if connection is not lost.\n+\t\t\t\t\tthis.readyToSubscribeOnStart = true;\n \n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcatch (MqttException ex1) {\n+\t\t\t\tlogger.error(ex1, \"Exception while unsubscribing\");\n \t\t\t}\n-\t\t}\n-\t\tcatch (MqttException ex1) {\n-\t\t\tlogger.error(ex1, \"Exception while unsubscribing\");\n-\t\t}\n \n-\t\tif (getClientManager() != null) {\n-\t\t\treturn;\n-\t\t}\n+\t\t\tif (getClientManager() != null) {\n+\t\t\t\treturn;\n+\t\t\t}\n \n-\t\ttry {\n-\t\t\tthis.client.disconnectForcibly(getDisconnectCompletionTimeout());\n+\t\t\ttry {\n+\t\t\t\tthis.client.disconnectForcibly(getDisconnectCompletionTimeout());\n+\t\t\t}\n+\t\t\tcatch (MqttException ex) {\n+\t\t\t\tlogger.error(ex, \"Exception while disconnecting\");\n+\t\t\t}\n \t\t}\n-\t\tcatch (MqttException ex) {\n-\t\t\tlogger.error(ex, \"Exception while disconnecting\");\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n@@ -322,17 +338,23 @@ private void warnInvalidQosForSubscription(String[] topics, int[] requestedQos,\n \t}\n \n \t@Override\n-\tpublic synchronized void connectionLost(Throwable cause) {\n-\t\tif (isRunning()) {\n-\t\t\tthis.logger.error(() -> \"Lost connection: \" + cause.getMessage());\n-\t\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n-\t\t\tif (applicationEventPublisher != null) {\n-\t\t\t\tapplicationEventPublisher.publishEvent(new MqttConnectionFailedEvent(this, cause));\n+\tpublic void connectionLost(Throwable cause) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (isRunning()) {\n+\t\t\t\tthis.logger.error(() -> \"Lost connection: \" + cause.getMessage());\n+\t\t\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n+\t\t\t\tif (applicationEventPublisher != null) {\n+\t\t\t\t\tapplicationEventPublisher.publishEvent(new MqttConnectionFailedEvent(this, cause));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// The 'connectComplete()' re-subscribes or sets this flag otherwise.\n+\t\t\t\tthis.readyToSubscribeOnStart = false;\n \t\t\t}\n \t\t}\n-\t\telse {\n-\t\t\t// The 'connectComplete()' re-subscribes or sets this flag otherwise.\n-\t\t\tthis.readyToSubscribeOnStart = false;\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/Mqttv5PahoMessageDrivenChannelAdapter.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/Mqttv5PahoMessageDrivenChannelAdapter.java\nindex cab526ddc5b..b589da35fc6 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/Mqttv5PahoMessageDrivenChannelAdapter.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/inbound/Mqttv5PahoMessageDrivenChannelAdapter.java\n@@ -18,6 +18,8 @@\n \n import java.util.Arrays;\n import java.util.Map;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.stream.IntStream;\n \n import org.eclipse.paho.mqttv5.client.IMqttAsyncClient;\n@@ -81,6 +83,8 @@ public class Mqttv5PahoMessageDrivenChannelAdapter\n \t\textends AbstractMqttMessageDrivenChannelAdapter<IMqttAsyncClient, MqttConnectionOptions>\n \t\timplements MqttCallback, MqttComponent<MqttConnectionOptions> {\n \n+\tprivate final Lock lock =  new ReentrantLock();\n+\n \tprivate final MqttConnectionOptions connectionOptions;\n \n \tprivate IMqttAsyncClient mqttClient;\n@@ -211,13 +215,19 @@ protected void doStart() {\n \t\t}\n \t}\n \n-\tprivate synchronized void connect() throws MqttException {\n-\t\tvar clientManager = getClientManager();\n-\t\tif (clientManager == null) {\n-\t\t\tthis.mqttClient.connect(this.connectionOptions).waitForCompletion(getCompletionTimeout());\n+\tprivate void connect() throws MqttException {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tvar clientManager = getClientManager();\n+\t\t\tif (clientManager == null) {\n+\t\t\t\tthis.mqttClient.connect(this.connectionOptions).waitForCompletion(getCompletionTimeout());\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.mqttClient = clientManager.getClient();\n+\t\t\t}\n \t\t}\n-\t\telse {\n-\t\t\tthis.mqttClient = clientManager.getClient();\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java\nindex 387db0497fe..a17f7f63a5b 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/AbstractMqttMessageHandler.java\n@@ -17,6 +17,8 @@\n package org.springframework.integration.mqtt.outbound;\n \n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.beans.factory.BeanFactoryAware;\n import org.springframework.context.ApplicationEventPublisher;\n@@ -63,6 +65,8 @@ public abstract class AbstractMqttMessageHandler<T, C> extends AbstractMessageHa\n \tprivate static final MessageProcessor<String> DEFAULT_TOPIC_PROCESSOR =\n \t\t\t(message) -> message.getHeaders().get(MqttHeaders.TOPIC, String.class);\n \n+\tprotected final Lock lock = new ReentrantLock();\n+\n \tprivate final AtomicBoolean running = new AtomicBoolean();\n \n \tprivate final String url;\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/MqttPahoMessageHandler.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/MqttPahoMessageHandler.java\nindex a9d5f3ab7f2..317a9b9604a 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/MqttPahoMessageHandler.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/outbound/MqttPahoMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -50,6 +50,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Artem Vozhdayenko\n+ * @author Christian Tzolov\n  *\n  * @since 4.0\n  *\n@@ -184,41 +185,47 @@ protected void doStop() {\n \t\t}\n \t}\n \n-\tprivate synchronized IMqttAsyncClient checkConnection() throws MqttException {\n-\t\tvar theClientManager = getClientManager();\n-\t\tif (theClientManager != null) {\n-\t\t\treturn theClientManager.getClient();\n-\t\t}\n+\tprivate IMqttAsyncClient checkConnection() throws MqttException {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tvar theClientManager = getClientManager();\n+\t\t\tif (theClientManager != null) {\n+\t\t\t\treturn theClientManager.getClient();\n+\t\t\t}\n \n-\t\tif (this.client != null && !this.client.isConnected()) {\n-\t\t\tthis.client.setCallback(null);\n-\t\t\tthis.client.close();\n-\t\t\tthis.client = null;\n-\t\t}\n-\t\tif (this.client == null) {\n-\t\t\ttry {\n-\t\t\t\tMqttConnectOptions connectionOptions = this.clientFactory.getConnectionOptions();\n-\t\t\t\tAssert.state(this.getUrl() != null || connectionOptions.getServerURIs() != null,\n-\t\t\t\t\t\t\"If no 'url' provided, connectionOptions.getServerURIs() must not be null\");\n-\t\t\t\tthis.client = this.clientFactory.getAsyncClientInstance(this.getUrl(), this.getClientId());\n-\t\t\t\tincrementClientInstance();\n-\t\t\t\tthis.client.setCallback(this);\n-\t\t\t\tthis.client.connect(connectionOptions).waitForCompletion(getCompletionTimeout());\n-\t\t\t\tlogger.debug(\"Client connected\");\n+\t\t\tif (this.client != null && !this.client.isConnected()) {\n+\t\t\t\tthis.client.setCallback(null);\n+\t\t\t\tthis.client.close();\n+\t\t\t\tthis.client = null;\n \t\t\t}\n-\t\t\tcatch (MqttException e) {\n-\t\t\t\tif (this.client != null) {\n-\t\t\t\t\tthis.client.close();\n-\t\t\t\t\tthis.client = null;\n+\t\t\tif (this.client == null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tMqttConnectOptions connectionOptions = this.clientFactory.getConnectionOptions();\n+\t\t\t\t\tAssert.state(this.getUrl() != null || connectionOptions.getServerURIs() != null,\n+\t\t\t\t\t\t\t\"If no 'url' provided, connectionOptions.getServerURIs() must not be null\");\n+\t\t\t\t\tthis.client = this.clientFactory.getAsyncClientInstance(this.getUrl(), this.getClientId());\n+\t\t\t\t\tincrementClientInstance();\n+\t\t\t\t\tthis.client.setCallback(this);\n+\t\t\t\t\tthis.client.connect(connectionOptions).waitForCompletion(getCompletionTimeout());\n+\t\t\t\t\tlogger.debug(\"Client connected\");\n \t\t\t\t}\n-\t\t\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n-\t\t\t\tif (applicationEventPublisher != null) {\n-\t\t\t\t\tapplicationEventPublisher.publishEvent(new MqttConnectionFailedEvent(this, e));\n+\t\t\t\tcatch (MqttException e) {\n+\t\t\t\t\tif (this.client != null) {\n+\t\t\t\t\t\tthis.client.close();\n+\t\t\t\t\t\tthis.client = null;\n+\t\t\t\t\t}\n+\t\t\t\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n+\t\t\t\t\tif (applicationEventPublisher != null) {\n+\t\t\t\t\t\tapplicationEventPublisher.publishEvent(new MqttConnectionFailedEvent(this, e));\n+\t\t\t\t\t}\n+\t\t\t\t\tthrow new MessagingException(\"Failed to connect\", e);\n \t\t\t\t}\n-\t\t\t\tthrow new MessagingException(\"Failed to connect\", e);\n \t\t\t}\n+\t\t\treturn this.client;\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\treturn this.client;\n \t}\n \n \t@Override\n@@ -252,22 +259,28 @@ private void sendDeliveryComplete(IMqttDeliveryToken token) {\n \t}\n \n \t@Override\n-\tpublic synchronized void connectionLost(Throwable cause) {\n-\t\tlogger.error(\"Lost connection; will attempt reconnect on next request\");\n-\t\tif (this.client != null) {\n-\t\t\ttry {\n-\t\t\t\tthis.client.setCallback(null);\n-\t\t\t\tthis.client.close();\n-\t\t\t}\n-\t\t\tcatch (MqttException e) {\n-\t\t\t\t// NOSONAR\n-\t\t\t}\n-\t\t\tthis.client = null;\n-\t\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n-\t\t\tif (applicationEventPublisher != null) {\n-\t\t\t\tapplicationEventPublisher.publishEvent(new MqttConnectionFailedEvent(this, cause));\n+\tpublic void connectionLost(Throwable cause) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tlogger.error(\"Lost connection; will attempt reconnect on next request\");\n+\t\t\tif (this.client != null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tthis.client.setCallback(null);\n+\t\t\t\t\tthis.client.close();\n+\t\t\t\t}\n+\t\t\t\tcatch (MqttException e) {\n+\t\t\t\t\t// NOSONAR\n+\t\t\t\t}\n+\t\t\t\tthis.client = null;\n+\t\t\t\tApplicationEventPublisher applicationEventPublisher = getApplicationEventPublisher();\n+\t\t\t\tif (applicationEventPublisher != null) {\n+\t\t\t\t\tapplicationEventPublisher.publishEvent(new MqttConnectionFailedEvent(this, cause));\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java b/spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java\nindex 2f6e3ecddc6..828c18701d5 100644\n--- a/spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java\n+++ b/spring-integration-redis/src/main/java/org/springframework/integration/redis/util/RedisLockRegistry.java\n@@ -82,6 +82,7 @@\n  * @author Vedran Pavic\n  * @author Unseok Kim\n  * @author Anton Gabov\n+ * @author Christian Tzolov\n  *\n  * @since 4.0\n  *\n@@ -94,6 +95,8 @@ public final class RedisLockRegistry implements ExpirableLockRegistry, Disposabl\n \n \tprivate static final int DEFAULT_CAPACITY = 100_000;\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final Map<String, RedisLock> locks =\n \t\t\tnew LinkedHashMap<String, RedisLock>(16, 0.75F, true) {\n \n@@ -224,15 +227,20 @@ public void setRedisLockType(RedisLockType redisLockType) {\n \tpublic Lock obtain(Object lockKey) {\n \t\tAssert.isInstanceOf(String.class, lockKey);\n \t\tString path = (String) lockKey;\n-\t\tsynchronized (this.locks) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\treturn this.locks.computeIfAbsent(path, getRedisLockConstructor(this.redisLockType));\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic void expireUnusedOlderThan(long age) {\n \t\tlong now = System.currentTimeMillis();\n-\t\tsynchronized (this.locks) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tthis.locks.entrySet()\n \t\t\t\t\t.removeIf(entry -> {\n \t\t\t\t\t\tRedisLock lock = entry.getValue();\n@@ -243,6 +251,9 @@ public void expireUnusedOlderThan(long age) {\n \t\t\t\t\t\t\t\t&& !lock.isAcquiredInThisProcess();\n \t\t\t\t\t});\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n@@ -631,7 +642,8 @@ private boolean subscribeLock(long time) throws ExecutionException, InterruptedE\n \t\t}\n \n \t\tprivate void runRedisMessageListenerContainer() {\n-\t\t\tsynchronized (RedisLockRegistry.this.locks) {\n+\t\t\tRedisLockRegistry.this.lock.tryLock();\n+\t\t\ttry {\n \t\t\t\tif (!(RedisLockRegistry.this.isRunningRedisMessageListenerContainer\n \t\t\t\t\t\t&& RedisLockRegistry.this.redisMessageListenerContainer != null\n \t\t\t\t\t\t&& RedisLockRegistry.this.redisMessageListenerContainer.isRunning())) {\n@@ -645,6 +657,9 @@ private void runRedisMessageListenerContainer() {\n \t\t\t\t\tRedisLockRegistry.this.isRunningRedisMessageListenerContainer = true;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tRedisLockRegistry.this.lock.unlock();\n+\t\t\t}\n \t\t}\n \n \t\tprivate static final class RedisUnLockNotifyMessageListener implements MessageListener {\n\ndiff --git a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java\nindex b74c1312ab2..782223a87e8 100644\n--- a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java\n+++ b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.java\n@@ -62,11 +62,14 @@\n  * @author Artem Bilan\n  * @author Krzysztof Debski\n  * @author Auke Zaaiman\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n public class DefaultSftpSessionFactory implements SessionFactory<SftpClient.DirEntry>, SharedSessionCapable {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final SshClient sshClient;\n \n \tprivate volatile boolean initialized;\n@@ -323,12 +326,16 @@ private ClientSession initClientSession() throws IOException {\n \n \tprivate void initClient() throws IOException {\n \t\tif (!this.initialized) {\n-\t\t\tsynchronized (this) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (!this.initialized) {\n \t\t\t\t\tdoInitClient();\n \t\t\t\t\tthis.initialized = true;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java\nindex 819d257b125..e26772c418e 100644\n--- a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java\n+++ b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/session/SftpSession.java\n@@ -22,6 +22,8 @@\n import java.io.UncheckedIOException;\n import java.net.SocketAddress;\n import java.time.Duration;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.stream.Stream;\n import java.util.stream.StreamSupport;\n \n@@ -46,11 +48,14 @@\n  * @author Oleg Zhurakousky\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  */\n public class SftpSession implements Session<SftpClient.DirEntry> {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final SftpClient sftpClient;\n \n \tpublic SftpSession(SftpClient sftpClient) {\n@@ -122,15 +127,20 @@ public boolean finalizeRaw() {\n \n \t@Override\n \tpublic void write(InputStream inputStream, String destination) throws IOException {\n-\t\tsynchronized (this.sftpClient) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tOutputStream outputStream = this.sftpClient.write(destination);\n \t\t\tFileCopyUtils.copy(inputStream, outputStream);\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic void append(InputStream inputStream, String destination) throws IOException {\n-\t\tsynchronized (this.sftpClient) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tOutputStream outputStream =\n \t\t\t\t\tthis.sftpClient.write(destination,\n \t\t\t\t\t\t\tSftpClient.OpenMode.Create,\n@@ -138,6 +148,9 @@ public void append(InputStream inputStream, String destination) throws IOExcepti\n \t\t\t\t\t\t\tSftpClient.OpenMode.Append);\n \t\t\tFileCopyUtils.copy(inputStream, outputStream);\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-smb/src/main/java/org/springframework/integration/smb/session/SmbShare.java b/spring-integration-smb/src/main/java/org/springframework/integration/smb/session/SmbShare.java\nindex 3878f0223e5..e3cb4bb9d12 100644\n--- a/spring-integration-smb/src/main/java/org/springframework/integration/smb/session/SmbShare.java\n+++ b/spring-integration-smb/src/main/java/org/springframework/integration/smb/session/SmbShare.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2012-2022 the original author or authors.\n+ * Copyright 2012-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,6 +19,8 @@\n import java.io.IOException;\n import java.util.Properties;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import jcifs.CIFSContext;\n import jcifs.CIFSException;\n@@ -41,6 +43,7 @@\n  * @author Gregory Bragg\n  * @author Adam Jones\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 6.0\n  */\n@@ -48,6 +51,8 @@ public class SmbShare extends SmbFile {\n \n \tprivate static final Log logger = LogFactory.getLog(SmbShare.class);\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final AtomicBoolean open = new AtomicBoolean(false);\n \n \tprivate final AtomicBoolean closeContext = new AtomicBoolean(false);\n@@ -126,17 +131,23 @@ boolean isOpened() {\n \t}\n \n \t@Override\n-\tpublic synchronized void close() {\n-\t\tthis.open.set(false);\n-\t\tif (this.closeContext.get()) {\n-\t\t\ttry {\n-\t\t\t\tgetContext().close();\n-\t\t\t}\n-\t\t\tcatch (CIFSException e) {\n-\t\t\t\tlogger.error(\"Unable to close share: \" + this);\n+\tpublic void close() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tthis.open.set(false);\n+\t\t\tif (this.closeContext.get()) {\n+\t\t\t\ttry {\n+\t\t\t\t\tgetContext().close();\n+\t\t\t\t}\n+\t\t\t\tcatch (CIFSException e) {\n+\t\t\t\t\tlogger.error(\"Unable to close share: \" + this);\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tsuper.close();\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n-\t\tsuper.close();\n \t}\n \n \t/**\n\ndiff --git a/spring-integration-stomp/src/main/java/org/springframework/integration/stomp/AbstractStompSessionManager.java b/spring-integration-stomp/src/main/java/org/springframework/integration/stomp/AbstractStompSessionManager.java\nindex 7ef57952e6d..13ae624efcd 100644\n--- a/spring-integration-stomp/src/main/java/org/springframework/integration/stomp/AbstractStompSessionManager.java\n+++ b/spring-integration-stomp/src/main/java/org/springframework/integration/stomp/AbstractStompSessionManager.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2015-2022 the original author or authors.\n+ * Copyright 2015-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -25,6 +25,8 @@\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.BiConsumer;\n \n import org.apache.commons.logging.Log;\n@@ -66,6 +68,7 @@\n  *\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n  *\n  * @since 4.2\n  */\n@@ -80,7 +83,9 @@ public abstract class AbstractStompSessionManager implements StompSessionManager\n \n \tprivate final CompositeStompSessionHandler compositeStompSessionHandler = new CompositeStompSessionHandler();\n \n-\tprivate final Object lifecycleMonitor = new Object();\n+\tprivate final Lock lifecycleMonitor = new ReentrantLock();\n+\n+\tprivate final Lock lock = new ReentrantLock();\n \n \tprivate final AtomicInteger epoch = new AtomicInteger();\n \n@@ -177,41 +182,47 @@ public int getPhase() {\n \t\treturn this.phase;\n \t}\n \n-\tprivate synchronized void connect() {\n-\t\tif (this.connecting || this.connected) {\n-\t\t\tthis.logger.debug(\"Aborting connect; another thread is connecting.\");\n-\t\t\treturn;\n-\t\t}\n-\t\tfinal int currentEpoch = this.epoch.get();\n-\t\tthis.connecting = true;\n-\t\tif (this.logger.isDebugEnabled()) {\n-\t\t\tthis.logger.debug(\"Connecting \" + this);\n-\t\t}\n+\tprivate void connect() {\n+\t\tthis.lock.lock();\n \t\ttry {\n-\t\t\tthis.stompSessionFuture = doConnect(this.compositeStompSessionHandler);\n-\t\t}\n-\t\tcatch (Exception e) {\n-\t\t\tif (currentEpoch == this.epoch.get()) {\n-\t\t\t\tscheduleReconnect(e);\n+\t\t\tif (this.connecting || this.connected) {\n+\t\t\t\tthis.logger.debug(\"Aborting connect; another thread is connecting.\");\n+\t\t\t\treturn;\n \t\t\t}\n-\t\t\telse {\n-\t\t\t\tthis.logger.error(\"STOMP doConnect() error for \" + this, e);\n+\t\t\tfinal int currentEpoch = this.epoch.get();\n+\t\t\tthis.connecting = true;\n+\t\t\tif (this.logger.isDebugEnabled()) {\n+\t\t\t\tthis.logger.debug(\"Connecting \" + this);\n \t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\t\tCountDownLatch connectLatch = addStompSessionCallback(currentEpoch);\n-\n-\t\ttry {\n-\t\t\tif (!connectLatch.await(30, TimeUnit.SECONDS)) { // NOSONAR magic number\n-\t\t\t\tthis.logger.error(\"No response to connection attempt\");\n+\t\t\ttry {\n+\t\t\t\tthis.stompSessionFuture = doConnect(this.compositeStompSessionHandler);\n+\t\t\t}\n+\t\t\tcatch (Exception e) {\n \t\t\t\tif (currentEpoch == this.epoch.get()) {\n-\t\t\t\t\tscheduleReconnect(null);\n+\t\t\t\t\tscheduleReconnect(e);\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthis.logger.error(\"STOMP doConnect() error for \" + this, e);\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tCountDownLatch connectLatch = addStompSessionCallback(currentEpoch);\n+\n+\t\t\ttry {\n+\t\t\t\tif (!connectLatch.await(30, TimeUnit.SECONDS)) { // NOSONAR magic number\n+\t\t\t\t\tthis.logger.error(\"No response to connection attempt\");\n+\t\t\t\t\tif (currentEpoch == this.epoch.get()) {\n+\t\t\t\t\t\tscheduleReconnect(null);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tcatch (InterruptedException e1) {\n+\t\t\t\tthis.logger.error(\"Interrupted while waiting for connection attempt\");\n+\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t}\n \t\t}\n-\t\tcatch (InterruptedException e1) {\n-\t\t\tthis.logger.error(\"Interrupted while waiting for connection attempt\");\n-\t\t\tThread.currentThread().interrupt();\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n@@ -294,7 +305,8 @@ public void accept(StompSession session, Throwable throwable) {\n \n \t@Override\n \tpublic void start() {\n-\t\tsynchronized (this.lifecycleMonitor) {\n+\t\tthis.lifecycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (!isRunning()) {\n \t\t\t\tif (this.logger.isInfoEnabled()) {\n \t\t\t\t\tthis.logger.info(\"Starting \" + this);\n@@ -303,11 +315,15 @@ public void start() {\n \t\t\t\tthis.running = true;\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleMonitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic void stop() {\n-\t\tsynchronized (this.lifecycleMonitor) {\n+\t\tthis.lifecycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (isRunning()) {\n \t\t\t\tthis.running = false;\n \t\t\t\tif (this.logger.isInfoEnabled()) {\n@@ -316,6 +332,9 @@ public void stop() {\n \t\t\t\tdestroy();\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleMonitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n@@ -355,18 +374,24 @@ private class CompositeStompSessionHandler extends StompSessionHandlerAdapter {\n \n \t\tprivate final List<StompSessionHandler> delegates = Collections.synchronizedList(new ArrayList<>());\n \n+\t\tprivate final Lock delegatesMonitor = new ReentrantLock();\n+\n \t\tprivate volatile StompSession session;\n \n \t\tCompositeStompSessionHandler() {\n \t\t}\n \n \t\tvoid addHandler(StompSessionHandler delegate) {\n-\t\t\tsynchronized (this.delegates) {\n+\t\t\tthis.delegatesMonitor.lock();\n+\t\t\ttry {\n \t\t\t\tif (this.session != null) {\n \t\t\t\t\tdelegate.afterConnected(this.session, getConnectHeaders());\n \t\t\t\t}\n \t\t\t\tthis.delegates.add(delegate);\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.delegatesMonitor.unlock();\n+\t\t\t}\n \t\t}\n \n \t\tvoid removeHandler(StompSessionHandler delegate) {\n@@ -375,23 +400,31 @@ void removeHandler(StompSessionHandler delegate) {\n \n \t\t@Override\n \t\tpublic void afterConnected(StompSession session, StompHeaders connectedHeaders) {\n-\t\t\tsynchronized (this.delegates) {\n+\t\t\tthis.delegatesMonitor.lock();\n+\t\t\ttry {\n \t\t\t\tthis.session = session;\n \t\t\t\tfor (StompSessionHandler delegate : this.delegates) {\n \t\t\t\t\tdelegate.afterConnected(session, connectedHeaders);\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.delegatesMonitor.unlock();\n+\t\t\t}\n \t\t}\n \n \t\t@Override\n \t\tpublic void handleException(StompSession session, @Nullable StompCommand command, StompHeaders headers,\n \t\t\t\tbyte[] payload, Throwable exception) {\n \n-\t\t\tsynchronized (this.delegates) {\n+\t\t\tthis.delegatesMonitor.lock();\n+\t\t\ttry {\n \t\t\t\tfor (StompSessionHandler delegate : this.delegates) {\n \t\t\t\t\tdelegate.handleException(session, command, headers, payload, exception);\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.delegatesMonitor.unlock();\n+\t\t\t}\n \t\t}\n \n \t\t@Override\n@@ -400,20 +433,28 @@ public void handleTransportError(StompSession session, Throwable exception) {\n \t\t\t\t\texception);\n \t\t\tthis.session = null;\n \t\t\tscheduleReconnect(exception);\n-\t\t\tsynchronized (this.delegates) {\n+\t\t\tthis.delegatesMonitor.lock();\n+\t\t\ttry {\n \t\t\t\tfor (StompSessionHandler delegate : this.delegates) {\n \t\t\t\t\tdelegate.handleTransportError(session, exception);\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.delegatesMonitor.unlock();\n+\t\t\t}\n \t\t}\n \n \t\t@Override\n \t\tpublic void handleFrame(StompHeaders headers, Object payload) {\n-\t\t\tsynchronized (this.delegates) {\n+\t\t\tthis.delegatesMonitor.lock();\n+\t\t\ttry {\n \t\t\t\tfor (StompSessionHandler delegate : this.delegates) {\n \t\t\t\t\tdelegate.handleFrame(headers, payload);\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.delegatesMonitor.unlock();\n+\t\t\t}\n \t\t}\n \n \t}\n\ndiff --git a/spring-integration-stomp/src/main/java/org/springframework/integration/stomp/outbound/StompMessageHandler.java b/spring-integration-stomp/src/main/java/org/springframework/integration/stomp/outbound/StompMessageHandler.java\nindex 7c93fa2de03..9f017d8926e 100644\n--- a/spring-integration-stomp/src/main/java/org/springframework/integration/stomp/outbound/StompMessageHandler.java\n+++ b/spring-integration-stomp/src/main/java/org/springframework/integration/stomp/outbound/StompMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2015-2020 the original author or authors.\n+ * Copyright 2015-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,6 +18,8 @@\n \n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.context.ApplicationEventPublisher;\n import org.springframework.context.ApplicationEventPublisherAware;\n@@ -51,6 +53,7 @@\n  *\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n  *\n  * @since 4.2\n  */\n@@ -59,6 +62,8 @@ public class StompMessageHandler extends AbstractMessageHandler\n \n \tprivate static final int DEFAULT_CONNECT_TIMEOUT = 3000;\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final StompSessionHandler sessionHandler = new IntegrationOutboundStompSessionHandler();\n \n \tprivate final StompSessionManager stompSessionManager;\n@@ -178,7 +183,8 @@ protected void handleMessageInternal(final Message<?> message) {\n \t}\n \n \tprivate void connectIfNecessary() throws InterruptedException {\n-\t\tsynchronized (this.connectSemaphore) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tif (this.stompSession == null || !this.stompSessionManager.isConnected()) {\n \t\t\t\tthis.stompSessionManager.disconnect(this.sessionHandler);\n \t\t\t\tthis.stompSessionManager.connect(this.sessionHandler);\n@@ -199,6 +205,9 @@ private void connectIfNecessary() throws InterruptedException {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-stream/src/main/java/org/springframework/integration/stream/CharacterStreamReadingMessageSource.java b/spring-integration-stream/src/main/java/org/springframework/integration/stream/CharacterStreamReadingMessageSource.java\nindex 450394047ff..b577d20f559 100644\n--- a/spring-integration-stream/src/main/java/org/springframework/integration/stream/CharacterStreamReadingMessageSource.java\n+++ b/spring-integration-stream/src/main/java/org/springframework/integration/stream/CharacterStreamReadingMessageSource.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,6 +21,8 @@\n import java.io.InputStreamReader;\n import java.io.Reader;\n import java.io.UnsupportedEncodingException;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.context.ApplicationEventPublisher;\n import org.springframework.context.ApplicationEventPublisherAware;\n@@ -34,10 +36,13 @@\n  * @author Mark Fisher\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class CharacterStreamReadingMessageSource extends AbstractMessageSource<String>\n \t\timplements ApplicationEventPublisherAware {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final BufferedReader reader;\n \n \tprivate final boolean blockToDetectEOF;\n@@ -112,7 +117,8 @@ public String getComponentType() {\n \t@Override\n \tpublic String doReceive() {\n \t\ttry {\n-\t\t\tsynchronized (this.reader) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (!this.blockToDetectEOF && !this.reader.ready()) {\n \t\t\t\t\treturn null;\n \t\t\t\t}\n@@ -122,6 +128,9 @@ public String doReceive() {\n \t\t\t\t}\n \t\t\t\treturn line;\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t}\n \t\tcatch (IOException e) {\n \t\t\tthrow new MessagingException(\"IO failure occurred in adapter\", e);\n\ndiff --git a/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/ClientWebSocketContainer.java b/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/ClientWebSocketContainer.java\nindex ac7f9d3b4ac..b89db27cc31 100644\n--- a/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/ClientWebSocketContainer.java\n+++ b/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/ClientWebSocketContainer.java\n@@ -46,6 +46,7 @@\n  *\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n  *\n  * @since 4.1\n  */\n@@ -183,12 +184,18 @@ public boolean isRunning() {\n \t}\n \n \t@Override\n-\tpublic synchronized void start() {\n-\t\tif (!isRunning()) {\n-\t\t\tthis.clientSession = null;\n-\t\t\tthis.openConnectionException = null;\n-\t\t\tthis.connectionLatch = new CountDownLatch(1);\n-\t\t\tthis.connectionManager.start();\n+\tpublic void start() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (!isRunning()) {\n+\t\t\t\tthis.clientSession = null;\n+\t\t\t\tthis.openConnectionException = null;\n+\t\t\t\tthis.connectionLatch = new CountDownLatch(1);\n+\t\t\t\tthis.connectionManager.start();\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/IntegrationWebSocketContainer.java b/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/IntegrationWebSocketContainer.java\nindex fab87e2fd2e..dfe8d67e9c9 100644\n--- a/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/IntegrationWebSocketContainer.java\n+++ b/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/IntegrationWebSocketContainer.java\n@@ -21,6 +21,8 @@\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n@@ -67,6 +69,8 @@ public abstract class IntegrationWebSocketContainer implements DisposableBean {\n \n \tprotected final Log logger = LogFactory.getLog(getClass()); // NOSONAR\n \n+\tprotected final Lock lock = new ReentrantLock();\n+\n \tprivate WebSocketHandler webSocketHandler = new IntegrationWebSocketHandler();\n \n \tprotected final Map<String, WebSocketSession> sessions = new ConcurrentHashMap<>(); // NOSONAR\n\ndiff --git a/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/ServerWebSocketContainer.java b/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/ServerWebSocketContainer.java\nindex 792e36b4207..fb103b8aa36 100644\n--- a/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/ServerWebSocketContainer.java\n+++ b/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/ServerWebSocketContainer.java\n@@ -47,6 +47,7 @@\n  *\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n  *\n  * @since 4.1\n  */\n@@ -224,9 +225,15 @@ public boolean isRunning() {\n \t}\n \n \t@Override\n-\tpublic synchronized void start() {\n-\t\tif (this.handshakeHandler instanceof Lifecycle && !isRunning()) {\n-\t\t\t((Lifecycle) this.handshakeHandler).start();\n+\tpublic void start() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.handshakeHandler instanceof Lifecycle && !isRunning()) {\n+\t\t\t\t((Lifecycle) this.handshakeHandler).start();\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/AbstractWebServiceOutboundGateway.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/AbstractWebServiceOutboundGateway.java\nindex 53fc14ea801..50f8338b9e7 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/AbstractWebServiceOutboundGateway.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/AbstractWebServiceOutboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,6 +20,8 @@\n import java.net.URI;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.xml.transform.TransformerException;\n \n@@ -55,9 +57,12 @@\n  * @author Oleg Zhurakousky\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public abstract class AbstractWebServiceOutboundGateway extends AbstractReplyProducingMessageHandler {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprotected final DefaultUriBuilderFactory uriFactory = new DefaultUriBuilderFactory(); // NOSONAR - final\n \n \tprivate final String uri;\n@@ -108,10 +113,14 @@ public void setHeaderMapper(SoapHeaderMapper headerMapper) {\n \t * @param uriVariableExpressions The URI variable expressions.\n \t */\n \tpublic void setUriVariableExpressions(Map<String, Expression> uriVariableExpressions) {\n-\t\tsynchronized (this.uriVariableExpressions) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tthis.uriVariableExpressions.clear();\n \t\t\tthis.uriVariableExpressions.putAll(uriVariableExpressions);\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t/**\n\ndiff --git a/spring-integration-xml/src/main/java/org/springframework/integration/xml/DefaultXmlPayloadConverter.java b/spring-integration-xml/src/main/java/org/springframework/integration/xml/DefaultXmlPayloadConverter.java\nindex 3b7ea3853b8..be48e562bdb 100644\n--- a/spring-integration-xml/src/main/java/org/springframework/integration/xml/DefaultXmlPayloadConverter.java\n+++ b/spring-integration-xml/src/main/java/org/springframework/integration/xml/DefaultXmlPayloadConverter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,6 +20,8 @@\n import java.io.File;\n import java.io.InputStream;\n import java.io.StringReader;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.xml.parsers.DocumentBuilder;\n import javax.xml.parsers.DocumentBuilderFactory;\n@@ -43,11 +45,13 @@\n  *\n  * @author Jonas Partner\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class DefaultXmlPayloadConverter implements XmlPayloadConverter {\n \n \tprivate final DocumentBuilderFactory documentBuilderFactory;\n \n+\tprivate final Lock lock = new ReentrantLock();\n \n \tpublic DefaultXmlPayloadConverter() {\n \t\tthis(DocumentBuilderFactoryUtils.newInstance());\n@@ -142,13 +146,17 @@ else if (object instanceof Document) {\n \t\t}\n \t}\n \n-\tprotected synchronized DocumentBuilder getDocumentBuilder() {\n+\tprotected DocumentBuilder getDocumentBuilder() {\n+\t\tthis.lock.lock();\n \t\ttry {\n \t\t\treturn this.documentBuilderFactory.newDocumentBuilder();\n \t\t}\n \t\tcatch (ParserConfigurationException e) {\n \t\t\tthrow new MessagingException(\"failed to create a new DocumentBuilder\", e);\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n }\n\ndiff --git a/spring-integration-xml/src/main/java/org/springframework/integration/xml/result/DomResultFactory.java b/spring-integration-xml/src/main/java/org/springframework/integration/xml/result/DomResultFactory.java\nindex 76bd1ac3224..4ee51dab409 100644\n--- a/spring-integration-xml/src/main/java/org/springframework/integration/xml/result/DomResultFactory.java\n+++ b/spring-integration-xml/src/main/java/org/springframework/integration/xml/result/DomResultFactory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,9 @@\n \n package org.springframework.integration.xml.result;\n \n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n import javax.xml.parsers.DocumentBuilder;\n import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n@@ -30,11 +33,16 @@\n  * @author Jonas Partner\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n  */\n public class DomResultFactory implements ResultFactory {\n \n \tprivate final DocumentBuilderFactory documentBuilderFactory;\n \n+\tprivate final Lock documentBuilderFactoryMonitor = new ReentrantLock();\n+\n+\tprivate final Lock lock = new ReentrantLock();\n+\n \n \tpublic DomResultFactory() {\n \t\tthis(DocumentBuilderFactoryUtils.newInstance());\n@@ -48,7 +56,8 @@ public DomResultFactory(DocumentBuilderFactory documentBuilderFactory) {\n \n \n \t@Override\n-\tpublic synchronized Result createResult(Object payload) {\n+\tpublic Result createResult(Object payload) {\n+\t\tthis.lock.lock();\n \t\ttry {\n \t\t\treturn new DOMResult(getNewDocumentBuilder().newDocument());\n \t\t}\n@@ -56,12 +65,19 @@ public synchronized Result createResult(Object payload) {\n \t\t\tthrow new MessagingException(\"failed to create Result for payload type [\" +\n \t\t\t\t\tpayload.getClass().getName() + \"]\", e);\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \tprotected DocumentBuilder getNewDocumentBuilder() throws ParserConfigurationException {\n-\t\tsynchronized (this.documentBuilderFactory) {\n+\t\tthis.documentBuilderFactoryMonitor.lock();\n+\t\ttry {\n \t\t\treturn this.documentBuilderFactory.newDocumentBuilder();\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.documentBuilderFactoryMonitor.unlock();\n+\t\t}\n \t}\n \n }\n\ndiff --git a/spring-integration-xml/src/main/java/org/springframework/integration/xml/source/DomSourceFactory.java b/spring-integration-xml/src/main/java/org/springframework/integration/xml/source/DomSourceFactory.java\nindex ab2593ce47a..4714e1bbfc2 100644\n--- a/spring-integration-xml/src/main/java/org/springframework/integration/xml/source/DomSourceFactory.java\n+++ b/spring-integration-xml/src/main/java/org/springframework/integration/xml/source/DomSourceFactory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,6 +18,8 @@\n \n import java.io.File;\n import java.io.StringReader;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.xml.parsers.DocumentBuilder;\n import javax.xml.parsers.DocumentBuilderFactory;\n@@ -39,9 +41,12 @@\n  * @author Jonas Partner\n  * @author Mark Fisher\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class DomSourceFactory implements SourceFactory {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final DocumentBuilderFactory documentBuilderFactory;\n \n \n@@ -99,9 +104,13 @@ private DOMSource createDomSourceForFile(File file) {\n \t}\n \n \tprivate DocumentBuilder getNewDocumentBuilder() throws ParserConfigurationException {\n-\t\tsynchronized (this.documentBuilderFactory) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\treturn this.documentBuilderFactory.newDocumentBuilder();\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n }\n\ndiff --git a/spring-integration-xml/src/main/java/org/springframework/integration/xml/source/StringSourceFactory.java b/spring-integration-xml/src/main/java/org/springframework/integration/xml/source/StringSourceFactory.java\nindex 16599180d02..b1317fdc1ba 100644\n--- a/spring-integration-xml/src/main/java/org/springframework/integration/xml/source/StringSourceFactory.java\n+++ b/spring-integration-xml/src/main/java/org/springframework/integration/xml/source/StringSourceFactory.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,6 +18,8 @@\n \n import java.io.File;\n import java.io.FileReader;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.xml.transform.Source;\n import javax.xml.transform.Transformer;\n@@ -40,9 +42,12 @@\n  * @author Jonas Partner\n  * @author Mark Fisher\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class StringSourceFactory implements SourceFactory {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final TransformerFactory transformerFactory;\n \n \n@@ -96,13 +101,17 @@ private StringSource createStringSourceForFile(File file) {\n \t\t}\n \t}\n \n-\tprivate synchronized Transformer getTransformer() {\n+\tprivate Transformer getTransformer() {\n+\t\tthis.lock.lock();\n \t\ttry {\n \t\t\treturn this.transformerFactory.newTransformer();\n \t\t}\n \t\tcatch (Exception e) {\n \t\t\tthrow new MessagingException(\"Exception creating transformer\", e);\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n }\n\ndiff --git a/spring-integration-xml/src/main/java/org/springframework/integration/xml/splitter/XPathMessageSplitter.java b/spring-integration-xml/src/main/java/org/springframework/integration/xml/splitter/XPathMessageSplitter.java\nindex 3d615024fa3..13eb3653882 100644\n--- a/spring-integration-xml/src/main/java/org/springframework/integration/xml/splitter/XPathMessageSplitter.java\n+++ b/spring-integration-xml/src/main/java/org/springframework/integration/xml/splitter/XPathMessageSplitter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2021 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -22,6 +22,8 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Properties;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.Function;\n \n import javax.xml.parsers.DocumentBuilder;\n@@ -67,12 +69,15 @@\n  * @author Mark Fisher\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Christian Tzolov\n  */\n public class XPathMessageSplitter extends AbstractMessageSplitter {\n \n \tprivate final TransformerFactory transformerFactory;\n \n-\tprivate final Object documentBuilderFactoryMonitor = new Object();\n+\tprivate final Lock documentBuilderFactoryMonitor = new ReentrantLock();\n+\n+\tprivate final Lock transformerFactoryMonitor = new ReentrantLock();\n \n \tprivate final XPathExpression xpathExpression;\n \n@@ -249,9 +254,13 @@ protected int obtainSizeIfPossible(Iterator<?> iterator) {\n \tprivate Object splitDocument(Document document) throws ParserConfigurationException, TransformerException {\n \t\tObject nodes = splitNode(document);\n \t\tfinal Transformer transformer;\n-\t\tsynchronized (this.transformerFactory) {\n+\t\tthis.transformerFactoryMonitor.lock();\n+\t\ttry {\n \t\t\ttransformer = this.transformerFactory.newTransformer();\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.transformerFactoryMonitor.unlock();\n+\t\t}\n \t\tif (this.outputProperties != null) {\n \t\t\ttransformer.setOutputProperties(this.outputProperties);\n \t\t}\n@@ -317,9 +326,13 @@ private Document convertNodeToDocument(DocumentBuilder documentBuilder, Node nod\n \t}\n \n \tprivate DocumentBuilder getNewDocumentBuilder() throws ParserConfigurationException {\n-\t\tsynchronized (this.documentBuilderFactoryMonitor) {\n+\t\tthis.documentBuilderFactoryMonitor.lock();\n+\t\ttry {\n \t\t\treturn this.documentBuilderFactory.newDocumentBuilder();\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.documentBuilderFactoryMonitor.unlock();\n+\t\t}\n \t}\n \n \tprivate final class NodeListIterator implements Iterator<Node> {\n\ndiff --git a/spring-integration-xml/src/main/java/org/springframework/integration/xml/transformer/ResultToDocumentTransformer.java b/spring-integration-xml/src/main/java/org/springframework/integration/xml/transformer/ResultToDocumentTransformer.java\nindex 9cdbc40a1c6..10a77624bb0 100644\n--- a/spring-integration-xml/src/main/java/org/springframework/integration/xml/transformer/ResultToDocumentTransformer.java\n+++ b/spring-integration-xml/src/main/java/org/springframework/integration/xml/transformer/ResultToDocumentTransformer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,6 +17,8 @@\n package org.springframework.integration.xml.transformer;\n \n import java.io.StringReader;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.xml.parsers.DocumentBuilder;\n import javax.xml.parsers.DocumentBuilderFactory;\n@@ -38,9 +40,12 @@\n  *\n  * @author Jonas Partner\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class ResultToDocumentTransformer implements ResultTransformer {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \t// Not guaranteed to be thread safe\n \tprivate final DocumentBuilderFactory documentBuilderFactory;\n \n@@ -84,13 +89,17 @@ private Document createDocumentFromStringResult(StringResult stringResult) {\n \t\t}\n \t}\n \n-\tprivate synchronized DocumentBuilder getDocumentBuilder() {\n+\tprivate DocumentBuilder getDocumentBuilder() {\n+\t\tthis.lock.lock();\n \t\ttry {\n \t\t\treturn this.documentBuilderFactory.newDocumentBuilder();\n \t\t}\n \t\tcatch (ParserConfigurationException e) {\n \t\t\tthrow new MessagingException(\"failed to create a new DocumentBuilder\", e);\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n }\n\ndiff --git a/spring-integration-xml/src/main/java/org/springframework/integration/xml/transformer/ResultToStringTransformer.java b/spring-integration-xml/src/main/java/org/springframework/integration/xml/transformer/ResultToStringTransformer.java\nindex ee966a2cc97..cffdd198969 100644\n--- a/spring-integration-xml/src/main/java/org/springframework/integration/xml/transformer/ResultToStringTransformer.java\n+++ b/spring-integration-xml/src/main/java/org/springframework/integration/xml/transformer/ResultToStringTransformer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,6 +17,8 @@\n package org.springframework.integration.xml.transformer;\n \n import java.util.Properties;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.xml.transform.Result;\n import javax.xml.transform.Transformer;\n@@ -38,9 +40,12 @@\n  * @author Jonas Partner\n  * @author Mark Fisher\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class ResultToStringTransformer implements ResultTransformer {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final TransformerFactory transformerFactory;\n \n \tprivate Properties outputProperties;\n@@ -90,9 +95,13 @@ else if (result instanceof DOMResult) {\n \n \tprivate Transformer getNewTransformer() throws TransformerConfigurationException {\n \t\tTransformer transformer;\n-\t\tsynchronized (this.transformerFactory) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\ttransformer = this.transformerFactory.newTransformer();\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t\tif (this.outputProperties != null) {\n \t\t\ttransformer.setOutputProperties(this.outputProperties);\n \t\t}\n\ndiff --git a/spring-integration-xmpp/src/main/java/org/springframework/integration/xmpp/config/XmppConnectionFactoryBean.java b/spring-integration-xmpp/src/main/java/org/springframework/integration/xmpp/config/XmppConnectionFactoryBean.java\nindex a0a9c4ca9ba..833bfc7162a 100644\n--- a/spring-integration-xmpp/src/main/java/org/springframework/integration/xmpp/config/XmppConnectionFactoryBean.java\n+++ b/spring-integration-xmpp/src/main/java/org/springframework/integration/xmpp/config/XmppConnectionFactoryBean.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2020 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,9 @@\n \n package org.springframework.integration.xmpp.config;\n \n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n import org.jivesoftware.smack.ConnectionListener;\n import org.jivesoftware.smack.XMPPConnection;\n import org.jivesoftware.smack.roster.Roster;\n@@ -40,6 +43,7 @@\n  * @author Artem Bilan\n  * @author Philipp Etschel\n  * @author Gary Russell\n+ * @author Christian Tzolov\n  *\n  * @since 2.0\n  *\n@@ -47,7 +51,7 @@\n  */\n public class XmppConnectionFactoryBean extends AbstractFactoryBean<XMPPConnection> implements SmartLifecycle {\n \n-\tprivate final Object lifecycleMonitor = new Object();\n+\tprivate final Lock lifecycleMonitor = new ReentrantLock();\n \n \tprivate XMPPTCPConnectionConfiguration connectionConfiguration;\n \n@@ -172,7 +176,8 @@ protected XMPPTCPConnection getConnection() {\n \n \t@Override\n \tpublic void start() {\n-\t\tsynchronized (this.lifecycleMonitor) {\n+\t\tthis.lifecycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.running) {\n \t\t\t\treturn;\n \t\t\t}\n@@ -195,16 +200,23 @@ public void start() {\n \t\t\t\t\t\t+ connection.getXMPPServiceDomain(), e);\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleMonitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic void stop() {\n-\t\tsynchronized (this.lifecycleMonitor) {\n+\t\tthis.lifecycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.isRunning()) {\n \t\t\t\tgetConnection().disconnect();\n \t\t\t\tthis.running = false;\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleMonitor.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java\nindex 681f4fd0a86..2ed9aea6fdf 100644\n--- a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java\n+++ b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java\n@@ -20,6 +20,8 @@\n import java.util.concurrent.Executors;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.Consumer;\n \n import org.apache.commons.logging.Log;\n@@ -58,6 +60,7 @@\n  * The address for this socket is {@code \"inproc://\" + beanName + \".capture\"}.\n  *\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 5.4\n  *\n@@ -67,6 +70,8 @@ public class ZeroMqProxy implements InitializingBean, SmartLifecycle, BeanNameAw\n \n \tprivate static final Log LOG = LogFactory.getLog(ZeroMqProxy.class);\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final ZContext context;\n \n \tprivate final Type type;\n@@ -247,65 +252,78 @@ public void afterPropertiesSet() {\n \t}\n \n \t@Override\n-\tpublic synchronized void start() {\n-\t\tif (!this.running.get()) {\n-\t\t\tthis.proxyExecutor\n-\t\t\t\t\t.execute(() -> {\n-\t\t\t\t\t\tZMQ.Socket captureSocket = null;\n-\t\t\t\t\t\tif (this.exposeCaptureSocket) {\n-\t\t\t\t\t\t\tcaptureSocket = this.context.createSocket(SocketType.PUB);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\ttry (\n-\t\t\t\t\t\t\t\tZMQ.Socket frontendSocket = this.context.createSocket(this.type.getFrontendSocketType());\n-\t\t\t\t\t\t\t\tZMQ.Socket backendSocket = this.context.createSocket(this.type.getBackendSocketType());\n-\t\t\t\t\t\t\t\tZMQ.Socket controlSocket = this.context.createSocket(SocketType.PAIR)\n-\t\t\t\t\t\t) {\n-\n-\t\t\t\t\t\t\tif (this.frontendSocketConfigurer != null) {\n-\t\t\t\t\t\t\t\tthis.frontendSocketConfigurer.accept(frontendSocket);\n+\tpublic void start() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (!this.running.get()) {\n+\t\t\t\tthis.proxyExecutor\n+\t\t\t\t\t\t.execute(() -> {\n+\t\t\t\t\t\t\tZMQ.Socket captureSocket = null;\n+\t\t\t\t\t\t\tif (this.exposeCaptureSocket) {\n+\t\t\t\t\t\t\t\tcaptureSocket = this.context.createSocket(SocketType.PUB);\n \t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\ttry (\n+\t\t\t\t\t\t\t\t\tZMQ.Socket frontendSocket = this.context\n+\t\t\t\t\t\t\t\t\t\t\t.createSocket(this.type.getFrontendSocketType());\n+\t\t\t\t\t\t\t\t\tZMQ.Socket backendSocket = this.context\n+\t\t\t\t\t\t\t\t\t\t\t.createSocket(this.type.getBackendSocketType());\n+\t\t\t\t\t\t\t\t\tZMQ.Socket controlSocket = this.context.createSocket(SocketType.PAIR)) {\n+\n+\t\t\t\t\t\t\t\tif (this.frontendSocketConfigurer != null) {\n+\t\t\t\t\t\t\t\t\tthis.frontendSocketConfigurer.accept(frontendSocket);\n+\t\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\tif (this.backendSocketConfigurer != null) {\n-\t\t\t\t\t\t\t\tthis.backendSocketConfigurer.accept(backendSocket);\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tif (this.backendSocketConfigurer != null) {\n+\t\t\t\t\t\t\t\t\tthis.backendSocketConfigurer.accept(backendSocket);\n+\t\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\tthis.frontendPort.set(bindSocket(frontendSocket, this.frontendPort.get())); // NOSONAR\n-\t\t\t\t\t\t\tthis.backendPort.set(bindSocket(backendSocket, this.backendPort.get())); // NOSONAR\n-\t\t\t\t\t\t\tboolean bound = controlSocket.bind(this.controlAddress); // NOSONAR\n-\t\t\t\t\t\t\tif (!bound) {\n-\t\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot bind ZeroMQ socket to address: \"\n-\t\t\t\t\t\t\t\t\t\t+ this.controlAddress);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif (captureSocket != null) {\n-\t\t\t\t\t\t\t\tbound = captureSocket.bind(this.captureAddress);\n+\t\t\t\t\t\t\t\tthis.frontendPort.set(bindSocket(frontendSocket, this.frontendPort.get())); // NOSONAR\n+\t\t\t\t\t\t\t\tthis.backendPort.set(bindSocket(backendSocket, this.backendPort.get())); // NOSONAR\n+\t\t\t\t\t\t\t\tboolean bound = controlSocket.bind(this.controlAddress); // NOSONAR\n \t\t\t\t\t\t\t\tif (!bound) {\n \t\t\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot bind ZeroMQ socket to address: \"\n-\t\t\t\t\t\t\t\t\t\t\t+ this.captureAddress);\n+\t\t\t\t\t\t\t\t\t\t\t+ this.controlAddress);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tif (captureSocket != null) {\n+\t\t\t\t\t\t\t\t\tbound = captureSocket.bind(this.captureAddress);\n+\t\t\t\t\t\t\t\t\tif (!bound) {\n+\t\t\t\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot bind ZeroMQ socket to address: \"\n+\t\t\t\t\t\t\t\t\t\t\t\t+ this.captureAddress);\n+\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tthis.running.set(true);\n+\t\t\t\t\t\t\t\tZMQ.proxy(frontendSocket, backendSocket, captureSocket, controlSocket);\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tthis.running.set(true);\n-\t\t\t\t\t\t\tZMQ.proxy(frontendSocket, backendSocket, captureSocket, controlSocket);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (Exception ex) { // NOSONAR\n-\t\t\t\t\t\t\tLOG.error(\"Cannot start ZeroMQ proxy from bean: \" + this.beanName, ex);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tfinally {\n-\t\t\t\t\t\t\tif (captureSocket != null) {\n-\t\t\t\t\t\t\t\tcaptureSocket.close();\n+\t\t\t\t\t\t\tcatch (Exception ex) { // NOSONAR\n+\t\t\t\t\t\t\t\tLOG.error(\"Cannot start ZeroMQ proxy from bean: \" + this.beanName, ex);\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t});\n+\t\t\t\t\t\t\tfinally {\n+\t\t\t\t\t\t\t\tif (captureSocket != null) {\n+\t\t\t\t\t\t\t\t\tcaptureSocket.close();\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t}\n+\t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n \t\t}\n \t}\n \n \t@Override\n-\tpublic synchronized void stop() {\n-\t\tif (this.running.getAndSet(false)) {\n-\t\t\ttry (ZMQ.Socket commandSocket = this.context.createSocket(SocketType.PAIR)) {\n-\t\t\t\tcommandSocket.connect(this.controlAddress); // NOSONAR\n-\t\t\t\tcommandSocket.send(zmq.ZMQ.PROXY_TERMINATE);\n+\tpublic void stop() {\n+\t\tthis.lock.lock();\n+\t\ttry {\n+\t\t\tif (this.running.getAndSet(false)) {\n+\t\t\t\ttry (ZMQ.Socket commandSocket = this.context.createSocket(SocketType.PAIR)) {\n+\t\t\t\t\tcommandSocket.connect(this.controlAddress); // NOSONAR\n+\t\t\t\t\tcommandSocket.send(zmq.ZMQ.PROXY_TERMINATE);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/config/CuratorFrameworkFactoryBean.java b/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/config/CuratorFrameworkFactoryBean.java\nindex 933ecf69584..4fca3c612ea 100644\n--- a/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/config/CuratorFrameworkFactoryBean.java\n+++ b/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/config/CuratorFrameworkFactoryBean.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2015-2019 the original author or authors.\n+ * Copyright 2015-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,9 @@\n \n package org.springframework.integration.zookeeper.config;\n \n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n import org.apache.curator.RetryPolicy;\n import org.apache.curator.framework.CuratorFramework;\n import org.apache.curator.framework.CuratorFrameworkFactory;\n@@ -31,12 +34,13 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 4.2\n  */\n public class CuratorFrameworkFactoryBean implements FactoryBean<CuratorFramework>, SmartLifecycle {\n \n-\tprivate final Object lifecycleLock = new Object();\n+\tprivate final Lock lifecycleLock = new ReentrantLock();\n \n \tprivate final CuratorFramework client;\n \n@@ -109,7 +113,8 @@ public void setAutoStartup(boolean autoStartup) {\n \n \t@Override\n \tpublic void start() {\n-\t\tsynchronized (this.lifecycleLock) {\n+\t\tthis.lifecycleLock.lock();\n+\t\ttry {\n \t\t\tif (!this.running) {\n \t\t\t\tif (this.client != null) {\n \t\t\t\t\tthis.client.start();\n@@ -117,16 +122,23 @@ public void start() {\n \t\t\t\tthis.running = true;\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleLock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic void stop() {\n-\t\tsynchronized (this.lifecycleLock) {\n+\t\tthis.lifecycleLock.lock();\n+\t\ttry {\n \t\t\tif (this.running) {\n \t\t\t\tCloseableUtils.closeQuietly(this.client);\n \t\t\t\tthis.running = false;\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleLock.unlock();\n+\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/config/LeaderInitiatorFactoryBean.java b/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/config/LeaderInitiatorFactoryBean.java\nindex 1a098a878b0..c78efb7c3a2 100644\n--- a/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/config/LeaderInitiatorFactoryBean.java\n+++ b/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/config/LeaderInitiatorFactoryBean.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2015-2020 the original author or authors.\n+ * Copyright 2015-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -37,6 +37,7 @@\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 4.2\n  */\n@@ -177,7 +178,7 @@ else if (this.applicationEventPublisher != null) {\n \t}\n \n \t@Override\n-\tpublic synchronized LeaderInitiator getObject() {\n+\tpublic LeaderInitiator getObject() {\n \t\treturn this.leaderInitiator;\n \t}\n \n\ndiff --git a/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/leader/LeaderInitiator.java b/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/leader/LeaderInitiator.java\nindex 8203d525b26..b1ae7b11065 100644\n--- a/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/leader/LeaderInitiator.java\n+++ b/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/leader/LeaderInitiator.java\n@@ -18,6 +18,8 @@\n \n import java.util.Collection;\n import java.util.List;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n@@ -43,6 +45,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Ivan Zaitsev\n+ * @author Christian Tzolov\n  *\n  * @since 4.2\n  */\n@@ -66,7 +69,7 @@ public class LeaderInitiator implements SmartLifecycle {\n \t */\n \tprivate final Candidate candidate;\n \n-\tprivate final Object lifecycleMonitor = new Object();\n+\tprivate final Lock lifecycleMonitor = new ReentrantLock();\n \n \t/**\n \t * Base path in a zookeeper\n@@ -159,7 +162,8 @@ public void setAutoStartup(boolean autoStartup) {\n \t */\n \t@Override\n \tpublic void start() {\n-\t\tsynchronized (this.lifecycleMonitor) {\n+\t\tthis.lifecycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (!this.running) {\n \t\t\t\tif (this.client.getState() != CuratorFrameworkState.STARTED) {\n \t\t\t\t\t// we want to do curator start here because it needs to\n@@ -177,6 +181,9 @@ public void start() {\n \t\t\t\tLOGGER.debug(\"Started LeaderInitiator\");\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleMonitor.unlock();\n+\t\t}\n \t}\n \n \t/**\n@@ -185,13 +192,17 @@ public void start() {\n \t */\n \t@Override\n \tpublic void stop() {\n-\t\tsynchronized (this.lifecycleMonitor) {\n+\t\tthis.lifecycleMonitor.lock();\n+\t\ttry {\n \t\t\tif (this.running) {\n \t\t\t\tthis.leaderSelector.close();\n \t\t\t\tthis.running = false;\n \t\t\t\tLOGGER.debug(\"Stopped LeaderInitiator\");\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lifecycleMonitor.unlock();\n+\t\t}\n \t}\n \n \t/**\n\ndiff --git a/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/lock/ZookeeperLockRegistry.java b/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/lock/ZookeeperLockRegistry.java\nindex d7afaba8512..fece7d598f0 100644\n--- a/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/lock/ZookeeperLockRegistry.java\n+++ b/spring-integration-zookeeper/src/main/java/org/springframework/integration/zookeeper/lock/ZookeeperLockRegistry.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2015-2021 the original author or authors.\n+ * Copyright 2015-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -24,6 +24,7 @@\n import java.util.concurrent.TimeoutException;\n import java.util.concurrent.locks.Condition;\n import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.curator.framework.CuratorFramework;\n import org.apache.curator.framework.recipes.locks.InterProcessMutex;\n@@ -44,6 +45,7 @@\n  * @author Artem Bilan\n  * @author Vedran Pavic\n  * @author Unseok Kim\n+ * @author Christian Tzolov\n  *\n  * @since 4.2\n  *\n@@ -58,6 +60,8 @@ public class ZookeeperLockRegistry implements ExpirableLockRegistry, DisposableB\n \n \tprivate static final int DEFAULT_CAPACITY = 30_000;\n \n+\tprivate final Lock locksLock = new ReentrantLock();\n+\n \tprivate final Map<String, ZkLock> locks =\n \t\t\tnew LinkedHashMap<String, ZkLock>(16, 0.75F, true) {\n \n@@ -145,9 +149,13 @@ public Lock obtain(Object lockKey) {\n \t\tAssert.isInstanceOf(String.class, lockKey);\n \t\tString path = this.keyToPath.pathFor((String) lockKey);\n \t\tZkLock lock;\n-\t\tsynchronized (this.locks) {\n+\t\tthis.locksLock.lock();\n+\t\ttry {\n \t\t\tlock = this.locks.computeIfAbsent(path, p -> new ZkLock(this.client, this.mutexTaskExecutor, p));\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.locksLock.unlock();\n+\t\t}\n \t\tif (this.trackingTime) {\n \t\t\tlock.setLastUsed(System.currentTimeMillis());\n \t\t}\n@@ -155,10 +163,9 @@ public Lock obtain(Object lockKey) {\n \t}\n \n \t/**\n-\t * Remove locks last acquired more than 'age' ago that are not currently locked.\n-\t * Expiry is not supported if the {@link KeyToPathStrategy} is bounded (returns a finite\n-\t * number of paths). With such a {@link KeyToPathStrategy}, the overhead of tracking when\n-\t * a lock is obtained is avoided.\n+\t * Remove locks last acquired more than 'age' ago that are not currently locked. Expiry is not supported if the\n+\t * {@link KeyToPathStrategy} is bounded (returns a finite number of paths). With such a {@link KeyToPathStrategy},\n+\t * the overhead of tracking when a lock is obtained is avoided.\n \t * @param age the time since the lock was last obtained.\n \t */\n \t@Override\n@@ -168,13 +175,18 @@ public void expireUnusedOlderThan(long age) {\n \t\t}\n \n \t\tlong now = System.currentTimeMillis();\n-\t\tsynchronized (this.locks) {\n+\t\tthis.locksLock.lock();\n+\t\ttry {\n \t\t\tthis.locks.entrySet()\n \t\t\t\t\t.removeIf(entry -> {\n \t\t\t\t\t\tZkLock lock = entry.getValue();\n \t\t\t\t\t\treturn now - lock.getLastUsed() > age && !lock.isAcquiredInThisProcess();\n \t\t\t\t\t});\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.locksLock.unlock();\n+\t\t}\n+\n \t}\n \n \t@Override\n",
    "test_patch": "diff --git a/spring-integration-stomp/src/test/java/org/springframework/integration/stomp/inbound/StompInboundChannelAdapterWebSocketIntegrationTests.java b/spring-integration-stomp/src/test/java/org/springframework/integration/stomp/inbound/StompInboundChannelAdapterWebSocketIntegrationTests.java\nindex d10ca04b148..8d11caa1006 100644\n--- a/spring-integration-stomp/src/test/java/org/springframework/integration/stomp/inbound/StompInboundChannelAdapterWebSocketIntegrationTests.java\n+++ b/spring-integration-stomp/src/test/java/org/springframework/integration/stomp/inbound/StompInboundChannelAdapterWebSocketIntegrationTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2015-2022 the original author or authors.\n+ * Copyright 2015-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -247,7 +247,8 @@ public WebSocketClient webSocketClient() {\n \t\t}\n \n \t\t@Bean\n-\t\tpublic WebSocketStompClient stompClient(TaskScheduler taskScheduler) {\n+\t\tpublic WebSocketStompClient stompClient(\n+\t\t\t@Qualifier(\"taskScheduler\") TaskScheduler taskScheduler) {\n \t\t\tWebSocketStompClient webSocketStompClient = new WebSocketStompClient(webSocketClient());\n \t\t\twebSocketStompClient.setMessageConverter(new MappingJackson2MessageConverter());\n \t\t\twebSocketStompClient.setTaskScheduler(taskScheduler);\n@@ -347,6 +348,7 @@ public void configureMessageBroker(MessageBrokerRegistry configurer) {\n \t\t//SimpleBrokerMessageHandler doesn't support RECEIPT frame, hence we emulate it this way\n \t\t@Bean\n \t\tpublic ApplicationListener<SessionSubscribeEvent> webSocketEventListener(\n+\t\t\t\t@Qualifier(\"clientOutboundChannel\")\n \t\t\t\tfinal AbstractSubscribableChannel clientOutboundChannel) {\n \t\t\treturn event -> {\n \t\t\t\tMessage<byte[]> message = event.getMessage();\n\ndiff --git a/spring-integration-stream/src/main/java/org/springframework/integration/stream/ByteStreamReadingMessageSource.java b/spring-integration-stream/src/main/java/org/springframework/integration/stream/ByteStreamReadingMessageSource.java\nindex b5a15f814eb..edeaef71475 100644\n--- a/spring-integration-stream/src/main/java/org/springframework/integration/stream/ByteStreamReadingMessageSource.java\n+++ b/spring-integration-stream/src/main/java/org/springframework/integration/stream/ByteStreamReadingMessageSource.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,6 +19,8 @@\n import java.io.BufferedInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.springframework.integration.endpoint.AbstractMessageSource;\n import org.springframework.messaging.MessagingException;\n@@ -28,9 +30,12 @@\n  *\n  * @author Mark Fisher\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  */\n public class ByteStreamReadingMessageSource extends AbstractMessageSource<byte[]> {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprivate final BufferedInputStream stream;\n \n \tprivate int bytesPerMessage = 1024; // NOSONAR magic number\n@@ -73,13 +78,17 @@ protected byte[] doReceive() {\n \t\ttry {\n \t\t\tbyte[] bytes;\n \t\t\tint bytesRead = 0;\n-\t\t\tsynchronized (this.stream) {\n+\t\t\tthis.lock.lock();\n+\t\t\ttry {\n \t\t\t\tif (this.stream.available() == 0) {\n \t\t\t\t\treturn null;\n \t\t\t\t}\n \t\t\t\tbytes = new byte[this.bytesPerMessage];\n \t\t\t\tbytesRead = this.stream.read(bytes, 0, bytes.length);\n \t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.lock.unlock();\n+\t\t\t}\n \t\t\tif (bytesRead <= 0) {\n \t\t\t\treturn null;\n \t\t\t}\n\ndiff --git a/spring-integration-test/src/main/java/org/springframework/integration/test/mock/MockMessageHandler.java b/spring-integration-test/src/main/java/org/springframework/integration/test/mock/MockMessageHandler.java\nindex 646d97c72b6..ab2a5d931b6 100644\n--- a/spring-integration-test/src/main/java/org/springframework/integration/test/mock/MockMessageHandler.java\n+++ b/spring-integration-test/src/main/java/org/springframework/integration/test/mock/MockMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2017-2019 the original author or authors.\n+ * Copyright 2017-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,6 +19,8 @@\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n@@ -51,11 +53,14 @@\n  * </pre>\n  *\n  * @author Artem Bilan\n+ * @author Christian Tzolov\n  *\n  * @since 5.0\n  */\n public class MockMessageHandler extends AbstractMessageProducingHandler {\n \n+\tprivate final Lock lock = new ReentrantLock();\n+\n \tprotected final List<Function<Message<?>, ?>> messageFunctions = new LinkedList<>(); // NOSONAR final\n \n \tprivate final CapturingMatcher<Message<?>> capturingMatcher;\n@@ -110,13 +115,17 @@ protected void handleMessageInternal(Message<?> message) {\n \n \t\tFunction<Message<?>, ?> function = this.lastFunction;\n \n-\t\tsynchronized (this) {\n+\t\tthis.lock.lock();\n+\t\ttry {\n \t\t\tIterator<Function<Message<?>, ?>> iterator = this.messageFunctions.iterator();\n \t\t\tif (iterator.hasNext()) {\n \t\t\t\tfunction = iterator.next();\n \t\t\t\titerator.remove();\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\tthis.lock.unlock();\n+\t\t}\n \n \t\tObject result = function.apply(message);\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8647",
    "pr_id": 8647,
    "issue_id": 8642,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Revise an ExecutorService injections in favor of injected TaskExecutor\nSamples are `PostgresChannelMessageTableSubscriber`, `org.springframework.integration.hazelcast.leader.LeaderInitiator`.\r\nThese threads potentially can be created as virtual threads with Java 21.",
    "issue_word_count": 30,
    "test_files_count": 3,
    "non_test_files_count": 6,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiator.java",
      "spring-integration-core/src/test/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiatorTests.java",
      "spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/leader/LeaderInitiator.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresSubscribableChannel.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java",
      "spring-integration-redis/src/main/java/org/springframework/integration/redis/channel/SubscribableRedisChannel.java",
      "spring-integration-redis/src/test/java/org/springframework/integration/redis/leader/RedisLockRegistryLeaderInitiatorTests.java",
      "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiatorTests.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java",
      "spring-integration-redis/src/test/java/org/springframework/integration/redis/leader/RedisLockRegistryLeaderInitiatorTests.java"
    ],
    "base_commit": "aac2adbaa37dca8b8d39856f51c1ee77c79c6a40",
    "head_commit": "8f9edde0a865e4e474fa5f2eb7f3e3ec7230946c",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8647",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8647",
    "dockerfile": "",
    "pr_merged_at": "2023-06-14T17:33:47.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiator.java b/spring-integration-core/src/main/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiator.java\nindex 1e5323cdc9d..777dbdf3012 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiator.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiator.java\n@@ -18,25 +18,24 @@\n \n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.locks.Lock;\n \n-import org.apache.commons.logging.Log;\n-import org.apache.commons.logging.LogFactory;\n-\n import org.springframework.beans.factory.DisposableBean;\n import org.springframework.context.ApplicationEventPublisher;\n import org.springframework.context.ApplicationEventPublisherAware;\n import org.springframework.context.SmartLifecycle;\n+import org.springframework.core.log.LogAccessor;\n+import org.springframework.core.task.AsyncTaskExecutor;\n+import org.springframework.core.task.SimpleAsyncTaskExecutor;\n+import org.springframework.core.task.support.TaskExecutorAdapter;\n import org.springframework.integration.leader.Candidate;\n import org.springframework.integration.leader.Context;\n import org.springframework.integration.leader.DefaultCandidate;\n import org.springframework.integration.leader.event.DefaultLeaderEventPublisher;\n import org.springframework.integration.leader.event.LeaderEventPublisher;\n import org.springframework.integration.support.locks.LockRegistry;\n-import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n import org.springframework.util.Assert;\n \n /**\n@@ -67,9 +66,7 @@ public class LockRegistryLeaderInitiator implements SmartLifecycle, DisposableBe\n \n \tpublic static final long DEFAULT_BUSY_WAIT_TIME = 50L;\n \n-\tprivate static final Log LOGGER = LogFactory.getLog(LockRegistryLeaderInitiator.class);\n-\n-\tprivate final Object lifecycleMonitor = new Object();\n+\tprivate static final LogAccessor LOGGER = new LogAccessor(LockRegistryLeaderInitiator.class);\n \n \t/**\n \t * A lock registry. The locks it manages should be global (whatever that means for the\n@@ -103,14 +100,7 @@ public String getRole() {\n \t/**\n \t * Executor service for running leadership daemon.\n \t */\n-\tprivate ExecutorService executorService =\n-\t\t\tExecutors.newSingleThreadExecutor(new CustomizableThreadFactory(\"lock-leadership-\"));\n-\n-\t/**\n-\t * Flag to denote whether the {@link ExecutorService} was provided via the setter and\n-\t * thus should not be shutdown when {@link #destroy()} is called.\n-\t */\n-\tprivate boolean executorServiceExplicitlySet;\n+\tprivate AsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor(\"lock-leadership-\");\n \n \t/**\n \t * Time in milliseconds to wait in between attempts to re-acquire the lock, once it is\n@@ -161,7 +151,7 @@ public String getRole() {\n \n \t/**\n \t * Future returned by submitting an {@link LeaderSelector} to\n-\t * {@link #executorService}. This is used to cancel leadership.\n+\t * {@link #taskExecutor}. This is used to cancel leadership.\n \t */\n \tprivate volatile Future<?> future;\n \n@@ -192,10 +182,21 @@ public LockRegistryLeaderInitiator(LockRegistry locks, Candidate candidate) {\n \t * single thread Executor will be used.\n \t * @param executorService the executor service\n \t * @since 5.0.2\n+\t * @deprecated since 6.2 in favor of {@link #setTaskExecutor(AsyncTaskExecutor)}\n \t */\n+\t@Deprecated(since = \"6.2\", forRemoval = true)\n \tpublic void setExecutorService(ExecutorService executorService) {\n-\t\tthis.executorService = executorService;\n-\t\tthis.executorServiceExplicitlySet = true;\n+\t\tsetTaskExecutor(new TaskExecutorAdapter(executorService));\n+\t}\n+\n+\t/**\n+\t * Set a {@link AsyncTaskExecutor} for running leadership daemon.\n+\t * @param taskExecutor the {@link AsyncTaskExecutor} to use.\n+\t * @since 6.2\n+\t */\n+\tpublic void setTaskExecutor(AsyncTaskExecutor taskExecutor) {\n+\t\tAssert.notNull(taskExecutor, \"A 'taskExecutor' must not be null.\");\n+\t\tthis.taskExecutor = taskExecutor;\n \t}\n \n \tpublic void setHeartBeatMillis(long heartBeatMillis) {\n@@ -224,9 +225,7 @@ public void setApplicationEventPublisher(ApplicationEventPublisher applicationEv\n \t */\n \t@Override\n \tpublic boolean isRunning() {\n-\t\tsynchronized (this.lifecycleMonitor) {\n-\t\t\treturn this.running;\n-\t\t}\n+\t\treturn this.running;\n \t}\n \n \t@Override\n@@ -287,26 +286,21 @@ public void setPublishFailedEvents(boolean publishFailedEvents) {\n \t * Start the registration of the {@link #candidate} for leader election.\n \t */\n \t@Override\n-\tpublic void start() {\n+\tpublic synchronized void start() {\n \t\tif (this.leaderEventPublisher == null && this.applicationEventPublisher != null) {\n \t\t\tthis.leaderEventPublisher = new DefaultLeaderEventPublisher(this.applicationEventPublisher);\n \t\t}\n-\t\tsynchronized (this.lifecycleMonitor) {\n-\t\t\tif (!this.running) {\n-\t\t\t\tthis.leaderSelector = new LeaderSelector(buildLeaderPath());\n-\t\t\t\tthis.running = true;\n-\t\t\t\tthis.future = this.executorService.submit(this.leaderSelector);\n-\t\t\t\tLOGGER.debug(\"Started LeaderInitiator\");\n-\t\t\t}\n+\t\tif (!this.running) {\n+\t\t\tthis.leaderSelector = new LeaderSelector(buildLeaderPath());\n+\t\t\tthis.running = true;\n+\t\t\tthis.future = this.taskExecutor.submit(this.leaderSelector);\n+\t\t\tLOGGER.debug(\"Started LeaderInitiator\");\n \t\t}\n \t}\n \n \t@Override\n \tpublic void destroy() {\n \t\tstop();\n-\t\tif (!this.executorServiceExplicitlySet) {\n-\t\t\tthis.executorService.shutdown();\n-\t\t}\n \t}\n \n \t/**\n@@ -314,16 +308,14 @@ public void destroy() {\n \t * candidate is currently leader, its leadership will be revoked.\n \t */\n \t@Override\n-\tpublic void stop() {\n-\t\tsynchronized (this.lifecycleMonitor) {\n-\t\t\tif (this.running) {\n-\t\t\t\tthis.running = false;\n-\t\t\t\tif (this.future != null) {\n-\t\t\t\t\tthis.future.cancel(true);\n-\t\t\t\t}\n-\t\t\t\tthis.future = null;\n-\t\t\t\tLOGGER.debug(\"Stopped LeaderInitiator for \" + getContext());\n+\tpublic synchronized void stop() {\n+\t\tif (this.running) {\n+\t\t\tthis.running = false;\n+\t\t\tif (this.future != null) {\n+\t\t\t\tthis.future.cancel(true);\n \t\t\t}\n+\t\t\tthis.future = null;\n+\t\t\tLOGGER.debug(() -> \"Stopped LeaderInitiator for \" + getContext());\n \t\t}\n \t}\n \n@@ -382,9 +374,9 @@ public Void call() {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tthis.lock.unlock();\n \t\t\t\t\t}\n-\t\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\t\tLOGGER.debug(\"Could not unlock during stop for \" + this.context\n-\t\t\t\t\t\t\t\t+ \" - treat as broken. Revoking...\", e);\n+\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\tLOGGER.debug(ex, () ->\n+\t\t\t\t\t\t\t\t\"Could not unlock during stop for \" + this.context + \" - treat as broken. Revoking...\");\n \t\t\t\t\t}\n \t\t\t\t\t// We are stopping, therefore not leading anymore\n \t\t\t\t\thandleRevoked();\n@@ -394,9 +386,7 @@ public Void call() {\n \t\t}\n \n \t\tprivate void tryAcquireLock() throws InterruptedException {\n-\t\t\tif (LOGGER.isDebugEnabled()) {\n-\t\t\t\tLOGGER.debug(\"Acquiring the lock for \" + this.context);\n-\t\t\t}\n+\t\t\tLOGGER.debug(() -> \"Acquiring the lock for \" + this.context);\n \t\t\t// We always try to acquire the lock, in case it expired\n \t\t\tboolean acquired =\n \t\t\t\t\tthis.lock.tryLock(LockRegistryLeaderInitiator.this.heartBeatMillis, TimeUnit.MILLISECONDS);\n@@ -436,8 +426,8 @@ private boolean unlockAndHandleException(Exception ex) { // NOSONAR\n \t\t\t\t\tthis.lock.unlock();\n \t\t\t\t}\n \t\t\t\tcatch (Exception e1) {\n-\t\t\t\t\tLOGGER.debug(\"Could not unlock - treat as broken \" + this.context +\n-\t\t\t\t\t\t\t\". Revoking \" + (isRunning() ? \" and retrying...\" : \"...\"), e1);\n+\t\t\t\t\tLOGGER.debug(e1, () -> \"Could not unlock - treat as broken \" + this.context +\n+\t\t\t\t\t\t\t\". Revoking \" + (isRunning() ? \" and retrying...\" : \"...\"));\n \n \t\t\t\t}\n \t\t\t\t// The lock was broken and we are no longer leader\n@@ -462,18 +452,16 @@ private boolean unlockAndHandleException(Exception ex) { // NOSONAR\n \t\t\t\t\t\tThread.currentThread().interrupt();\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tif (LOGGER.isDebugEnabled()) {\n-\t\t\t\t\tLOGGER.debug(\"Error acquiring the lock for \" + this.context +\n-\t\t\t\t\t\t\t\". \" + (isRunning() ? \"Retrying...\" : \"\"), ex);\n-\t\t\t\t}\n+\t\t\t\tLOGGER.debug(ex, () ->\n+\t\t\t\t\t\t\"Error acquiring the lock for \" + this.context + \". \" + (isRunning() ? \"Retrying...\" : \"\"));\n \t\t\t}\n \t\t\treturn false;\n \t\t}\n \n \t\tprivate void restartSelectorBecauseOfError(Exception ex) {\n-\t\t\tLOGGER.warn(\"Restarting LeaderSelector for \" + this.context + \" because of error.\", ex);\n+\t\t\tLOGGER.warn(ex, () -> \"Restarting LeaderSelector for \" + this.context + \" because of error.\");\n \t\t\tLockRegistryLeaderInitiator.this.future =\n-\t\t\t\t\tLockRegistryLeaderInitiator.this.executorService.submit(\n+\t\t\t\t\tLockRegistryLeaderInitiator.this.taskExecutor.submit(\n \t\t\t\t\t\t\t() -> {\n \t\t\t\t\t\t\t\t// Give it a chance to elect some other leader.\n \t\t\t\t\t\t\t\tThread.sleep(LockRegistryLeaderInitiator.this.busyWaitMillis);\n@@ -492,8 +480,8 @@ private void handleGranted() throws InterruptedException {\n \t\t\t\t\tLockRegistryLeaderInitiator.this.leaderEventPublisher.publishOnGranted(\n \t\t\t\t\t\t\tLockRegistryLeaderInitiator.this, this.context, this.lockKey);\n \t\t\t\t}\n-\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\tLOGGER.warn(\"Error publishing OnGranted event.\", e);\n+\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\tLOGGER.warn(ex, \"Error publishing OnGranted event.\");\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -506,8 +494,8 @@ private void handleRevoked() {\n \t\t\t\t\t\t\tLockRegistryLeaderInitiator.this, this.context,\n \t\t\t\t\t\t\tLockRegistryLeaderInitiator.this.candidate.getRole());\n \t\t\t\t}\n-\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\tLOGGER.warn(\"Error publishing OnRevoked event.\", e);\n+\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\tLOGGER.warn(ex, \"Error publishing OnRevoked event.\");\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -520,8 +508,8 @@ private void publishFailedToAcquire() {\n \t\t\t\t\t\t\tthis.context,\n \t\t\t\t\t\t\tLockRegistryLeaderInitiator.this.candidate.getRole());\n \t\t\t\t}\n-\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\tLOGGER.warn(\"Error publishing OnFailedToAcquire event.\", e);\n+\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\tLOGGER.warn(ex, \"Error publishing OnFailedToAcquire event.\");\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -543,9 +531,7 @@ public boolean isLeader() {\n \n \t\t@Override\n \t\tpublic void yield() {\n-\t\t\tif (LOGGER.isDebugEnabled()) {\n-\t\t\t\tLOGGER.debug(\"Yielding leadership from \" + this);\n-\t\t\t}\n+\t\t\tLOGGER.debug(() -> \"Yielding leadership from \" + this);\n \t\t\tLockRegistryLeaderInitiator.this.leaderSelector.yielding = true;\n \t\t}\n \n\ndiff --git a/spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/leader/LeaderInitiator.java b/spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/leader/LeaderInitiator.java\nindex c83849ca027..2a843119cf3 100644\n--- a/spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/leader/LeaderInitiator.java\n+++ b/spring-integration-hazelcast/src/main/java/org/springframework/integration/hazelcast/leader/LeaderInitiator.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2015-2022 the original author or authors.\n+ * Copyright 2015-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,8 +18,6 @@\n \n \n import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n@@ -27,13 +25,15 @@\n import com.hazelcast.core.HazelcastInstance;\n import com.hazelcast.cp.CPSubsystem;\n import com.hazelcast.cp.lock.FencedLock;\n-import org.apache.commons.logging.Log;\n-import org.apache.commons.logging.LogFactory;\n \n import org.springframework.beans.factory.DisposableBean;\n import org.springframework.context.ApplicationEventPublisher;\n import org.springframework.context.ApplicationEventPublisherAware;\n import org.springframework.context.SmartLifecycle;\n+import org.springframework.core.log.LogAccessor;\n+import org.springframework.core.log.LogMessage;\n+import org.springframework.core.task.AsyncTaskExecutor;\n+import org.springframework.core.task.SimpleAsyncTaskExecutor;\n import org.springframework.integration.leader.Candidate;\n import org.springframework.integration.leader.Context;\n import org.springframework.integration.leader.DefaultCandidate;\n@@ -57,9 +57,7 @@\n  */\n public class LeaderInitiator implements SmartLifecycle, DisposableBean, ApplicationEventPublisherAware {\n \n-\tprivate static final Log logger = LogFactory.getLog(LeaderInitiator.class);\n-\n-\tprivate static int threadNameCount = 0;\n+\tprivate static final LogAccessor logger = new LogAccessor(LeaderInitiator.class);\n \n \tprivate static final Context NULL_CONTEXT = new NullContext();\n \n@@ -75,12 +73,7 @@ public class LeaderInitiator implements SmartLifecycle, DisposableBean, Applicat\n \t/**\n \t * Executor service for running leadership daemon.\n \t */\n-\tprivate final ExecutorService executorService =\n-\t\t\tExecutors.newSingleThreadExecutor(r -> {\n-\t\t\t\tThread thread = new Thread(r, \"Hazelcast-leadership-\" + (threadNameCount++));\n-\t\t\t\tthread.setDaemon(true);\n-\t\t\t\treturn thread;\n-\t\t\t});\n+\tprivate AsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor(\"Hazelcast-leadership-\");\n \n \tprivate long heartBeatMillis = LockRegistryLeaderInitiator.DEFAULT_HEART_BEAT_TIME;\n \n@@ -98,7 +91,7 @@ public class LeaderInitiator implements SmartLifecycle, DisposableBean, Applicat\n \tprivate int phase;\n \n \t/**\n-\t * Future returned by submitting an {@link LeaderSelector} to {@link #executorService}.\n+\t * Future returned by submitting an {@link LeaderSelector} to {@link #taskExecutor}.\n \t * This is used to cancel leadership.\n \t */\n \tprivate volatile Future<Void> future;\n@@ -130,7 +123,17 @@ public LeaderInitiator(HazelcastInstance client, Candidate candidate) {\n \t}\n \n \t/**\n-\t * Sets the {@link LeaderEventPublisher}.\n+\t * Set a {@link AsyncTaskExecutor} for running leadership daemon.\n+\t * @param taskExecutor the {@link AsyncTaskExecutor} to use.\n+\t * @since 6.2\n+\t */\n+\tpublic void setTaskExecutor(AsyncTaskExecutor taskExecutor) {\n+\t\tAssert.notNull(taskExecutor, \"A 'taskExecutor' must not be null.\");\n+\t\tthis.taskExecutor = taskExecutor;\n+\t}\n+\n+\t/**\n+\t * Set the {@link LeaderEventPublisher}.\n \t * @param leaderEventPublisher the event publisher\n \t */\n \tpublic void setLeaderEventPublisher(LeaderEventPublisher leaderEventPublisher) {\n@@ -209,7 +212,7 @@ public synchronized void start() {\n \t\tif (!this.running) {\n \t\t\tthis.leaderSelector = new LeaderSelector();\n \t\t\tthis.running = true;\n-\t\t\tthis.future = this.executorService.submit(this.leaderSelector);\n+\t\t\tthis.future = this.taskExecutor.submit(this.leaderSelector);\n \t\t}\n \t}\n \n@@ -246,17 +249,14 @@ public boolean isRunning() {\n \t@Override\n \tpublic void destroy() {\n \t\tstop();\n-\t\tthis.executorService.shutdown();\n \t}\n \n \n \tFencedLock getLock() {\n \t\tCPSubsystem cpSubSystem = this.client.getCPSubsystem();\n \t\tFencedLock lock = cpSubSystem.getLock(this.candidate.getRole());\n-\t\tif (logger.isDebugEnabled()) {\n-\t\t\tlogger.debug(\n-\t\t\t\t\tString.format(\"Use lock groupId '%s', lock count '%s'\", lock.getGroupId(), lock.getLockCount()));\n-\t\t}\n+\t\tlogger.debug(\n+\t\t\t\tLogMessage.format(\"Use lock groupId '%s', lock count '%s'\", lock.getGroupId(), lock.getLockCount()));\n \t\treturn lock;\n \t}\n \n@@ -278,17 +278,17 @@ public Void call() {\n \t\t\ttry {\n \t\t\t\twhile (isRunning()) {\n \t\t\t\t\ttry {\n-\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n-\t\t\t\t\t\t\tlogger.trace(\"Am I the leader (\" + LeaderInitiator.this.candidate.getRole() + \") ? \"\n-\t\t\t\t\t\t\t\t\t+ this.leader);\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tlogger.trace(() ->\n+\t\t\t\t\t\t\t\t\"Am I the leader (\" + LeaderInitiator.this.candidate.getRole() + \")? \" + this.leader);\n \t\t\t\t\t\tif (getLock().isLockedByCurrentThread()) {\n \t\t\t\t\t\t\tif (!this.leader) {\n \t\t\t\t\t\t\t\t// Since we have the lock we need to ensure that the leader flag is set\n \t\t\t\t\t\t\t\tthis.leader = true;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Give it a chance to expire.\n-\t\t\t\t\t\t\tif (LeaderInitiator.this.yieldSign.tryAcquire(LeaderInitiator.this.heartBeatMillis, TimeUnit.MILLISECONDS)) {\n+\t\t\t\t\t\t\tif (LeaderInitiator.this.yieldSign\n+\t\t\t\t\t\t\t\t\t.tryAcquire(LeaderInitiator.this.heartBeatMillis, TimeUnit.MILLISECONDS)) {\n+\n \t\t\t\t\t\t\t\trevokeLeadership();\n \t\t\t\t\t\t\t\t// Give it a chance to elect some other leader.\n \t\t\t\t\t\t\t\tThread.sleep(LeaderInitiator.this.busyWaitMillis);\n@@ -305,7 +305,7 @@ public Void call() {\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tcatch (Exception e) {\n+\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t// The lock was broken and we are no longer leader\n \t\t\t\t\t\trevokeLeadership();\n \n@@ -316,14 +316,12 @@ public Void call() {\n \t\t\t\t\t\t\t\tThread.sleep(LeaderInitiator.this.busyWaitMillis);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (InterruptedException e1) {\n-\t\t\t\t\t\t\t\t// Ignore interruption and let it to be caught on the next cycle.\n+\t\t\t\t\t\t\t\t// Ignore interruption and let it be caught on the next cycle.\n \t\t\t\t\t\t\t\tThread.currentThread().interrupt();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\tlogger.debug(\"Error acquiring the lock for \" + this.context +\n-\t\t\t\t\t\t\t\t\t\". \" + (isRunning() ? \"Retrying...\" : \"\"), e);\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tlogger.debug(ex, () -> \"Error acquiring the lock for \" + this.context +\n+\t\t\t\t\t\t\t\t\". \" + (isRunning() ? \"Retrying...\" : \"\"));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n@@ -342,8 +340,8 @@ private void revokeLeadership() {\n \t\t\t\t\tgetLock().unlock();\n \t\t\t\t}\n \t\t\t\tcatch (Exception e1) {\n-\t\t\t\t\tlogger.warn(\"Could not unlock - treat as broken \" + this.context + \". Revoking \"\n-\t\t\t\t\t\t\t+ (isRunning() ? \" and retrying...\" : \"...\"), e1);\n+\t\t\t\t\tlogger.warn(e1, () -> \"Could not unlock - treat as broken \" + this.context + \". Revoking \"\n+\t\t\t\t\t\t\t+ (isRunning() ? \" and retrying...\" : \"...\"));\n \n \t\t\t\t}\n \n@@ -359,8 +357,8 @@ private void handleGranted() throws InterruptedException {\n \t\t\t\t\tLeaderInitiator.this.leaderEventPublisher.publishOnGranted(\n \t\t\t\t\t\t\tLeaderInitiator.this, this.context, this.role);\n \t\t\t\t}\n-\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\tlogger.warn(\"Error publishing OnGranted event.\", e);\n+\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\tlogger.warn(ex, \"Error publishing OnGranted event.\");\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -372,8 +370,8 @@ private void handleRevoked() {\n \t\t\t\t\tLeaderInitiator.this.leaderEventPublisher.publishOnRevoked(\n \t\t\t\t\t\t\tLeaderInitiator.this, this.context, this.role);\n \t\t\t\t}\n-\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\tlogger.warn(\"Error publishing OnRevoked event.\", e);\n+\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\tlogger.warn(ex, \"Error publishing OnRevoked event.\");\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java\nindex c68f166008d..08d0c74b4f0 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java\n@@ -24,7 +24,6 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n \n@@ -33,10 +32,12 @@\n \n import org.springframework.context.SmartLifecycle;\n import org.springframework.core.log.LogAccessor;\n+import org.springframework.core.task.AsyncTaskExecutor;\n+import org.springframework.core.task.SimpleAsyncTaskExecutor;\n+import org.springframework.core.task.support.TaskExecutorAdapter;\n import org.springframework.integration.jdbc.store.JdbcChannelMessageStore;\n import org.springframework.integration.util.UUIDConverter;\n import org.springframework.lang.Nullable;\n-import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n import org.springframework.util.Assert;\n \n /**\n@@ -73,8 +74,7 @@ public final class PostgresChannelMessageTableSubscriber implements SmartLifecyc\n \n \tprivate final String tablePrefix;\n \n-\t@Nullable\n-\tprivate ExecutorService executor;\n+\tprivate AsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor(\"postgres-channel-message-table-subscriber-\");\n \n \tprivate CountDownLatch latch = new CountDownLatch(0);\n \n@@ -108,9 +108,21 @@ public PostgresChannelMessageTableSubscriber(PgConnectionSupplier connectionSupp\n \t * listening for notifications as a blocking operation which will permanently block a thread of this executor\n \t * while running.\n \t * @param executor The executor to use or {@code null} if an executor should be created by this class.\n+\t * @deprecated since 6.2 in favor of {@link #setTaskExecutor(AsyncTaskExecutor)}\n \t */\n-\tpublic synchronized void setExecutor(@Nullable ExecutorService executor) {\n-\t\tthis.executor = executor;\n+\t@Deprecated(since = \"6.2\", forRemoval = true)\n+\tpublic synchronized void setExecutor(ExecutorService executor) {\n+\t\tsetTaskExecutor(new TaskExecutorAdapter(executor));\n+\t}\n+\n+\t/**\n+\t * Provide a managed {@link AsyncTaskExecutor} for Postgres listener daemon.\n+\t * @param taskExecutor the {@link AsyncTaskExecutor} to use.\n+\t * @since 6.2\n+\t */\n+\tpublic void setTaskExecutor(AsyncTaskExecutor taskExecutor) {\n+\t\tAssert.notNull(taskExecutor, \"A 'taskExecutor' must not be null.\");\n+\t\tthis.taskExecutor = taskExecutor;\n \t}\n \n \t/**\n@@ -141,18 +153,11 @@ public synchronized void start() {\n \t\tif (this.latch.getCount() > 0) {\n \t\t\treturn;\n \t\t}\n-\t\tExecutorService executorToUse = this.executor;\n-\t\tif (executorToUse == null) {\n-\t\t\tCustomizableThreadFactory threadFactory =\n-\t\t\t\t\tnew CustomizableThreadFactory(\"postgres-channel-message-table-subscriber-\");\n-\t\t\tthreadFactory.setDaemon(true);\n-\t\t\texecutorToUse = Executors.newSingleThreadExecutor(threadFactory);\n-\t\t\tthis.executor = executorToUse;\n-\t\t}\n+\n \t\tthis.latch = new CountDownLatch(1);\n \n \t\tCountDownLatch startingLatch = new CountDownLatch(1);\n-\t\tthis.future = executorToUse.submit(() -> {\n+\t\tthis.future = this.taskExecutor.submit(() -> {\n \t\t\ttry {\n \t\t\t\twhile (isActive()) {\n \t\t\t\t\ttry {\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresSubscribableChannel.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresSubscribableChannel.java\nindex 422b01333ab..67428a30a2f 100644\n--- a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresSubscribableChannel.java\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresSubscribableChannel.java\n@@ -65,7 +65,7 @@ public class PostgresSubscribableChannel extends AbstractSubscribableChannel\n \n \tprivate RetryTemplate retryTemplate = RetryTemplate.builder().maxAttempts(1).build();\n \n-\tprivate Executor executor = new SimpleAsyncTaskExecutor();\n+\tprivate Executor executor;\n \n \t/**\n \t * Create a subscribable channel for a Postgres database.\n@@ -115,6 +115,14 @@ public void setRetryTemplate(RetryTemplate retryTemplate) {\n \t\tthis.retryTemplate = retryTemplate;\n \t}\n \n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tif (this.executor == null) {\n+\t\t\tthis.executor = new SimpleAsyncTaskExecutor(getBeanName() + \"-dispatcher-\");\n+\t\t}\n+\t}\n+\n \t@Override\n \tpublic boolean subscribe(MessageHandler handler) {\n \t\tboolean subscribed = super.subscribe(handler);\n\ndiff --git a/spring-integration-redis/src/main/java/org/springframework/integration/redis/channel/SubscribableRedisChannel.java b/spring-integration-redis/src/main/java/org/springframework/integration/redis/channel/SubscribableRedisChannel.java\nindex 3f31cbf8e9c..a82a8dbb384 100644\n--- a/spring-integration-redis/src/main/java/org/springframework/integration/redis/channel/SubscribableRedisChannel.java\n+++ b/spring-integration-redis/src/main/java/org/springframework/integration/redis/channel/SubscribableRedisChannel.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -67,10 +67,9 @@ public class SubscribableRedisChannel extends AbstractMessageChannel\n \n \tprivate final String topicName;\n \n-\tprivate final BroadcastingDispatcher dispatcher = new BroadcastingDispatcher(true);\n+\tprivate Executor taskExecutor;\n \n-\t// defaults\n-\tprivate Executor taskExecutor = new SimpleAsyncTaskExecutor();\n+\tprivate final BroadcastingDispatcher dispatcher = new BroadcastingDispatcher(true);\n \n \tprivate RedisSerializer<?> serializer = new StringRedisSerializer();\n \n@@ -148,6 +147,11 @@ public void onInit() {\n \t\t\t((BeanFactoryAware) this.messageConverter).setBeanFactory(beanFactory);\n \t\t}\n \t\tthis.container.setConnectionFactory(this.connectionFactory);\n+\n+\t\tif (this.taskExecutor == null) {\n+\t\t\tthis.taskExecutor = new SimpleAsyncTaskExecutor(getBeanName() + \"-\");\n+\t\t}\n+\n \t\tif (!(this.taskExecutor instanceof ErrorHandlingTaskExecutor)) {\n \t\t\tErrorHandler errorHandler = ChannelUtils.getErrorHandler(beanFactory);\n \t\t\tthis.taskExecutor = new ErrorHandlingTaskExecutor(this.taskExecutor, errorHandler);\n\ndiff --git a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java\nindex 9b5956fca0d..681f4fd0a86 100644\n--- a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java\n+++ b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2022 the original author or authors.\n+ * Copyright 2020-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,7 +17,6 @@\n package org.springframework.integration.zeromq;\n \n import java.util.concurrent.Executor;\n-import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n@@ -33,8 +32,8 @@\n import org.springframework.beans.factory.DisposableBean;\n import org.springframework.beans.factory.InitializingBean;\n import org.springframework.context.SmartLifecycle;\n+import org.springframework.core.task.SimpleAsyncTaskExecutor;\n import org.springframework.lang.Nullable;\n-import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n import org.springframework.util.Assert;\n \n /**\n@@ -82,8 +81,6 @@ public class ZeroMqProxy implements InitializingBean, SmartLifecycle, BeanNameAw\n \n \tprivate Executor proxyExecutor;\n \n-\tprivate boolean proxyExecutorExplicitlySet;\n-\n \t@Nullable\n \tprivate Consumer<ZMQ.Socket> frontendSocketConfigurer;\n \n@@ -126,13 +123,12 @@ public ZeroMqProxy(ZContext context, Type type) {\n \t/**\n \t * Configure an executor to perform a ZeroMQ proxy loop.\n \t * The thread is held until ZeroMQ proxy loop is terminated.\n-\t * By default an internal {@link Executors#newSingleThreadExecutor} instance is used.\n+\t * By default, an internal {@link Executors#newSingleThreadExecutor} instance is used.\n \t * @param proxyExecutor the {@link Executor} to use for ZeroMQ proxy loop\n \t */\n \tpublic void setProxyExecutor(Executor proxyExecutor) {\n \t\tAssert.notNull(proxyExecutor, \"'proxyExecutor' must not be null\");\n \t\tthis.proxyExecutor = proxyExecutor;\n-\t\tthis.proxyExecutorExplicitlySet = true;\n \t}\n \n \t/**\n@@ -242,7 +238,7 @@ public int getPhase() {\n \t@Override\n \tpublic void afterPropertiesSet() {\n \t\tif (this.proxyExecutor == null) {\n-\t\t\tthis.proxyExecutor = Executors.newSingleThreadExecutor(new CustomizableThreadFactory(this.beanName));\n+\t\t\tthis.proxyExecutor = new SimpleAsyncTaskExecutor(this.beanName + \"-\");\n \t\t}\n \t\tthis.controlAddress = \"inproc://\" + this.beanName + \".control\";\n \t\tif (this.exposeCaptureSocket) {\n@@ -319,9 +315,7 @@ public boolean isRunning() {\n \n \t@Override\n \tpublic void destroy() {\n-\t\tif (!this.proxyExecutorExplicitlySet) {\n-\t\t\t((ExecutorService) this.proxyExecutor).shutdown();\n-\t\t}\n+\t\tstop();\n \t}\n \n \tprivate static int bindSocket(ZMQ.Socket socket, int port) {\n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiatorTests.java b/spring-integration-core/src/test/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiatorTests.java\nindex 15fbcd1f689..e7dc3efc75b 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiatorTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/support/leader/LockRegistryLeaderInitiatorTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2012-2022 the original author or authors.\n+ * Copyright 2012-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,27 +17,24 @@\n package org.springframework.integration.support.leader;\n \n import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n \n-import org.junit.Before;\n-import org.junit.Test;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.DirectFieldAccessor;\n import org.springframework.core.task.SyncTaskExecutor;\n-import org.springframework.core.task.support.ExecutorServiceAdapter;\n+import org.springframework.core.task.support.TaskExecutorAdapter;\n import org.springframework.integration.leader.Context;\n import org.springframework.integration.leader.DefaultCandidate;\n import org.springframework.integration.leader.event.DefaultLeaderEventPublisher;\n import org.springframework.integration.leader.event.LeaderEventPublisher;\n import org.springframework.integration.support.locks.DefaultLockRegistry;\n import org.springframework.integration.support.locks.LockRegistry;\n-import org.springframework.integration.test.util.TestUtils;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n@@ -69,7 +66,7 @@ public class LockRegistryLeaderInitiatorTests {\n \tprivate final LockRegistryLeaderInitiator initiator =\n \t\t\tnew LockRegistryLeaderInitiator(this.registry, new DefaultCandidate());\n \n-\t@Before\n+\t@BeforeEach\n \tpublic void init() {\n \t\tthis.initiator.setLeaderEventPublisher(new CountingPublisher(this.granted, this.revoked));\n \t}\n@@ -255,9 +252,8 @@ public void testGracefulLeaderSelectorExit() throws Exception {\n \t\t\t\t.given(lock)\n \t\t\t\t.tryLock(anyLong(), eq(TimeUnit.MILLISECONDS));\n \n-\t\tnew DirectFieldAccessor(another).setPropertyValue(\"executorService\",\n-\t\t\t\tnew ExecutorServiceAdapter(\n-\t\t\t\t\t\tnew SyncTaskExecutor()));\n+\t\tnew DirectFieldAccessor(another).setPropertyValue(\"taskExecutor\",\n+\t\t\t\tnew TaskExecutorAdapter(new SyncTaskExecutor()));\n \n \t\tanother.start();\n \n@@ -297,29 +293,6 @@ public void testExceptionFromLock() throws Exception {\n \t\tanother.stop();\n \t}\n \n-\t@Test\n-\tpublic void shouldShutdownInternalExecutorService() {\n-\t\tthis.initiator.start();\n-\t\tthis.initiator.destroy();\n-\n-\t\tExecutorService executorService =\n-\t\t\t\tTestUtils.getPropertyValue(this.initiator, \"executorService\", ExecutorService.class);\n-\n-\t\tassertThat(executorService.isShutdown()).isTrue();\n-\t}\n-\n-\t@Test\n-\tpublic void doNotShutdownProvidedExecutorService() {\n-\t\tLockRegistryLeaderInitiator another = new LockRegistryLeaderInitiator(this.registry);\n-\t\tExecutorService executorService = Executors.newSingleThreadExecutor();\n-\t\tanother.setExecutorService(executorService);\n-\n-\t\tanother.start();\n-\t\tanother.destroy();\n-\n-\t\tassertThat(executorService.isShutdown()).isFalse();\n-\t}\n-\n \tprivate static class CountingPublisher implements LeaderEventPublisher {\n \n \t\tprivate final CountDownLatch granted;\n\ndiff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java\nindex bbe9ab567d3..f29a8bf422d 100644\n--- a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriberTests.java\n@@ -124,6 +124,8 @@ void setUp(TestInfo testInfo) {\n \n \t\tthis.postgresSubscribableChannel =\n \t\t\t\tnew PostgresSubscribableChannel(messageStore, groupId, postgresChannelMessageTableSubscriber);\n+\t\tthis.postgresSubscribableChannel.setBeanName(\"testPostgresChannel\");\n+\t\tthis.postgresSubscribableChannel.afterPropertiesSet();\n \t}\n \n \t@AfterEach\n\ndiff --git a/spring-integration-redis/src/test/java/org/springframework/integration/redis/leader/RedisLockRegistryLeaderInitiatorTests.java b/spring-integration-redis/src/test/java/org/springframework/integration/redis/leader/RedisLockRegistryLeaderInitiatorTests.java\nindex cfd4175e88d..667b6ef9fdf 100644\n--- a/spring-integration-redis/src/test/java/org/springframework/integration/redis/leader/RedisLockRegistryLeaderInitiatorTests.java\n+++ b/spring-integration-redis/src/test/java/org/springframework/integration/redis/leader/RedisLockRegistryLeaderInitiatorTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2022 the original author or authors.\n+ * Copyright 2016-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,12 +19,12 @@\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n \n+import org.springframework.core.task.SimpleAsyncTaskExecutor;\n import org.springframework.data.redis.connection.RedisConnectionFactory;\n import org.springframework.integration.leader.Context;\n import org.springframework.integration.leader.DefaultCandidate;\n@@ -33,7 +33,6 @@\n import org.springframework.integration.redis.util.RedisLockRegistry;\n import org.springframework.integration.support.leader.LockRegistryLeaderInitiator;\n import org.springframework.integration.test.condition.LogLevels;\n-import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -64,8 +63,7 @@ void testDistributedLeaderElection() throws Exception {\n \t\tfor (int i = 0; i < 2; i++) {\n \t\t\tLockRegistryLeaderInitiator initiator =\n \t\t\t\t\tnew LockRegistryLeaderInitiator(registry, new DefaultCandidate(\"foo:\" + i, \"bar\"));\n-\t\t\tinitiator.setExecutorService(\n-\t\t\t\t\tExecutors.newSingleThreadExecutor(new CustomizableThreadFactory(\"lock-leadership-\" + i + \"-\")));\n+\t\t\tinitiator.setTaskExecutor(new SimpleAsyncTaskExecutor(\"lock-leadership-\" + i + \"-\"));\n \t\t\tinitiator.setLeaderEventPublisher(countingPublisher);\n \t\t\tinitiators.add(initiator);\n \t\t}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8641",
    "pr_id": 8641,
    "issue_id": 8638,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "KafkaProducerMessageHandler send failure messages for immediate exceptions\n### Discussed in https://github.com/spring-projects/spring-integration/discussions/8637\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **yevsh** June  1, 2023</sup>\r\nSometimes there are  \"error\" network/kafka cluster errors - that can be only detected when we see in logs something like:\r\n\r\n`\"INFO\",\"logger\":\"org.apache.kafka.clients.NetworkClient\",\"message\":\"[Producer clientId=producer-1] Node 2 disconnected`.\r\n\r\nThe problem KafkaTemplate/KafkaProducerMessageHandler can't identify it as error, and data can be lost.\r\n\r\nNeed some reliable solution for this.</div>",
    "issue_word_count": 89,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandlerTests.java",
      "src/checkstyle/checkstyle.xml"
    ],
    "pr_changed_test_files": [
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandlerTests.java"
    ],
    "base_commit": "8b8a7a4c16661ffd62508dc782dcf8cf0388cfff",
    "head_commit": "9a2e195a92d98f25bef2e02ec2ea621f24a27619",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8641",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8641",
    "dockerfile": "",
    "pr_merged_at": "2023-06-08T17:44:30.000Z",
    "patch": "diff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java\nindex f6eaacf233b..961596e0d0a 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2022 the original author or authors.\n+ * Copyright 2013-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -438,6 +438,7 @@ public String getComponentType() {\n \t\treturn this.isGateway ? \"kafka:outbound-gateway\" : \"kafka:outbound-channel-adapter\";\n \t}\n \n+\t@Nullable\n \tprotected MessageChannel getSendFailureChannel() {\n \t\tif (this.sendFailureChannel != null) {\n \t\t\treturn this.sendFailureChannel;\n@@ -515,19 +516,27 @@ protected Object handleRequestMessage(final Message<?> message) {\n \t\t}\n \t\tCompletableFuture<SendResult<K, V>> sendFuture;\n \t\tRequestReplyFuture<K, V, Object> gatewayFuture = null;\n-\t\tif (this.isGateway && (!preBuilt || producerRecord.headers().lastHeader(KafkaHeaders.REPLY_TOPIC) == null)) {\n-\t\t\tproducerRecord.headers().add(new RecordHeader(KafkaHeaders.REPLY_TOPIC, getReplyTopic(message)));\n-\t\t\tgatewayFuture = ((ReplyingKafkaTemplate<K, V, Object>) this.kafkaTemplate).sendAndReceive(producerRecord);\n-\t\t\tsendFuture = gatewayFuture.getSendFuture();\n-\t\t}\n-\t\telse {\n-\t\t\tif (this.transactional && !this.kafkaTemplate.inTransaction() && !this.allowNonTransactional) {\n-\t\t\t\tsendFuture = this.kafkaTemplate.executeInTransaction(template -> template.send(producerRecord));\n+\t\ttry {\n+\t\t\tif (this.isGateway\n+\t\t\t\t\t&& (!preBuilt || producerRecord.headers().lastHeader(KafkaHeaders.REPLY_TOPIC) == null)) {\n+\t\t\t\tproducerRecord.headers().add(new RecordHeader(KafkaHeaders.REPLY_TOPIC, getReplyTopic(message)));\n+\t\t\t\tgatewayFuture = ((ReplyingKafkaTemplate<K, V, Object>) this.kafkaTemplate)\n+\t\t\t\t\t\t.sendAndReceive(producerRecord);\n+\t\t\t\tsendFuture = gatewayFuture.getSendFuture();\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tsendFuture = this.kafkaTemplate.send(producerRecord);\n+\t\t\t\tif (this.transactional && !this.kafkaTemplate.inTransaction() && !this.allowNonTransactional) {\n+\t\t\t\t\tsendFuture = this.kafkaTemplate.executeInTransaction(template -> template.send(producerRecord));\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tsendFuture = this.kafkaTemplate.send(producerRecord);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tcatch (RuntimeException rtex) {\n+\t\t\tsendFailure(message, producerRecord, getSendFailureChannel(), rtex);\n+\t\t\tthrow rtex;\n+\t\t}\n \t\tsendFutureIfRequested(sendFuture, futureToken);\n \t\tif (flush) {\n \t\t\tthis.kafkaTemplate.flush();\n@@ -699,10 +708,8 @@ public void processSendResult(final Message<?> message, final ProducerRecord<K,\n \t\t\t\t\t\t\t\t\t\t.build());\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\telse if (failureChannel != null) {\n-\t\t\t\t\tKafkaProducerMessageHandler.this.messagingTemplate.send(failureChannel,\n-\t\t\t\t\t\t\tKafkaProducerMessageHandler.this.errorMessageStrategy.buildErrorMessage(\n-\t\t\t\t\t\t\t\t\tnew KafkaSendFailureException(message, producerRecord, exception), null));\n+\t\t\t\telse {\n+\t\t\t\t\tsendFailure(message, producerRecord, failureChannel, exception);\n \t\t\t\t}\n \t\t\t});\n \t\t}\n@@ -730,6 +737,16 @@ else if (failureChannel != null) {\n \t\t}\n \t}\n \n+\tprivate void sendFailure(final Message<?> message, final ProducerRecord<K, V> producerRecord,\n+\t\t\t@Nullable MessageChannel failureChannel, Throwable exception) {\n+\n+\t\tif (failureChannel != null) {\n+\t\t\tKafkaProducerMessageHandler.this.messagingTemplate.send(failureChannel,\n+\t\t\t\t\tKafkaProducerMessageHandler.this.errorMessageStrategy.buildErrorMessage(\n+\t\t\t\t\t\t\tnew KafkaSendFailureException(message, producerRecord, exception), null));\n+\t\t}\n+\t}\n+\n \tprivate Future<?> processReplyFuture(@Nullable RequestReplyFuture<?, ?, Object> future) {\n \t\tif (future == null) {\n \t\t\treturn null;\n\ndiff --git a/src/checkstyle/checkstyle.xml b/src/checkstyle/checkstyle.xml\nindex f557a20d5e2..0a23156ce3b 100644\n--- a/src/checkstyle/checkstyle.xml\n+++ b/src/checkstyle/checkstyle.xml\n@@ -80,6 +80,7 @@\n \t\t\t\t\t  value=\"org.assertj.core.api.Assertions.*,\n \t\t\t\t\t  org.xmlunit.assertj3.XmlAssert.*,\n \t\t\t\torg.assertj.core.api.Assumptions.*,\n+\t\t\t\torg.assertj.core.api.InstanceOfAssertFactories.*,\n \t\t\t\torg.awaitility.Awaitility.*,\n \t\t\t\torg.mockito.Mockito.*,\n \t\t\t\torg.mockito.BDDMockito.*,\n",
    "test_patch": "diff --git a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandlerTests.java b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandlerTests.java\nindex 54759d6d855..28317ab32d9 100644\n--- a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandlerTests.java\n+++ b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandlerTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2022 the original author or authors.\n+ * Copyright 2016-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -60,6 +60,7 @@\n import org.springframework.integration.kafka.support.KafkaIntegrationHeaders;\n import org.springframework.integration.kafka.support.KafkaSendFailureException;\n import org.springframework.integration.support.MessageBuilder;\n+import org.springframework.kafka.KafkaException;\n import org.springframework.kafka.core.ConsumerFactory;\n import org.springframework.kafka.core.DefaultKafkaConsumerFactory;\n import org.springframework.kafka.core.DefaultKafkaProducerFactory;\n@@ -93,6 +94,7 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.InstanceOfAssertFactories.throwable;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.isNull;\n import static org.mockito.BDDMockito.given;\n@@ -344,6 +346,35 @@ protected CompletableFuture<SendResult<Integer, String>> doSend(\n \t\tproducerFactory.destroy();\n \t}\n \n+\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+\t@Test\n+\tvoid immediateFailure() {\n+\t\tProducer producer = mock(Producer.class);\n+\t\tCompletableFuture cf = new CompletableFuture();\n+\t\tRuntimeException rte = new RuntimeException(\"test.immediate\");\n+\t\tcf.completeExceptionally(rte);\n+\t\tgiven(producer.send(any(), any())).willReturn(cf);\n+\t\tProducerFactory pf = mock(ProducerFactory.class);\n+\t\tgiven(pf.createProducer()).willReturn(producer);\n+\t\tKafkaTemplate template = new KafkaTemplate(pf);\n+\t\ttemplate.setDefaultTopic(\"foo\");\n+\t\tKafkaProducerMessageHandler handler = new KafkaProducerMessageHandler<>(template);\n+\t\tQueueChannel fails = new QueueChannel();\n+\t\thandler.setSendFailureChannel(fails);\n+\t\tassertThatExceptionOfType(MessageHandlingException.class).isThrownBy(\n+\t\t\t\t\t\t() -> handler.handleMessage(new GenericMessage<>(\"\")))\n+\t\t\t\t.withCauseExactlyInstanceOf(KafkaException.class)\n+\t\t\t\t.withStackTraceContaining(\"test.immediate\");\n+\t\tMessage<?> fail = fails.receive(0);\n+\t\tassertThat(fail).isNotNull();\n+\t\tassertThat(fail.getPayload())\n+\t\t\t.asInstanceOf(throwable(KafkaSendFailureException.class))\n+\t\t\t.cause()\n+\t\t\t.isInstanceOf(KafkaException.class)\n+\t\t\t.cause()\n+\t\t\t.isEqualTo(rte);\n+\t}\n+\n \t@Test\n \tvoid testOutboundWithCustomHeaderMapper() {\n \t\tDefaultKafkaProducerFactory<Integer, String> producerFactory = new DefaultKafkaProducerFactory<>(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8636",
    "pr_id": 8636,
    "issue_id": 8625,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Poller fixed-delay and fixed-rate support for Duration syntax\n**Expected Behavior**\r\n\r\nIt would be nice and useful (from a configuration point of view) if `<int:poller>` attributes `fixed-delay` and `fixed-rate` supported the `java.time.Duration` syntax, with support for resolvable configuration values (via a `StringValueResolver`) just like `@Scheduled`/`ScheduledAnnotationBeanPostProcessor` do.\r\n\r\n**Current Behavior**\r\n\r\n`fixed-delay` and `fixed-rate` attributes in `<int:poller>` must be integer values, interpreted as milliseconds or amount of `time-unit` units. Resolvable configuration values are supported, but configuration must then specify these values as milliseconds, or provide two distinct configuration values for delay/rate and time unit.\r\n\r\n**Context**\r\n\r\nUsing Spring Integration with Spring Boot 2.7.10. Duration syntax is nicely supported in a lot of places, but not in `<int:poller>` tag.\r\nThe alternative to have maximum flexibility is to leave `fixed-delay`/`fixed-rate` in milliseconds and externalize them in configuration. But milliseconds are not so readable when resolutions of minutes or hours is needed.\r\n",
    "issue_word_count": 163,
    "test_files_count": 3,
    "non_test_files_count": 5,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/BaseIntegrationFlowDefinition.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/HeaderFilterSpec.java",
      "spring-integration-core/src/main/java/org/springframework/integration/transformer/HeaderFilter.java",
      "spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinIntegrationFlowDefinition.kt",
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/correlation/CorrelationHandlerTests.java",
      "spring-integration-core/src/test/kotlin/org/springframework/integration/dsl/KotlinDslTests.kt",
      "spring-integration-groovy/src/main/groovy/org/springframework/integration/groovy/dsl/GroovyIntegrationFlowDefinition.groovy",
      "spring-integration-groovy/src/test/groovy/org/springframework/integration/groovy/dsl/test/GroovyDslTests.groovy"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/dsl/correlation/CorrelationHandlerTests.java",
      "spring-integration-core/src/test/kotlin/org/springframework/integration/dsl/KotlinDslTests.kt",
      "spring-integration-groovy/src/test/groovy/org/springframework/integration/groovy/dsl/test/GroovyDslTests.groovy"
    ],
    "base_commit": "8b004e9ec2be349cd112c84ba7075e84f1eaa232",
    "head_commit": "ec857af11b6288b2f3b6f4f08aaaf4a4afd0474a",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8636",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8636",
    "dockerfile": "",
    "pr_merged_at": "2023-06-01T16:18:02.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/BaseIntegrationFlowDefinition.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/BaseIntegrationFlowDefinition.java\nindex 14a85c3caa4..d2caa74932e 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/BaseIntegrationFlowDefinition.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/BaseIntegrationFlowDefinition.java\n@@ -1626,11 +1626,23 @@ public B headerFilter(String... headersToRemove) {\n \t * @param patternMatch the {@code boolean} flag to indicate if {@code headersToRemove}\n \t * should be interpreted as patterns or direct header names.\n \t * @return this {@link BaseIntegrationFlowDefinition}.\n+\t * @deprecated since 6.2 in favor of {@link #headerFilter(Consumer)}\n \t */\n+\t@Deprecated(since = \"6.2\", forRemoval = true)\n \tpublic B headerFilter(String headersToRemove, boolean patternMatch) {\n-\t\tHeaderFilter headerFilter = new HeaderFilter(StringUtils.delimitedListToStringArray(headersToRemove, \",\", \" \"));\n-\t\theaderFilter.setPatternMatch(patternMatch);\n-\t\treturn headerFilter(headerFilter, null);\n+\t\treturn headerFilter((headerFilterSpec) -> headerFilterSpec\n+\t\t\t\t.headersToRemove(StringUtils.delimitedListToStringArray(headersToRemove, \",\", \" \"))\n+\t\t\t\t.patternMatch(patternMatch));\n+\t}\n+\n+\t/**\n+\t * Provide the {@link HeaderFilter} options via fluent API of the {@link HeaderFilterSpec}.\n+\t * @param headerFilter the {@link Consumer} to provide header filter and its endpoint options.\n+\t * @return this {@link BaseIntegrationFlowDefinition}.\n+\t * @since 6.2\n+\t */\n+\tpublic B headerFilter(Consumer<HeaderFilterSpec> headerFilter) {\n+\t\treturn register(new HeaderFilterSpec(), headerFilter);\n \t}\n \n \t/**\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/HeaderFilterSpec.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/HeaderFilterSpec.java\nnew file mode 100644\nindex 00000000000..39e0cf978a6\n--- /dev/null\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/HeaderFilterSpec.java\n@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.dsl;\n+\n+import org.springframework.integration.transformer.HeaderFilter;\n+import org.springframework.integration.transformer.MessageTransformingHandler;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * A {@link ConsumerEndpointSpec} implementation for the {@link HeaderFilter}.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 6.2\n+ */\n+public class HeaderFilterSpec extends ConsumerEndpointSpec<HeaderFilterSpec, MessageTransformingHandler> {\n+\n+\tprivate final HeaderFilter headerFilter;\n+\n+\tprivate final boolean headerFilterExplicitlySet;\n+\n+\tprotected HeaderFilterSpec() {\n+\t\tthis(new HeaderFilter(), false);\n+\t}\n+\n+\tprotected HeaderFilterSpec(HeaderFilter headerFilter) {\n+\t\tthis(headerFilter, true);\n+\t}\n+\n+\tprivate HeaderFilterSpec(HeaderFilter headerFilter, boolean headerFilterExplicitlySet) {\n+\t\tsuper(new MessageTransformingHandler(headerFilter));\n+\t\tthis.headerFilter = headerFilter;\n+\t\tthis.componentsToRegister.put(this.headerFilter, null);\n+\t\tthis.headerFilterExplicitlySet = headerFilterExplicitlySet;\n+\t}\n+\n+\tpublic HeaderFilterSpec headersToRemove(String... headersToRemove) {\n+\t\tassertHeaderFilterNotExplicitlySet();\n+\t\tthis.headerFilter.setHeadersToRemove(headersToRemove);\n+\t\treturn this;\n+\t}\n+\n+\tpublic HeaderFilterSpec patternMatch(boolean patternMatch) {\n+\t\tassertHeaderFilterNotExplicitlySet();\n+\t\tthis.headerFilter.setPatternMatch(patternMatch);\n+\t\treturn this;\n+\t}\n+\n+\tprivate void assertHeaderFilterNotExplicitlySet() {\n+\t\tAssert.isTrue(!this.headerFilterExplicitlySet,\n+\t\t\t\t() -> \"Cannot override already set header filter: \" + this.headerFilter);\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/transformer/HeaderFilter.java b/spring-integration-core/src/main/java/org/springframework/integration/transformer/HeaderFilter.java\nindex 4f211e6e01e..91f10b13951 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/transformer/HeaderFilter.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/transformer/HeaderFilter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -40,16 +40,32 @@\n  */\n public class HeaderFilter extends IntegrationObjectSupport implements Transformer, IntegrationPattern {\n \n-\tprivate final String[] headersToRemove;\n+\tprivate String[] headersToRemove;\n \n \tprivate volatile boolean patternMatch = true;\n \n \n+\t/**\n+\t * Create an instance of the class.\n+\t * The {@link #setHeadersToRemove} must be called afterwards.\n+\t * @since 6.2\n+\t */\n+\tpublic HeaderFilter() {\n+\t}\n+\n \tpublic HeaderFilter(String... headersToRemove) {\n-\t\tAssert.notEmpty(headersToRemove, \"At least one header name to remove is required.\");\n-\t\tthis.headersToRemove = Arrays.copyOf(headersToRemove, headersToRemove.length);\n+\t\tsetHeadersToRemove(headersToRemove);\n \t}\n \n+\t/**\n+\t * Set a list of header names (or patterns) to remove from a request message.\n+\t * @param headersToRemove the list of header names (or patterns) to remove from a request message.\n+\t * @since 6.2\n+\t */\n+\tpublic final void setHeadersToRemove(String... headersToRemove) {\n+\t\tassertHeadersToRemoveNotEmpty(headersToRemove);\n+\t\tthis.headersToRemove = Arrays.copyOf(headersToRemove, headersToRemove.length);\n+\t}\n \tpublic void setPatternMatch(boolean patternMatch) {\n \t\tthis.patternMatch = patternMatch;\n \t}\n@@ -66,6 +82,7 @@ public IntegrationPatternType getIntegrationPatternType() {\n \n \t@Override\n \tprotected void onInit() {\n+\t\tassertHeadersToRemoveNotEmpty(this.headersToRemove);\n \t\tsuper.onInit();\n \t\tif (getMessageBuilderFactory() instanceof DefaultMessageBuilderFactory) {\n \t\t\tfor (String header : this.headersToRemove) {\n@@ -94,4 +111,8 @@ public Message<?> transform(Message<?> message) {\n \t\treturn builder.build();\n \t}\n \n+\tprivate static void assertHeadersToRemoveNotEmpty(String[] headersToRemove) {\n+\t\tAssert.notEmpty(headersToRemove, \"At least one header name to remove is required.\");\n+\t}\n+\n }\n\ndiff --git a/spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinIntegrationFlowDefinition.kt b/spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinIntegrationFlowDefinition.kt\nindex 9fba9de61df..5d77d4280b6 100644\n--- a/spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinIntegrationFlowDefinition.kt\n+++ b/spring-integration-core/src/main/kotlin/org/springframework/integration/dsl/KotlinIntegrationFlowDefinition.kt\n@@ -22,13 +22,13 @@ import org.springframework.integration.aggregator.AggregatingMessageHandler\n import org.springframework.integration.channel.BroadcastCapableChannel\n import org.springframework.integration.channel.FluxMessageChannel\n import org.springframework.integration.channel.interceptor.WireTap\n+import org.springframework.integration.core.GenericHandler\n import org.springframework.integration.core.MessageSelector\n import org.springframework.integration.dsl.support.MessageChannelReference\n import org.springframework.integration.filter.MessageFilter\n import org.springframework.integration.filter.MethodInvokingSelector\n import org.springframework.integration.handler.BridgeHandler\n import org.springframework.integration.handler.DelayHandler\n-import org.springframework.integration.core.GenericHandler\n import org.springframework.integration.handler.LoggingHandler\n import org.springframework.integration.handler.MessageProcessor\n import org.springframework.integration.handler.MessageTriggerAction\n@@ -56,6 +56,7 @@ import org.springframework.messaging.MessageChannel\n import org.springframework.messaging.MessageHandler\n import org.springframework.messaging.MessageHeaders\n import org.springframework.messaging.support.ChannelInterceptor\n+import org.springframework.util.StringUtils\n import reactor.core.publisher.Flux\n import java.util.function.Consumer\n \n@@ -711,8 +712,23 @@ class KotlinIntegrationFlowDefinition(@PublishedApi internal val delegate: Integ\n \t/**\n \t * Provide the [HeaderFilter] to the current [IntegrationFlow].\n \t */\n+\t@Deprecated(\"since 6.2\",\n+\t\t\tReplaceWith(\"\"\"headerFilter { \n+\t\t\t\t\t\t\t\t\t\tpatternMatch() \n+\t\t\t\t\t\t\t\t\t\theadersToRemove() \n+\t\t\t\t\t\t\t\t\t}\"\"\"))\n \tfun headerFilter(headersToRemove: String, patternMatch: Boolean = true) {\n-\t\tthis.delegate.headerFilter(headersToRemove, patternMatch)\n+\t\theaderFilter {\n+\t\t\tpatternMatch(patternMatch)\n+\t\t\theadersToRemove(*StringUtils.delimitedListToStringArray(headersToRemove, \",\", \" \"))\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Provide the [HeaderFilter] to the current [IntegrationFlow].\n+\t */\n+\tfun headerFilter(endpointConfigurer: HeaderFilterSpec.() -> Unit) {\n+\t\tthis.delegate.headerFilter(endpointConfigurer)\n \t}\n \n \t/**\n\ndiff --git a/spring-integration-groovy/src/main/groovy/org/springframework/integration/groovy/dsl/GroovyIntegrationFlowDefinition.groovy b/spring-integration-groovy/src/main/groovy/org/springframework/integration/groovy/dsl/GroovyIntegrationFlowDefinition.groovy\nindex b8187380a2b..648b6cabaed 100644\n--- a/spring-integration-groovy/src/main/groovy/org/springframework/integration/groovy/dsl/GroovyIntegrationFlowDefinition.groovy\n+++ b/spring-integration-groovy/src/main/groovy/org/springframework/integration/groovy/dsl/GroovyIntegrationFlowDefinition.groovy\n@@ -35,6 +35,7 @@ import org.springframework.integration.dsl.FilterEndpointSpec\n import org.springframework.integration.dsl.GatewayEndpointSpec\n import org.springframework.integration.dsl.GenericEndpointSpec\n import org.springframework.integration.dsl.HeaderEnricherSpec\n+import org.springframework.integration.dsl.HeaderFilterSpec\n import org.springframework.integration.dsl.IntegrationFlow\n import org.springframework.integration.dsl.IntegrationFlowDefinition\n import org.springframework.integration.dsl.MessageChannelSpec\n@@ -818,8 +819,10 @@ class GroovyIntegrationFlowDefinition {\n \t * {@link HeaderFilter}.\n \t * @param headerFilter the {@link HeaderFilter} to use.\n \t * @param endpointConfigurer the {@link Consumer} to provide integration endpoint options.\n+\t * @deprecated since 6.2 in favor of {@link #headerFilter(groovy.lang.Closure)}\n \t * @see GenericEndpointSpec\n \t */\n+\t@Deprecated(since = \"6.2\", forRemoval = true)\n \tGroovyIntegrationFlowDefinition headerFilter(\n \t\t\tString headersToRemove,\n \t\t\tboolean patternMatch = true,\n@@ -834,6 +837,21 @@ class GroovyIntegrationFlowDefinition {\n \t\tthis\n \t}\n \n+\t/**\n+\t * Populate {@link HeaderFilter} based on the options from a {@link HeaderFilterSpec}.\n+\t * @param endpointConfigurer the {@link Consumer} to provide {@link HeaderFilter} and its endpoint options.\n+\t * @see HeaderFilterSpec\n+\t * @since 6.2\n+\t */\n+\tGroovyIntegrationFlowDefinition headerFilter(\n+\t\t\t@DelegatesTo(value = HeaderFilterSpec, strategy = Closure.DELEGATE_FIRST)\n+\t\t\t@ClosureParams(value = SimpleType.class, options = 'org.springframework.integration.dsl.HeaderFilterSpec')\n+\t\t\t\t\tClosure<?> headerFilterConfigurer) {\n+\n+\t\tthis.delegate.headerFilter createConfigurerIfAny(headerFilterConfigurer)\n+\t\tthis\n+\t}\n+\n \t/**\n \t * Populate the {@link MessageTransformingHandler} for the\n \t * {@link org.springframework.integration.transformer.ClaimCheckInTransformer} with provided {@link MessageStore}.\n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/dsl/correlation/CorrelationHandlerTests.java b/spring-integration-core/src/test/java/org/springframework/integration/dsl/correlation/CorrelationHandlerTests.java\nindex 874144c4d05..be136aaf10b 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/dsl/correlation/CorrelationHandlerTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/dsl/correlation/CorrelationHandlerTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2022 the original author or authors.\n+ * Copyright 2016-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -60,7 +60,6 @@\n /**\n  * @author Artem Bilan\n  * @author Gary Russell\n- *\n  * @since 5.0\n  */\n @RunWith(SpringRunner.class)\n@@ -241,7 +240,7 @@ public IntegrationFlow splitResequenceFlow(MessageChannel executorChannel, TaskE\n \t\t\t\t\t.enrichHeaders(h ->\n \t\t\t\t\t\t\th.headerFunction(IntegrationMessageHeaderAccessor.SEQUENCE_NUMBER, Message::getPayload))\n \t\t\t\t\t.resequence(r -> r.releasePartialSequences(true).correlationExpression(\"'foo'\"))\n-\t\t\t\t\t.headerFilter(\"foo\", false);\n+\t\t\t\t\t.headerFilter(headerFilterSpec -> headerFilterSpec.headersToRemove(\"foo\").patternMatch(false));\n \t\t}\n \n \n\ndiff --git a/spring-integration-core/src/test/kotlin/org/springframework/integration/dsl/KotlinDslTests.kt b/spring-integration-core/src/test/kotlin/org/springframework/integration/dsl/KotlinDslTests.kt\nindex bf0f87f5898..0918cb1cb80 100644\n--- a/spring-integration-core/src/test/kotlin/org/springframework/integration/dsl/KotlinDslTests.kt\n+++ b/spring-integration-core/src/test/kotlin/org/springframework/integration/dsl/KotlinDslTests.kt\n@@ -182,11 +182,16 @@ class KotlinDslTests {\n \t@Test\n \tfun `flow from lambda`() {\n \t\tval replyChannel = QueueChannel()\n-\t\tval message = MessageBuilder.withPayload(\"test\").setReplyChannel(replyChannel).build()\n+\t\tval message = MessageBuilder.withPayload(\"test\")\n+\t\t\t\t.setHeader(\"headerToRemove\", \"no value\")\n+\t\t\t\t.setReplyChannel(replyChannel)\n+\t\t\t\t.build()\n \n \t\tthis.flowLambdaInput.send(message)\n \n-\t\tassertThat(replyChannel.receive(10_000)?.payload).isNotNull().isEqualTo(\"TEST\")\n+\t\tval receive = replyChannel.receive(10_000)\n+\t\tassertThat(receive?.payload).isNotNull().isEqualTo(\"TEST\")\n+\t\tassertThat(receive.headers).doesNotContain(\"headerToRemove\", null)\n \t\tassertThat(this.wireTapChannel.receive(10_000)?.payload).isNotNull().isEqualTo(\"test\")\n \t}\n \n@@ -308,6 +313,10 @@ class KotlinDslTests {\n \t\tfun flowLambda() =\n \t\t\tintegrationFlow {\n \t\t\t\tfilter<String>({ it === \"test\" }) { id(\"filterEndpoint\") }\n+\t\t\t\theaderFilter {\n+\t\t\t\t\tpatternMatch(false)\n+\t\t\t\t\theadersToRemove(\"notAHeader\", \"headerToRemove\")\n+\t\t\t\t}\n \t\t\t\twireTap {\n \t\t\t\t\tchannel { queue(\"wireTapChannel\") }\n \t\t\t\t}\n\ndiff --git a/spring-integration-groovy/src/test/groovy/org/springframework/integration/groovy/dsl/test/GroovyDslTests.groovy b/spring-integration-groovy/src/test/groovy/org/springframework/integration/groovy/dsl/test/GroovyDslTests.groovy\nindex 27ed13d271b..799fb08d522 100644\n--- a/spring-integration-groovy/src/test/groovy/org/springframework/integration/groovy/dsl/test/GroovyDslTests.groovy\n+++ b/spring-integration-groovy/src/test/groovy/org/springframework/integration/groovy/dsl/test/GroovyDslTests.groovy\n@@ -189,11 +189,18 @@ class GroovyDslTests {\n \t@Test\n \tvoid 'flow from lambda'() {\n \t\tdef replyChannel = new QueueChannel()\n-\t\tdef message = MessageBuilder.withPayload('test').setReplyChannel(replyChannel).build()\n+\t\tdef message =\n+\t\t\t\tMessageBuilder.withPayload('test')\n+\t\t\t\t\t\t.setHeader('headerToRemove', 'no value')\n+\t\t\t\t\t\t.setReplyChannel(replyChannel)\n+\t\t\t\t\t\t.build()\n \n \t\tthis.flowLambdaInput.send message\n \n-\t\tassert replyChannel.receive(10_000)?.payload == 'TEST'\n+\t\tdef receive = replyChannel.receive(10_000)\n+\n+\t\tassert receive?.payload == 'TEST'\n+\t\tassert !receive?.headers?.containsKey('headerToRemove')\n \t\tassert this.wireTapChannel.receive(10_000)?.payload == 'test'\n \t}\n \n@@ -300,6 +307,10 @@ class GroovyDslTests {\n \t\tflowLambda() {\n \t\t\tintegrationFlow {\n \t\t\t\tfilter String, { it == 'test' }, { id 'filterEndpoint' }\n+\t\t\t\theaderFilter {\n+\t\t\t\t\tpatternMatch false\n+\t\t\t\t\theadersToRemove \"notAHeader\", \"headerToRemove\"\n+\t\t\t\t}\n \t\t\t\twireTap integrationFlow {\n \t\t\t\t\tchannel { queue 'wireTapChannel' }\n \t\t\t\t}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-8627",
    "pr_id": 8627,
    "issue_id": 8625,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Poller fixed-delay and fixed-rate support for Duration syntax\n**Expected Behavior**\r\n\r\nIt would be nice and useful (from a configuration point of view) if `<int:poller>` attributes `fixed-delay` and `fixed-rate` supported the `java.time.Duration` syntax, with support for resolvable configuration values (via a `StringValueResolver`) just like `@Scheduled`/`ScheduledAnnotationBeanPostProcessor` do.\r\n\r\n**Current Behavior**\r\n\r\n`fixed-delay` and `fixed-rate` attributes in `<int:poller>` must be integer values, interpreted as milliseconds or amount of `time-unit` units. Resolvable configuration values are supported, but configuration must then specify these values as milliseconds, or provide two distinct configuration values for delay/rate and time unit.\r\n\r\n**Context**\r\n\r\nUsing Spring Integration with Spring Boot 2.7.10. Duration syntax is nicely supported in a lot of places, but not in `<int:poller>` tag.\r\nThe alternative to have maximum flexibility is to leave `fixed-delay`/`fixed-rate` in milliseconds and externalize them in configuration. But milliseconds are not so readable when resolutions of minutes or hours is needed.\r\n",
    "issue_word_count": 163,
    "test_files_count": 3,
    "non_test_files_count": 10,
    "pr_changed_files": [
      "build.gradle",
      "spring-integration-core/src/main/java/org/springframework/integration/annotation/Poller.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/AbstractMethodAnnotationPostProcessor.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/PeriodicTriggerFactoryBean.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/xml/PollerParser.java",
      "spring-integration-core/src/main/resources/org/springframework/integration/config/spring-integration.xsd",
      "spring-integration-core/src/test/java/org/springframework/integration/config/xml/PollerParserTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/xml/pollerWithReceiveTimeout.xml",
      "spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.properties",
      "src/reference/asciidoc/channel-adapter.adoc",
      "src/reference/asciidoc/endpoint.adoc",
      "src/reference/asciidoc/polling-consumer.adoc",
      "src/reference/asciidoc/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/config/xml/PollerParserTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/config/xml/pollerWithReceiveTimeout.xml",
      "spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.properties"
    ],
    "base_commit": "edbaf6d5904ffeb89bd2dff4b36846feed5153a8",
    "head_commit": "e66c92773195c85b6ee70ca91a7fe51674fc258a",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/8627",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/8627",
    "dockerfile": "",
    "pr_merged_at": "2023-05-22T15:47:08.000Z",
    "patch": "diff --git a/build.gradle b/build.gradle\nindex c9156eadfe1..a82aa151bd0 100644\n--- a/build.gradle\n+++ b/build.gradle\n@@ -212,6 +212,7 @@ configure(javaProjects) { subproject ->\n \n     compileJava {\n         options.release = 17\n+        options.compilerArgs << '-parameters'\n     }\n \n     compileTestJava {\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/annotation/Poller.java b/spring-integration-core/src/main/java/org/springframework/integration/annotation/Poller.java\nindex 792438061a4..83faf806a6a 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/annotation/Poller.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/annotation/Poller.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2019 the original author or authors.\n+ * Copyright 2014-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -65,16 +65,16 @@\n \tString maxMessagesPerPoll() default \"\";\n \n \t/**\n-\t * @return The fixed delay in milliseconds to create the\n-\t * {@link org.springframework.scheduling.support.PeriodicTrigger}. Can be specified as\n-\t * 'property placeholder', e.g. {@code ${poller.fixedDelay}}.\n+\t * @return The fixed delay in milliseconds or a {@link java.time.Duration} compliant string\n+\t * to create the {@link org.springframework.scheduling.support.PeriodicTrigger}.\n+\t * Can be specified as 'property placeholder', e.g. {@code ${poller.fixedDelay}}.\n \t */\n \tString fixedDelay() default \"\";\n \n \t/**\n-\t * @return The fixed rate in milliseconds to create the\n-\t * {@link org.springframework.scheduling.support.PeriodicTrigger} with\n-\t * {@code fixedRate}. Can be specified as 'property placeholder', e.g.\n+\t * @return The fixed rate in milliseconds or a {@link java.time.Duration} compliant string\n+\t * to create the {@link org.springframework.scheduling.support.PeriodicTrigger} with\n+\t * the {@code fixedRate} option. Can be specified as 'property placeholder', e.g.\n \t * {@code ${poller.fixedRate}}.\n \t */\n \tString fixedRate() default \"\";\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractMethodAnnotationPostProcessor.java b/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractMethodAnnotationPostProcessor.java\nindex abd651d10c0..bb075afb285 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractMethodAnnotationPostProcessor.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/AbstractMethodAnnotationPostProcessor.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,7 +18,6 @@\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Method;\n-import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -744,14 +743,11 @@ else if (StringUtils.hasText(cron)) {\n \t\t\t\t\t\"The '@Poller' 'cron' attribute is mutually exclusive with other attributes.\");\n \t\t\ttrigger = new CronTrigger(cron);\n \t\t}\n-\t\telse if (StringUtils.hasText(fixedDelayValue)) {\n-\t\t\tAssert.state(!StringUtils.hasText(fixedRateValue),\n-\t\t\t\t\t\"The '@Poller' 'fixedDelay' attribute is mutually exclusive with other attributes.\");\n-\t\t\ttrigger = new PeriodicTrigger(Duration.ofMillis(Long.parseLong(fixedDelayValue)));\n-\t\t}\n-\t\telse if (StringUtils.hasText(fixedRateValue)) {\n-\t\t\ttrigger = new PeriodicTrigger(Duration.ofMillis(Long.parseLong(fixedRateValue)));\n-\t\t\t((PeriodicTrigger) trigger).setFixedRate(true);\n+\t\telse if (StringUtils.hasText(fixedDelayValue) || StringUtils.hasText(fixedRateValue)) {\n+\t\t\tPeriodicTriggerFactoryBean periodicTriggerFactoryBean = new PeriodicTriggerFactoryBean();\n+\t\t\tperiodicTriggerFactoryBean.setFixedDelayValue(fixedDelayValue);\n+\t\t\tperiodicTriggerFactoryBean.setFixedRateValue(fixedRateValue);\n+\t\t\ttrigger = periodicTriggerFactoryBean.getObject();\n \t\t}\n \t\t//'Trigger' can be null. 'PollingConsumer' does fallback to the 'new PeriodicTrigger(10)'.\n \t\tpollerMetadata.setTrigger(trigger);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/PeriodicTriggerFactoryBean.java b/spring-integration-core/src/main/java/org/springframework/integration/config/PeriodicTriggerFactoryBean.java\nnew file mode 100644\nindex 00000000000..4b4034a9c48\n--- /dev/null\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/PeriodicTriggerFactoryBean.java\n@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.config;\n+\n+import java.time.Duration;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.springframework.beans.factory.FactoryBean;\n+import org.springframework.lang.Nullable;\n+import org.springframework.scheduling.support.PeriodicTrigger;\n+import org.springframework.util.Assert;\n+import org.springframework.util.StringUtils;\n+\n+/**\n+ * The {@link FactoryBean} to produce a {@link PeriodicTrigger}\n+ * based on parsing string values for its options.\n+ * This class is mostly driven by the XML configuration requirements for\n+ * {@link Duration} value representations for the respective attributes.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 6.2\n+ */\n+public class PeriodicTriggerFactoryBean implements FactoryBean<PeriodicTrigger> {\n+\n+\t@Nullable\n+\tprivate String fixedDelayValue;\n+\n+\t@Nullable\n+\tprivate String fixedRateValue;\n+\n+\t@Nullable\n+\tprivate String initialDelayValue;\n+\n+\t@Nullable\n+\tprivate TimeUnit timeUnit;\n+\n+\tpublic void setFixedDelayValue(String fixedDelayValue) {\n+\t\tthis.fixedDelayValue = fixedDelayValue;\n+\t}\n+\n+\tpublic void setFixedRateValue(String fixedRateValue) {\n+\t\tthis.fixedRateValue = fixedRateValue;\n+\t}\n+\n+\tpublic void setInitialDelayValue(String initialDelayValue) {\n+\t\tthis.initialDelayValue = initialDelayValue;\n+\t}\n+\n+\tpublic void setTimeUnit(TimeUnit timeUnit) {\n+\t\tthis.timeUnit = timeUnit;\n+\t}\n+\n+\t@Override\n+\tpublic PeriodicTrigger getObject() {\n+\t\tboolean hasFixedDelay = StringUtils.hasText(this.fixedDelayValue);\n+\t\tboolean hasFixedRate = StringUtils.hasText(this.fixedRateValue);\n+\n+\t\tAssert.isTrue(hasFixedDelay ^ hasFixedRate,\n+\t\t\t\t\"One of the 'fixedDelayValue' or 'fixedRateValue' property must be provided but not both.\");\n+\n+\t\tTimeUnit timeUnitToUse = this.timeUnit;\n+\t\tif (timeUnitToUse == null) {\n+\t\t\ttimeUnitToUse = TimeUnit.MILLISECONDS;\n+\t\t}\n+\n+\t\tDuration duration = toDuration(hasFixedDelay ? this.fixedDelayValue : this.fixedRateValue, timeUnitToUse);\n+\n+\t\tPeriodicTrigger periodicTrigger = new PeriodicTrigger(duration);\n+\t\tperiodicTrigger.setFixedRate(hasFixedRate);\n+\t\tif (StringUtils.hasText(this.initialDelayValue)) {\n+\t\t\tperiodicTrigger.setInitialDelay(toDuration(this.initialDelayValue, timeUnitToUse));\n+\t\t}\n+\t\treturn periodicTrigger;\n+\t}\n+\n+\t@Override\n+\tpublic Class<?> getObjectType() {\n+\t\treturn PeriodicTrigger.class;\n+\t}\n+\n+\tprivate static Duration toDuration(String value, TimeUnit timeUnit) {\n+\t\tif (isDurationString(value)) {\n+\t\t\treturn Duration.parse(value);\n+\t\t}\n+\t\treturn toDuration(Long.parseLong(value), timeUnit);\n+\t}\n+\n+\tprivate static boolean isDurationString(String value) {\n+\t\treturn (value.length() > 1 && (isP(value.charAt(0)) || isP(value.charAt(1))));\n+\t}\n+\n+\tprivate static boolean isP(char ch) {\n+\t\treturn (ch == 'P' || ch == 'p');\n+\t}\n+\n+\tprivate static Duration toDuration(long value, TimeUnit timeUnit) {\n+\t\treturn Duration.of(value, timeUnit.toChronoUnit());\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/xml/PollerParser.java b/spring-integration-core/src/main/java/org/springframework/integration/config/xml/PollerParser.java\nindex 0bbc2113f49..ec60a15c5b8 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/xml/PollerParser.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/xml/PollerParser.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -28,9 +28,9 @@\n import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;\n import org.springframework.beans.factory.xml.ParserContext;\n import org.springframework.integration.channel.MessagePublishingErrorHandler;\n+import org.springframework.integration.config.PeriodicTriggerFactoryBean;\n import org.springframework.integration.scheduling.PollerMetadata;\n import org.springframework.scheduling.support.CronTrigger;\n-import org.springframework.scheduling.support.PeriodicTrigger;\n import org.springframework.util.StringUtils;\n import org.springframework.util.xml.DomUtils;\n \n@@ -45,12 +45,15 @@\n  */\n public class PollerParser extends AbstractBeanDefinitionParser {\n \n-\tprivate static final String MULTIPLE_TRIGGER_DEFINITIONS = \"A <poller> cannot specify more than one trigger configuration.\";\n+\tprivate static final String MULTIPLE_TRIGGER_DEFINITIONS =\n+\t\t\t\"A <poller> cannot specify more than one trigger configuration.\";\n \n \tprivate static final String NO_TRIGGER_DEFINITIONS = \"A <poller> must have one and only one trigger configuration.\";\n \n \t@Override\n-\tprotected String resolveId(Element element, AbstractBeanDefinition definition, ParserContext parserContext) throws BeanDefinitionStoreException {\n+\tprotected String resolveId(Element element, AbstractBeanDefinition definition, ParserContext parserContext)\n+\t\t\tthrows BeanDefinitionStoreException {\n+\n \t\tString id = super.resolveId(element, definition, parserContext);\n \t\tif (element.getAttribute(\"default\").equals(\"true\")) {\n \t\t\tif (parserContext.getRegistry().isBeanNameInUse(PollerMetadata.DEFAULT_POLLER_METADATA_BEAN_NAME)) {\n@@ -102,29 +105,30 @@ else if (adviceChainElement != null) {\n \n \t\tString errorChannel = element.getAttribute(\"error-channel\");\n \t\tif (StringUtils.hasText(errorChannel)) {\n-\t\t\tBeanDefinitionBuilder errorHandler = BeanDefinitionBuilder.genericBeanDefinition(MessagePublishingErrorHandler.class);\n+\t\t\tBeanDefinitionBuilder errorHandler =\n+\t\t\t\t\tBeanDefinitionBuilder.genericBeanDefinition(MessagePublishingErrorHandler.class);\n \t\t\terrorHandler.addPropertyReference(\"defaultErrorChannel\", errorChannel);\n \t\t\tmetadataBuilder.addPropertyValue(\"errorHandler\", errorHandler.getBeanDefinition());\n \t\t}\n \t\treturn metadataBuilder.getBeanDefinition();\n \t}\n \n-\tprivate void configureTrigger(Element pollerElement, BeanDefinitionBuilder targetBuilder, ParserContext parserContext) {\n+\tprivate void configureTrigger(Element pollerElement, BeanDefinitionBuilder targetBuilder,\n+\t\t\tParserContext parserContext) {\n+\n \t\tString triggerAttribute = pollerElement.getAttribute(\"trigger\");\n \t\tString fixedRateAttribute = pollerElement.getAttribute(\"fixed-rate\");\n \t\tString fixedDelayAttribute = pollerElement.getAttribute(\"fixed-delay\");\n \t\tString cronAttribute = pollerElement.getAttribute(\"cron\");\n \t\tString timeUnit = pollerElement.getAttribute(\"time-unit\");\n \n-\t\tList<String> triggerBeanNames = new ArrayList<String>();\n+\t\tList<String> triggerBeanNames = new ArrayList<>();\n \t\tif (StringUtils.hasText(triggerAttribute)) {\n \t\t\ttrigger(pollerElement, parserContext, triggerAttribute, timeUnit, triggerBeanNames);\n \t\t}\n-\t\tif (StringUtils.hasText(fixedRateAttribute)) {\n-\t\t\tfixedRate(parserContext, fixedRateAttribute, timeUnit, triggerBeanNames);\n-\t\t}\n-\t\tif (StringUtils.hasText(fixedDelayAttribute)) {\n-\t\t\tfixedDelay(parserContext, fixedDelayAttribute, timeUnit, triggerBeanNames);\n+\t\tif (StringUtils.hasText(fixedRateAttribute) || StringUtils.hasText(fixedDelayAttribute)) {\n+\t\t\tperiod(parserContext, fixedDelayAttribute, fixedRateAttribute, pollerElement.getAttribute(\"initial-delay\"),\n+\t\t\t\t\ttimeUnit, triggerBeanNames);\n \t\t}\n \t\tif (StringUtils.hasText(cronAttribute)) {\n \t\t\tcron(pollerElement, parserContext, cronAttribute, timeUnit, triggerBeanNames);\n@@ -142,33 +146,20 @@ private void trigger(Element pollerElement, ParserContext parserContext, String\n \t\t\tList<String> triggerBeanNames) {\n \n \t\tif (StringUtils.hasText(timeUnit)) {\n-\t\t\tparserContext.getReaderContext().error(\"The 'time-unit' attribute cannot be used with a 'trigger' reference.\", pollerElement);\n+\t\t\tparserContext.getReaderContext()\n+\t\t\t\t\t.error(\"The 'time-unit' attribute cannot be used with a 'trigger' reference.\", pollerElement);\n \t\t}\n \t\ttriggerBeanNames.add(triggerAttribute);\n \t}\n \n-\tprivate void fixedRate(ParserContext parserContext, String fixedRateAttribute, String timeUnit,\n-\t\t\tList<String> triggerBeanNames) {\n-\t\tBeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(PeriodicTrigger.class);\n-\t\tbuilder.addConstructorArgValue(fixedRateAttribute);\n-\t\tif (StringUtils.hasText(timeUnit)) {\n-\t\t\tbuilder.addConstructorArgValue(timeUnit);\n-\t\t}\n-\t\tbuilder.addPropertyValue(\"fixedRate\", Boolean.TRUE);\n-\t\tString triggerBeanName = BeanDefinitionReaderUtils.registerWithGeneratedName(\n-\t\t\t\tbuilder.getBeanDefinition(), parserContext.getRegistry());\n-\t\ttriggerBeanNames.add(triggerBeanName);\n-\t}\n-\n-\tprivate void fixedDelay(ParserContext parserContext, String fixedDelayAttribute, String timeUnit,\n-\t\t\tList<String> triggerBeanNames) {\n+\tprivate void period(ParserContext parserContext, String fixedDelayAttribute, String fixedRateAttribute,\n+\t\t\tString initialDelayAttribute, String timeUnit, List<String> triggerBeanNames) {\n \n-\t\tBeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(PeriodicTrigger.class);\n-\t\tbuilder.addConstructorArgValue(fixedDelayAttribute);\n-\t\tif (StringUtils.hasText(timeUnit)) {\n-\t\t\tbuilder.addConstructorArgValue(timeUnit);\n-\t\t}\n-\t\tbuilder.addPropertyValue(\"fixedRate\", Boolean.FALSE);\n+\t\tBeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(PeriodicTriggerFactoryBean.class);\n+\t\tbuilder.addPropertyValue(\"fixedDelayValue\", fixedDelayAttribute);\n+\t\tbuilder.addPropertyValue(\"fixedRateValue\", fixedRateAttribute);\n+\t\tbuilder.addPropertyValue(\"timeUnit\", timeUnit);\n+\t\tbuilder.addPropertyValue(\"initialDelayValue\", initialDelayAttribute);\n \t\tString triggerBeanName = BeanDefinitionReaderUtils.registerWithGeneratedName(\n \t\t\t\tbuilder.getBeanDefinition(), parserContext.getRegistry());\n \t\ttriggerBeanNames.add(triggerBeanName);\n@@ -187,4 +178,5 @@ private void cron(Element pollerElement, ParserContext parserContext, String cro\n \t\t\t\tbuilder.getBeanDefinition(), parserContext.getRegistry());\n \t\ttriggerBeanNames.add(triggerBeanName);\n \t}\n+\n }\n\ndiff --git a/spring-integration-core/src/main/resources/org/springframework/integration/config/spring-integration.xsd b/spring-integration-core/src/main/resources/org/springframework/integration/config/spring-integration.xsd\nindex 66d33f72ff0..15a9ada77c4 100644\n--- a/spring-integration-core/src/main/resources/org/springframework/integration/config/spring-integration.xsd\n+++ b/spring-integration-core/src/main/resources/org/springframework/integration/config/spring-integration.xsd\n@@ -1983,7 +1983,7 @@\n \t\t</xsd:sequence>\n \t\t<xsd:attribute name=\"fixed-delay\" type=\"xsd:string\">\n \t\t\t<xsd:annotation>\n-\t\t\t\t<xsd:documentation>Fixed delay trigger (in milliseconds).</xsd:documentation>\n+\t\t\t\t<xsd:documentation>Fixed delay trigger (decimal for time unit or Duration string).</xsd:documentation>\n \t\t\t</xsd:annotation>\n \t\t</xsd:attribute>\n \t\t<xsd:attribute name=\"ref\" type=\"xsd:string\" use=\"optional\">\n@@ -1997,7 +1997,14 @@\n \t\t</xsd:attribute>\n \t\t<xsd:attribute name=\"fixed-rate\" type=\"xsd:string\">\n \t\t\t<xsd:annotation>\n-\t\t\t\t<xsd:documentation>Fixed rate trigger (in milliseconds).</xsd:documentation>\n+\t\t\t\t<xsd:documentation>Fixed rate trigger (decimal for time unit or Duration string).</xsd:documentation>\n+\t\t\t</xsd:annotation>\n+\t\t</xsd:attribute>\n+\t\t<xsd:attribute name=\"initial-delay\" type=\"xsd:string\">\n+\t\t\t<xsd:annotation>\n+\t\t\t\t<xsd:documentation>\n+\t\t\t\t\tPeriodic trigger initial delay (decimal for time unit or Duration string).\n+\t\t\t\t</xsd:documentation>\n \t\t\t</xsd:annotation>\n \t\t</xsd:attribute>\n \t\t<xsd:attribute name=\"time-unit\">\n\ndiff --git a/src/reference/asciidoc/channel-adapter.adoc b/src/reference/asciidoc/channel-adapter.adoc\nindex bc9e68e1a40..bb9a2d9befd 100644\n--- a/src/reference/asciidoc/channel-adapter.adoc\n+++ b/src/reference/asciidoc/channel-adapter.adoc\n@@ -114,7 +114,7 @@ However, in the `SourcePollingChannelAdapter`, it is a bit different.\n The default value for `max-messages-per-poll` is `1`, unless you explicitly set it to a negative value (such as `-1`).\n This makes sure that the poller can react to lifecycle events (such as start and stop) and prevents it from potentially spinning in an infinite loop if the implementation of the custom method of the `MessageSource` has a potential to never return null and happens to be non-interruptible.\n \n-However, if you are sure that your method can return null and you need to poll for as many sources as available per each poll, you should explicitly set `max-messages-per-poll` to a negative value, as the following example shows:\n+However, if you are sure that your method can return null, and you need to poll for as many sources as available per each poll, you should explicitly set `max-messages-per-poll` to a negative value, as the following example shows:\n \n ====\n [source,xml]\n@@ -125,6 +125,9 @@ However, if you are sure that your method can return null and you need to poll f\n \n Starting with version 5.5, a `0` value for `max-messages-per-poll` has a special meaning - skip the `MessageSource.receive()` call altogether, which may be considered as pausing for this inbound channel adapter until the `maxMessagesPerPoll` is changed to a non-zero value at a later time, e.g. via a Control Bus.\n \n+Starting with version 6.2, the `fixed-delay` and `fixed-rate` can be configured in https://en.wikipedia.org/wiki/ISO_8601#Durations[ISO 8601 Duration] format, e.g. `PT10S`, `P1D` etc.\n+In addition, an `initial-interval` of the underlying `PeriodicTrigger` is also exposed with similar value formats as `fixed-delay` and `fixed-rate`.\n+\n Also see <<./endpoint.adoc#global-default-poller,Global Default Poller>> for more information.\n =====\n \n\ndiff --git a/src/reference/asciidoc/endpoint.adoc b/src/reference/asciidoc/endpoint.adoc\nindex 1120cb481b4..6d43a5a19c1 100644\n--- a/src/reference/asciidoc/endpoint.adoc\n+++ b/src/reference/asciidoc/endpoint.adoc\n@@ -148,7 +148,7 @@ Starting with version 5.5, a `0` value has a special meaning - skip the `Message\n \n The `receiveTimeout` property specifies the amount of time the poller should wait if no messages are available when it invokes the receive operation.\n For example, consider two options that seem similar on the surface but are actually quite different: The first has an interval trigger of 5 seconds and a receive timeout of 50 milliseconds, while the second has an interval trigger of 50 milliseconds and a receive timeout of 5 seconds.\n-The first one may receive a message up to 4950 milliseconds later than it arrived on the channel (if that message arrived immediately after one of its poll calls returned).\n+The first one may receive a message up to 4950 milliseconds later than it accepted on the channel (if that message arrived immediately after one of its poll calls returned).\n On the other hand, the second configuration never misses a message by more than 50 milliseconds.\n The difference is that the second option requires a thread to wait.\n However, as a result, it can respond much more quickly to arriving messages.\n@@ -167,9 +167,11 @@ consumer.setTaskExecutor(taskExecutor);\n ====\n \n Furthermore, a `PollingConsumer` has a property called `adviceChain`.\n-This property lets you to specify a `List` of AOP advices for handling additional cross-cutting concerns including transactions.\n+This property lets you specify a `List` of AOP advices for handling additional cross-cutting concerns including transactions.\n These advices are applied around the `doPoll()` method.\n For more in-depth information, see the sections on AOP advice chains and transaction support under <<endpoint-namespace>>.\n+See also a `@Poller` annotation Javadocs and respective <<./configuration.adoc#annotations, Messaging Annotations Support>> section.\n+The Java DSL also provides a <<./dsl.adoc#java-dsl-pollers, `.poller()`>> endpoint configuration option with its respective `Pollers` factory.\n \n The earlier examples show dependency lookups.\n However, keep in mind that these consumers are most often configured as Spring bean definitions.\n@@ -181,7 +183,7 @@ NOTE: Many of the `MessageHandler` implementations can generate reply messages.\n As mentioned earlier, sending messages is trivial when compared to receiving messages.\n Nevertheless, when and how many reply messages are sent depends on the handler type.\n For example, an aggregator waits for a number of messages to arrive and is often configured as a downstream consumer for a splitter, which can generate multiple replies for each message it handles.\n-When using the namespace configuration, you do not strictly need to know all of the details.\n+When using the namespace configuration, you do not strictly need to know all the details.\n However, it still might be worth knowing that several of these components share a common base class, the `AbstractReplyProducingMessageHandler`, and that it provides a `setOutputChannel(..)` method.\n \n [[endpoint-namespace]]\n@@ -192,7 +194,7 @@ Most of these support an `input-channel` attribute and many support an `output-c\n After being parsed, these endpoint elements produce an instance of either the `PollingConsumer` or the `EventDrivenConsumer`, depending on the type of the `input-channel` that is referenced: `PollableChannel` or `SubscribableChannel`, respectively.\n When the channel is pollable, the polling behavior is based on the endpoint element's `poller` sub-element and its attributes.\n \n-The following listing lists all of the available configuration options for a `poller`:\n+The following lists all available configuration options for a `poller`:\n \n [source,xml]\n ----\n@@ -201,15 +203,16 @@ The following listing lists all of the available configuration options for a `po\n             error-channel=\"\"                         <3>\n             fixed-delay=\"\"                           <4>\n             fixed-rate=\"\"                            <5>\n-            id=\"\"                                    <6>\n-            max-messages-per-poll=\"\"                 <7>\n-            receive-timeout=\"\"                       <8>\n-            ref=\"\"                                   <9>\n-            task-executor=\"\"                         <10>\n-            time-unit=\"MILLISECONDS\"                 <11>\n-            trigger=\"\">                              <12>\n-            <int:advice-chain />                     <13>\n-            <int:transactional />                    <14>\n+            initial-delay=\"\"                         <6>\n+            id=\"\"                                    <7>\n+            max-messages-per-poll=\"\"                 <8>\n+            receive-timeout=\"\"                       <9>\n+            ref=\"\"                                   <10>\n+            task-executor=\"\"                         <11>\n+            time-unit=\"MILLISECONDS\"                 <12>\n+            trigger=\"\">                              <13>\n+            <int:advice-chain />                     <14>\n+            <int:transactional />                    <15>\n </int:poller>\n ----\n \n@@ -225,28 +228,30 @@ Optional.\n To completely suppress exceptions, you can provide a reference to the `nullChannel`.\n Optional.\n <4> The fixed delay trigger uses a `PeriodicTrigger` under the covers.\n-If you do not use the `time-unit` attribute, the specified value is represented in milliseconds.\n+The numeric value is in `time-unit` or can be as a duration format (starting with version 6.2), e.g. `PT10S`, `P1D`.\n If this attribute is set, none of the following attributes must be specified: `fixed-rate`, `trigger`, `cron`, and `ref`.\n <5> The fixed rate trigger uses a `PeriodicTrigger` under the covers.\n-If you do not use the `time-unit` attribute, the specified value is represented in milliseconds.\n+The numeric value is in `time-unit` or can be as a duration format (starting with version 6.2), e.g. `PT10S`, `P1D`.\n If this attribute is set, none of the following attributes must be specified: `fixed-delay`, `trigger`, `cron`, and `ref`.\n-<6> The ID referring to the poller's underlying bean-definition, which is of type `org.springframework.integration.scheduling.PollerMetadata`.\n+<6> The initial delay for a `PeriodicTrigger` under the covers(starting with version 6.2).\n+The numeric value is in `time-unit` or can be as a duration format, e.g. `PT10S`, `P1D`.\n+<7> The ID referring to the poller's underlying bean-definition, which is of type `org.springframework.integration.scheduling.PollerMetadata`.\n The `id` attribute is required for a top-level poller element, unless it is the default poller (`default=\"true\"`).\n-<7> See <<./channel-adapter.adoc#channel-adapter-namespace-inbound,Configuring An Inbound Channel Adapter>> for more information.\n+<8> See <<./channel-adapter.adoc#channel-adapter-namespace-inbound,Configuring An Inbound Channel Adapter>> for more information.\n If not specified, the default value depends on the context.\n If you use a `PollingConsumer`, this attribute defaults to `-1`.\n However, if you use a `SourcePollingChannelAdapter`, the `max-messages-per-poll` attribute defaults to `1`.\n Optional.\n-<8> Value is set on the underlying class `PollerMetadata`.\n+<9> Value is set on the underlying class `PollerMetadata`.\n If not specified, it defaults to 1000 (milliseconds).\n Optional.\n-<9> Bean reference to another top-level poller.\n+<10> Bean reference to another top-level poller.\n The `ref` attribute must not be present on the top-level `poller` element.\n However, if this attribute is set, none of the following attributes must be specified: `fixed-rate`, `trigger`, `cron`, and `fixed-delay`.\n-<10> Provides the ability to reference a custom task executor.\n+<11> Provides the ability to reference a custom task executor.\n See <<taskexecutor-support>> for further information.\n Optional.\n-<11> This attribute specifies the `java.util.concurrent.TimeUnit` enum value on the underlying `org.springframework.scheduling.support.PeriodicTrigger`.\n+<12> This attribute specifies the `java.util.concurrent.TimeUnit` enum value on the underlying `org.springframework.scheduling.support.PeriodicTrigger`.\n Therefore, this attribute can be used only in combination with the `fixed-delay` or `fixed-rate` attributes.\n If combined with either `cron` or a `trigger` reference attribute, it causes a failure.\n The minimal supported granularity for a `PeriodicTrigger` is milliseconds.\n@@ -254,13 +259,13 @@ Therefore, the only available options are milliseconds and seconds.\n If this value is not provided, any `fixed-delay` or `fixed-rate` value is interpreted as milliseconds.\n Basically, this enum provides a convenience for seconds-based interval trigger values.\n For hourly, daily, and monthly settings, we recommend using a `cron` trigger instead.\n-<12> Reference to any Spring-configured bean that implements the `org.springframework.scheduling.Trigger` interface.\n+<13> Reference to any Spring-configured bean that implements the `org.springframework.scheduling.Trigger` interface.\n However, if this attribute is set, none of the following attributes must be specified: `fixed-delay`, `fixed-rate`, `cron`, and `ref`.\n Optional.\n-<13> Allows specifying extra AOP advices to handle additional cross-cutting concerns.\n+<14> Allows specifying extra AOP advices to handle additional cross-cutting concerns.\n See <<transaction-support>> for further information.\n Optional.\n-<14> Pollers can be made transactional.\n+<15> Pollers can be made transactional.\n See <<aop-advice-chains>> for further information.\n Optional.\n \n\ndiff --git a/src/reference/asciidoc/polling-consumer.adoc b/src/reference/asciidoc/polling-consumer.adoc\nindex a6e0d347f85..f8313b8710d 100644\n--- a/src/reference/asciidoc/polling-consumer.adoc\n+++ b/src/reference/asciidoc/polling-consumer.adoc\n@@ -20,6 +20,8 @@ They represent a critical cross-cutting concern in many messaging scenarios.\n In Spring Integration, polling consumers are based on the pattern with the same name, which is described in the book _Enterprise Integration Patterns_, by Gregor Hohpe and Bobby Woolf.\n You can find a description of the pattern on the https://www.enterpriseintegrationpatterns.com/PollingConsumer.html[book's website].\n \n+For more information polling consumer configuration, see <<./endpoint.adoc#endpoint,Message Endpoints>>.\n+\n [[pollable-message-source]]\n ==== Pollable Message Source\n \n\ndiff --git a/src/reference/asciidoc/whats-new.adoc b/src/reference/asciidoc/whats-new.adoc\nindex 3d152486e5a..69c9a353e1a 100644\n--- a/src/reference/asciidoc/whats-new.adoc\n+++ b/src/reference/asciidoc/whats-new.adoc\n@@ -19,3 +19,6 @@ In general the project has been moved to the latest dependency versions.\n \n [[x6.2-general]]\n === General Changes\n+\n+- The XML configuration for `<poller>` and `@Poller` annotation now support ISO 8601 duration format for `fixed-delay`, `fixed-rate` and `initial-delay` options.\n+See <<./endpoint.adoc#endpoint-pollingconsumer, Polling Consumer>> for more information.\n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/config/xml/PollerParserTests.java b/spring-integration-core/src/test/java/org/springframework/integration/config/xml/PollerParserTests.java\nindex 681aeb90278..4aa4b5477e1 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/config/xml/PollerParserTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/config/xml/PollerParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2023 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,7 +16,7 @@\n \n package org.springframework.integration.config.xml;\n \n-import java.time.temporal.ChronoUnit;\n+import java.time.Duration;\n import java.util.HashMap;\n \n import org.aopalliance.aop.Advice;\n@@ -112,7 +112,9 @@ public void pollerWithReceiveTimeoutAndTimeunit() {\n \t\tPollerMetadata metadata = (PollerMetadata) poller;\n \t\tassertThat(metadata.getReceiveTimeout()).isEqualTo(1234);\n \t\tPeriodicTrigger trigger = (PeriodicTrigger) metadata.getTrigger();\n-\t\tassertThat(TestUtils.getPropertyValue(trigger, \"chronoUnit\")).isEqualTo(ChronoUnit.SECONDS);\n+\t\tassertThat(trigger.getPeriodDuration()).isEqualTo(Duration.ofSeconds(5));\n+\t\tassertThat(trigger.isFixedRate()).isTrue();\n+\t\tassertThat(trigger.getInitialDelayDuration()).isEqualTo(Duration.ofSeconds(45));\n \t\tcontext.close();\n \t}\n \n@@ -123,7 +125,7 @@ public void pollerWithTriggerReference() {\n \t\tObject poller = context.getBean(\"poller\");\n \t\tassertThat(poller).isNotNull();\n \t\tPollerMetadata metadata = (PollerMetadata) poller;\n-\t\tassertThat(metadata.getTrigger() instanceof TestTrigger).isTrue();\n+\t\tassertThat(metadata.getTrigger()).isInstanceOf(TestTrigger.class);\n \t\tcontext.close();\n \t}\n \n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/config/xml/pollerWithReceiveTimeout.xml b/spring-integration-core/src/test/java/org/springframework/integration/config/xml/pollerWithReceiveTimeout.xml\nindex 8c8e9ea8d13..38ad3d6c445 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/config/xml/pollerWithReceiveTimeout.xml\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/config/xml/pollerWithReceiveTimeout.xml\n@@ -15,6 +15,6 @@\n \t\t<beans:prop key=\"seconds\">SECONDS</beans:prop>\n \t</util:properties>\n \n-\t<poller id=\"poller\" receive-timeout=\"1234\" fixed-rate=\"5\" time-unit=\"${seconds}\"/>\n+\t<poller id=\"poller\" receive-timeout=\"1234\" fixed-rate=\"5\" time-unit=\"${seconds}\" initial-delay=\"PT45S\"/>\n \t\t\n </beans:beans>\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.properties b/spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.properties\nindex 725e320a1cb..364e0b2eda7 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.properties\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/configuration/EnableIntegrationTests.properties\n@@ -1,5 +1,5 @@\n message.history.tracked.components=input, publishedChannel, annotationTestService*\n poller.maxMessagesPerPoll=10\n-poller.interval=100\n+poller.interval=PT0.1S\n poller.receiveTimeout=10000\n global.wireTap.pattern=input\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-10138",
    "pr_id": 10138,
    "issue_id": 10083,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Apply Nullability to the project\nMore info in the Spring Framework `7.0` docs: https://docs.spring.io/spring-framework/reference/7.0/core/null-safety.html.\n\nWe can treat this issue an Epic and have sub-issues for specific tasks or dedicated module fixes.\n\nThis can be done in phase:\n\n1. Migrate from deprecated `org.springframework.lang.Nullable` on properties methods to the `org.jspecify.annotations.Nullable`.\n2. Migrate `@org.springframework.lang.NonNullApi` and `@org.springframework.lang.NonNullFields` pair to the `@org.jspecify.annotations.NullMarked`. However this would trigger the third phase.\n3. Fix nullabilty errors in those `@org.jspecify.annotations.NullMarked` packages.\n4. Add more and more `@org.jspecify.annotations.NullMarked`  and fix respective nullability vulnerabilities in those package and modules.\n\nAny other thoughts and possible ways to fix this huge task are welcome!\n\nlist (checked means someone has taken it )\n- [x] spring-integration-amqp\n- [x] spring-integration-camel\n- [x] spring-integration-cassandra\n- [x] spring-integration-core\n- [ ] spring-integration-debezium\n- [x] spring-integration-event\n- [ ] spring-integration-feed\n- [ ] spring-integration-file\n- [ ] spring-integration-ftp\n- [ ] spring-integration-graphql\n- [ ] spring-integration-groovy\n- [ ] spring-integration-hazelcast\n- [ ] spring-integration-http\n- [ ] spring-integration-ip\n- [ ] spring-integration-jdbc\n- [ ] spring-integration-jms\n- [x] spring-integration-jmx\n- [x] spring-integration-jpa\n- [x] spring-integration-kafka\n- [x] spring-integration-mail\n- [ ] spring-integration-mongodb\n- [ ] spring-integration-r2dbc\n- [ ] spring-integration-mqtt\n- [ ] spring-integration-redis\n- [ ] spring-integration-rsocket\n- [ ] spring-integration-scripting\n- [ ] spring-integration-sftp\n- [ ] spring-integration-smb\n- [ ] spring-integration-stomp\n- [ ] spring-integration-stream\n- [ ] spring-integration-syslog\n- [ ] spring-integration-test\n- [ ] spring-integration-test-support\n- [ ] spring-integration-webflux\n- [ ] spring-integration-websocket\n- [x] spring-integration-ws\n- [x] spring-integration-xml\n- [x] spring-integration-xmpp\n- [x] spring-integration-zeromq\n- [x] spring-integration-zip\n- [x] spring-integration-zookeeper",
    "issue_word_count": 282,
    "test_files_count": 7,
    "non_test_files_count": 20,
    "pr_changed_files": [
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/AbstractKafkaChannel.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/PollableKafkaChannel.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/SubscribableKafkaChannel.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/package-info.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/config/xml/KafkaChannelParser.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/config/xml/package-info.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/AbstractKafkaChannelSpec.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/KafkaMessageListenerContainerSpec.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/KafkaTemplateSpec.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/package-info.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundEndpoint.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundGateway.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageDrivenChannelAdapter.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/package-info.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/package-info.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/package-info.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/support/RawRecordHeaderErrorMessageStrategy.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/support/package-info.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/channnel/ChannelTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/dsl/KafkaDslTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/InboundGatewayTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageDrivenAdapterTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceIntegrationTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandlerTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/channnel/ChannelTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/dsl/KafkaDslTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/InboundGatewayTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageDrivenAdapterTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceIntegrationTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceTests.java",
      "spring-integration-kafka/src/test/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandlerTests.java"
    ],
    "base_commit": "a41c86802a8a50613c74d6b25d59e2995d00bf2b",
    "head_commit": "e1c254966a74a97cf8985ceda2d11d7e309edc3f",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/10138",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/10138",
    "dockerfile": "",
    "pr_merged_at": "2025-06-20T14:18:04.000Z",
    "patch": "diff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/AbstractKafkaChannel.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/AbstractKafkaChannel.java\nindex d9b872f87db..c4e9bc3c5d3 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/AbstractKafkaChannel.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/AbstractKafkaChannel.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2022 the original author or authors.\n+ * Copyright 2020-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,6 +20,8 @@\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n \n+import org.jspecify.annotations.Nullable;\n+\n import org.springframework.integration.channel.AbstractMessageChannel;\n import org.springframework.kafka.core.KafkaOperations;\n import org.springframework.kafka.support.KafkaHeaders;\n@@ -42,7 +44,7 @@ public abstract class AbstractKafkaChannel extends AbstractMessageChannel {\n \n \tprotected final String topic; // NOSONAR final\n \n-\tprivate String groupId;\n+\tprivate @Nullable String groupId;\n \n \t/**\n \t * Construct an instance with the provided {@link KafkaOperations} and topic.\n@@ -64,7 +66,7 @@ public void setGroupId(String groupId) {\n \t\tthis.groupId = groupId;\n \t}\n \n-\tprotected String getGroupId() {\n+\tprotected @Nullable String getGroupId() {\n \t\treturn this.groupId;\n \t}\n \n@@ -82,7 +84,8 @@ protected boolean doSend(Message<?> message, long timeout) {\n \t\t\treturn false;\n \t\t}\n \t\tcatch (ExecutionException e) {\n-\t\t\tthis.logger.error(e.getCause(), () -> \"Interrupted while waiting for send result for: \" + message);\n+\t\t\tThrowable cause = e.getCause() != null ? e.getCause() : e;\n+\t\t\tthis.logger.error(cause, () -> \"Interrupted while waiting for send result for: \" + message);\n \t\t\treturn false;\n \t\t}\n \t\tcatch (TimeoutException e) {\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/PollableKafkaChannel.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/PollableKafkaChannel.java\nindex 2c8cc23f6fb..a5e46bbe0de 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/PollableKafkaChannel.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/PollableKafkaChannel.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2024 the original author or authors.\n+ * Copyright 2020-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,12 +20,13 @@\n import java.util.Deque;\n import java.util.List;\n \n+import org.jspecify.annotations.Nullable;\n+\n import org.springframework.integration.channel.ExecutorChannelInterceptorAware;\n import org.springframework.integration.kafka.inbound.KafkaMessageSource;\n import org.springframework.integration.support.management.metrics.CounterFacade;\n import org.springframework.integration.support.management.metrics.MetricsCaptor;\n import org.springframework.kafka.core.KafkaOperations;\n-import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.PollableChannel;\n import org.springframework.messaging.support.ChannelInterceptor;\n@@ -47,7 +48,7 @@ public class PollableKafkaChannel extends AbstractKafkaChannel\n \n \tprivate final KafkaMessageSource<?, ?> source;\n \n-\tprivate CounterFacade receiveCounter;\n+\tprivate @Nullable CounterFacade receiveCounter;\n \n \tprivate volatile int executorInterceptorsSize;\n \n@@ -197,8 +198,8 @@ public boolean hasExecutorInterceptors() {\n \n \tprivate static String topic(KafkaMessageSource<?, ?> source) {\n \t\tAssert.notNull(source, \"'source' cannot be null\");\n-\t\tString[] topics = source.getConsumerProperties().getTopics();\n-\t\tAssert.isTrue(topics != null && topics.length == 1, \"Only one topic is allowed\");\n+\t\t@Nullable String @Nullable [] topics = source.getConsumerProperties().getTopics();\n+\t\tAssert.isTrue(topics != null && topics.length == 1 && topics[0] != null, \"Only one topic is allowed\");\n \t\treturn topics[0];\n \t}\n \n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/SubscribableKafkaChannel.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/SubscribableKafkaChannel.java\nindex d83ea42b7d5..f966b3e3f49 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/SubscribableKafkaChannel.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/SubscribableKafkaChannel.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2024 the original author or authors.\n+ * Copyright 2020-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,6 +18,7 @@\n \n import org.apache.kafka.clients.consumer.Consumer;\n import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.jspecify.annotations.Nullable;\n \n import org.springframework.integration.dispatcher.MessageDispatcher;\n import org.springframework.integration.dispatcher.RoundRobinLoadBalancingStrategy;\n@@ -56,8 +57,10 @@ public class SubscribableKafkaChannel extends AbstractKafkaChannel implements Su\n \n \tprivate final IntegrationRecordMessageListener recordListener = new IntegrationRecordMessageListener();\n \n+\t@SuppressWarnings(\"NullAway.Init\")\n \tprivate MessageDispatcher dispatcher;\n \n+\t@SuppressWarnings(\"NullAway.Init\")\n \tprivate MessageListenerContainer container;\n \n \tprivate boolean autoStartup = true;\n@@ -183,8 +186,8 @@ private class IntegrationRecordMessageListener extends RecordMessagingMessageLis\n \t\t}\n \n \t\t@Override\n-\t\tpublic void onMessage(ConsumerRecord<Object, Object> record, Acknowledgment acknowledgment,\n-\t\t\t\tConsumer<?, ?> consumer) {\n+\t\tpublic void onMessage(ConsumerRecord<Object, Object> record, @Nullable Acknowledgment acknowledgment,\n+\t\t\t\t@Nullable Consumer<?, ?> consumer) {\n \n \t\t\tSubscribableKafkaChannel.this.dispatcher.dispatch(toMessagingMessage(record, acknowledgment, consumer));\n \t\t}\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/package-info.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/package-info.java\nindex 3816bbfa8f2..47754acfc8b 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/package-info.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/channel/package-info.java\n@@ -1,4 +1,5 @@\n /**\n  * Provides classes related to message channel implementations for Apache Kafka.\n  */\n+@org.jspecify.annotations.NullMarked\n package org.springframework.integration.kafka.channel;\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/config/xml/KafkaChannelParser.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/config/xml/KafkaChannelParser.java\nindex ba241223388..7681dd5d2bd 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/config/xml/KafkaChannelParser.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/config/xml/KafkaChannelParser.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020 the original author or authors.\n+ * Copyright 2020-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,7 @@\n \n package org.springframework.integration.kafka.config.xml;\n \n+import org.jspecify.annotations.Nullable;\n import org.w3c.dom.Element;\n \n import org.springframework.beans.factory.support.BeanDefinitionBuilder;\n@@ -38,7 +39,7 @@\n public class KafkaChannelParser extends AbstractChannelParser {\n \n \t@Override\n-\tprotected BeanDefinitionBuilder buildBeanDefinition(Element element, ParserContext parserContext) {\n+\tprotected @Nullable BeanDefinitionBuilder buildBeanDefinition(Element element, ParserContext parserContext) {\n \t\tBeanDefinitionBuilder builder;\n \t\tString factory = element.getAttribute(\"container-factory\");\n \t\tboolean hasFactory = StringUtils.hasText(factory);\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/config/xml/package-info.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/config/xml/package-info.java\nindex d102e5e5ab0..110c9f3eb40 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/config/xml/package-info.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/config/xml/package-info.java\n@@ -1,4 +1,5 @@\n /**\n  * Provides parser classes to provide Xml namespace support for the Apache Kafka components.\n  */\n+@org.jspecify.annotations.NullMarked\n package org.springframework.integration.kafka.config.xml;\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/AbstractKafkaChannelSpec.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/AbstractKafkaChannelSpec.java\nindex c22f000bb3b..f420986054c 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/AbstractKafkaChannelSpec.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/AbstractKafkaChannelSpec.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2023 the original author or authors.\n+ * Copyright 2020-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,9 +16,10 @@\n \n package org.springframework.integration.kafka.dsl;\n \n+import org.jspecify.annotations.Nullable;\n+\n import org.springframework.integration.dsl.MessageChannelSpec;\n import org.springframework.integration.kafka.channel.AbstractKafkaChannel;\n-import org.springframework.lang.Nullable;\n \n /**\n  *\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/KafkaMessageListenerContainerSpec.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/KafkaMessageListenerContainerSpec.java\nindex 072a78b5fb4..edb185d897c 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/KafkaMessageListenerContainerSpec.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/KafkaMessageListenerContainerSpec.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018-2023 the original author or authors.\n+ * Copyright 2018-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,6 +20,7 @@\n \n import org.apache.kafka.clients.consumer.ConsumerRebalanceListener;\n import org.apache.kafka.clients.consumer.OffsetCommitCallback;\n+import org.jspecify.annotations.Nullable;\n \n import org.springframework.core.task.AsyncTaskExecutor;\n import org.springframework.integration.dsl.IntegrationComponentSpec;\n@@ -28,7 +29,6 @@\n import org.springframework.kafka.listener.ConcurrentMessageListenerContainer;\n import org.springframework.kafka.listener.ContainerProperties;\n import org.springframework.kafka.support.TopicPartitionOffset;\n-import org.springframework.lang.Nullable;\n \n /**\n  * A helper class in the Builder pattern style to delegate options to the\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/KafkaTemplateSpec.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/KafkaTemplateSpec.java\nindex 2ec42fbc900..e655b05f6be 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/KafkaTemplateSpec.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/KafkaTemplateSpec.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018-2023 the original author or authors.\n+ * Copyright 2018-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,12 +16,13 @@\n \n package org.springframework.integration.kafka.dsl;\n \n+import org.jspecify.annotations.Nullable;\n+\n import org.springframework.integration.dsl.IntegrationComponentSpec;\n import org.springframework.kafka.core.KafkaTemplate;\n import org.springframework.kafka.core.ProducerFactory;\n import org.springframework.kafka.support.ProducerListener;\n import org.springframework.kafka.support.converter.RecordMessageConverter;\n-import org.springframework.lang.Nullable;\n \n /**\n  * An {@link IntegrationComponentSpec} implementation for the {@link KafkaTemplate}.\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/package-info.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/package-info.java\nindex 53f5ad837bc..5a2f136f533 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/package-info.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/dsl/package-info.java\n@@ -1,6 +1,5 @@\n /**\n  * Provides Spring Integration Java DSL Components support for Apache Kafka.\n  */\n-@org.springframework.lang.NonNullApi\n-@org.springframework.lang.NonNullFields\n+@org.jspecify.annotations.NullMarked\n package org.springframework.integration.kafka.dsl;\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundEndpoint.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundEndpoint.java\nindex 3f2090322e8..23319beb60d 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundEndpoint.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundEndpoint.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2022-2023 the original author or authors.\n+ * Copyright 2022-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,6 +18,7 @@\n \n import org.apache.kafka.clients.consumer.Consumer;\n import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.jspecify.annotations.Nullable;\n \n import org.springframework.core.AttributeAccessor;\n import org.springframework.kafka.KafkaException;\n@@ -63,8 +64,8 @@ public interface KafkaInboundEndpoint {\n \t * @param consumer the consumer.\n \t * @param runnable the runnable.\n \t */\n-\tdefault void doWithRetry(RetryTemplate template, RecoveryCallback<?> callback, ConsumerRecord<?, ?> record,\n-\t\t\tAcknowledgment acknowledgment, Consumer<?, ?> consumer, Runnable runnable) {\n+\tdefault void doWithRetry(RetryTemplate template, @Nullable RecoveryCallback<?> callback, ConsumerRecord<?, ?> record,\n+\t\t\t@Nullable Acknowledgment acknowledgment, @Nullable Consumer<?, ?> consumer, Runnable runnable) {\n \n \t\ttry {\n \t\t\ttemplate.execute(context -> {\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundGateway.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundGateway.java\nindex 67a5a833927..ede846a15b3 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundGateway.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundGateway.java\n@@ -25,6 +25,7 @@\n import org.apache.kafka.clients.consumer.ConsumerRecord;\n import org.apache.kafka.common.TopicPartition;\n import org.apache.kafka.common.header.Header;\n+import org.jspecify.annotations.Nullable;\n \n import org.springframework.core.AttributeAccessor;\n import org.springframework.integration.IntegrationMessageHeaderAccessor;\n@@ -50,7 +51,6 @@\n import org.springframework.kafka.support.converter.KafkaMessageHeaders;\n import org.springframework.kafka.support.converter.MessagingMessageConverter;\n import org.springframework.kafka.support.converter.RecordMessageConverter;\n-import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.messaging.MessageHeaders;\n@@ -82,11 +82,11 @@ public class KafkaInboundGateway<K, V, R> extends MessagingGatewaySupport\n \n \tprivate final KafkaTemplate<K, R> kafkaTemplate;\n \n-\tprivate RetryTemplate retryTemplate;\n+\tprivate @Nullable RetryTemplate retryTemplate;\n \n-\tprivate RecoveryCallback<?> recoveryCallback;\n+\tprivate @Nullable RecoveryCallback<?> recoveryCallback;\n \n-\tprivate BiConsumer<Map<TopicPartition, Long>, ConsumerSeekAware.ConsumerSeekCallback> onPartitionsAssignedSeekCallback;\n+\tprivate @Nullable BiConsumer<Map<TopicPartition, Long>, ConsumerSeekAware.ConsumerSeekCallback> onPartitionsAssignedSeekCallback;\n \n \tprivate boolean bindSourceRecord;\n \n@@ -271,7 +271,7 @@ private void setAttributesIfNecessary(Object record, @Nullable Message<?> messag\n \t}\n \n \t@Override\n-\tprotected AttributeAccessor getErrorMessageAttributes(Message<?> message) {\n+\tprotected AttributeAccessor getErrorMessageAttributes(@Nullable Message<?> message) {\n \t\tAttributeAccessor attributes = ATTRIBUTES_HOLDER.get();\n \t\tif (attributes == null) {\n \t\t\treturn super.getErrorMessageAttributes(message);\n@@ -295,7 +295,8 @@ public void onPartitionsAssigned(Map<TopicPartition, Long> assignments, Consumer\n \t\t}\n \n \t\t@Override\n-\t\tpublic void onMessage(ConsumerRecord<K, V> record, Acknowledgment acknowledgment, Consumer<?, ?> consumer) {\n+\t\tpublic void onMessage(ConsumerRecord<K, V> record, @Nullable Acknowledgment acknowledgment,\n+\t\t\t\t@Nullable Consumer<?, ?> consumer) {\n \t\t\tMessage<?> message = null;\n \t\t\ttry {\n \t\t\t\tmessage = toMessagingMessage(record, acknowledgment, consumer);\n@@ -321,8 +322,8 @@ public void onMessage(ConsumerRecord<K, V> record, Acknowledgment acknowledgment\n \t\t\t}\n \t\t}\n \n-\t\tprivate void sendAndReceive(ConsumerRecord<K, V> record, Message<?> message, Acknowledgment acknowledgment,\n-\t\t\t\tConsumer<?, ?> consumer) {\n+\t\tprivate void sendAndReceive(ConsumerRecord<K, V> record, Message<?> message,\n+\t\t\t\t@Nullable Acknowledgment acknowledgment, @Nullable Consumer<?, ?> consumer) {\n \n \t\t\tRetryTemplate template = KafkaInboundGateway.this.retryTemplate;\n \t\t\tif (template != null) {\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageDrivenChannelAdapter.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageDrivenChannelAdapter.java\nindex 20006e21f27..bf941440c8f 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageDrivenChannelAdapter.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageDrivenChannelAdapter.java\n@@ -28,6 +28,7 @@\n import org.apache.kafka.clients.consumer.ConsumerRecord;\n import org.apache.kafka.common.TopicPartition;\n import org.apache.kafka.common.header.Header;\n+import org.jspecify.annotations.Nullable;\n \n import org.springframework.core.AttributeAccessor;\n import org.springframework.integration.IntegrationMessageHeaderAccessor;\n@@ -59,7 +60,6 @@\n import org.springframework.kafka.support.converter.MessageConverter;\n import org.springframework.kafka.support.converter.MessagingMessageConverter;\n import org.springframework.kafka.support.converter.RecordMessageConverter;\n-import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.retry.RecoveryCallback;\n@@ -91,17 +91,17 @@ public class KafkaMessageDrivenChannelAdapter<K, V> extends MessageProducerSuppo\n \n \tprivate final ListenerMode mode;\n \n-\tprivate RecordFilterStrategy<K, V> recordFilterStrategy;\n+\tprivate @Nullable RecordFilterStrategy<K, V> recordFilterStrategy;\n \n \tprivate boolean ackDiscarded;\n \n-\tprivate RetryTemplate retryTemplate;\n+\tprivate @Nullable RetryTemplate retryTemplate;\n \n-\tprivate RecoveryCallback<?> recoveryCallback;\n+\tprivate @Nullable RecoveryCallback<?> recoveryCallback;\n \n \tprivate boolean filterInRetry;\n \n-\tprivate BiConsumer<Map<TopicPartition, Long>, ConsumerSeekAware.ConsumerSeekCallback> onPartitionsAssignedSeekCallback;\n+\tprivate @Nullable BiConsumer<Map<TopicPartition, Long>, ConsumerSeekAware.ConsumerSeekCallback> onPartitionsAssignedSeekCallback;\n \n \tprivate boolean bindSourceRecord;\n \n@@ -378,7 +378,7 @@ private void setAttributesIfNecessary(Object record, @Nullable Message<?> messag\n \t}\n \n \t@Override\n-\tprotected AttributeAccessor getErrorMessageAttributes(Message<?> message) {\n+\tprotected AttributeAccessor getErrorMessageAttributes(@Nullable Message<?> message) {\n \t\tAttributeAccessor attributes = ATTRIBUTES_HOLDER.get();\n \t\tif (attributes == null) {\n \t\t\treturn super.getErrorMessageAttributes(message);\n@@ -436,7 +436,8 @@ public void onPartitionsAssigned(Map<TopicPartition, Long> assignments, Consumer\n \t\t}\n \n \t\t@Override\n-\t\tpublic void onMessage(ConsumerRecord<K, V> record, Acknowledgment acknowledgment, Consumer<?, ?> consumer) {\n+\t\tpublic void onMessage(ConsumerRecord<K, V> record, @Nullable Acknowledgment acknowledgment,\n+\t\t\t\t@Nullable Consumer<?, ?> consumer) {\n \t\t\tMessage<?> message;\n \t\t\ttry {\n \t\t\t\tmessage = toMessagingMessage(record, acknowledgment, consumer);\n@@ -524,8 +525,8 @@ public void onPartitionsAssigned(Map<TopicPartition, Long> assignments, Consumer\n \t\t}\n \n \t\t@Override\n-\t\tpublic void onMessage(List<ConsumerRecord<K, V>> records, Acknowledgment acknowledgment,\n-\t\t\t\tConsumer<?, ?> consumer) {\n+\t\tpublic void onMessage(List<ConsumerRecord<K, V>> records, @Nullable Acknowledgment acknowledgment,\n+\t\t\t\t@Nullable Consumer<?, ?> consumer) {\n \n \t\t\tMessage<?> message = null;\n \t\t\tif (!KafkaMessageDrivenChannelAdapter.this.filterInRetry) {\n@@ -537,8 +538,8 @@ public void onMessage(List<ConsumerRecord<K, V>> records, Acknowledgment acknowl\n \t\t}\n \n \t\t@Nullable\n-\t\tprivate Message<?> toMessage(List<ConsumerRecord<K, V>> records, Acknowledgment acknowledgment,\n-\t\t\t\tConsumer<?, ?> consumer) {\n+\t\tprivate Message<?> toMessage(List<ConsumerRecord<K, V>> records, @Nullable Acknowledgment acknowledgment,\n+\t\t\t\t@Nullable Consumer<?, ?> consumer) {\n \n \t\t\tMessage<?> message = null;\n \t\t\ttry {\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java\nindex 607994cbc9e..5da24375084 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageSource.java\n@@ -26,6 +26,7 @@\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Properties;\n import java.util.Set;\n import java.util.TreeSet;\n@@ -47,6 +48,7 @@\n import org.apache.kafka.clients.consumer.OffsetCommitCallback;\n import org.apache.kafka.common.TopicPartition;\n import org.apache.kafka.common.errors.WakeupException;\n+import org.jspecify.annotations.Nullable;\n \n import org.springframework.beans.factory.BeanClassLoaderAware;\n import org.springframework.core.log.LogAccessor;\n@@ -75,7 +77,6 @@\n import org.springframework.kafka.support.converter.RecordMessageConverter;\n import org.springframework.kafka.support.serializer.DeserializationException;\n import org.springframework.kafka.support.serializer.SerializationUtils;\n-import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.util.Assert;\n import org.springframework.util.ObjectUtils;\n@@ -138,7 +139,7 @@ public class KafkaMessageSource<K, V> extends AbstractMessageSource<Object>\n \n \tprivate final Collection<TopicPartition> assignedPartitions = new LinkedHashSet<>();\n \n-\tprivate final Duration commitTimeout;\n+\tprivate final @Nullable Duration commitTimeout;\n \n \tprivate final Duration assignTimeout;\n \n@@ -154,7 +155,7 @@ public class KafkaMessageSource<K, V> extends AbstractMessageSource<Object>\n \n \tprivate RecordMessageConverter messageConverter = new MessagingMessageConverter();\n \n-\tprivate Class<?> payloadType;\n+\tprivate @Nullable Class<?> payloadType;\n \n \tprivate boolean rawMessageHeader;\n \n@@ -164,13 +165,13 @@ public class KafkaMessageSource<K, V> extends AbstractMessageSource<Object>\n \n \tprivate boolean checkNullValueForExceptions;\n \n-\tprivate volatile Consumer<K, V> consumer;\n+\tprivate volatile @Nullable Consumer<K, V> consumer;\n \n-\tprivate volatile Iterator<ConsumerRecord<K, V>> recordsIterator;\n+\tprivate volatile @Nullable Iterator<ConsumerRecord<K, V>> recordsIterator;\n \n \tpublic volatile boolean newAssignment; // NOSONAR - direct access from inner\n \n-\tprivate ClassLoader classLoader;\n+\tprivate @Nullable ClassLoader classLoader;\n \n \t/**\n \t * Construct an instance with the supplied parameters. Fetching multiple\n@@ -307,7 +308,7 @@ public ConsumerProperties getConsumerProperties() {\n \t\treturn this.consumerProperties;\n \t}\n \n-\tprotected String getGroupId() {\n+\tprotected @Nullable String getGroupId() {\n \t\treturn this.consumerProperties.getGroupId();\n \t}\n \n@@ -332,7 +333,7 @@ public void setMessageConverter(RecordMessageConverter messageConverter) {\n \t\tthis.messageConverter = messageConverter;\n \t}\n \n-\tprotected Class<?> getPayloadType() {\n+\tprotected @Nullable Class<?> getPayloadType() {\n \t\treturn this.payloadType;\n \t}\n \n@@ -345,7 +346,7 @@ public void setPayloadType(Class<?> payloadType) {\n \t\tthis.payloadType = payloadType;\n \t}\n \n-\tprotected ConsumerRebalanceListener getRebalanceListener() {\n+\tprotected @Nullable ConsumerRebalanceListener getRebalanceListener() {\n \t\treturn this.consumerProperties.getConsumerRebalanceListener();\n \t}\n \n@@ -369,7 +370,7 @@ public void setRawMessageHeader(boolean rawMessageHeader) {\n \t\tthis.rawMessageHeader = rawMessageHeader;\n \t}\n \n-\tprotected Duration getCommitTimeout() {\n+\tprotected @Nullable Duration getCommitTimeout() {\n \t\treturn this.commitTimeout;\n \t}\n \n@@ -450,7 +451,7 @@ public boolean isPaused() {\n \t}\n \n \t@Override // NOSONAR - not so complex\n-\tprotected Object doReceive() {\n+\tprotected @Nullable Object doReceive() {\n \t\tthis.receiveLock.lock();\n \t\ttry {\n \n@@ -461,6 +462,7 @@ protected Object doReceive() {\n \t\t\tif (this.consumer == null) {\n \t\t\t\tcreateConsumer();\n \t\t\t}\n+\t\t\tAssert.state(this.consumer != null, \"'consumer' must not be null\");\n \t\t\tif (this.pausing.get() && !this.paused.get() && !this.assignedPartitions.isEmpty()) {\n \t\t\t\tthis.consumer.pause(this.assignedPartitions);\n \t\t\t\tthis.paused.set(true);\n@@ -492,7 +494,7 @@ protected void createConsumer() {\n \t\t\t\t\tnew IntegrationConsumerRebalanceListener(this.consumerProperties.getConsumerRebalanceListener());\n \n \t\t\tPattern topicPattern = this.consumerProperties.getTopicPattern();\n-\t\t\tTopicPartitionOffset[] partitions = this.consumerProperties.getTopicPartitions();\n+\t\t\t@Nullable TopicPartitionOffset @Nullable [] partitions = this.consumerProperties.getTopicPartitions();\n \t\t\tif (topicPattern != null) {\n \t\t\t\tthis.consumer.subscribe(topicPattern, rebalanceCallback);\n \t\t\t}\n@@ -509,15 +511,18 @@ else if (partitions != null) {\n \t\t}\n \t}\n \n-\tprivate void assignAndSeekPartitions(TopicPartitionOffset[] partitions) {\n+\tprivate void assignAndSeekPartitions(@Nullable TopicPartitionOffset[] partitions) {\n \t\tList<TopicPartition> topicPartitionsToAssign =\n \t\t\t\tArrays.stream(partitions)\n+\t\t\t\t\t\t.filter(Objects::nonNull)\n \t\t\t\t\t\t.map(TopicPartitionOffset::getTopicPartition)\n \t\t\t\t\t\t.collect(Collectors.toList());\n+\t\tAssert.state(this.consumer != null, \"'consumer' must not be null\");\n \t\tthis.consumer.assign(topicPartitionsToAssign);\n \t\tthis.assignedPartitions.addAll(topicPartitionsToAssign);\n \n \t\tfor (TopicPartitionOffset partition : partitions) {\n+\t\t\tAssert.state(partition != null, \"'partition' must not be null\");\n \t\t\tif (TopicPartitionOffset.SeekPosition.BEGINNING.equals(partition.getPosition())) {\n \t\t\t\tthis.consumer.seekToBeginning(Collections.singleton(partition.getTopicPartition()));\n \t\t\t}\n@@ -548,8 +553,9 @@ else if (partition.isRelativeToCurrent()) {\n \t\t\t\t\t\tthis.consumer.seek(topicPartition, newOffset);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\tvar consumer = this.consumer;\n \t\t\t\t\t\tthis.logger.error(ex, () -> \"Failed to set initial offset for \" + topicPartition\n-\t\t\t\t\t\t\t\t+ \" at \" + newOffset + \". Position is \" + this.consumer\n+\t\t\t\t\t\t\t\t+ \" at \" + newOffset + \". Position is \" + consumer\n \t\t\t\t\t\t\t\t.position(topicPartition));\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -566,6 +572,7 @@ private ConsumerRecord<K, V> pollRecord() {\n \t\t\tthis.consumerLock.lock();\n \t\t\ttry {\n \t\t\t\ttry {\n+\t\t\t\t\tAssert.state(this.consumer != null, \"'consumer' must not be null\");\n \t\t\t\t\tConsumerRecords<K, V> records = this.consumer\n \t\t\t\t\t\t\t.poll(this.assignedPartitions.isEmpty() ? this.assignTimeout : this.pollTimeout);\n \t\t\t\t\tthis.logger.debug(() -> records == null\n@@ -595,6 +602,7 @@ private ConsumerRecord<K, V> pollRecord() {\n \n \tprivate ConsumerRecord<K, V> nextRecord() {\n \t\tConsumerRecord<K, V> record;\n+\t\tAssert.state(this.recordsIterator != null, \"'recordsIterator' must not be null\");\n \t\trecord = this.recordsIterator.next();\n \t\tif (!this.recordsIterator.hasNext()) {\n \t\t\tthis.recordsIterator = null;\n@@ -689,11 +697,11 @@ private static <K, V> ConsumerFactory<K, V> fixConsumerFactory(ConsumerFactory<K\n \n \tprivate class IntegrationConsumerRebalanceListener implements ConsumerRebalanceListener {\n \n-\t\tprivate final ConsumerRebalanceListener providedRebalanceListener;\n+\t\tprivate final @Nullable ConsumerRebalanceListener providedRebalanceListener;\n \n \t\tprivate final boolean isConsumerAware;\n \n-\t\tIntegrationConsumerRebalanceListener(ConsumerRebalanceListener providedRebalanceListener) {\n+\t\tIntegrationConsumerRebalanceListener(@Nullable ConsumerRebalanceListener providedRebalanceListener) {\n \t\t\tthis.providedRebalanceListener = providedRebalanceListener;\n \t\t\tthis.isConsumerAware = providedRebalanceListener instanceof ConsumerAwareRebalanceListener;\n \t\t}\n@@ -704,6 +712,7 @@ public void onPartitionsRevoked(Collection<TopicPartition> partitions) {\n \t\t\tKafkaMessageSource.this.logger.info(() -> \"Partitions revoked: \" + partitions);\n \t\t\tif (this.providedRebalanceListener != null) {\n \t\t\t\tif (this.isConsumerAware) {\n+\t\t\t\t\tAssert.state(KafkaMessageSource.this.consumer != null, \"'consumer' must not be null\");\n \t\t\t\t\t((ConsumerAwareRebalanceListener) this.providedRebalanceListener)\n \t\t\t\t\t\t\t.onPartitionsRevokedAfterCommit(KafkaMessageSource.this.consumer, partitions);\n \t\t\t\t}\n@@ -725,6 +734,7 @@ public void onPartitionsLost(Collection<TopicPartition> partitions) {\n \t\t@Override\n \t\tpublic void onPartitionsAssigned(Collection<TopicPartition> partitions) {\n \t\t\tKafkaMessageSource.this.assignedPartitions.addAll(partitions);\n+\t\t\tAssert.state(KafkaMessageSource.this.consumer != null, \"'consumer' must not be null\");\n \t\t\tif (KafkaMessageSource.this.paused.get()) {\n \t\t\t\tKafkaMessageSource.this.consumer.pause(KafkaMessageSource.this.assignedPartitions);\n \t\t\t\tKafkaMessageSource.this.logger.warn(\"Paused consumer resumed by Kafka due to rebalance; \"\n@@ -777,7 +787,7 @@ public static class KafkaAckCallback<K, V> implements AcknowledgmentCallback, Ac\n \n \t\tprivate final KafkaAckInfo<K, V> ackInfo;\n \n-\t\tprivate final Duration commitTimeout;\n+\t\tprivate final @Nullable Duration commitTimeout;\n \n \t\tprivate final OffsetCommitCallback commitCallback;\n \n@@ -830,15 +840,19 @@ public void acknowledge(Status status) {\n \t\t\t\tfinally {\n \t\t\t\t\tthis.acknowledged = true;\n \t\t\t\t\tif (!this.ackInfo.isAckDeferred()) {\n-\t\t\t\t\t\tthis.ackInfo.getOffsets().get(this.ackInfo.getTopicPartition()).remove(this.ackInfo);\n+\t\t\t\t\t\tvar inflight = this.ackInfo.getOffsets().get(this.ackInfo.getTopicPartition());\n+\t\t\t\t\t\tAssert.state(inflight != null, \"'inflight' must not be null\");\n+\t\t\t\t\t\tinflight.remove(this.ackInfo);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tprivate void rollback(ConsumerRecord<K, V> record) {\n+\t\t\tAssert.state(this.ackInfo.getConsumer() != null, \"'consumer' must not be null\");\n \t\t\tthis.ackInfo.getConsumer().seek(this.ackInfo.getTopicPartition(), record.offset());\n \t\t\tSet<KafkaAckInfo<K, V>> inflight = this.ackInfo.getOffsets().get(this.ackInfo.getTopicPartition());\n+\t\t\tAssert.state(inflight != null, \"'infligt' must not be null\");\n \t\t\tsynchronized (inflight) {\n \t\t\t\tif (inflight.size() > 1) {\n \t\t\t\t\tList<Long> rewound =\n@@ -866,6 +880,7 @@ private void commitIfPossible(ConsumerRecord<K, V> record) { // NOSONAR\n \t\t\t}\n \t\t\telse {\n \t\t\t\tSet<KafkaAckInfo<K, V>> candidates = this.ackInfo.getOffsets().get(this.ackInfo.getTopicPartition());\n+\t\t\t\tAssert.state(candidates != null, \"'candidates' must not be null\");\n \t\t\t\tKafkaAckInfo<K, V> ackInformation = null;\n \t\t\t\tsynchronized (candidates) {\n \t\t\t\t\tif (candidates.iterator().next().equals(this.ackInfo)) {\n@@ -902,6 +917,7 @@ private void commitIfPossible(ConsumerRecord<K, V> record) { // NOSONAR\n \t\t\t\t\t\tMap<TopicPartition, OffsetAndMetadata> offset =\n \t\t\t\t\t\t\t\tCollections.singletonMap(ackInformation.getTopicPartition(),\n \t\t\t\t\t\t\t\t\t\tnew OffsetAndMetadata(ackInformation.getRecord().offset() + 1));\n+\t\t\t\t\t\tAssert.state(ackInformation.getConsumer() != null, \"'consumer' must not be null\");\n \t\t\t\t\t\tif (this.isSyncCommits) {\n \t\t\t\t\t\t\tif (this.commitTimeout == null) {\n \t\t\t\t\t\t\t\tackInformation.getConsumer().commitSync(offset);\n@@ -967,12 +983,12 @@ public Object getConsumerMonitor() {\n \t\t}\n \n \t\t@Override\n-\t\tpublic String getGroupId() {\n+\t\tpublic @Nullable String getGroupId() {\n \t\t\treturn KafkaMessageSource.this.getGroupId();\n \t\t}\n \n \t\t@Override\n-\t\tpublic Consumer<K, V> getConsumer() {\n+\t\tpublic @Nullable Consumer<K, V> getConsumer() {\n \t\t\treturn KafkaMessageSource.this.consumer;\n \t\t}\n \n@@ -1035,9 +1051,9 @@ public interface KafkaAckInfo<K, V> extends Comparable<KafkaAckInfo<K, V>> {\n \n \t\tObject getConsumerMonitor();\n \n-\t\tString getGroupId();\n+\t\t@Nullable String getGroupId();\n \n-\t\tConsumer<K, V> getConsumer();\n+\t\t@Nullable Consumer<K, V> getConsumer();\n \n \t\tConsumerRecord<K, V> getRecord();\n \n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/package-info.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/package-info.java\nindex e75fc2ac772..a5ed7e6b7f2 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/package-info.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/package-info.java\n@@ -1,4 +1,5 @@\n /**\n  * Provides Spring Integration inbound components for Apache Kafka.\n  */\n+@org.jspecify.annotations.NullMarked\n package org.springframework.integration.kafka.inbound;\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java\nindex 3498526d7c1..6089953b1f4 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java\n@@ -33,6 +33,7 @@\n import org.apache.kafka.clients.producer.ProducerRecord;\n import org.apache.kafka.common.header.Headers;\n import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.jspecify.annotations.Nullable;\n \n import org.springframework.expression.EvaluationContext;\n import org.springframework.expression.Expression;\n@@ -59,7 +60,6 @@\n import org.springframework.kafka.support.converter.KafkaMessageHeaders;\n import org.springframework.kafka.support.converter.MessagingMessageConverter;\n import org.springframework.kafka.support.converter.RecordMessageConverter;\n-import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.messaging.MessageHandlingException;\n@@ -118,38 +118,40 @@ public class KafkaProducerMessageHandler<K, V> extends AbstractReplyProducingMes\n \n \tprivate final long deliveryTimeoutMsProperty;\n \n+\t@SuppressWarnings(\"NullAway.Init\")\n \tprivate EvaluationContext evaluationContext;\n \n-\tprivate Expression topicExpression;\n+\tprivate @Nullable Expression topicExpression;\n \n-\tprivate Expression messageKeyExpression;\n+\tprivate @Nullable Expression messageKeyExpression;\n \n-\tprivate Expression partitionIdExpression;\n+\tprivate @Nullable Expression partitionIdExpression;\n \n-\tprivate Expression timestampExpression;\n+\tprivate @Nullable Expression timestampExpression;\n \n \tprivate Expression flushExpression = new FunctionExpression<Message<?>>(message ->\n \t\t\tBoolean.TRUE.equals(message.getHeaders().get(KafkaIntegrationHeaders.FLUSH)));\n \n \tprivate boolean sync;\n \n+\t@SuppressWarnings(\"NullAway.Init\")\n \tprivate Expression sendTimeoutExpression;\n \n-\tprivate KafkaHeaderMapper headerMapper;\n+\tprivate @Nullable KafkaHeaderMapper headerMapper;\n \n \tprivate RecordMessageConverter replyMessageConverter = new MessagingMessageConverter();\n \n-\tprivate MessageChannel sendFailureChannel;\n+\tprivate @Nullable MessageChannel sendFailureChannel;\n \n-\tprivate String sendFailureChannelName;\n+\tprivate @Nullable String sendFailureChannelName;\n \n-\tprivate MessageChannel sendSuccessChannel;\n+\tprivate @Nullable MessageChannel sendSuccessChannel;\n \n-\tprivate String sendSuccessChannelName;\n+\tprivate @Nullable String sendSuccessChannelName;\n \n-\tprivate MessageChannel futuresChannel;\n+\tprivate @Nullable MessageChannel futuresChannel;\n \n-\tprivate String futuresChannelName;\n+\tprivate @Nullable String futuresChannelName;\n \n \tprivate ErrorMessageStrategy errorMessageStrategy = new DefaultErrorMessageStrategy();\n \n@@ -165,8 +167,6 @@ public class KafkaProducerMessageHandler<K, V> extends AbstractReplyProducingMes\n \n \tprivate Duration assignmentDuration = DEFAULT_ASSIGNMENT_TIMEOUT;\n \n-\tprivate volatile byte[] singleReplyTopic;\n-\n \t@SuppressWarnings(\"this-escape\")\n \tpublic KafkaProducerMessageHandler(final KafkaTemplate<K, V> kafkaTemplate) {\n \t\tAssert.notNull(kafkaTemplate, \"kafkaTemplate cannot be null\");\n@@ -190,9 +190,9 @@ public KafkaProducerMessageHandler(final KafkaTemplate<K, V> kafkaTemplate) {\n \t\t\t\t\t+ \"configured to read uncommitted records\");\n \t\t}\n \t\tdetermineSendTimeout();\n-\t\tthis.deliveryTimeoutMsProperty =\n-\t\t\t\tthis.sendTimeoutExpression.getValue(Long.class) // NOSONAR - never null after determineSendTimeout()\n-\t\t\t\t\t\t- this.timeoutBuffer;\n+\t\tLong sendTimeout = this.sendTimeoutExpression.getValue(Long.class); // never null after determineSendTimeout()\n+\t\tAssert.state(sendTimeout != null, \"'sendTimeout' must not be null\");\n+\t\tthis.deliveryTimeoutMsProperty = sendTimeout - this.timeoutBuffer;\n \t}\n \n \tprivate void determineSendTimeout() {\n@@ -254,7 +254,7 @@ public void setHeaderMapper(KafkaHeaderMapper headerMapper) {\n \t\tthis.headerMapper = headerMapper;\n \t}\n \n-\tpublic KafkaHeaderMapper getHeaderMapper() {\n+\tpublic @Nullable KafkaHeaderMapper getHeaderMapper() {\n \t\treturn this.headerMapper;\n \t}\n \n@@ -446,7 +446,7 @@ else if (this.sendFailureChannelName != null) {\n \t\treturn null;\n \t}\n \n-\tprotected MessageChannel getSendSuccessChannel() {\n+\tprotected @Nullable MessageChannel getSendSuccessChannel() {\n \t\tif (this.sendSuccessChannel != null) {\n \t\t\treturn this.sendSuccessChannel;\n \t\t}\n@@ -457,7 +457,7 @@ else if (this.sendSuccessChannelName != null) {\n \t\treturn null;\n \t}\n \n-\tprotected MessageChannel getFuturesChannel() {\n+\tprotected @Nullable MessageChannel getFuturesChannel() {\n \t\tif (this.futuresChannel != null) {\n \t\t\treturn this.futuresChannel;\n \t\t}\n@@ -492,7 +492,7 @@ public boolean isRunning() {\n \n \t@SuppressWarnings(\"unchecked\") // NOSONAR - complexity\n \t@Override\n-\tprotected Object handleRequestMessage(final Message<?> message) {\n+\tprotected @Nullable Object handleRequestMessage(final Message<?> message) {\n \t\tfinal ProducerRecord<K, V> producerRecord;\n \t\tboolean flush =\n \t\t\t\tBoolean.TRUE.equals(this.flushExpression.getValue(this.evaluationContext, message, Boolean.class));\n@@ -544,7 +544,8 @@ protected Object handleRequestMessage(final Message<?> message) {\n \t\t\tthrow new MessageHandlingException(message, e);\n \t\t}\n \t\tcatch (ExecutionException e) {\n-\t\t\tthrow new MessageHandlingException(message, e.getCause()); // NOSONAR\n+\t\t\tThrowable cause = e.getCause() != null ? e.getCause() : e;\n+\t\t\tthrow new MessageHandlingException(message, cause);\n \t\t}\n \t\treturn processReplyFuture(gatewayFuture);\n \t}\n@@ -600,7 +601,6 @@ private void waitForAssignment() {\n \t\t}\n \t}\n \n-\t@Nullable\n \tprivate void addReplyTopicIfAny(MessageHeaders messageHeaders, Headers headers) {\n \t\tif (this.isGateway) {\n \t\t\tObject replyHeader = messageHeaders.get(KafkaHeaders.REPLY_TOPIC);\n@@ -616,9 +616,10 @@ else if (replyHeader != null) {\n \t\t}\n \t}\n \n-\tprivate void sendFutureIfRequested(CompletableFuture<SendResult<K, V>> sendFuture, Object futureToken) {\n+\tprivate void sendFutureIfRequested(@Nullable CompletableFuture<SendResult<K, V>> sendFuture,\n+\t\t\t@Nullable Object futureToken) {\n \n-\t\tif (futureToken != null) {\n+\t\tif (sendFuture != null && futureToken != null) {\n \t\t\tMessageChannel futures = getFuturesChannel();\n \t\t\tif (futures != null) {\n \t\t\t\ttry {\n@@ -635,9 +636,13 @@ private void sendFutureIfRequested(CompletableFuture<SendResult<K, V>> sendFutur\n \t}\n \n \tpublic void processSendResult(final Message<?> message, final ProducerRecord<K, V> producerRecord,\n-\t\t\tCompletableFuture<SendResult<K, V>> future, MessageChannel metadataChannel)\n+\t\t\t@Nullable CompletableFuture<SendResult<K, V>> future, @Nullable MessageChannel metadataChannel)\n \t\t\tthrows InterruptedException, ExecutionException {\n \n+\t\tif (future == null) {\n+\t\t\tthis.logger.warn(\"send future is null, skip processing send result.\");\n+\t\t\treturn;\n+\t\t}\n \t\tfinal MessageChannel failureChannel = getSendFailureChannel();\n \t\tif (failureChannel != null || metadataChannel != null) {\n \t\t\tfuture.whenComplete((sendResult, exception) -> {\n@@ -689,7 +694,7 @@ private void sendFailure(final Message<?> message, final ProducerRecord<K, V> pr\n \t\t}\n \t}\n \n-\tprivate Future<?> processReplyFuture(@Nullable RequestReplyFuture<?, ?, Object> future) {\n+\tprivate @Nullable Future<?> processReplyFuture(@Nullable RequestReplyFuture<?, ?, Object> future) {\n \t\tif (future == null) {\n \t\t\treturn null;\n \t\t}\n@@ -763,8 +768,8 @@ public interface ProducerRecordCreator<K, V> {\n \t\t * @param headers the headers.\n \t\t * @return the record.\n \t\t */\n-\t\tProducerRecord<K, V> create(Message<?> message, String topic, Integer partition, Long timestamp, K key, V value,\n-\t\t\t\tHeaders headers);\n+\t\tProducerRecord<K, V> create(Message<?> message, @Nullable String topic, @Nullable Integer partition,\n+\t\t\t\t@Nullable Long timestamp, @Nullable K key, @Nullable V value, Headers headers);\n \n \t}\n \n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/package-info.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/package-info.java\nindex 8f27e06393d..021e99c5893 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/package-info.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/package-info.java\n@@ -1,4 +1,5 @@\n /**\n  * Provides Spring Integration outbound components for Apache Kafka.\n  */\n+@org.jspecify.annotations.NullMarked\n package org.springframework.integration.kafka.outbound;\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/package-info.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/package-info.java\nindex d77f8072e7e..e175b2f23a4 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/package-info.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/package-info.java\n@@ -1,4 +1,5 @@\n /**\n  * Root package of the Apache Kafka Module.\n  */\n+@org.jspecify.annotations.NullMarked\n package org.springframework.integration.kafka;\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/support/RawRecordHeaderErrorMessageStrategy.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/support/RawRecordHeaderErrorMessageStrategy.java\nindex 552fb6ba5fa..a60ce740b98 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/support/RawRecordHeaderErrorMessageStrategy.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/support/RawRecordHeaderErrorMessageStrategy.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2017-2019 the original author or authors.\n+ * Copyright 2017-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,12 +19,13 @@\n import java.util.HashMap;\n import java.util.Map;\n \n+import org.jspecify.annotations.Nullable;\n+\n import org.springframework.core.AttributeAccessor;\n import org.springframework.integration.IntegrationMessageHeaderAccessor;\n import org.springframework.integration.support.ErrorMessageStrategy;\n import org.springframework.integration.support.ErrorMessageUtils;\n import org.springframework.kafka.support.KafkaHeaders;\n-import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.support.ErrorMessage;\n \n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/support/package-info.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/support/package-info.java\nindex 0b8fe48568d..72a98346d47 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/support/package-info.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/support/package-info.java\n@@ -1,4 +1,5 @@\n /**\n  * Provides support classes.\n  */\n+@org.jspecify.annotations.NullMarked\n package org.springframework.integration.kafka.support;\n",
    "test_patch": "diff --git a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/channnel/ChannelTests.java b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/channnel/ChannelTests.java\nindex fd4115459f0..8bd7bc64657 100644\n--- a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/channnel/ChannelTests.java\n+++ b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/channnel/ChannelTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2022 the original author or authors.\n+ * Copyright 2020-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -129,7 +129,7 @@ public ProducerFactory<Integer, String> pf() {\n \t\t@Bean\n \t\tpublic ConsumerFactory<Integer, String> cf() {\n \t\t\tMap<String, Object> consumerProps =\n-\t\t\t\t\tKafkaTestUtils.consumerProps(this.embeddedKafkaBrokers, \"channelTests\", \"false\");\n+\t\t\t\t\tKafkaTestUtils.consumerProps(this.embeddedKafkaBrokers, \"channelTests\", false);\n \t\t\tconsumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\t\treturn new DefaultKafkaConsumerFactory<>(consumerProps);\n \t\t}\n\ndiff --git a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/dsl/KafkaDslTests.java b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/dsl/KafkaDslTests.java\nindex 930f50da364..5ed6f539f29 100644\n--- a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/dsl/KafkaDslTests.java\n+++ b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/dsl/KafkaDslTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2015-2024 the original author or authors.\n+ * Copyright 2015-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -280,7 +280,7 @@ public static class ContextConfiguration {\n \n \t\t@Bean\n \t\tpublic ConsumerFactory<Integer, String> consumerFactory() {\n-\t\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(this.embeddedKafkaBrokers, \"dsl-group\", \"false\");\n+\t\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(this.embeddedKafkaBrokers, \"dsl-group\", false);\n \t\t\treturn new DefaultKafkaConsumerFactory<>(props);\n \t\t}\n \n\ndiff --git a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/InboundGatewayTests.java b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/InboundGatewayTests.java\nindex 0af6037c030..3edf76515a8 100644\n--- a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/InboundGatewayTests.java\n+++ b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/InboundGatewayTests.java\n@@ -102,13 +102,13 @@ class InboundGatewayTests {\n \t@Test\n \tvoid testInbound(EmbeddedKafkaBroker embeddedKafka) throws Exception {\n \t\tMap<String, Object> consumerProps =\n-\t\t\t\tKafkaTestUtils.consumerProps(\"replyHandler1\", \"false\", embeddedKafka);\n+\t\t\t\tKafkaTestUtils.consumerProps(embeddedKafka, \"replyHandler1\", false);\n \t\tconsumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tConsumerFactory<Integer, String> cf2 = new DefaultKafkaConsumerFactory<>(consumerProps);\n \t\tConsumer<Integer, String> consumer = cf2.createConsumer();\n \t\tembeddedKafka.consumeFromAnEmbeddedTopic(consumer, topic2);\n \n-\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(\"test1\", \"false\", embeddedKafka);\n+\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(embeddedKafka, \"test1\", false);\n \t\tprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tDefaultKafkaConsumerFactory<Integer, String> cf = new DefaultKafkaConsumerFactory<>(props);\n \t\tContainerProperties containerProps = new ContainerProperties(topic1);\n@@ -195,13 +195,13 @@ public Message<?> toMessage(ConsumerRecord<?, ?> record, Acknowledgment acknowle\n \n \t@Test\n \tvoid testInboundErrorRecover(EmbeddedKafkaBroker embeddedKafka) {\n-\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(\"replyHandler2\", \"false\", embeddedKafka);\n+\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(embeddedKafka, \"replyHandler2\", false);\n \t\tconsumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tConsumerFactory<Integer, String> cf2 = new DefaultKafkaConsumerFactory<>(consumerProps);\n \t\tConsumer<Integer, String> consumer = cf2.createConsumer();\n \t\tembeddedKafka.consumeFromAnEmbeddedTopic(consumer, topic4);\n \n-\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(\"test2\", \"false\", embeddedKafka);\n+\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(embeddedKafka, \"test2\", false);\n \t\tprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tDefaultKafkaConsumerFactory<Integer, String> cf = new DefaultKafkaConsumerFactory<>(props);\n \t\tContainerProperties containerProps = new ContainerProperties(topic3);\n@@ -276,13 +276,13 @@ public Message<?> toMessage(ConsumerRecord<?, ?> record, Acknowledgment acknowle\n \n \t@Test\n \tvoid testInboundRetryErrorRecover(EmbeddedKafkaBroker embeddedKafka) {\n-\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(\"replyHandler3\", \"false\", embeddedKafka);\n+\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(embeddedKafka, \"replyHandler3\", false);\n \t\tconsumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tConsumerFactory<Integer, String> cf2 = new DefaultKafkaConsumerFactory<>(consumerProps);\n \t\tConsumer<Integer, String> consumer = cf2.createConsumer();\n \t\tembeddedKafka.consumeFromAnEmbeddedTopic(consumer, topic6);\n \n-\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(\"test3\", \"false\", embeddedKafka);\n+\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(embeddedKafka, \"test3\", false);\n \t\tprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tDefaultKafkaConsumerFactory<Integer, String> cf = new DefaultKafkaConsumerFactory<>(props);\n \t\tContainerProperties containerProps = new ContainerProperties(topic5);\n@@ -362,13 +362,13 @@ public Message<?> toMessage(ConsumerRecord<?, ?> record, Acknowledgment acknowle\n \n \t@Test\n \tvoid testInboundRetryErrorRecoverWithoutRecoveryCallback(EmbeddedKafkaBroker embeddedKafka) throws Exception {\n-\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(\"replyHandler4\", \"false\", embeddedKafka);\n+\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(embeddedKafka, \"replyHandler4\", false);\n \t\tconsumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tConsumerFactory<Integer, String> cf2 = new DefaultKafkaConsumerFactory<>(consumerProps);\n \t\tConsumer<Integer, String> consumer = cf2.createConsumer();\n \t\tembeddedKafka.consumeFromAnEmbeddedTopic(consumer, topic7);\n \n-\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(\"test4\", \"false\", embeddedKafka);\n+\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(embeddedKafka, \"test4\", false);\n \t\tprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tDefaultKafkaConsumerFactory<Integer, String> cf = new DefaultKafkaConsumerFactory<>(props);\n \t\tContainerProperties containerProps = new ContainerProperties(topic7);\n\ndiff --git a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageDrivenAdapterTests.java b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageDrivenAdapterTests.java\nindex a1be77c5e4c..269f41d494c 100644\n--- a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageDrivenAdapterTests.java\n+++ b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageDrivenAdapterTests.java\n@@ -133,7 +133,7 @@ static void setup() {\n \n \t@Test\n \tvoid testInboundRecord() {\n-\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test1\", \"true\");\n+\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test1\", true);\n \t\tprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tDefaultKafkaConsumerFactory<Integer, String> cf = new DefaultKafkaConsumerFactory<>(props);\n \t\tContainerProperties containerProps = new ContainerProperties(topic1);\n@@ -222,7 +222,7 @@ public Message<?> toMessage(ConsumerRecord<?, ?> record, Acknowledgment acknowle\n \n \t@Test\n \tvoid testInboundRecordRetryRecover() {\n-\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test4\", \"true\");\n+\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test4\", true);\n \t\tprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tDefaultKafkaConsumerFactory<Integer, String> cf = new DefaultKafkaConsumerFactory<>(props);\n \t\tContainerProperties containerProps = new ContainerProperties(topic4);\n@@ -289,7 +289,7 @@ protected boolean doSend(Message<?> message, long timeout) {\n \t */\n \t@Test\n \tvoid testInboundRecordRetryRecoverWithoutRecoveryCallback() throws Exception {\n-\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test6\", \"true\");\n+\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test6\", true);\n \t\tprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tDefaultKafkaConsumerFactory<Integer, String> cf = new DefaultKafkaConsumerFactory<>(props);\n \t\tContainerProperties containerProps = new ContainerProperties(topic6);\n@@ -340,7 +340,7 @@ public <T, E extends Throwable> void onError(RetryContext context, RetryCallback\n \n \t@Test\n \tvoid testInboundRecordNoRetryRecover() {\n-\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test5\", \"true\");\n+\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test5\", true);\n \t\tprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tDefaultKafkaConsumerFactory<Integer, String> cf = new DefaultKafkaConsumerFactory<>(props);\n \t\tContainerProperties containerProps = new ContainerProperties(topic5);\n@@ -396,7 +396,7 @@ protected boolean doSend(Message<?> message, long timeout) {\n \n \t@Test\n \tvoid testInboundBatch() throws Exception {\n-\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test2\", \"true\");\n+\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test2\", true);\n \t\tprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tDefaultKafkaConsumerFactory<Integer, String> cf = new DefaultKafkaConsumerFactory<>(props);\n \t\tContainerProperties containerProps = new ContainerProperties(topic2);\n@@ -486,7 +486,7 @@ public Message<?> toMessage(List<ConsumerRecord<?, ?>> records, Acknowledgment a\n \n \t@Test\n \tvoid testInboundJson() {\n-\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test3\", \"true\");\n+\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test3\", true);\n \t\tprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tDefaultKafkaConsumerFactory<Integer, String> cf = new DefaultKafkaConsumerFactory<>(props);\n \t\tContainerProperties containerProps = new ContainerProperties(topic3);\n@@ -529,7 +529,7 @@ void testInboundJson() {\n \n \t@Test\n \tvoid testInboundJsonWithPayload() {\n-\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test7\", \"true\");\n+\t\tMap<String, Object> props = KafkaTestUtils.consumerProps(EMBEDDED_BROKERS, \"test7\", true);\n \t\tprops.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tDefaultKafkaConsumerFactory<Integer, Foo> cf = new DefaultKafkaConsumerFactory<>(props);\n \t\tContainerProperties containerProps = new ContainerProperties(topic6);\n@@ -585,8 +585,8 @@ void testPauseResume() throws Exception {\n \t\trecords.put(new TopicPartition(\"foo\", 0), Arrays.asList(\n \t\t\t\tnew ConsumerRecord<>(\"foo\", 0, 0L, 1, \"foo\"),\n \t\t\t\tnew ConsumerRecord<>(\"foo\", 0, 1L, 1, \"bar\")));\n-\t\tConsumerRecords<Integer, String> consumerRecords = new ConsumerRecords<>(records);\n-\t\tConsumerRecords<Integer, String> emptyRecords = new ConsumerRecords<>(Collections.emptyMap());\n+\t\tConsumerRecords<Integer, String> consumerRecords = new ConsumerRecords<>(records, Map.of());\n+\t\tConsumerRecords<Integer, String> emptyRecords = new ConsumerRecords<>(Collections.emptyMap(), Map.of());\n \t\tAtomicBoolean first = new AtomicBoolean(true);\n \t\tgiven(consumer.poll(any(Duration.class))).willAnswer(i -> {\n \t\t\tThread.sleep(50);\n\ndiff --git a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceIntegrationTests.java b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceIntegrationTests.java\nindex c1bf2cadd2a..ad991d3b129 100644\n--- a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceIntegrationTests.java\n+++ b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceIntegrationTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018-2024 the original author or authors.\n+ * Copyright 2018-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -69,7 +69,7 @@ static void setup() {\n \n \t@Test\n \tvoid testSource() throws Exception {\n-\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(brokers, \"testSource\", \"false\");\n+\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(brokers, \"testSource\", false);\n \t\tconsumerProps.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 2);\n \t\tconsumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tconsumerProps.put(ConsumerConfig.FETCH_MIN_BYTES_CONFIG, 42);\n@@ -140,7 +140,7 @@ public void onPartitionsAssigned(Collection<TopicPartition> partitions) {\n \n \t@Test\n \tvoid deserializationErrorIsThrownFromSource() {\n-\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(brokers, \"testErrorChannelSource\", \"false\");\n+\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(brokers, \"testErrorChannelSource\", false);\n \t\tconsumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);\n \t\tconsumerProps.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, FailingDeserializer.class);\n \n\ndiff --git a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceTests.java b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceTests.java\nindex cfe99822c35..7a537f734ab 100644\n--- a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceTests.java\n+++ b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/inbound/MessageSourceTests.java\n@@ -46,7 +46,7 @@\n import org.apache.kafka.clients.consumer.MockConsumer;\n import org.apache.kafka.clients.consumer.OffsetAndMetadata;\n import org.apache.kafka.clients.consumer.OffsetCommitCallback;\n-import org.apache.kafka.clients.consumer.OffsetResetStrategy;\n+import org.apache.kafka.clients.consumer.internals.AutoOffsetResetStrategy;\n import org.apache.kafka.common.TopicPartition;\n import org.apache.kafka.common.header.internals.RecordHeaders;\n import org.apache.kafka.common.record.TimestampType;\n@@ -267,11 +267,11 @@ private void testAckCommon(boolean sync, boolean timeout) {\n \t\trecords4.put(topicPartition, Collections.singletonList(\n \t\t\t\tnew ConsumerRecord(\"foo\", 0, 3L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, \"qux\",\n \t\t\t\t\t\tnew RecordHeaders(), Optional.empty())));\n-\t\tConsumerRecords cr1 = new ConsumerRecords(records1);\n-\t\tConsumerRecords cr2 = new ConsumerRecords(records2);\n-\t\tConsumerRecords cr3 = new ConsumerRecords(records3);\n-\t\tConsumerRecords cr4 = new ConsumerRecords(records4);\n-\t\tConsumerRecords cr5 = new ConsumerRecords(Collections.emptyMap());\n+\t\tConsumerRecords cr1 = new ConsumerRecords(records1, Map.of());\n+\t\tConsumerRecords cr2 = new ConsumerRecords(records2, Map.of());\n+\t\tConsumerRecords cr3 = new ConsumerRecords(records3, Map.of());\n+\t\tConsumerRecords cr4 = new ConsumerRecords(records4, Map.of());\n+\t\tConsumerRecords cr5 = new ConsumerRecords(Collections.emptyMap(), Map.of());\n \t\tgiven(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr3, cr4, cr5);\n \t\tConsumerFactory consumerFactory = mock(ConsumerFactory.class);\n \t\twillReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory)\n@@ -404,13 +404,13 @@ void testAckOutOfOrder() {\n \t\trecords6.put(topicPartition, Collections.singletonList(\n \t\t\t\tnew ConsumerRecord(\"foo\", 0, 5L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, \"buz\",\n \t\t\t\t\t\tnew RecordHeaders(), Optional.empty())));\n-\t\tConsumerRecords cr1 = new ConsumerRecords(records1);\n-\t\tConsumerRecords cr2 = new ConsumerRecords(records2);\n-\t\tConsumerRecords cr3 = new ConsumerRecords(records3);\n-\t\tConsumerRecords cr4 = new ConsumerRecords(records4);\n-\t\tConsumerRecords cr5 = new ConsumerRecords(records5);\n-\t\tConsumerRecords cr6 = new ConsumerRecords(records6);\n-\t\tConsumerRecords cr7 = new ConsumerRecords(Collections.emptyMap());\n+\t\tConsumerRecords cr1 = new ConsumerRecords(records1, Map.of());\n+\t\tConsumerRecords cr2 = new ConsumerRecords(records2, Map.of());\n+\t\tConsumerRecords cr3 = new ConsumerRecords(records3, Map.of());\n+\t\tConsumerRecords cr4 = new ConsumerRecords(records4, Map.of());\n+\t\tConsumerRecords cr5 = new ConsumerRecords(records5, Map.of());\n+\t\tConsumerRecords cr6 = new ConsumerRecords(records6, Map.of());\n+\t\tConsumerRecords cr7 = new ConsumerRecords(Collections.emptyMap(), Map.of());\n \t\tgiven(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr3, cr4, cr5, cr6, cr7);\n \t\tConsumerFactory consumerFactory = mock(ConsumerFactory.class);\n \t\twillReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory)\n@@ -480,13 +480,13 @@ void testNack() {\n \t\trecords1.put(topicPartition, Collections.singletonList(\n \t\t\t\tnew ConsumerRecord(\"foo\", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, \"foo\",\n \t\t\t\t\t\tnew RecordHeaders(), Optional.empty())));\n-\t\tConsumerRecords cr1 = new ConsumerRecords(records1);\n+\t\tConsumerRecords cr1 = new ConsumerRecords(records1, Map.of());\n \t\tMap<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();\n \t\trecords2.put(topicPartition, Collections.singletonList(\n \t\t\t\tnew ConsumerRecord(\"foo\", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, \"bar\",\n \t\t\t\t\t\tnew RecordHeaders(), Optional.empty())));\n-\t\tConsumerRecords cr2 = new ConsumerRecords(records2);\n-\t\tConsumerRecords cr3 = new ConsumerRecords(Collections.emptyMap());\n+\t\tConsumerRecords cr2 = new ConsumerRecords(records2, Map.of());\n+\t\tConsumerRecords cr3 = new ConsumerRecords(Collections.emptyMap(), Map.of());\n \t\tgiven(consumer.poll(any(Duration.class))).willReturn(cr1, cr1, cr2, cr2, cr3);\n \t\tConsumerFactory consumerFactory = mock(ConsumerFactory.class);\n \t\twillReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory)\n@@ -551,13 +551,13 @@ void testNackWithLaterInflight() {\n \t\trecords1.put(topicPartition, Collections.singletonList(\n \t\t\t\tnew ConsumerRecord(\"foo\", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, \"foo\",\n \t\t\t\t\t\tnew RecordHeaders(), Optional.empty())));\n-\t\tConsumerRecords cr1 = new ConsumerRecords(records1);\n+\t\tConsumerRecords cr1 = new ConsumerRecords(records1, Map.of());\n \t\tMap<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();\n \t\trecords2.put(topicPartition, Collections.singletonList(\n \t\t\t\tnew ConsumerRecord(\"foo\", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, \"bar\",\n \t\t\t\t\t\tnew RecordHeaders(), Optional.empty())));\n-\t\tConsumerRecords cr2 = new ConsumerRecords(records2);\n-\t\tConsumerRecords cr3 = new ConsumerRecords(Collections.emptyMap());\n+\t\tConsumerRecords cr2 = new ConsumerRecords(records2, Map.of());\n+\t\tConsumerRecords cr3 = new ConsumerRecords(Collections.emptyMap(), Map.of());\n \t\tgiven(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr1, cr2, cr3);\n \t\tConsumerFactory consumerFactory = mock(ConsumerFactory.class);\n \t\twillReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory)\n@@ -656,13 +656,13 @@ void testPollTimeouts() {\n \t\trecords1.put(topicPartition, Collections.singletonList(\n \t\t\t\tnew ConsumerRecord(\"foo\", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, \"foo\",\n \t\t\t\t\t\tnew RecordHeaders(), Optional.empty())));\n-\t\tConsumerRecords cr1 = new ConsumerRecords(records1);\n+\t\tConsumerRecords cr1 = new ConsumerRecords(records1, Map.of());\n \t\tgiven(consumer.poll(Duration.of(20 * 5000, ChronoUnit.MILLIS))).willReturn(cr1, ConsumerRecords.EMPTY);\n \t\tMap<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();\n \t\trecords2.put(topicPartition, Collections.singletonList(\n \t\t\t\tnew ConsumerRecord(\"foo\", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, \"foo\",\n \t\t\t\t\t\tnew RecordHeaders(), Optional.empty())));\n-\t\tConsumerRecords cr2 = new ConsumerRecords(records2);\n+\t\tConsumerRecords cr2 = new ConsumerRecords(records2, Map.of());\n \t\tgiven(consumer.poll(Duration.of(5000, ChronoUnit.MILLIS))).willReturn(cr2, ConsumerRecords.EMPTY);\n \t\tConsumerFactory consumerFactory = mock(ConsumerFactory.class);\n \t\twillReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory)\n@@ -727,8 +727,8 @@ void testAllowMulti() {\n \t\t\t\t\t\tnew RecordHeaders(), Optional.empty()),\n \t\t\t\tnew ConsumerRecord(\"foo\", 0, 3L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, \"qux\",\n \t\t\t\t\t\tnew RecordHeaders(), Optional.empty())));\n-\t\tConsumerRecords cr1 = new ConsumerRecords(records);\n-\t\tConsumerRecords cr2 = new ConsumerRecords(Collections.emptyMap());\n+\t\tConsumerRecords cr1 = new ConsumerRecords(records, Map.of());\n+\t\tConsumerRecords cr2 = new ConsumerRecords(Collections.emptyMap(), Map.of());\n \t\tgiven(consumer.poll(any(Duration.class))).willReturn(cr1, cr2);\n \t\tConsumerFactory consumerFactory = mock(ConsumerFactory.class);\n \t\twillReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 4)).given(consumerFactory)\n@@ -775,7 +775,7 @@ void testAllowMulti() {\n \t@SuppressWarnings(\"unchecked\")\n \t@Test\n \tvoid testTopicPatternBasedMessageSource() {\n-\t\tMockConsumer<String, String> consumer = new MockConsumer<>(OffsetResetStrategy.EARLIEST);\n+\t\tMockConsumer<String, String> consumer = new MockConsumer<>(AutoOffsetResetStrategy.EARLIEST.name());\n \t\tTopicPartition topicPartition1 = new TopicPartition(\"abc_foo\", 0);\n \t\tTopicPartition topicPartition2 = new TopicPartition(\"abc_foo\", 1);\n \t\tTopicPartition topicPartition3 = new TopicPartition(\"def_foo\", 0);\n@@ -836,7 +836,7 @@ void testTopicPatternBasedMessageSource() {\n \t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n \t@Test\n \tvoid testStaticPartitionAssignment() {\n-\t\tMockConsumer<String, String> consumer = spy(new MockConsumer<>(OffsetResetStrategy.EARLIEST));\n+\t\tMockConsumer<String, String> consumer = spy(new MockConsumer<>(AutoOffsetResetStrategy.EARLIEST.name()));\n \n \t\tTopicPartition beginning = new TopicPartition(\"foo\", 0);\n \t\tTopicPartition end = new TopicPartition(\"foo\", 1);\n\ndiff --git a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandlerTests.java b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandlerTests.java\nindex 2382dd31dd8..3d038bb3ebb 100644\n--- a/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandlerTests.java\n+++ b/spring-integration-kafka/src/test/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandlerTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2024 the original author or authors.\n+ * Copyright 2016-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -42,6 +42,7 @@\n import org.apache.kafka.clients.producer.ProducerRecord;\n import org.apache.kafka.clients.producer.RecordMetadata;\n import org.apache.kafka.common.TopicPartition;\n+import org.jspecify.annotations.Nullable;\n import org.junit.jupiter.api.AfterAll;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n@@ -79,7 +80,6 @@\n import org.springframework.kafka.test.EmbeddedKafkaKraftBroker;\n import org.springframework.kafka.test.utils.KafkaTestUtils;\n import org.springframework.kafka.transaction.KafkaTransactionManager;\n-import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageHandlingException;\n import org.springframework.messaging.MessagingException;\n@@ -141,7 +141,7 @@ class KafkaProducerMessageHandlerTests {\n \tstatic void setup() {\n \t\tembeddedKafka = new EmbeddedKafkaKraftBroker(1, 2, topic1, topic2, topic3, topic4, topic5, topic6);\n \t\tembeddedKafka.afterPropertiesSet();\n-\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(\"testOut\", \"true\", embeddedKafka);\n+\t\tMap<String, Object> consumerProps = KafkaTestUtils.consumerProps(embeddedKafka, \"testOut\", true);\n \t\tconsumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n \t\tConsumerFactory<Integer, String> cf = new DefaultKafkaConsumerFactory<>(consumerProps);\n \t\tconsumer = cf.createConsumer();\n@@ -408,7 +408,7 @@ void testOutboundGatewayPrPayload() throws Exception {\n \n \tprivate void testOutboundGatewayGuts(ProducerRecord<?, ?> payload) throws Exception {\n \t\tConsumerFactory<Integer, String> consumerFactory = new DefaultKafkaConsumerFactory<>(\n-\t\t\t\tKafkaTestUtils.consumerProps(topic5, \"false\", embeddedKafka));\n+\t\t\t\tKafkaTestUtils.consumerProps(embeddedKafka, topic5, false));\n \t\tContainerProperties containerProperties = new ContainerProperties(topic6);\n \t\tfinal CountDownLatch assigned = new CountDownLatch(1);\n \t\tcontainerProperties.setConsumerRebalanceListener(new ConsumerRebalanceListener() {\n@@ -507,7 +507,7 @@ void testConsumeAndProduceTransaction() throws Exception {\n \t\t\treturn null;\n \t\t}).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));\n \t\tConsumerRecords records = new ConsumerRecords(Collections.singletonMap(topicPartition,\n-\t\t\t\tCollections.singletonList(new ConsumerRecord<>(\"foo\", 0, 0, \"key\", \"value\"))));\n+\t\t\t\tCollections.singletonList(new ConsumerRecord<>(\"foo\", 0, 0, \"key\", \"value\"))), Map.of());\n \t\tfinal AtomicBoolean done = new AtomicBoolean();\n \t\twillAnswer(i -> {\n \t\t\tif (done.compareAndSet(false, true)) {\n@@ -642,7 +642,7 @@ void testConsumeAndProduceTransactionTxIdOverride() throws Exception {\n \t\t\treturn null;\n \t\t}).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));\n \t\tConsumerRecords records = new ConsumerRecords(Collections.singletonMap(topicPartition,\n-\t\t\t\tCollections.singletonList(new ConsumerRecord<>(\"foo\", 0, 0, \"key\", \"value\"))));\n+\t\t\t\tCollections.singletonList(new ConsumerRecord<>(\"foo\", 0, 0, \"key\", \"value\"))), Map.of());\n \t\tfinal AtomicBoolean done = new AtomicBoolean();\n \t\twillAnswer(i -> {\n \t\t\tif (done.compareAndSet(false, true)) {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-10102",
    "pr_id": 10102,
    "issue_id": 10100,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Mail: Proposal for removing constructors in `AbstractMailReceiver` which support `url` to be null\ncurrent in `AbstractMailReceiver`, we have 3 constructors.\n\n```java\n        private final URLName url;\n\n\tpublic AbstractMailReceiver() {\n\t\tthis.url = null;\n\t}\n\n\tpublic AbstractMailReceiver(URLName urlName) {\n\t\tAssert.notNull(urlName, \"urlName must not be null\");\n\t\tthis.url = urlName;\n\t}\n\n\tpublic AbstractMailReceiver(String url) {\n\t\tif (url != null) {\n\t\t\tthis.url = new URLName(url);\n\t\t}\n\t\telse {\n\t\t\tthis.url = null;\n\t\t}\n\t}\n``` \n\nit says `url` could be null in some cases. \n\nhowever, inside the `AbstractMailReceiver.receive()`, we will call below:\n```java\n\tprivate Folder obtainFolderInstance() throws MessagingException {\n\t\treturn this.store.getFolder(this.url);\n\t}\n```\nhere, if `this.url` is null, `getFolder` will throw an NPE.\n\nSo, I think it's safe to remove this constructors.\n",
    "issue_word_count": 112,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "spring-integration-mail/src/main/java/org/springframework/integration/mail/AbstractMailReceiver.java",
      "spring-integration-mail/src/test/java/org/springframework/integration/mail/MailReceiverTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-mail/src/test/java/org/springframework/integration/mail/MailReceiverTests.java"
    ],
    "base_commit": "d63dd2637cdbace92844e7b19c34e91cca351f40",
    "head_commit": "ff240236a0a5a3e69694fee4af99a1adbce9baf1",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/10102",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/10102",
    "dockerfile": "",
    "pr_merged_at": "2025-06-12T14:44:54.000Z",
    "patch": "diff --git a/spring-integration-mail/src/main/java/org/springframework/integration/mail/AbstractMailReceiver.java b/spring-integration-mail/src/main/java/org/springframework/integration/mail/AbstractMailReceiver.java\nindex 2086d930d2..de1c9085ea 100755\n--- a/spring-integration-mail/src/main/java/org/springframework/integration/mail/AbstractMailReceiver.java\n+++ b/spring-integration-mail/src/main/java/org/springframework/integration/mail/AbstractMailReceiver.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -69,6 +69,7 @@\n  * @author Yuxin Wang\n  * @author Ngoc Nhan\n  * @author Filip Hrisafov\n+ * @author Jiandong Ma\n  */\n public abstract class AbstractMailReceiver extends IntegrationObjectSupport implements MailReceiver, DisposableBean {\n \n@@ -370,6 +371,9 @@ protected void openFolder() throws MessagingException {\n \t}\n \n \tprivate Folder obtainFolderInstance() throws MessagingException {\n+\t\tif (this.url == null) {\n+\t\t\treturn this.store.getDefaultFolder();\n+\t\t}\n \t\treturn this.store.getFolder(this.url);\n \t}\n \n",
    "test_patch": "diff --git a/spring-integration-mail/src/test/java/org/springframework/integration/mail/MailReceiverTests.java b/spring-integration-mail/src/test/java/org/springframework/integration/mail/MailReceiverTests.java\nindex 4de6537ee1..752a1b8319 100644\n--- a/spring-integration-mail/src/test/java/org/springframework/integration/mail/MailReceiverTests.java\n+++ b/spring-integration-mail/src/test/java/org/springframework/integration/mail/MailReceiverTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2022 the original author or authors.\n+ * Copyright 2014-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -22,7 +22,6 @@\n import jakarta.mail.Message;\n import jakarta.mail.Session;\n import jakarta.mail.Store;\n-import jakarta.mail.URLName;\n import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.DirectFieldAccessor;\n@@ -68,7 +67,7 @@ protected Message[] searchForNewMessages() {\n \t\tFolder folder = mock(Folder.class);\n \t\twhen(folder.exists()).thenReturn(true);\n \t\twhen(folder.isOpen()).thenReturn(false, true);\n-\t\tdoReturn(folder).when(store).getFolder((URLName) null);\n+\t\tdoReturn(folder).when(store).getDefaultFolder();\n \t\tdoNothing().when(store).connect();\n \t\treceiver.openFolder();\n \t\treceiver.openFolder();\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-10098",
    "pr_id": 10098,
    "issue_id": 10083,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Apply Nullability to the project\nMore info in the Spring Framework `7.0` docs: https://docs.spring.io/spring-framework/reference/7.0/core/null-safety.html.\n\nWe can treat this issue an Epic and have sub-issues for specific tasks or dedicated module fixes.\n\nThis can be done in phase:\n\n1. Migrate from deprecated `org.springframework.lang.Nullable` on properties methods to the `org.jspecify.annotations.Nullable`.\n2. Migrate `@org.springframework.lang.NonNullApi` and `@org.springframework.lang.NonNullFields` pair to the `@org.jspecify.annotations.NullMarked`. However this would trigger the third phase.\n3. Fix nullabilty errors in those `@org.jspecify.annotations.NullMarked` packages.\n4. Add more and more `@org.jspecify.annotations.NullMarked`  and fix respective nullability vulnerabilities in those package and modules.\n\nAny other thoughts and possible ways to fix this huge task are welcome!\n\nlist (checked means someone has taken it )\n- [x] spring-integration-amqp\n- [x] spring-integration-camel\n- [x] spring-integration-cassandra\n- [x] spring-integration-core\n- [ ] spring-integration-debezium\n- [x] spring-integration-event\n- [ ] spring-integration-feed\n- [ ] spring-integration-file\n- [ ] spring-integration-ftp\n- [ ] spring-integration-graphql\n- [ ] spring-integration-groovy\n- [ ] spring-integration-hazelcast\n- [ ] spring-integration-http\n- [ ] spring-integration-ip\n- [ ] spring-integration-jdbc\n- [ ] spring-integration-jms\n- [x] spring-integration-jmx\n- [x] spring-integration-jpa\n- [x] spring-integration-kafka\n- [x] spring-integration-mail\n- [ ] spring-integration-mongodb\n- [ ] spring-integration-r2dbc\n- [ ] spring-integration-mqtt\n- [ ] spring-integration-redis\n- [ ] spring-integration-rsocket\n- [ ] spring-integration-scripting\n- [ ] spring-integration-sftp\n- [ ] spring-integration-smb\n- [ ] spring-integration-stomp\n- [ ] spring-integration-stream\n- [ ] spring-integration-syslog\n- [ ] spring-integration-test\n- [ ] spring-integration-test-support\n- [ ] spring-integration-webflux\n- [ ] spring-integration-websocket\n- [x] spring-integration-ws\n- [x] spring-integration-xml\n- [x] spring-integration-xmpp\n- [x] spring-integration-zeromq\n- [x] spring-integration-zip\n- [x] spring-integration-zookeeper",
    "issue_word_count": 282,
    "test_files_count": 1,
    "non_test_files_count": 11,
    "pr_changed_files": [
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/AbstractWebServiceOutboundGateway.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/DefaultSoapHeaderMapper.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceInboundGateway.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceOutboundGateway.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/SimpleWebServiceOutboundGateway.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/config/package-info.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/BaseWsOutboundGatewaySpec.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/MarshallingWsOutboundGatewaySpec.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/SimpleWsOutboundGatewaySpec.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/package-info.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/package-info.java",
      "spring-integration-ws/src/test/java/org/springframework/integration/ws/config/WebServiceOutboundGatewayParserTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-ws/src/test/java/org/springframework/integration/ws/config/WebServiceOutboundGatewayParserTests.java"
    ],
    "base_commit": "d63dd2637cdbace92844e7b19c34e91cca351f40",
    "head_commit": "4d4f2799269e69789492f65657ef159786d15d6e",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/10098",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/10098",
    "dockerfile": "",
    "pr_merged_at": "2025-06-20T17:52:41.000Z",
    "patch": "diff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/AbstractWebServiceOutboundGateway.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/AbstractWebServiceOutboundGateway.java\nindex f053ad65bd7..9cb3d73776b 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/AbstractWebServiceOutboundGateway.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/AbstractWebServiceOutboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -25,6 +25,8 @@\n \n import javax.xml.transform.TransformerException;\n \n+import org.jspecify.annotations.Nullable;\n+\n import org.springframework.expression.Expression;\n import org.springframework.expression.spel.support.StandardEvaluationContext;\n import org.springframework.integration.expression.ExpressionEvalMap;\n@@ -59,6 +61,7 @@\n  * @author Artem Bilan\n  * @author Christian Tzolov\n  * @author Ngoc Nhan\n+ * @author Jooyoung Pyoung\n  */\n public abstract class AbstractWebServiceOutboundGateway extends AbstractReplyProducingMessageHandler {\n \n@@ -66,15 +69,16 @@ public abstract class AbstractWebServiceOutboundGateway extends AbstractReplyPro\n \n \tprotected final DefaultUriBuilderFactory uriFactory = new DefaultUriBuilderFactory(); // NOSONAR - final\n \n-\tprivate final String uri;\n+\tprivate final @Nullable String uri;\n \n-\tprivate final DestinationProvider destinationProvider;\n+\tprivate final @Nullable DestinationProvider destinationProvider;\n \n \tprivate final Map<String, Expression> uriVariableExpressions = new HashMap<>();\n \n+\t@SuppressWarnings(\"NullAway.Init\")\n \tprivate StandardEvaluationContext evaluationContext;\n \n-\tprivate WebServiceMessageCallback requestCallback;\n+\tprivate @Nullable WebServiceMessageCallback requestCallback;\n \n \tprivate WebServiceTemplate webServiceTemplate;\n \n@@ -84,18 +88,20 @@ public abstract class AbstractWebServiceOutboundGateway extends AbstractReplyPro\n \n \tprivate boolean webServiceTemplateExplicitlySet;\n \n-\tpublic AbstractWebServiceOutboundGateway(final String uri, WebServiceMessageFactory messageFactory) {\n+\tpublic AbstractWebServiceOutboundGateway(@Nullable final String uri, @Nullable WebServiceMessageFactory messageFactory) {\n \t\tAssert.hasText(uri, \"URI must not be empty\");\n-\t\tthis.webServiceTemplate = new WebServiceTemplate(messageFactory);\n+\t\tthis.webServiceTemplate = messageFactory != null ?\n+\t\t\t\tnew WebServiceTemplate(messageFactory) : new WebServiceTemplate();\n \t\tthis.destinationProvider = null;\n \t\tthis.uri = uri;\n \t}\n \n \tpublic AbstractWebServiceOutboundGateway(DestinationProvider destinationProvider,\n-\t\t\tWebServiceMessageFactory messageFactory) {\n+\t\t\t@Nullable WebServiceMessageFactory messageFactory) {\n \n \t\tAssert.notNull(destinationProvider, \"DestinationProvider must not be null\");\n-\t\tthis.webServiceTemplate = new WebServiceTemplate(messageFactory);\n+\t\tthis.webServiceTemplate = messageFactory != null ?\n+\t\t\t\tnew WebServiceTemplate(messageFactory) : new WebServiceTemplate();\n \t\tthis.destinationProvider = destinationProvider;\n \t\t// we always call WebServiceTemplate methods with an explicit URI argument,\n \t\t// but in case the WebServiceTemplate is accessed directly we'll set this:\n@@ -165,7 +171,7 @@ public void setMessageFactory(WebServiceMessageFactory messageFactory) {\n \t\tthis.webServiceTemplate.setMessageFactory(messageFactory);\n \t}\n \n-\tpublic void setRequestCallback(WebServiceMessageCallback requestCallback) {\n+\tpublic void setRequestCallback(@Nullable WebServiceMessageCallback requestCallback) {\n \t\tthis.requestCallback = requestCallback;\n \t}\n \n@@ -199,7 +205,7 @@ protected WebServiceTemplate getWebServiceTemplate() {\n \t}\n \n \t@Override\n-\tpublic final Object handleRequestMessage(Message<?> requestMessage) {\n+\tpublic final @Nullable Object handleRequestMessage(Message<?> requestMessage) {\n \t\tURI uriWithVariables = prepareUri(requestMessage);\n \t\tif (uriWithVariables == null) {\n \t\t\tthrow new MessageDeliveryException(requestMessage, \"Failed to determine URI for \" +\n@@ -215,7 +221,7 @@ public final Object handleRequestMessage(Message<?> requestMessage) {\n \t\treturn null;\n \t}\n \n-\tprivate URI prepareUri(Message<?> requestMessage) {\n+\tprivate @Nullable URI prepareUri(Message<?> requestMessage) {\n \t\tif (this.destinationProvider != null) {\n \t\t\treturn this.destinationProvider.getDestination();\n \t\t}\n@@ -226,20 +232,21 @@ private URI prepareUri(Message<?> requestMessage) {\n \t\t\t\t\t\t.withRoot(requestMessage)\n \t\t\t\t\t\t.build();\n \n+\t\tAssert.notNull(this.uri, \"'uri' must not be null\");\n \t\treturn this.uriFactory.expand(this.uri, uriVariables);\n \t}\n \n-\tprotected abstract Object doHandle(String theUri, Message<?> requestMessage,\n-\t\t\tWebServiceMessageCallback reqCallback);\n+\tprotected abstract @Nullable Object doHandle(String theUri, Message<?> requestMessage,\n+\t\t\t@Nullable WebServiceMessageCallback reqCallback);\n \n \tprotected abstract class RequestMessageCallback extends TransformerObjectSupport\n \t\t\timplements WebServiceMessageCallback {\n \n-\t\tprivate final WebServiceMessageCallback reqCallback;\n+\t\tprivate final @Nullable WebServiceMessageCallback reqCallback;\n \n \t\tprivate final Message<?> requestMessage;\n \n-\t\tpublic RequestMessageCallback(WebServiceMessageCallback requestCallback, Message<?> requestMessage) {\n+\t\tpublic RequestMessageCallback(@Nullable WebServiceMessageCallback requestCallback, Message<?> requestMessage) {\n \t\t\tthis.reqCallback = requestCallback;\n \t\t\tthis.requestMessage = requestMessage;\n \t\t}\n@@ -266,7 +273,7 @@ protected abstract class ResponseMessageExtractor extends TransformerObjectSuppo\n \t\t\timplements WebServiceMessageExtractor<Object> {\n \n \t\t@Override\n-\t\tpublic Object extractData(WebServiceMessage message)\n+\t\tpublic @Nullable Object extractData(WebServiceMessage message)\n \t\t\t\tthrows IOException, TransformerException {\n \n \t\t\tObject resultObject = this.doExtractData(message);\n@@ -284,7 +291,7 @@ public Object extractData(WebServiceMessage message)\n \t\t\t}\n \t\t}\n \n-\t\tpublic abstract Object doExtractData(WebServiceMessage message) throws IOException, TransformerException;\n+\t\tpublic abstract @Nullable Object doExtractData(WebServiceMessage message) throws IOException, TransformerException;\n \n \t}\n \n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/DefaultSoapHeaderMapper.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/DefaultSoapHeaderMapper.java\nindex 39544c5c948..fa87c8f3590 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/DefaultSoapHeaderMapper.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/DefaultSoapHeaderMapper.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -53,6 +53,7 @@\n  * @author Mauro Molinari\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Jooyoung Pyoung\n  *\n  * @since 2.0\n  */\n@@ -126,6 +127,10 @@ else if (!StringUtils.hasText(target.getSoapAction())) {\n \t@Override\n \tprotected void populateUserDefinedHeader(String headerName, Object headerValue, SoapMessage target) {\n \t\tSoapHeader soapHeader = target.getSoapHeader();\n+\t\tif (soapHeader == null) {\n+\t\t\treturn;\n+\t\t}\n+\n \t\tif (headerValue instanceof String) {\n \t\t\tQName qname = QNameUtils.parseQNameString(headerName);\n \t\t\tsoapHeader.addAttribute(qname, (String) headerValue);\n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceInboundGateway.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceInboundGateway.java\nindex d7f6ea52cb8..8800715270d 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceInboundGateway.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceInboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -35,8 +35,10 @@\n  */\n public class MarshallingWebServiceInboundGateway extends AbstractWebServiceInboundGateway {\n \n+\t@SuppressWarnings(\"NullAway.Init\")\n \tprivate Marshaller marshaller;\n \n+\t@SuppressWarnings(\"NullAway.Init\")\n \tprivate Unmarshaller unmarshaller;\n \n \t/**\n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceOutboundGateway.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceOutboundGateway.java\nindex 6a5329b9e3d..b1d3126a4bc 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceOutboundGateway.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceOutboundGateway.java\n@@ -18,7 +18,8 @@\n \n import java.io.IOException;\n \n-import org.springframework.lang.Nullable;\n+import org.jspecify.annotations.Nullable;\n+\n import org.springframework.messaging.Message;\n import org.springframework.oxm.Marshaller;\n import org.springframework.oxm.Unmarshaller;\n@@ -45,7 +46,7 @@ public class MarshallingWebServiceOutboundGateway extends AbstractWebServiceOutb\n \n \t@SuppressWarnings(\"this-escape\")\n \tpublic MarshallingWebServiceOutboundGateway(DestinationProvider destinationProvider, Marshaller marshaller,\n-\t\t\tUnmarshaller unmarshaller, WebServiceMessageFactory messageFactory) {\n+\t\t\t@Nullable Unmarshaller unmarshaller, @Nullable WebServiceMessageFactory messageFactory) {\n \t\tsuper(destinationProvider, messageFactory);\n \t\tconfigureMarshallers(marshaller, unmarshaller);\n \t}\n@@ -56,7 +57,7 @@ public MarshallingWebServiceOutboundGateway(DestinationProvider destinationProvi\n \t}\n \n \tpublic MarshallingWebServiceOutboundGateway(DestinationProvider destinationProvider, Marshaller marshaller,\n-\t\t\tWebServiceMessageFactory messageFactory) {\n+\t\t\t@Nullable WebServiceMessageFactory messageFactory) {\n \t\tthis(destinationProvider, marshaller, null, messageFactory);\n \t}\n \n@@ -65,8 +66,8 @@ public MarshallingWebServiceOutboundGateway(DestinationProvider destinationProvi\n \t}\n \n \t@SuppressWarnings(\"this-escape\")\n-\tpublic MarshallingWebServiceOutboundGateway(String uri, Marshaller marshaller, Unmarshaller unmarshaller,\n-\t\t\tWebServiceMessageFactory messageFactory) {\n+\tpublic MarshallingWebServiceOutboundGateway(@Nullable String uri, Marshaller marshaller, @Nullable Unmarshaller unmarshaller,\n+\t\t\t@Nullable WebServiceMessageFactory messageFactory) {\n \t\tsuper(uri, messageFactory);\n \t\tconfigureMarshallers(marshaller, unmarshaller);\n \t}\n@@ -76,7 +77,7 @@ public MarshallingWebServiceOutboundGateway(String uri, Marshaller marshaller, U\n \t}\n \n \tpublic MarshallingWebServiceOutboundGateway(String uri, Marshaller marshaller,\n-\t\t\tWebServiceMessageFactory messageFactory) {\n+\t\t\t@Nullable WebServiceMessageFactory messageFactory) {\n \t\tthis(uri, marshaller, null, messageFactory);\n \t}\n \n@@ -91,7 +92,7 @@ public MarshallingWebServiceOutboundGateway(String uri, Marshaller marshaller) {\n \t * @since 5.0\n \t */\n \t@SuppressWarnings(\"this-escape\")\n-\tpublic MarshallingWebServiceOutboundGateway(String uri, WebServiceTemplate webServiceTemplate) {\n+\tpublic MarshallingWebServiceOutboundGateway(@Nullable String uri, WebServiceTemplate webServiceTemplate) {\n \t\tsuper(uri, null);\n \t\tdoSetWebServiceTemplate(webServiceTemplate);\n \t}\n@@ -139,7 +140,7 @@ public String getComponentType() {\n \t}\n \n \t@Override\n-\tprotected Object doHandle(String uri, Message<?> requestMessage, WebServiceMessageCallback requestCallback) {\n+\tprotected @Nullable Object doHandle(String uri, Message<?> requestMessage, @Nullable WebServiceMessageCallback requestCallback) {\n \t\treturn getWebServiceTemplate()\n \t\t\t\t.marshalSendAndReceive(uri, requestMessage.getPayload(),\n \t\t\t\t\t\tnew PassThroughRequestMessageCallback(requestCallback, requestMessage));\n@@ -147,7 +148,7 @@ protected Object doHandle(String uri, Message<?> requestMessage, WebServiceMessa\n \n \tprivate final class PassThroughRequestMessageCallback extends RequestMessageCallback {\n \n-\t\tPassThroughRequestMessageCallback(WebServiceMessageCallback requestCallback, Message<?> requestMessage) {\n+\t\tPassThroughRequestMessageCallback(@Nullable WebServiceMessageCallback requestCallback, Message<?> requestMessage) {\n \t\t\tsuper(requestCallback, requestMessage);\n \t\t}\n \n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/SimpleWebServiceOutboundGateway.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/SimpleWebServiceOutboundGateway.java\nindex d5185e1a023..216820fcbd7 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/SimpleWebServiceOutboundGateway.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/SimpleWebServiceOutboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -25,9 +25,9 @@\n import javax.xml.transform.dom.DOMResult;\n import javax.xml.transform.dom.DOMSource;\n \n+import org.jspecify.annotations.Nullable;\n import org.w3c.dom.Document;\n \n-import org.springframework.lang.Nullable;\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessagingException;\n import org.springframework.util.Assert;\n@@ -49,6 +49,7 @@\n  * @author Oleg Zhurakousky\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Jooyoung Pyoung\n  */\n public class SimpleWebServiceOutboundGateway extends AbstractWebServiceOutboundGateway {\n \n@@ -68,8 +69,7 @@ public SimpleWebServiceOutboundGateway(DestinationProvider destinationProvider,\n \n \tpublic SimpleWebServiceOutboundGateway(DestinationProvider destinationProvider,\n \t\t\t@Nullable SourceExtractor<?> sourceExtractor,\n-\t\t\tWebServiceMessageFactory messageFactory) {\n-\n+\t\t\t@Nullable WebServiceMessageFactory messageFactory) {\n \t\tsuper(destinationProvider, messageFactory);\n \t\tthis.sourceExtractor = (sourceExtractor != null) ? sourceExtractor : new DefaultSourceExtractor();\n \t}\n@@ -82,8 +82,8 @@ public SimpleWebServiceOutboundGateway(String uri, SourceExtractor<?> sourceExtr\n \t\tthis(uri, sourceExtractor, null);\n \t}\n \n-\tpublic SimpleWebServiceOutboundGateway(String uri, @Nullable SourceExtractor<?> sourceExtractor,\n-\t\t\tWebServiceMessageFactory messageFactory) {\n+\tpublic SimpleWebServiceOutboundGateway(@Nullable String uri, @Nullable SourceExtractor<?> sourceExtractor,\n+\t\t\t@Nullable WebServiceMessageFactory messageFactory) {\n \n \t\tsuper(uri, messageFactory);\n \t\tthis.sourceExtractor = (sourceExtractor != null) ? sourceExtractor : new DefaultSourceExtractor();\n@@ -107,8 +107,8 @@ public String getComponentType() {\n \t}\n \n \t@Override\n-\tprotected Object doHandle(String uri, final Message<?> requestMessage,\n-\t\t\tfinal WebServiceMessageCallback requestCallback) {\n+\tprotected @Nullable Object doHandle(String uri, final Message<?> requestMessage,\n+\t\t\tfinal @Nullable WebServiceMessageCallback requestCallback) {\n \n \t\tObject requestPayload = requestMessage.getPayload();\n \t\tResult responseResultInstance = null;\n@@ -126,7 +126,7 @@ else if (requestPayload instanceof Document) {\n \n \tprivate final class SimpleRequestMessageCallback extends RequestMessageCallback {\n \n-\t\tSimpleRequestMessageCallback(WebServiceMessageCallback requestCallback, Message<?> requestMessage) {\n+\t\tSimpleRequestMessageCallback(@Nullable WebServiceMessageCallback requestCallback, Message<?> requestMessage) {\n \t\t\tsuper(requestCallback, requestMessage);\n \t\t}\n \n@@ -134,13 +134,16 @@ private final class SimpleRequestMessageCallback extends RequestMessageCallback\n \t\tpublic void doWithMessageInternal(WebServiceMessage message, Object payload)\n \t\t\t\tthrows IOException, TransformerException {\n \t\t\tSource source = this.extractSource(payload);\n+\t\t\tif (source == null) {\n+\t\t\t\tsource = new DOMSource();\n+\t\t\t}\n \t\t\ttransform(source, message.getPayloadResult());\n \t\t\tif (message instanceof MimeMessage && payload instanceof MimeMessage) {\n \t\t\t\tcopyAttachments((MimeMessage) payload, (MimeMessage) message);\n \t\t\t}\n \t\t}\n \n-\t\tprivate Source extractSource(Object requestPayload) throws IOException, TransformerException {\n+\t\tprivate @Nullable Source extractSource(Object requestPayload) throws IOException, TransformerException {\n \t\t\tSource source = null;\n \n \t\t\tif (requestPayload instanceof Source) {\n@@ -181,14 +184,14 @@ private void copyAttachments(MimeMessage source, MimeMessage target) {\n \n \tprivate final class SimpleResponseMessageExtractor extends ResponseMessageExtractor {\n \n-\t\tprivate final Result result;\n+\t\tprivate final @Nullable Result result;\n \n-\t\tSimpleResponseMessageExtractor(Result result) {\n+\t\tSimpleResponseMessageExtractor(@Nullable Result result) {\n \t\t\tthis.result = result;\n \t\t}\n \n \t\t@Override\n-\t\tpublic Object doExtractData(WebServiceMessage message) throws TransformerException {\n+\t\tpublic @Nullable Object doExtractData(WebServiceMessage message) throws TransformerException {\n \t\t\tif (!SimpleWebServiceOutboundGateway.this.extractPayload) {\n \t\t\t\treturn message;\n \t\t\t}\n@@ -220,10 +223,13 @@ private static class DefaultSourceExtractor extends TransformerObjectSupport imp\n \t\t}\n \n \t\t@Override\n-\t\tpublic DOMSource extractData(Source source) throws TransformerException {\n+\t\tpublic @Nullable DOMSource extractData(@Nullable Source source) throws TransformerException {\n \t\t\tif (source instanceof DOMSource) {\n \t\t\t\treturn (DOMSource) source;\n \t\t\t}\n+\t\t\telse if (source == null) {\n+\t\t\t\treturn new DOMSource();\n+\t\t\t}\n \t\t\tDOMResult result = new DOMResult();\n \t\t\tthis.transform(source, result);\n \t\t\treturn new DOMSource(result.getNode());\n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/config/package-info.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/config/package-info.java\nindex d89a5edf0a6..d0742368f6c 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/config/package-info.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/config/package-info.java\n@@ -1,4 +1,5 @@\n /**\n  * Contains parser classes for the Web Services namespace support.\n  */\n+@org.jspecify.annotations.NullMarked\n package org.springframework.integration.ws.config;\n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/BaseWsOutboundGatewaySpec.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/BaseWsOutboundGatewaySpec.java\nindex c5d37417eba..02afeae0f2a 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/BaseWsOutboundGatewaySpec.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/BaseWsOutboundGatewaySpec.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2021 the original author or authors.\n+ * Copyright 2020-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,6 +19,8 @@\n import java.util.HashMap;\n import java.util.Map;\n \n+import org.jspecify.annotations.Nullable;\n+\n import org.springframework.expression.Expression;\n import org.springframework.integration.JavaUtils;\n import org.springframework.integration.dsl.MessageHandlerSpec;\n@@ -51,27 +53,28 @@ public abstract class BaseWsOutboundGatewaySpec<\n \n \tprivate final Map<String, Expression> uriVariableExpressions = new HashMap<>();\n \n+\t@SuppressWarnings(\"NullAway.Init\")\n \tprotected WebServiceTemplate template; // NOSONAR\n \n-\tprotected DestinationProvider destinationProvider; // NOSONAR\n+\tprotected @Nullable DestinationProvider destinationProvider; // NOSONAR\n \n-\tprotected String uri; // NOSONAR\n+\tprotected @Nullable String uri; // NOSONAR\n \n-\tprotected WebServiceMessageFactory webServiceMessageFactory; // NOSONAR\n+\tprotected @Nullable WebServiceMessageFactory webServiceMessageFactory; // NOSONAR\n \n-\tprivate SoapHeaderMapper headerMapper;\n+\tprivate @Nullable SoapHeaderMapper headerMapper;\n \n-\tprivate DefaultUriBuilderFactory.EncodingMode encodingMode;\n+\tprivate DefaultUriBuilderFactory.@Nullable EncodingMode encodingMode;\n \n \tprivate boolean ignoreEmptyResponses = true;\n \n-\tprivate WebServiceMessageCallback requestCallback;\n+\tprivate @Nullable WebServiceMessageCallback requestCallback;\n \n-\tprotected FaultMessageResolver faultMessageResolver; // NOSONAR\n+\tprotected @Nullable FaultMessageResolver faultMessageResolver; // NOSONAR\n \n-\tprotected WebServiceMessageSender[] messageSenders; // NOSONAR\n+\tprotected WebServiceMessageSender @Nullable [] messageSenders; // NOSONAR\n \n-\tprotected ClientInterceptor[] gatewayInterceptors; // NOSONAR\n+\tprotected ClientInterceptor @Nullable [] gatewayInterceptors; // NOSONAR\n \n \tprotected boolean extractPayload = true; // NOSONAR\n \n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/MarshallingWsOutboundGatewaySpec.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/MarshallingWsOutboundGatewaySpec.java\nindex c78920ccd75..544efab8918 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/MarshallingWsOutboundGatewaySpec.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/MarshallingWsOutboundGatewaySpec.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2021 the original author or authors.\n+ * Copyright 2020-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,10 +18,13 @@\n \n import java.util.Arrays;\n \n+import org.jspecify.annotations.Nullable;\n+\n import org.springframework.integration.JavaUtils;\n import org.springframework.integration.ws.MarshallingWebServiceOutboundGateway;\n import org.springframework.oxm.Marshaller;\n import org.springframework.oxm.Unmarshaller;\n+import org.springframework.oxm.jaxb.Jaxb2Marshaller;\n import org.springframework.ws.WebServiceMessageFactory;\n import org.springframework.ws.client.core.FaultMessageResolver;\n import org.springframework.ws.client.core.WebServiceTemplate;\n@@ -63,9 +66,9 @@ public static class MarshallingWsOutboundGatewayNoTemplateSpec\n \t\t\textends BaseWsOutboundGatewaySpec<MarshallingWsOutboundGatewayNoTemplateSpec,\n \t\t\tMarshallingWebServiceOutboundGateway> {\n \n-\t\tprotected Marshaller gatewayMarshaller; // NOSONAR\n+\t\tprotected Marshaller gatewayMarshaller = new Jaxb2Marshaller();\n \n-\t\tprotected Unmarshaller gatewayUnmarshaller; // NOSONAR\n+\t\tprotected @Nullable Unmarshaller gatewayUnmarshaller; // NOSONAR\n \n \t\t/**\n \t\t * Configure the marshaller to use.\n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/SimpleWsOutboundGatewaySpec.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/SimpleWsOutboundGatewaySpec.java\nindex fb584394ed2..0fbc9b3b280 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/SimpleWsOutboundGatewaySpec.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/SimpleWsOutboundGatewaySpec.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2024 the original author or authors.\n+ * Copyright 2020-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,9 +18,10 @@\n \n import java.util.Arrays;\n \n+import org.jspecify.annotations.Nullable;\n+\n import org.springframework.integration.JavaUtils;\n import org.springframework.integration.ws.SimpleWebServiceOutboundGateway;\n-import org.springframework.lang.Nullable;\n import org.springframework.ws.WebServiceMessageFactory;\n import org.springframework.ws.client.core.FaultMessageResolver;\n import org.springframework.ws.client.core.SourceExtractor;\n@@ -40,8 +41,7 @@\n public class SimpleWsOutboundGatewaySpec\n \t\textends BaseWsOutboundGatewaySpec<SimpleWsOutboundGatewaySpec, SimpleWebServiceOutboundGateway> {\n \n-\t@Nullable\n-\tprotected SourceExtractor<?> sourceExtractor; // NOSONAR\n+\tprotected @Nullable SourceExtractor<?> sourceExtractor; // NOSONAR\n \n \tprotected SimpleWsOutboundGatewaySpec(WebServiceTemplate template) {\n \t\tthis.template = template;\n@@ -100,6 +100,7 @@ protected SimpleWebServiceOutboundGateway create() {\n \tpublic static class SimpleWsOutboundGatewayNoTemplateSpec\n \t\t\textends BaseWsOutboundGatewaySpec<SimpleWsOutboundGatewayNoTemplateSpec, SimpleWebServiceOutboundGateway> {\n \n+\t\t@Nullable\n \t\tprotected SourceExtractor<?> sourceExtractor; // NOSONAR\n \n \t\tprivate boolean extractPayload = true;\n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/package-info.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/package-info.java\nindex b10046610d9..c77e7a4ab5a 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/package-info.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/dsl/package-info.java\n@@ -1,5 +1,5 @@\n /**\n  * Contains classes for DSL support.\n  */\n-@org.springframework.lang.NonNullApi\n+@org.jspecify.annotations.NullMarked\n package org.springframework.integration.ws.dsl;\n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/package-info.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/package-info.java\nindex 3c8070775dd..d78697a966e 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/package-info.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/package-info.java\n@@ -2,4 +2,5 @@\n  * Provides several inbound and outbound Web Service components. Also contains\n  * support classes (e.g. Header Mapper)\n  */\n+@org.jspecify.annotations.NullMarked\n package org.springframework.integration.ws;\n",
    "test_patch": "diff --git a/spring-integration-ws/src/test/java/org/springframework/integration/ws/config/WebServiceOutboundGatewayParserTests.java b/spring-integration-ws/src/test/java/org/springframework/integration/ws/config/WebServiceOutboundGatewayParserTests.java\nindex f9559e64105..c366bbe0be5 100644\n--- a/spring-integration-ws/src/test/java/org/springframework/integration/ws/config/WebServiceOutboundGatewayParserTests.java\n+++ b/spring-integration-ws/src/test/java/org/springframework/integration/ws/config/WebServiceOutboundGatewayParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-10088",
    "pr_id": 10088,
    "issue_id": 10069,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Mitigate `warning: [this-escape]` in the project\nRecently we have upgraded our build tool chain to Java `24`.\nEven if we still target for Java `17`, we need the latest Java for a proper nullability support.\nAs a side effect we got a lot of compilation warnings.\nOne of them is:\n```\n warning: [deprecation] Locale(String,String) in Locale has been deprecated \n```\n\nThe goal of this issue is to mitigate such a warning this or other way.\nIn most cases I anticipate it can only be resolved with `@SuppressWarnings(\"this-escape\")`.",
    "issue_word_count": 90,
    "test_files_count": 5,
    "non_test_files_count": 62,
    "pr_changed_files": [
      "spring-integration-amqp/src/main/java/org/springframework/integration/amqp/inbound/AmqpInboundChannelAdapter.java",
      "spring-integration-amqp/src/main/java/org/springframework/integration/amqp/inbound/AmqpInboundGateway.java",
      "spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AmqpOutboundEndpoint.java",
      "spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AsyncAmqpOutboundGateway.java",
      "spring-integration-amqp/src/main/java/org/springframework/integration/amqp/support/DefaultAmqpHeaderMapper.java",
      "spring-integration-cassandra/src/main/java/org/springframework/integration/cassandra/outbound/CassandraMessageHandler.java",
      "spring-integration-core/src/main/java/org/springframework/integration/aop/PublisherAnnotationAdvisor.java",
      "spring-integration-core/src/main/java/org/springframework/integration/channel/MessagePublishingErrorHandler.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/TransformerFactoryBean.java",
      "spring-integration-core/src/main/java/org/springframework/integration/config/xml/StandardHeaderEnricherParser.java",
      "spring-integration-core/src/main/java/org/springframework/integration/core/MessagingTemplate.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dispatcher/AggregateMessageDeliveryException.java",
      "spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowExtension.java",
      "spring-integration-core/src/main/java/org/springframework/integration/endpoint/AbstractPollingEndpoint.java",
      "spring-integration-core/src/main/java/org/springframework/integration/endpoint/EventDrivenConsumer.java",
      "spring-integration-core/src/main/java/org/springframework/integration/endpoint/MessageProducerSupport.java",
      "spring-integration-core/src/main/java/org/springframework/integration/filter/SimpleExpressionEvaluatingSelector.java",
      "spring-integration-core/src/main/java/org/springframework/integration/handler/DelayHandler.java",
      "spring-integration-core/src/main/java/org/springframework/integration/handler/ExpressionEvaluatingMessageHandler.java",
      "spring-integration-core/src/main/java/org/springframework/integration/handler/advice/ErrorMessageSendingRecoverer.java",
      "spring-integration-core/src/main/java/org/springframework/integration/mapping/AbstractHeaderMapper.java",
      "spring-integration-core/src/main/java/org/springframework/integration/router/ExpressionEvaluatingRouter.java",
      "spring-integration-core/src/main/java/org/springframework/integration/splitter/ExpressionEvaluatingSplitter.java",
      "spring-integration-core/src/main/java/org/springframework/integration/store/SimpleMessageStore.java",
      "spring-integration-core/src/main/java/org/springframework/integration/support/json/ErrorMessageJacksonDeserializer.java",
      "spring-integration-core/src/main/java/org/springframework/integration/transaction/TransactionHandleMessageAdvice.java",
      "spring-integration-core/src/main/java/org/springframework/integration/transformer/MessageTransformingHandler.java",
      "spring-integration-core/src/main/java/org/springframework/integration/transformer/PayloadDeserializingTransformer.java",
      "spring-integration-core/src/main/java/org/springframework/integration/transformer/PayloadSerializingTransformer.java",
      "spring-integration-event/src/main/java/org/springframework/integration/event/inbound/ApplicationEventListeningMessageProducer.java",
      "spring-integration-file/src/main/java/org/springframework/integration/file/remote/gateway/AbstractRemoteFileOutboundGateway.java",
      "spring-integration-file/src/main/java/org/springframework/integration/file/splitter/FileSplitter.java",
      "spring-integration-file/src/test/java/org/springframework/integration/file/config/ChainElementsTests.java",
      "spring-integration-file/src/test/java/org/springframework/integration/file/remote/StreamingInboundTests.java",
      "spring-integration-file/src/test/java/org/springframework/integration/file/tail/TailCondition.java",
      "spring-integration-ftp/src/main/java/org/springframework/integration/ftp/gateway/FtpOutboundGateway.java",
      "spring-integration-ftp/src/main/java/org/springframework/integration/ftp/inbound/FtpInboundFileSynchronizer.java",
      "spring-integration-ftp/src/main/java/org/springframework/integration/ftp/inbound/FtpStreamingMessageSource.java",
      "spring-integration-graphql/src/main/java/org/springframework/integration/graphql/outbound/GraphQlMessageHandler.java",
      "spring-integration-jms/src/main/java/org/springframework/integration/jms/JmsMessageDrivenEndpoint.java",
      "spring-integration-jms/src/main/java/org/springframework/integration/jms/config/JmsHeaderEnricherParser.java",
      "spring-integration-jmx/src/main/java/org/springframework/integration/monitor/IntegrationMBeanExporter.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaErrorSendingMessageRecoverer.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundGateway.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageDrivenChannelAdapter.java",
      "spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java",
      "spring-integration-mail/src/main/java/org/springframework/integration/mail/ImapMailReceiver.java",
      "spring-integration-mail/src/main/java/org/springframework/integration/mail/Pop3MailReceiver.java",
      "spring-integration-mail/src/main/java/org/springframework/integration/mail/config/MailHeaderEnricherParser.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java",
      "spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java",
      "spring-integration-redis/src/main/java/org/springframework/integration/redis/inbound/ReactiveRedisStreamMessageProducer.java",
      "spring-integration-rsocket/src/main/java/org/springframework/integration/rsocket/outbound/RSocketOutboundGateway.java",
      "spring-integration-sftp/src/main/java/org/springframework/integration/sftp/gateway/SftpOutboundGateway.java",
      "spring-integration-sftp/src/main/java/org/springframework/integration/sftp/inbound/SftpInboundFileSynchronizer.java",
      "spring-integration-sftp/src/main/java/org/springframework/integration/sftp/inbound/SftpStreamingMessageSource.java",
      "spring-integration-sftp/src/main/java/org/springframework/integration/sftp/server/DirectoryCreatedEvent.java",
      "spring-integration-smb/src/main/java/org/springframework/integration/smb/inbound/SmbStreamingMessageSource.java",
      "spring-integration-smb/src/main/java/org/springframework/integration/smb/outbound/SmbOutboundGateway.java",
      "spring-integration-webflux/src/main/java/org/springframework/integration/webflux/outbound/WebFluxRequestExecutingMessageHandler.java",
      "spring-integration-websocket/src/main/java/org/springframework/integration/websocket/inbound/WebSocketInboundChannelAdapter.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceOutboundGateway.java",
      "spring-integration-ws/src/main/java/org/springframework/integration/ws/config/WebServiceHeaderEnricherParser.java",
      "spring-integration-xml/src/test/java/org/springframework/integration/xml/config/TestXmlApplicationContext.java",
      "spring-integration-xml/src/test/java/org/springframework/integration/xml/config/XmlPayloadValidatingFilterParserTests.java",
      "spring-integration-xmpp/src/main/java/org/springframework/integration/xmpp/config/XmppHeaderEnricherParser.java",
      "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-file/src/test/java/org/springframework/integration/file/config/ChainElementsTests.java",
      "spring-integration-file/src/test/java/org/springframework/integration/file/remote/StreamingInboundTests.java",
      "spring-integration-file/src/test/java/org/springframework/integration/file/tail/TailCondition.java",
      "spring-integration-xml/src/test/java/org/springframework/integration/xml/config/TestXmlApplicationContext.java",
      "spring-integration-xml/src/test/java/org/springframework/integration/xml/config/XmlPayloadValidatingFilterParserTests.java"
    ],
    "base_commit": "bf9d3910cb0437cff62d8b46ef79c7a455cc23b3",
    "head_commit": "ed7069b5b3a11d3cc7b34332b0374c58baaa919c",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/10088",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/10088",
    "dockerfile": "",
    "pr_merged_at": "2025-06-09T15:53:17.000Z",
    "patch": "diff --git a/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/inbound/AmqpInboundChannelAdapter.java b/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/inbound/AmqpInboundChannelAdapter.java\nindex 7f8a9c1ef9d..726391f93ae 100644\n--- a/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/inbound/AmqpInboundChannelAdapter.java\n+++ b/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/inbound/AmqpInboundChannelAdapter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -130,6 +130,7 @@ public enum BatchMode {\n \t * Construct an instance using the provided container.\n \t * @param listenerContainer the container.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic AmqpInboundChannelAdapter(MessageListenerContainer listenerContainer) {\n \t\tAssert.notNull(listenerContainer, \"listenerContainer must not be null\");\n \t\tAssert.isNull(listenerContainer.getMessageListener(),\n\ndiff --git a/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/inbound/AmqpInboundGateway.java b/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/inbound/AmqpInboundGateway.java\nindex 4a708885eee..f741898169c 100644\n--- a/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/inbound/AmqpInboundGateway.java\n+++ b/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/inbound/AmqpInboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -98,6 +98,7 @@ public class AmqpInboundGateway extends MessagingGatewaySupport {\n \n \tprivate boolean replyHeadersMappedLast;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic AmqpInboundGateway(AbstractMessageListenerContainer listenerContainer) {\n \t\tthis(listenerContainer, new RabbitTemplate(listenerContainer.getConnectionFactory()), false);\n \t}\n@@ -108,10 +109,12 @@ public AmqpInboundGateway(AbstractMessageListenerContainer listenerContainer) {\n \t * @param listenerContainer the {@link MessageListenerContainer} to receive AMQP messages.\n \t * @param amqpTemplate the {@link AmqpTemplate} to send reply messages.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic AmqpInboundGateway(MessageListenerContainer listenerContainer, AmqpTemplate amqpTemplate) {\n \t\tthis(listenerContainer, amqpTemplate, true);\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tprivate AmqpInboundGateway(MessageListenerContainer listenerContainer, AmqpTemplate amqpTemplate,\n \t\t\tboolean amqpTemplateExplicitlySet) {\n \n\ndiff --git a/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AmqpOutboundEndpoint.java b/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AmqpOutboundEndpoint.java\nindex a66f47ec5cd..e9b6a892ed9 100644\n--- a/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AmqpOutboundEndpoint.java\n+++ b/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AmqpOutboundEndpoint.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -65,6 +65,7 @@ public class AmqpOutboundEndpoint extends AbstractAmqpOutboundEndpoint\n \n \tprivate boolean multiSend;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic AmqpOutboundEndpoint(AmqpTemplate amqpTemplate) {\n \t\tAssert.notNull(amqpTemplate, \"amqpTemplate must not be null\");\n \t\tthis.amqpTemplate = amqpTemplate;\n\ndiff --git a/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AsyncAmqpOutboundGateway.java b/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AsyncAmqpOutboundGateway.java\nindex d86665980ce..c215ca42eff 100644\n--- a/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AsyncAmqpOutboundGateway.java\n+++ b/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/outbound/AsyncAmqpOutboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2022 the original author or authors.\n+ * Copyright 2016-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -52,6 +52,7 @@ public class AsyncAmqpOutboundGateway extends AbstractAmqpOutboundEndpoint {\n \n \tprivate final MessageConverter messageConverter;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic AsyncAmqpOutboundGateway(AsyncRabbitTemplate template) {\n \t\tAssert.notNull(template, \"AsyncRabbitTemplate cannot be null\");\n \t\tthis.template = template;\n\ndiff --git a/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/support/DefaultAmqpHeaderMapper.java b/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/support/DefaultAmqpHeaderMapper.java\nindex 6b5e3416666..9544351af66 100644\n--- a/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/support/DefaultAmqpHeaderMapper.java\n+++ b/spring-integration-amqp/src/main/java/org/springframework/integration/amqp/support/DefaultAmqpHeaderMapper.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -91,6 +91,7 @@ public class DefaultAmqpHeaderMapper extends AbstractHeaderMapper<MessagePropert\n \t\tSTANDARD_HEADER_NAMES.add(AmqpHeaders.SPRING_REPLY_TO_STACK);\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tprotected DefaultAmqpHeaderMapper(String[] requestHeaderNames, String[] replyHeaderNames) {\n \t\tsuper(AmqpHeaders.PREFIX, STANDARD_HEADER_NAMES, STANDARD_HEADER_NAMES);\n \t\tif (requestHeaderNames != null) {\n\ndiff --git a/spring-integration-cassandra/src/main/java/org/springframework/integration/cassandra/outbound/CassandraMessageHandler.java b/spring-integration-cassandra/src/main/java/org/springframework/integration/cassandra/outbound/CassandraMessageHandler.java\nindex c902806b35a..76ac5d6a667 100644\n--- a/spring-integration-cassandra/src/main/java/org/springframework/integration/cassandra/outbound/CassandraMessageHandler.java\n+++ b/spring-integration-cassandra/src/main/java/org/springframework/integration/cassandra/outbound/CassandraMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2022-2024 the original author or authors.\n+ * Copyright 2022-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -93,6 +93,7 @@ public CassandraMessageHandler(ReactiveCassandraOperations cassandraOperations)\n \t\tthis(cassandraOperations, Type.INSERT);\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic CassandraMessageHandler(ReactiveCassandraOperations cassandraOperations,\n \t\t\tCassandraMessageHandler.Type queryType) {\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/aop/PublisherAnnotationAdvisor.java b/spring-integration-core/src/main/java/org/springframework/integration/aop/PublisherAnnotationAdvisor.java\nindex 3e8732a7418..2a015e96396 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/aop/PublisherAnnotationAdvisor.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/aop/PublisherAnnotationAdvisor.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -42,6 +42,7 @@\n  * @author Mark Fisher\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Jooyoung Pyoung\n  *\n  * @since 2.0\n  */\n@@ -51,7 +52,7 @@ public class PublisherAnnotationAdvisor extends AbstractPointcutAdvisor implemen\n \n \tprivate final transient MessagePublishingInterceptor interceptor;\n \n-\tprivate final Pointcut pointcut;\n+\tprivate final transient Pointcut pointcut;\n \n \tpublic PublisherAnnotationAdvisor() {\n \t\tthis(Publisher.class);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/channel/MessagePublishingErrorHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/channel/MessagePublishingErrorHandler.java\nindex e575f25b308..df0c2f411f1 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/channel/MessagePublishingErrorHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/channel/MessagePublishingErrorHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -53,11 +53,13 @@ public class MessagePublishingErrorHandler extends ErrorMessagePublisher impleme\n \t\t}\n \t};\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic MessagePublishingErrorHandler() {\n \t\tsetErrorMessageStrategy(DEFAULT_ERROR_MESSAGE_STRATEGY);\n \t\tsetSendTimeout(DEFAULT_SEND_TIMEOUT);\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic MessagePublishingErrorHandler(DestinationResolver<MessageChannel> channelResolver) {\n \t\tthis();\n \t\tsetChannelResolver(channelResolver);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/TransformerFactoryBean.java b/spring-integration-core/src/main/java/org/springframework/integration/config/TransformerFactoryBean.java\nindex 5bf942003b1..83d1d511fbe 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/TransformerFactoryBean.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/TransformerFactoryBean.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -37,6 +37,7 @@\n  */\n public class TransformerFactoryBean extends AbstractStandardMessageHandlerFactoryBean {\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic TransformerFactoryBean() {\n \t\tsetRequiresReply(true);\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/config/xml/StandardHeaderEnricherParser.java b/spring-integration-core/src/main/java/org/springframework/integration/config/xml/StandardHeaderEnricherParser.java\nindex 362ef6bfd8b..30084570037 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/config/xml/StandardHeaderEnricherParser.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/config/xml/StandardHeaderEnricherParser.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -40,6 +40,7 @@\n  */\n public class StandardHeaderEnricherParser extends HeaderEnricherParserSupport {\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic StandardHeaderEnricherParser() {\n \t\taddElementToHeaderMapping(\"reply-channel\", MessageHeaders.REPLY_CHANNEL);\n \t\taddElementToHeaderMapping(\"error-channel\", MessageHeaders.ERROR_CHANNEL);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/core/MessagingTemplate.java b/spring-integration-core/src/main/java/org/springframework/integration/core/MessagingTemplate.java\nindex e4dcca64aad..5b4e711fc34 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/core/MessagingTemplate.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/core/MessagingTemplate.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2023 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -58,6 +58,7 @@ public MessagingTemplate() {\n \t * Create a MessagingTemplate with the given default channel.\n \t * @param defaultChannel the default {@link MessageChannel} for {@code send} operations\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic MessagingTemplate(MessageChannel defaultChannel) {\n \t\tsuper.setDefaultDestination(defaultChannel);\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/AggregateMessageDeliveryException.java b/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/AggregateMessageDeliveryException.java\nindex 84f0bddd725..a182882bf91 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/AggregateMessageDeliveryException.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dispatcher/AggregateMessageDeliveryException.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -38,6 +38,7 @@ public class AggregateMessageDeliveryException extends MessageDeliveryException\n \n \tprivate final List<? extends Exception> aggregatedExceptions;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic AggregateMessageDeliveryException(Message<?> undeliveredMessage,\n \t\t\tString description, List<? extends Exception> aggregatedExceptions) {\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowExtension.java b/spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowExtension.java\nindex 483fa231555..110688071af 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowExtension.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/dsl/IntegrationFlowExtension.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2021 the original author or authors.\n+ * Copyright 2020-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -66,6 +66,7 @@ public abstract class IntegrationFlowExtension<B extends IntegrationFlowExtensio\n \n \tprivate final DirectChannel inputChannel = new DirectChannel();\n \n+\t@SuppressWarnings(\"this-escape\")\n \tprotected IntegrationFlowExtension() {\n \t\tchannel(this.inputChannel);\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/AbstractPollingEndpoint.java b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/AbstractPollingEndpoint.java\nindex 05a68e88ca7..66bd5adef8c 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/AbstractPollingEndpoint.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/AbstractPollingEndpoint.java\n@@ -122,6 +122,7 @@ public abstract class AbstractPollingEndpoint extends AbstractEndpoint implement\n \n \tprivate volatile boolean initialized;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic AbstractPollingEndpoint() {\n \t\tthis.setPhase(Integer.MAX_VALUE / 2);\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/EventDrivenConsumer.java b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/EventDrivenConsumer.java\nindex f854d7c952b..b7a0347eb64 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/EventDrivenConsumer.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/EventDrivenConsumer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -40,6 +40,7 @@ public class EventDrivenConsumer extends AbstractEndpoint implements Integration\n \n \tprivate final MessageHandler handler;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic EventDrivenConsumer(SubscribableChannel inputChannel, MessageHandler handler) {\n \t\tAssert.notNull(inputChannel, \"inputChannel must not be null\");\n \t\tAssert.notNull(handler, \"handler must not be null\");\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/MessageProducerSupport.java b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/MessageProducerSupport.java\nindex cf5dd074a64..bbef5cf7e2b 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/endpoint/MessageProducerSupport.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/endpoint/MessageProducerSupport.java\n@@ -80,6 +80,7 @@ public abstract class MessageProducerSupport extends AbstractEndpoint\n \n \tprivate volatile Subscription subscription;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tprotected MessageProducerSupport() {\n \t\tsetPhase(Integer.MAX_VALUE / 2);\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/filter/SimpleExpressionEvaluatingSelector.java b/spring-integration-core/src/main/java/org/springframework/integration/filter/SimpleExpressionEvaluatingSelector.java\nindex 22e9155c363..08a8bcf8f16 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/filter/SimpleExpressionEvaluatingSelector.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/filter/SimpleExpressionEvaluatingSelector.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2024 the original author or authors.\n+ * Copyright 2024-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -34,12 +34,14 @@ public class SimpleExpressionEvaluatingSelector extends AbstractMessageProcessin\n \n \tprivate final String expressionString;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic SimpleExpressionEvaluatingSelector(String expressionString) {\n \t\tsuper(new ExpressionEvaluatingMessageProcessor<>(expressionString, Boolean.class));\n \t\t((ExpressionEvaluatingMessageProcessor<?>) getMessageProcessor()).setSimpleEvaluationContext(true);\n \t\tthis.expressionString = expressionString;\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic SimpleExpressionEvaluatingSelector(Expression expression) {\n \t\tsuper(new ExpressionEvaluatingMessageProcessor<>(expression, Boolean.class));\n \t\t((ExpressionEvaluatingMessageProcessor<?>) getMessageProcessor()).setSimpleEvaluationContext(true);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/handler/DelayHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/handler/DelayHandler.java\nindex 96da2c3861b..bddb4b40f7a 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/handler/DelayHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/handler/DelayHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -170,6 +170,7 @@ public DelayHandler(String messageGroupId) {\n \t * @param messageGroupId The message group identifier.\n \t * @param taskScheduler A task scheduler.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic DelayHandler(String messageGroupId, TaskScheduler taskScheduler) {\n \t\tthis(messageGroupId);\n \t\tsetTaskScheduler(taskScheduler);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/handler/ExpressionEvaluatingMessageHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/handler/ExpressionEvaluatingMessageHandler.java\nindex 90e6be1fcbd..f3cbd49b743 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/handler/ExpressionEvaluatingMessageHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/handler/ExpressionEvaluatingMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -37,6 +37,7 @@ public class ExpressionEvaluatingMessageHandler extends AbstractMessageHandler {\n \n \tprivate String componentType;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic ExpressionEvaluatingMessageHandler(Expression expression) {\n \t\tAssert.notNull(expression, \"'expression' must not be null\");\n \t\tthis.processor = new ExpressionEvaluatingMessageProcessor<>(expression, Void.class);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/handler/advice/ErrorMessageSendingRecoverer.java b/spring-integration-core/src/main/java/org/springframework/integration/handler/advice/ErrorMessageSendingRecoverer.java\nindex a1ee875e21c..66bb24b4abe 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/handler/advice/ErrorMessageSendingRecoverer.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/handler/advice/ErrorMessageSendingRecoverer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -70,6 +70,7 @@ public ErrorMessageSendingRecoverer(MessageChannel channel) {\n \t * {@link DefaultErrorMessageStrategy} is used.\n \t * @since 4.3.10\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic ErrorMessageSendingRecoverer(MessageChannel channel, ErrorMessageStrategy errorMessageStrategy) {\n \t\tsetChannel(channel);\n \t\tsetErrorMessageStrategy(\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/mapping/AbstractHeaderMapper.java b/spring-integration-core/src/main/java/org/springframework/integration/mapping/AbstractHeaderMapper.java\nindex 8156e6c6cdf..7759c58fe68 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/mapping/AbstractHeaderMapper.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/mapping/AbstractHeaderMapper.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -97,6 +97,7 @@ public abstract class AbstractHeaderMapper<T> implements RequestReplyHeaderMappe\n \t * @param requestHeaderNames the header names that should be mapped from a request to {@link MessageHeaders}\n \t * @param replyHeaderNames the header names that should be mapped to a response from {@link MessageHeaders}\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tprotected AbstractHeaderMapper(String standardHeaderPrefix,\n \t\t\tCollection<String> requestHeaderNames, Collection<String> replyHeaderNames) {\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/router/ExpressionEvaluatingRouter.java b/spring-integration-core/src/main/java/org/springframework/integration/router/ExpressionEvaluatingRouter.java\nindex 2b0422c3177..3986038471c 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/router/ExpressionEvaluatingRouter.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/router/ExpressionEvaluatingRouter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -42,6 +42,7 @@ public ExpressionEvaluatingRouter(String expressionString) {\n \t * Construct an instance with the supplied {@link Expression}.\n \t * @param expression the expression.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic ExpressionEvaluatingRouter(Expression expression) {\n \t\tsuper(new ExpressionEvaluatingMessageProcessor<Object>(expression));\n \t\tsetPrimaryExpression(expression);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/splitter/ExpressionEvaluatingSplitter.java b/spring-integration-core/src/main/java/org/springframework/integration/splitter/ExpressionEvaluatingSplitter.java\nindex 66eeb418608..29f8c9f452c 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/splitter/ExpressionEvaluatingSplitter.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/splitter/ExpressionEvaluatingSplitter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -31,7 +31,7 @@\n  */\n public class ExpressionEvaluatingSplitter extends AbstractMessageProcessingSplitter {\n \n-\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+\t@SuppressWarnings({\"unchecked\", \"rawtypes\", \"this-escape\"})\n \tpublic ExpressionEvaluatingSplitter(Expression expression) {\n \t\tsuper(new ExpressionEvaluatingMessageProcessor(expression));\n \t\tsetPrimaryExpression(expression);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/store/SimpleMessageStore.java b/spring-integration-core/src/main/java/org/springframework/integration/store/SimpleMessageStore.java\nindex 230b33cb484..ded03f5c95f 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/store/SimpleMessageStore.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/store/SimpleMessageStore.java\n@@ -120,6 +120,7 @@ public SimpleMessageStore(int individualCapacity, int groupCapacity, LockRegistr\n \t * @param lockRegistry       The lock registry.\n \t * @since 4.3\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic SimpleMessageStore(int individualCapacity, int groupCapacity, long upperBoundTimeout,\n \t\t\tLockRegistry lockRegistry) {\n \n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/support/json/ErrorMessageJacksonDeserializer.java b/spring-integration-core/src/main/java/org/springframework/integration/support/json/ErrorMessageJacksonDeserializer.java\nindex 04718afaf34..5632536c321 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/support/json/ErrorMessageJacksonDeserializer.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/support/json/ErrorMessageJacksonDeserializer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2017-2022 the original author or authors.\n+ * Copyright 2017-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -37,6 +37,7 @@ public class ErrorMessageJacksonDeserializer extends MessageJacksonDeserializer<\n \n \tprivate static final long serialVersionUID = 1L;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic ErrorMessageJacksonDeserializer() {\n \t\tsuper(ErrorMessage.class);\n \t\tsetPayloadType(TypeFactory.defaultInstance().constructType(Throwable.class));\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/transaction/TransactionHandleMessageAdvice.java b/spring-integration-core/src/main/java/org/springframework/integration/transaction/TransactionHandleMessageAdvice.java\nindex e812153f8bc..8119b37dbd4 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/transaction/TransactionHandleMessageAdvice.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/transaction/TransactionHandleMessageAdvice.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2020 the original author or authors.\n+ * Copyright 2016-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -46,6 +46,7 @@ public class TransactionHandleMessageAdvice extends TransactionInterceptor imple\n \tpublic TransactionHandleMessageAdvice() {\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic TransactionHandleMessageAdvice(TransactionManager transactionManager, Properties transactionAttributes) {\n \t\tsetTransactionManager(transactionManager);\n \t\tsetTransactionAttributes(transactionAttributes);\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/transformer/MessageTransformingHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/transformer/MessageTransformingHandler.java\nindex 96987516b97..2cd8b257a19 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/transformer/MessageTransformingHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/transformer/MessageTransformingHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2023 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -48,6 +48,7 @@ public class MessageTransformingHandler extends AbstractReplyProducingMessageHan\n \t * The target delegate {@link Transformer} must be provided then via setter.\n \t * @since 6.2\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic MessageTransformingHandler() {\n \t\tsetRequiresReply(true);\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/transformer/PayloadDeserializingTransformer.java b/spring-integration-core/src/main/java/org/springframework/integration/transformer/PayloadDeserializingTransformer.java\nindex 755f014cc03..6d002ba9861 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/transformer/PayloadDeserializingTransformer.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/transformer/PayloadDeserializingTransformer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -40,6 +40,7 @@ public class PayloadDeserializingTransformer extends PayloadTypeConvertingTransf\n \t * Instantiate based on the {@link AllowListDeserializingConverter} with the\n \t * {@link org.springframework.core.serializer.DefaultDeserializer}.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic PayloadDeserializingTransformer() {\n \t\tdoSetConverter(new AllowListDeserializingConverter());\n \t}\n\ndiff --git a/spring-integration-core/src/main/java/org/springframework/integration/transformer/PayloadSerializingTransformer.java b/spring-integration-core/src/main/java/org/springframework/integration/transformer/PayloadSerializingTransformer.java\nindex 1dcb0f3573d..1e1e308028c 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/transformer/PayloadSerializingTransformer.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/transformer/PayloadSerializingTransformer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -38,6 +38,7 @@ public class PayloadSerializingTransformer extends PayloadTypeConvertingTransfor\n \t * Instantiate based on the {@link SerializingConverter} with the\n \t * {@link org.springframework.core.serializer.DefaultSerializer}.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic PayloadSerializingTransformer() {\n \t\tdoSetConverter(new SerializingConverter());\n \t}\n\ndiff --git a/spring-integration-event/src/main/java/org/springframework/integration/event/inbound/ApplicationEventListeningMessageProducer.java b/spring-integration-event/src/main/java/org/springframework/integration/event/inbound/ApplicationEventListeningMessageProducer.java\nindex 8c30b34250e..60a5415d69d 100644\n--- a/spring-integration-event/src/main/java/org/springframework/integration/event/inbound/ApplicationEventListeningMessageProducer.java\n+++ b/spring-integration-event/src/main/java/org/springframework/integration/event/inbound/ApplicationEventListeningMessageProducer.java\n@@ -58,6 +58,7 @@ public class ApplicationEventListeningMessageProducer extends ExpressionMessageP\n \t/**\n \t * Construct an instance.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic ApplicationEventListeningMessageProducer() {\n \t\tsetPhase(Integer.MAX_VALUE / 2 - 1000); // NOSONAR magic number\n \t}\n\ndiff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/remote/gateway/AbstractRemoteFileOutboundGateway.java b/spring-integration-file/src/main/java/org/springframework/integration/file/remote/gateway/AbstractRemoteFileOutboundGateway.java\nindex f7f0fa1b614..20cde48eef4 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/remote/gateway/AbstractRemoteFileOutboundGateway.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/remote/gateway/AbstractRemoteFileOutboundGateway.java\n@@ -219,6 +219,7 @@ public AbstractRemoteFileOutboundGateway(RemoteFileTemplate<F> remoteFileTemplat\n \t * @param command the command.\n \t * @param expressionArg the remote path.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic AbstractRemoteFileOutboundGateway(RemoteFileTemplate<F> remoteFileTemplate, Command command,\n \t\t\t@Nullable String expressionArg) {\n \n\ndiff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/splitter/FileSplitter.java b/spring-integration-file/src/main/java/org/springframework/integration/file/splitter/FileSplitter.java\nindex 27344126951..dae9bb8f2ad 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/splitter/FileSplitter.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/splitter/FileSplitter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2015-2020 the original author or authors.\n+ * Copyright 2015-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -130,6 +130,7 @@ public FileSplitter(boolean iterator, boolean markers) {\n \t * @param markersJson when true, markers are represented as JSON.\n \t * @since 4.2.7\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic FileSplitter(boolean iterator, boolean markers, boolean markersJson) {\n \t\tthis.returnIterator = iterator;\n \t\tthis.markers = markers;\n\ndiff --git a/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/gateway/FtpOutboundGateway.java b/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/gateway/FtpOutboundGateway.java\nindex 089e0fd3103..4cf50233f71 100644\n--- a/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/gateway/FtpOutboundGateway.java\n+++ b/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/gateway/FtpOutboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -64,6 +64,7 @@ public class FtpOutboundGateway extends AbstractRemoteFileOutboundGateway<FTPFil\n \t * @param sessionFactory the session factory.\n \t * @param messageSessionCallback the callback.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic FtpOutboundGateway(SessionFactory<FTPFile> sessionFactory,\n \t\t\tMessageSessionCallback<FTPFile, ?> messageSessionCallback) {\n \n@@ -91,6 +92,7 @@ public FtpOutboundGateway(RemoteFileTemplate<FTPFile> remoteFileTemplate,\n \t * @param command the command.\n \t * @param expression the remote path expression.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic FtpOutboundGateway(SessionFactory<FTPFile> sessionFactory, String command, @Nullable String expression) {\n \t\tthis(new FtpRemoteFileTemplate(sessionFactory), command, expression);\n \t\t((FtpRemoteFileTemplate) getRemoteFileTemplate()).setExistsMode(FtpRemoteFileTemplate.ExistsMode.NLST);\n\ndiff --git a/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/inbound/FtpInboundFileSynchronizer.java b/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/inbound/FtpInboundFileSynchronizer.java\nindex 8ff99dc9c13..ef44d4cd943 100644\n--- a/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/inbound/FtpInboundFileSynchronizer.java\n+++ b/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/inbound/FtpInboundFileSynchronizer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -42,6 +42,7 @@ public class FtpInboundFileSynchronizer extends AbstractInboundFileSynchronizer<\n \t * {@link org.springframework.integration.file.remote.session.Session} instances.\n \t * @param sessionFactory The session factory.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic FtpInboundFileSynchronizer(SessionFactory<FTPFile> sessionFactory) {\n \t\tsuper(sessionFactory);\n \t\tdoSetRemoteDirectoryExpression(new LiteralExpression(null)); // NOSONAR - LE can actually handle null ok\n\ndiff --git a/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/inbound/FtpStreamingMessageSource.java b/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/inbound/FtpStreamingMessageSource.java\nindex 47f9f9f5605..4abf7373de6 100644\n--- a/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/inbound/FtpStreamingMessageSource.java\n+++ b/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/inbound/FtpStreamingMessageSource.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2019 the original author or authors.\n+ * Copyright 2016-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -56,6 +56,7 @@ public FtpStreamingMessageSource(RemoteFileTemplate<FTPFile> template) {\n \t * @param template the template.\n \t * @param comparator the comparator.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic FtpStreamingMessageSource(RemoteFileTemplate<FTPFile> template, Comparator<FTPFile> comparator) {\n \t\tsuper(template, comparator);\n \t\tdoSetFilter(new FtpPersistentAcceptOnceFileListFilter(new SimpleMetadataStore(), \"ftpStreamingMessageSource\"));\n\ndiff --git a/spring-integration-graphql/src/main/java/org/springframework/integration/graphql/outbound/GraphQlMessageHandler.java b/spring-integration-graphql/src/main/java/org/springframework/integration/graphql/outbound/GraphQlMessageHandler.java\nindex 58edacdf8d3..2b2646b51bc 100644\n--- a/spring-integration-graphql/src/main/java/org/springframework/integration/graphql/outbound/GraphQlMessageHandler.java\n+++ b/spring-integration-graphql/src/main/java/org/springframework/integration/graphql/outbound/GraphQlMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2022-2023 the original author or authors.\n+ * Copyright 2022-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -62,6 +62,7 @@ public class GraphQlMessageHandler extends AbstractReplyProducingMessageHandler\n \tprivate Expression executionIdExpression =\n \t\t\tnew FunctionExpression<Message<?>>(message -> message.getHeaders().getId());\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic GraphQlMessageHandler(ExecutionGraphQlService graphQlService) {\n \t\tAssert.notNull(graphQlService, \"'graphQlService' must not be null\");\n \t\tthis.graphQlService = graphQlService;\n\ndiff --git a/spring-integration-jms/src/main/java/org/springframework/integration/jms/JmsMessageDrivenEndpoint.java b/spring-integration-jms/src/main/java/org/springframework/integration/jms/JmsMessageDrivenEndpoint.java\nindex 6a2603daf0e..73ee4c9d46f 100644\n--- a/spring-integration-jms/src/main/java/org/springframework/integration/jms/JmsMessageDrivenEndpoint.java\n+++ b/spring-integration-jms/src/main/java/org/springframework/integration/jms/JmsMessageDrivenEndpoint.java\n@@ -59,6 +59,7 @@ public class JmsMessageDrivenEndpoint extends MessageProducerSupport implements\n \t * @param listenerContainer the container.\n \t * @param listener the listener.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic JmsMessageDrivenEndpoint(AbstractMessageListenerContainer listenerContainer,\n \t\t\tChannelPublishingJmsMessageListener listener) {\n \n@@ -74,6 +75,7 @@ public JmsMessageDrivenEndpoint(AbstractMessageListenerContainer listenerContain\n \t * @param externalContainer true if the container is externally configured and should not have its ack mode\n \t * coerced when no sessionAcknowledgeMode was supplied.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tprivate JmsMessageDrivenEndpoint(AbstractMessageListenerContainer listenerContainer,\n \t\t\tChannelPublishingJmsMessageListener listener, boolean externalContainer) {\n \n\ndiff --git a/spring-integration-jms/src/main/java/org/springframework/integration/jms/config/JmsHeaderEnricherParser.java b/spring-integration-jms/src/main/java/org/springframework/integration/jms/config/JmsHeaderEnricherParser.java\nindex d05362bb519..d93f1fd21ff 100644\n--- a/spring-integration-jms/src/main/java/org/springframework/integration/jms/config/JmsHeaderEnricherParser.java\n+++ b/spring-integration-jms/src/main/java/org/springframework/integration/jms/config/JmsHeaderEnricherParser.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -27,6 +27,7 @@\n  */\n public class JmsHeaderEnricherParser extends HeaderEnricherParserSupport {\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic JmsHeaderEnricherParser() {\n \t\tthis.addElementToHeaderMapping(\"correlation-id\", JmsHeaders.CORRELATION_ID);\n \t\tthis.addElementToHeaderMapping(\"reply-to\", JmsHeaders.REPLY_TO);\n\ndiff --git a/spring-integration-jmx/src/main/java/org/springframework/integration/monitor/IntegrationMBeanExporter.java b/spring-integration-jmx/src/main/java/org/springframework/integration/monitor/IntegrationMBeanExporter.java\nindex f8819780b3d..db72b898277 100644\n--- a/spring-integration-jmx/src/main/java/org/springframework/integration/monitor/IntegrationMBeanExporter.java\n+++ b/spring-integration-jmx/src/main/java/org/springframework/integration/monitor/IntegrationMBeanExporter.java\n@@ -153,6 +153,7 @@ public class IntegrationMBeanExporter extends MBeanExporter\n \n \tprivate volatile boolean singletonsInstantiated;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic IntegrationMBeanExporter() {\n \t\t// Shouldn't be necessary, but to be on the safe side...\n \t\tsetAutodetect(false);\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaErrorSendingMessageRecoverer.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaErrorSendingMessageRecoverer.java\nindex c591e6c4ae1..4149bee2c29 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaErrorSendingMessageRecoverer.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaErrorSendingMessageRecoverer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2022 the original author or authors.\n+ * Copyright 2022-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -52,6 +52,7 @@ public KafkaErrorSendingMessageRecoverer(MessageChannel channel) {\n \t * @param channel the channel.\n \t * @param errorMessageStrategy the strategy.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic KafkaErrorSendingMessageRecoverer(MessageChannel channel, ErrorMessageStrategy errorMessageStrategy) {\n \t\tsetChannel(channel);\n \t\tsetErrorMessageStrategy(errorMessageStrategy);\n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundGateway.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundGateway.java\nindex 7eebada4806..529454f7895 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundGateway.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaInboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018-2023 the original author or authors.\n+ * Copyright 2018-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -97,6 +97,7 @@ public class KafkaInboundGateway<K, V, R> extends MessagingGatewaySupport\n \t * @param messageListenerContainer the container.\n \t * @param kafkaTemplate the kafka template.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic KafkaInboundGateway(AbstractMessageListenerContainer<K, V> messageListenerContainer,\n \t\t\tKafkaTemplate<K, R> kafkaTemplate) {\n \n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageDrivenChannelAdapter.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageDrivenChannelAdapter.java\nindex 539d3becd5d..18b928aac5c 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageDrivenChannelAdapter.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/inbound/KafkaMessageDrivenChannelAdapter.java\n@@ -120,6 +120,7 @@ public KafkaMessageDrivenChannelAdapter(AbstractMessageListenerContainer<K, V> m\n \t * @param messageListenerContainer the container.\n \t * @param mode the mode.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic KafkaMessageDrivenChannelAdapter(AbstractMessageListenerContainer<K, V> messageListenerContainer,\n \t\t\tListenerMode mode) {\n \n\ndiff --git a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java\nindex 9883f195778..3498526d7c1 100644\n--- a/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java\n+++ b/spring-integration-kafka/src/main/java/org/springframework/integration/kafka/outbound/KafkaProducerMessageHandler.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2024 the original author or authors.\n+ * Copyright 2013-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -167,6 +167,7 @@ public class KafkaProducerMessageHandler<K, V> extends AbstractReplyProducingMes\n \n \tprivate volatile byte[] singleReplyTopic;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic KafkaProducerMessageHandler(final KafkaTemplate<K, V> kafkaTemplate) {\n \t\tAssert.notNull(kafkaTemplate, \"kafkaTemplate cannot be null\");\n \t\tthis.kafkaTemplate = kafkaTemplate;\n\ndiff --git a/spring-integration-mail/src/main/java/org/springframework/integration/mail/ImapMailReceiver.java b/spring-integration-mail/src/main/java/org/springframework/integration/mail/ImapMailReceiver.java\nindex 8eadb19f4dd..b7d145ac330 100755\n--- a/spring-integration-mail/src/main/java/org/springframework/integration/mail/ImapMailReceiver.java\n+++ b/spring-integration-mail/src/main/java/org/springframework/integration/mail/ImapMailReceiver.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -73,10 +73,12 @@ public class ImapMailReceiver extends AbstractMailReceiver {\n \n \tprivate volatile ScheduledFuture<?> pingTask;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic ImapMailReceiver() {\n \t\tsetProtocol(PROTOCOL);\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic ImapMailReceiver(String url) {\n \t\tsuper(url);\n \t\tif (url != null) {\n\ndiff --git a/spring-integration-mail/src/main/java/org/springframework/integration/mail/Pop3MailReceiver.java b/spring-integration-mail/src/main/java/org/springframework/integration/mail/Pop3MailReceiver.java\nindex 325ecb4a7bf..2318b7cb459 100755\n--- a/spring-integration-mail/src/main/java/org/springframework/integration/mail/Pop3MailReceiver.java\n+++ b/spring-integration-mail/src/main/java/org/springframework/integration/mail/Pop3MailReceiver.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -35,10 +35,12 @@ public class Pop3MailReceiver extends AbstractMailReceiver {\n \n \tpublic static final String PROTOCOL = \"pop3\";\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic Pop3MailReceiver() {\n \t\tsetProtocol(PROTOCOL);\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic Pop3MailReceiver(String url) {\n \t\tsuper(url);\n \t\tif (url != null) {\n\ndiff --git a/spring-integration-mail/src/main/java/org/springframework/integration/mail/config/MailHeaderEnricherParser.java b/spring-integration-mail/src/main/java/org/springframework/integration/mail/config/MailHeaderEnricherParser.java\nindex a2b7b5b47de..92d3b25b637 100644\n--- a/spring-integration-mail/src/main/java/org/springframework/integration/mail/config/MailHeaderEnricherParser.java\n+++ b/spring-integration-mail/src/main/java/org/springframework/integration/mail/config/MailHeaderEnricherParser.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -26,6 +26,7 @@\n  */\n public class MailHeaderEnricherParser extends HeaderEnricherParserSupport {\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic MailHeaderEnricherParser() {\n \t\tthis.addElementToHeaderMapping(\"subject\", MailHeaders.SUBJECT);\n \t\tthis.addElementToHeaderMapping(\"to\", MailHeaders.TO);\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java\nindex 0936bfadeb0..9f2f263dc3c 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv3ClientManager.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2022-2024 the original author or authors.\n+ * Copyright 2022-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -54,6 +54,7 @@ public Mqttv3ClientManager(String url, String clientId) {\n \t\tthis(buildDefaultConnectionOptions(url), clientId);\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic Mqttv3ClientManager(MqttConnectOptions connectionOptions, String clientId) {\n \t\tsuper(clientId);\n \t\tAssert.notNull(connectionOptions, \"'connectionOptions' is required\");\n\ndiff --git a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java\nindex 3bcbcca520d..eeb5f9ada59 100644\n--- a/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java\n+++ b/spring-integration-mqtt/src/main/java/org/springframework/integration/mqtt/core/Mqttv5ClientManager.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2022-2024 the original author or authors.\n+ * Copyright 2022-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -56,6 +56,7 @@ public Mqttv5ClientManager(String url, String clientId) {\n \t\tthis(buildDefaultConnectionOptions(url), clientId);\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic Mqttv5ClientManager(MqttConnectionOptions connectionOptions, String clientId) {\n \t\tsuper(clientId);\n \t\tAssert.notNull(connectionOptions, \"'connectionOptions' is required\");\n\ndiff --git a/spring-integration-redis/src/main/java/org/springframework/integration/redis/inbound/ReactiveRedisStreamMessageProducer.java b/spring-integration-redis/src/main/java/org/springframework/integration/redis/inbound/ReactiveRedisStreamMessageProducer.java\nindex 5ad255781cd..0e0a66840bb 100644\n--- a/spring-integration-redis/src/main/java/org/springframework/integration/redis/inbound/ReactiveRedisStreamMessageProducer.java\n+++ b/spring-integration-redis/src/main/java/org/springframework/integration/redis/inbound/ReactiveRedisStreamMessageProducer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2022 the original author or authors.\n+ * Copyright 2020-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -65,6 +65,7 @@ public class ReactiveRedisStreamMessageProducer extends MessageProducerSupport {\n \n \tprivate final String streamKey;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tprivate final StreamReceiver.StreamReceiverOptionsBuilder<String, ?> streamReceiverOptionsBuilder =\n \t\t\tStreamReceiver.StreamReceiverOptions.builder()\n \t\t\t\t\t.pollTimeout(Duration.ZERO)\n\ndiff --git a/spring-integration-rsocket/src/main/java/org/springframework/integration/rsocket/outbound/RSocketOutboundGateway.java b/spring-integration-rsocket/src/main/java/org/springframework/integration/rsocket/outbound/RSocketOutboundGateway.java\nindex 002fa0e45bc..0b1f45ce702 100644\n--- a/spring-integration-rsocket/src/main/java/org/springframework/integration/rsocket/outbound/RSocketOutboundGateway.java\n+++ b/spring-integration-rsocket/src/main/java/org/springframework/integration/rsocket/outbound/RSocketOutboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2019-2024 the original author or authors.\n+ * Copyright 2019-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -112,6 +112,7 @@ public RSocketOutboundGateway(String route, @Nullable Object... routeVariables)\n \t * in this expression evaluation, for example using some bean with an appropriate logic.\n \t * @param routeExpression the SpEL expression to use.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic RSocketOutboundGateway(Expression routeExpression) {\n \t\tAssert.notNull(routeExpression, \"'routeExpression' must not be null\");\n \t\tthis.routeExpression = routeExpression;\n\ndiff --git a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/gateway/SftpOutboundGateway.java b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/gateway/SftpOutboundGateway.java\nindex 94d691dbbff..1f71e32f01a 100644\n--- a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/gateway/SftpOutboundGateway.java\n+++ b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/gateway/SftpOutboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -51,6 +51,7 @@ public class SftpOutboundGateway extends AbstractRemoteFileOutboundGateway<SftpC\n \t * @param sessionFactory the session factory.\n \t * @param messageSessionCallback the callback.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic SftpOutboundGateway(SessionFactory<SftpClient.DirEntry> sessionFactory,\n \t\t\tMessageSessionCallback<SftpClient.DirEntry, ?> messageSessionCallback) {\n \n@@ -77,6 +78,7 @@ public SftpOutboundGateway(RemoteFileTemplate<SftpClient.DirEntry> remoteFileTem\n \t * @param command the command.\n \t * @param expression the remote path expression.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic SftpOutboundGateway(SessionFactory<SftpClient.DirEntry> sessionFactory, String command,\n \t\t\t@Nullable String expression) {\n \n\ndiff --git a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/inbound/SftpInboundFileSynchronizer.java b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/inbound/SftpInboundFileSynchronizer.java\nindex fca7fcc2c19..dec459061b6 100644\n--- a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/inbound/SftpInboundFileSynchronizer.java\n+++ b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/inbound/SftpInboundFileSynchronizer.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -39,6 +39,7 @@ public class SftpInboundFileSynchronizer extends AbstractInboundFileSynchronizer\n \t * Create a synchronizer with the {@code SessionFactory} used to acquire {@code Session} instances.\n \t * @param sessionFactory The session factory.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic SftpInboundFileSynchronizer(SessionFactory<SftpClient.DirEntry> sessionFactory) {\n \t\tsuper(sessionFactory);\n \t\tdoSetFilter(new SftpPersistentAcceptOnceFileListFilter(new SimpleMetadataStore(), \"sftpMessageSource\"));\n\ndiff --git a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/inbound/SftpStreamingMessageSource.java b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/inbound/SftpStreamingMessageSource.java\nindex 288abeed756..987c2a300af 100644\n--- a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/inbound/SftpStreamingMessageSource.java\n+++ b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/inbound/SftpStreamingMessageSource.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2019 the original author or authors.\n+ * Copyright 2016-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -56,6 +56,7 @@ public SftpStreamingMessageSource(RemoteFileTemplate<SftpClient.DirEntry> templa\n \t * @param template the template.\n \t * @param comparator the comparator.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic SftpStreamingMessageSource(RemoteFileTemplate<SftpClient.DirEntry> template,\n \t\t\tComparator<SftpClient.DirEntry> comparator) {\n \n\ndiff --git a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/server/DirectoryCreatedEvent.java b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/server/DirectoryCreatedEvent.java\nindex efaedda08bc..39f84f469d5 100644\n--- a/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/server/DirectoryCreatedEvent.java\n+++ b/spring-integration-sftp/src/main/java/org/springframework/integration/sftp/server/DirectoryCreatedEvent.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2019 the original author or authors.\n+ * Copyright 2019-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -25,6 +25,7 @@\n  * An event emitted when a directory is created.\n  *\n  * @author Gary Russell\n+ * @author Jooyoung Pyoung\n  * @since 5.2\n  *\n  */\n@@ -34,7 +35,7 @@ public class DirectoryCreatedEvent extends ApacheMinaSftpEvent {\n \n \tprivate transient Path path;\n \n-\tprivate final Map<String, ?> attrs;\n+\tprivate final transient Map<String, ?> attrs;\n \n \tpublic DirectoryCreatedEvent(Object source, Path path, Map<String, ?> attrs) {\n \t\tsuper(source);\n\ndiff --git a/spring-integration-smb/src/main/java/org/springframework/integration/smb/inbound/SmbStreamingMessageSource.java b/spring-integration-smb/src/main/java/org/springframework/integration/smb/inbound/SmbStreamingMessageSource.java\nindex 68c89a05694..c3f8d7e8f7c 100644\n--- a/spring-integration-smb/src/main/java/org/springframework/integration/smb/inbound/SmbStreamingMessageSource.java\n+++ b/spring-integration-smb/src/main/java/org/springframework/integration/smb/inbound/SmbStreamingMessageSource.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2022 the original author or authors.\n+ * Copyright 2022-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -60,6 +60,7 @@ public SmbStreamingMessageSource(RemoteFileTemplate<SmbFile> template) {\n \t * @param template the template.\n \t * @param comparator the comparator.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic SmbStreamingMessageSource(RemoteFileTemplate<SmbFile> template, Comparator<SmbFile> comparator) {\n \t\tsuper(template, comparator);\n \t\tdoSetFilter(new SmbPersistentAcceptOnceFileListFilter(new SimpleMetadataStore(), \"smbStreamingMessageSource\"));\n\ndiff --git a/spring-integration-smb/src/main/java/org/springframework/integration/smb/outbound/SmbOutboundGateway.java b/spring-integration-smb/src/main/java/org/springframework/integration/smb/outbound/SmbOutboundGateway.java\nindex 9f35c6660cd..dbc1820dc4a 100644\n--- a/spring-integration-smb/src/main/java/org/springframework/integration/smb/outbound/SmbOutboundGateway.java\n+++ b/spring-integration-smb/src/main/java/org/springframework/integration/smb/outbound/SmbOutboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2022-2024 the original author or authors.\n+ * Copyright 2022-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -48,6 +48,7 @@ public class SmbOutboundGateway extends AbstractRemoteFileOutboundGateway<SmbFil\n \t * @param sessionFactory the session factory.\n \t * @param messageSessionCallback the callback.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic SmbOutboundGateway(SessionFactory<SmbFile> sessionFactory,\n \t\t\tMessageSessionCallback<SmbFile, ?> messageSessionCallback) {\n \n@@ -74,6 +75,7 @@ public SmbOutboundGateway(RemoteFileTemplate<SmbFile> remoteFileTemplate,\n \t * @param command the command.\n \t * @param expression the remote path expression.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic SmbOutboundGateway(SessionFactory<SmbFile> sessionFactory, String command, @Nullable String expression) {\n \t\tthis(new SmbRemoteFileTemplate(sessionFactory), command, expression);\n \t\tremoteFileTemplateExplicitlySet(false);\n\ndiff --git a/spring-integration-webflux/src/main/java/org/springframework/integration/webflux/outbound/WebFluxRequestExecutingMessageHandler.java b/spring-integration-webflux/src/main/java/org/springframework/integration/webflux/outbound/WebFluxRequestExecutingMessageHandler.java\nindex 1d135f2ac45..76b514d1066 100644\n--- a/spring-integration-webflux/src/main/java/org/springframework/integration/webflux/outbound/WebFluxRequestExecutingMessageHandler.java\n+++ b/spring-integration-webflux/src/main/java/org/springframework/integration/webflux/outbound/WebFluxRequestExecutingMessageHandler.java\n@@ -131,6 +131,7 @@ public WebFluxRequestExecutingMessageHandler(String uri, @Nullable WebClient web\n \t * {@link org.springframework.beans.factory.BeanFactory}.\n \t * @param webClient The WebClient to use.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic WebFluxRequestExecutingMessageHandler(Expression uriExpression, @Nullable WebClient webClient) {\n \t\tsuper(uriExpression);\n \t\tthis.webClientExplicitlySet = webClient != null;\n\ndiff --git a/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/inbound/WebSocketInboundChannelAdapter.java b/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/inbound/WebSocketInboundChannelAdapter.java\nindex a1c398199a5..45b9df42817 100644\n--- a/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/inbound/WebSocketInboundChannelAdapter.java\n+++ b/spring-integration-websocket/src/main/java/org/springframework/integration/websocket/inbound/WebSocketInboundChannelAdapter.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2024 the original author or authors.\n+ * Copyright 2014-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -115,6 +115,7 @@ public WebSocketInboundChannelAdapter(IntegrationWebSocketContainer webSocketCon\n \t\tthis(webSocketContainer, new SubProtocolHandlerRegistry(new PassThruSubProtocolHandler()));\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic WebSocketInboundChannelAdapter(IntegrationWebSocketContainer webSocketContainer,\n \t\t\tSubProtocolHandlerRegistry protocolHandlerRegistry) {\n \n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceOutboundGateway.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceOutboundGateway.java\nindex 4853015278b..6a5329b9e3d 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceOutboundGateway.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/MarshallingWebServiceOutboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -43,6 +43,7 @@\n  */\n public class MarshallingWebServiceOutboundGateway extends AbstractWebServiceOutboundGateway {\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic MarshallingWebServiceOutboundGateway(DestinationProvider destinationProvider, Marshaller marshaller,\n \t\t\tUnmarshaller unmarshaller, WebServiceMessageFactory messageFactory) {\n \t\tsuper(destinationProvider, messageFactory);\n@@ -63,6 +64,7 @@ public MarshallingWebServiceOutboundGateway(DestinationProvider destinationProvi\n \t\tthis(destinationProvider, marshaller, (WebServiceMessageFactory) null);\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic MarshallingWebServiceOutboundGateway(String uri, Marshaller marshaller, Unmarshaller unmarshaller,\n \t\t\tWebServiceMessageFactory messageFactory) {\n \t\tsuper(uri, messageFactory);\n@@ -88,6 +90,7 @@ public MarshallingWebServiceOutboundGateway(String uri, Marshaller marshaller) {\n \t * @param webServiceTemplate the WebServiceTemplate\n \t * @since 5.0\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic MarshallingWebServiceOutboundGateway(String uri, WebServiceTemplate webServiceTemplate) {\n \t\tsuper(uri, null);\n \t\tdoSetWebServiceTemplate(webServiceTemplate);\n@@ -99,6 +102,7 @@ public MarshallingWebServiceOutboundGateway(String uri, WebServiceTemplate webSe\n \t * @param webServiceTemplate the WebServiceTemplate\n \t * @since 5.0\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic MarshallingWebServiceOutboundGateway(DestinationProvider destinationProvider,\n \t\t\tWebServiceTemplate webServiceTemplate) {\n \t\tsuper(destinationProvider, null);\n@@ -111,6 +115,7 @@ public MarshallingWebServiceOutboundGateway(DestinationProvider destinationProvi\n \t * @param marshaller The marshaller.\n \t * @param unmarshallerArg The unmarshaller.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tprivate void configureMarshallers(Marshaller marshaller, @Nullable Unmarshaller unmarshallerArg) {\n \t\tUnmarshaller unmarshaller = unmarshallerArg;\n \t\tAssert.notNull(marshaller, \"marshaller must not be null\");\n\ndiff --git a/spring-integration-ws/src/main/java/org/springframework/integration/ws/config/WebServiceHeaderEnricherParser.java b/spring-integration-ws/src/main/java/org/springframework/integration/ws/config/WebServiceHeaderEnricherParser.java\nindex d82e110723f..9dbe52cfb72 100644\n--- a/spring-integration-ws/src/main/java/org/springframework/integration/ws/config/WebServiceHeaderEnricherParser.java\n+++ b/spring-integration-ws/src/main/java/org/springframework/integration/ws/config/WebServiceHeaderEnricherParser.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -25,6 +25,7 @@\n  */\n public class WebServiceHeaderEnricherParser extends HeaderEnricherParserSupport {\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic WebServiceHeaderEnricherParser() {\n \t\tthis.addElementToHeaderMapping(\"soap-action\", WebServiceHeaders.SOAP_ACTION);\n \t}\n\ndiff --git a/spring-integration-xmpp/src/main/java/org/springframework/integration/xmpp/config/XmppHeaderEnricherParser.java b/spring-integration-xmpp/src/main/java/org/springframework/integration/xmpp/config/XmppHeaderEnricherParser.java\nindex 6804a24b540..b968d13a53b 100644\n--- a/spring-integration-xmpp/src/main/java/org/springframework/integration/xmpp/config/XmppHeaderEnricherParser.java\n+++ b/spring-integration-xmpp/src/main/java/org/springframework/integration/xmpp/config/XmppHeaderEnricherParser.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -27,6 +27,7 @@\n  */\n public class XmppHeaderEnricherParser extends HeaderEnricherParserSupport {\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic XmppHeaderEnricherParser() {\n \t\tthis.addElementToHeaderMapping(\"chat-to\", XmppHeaders.TO);\n \t\tthis.addElementToHeaderMapping(\"chat-thread-id\", XmppHeaders.THREAD);\n\ndiff --git a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java\nindex 8c943554506..b1cd3792cdf 100644\n--- a/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java\n+++ b/spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2020-2022 the original author or authors.\n+ * Copyright 2020-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -128,6 +128,7 @@ public ZeroMqChannel(ZContext context) {\n \t * @param context the {@link ZContext} to use.\n \t * @param pubSub the communication model: push/pull or pub/sub.\n \t */\n+\t@SuppressWarnings(\"this-escape\")\n \tpublic ZeroMqChannel(ZContext context, boolean pubSub) {\n \t\tAssert.notNull(context, \"'context' must not be null\");\n \t\tthis.context = context;\n@@ -141,6 +142,7 @@ public ZeroMqChannel(ZContext context, boolean pubSub) {\n \t\tthis.subscriberData = prepareSubscriberDataFlux();\n \t}\n \n+\t@SuppressWarnings(\"this-escape\")\n \tprivate Mono<Integer> prepareProxyMono() {\n \t\treturn Mono.defer(() -> {\n \t\t\t\t\tif (this.zeroMqProxy != null) {\n",
    "test_patch": "diff --git a/spring-integration-file/src/test/java/org/springframework/integration/file/config/ChainElementsTests.java b/spring-integration-file/src/test/java/org/springframework/integration/file/config/ChainElementsTests.java\nindex 1153b33b1d1..96588d15906 100644\n--- a/spring-integration-file/src/test/java/org/springframework/integration/file/config/ChainElementsTests.java\n+++ b/spring-integration-file/src/test/java/org/springframework/integration/file/config/ChainElementsTests.java\n@@ -39,6 +39,7 @@\n /**\n  * @author Gunnar Hillert\n  * @author Artem Bilan\n+ * @author Jooyoung Pyoung\n  *\n  * @since 2.2\n  */\n@@ -49,7 +50,7 @@ public class ChainElementsTests {\n \t@BeforeEach\n \tpublic void setUp() {\n \t\tlocaleBeforeTest = Locale.getDefault();\n-\t\tLocale.setDefault(new Locale(\"en\", \"US\"));\n+\t\tLocale.setDefault(Locale.US);\n \t}\n \n \t@AfterEach\n\ndiff --git a/spring-integration-file/src/test/java/org/springframework/integration/file/remote/StreamingInboundTests.java b/spring-integration-file/src/test/java/org/springframework/integration/file/remote/StreamingInboundTests.java\nindex a17c7241dea..1fde528c9e6 100644\n--- a/spring-integration-file/src/test/java/org/springframework/integration/file/remote/StreamingInboundTests.java\n+++ b/spring-integration-file/src/test/java/org/springframework/integration/file/remote/StreamingInboundTests.java\n@@ -269,11 +269,13 @@ public static class Streamer extends AbstractRemoteFileStreamingMessageSource<St\n \n \t\tConcurrentHashMap<String, String> metadataMap = new ConcurrentHashMap<>();\n \n+\t\t@SuppressWarnings(\"this-escape\")\n \t\tprotected Streamer(RemoteFileTemplate<String> template) {\n \t\t\tsuper(template, null);\n \t\t\tdoSetFilter(null);\n \t\t}\n \n+\t\t@SuppressWarnings(\"this-escape\")\n \t\tprotected Streamer(RemoteFileTemplate<String> template, Comparator<String> comparator) {\n \t\t\tsuper(template, comparator);\n \t\t\tdoSetFilter(new StringPersistentFileListFilter(new SimpleMetadataStore(this.metadataMap), \"streamer\"));\n\ndiff --git a/spring-integration-file/src/test/java/org/springframework/integration/file/tail/TailCondition.java b/spring-integration-file/src/test/java/org/springframework/integration/file/tail/TailCondition.java\nindex 6716234f9ea..ce148bf8860 100644\n--- a/spring-integration-file/src/test/java/org/springframework/integration/file/tail/TailCondition.java\n+++ b/spring-integration-file/src/test/java/org/springframework/integration/file/tail/TailCondition.java\n@@ -45,6 +45,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Jiandong Ma\n+ * @author Jooyoung Pyoung\n  *\n  * @since 6.5\n  *\n@@ -94,7 +95,8 @@ private boolean tailWorksOnThisMachine() {\n \t\t\tExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();\n \t\t\tFuture<Process> future =\n \t\t\t\t\tnewSingleThreadExecutor.submit(() -> {\n-\t\t\t\t\t\tfinal Process process = Runtime.getRuntime().exec(commandToTest + \" \" + file.getAbsolutePath());\n+\t\t\t\t\t\tProcessBuilder pb = new ProcessBuilder(commandToTest, file.getAbsolutePath());\n+\t\t\t\t\t\tfinal Process process = pb.start();\n \t\t\t\t\t\tExecutorService executorService = Executors.newSingleThreadExecutor();\n \t\t\t\t\t\texecutorService.execute(() -> {\n \t\t\t\t\t\t\ttry {\n\ndiff --git a/spring-integration-xml/src/test/java/org/springframework/integration/xml/config/TestXmlApplicationContext.java b/spring-integration-xml/src/test/java/org/springframework/integration/xml/config/TestXmlApplicationContext.java\nindex 5f125b50e39..76f2cbb211e 100644\n--- a/spring-integration-xml/src/test/java/org/springframework/integration/xml/config/TestXmlApplicationContext.java\n+++ b/spring-integration-xml/src/test/java/org/springframework/integration/xml/config/TestXmlApplicationContext.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -28,6 +28,7 @@ public class TestXmlApplicationContext extends AbstractXmlApplicationContext {\n \n \tprivate final Resource[] resources;\n \n+\t@SuppressWarnings(\"this-escape\")\n \tpublic TestXmlApplicationContext(String... xmlStrings) {\n \t\tresources = new Resource[xmlStrings.length];\n \t\tfor (int i = 0; i < xmlStrings.length; i++) {\n\ndiff --git a/spring-integration-xml/src/test/java/org/springframework/integration/xml/config/XmlPayloadValidatingFilterParserTests.java b/spring-integration-xml/src/test/java/org/springframework/integration/xml/config/XmlPayloadValidatingFilterParserTests.java\nindex fb495566284..8af7e4226ae 100644\n--- a/spring-integration-xml/src/test/java/org/springframework/integration/xml/config/XmlPayloadValidatingFilterParserTests.java\n+++ b/spring-integration-xml/src/test/java/org/springframework/integration/xml/config/XmlPayloadValidatingFilterParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2023 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -53,6 +53,7 @@\n  * @author Gunnar Hillert\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Jooyoung Pyoung\n  */\n @SpringJUnitConfig\n @DirtiesContext\n@@ -63,7 +64,7 @@ public class XmlPayloadValidatingFilterParserTests {\n \t@BeforeEach\n \tpublic void setUp() {\n \t\tlocaleBeforeTest = Locale.getDefault();\n-\t\tLocale.setDefault(new Locale(\"en\", \"US\"));\n+\t\tLocale.setDefault(Locale.US);\n \t}\n \n \t@AfterEach\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-10087",
    "pr_id": 10087,
    "issue_id": 9996,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Deprecate JUnit 4 utilities in the project\nAlso, migrate JUnit 4 tests to Jupiter.\nMore info in: https://github.com/spring-projects/spring-framework/issues/34794",
    "issue_word_count": 26,
    "test_files_count": 52,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "build.gradle",
      "spring-integration-core/src/test/java/org/springframework/integration/support/MessageScenariosTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/support/SingleScenarioTests.java",
      "spring-integration-file/src/test/java/org/springframework/integration/file/FileToChannelIntegrationTests-context.xml",
      "spring-integration-file/src/test/java/org/springframework/integration/file/FileToChannelIntegrationTests.java",
      "spring-integration-file/src/test/java/org/springframework/integration/file/locking/FileLockingNamespaceTests-context.xml",
      "spring-integration-file/src/test/java/org/springframework/integration/file/locking/FileLockingNamespaceTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/AttributePollingMessageSourceTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/MBeanTreePollingMessageSourceTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/NotificationListeningMessageProducerTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/NotificationPublishingMessageHandlerTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/OperationInvokingMessageHandlerTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/AttributePollingChannelAdapterParserTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/ControlBusParserTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/CustomObjectNameTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/DynamicRouterTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanAutoDetectTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanExporterNameTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanRegistrationCustomNamingTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanRegistrationTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MessageStoreTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MethodInvokerTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/NotificationListeningChannelAdapterParserTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/NotificationPublishingChannelAdapterParserTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/OperationInvokingOutboundGatewayTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/PollingAdapterMBeanTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/PriorityChannelTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/RouterMBeanTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/RouterMBeanVanillaTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/monitor/ChainWithMessageProducingHandlersTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/monitor/HandlerMonitoringIntegrationTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/monitor/MBeanExporterIntegrationTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/monitor/MessagingGatewaySupportRegistrationTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/monitor/RemoteMBeanServerTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/monitor/TransformerContextTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration_/mbeanexporterhelper/INT_2626Tests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration_/mbeanexporterhelper/Int2307Tests.java",
      "spring-integration-jpa/src/test/java/org/springframework/integration/jpa/config/xml/JpaMessageHandlerParserTests.java",
      "spring-integration-jpa/src/test/java/org/springframework/integration/jpa/inbound/JpaPollingChannelAdapterUnitTests.java",
      "spring-integration-redis/src/test/java/org/springframework/integration/redis/config/RedisQueueOutboundGatewayParserTests.java",
      "spring-integration-stream/src/test/java/org/springframework/integration/stream/ByteStreamSourceTests.java",
      "spring-integration-stream/src/test/java/org/springframework/integration/stream/ByteStreamWritingMessageHandlerTests.java",
      "spring-integration-syslog/src/test/java/org/springframework/integration/syslog/inbound/SyslogDeserializerTests.java",
      "spring-integration-test-support/src/main/java/org/springframework/integration/test/rule/Log4j2LevelAdjuster.java",
      "spring-integration-test-support/src/main/java/org/springframework/integration/test/support/AbstractRequestResponseScenarioTest.java",
      "spring-integration-test-support/src/main/java/org/springframework/integration/test/support/AbstractRequestResponseScenarioTests.java",
      "spring-integration-test-support/src/main/java/org/springframework/integration/test/support/LongRunningIntegrationTest.java",
      "spring-integration-test-support/src/main/java/org/springframework/integration/test/support/SingleRequestResponseScenarioTest.java",
      "spring-integration-test-support/src/main/java/org/springframework/integration/test/support/SingleRequestResponseScenarioTests.java",
      "spring-integration-test-support/src/test/java/org/springframework/integration/test/matcher/MockitoMessageMatchersTests.java",
      "spring-integration-ws/src/test/java/org/springframework/integration/ws/DefaultSoapHeaderMapperTests.java",
      "spring-integration-ws/src/test/java/org/springframework/integration/ws/WebServiceInboundGatewayJavaConfigTests.java",
      "src/reference/antora/modules/ROOT/pages/testing.adoc",
      "src/reference/antora/modules/ROOT/pages/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/support/MessageScenariosTests.java",
      "spring-integration-core/src/test/java/org/springframework/integration/support/SingleScenarioTests.java",
      "spring-integration-file/src/test/java/org/springframework/integration/file/FileToChannelIntegrationTests-context.xml",
      "spring-integration-file/src/test/java/org/springframework/integration/file/FileToChannelIntegrationTests.java",
      "spring-integration-file/src/test/java/org/springframework/integration/file/locking/FileLockingNamespaceTests-context.xml",
      "spring-integration-file/src/test/java/org/springframework/integration/file/locking/FileLockingNamespaceTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/AttributePollingMessageSourceTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/MBeanTreePollingMessageSourceTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/NotificationListeningMessageProducerTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/NotificationPublishingMessageHandlerTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/OperationInvokingMessageHandlerTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/AttributePollingChannelAdapterParserTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/ControlBusParserTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/CustomObjectNameTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/DynamicRouterTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanAutoDetectTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanExporterNameTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanRegistrationCustomNamingTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanRegistrationTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MessageStoreTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MethodInvokerTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/NotificationListeningChannelAdapterParserTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/NotificationPublishingChannelAdapterParserTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/OperationInvokingOutboundGatewayTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/PollingAdapterMBeanTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/PriorityChannelTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/RouterMBeanTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/RouterMBeanVanillaTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/monitor/ChainWithMessageProducingHandlersTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/monitor/HandlerMonitoringIntegrationTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/monitor/MBeanExporterIntegrationTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/monitor/MessagingGatewaySupportRegistrationTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/monitor/RemoteMBeanServerTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration/monitor/TransformerContextTests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration_/mbeanexporterhelper/INT_2626Tests.java",
      "spring-integration-jmx/src/test/java/org/springframework/integration_/mbeanexporterhelper/Int2307Tests.java",
      "spring-integration-jpa/src/test/java/org/springframework/integration/jpa/config/xml/JpaMessageHandlerParserTests.java",
      "spring-integration-jpa/src/test/java/org/springframework/integration/jpa/inbound/JpaPollingChannelAdapterUnitTests.java",
      "spring-integration-redis/src/test/java/org/springframework/integration/redis/config/RedisQueueOutboundGatewayParserTests.java",
      "spring-integration-stream/src/test/java/org/springframework/integration/stream/ByteStreamSourceTests.java",
      "spring-integration-stream/src/test/java/org/springframework/integration/stream/ByteStreamWritingMessageHandlerTests.java",
      "spring-integration-syslog/src/test/java/org/springframework/integration/syslog/inbound/SyslogDeserializerTests.java",
      "spring-integration-test-support/src/main/java/org/springframework/integration/test/rule/Log4j2LevelAdjuster.java",
      "spring-integration-test-support/src/main/java/org/springframework/integration/test/support/AbstractRequestResponseScenarioTest.java",
      "spring-integration-test-support/src/main/java/org/springframework/integration/test/support/AbstractRequestResponseScenarioTests.java",
      "spring-integration-test-support/src/main/java/org/springframework/integration/test/support/LongRunningIntegrationTest.java",
      "spring-integration-test-support/src/main/java/org/springframework/integration/test/support/SingleRequestResponseScenarioTest.java",
      "spring-integration-test-support/src/main/java/org/springframework/integration/test/support/SingleRequestResponseScenarioTests.java",
      "spring-integration-test-support/src/test/java/org/springframework/integration/test/matcher/MockitoMessageMatchersTests.java",
      "spring-integration-ws/src/test/java/org/springframework/integration/ws/DefaultSoapHeaderMapperTests.java",
      "spring-integration-ws/src/test/java/org/springframework/integration/ws/WebServiceInboundGatewayJavaConfigTests.java",
      "src/reference/antora/modules/ROOT/pages/testing.adoc"
    ],
    "base_commit": "ca822a2659d9abeff0ca194cec2a025cdd901e06",
    "head_commit": "cd07e6bc908e04e76a7ad6731419e37b13859c8f",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/10087",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/10087",
    "dockerfile": "",
    "pr_merged_at": "2025-06-09T15:46:42.000Z",
    "patch": "diff --git a/build.gradle b/build.gradle\nindex 3960777f934..4f794c6cdf6 100644\n--- a/build.gradle\n+++ b/build.gradle\n@@ -299,9 +299,6 @@ configure(javaProjects) { subproject ->\n         testImplementation(\"org.awaitility:awaitility:$awaitilityVersion\") {\n             exclude group: 'org.hamcrest'\n         }\n-        testImplementation(\"junit:junit:$junit4Version\") {\n-            exclude group: 'org.hamcrest'\n-        }\n         testImplementation 'org.junit.jupiter:junit-jupiter-api'\n         testImplementation 'org.junit.jupiter:junit-jupiter-params'\n         testImplementation(\"com.willowtreeapps.assertk:assertk-jvm:$assertkVersion\") {\n@@ -314,8 +311,6 @@ configure(javaProjects) { subproject ->\n \n         testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'\n         testRuntimeOnly 'org.junit.platform:junit-platform-launcher'\n-        // To support JUnit 4 tests\n-        testRuntimeOnly 'org.junit.vintage:junit-vintage-engine'\n \n         testRuntimeOnly 'org.apache.logging.log4j:log4j-core'\n         testRuntimeOnly 'org.apache.logging.log4j:log4j-jcl'\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/whats-new.adoc b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\nindex 8c646414e72..01ac532be57 100644\n--- a/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n@@ -17,6 +17,8 @@ Java 17 is still baseline, but Java 24 is supported.\n [[x7.0-general]]\n == General Changes\n \n+Junit 4 Based Support Components are deprecated.\n+\n [[x7.0-new-components]]\n == New Components\n \n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/support/MessageScenariosTests.java b/spring-integration-core/src/test/java/org/springframework/integration/support/MessageScenariosTests.java\nindex d5120e49601..4e4a0494025 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/support/MessageScenariosTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/support/MessageScenariosTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,7 +20,7 @@\n import java.util.List;\n \n import org.springframework.integration.test.predicate.MessagePredicate;\n-import org.springframework.integration.test.support.AbstractRequestResponseScenarioTests;\n+import org.springframework.integration.test.support.AbstractRequestResponseScenarioTest;\n import org.springframework.integration.test.support.MessageValidator;\n import org.springframework.integration.test.support.PayloadValidator;\n import org.springframework.integration.test.support.RequestResponseScenario;\n@@ -37,7 +37,7 @@\n  */\n @ContextConfiguration\n @DirtiesContext\n-public class MessageScenariosTests extends AbstractRequestResponseScenarioTests {\n+public class MessageScenariosTests extends AbstractRequestResponseScenarioTest {\n \n \t@Override\n \tprotected List<RequestResponseScenario> defineRequestResponseScenarios() {\n\ndiff --git a/spring-integration-core/src/test/java/org/springframework/integration/support/SingleScenarioTests.java b/spring-integration-core/src/test/java/org/springframework/integration/support/SingleScenarioTests.java\nindex 840e66dfcde..feac834fd32 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/support/SingleScenarioTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/support/SingleScenarioTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,7 +18,7 @@\n \n import org.springframework.integration.test.support.PayloadValidator;\n import org.springframework.integration.test.support.RequestResponseScenario;\n-import org.springframework.integration.test.support.SingleRequestResponseScenarioTests;\n+import org.springframework.integration.test.support.SingleRequestResponseScenarioTest;\n import org.springframework.test.annotation.DirtiesContext;\n import org.springframework.test.context.ContextConfiguration;\n \n@@ -31,7 +31,7 @@\n  */\n @ContextConfiguration(\"MessageScenariosTests-context.xml\")\n @DirtiesContext\n-public class SingleScenarioTests extends SingleRequestResponseScenarioTests {\n+public class SingleScenarioTests extends SingleRequestResponseScenarioTest {\n \n \t@Override\n \tprotected RequestResponseScenario defineRequestResponseScenario() {\n\ndiff --git a/spring-integration-file/src/test/java/org/springframework/integration/file/FileToChannelIntegrationTests-context.xml b/spring-integration-file/src/test/java/org/springframework/integration/file/FileToChannelIntegrationTests-context.xml\nindex 91d7ba5c40f..507e2211f65 100644\n--- a/spring-integration-file/src/test/java/org/springframework/integration/file/FileToChannelIntegrationTests-context.xml\n+++ b/spring-integration-file/src/test/java/org/springframework/integration/file/FileToChannelIntegrationTests-context.xml\n@@ -19,11 +19,8 @@\n \t\t\tdirectory=\"#{inputDirectory.path}\"\n \t\t\tchannel=\"fileMessages\" filter=\"compositeFilter\"/>\n \n-\t<bean id=\"temp\" class=\"org.junit.rules.TemporaryFolder\"\n-\t\t  init-method=\"create\" destroy-method=\"delete\"/>\n-\n \t<bean id=\"inputDirectory\" class=\"java.io.File\">\n-\t\t<constructor-arg value=\"#{temp.newFolder('FileToChannelIntegrationTests').path}\"/>\n+\t\t<constructor-arg value=\"#{T(org.springframework.integration.file.FileToChannelIntegrationTests).tempDir.path}\"/>\n \t</bean>\n \n \t<si:channel id=\"fileMessages\">\n\ndiff --git a/spring-integration-file/src/test/java/org/springframework/integration/file/FileToChannelIntegrationTests.java b/spring-integration-file/src/test/java/org/springframework/integration/file/FileToChannelIntegrationTests.java\nindex 469f38d628e..7f6acd5ba11 100644\n--- a/spring-integration-file/src/test/java/org/springframework/integration/file/FileToChannelIntegrationTests.java\n+++ b/spring-integration-file/src/test/java/org/springframework/integration/file/FileToChannelIntegrationTests.java\n@@ -19,6 +19,7 @@\n import java.io.File;\n \n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.messaging.Message;\n@@ -37,6 +38,9 @@\n @DirtiesContext(classMode = ClassMode.AFTER_EACH_TEST_METHOD)\n public class FileToChannelIntegrationTests {\n \n+\t@TempDir\n+\tpublic static File tempDir;\n+\n \t@Autowired\n \tFile inputDirectory;\n \n\ndiff --git a/spring-integration-file/src/test/java/org/springframework/integration/file/locking/FileLockingNamespaceTests-context.xml b/spring-integration-file/src/test/java/org/springframework/integration/file/locking/FileLockingNamespaceTests-context.xml\nindex 50d01783272..4264c578aa2 100644\n--- a/spring-integration-file/src/test/java/org/springframework/integration/file/locking/FileLockingNamespaceTests-context.xml\n+++ b/spring-integration-file/src/test/java/org/springframework/integration/file/locking/FileLockingNamespaceTests-context.xml\n@@ -11,17 +11,19 @@\n \t\t\thttps://www.springframework.org/schema/integration/file/spring-integration-file.xsd\">\n \n     <!-- under test -->\n-    <file:inbound-channel-adapter id=\"customLockingAdapter\" directory=\"#{directory.root}\">\n+    <file:inbound-channel-adapter id=\"customLockingAdapter\" directory=\"#{directory}\">\n         <file:locker ref=\"customLocker\"/>\n     </file:inbound-channel-adapter>\n \n-    <file:inbound-channel-adapter id=\"nioLockingAdapter\" directory=\"#{directory.root}\">\n+    <file:inbound-channel-adapter id=\"nioLockingAdapter\" directory=\"#{directory}\">\n         <file:nio-locker/>\n     </file:inbound-channel-adapter>\n \n     <bean id=\"customLocker\" class=\"org.springframework.integration.file.locking.FileLockingNamespaceTests$StubLocker\"/>\n \n-    <bean id=\"directory\" class=\"org.junit.rules.TemporaryFolder\" init-method=\"create\" destroy-method=\"delete\"/>\n+\t<bean id=\"directory\" class=\"java.io.File\">\n+\t\t<constructor-arg value=\"#{T(org.springframework.integration.file.locking.FileLockingNamespaceTests).tempDir.path}\"/>\n+\t</bean>\n \n     <si:poller default=\"true\" fixed-delay=\"100000000\"/>\n \n\ndiff --git a/spring-integration-file/src/test/java/org/springframework/integration/file/locking/FileLockingNamespaceTests.java b/spring-integration-file/src/test/java/org/springframework/integration/file/locking/FileLockingNamespaceTests.java\nindex edc983e0341..f7fd02b57f4 100644\n--- a/spring-integration-file/src/test/java/org/springframework/integration/file/locking/FileLockingNamespaceTests.java\n+++ b/spring-integration-file/src/test/java/org/springframework/integration/file/locking/FileLockingNamespaceTests.java\n@@ -20,6 +20,7 @@\n \n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n \n import org.springframework.beans.DirectFieldAccessor;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -41,6 +42,9 @@\n @DirtiesContext\n public class FileLockingNamespaceTests {\n \n+\t@TempDir\n+\tpublic static File tempDir;\n+\n \t@Autowired\n \t@Qualifier(\"nioLockingAdapter.adapter\")\n \tSourcePollingChannelAdapter nioAdapter;\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/AttributePollingMessageSourceTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/AttributePollingMessageSourceTests.java\nindex c86c4295e23..a2da477f988 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/AttributePollingMessageSourceTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/AttributePollingMessageSourceTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,7 +20,7 @@\n \n import javax.management.MBeanServer;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.jmx.support.MBeanServerFactoryBean;\n import org.springframework.jmx.support.ObjectNameManager;\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/MBeanTreePollingMessageSourceTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/MBeanTreePollingMessageSourceTests.java\nindex b2328ca0134..4ff24383254 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/MBeanTreePollingMessageSourceTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/MBeanTreePollingMessageSourceTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2022 the original author or authors.\n+ * Copyright 2013-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,9 +21,9 @@\n \n import javax.management.MBeanServer;\n \n-import org.junit.AfterClass;\n-import org.junit.BeforeClass;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.jmx.support.MBeanServerFactoryBean;\n \n@@ -40,7 +40,7 @@ public class MBeanTreePollingMessageSourceTests {\n \n \tprivate static MBeanServer server;\n \n-\t@BeforeClass\n+\t@BeforeAll\n \tpublic static void setup() {\n \t\tfactoryBean = new MBeanServerFactoryBean();\n \t\tfactoryBean.setLocateExistingServerIfPossible(true);\n@@ -48,7 +48,7 @@ public static void setup() {\n \t\tserver = factoryBean.getObject();\n \t}\n \n-\t@AfterClass\n+\t@AfterAll\n \tpublic static void tearDown() {\n \t\tfactoryBean.destroy();\n \t}\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/NotificationListeningMessageProducerTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/NotificationListeningMessageProducerTests.java\nindex 54c3c6ab381..66345d8b9e6 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/NotificationListeningMessageProducerTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/NotificationListeningMessageProducerTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -22,11 +22,11 @@\n import javax.management.Notification;\n import javax.management.ObjectName;\n \n-import org.junit.After;\n-import org.junit.AfterClass;\n-import org.junit.Before;\n-import org.junit.BeforeClass;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n import org.mockito.Mockito;\n \n import org.springframework.beans.factory.BeanFactory;\n@@ -59,13 +59,13 @@ public class NotificationListeningMessageProducerTests {\n \n \tprivate ObjectName objectName;\n \n-\t@BeforeClass\n+\t@BeforeAll\n \tpublic static void setupClass() {\n \t\tserverFactoryBean = new MBeanServerFactoryBean();\n \t\tserverFactoryBean.afterPropertiesSet();\n \t}\n \n-\t@Before\n+\t@BeforeEach\n \tpublic void setup() throws Exception {\n \t\tthis.server = serverFactoryBean.getObject();\n \t\tMBeanExporter exporter = new MBeanExporter();\n@@ -75,12 +75,12 @@ public void setup() throws Exception {\n \t\texporter.registerManagedResource(this.numberHolder, this.objectName);\n \t}\n \n-\t@After\n+\t@AfterEach\n \tpublic void cleanup() throws Exception {\n \t\tthis.server.unregisterMBean(this.objectName);\n \t}\n \n-\t@AfterClass\n+\t@AfterAll\n \tpublic static void tearDown() {\n \t\tserverFactoryBean.destroy();\n \t}\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/NotificationPublishingMessageHandlerTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/NotificationPublishingMessageHandlerTests.java\nindex 62b6f4e1fcc..f0c9b3602ea 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/NotificationPublishingMessageHandlerTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/NotificationPublishingMessageHandlerTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,9 +23,9 @@\n import javax.management.NotificationListener;\n import javax.management.ObjectName;\n \n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.MutablePropertyValues;\n import org.springframework.beans.factory.config.RuntimeBeanReference;\n@@ -54,7 +54,7 @@ public class NotificationPublishingMessageHandlerTests {\n \n \tprivate volatile ObjectName publisherObjectName;\n \n-\t@Before\n+\t@BeforeEach\n \tpublic void setup() throws Exception {\n \t\tthis.publisherObjectName = ObjectNameManager.getInstance(\"test:type=publisher\");\n \t\tthis.context.registerBean(\"mbeanServer\", MBeanServerFactoryBean.class, MBeanServerFactoryBean::new);\n@@ -72,7 +72,7 @@ public void setup() throws Exception {\n \t\texporter.getServer().addNotificationListener(publisherObjectName, this.listener, null, null);\n \t}\n \n-\t@After\n+\t@AfterEach\n \tpublic void cleanup() {\n \t\tthis.listener.clearNotifications();\n \t\tcontext.close();\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/OperationInvokingMessageHandlerTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/OperationInvokingMessageHandlerTests.java\nindex 946a99f28b3..52ea64aca9d 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/OperationInvokingMessageHandlerTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/OperationInvokingMessageHandlerTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,11 +23,11 @@\n \n import javax.management.MBeanServer;\n \n-import org.junit.After;\n-import org.junit.AfterClass;\n-import org.junit.Before;\n-import org.junit.BeforeClass;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.integration.channel.QueueChannel;\n@@ -39,6 +39,7 @@\n import org.springframework.messaging.MessagingException;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n import static org.mockito.Mockito.mock;\n \n /**\n@@ -61,24 +62,24 @@ public class OperationInvokingMessageHandlerTests {\n \n \tprivate final String objectName = \"si:name=test\";\n \n-\t@BeforeClass\n+\t@BeforeAll\n \tpublic static void setupClass() {\n \t\tfactoryBean = new MBeanServerFactoryBean();\n \t\tfactoryBean.afterPropertiesSet();\n \t\tserver = factoryBean.getObject();\n \t}\n \n-\t@AfterClass\n+\t@AfterAll\n \tpublic static void tearDown() {\n \t\tfactoryBean.destroy();\n \t}\n \n-\t@Before\n+\t@BeforeEach\n \tpublic void setup() throws Exception {\n \t\tserver.registerMBean(new TestOps(), ObjectNameManager.getInstance(this.objectName));\n \t}\n \n-\t@After\n+\t@AfterEach\n \tpublic void cleanup() throws Exception {\n \t\tserver.unregisterMBean(ObjectNameManager.getInstance(this.objectName));\n \t}\n@@ -115,7 +116,7 @@ public void invocationWithPayloadNoReturnValue() {\n \t\thandler.handleMessage(message);\n \t}\n \n-\t@Test(expected = MessagingException.class)\n+\t@Test\n \tpublic void invocationWithMapPayloadNotEnoughParameters() {\n \t\tQueueChannel outputChannel = new QueueChannel();\n \t\tOperationInvokingMessageHandler handler = new OperationInvokingMessageHandler(server);\n@@ -127,10 +128,8 @@ public void invocationWithMapPayloadNotEnoughParameters() {\n \t\tMap<String, Object> params = new HashMap<>();\n \t\tparams.put(\"p1\", \"foo\");\n \t\tMessage<?> message = MessageBuilder.withPayload(params).build();\n-\t\thandler.handleMessage(message);\n-\t\tMessage<?> reply = outputChannel.receive(0);\n-\t\tassertThat(reply).isNotNull();\n-\t\tassertThat(reply.getPayload()).isEqualTo(\"foobar\");\n+\t\tassertThatExceptionOfType(MessagingException.class)\n+\t\t\t\t.isThrownBy(() -> handler.handleMessage(message));\n \t}\n \n \t@Test\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/AttributePollingChannelAdapterParserTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/AttributePollingChannelAdapterParserTests.java\nindex 2ca8bc9ec86..2b566adc6a7 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/AttributePollingChannelAdapterParserTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/AttributePollingChannelAdapterParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,8 +16,7 @@\n \n package org.springframework.integration.jmx.config;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Qualifier;\n@@ -27,8 +26,7 @@\n import org.springframework.messaging.MessageChannel;\n import org.springframework.messaging.PollableChannel;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -38,8 +36,7 @@\n  *\n  * @since 2.0\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class AttributePollingChannelAdapterParserTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/ControlBusParserTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/ControlBusParserTests.java\nindex a1648074bd7..93524be7511 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/ControlBusParserTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/ControlBusParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,15 +16,14 @@\n \n package org.springframework.integration.jmx.config;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.context.ApplicationContext;\n import org.springframework.integration.core.MessagingTemplate;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.junit4.SpringRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -35,7 +34,7 @@\n  *\n  * @since 2.0\n  */\n-@RunWith(SpringRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class ControlBusParserTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/CustomObjectNameTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/CustomObjectNameTests.java\nindex ddaf589f3ef..be1ad37d9a0 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/CustomObjectNameTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/CustomObjectNameTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2015-2022 the original author or authors.\n+ * Copyright 2015-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -25,8 +25,7 @@\n import javax.management.MBeanServer;\n import javax.management.ObjectName;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.aop.support.AopUtils;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -39,8 +38,7 @@\n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageHandler;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n import org.springframework.transaction.PlatformTransactionManager;\n import org.springframework.transaction.annotation.Transactional;\n \n@@ -51,8 +49,7 @@\n  * @author Gary Russell\n  * @since 4.2.1\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class CustomObjectNameTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/DynamicRouterTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/DynamicRouterTests.java\nindex 19834444da2..eb23cc7c51a 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/DynamicRouterTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/DynamicRouterTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,9 +19,8 @@\n import java.util.HashMap;\n import java.util.Map;\n \n-import org.junit.Ignore;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Qualifier;\n@@ -31,8 +30,7 @@\n import org.springframework.messaging.PollableChannel;\n import org.springframework.messaging.support.GenericMessage;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -41,8 +39,7 @@\n  * @author Gary Russell\n  *\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class DynamicRouterTests {\n \n@@ -119,7 +116,7 @@ public void testRouteChangeMapNamedArgs() throws Exception {\n \n \t@Test\n \t@DirtiesContext\n-\t@Ignore\n+\t@Disabled\n \tpublic void testPerf() throws Exception {\n //\t\tthis.nullChannel.enableStats(false);\n \t\tfor (int i = 0; i < 1000000000; i++) {\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanAutoDetectTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanAutoDetectTests.java\nindex 1d42cac627f..c7708be5977 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanAutoDetectTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanAutoDetectTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,8 +21,8 @@\n import javax.management.MBeanServer;\n import javax.management.ObjectName;\n \n-import org.junit.After;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.context.support.ClassPathXmlApplicationContext;\n \n@@ -40,7 +40,7 @@ public class MBeanAutoDetectTests {\n \n \tprivate ClassPathXmlApplicationContext context;\n \n-\t@After\n+\t@AfterEach\n \tpublic void close() {\n \t\tif (context != null) {\n \t\t\tcontext.close();\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanExporterNameTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanExporterNameTests.java\nindex 7ae997eeac9..40843c8fd90 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanExporterNameTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanExporterNameTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,7 +16,8 @@\n \n package org.springframework.integration.jmx.config;\n \n-import org.junit.Test;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.parsing.BeanDefinitionParsingException;\n import org.springframework.context.support.ClassPathXmlApplicationContext;\n@@ -27,9 +28,10 @@\n  */\n public class MBeanExporterNameTests {\n \n-\t@Test(expected = BeanDefinitionParsingException.class)\n-\tpublic void testHandlerMBeanRegistration() throws Exception {\n-\t\tnew ClassPathXmlApplicationContext(getClass().getSimpleName() + \"-context.xml\", getClass()).close();\n+\t@Test\n+\tpublic void testHandlerMBeanRegistration() {\n+\t\tAssertions.assertThatExceptionOfType(BeanDefinitionParsingException.class)\n+\t\t\t\t.isThrownBy(() -> new ClassPathXmlApplicationContext(getClass().getSimpleName() + \"-context.xml\", getClass()));\n \t}\n \n \tpublic static class Source {\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanRegistrationCustomNamingTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanRegistrationCustomNamingTests.java\nindex b03858d3c9b..708fdb74de6 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanRegistrationCustomNamingTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanRegistrationCustomNamingTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2024 the original author or authors.\n+ * Copyright 2013-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -22,15 +22,13 @@\n import javax.management.MalformedObjectNameException;\n import javax.management.ObjectName;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.jmx.export.naming.KeyNamingStrategy;\n import org.springframework.jmx.export.naming.ObjectNamingStrategy;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -39,8 +37,7 @@\n  * @author Gary Russell\n  * @since 3.0\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class MBeanRegistrationCustomNamingTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanRegistrationTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanRegistrationTests.java\nindex d5b143a85f8..6ab99862c6a 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanRegistrationTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MBeanRegistrationTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -24,15 +24,13 @@\n import javax.management.MBeanServer;\n import javax.management.ObjectName;\n \n-import org.junit.Ignore;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.integration.gateway.MessagingGatewaySupport;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -41,8 +39,7 @@\n  * @author Gary Russell\n  * @since 2.0\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class MBeanRegistrationTests {\n \n@@ -78,7 +75,7 @@ public void testExporterMBeanRegistration() throws Exception {\n \t}\n \n \t@Test\n-\t@Ignore // re-instate this if Spring decides to look for @ManagedResource on super classes\n+\t@Disabled // re-instate this if Spring decides to look for @ManagedResource on super classes\n \tpublic void testServiceActivatorMBeanHasTrackableComponent() throws Exception {\n \t\tSet<ObjectName> names = server.queryNames(new ObjectName(\"test.MBeanRegistration:type=ServiceActivatingHandler,name=service,*\"), null);\n \t\tMap<String, MBeanOperationInfo> infos = new HashMap<String, MBeanOperationInfo>();\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MessageStoreTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MessageStoreTests.java\nindex 95adc91ab5d..fe2cb2a5a50 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MessageStoreTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MessageStoreTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,13 +21,11 @@\n import javax.management.MBeanServer;\n import javax.management.ObjectName;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -36,8 +34,7 @@\n  * @author Gary Russell\n  * @since 2.0\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class MessageStoreTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MethodInvokerTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MethodInvokerTests.java\nindex 12059468480..5e1b74b19f2 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MethodInvokerTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/MethodInvokerTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,16 +21,14 @@\n import javax.management.MBeanServer;\n import javax.management.ObjectName;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.integration.support.MessageBuilder;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.messaging.SubscribableChannel;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -39,8 +37,7 @@\n  * @author Gary Russell\n  * @since 2.0\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class MethodInvokerTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/NotificationListeningChannelAdapterParserTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/NotificationListeningChannelAdapterParserTests.java\nindex 54ef908e26f..cf6b8ab8ab8 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/NotificationListeningChannelAdapterParserTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/NotificationListeningChannelAdapterParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,8 +18,7 @@\n \n import javax.management.Notification;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Qualifier;\n@@ -29,8 +28,7 @@\n import org.springframework.messaging.MessageChannel;\n import org.springframework.messaging.PollableChannel;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -39,8 +37,7 @@\n  * @author Gary Russell\n  * @since 2.0\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class NotificationListeningChannelAdapterParserTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/NotificationPublishingChannelAdapterParserTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/NotificationPublishingChannelAdapterParserTests.java\nindex 54309d38455..ccb50133160 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/NotificationPublishingChannelAdapterParserTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/NotificationPublishingChannelAdapterParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -25,9 +25,8 @@\n import javax.management.ObjectInstance;\n import javax.management.ObjectName;\n \n-import org.junit.After;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -38,8 +37,7 @@\n import org.springframework.messaging.MessageChannel;\n import org.springframework.messaging.MessageHandler;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.fail;\n@@ -50,8 +48,7 @@\n  * @author Gary Russell\n  * @since 2.0\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class NotificationPublishingChannelAdapterParserTests {\n \n@@ -72,7 +69,7 @@ public class NotificationPublishingChannelAdapterParserTests {\n \n \tprivate static volatile int adviceCalled;\n \n-\t@After\n+\t@AfterEach\n \tpublic void clearListener() {\n \t\tlistener.lastNotification = null;\n \t}\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/OperationInvokingOutboundGatewayTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/OperationInvokingOutboundGatewayTests.java\nindex 1d36ccf6911..3eab92afe12 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/OperationInvokingOutboundGatewayTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/OperationInvokingOutboundGatewayTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,9 +21,8 @@\n import java.util.List;\n import java.util.Map;\n \n-import org.junit.After;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Qualifier;\n@@ -38,8 +37,7 @@\n import org.springframework.messaging.PollableChannel;\n import org.springframework.messaging.support.GenericMessage;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.fail;\n@@ -50,8 +48,7 @@\n  * @author Gary Russell\n  *\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class OperationInvokingOutboundGatewayTests {\n \n@@ -79,7 +76,7 @@ public class OperationInvokingOutboundGatewayTests {\n \n \tprivate static volatile int adviceCalled;\n \n-\t@After\n+\t@AfterEach\n \tpublic void resetLists() {\n \t\ttestBean.messages.clear();\n \t}\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/PollingAdapterMBeanTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/PollingAdapterMBeanTests.java\nindex a042fa87c3c..ef671cd299b 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/PollingAdapterMBeanTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/PollingAdapterMBeanTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,13 +21,11 @@\n import javax.management.MBeanServer;\n import javax.management.ObjectName;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -36,8 +34,7 @@\n  * @author Gary Russell\n  * @since 2.0\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class PollingAdapterMBeanTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/PriorityChannelTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/PriorityChannelTests.java\nindex 56e3cd72f52..b48f2d29a3b 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/PriorityChannelTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/PriorityChannelTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,15 +21,13 @@\n import javax.management.MBeanServer;\n import javax.management.ObjectName;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.integration.channel.QueueChannelOperations;\n import org.springframework.messaging.PollableChannel;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -38,8 +36,7 @@\n  * @author Gary Russell\n  * @since 2.0\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class PriorityChannelTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/RouterMBeanTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/RouterMBeanTests.java\nindex 5a191e93a4e..2506f0b5656 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/RouterMBeanTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/RouterMBeanTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,11 +23,9 @@\n import javax.management.MBeanServer;\n import javax.management.ObjectName;\n \n-import org.junit.After;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameters;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n \n import org.springframework.context.support.ClassPathXmlApplicationContext;\n \n@@ -37,59 +35,65 @@\n  * @author Dave Syer\n  * @since 2.0\n  */\n-@RunWith(Parameterized.class)\n public class RouterMBeanTests {\n \n-\tprivate final MBeanServer server;\n+\tprivate MBeanServer server;\n \n-\tprivate final ClassPathXmlApplicationContext context;\n+\tprivate ClassPathXmlApplicationContext context;\n \n-\tpublic RouterMBeanTests(String configLocation) {\n+\tpublic void initContext(String configLocation) {\n \t\tcontext = new ClassPathXmlApplicationContext(configLocation, getClass());\n \t\tserver = context.getBean(MBeanServer.class);\n \t}\n \n-\t@Parameters\n-\tpublic static List<Object[]> getParameters() {\n+\tpublic static List<String> contexts() {\n \t\treturn Arrays.asList(\n-\t\t\t\tnew Object[] {\"RouterMBeanTests-context.xml\"},\n-\t\t\t\tnew Object[] {\"RouterMBeanGatewayTests-context.xml\"},\n-\t\t\t\tnew Object[] {\"RouterMBeanNoneTests-context.xml\"},\n-\t\t\t\tnew Object[] {\"RouterMBeanSwitchTests-context.xml\"});\n+\t\t\t\t\"RouterMBeanTests-context.xml\",\n+\t\t\t\t\"RouterMBeanGatewayTests-context.xml\",\n+\t\t\t\t\"RouterMBeanNoneTests-context.xml\",\n+\t\t\t\t\"RouterMBeanSwitchTests-context.xml\");\n \t}\n \n-\t@After\n+\t@AfterEach\n \tpublic void close() {\n \t\tif (context != null) {\n \t\t\tcontext.close();\n \t\t}\n \t}\n \n-\t@Test\n-\tpublic void testRouterMBeanExists() throws Exception {\n+\t@ParameterizedTest\n+\t@MethodSource(\"contexts\")\n+\tpublic void testRouterMBeanExists(String context) throws Exception {\n+\t\tinitContext(context);\n \t\t// System . err.println(server.queryNames(new ObjectName(\"test.RouterMBean:*\"), null));\n \t\tSet<ObjectName> names = server.queryNames(\n \t\t\t\tnew ObjectName(\"test.RouterMBean:type=MessageHandler,name=ptRouter,*\"), null);\n \t\tassertThat(names.size()).isEqualTo(1);\n \t}\n \n-\t@Test\n-\tpublic void testInputChannelMBeanExists() throws Exception {\n+\t@ParameterizedTest\n+\t@MethodSource(\"contexts\")\n+\tpublic void testInputChannelMBeanExists(String context) throws Exception {\n+\t\tinitContext(context);\n \t\t// System . err.println(server.queryNames(new ObjectName(\"test.RouterMBean:type=MessageChannel,*\"), null));\n \t\tSet<ObjectName> names = server.queryNames(\n \t\t\t\tnew ObjectName(\"test.RouterMBean:type=MessageChannel,name=testChannel,*\"), null);\n \t\tassertThat(names.size()).isEqualTo(1);\n \t}\n \n-\t@Test\n-\tpublic void testErrorChannelMBeanExists() throws Exception {\n+\t@ParameterizedTest\n+\t@MethodSource(\"contexts\")\n+\tpublic void testErrorChannelMBeanExists(String context) throws Exception {\n+\t\tinitContext(context);\n \t\tSet<ObjectName> names = server.queryNames(\n \t\t\t\tnew ObjectName(\"test.RouterMBean:type=MessageChannel,name=errorChannel,*\"), null);\n \t\tassertThat(names.size()).isEqualTo(1);\n \t}\n \n-\t@Test\n-\tpublic void testRouterMBeanOnlyRegisteredOnce() throws Exception {\n+\t@ParameterizedTest\n+\t@MethodSource(\"contexts\")\n+\tpublic void testRouterMBeanOnlyRegisteredOnce(String context) throws Exception {\n+\t\tinitContext(context);\n \t\t// System . err.println(server.queryNames(new ObjectName(\"*:type=MessageHandler,*\"), null));\n \t\tSet<ObjectName> names = server.queryNames(new ObjectName(\"test.RouterMBean:type=MessageHandler,name=ptRouter,*\"), null);\n \t\tassertThat(names.size()).isEqualTo(1);\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/RouterMBeanVanillaTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/RouterMBeanVanillaTests.java\nindex ea38bddbe09..658315e7d6e 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/RouterMBeanVanillaTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/jmx/config/RouterMBeanVanillaTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,13 +21,11 @@\n import javax.management.MBeanServer;\n import javax.management.ObjectName;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -36,8 +34,7 @@\n  * @author Gary Russell\n  * @since 2.0\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class RouterMBeanVanillaTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/ChainWithMessageProducingHandlersTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/ChainWithMessageProducingHandlersTests.java\nindex e3eb35bbce7..d6188f8afbb 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/ChainWithMessageProducingHandlersTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/ChainWithMessageProducingHandlersTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,14 +16,12 @@\n \n package org.springframework.integration.monitor;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.context.ApplicationContext;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -33,8 +31,7 @@\n  * @author Gary Russell\n  *\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class ChainWithMessageProducingHandlersTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/HandlerMonitoringIntegrationTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/HandlerMonitoringIntegrationTests.java\nindex c813f555371..502e24e0542 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/HandlerMonitoringIntegrationTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/HandlerMonitoringIntegrationTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2009-2022 the original author or authors.\n+ * Copyright 2009-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -22,7 +22,7 @@\n import org.apache.commons.logging.LogFactory;\n import org.aspectj.lang.annotation.Aspect;\n import org.aspectj.lang.annotation.Before;\n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.config.AutowireCapableBeanFactory;\n import org.springframework.context.support.ClassPathXmlApplicationContext;\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/MBeanExporterIntegrationTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/MBeanExporterIntegrationTests.java\nindex 69d6aa77193..eafa30ce31d 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/MBeanExporterIntegrationTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/MBeanExporterIntegrationTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2009-2022 the original author or authors.\n+ * Copyright 2009-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -24,8 +24,8 @@\n import javax.management.MBeanServer;\n import javax.management.ObjectName;\n \n-import org.junit.After;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.aop.framework.Advised;\n import org.springframework.beans.factory.FactoryBean;\n@@ -66,7 +66,7 @@ public class MBeanExporterIntegrationTests {\n \n \tprivate GenericXmlApplicationContext context;\n \n-\t@After\n+\t@AfterEach\n \tpublic void close() {\n \t\tif (context != null) {\n \t\t\tcontext.close();\n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/MessagingGatewaySupportRegistrationTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/MessagingGatewaySupportRegistrationTests.java\nindex c5a222dcf93..c692f3fa5c2 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/MessagingGatewaySupportRegistrationTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/MessagingGatewaySupportRegistrationTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2015-2022 the original author or authors.\n+ * Copyright 2015-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -21,8 +21,7 @@\n import javax.management.MBeanServer;\n import javax.management.ObjectName;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.context.annotation.Bean;\n@@ -34,8 +33,7 @@\n import org.springframework.jmx.support.MBeanServerFactoryBean;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -44,8 +42,7 @@\n  * @author Gary Russell\n  * @since 4.2.1\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class MessagingGatewaySupportRegistrationTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/RemoteMBeanServerTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/RemoteMBeanServerTests.java\nindex afa198616ef..429f91651b4 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/RemoteMBeanServerTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/RemoteMBeanServerTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,8 +18,7 @@\n \n import javax.management.Notification;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.messaging.Message;\n@@ -27,8 +26,7 @@\n import org.springframework.messaging.PollableChannel;\n import org.springframework.messaging.support.GenericMessage;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -44,8 +42,7 @@\n  * @since 2.2\n  *\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class RemoteMBeanServerTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/TransformerContextTests.java b/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/TransformerContextTests.java\nindex a8f97e9309e..cf8ac1043ac 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/TransformerContextTests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration/monitor/TransformerContextTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,8 +16,7 @@\n \n package org.springframework.integration.monitor;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.context.ApplicationContext;\n@@ -29,7 +28,7 @@\n import org.springframework.messaging.PollableChannel;\n import org.springframework.messaging.support.GenericMessage;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -38,7 +37,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  */\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class TransformerContextTests {\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration_/mbeanexporterhelper/INT_2626Tests.java b/spring-integration-jmx/src/test/java/org/springframework/integration_/mbeanexporterhelper/INT_2626Tests.java\nindex 4f4c9f47a8a..1928f1b282c 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration_/mbeanexporterhelper/INT_2626Tests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration_/mbeanexporterhelper/INT_2626Tests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,7 +16,7 @@\n \n package org.springframework.integration_.mbeanexporterhelper;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.context.support.ClassPathXmlApplicationContext;\n \n\ndiff --git a/spring-integration-jmx/src/test/java/org/springframework/integration_/mbeanexporterhelper/Int2307Tests.java b/spring-integration-jmx/src/test/java/org/springframework/integration_/mbeanexporterhelper/Int2307Tests.java\nindex faf20418c6e..f61e49a8110 100644\n--- a/spring-integration-jmx/src/test/java/org/springframework/integration_/mbeanexporterhelper/Int2307Tests.java\n+++ b/spring-integration-jmx/src/test/java/org/springframework/integration_/mbeanexporterhelper/Int2307Tests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -22,7 +22,7 @@\n import javax.management.MBeanServer;\n import javax.management.ObjectInstance;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.context.support.ClassPathXmlApplicationContext;\n import org.springframework.integration.test.util.TestUtils;\n\ndiff --git a/spring-integration-jpa/src/test/java/org/springframework/integration/jpa/config/xml/JpaMessageHandlerParserTests.java b/spring-integration-jpa/src/test/java/org/springframework/integration/jpa/config/xml/JpaMessageHandlerParserTests.java\nindex a83962a2318..218bde5e202 100644\n--- a/spring-integration-jpa/src/test/java/org/springframework/integration/jpa/config/xml/JpaMessageHandlerParserTests.java\n+++ b/spring-integration-jpa/src/test/java/org/springframework/integration/jpa/config/xml/JpaMessageHandlerParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,8 +18,8 @@\n \n import java.util.List;\n \n-import org.junit.After;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.aop.support.AopUtils;\n import org.springframework.context.ConfigurableApplicationContext;\n@@ -210,7 +210,7 @@ public void testJpaExecutorBeanIdNaming() throws Exception {\n \n \t}\n \n-\t@After\n+\t@AfterEach\n \tpublic void tearDown() {\n \t\tif (context != null) {\n \t\t\tcontext.close();\n\ndiff --git a/spring-integration-jpa/src/test/java/org/springframework/integration/jpa/inbound/JpaPollingChannelAdapterUnitTests.java b/spring-integration-jpa/src/test/java/org/springframework/integration/jpa/inbound/JpaPollingChannelAdapterUnitTests.java\nindex ef977f3ca02..88f614e2a74 100644\n--- a/spring-integration-jpa/src/test/java/org/springframework/integration/jpa/inbound/JpaPollingChannelAdapterUnitTests.java\n+++ b/spring-integration-jpa/src/test/java/org/springframework/integration/jpa/inbound/JpaPollingChannelAdapterUnitTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,7 +16,7 @@\n \n package org.springframework.integration.jpa.inbound;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.integration.jpa.core.JpaExecutor;\n \n\ndiff --git a/spring-integration-redis/src/test/java/org/springframework/integration/redis/config/RedisQueueOutboundGatewayParserTests.java b/spring-integration-redis/src/test/java/org/springframework/integration/redis/config/RedisQueueOutboundGatewayParserTests.java\nindex 6b27b488f75..30023f8c597 100644\n--- a/spring-integration-redis/src/test/java/org/springframework/integration/redis/config/RedisQueueOutboundGatewayParserTests.java\n+++ b/spring-integration-redis/src/test/java/org/springframework/integration/redis/config/RedisQueueOutboundGatewayParserTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2022 the original author or authors.\n+ * Copyright 2014-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,8 +16,7 @@\n \n package org.springframework.integration.redis.config;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Qualifier;\n@@ -27,8 +26,7 @@\n import org.springframework.integration.test.util.TestUtils;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -37,8 +35,7 @@\n  * @author Gary Russell\n  * since 4.1\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class RedisQueueOutboundGatewayParserTests {\n \n\ndiff --git a/spring-integration-stream/src/test/java/org/springframework/integration/stream/ByteStreamSourceTests.java b/spring-integration-stream/src/test/java/org/springframework/integration/stream/ByteStreamSourceTests.java\nindex 26ddbce716e..bf915cb24ed 100644\n--- a/spring-integration-stream/src/test/java/org/springframework/integration/stream/ByteStreamSourceTests.java\n+++ b/spring-integration-stream/src/test/java/org/springframework/integration/stream/ByteStreamSourceTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,7 +18,7 @@\n \n import java.io.ByteArrayInputStream;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.messaging.Message;\n\ndiff --git a/spring-integration-stream/src/test/java/org/springframework/integration/stream/ByteStreamWritingMessageHandlerTests.java b/spring-integration-stream/src/test/java/org/springframework/integration/stream/ByteStreamWritingMessageHandlerTests.java\nindex 0fe69f93cd6..9a981e7db54 100644\n--- a/spring-integration-stream/src/test/java/org/springframework/integration/stream/ByteStreamWritingMessageHandlerTests.java\n+++ b/spring-integration-stream/src/test/java/org/springframework/integration/stream/ByteStreamWritingMessageHandlerTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,9 +19,9 @@\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n \n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.integration.channel.QueueChannel;\n@@ -51,7 +51,7 @@ public class ByteStreamWritingMessageHandlerTests {\n \n \tprivate ThreadPoolTaskScheduler scheduler;\n \n-\t@Before\n+\t@BeforeEach\n \tpublic void initialize() {\n \t\tstream = new ByteArrayOutputStream();\n \t\thandler = new ByteStreamWritingMessageHandler(stream);\n@@ -65,7 +65,7 @@ public void initialize() {\n \t\tendpoint.setBeanFactory(mock(BeanFactory.class));\n \t}\n \n-\t@After\n+\t@AfterEach\n \tpublic void stop() throws Exception {\n \t\tscheduler.destroy();\n \t}\n\ndiff --git a/spring-integration-syslog/src/test/java/org/springframework/integration/syslog/inbound/SyslogDeserializerTests.java b/spring-integration-syslog/src/test/java/org/springframework/integration/syslog/inbound/SyslogDeserializerTests.java\nindex 8c848b5b233..ce1d0a0ce91 100644\n--- a/spring-integration-syslog/src/test/java/org/springframework/integration/syslog/inbound/SyslogDeserializerTests.java\n+++ b/spring-integration-syslog/src/test/java/org/springframework/integration/syslog/inbound/SyslogDeserializerTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014-2022 the original author or authors.\n+ * Copyright 2014-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -20,7 +20,7 @@\n import java.util.List;\n import java.util.Map;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import org.springframework.integration.syslog.SyslogHeaders;\n \n\ndiff --git a/spring-integration-test-support/src/main/java/org/springframework/integration/test/rule/Log4j2LevelAdjuster.java b/spring-integration-test-support/src/main/java/org/springframework/integration/test/rule/Log4j2LevelAdjuster.java\nindex 83c3e925c1c..44bc04ea6d0 100644\n--- a/spring-integration-test-support/src/main/java/org/springframework/integration/test/rule/Log4j2LevelAdjuster.java\n+++ b/spring-integration-test-support/src/main/java/org/springframework/integration/test/rule/Log4j2LevelAdjuster.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018-2024 the original author or authors.\n+ * Copyright 2018-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -24,6 +24,7 @@\n import org.junit.runners.model.FrameworkMethod;\n import org.junit.runners.model.Statement;\n \n+import org.springframework.integration.test.condition.LogLevels;\n import org.springframework.integration.test.util.TestUtils;\n import org.springframework.integration.test.util.TestUtils.LevelsContainer;\n import org.springframework.util.Assert;\n@@ -37,10 +38,13 @@\n  *\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Jiandong Ma\n  *\n  * @since 5.0.1\n  *\n+ * @deprecated since 7.0 in favor of {@link LogLevels}\n  */\n+@Deprecated(since = \"7.0\", forRemoval = true)\n public final class Log4j2LevelAdjuster implements MethodRule {\n \n \tprivate final Class<?>[] classes;\n\ndiff --git a/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/AbstractRequestResponseScenarioTest.java b/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/AbstractRequestResponseScenarioTest.java\nnew file mode 100644\nindex 00000000000..ebc595af133\n--- /dev/null\n+++ b/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/AbstractRequestResponseScenarioTest.java\n@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2002-2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.test.support;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageChannel;\n+import org.springframework.messaging.PollableChannel;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+/**\n+ * Convenience class for testing Spring Integration request-response message scenarios.\n+ * Users create subclasses to execute on or more {@link RequestResponseScenario} tests.\n+ * each scenario defines:\n+ * <ul>\n+ * <li>An inputChannelName</li>\n+ * <li>An outputChannelName</li>\n+ * <li>A payload or message to send as a request message on the inputChannel</li>\n+ * <li>A handler to validate the response received on the outputChannel</li>\n+ * </ul>\n+ *\n+ * @author David Turanski\n+ * @author Gary Russell\n+ * @author Artem Bilan\n+ * @author Jiandong Ma\n+ */\n+@SpringJUnitConfig\n+@DirtiesContext\n+public abstract class AbstractRequestResponseScenarioTest {\n+\n+\tprivate List<RequestResponseScenario> scenarios = null;\n+\n+\t@Autowired\n+\tprivate ApplicationContext applicationContext;\n+\n+\t@BeforeEach\n+\tpublic void setUp() {\n+\t\tscenarios = defineRequestResponseScenarios();\n+\t}\n+\n+\t/**\n+\t * Execute each scenario. Instantiate the message channels, send the request message\n+\t * on the input channel and invoke the validator on the response received on the\n+\t * output channel. This can handle subscribable or pollable output channels.\n+\t */\n+\t@Test\n+\tpublic void testRequestResponseScenarios() {\n+\t\tint i = 1;\n+\t\tfor (RequestResponseScenario scenario : scenarios) {\n+\t\t\tString name = scenario.getName() == null ? \"scenario-\" + (i++) : scenario.getName();\n+\t\t\tscenario.init();\n+\t\t\tMessageChannel inputChannel = applicationContext.getBean(scenario.getInputChannelName(),\n+\t\t\t\t\tMessageChannel.class);\n+\t\t\tMessageChannel outputChannel = applicationContext.getBean(scenario.getOutputChannelName(),\n+\t\t\t\t\tMessageChannel.class);\n+\t\t\tif (outputChannel instanceof SubscribableChannel) {\n+\t\t\t\t((SubscribableChannel) outputChannel).subscribe(scenario.getResponseValidator());\n+\t\t\t}\n+\n+\t\t\tassertThat(inputChannel.send(scenario.getMessage()))\n+\t\t\t\t\t.as(name + \": message not sent on \" + scenario.getInputChannelName()).isTrue();\n+\n+\t\t\tif (outputChannel instanceof PollableChannel) {\n+\t\t\t\tMessage<?> response = ((PollableChannel) outputChannel).receive(10000); // NOSONAR magic number\n+\t\t\t\tassertThat(response).as(name + \": receive timeout on \" + scenario.getOutputChannelName()).isNotNull();\n+\t\t\t\tscenario.getResponseValidator().handleMessage(response);\n+\t\t\t}\n+\n+\t\t\tassertThat(scenario.getResponseValidator().getLastMessage())\n+\t\t\t\t\t.as(\"message was not handled on \" + outputChannel + \" for scenario '\" + name + \"'.\").isNotNull();\n+\n+\t\t\tif (outputChannel instanceof SubscribableChannel) {\n+\t\t\t\t((SubscribableChannel) outputChannel).unsubscribe(scenario.getResponseValidator());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Implement this method to define RequestResponse scenarios\n+\t * @return - A List of {@link RequestResponseScenario}\n+\t */\n+\tprotected abstract List<RequestResponseScenario> defineRequestResponseScenarios();\n+\n+}\n\ndiff --git a/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/AbstractRequestResponseScenarioTests.java b/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/AbstractRequestResponseScenarioTests.java\nindex c777d4c9763..343bbf8ac90 100644\n--- a/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/AbstractRequestResponseScenarioTests.java\n+++ b/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/AbstractRequestResponseScenarioTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -47,9 +47,13 @@\n  * @author David Turanski\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Jiandong Ma\n+ *\n+ * @deprecated since 7.0 in favor of {@link AbstractRequestResponseScenarioTest}\n  */\n @RunWith(SpringJUnit4ClassRunner.class)\n @DirtiesContext\n+@Deprecated(since = \"7.0\", forRemoval = true)\n public abstract class AbstractRequestResponseScenarioTests {\n \n \tprivate List<RequestResponseScenario> scenarios = null;\n\ndiff --git a/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/LongRunningIntegrationTest.java b/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/LongRunningIntegrationTest.java\nindex 5577e9f1eeb..ebcbd186ca5 100644\n--- a/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/LongRunningIntegrationTest.java\n+++ b/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/LongRunningIntegrationTest.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2022 the original author or authors.\n+ * Copyright 2013-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,16 +23,21 @@\n import org.junit.runner.Description;\n import org.junit.runners.model.Statement;\n \n+import org.springframework.integration.test.condition.LongRunningTest;\n+\n /**\n  * Rule to prevent long running tests from running on every build; set environment\n  * variable RUN_LONG_INTEGRATION_TESTS on a CI nightly build to ensure coverage.\n  *\n  * @author Gary Russell\n  * @author Artem Bilan\n+ * @author Jiandong Ma\n  *\n  * @since 3.0\n  *\n+ * @deprecated since 7.0 in favor of {@link LongRunningTest}.\n  */\n+@Deprecated(since = \"7.0\", forRemoval = true)\n public class LongRunningIntegrationTest extends TestWatcher {\n \n \tprivate static final Log LOGGER = LogFactory.getLog(LongRunningIntegrationTest.class);\n\ndiff --git a/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/SingleRequestResponseScenarioTest.java b/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/SingleRequestResponseScenarioTest.java\nnew file mode 100644\nindex 00000000000..a14cf36c0e7\n--- /dev/null\n+++ b/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/SingleRequestResponseScenarioTest.java\n@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2002-2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.test.support;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Convenience class for a single {@link RequestResponseScenario} test\n+ *\n+ * @author David Turanski\n+ * @author Jiandong Ma\n+ *\n+ */\n+public abstract class SingleRequestResponseScenarioTest extends AbstractRequestResponseScenarioTest {\n+\n+\t@Override\n+\tprotected List<RequestResponseScenario> defineRequestResponseScenarios() {\n+\t\treturn Collections.singletonList(defineRequestResponseScenario());\n+\t}\n+\n+\tprotected abstract RequestResponseScenario defineRequestResponseScenario();\n+\n+}\n\ndiff --git a/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/SingleRequestResponseScenarioTests.java b/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/SingleRequestResponseScenarioTests.java\nindex 1cafdc3377d..0e53de83c79 100644\n--- a/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/SingleRequestResponseScenarioTests.java\n+++ b/spring-integration-test-support/src/main/java/org/springframework/integration/test/support/SingleRequestResponseScenarioTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2019 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,7 +23,11 @@\n  * Convenience class for a single {@link RequestResponseScenario} test\n  *\n  * @author David Turanski\n+ * @author Jiandong Ma\n+ *\n+ * @deprecated since 7.0 in favor of {@link SingleRequestResponseScenarioTest}\n  */\n+@Deprecated(since = \"7.0\", forRemoval = true)\n public abstract class SingleRequestResponseScenarioTests extends AbstractRequestResponseScenarioTests {\n \n \t@Override\n\ndiff --git a/spring-integration-test-support/src/test/java/org/springframework/integration/test/matcher/MockitoMessageMatchersTests.java b/spring-integration-test-support/src/test/java/org/springframework/integration/test/matcher/MockitoMessageMatchersTests.java\nindex a74a47bf534..4d99c68b8fa 100644\n--- a/spring-integration-test-support/src/test/java/org/springframework/integration/test/matcher/MockitoMessageMatchersTests.java\n+++ b/spring-integration-test-support/src/test/java/org/springframework/integration/test/matcher/MockitoMessageMatchersTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2022 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,12 +19,9 @@\n import java.util.Date;\n \n import org.hamcrest.Matchers;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.mockito.Mock;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;\n-import org.mockito.junit.MockitoJUnitRunner;\n \n import org.springframework.messaging.Message;\n import org.springframework.messaging.MessageChannel;\n@@ -33,6 +30,7 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n@@ -43,7 +41,6 @@\n  * @author Artem Bilan\n  *\n  */\n-@RunWith(MockitoJUnitRunner.Silent.class)\n public class MockitoMessageMatchersTests {\n \n \tstatic final Date SOME_PAYLOAD = new Date();\n@@ -52,15 +49,13 @@ public class MockitoMessageMatchersTests {\n \n \tstatic final String SOME_HEADER_KEY = \"test.foo\";\n \n-\t@Mock\n-\tMessageHandler handler;\n+\tMessageHandler handler = mock();\n \n-\t@Mock\n-\tMessageChannel channel;\n+\tMessageChannel channel = mock();\n \n \tMessage<Date> message;\n \n-\t@Before\n+\t@BeforeEach\n \tpublic void setUp() {\n \t\tthis.message =\n \t\t\t\tMessageBuilder.withPayload(SOME_PAYLOAD)\n\ndiff --git a/spring-integration-ws/src/test/java/org/springframework/integration/ws/DefaultSoapHeaderMapperTests.java b/spring-integration-ws/src/test/java/org/springframework/integration/ws/DefaultSoapHeaderMapperTests.java\nindex 956a9322f89..933af38af52 100644\n--- a/spring-integration-ws/src/test/java/org/springframework/integration/ws/DefaultSoapHeaderMapperTests.java\n+++ b/spring-integration-ws/src/test/java/org/springframework/integration/ws/DefaultSoapHeaderMapperTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -29,7 +29,7 @@\n import jakarta.xml.soap.MimeHeaders;\n import jakarta.xml.soap.SOAPException;\n import jakarta.xml.soap.SOAPMessage;\n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n import org.w3c.dom.NodeList;\n \n import org.springframework.messaging.MessageHeaders;\n\ndiff --git a/spring-integration-ws/src/test/java/org/springframework/integration/ws/WebServiceInboundGatewayJavaConfigTests.java b/spring-integration-ws/src/test/java/org/springframework/integration/ws/WebServiceInboundGatewayJavaConfigTests.java\nindex 21680776a8e..daab6a4d1cd 100644\n--- a/spring-integration-ws/src/test/java/org/springframework/integration/ws/WebServiceInboundGatewayJavaConfigTests.java\n+++ b/spring-integration-ws/src/test/java/org/springframework/integration/ws/WebServiceInboundGatewayJavaConfigTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2024 the original author or authors.\n+ * Copyright 2016-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -23,8 +23,7 @@\n import javax.xml.transform.Source;\n import javax.xml.transform.stream.StreamResult;\n \n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import org.junit.jupiter.api.Test;\n import org.w3c.dom.Element;\n \n import org.springframework.beans.factory.annotation.Autowired;\n@@ -43,8 +42,7 @@\n import org.springframework.messaging.MessageChannel;\n import org.springframework.messaging.PollableChannel;\n import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n import org.springframework.ws.config.annotation.EnableWs;\n import org.springframework.ws.context.MessageContext;\n import org.springframework.ws.server.EndpointMapping;\n@@ -70,8 +68,7 @@\n  * @author Artem Bilan\n  * @since 4.3\n  */\n-@ContextConfiguration\n-@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringJUnitConfig\n @DirtiesContext\n public class WebServiceInboundGatewayJavaConfigTests {\n \n\ndiff --git a/src/reference/antora/modules/ROOT/pages/testing.adoc b/src/reference/antora/modules/ROOT/pages/testing.adoc\nindex 74017affd61..8ea5df57e9e 100644\n--- a/src/reference/antora/modules/ROOT/pages/testing.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/testing.adoc\n@@ -114,20 +114,18 @@ public void testWithEntityClass() throws Exception {\n \n The `org.springframework.integration.test.support` package contains various abstract classes that you should implement in target tests\n \n-* https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/AbstractRequestResponseScenarioTests.html[`AbstractRequestResponseScenarioTests`]\n+* https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/AbstractRequestResponseScenarioTest.html[`AbstractRequestResponseScenarioTest`]\n * https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/AbstractResponseValidator.html[`AbstractResponseValidator`]\n-* https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/LogAdjustingTestSupport.html[`LogAdjustingTestSupport`] (Deprecated)\n * https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/MessageValidator.html[`MessageValidator`]\n * https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/PayloadValidator.html[`PayloadValidator`]\n * https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/RequestResponseScenario.html[`RequestResponseScenario`]\n-* https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/SingleRequestResponseScenarioTests.html[`SingleRequestResponseScenarioTests`]\n+* https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/SingleRequestResponseScenarioTest.html[`SingleRequestResponseScenarioTest`]\n \n-[[test-junit-rules]]\n-=== JUnit Rules and Conditions\n+[[test-junit-conditions]]\n+=== JUnit Conditions\n \n-The `LongRunningIntegrationTest` JUnit 4 test rule is present to indicate if test should be run if `RUN_LONG_INTEGRATION_TESTS` environment or system property is set to `true`.\n+The `@LongRunningTest` conditional annotation is present to indicate if test should be run if `RUN_LONG_INTEGRATION_TESTS` environment or system property is set to `true`.\n Otherwise, it is skipped.\n-For the same reason since version 5.1, a `@LongRunningTest` conditional annotation is provided for JUnit 5 tests.\n \n [[hamcrest-and-mockito-matchers]]\n === Hamcrest and Mockito Matchers\n@@ -231,7 +229,7 @@ After test is performed you can restore the state of endpoint beans to the real\n \n [source,java]\n ----\n-@After\n+@AfterEach\n public void tearDown() {\n     this.mockIntegrationContext.resetBeans();\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-10081",
    "pr_id": 10081,
    "issue_id": 8467,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Add spring-integration DSL support for JDBC [INT-4529]\n**[Dietrich Schulten](https://jira.spring.io/secure/ViewProfile.jspa?name=dschulten)** opened **[INT-4529](https://jira.spring.io/browse/INT-4529?redirect=false)** and commented\n\nFor JDBC we do not have the same comfort as with other integrations like Http etc.\n\nhttps://stackoverflow.com/a/46712252/743507asks to create a Jira issue for that - which hereby exists:o)\n\nPlease add `Jdbc.outboundGateway()` etc.\n\n---\n\n**Reference URL:** https://stackoverflow.com/a/46712252/743507\n\nThis issue is a sub-task of #8104\n\n1 votes, 2 watchers\n",
    "issue_word_count": 93,
    "test_files_count": 2,
    "non_test_files_count": 8,
    "pr_changed_files": [
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/Jdbc.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcInboundChannelAdapterSpec.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcOutboundChannelAdapterSpec.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcOutboundGatewaySpec.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcStoredProcInboundChannelAdapterSpec.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcStoredProcOutboundChannelAdapterSpec.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcStoredProcOutboundGatewaySpec.java",
      "spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/StoredProcExecutorConfigurer.java",
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/dsl/JdbcTest.java",
      "spring-integration-jdbc/src/test/resources/dsl-h2.sql"
    ],
    "pr_changed_test_files": [
      "spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/dsl/JdbcTest.java",
      "spring-integration-jdbc/src/test/resources/dsl-h2.sql"
    ],
    "base_commit": "66d76a3aa3575eedd37f0e366c9a283e4e4cb2d4",
    "head_commit": "0f0052c9d13b225af662784f236fcd7b561ecf9e",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/10081",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/10081",
    "dockerfile": "",
    "pr_merged_at": "2025-06-06T16:30:41.000Z",
    "patch": "diff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/Jdbc.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/Jdbc.java\nnew file mode 100644\nindex 00000000000..ca7e716355c\n--- /dev/null\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/Jdbc.java\n@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.jdbc.dsl;\n+\n+import javax.sql.DataSource;\n+\n+import org.springframework.integration.jdbc.StoredProcExecutor;\n+import org.springframework.jdbc.core.JdbcOperations;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+\n+/**\n+ * Factory class for JDBC components.\n+ *\n+ * @author Jiandong Ma\n+ *\n+ * @since 7.0\n+ */\n+public final class Jdbc {\n+\n+\t/**\n+\t * The factory to produce a {@link JdbcInboundChannelAdapterSpec}.\n+\t * @param dataSource the {@link DataSource} to build on\n+\t * @param selectQuery the select query to build on\n+\t * @return the {@link JdbcInboundChannelAdapterSpec} instance\n+\t */\n+\tpublic static JdbcInboundChannelAdapterSpec inboundAdapter(DataSource dataSource, String selectQuery) {\n+\t\treturn inboundAdapter(new JdbcTemplate(dataSource), selectQuery);\n+\t}\n+\n+\t/**\n+\t * The factory to produce a {@link JdbcInboundChannelAdapterSpec}.\n+\t * @param jdbcOperations the {@link JdbcOperations} to build on\n+\t * @param selectQuery the select query to build on\n+\t * @return the {@link JdbcInboundChannelAdapterSpec} instance\n+\t */\n+\tpublic static JdbcInboundChannelAdapterSpec inboundAdapter(JdbcOperations jdbcOperations, String selectQuery) {\n+\t\treturn new JdbcInboundChannelAdapterSpec(jdbcOperations, selectQuery);\n+\t}\n+\n+\t/**\n+\t * The factory to produce a {@link JdbcOutboundChannelAdapterSpec}.\n+\t * @param dataSource the {@link DataSource} to build on\n+\t * @param updateQuery the update query to build on\n+\t * @return the {@link JdbcOutboundChannelAdapterSpec} instance\n+\t */\n+\tpublic static JdbcOutboundChannelAdapterSpec outboundAdapter(DataSource dataSource, String updateQuery) {\n+\t\treturn outboundAdapter(new JdbcTemplate(dataSource), updateQuery);\n+\t}\n+\n+\t/**\n+\t * The factory to produce a {@link JdbcOutboundChannelAdapterSpec}.\n+\t * @param jdbcOperations the {@link JdbcOperations} to build on\n+\t * @param updateQuery the update query to build on\n+\t * @return the {@link JdbcOutboundChannelAdapterSpec} instance\n+\t */\n+\tpublic static JdbcOutboundChannelAdapterSpec outboundAdapter(JdbcOperations jdbcOperations, String updateQuery) {\n+\t\treturn new JdbcOutboundChannelAdapterSpec(jdbcOperations, updateQuery);\n+\t}\n+\n+\t/**\n+\t * The factory to produce a {@link JdbcOutboundGatewaySpec}.\n+\t * @param dataSource the {@link DataSource} to build on\n+\t * @param updateQuery the update query to build on\n+\t * @return the {@link JdbcOutboundGatewaySpec} instance\n+\t */\n+\tpublic static JdbcOutboundGatewaySpec outboundGateway(DataSource dataSource, String updateQuery) {\n+\t\treturn outboundGateway(new JdbcTemplate(dataSource), updateQuery);\n+\t}\n+\n+\t/**\n+\t * The factory to produce a {@link JdbcOutboundGatewaySpec}.\n+\t * @param dataSource the {@link DataSource} to build on\n+\t * @param updateQuery the update query to build on\n+\t * @param selectQuery the select query to build on\n+\t * @return the {@link JdbcOutboundGatewaySpec} instance\n+\t */\n+\tpublic static JdbcOutboundGatewaySpec outboundGateway(DataSource dataSource, String updateQuery, String selectQuery) {\n+\t\treturn outboundGateway(new JdbcTemplate(dataSource), updateQuery, selectQuery);\n+\t}\n+\n+\t/**\n+\t * The factory to produce a {@link JdbcOutboundGatewaySpec}.\n+\t * @param jdbcOperations the {@link JdbcOperations} to build on\n+\t * @param updateQuery the update query to build on\n+\t * @return the {@link JdbcOutboundGatewaySpec} instance\n+\t */\n+\tpublic static JdbcOutboundGatewaySpec outboundGateway(JdbcOperations jdbcOperations, String updateQuery) {\n+\t\treturn outboundGateway(jdbcOperations, updateQuery, null);\n+\t}\n+\n+\t/**\n+\t * The factory to produce a {@link JdbcOutboundGatewaySpec}.\n+\t * @param jdbcOperations the {@link JdbcOperations} to build on\n+\t * @param updateQuery the update query to build on\n+\t * @param selectQuery the select query to build on\n+\t * @return the {@link JdbcOutboundGatewaySpec} instance\n+\t */\n+\tpublic static JdbcOutboundGatewaySpec outboundGateway(JdbcOperations jdbcOperations, String updateQuery, String selectQuery) {\n+\t\treturn new JdbcOutboundGatewaySpec(jdbcOperations, updateQuery, selectQuery);\n+\t}\n+\n+\t/**\n+\t * The factory to produce a {@link JdbcStoredProcInboundChannelAdapterSpec}.\n+\t * @param dataSource the {@link DataSource} to build on\n+\t * @return the {@link JdbcStoredProcInboundChannelAdapterSpec} instance\n+\t */\n+\tpublic static JdbcStoredProcInboundChannelAdapterSpec storedProcInboundAdapter(DataSource dataSource) {\n+\t\treturn new JdbcStoredProcInboundChannelAdapterSpec(new StoredProcExecutor(dataSource));\n+\t}\n+\n+\t/**\n+\t * The factory to produce a {@link JdbcStoredProcOutboundChannelAdapterSpec}.\n+\t * @param dataSource the {@link DataSource} to build on\n+\t * @return the {@link JdbcStoredProcOutboundChannelAdapterSpec} instance\n+\t */\n+\tpublic static JdbcStoredProcOutboundChannelAdapterSpec storedProcOutboundAdapter(DataSource dataSource) {\n+\t\treturn new JdbcStoredProcOutboundChannelAdapterSpec(new StoredProcExecutor(dataSource));\n+\t}\n+\n+\t/**\n+\t * The factory to produce a {@link JdbcStoredProcOutboundGatewaySpec}.\n+\t * @param dataSource the {@link DataSource} to build on\n+\t * @return the {@link JdbcStoredProcOutboundGatewaySpec} instance\n+\t */\n+\tpublic static JdbcStoredProcOutboundGatewaySpec storedProcOutboundGateway(DataSource dataSource) {\n+\t\treturn new JdbcStoredProcOutboundGatewaySpec(new StoredProcExecutor(dataSource));\n+\t}\n+\n+\tprivate Jdbc() {\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcInboundChannelAdapterSpec.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcInboundChannelAdapterSpec.java\nnew file mode 100644\nindex 00000000000..611f5a95b25\n--- /dev/null\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcInboundChannelAdapterSpec.java\n@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.jdbc.dsl;\n+\n+import org.springframework.integration.dsl.MessageSourceSpec;\n+import org.springframework.integration.jdbc.JdbcPollingChannelAdapter;\n+import org.springframework.integration.jdbc.SqlParameterSourceFactory;\n+import org.springframework.jdbc.core.JdbcOperations;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.SqlParameterSource;\n+\n+/**\n+ * A {@link MessageSourceSpec} for a {@link JdbcInboundChannelAdapterSpec}.\n+ *\n+ * @author Jiandong Ma\n+ *\n+ * @since 7.0\n+ */\n+public class JdbcInboundChannelAdapterSpec extends MessageSourceSpec<JdbcInboundChannelAdapterSpec, JdbcPollingChannelAdapter> {\n+\n+\tprotected JdbcInboundChannelAdapterSpec(JdbcOperations jdbcOperations, String selectQuery) {\n+\t\tthis.target = new JdbcPollingChannelAdapter(jdbcOperations, selectQuery);\n+\t}\n+\n+\t/**\n+\t * @param rowMapper the rowMapper\n+\t * @return the spec\n+\t * @see JdbcPollingChannelAdapter#setRowMapper(RowMapper)\n+\t */\n+\tpublic JdbcInboundChannelAdapterSpec rowMapper(RowMapper<?> rowMapper) {\n+\t\tthis.target.setRowMapper(rowMapper);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param updateSql the updateSql\n+\t * @return the spec\n+\t * @see JdbcPollingChannelAdapter#setUpdateSql(String)\n+\t */\n+\tpublic JdbcInboundChannelAdapterSpec updateSql(String updateSql) {\n+\t\tthis.target.setUpdateSql(updateSql);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param updatePerRow the updatePerRow\n+\t * @return the spec\n+\t * @see JdbcPollingChannelAdapter#setUpdatePerRow(boolean)\n+\t */\n+\tpublic JdbcInboundChannelAdapterSpec updatePerRow(boolean updatePerRow) {\n+\t\tthis.target.setUpdatePerRow(updatePerRow);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param sqlParameterSourceFactory the sqlParameterSourceFactory\n+\t * @return the spec\n+\t * @see JdbcPollingChannelAdapter#setUpdateSqlParameterSourceFactory(SqlParameterSourceFactory)\n+\t */\n+\tpublic JdbcInboundChannelAdapterSpec updateSqlParameterSourceFactory(SqlParameterSourceFactory sqlParameterSourceFactory) {\n+\t\tthis.target.setUpdateSqlParameterSourceFactory(sqlParameterSourceFactory);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param sqlQueryParameterSource the sqlQueryParameterSource\n+\t * @return the spec\n+\t * @see JdbcPollingChannelAdapter#setSelectSqlParameterSource(SqlParameterSource)\n+\t */\n+\tpublic JdbcInboundChannelAdapterSpec selectSqlParameterSource(SqlParameterSource sqlQueryParameterSource) {\n+\t\tthis.target.setSelectSqlParameterSource(sqlQueryParameterSource);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param maxRows the maxRows\n+\t * @return the spec\n+\t * @see JdbcPollingChannelAdapter#setMaxRows(int)\n+\t */\n+\tpublic JdbcInboundChannelAdapterSpec maxRows(int maxRows) {\n+\t\tthis.target.setMaxRows(maxRows);\n+\t\treturn _this();\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcOutboundChannelAdapterSpec.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcOutboundChannelAdapterSpec.java\nnew file mode 100644\nindex 00000000000..547bb1026db\n--- /dev/null\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcOutboundChannelAdapterSpec.java\n@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.jdbc.dsl;\n+\n+import org.springframework.integration.dsl.MessageHandlerSpec;\n+import org.springframework.integration.jdbc.JdbcMessageHandler;\n+import org.springframework.integration.jdbc.MessagePreparedStatementSetter;\n+import org.springframework.integration.jdbc.SqlParameterSourceFactory;\n+import org.springframework.jdbc.core.JdbcOperations;\n+\n+/**\n+ * A {@link MessageHandlerSpec} for a {@link JdbcOutboundChannelAdapterSpec}.\n+ *\n+ * @author Jiandong Ma\n+ *\n+ * @since 7.0\n+ */\n+public class JdbcOutboundChannelAdapterSpec extends MessageHandlerSpec<JdbcOutboundChannelAdapterSpec, JdbcMessageHandler> {\n+\n+\tprotected JdbcOutboundChannelAdapterSpec(JdbcOperations jdbcOperations, String updateQuery) {\n+\t\tthis.target = new JdbcMessageHandler(jdbcOperations, updateQuery);\n+\t}\n+\n+\t/**\n+\t * @param keysGenerated the keysGenerated\n+\t * @return the spec\n+\t * @see JdbcMessageHandler#setKeysGenerated(boolean)\n+\t */\n+\tpublic JdbcOutboundChannelAdapterSpec keysGenerated(boolean keysGenerated) {\n+\t\tthis.target.setKeysGenerated(keysGenerated);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param sqlParameterSourceFactory the sqlParameterSourceFactory\n+\t * @return the spec\n+\t * @see JdbcMessageHandler#setSqlParameterSourceFactory(SqlParameterSourceFactory)\n+\t */\n+\tpublic JdbcOutboundChannelAdapterSpec sqlParameterSourceFactory(SqlParameterSourceFactory sqlParameterSourceFactory) {\n+\t\tthis.target.setSqlParameterSourceFactory(sqlParameterSourceFactory);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param usePayloadAsParameterSource the usePayloadAsParameterSource\n+\t * @return the spec\n+\t * @see JdbcMessageHandler#setUsePayloadAsParameterSource(boolean)\n+\t */\n+\tpublic JdbcOutboundChannelAdapterSpec usePayloadAsParameterSource(boolean usePayloadAsParameterSource) {\n+\t\tthis.target.setUsePayloadAsParameterSource(usePayloadAsParameterSource);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param preparedStatementSetter the preparedStatementSetter\n+\t * @return the spec\n+\t * @see JdbcMessageHandler#setPreparedStatementSetter(MessagePreparedStatementSetter)\n+\t */\n+\tpublic JdbcOutboundChannelAdapterSpec preparedStatementSetter(MessagePreparedStatementSetter preparedStatementSetter) {\n+\t\tthis.target.setPreparedStatementSetter(preparedStatementSetter);\n+\t\treturn _this();\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcOutboundGatewaySpec.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcOutboundGatewaySpec.java\nnew file mode 100644\nindex 00000000000..385f606cbb5\n--- /dev/null\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcOutboundGatewaySpec.java\n@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.jdbc.dsl;\n+\n+import org.springframework.integration.dsl.MessageHandlerSpec;\n+import org.springframework.integration.jdbc.JdbcOutboundGateway;\n+import org.springframework.integration.jdbc.MessagePreparedStatementSetter;\n+import org.springframework.integration.jdbc.SqlParameterSourceFactory;\n+import org.springframework.jdbc.core.JdbcOperations;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+/**\n+ * A {@link MessageHandlerSpec} for a {@link JdbcOutboundGatewaySpec}.\n+ *\n+ * @author Jiandong Ma\n+ *\n+ * @since 7.0\n+ */\n+public class JdbcOutboundGatewaySpec extends MessageHandlerSpec<JdbcOutboundGatewaySpec, JdbcOutboundGateway> {\n+\n+\tprotected JdbcOutboundGatewaySpec(JdbcOperations jdbcOperations, String updateQuery, String selectQuery) {\n+\t\tthis.target = new JdbcOutboundGateway(jdbcOperations, updateQuery, selectQuery);\n+\t}\n+\n+\t/**\n+\t * @param maxRows the maxRows\n+\t * @return the spec\n+\t * @see JdbcOutboundGateway#setMaxRows(Integer)\n+\t */\n+\tpublic JdbcOutboundGatewaySpec maxRows(Integer maxRows) {\n+\t\tthis.target.setMaxRows(maxRows);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param keysGenerated the keysGenerated\n+\t * @return the spec\n+\t * @see JdbcOutboundGateway#setKeysGenerated(boolean)\n+\t */\n+\tpublic JdbcOutboundGatewaySpec keysGenerated(boolean keysGenerated) {\n+\t\tthis.target.setKeysGenerated(keysGenerated);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param sqlParameterSourceFactory the sqlParameterSourceFactory\n+\t * @return the spec\n+\t * @see JdbcOutboundGateway#setRequestSqlParameterSourceFactory(SqlParameterSourceFactory)\n+\t */\n+\tpublic JdbcOutboundGatewaySpec requestSqlParameterSourceFactory(SqlParameterSourceFactory sqlParameterSourceFactory) {\n+\t\tthis.target.setRequestSqlParameterSourceFactory(sqlParameterSourceFactory);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param preparedStatementSetter the preparedStatementSetter\n+\t * @return the spec\n+\t * @see JdbcOutboundGateway#setRequestPreparedStatementSetter(MessagePreparedStatementSetter)\n+\t */\n+\tpublic JdbcOutboundGatewaySpec requestPreparedStatementSetter(MessagePreparedStatementSetter preparedStatementSetter) {\n+\t\tthis.target.setRequestPreparedStatementSetter(preparedStatementSetter);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param sqlParameterSourceFactory the sqlQueryParameterSource\n+\t * @return the spec\n+\t * @see JdbcOutboundGateway#setReplySqlParameterSourceFactory(SqlParameterSourceFactory)\n+\t */\n+\tpublic JdbcOutboundGatewaySpec replySqlParameterSourceFactory(SqlParameterSourceFactory sqlParameterSourceFactory) {\n+\t\tthis.target.setReplySqlParameterSourceFactory(sqlParameterSourceFactory);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param rowMapper the rowMapper\n+\t * @return the spec\n+\t * @see JdbcOutboundGateway#setRowMapper(RowMapper)\n+\t */\n+\tpublic JdbcOutboundGatewaySpec rowMapper(RowMapper<?> rowMapper) {\n+\t\tthis.target.setRowMapper(rowMapper);\n+\t\treturn _this();\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcStoredProcInboundChannelAdapterSpec.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcStoredProcInboundChannelAdapterSpec.java\nnew file mode 100644\nindex 00000000000..30a6a308076\n--- /dev/null\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcStoredProcInboundChannelAdapterSpec.java\n@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.jdbc.dsl;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+import org.springframework.integration.dsl.ComponentsRegistration;\n+import org.springframework.integration.dsl.MessageSourceSpec;\n+import org.springframework.integration.jdbc.StoredProcExecutor;\n+import org.springframework.integration.jdbc.StoredProcPollingChannelAdapter;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * A {@link MessageSourceSpec} for a {@link JdbcStoredProcInboundChannelAdapterSpec}.\n+ *\n+ * @author Jiandong Ma\n+ *\n+ * @since 7.0\n+ */\n+public class JdbcStoredProcInboundChannelAdapterSpec\n+\t\textends MessageSourceSpec<JdbcStoredProcInboundChannelAdapterSpec, StoredProcPollingChannelAdapter>\n+\t\timplements ComponentsRegistration {\n+\n+\tprivate final StoredProcExecutor storedProcExecutor;\n+\n+\tprivate final StoredProcExecutorConfigurer storedProcExecutorConfigurer;\n+\n+\tprotected JdbcStoredProcInboundChannelAdapterSpec(StoredProcExecutor storedProcExecutor) {\n+\t\tthis.storedProcExecutor = storedProcExecutor;\n+\t\tthis.storedProcExecutorConfigurer = new StoredProcExecutorConfigurer(this.storedProcExecutor);\n+\t\tthis.target = new StoredProcPollingChannelAdapter(this.storedProcExecutor);\n+\t}\n+\n+\t/**\n+\t * Configure the storedProcExecutor through storedProcExecutorConfigurer by invoking the {@link Consumer} callback\n+\t * @param configurer the configurer.\n+\t * @return the spec\n+\t */\n+\tpublic JdbcStoredProcInboundChannelAdapterSpec configurerStoredProcExecutor(Consumer<StoredProcExecutorConfigurer> configurer) {\n+\t\tAssert.notNull(configurer, \"'configurer' must not be null\");\n+\t\tconfigurer.accept(this.storedProcExecutorConfigurer);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param expectSingleResult the expectSingleResult\n+\t * @return the spec\n+\t * @see StoredProcPollingChannelAdapter#setExpectSingleResult(boolean)\n+\t */\n+\tpublic JdbcStoredProcInboundChannelAdapterSpec expectSingleResult(boolean expectSingleResult) {\n+\t\tthis.target.setExpectSingleResult(expectSingleResult);\n+\t\treturn _this();\n+\t}\n+\n+\t@Override\n+\tpublic Map<Object, String> getComponentsToRegister() {\n+\t\treturn Collections.singletonMap(this.storedProcExecutor, null);\n+\t}\n+}\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcStoredProcOutboundChannelAdapterSpec.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcStoredProcOutboundChannelAdapterSpec.java\nnew file mode 100644\nindex 00000000000..d00bce59a02\n--- /dev/null\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcStoredProcOutboundChannelAdapterSpec.java\n@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.jdbc.dsl;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+import org.springframework.integration.dsl.ComponentsRegistration;\n+import org.springframework.integration.dsl.MessageHandlerSpec;\n+import org.springframework.integration.jdbc.StoredProcExecutor;\n+import org.springframework.integration.jdbc.StoredProcMessageHandler;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * A {@link MessageHandlerSpec} for a {@link JdbcStoredProcOutboundChannelAdapterSpec}.\n+ *\n+ * @author Jiandong Ma\n+ *\n+ * @since 7.0\n+ */\n+public class JdbcStoredProcOutboundChannelAdapterSpec\n+\t\textends MessageHandlerSpec<JdbcStoredProcOutboundChannelAdapterSpec, StoredProcMessageHandler>\n+\t\timplements ComponentsRegistration {\n+\n+\tprivate final StoredProcExecutor storedProcExecutor;\n+\n+\tprivate final StoredProcExecutorConfigurer storedProcExecutorConfigurer;\n+\n+\tprotected JdbcStoredProcOutboundChannelAdapterSpec(StoredProcExecutor storedProcExecutor) {\n+\t\tthis.storedProcExecutor = storedProcExecutor;\n+\t\tthis.storedProcExecutorConfigurer = new StoredProcExecutorConfigurer(this.storedProcExecutor);\n+\t\tthis.target = new StoredProcMessageHandler(this.storedProcExecutor);\n+\t}\n+\n+\t/**\n+\t * Configure the storedProcExecutor through storedProcExecutorConfigurer by invoking the {@link Consumer} callback\n+\t * @param configurer the configurer.\n+\t * @return the spec\n+\t */\n+\tpublic JdbcStoredProcOutboundChannelAdapterSpec configurerStoredProcExecutor(Consumer<StoredProcExecutorConfigurer> configurer) {\n+\t\tAssert.notNull(configurer, \"'configurer' must not be null\");\n+\t\tconfigurer.accept(this.storedProcExecutorConfigurer);\n+\t\treturn _this();\n+\t}\n+\n+\t@Override\n+\tpublic Map<Object, String> getComponentsToRegister() {\n+\t\treturn Collections.singletonMap(this.storedProcExecutor, null);\n+\t}\n+}\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcStoredProcOutboundGatewaySpec.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcStoredProcOutboundGatewaySpec.java\nnew file mode 100644\nindex 00000000000..dd7e97d9002\n--- /dev/null\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/JdbcStoredProcOutboundGatewaySpec.java\n@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.jdbc.dsl;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+import org.springframework.integration.dsl.ComponentsRegistration;\n+import org.springframework.integration.dsl.MessageHandlerSpec;\n+import org.springframework.integration.jdbc.StoredProcExecutor;\n+import org.springframework.integration.jdbc.StoredProcOutboundGateway;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * A {@link MessageHandlerSpec} for a {@link JdbcStoredProcOutboundGatewaySpec}.\n+ *\n+ * @author Jiandong Ma\n+ *\n+ * @since 7.0\n+ */\n+public class JdbcStoredProcOutboundGatewaySpec\n+\t\textends MessageHandlerSpec<JdbcStoredProcOutboundGatewaySpec, StoredProcOutboundGateway>\n+\t\timplements ComponentsRegistration {\n+\n+\tprivate final StoredProcExecutor storedProcExecutor;\n+\n+\tprivate final StoredProcExecutorConfigurer storedProcExecutorConfigurer;\n+\n+\tprotected JdbcStoredProcOutboundGatewaySpec(StoredProcExecutor storedProcExecutor) {\n+\t\tthis.storedProcExecutor = storedProcExecutor;\n+\t\tthis.storedProcExecutorConfigurer = new StoredProcExecutorConfigurer(this.storedProcExecutor);\n+\t\tthis.target = new StoredProcOutboundGateway(this.storedProcExecutor);\n+\t}\n+\n+\t/**\n+\t * Configure the storedProcExecutor through storedProcExecutorConfigurer by invoking the {@link Consumer} callback\n+\t * @param configurer the configurer.\n+\t * @return the spec\n+\t */\n+\tpublic JdbcStoredProcOutboundGatewaySpec configurerStoredProcExecutor(Consumer<StoredProcExecutorConfigurer> configurer) {\n+\t\tAssert.notNull(configurer, \"'configurer' must not be null\");\n+\t\tconfigurer.accept(this.storedProcExecutorConfigurer);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param requiresReply the requiresReply\n+\t * @return the spec\n+\t * @see StoredProcOutboundGateway#setRequiresReply(boolean)\n+\t */\n+\tpublic JdbcStoredProcOutboundGatewaySpec requiresReply(boolean requiresReply) {\n+\t\tthis.target.setRequiresReply(requiresReply);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * @param expectSingleResult the expectSingleResult\n+\t * @return the spec\n+\t * @see StoredProcOutboundGateway#setExpectSingleResult(boolean)\n+\t */\n+\tpublic JdbcStoredProcOutboundGatewaySpec expectSingleResult(boolean expectSingleResult) {\n+\t\tthis.target.setExpectSingleResult(expectSingleResult);\n+\t\treturn _this();\n+\t}\n+\n+\t@Override\n+\tpublic Map<Object, String> getComponentsToRegister() {\n+\t\treturn Collections.singletonMap(this.storedProcExecutor, null);\n+\t}\n+}\n\ndiff --git a/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/StoredProcExecutorConfigurer.java b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/StoredProcExecutorConfigurer.java\nnew file mode 100644\nindex 00000000000..509419899a4\n--- /dev/null\n+++ b/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/dsl/StoredProcExecutorConfigurer.java\n@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.jdbc.dsl;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.springframework.expression.Expression;\n+import org.springframework.integration.jdbc.SqlParameterSourceFactory;\n+import org.springframework.integration.jdbc.StoredProcExecutor;\n+import org.springframework.integration.jdbc.storedproc.ProcedureParameter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.SqlParameter;\n+\n+/**\n+ * A {@link StoredProcExecutor} configurer.\n+ *\n+ * @author Jiandong Ma\n+ *\n+ * @since 7.0\n+ */\n+public class StoredProcExecutorConfigurer {\n+\n+\tprivate final StoredProcExecutor storedProcExecutor;\n+\n+\tprotected StoredProcExecutorConfigurer(StoredProcExecutor storedProcExecutor) {\n+\t\tthis.storedProcExecutor = storedProcExecutor;\n+\t}\n+\n+\t/**\n+\t * @param ignoreColumnMetaData the ignoreColumnMetaData\n+\t * @return the storedProcExecutor\n+\t * @see StoredProcExecutor#setIgnoreColumnMetaData(boolean)\n+\t */\n+\tpublic StoredProcExecutorConfigurer ignoreColumnMetaData(boolean ignoreColumnMetaData) {\n+\t\tthis.storedProcExecutor.setIgnoreColumnMetaData(ignoreColumnMetaData);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * @param procedureParameters the procedureParameters\n+\t * @return the storedProcExecutor\n+\t * @see StoredProcExecutor#setProcedureParameters(List)\n+\t */\n+\tpublic StoredProcExecutorConfigurer procedureParameters(List<ProcedureParameter> procedureParameters) {\n+\t\tthis.storedProcExecutor.setProcedureParameters(procedureParameters);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * @param sqlParameters the sqlParameters\n+\t * @return the storedProcExecutor\n+\t * @see StoredProcExecutor#setSqlParameters(List)\n+\t */\n+\tpublic StoredProcExecutorConfigurer sqlParameters(List<SqlParameter> sqlParameters) {\n+\t\tthis.storedProcExecutor.setSqlParameters(sqlParameters);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * @param sqlParameterSourceFactory the sqlParameterSourceFactory\n+\t * @return the storedProcExecutor\n+\t * @see StoredProcExecutor#setSqlParameterSourceFactory(SqlParameterSourceFactory)\n+\t */\n+\tpublic StoredProcExecutorConfigurer sqlParameterSourceFactory(SqlParameterSourceFactory sqlParameterSourceFactory) {\n+\t\tthis.storedProcExecutor.setSqlParameterSourceFactory(sqlParameterSourceFactory);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * @param storedProcedureName the storedProcedureName\n+\t * @return the storedProcExecutor\n+\t * @see StoredProcExecutor#setStoredProcedureName(String)\n+\t */\n+\tpublic StoredProcExecutorConfigurer storedProcedureName(String storedProcedureName) {\n+\t\tthis.storedProcExecutor.setStoredProcedureName(storedProcedureName);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * @param storedProcedureNameExpression the storedProcedureNameExpression\n+\t * @return the storedProcExecutor\n+\t * @see StoredProcExecutor#setStoredProcedureNameExpression(Expression)\n+\t */\n+\tpublic StoredProcExecutorConfigurer storedProcedureNameExpression(Expression storedProcedureNameExpression) {\n+\t\tthis.storedProcExecutor.setStoredProcedureNameExpression(storedProcedureNameExpression);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * @param usePayloadAsParameterSource the usePayloadAsParameterSource\n+\t * @return the storedProcExecutor\n+\t * @see StoredProcExecutor#setUsePayloadAsParameterSource(boolean)\n+\t */\n+\tpublic StoredProcExecutorConfigurer usePayloadAsParameterSource(boolean usePayloadAsParameterSource) {\n+\t\tthis.storedProcExecutor.setUsePayloadAsParameterSource(usePayloadAsParameterSource);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * @param isFunction the isFunction\n+\t * @return the storedProcExecutor\n+\t * @see StoredProcExecutor#setIsFunction(boolean)\n+\t */\n+\tpublic StoredProcExecutorConfigurer isFunction(boolean isFunction) {\n+\t\tthis.storedProcExecutor.setIsFunction(isFunction);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * @param returnValueRequired the returnValueRequired\n+\t * @return the storedProcExecutor\n+\t * @see StoredProcExecutor#setReturnValueRequired(boolean)\n+\t */\n+\tpublic StoredProcExecutorConfigurer returnValueRequired(boolean returnValueRequired) {\n+\t\tthis.storedProcExecutor.setReturnValueRequired(returnValueRequired);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * @param skipUndeclaredResults the skipUndeclaredResults\n+\t * @return the storedProcExecutor\n+\t * @see StoredProcExecutor#setSkipUndeclaredResults(boolean)\n+\t */\n+\tpublic StoredProcExecutorConfigurer skipUndeclaredResults(boolean skipUndeclaredResults) {\n+\t\tthis.storedProcExecutor.setSkipUndeclaredResults(skipUndeclaredResults);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * @param returningResultSetRowMappers the returningResultSetRowMappers\n+\t * @return the storedProcExecutor\n+\t * @see StoredProcExecutor#setReturningResultSetRowMappers(Map)\n+\t */\n+\tpublic StoredProcExecutorConfigurer returningResultSetRowMappers(Map<String, RowMapper<?>> returningResultSetRowMappers) {\n+\t\tthis.storedProcExecutor.setReturningResultSetRowMappers(returningResultSetRowMappers);\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * @param jdbcCallOperationsCacheSize the jdbcCallOperationsCacheSize\n+\t * @return the storedProcExecutor\n+\t * @see StoredProcExecutor#setJdbcCallOperationsCacheSize(int)\n+\t */\n+\tpublic StoredProcExecutorConfigurer jdbcCallOperationsCacheSize(int jdbcCallOperationsCacheSize) {\n+\t\tthis.storedProcExecutor.setJdbcCallOperationsCacheSize(jdbcCallOperationsCacheSize);\n+\t\treturn this;\n+\t}\n+}\n",
    "test_patch": "diff --git a/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/dsl/JdbcTest.java b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/dsl/JdbcTest.java\nnew file mode 100644\nindex 00000000000..2e2eee6fcde\n--- /dev/null\n+++ b/spring-integration-jdbc/src/test/java/org/springframework/integration/jdbc/dsl/JdbcTest.java\n@@ -0,0 +1,377 @@\n+/*\n+ * Copyright 2016-2025 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.jdbc.dsl;\n+\n+import java.sql.CallableStatement;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.sql.DataSource;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.integration.channel.QueueChannel;\n+import org.springframework.integration.config.EnableIntegration;\n+import org.springframework.integration.dsl.IntegrationFlow;\n+import org.springframework.integration.expression.ValueExpression;\n+import org.springframework.integration.jdbc.BeanPropertySqlParameterSourceFactory;\n+import org.springframework.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory;\n+import org.springframework.integration.jdbc.config.JdbcTypesEnum;\n+import org.springframework.integration.jdbc.storedproc.ClobSqlReturnType;\n+import org.springframework.integration.jdbc.storedproc.PrimeMapper;\n+import org.springframework.integration.jdbc.storedproc.ProcedureParameter;\n+import org.springframework.integration.jdbc.storedproc.User;\n+import org.springframework.integration.support.MessageBuilder;\n+import org.springframework.integration.support.json.Jackson2JsonMessageParser;\n+import org.springframework.integration.support.json.JsonInboundMessageMapper;\n+import org.springframework.integration.support.json.JsonOutboundMessageMapper;\n+import org.springframework.integration.test.util.OnlyOnceTrigger;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.SqlOutParameter;\n+import org.springframework.jdbc.core.SqlParameter;\n+import org.springframework.jdbc.core.SqlReturnType;\n+import org.springframework.jdbc.datasource.DataSourceTransactionManager;\n+import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;\n+import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageChannel;\n+import org.springframework.messaging.support.GenericMessage;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n+import org.springframework.transaction.PlatformTransactionManager;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * @author Jiandong Ma\n+ *\n+ * @since 7.0\n+ */\n+@SpringJUnitConfig\n+@DirtiesContext\n+class JdbcTest {\n+\n+\t@Autowired\n+\tprivate JdbcTemplate h2JdbcTemplate;\n+\n+\t@Autowired\n+\tprivate JdbcTemplate derbyJdbcTemplate;\n+\n+\t@Autowired\n+\tprivate QueueChannel inboundFlowPollerChannel;\n+\n+\t@Autowired\n+\t@Qualifier(\"outboundFlow.input\")\n+\tprivate MessageChannel outboundFlowInputChannel;\n+\n+\t@Autowired\n+\t@Qualifier(\"outboundGateway.input\")\n+\tprivate MessageChannel outboundGatewayInputChannel;\n+\n+\t@Autowired\n+\tprivate QueueChannel outboundGatewayReplyChannel;\n+\n+\t@Autowired\n+\t@Qualifier(\"outboundGatewayNoSelectQuery.input\")\n+\tprivate MessageChannel outboundGatewayNoSelectQueryInputChannel;\n+\n+\t@Autowired\n+\tprivate QueueChannel outboundGatewayNoSelectQueryReplyChannel;\n+\n+\t@Autowired\n+\tprivate QueueChannel storedProcInboundPollerChannel;\n+\n+\t@Autowired\n+\t@Qualifier(\"storedProcOutboundAdapter.input\")\n+\tprivate MessageChannel storedProcOutboundFlowInputChannel;\n+\n+\t@Autowired\n+\t@Qualifier(\"storedProcOutboundGateway.input\")\n+\tprivate MessageChannel storedProcOutboundGatewayInputChannel;\n+\n+\t@Autowired\n+\tprivate QueueChannel storedProcOutboundGatewayReplyChannel;\n+\n+\t@Autowired\n+\tprivate SqlReturnType clobSqlReturnType;\n+\n+\t@Test\n+\tvoid testInboundFlow() {\n+\t\tMessage<?> message = this.inboundFlowPollerChannel.receive(10_000);\n+\t\tList<?> rows = (List<?>) message.getPayload();\n+\t\tassertThat(rows.size()).isEqualTo(2);\n+\t\tassertThat(rows.get(0) instanceof Inbound).isTrue();\n+\t\tInbound item = (Inbound) rows.get(0);\n+\t\tassertThat(item.id()).isEqualTo(1);\n+\t\tassertThat(item.status()).isEqualTo(2);\n+\n+\t\tInteger countOfStatusTwo = h2JdbcTemplate.queryForObject(\"select count(*) from inbound where status = 2\", Integer.class);\n+\t\tassertThat(countOfStatusTwo).isEqualTo(0);\n+\n+\t\tInteger countOfStatusTen = h2JdbcTemplate.queryForObject(\"select count(*) from inbound where status = 10\", Integer.class);\n+\t\tassertThat(countOfStatusTen).isEqualTo(2);\n+\t}\n+\n+\trecord Inbound(int id, int status) {\n+\t}\n+\n+\t@Test\n+\tvoid testOutboundFlow() {\n+\t\toutboundFlowInputChannel.send(new GenericMessage<>(\"foo\"));\n+\t\tMap<String, Object> map = h2JdbcTemplate.queryForMap(\"select * from outbound where id=?\", 1);\n+\t\tassertThat(map.get(\"name\")).isEqualTo(\"foo\");\n+\t}\n+\n+\t@Test\n+\tvoid testOutboundGateway() {\n+\t\toutboundGatewayInputChannel.send(new GenericMessage<>(10));\n+\t\tMessage<?> message = outboundGatewayReplyChannel.receive(10_000);\n+\t\tassertThat(message).isNotNull();\n+\t\tList<?> payload = (List<?>) message.getPayload();\n+\t\tassertThat(payload).hasSize(1);\n+\t\tObject item = payload.get(0);\n+\t\tassertThat(item).isInstanceOf(Map.class);\n+\t\tassertThat(((Map<?, ?>) item).get(\"status\")).isEqualTo(10);\n+\t}\n+\n+\t@Test\n+\tvoid testOutboundGatewayNoSelectQuery() {\n+\t\toutboundGatewayNoSelectQueryInputChannel.send(new GenericMessage<>(10));\n+\t\tMessage<?> message = outboundGatewayNoSelectQueryReplyChannel.receive(10_000);\n+\t\tassertThat(message).isNotNull();\n+\t\tObject payload = message.getPayload();\n+\t\tassertThat(payload).isInstanceOf(Map.class);\n+\t\tassertThat(((Map<?, ?>) payload).get(\"UPDATED\")).isEqualTo(1);\n+\t}\n+\n+\t@Test\n+\tvoid testStoredProcInboundFlow() {\n+\t\tMessage<?> message = this.storedProcInboundPollerChannel.receive(10_000);\n+\t\tassertThat(message).isNotNull();\n+\t\tObject payload = message.getPayload();\n+\t\tassertThat(payload).isNotNull();\n+\t\tassertThat(payload).isInstanceOf(List.class);\n+\n+\t\tList<Integer> primeNumbers = (List<Integer>) payload;\n+\n+\t\tassertThat(primeNumbers.size() == 4).isTrue();\n+\t}\n+\n+\t@Test\n+\tvoid testStoredProcOutboundFlow() {\n+\t\tstoredProcOutboundFlowInputChannel.send(MessageBuilder.withPayload(new User(\"username\", \"password\", \"email\")).build());\n+\t\tMap<String, Object> map = this.derbyJdbcTemplate.queryForMap(\"SELECT * FROM USERS WHERE USERNAME=?\", \"username\");\n+\t\tassertThat(map.get(\"USERNAME\")).as(\"Wrong username\").isEqualTo(\"username\");\n+\t\tassertThat(map.get(\"PASSWORD\")).as(\"Wrong password\").isEqualTo(\"password\");\n+\t\tassertThat(map.get(\"EMAIL\")).as(\"Wrong email\").isEqualTo(\"email\");\n+\t}\n+\n+\t@Test\n+\t@Transactional(transactionManager = \"derbyTransactionManager\")\n+\tvoid testStoredProcOutboundGateway() throws SQLException {\n+\t\tMockito.reset(this.clobSqlReturnType);\n+\t\tMessage<String> testMessage = MessageBuilder.withPayload(\"TEST\").setHeader(\"FOO\", \"BAR\").build();\n+\t\tString messageId = testMessage.getHeaders().getId().toString();\n+\t\tString jsonMessage = new JsonOutboundMessageMapper().fromMessage(testMessage);\n+\t\tthis.derbyJdbcTemplate.update(\"INSERT INTO json_message VALUES (?,?)\", messageId, jsonMessage);\n+\n+\t\tthis.storedProcOutboundGatewayInputChannel.send(new GenericMessage<>(messageId));\n+\t\tMessage<?> resultMessage = this.storedProcOutboundGatewayReplyChannel.receive(10_000);\n+\n+\t\tassertThat(resultMessage).isNotNull();\n+\t\tObject resultPayload = resultMessage.getPayload();\n+\t\tassertThat(resultPayload instanceof String).isTrue();\n+\t\tMessage<?> message = new JsonInboundMessageMapper(String.class, new Jackson2JsonMessageParser())\n+\t\t\t\t.toMessage((String) resultPayload);\n+\t\tassertThat(message.getPayload()).isEqualTo(testMessage.getPayload());\n+\t\tassertThat(message.getHeaders().get(\"FOO\")).isEqualTo(testMessage.getHeaders().get(\"FOO\"));\n+\t\tMockito.verify(clobSqlReturnType).getTypeValue(Mockito.any(CallableStatement.class),\n+\t\t\t\tMockito.eq(2), Mockito.eq(JdbcTypesEnum.CLOB.getCode()), Mockito.eq(null));\n+\n+\t}\n+\n+\t@Configuration\n+\t@EnableIntegration\n+\tpublic static class Config {\n+\n+\t\t@Bean\n+\t\tpublic IntegrationFlow inboundFlow(DataSource h2DataSource) {\n+\t\t\tvar sqlParameterSourceFactory = new ExpressionEvaluatingSqlParameterSourceFactory();\n+\t\t\tsqlParameterSourceFactory.setBeanFactory(mock());\n+\t\t\treturn IntegrationFlow.from(Jdbc.inboundAdapter(h2DataSource, \"select * from inbound\")\n+\t\t\t\t\t\t\t\t\t.maxRows(2)\n+\t\t\t\t\t\t\t\t\t.rowMapper((RowMapper<Inbound>) (rs, rowNum) -> new Inbound(rs.getInt(1), rs.getInt(2)))\n+\t\t\t\t\t\t\t\t\t.updateSql(\"update inbound set status = 10 where id in (:id)\")\n+\t\t\t\t\t\t\t\t\t.updatePerRow(false)\n+\t\t\t\t\t\t\t\t\t.updateSqlParameterSourceFactory(sqlParameterSourceFactory)\n+\t\t\t\t\t\t\t\t\t.selectSqlParameterSource(null),\n+\t\t\t\t\t\t\te -> e.poller(p -> p.trigger(new OnlyOnceTrigger())))\n+\t\t\t\t\t.channel(c -> c.queue(\"inboundFlowPollerChannel\"))\n+\t\t\t\t\t.get();\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic IntegrationFlow outboundFlow(DataSource h2DataSource) {\n+\t\t\treturn flow -> flow\n+\t\t\t\t\t.handle(Jdbc.outboundAdapter(h2DataSource, \"insert into outbound (id, status, name) values (1, 0, ?)\")\n+\t\t\t\t\t\t\t.preparedStatementSetter((ps, requestMessage) -> {\n+\t\t\t\t\t\t\t\tps.setObject(1, requestMessage.getPayload());\n+\t\t\t\t\t\t\t})\n+\t\t\t\t\t\t\t.usePayloadAsParameterSource(false)\n+\t\t\t\t\t\t\t.sqlParameterSourceFactory(null)\n+\t\t\t\t\t\t\t.keysGenerated(false)\n+\t\t\t\t\t);\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic IntegrationFlow outboundGateway(DataSource h2DataSource) {\n+\t\t\treturn flow -> flow\n+\t\t\t\t\t.handle(Jdbc.outboundGateway(h2DataSource,\n+\t\t\t\t\t\t\t\t\t\"update outbound_gateway set status = :payload where id = 1\",\n+\t\t\t\t\t\t\t\t\t\"select * from outbound_gateway where id = 1\")\n+\t\t\t\t\t\t\t.keysGenerated(false)\n+\t\t\t\t\t\t\t.requestSqlParameterSourceFactory(new BeanPropertySqlParameterSourceFactory())\n+\t\t\t\t\t\t\t.requestPreparedStatementSetter(null)\n+\t\t\t\t\t\t\t.replySqlParameterSourceFactory(new ExpressionEvaluatingSqlParameterSourceFactory())\n+\t\t\t\t\t\t\t.rowMapper(null)\n+\t\t\t\t\t\t\t.maxRows(0)\n+\t\t\t\t\t)\n+\t\t\t\t\t.channel(c -> c.queue(\"outboundGatewayReplyChannel\"));\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic IntegrationFlow outboundGatewayNoSelectQuery(DataSource h2DataSource) {\n+\t\t\treturn flow -> flow\n+\t\t\t\t\t.handle(Jdbc.outboundGateway(h2DataSource,\n+\t\t\t\t\t\t\t\"update outbound_gateway set status = :payload where id = 2\")\n+\t\t\t\t\t)\n+\t\t\t\t\t.channel(c -> c.queue(\"outboundGatewayNoSelectQueryReplyChannel\"));\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic IntegrationFlow storedProcInboundFlow(DataSource h2DataSource) {\n+\t\t\treturn IntegrationFlow.from(Jdbc.storedProcInboundAdapter(h2DataSource)\n+\t\t\t\t\t\t\t\t\t.expectSingleResult(true)\n+\t\t\t\t\t\t\t\t\t.configurerStoredProcExecutor(configurer -> configurer\n+\t\t\t\t\t\t\t\t\t\t\t.ignoreColumnMetaData(true)\n+\t\t\t\t\t\t\t\t\t\t\t.isFunction(false)\n+\t\t\t\t\t\t\t\t\t\t\t.storedProcedureName(\"GET_PRIME_NUMBERS\")\n+\t\t\t\t\t\t\t\t\t\t\t.procedureParameters(List.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnew ProcedureParameter(\"beginRange\", 1, null),\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnew ProcedureParameter(\"endRange\", 10, null)\n+\t\t\t\t\t\t\t\t\t\t\t))\n+\t\t\t\t\t\t\t\t\t\t\t.sqlParameters(List.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnew SqlParameter(\"beginRange\", Types.INTEGER),\n+\t\t\t\t\t\t\t\t\t\t\t\t\tnew SqlParameter(\"endRange\", Types.INTEGER)\n+\t\t\t\t\t\t\t\t\t\t\t))\n+\t\t\t\t\t\t\t\t\t\t\t.returningResultSetRowMappers(Map.of(\"out\", new PrimeMapper()))\n+\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\te -> e.poller(p -> p.trigger(new OnlyOnceTrigger())))\n+\t\t\t\t\t.channel(c -> c.queue(\"storedProcInboundPollerChannel\"))\n+\t\t\t\t\t.get();\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic IntegrationFlow storedProcOutboundAdapter(DataSource derbyDataSource) {\n+\t\t\treturn flow -> flow\n+\t\t\t\t\t.handle(Jdbc.storedProcOutboundAdapter(derbyDataSource)\n+\t\t\t\t\t\t\t.configurerStoredProcExecutor(configurer -> configurer\n+\t\t\t\t\t\t\t\t\t.storedProcedureName(\"CREATE_USER\")\n+\t\t\t\t\t\t\t\t\t.sqlParameterSourceFactory(new BeanPropertySqlParameterSourceFactory())\n+\t\t\t\t\t\t\t\t\t.usePayloadAsParameterSource(true)\n+\t\t\t\t\t\t\t)\n+\t\t\t\t\t);\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic IntegrationFlow storedProcOutboundGateway(DataSource derbyDataSource) throws Exception {\n+\n+\t\t\treturn flow -> flow\n+\t\t\t\t\t.handle(Jdbc.storedProcOutboundGateway(derbyDataSource)\n+\t\t\t\t\t\t\t.requiresReply(true)\n+\t\t\t\t\t\t\t.expectSingleResult(true)\n+\t\t\t\t\t\t\t.configurerStoredProcExecutor(configurer -> configurer\n+\t\t\t\t\t\t\t\t\t.storedProcedureNameExpression(new ValueExpression<>(\"GET_MESSAGE\"))\n+\t\t\t\t\t\t\t\t\t.ignoreColumnMetaData(false)\n+\t\t\t\t\t\t\t\t\t.isFunction(false)\n+\t\t\t\t\t\t\t\t\t.procedureParameters(List.of(\n+\t\t\t\t\t\t\t\t\t\t\tnew ProcedureParameter(\"message_id\", null, \"payload\")\n+\t\t\t\t\t\t\t\t\t))\n+\t\t\t\t\t\t\t\t\t.sqlParameters(List.of(\n+\t\t\t\t\t\t\t\t\t\t\tnew SqlParameter(\"message_id\", Types.VARCHAR),\n+\t\t\t\t\t\t\t\t\t\t\tnew SqlOutParameter(\"message_json\", Types.CLOB, null, clobSqlReturnType())\n+\t\t\t\t\t\t\t\t\t))\n+\t\t\t\t\t\t\t\t\t.returnValueRequired(false)\n+\t\t\t\t\t\t\t\t\t.skipUndeclaredResults(true)\n+\t\t\t\t\t\t\t\t\t.jdbcCallOperationsCacheSize(10)\n+\t\t\t\t\t\t\t))\n+\t\t\t\t\t.channel(c -> c.queue(\"storedProcOutboundGatewayReplyChannel\"));\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic ClobSqlReturnType clobSqlReturnType() {\n+\t\t\treturn Mockito.spy(new ClobSqlReturnType());\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic DataSource h2DataSource() {\n+\t\t\treturn new EmbeddedDatabaseBuilder()\n+\t\t\t\t\t.setType(EmbeddedDatabaseType.H2)\n+\t\t\t\t\t.addScripts(\"classpath:dsl-h2.sql\", \"classpath:h2-stored-procedures.sql\")\n+\t\t\t\t\t.build();\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic DataSource derbyDataSource() {\n+\t\t\treturn new EmbeddedDatabaseBuilder()\n+\t\t\t\t\t.setType(EmbeddedDatabaseType.DERBY)\n+\t\t\t\t\t.addScripts(\"classpath:derby-stored-procedures.sql\")\n+\t\t\t\t\t.build();\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic JdbcTemplate h2JdbcTemplate(DataSource h2DataSource) {\n+\t\t\treturn new JdbcTemplate(h2DataSource);\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic JdbcTemplate derbyJdbcTemplate(DataSource derbyDataSource) {\n+\t\t\treturn new JdbcTemplate(derbyDataSource);\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic PlatformTransactionManager h2TransactionManager() {\n+\t\t\treturn new DataSourceTransactionManager(h2DataSource());\n+\t\t}\n+\n+\t\t@Bean\n+\t\tpublic PlatformTransactionManager derbyTransactionManager() {\n+\t\t\treturn new DataSourceTransactionManager(derbyDataSource());\n+\t\t}\n+\t}\n+\n+}\n\ndiff --git a/spring-integration-jdbc/src/test/resources/dsl-h2.sql b/spring-integration-jdbc/src/test/resources/dsl-h2.sql\nnew file mode 100644\nindex 00000000000..f42fb973cc4\n--- /dev/null\n+++ b/spring-integration-jdbc/src/test/resources/dsl-h2.sql\n@@ -0,0 +1,10 @@\n+create table inbound(id int,status int);\n+insert into inbound values(1,2);\n+insert into inbound values(2,2);\n+\n+create table outbound(id varchar(100),status int,name varchar(20));\n+\n+create table outbound_gateway(id int,status int);\n+insert into outbound_gateway values(1,2);\n+insert into outbound_gateway values(2,2);\n+\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-10019",
    "pr_id": 10019,
    "issue_id": 9988,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "Support fileExistModeExpression() in Ftp.outboundGateway\n**Expected Behavior**\nThe `Ftp.outboundGateway` should support a `fileExistModeExpression()` method that accepts a SpEL expression to dynamically determine the FileExistsMode at runtime. This would allow users to conditionally choose between `REPLACE`, `APPEND`, `FAIL`, or other file exist modes based on message content or context variables.\n\n**Current Behavior**\nCurrently, the `Ftp.outboundGateway` only supports `fileExistMode()` which accepts a static FileExistsMode value. This mode is fixed at configuration time and cannot be changed dynamically during message processing.\n\n**Context**\nI'd be willing to implement this feature if the team agrees it would be valuable to the Spring Integration community.",
    "issue_word_count": 102,
    "test_files_count": 1,
    "non_test_files_count": 5,
    "pr_changed_files": [
      "spring-integration-file/src/main/java/org/springframework/integration/file/dsl/RemoteFileOutboundGatewaySpec.java",
      "spring-integration-file/src/main/java/org/springframework/integration/file/remote/RemoteFileTemplate.java",
      "spring-integration-file/src/main/java/org/springframework/integration/file/remote/gateway/AbstractRemoteFileOutboundGateway.java",
      "spring-integration-file/src/test/java/org/springframework/integration/file/remote/gateway/RemoteFileOutboundGatewayTests.java",
      "src/reference/antora/modules/ROOT/pages/ftp/rft.adoc",
      "src/reference/antora/modules/ROOT/pages/whats-new.adoc"
    ],
    "pr_changed_test_files": [
      "spring-integration-file/src/test/java/org/springframework/integration/file/remote/gateway/RemoteFileOutboundGatewayTests.java"
    ],
    "base_commit": "cf6f2d6fc2c559d20d62da85a828fed57d7783ca",
    "head_commit": "a04521467e36ddb9918706b5cfb2aa0029d9d63c",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/10019",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/10019",
    "dockerfile": "",
    "pr_merged_at": "2025-05-15T14:47:07.000Z",
    "patch": "diff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/dsl/RemoteFileOutboundGatewaySpec.java b/spring-integration-file/src/main/java/org/springframework/integration/file/dsl/RemoteFileOutboundGatewaySpec.java\nindex a566aea78a6..5e1a2b87463 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/dsl/RemoteFileOutboundGatewaySpec.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/dsl/RemoteFileOutboundGatewaySpec.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016-2023 the original author or authors.\n+ * Copyright 2016-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -44,6 +44,7 @@\n  *\n  * @author Artem Bilan\n  * @author Gary Russell\n+ * @author Jooyoung Pyoung\n  *\n  * @since 5.0\n  */\n@@ -358,6 +359,48 @@ public S fileExistsMode(FileExistsMode fileExistsMode) {\n \t\treturn _this();\n \t}\n \n+\t/**\n+\t * Specify a SpEL expression to determine the action to take when files already exist.\n+\t * Expression evaluation should return a {@link FileExistsMode} or a String representation.\n+\t * Used for GET and MGET operations when the file already exists locally,\n+\t * or PUT and MPUT when the file exists on the remote system.\n+\t * @param fileExistsModeExpression a SpEL expression to evaluate the file exists mode\n+\t * @return the Spec.\n+\t * @since 6.5\n+\t */\n+\tpublic S fileExistsModeExpression(Expression fileExistsModeExpression) {\n+\t\tthis.target.setFileExistsModeExpression(fileExistsModeExpression);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * Specify a SpEL expression to determine the action to take when files already exist.\n+\t * Expression evaluation should return a {@link FileExistsMode} or a String representation.\n+\t * Used for GET and MGET operations when the file already exists locally,\n+\t * or PUT and MPUT when the file exists on the remote system.\n+\t * @param fileExistsModeExpression the String in SpEL syntax.\n+\t * @return the Spec.\n+\t * @since 6.5\n+\t */\n+\tpublic S fileExistsModeExpression(String fileExistsModeExpression) {\n+\t\tthis.target.setFileExistsModeExpressionString(fileExistsModeExpression);\n+\t\treturn _this();\n+\t}\n+\n+\t/**\n+\t * Specify a {@link Function} to determine the action to take when files already exist.\n+\t * Expression evaluation should return a {@link FileExistsMode} or a String representation.\n+\t * Used for GET and MGET operations when the file already exists locally,\n+\t * or PUT and MPUT when the file exists on the remote system.\n+\t * @param fileExistsModeFunction the {@link Function} to use.\n+\t * @param <P> the expected payload type.\n+\t * @return the Spec.\n+\t * @since 6.5\n+\t */\n+\tpublic <P> S fileExistsModeFunction(Function<Message<P>, Object> fileExistsModeFunction) {\n+\t\treturn fileExistsModeExpression(new FunctionExpression<>(fileExistsModeFunction));\n+\t}\n+\n \t/**\n \t * Determine whether the remote directory should automatically be created when\n \t * sending files to the remote system.\n\ndiff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/remote/RemoteFileTemplate.java b/spring-integration-file/src/main/java/org/springframework/integration/file/remote/RemoteFileTemplate.java\nindex 28621adc837..456fac9c70c 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/remote/RemoteFileTemplate.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/remote/RemoteFileTemplate.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2024 the original author or authors.\n+ * Copyright 2013-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -63,6 +63,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Alen Turkovic\n+ * @author Jooyoung Pyoung\n  *\n  * @since 3.0\n  *\n@@ -303,8 +304,6 @@ public String send(Message<?> message, String subDirectory, FileExistsMode... mo\n \n \tprivate String send(Message<?> message, String subDirectory, FileExistsMode mode) {\n \t\tAssert.notNull(this.directoryExpressionProcessor, \"'remoteDirectoryExpression' is required\");\n-\t\tAssert.isTrue(!FileExistsMode.APPEND.equals(mode) || !this.useTemporaryFileName,\n-\t\t\t\t\"Cannot append when using a temporary file name\");\n \t\tAssert.isTrue(!FileExistsMode.REPLACE_IF_MODIFIED.equals(mode),\n \t\t\t\t\"FilExistsMode.REPLACE_IF_MODIFIED can only be used for local files\");\n \t\tfinal StreamHolder inputStreamHolder = payloadToInputStream(message);\n@@ -565,7 +564,10 @@ private void sendFileToRemoteDirectory(InputStream inputStream, String temporary\n \t\tString tempRemoteFilePath = temporaryRemoteDirectory + fileName;\n \t\t// write remote file first with temporary file extension if enabled\n \n-\t\tString tempFilePath = tempRemoteFilePath + (this.useTemporaryFileName ? this.temporaryFileSuffix : \"\");\n+\t\tString tempFilePath = tempRemoteFilePath;\n+\t\tif (!FileExistsMode.APPEND.equals(mode) && this.useTemporaryFileName) {\n+\t\t\ttempFilePath += this.temporaryFileSuffix;\n+\t\t}\n \n \t\tif (this.autoCreateDirectory) {\n \t\t\ttry {\n\ndiff --git a/spring-integration-file/src/main/java/org/springframework/integration/file/remote/gateway/AbstractRemoteFileOutboundGateway.java b/spring-integration-file/src/main/java/org/springframework/integration/file/remote/gateway/AbstractRemoteFileOutboundGateway.java\nindex 4c1f7e56556..f7f0fa1b614 100644\n--- a/spring-integration-file/src/main/java/org/springframework/integration/file/remote/gateway/AbstractRemoteFileOutboundGateway.java\n+++ b/spring-integration-file/src/main/java/org/springframework/integration/file/remote/gateway/AbstractRemoteFileOutboundGateway.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -75,6 +75,7 @@\n  * @author Gary Russell\n  * @author Artem Bilan\n  * @author Mauro Molinari\n+ * @author Jooyoung Pyoung\n  *\n  * @since 2.1\n  */\n@@ -114,8 +115,12 @@ public abstract class AbstractRemoteFileOutboundGateway<F> extends AbstractReply\n \n \tprivate Expression localFilenameGeneratorExpression;\n \n+\tprivate Expression fileExistsModeExpression;\n+\n \tprivate FileExistsMode fileExistsMode;\n \n+\tprivate EvaluationContext standardEvaluationContext;\n+\n \tprivate Integer chmod;\n \n \tprivate boolean remoteFileTemplateExplicitlySet;\n@@ -486,6 +491,32 @@ public void setLocalFilenameGeneratorExpressionString(String localFilenameGenera\n \t\tthis.localFilenameGeneratorExpression = EXPRESSION_PARSER.parseExpression(localFilenameGeneratorExpression);\n \t}\n \n+\t/**\n+\t * Specify a SpEL expression to determine the action to take when files already exist.\n+\t * Expression evaluation should return a {@link FileExistsMode} object.\n+\t * Used for GET and MGET operations when the file already exists locally,\n+\t * or PUT and MPUT when the file exists on the remote system.\n+\t * @param fileExistsModeExpression the expression to use.\n+\t * @since 6.5\n+\t */\n+\tpublic void setFileExistsModeExpression(Expression fileExistsModeExpression) {\n+\t\tAssert.notNull(fileExistsModeExpression, \"'fileExistsModeExpression' must not be null\");\n+\t\tthis.fileExistsModeExpression = fileExistsModeExpression;\n+\t}\n+\n+\t/**\n+\t * Specify a SpEL expression to determine the action to take when files already exist.\n+\t * Expression evaluation should return a {@link FileExistsMode} object.\n+\t * Used for GET and MGET operations when the file already exists locally,\n+\t * or PUT and MPUT when the file exists on the remote system.\n+\t * @param fileExistsModeExpression the String in SpEL syntax.\n+\t * @since 6.5\n+\t */\n+\tpublic void setFileExistsModeExpressionString(String fileExistsModeExpression) {\n+\t\tAssert.hasText(fileExistsModeExpression, \"'fileExistsModeExpression' must not be empty\");\n+\t\tthis.fileExistsModeExpression = EXPRESSION_PARSER.parseExpression(fileExistsModeExpression);\n+\t}\n+\n \t/**\n \t * Determine the action to take when using GET and MGET operations when the file\n \t * already exists locally, or PUT and MPUT when the file exists on the remote\n@@ -495,9 +526,6 @@ public void setLocalFilenameGeneratorExpressionString(String localFilenameGenera\n \t */\n \tpublic void setFileExistsMode(FileExistsMode fileExistsMode) {\n \t\tthis.fileExistsMode = fileExistsMode;\n-\t\tif (FileExistsMode.APPEND.equals(fileExistsMode)) {\n-\t\t\tthis.remoteFileTemplate.setUseTemporaryFileName(false);\n-\t\t}\n \t}\n \n \t/**\n@@ -539,6 +567,7 @@ protected void doInit() {\n \t\t\tAssert.isNull(this.filter, \"Filters are not supported with the rm and get commands\");\n \t\t}\n \n+\t\tthis.standardEvaluationContext = ExpressionUtils.createStandardEvaluationContext(getBeanFactory());\n \t\tif ((Command.GET.equals(this.command) && !this.options.contains(Option.STREAM))\n \t\t\t\t|| Command.MGET.equals(this.command)) {\n \t\t\tAssert.notNull(this.localDirectoryExpression, \"localDirectory must not be null\");\n@@ -553,6 +582,11 @@ protected void doInit() {\n \t\t\t\t\t\t\tOption.RECURSIVE.toString() + \" to obtain files in subdirectories\");\n \t\t}\n \n+\t\tif (FileExistsMode.APPEND.equals(this.fileExistsMode) && this.remoteFileTemplate.isUseTemporaryFileName()) {\n+\t\t\tlogger.warn(\"FileExistsMode.APPEND is incompatible with useTemporaryFileName=true. \" +\n+\t\t\t\t\t\"Temporary filename will be ignored for APPEND mode.\");\n+\t\t}\n+\n \t\tpopulateBeanFactoryIntoComponentsIfAny();\n \t\tif (!this.remoteFileTemplateExplicitlySet) {\n \t\t\tthis.remoteFileTemplate.afterPropertiesSet();\n@@ -573,7 +607,7 @@ private void populateBeanFactoryIntoComponentsIfAny() {\n \tprivate void setupLocalDirectory() {\n \t\tFile localDirectory =\n \t\t\t\tExpressionUtils.expressionToFile(this.localDirectoryExpression,\n-\t\t\t\t\t\tExpressionUtils.createStandardEvaluationContext(getBeanFactory()), null,\n+\t\t\t\t\t\tthis.standardEvaluationContext, null,\n \t\t\t\t\t\t\"localDirectoryExpression\");\n \t\tif (!localDirectory.exists()) {\n \t\t\ttry {\n@@ -845,7 +879,8 @@ private String doPut(Message<?> requestMessage, String subDirectory) {\n \t * @since 5.0\n \t */\n \tprotected String put(Message<?> message, Session<F> session, String subDirectory) {\n-\t\tString path = this.remoteFileTemplate.send(message, subDirectory, this.fileExistsMode);\n+\t\tFileExistsMode existsMode = resolveFileExistsMode(message);\n+\t\tString path = this.remoteFileTemplate.send(message, subDirectory, existsMode);\n \t\tif (path == null) {\n \t\t\tthrow new MessagingException(message, \"No local file found for \" + message);\n \t\t}\n@@ -1130,7 +1165,7 @@ protected File get(Message<?> message, Session<F> session, String remoteDir, //\n \t\t}\n \t\tfinal File localFile =\n \t\t\t\tnew File(generateLocalDirectory(message, remoteDir), generateLocalFileName(message, remoteFilename));\n-\t\tFileExistsMode existsMode = this.fileExistsMode;\n+\t\tFileExistsMode existsMode = resolveFileExistsMode(message);\n \t\tboolean appending = FileExistsMode.APPEND.equals(existsMode);\n \t\tboolean exists = localFile.exists();\n \t\tboolean replacing = exists && (FileExistsMode.REPLACE.equals(existsMode)\n@@ -1351,6 +1386,31 @@ protected String getRemoteFilename(String remoteFilePath) {\n \t\t}\n \t}\n \n+\tprivate FileExistsMode resolveFileExistsMode(Message<?> message) {\n+\t\tif (this.fileExistsModeExpression != null) {\n+\t\t\tObject evaluationResult = this.fileExistsModeExpression.getValue(this.standardEvaluationContext, message);\n+\t\t\tif (evaluationResult instanceof FileExistsMode resolvedMode) {\n+\t\t\t\treturn resolvedMode;\n+\t\t\t}\n+\t\t\telse if (evaluationResult instanceof String modeAsString) {\n+\t\t\t\ttry {\n+\t\t\t\t\treturn FileExistsMode.valueOf(modeAsString.toUpperCase());\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\t\tthrow new MessagingException(message,\n+\t\t\t\t\t\t\t\"Invalid FileExistsMode string: '\" + modeAsString + \"'. Expected one of: \" +\n+\t\t\t\t\t\t\t\t\tArrays.toString(FileExistsMode.values()), ex);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse if (evaluationResult != null) {\n+\t\t\t\tthrow new MessagingException(message,\n+\t\t\t\t\t\t\"Expression returned invalid type for FileExistsMode: \" +\n+\t\t\t\t\t\t\t\tevaluationResult.getClass().getName() + \". Expected FileExistsMode or String.\");\n+\t\t\t}\n+\t\t}\n+\t\treturn this.fileExistsMode;\n+\t}\n+\n \tprivate File generateLocalDirectory(Message<?> message, String remoteDirectory) {\n \t\tEvaluationContext evaluationContext = ExpressionUtils.createStandardEvaluationContext(getBeanFactory());\n \t\tif (remoteDirectory != null) {\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/ftp/rft.adoc b/src/reference/antora/modules/ROOT/pages/ftp/rft.adoc\nindex 55f2924f2dd..de806c14a7b 100644\n--- a/src/reference/antora/modules/ROOT/pages/ftp/rft.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/ftp/rft.adoc\n@@ -37,3 +37,21 @@ This is useful when you need to perform several high-level operations of the `Re\n For example, `AbstractRemoteFileOutboundGateway` uses it with the `mput` command implementation, where we perform a `put` operation for each file in the provided directory and recursively for its sub-directories.\n See the https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/RemoteFileOperations.html#invoke[Javadoc] for more information.\n \n+Starting with version 6.5, the `AbstractRemoteFileOutboundGateway` supports dynamic resolution of `FileExistsMode` at runtime via SpEL expressions.\n+This allows you to determine the action to take when files already exist based on message content or other conditions.\n+\n+To use this feature, configure the `fileExistsModeExpression` property on the gateway.\n+The expression can evaluate to:\n+\n+* A `FileExistsMode` enum value (e.g., `FileExistsMode.REPLACE`)\n+* A string representation of a `FileExistsMode` (case-insensitive, e.g., \"REPLACE\", \"append\")\n+\n+If the expression returns `null`, the default `fileExistsMode` configured on the gateway will be used.\n+\n+See the https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/gateway/AbstractRemoteFileOutboundGateway.html#setFileExistsModeExpression(org.springframework.expression.Expression)[Javadoc] for more information.\n+\n+[IMPORTANT]\n+====\n+When using `FileExistsMode.APPEND`, temporary filename functionality is automatically disabled regardless of the `useTemporaryFileName` setting.\n+This is because appending to a temporary file and then renaming it would not achieve the intended append behavior.\n+====\n\ndiff --git a/src/reference/antora/modules/ROOT/pages/whats-new.adoc b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\nindex c4da105c195..d097c05cef6 100644\n--- a/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n+++ b/src/reference/antora/modules/ROOT/pages/whats-new.adoc\n@@ -79,6 +79,12 @@ The `AbstractRecentFileListFilter` strategy has been introduced to accept only t\n The respective implementations are provided: `RecentFileListFilter`, `FtpRecentFileListFilter`, `SftpRecentFileListFilter` and `SmbRecentFileListFilter`.\n See xref:file/reading.adoc[Reading Files] for more information.\n \n+[[x6.5-file-exists-mode-expression]]\n+== FileExistsMode Expression Support\n+\n+The remote file gateways (`AbstractRemoteFileOutboundGateway`) now support dynamic resolution of `FileExistsMode` at runtime via SpEL expressions.\n+See xref:ftp/rft.adoc[Remote File Gateways] for more information.\n+\n [[x6.5-hazelcast-changes]]\n == Hazelcast Module Deprecations\n \n",
    "test_patch": "diff --git a/spring-integration-file/src/test/java/org/springframework/integration/file/remote/gateway/RemoteFileOutboundGatewayTests.java b/spring-integration-file/src/test/java/org/springframework/integration/file/remote/gateway/RemoteFileOutboundGatewayTests.java\nindex fcf226bf302..3c554f0a007 100644\n--- a/spring-integration-file/src/test/java/org/springframework/integration/file/remote/gateway/RemoteFileOutboundGatewayTests.java\n+++ b/spring-integration-file/src/test/java/org/springframework/integration/file/remote/gateway/RemoteFileOutboundGatewayTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -29,6 +29,7 @@\n import java.util.Collection;\n import java.util.Date;\n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.atomic.AtomicReference;\n \n import org.junit.jupiter.api.Test;\n@@ -70,6 +71,7 @@\n  * @author Gary Russell\n  * @author Liu Jiong\n  * @author Artem Bilan\n+ * @author Jooyoung Pyoung\n  *\n  * @since 2.1\n  */\n@@ -640,6 +642,66 @@ public void read(String source, OutputStream outputStream)\n \t\toutFile.delete();\n \t}\n \n+\t@Test\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void testGetExistsExpression() throws Exception {\n+\t\tSessionFactory sessionFactory = mock(SessionFactory.class);\n+\t\tTestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, \"get\", \"payload\");\n+\t\tgw.setFileExistsModeExpressionString(\"headers[\\\"file.exists.mode\\\"]\");\n+\n+\t\tgw.setLocalDirectory(new File(this.tmpDir));\n+\t\tgw.afterPropertiesSet();\n+\t\tFile outFile = new File(this.tmpDir + \"/f1\");\n+\t\tFileOutputStream fos = new FileOutputStream(outFile);\n+\t\tfos.write(\"foo\".getBytes());\n+\t\tfos.close();\n+\t\twhen(sessionFactory.getSession()).thenReturn(new TestSession() {\n+\n+\t\t\t@Override\n+\t\t\tpublic TestLsEntry[] list(String path) {\n+\t\t\t\treturn new TestLsEntry[] {\n+\t\t\t\t\t\tnew TestLsEntry(\"f1\", 1234, false, false, 12345, \"-rw-r--r--\")\n+\t\t\t\t};\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void read(String source, OutputStream outputStream)\n+\t\t\t\t\tthrows IOException {\n+\t\t\t\toutputStream.write(\"testfile\".getBytes());\n+\t\t\t}\n+\n+\t\t});\n+\n+\t\t// default (null)\n+\t\tMessageBuilder<File> out;\n+\n+\t\tassertThatExceptionOfType(MessageHandlingException.class)\n+\t\t\t\t.isThrownBy(() -> gw.handleRequestMessage(new GenericMessage<>(\"f1\")))\n+\t\t\t\t.withMessageContaining(\"already exists\");\n+\n+\t\tassertThatExceptionOfType(MessageHandlingException.class)\n+\t\t\t\t.isThrownBy(() -> gw.handleRequestMessage(\n+\t\t\t\t\t\tnew GenericMessage<>(\"f1\", Map.of(\"file.exists.mode\", FileExistsMode.FAIL))))\n+\t\t\t\t.withMessageContaining(\"already exists\");\n+\n+\t\tout = (MessageBuilder<File>) gw.handleRequestMessage(\n+\t\t\t\tnew GenericMessage<>(\"f1\", Map.of(\"file.exists.mode\", \"IGNORE\")));\n+\t\tassertThat(out.getPayload()).isEqualTo(outFile);\n+\t\tassertContents(\"foo\", outFile);\n+\n+\t\tout = (MessageBuilder<File>) gw.handleRequestMessage(\n+\t\t\t\tnew GenericMessage<>(\"f1\", Map.of(\"file.exists.mode\", \"append\")));\n+\t\tassertThat(out.getPayload()).isEqualTo(outFile);\n+\t\tassertContents(\"footestfile\", outFile);\n+\n+\t\tout = (MessageBuilder<File>) gw.handleRequestMessage(\n+\t\t\t\tnew GenericMessage<>(\"f1\", Map.of(\"file.exists.mode\", FileExistsMode.REPLACE)));\n+\t\tassertThat(out.getPayload()).isEqualTo(outFile);\n+\t\tassertContents(\"testfile\", outFile);\n+\n+\t\toutFile.delete();\n+\t}\n+\n \tprivate void assertContents(String expected, File outFile) throws Exception {\n \t\tBufferedReader reader = new BufferedReader(new FileReader(outFile));\n \t\tassertThat(reader.readLine()).isEqualTo(expected);\n@@ -860,6 +922,69 @@ public void testPutExists() throws Exception {\n \t\tverify(session, times(1)).append(any(InputStream.class), anyString());\n \t}\n \n+\t@Test\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void testPutExistsExpression() throws Exception {\n+\t\tSessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);\n+\t\tSession<TestLsEntry> session = mock(Session.class);\n+\t\twillReturn(Boolean.TRUE)\n+\t\t\t\t.given(session)\n+\t\t\t\t.exists(anyString());\n+\t\tRemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);\n+\t\ttemplate.setRemoteDirectoryExpression(new LiteralExpression(\"foo/\"));\n+\t\ttemplate.setBeanFactory(mock(BeanFactory.class));\n+\t\ttemplate.afterPropertiesSet();\n+\t\tTestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, \"put\", \"payload\");\n+\t\tFileTransferringMessageHandler<TestLsEntry> handler = new FileTransferringMessageHandler<>(sessionFactory);\n+\t\thandler.setRemoteDirectoryExpression(new LiteralExpression(\"foo/\"));\n+\t\thandler.setBeanFactory(mock(BeanFactory.class));\n+\t\thandler.afterPropertiesSet();\n+\t\tgw.afterPropertiesSet();\n+\t\tgw.setFileExistsModeExpressionString(\"headers[\\\"file.exists.mode\\\"]\");\n+\t\twhen(sessionFactory.getSession()).thenReturn(session);\n+\t\tMessageBuilder<String> requestMessageBuilder = MessageBuilder.withPayload(\"hello\")\n+\t\t\t\t.setHeader(FileHeaders.FILENAME, \"bar.txt\");\n+\n+\t\tMessage<String> defaultMessage = requestMessageBuilder.build();\n+\t\tString path = (String) gw.handleRequestMessage(defaultMessage);\n+\t\tassertThat(path).isEqualTo(\"foo/bar.txt\");\n+\t\tArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);\n+\t\tverify(session).write(any(InputStream.class), captor.capture());\n+\t\tassertThat(captor.getValue()).isEqualTo(\"foo/bar.txt.writing\");\n+\t\tverify(session).rename(\"foo/bar.txt.writing\", \"foo/bar.txt\");\n+\n+\t\tMessage<String> failMessage = requestMessageBuilder.setHeader(\"file.exists.mode\", FileExistsMode.FAIL)\n+\t\t\t\t.build();\n+\t\tassertThatExceptionOfType(MessageDeliveryException.class)\n+\t\t\t\t.isThrownBy(() -> gw.handleRequestMessage(failMessage))\n+\t\t\t\t.withStackTraceContaining(\"The destination file already exists\");\n+\n+\t\tMessage<String> replaceMessage = requestMessageBuilder.setHeader(\"file.exists.mode\", \"replace\")\n+\t\t\t\t.build();\n+\t\tpath = (String) gw.handleRequestMessage(replaceMessage);\n+\t\tassertThat(path).isEqualTo(\"foo/bar.txt\");\n+\t\tcaptor = ArgumentCaptor.forClass(String.class);\n+\t\tverify(session, times(2)).write(any(InputStream.class), captor.capture());\n+\t\tassertThat(captor.getValue()).isEqualTo(\"foo/bar.txt.writing\");\n+\t\tverify(session, times(2)).rename(\"foo/bar.txt.writing\", \"foo/bar.txt\");\n+\n+\t\tMessage<String> appendMessage = requestMessageBuilder.setHeader(\"file.exists.mode\", \"APPEND\")\n+\t\t\t\t.build();\n+\t\tpath = (String) gw.handleRequestMessage(appendMessage);\n+\t\tassertThat(path).isEqualTo(\"foo/bar.txt\");\n+\t\tcaptor = ArgumentCaptor.forClass(String.class);\n+\t\tverify(session).append(any(InputStream.class), captor.capture());\n+\t\tassertThat(captor.getValue()).isEqualTo(\"foo/bar.txt\");\n+\n+\t\tMessage<String> ignoreMessage = requestMessageBuilder.setHeader(\"file.exists.mode\", FileExistsMode.IGNORE)\n+\t\t\t\t.build();\n+\t\tpath = (String) gw.handleRequestMessage(ignoreMessage);\n+\t\tassertThat(path).isEqualTo(\"foo/bar.txt\");\n+\t\t// no more writes/appends\n+\t\tverify(session, times(2)).write(any(InputStream.class), anyString());\n+\t\tverify(session, times(1)).append(any(InputStream.class), anyString());\n+\t}\n+\n \t@Test\n \t@SuppressWarnings(\"unchecked\")\n \tpublic void testMput() throws Exception {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "spring-projects__spring-integration-10004",
    "pr_id": 10004,
    "issue_id": 10003,
    "repo": "spring-projects/spring-integration",
    "problem_statement": "The value of `releasePartialSequences` is not propagated to the underlying SequenceSizeReleaseStrategy\ntaking a example from unit test (which is disabled due to Time sensitive issue)\ntest method reference `org.springframework.integration.aggregator.AggregatorTests#testAggPerfDefaultPartial`\n\n```\n@Test\n@Disabled(\"Time sensitive\")\npublic void testAggPerfDefaultPartial() throws InterruptedException, ExecutionException,TimeoutException {\n\tAggregatingMessageHandler handler = new AggregatingMessageHandler(new DefaultAggregatingMessageGroupProcessor());\n\thandler.setCorrelationStrategy(message -> \"foo\");\n\thandler.setReleasePartialSequences(true);\n        ....\n}\n\n```\nin above test, we set releasePartialSequences to true, which will set releaseStrategy to `SequenceSizeReleaseStrategy`.\n\n``` \n// class AbstractCorrelatingMessageHandler\n\npublic void setReleasePartialSequences(boolean releasePartialSequences) {\n\tif (!this.releaseStrategySet && releasePartialSequences) {\n\t\tsetReleaseStrategy(new SequenceSizeReleaseStrategy());\n\t}\n\tthis.releasePartialSequences = releasePartialSequences;\n}\n```\n\nhowever, the releasePartialSequences value is never propagated to SequenceSizeReleaseStrategy.\n\nactually it is propagated in onInit() method, inside `afterPropertiesSet()`,  which means only we call `afterPropertiesSet()`, it will be propagated.\n\n```\n// class AbstractCorrelatingMessageHandler\n\n@Override\nprotected void onInit() {\n\tsuper.onInit();\n        // ...\n\tif (this.releasePartialSequences) {\n\t\tAssert.isInstanceOf(SequenceSizeReleaseStrategy.class, this.releaseStrategy, () ->\n\t\t\t\t\"Release strategy of type [\" + this.releaseStrategy.getClass().getSimpleName() +\n\t\t\t\t\t\t\"] cannot release partial sequences. Use a SequenceSizeReleaseStrategy instead.\");\n\t\t((SequenceSizeReleaseStrategy) this.releaseStrategy)\n\t\t\t\t.setReleasePartialSequences(this.releasePartialSequences);\n\t}\n        // ...\n}\n```\n\n------\n\nI think it is our unit test issue,  also the assertion is not correct. even it passes when we enabled the test.\n\nfor fix, I prefer remove the value propagation in method `onInit()`, and add this logic in `setReleasePartialSequences()`\n```\n// class AbstractCorrelatingMessageHandler\npublic void setReleasePartialSequences(boolean releasePartialSequences) {\n\tif (!this.releaseStrategySet && releasePartialSequences) {\n\t\tSequenceSizeReleaseStrategy sequenceSizeReleaseStrategy = new SequenceSizeReleaseStrategy();\n\t\tsequenceSizeReleaseStrategy.setReleasePartialSequences(releasePartialSequences);\n\t\tsetReleaseStrategy(sequenceSizeReleaseStrategy);\n\t}\n\tthis.releasePartialSequences = releasePartialSequences;\n}\n\n```\n\nkindly confirm.\n\n",
    "issue_word_count": 220,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "spring-integration-core/src/main/java/org/springframework/integration/aggregator/AbstractCorrelatingMessageHandler.java",
      "spring-integration-core/src/test/java/org/springframework/integration/aggregator/AggregatorTests.java"
    ],
    "pr_changed_test_files": [
      "spring-integration-core/src/test/java/org/springframework/integration/aggregator/AggregatorTests.java"
    ],
    "base_commit": "05ee9ff4a994dfbacf8bb07811996d98c483a473",
    "head_commit": "fac8baa93698d22ab9f7bc3cd6ae70806d65b0d5",
    "repo_url": "https://github.com/spring-projects/spring-integration/pull/10004",
    "swe_url": "https://swe-bench-plus.turing.com/repos/spring-projects__spring-integration/10004",
    "dockerfile": "",
    "pr_merged_at": "2025-05-02T15:45:01.000Z",
    "patch": "diff --git a/spring-integration-core/src/main/java/org/springframework/integration/aggregator/AbstractCorrelatingMessageHandler.java b/spring-integration-core/src/main/java/org/springframework/integration/aggregator/AbstractCorrelatingMessageHandler.java\nindex 68433fecd22..01d1f44d060 100644\n--- a/spring-integration-core/src/main/java/org/springframework/integration/aggregator/AbstractCorrelatingMessageHandler.java\n+++ b/spring-integration-core/src/main/java/org/springframework/integration/aggregator/AbstractCorrelatingMessageHandler.java\n@@ -299,7 +299,7 @@ public void setMinimumTimeoutForEmptyGroups(long minimumTimeoutForEmptyGroups) {\n \t */\n \tpublic void setReleasePartialSequences(boolean releasePartialSequences) {\n \t\tif (!this.releaseStrategySet && releasePartialSequences) {\n-\t\t\tsetReleaseStrategy(new SequenceSizeReleaseStrategy());\n+\t\t\tsetReleaseStrategy(new SequenceSizeReleaseStrategy(releasePartialSequences));\n \t\t}\n \t\tthis.releasePartialSequences = releasePartialSequences;\n \t}\n",
    "test_patch": "diff --git a/spring-integration-core/src/test/java/org/springframework/integration/aggregator/AggregatorTests.java b/spring-integration-core/src/test/java/org/springframework/integration/aggregator/AggregatorTests.java\nindex 12369cd16a8..0e667a06d5f 100644\n--- a/spring-integration-core/src/test/java/org/springframework/integration/aggregator/AggregatorTests.java\n+++ b/spring-integration-core/src/test/java/org/springframework/integration/aggregator/AggregatorTests.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2024 the original author or authors.\n+ * Copyright 2002-2025 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -133,7 +133,6 @@ public void testAggPerf() throws InterruptedException, ExecutionException, Timeo\n \tpublic void testAggPerfDefaultPartial() throws InterruptedException, ExecutionException, TimeoutException {\n \t\tAggregatingMessageHandler handler = new AggregatingMessageHandler(new DefaultAggregatingMessageGroupProcessor());\n \t\thandler.setCorrelationStrategy(message -> \"foo\");\n-\t\thandler.setReleasePartialSequences(true);\n \t\tDirectChannel outputChannel = new DirectChannel();\n \t\thandler.setOutputChannel(outputChannel);\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  }
]