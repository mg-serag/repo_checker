[
  {
    "instance_id": "openrewrite__rewrite-5668",
    "pr_id": 5668,
    "issue_id": 5667,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ChangeProjectVersion should ignore Maven CI-friendly version placeholders\n`ChangeProjectVersion` implementation in the rewrite-maven module should ignore Maven CI-friendly version placeholder properties such as `${revision}`, `${sha1}`, and `${changelist}` similar to Implicitly Defined Version Properties.\n\n**Use Case**\n\nAutomate the use of [Maven CI Friendly versioning](https://maven.apache.org/guides/mini/guide-maven-ci-friendly.html) within maven apps. \n\nTo enable this automation, custom declarative recipes are created and packaged as jar for consumption.\n\n**Workflow and Recipe Definition**\n\n- Add `revision` property using `org.openrewrite.maven.AddProperty`\n\n```xml\nmvn org.openrewrite.maven:rewrite-maven-plugin::RELEASE:run  -Drewrite.activeRecipes=org.openrewrite.maven.AddProperty -Drewrite.options=key=revision,value=${VERSION}\n```\n\n- Add custom declarative recipe to change project version to `${revision}`.\n\n```\n---\ntype: specs.openrewrite.org/v1beta/recipe\nname: customRecipe\ndisplayName: Change Project Version to Use Revision Property\ndescription: >\n  Updates the project version to use the ${revision} property for CI friendly versioning.\nrecipeList:\n  - org.openrewrite.maven.ChangeProjectVersion:\n      groupId: '*'\n      artifactId: '*'\n      newVersion: ${revision}\n```\nThis recipe is executed via maven command line with rewrite option `-Drewrite.resolvePropertiesInYaml=false` to avoid interpolation of `revision` value\n\nWhen the custom declarative recipe to change the project version (e.g., setting it to ${revision} for CI-friendly versioning), the recipe works as expected on the first run. However, subsequent runs of the recipe override the `revision` property with ${revision}  again, leading to a cyclic reference error.\n\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using\n\n- Maven plugin v6.11.0\n- rewrite-module v8.55.x\n\n## How are you running OpenRewrite?\n<!--\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\nIs your project a single module or a multi-module project?\n\nCan you share your configuration so that we can rule out any configuration issues?\n\nIs your project public? If so, can you share a link to it?\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\n-->\nI am using maven command line , and work with both single/multi module pojects\n\n```xml\nmvn org.openrewrite.maven:rewrite-maven-plugin::6.11.0:run -Drewrite.recipeArtifactCoordinates=custom-decalartive-recipes:RELESE:run-Drewrite.resolvePropertiesInYaml=false -Drewrite.activeRecipes=custom-declarative-recipe\n```\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\n\n**Minimal Unit test**\n\n```java\n\npackage com.example;\n\nimport org.junit.jupiter.api.Test;\nimport org.openrewrite.DocumentExample;\nimport org.openrewrite.test.RewriteTest;\n\nimport static org.openrewrite.maven.Assertions.pomXml;\n\npublic class OpenRewriteChangeProjectVersionTest implements RewriteTest {\n\n    @DocumentExample\n    @Test\n    void doNotchangeProjectVersionIfRevisionPlaceholderProperty() {\n        rewriteRun(\n            spec -> spec.recipe(new org.openrewrite.maven.ChangeProjectVersion(\n                \"org.openrewrite\", \"rewrite-maven\", \"${revision}\", null)),\n            pomXml(\n                \"<project>\\n\"\n                + \"    <groupId>org.openrewrite</groupId>\\n\"\n                + \"    <artifactId>rewrite-maven</artifactId>\\n\"\n                + \"    <version>${revision}</version>\\n\"\n                + \"    <properties>\\n\"\n                + \"        <revision>8.55.5</revision>\\n\"\n                + \"    </properties>\\n\"\n                + \"</project>\\n\"\n            )\n        );\n    }\n}\n\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\nThe recipe should not attempt to update the version if it is already set to one of these placeholders.\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\nRecipe updates the revision property with placeholder property.\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\nStack Trace from Test failure\n```\n,doNotchangeProjectVersionIfRevisionPlaceholderProperty(com.example.OpenRewriteChangeProjectVersionTest)\n%TRACES \njava.lang.AssertionError: Failed to run recipe at Cursor{Document->root}\n        at org.openrewrite.test.RewriteTest.lambda$defaultExecutionContext$14(RewriteTest.java:639)\n        at org.openrewrite.scheduling.RecipeRunCycle.handleError(RecipeRunCycle.java:289)\n        at org.openrewrite.scheduling.RecipeRunCycle.lambda$editSources$8(RecipeRunCycle.java:229)\n        at org.openrewrite.scheduling.RecipeStack.reduce(RecipeStack.java:60)\n        at org.openrewrite.scheduling.RecipeRunCycle.lambda$editSources$9(RecipeRunCycle.java:178)\n        at org.openrewrite.internal.InMemoryLargeSourceSet.lambda$edit$0(InMemoryLargeSourceSet.java:83)\n        at org.openrewrite.internal.ListUtils.map(ListUtils.java:244)\n        at org.openrewrite.internal.ListUtils.map(ListUtils.java:267)\n        at org.openrewrite.internal.InMemoryLargeSourceSet.edit(InMemoryLargeSourceSet.java:82)\n        at org.openrewrite.scheduling.RecipeRunCycle.editSources(RecipeRunCycle.java:177)\n        at org.openrewrite.RecipeScheduler.runRecipeCycles(RecipeScheduler.java:84)\n        at org.openrewrite.RecipeScheduler.scheduleRun(RecipeScheduler.java:41)\n        at org.openrewrite.Recipe.run(Recipe.java:441)\n        at org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:377)\n        at org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:130)\n        at com.exmaple.OpenRewriteChangeProjectVersionTest.doNotchangeProjectVersionIfRevisionPlaceholderProperty(OpenRewriteChangeProjectVersionTest.java:35)\n        at java.base/java.lang.reflect.Method.invoke(Method.java:580)\n        at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)\n        at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)\nCaused by: org.openrewrite.internal.RecipeRunException: java.lang.IllegalArgumentException: Circular placeholder reference 'revision' in property definitions\n        at org.openrewrite.TreeVisitor.visit(TreeVisitor.java:281)\n        at org.openrewrite.TreeVisitor.visit(TreeVisitor.java:268)\n        at org.openrewrite.Preconditions$Check.visit(Preconditions.java:166)\n        at org.openrewrite.Preconditions$Check.visit(Preconditions.java:145)\n        at org.openrewrite.TreeVisitor.visit(TreeVisitor.java:268)\n        at org.openrewrite.TreeVisitor.visit(TreeVisitor.java:154)\n        at org.openrewrite.scheduling.RecipeRunCycle.lambda$editSources$7(RecipeRunCycle.java:209)\n        at io.micrometer.core.instrument.AbstractTimer.recordCallable(AbstractTimer.java:147)\n        at org.openrewrite.table.RecipeRunStats.recordEdit(RecipeRunStats.java:67)\n        at org.openrewrite.scheduling.RecipeRunCycle.lambda$editSources$8(RecipeRunCycle.java:205)\n        ... 16 more\nCaused by: java.lang.IllegalArgumentException: Circular placeholder reference 'revision' in property definitions\n        at org.openrewrite.internal.PropertyPlaceholderHelper.parseStringValue(PropertyPlaceholderHelper.java:94)\n        at org.openrewrite.internal.PropertyPlaceholderHelper.parseStringValue(PropertyPlaceholderHelper.java:115)\n        at org.openrewrite.internal.PropertyPlaceholderHelper.replacePlaceholders(PropertyPlaceholderHelper.java:74)\n        at org.openrewrite.maven.internal.MavenPomDownloader.projectPomsByGav(MavenPomDownloader.java:179)\n        at org.openrewrite.maven.internal.MavenPomDownloader.<init>(MavenPomDownloader.java:137)\n        at org.openrewrite.maven.internal.MavenPomDownloader.<init>(MavenPomDownloader.java:102)\n        at org.openrewrite.maven.UpdateMavenModel.updateResult(UpdateMavenModel.java:163)\n        at org.openrewrite.maven.UpdateMavenModel.visitDocument(UpdateMavenModel.java:136)\n        at org.openrewrite.xml.tree.Xml$Document.acceptXml(Xml.java:149)\n        at org.openrewrite.xml.tree.Xml.accept(Xml.java:53)\n        at org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n        ... 25 more\n\n%TRACEE \n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\nYes",
    "issue_word_count": 1246,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeProjectVersion.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeProjectVersionTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeProjectVersionTest.java"
    ],
    "base_commit": "a3de8ed50eb739b5556af9f5027dce68dd36c0fa",
    "head_commit": "53fcc4dfe0204fe553e4b9c8173dffeb113c1988",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5668",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5668",
    "dockerfile": "",
    "pr_merged_at": "2025-06-24T21:51:48.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeProjectVersion.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeProjectVersion.java\nindex 957c90bc989..26b472512e4 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeProjectVersion.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeProjectVersion.java\n@@ -38,7 +38,8 @@\n public class ChangeProjectVersion extends Recipe {\n     // there are several implicitly defined version properties that we should never attempt to update\n     private static final Collection<String> implicitlyDefinedVersionProperties = Arrays.asList(\n-            \"${version}\", \"${project.version}\", \"${pom.version}\", \"${project.parent.version}\"\n+            \"${version}\", \"${project.version}\", \"${pom.version}\", \"${project.parent.version}\",\n+            \"${revision}\", \"${sha1}\", \"${changelist}\"\n     );\n \n     @Option(displayName = \"Group\",\n@@ -97,13 +98,16 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                             String oldVersion = resolvedPom.getValue(versionTagValue);\n                             assert oldVersion != null;\n \n-                            if (!oldVersion.equals(newVersion)) {\n-                                if (versionTagValue.startsWith(\"${\") && !implicitlyDefinedVersionProperties.contains(versionTagValue)) {\n-                                    doAfterVisit(new ChangePropertyValue(versionTagValue.substring(2, versionTagValue.length() - 1), newVersion, false, false).getVisitor());\n-                                } else {\n-                                    doAfterVisit(new ChangeTagValueVisitor<>(versionTag.get(), newVersion));\n+                            // Skip if the current version tag value is already equal to the new version\n+                            if (!versionTagValue.equals(newVersion)) {\n+                                if (!oldVersion.equals(newVersion)) {\n+                                    if (versionTagValue.startsWith(\"${\") && !implicitlyDefinedVersionProperties.contains(versionTagValue)) {\n+                                        doAfterVisit(new ChangePropertyValue(versionTagValue.substring(2, versionTagValue.length() - 1), newVersion, false, false).getVisitor());\n+                                    } else {\n+                                        doAfterVisit(new ChangeTagValueVisitor<>(versionTag.get(), newVersion));\n+                                    }\n+                                    maybeUpdateModel();\n                                 }\n-                                maybeUpdateModel();\n                             }\n                         } else if (Boolean.TRUE.equals(overrideParentVersion)) {\n                             // if the version is not present and the override parent version is set,\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeProjectVersionTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeProjectVersionTest.java\nindex ecec794223e..c3c2a537722 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeProjectVersionTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeProjectVersionTest.java\n@@ -303,4 +303,61 @@ void changeProjectVersionInheritedFromParentIfOverrideParentVersion() {\n         );\n     }\n \n+    @Test\n+    void doNotChangeProjectVersionIfRevisionPlaceholderProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeProjectVersion(\"org.openrewrite\", \"rewrite-maven\", \"${revision}\", null)),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <groupId>org.openrewrite</groupId>\n+                  <artifactId>rewrite-maven</artifactId>\n+                  <version>${revision}</version>\n+                  <properties>\n+                      <revision>8.55.5</revision>\n+                  </properties>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void doNotChangeProjectVersionIfSha1PlaceholderProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeProjectVersion(\"org.openrewrite\", \"rewrite-maven\", \"${sha1}\", null)),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <groupId>org.openrewrite</groupId>\n+                  <artifactId>rewrite-maven</artifactId>\n+                  <version>${sha1}</version>\n+                  <properties>\n+                      <sha1>abc123</sha1>\n+                  </properties>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void doNotChangeProjectVersionIfChangelistPlaceholderProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeProjectVersion(\"org.openrewrite\", \"rewrite-maven\", \"${changelist}\", null)),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <groupId>org.openrewrite</groupId>\n+                  <artifactId>rewrite-maven</artifactId>\n+                  <version>${changelist}</version>\n+                  <properties>\n+                      <changelist>SNAPSHOT</changelist>\n+                  </properties>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5662",
    "pr_id": 5662,
    "issue_id": 5660,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Semver Version Comparator incorrectly comparing RC releases.\nThe Semver VersionComparator upgrade function is incorrectly returning null when comparing RC versions with the full release version. This seems to be related to #5192 , which is now marking pre-release versions as valid versions.\n\n- https://github.com/openrewrite/rewrite/pull/5192\n\n## What version of OpenRewrite are you using?\n8.55.3\n\n## How are you running OpenRewrite?\nUnit tests in private repo. \n\n## What is the smallest, simplest way to reproduce the problem?\n```kotlin\n    @Test\n    fun `Compare RC version`() {\n        val versionComparator = Semver.validate(\"3.5.x\", null).value\n        assertEquals<String?>(\"3.5.0\", versionComparator!!.upgrade(\"3.5.0-RC1\", listOf(\"3.5.0\")).orElse(null))\n    }\n```\norg.opentest4j.AssertionFailedError: \nExpected :3.5.0\nActual   :null\n\n",
    "issue_word_count": 120,
    "test_files_count": 3,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/semver/LatestRelease.java",
      "rewrite-core/src/main/java/org/openrewrite/semver/XRange.java",
      "rewrite-core/src/test/java/org/openrewrite/semver/LatestReleaseTest.java",
      "rewrite-core/src/test/java/org/openrewrite/semver/XRangeTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-core/src/main/java/org/openrewrite/semver/LatestRelease.java",
      "rewrite-core/src/test/java/org/openrewrite/semver/LatestReleaseTest.java",
      "rewrite-core/src/test/java/org/openrewrite/semver/XRangeTest.java"
    ],
    "base_commit": "da11c2b2955444ce34f06cbbddb2568d6efc66d2",
    "head_commit": "813d6b46c1d2c3bcd731cd84503c0c74dea3b4cb",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5662",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5662",
    "dockerfile": "",
    "pr_merged_at": "2025-06-24T09:49:17.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/semver/XRange.java b/rewrite-core/src/main/java/org/openrewrite/semver/XRange.java\nindex 6b95f2c0bbf..32d11ea6e8b 100644\n--- a/rewrite-core/src/main/java/org/openrewrite/semver/XRange.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/semver/XRange.java\n@@ -44,7 +44,9 @@ public class XRange extends LatestRelease {\n     @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n     @Override\n     public boolean isValid(@Nullable String currentVersion, String version) {\n-        if (!super.isValid(currentVersion, version)) {\n+        // For X-range patterns, we need to check if the version matches the pattern\n+        // but we should not exclude it just because it's a pre-release version\n+        if (!VersionComparator.checkVersion(version, getMetadataPattern(), false)) {\n             return false;\n         }\n \n",
    "test_patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/semver/LatestRelease.java b/rewrite-core/src/main/java/org/openrewrite/semver/LatestRelease.java\nindex c9d7dcabdd6..03bfdf53251 100644\n--- a/rewrite-core/src/main/java/org/openrewrite/semver/LatestRelease.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/semver/LatestRelease.java\n@@ -149,6 +149,19 @@ public int compare(@Nullable String currentVersion, String v1, String v2) {\n             throw new IllegalStateException(\"Illegal state while comparing versions : [\" + nv1 + \"] and [\" + nv2 + \"]. Metadata = [\" + metadataPattern + \"]\", exception);\n         }\n \n+        // When all numeric parts are equal, we need to handle pre-release versions properly\n+        // A pre-release version should be considered less than a release version\n+        // e.g., \"3.5.0-RC1\" < \"3.5.0\"\n+        boolean v1IsPreRelease = v1Gav.group(6) != null && PRE_RELEASE_ENDING.matcher(v1Gav.group(6)).find();\n+        boolean v2IsPreRelease = v2Gav.group(6) != null && PRE_RELEASE_ENDING.matcher(v2Gav.group(6)).find();\n+        \n+        if (v1IsPreRelease && !v2IsPreRelease) {\n+            return -1; // v1 is pre-release, v2 is not, so v1 < v2\n+        } else if (!v1IsPreRelease && v2IsPreRelease) {\n+            return 1;  // v1 is not pre-release, v2 is, so v1 > v2\n+        }\n+        \n+        // Both are either pre-release or release versions, do string comparison\n         return normalized1.compareTo(normalized2);\n     }\n \n\ndiff --git a/rewrite-core/src/test/java/org/openrewrite/semver/LatestReleaseTest.java b/rewrite-core/src/test/java/org/openrewrite/semver/LatestReleaseTest.java\nindex fc92187fda7..a808c0eb42b 100644\n--- a/rewrite-core/src/test/java/org/openrewrite/semver/LatestReleaseTest.java\n+++ b/rewrite-core/src/test/java/org/openrewrite/semver/LatestReleaseTest.java\n@@ -173,4 +173,15 @@ void datedSnapshotVersions() {\n     void matchCustomMetadata() {\n         assertThat(new LatestRelease(\".Final-custom-\\\\d+\").isValid(null, \"3.2.9.Final-custom-00003\")).isTrue();\n     }\n+\n+    @Test\n+    void preReleaseVersionsShouldBeLessThanReleaseVersions() {\n+        assertThat(latestRelease.compare(null, \"3.5.0-RC1\", \"3.5.0\")).isLessThan(0);\n+        assertThat(latestRelease.compare(null, \"3.5.0\", \"3.5.0-RC1\")).isGreaterThan(0);\n+        assertThat(latestRelease.compare(null, \"3.5.0-RC1\", \"3.5.0-RC2\")).isLessThan(0);\n+        assertThat(latestRelease.compare(null, \"3.5.0-alpha\", \"3.5.0-beta\")).isLessThan(0);\n+        // String comparison: \"beta\" > \"RC1\" lexicographically\n+        assertThat(latestRelease.compare(null, \"3.5.0-beta\", \"3.5.0-RC1\")).isGreaterThan(0);\n+        assertThat(latestRelease.compare(null, \"3.5.0-RC1\", \"3.5.0-beta\")).isLessThan(0);\n+    }\n }\n\ndiff --git a/rewrite-core/src/test/java/org/openrewrite/semver/XRangeTest.java b/rewrite-core/src/test/java/org/openrewrite/semver/XRangeTest.java\nindex bf18721bfe8..4887fd55abb 100644\n--- a/rewrite-core/src/test/java/org/openrewrite/semver/XRangeTest.java\n+++ b/rewrite-core/src/test/java/org/openrewrite/semver/XRangeTest.java\n@@ -110,4 +110,20 @@ void matchingJavaxValidation() {\n     void matchCustomMetadata() {\n         assertThat(new XRange(\"3\", \"2\", \"*\", \"\", \".Final-custom-\\\\d+\").isValid(null, \"3.2.9.Final-custom-00003\")).isTrue();\n     }\n+\n+    @Test\n+    void compareRCVersion() {\n+        XRange xRange = XRange.build(\"3.5.x\", null).getValue();\n+        assertThat(xRange).isNotNull();\n+        assertThat(xRange.upgrade(\"3.5.0-RC1\", java.util.Arrays.asList(\"3.5.0\")).orElse(null)).isEqualTo(\"3.5.0\");\n+    }\n+\n+    @Test\n+    void rcVersionsShouldBeValidForXRange() {\n+        XRange xRange = XRange.build(\"3.5.x\", null).getValue();\n+        assertThat(xRange).isNotNull();\n+        assertThat(xRange.isValid(\"3.5.0-RC1\", \"3.5.0-RC1\")).isTrue();\n+        assertThat(xRange.isValid(\"3.5.0-RC1\", \"3.5.0\")).isTrue();\n+        assertThat(xRange.isValid(\"3.5.0\", \"3.5.1-RC1\")).isTrue();\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5629",
    "pr_id": 5629,
    "issue_id": 5341,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Groovy fails to parse Elvis-assignment operator ?=\n## What version of OpenRewrite are you using?\n\n8.51.0 or current main = ef702a72be2bbf6a932051254913aa86aab69c5a\n\n## What is the smallest, simplest way to reproduce the problem?\n\nThe following test:\n```\n    @Test\n    void elvisAssignment() {\n        rewriteRun(\n                groovy(\n                        \"\"\"\n                        def x = 3\n                        x ?= 4\n                        \"\"\"\n                )\n        );\n    }\n```\nfails with:\n```\njava.lang.AssertionError: Source file was parsed into an LST that contains non-whitespace characters in its whitespace. This is indicative of a bug in the parser. \n~~(non-whitespace)~~>def <~~x~~(non-whitespace)~~> = 3\nx ?= 4<~~\n```\nwhile I think this is a valid Groovy program\n\n## Context\n\nOSS repro:\n- https://github.com/spring-projects/spring-boot-data-geode/blob/b0ffcdd1194050dedc9c3bdab92d768555a721c8/buildSrc/src/main/groovy/io/spring/gradle/convention/JavadocApiPlugin.groovy#L83",
    "issue_word_count": 116,
    "test_files_count": 1,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ElvisAssignmentTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ElvisAssignmentTest.java"
    ],
    "base_commit": "156ce3c06e194c2213cfddabfba0261180831323",
    "head_commit": "5d38cb504b433b68b56f85ff2b4c65971b88eb4e",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5629",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5629",
    "dockerfile": "",
    "pr_merged_at": "2025-06-16T17:50:04.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex 39041a1c2ff..f59a4ae6afa 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -993,6 +993,9 @@ public void visitBinaryExpression(BinaryExpression binary) {\n                     case \"<=>\":\n                         gBinaryOp = G.Binary.Type.Spaceship;\n                         break;\n+                    case \"?=\":\n+                        gBinaryOp = G.Binary.Type.ElvisAssignment;\n+                        break;\n                 }\n \n                 cursor += binary.getOperation().getText().length();\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\nindex 330a4dfdc72..c6b208203b7 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\n@@ -170,6 +170,9 @@ public J visitBinary(G.Binary binary, PrintOutputCapture<P> p) {\n             case Spaceship:\n                 keyword = \"<=>\";\n                 break;\n+            case ElvisAssignment:\n+                keyword = \"?=\";\n+                break;\n         }\n         beforeSyntax(binary, GSpace.Location.BINARY_PREFIX, p);\n         visit(binary.getLeft(), p);\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java\nindex 3c3dfe605c2..36769e9d7aa 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java\n@@ -795,7 +795,8 @@ public enum Type {\n             In,\n             NotIn,\n             Access,\n-            Spaceship\n+            Spaceship,\n+            ElvisAssignment\n         }\n \n         public Padding getPadding() {\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ElvisAssignmentTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ElvisAssignmentTest.java\nnew file mode 100644\nindex 00000000000..7463a60cf83\n--- /dev/null\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ElvisAssignmentTest.java\n@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.groovy.tree;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.test.RewriteTest;\n+\n+import static org.openrewrite.groovy.Assertions.groovy;\n+\n+class ElvisAssignmentTest implements RewriteTest {\n+\n+    @Test\n+    void simpleElvisAssignment() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              def x = null\n+              x ?= 42\n+              \n+              def y = 44\n+              y ?= 46\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void elvisAssignmentWithMethodCall() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              def value = null\n+              value ?= computeDefault()\n+\n+              def computeDefault() {\n+                  return \"Groovy\"\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void elvisAssignmentWithBinaryExpression() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              def count = null\n+              count ?= 10 + 5\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void elvisAssignmentToFieldInClass() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              class A {\n+                  def name\n+\n+                  void init() {\n+                      name ?= \"default\"\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void elvisAssignmentWithArrayParam() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              import java.util.HashSet\n+              import java.util.Set\n+              import java.util.regex.Pattern\n+\n+              class A {\n+                  Set excludes\n+\n+                  void setExcludes(String... excludes) {\n+                      excludes ?= new String[0]\n+                      this.excludes = new HashSet<>(excludes.length)\n+                      excludes.each { this.excludes.add(Pattern.compile(it)) }\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5625",
    "pr_id": 5625,
    "issue_id": 5296,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Error parsing Groovy with double-generics and anonymous class instantiation.\n## What version of OpenRewrite are you using?\n\ncurrent main = b504c17eb4055e959ac7d5edd5616c84664667f2\n\n## What is the smallest, simplest way to reproduce the problem?\n```\n    @Test\n    void classEnum() {\n        rewriteRun(groovy(\"new ArrayList<Map<String, String>>() {}\"));\n    }\n```\nfails with:\n```diff\n- new ArrayList<Map<String, String>>() {}\n+ new ArrayList<Map,String, String>()>() {}\n```\n\n## Context\n\nFound the same failure in https://github.com/spinnaker/spinnaker/blob/97cee4f3da768323984a4e1f404c96a9addf5306/clouddriver/clouddriver-appengine/src/main/groovy/com/netflix/spinnaker/clouddriver/appengine/model/AppengineHealth.groovy#L41C1-L43C4",
    "issue_word_count": 82,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyParserTest.java"
    ],
    "base_commit": "32d30c0d9d15df09963fce9927ab242ee1ffdbe3",
    "head_commit": "3cb61500f6e53bbfc2e3d5bb1ab8d88c1757bc0b",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5625",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5625",
    "dockerfile": "",
    "pr_merged_at": "2025-06-16T23:04:00.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex 39041a1c2ff..7b5ba5d6e9d 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -1374,7 +1374,7 @@ public void visitConstructorCallExpression(ConstructorCallExpression ctor) {\n                 }\n \n                 skip(\"new\");\n-                TypeTree clazz = visitTypeTree(ctor.getType(), ctor.getNodeMetaData().containsKey(StaticTypesMarker.INFERRED_TYPE));\n+                TypeTree clazz = visitTypeTree(ctor.getType(), isInferred(ctor));\n                 JContainer<Expression> args = visit(ctor.getArguments());\n                 J.Block body = null;\n                 if (ctor.isUsingAnonymousInnerClass() && ctor.getType() instanceof InnerClassNode) {\n@@ -2443,7 +2443,17 @@ private <T extends TypeTree & Expression> T typeTree(@Nullable ClassNode classNo\n \n         assert expr != null;\n         if (classNode != null) {\n-            if (classNode.isUsingGenerics() && !classNode.isGenericsPlaceHolder()) {\n+            boolean isAnonymousClassWithGenericSuper = classNode instanceof InnerClassNode\n+                    && classNode.getUnresolvedSuperClass() != null\n+                    && classNode.getUnresolvedSuperClass().isUsingGenerics()\n+                    && !classNode.getUnresolvedSuperClass().isGenericsPlaceHolder()\n+                    && classNode.getGenericsTypes() == null;\n+            if (isAnonymousClassWithGenericSuper) {\n+                JContainer<Expression> typeParameters = inferredType ?\n+                        JContainer.build(sourceBefore(\"<\"), singletonList(padRight(new J.Empty(randomId(), EMPTY, Markers.EMPTY), sourceBefore(\">\"))), Markers.EMPTY) :\n+                        visitTypeParameterizations(classNode.getUnresolvedSuperClass().getGenericsTypes());\n+                expr = new J.ParameterizedType(randomId(), EMPTY, Markers.EMPTY, (NameTree) expr, typeParameters, typeMapping.type(classNode));\n+            } else if (classNode.isUsingGenerics() && !classNode.isGenericsPlaceHolder()) {\n                 JContainer<Expression> typeParameters = inferredType ?\n                         JContainer.build(sourceBefore(\"<\"), singletonList(padRight(new J.Empty(randomId(), EMPTY, Markers.EMPTY), sourceBefore(\">\"))), Markers.EMPTY) :\n                         visitTypeParameterizations(classNode.getGenericsTypes());\n@@ -3015,6 +3025,21 @@ private static ClassNode staticType(Parameter parameter) {\n         }\n     }\n \n+    private boolean isInferred(ConstructorCallExpression ctor) {\n+        if (ctor.getNodeMetaData().containsKey(StaticTypesMarker.INFERRED_TYPE)) {\n+            return true;\n+        }\n+\n+        ClassNode innerClass = ctor.getType();\n+        if (!(innerClass instanceof InnerClassNode)) {\n+            return false;\n+        }\n+\n+        ClassNode superClass = innerClass.getUnresolvedSuperClass();\n+        GenericsType[] generics = superClass != null ? superClass.getGenericsTypes() : null;\n+        return generics != null && generics.length == 0;\n+    }\n+\n     private static final Map<String, J.Modifier.Type> modifierNameToType;\n \n     static {\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyParserTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyParserTest.java\nindex a41159e38a9..3a0b2db8ba3 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyParserTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyParserTest.java\n@@ -82,4 +82,39 @@ Map<String, Object> buildMap() {\n           ));\n     }\n \n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5296\")\n+    @Test\n+    void anonymousClassWithNestedGenericType() {\n+        rewriteRun(groovy(\"new ArrayList<Map<String, String>>() {}\"));\n+    }\n+\n+    @Test\n+    void deeplyNestedAnonymousGeneric() {\n+        rewriteRun(groovy(\"new HashMap<String, List<Map<Integer, String>>>() {}\"));\n+    }\n+\n+    @Test\n+    void rawAnonymousClassShouldNotGetGenerics() {\n+        rewriteRun(groovy(\"new ArrayList() {}\"));\n+    }\n+\n+    @Test\n+    void inferredGenericsWithDiamondOperator() {\n+        rewriteRun(groovy(\"new ArrayList<>() {}\"));\n+    }\n+\n+    @Test\n+    void nestedAnonymousWithGenerics() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              new HashMap<String, List<String>>() {\n+                  void inner() {\n+                      new ArrayList<Map<Integer, String>>() {}\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5618",
    "pr_id": 5618,
    "issue_id": 5329,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Java parser idempotency issue when using generics, annotations and arrays\n## What version of OpenRewrite are you using?\n\nCurrent main = a344e18ff346684b0ad9d18cedc57868c1ca0ab6\n\n## What is the smallest, simplest way to reproduce the problem?\n```java\n    @Test\n    void arraysWithAnnotations() {\n        rewriteRun(\n          java(\n            \"\"\"\n            import java.lang.annotation.ElementType;\n            import java.lang.annotation.Target;\n            \n            class A {\n               @Target({ ElementType.TYPE_USE, ElementType.TYPE_PARAMETER })\n               private static @interface C {\n               }\n\n               Comparable<@C Object @C []> specialArray; \n            }\n            \"\"\"\n          )\n        );\n    }\n```\nfails with:\n```\n[When parsing and printing the source code back to text without modifications, the printed source didn't match the original source code. This means there is a bug in the parser implementation itself. Please open an issue to report this, providing a sample of the code that generated this error for \"A.java\":\n```\n\n```diff\n-   Comparable<@C Object @C []> specialArray;\n+   Comparable<Objectect @C []> specialArray;\n```\n\n## Context\n\nOSS repro: https://github.com/classgraph/classgraph/blob/6f9012f2a193ebfefe4a4384e7642820e7aab0f5/src/test/java/io/github/classgraph/issues/issue402/TypeAnnotationTest.java#L65",
    "issue_word_count": 148,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java"
    ],
    "base_commit": "6b02819b76936e10934bf8d644cfb82687e116a0",
    "head_commit": "31532e1ec121a5cbfa6eadf6dda89aed72cbdcd6",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5618",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5618",
    "dockerfile": "",
    "pr_merged_at": "2025-06-13T11:11:23.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\nindex 5eb24dcd694..f0705876943 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n@@ -1266,6 +1266,13 @@ public J visitTypeCast(TypeCastTree node, Space fmt) {\n     public J visitAnnotatedType(AnnotatedTypeTree node, Space fmt) {\n         Map<Integer, JCAnnotation> annotationPosTable = mapAnnotations(node.getAnnotations(),\n                 new HashMap<>(node.getAnnotations().size()));\n+        Tree underlying = node.getUnderlyingType();\n+        if (underlying instanceof JCArrayTypeTree) {\n+            Tree element = ((JCArrayTypeTree) underlying).getType();\n+            if (element instanceof JCAnnotatedType) {\n+                annotationPosTable.putAll(mapAnnotations(((JCAnnotatedType) element).getAnnotations(), new HashMap<>()));\n+            }\n+        }\n         List<J.Annotation> leadingAnnotations = leadingAnnotations(annotationPosTable);\n         if (!annotationPosTable.isEmpty()) {\n             if (node.getUnderlyingType() instanceof JCFieldAccess) {\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex 7ae3fbdc886..1ce33cb7fb6 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -1356,6 +1356,9 @@ public J visitTypeCast(TypeCastTree node, Space fmt) {\n     public J visitAnnotatedType(AnnotatedTypeTree node, Space fmt) {\n         Map<Integer, JCAnnotation> annotationPosTable = mapAnnotations(node.getAnnotations(),\n                 new HashMap<>(node.getAnnotations().size()));\n+        if (node.getUnderlyingType() instanceof JCArrayTypeTree arrayTypeTree && arrayTypeTree.getType() instanceof JCAnnotatedType annotatedType) {\n+            annotationPosTable.putAll(mapAnnotations(annotatedType.getAnnotations(), new HashMap<>()));\n+        }\n         List<J.Annotation> leadingAnnotations = leadingAnnotations(annotationPosTable);\n         if (!annotationPosTable.isEmpty()) {\n             if (node.getUnderlyingType() instanceof JCFieldAccess) {\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex 20249ce2b3d..2aed9909cfe 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -1384,6 +1384,9 @@ public J visitTypeCast(TypeCastTree node, Space fmt) {\n     public J visitAnnotatedType(AnnotatedTypeTree node, Space fmt) {\n         Map<Integer, JCAnnotation> annotationPosTable = mapAnnotations(node.getAnnotations(),\n                 new HashMap<>(node.getAnnotations().size()));\n+        if (node.getUnderlyingType() instanceof JCArrayTypeTree arrayTypeTree && arrayTypeTree.getType() instanceof JCAnnotatedType annotatedType) {\n+            annotationPosTable.putAll(mapAnnotations(annotatedType.getAnnotations(), new HashMap<>()));\n+        }\n         List<J.Annotation> leadingAnnotations = leadingAnnotations(annotationPosTable);\n         if (!annotationPosTable.isEmpty()) {\n             if (node.getUnderlyingType() instanceof JCFieldAccess) {\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\nindex 2a5de0dce6e..7f4c0c7c629 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n@@ -1259,6 +1259,13 @@ public J visitTypeCast(TypeCastTree node, Space fmt) {\n     public J visitAnnotatedType(AnnotatedTypeTree node, Space fmt) {\n         Map<Integer, JCAnnotation> annotationPosTable = mapAnnotations(node.getAnnotations(),\n                 new HashMap<>(node.getAnnotations().size()));\n+        Tree underlying = node.getUnderlyingType();\n+        if (underlying instanceof JCArrayTypeTree) {\n+            Tree element = ((JCArrayTypeTree) underlying).getType();\n+            if (element instanceof JCAnnotatedType) {\n+                annotationPosTable.putAll(mapAnnotations(((JCAnnotatedType) element).getAnnotations(), new HashMap<>()));\n+            }\n+        }\n         List<J.Annotation> leadingAnnotations = leadingAnnotations(annotationPosTable);\n         if (!annotationPosTable.isEmpty()) {\n             if (node.getUnderlyingType() instanceof JCFieldAccess) {\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java\nindex 7aee360b496..6b47ffda548 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java\n@@ -659,4 +659,29 @@ public class A {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5329\")\n+    @Test\n+    void arraysWithAnnotations() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+            import java.lang.annotation.ElementType;\n+            import java.lang.annotation.Target;\n+            \n+            class A {\n+               @Target({ ElementType.TYPE_USE, ElementType.TYPE_PARAMETER })\n+               private static @interface C {\n+               }\n+               @Target({ ElementType.TYPE_USE, ElementType.TYPE_PARAMETER })\n+               private static @interface B {\n+               }\n+\n+               Comparable<@C Object @C []> specialArray1;\n+               Comparable<@C Object @B []> specialArray2;\n+            }\n+            \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5601",
    "pr_id": 5601,
    "issue_id": 5578,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Failure when using DependencyInsight with duplicated dependencies\nI noticed this regression when I used the latest version after a release on a codebase which (I imagine by accident) had the same dependency listed twice.\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using latest in main.\n\n## What is the smallest, simplest way to reproduce the problem?\n\n```java\n    @Test\n    void duplicateDependencies() {\n        rewriteRun(\n          spec -> spec.recipe(new DependencyInsight(\"org.springframework.*\", \"*\", null, null)),\n          buildGradle(\"\"\"\n          plugins {\n              id 'java'\n          }\n          repositories {\n              mavenCentral()\n          }\n          dependencies {\n              implementation \"org.springframework.boot:spring-boot-starter-web:3.4.4\"\n              implementation \"org.springframework.boot:spring-boot-starter-web:3.4.4\"\n          }\n          \"\"\",\n        \"\"\"\n          plugins {\n              id 'java'\n          }\n          repositories {\n              mavenCentral()\n          }\n          dependencies {\n              /*~~(org.springframework.boot:spring-boot-starter-web:3.4.4)~~>*/implementation \"org.springframework.boot:spring-boot-starter-web:3.4.4\"\n              /*~~(org.springframework.boot:spring-boot-starter-web:3.4.4)~~>*/implementation \"org.springframework.boot:spring-boot-starter-web:3.4.4\"\n          }\n          \"\"\"));\n    }\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\n\nTest pass as in v8.54.0\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\n\nTest fails\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n```\njava.lang.AssertionError: Failed to run recipe at Cursor{MethodInvocation->Return->JRightPadded(element=returnimplementation( \"org.springframework.boot:spring-boot-starter-web:3.4.4\"), after=Space(comments=<0 comments>, whitespace=<empty>))->Block->Lambda->JRightPadded(element=J.Lambda(id=3db463dd-57e0-4b83-b865-81b7bb870485, prefix=Space(comments=<0 comments>, whitespace='·₁'), markers=Markers(id=53f9dc08-61cb-46d2-823e-98a386b3052a, markers=[LambdaStyle(id=20e99e23-d2b8-40a4-b2f4-249eb9eca47e, javaStyle=false, arrow=false), OmitParentheses(id=0db0635d-2f6b-45f8-beaf-7c1e633b2b9a)]), parameters=J.Lambda.Parameters(padding=org.openrewrite.java.tree.J$Lambda$Parameters$Padding@361f26b4, id=8f488689-01af-4d9c-bf05-4e9f3cf910ab, prefix=Space(comments=<0 comments>, whitespace=<empty>), markers=Markers(id=71df4248-238e-4844-bab2-baa038e932a5, markers=[]), parenthesized=false, parameters=[J.Empty(id=a2c1ab50-9eca-49ad-9095-8e4073e71904, prefix=Space(comments=<0 comments>, whitespace=<empty>), markers=Markers(id=71df4248-238e-4844-bab2-baa038e932a5, markers=[]))]), arrow=Space(comments=<0 comments>, whitespace=<empty>), body=J.Block(padding=org.openrewrite.java.tree.J$Block$Padding@1d9ff1e2, id=a9ea0555-d191-41e8-80b6-1e313572668c, prefix=Space(comments=<0 comments>, whitespace=<empty>), markers=Markers(id=71df4248-238e-4844-bab2-baa038e932a5, markers=[]), statik=JRightPadded(element=false, after=Space(comments=<0 comments>, whitespace=<empty>)), statements=[implementation( \"org.springframework.boot:spring-boot-starter-web:3.4.4\"), returnimplementation( \"org.springframework.boot:spring-boot-starter-web:3.4.4\")], end=Space(comments=<0 comments>, whitespace='\\n')), type=groovy.lang.Closure<org.gradle.api.artifacts.Dependency>), after=Space(comments=<0 comments>, whitespace=<empty>))->JContainer(before=Space(comments=<0 comments>, whitespace=<empty>), elementCount=1)->MethodInvocation->CompilationUnit->root}\n\tat org.openrewrite.test.RewriteTest.lambda$defaultExecutionContext$14(RewriteTest.java:640)\n\tat org.openrewrite.test.RewriteTest$$Lambda/0x00007f9fb01a3cb8.accept(Unknown Source)\n\tat org.openrewrite.scheduling.RecipeRunCycle.handleError(RecipeRunCycle.java:291)\n\tat org.openrewrite.scheduling.RecipeRunCycle.lambda$editSources$8(RecipeRunCycle.java:230)\n\tat org.openrewrite.scheduling.RecipeRunCycle$$Lambda/0x00007f9fb079f0c0.apply(Unknown Source)\n\tat org.openrewrite.scheduling.RecipeStack.reduce(RecipeStack.java:60)\n\tat org.openrewrite.scheduling.RecipeRunCycle.lambda$editSources$9(RecipeRunCycle.java:179)\n\tat org.openrewrite.scheduling.RecipeRunCycle$$Lambda/0x00007f9fb079ec20.apply(Unknown Source)\n\tat org.openrewrite.internal.InMemoryLargeSourceSet.lambda$edit$0(InMemoryLargeSourceSet.java:83)\n\tat org.openrewrite.internal.InMemoryLargeSourceSet$$Lambda/0x00007f9fb079ee70.apply(Unknown Source)\n\tat org.openrewrite.internal.ListUtils.map(ListUtils.java:244)\n\tat org.openrewrite.internal.ListUtils.map(ListUtils.java:267)\n\tat org.openrewrite.internal.InMemoryLargeSourceSet.edit(InMemoryLargeSourceSet.java:82)\n\tat org.openrewrite.RecipeScheduler$$Lambda/0x00007f9fb079e7f0.apply(Unknown Source)\n\tat org.openrewrite.scheduling.RecipeRunCycle.editSources(RecipeRunCycle.java:177)\n\tat org.openrewrite.RecipeScheduler.runRecipeCycles(RecipeScheduler.java:84)\n\tat org.openrewrite.RecipeScheduler.scheduleRun(RecipeScheduler.java:41)\n\tat org.openrewrite.Recipe.run(Recipe.java:441)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:377)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:130)\n\tat org.openrewrite.gradle.search.DependencyInsightTest.duplicateDependencies(DependencyInsightTest.java:417)\n\tat java.base/java.lang.invoke.LambdaForm$DMH/0x00007f9fb0170000.invokeVirtual(LambdaForm$DMH)\n\tat java.base/java.lang.invoke.LambdaForm$MH/0x00007f9fb0098800.invoke(LambdaForm$MH)\n\tat java.base/java.lang.invoke.Invokers$Holder.invokeExact_MT(Invokers$Holder)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:580)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1596)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1596)\nCaused by: org.openrewrite.internal.RecipeRunException: java.lang.NullPointerException: Cannot invoke \"java.util.Set.stream()\" because the return value of \"java.util.Map.remove(Object)\" is null\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:281)\n\tat org.openrewrite.TreeVisitor.visitAndCast(TreeVisitor.java:311)\n\tat org.openrewrite.java.JavaVisitor.visitReturn(JavaVisitor.java:1100)\n\tat org.openrewrite.java.JavaIsoVisitor.visitReturn(JavaIsoVisitor.java:300)\n\tat org.openrewrite.java.JavaIsoVisitor.visitReturn(JavaIsoVisitor.java:30)\n\tat org.openrewrite.java.tree.J$Return.acceptJava(J.java:5336)\n\tat org.openrewrite.java.tree.J.accept(J.java:63)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.TreeVisitor.visitAndCast(TreeVisitor.java:311)\n\tat org.openrewrite.java.JavaVisitor.visitRightPadded(JavaVisitor.java:1380)\n\tat org.openrewrite.java.JavaVisitor.lambda$visitBlock$4(JavaVisitor.java:400)\n\tat org.openrewrite.java.JavaVisitor$$Lambda/0x00007f9fb05d6eb8.apply(Unknown Source)\n\tat org.openrewrite.internal.ListUtils.map(ListUtils.java:244)\n\tat org.openrewrite.internal.ListUtils.map(ListUtils.java:267)\n\tat org.openrewrite.java.JavaVisitor.visitBlock(JavaVisitor.java:399)\n\tat org.openrewrite.java.JavaIsoVisitor.visitBlock(JavaIsoVisitor.java:88)\n\tat org.openrewrite.java.JavaIsoVisitor.visitBlock(JavaIsoVisitor.java:30)\n\tat org.openrewrite.java.tree.J$Block.acceptJava(J.java:851)\n\tat org.openrewrite.java.tree.J.accept(J.java:63)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.TreeVisitor.visitAndCast(TreeVisitor.java:311)\n\tat org.openrewrite.java.JavaVisitor.visitLambda(JavaVisitor.java:798)\n\tat org.openrewrite.java.JavaIsoVisitor.visitLambda(JavaIsoVisitor.java:214)\n\tat org.openrewrite.java.JavaIsoVisitor.visitLambda(JavaIsoVisitor.java:30)\n\tat org.openrewrite.java.tree.J$Lambda.acceptJava(J.java:3544)\n\tat org.openrewrite.java.tree.J.accept(J.java:63)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.TreeVisitor.visitAndCast(TreeVisitor.java:311)\n\tat org.openrewrite.java.JavaVisitor.visitRightPadded(JavaVisitor.java:1380)\n\tat org.openrewrite.java.JavaVisitor.lambda$visitContainer$35(JavaVisitor.java:1430)\n\tat org.openrewrite.java.JavaVisitor$$Lambda/0x00007f9fb05d6a18.apply(Unknown Source)\n\tat org.openrewrite.internal.ListUtils.map(ListUtils.java:244)\n\tat org.openrewrite.internal.ListUtils.map(ListUtils.java:267)\n\tat org.openrewrite.java.JavaVisitor.visitContainer(JavaVisitor.java:1430)\n\tat org.openrewrite.java.JavaVisitor.visitMethodInvocation(JavaVisitor.java:914)\n\tat org.openrewrite.java.JavaIsoVisitor.visitMethodInvocation(JavaIsoVisitor.java:239)\n\tat org.openrewrite.gradle.search.DependencyInsight$MarkIndividualDependency.visitMethodInvocation(DependencyInsight.java:216)\n\tat org.openrewrite.gradle.search.DependencyInsight$MarkIndividualDependency.visitMethodInvocation(DependencyInsight.java:192)\n\tat org.openrewrite.gradle.search.DependencyInsight_MarkIndividualDependency_GroovyVisitor.visitMethodInvocation(DependencyInsight_MarkIndividualDependency_GroovyVisitor.zig:81)\n\tat org.openrewrite.java.tree.J$MethodInvocation.acceptJava(J.java:4281)\n\tat org.openrewrite.java.tree.J.accept(J.java:63)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.TreeVisitor.visitAndCast(TreeVisitor.java:311)\n\tat org.openrewrite.groovy.GroovyVisitor.lambda$visitCompilationUnit$0(GroovyVisitor.java:44)\n\tat org.openrewrite.groovy.GroovyVisitor$$Lambda/0x00007f9fb05d67c8.apply(Unknown Source)\n\tat org.openrewrite.internal.ListUtils.map(ListUtils.java:244)\n\tat org.openrewrite.internal.ListUtils.map(ListUtils.java:267)\n\tat org.openrewrite.groovy.GroovyVisitor.visitCompilationUnit(GroovyVisitor.java:44)\n\tat org.openrewrite.groovy.tree.G$CompilationUnit.acceptGroovy(G.java:212)\n\tat org.openrewrite.groovy.tree.G.accept(G.java:47)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.TreeVisitor.visitNonNull(TreeVisitor.java:167)\n\tat org.openrewrite.gradle.search.DependencyInsight$MarkIndividualDependency.attachMarkers(DependencyInsight.java:200)\n\tat org.openrewrite.gradle.search.DependencyInsight$1.visit(DependencyInsight.java:187)\n\tat org.openrewrite.gradle.search.DependencyInsight$1.visit(DependencyInsight.java:105)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:154)\n\tat org.openrewrite.scheduling.RecipeRunCycle.lambda$editSources$7(RecipeRunCycle.java:210)\n\tat org.openrewrite.scheduling.RecipeRunCycle$$Lambda/0x00007f9fb079f2e8.call(Unknown Source)\n\tat io.micrometer.core.instrument.AbstractTimer.recordCallable(AbstractTimer.java:147)\n\tat org.openrewrite.table.RecipeRunStats.recordEdit(RecipeRunStats.java:74)\n\tat org.openrewrite.scheduling.RecipeRunCycle.lambda$editSources$8(RecipeRunCycle.java:206)\n\t... 23 more\nCaused by: java.lang.NullPointerException: Cannot invoke \"java.util.Set.stream()\" because the return value of \"java.util.Map.remove(Object)\" is null\n\tat org.openrewrite.gradle.search.DependencyInsight$MarkIndividualDependency.lambda$visitMethodInvocation$4(DependencyInsight.java:237)\n\tat org.openrewrite.gradle.search.DependencyInsight$MarkIndividualDependency$$Lambda/0x00007f9fb07d3c40.apply(Unknown Source)\n\tat java.base/java.util.Optional.map(Optional.java:260)\n\tat org.openrewrite.gradle.search.DependencyInsight$MarkIndividualDependency.visitMethodInvocation(DependencyInsight.java:230)\n\tat org.openrewrite.gradle.search.DependencyInsight$MarkIndividualDependency.visitMethodInvocation(DependencyInsight.java:192)\n\tat org.openrewrite.java.tree.J$MethodInvocation.acceptJava(J.java:4281)\n\tat org.openrewrite.java.tree.J.accept(J.java:63)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\nYes\n",
    "issue_word_count": 1602,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/search/DependencyInsight.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/search/DependencyInsightTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/search/DependencyInsightTest.java"
    ],
    "base_commit": "7b279a5ea961610f6a0027234257ebe1b841241b",
    "head_commit": "3602decbd8f069ba0a19cd783e75579fe46dfe9c",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5601",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5601",
    "dockerfile": "",
    "pr_merged_at": "2025-06-11T19:53:35.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/DependencyInsight.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/DependencyInsight.java\nindex d31df1154a6..484fdff4cf0 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/DependencyInsight.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/DependencyInsight.java\n@@ -195,11 +195,14 @@ public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {\n     private static class MarkIndividualDependency extends JavaIsoVisitor<ExecutionContext> {\n         private final Map<String, Set<GroupArtifactVersion>> configurationToDirectDependency;\n         private final Map<GroupArtifactVersion, Set<GroupArtifactVersion>> directDependencyToTargetDependency;\n+        private final Set<GroupArtifactVersion> individuallyMarkedDependencies = new HashSet<>();\n \n         public Tree attachMarkers(Tree before, ExecutionContext ctx) {\n             Tree after = super.visitNonNull(before, ctx);\n             if (after == before) {\n-                String resultText = directDependencyToTargetDependency.values().stream()\n+                String resultText = directDependencyToTargetDependency.entrySet().stream()\n+                        .filter(target -> !individuallyMarkedDependencies.contains(target.getKey()))\n+                        .map(Map.Entry::getValue)\n                         .flatMap(Set::stream)\n                         .distinct()\n                         .map(target -> target.getGroupId() + \":\" + target.getArtifactId() + \":\" + target.getVersion())\n@@ -215,7 +218,9 @@ public Tree attachMarkers(Tree before, ExecutionContext ctx) {\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n             if (DEPENDENCY_CLOSURE_MATCHER.matches(m)) {\n-                String resultText = directDependencyToTargetDependency.values().stream()\n+                String resultText = directDependencyToTargetDependency.entrySet().stream()\n+                        .filter(target -> !individuallyMarkedDependencies.contains(target.getKey()))\n+                        .map(Map.Entry::getValue)\n                         .flatMap(Set::stream)\n                         .distinct()\n                         .map(target -> target.getGroupId() + \":\" + target.getArtifactId() + \":\" + target.getVersion())\n@@ -234,11 +239,12 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                             .findAny();\n                     if (configurationGav.isPresent()) {\n                         configurationToDirectDependency.get(m.getSimpleName());\n-                        Set<GroupArtifactVersion> removed = directDependencyToTargetDependency.remove(configurationGav.get());\n-                        if (removed == null) {\n+                        Set<GroupArtifactVersion> mark = directDependencyToTargetDependency.get(configurationGav.get());\n+                        if (mark == null) {\n                             return null;\n                         }\n-                        String resultText = removed.stream()\n+                        individuallyMarkedDependencies.add(configurationGav.get());\n+                        String resultText = mark.stream()\n                                 .map(target -> target.getGroupId() + \":\" + target.getArtifactId() + \":\" + target.getVersion())\n                                 .collect(Collectors.joining(\",\"));\n                         if (!resultText.isEmpty()) {\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/DependencyInsightTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/DependencyInsightTest.java\nindex d4403bda5f4..1596378aef1 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/DependencyInsightTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/DependencyInsightTest.java\n@@ -77,7 +77,7 @@ void findPluginDependencyAndAddToDependencyClosure() {\n                   gradlePluginPortal()\n               }\n               \"\"\",\n-                spec -> spec.path(\"buildSrc/build.gradle\")),\n+            spec -> spec.path(\"buildSrc/build.gradle\")),\n           groovy(\n             \"\"\"\n               plugins{\n@@ -87,7 +87,7 @@ void findPluginDependencyAndAddToDependencyClosure() {\n                   implementation 'com.google.guava:guava:31.1-jre'\n               }\n               \"\"\",\n-                spec -> spec.path(\"buildSrc/src/main/groovy/convention-plugin.gradle\")),\n+            spec -> spec.path(\"buildSrc/src/main/groovy/convention-plugin.gradle\")),\n           buildGradle(\n             \"\"\"\n               plugins {\n@@ -127,7 +127,7 @@ void findPluginDependencyAndAddToRoot() {\n                   gradlePluginPortal()\n               }\n               \"\"\",\n-                spec -> spec.path(\"buildSrc/build.gradle\")),\n+            spec -> spec.path(\"buildSrc/build.gradle\")),\n           groovy(\n             \"\"\"\n               plugins{\n@@ -137,7 +137,7 @@ void findPluginDependencyAndAddToRoot() {\n                   implementation 'com.google.guava:guava:31.1-jre'\n               }\n               \"\"\",\n-                spec -> spec.path(\"buildSrc/src/main/groovy/convention-plugin.gradle\")),\n+            spec -> spec.path(\"buildSrc/src/main/groovy/convention-plugin.gradle\")),\n           buildGradle(\n             \"\"\"\n               plugins {\n@@ -255,16 +255,16 @@ void nestedDependenciesAreTransitivelySearchedForMatchingDependencies() {\n         rewriteRun(\n           spec -> spec.recipe(new DependencyInsight(\"org.springframework.boot\", \"*\", null, null))\n             .dataTable(DependenciesInUse.Row.class, rows -> {\n-              assertThat(rows).isNotEmpty();\n-              DependenciesInUse.Row row = rows.getFirst();\n-              assertThat(row.getArtifactId()).isEqualTo(\"spring-boot-starter-web\");\n-              assertThat(row.getDepth()).isEqualTo(0);\n-              assertThat(row.getDirect()).isNotNull().hasToString(\"org.springframework.boot:spring-boot-starter-web:2.6.6\");\n-              row = rows.get(4);\n-              assertThat(row.getArtifactId()).isEqualTo(\"spring-boot\");\n-              assertThat(row.getDepth()).isEqualTo(4);\n-              assertThat(row.getDirect()).isNotNull().hasToString(\"org.springframework.boot:spring-boot-starter-web:2.6.6\");\n-          }),\n+                assertThat(rows).isNotEmpty();\n+                DependenciesInUse.Row row = rows.getFirst();\n+                assertThat(row.getArtifactId()).isEqualTo(\"spring-boot-starter-web\");\n+                assertThat(row.getDepth()).isEqualTo(0);\n+                assertThat(row.getDirect()).isNotNull().hasToString(\"org.springframework.boot:spring-boot-starter-web:2.6.6\");\n+                row = rows.get(4);\n+                assertThat(row.getArtifactId()).isEqualTo(\"spring-boot\");\n+                assertThat(row.getDepth()).isEqualTo(4);\n+                assertThat(row.getDirect()).isNotNull().hasToString(\"org.springframework.boot:spring-boot-starter-web:2.6.6\");\n+            }),\n           buildGradle(\n             \"\"\"\n               buildscript {\n@@ -281,11 +281,11 @@ void nestedDependenciesAreTransitivelySearchedForMatchingDependencies() {\n               repositories {\n                   mavenCentral()\n               }\n-    \n+              \n               apply plugin: 'org.springframework.boot'\n               apply plugin: 'io.spring.dependency-management'\n               apply plugin: 'java'\n-\n+              \n               java {\n                   sourceCompatibility = '11'\n               }\n@@ -311,11 +311,11 @@ void nestedDependenciesAreTransitivelySearchedForMatchingDependencies() {\n               repositories {\n                   mavenCentral()\n               }\n-    \n+              \n               apply plugin: 'org.springframework.boot'\n               apply plugin: 'io.spring.dependency-management'\n               apply plugin: 'java'\n-\n+              \n               java {\n                   sourceCompatibility = '11'\n               }\n@@ -363,11 +363,11 @@ void jacksonIsFoundInternally() {\n               repositories {\n                   mavenCentral()\n               }\n-    \n+              \n               apply plugin: 'org.springframework.boot'\n               apply plugin: 'io.spring.dependency-management'\n               apply plugin: 'java'\n-\n+              \n               java {\n                   sourceCompatibility = '11'\n               }\n@@ -393,11 +393,11 @@ void jacksonIsFoundInternally() {\n               repositories {\n                   mavenCentral()\n               }\n-    \n+              \n               apply plugin: 'org.springframework.boot'\n               apply plugin: 'io.spring.dependency-management'\n               apply plugin: 'java'\n-\n+              \n               java {\n                   sourceCompatibility = '11'\n               }\n@@ -411,4 +411,43 @@ void jacksonIsFoundInternally() {\n           )\n         );\n     }\n+\n+    @Test\n+    void duplicateDependencies() {\n+        rewriteRun(\n+          spec -> spec.beforeRecipe(withToolingApi()).recipe(new DependencyInsight(\"org.projectlombok\", \"lombok\", null, null)),\n+          buildGradle(\n+            \"\"\"\n+              plugins {\n+                  id 'java'\n+              }\n+              repositories {\n+                  mavenCentral()\n+              }\n+              dependencies {\n+                  compileOnly(\"org.projectlombok:lombok:1.18.38\")\n+                  annotationProcessor(\"org.projectlombok:lombok:1.18.38\")\n+              \n+                  testCompileOnly(\"org.projectlombok:lombok:1.18.38\")\n+                  testAnnotationProcessor(\"org.projectlombok:lombok:1.18.38\")\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  id 'java'\n+              }\n+              repositories {\n+                  mavenCentral()\n+              }\n+              dependencies {\n+                  /*~~(org.projectlombok:lombok:1.18.38)~~>*/compileOnly(\"org.projectlombok:lombok:1.18.38\")\n+                  /*~~(org.projectlombok:lombok:1.18.38)~~>*/annotationProcessor(\"org.projectlombok:lombok:1.18.38\")\n+              \n+                  /*~~(org.projectlombok:lombok:1.18.38)~~>*/testCompileOnly(\"org.projectlombok:lombok:1.18.38\")\n+                  /*~~(org.projectlombok:lombok:1.18.38)~~>*/testAnnotationProcessor(\"org.projectlombok:lombok:1.18.38\")\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5582",
    "pr_id": 5582,
    "issue_id": 5579,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Find And Replace Literal Recipe throws NullPointerException\nDue to change #5056, the FindAndReplaceLiteral recipe throws a null pointer exception [here](https://github.com/openrewrite/rewrite/blob/main/rewrite-hcl/src/main/java/org/openrewrite/hcl/search/FindAndReplaceLiteral.java#L92) when a null literal is used in a hcl file. \n\n## What version of OpenRewrite are you using?\n8.55.1\n\n## How are you running OpenRewrite?\nUnit test in private repo\n\n## What is the smallest, simplest way to reproduce the problem?\n\n```kotlin\nclass DebugHCL: RewriteTest{\n\n  override fun defaults(spec: RecipeSpec) {\n    spec.recipe(FindAndReplaceLiteral(\"foo\", \"bar\", null, null))\n  }\n\n  @Test\n  fun `debug`() {\n    rewriteRun(hcl(\"myVar = null\"))\n  }\n}\n```\n\n## What did you expect to see?\nNo change\n\n## What did you see instead?\n```cmd\nCaused by: java.lang.NullPointerException: Cannot invoke \"Object.toString()\" because the return value of \"org.openrewrite.hcl.tree.Hcl$Literal.getValue()\" is null\n\tat org.openrewrite.hcl.search.FindAndReplaceLiteral$1.visitLiteral(FindAndReplaceLiteral.java:92)\n\tat org.openrewrite.hcl.search.FindAndReplaceLiteral$1.visitLiteral(FindAndReplaceLiteral.java:74)\n\tat org.openrewrite.hcl.tree.Hcl$Literal.acceptHcl(Hcl.java:1274)\n\tat org.openrewrite.hcl.tree.Hcl.accept(Hcl.java:45)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:250)\n\t... 37 more\n```\n\n## Additional context\n- #5056",
    "issue_word_count": 195,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-hcl/src/main/java/org/openrewrite/hcl/search/FindAndReplaceLiteral.java",
      "rewrite-hcl/src/test/java/org/openrewrite/hcl/search/FindAndReplaceLiteralTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-hcl/src/test/java/org/openrewrite/hcl/search/FindAndReplaceLiteralTest.java"
    ],
    "base_commit": "d3a4f0efb9af5ee6309b978e0d92fe36f481b19f",
    "head_commit": "789b489473fadc26b30b2302a8de9efa122df4a3",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5582",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5582",
    "dockerfile": "",
    "pr_merged_at": "2025-06-09T17:54:13.000Z",
    "patch": "diff --git a/rewrite-hcl/src/main/java/org/openrewrite/hcl/search/FindAndReplaceLiteral.java b/rewrite-hcl/src/main/java/org/openrewrite/hcl/search/FindAndReplaceLiteral.java\nindex 844bd048e8e..c7f0049629a 100644\n--- a/rewrite-hcl/src/main/java/org/openrewrite/hcl/search/FindAndReplaceLiteral.java\n+++ b/rewrite-hcl/src/main/java/org/openrewrite/hcl/search/FindAndReplaceLiteral.java\n@@ -89,6 +89,9 @@ public Hcl.Literal visitLiteral(final Hcl.Literal literal, final ExecutionContex\n                     patternOptions |= Pattern.CASE_INSENSITIVE;\n                 }\n                 Pattern pattern = Pattern.compile(searchStr, patternOptions);\n+                if (literal.getValue() == null) {\n+                    return literal;\n+                }\n                 Matcher matcher = pattern.matcher(literal.getValue().toString());\n                 if (!matcher.find()) {\n                     return literal;\n",
    "test_patch": "diff --git a/rewrite-hcl/src/test/java/org/openrewrite/hcl/search/FindAndReplaceLiteralTest.java b/rewrite-hcl/src/test/java/org/openrewrite/hcl/search/FindAndReplaceLiteralTest.java\nindex d5493a7022b..40b438f38c3 100644\n--- a/rewrite-hcl/src/test/java/org/openrewrite/hcl/search/FindAndReplaceLiteralTest.java\n+++ b/rewrite-hcl/src/test/java/org/openrewrite/hcl/search/FindAndReplaceLiteralTest.java\n@@ -17,6 +17,7 @@\n \n import org.junit.jupiter.api.Test;\n import org.openrewrite.DocumentExample;\n+import org.openrewrite.Issue;\n import org.openrewrite.test.RewriteTest;\n \n import static org.openrewrite.hcl.Assertions.hcl;\n@@ -272,4 +273,20 @@ void successiveReplacement() {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5579\")\n+    void handleNullLiteral() {\n+        rewriteRun(\n+          spec -> spec.recipes(\n+            new FindAndReplaceLiteral(\"foo\", \"bar\", null, null)\n+          ),\n+          //language=hcl\n+          hcl(\n+            \"\"\"\n+              myVar = null\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5581",
    "pr_id": 5581,
    "issue_id": 4930,
    "repo": "openrewrite/rewrite",
    "problem_statement": "XML parser parses comments inside doctype subset into `Xml.Ident`\nGiven an XML document like the following:\n\n```xml\n  <?xml version=\"1.0\" encoding=\"iso-8859-1\" standalone=\"no\"?>\n  <!DOCTYPE xsl:stylesheet [\n  <!-- EXSLT-Math -->\n  <!ENTITY foons \"https://www.foo.org/bar\">\n  ]>\n  <xsl:stylesheet version=\"1.0\"/>\n```\n\nthe parser parses the comment into an `Xml.Ident` element rather than creating an `Xml.Comment`: https://github.com/openrewrite/rewrite/blob/b6f178b30a4298eb5f06015783638e17c77a75a9/rewrite-xml/src/main/java/org/openrewrite/xml/internal/XmlParserVisitor.java#L334-L338.\n\nThe name of the created `Xml.Ident` is `<!-- EXSLT-Math -->` which then can cause recipes to fail processing this.",
    "issue_word_count": 100,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-xml/src/main/java/org/openrewrite/xml/internal/XmlParserVisitor.java",
      "rewrite-xml/src/main/java/org/openrewrite/xml/tree/Xml.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/XmlParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-xml/src/test/java/org/openrewrite/xml/XmlParserTest.java"
    ],
    "base_commit": "597ce616701e66499d787b5c843f32ad617866d3",
    "head_commit": "f84a0a68ab41b1d5daec64fef182d69d81b4c54d",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5581",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5581",
    "dockerfile": "",
    "pr_merged_at": "2025-06-10T04:44:28.000Z",
    "patch": "diff --git a/rewrite-xml/src/main/java/org/openrewrite/xml/internal/XmlParserVisitor.java b/rewrite-xml/src/main/java/org/openrewrite/xml/internal/XmlParserVisitor.java\nindex a2f30e64e2d..0257c5442ef 100755\n--- a/rewrite-xml/src/main/java/org/openrewrite/xml/internal/XmlParserVisitor.java\n+++ b/rewrite-xml/src/main/java/org/openrewrite/xml/internal/XmlParserVisitor.java\n@@ -31,7 +31,6 @@\n import java.nio.charset.Charset;\n import java.nio.file.Path;\n import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.List;\n import java.util.function.BiFunction;\n \n@@ -329,27 +328,45 @@ public Xml.DocTypeDecl visitDoctypedecl(XMLParser.DoctypedeclContext ctx) {\n                 String subsetPrefix = prefix(c.DTD_SUBSET_OPEN());\n                 cursor = c.DTD_SUBSET_OPEN().getSymbol().getStopIndex() + 1;\n \n-                List<Xml.Element> elements = new ArrayList<>();\n-                List<ParseTree> children = c.intsubset().children;\n-                for (int i = 0; i < children.size(); i++) {\n-                    ParserRuleContext element = (ParserRuleContext) children.get(i);\n+                List<Content> elements = new ArrayList<>();\n+                for (ParseTree child : c.intsubset().children) {\n+                    ParserRuleContext element = (ParserRuleContext) child;\n                     // Markup declarations are not fully implemented.\n                     // n.getText() includes element subsets.\n-                    Xml.Ident ident = convert(element, (n, p) -> new Xml.Ident(randomId(), p, Markers.EMPTY, n.getText()));\n-\n-                    String beforeElementTag = \"\";\n-                    if (i == children.size() - 1) {\n-                        beforeElementTag = prefix(c.DTD_SUBSET_CLOSE());\n-                        cursor = c.DTD_SUBSET_CLOSE().getSymbol().getStopIndex() + 1;\n+                    Content content;\n+                    if (element instanceof XMLParser.MarkupdeclContext && ((XMLParser.MarkupdeclContext) element).COMMENT() != null) {\n+                        TerminalNode commentNode = ((XMLParser.MarkupdeclContext) element).COMMENT();\n+                        content = convert(commentNode, (n, p) -> new Xml.Comment(\n+                                randomId(),\n+                                p,\n+                                Markers.EMPTY,\n+                                n.getText().substring(\"<!--\".length(), n.getText().length() - \"-->\".length())\n+                        ));\n+                    } else {\n+                        content = convert(element, (n, p) -> new Xml.CharData(\n+                                randomId(),\n+                                p,\n+                                Markers.EMPTY,\n+                                false,\n+                                n.getText(),\n+                                \"\"\n+                        ));\n                     }\n+                    elements.add(content);\n+                }\n \n-                    elements.add(\n-                            new Xml.Element(\n-                                    randomId(),\n-                                    prefix(element),\n-                                    Markers.EMPTY,\n-                                    Collections.singletonList(ident),\n-                                    beforeElementTag));\n+                if (!elements.isEmpty()) {\n+                    String beforeElementTag = prefix(c.DTD_SUBSET_CLOSE());\n+                    cursor = c.DTD_SUBSET_CLOSE().getSymbol().getStopIndex() + 1;\n+\n+                    Content lastElement = elements.get(elements.size() - 1);\n+                    if (lastElement instanceof Xml.Comment) {\n+                        elements.add(new Xml.CharData(randomId(), \"\", Markers.EMPTY, false, beforeElementTag, \"\"));\n+                    } else if (lastElement instanceof Xml.CharData) {\n+                        Xml.CharData lastCharData = (Xml.CharData) lastElement;\n+                        String afterText = (lastCharData.getAfterText() == null ? \"\" : lastCharData.getAfterText()) + beforeElementTag;\n+                        elements.set(elements.size() - 1, lastCharData.withAfterText(afterText));\n+                    }\n                 }\n                 externalSubsets = new Xml.DocTypeDecl.ExternalSubsets(randomId(), subsetPrefix, Markers.EMPTY, elements);\n             }\n\ndiff --git a/rewrite-xml/src/main/java/org/openrewrite/xml/tree/Xml.java b/rewrite-xml/src/main/java/org/openrewrite/xml/tree/Xml.java\nindex 138f470ab7a..0aa98d64722 100755\n--- a/rewrite-xml/src/main/java/org/openrewrite/xml/tree/Xml.java\n+++ b/rewrite-xml/src/main/java/org/openrewrite/xml/tree/Xml.java\n@@ -740,7 +740,7 @@ public String getPrefix() {\n             }\n \n             Markers markers;\n-            List<Element> elements;\n+            List<Content> elements;\n \n             @Override\n             public <P> Xml acceptXml(XmlVisitor<P> v, P p) {\n",
    "test_patch": "diff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/XmlParserTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/XmlParserTest.java\nindex a1adfe133cc..59465b80a41 100755\n--- a/rewrite-xml/src/test/java/org/openrewrite/xml/XmlParserTest.java\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/XmlParserTest.java\n@@ -25,9 +25,11 @@\n import org.openrewrite.test.RecipeSpec;\n import org.openrewrite.test.RewriteTest;\n import org.openrewrite.trait.Reference;\n+import org.openrewrite.xml.tree.Content;\n import org.openrewrite.xml.tree.Xml;\n \n import java.nio.file.Paths;\n+import java.util.List;\n \n import static org.assertj.core.api.AssertionsForClassTypes.assertThat;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n@@ -463,4 +465,44 @@ void CRsWithNoLFs() {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4930\")\n+    @Test\n+    void commentIsParsedAsXmlComment() {\n+        rewriteRun(\n+          xml(\n+            \"\"\"\n+            <?xml version=\"1.0\" encoding=\"iso-8859-1\" standalone=\"no\"?>\n+            <!DOCTYPE xsl:stylesheet [\n+                <!-- EXSLT-Math -->\n+                <!ENTITY foons \"https://www.foo.org/bar\">\n+            ]>\n+            <xsl:stylesheet version=\"1.0\"/>\n+            \"\"\",\n+            spec -> spec.afterRecipe(doc -> {\n+                Xml.DocTypeDecl docTypeDecl = doc.getProlog().getMisc().stream()\n+                  .filter(Xml.DocTypeDecl.class::isInstance)\n+                  .map(Xml.DocTypeDecl.class::cast)\n+                  .findFirst()\n+                  .orElse(null);\n+\n+                assertNotNull(docTypeDecl, \"DocTypeDecl should be present\");\n+                assertNotNull(docTypeDecl.getExternalSubsets(), \"ExternalSubsets should be present\");\n+\n+                List<Content> elements = docTypeDecl.getExternalSubsets().getElements();\n+                assertThat(elements.size()).isEqualTo(2);\n+\n+                assertThat(elements.get(0))\n+                  .as(\"Comment should be Xml.Comment\")\n+                  .isInstanceOf(Xml.Comment.class);\n+                assertThat(((Xml.Comment) elements.get(0)).getText().trim())\n+                  .isEqualTo(\"EXSLT-Math\");\n+\n+                assertThat(elements.get(1))\n+                  .as(\"Non-comment should be Xml.CharData\")\n+                  .isInstanceOf(Xml.CharData.class);\n+            })\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5546",
    "pr_id": 5546,
    "issue_id": 5542,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Regression in `AddImport`: randomly misses imports\nConsider the test below in `AddImportTest`:\n\n```java\n@Test\nvoid codeSanityCheck() {\n    rewriteRun(\n      spec -> spec.parser(JavaParser.fromJavaVersion().dependsOn(\n        \"\"\"\n          package com.ex.app.config;\n          public class OldA {}\n          \"\"\",\n        \"\"\"\n          package com.ex.app.task;\n          public class OldB {}\n          \"\"\",\n        \"\"\"\n          package com.ex.app.task;\n          public class OldC {}\n          \"\"\",\n        \"\"\"\n          package com.ex.app.task;\n          public class OldD {}\n          \"\"\",\n        \"\"\"\n          package com.ex.app.task;\n          public class OldE {}\n          \"\"\"\n      )).recipes(\n        new ChangeType(\"com.ex.app.config.OldA\", \"com.ex.app.config.NewA\", null),\n        new ChangeType(\"com.ex.app.task.OldB\", \"com.ex.app.task.NewB\", null),\n        new ChangeType(\"com.ex.app.task.OldC\", \"com.ex.app.task.NewC\", null),\n        new ChangeType(\"com.ex.app.task.OldD\", \"com.ex.app.task.NewD\", null),\n        new ChangeType(\"com.ex.app.task.OldE\", \"com.ex.app.task.NewE\", null)\n      ),\n      java(\n        \"\"\"\n          package sample;\n          \n          import com.ex.app.config.OldA;\n          import com.ex.app.task.OldB;\n          import com.ex.app.task.OldC;\n          import com.ex.app.task.OldD;\n          import com.ex.app.task.OldE;\n          \n          public class A {\n              private final OldA a;\n              private final OldB b;\n              private final OldC c;\n              private final OldD d;\n              private final OldE e;\n          \n              public A(OldA a, OldB b, OldC c, OldD d, OldE e) {\n                  this.a = a;\n                  this.b = b;\n                  this.c = c;\n                  this.d = d;\n                  this.e = e;\n              }\n          }\n          \"\"\", \"\"\"\n          package sample;\n          \n          import com.ex.app.config.NewA;\n          import com.ex.app.task.NewB;\n          import com.ex.app.task.NewC;\n          import com.ex.app.task.NewD;\n          import com.ex.app.task.NewE;\n          \n          public class A {\n              private final NewA a;\n              private final NewB b;\n              private final NewC c;\n              private final NewD d;\n              private final NewE e;\n          \n              public A(NewA a, NewB b, NewC c, NewD d, NewE e) {\n                  this.a = a;\n                  this.b = b;\n                  this.c = c;\n                  this.d = d;\n                  this.e = e;\n              }\n          }\n          \"\"\"\n      )\n    );\n}\n```\n\nIf you run you'd find that it would **randomly** miss one or more import statements:\n> Unexpected result in \"sample/A.java\":\n```diff\ndiff --git a/sample/A.java b/sample/A.java\nindex 5748f86..90e95bb 100644\n--- a/sample/A.java\n+++ b/sample/A.java\n@@ -1,8 +1,6 @@ \n package sample;\n \n-import com.ex.app.config.NewA;\n import com.ex.app.task.NewB;\n-import com.ex.app.task.NewC;\n import com.ex.app.task.NewD;\n import com.ex.app.task.NewE;\n```\n\nIf it doesn't fail for the first time run in 5 times. Pretty sure one would fail.\nWith 8.52.1 it doesn't fail but fails with 8.53.0 and up. It is the changes to `AddImport` folded into 8.53.0 release ",
    "issue_word_count": 421,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/AddImportTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/AddImport.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/AddImportTest.java"
    ],
    "base_commit": "d7bb97c1369a8a3bbfdf7de8ad0ec841044c3f1b",
    "head_commit": "5af72a9efb3bd8efb5a3a14dd567ca36387edc7b",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5546",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5546",
    "dockerfile": "",
    "pr_merged_at": "2025-06-03T06:44:08.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/AddImport.java b/rewrite-java/src/main/java/org/openrewrite/java/AddImport.java\nindex e78840c30d2..1ca1294ac8e 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/AddImport.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/AddImport.java\n@@ -269,7 +269,10 @@ private Optional<JavaType> findTypeReference(JavaSourceFile compilationUnit) {\n             //Non-static imports, we just look for field accesses.\n             for (NameTree t : FindTypes.find(compilationUnit, fullyQualifiedName)) {\n                 if (!(t instanceof J.FieldAccess) || !((J.FieldAccess) t).isFullyQualifiedClassReference(fullyQualifiedName)) {\n-                    return getTypeReference(t);\n+                    Optional<JavaType> mayBeTypeReference = getTypeReference(t);\n+                    if (mayBeTypeReference.isPresent()) {\n+                        return mayBeTypeReference;\n+                    }\n                 }\n             }\n             return Optional.empty();\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/AddImportTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/AddImportTest.java\nindex ffe089879b9..a9c6e41b1c6 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/AddImportTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/AddImportTest.java\n@@ -1655,4 +1655,90 @@ class Test {\n         );\n     }\n \n+    @Test\n+    void codeSanityCheck() {\n+        rewriteRun(\n+          spec -> spec.parser(JavaParser.fromJavaVersion().dependsOn(\n+            \"\"\"\n+              package com.ex.app.config;\n+              public class OldA {}\n+              \"\"\",\n+            \"\"\"\n+              package com.ex.app.task;\n+              public class OldB {}\n+              \"\"\",\n+            \"\"\"\n+              package com.ex.app.task;\n+              public class OldC {}\n+              \"\"\",\n+            \"\"\"\n+              package com.ex.app.task;\n+              public class OldD {}\n+              \"\"\",\n+            \"\"\"\n+              package com.ex.app.task;\n+              public class OldE {}\n+              \"\"\"\n+          )).recipes(\n+            new ChangeType(\"com.ex.app.config.OldA\", \"com.ex.app.config.NewA\", null),\n+            new ChangeType(\"com.ex.app.task.OldB\", \"com.ex.app.task.NewB\", null),\n+            new ChangeType(\"com.ex.app.task.OldC\", \"com.ex.app.task.NewC\", null),\n+            new ChangeType(\"com.ex.app.task.OldD\", \"com.ex.app.task.NewD\", null),\n+            new ChangeType(\"com.ex.app.task.OldE\", \"com.ex.app.task.NewE\", null)\n+          ),\n+          java(\n+            \"\"\"\n+              package sample;\n+              \n+              import com.ex.app.config.OldA;\n+              import com.ex.app.task.OldB;\n+              import com.ex.app.task.OldC;\n+              import com.ex.app.task.OldD;\n+              import com.ex.app.task.OldE;\n+              \n+              public class A {\n+                  private final OldA a;\n+                  private final OldB b;\n+                  private final OldC c;\n+                  private final OldD d;\n+                  private final OldE e;\n+              \n+                  public A(OldA a, OldB b, OldC c, OldD d, OldE e) {\n+                      this.a = a;\n+                      this.b = b;\n+                      this.c = c;\n+                      this.d = d;\n+                      this.e = e;\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+          package sample;\n+          \n+          import com.ex.app.config.NewA;\n+          import com.ex.app.task.NewB;\n+          import com.ex.app.task.NewC;\n+          import com.ex.app.task.NewD;\n+          import com.ex.app.task.NewE;\n+          \n+          public class A {\n+              private final NewA a;\n+              private final NewB b;\n+              private final NewC c;\n+              private final NewD d;\n+              private final NewE e;\n+          \n+              public A(NewA a, NewB b, NewC c, NewD d, NewE e) {\n+                  this.a = a;\n+                  this.b = b;\n+                  this.c = c;\n+                  this.d = d;\n+                  this.e = e;\n+              }\n+          }\n+          \"\"\"\n+          )\n+        );\n+    }\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5535",
    "pr_id": 5535,
    "issue_id": 5443,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Parsing invalid Javadoc reference fails\n## What version of OpenRewrite are you using?\n\n* org.openrewrite:rewrite-core:8.52.1\n\n## What is the smallest, simplest way to reproduce the problem?\n\nThis is a case the Javadoc is invalid, but where the parser should yet not fail. This was found in our code base but have since been fixed so this is not a blocker for us.\n\n```java\n  @Test\n  void parsingIncorrectJavadocValueReference() {\n    rewriteRun(\n        // language=java\n        java(\n            \"\"\"\n            public class Foo {\n                private static final String BAR = \"bar\";\n\n                /**\n                This is an incorrect reference {@value BAR}\n                */\n                public void foo() {}\n            }\n            \"\"\"));\n  }\n```\n\nFails with:\n\n```\norg.openrewrite.internal.RecipeRunException: java.lang.NullPointerException: Cannot invoke \"org.openrewrite.java.tree.JRightPadded.getElement()\" because \"this.containing\" is null\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:281)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:154)\n\tat org.openrewrite.java.JavadocVisitor.javaVisitorVisit(JavadocVisitor.java:38)\n\tat org.openrewrite.java.JavadocPrinter.visitInlinedValue(JavadocPrinter.java:148)\n\tat org.openrewrite.java.JavadocPrinter.visitInlinedValue(JavadocPrinter.java:29)\n\tat org.openrewrite.java.tree.Javadoc$InlinedValue.acceptJavadoc(Javadoc.java:282)\n\tat org.openrewrite.java.tree.Javadoc.accept(Javadoc.java:39)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.java.JavadocPrinter.visit(JavadocPrinter.java:352)\n\tat org.openrewrite.java.JavadocPrinter.visitDocComment(JavadocPrinter.java:71)\n\tat org.openrewrite.java.JavadocPrinter.visitDocComment(JavadocPrinter.java:29)\n\tat org.openrewrite.java.tree.Javadoc$DocComment.acceptJavadoc(Javadoc.java:158)\n\tat org.openrewrite.java.tree.Javadoc.accept(Javadoc.java:39)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:154)\n\tat org.openrewrite.java.tree.Javadoc$DocComment.printComment(Javadoc.java:163)\n\tat org.openrewrite.java.JavaPrinter.visitSpace(JavaPrinter.java:69)\n\tat org.openrewrite.java.JavaPrinter.beforeSyntax(JavaPrinter.java:1263)\n\tat org.openrewrite.java.JavaPrinter.beforeSyntax(JavaPrinter.java:1252)\n\tat org.openrewrite.java.JavaPrinter.visitMethodDeclaration(JavaPrinter.java:828)\n\tat org.openrewrite.java.JavaPrinter.visitMethodDeclaration(JavaPrinter.java:35)\n\tat org.openrewrite.java.tree.J$MethodDeclaration.acceptJava(J.java:3811)\n\tat org.openrewrite.java.tree.J.accept(J.java:58)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.java.JavaPrinter.visitStatement(JavaPrinter.java:403)\n\tat org.openrewrite.java.JavaPrinter.visitStatements(JavaPrinter.java:394)\n\tat org.openrewrite.java.JavaPrinter.visitBlock(JavaPrinter.java:385)\n\tat org.openrewrite.java.JavaPrinter.visitBlock(JavaPrinter.java:35)\n\tat org.openrewrite.java.tree.J$Block.acceptJava(J.java:837)\n\tat org.openrewrite.java.tree.J.accept(J.java:58)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.java.JavaPrinter.visitClassDeclaration(JavaPrinter.java:558)\n\tat org.openrewrite.java.JavaPrinter.visitClassDeclaration(JavaPrinter.java:35)\n\tat org.openrewrite.java.tree.J$ClassDeclaration.acceptJava(J.java:1345)\n\tat org.openrewrite.java.tree.J.accept(J.java:58)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:291)\n\tat org.openrewrite.java.JavaPrinter.visitCompilationUnit(JavaPrinter.java:571)\n\tat org.openrewrite.java.JavaPrinter.visitCompilationUnit(JavaPrinter.java:35)\n\tat org.openrewrite.java.tree.J$CompilationUnit.acceptJava(J.java:1616)\n\tat org.openrewrite.java.tree.J.accept(J.java:58)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:154)\n\tat org.openrewrite.Tree.print(Tree.java:81)\n\tat org.openrewrite.SourceFile.printAll(SourceFile.java:102)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:314)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:130)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:125)\n\tat \nKnownBugsTest.parsingIncorrectJavadocValueReference(KnownBugsTest.java:338)\nCaused by: java.lang.NullPointerException: Cannot invoke \"org.openrewrite.java.tree.JRightPadded.getElement()\" because \"this.containing\" is null\n\tat org.openrewrite.java.tree.J$MemberReference.getContaining(J.java:3544)\n\tat org.openrewrite.java.JavadocPrinter$JavadocJavaPrinter.visitMemberReference(JavadocPrinter.java:400)\n\tat org.openrewrite.java.JavadocPrinter$JavadocJavaPrinter.visitMemberReference(JavadocPrinter.java:366)\n\tat org.openrewrite.java.tree.J$MemberReference.acceptJava(J.java:3614)\n\tat org.openrewrite.java.tree.J.accept(J.java:58)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:154)\n\tat org.openrewrite.java.JavadocVisitor.javaVisitorVisit(JavadocVisitor.java:38)\n\tat org.openrewrite.java.JavadocPrinter.visitInlinedValue(JavadocPrinter.java:148)\n\tat org.openrewrite.java.JavadocPrinter.visitInlinedValue(JavadocPrinter.java:29)\n\tat org.openrewrite.java.tree.Javadoc$InlinedValue.acceptJavadoc(Javadoc.java:282)\n\tat org.openrewrite.java.tree.Javadoc.accept(Javadoc.java:39)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.java.JavadocPrinter.visit(JavadocPrinter.java:352)\n\tat org.openrewrite.java.JavadocPrinter.visitDocComment(JavadocPrinter.java:71)\n\tat org.openrewrite.java.JavadocPrinter.visitDocComment(JavadocPrinter.java:29)\n\tat org.openrewrite.java.tree.Javadoc$DocComment.acceptJavadoc(Javadoc.java:158)\n\tat org.openrewrite.java.tree.Javadoc.accept(Javadoc.java:39)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:154)\n\tat org.openrewrite.java.tree.Javadoc$DocComment.printComment(Javadoc.java:163)\n\tat org.openrewrite.java.JavaPrinter.visitSpace(JavaPrinter.java:69)\n\tat org.openrewrite.java.JavaPrinter.beforeSyntax(JavaPrinter.java:1263)\n\tat org.openrewrite.java.JavaPrinter.beforeSyntax(JavaPrinter.java:1252)\n\tat org.openrewrite.java.JavaPrinter.visitMethodDeclaration(JavaPrinter.java:828)\n\tat org.openrewrite.java.JavaPrinter.visitMethodDeclaration(JavaPrinter.java:35)\n\tat org.openrewrite.java.tree.J$MethodDeclaration.acceptJava(J.java:3811)\n\tat org.openrewrite.java.tree.J.accept(J.java:58)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.java.JavaPrinter.visitStatement(JavaPrinter.java:403)\n\tat org.openrewrite.java.JavaPrinter.visitStatements(JavaPrinter.java:394)\n\tat org.openrewrite.java.JavaPrinter.visitBlock(JavaPrinter.java:385)\n\tat org.openrewrite.java.JavaPrinter.visitBlock(JavaPrinter.java:35)\n\tat org.openrewrite.java.tree.J$Block.acceptJava(J.java:837)\n\tat org.openrewrite.java.tree.J.accept(J.java:58)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.java.JavaPrinter.visitClassDeclaration(JavaPrinter.java:558)\n\tat org.openrewrite.java.JavaPrinter.visitClassDeclaration(JavaPrinter.java:35)\n\tat org.openrewrite.java.tree.J$ClassDeclaration.acceptJava(J.java:1345)\n\tat org.openrewrite.java.tree.J.accept(J.java:58)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:291)\n\tat org.openrewrite.java.JavaPrinter.visitCompilationUnit(JavaPrinter.java:571)\n\tat org.openrewrite.java.JavaPrinter.visitCompilationUnit(JavaPrinter.java:35)\n\tat org.openrewrite.java.tree.J$CompilationUnit.acceptJava(J.java:1616)\n\tat org.openrewrite.java.tree.J.accept(J.java:58)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:154)\n\tat org.openrewrite.Tree.print(Tree.java:81)\n\tat org.openrewrite.SourceFile.printAll(SourceFile.java:102)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:314)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:130)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:125)\n```\n",
    "issue_word_count": 1068,
    "test_files_count": 1,
    "non_test_files_count": 8,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java",
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/JavadocPrinter.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java"
    ],
    "base_commit": "400179977d08bb291c40cbd86e87c5c30a55aede",
    "head_commit": "ac8ae7b0e88f0178bd88a65336a3bb07014c0f6d",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5535",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5535",
    "dockerfile": "",
    "pr_merged_at": "2025-06-02T13:17:29.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\nindex 97084215c50..af01a241279 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\n@@ -665,7 +665,7 @@ public Tree visitProvides(ProvidesTree node, List<Javadoc> body) {\n                         randomId(),\n                         qualifier == null ? Space.EMPTY : qualifier.getPrefix(),\n                         Markers.EMPTY,\n-                        qualifier == null ? null : JRightPadded.build(qualifier.withPrefix(Space.EMPTY)),\n+                        JRightPadded.build(qualifier == null ? null : qualifier.withPrefix(Space.EMPTY)),\n                         JContainer.empty(),\n                         JLeftPadded.build(name),\n                         null,\n\ndiff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\nindex 331ae90f16c..6341a7ec82e 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n@@ -27,7 +27,6 @@\n import com.sun.tools.javac.tree.JCTree.*;\n import com.sun.tools.javac.util.Context;\n import org.jspecify.annotations.Nullable;\n-import org.openrewrite.Cursor;\n import org.openrewrite.ExecutionContext;\n import org.openrewrite.FileAttributes;\n import org.openrewrite.PrintOutputCapture;\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\nindex 36ae7d77381..66a8e3894f5 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\n@@ -668,7 +668,7 @@ public Tree visitProvides(ProvidesTree node, List<Javadoc> body) {\n                         randomId(),\n                         qualifier == null ? Space.EMPTY : qualifier.getPrefix(),\n                         Markers.EMPTY,\n-                        qualifier == null ? null : JRightPadded.build(qualifier.withPrefix(Space.EMPTY)),\n+                        JRightPadded.build(qualifier == null ? null : qualifier.withPrefix(Space.EMPTY)),\n                         JContainer.empty(),\n                         JLeftPadded.build(name),\n                         null,\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex 675bd5f2ad7..263225efc57 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -27,7 +27,6 @@\n import com.sun.tools.javac.tree.JCTree.*;\n import com.sun.tools.javac.util.Context;\n import org.jspecify.annotations.Nullable;\n-import org.openrewrite.Cursor;\n import org.openrewrite.ExecutionContext;\n import org.openrewrite.FileAttributes;\n import org.openrewrite.PrintOutputCapture;\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\nindex 872208ac2d5..dd577327567 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\n@@ -668,7 +668,7 @@ public Tree visitProvides(ProvidesTree node, List<Javadoc> body) {\n                         randomId(),\n                         qualifier == null ? Space.EMPTY : qualifier.getPrefix(),\n                         Markers.EMPTY,\n-                        qualifier == null ? null : JRightPadded.build(qualifier.withPrefix(Space.EMPTY)),\n+                        JRightPadded.build(qualifier == null ? null : qualifier.withPrefix(Space.EMPTY)),\n                         JContainer.empty(),\n                         JLeftPadded.build(name),\n                         null,\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex 4fbb0306fd8..07011a086c2 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -27,7 +27,6 @@\n import com.sun.tools.javac.tree.JCTree.*;\n import com.sun.tools.javac.util.Context;\n import org.jspecify.annotations.Nullable;\n-import org.openrewrite.Cursor;\n import org.openrewrite.ExecutionContext;\n import org.openrewrite.FileAttributes;\n import org.openrewrite.PrintOutputCapture;\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\nindex b4b66a24b23..24dd0cd9927 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\n@@ -625,7 +625,7 @@ public Tree visitParam(ParamTree node, List<Javadoc> body) {\n                         randomId(),\n                         qualifier == null ? Space.EMPTY : qualifier.getPrefix(),\n                         Markers.EMPTY,\n-                        qualifier == null ? null : JRightPadded.build(qualifier.withPrefix(Space.EMPTY)),\n+                        JRightPadded.build(qualifier == null ? null : qualifier.withPrefix(Space.EMPTY)),\n                         JContainer.empty(),\n                         JLeftPadded.build(name),\n                         null,\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavadocPrinter.java b/rewrite-java/src/main/java/org/openrewrite/java/JavadocPrinter.java\nindex d3b0bae0bee..ce71b8c617b 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavadocPrinter.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavadocPrinter.java\n@@ -397,8 +397,13 @@ public J visitFieldAccess(J.FieldAccess fieldAccess, PrintOutputCapture<P> p) {\n         @Override\n         public J visitMemberReference(J.MemberReference memberRef, PrintOutputCapture<P> p) {\n             beforeSyntax(memberRef, Space.Location.MEMBER_REFERENCE_PREFIX, p);\n-            visit(memberRef.getContaining(), p);\n-            visitLeftPadded(\"#\", memberRef.getPadding().getReference(), JLeftPadded.Location.MEMBER_REFERENCE_NAME, p);\n+            Expression containing = memberRef.getContaining();\n+            if (containing != null) { // Invalid references will have a null containing\n+                visit(containing, p);\n+                visitLeftPadded(\"#\", memberRef.getPadding().getReference(), JLeftPadded.Location.MEMBER_REFERENCE_NAME, p);\n+            } else {\n+                visitLeftPadded(null, memberRef.getPadding().getReference(), JLeftPadded.Location.MEMBER_REFERENCE_NAME, p);\n+            }\n             afterSyntax(memberRef, p);\n             return memberRef;\n         }\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\nindex 5833fd7ebd0..66b90ae3477 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\n@@ -2073,4 +2073,25 @@ class Test {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5443\")\n+    @Test\n+    void parsingIncorrectJavadocValueReference() {\n+        rewriteRun(\n+          spec-> spec.typeValidationOptions(TypeValidation.all().identifiers(false)),\n+          // language=java\n+          java(\n+            \"\"\"\n+            public class Foo {\n+                private static final String BAR = \"bar\";\n+\n+                /**\n+                This is an incorrect reference {@value BAR}\n+                */\n+                public void foo() {}\n+            }\n+            \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5533",
    "pr_id": 5533,
    "issue_id": 5526,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Spring Boot 3.5 recipes fail with ClassCastException when calling AddOrUpdateAnnotationAttribute\n## What version of OpenRewrite are you using?\n8.54.0\n\n## How are you running OpenRewrite?\nModerne\n\n## What is the smallest, simplest way to reproduce the problem?\n\nI am not fully sure, but I bet it would be:\n- run `AddOrUpdateAnnotationAttribute` against a class which has field-accesses as attribute values\n\n## OSS repro\n- Run Spring Boot 3.5 upgrade recipe against https://github.com/spring-cloud/spring-cloud-sleuth/blob/43744e8471f1629d26afafc3fa696b6b826a11a4/tests/brave/spring-cloud-sleuth-instrumentation-mvc-tests/src/test/java/org/springframework/cloud/sleuth/brave/instrument/web/TraceFilterWebIntegrationTests.java#L226\n\n<img width=\"965\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/c258daaf-8e18-4ccb-ba7d-06bdba69c770\" />\n\n## Error message\n```\njava.lang.ClassCastException: class org.openrewrite.java.tree.J$FieldAccess cannot be cast to class org.openrewrite.java.tree.J$Literal (org.openrewrite.java.tree.J$FieldAccess and org.openrewrite.java.tree.J$Literal are in unnamed module of loader 'app')\n  org.openrewrite.java.AddOrUpdateAnnotationAttribute$1.lambda$visitAnnotation$4(AddOrUpdateAnnotationAttribute.java:197)\n  org.openrewrite.internal.ListUtils.map(ListUtils.java:244)\n  org.openrewrite.internal.ListUtils.map(ListUtils.java:267)\n  org.openrewrite.java.AddOrUpdateAnnotationAttribute$1.visitAnnotation(AddOrUpdateAnnotationAttribute.java:137)\n  org.openrewrite.java.AddOrUpdateAnnotationAttribute$1.visitAnnotation(AddOrUpdateAnnotationAttribute.java:99)\n  org.openrewrite.java.tree.J$Annotation.acceptJava(J.java:247)\n```",
    "issue_word_count": 216,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java"
    ],
    "base_commit": "f37ee624b09484e44ecd857baafc8f47cef07f48",
    "head_commit": "22c65dec1f372ab8e0802d425c9674550244526b",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5533",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5533",
    "dockerfile": "",
    "pr_merged_at": "2025-05-31T22:45:18.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java b/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java\nindex 7adba9842d3..c4cf4da7ad7 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java\n@@ -152,7 +152,7 @@ public J.Annotation visitAnnotation(J.Annotation a, ExecutionContext ctx) {\n                             }\n \n                             if (as.getAssignment() instanceof J.NewArray) {\n-                                List<Expression> jLiteralList = requireNonNull(((J.NewArray) as.getAssignment()).getInitializer());\n+                                List<Expression> initializerList = requireNonNull(((J.NewArray) as.getAssignment()).getInitializer());\n                                 String attributeValueCleanedUp = attributeValue.replaceAll(\"\\\\s+\", \"\").replaceAll(\"[\\\\s+{}\\\"]\", \"\");\n                                 List<String> attributeList = Arrays.asList(attributeValueCleanedUp.contains(\",\") ? attributeValueCleanedUp.split(\",\") : new String[]{attributeValueCleanedUp});\n \n@@ -164,7 +164,7 @@ public J.Annotation visitAnnotation(J.Annotation a, ExecutionContext ctx) {\n                                     boolean changed = false;\n                                     for (String attrListValues : attributeList) {\n                                         String newAttributeListValue = maybeQuoteStringArgument(attributeName, attrListValues, finalA);\n-                                        if (Boolean.FALSE.equals(addOnly) && attributeValIsAlreadyPresent(jLiteralList, newAttributeListValue)) {\n+                                        if (Boolean.FALSE.equals(addOnly) && attributeValIsAlreadyPresent(initializerList, newAttributeListValue)) {\n                                             continue;\n                                         }\n                                         if (oldAttributeValue != null && !oldAttributeValue.equals(attrListValues)) {\n@@ -176,44 +176,45 @@ public J.Annotation visitAnnotation(J.Annotation a, ExecutionContext ctx) {\n                                                 .build()\n                                                 .apply(getCursor(), finalA.getCoordinates().replaceArguments()))\n                                                 .getArguments()).get(0);\n-                                        jLiteralList.add(e);\n+                                        initializerList.add(e);\n                                     }\n-                                    return changed ? as.withAssignment(((J.NewArray) as.getAssignment()).withInitializer(jLiteralList))\n+                                    return changed ? as.withAssignment(((J.NewArray) as.getAssignment()).withInitializer(initializerList))\n                                             .withMarkers(as.getMarkers().add(new AlreadyAppended(randomId(), newAttributeValue))) : as;\n                                 }\n                                 int m = 0;\n-                                for (int i = 0; i < requireNonNull(jLiteralList).size(); i++) {\n+                                for (int i = 0; i < requireNonNull(initializerList).size(); i++) {\n                                     if (i >= attributeList.size()) {\n-                                        jLiteralList.remove(i);\n+                                        initializerList.remove(i);\n                                         i--;\n                                         continue;\n                                     }\n \n                                     String newAttributeListValue = maybeQuoteStringArgument(attributeName, attributeList.get(i), finalA);\n-                                    if (jLiteralList.size() == i + 1) {\n+                                    if (initializerList.size() == i + 1) {\n                                         m = i + 1;\n                                     }\n \n-                                    if (newAttributeListValue.equals(((J.Literal) jLiteralList.get(i)).getValueSource()) || Boolean.TRUE.equals(addOnly)) {\n+                                    if (initializerList.get(i) instanceof J.Literal && newAttributeListValue.equals(((J.Literal) initializerList.get(i)).getValueSource()) || Boolean.TRUE.equals(addOnly)) {\n                                         continue;\n                                     }\n                                     if (oldAttributeValue != null && !oldAttributeValue.equals(attributeList.get(i))) {\n                                         continue;\n                                     }\n \n-                                    jLiteralList.set(i, ((J.Literal) jLiteralList.get(i)).withValue(newAttributeListValue).withValueSource(newAttributeListValue).withPrefix(jLiteralList.get(i).getPrefix()));\n+                                    J.Literal newLiteral = new J.Literal(randomId(), initializerList.get(i).getPrefix(), Markers.EMPTY, newAttributeListValue, newAttributeListValue, null, JavaType.Primitive.String);\n+                                    initializerList.set(i, newLiteral);\n                                 }\n-                                if (jLiteralList.size() < attributeList.size() || Boolean.TRUE.equals(addOnly)) {\n+                                if (initializerList.size() < attributeList.size() || Boolean.TRUE.equals(addOnly)) {\n                                     if (Boolean.TRUE.equals(addOnly)) {\n                                         m = 0;\n                                     }\n                                     for (int j = m; j < attributeList.size(); j++) {\n                                         String newAttributeListValue = maybeQuoteStringArgument(attributeName, attributeList.get(j), finalA);\n-                                        jLiteralList.add(j, new J.Literal(randomId(), jLiteralList.get(j - 1).getPrefix(), Markers.EMPTY, newAttributeListValue, newAttributeListValue, null, JavaType.Primitive.String));\n+                                        initializerList.add(j, new J.Literal(randomId(), initializerList.get(j - 1).getPrefix(), Markers.EMPTY, newAttributeListValue, newAttributeListValue, null, JavaType.Primitive.String));\n                                     }\n                                 }\n \n-                                return as.withAssignment(((J.NewArray) as.getAssignment()).withInitializer(jLiteralList));\n+                                return as.withAssignment(((J.NewArray) as.getAssignment()).withInitializer(initializerList));\n                             } else {\n                                 Expression exp = as.getAssignment();\n                                 if (exp instanceof J.Literal) {\n@@ -294,7 +295,7 @@ public J.Annotation visitAnnotation(J.Annotation a, ExecutionContext ctx) {\n                             }\n \n                             J.NewArray arrayValue = (J.NewArray) it;\n-                            List<Expression> jLiteralList = requireNonNull(arrayValue.getInitializer());\n+                            List<Expression> initializerList = requireNonNull(arrayValue.getInitializer());\n                             String attributeValueCleanedUp = attributeValue.replaceAll(\"\\\\s+\", \"\").replaceAll(\"[\\\\s+{}\\\"]\", \"\");\n                             List<String> attributeList = Arrays.asList(attributeValueCleanedUp.contains(\",\") ? attributeValueCleanedUp.split(\",\") : new String[]{attributeValueCleanedUp});\n \n@@ -302,7 +303,7 @@ public J.Annotation visitAnnotation(J.Annotation a, ExecutionContext ctx) {\n                                 boolean changed = false;\n                                 for (String attrListValues : attributeList) {\n                                     String newAttributeListValue = maybeQuoteStringArgument(attributeName, attrListValues, finalA);\n-                                    if (Boolean.FALSE.equals(addOnly) && attributeValIsAlreadyPresent(jLiteralList, newAttributeListValue)) {\n+                                    if (Boolean.FALSE.equals(addOnly) && attributeValIsAlreadyPresent(initializerList, newAttributeListValue)) {\n                                         continue;\n                                     }\n                                     changed = true;\n@@ -312,38 +313,39 @@ public J.Annotation visitAnnotation(J.Annotation a, ExecutionContext ctx) {\n                                             .build()\n                                             .apply(getCursor(), finalA.getCoordinates().replaceArguments()))\n                                             .getArguments()).get(0);\n-                                    jLiteralList.add(e);\n+                                    initializerList.add(e);\n                                 }\n                                 if (oldAttributeValue != null) { // remove old value from array\n-                                    jLiteralList = ListUtils.map(jLiteralList, val -> valueMatches(val, oldAttributeValue) ? null : val);\n+                                    initializerList = ListUtils.map(initializerList, val -> valueMatches(val, oldAttributeValue) ? null : val);\n                                 }\n \n-                                return changed ? arrayValue.withInitializer(jLiteralList)\n+                                return changed ? arrayValue.withInitializer(initializerList)\n                                         .withMarkers(it.getMarkers().add(new AlreadyAppended(randomId(), newAttributeValue))) : it;\n                             }\n                             int m = 0;\n-                            for (int i = 0; i < requireNonNull(jLiteralList).size(); i++) {\n+                            for (int i = 0; i < requireNonNull(initializerList).size(); i++) {\n                                 if (i >= attributeList.size()) {\n-                                    jLiteralList.remove(i);\n+                                    initializerList.remove(i);\n                                     i--;\n                                     continue;\n                                 }\n \n                                 String newAttributeListValue = maybeQuoteStringArgument(attributeName, attributeList.get(i), finalA);\n-                                if (jLiteralList.size() == i + 1) {\n+                                if (initializerList.size() == i + 1) {\n                                     m = i + 1;\n                                 }\n \n-                                if (newAttributeListValue.equals(((J.Literal) jLiteralList.get(i)).getValueSource()) || Boolean.TRUE.equals(addOnly)) {\n+                                if (initializerList.get(i) instanceof J.Literal && newAttributeListValue.equals(((J.Literal) initializerList.get(i)).getValueSource()) || Boolean.TRUE.equals(addOnly)) {\n                                     continue;\n                                 }\n                                 if (oldAttributeValue != null && !oldAttributeValue.equals(newAttributeListValue)) {\n                                     continue;\n                                 }\n \n-                                jLiteralList.set(i, ((J.Literal) jLiteralList.get(i)).withValue(newAttributeListValue).withValueSource(newAttributeListValue).withPrefix(jLiteralList.get(i).getPrefix()));\n+                                J.Literal newLiteral = new J.Literal(randomId(), initializerList.get(i).getPrefix(), Markers.EMPTY, newAttributeListValue, newAttributeListValue, null, JavaType.Primitive.String);\n+                                initializerList.set(i, newLiteral);\n                             }\n-                            if (jLiteralList.size() < attributeList.size() || Boolean.TRUE.equals(addOnly)) {\n+                            if (initializerList.size() < attributeList.size() || Boolean.TRUE.equals(addOnly)) {\n                                 if (Boolean.TRUE.equals(addOnly)) {\n                                     m = 0;\n                                 }\n@@ -355,11 +357,11 @@ public J.Annotation visitAnnotation(J.Annotation a, ExecutionContext ctx) {\n                                             .build()\n                                             .apply(getCursor(), finalA.getCoordinates().replaceArguments()))\n                                             .getArguments()).get(0);\n-                                    jLiteralList.add(j, e);\n+                                    initializerList.add(j, e);\n                                 }\n                             }\n \n-                            return arrayValue.withInitializer(jLiteralList);\n+                            return arrayValue.withInitializer(initializerList);\n                         }\n                         return it;\n                     });\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java\nindex 39758e2e846..eaf9d288be0 100755\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java\n@@ -18,6 +18,8 @@\n import org.intellij.lang.annotations.Language;\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n+import org.openrewrite.DocumentExample;\n+import org.openrewrite.Issue;\n import org.openrewrite.test.RewriteTest;\n import org.openrewrite.test.SourceSpec;\n \n@@ -25,6 +27,7 @@\n \n class AddOrUpdateAnnotationAttributeTest implements RewriteTest {\n \n+    @DocumentExample\n     @Test\n     void addValueAttribute() {\n         rewriteRun(\n@@ -1327,4 +1330,90 @@ public class A {\n             );\n         }\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5526\")\n+    @Test\n+    void fieldAccessArgumentDefaultAttribute() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\n+            \"org.example.Foo\", null, \"hello\", null, false, false)),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              public @interface Foo {\n+                  String[] value() default {};\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              public interface Bar {\n+                  String BAR = \"bar\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import org.example.Bar;\n+              import org.example.Foo;\n+              \n+              @Foo({Bar.BAR})\n+              public class A {\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import org.example.Bar;\n+              import org.example.Foo;\n+              \n+              @Foo({\"hello\"})\n+              public class A {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5526\")\n+    @Test\n+    void fieldAccessArgumentNamedAttribute() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\n+            \"org.example.Foo\", \"foo\", \"hello\", null, false, false)),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              public @interface Foo {\n+                  String[] foo() default {};\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              public interface Bar {\n+                  String BAR = \"bar\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import org.example.Bar;\n+              import org.example.Foo;\n+              \n+              @Foo(foo = {Bar.BAR})\n+              public class A {\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import org.example.Bar;\n+              import org.example.Foo;\n+              \n+              @Foo(foo = {\"hello\"})\n+              public class A {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5525",
    "pr_id": 5525,
    "issue_id": 5498,
    "repo": "openrewrite/rewrite",
    "problem_statement": "`RemoveUnusedImports` adds an invalid import of `java.util.Entry`\n## Original problem\n\nHappened in real-life:\nhttps://github.com/openrewrite/rewrite-hibernate/commit/a4c7d867153c95f8cd46d45a0b082e5b2c455bff\nThe change was added by Moderne, which was running `RemoveUnusedImports` among others.\n\n## Steps to reproduce\n\nIn current main (8261b9038496cb446697b6b30fb82c470a247f02)\nthe following test:\n```java\n    @Test\n    void javaUtilMapEntry() {\n        // language=java\n        rewriteRun(\n          java(\n            \"\"\"\n              import java.util.*;\n\n              public class Usages {\n                  HashMap<String, String> hashMap;\n                  Map<String, String> map;\n                  Optional<String> optional;\n                  Map.Entry<String, String> favoriteEntry;\n              }\n            \"\"\",\n            \"\"\"\n              import java.util.HashMap;\n              import java.util.Map;\n              import java.util.Optional;\n\n              public class Usages {\n                  HashMap<String, String> hashMap;\n                  Map<String, String> map;\n                  Optional<String> optional;\n                  Map.Entry<String, String> favoriteEntry;\n              }\n              \"\"\"\n          )\n        );\n    }\n```\n- is not idempotent, takes two cycles.\n- adds the spurious `import java.util.Entry` in one of the cycles.\n",
    "issue_word_count": 124,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/RemoveUnusedImports.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java"
    ],
    "base_commit": "f8171dc4ecacdf767a93a4f9242e6dde56e01a10",
    "head_commit": "6d7a44571d9ccf9e83901e69dc7bbffde8b3a038",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5525",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5525",
    "dockerfile": "",
    "pr_merged_at": "2025-05-30T13:50:18.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/RemoveUnusedImports.java b/rewrite-java/src/main/java/org/openrewrite/java/RemoveUnusedImports.java\nindex 3d8af666459..087134868ed 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/RemoveUnusedImports.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/RemoveUnusedImports.java\n@@ -219,7 +219,12 @@ public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionCon\n                     String target = qualid.getTarget().toString();\n                     Set<JavaType.FullyQualified> types = typesByPackage.getOrDefault(target, new HashSet<>());\n                     Set<JavaType.FullyQualified> typesByFullyQualifiedClassPath = typesByPackage.getOrDefault(toFullyQualifiedName(target), new HashSet<>());\n+                    Set<String> topLevelTypeNames = Stream.concat(types.stream(), typesByFullyQualifiedClassPath.stream())\n+                            .filter(fq -> fq.getOwningClass() == null)\n+                            .map(JavaType.FullyQualified::getFullyQualifiedName)\n+                            .collect(Collectors.toSet());\n                     Set<JavaType.FullyQualified> combinedTypes = Stream.concat(types.stream(), typesByFullyQualifiedClassPath.stream())\n+                            .filter(fq -> fq.getOwningClass() == null || !topLevelTypeNames.contains(fq.getOwningClass().getFullyQualifiedName()))\n                             .collect(Collectors.toSet());\n                     JavaType.FullyQualified qualidType = TypeUtils.asFullyQualified(elem.getQualid().getType());\n                     if (combinedTypes.isEmpty() || sourcePackage.equals(elem.getPackageName()) && qualidType != null && !qualidType.getFullyQualifiedName().contains(\"$\")) {\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java\nindex b9b51ddd195..0269fa74b4a 100755\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java\n@@ -2069,4 +2069,55 @@ A method(A.B ab, A.C ac) {}\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5498\")\n+    void javaUtilMapEntry() {\n+        // language=java\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import java.util.*;\n+\n+              public class Usages {\n+                  HashMap<String, String> hashMap;\n+                  Map<String, String> map;\n+                  Optional<String> optional;\n+                  Map.Entry<String, String> favoriteEntry;\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import java.util.HashMap;\n+              import java.util.Map;\n+              import java.util.Optional;\n+                      \n+              public class Usages {\n+                  HashMap<String, String> hashMap;\n+                  Map<String, String> map;\n+                  Optional<String> optional;\n+                  Map.Entry<String, String> favoriteEntry;\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import java.util.*;\n+\n+              public class WithoutMap {\n+                  Optional<String> optional;\n+                  Map.Entry<String, String> favoriteEntry;\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import java.util.Map;\n+              import java.util.Optional;\n+                      \n+              public class WithoutMap {\n+                  Optional<String> optional;\n+                  Map.Entry<String, String> favoriteEntry;\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5524",
    "pr_id": 5524,
    "issue_id": 5445,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Parsing fails to roundtrip switch block\n## What version of OpenRewrite are you using?\n\n* org.openrewrite:rewrite-core:8.52.1\n\n## What is the smallest, simplest way to reproduce the problem?\n\nThe block used in the switch statement works as expected in javac, but fails to roundtrip correctly in OpenRewrite. This was found in our code base but have since been changed so this is not a blocker for us.\n\n```java\n  @Test\n  //p@Disabled\n  void parsingSwitchBlock() {\n    rewriteRun(\n        // language=java\n        java(\n            \"\"\"\n            public class Foo {\n                  private String foo(final int i) {\n                    return switch (i) {\n                      case 200:\n                        {\n                            yield \"I'm in a block\";\n                        }\n                      default:\n                        yield \"default\";\n                    };\n                  }\n            }\n            \"\"\"));\n  }\n```\n\nFails with:\n\n```\norg.opentest4j.AssertionFailedError: [When parsing and printing the source code back to text without modifications, the printed source didn't match the original source code. This means there is a bug in the parser implementation itself. Please open an issue to report this, providing a sample of the code that generated this error for \"Foo.java\":\n```\n```diff\ndiff --git a/Foo.java b/Foo.java\nindex 70e6c6f..3b2d151 100644\n--- a/Foo.java\n+++ b/Foo.java\n@@ -4,7 +4,7 @@\n           case 200:\n             {\n                 yield \"I'm in a block\";\n-            }\n+            };\n           default:\n             yield \"default\";\n         };\n```\n```\n]\nexpected:\n  \"public class Foo {\n        private String foo(final int i) {\n          return switch (i) {\n            case 200:\n              {\n                  yield \"I'm in a block\";\n              }\n            default:\n              yield \"default\";\n          };\n        }\n  }\"\n but was:\n  \"public class Foo {\n        private String foo(final int i) {\n          return switch (i) {\n            case 200:\n              {\n                  yield \"I'm in a block\";\n              };\n            default:\n              yield \"default\";\n          };\n        }\n  }\"\n\tat org.openrewrite.test.RewriteTest.assertContentEquals(RewriteTest.java:622)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:311)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:130)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:125)\n```",
    "issue_word_count": 279,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java"
    ],
    "base_commit": "0707eee11bef9f766b7ca3d2bdd3cd24070adb92",
    "head_commit": "194aeeb0a309d3d65f4609a2ae805de58ce9a19f",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5524",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5524",
    "dockerfile": "",
    "pr_merged_at": "2025-05-29T17:13:04.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java b/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java\nindex 6534d8eb528..d66be7ca48b 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java\n@@ -448,7 +448,7 @@ protected void printStatementTerminator(Statement s, PrintOutputCapture<P> p) {\n                                 .getValue();\n                 if (aSwitch instanceof SwitchExpression) {\n                     Case aCase = getCursor().getValue();\n-                    if (!(aCase.getBody() instanceof Block)) {\n+                    if (!(aCase.getBody() instanceof Block || s instanceof Block)) {\n                         p.append(';');\n                     }\n                     return;\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\nindex 94973abd5e8..b180423049a 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\n@@ -394,4 +394,46 @@ public InstallationStatus create(Instant updateTime) {\n           ));\n     }\n \n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5445\")\n+    void parseSwitchBlock() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+            public class Foo {\n+              private String foo(final int i) {\n+                return switch (i) {\n+                  case 200:\n+                    {\n+                      yield \"I'm in a block\";\n+                    }\n+                  case 250, 300 -> {\n+                      yield \"another block\";\n+                  }\n+                  case 400:\n+                    yield \"single line yield\";\n+                  default:\n+                    yield \"default\";\n+                };\n+              }\n+              private String mapFoo(final int i) {\n+                String temp;\n+                switch (i) {\n+                  case 100: {\n+                    temp = \"value in block\";\n+                    break;\n+                  }\n+                  case 200, 300-> {\n+                    temp = \"another value in block\";\n+                  }\n+                  default: temp = \"default value\";\n+                }\n+                return temp;\n+              }\n+            }\n+            \"\"\"\n+          )\n+        );\n+    }\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5517",
    "pr_id": 5517,
    "issue_id": 4527,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Generalize property handling in Maven recipes?\nHi,\r\n\r\nWe have been very happy with the property handling in [UpgradeDependencyVersion](https://github.com/openrewrite/rewrite/blob/main/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java): when a version is a property, the property is updated instead of the original version tag.\r\nWhich is awesome as a lot of versions are properties.\r\n\r\nAll good but... in Quarkus, we are using properties in generated projects also for the groupId/artifactId of the Quarkus BOM (and it's something that is important to us as we have several \"Platforms\" with different coordinates and we need to enforce the Platform consistently to the BOM and the Quarkus Maven plugin, thus why we use properties).\r\n\r\nWhile working on a PR to handle changing the Platform entirely (i.e. including the groupId/artifactId, until now we were just updating the version), I stumbled upon the fact that this nice property handling is actually not generalized to the Maven recipes.\r\n\r\nFor instance, there is nothing to handle it in [ChangeDependencyGroupIdAndArtifactId](https://github.com/openrewrite/rewrite/blob/main/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java) or [ChangeManagedDependencyGroupIdAndArtifactId](https://github.com/openrewrite/rewrite/blob/main/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java) (unless I missed something  but the code seems in line with the behavior I'm experiencing).\r\n\r\nI'm not sure exactly why this is handled only in a very specific case. I'm also not completely sure it should be generalized everywhere but not handling it for the groupId/artifactId is actually quite blocking for us. And to be fair, the version is not handled either in `ChangeDependencyGroupIdAndArtifactId` and `ChangeManagedDependencyGroupIdAndArtifactId` so it's not very consistent.\r\n\r\nI was wondering if it's something you would consider? If you had some advice on how to fix it? I could probably dedicate some time to it as it's in our way but I definitely need some guidance. Also, I might not be able to generalize it everywhere in the time I would be able to dedicate to it but I could at least put the infrastructure in place and fix the cases that are in our way, opening the gate for more in the future if someone needs it elsewhere.\r\n\r\nThoughts?",
    "issue_word_count": 379,
    "test_files_count": 2,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java"
    ],
    "base_commit": "ae563f82a085081f502f989d12ce64b5dea01380",
    "head_commit": "d1c22745d3bbb580cb02f87ba6e4dc8418eb3271",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5517",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5517",
    "dockerfile": "",
    "pr_merged_at": "2025-05-28T18:22:03.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\nindex 36a04e5be44..9fc71cdec11 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\n@@ -25,7 +25,6 @@\n import org.openrewrite.semver.Semver;\n import org.openrewrite.semver.VersionComparator;\n import org.openrewrite.xml.AddToTagVisitor;\n-import org.openrewrite.xml.ChangeTagValueVisitor;\n import org.openrewrite.xml.RemoveContentVisitor;\n import org.openrewrite.xml.tree.Xml;\n \n@@ -178,13 +177,13 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 if (isOldDependencyTag || isPluginDependencyTag(oldGroupId, oldArtifactId)) {\n                     String groupId = newGroupId;\n                     if (groupId != null) {\n-                        t = changeChildTagValue2(t, \"groupId\", groupId, ctx);\n+                        t = changeChildTagValue(t, \"groupId\", groupId, ctx);\n                     } else {\n                         groupId = t.getChildValue(\"groupId\").orElseThrow(NoSuchElementException::new);\n                     }\n                     String artifactId = newArtifactId;\n                     if (artifactId != null) {\n-                        t = changeChildTagValue2(t, \"artifactId\", artifactId, ctx);\n+                        t = changeChildTagValue(t, \"artifactId\", artifactId, ctx);\n                     } else {\n                         artifactId = t.getChildValue(\"artifactId\").orElseThrow(NoSuchElementException::new);\n                     }\n@@ -208,7 +207,7 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                                     t = (Xml.Tag) new RemoveContentVisitor<>(versionTag.get(), false, true).visit(t, ctx);\n                                 } else {\n                                     // Otherwise, change the version to the new value.\n-                                    t = changeChildTagValue2(t, \"version\", resolvedNewVersion, ctx);\n+                                    t = changeChildTagValue(t, \"version\", resolvedNewVersion, ctx);\n                                 }\n                             } else if (configuredToOverrideManageVersion || !newDependencyManaged) {\n                                 //If the version is not present, add the version if we are explicitly overriding a managed version or if no managed version exists.\n@@ -239,17 +238,7 @@ private boolean checkIfNewDependencyPresents(@Nullable String groupId, @Nullable\n                         .anyMatch(rd -> (version == null) || version.equals(rd.getVersion()));\n             }\n \n-            @Deprecated // Use changeChildTagValue from MavenVisitor instead: https://github.com/openrewrite/rewrite/pull/5516\n-            private Xml.Tag changeChildTagValue2(Xml.Tag tag, String childTagName, String newValue, ExecutionContext ctx) {\n-                Optional<Xml.Tag> childTag = tag.getChild(childTagName);\n-                if (childTag.isPresent() && !newValue.equals(childTag.get().getValue().orElse(null))) {\n-                    tag = (Xml.Tag) new ChangeTagValueVisitor<>(childTag.get(), newValue).visitNonNull(tag, ctx);\n-                }\n-                return tag;\n-            }\n-\n             private boolean isDependencyManaged(Scope scope, String groupId, String artifactId) {\n-\n                 MavenResolutionResult result = getResolutionResult();\n                 for (ResolvedManagedDependency managedDependency : result.getPom().getDependencyManagement()) {\n                     if (groupId.equals(managedDependency.getGroupId()) && artifactId.equals(managedDependency.getArtifactId())) {\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\nindex 6915c9bcc9e..fbf6a814504 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\n@@ -26,7 +26,6 @@\n import org.openrewrite.maven.tree.ResolvedPom;\n import org.openrewrite.semver.Semver;\n import org.openrewrite.semver.VersionComparator;\n-import org.openrewrite.xml.ChangeTagValueVisitor;\n import org.openrewrite.xml.RemoveContentVisitor;\n import org.openrewrite.xml.tree.Xml;\n \n@@ -41,11 +40,6 @@ public class ChangeManagedDependencyGroupIdAndArtifactId extends Recipe {\n     @EqualsAndHashCode.Exclude\n     MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);\n \n-    // there are several implicitly defined version properties that we should never attempt to update\n-    private static final Set<String> implicitlyDefinedVersionProperties = new HashSet<>(Arrays.asList(\n-            \"${version}\", \"${project.version}\", \"${pom.version}\", \"${project.parent.version}\"\n-    ));\n-\n     @Option(displayName = \"Old groupId\",\n             description = \"The old groupId to replace. The groupId is the first part of a managed dependency coordinate `com.google.guava:guava:VERSION`.\",\n             example = \"org.openrewrite.recipe\")\n@@ -146,24 +140,17 @@ public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {\n \n             @Override\n             public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n-\n                 Xml.Tag t = super.visitTag(tag, ctx);\n                 if (isManagedDependencyTag(oldGroupId, oldArtifactId)) {\n-                    Optional<Xml.Tag> groupIdTag = t.getChild(\"groupId\");\n-                    boolean changed = false;\n-                    if (groupIdTag.isPresent() && !newGroupId.equals(groupIdTag.get().getValue().orElse(null))) {\n-                        doAfterVisit(new ChangeTagValueVisitor<>(groupIdTag.get(), newGroupId));\n-                        changed = true;\n+                    if (t.getChild(\"groupId\").isPresent()) {\n+                        t = changeChildTagValue(t, \"groupId\", newGroupId, ctx);\n                     }\n-                    Optional<Xml.Tag> artifactIdTag = t.getChild(\"artifactId\");\n-                    if (artifactIdTag.isPresent() && !newArtifactId.equals(artifactIdTag.get().getValue().orElse(null))) {\n-                        doAfterVisit(new ChangeTagValueVisitor<>(artifactIdTag.get(), newArtifactId));\n-                        changed = true;\n+                    if (t.getChild(\"artifactId\").isPresent()) {\n+                        t = changeChildTagValue(t, \"artifactId\", newArtifactId, ctx);\n                     }\n                     if (newVersion != null) {\n                         try {\n                             Optional<Xml.Tag> versionTag = t.getChild(\"version\");\n-\n                             if (versionTag.isPresent()) {\n                                 String resolvedArtifactId = newArtifactId;\n                                 if (resolvedArtifactId.contains(\"${\")) {\n@@ -172,14 +159,13 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                                     resolvedArtifactId = ResolvedPom.placeholderHelper.replacePlaceholders(newArtifactId, properties::get);\n                                 }\n                                 String resolvedNewVersion = resolveSemverVersion(ctx, newGroupId, resolvedArtifactId, getResolutionResult().getPom().getValue(versionTag.get().getValue().orElse(null)));\n-                                t = (Xml.Tag) new ChangeTagValueVisitor<>(versionTag.get(), resolvedNewVersion).visitNonNull(t, 0, getCursor().getParentOrThrow());\n+                                t = changeChildTagValue(t, \"version\", resolvedNewVersion, ctx);\n                             }\n-                            changed = true;\n                         } catch (MavenDownloadingException e) {\n                             return e.warn(t);\n                         }\n                     }\n-                    if (changed) {\n+                    if (t != tag) {\n                         maybeUpdateModel();\n                         doAfterVisit(new RemoveRedundantDependencyVersions(null, null, null, null).getVisitor());\n                         if (isNewDependencyPresent) {\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\nindex 63cbf915dd1..24f6e8096d6 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\n@@ -23,11 +23,8 @@\n import org.openrewrite.Recipe;\n import org.openrewrite.TreeVisitor;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n-import org.openrewrite.xml.ChangeTagValueVisitor;\n import org.openrewrite.xml.tree.Xml;\n \n-import java.util.Optional;\n-\n @Value\n @EqualsAndHashCode(callSuper = false)\n public class ChangePluginGroupIdAndArtifactId extends Recipe {\n@@ -90,13 +87,13 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);\n                 if (isPluginTag(oldGroupId, oldArtifactId)) {\n                     if (newGroupId != null) {\n-                        t = changeChildTagValue2(t, \"groupId\", newGroupId, ctx);\n+                        t = changeChildTagValue(t, \"groupId\", newGroupId, ctx);\n                     }\n                     if (newArtifactId != null) {\n-                        t = changeChildTagValue2(t, \"artifactId\", newArtifactId, ctx);\n+                        t = changeChildTagValue(t, \"artifactId\", newArtifactId, ctx);\n                     }\n                     if (newVersion != null) {\n-                        t = changeChildTagValue2(t, \"version\", newVersion, ctx);\n+                        t = changeChildTagValue(t, \"version\", newVersion, ctx);\n                     }\n                     if (t != tag) {\n                         maybeUpdateModel();\n@@ -105,14 +102,6 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 //noinspection ConstantConditions\n                 return t;\n             }\n-\n-            private Xml.Tag changeChildTagValue2(Xml.Tag tag, String childTagName, String newValue, ExecutionContext ctx) {\n-                Optional<Xml.Tag> childTag = tag.getChild(childTagName);\n-                if (childTag.isPresent() && !newValue.equals(childTag.get().getValue().orElse(null))) {\n-                    tag = (Xml.Tag) new ChangeTagValueVisitor<>(childTag.get(), newValue).visitNonNull(tag, ctx);\n-                }\n-                return tag;\n-            }\n         };\n     }\n }\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java b/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\nindex c6cdb44568f..83be12577c2 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\n@@ -52,11 +52,6 @@ public class UpgradeDependencyVersion extends ScanningRecipe<UpgradeDependencyVe\n     @EqualsAndHashCode.Exclude\n     transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);\n \n-    // there are several implicitly defined version properties that we should never attempt to update\n-    private static final Collection<String> implicitlyDefinedVersionProperties = Arrays.asList(\n-            \"${version}\", \"${project.version}\", \"${pom.version}\", \"${project.parent.version}\"\n-    );\n-\n     @Option(displayName = \"Group\",\n             description = \"The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression.\",\n             example = \"com.fasterxml.jackson*\")\n@@ -156,8 +151,7 @@ public Xml.Tag visitTag(final Xml.Tag tag, final ExecutionContext ctx) {\n                                 Optional<Xml.Tag> version = tag.getChild(\"version\");\n                                 if (version.isPresent()) {\n                                     String requestedVersion = d.getRequested().getVersion();\n-                                    if (requestedVersion != null && requestedVersion.startsWith(\"${\") &&\n-                                        !implicitlyDefinedVersionProperties.contains(requestedVersion)) {\n+                                    if (isProperty(requestedVersion)) {\n                                         String propertyName = requestedVersion.substring(2, requestedVersion.length() - 1);\n                                         if (!getResolutionResult().getPom().getRequested().getProperties().containsKey(propertyName)) {\n                                             storeParentPomProperty(getResolutionResult().getParent(), propertyName, newerVersion);\n@@ -180,8 +174,7 @@ public Xml.Tag visitTag(final Xml.Tag tag, final ExecutionContext ctx) {\n              * @param propertyName the name of the property to update, if found in any the parent pom source file\n              * @param newerVersion the resolved newer version that any matching parent pom property should be updated to\n              */\n-            private void storeParentPomProperty(\n-                    @Nullable MavenResolutionResult currentMavenResolutionResult, String propertyName, String newerVersion) {\n+            private void storeParentPomProperty(@Nullable MavenResolutionResult currentMavenResolutionResult, String propertyName, String newerVersion) {\n                 if (currentMavenResolutionResult == null) {\n                     return; // No parent contained the property; might then be in the same source file, or an import BOM\n                 }\n@@ -270,10 +263,8 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 }\n \n                 private void retainVersions() {\n-                    for (Recipe retainVersionRecipe : RetainVersions.plan(this, retainVersions == null ?\n-                            emptyList() : retainVersions)) {\n-                        doAfterVisit(retainVersionRecipe.getVisitor());\n-                    }\n+                    RetainVersions.plan(this, retainVersions == null ? emptyList() : retainVersions)\n+                            .forEach(it -> doAfterVisit(it.getVisitor()));\n                 }\n             }\n \n@@ -284,26 +275,13 @@ private Xml.Tag upgradeDependency(ExecutionContext ctx, Xml.Tag t) throws MavenD\n                     // as a source file, attempt to find a new version.\n                     String newerVersion = findNewerVersion(d.getGroupId(), d.getArtifactId(), d.getVersion(), ctx);\n                     if (newerVersion != null) {\n-                        Optional<Xml.Tag> version = t.getChild(\"version\");\n-                        if (version.isPresent()) {\n-                            String requestedVersion = d.getRequested().getVersion();\n-                            if (requestedVersion != null && requestedVersion.startsWith(\"${\") && !implicitlyDefinedVersionProperties.contains(requestedVersion)) {\n-                                String propertyName = requestedVersion.substring(2, requestedVersion.length() - 1);\n-                                if (getResolutionResult().getPom().getRequested().getProperties().containsKey(propertyName)) {\n-                                    doAfterVisit(new ChangePropertyValue(propertyName, newerVersion, overrideManagedVersion, false).getVisitor());\n-                                }\n-                            } else {\n-                                t = (Xml.Tag) new ChangeTagValueVisitor<>(version.get(), newerVersion).visitNonNull(t, 0, getCursor().getParentOrThrow());\n-                            }\n+                        if (t.getChild(\"version\").isPresent()) {\n+                            t = changeChildTagValue(t, \"version\", newerVersion, overrideManagedVersion, ctx);\n                         } else if (Boolean.TRUE.equals(overrideManagedVersion)) {\n                             ResolvedManagedDependency dm = findManagedDependency(t);\n                             // if a managed dependency is expressed as a property, change the property value\n                             // do this only when a requested bom is absent, otherwise changing property has no effect\n-                            if (dm != null &&\n-                                dm.getRequested().getVersion() != null &&\n-                                dm.getRequested().getVersion().startsWith(\"${\") &&\n-                                !implicitlyDefinedVersionProperties.contains(dm.getRequested().getVersion()) &&\n-                                dm.getRequestedBom() == null) {\n+                            if (dm != null && isProperty(dm.getRequested().getVersion()) && dm.getRequestedBom() == null) {\n                                 doAfterVisit(new ChangePropertyValue(dm.getRequested().getVersion().substring(2,\n                                         dm.getRequested().getVersion().length() - 1),\n                                         newerVersion, overrideManagedVersion, false).getVisitor());\n@@ -359,20 +337,14 @@ private Xml.Tag upgradePluginDependency(ExecutionContext ctx, Xml.Tag t) throws\n                 if (groupId != null && artifactId != null && version != null) {\n                     String newerVersion = findNewerVersion(groupId, artifactId, resolveVersion(version), ctx);\n                     if (newerVersion != null) {\n-                        if (version.startsWith(\"${\") && !implicitlyDefinedVersionProperties.contains(version)) {\n-                            doAfterVisit(new ChangePropertyValue(version.substring(2, version.length() - 1), newerVersion, overrideManagedVersion, false).getVisitor());\n-                        } else {\n-                            Optional<Xml.Tag> versionTag = t.getChild(\"version\");\n-                            assert versionTag.isPresent();\n-                            t = (Xml.Tag) new ChangeTagValueVisitor<>(versionTag.get(), newerVersion).visitNonNull(t, 0, getCursor().getParentOrThrow());\n-                        }\n+                        t = changeChildTagValue(t, \"version\", newerVersion, overrideManagedVersion, ctx);\n                     }\n                 }\n                 return t;\n             }\n \n             private String resolveVersion(String version) {\n-                if (version.startsWith(\"${\") && !implicitlyDefinedVersionProperties.contains(version)) {\n+                if (isProperty(version)) {\n                     Map<String, String> properties = getResolutionResult().getPom().getProperties();\n                     String property = version.substring(2, version.length() - 1);\n                     return properties.getOrDefault(property, version);\n@@ -384,7 +356,7 @@ private String resolveVersion(String version) {\n                 String newerVersion = findNewerVersion(groupId, artifactId, version2, ctx);\n                 if (newerVersion == null) {\n                     return null;\n-                } else if (requestedVersion != null && requestedVersion.startsWith(\"${\")) {\n+                } else if (isProperty(requestedVersion)) {\n                     //noinspection unchecked\n                     return (TreeVisitor<Xml, ExecutionContext>) new ChangePropertyValue(requestedVersion.substring(2, requestedVersion.length() - 1), newerVersion, overrideManagedVersion, false)\n                             .getVisitor();\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\nindex a0fb4005f9c..95d6395d49f 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\n@@ -1624,4 +1624,56 @@ void changePluginDependencyGroupIdAndArtifactId() {\n           )\n         );\n     }\n+\n+    @Test\n+    void changeDependencyGroupIdAndArtifactIdWithVersionProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependencyGroupIdAndArtifactId(\n+            \"javax.activation\",\n+            \"javax.activation-api\",\n+            \"jakarta.activation\",\n+            \"jakarta.activation-api\",\n+            \"1.2.x\",\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <properties>\n+                      <activation.api>1.2.0</activation.api>\n+                  </properties>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>javax.activation</groupId>\n+                          <artifactId>javax.activation-api</artifactId>\n+                          <version>${activation.api}</version>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <properties>\n+                      <activation.api>1.2.2</activation.api>\n+                  </properties>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                          <version>${activation.api}</version>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java\nindex 442e575e54c..8f0f7af3d67 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java\n@@ -329,14 +329,14 @@ void changeManagedDependencyWithPropertyVersion() {\n                   <artifactId>my-app</artifactId>\n                   <version>1</version>\n                   <properties>\n-                      <version.property>1.2.0</version.property>\n+                      <version.property>1.2.2</version.property>\n                   </properties>\n                   <dependencyManagement>\n                       <dependencies>\n                           <dependency>\n                               <groupId>jakarta.activation</groupId>\n                               <artifactId>jakarta.activation-api</artifactId>\n-                              <version>1.2.2</version>\n+                              <version>${version.property}</version>\n                           </dependency>\n                       </dependencies>\n                   </dependencyManagement>\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5516",
    "pr_id": 5516,
    "issue_id": 4527,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Generalize property handling in Maven recipes?\nHi,\r\n\r\nWe have been very happy with the property handling in [UpgradeDependencyVersion](https://github.com/openrewrite/rewrite/blob/main/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java): when a version is a property, the property is updated instead of the original version tag.\r\nWhich is awesome as a lot of versions are properties.\r\n\r\nAll good but... in Quarkus, we are using properties in generated projects also for the groupId/artifactId of the Quarkus BOM (and it's something that is important to us as we have several \"Platforms\" with different coordinates and we need to enforce the Platform consistently to the BOM and the Quarkus Maven plugin, thus why we use properties).\r\n\r\nWhile working on a PR to handle changing the Platform entirely (i.e. including the groupId/artifactId, until now we were just updating the version), I stumbled upon the fact that this nice property handling is actually not generalized to the Maven recipes.\r\n\r\nFor instance, there is nothing to handle it in [ChangeDependencyGroupIdAndArtifactId](https://github.com/openrewrite/rewrite/blob/main/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java) or [ChangeManagedDependencyGroupIdAndArtifactId](https://github.com/openrewrite/rewrite/blob/main/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java) (unless I missed something  but the code seems in line with the behavior I'm experiencing).\r\n\r\nI'm not sure exactly why this is handled only in a very specific case. I'm also not completely sure it should be generalized everywhere but not handling it for the groupId/artifactId is actually quite blocking for us. And to be fair, the version is not handled either in `ChangeDependencyGroupIdAndArtifactId` and `ChangeManagedDependencyGroupIdAndArtifactId` so it's not very consistent.\r\n\r\nI was wondering if it's something you would consider? If you had some advice on how to fix it? I could probably dedicate some time to it as it's in our way but I definitely need some guidance. Also, I might not be able to generalize it everywhere in the time I would be able to dedicate to it but I could at least put the infrastructure in place and fix the cases that are in our way, opening the gate for more in the future if someone needs it elsewhere.\r\n\r\nThoughts?",
    "issue_word_count": 379,
    "test_files_count": 2,
    "non_test_files_count": 5,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java"
    ],
    "base_commit": "4420254f44d0b8fc148b2a6249d51942449af193",
    "head_commit": "58de9c084117dfad2a561ac6fa906feac1488c14",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5516",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5516",
    "dockerfile": "",
    "pr_merged_at": "2025-05-28T13:02:45.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\nindex 9fc71cdec11..36a04e5be44 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\n@@ -25,6 +25,7 @@\n import org.openrewrite.semver.Semver;\n import org.openrewrite.semver.VersionComparator;\n import org.openrewrite.xml.AddToTagVisitor;\n+import org.openrewrite.xml.ChangeTagValueVisitor;\n import org.openrewrite.xml.RemoveContentVisitor;\n import org.openrewrite.xml.tree.Xml;\n \n@@ -177,13 +178,13 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 if (isOldDependencyTag || isPluginDependencyTag(oldGroupId, oldArtifactId)) {\n                     String groupId = newGroupId;\n                     if (groupId != null) {\n-                        t = changeChildTagValue(t, \"groupId\", groupId, ctx);\n+                        t = changeChildTagValue2(t, \"groupId\", groupId, ctx);\n                     } else {\n                         groupId = t.getChildValue(\"groupId\").orElseThrow(NoSuchElementException::new);\n                     }\n                     String artifactId = newArtifactId;\n                     if (artifactId != null) {\n-                        t = changeChildTagValue(t, \"artifactId\", artifactId, ctx);\n+                        t = changeChildTagValue2(t, \"artifactId\", artifactId, ctx);\n                     } else {\n                         artifactId = t.getChildValue(\"artifactId\").orElseThrow(NoSuchElementException::new);\n                     }\n@@ -207,7 +208,7 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                                     t = (Xml.Tag) new RemoveContentVisitor<>(versionTag.get(), false, true).visit(t, ctx);\n                                 } else {\n                                     // Otherwise, change the version to the new value.\n-                                    t = changeChildTagValue(t, \"version\", resolvedNewVersion, ctx);\n+                                    t = changeChildTagValue2(t, \"version\", resolvedNewVersion, ctx);\n                                 }\n                             } else if (configuredToOverrideManageVersion || !newDependencyManaged) {\n                                 //If the version is not present, add the version if we are explicitly overriding a managed version or if no managed version exists.\n@@ -238,7 +239,17 @@ private boolean checkIfNewDependencyPresents(@Nullable String groupId, @Nullable\n                         .anyMatch(rd -> (version == null) || version.equals(rd.getVersion()));\n             }\n \n+            @Deprecated // Use changeChildTagValue from MavenVisitor instead: https://github.com/openrewrite/rewrite/pull/5516\n+            private Xml.Tag changeChildTagValue2(Xml.Tag tag, String childTagName, String newValue, ExecutionContext ctx) {\n+                Optional<Xml.Tag> childTag = tag.getChild(childTagName);\n+                if (childTag.isPresent() && !newValue.equals(childTag.get().getValue().orElse(null))) {\n+                    tag = (Xml.Tag) new ChangeTagValueVisitor<>(childTag.get(), newValue).visitNonNull(tag, ctx);\n+                }\n+                return tag;\n+            }\n+\n             private boolean isDependencyManaged(Scope scope, String groupId, String artifactId) {\n+\n                 MavenResolutionResult result = getResolutionResult();\n                 for (ResolvedManagedDependency managedDependency : result.getPom().getDependencyManagement()) {\n                     if (groupId.equals(managedDependency.getGroupId()) && artifactId.equals(managedDependency.getArtifactId())) {\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\nindex fbf6a814504..6915c9bcc9e 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\n@@ -26,6 +26,7 @@\n import org.openrewrite.maven.tree.ResolvedPom;\n import org.openrewrite.semver.Semver;\n import org.openrewrite.semver.VersionComparator;\n+import org.openrewrite.xml.ChangeTagValueVisitor;\n import org.openrewrite.xml.RemoveContentVisitor;\n import org.openrewrite.xml.tree.Xml;\n \n@@ -40,6 +41,11 @@ public class ChangeManagedDependencyGroupIdAndArtifactId extends Recipe {\n     @EqualsAndHashCode.Exclude\n     MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);\n \n+    // there are several implicitly defined version properties that we should never attempt to update\n+    private static final Set<String> implicitlyDefinedVersionProperties = new HashSet<>(Arrays.asList(\n+            \"${version}\", \"${project.version}\", \"${pom.version}\", \"${project.parent.version}\"\n+    ));\n+\n     @Option(displayName = \"Old groupId\",\n             description = \"The old groupId to replace. The groupId is the first part of a managed dependency coordinate `com.google.guava:guava:VERSION`.\",\n             example = \"org.openrewrite.recipe\")\n@@ -140,17 +146,24 @@ public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {\n \n             @Override\n             public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n+\n                 Xml.Tag t = super.visitTag(tag, ctx);\n                 if (isManagedDependencyTag(oldGroupId, oldArtifactId)) {\n-                    if (t.getChild(\"groupId\").isPresent()) {\n-                        t = changeChildTagValue(t, \"groupId\", newGroupId, ctx);\n+                    Optional<Xml.Tag> groupIdTag = t.getChild(\"groupId\");\n+                    boolean changed = false;\n+                    if (groupIdTag.isPresent() && !newGroupId.equals(groupIdTag.get().getValue().orElse(null))) {\n+                        doAfterVisit(new ChangeTagValueVisitor<>(groupIdTag.get(), newGroupId));\n+                        changed = true;\n                     }\n-                    if (t.getChild(\"artifactId\").isPresent()) {\n-                        t = changeChildTagValue(t, \"artifactId\", newArtifactId, ctx);\n+                    Optional<Xml.Tag> artifactIdTag = t.getChild(\"artifactId\");\n+                    if (artifactIdTag.isPresent() && !newArtifactId.equals(artifactIdTag.get().getValue().orElse(null))) {\n+                        doAfterVisit(new ChangeTagValueVisitor<>(artifactIdTag.get(), newArtifactId));\n+                        changed = true;\n                     }\n                     if (newVersion != null) {\n                         try {\n                             Optional<Xml.Tag> versionTag = t.getChild(\"version\");\n+\n                             if (versionTag.isPresent()) {\n                                 String resolvedArtifactId = newArtifactId;\n                                 if (resolvedArtifactId.contains(\"${\")) {\n@@ -159,13 +172,14 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                                     resolvedArtifactId = ResolvedPom.placeholderHelper.replacePlaceholders(newArtifactId, properties::get);\n                                 }\n                                 String resolvedNewVersion = resolveSemverVersion(ctx, newGroupId, resolvedArtifactId, getResolutionResult().getPom().getValue(versionTag.get().getValue().orElse(null)));\n-                                t = changeChildTagValue(t, \"version\", resolvedNewVersion, ctx);\n+                                t = (Xml.Tag) new ChangeTagValueVisitor<>(versionTag.get(), resolvedNewVersion).visitNonNull(t, 0, getCursor().getParentOrThrow());\n                             }\n+                            changed = true;\n                         } catch (MavenDownloadingException e) {\n                             return e.warn(t);\n                         }\n                     }\n-                    if (t != tag) {\n+                    if (changed) {\n                         maybeUpdateModel();\n                         doAfterVisit(new RemoveRedundantDependencyVersions(null, null, null, null).getVisitor());\n                         if (isNewDependencyPresent) {\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\nindex 24f6e8096d6..63cbf915dd1 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\n@@ -23,8 +23,11 @@\n import org.openrewrite.Recipe;\n import org.openrewrite.TreeVisitor;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n+import org.openrewrite.xml.ChangeTagValueVisitor;\n import org.openrewrite.xml.tree.Xml;\n \n+import java.util.Optional;\n+\n @Value\n @EqualsAndHashCode(callSuper = false)\n public class ChangePluginGroupIdAndArtifactId extends Recipe {\n@@ -87,13 +90,13 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);\n                 if (isPluginTag(oldGroupId, oldArtifactId)) {\n                     if (newGroupId != null) {\n-                        t = changeChildTagValue(t, \"groupId\", newGroupId, ctx);\n+                        t = changeChildTagValue2(t, \"groupId\", newGroupId, ctx);\n                     }\n                     if (newArtifactId != null) {\n-                        t = changeChildTagValue(t, \"artifactId\", newArtifactId, ctx);\n+                        t = changeChildTagValue2(t, \"artifactId\", newArtifactId, ctx);\n                     }\n                     if (newVersion != null) {\n-                        t = changeChildTagValue(t, \"version\", newVersion, ctx);\n+                        t = changeChildTagValue2(t, \"version\", newVersion, ctx);\n                     }\n                     if (t != tag) {\n                         maybeUpdateModel();\n@@ -102,6 +105,14 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 //noinspection ConstantConditions\n                 return t;\n             }\n+\n+            private Xml.Tag changeChildTagValue2(Xml.Tag tag, String childTagName, String newValue, ExecutionContext ctx) {\n+                Optional<Xml.Tag> childTag = tag.getChild(childTagName);\n+                if (childTag.isPresent() && !newValue.equals(childTag.get().getValue().orElse(null))) {\n+                    tag = (Xml.Tag) new ChangeTagValueVisitor<>(childTag.get(), newValue).visitNonNull(tag, ctx);\n+                }\n+                return tag;\n+            }\n         };\n     }\n }\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\nindex ce43da0e338..166831c4b94 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n@@ -50,7 +50,13 @@ public class MavenVisitor<P> extends XmlVisitor<P> {\n \n     // there are several implicitly defined version properties that we should never attempt to update\n     private static final Set<String> IMPLICITLY_DEFINED_VERSION_PROPERTIES = new HashSet<>(Arrays.asList(\n-            \"${version}\", \"${project.version}\", \"${pom.version}\", \"${project.parent.version}\"\n+            \"${version}\",\n+            \"${project.version}\",\n+            \"${pom.version}\",\n+            \"${project.parent.version}\",\n+            \"${revision}\",\n+            \"${sha1}\",\n+            \"${changelist}\"\n     ));\n \n     private transient Xml.@Nullable Document document;\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java b/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\nindex 83be12577c2..c6cdb44568f 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\n@@ -52,6 +52,11 @@ public class UpgradeDependencyVersion extends ScanningRecipe<UpgradeDependencyVe\n     @EqualsAndHashCode.Exclude\n     transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);\n \n+    // there are several implicitly defined version properties that we should never attempt to update\n+    private static final Collection<String> implicitlyDefinedVersionProperties = Arrays.asList(\n+            \"${version}\", \"${project.version}\", \"${pom.version}\", \"${project.parent.version}\"\n+    );\n+\n     @Option(displayName = \"Group\",\n             description = \"The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression.\",\n             example = \"com.fasterxml.jackson*\")\n@@ -151,7 +156,8 @@ public Xml.Tag visitTag(final Xml.Tag tag, final ExecutionContext ctx) {\n                                 Optional<Xml.Tag> version = tag.getChild(\"version\");\n                                 if (version.isPresent()) {\n                                     String requestedVersion = d.getRequested().getVersion();\n-                                    if (isProperty(requestedVersion)) {\n+                                    if (requestedVersion != null && requestedVersion.startsWith(\"${\") &&\n+                                        !implicitlyDefinedVersionProperties.contains(requestedVersion)) {\n                                         String propertyName = requestedVersion.substring(2, requestedVersion.length() - 1);\n                                         if (!getResolutionResult().getPom().getRequested().getProperties().containsKey(propertyName)) {\n                                             storeParentPomProperty(getResolutionResult().getParent(), propertyName, newerVersion);\n@@ -174,7 +180,8 @@ public Xml.Tag visitTag(final Xml.Tag tag, final ExecutionContext ctx) {\n              * @param propertyName the name of the property to update, if found in any the parent pom source file\n              * @param newerVersion the resolved newer version that any matching parent pom property should be updated to\n              */\n-            private void storeParentPomProperty(@Nullable MavenResolutionResult currentMavenResolutionResult, String propertyName, String newerVersion) {\n+            private void storeParentPomProperty(\n+                    @Nullable MavenResolutionResult currentMavenResolutionResult, String propertyName, String newerVersion) {\n                 if (currentMavenResolutionResult == null) {\n                     return; // No parent contained the property; might then be in the same source file, or an import BOM\n                 }\n@@ -263,8 +270,10 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 }\n \n                 private void retainVersions() {\n-                    RetainVersions.plan(this, retainVersions == null ? emptyList() : retainVersions)\n-                            .forEach(it -> doAfterVisit(it.getVisitor()));\n+                    for (Recipe retainVersionRecipe : RetainVersions.plan(this, retainVersions == null ?\n+                            emptyList() : retainVersions)) {\n+                        doAfterVisit(retainVersionRecipe.getVisitor());\n+                    }\n                 }\n             }\n \n@@ -275,13 +284,26 @@ private Xml.Tag upgradeDependency(ExecutionContext ctx, Xml.Tag t) throws MavenD\n                     // as a source file, attempt to find a new version.\n                     String newerVersion = findNewerVersion(d.getGroupId(), d.getArtifactId(), d.getVersion(), ctx);\n                     if (newerVersion != null) {\n-                        if (t.getChild(\"version\").isPresent()) {\n-                            t = changeChildTagValue(t, \"version\", newerVersion, overrideManagedVersion, ctx);\n+                        Optional<Xml.Tag> version = t.getChild(\"version\");\n+                        if (version.isPresent()) {\n+                            String requestedVersion = d.getRequested().getVersion();\n+                            if (requestedVersion != null && requestedVersion.startsWith(\"${\") && !implicitlyDefinedVersionProperties.contains(requestedVersion)) {\n+                                String propertyName = requestedVersion.substring(2, requestedVersion.length() - 1);\n+                                if (getResolutionResult().getPom().getRequested().getProperties().containsKey(propertyName)) {\n+                                    doAfterVisit(new ChangePropertyValue(propertyName, newerVersion, overrideManagedVersion, false).getVisitor());\n+                                }\n+                            } else {\n+                                t = (Xml.Tag) new ChangeTagValueVisitor<>(version.get(), newerVersion).visitNonNull(t, 0, getCursor().getParentOrThrow());\n+                            }\n                         } else if (Boolean.TRUE.equals(overrideManagedVersion)) {\n                             ResolvedManagedDependency dm = findManagedDependency(t);\n                             // if a managed dependency is expressed as a property, change the property value\n                             // do this only when a requested bom is absent, otherwise changing property has no effect\n-                            if (dm != null && isProperty(dm.getRequested().getVersion()) && dm.getRequestedBom() == null) {\n+                            if (dm != null &&\n+                                dm.getRequested().getVersion() != null &&\n+                                dm.getRequested().getVersion().startsWith(\"${\") &&\n+                                !implicitlyDefinedVersionProperties.contains(dm.getRequested().getVersion()) &&\n+                                dm.getRequestedBom() == null) {\n                                 doAfterVisit(new ChangePropertyValue(dm.getRequested().getVersion().substring(2,\n                                         dm.getRequested().getVersion().length() - 1),\n                                         newerVersion, overrideManagedVersion, false).getVisitor());\n@@ -337,14 +359,20 @@ private Xml.Tag upgradePluginDependency(ExecutionContext ctx, Xml.Tag t) throws\n                 if (groupId != null && artifactId != null && version != null) {\n                     String newerVersion = findNewerVersion(groupId, artifactId, resolveVersion(version), ctx);\n                     if (newerVersion != null) {\n-                        t = changeChildTagValue(t, \"version\", newerVersion, overrideManagedVersion, ctx);\n+                        if (version.startsWith(\"${\") && !implicitlyDefinedVersionProperties.contains(version)) {\n+                            doAfterVisit(new ChangePropertyValue(version.substring(2, version.length() - 1), newerVersion, overrideManagedVersion, false).getVisitor());\n+                        } else {\n+                            Optional<Xml.Tag> versionTag = t.getChild(\"version\");\n+                            assert versionTag.isPresent();\n+                            t = (Xml.Tag) new ChangeTagValueVisitor<>(versionTag.get(), newerVersion).visitNonNull(t, 0, getCursor().getParentOrThrow());\n+                        }\n                     }\n                 }\n                 return t;\n             }\n \n             private String resolveVersion(String version) {\n-                if (isProperty(version)) {\n+                if (version.startsWith(\"${\") && !implicitlyDefinedVersionProperties.contains(version)) {\n                     Map<String, String> properties = getResolutionResult().getPom().getProperties();\n                     String property = version.substring(2, version.length() - 1);\n                     return properties.getOrDefault(property, version);\n@@ -356,7 +384,7 @@ private String resolveVersion(String version) {\n                 String newerVersion = findNewerVersion(groupId, artifactId, version2, ctx);\n                 if (newerVersion == null) {\n                     return null;\n-                } else if (isProperty(requestedVersion)) {\n+                } else if (requestedVersion != null && requestedVersion.startsWith(\"${\")) {\n                     //noinspection unchecked\n                     return (TreeVisitor<Xml, ExecutionContext>) new ChangePropertyValue(requestedVersion.substring(2, requestedVersion.length() - 1), newerVersion, overrideManagedVersion, false)\n                             .getVisitor();\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\nindex 95d6395d49f..a0fb4005f9c 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\n@@ -1624,56 +1624,4 @@ void changePluginDependencyGroupIdAndArtifactId() {\n           )\n         );\n     }\n-\n-    @Test\n-    void changeDependencyGroupIdAndArtifactIdWithVersionProperty() {\n-        rewriteRun(\n-          spec -> spec.recipe(new ChangeDependencyGroupIdAndArtifactId(\n-            \"javax.activation\",\n-            \"javax.activation-api\",\n-            \"jakarta.activation\",\n-            \"jakarta.activation-api\",\n-            \"1.2.x\",\n-            null\n-          )),\n-          pomXml(\n-            \"\"\"\n-              <project>\n-                  <modelVersion>4.0.0</modelVersion>\n-                  <groupId>com.mycompany.app</groupId>\n-                  <artifactId>my-app</artifactId>\n-                  <version>1</version>\n-                  <properties>\n-                      <activation.api>1.2.0</activation.api>\n-                  </properties>\n-                  <dependencies>\n-                      <dependency>\n-                          <groupId>javax.activation</groupId>\n-                          <artifactId>javax.activation-api</artifactId>\n-                          <version>${activation.api}</version>\n-                      </dependency>\n-                  </dependencies>\n-              </project>\n-              \"\"\",\n-            \"\"\"\n-              <project>\n-                  <modelVersion>4.0.0</modelVersion>\n-                  <groupId>com.mycompany.app</groupId>\n-                  <artifactId>my-app</artifactId>\n-                  <version>1</version>\n-                  <properties>\n-                      <activation.api>1.2.2</activation.api>\n-                  </properties>\n-                  <dependencies>\n-                      <dependency>\n-                          <groupId>jakarta.activation</groupId>\n-                          <artifactId>jakarta.activation-api</artifactId>\n-                          <version>${activation.api}</version>\n-                      </dependency>\n-                  </dependencies>\n-              </project>\n-              \"\"\"\n-          )\n-        );\n-    }\n }\n\ndiff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java\nindex 8f0f7af3d67..442e575e54c 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java\n@@ -329,14 +329,14 @@ void changeManagedDependencyWithPropertyVersion() {\n                   <artifactId>my-app</artifactId>\n                   <version>1</version>\n                   <properties>\n-                      <version.property>1.2.2</version.property>\n+                      <version.property>1.2.0</version.property>\n                   </properties>\n                   <dependencyManagement>\n                       <dependencies>\n                           <dependency>\n                               <groupId>jakarta.activation</groupId>\n                               <artifactId>jakarta.activation-api</artifactId>\n-                              <version>${version.property}</version>\n+                              <version>1.2.2</version>\n                           </dependency>\n                       </dependencies>\n                   </dependencyManagement>\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5515",
    "pr_id": 5515,
    "issue_id": 5361,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Plugin management support for Gradle Kotlin scripts (.kts)\n## What problem are you trying to solve?\n\nDependency management has been enhanced to support the Gradle Kotlin DSL via https://github.com/openrewrite/rewrite/pull/5158. Recipes for managing plugins only works for the Gradle Groovy DSL, but should be supported for the Kotlin DSL as well.\n\n## Describe the solution you'd like\n\nSupport the Kotlin DSL for the recipes in the package `org.openrewrite.gradle.plugins`.\n\n## Have you considered any alternatives or workarounds?\n\nNo workarounds are available right now except for writing a custom recipe.\n\n## Additional context\n\nSome upgrade recipes e.g. for Spring Boot may need to touch the applied plugin(s) in a Gradle build.",
    "issue_word_count": 116,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseMapNotation.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseMapNotationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseMapNotationTest.java"
    ],
    "base_commit": "69ee1d67e0a8046806fbfb10ef5821eb439c3679",
    "head_commit": "4bfd83cddbc7d783ecf681667dee7000afd23b7f",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5515",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5515",
    "dockerfile": "",
    "pr_merged_at": "2025-06-05T19:51:25.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseMapNotation.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseMapNotation.java\nindex ad9958e8038..2590f51edfd 100755\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseMapNotation.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseMapNotation.java\n@@ -15,10 +15,7 @@\n  */\n package org.openrewrite.gradle;\n \n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.Preconditions;\n-import org.openrewrite.Recipe;\n-import org.openrewrite.TreeVisitor;\n+import org.openrewrite.*;\n import org.openrewrite.gradle.internal.Dependency;\n import org.openrewrite.gradle.internal.DependencyStringNotationConverter;\n import org.openrewrite.gradle.trait.GradleDependency;\n@@ -27,11 +24,15 @@\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.java.tree.*;\n+import org.openrewrite.kotlin.KotlinVisitor;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.marker.Markers;\n \n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n \n import static java.util.Collections.emptyList;\n import static java.util.Collections.singletonList;\n@@ -46,143 +47,185 @@ public String getDisplayName() {\n     @Override\n     public String getDescription() {\n         return \"In Gradle, dependencies can be expressed as a `String` like `\\\"groupId:artifactId:version\\\"`, \" +\n-                \"or equivalently as a `Map` like `group: 'groupId', name: 'artifactId', version: 'version'`. \" +\n+                \"or equivalently as a `Map` like `group: 'groupId', name: 'artifactId', version: 'version'` (groovy)\" +\n+                \"or `group = \\\"groupId\\\", name = \\\"artifactId\\\", version = \\\"version\\\"` (kotlin). \" +\n                 \"This recipe replaces dependencies represented as `Strings` with an equivalent dependency represented as a `Map`.\";\n     }\n \n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(new IsBuildGradle<>(), new GroovyVisitor<ExecutionContext>() {\n-            @Override\n-            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n-                J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);\n-\n-                GradleDependency.Matcher gradleDependencyMatcher = Traits.gradleDependency();\n-\n-                if (!gradleDependencyMatcher.get(getCursor()).isPresent()) {\n-                    return m;\n-                }\n-                m = forBasicString(m);\n-                m = forGString(m);\n+        return Preconditions.check(new IsBuildGradle<>(), Preconditions.or(new GroovyScriptVisitor(), new KotlinScriptVisitor()));\n+    }\n+\n+    private static class KotlinScriptVisitor extends KotlinVisitor<ExecutionContext> {\n+        @Override\n+        public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n+            J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);\n+\n+            GradleDependency.Matcher gradleDependencyMatcher = Traits.gradleDependency();\n+\n+            if (!gradleDependencyMatcher.get(getCursor()).isPresent()) {\n                 return m;\n             }\n+            m = forBasicString(m, this::mapEntry, J.Assignment::withPrefix, Function.identity());\n+            m = forStringTemplate(m, K.StringTemplate.class, K.StringTemplate::getStrings, K.StringTemplate.Expression.class, K.StringTemplate.Expression::getTree, this::mapEntry, this::mapEntry, J.Assignment::withPrefix, Function.identity());\n+            return m;\n+        }\n+\n+        private J.Assignment mapEntry(String key, String value) {\n+            return mapEntry(key,\n+                    new J.Literal(randomId(), Space.build(\" \", emptyList()), Markers.EMPTY, value, \"\\\"\" + value + \"\\\"\", null, JavaType.Primitive.String));\n+        }\n+\n+        private J.Assignment mapEntry(String key, Expression e) {\n+            return new J.Assignment(\n+                    randomId(),\n+                    Space.format(\" \"),\n+                    Markers.EMPTY,\n+                    new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), key, null, null),\n+                    JLeftPadded.build(e).withBefore(Space.SINGLE_SPACE),\n+                    null\n+            );\n+        }\n+    }\n \n-            private J.MethodInvocation forBasicString(J.MethodInvocation m) {\n-                Expression e = m.getArguments().get(0);\n-                if (!(e instanceof J.Literal)) {\n-                    return m;\n-                }\n-                J.Literal arg = (J.Literal) e;\n-                if (arg.getType() != JavaType.Primitive.String) {\n-                    return m;\n-                }\n-                String dependencyString = (String) arg.getValue();\n-                if (dependencyString == null) {\n-                    return m;\n-                }\n-                Dependency dependency = DependencyStringNotationConverter.parse(dependencyString);\n-                if (dependency == null) {\n-                    return m;\n-                }\n-                List<Expression> arguments = new ArrayList<>();\n-                arguments.add(mapEntry(\"group\", dependency.getGroupId())\n-                        .withMarkers(arg.getMarkers())\n-                        .withPrefix(arg.getPrefix()));\n-                arguments.add(mapEntry(\"name\", dependency.getArtifactId())\n-                        .withMarkers(arg.getMarkers()));\n-                if (dependency.getVersion() != null) {\n-                    arguments.add(mapEntry(\"version\", dependency.getVersion())\n-                            .withMarkers(arg.getMarkers()));\n-                }\n-                if (dependency.getClassifier() != null) {\n-                    arguments.add(mapEntry(\"classifier\", dependency.getClassifier())\n-                            .withMarkers(arg.getMarkers()));\n-                }\n-                if (dependency.getExt() != null) {\n-                    arguments.add(mapEntry(\"ext\", dependency.getExt())\n-                            .withMarkers(arg.getMarkers()));\n-                }\n-\n-                Expression lastArg = m.getArguments().get(m.getArguments().size() - 1);\n-                if (lastArg instanceof J.Lambda) {\n-                    m = m.withArguments(ListUtils.concat(arguments, lastArg));\n-                } else {\n-                    m = m.withArguments(arguments);\n-                }\n-\n-                return updateTypeForMapArgument(m);\n-            }\n+    private static class GroovyScriptVisitor extends GroovyVisitor<ExecutionContext> {\n+        @Override\n+        public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n+            J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);\n \n-            private J.MethodInvocation forGString(J.MethodInvocation m) {\n-                Expression e = m.getArguments().get(0);\n-                if (!(e instanceof G.GString)) {\n-                    return m;\n-                }\n-                G.GString g = (G.GString)e;\n-                // Supporting all possible GString interpolations is impossible\n-                // Supporting all probable GString interpolations is difficult\n-                // This focuses on the most common case: When only the version number is interpolated\n-                if (g.getStrings().size() != 2 || !(g.getStrings().get(0) instanceof J.Literal) ||\n-                        !(g.getStrings().get(1) instanceof G.GString.Value)) {\n-                    return m;\n-                }\n-                J.Literal arg1 = (J.Literal)g.getStrings().get(0);\n-                if (arg1.getType() != JavaType.Primitive.String || arg1.getValue() == null) {\n-                    return m;\n-                }\n-                String[] ga = ((String) arg1.getValue()).split(\":\");\n-                if (ga.length != 2) {\n-                    return m;\n-                }\n-                G.GString.Value arg2 = (G.GString.Value)g.getStrings().get(1);\n-                if (!(arg2.getTree() instanceof Expression)) {\n-                    return m;\n-                }\n-                G.MapEntry groupEntry = mapEntry(\"group\", ga[0])\n-                        .withMarkers(e.getMarkers())\n-                        .withPrefix(e.getPrefix());\n-                G.MapEntry artifactEntry = mapEntry(\"name\", ga[1])\n-                        .withMarkers(e.getMarkers());\n-                G.MapEntry versionEntry = mapEntry(\"version\", (Expression) arg2.getTree().withPrefix(Space.format(\" \")))\n-                        .withMarkers(e.getMarkers());\n-\n-                Expression lastArg = m.getArguments().get(m.getArguments().size() - 1);\n-                if (lastArg instanceof J.Lambda) {\n-                    m = m.withArguments(Arrays.asList(groupEntry, artifactEntry, versionEntry, lastArg));\n-                } else {\n-                    m = m.withArguments(Arrays.asList(groupEntry, artifactEntry, versionEntry));\n-                }\n-\n-                return updateTypeForMapArgument(m);\n-            }\n+            GradleDependency.Matcher gradleDependencyMatcher = Traits.gradleDependency();\n \n-            private J.MethodInvocation updateTypeForMapArgument(J.MethodInvocation m) {\n-                JavaType.Method mtype = m.getMethodType();\n-                if (mtype == null) {\n-                    return m;\n-                }\n-                mtype = mtype.withParameterTypes(singletonList(JavaType.ShallowClass.build(\"java.util.Map\")));\n-                if (m.getName().getType() != null) {\n-                    m = m.withName(m.getName().withType(mtype));\n-                }\n-                return m.withMethodType(mtype);\n+            if (!gradleDependencyMatcher.get(getCursor()).isPresent()) {\n+                return m;\n+            }\n+            m = forBasicString(m, this::mapEntry, G.MapEntry::withPrefix, this::updateTypeForMapArgument);\n+            m = forStringTemplate(m, G.GString.class, G.GString::getStrings, G.GString.Value.class, G.GString.Value::getTree, this::mapEntry, this::mapEntry, G.MapEntry::withPrefix, this::updateTypeForMapArgument);\n+            return m;\n+        }\n+\n+        private J.MethodInvocation updateTypeForMapArgument(J.MethodInvocation m) {\n+            JavaType.Method mtype = m.getMethodType();\n+            if (mtype == null) {\n+                return m;\n+            }\n+            mtype = mtype.withParameterTypes(singletonList(JavaType.ShallowClass.build(\"java.util.Map\")));\n+            if (m.getName().getType() != null) {\n+                m = m.withName(m.getName().withType(mtype));\n             }\n-        });\n+            return m.withMethodType(mtype);\n+        }\n+\n+        private G.MapEntry mapEntry(String key, String value) {\n+            return mapEntry(key,\n+                    new J.Literal(randomId(), Space.build(\" \", emptyList()), Markers.EMPTY, value, \"'\" + value + \"'\", null, JavaType.Primitive.String));\n+        }\n+\n+        private G.MapEntry mapEntry(String key, Expression e) {\n+            return new G.MapEntry(\n+                    randomId(),\n+                    Space.format(\" \"),\n+                    Markers.EMPTY,\n+                    JRightPadded.build(new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), key, null, null)),\n+                    e,\n+                    null\n+            );\n+        }\n     }\n \n-    private static G.MapEntry mapEntry(String key, String value) {\n-        return mapEntry(key,\n-                new J.Literal(randomId(), Space.build(\" \", emptyList()), Markers.EMPTY, value, \"'\" + value + \"'\", null, JavaType.Primitive.String));\n+    private static <T extends Expression> J.MethodInvocation forBasicString(J.MethodInvocation m,\n+                                                                            BiFunction<String, String, T> mapper,\n+                                                                            BiFunction<T, Space, T> firstItemPrefixer,\n+                                                                            Function<J.MethodInvocation, J.MethodInvocation> typeAddition) {\n+        Expression e = m.getArguments().get(0);\n+        if (!(e instanceof J.Literal)) {\n+            return m;\n+        }\n+        J.Literal arg = (J.Literal) e;\n+        if (arg.getType() != JavaType.Primitive.String) {\n+            return m;\n+        }\n+        String dependencyString = (String) arg.getValue();\n+        if (dependencyString == null) {\n+            return m;\n+        }\n+        Dependency dependency = DependencyStringNotationConverter.parse(dependencyString);\n+        if (dependency == null) {\n+            return m;\n+        }\n+        List<Expression> arguments = new ArrayList<>();\n+        arguments.add(firstItemPrefixer.apply(mapper.apply(\"group\", dependency.getGroupId())\n+                .withMarkers(arg.getMarkers()), arg.getPrefix()));\n+        arguments.add(mapper.apply(\"name\", dependency.getArtifactId())\n+                .withMarkers(arg.getMarkers()));\n+        if (dependency.getVersion() != null) {\n+            arguments.add(mapper.apply(\"version\", dependency.getVersion())\n+                    .withMarkers(arg.getMarkers()));\n+        }\n+        if (dependency.getClassifier() != null) {\n+            arguments.add(mapper.apply(\"classifier\", dependency.getClassifier())\n+                    .withMarkers(arg.getMarkers()));\n+        }\n+        if (dependency.getExt() != null) {\n+            arguments.add(mapper.apply(\"ext\", dependency.getExt())\n+                    .withMarkers(arg.getMarkers()));\n+        }\n+\n+        Expression lastArg = m.getArguments().get(m.getArguments().size() - 1);\n+        if (lastArg instanceof J.Lambda) {\n+            m = m.withArguments(ListUtils.concat(arguments, lastArg));\n+        } else {\n+            m = m.withArguments(arguments);\n+        }\n+\n+        return typeAddition.apply(m);\n     }\n \n-    private static G.MapEntry mapEntry(String key, Expression e) {\n-        return new G.MapEntry(\n-                randomId(),\n-                Space.format(\" \"),\n-                Markers.EMPTY,\n-                JRightPadded.build(new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), key, null, null)),\n-                e,\n-                null\n-        );\n+    private static <T extends Expression, P extends J, R extends Expression> J.MethodInvocation forStringTemplate(J.MethodInvocation m,\n+                                                                                                     Class<T> type,\n+                                                                                                     Function<T, List<J>> partsExtractor,\n+                                                                                                     Class<P> partsType,\n+                                                                                                     Function<P, Tree> getTreeFromTemplatePart,\n+                                                                                                     BiFunction<String, String, R> mapper,\n+                                                                                                     BiFunction<String, Expression, R> expressionMapper,\n+                                                                                                     BiFunction<R, Space, R> firstItemPrefixer,\n+                                                                                                     Function<J.MethodInvocation, J.MethodInvocation> typeAddition) {\n+        Expression e = m.getArguments().get(0);\n+        if (!(type.isInstance(e))) {\n+            return m;\n+        }\n+        T template = type.cast(e);\n+        // Supporting all possible interpolations is impossible\n+        // Supporting all probable interpolations is difficult\n+        // This focuses on the most common case: When only the version number is interpolated\n+        List<J> parts = partsExtractor.apply(template);\n+        if (parts.size() != 2 || !(parts.get(0) instanceof J.Literal) || !(partsType.isInstance(parts.get(1)))) {\n+            return m;\n+        }\n+        J.Literal arg1 = (J.Literal) parts.get(0);\n+        if (arg1.getType() != JavaType.Primitive.String || arg1.getValue() == null) {\n+            return m;\n+        }\n+        String[] ga = ((String) arg1.getValue()).split(\":\");\n+        if (ga.length != 2) {\n+            return m;\n+        }\n+        P arg2 = partsType.cast(parts.get(1));\n+        Tree tree = getTreeFromTemplatePart.apply(arg2);\n+        if (!(tree instanceof Expression)) {\n+            return m;\n+        }\n+        R groupEntry = firstItemPrefixer.apply(mapper.apply(\"group\", ga[0]).withMarkers(e.getMarkers()), e.getPrefix());\n+        R artifactEntry = mapper.apply(\"name\", ga[1]).withMarkers(e.getMarkers());\n+        R versionEntry = expressionMapper.apply(\"version\", ((Expression) tree).withPrefix(Space.SINGLE_SPACE)).withMarkers(e.getMarkers());\n+\n+        Expression lastArg = m.getArguments().get(m.getArguments().size() - 1);\n+        if (lastArg instanceof J.Lambda) {\n+            m = m.withArguments(Arrays.asList(groupEntry, artifactEntry, versionEntry, lastArg));\n+        } else {\n+            m = m.withArguments(Arrays.asList(groupEntry, artifactEntry, versionEntry));\n+        }\n+\n+        return typeAddition.apply(m);\n     }\n }\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseMapNotationTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseMapNotationTest.java\nindex b91a42ea085..e5bc795d964 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseMapNotationTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseMapNotationTest.java\n@@ -22,6 +22,7 @@\n import org.openrewrite.test.RewriteTest;\n \n import static org.openrewrite.gradle.Assertions.buildGradle;\n+import static org.openrewrite.gradle.Assertions.buildGradleKts;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n \n class DependencyUseMapNotationTest implements RewriteTest {\n@@ -69,6 +70,46 @@ void basicString() {\n         );\n     }\n \n+    @Test\n+    void kotlinSupport() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              val version = \"latest.release\"\n+              \n+              dependencies {\n+                  api(\"org.openrewrite:rewrite-core:latest.release:sources\")\n+                  implementation(\"org.openrewrite:rewrite-core:$version\")\n+              }\n+              \"\"\",\n+              \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              val version = \"latest.release\"\n+              \n+              dependencies {\n+                  api(group = \"org.openrewrite\", name = \"rewrite-core\", version = \"latest.release\", classifier = \"sources\")\n+                  implementation(group = \"org.openrewrite\", name = \"rewrite-core\", version = version)\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void withGString() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5510",
    "pr_id": 5510,
    "issue_id": 5361,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Plugin management support for Gradle Kotlin scripts (.kts)\n## What problem are you trying to solve?\n\nDependency management has been enhanced to support the Gradle Kotlin DSL via https://github.com/openrewrite/rewrite/pull/5158. Recipes for managing plugins only works for the Gradle Groovy DSL, but should be supported for the Kotlin DSL as well.\n\n## Describe the solution you'd like\n\nSupport the Kotlin DSL for the recipes in the package `org.openrewrite.gradle.plugins`.\n\n## Have you considered any alternatives or workarounds?\n\nNo workarounds are available right now except for writing a custom recipe.\n\n## Additional context\n\nSome upgrade recipes e.g. for Spring Boot may need to touch the applied plugin(s) in a Gradle build.",
    "issue_word_count": 116,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseStringNotation.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseStringNotationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseStringNotationTest.java"
    ],
    "base_commit": "37633a0b9eb6cf06c0d37abfe722a2e7bb4ecc0c",
    "head_commit": "b367b47b315a26cf5c95f86c2b6f2a6d9722a057",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5510",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5510",
    "dockerfile": "",
    "pr_merged_at": "2025-05-27T19:24:15.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseStringNotation.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseStringNotation.java\nindex 1f655c4f471..062caec88c4 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseStringNotation.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseStringNotation.java\n@@ -22,8 +22,8 @@\n import org.openrewrite.TreeVisitor;\n import org.openrewrite.gradle.trait.GradleDependency;\n import org.openrewrite.gradle.trait.Traits;\n-import org.openrewrite.groovy.GroovyVisitor;\n import org.openrewrite.groovy.tree.G;\n+import org.openrewrite.java.JavaVisitor;\n import org.openrewrite.java.tree.Expression;\n import org.openrewrite.java.tree.J;\n import org.openrewrite.java.tree.JavaType;\n@@ -49,7 +49,7 @@ public String getDescription() {\n \n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(new IsBuildGradle<>(), new GroovyVisitor<ExecutionContext>() {\n+        return Preconditions.check(new IsBuildGradle<>(), new JavaVisitor<ExecutionContext>() {\n             @Override\n             public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n                 J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);\n@@ -110,6 +110,32 @@ public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx)\n                         return m;\n                     }\n \n+                    Expression lastArg = m.getArguments().get(m.getArguments().size() - 1);\n+                    if (lastArg instanceof J.Lambda) {\n+                        m = m.withArguments(Arrays.asList(stringNotation, lastArg));\n+                    } else {\n+                        m = m.withArguments(Collections.singletonList(stringNotation));\n+                    }\n+                } else if (m.getArguments().get(0) instanceof J.Assignment) {\n+                    J.Assignment firstEntry = (J.Assignment) m.getArguments().get(0);\n+                    Space prefix = firstEntry.getPrefix();\n+                    Markers markers = firstEntry.getMarkers();\n+\n+                    for (Expression e : m.getArguments()) {\n+                        if (e instanceof J.Assignment) {\n+                            J.Assignment assignment = (J.Assignment) e;\n+                            if (assignment.getVariable() instanceof J.Identifier) {\n+                                J.Identifier key = (J.Identifier) assignment.getVariable();\n+                                mapNotation.put(key.getSimpleName(), assignment.getAssignment());\n+                            }\n+                        }\n+                    }\n+\n+                    J.Literal stringNotation = toLiteral(prefix, markers, mapNotation);\n+                    if (stringNotation == null) {\n+                        return m;\n+                    }\n+\n                     Expression lastArg = m.getArguments().get(m.getArguments().size() - 1);\n                     if (lastArg instanceof J.Lambda) {\n                         m = m.withArguments(Arrays.asList(stringNotation, lastArg));\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseStringNotationTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseStringNotationTest.java\nindex 8963f259414..47a16595e3d 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseStringNotationTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseStringNotationTest.java\n@@ -21,6 +21,7 @@\n import org.openrewrite.test.RewriteTest;\n \n import static org.openrewrite.gradle.Assertions.buildGradle;\n+import static org.openrewrite.gradle.Assertions.buildGradleKts;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n \n class DependencyUseStringNotationTest implements RewriteTest {\n@@ -68,6 +69,47 @@ void basicMap() {\n         );\n     }\n \n+    @DocumentExample\n+    @Test\n+    void kotlinSupport() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              val version = \"latest.release\"\n+              \n+              dependencies {\n+                  api(group = \"org.openrewrite\", name = \"rewrite-core\", version = \"latest.release\")\n+                  implementation(group = \"org.openrewrite\", name = \"rewrite-core\", version = version, classifier = \"sources\")\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              val version = \"latest.release\"\n+              \n+              dependencies {\n+                  api(\"org.openrewrite:rewrite-core:latest.release\")\n+                  implementation(\"org.openrewrite:rewrite-core:$version:sources\")\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void withClassifier() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5504",
    "pr_id": 5504,
    "issue_id": 5361,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Plugin management support for Gradle Kotlin scripts (.kts)\n## What problem are you trying to solve?\n\nDependency management has been enhanced to support the Gradle Kotlin DSL via https://github.com/openrewrite/rewrite/pull/5158. Recipes for managing plugins only works for the Gradle Groovy DSL, but should be supported for the Kotlin DSL as well.\n\n## Describe the solution you'd like\n\nSupport the Kotlin DSL for the recipes in the package `org.openrewrite.gradle.plugins`.\n\n## Have you considered any alternatives or workarounds?\n\nNo workarounds are available right now except for writing a custom recipe.\n\n## Additional context\n\nSome upgrade recipes e.g. for Spring Boot may need to touch the applied plugin(s) in a Gradle build.",
    "issue_word_count": 116,
    "test_files_count": 1,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/ChangePluginVersion.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocity.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/UpgradePluginVersion.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/plugins/UpgradePluginVersionTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/plugins/UpgradePluginVersionTest.java"
    ],
    "base_commit": "da2e4dd9218b291b322076ab6887d51201cfe54a",
    "head_commit": "c99487570f2adc7520765f8e0f0327fa33133491",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5504",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5504",
    "dockerfile": "",
    "pr_merged_at": "2025-05-27T13:57:03.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/ChangePluginVersion.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/ChangePluginVersion.java\nindex 0c9ee0249bc..38773cf47c2 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/ChangePluginVersion.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/ChangePluginVersion.java\n@@ -40,8 +40,12 @@\n \n import java.util.List;\n \n+/**\n+ * @deprecated in favor of {@link org.openrewrite.gradle.plugins.UpgradePluginVersion}.\n+ */\n @Value\n @EqualsAndHashCode(callSuper = false)\n+@Deprecated\n public class ChangePluginVersion extends Recipe {\n     private static final String GRADLE_PROPERTIES_FILE_NAME = \"gradle.properties\";\n \n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocity.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocity.java\nindex b0c812ea5d9..e36baef9d61 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocity.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocity.java\n@@ -97,7 +97,7 @@ public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionCon\n                         G.CompilationUnit g = cu;\n                         g = (G.CompilationUnit) new ChangePlugin(\"com.gradle.enterprise\", \"com.gradle.develocity\", version).getVisitor()\n                                 .visitNonNull(g, ctx);\n-                        g = (G.CompilationUnit) new ChangePluginVersion(\"com.gradle.common-custom-user-data-gradle-plugin\", \"2.x\", null).getVisitor()\n+                        g = (G.CompilationUnit) new UpgradePluginVersion(\"com.gradle.common-custom-user-data-gradle-plugin\", \"2.x\", null).getVisitor()\n                                 .visitNonNull(g, ctx);\n                         g = (G.CompilationUnit) new MigrateConfigurationVisitor().visitNonNull(g, ctx);\n                         return g;\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/UpgradePluginVersion.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/UpgradePluginVersion.java\nindex 910710f0fd4..4411e0b220c 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/UpgradePluginVersion.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/UpgradePluginVersion.java\n@@ -180,6 +180,15 @@ public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx)\n                         String resolvedPluginVersion = new DependencyVersionSelector(metadataFailures, gradleProject, gradleSettings)\n                                 .select(new GroupArtifact(pluginId, pluginId + \".gradle.plugin\"), \"classpath\", newVersion, versionPattern, ctx);\n \n+                        acc.versionPropNameToPluginId.put(versionVariableName, pluginId);\n+                        assert resolvedPluginVersion != null;\n+                        acc.pluginIdToNewVersion.put(pluginId, resolvedPluginVersion);\n+                    } else if (versionArgs.get(0) instanceof J.Identifier) {\n+                        J.Identifier identifier = (J.Identifier) versionArgs.get(0);\n+                        String versionVariableName = identifier.getSimpleName();\n+                        String resolvedPluginVersion = new DependencyVersionSelector(metadataFailures, gradleProject, gradleSettings)\n+                                .select(new GroupArtifact(pluginId, pluginId + \".gradle.plugin\"), \"classpath\", newVersion, versionPattern, ctx);\n+\n                         acc.versionPropNameToPluginId.put(versionVariableName, pluginId);\n                         assert resolvedPluginVersion != null;\n                         acc.pluginIdToNewVersion.put(pluginId, resolvedPluginVersion);\n@@ -250,6 +259,21 @@ public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx)\n                     return ChangeStringLiteral.withStringValue(v, resolvedVersion);\n                 }));\n             }\n+\n+            @Override\n+            public J visitVariable(J.VariableDeclarations.NamedVariable variable, ExecutionContext ctx) {\n+                J.VariableDeclarations.NamedVariable visited = (J.VariableDeclarations.NamedVariable) super.visitVariable(variable, ctx);\n+                if (acc.versionPropNameToPluginId.containsKey(visited.getSimpleName()) && visited.getInitializer() instanceof J.Literal) {\n+                    J.Literal initializer = (J.Literal) visited.getInitializer();\n+                    String oldVersion = literalValue(initializer);\n+                    String newVersion = acc.pluginIdToNewVersion.get(acc.versionPropNameToPluginId.get(visited.getSimpleName()));\n+                    if (newVersion != null && !newVersion.equals(oldVersion)) {\n+                        String valueSource = initializer.getValueSource() == null || oldVersion == null ? initializer.getValueSource() : initializer.getValueSource().replace(oldVersion, newVersion);\n+                        return visited.withInitializer(initializer.withValueSource(valueSource).withValue(newVersion));\n+                    }\n+                }\n+                return visited;\n+            }\n         };\n         return Preconditions.or(propertiesVisitor, Preconditions.check(Preconditions.or(new IsBuildGradle<>(), new IsSettingsGradle<>()), javaVisitor));\n     }\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/plugins/UpgradePluginVersionTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/plugins/UpgradePluginVersionTest.java\nindex 7e75e03ce16..b57f6816136 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/plugins/UpgradePluginVersionTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/plugins/UpgradePluginVersionTest.java\n@@ -104,6 +104,31 @@ void upgradePluginVersionInProperties() {\n         );\n     }\n \n+    @Test\n+    void change() {\n+        rewriteRun(\n+          spec -> spec.recipe(new UpgradePluginVersion(\"org.openrewrite.rewrite\", \"5.x\", null)),\n+          settingsGradle(\n+            \"\"\"\n+              pluginManagement {\n+                  plugins {\n+                      String v = '5.40.0'\n+                      id 'org.openrewrite.rewrite' version v\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              pluginManagement {\n+                  plugins {\n+                      String v = '5.40.6'\n+                      id 'org.openrewrite.rewrite' version v\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void pluginManagementPlugin() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5503",
    "pr_id": 5503,
    "issue_id": 4527,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Generalize property handling in Maven recipes?\nHi,\r\n\r\nWe have been very happy with the property handling in [UpgradeDependencyVersion](https://github.com/openrewrite/rewrite/blob/main/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java): when a version is a property, the property is updated instead of the original version tag.\r\nWhich is awesome as a lot of versions are properties.\r\n\r\nAll good but... in Quarkus, we are using properties in generated projects also for the groupId/artifactId of the Quarkus BOM (and it's something that is important to us as we have several \"Platforms\" with different coordinates and we need to enforce the Platform consistently to the BOM and the Quarkus Maven plugin, thus why we use properties).\r\n\r\nWhile working on a PR to handle changing the Platform entirely (i.e. including the groupId/artifactId, until now we were just updating the version), I stumbled upon the fact that this nice property handling is actually not generalized to the Maven recipes.\r\n\r\nFor instance, there is nothing to handle it in [ChangeDependencyGroupIdAndArtifactId](https://github.com/openrewrite/rewrite/blob/main/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java) or [ChangeManagedDependencyGroupIdAndArtifactId](https://github.com/openrewrite/rewrite/blob/main/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java) (unless I missed something  but the code seems in line with the behavior I'm experiencing).\r\n\r\nI'm not sure exactly why this is handled only in a very specific case. I'm also not completely sure it should be generalized everywhere but not handling it for the groupId/artifactId is actually quite blocking for us. And to be fair, the version is not handled either in `ChangeDependencyGroupIdAndArtifactId` and `ChangeManagedDependencyGroupIdAndArtifactId` so it's not very consistent.\r\n\r\nI was wondering if it's something you would consider? If you had some advice on how to fix it? I could probably dedicate some time to it as it's in our way but I definitely need some guidance. Also, I might not be able to generalize it everywhere in the time I would be able to dedicate to it but I could at least put the infrastructure in place and fix the cases that are in our way, opening the gate for more in the future if someone needs it elsewhere.\r\n\r\nThoughts?",
    "issue_word_count": 379,
    "test_files_count": 2,
    "non_test_files_count": 5,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java"
    ],
    "base_commit": "da2e4dd9218b291b322076ab6887d51201cfe54a",
    "head_commit": "1dbf2fca42e3eec1595bc2e1ee6032a099c87394",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5503",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5503",
    "dockerfile": "",
    "pr_merged_at": "2025-05-27T12:57:53.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\nindex 4bb4ccce955..9fc71cdec11 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\n@@ -25,7 +25,6 @@\n import org.openrewrite.semver.Semver;\n import org.openrewrite.semver.VersionComparator;\n import org.openrewrite.xml.AddToTagVisitor;\n-import org.openrewrite.xml.ChangeTagValueVisitor;\n import org.openrewrite.xml.RemoveContentVisitor;\n import org.openrewrite.xml.tree.Xml;\n \n@@ -239,16 +238,7 @@ private boolean checkIfNewDependencyPresents(@Nullable String groupId, @Nullable\n                         .anyMatch(rd -> (version == null) || version.equals(rd.getVersion()));\n             }\n \n-            private Xml.Tag changeChildTagValue(Xml.Tag tag, String childTagName, String newValue, ExecutionContext ctx) {\n-                Optional<Xml.Tag> childTag = tag.getChild(childTagName);\n-                if (childTag.isPresent() && !newValue.equals(childTag.get().getValue().orElse(null))) {\n-                    tag = (Xml.Tag) new ChangeTagValueVisitor<>(childTag.get(), newValue).visitNonNull(tag, ctx);\n-                }\n-                return tag;\n-            }\n-\n             private boolean isDependencyManaged(Scope scope, String groupId, String artifactId) {\n-\n                 MavenResolutionResult result = getResolutionResult();\n                 for (ResolvedManagedDependency managedDependency : result.getPom().getDependencyManagement()) {\n                     if (groupId.equals(managedDependency.getGroupId()) && artifactId.equals(managedDependency.getArtifactId())) {\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\nindex 6915c9bcc9e..fbf6a814504 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\n@@ -26,7 +26,6 @@\n import org.openrewrite.maven.tree.ResolvedPom;\n import org.openrewrite.semver.Semver;\n import org.openrewrite.semver.VersionComparator;\n-import org.openrewrite.xml.ChangeTagValueVisitor;\n import org.openrewrite.xml.RemoveContentVisitor;\n import org.openrewrite.xml.tree.Xml;\n \n@@ -41,11 +40,6 @@ public class ChangeManagedDependencyGroupIdAndArtifactId extends Recipe {\n     @EqualsAndHashCode.Exclude\n     MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);\n \n-    // there are several implicitly defined version properties that we should never attempt to update\n-    private static final Set<String> implicitlyDefinedVersionProperties = new HashSet<>(Arrays.asList(\n-            \"${version}\", \"${project.version}\", \"${pom.version}\", \"${project.parent.version}\"\n-    ));\n-\n     @Option(displayName = \"Old groupId\",\n             description = \"The old groupId to replace. The groupId is the first part of a managed dependency coordinate `com.google.guava:guava:VERSION`.\",\n             example = \"org.openrewrite.recipe\")\n@@ -146,24 +140,17 @@ public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {\n \n             @Override\n             public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n-\n                 Xml.Tag t = super.visitTag(tag, ctx);\n                 if (isManagedDependencyTag(oldGroupId, oldArtifactId)) {\n-                    Optional<Xml.Tag> groupIdTag = t.getChild(\"groupId\");\n-                    boolean changed = false;\n-                    if (groupIdTag.isPresent() && !newGroupId.equals(groupIdTag.get().getValue().orElse(null))) {\n-                        doAfterVisit(new ChangeTagValueVisitor<>(groupIdTag.get(), newGroupId));\n-                        changed = true;\n+                    if (t.getChild(\"groupId\").isPresent()) {\n+                        t = changeChildTagValue(t, \"groupId\", newGroupId, ctx);\n                     }\n-                    Optional<Xml.Tag> artifactIdTag = t.getChild(\"artifactId\");\n-                    if (artifactIdTag.isPresent() && !newArtifactId.equals(artifactIdTag.get().getValue().orElse(null))) {\n-                        doAfterVisit(new ChangeTagValueVisitor<>(artifactIdTag.get(), newArtifactId));\n-                        changed = true;\n+                    if (t.getChild(\"artifactId\").isPresent()) {\n+                        t = changeChildTagValue(t, \"artifactId\", newArtifactId, ctx);\n                     }\n                     if (newVersion != null) {\n                         try {\n                             Optional<Xml.Tag> versionTag = t.getChild(\"version\");\n-\n                             if (versionTag.isPresent()) {\n                                 String resolvedArtifactId = newArtifactId;\n                                 if (resolvedArtifactId.contains(\"${\")) {\n@@ -172,14 +159,13 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                                     resolvedArtifactId = ResolvedPom.placeholderHelper.replacePlaceholders(newArtifactId, properties::get);\n                                 }\n                                 String resolvedNewVersion = resolveSemverVersion(ctx, newGroupId, resolvedArtifactId, getResolutionResult().getPom().getValue(versionTag.get().getValue().orElse(null)));\n-                                t = (Xml.Tag) new ChangeTagValueVisitor<>(versionTag.get(), resolvedNewVersion).visitNonNull(t, 0, getCursor().getParentOrThrow());\n+                                t = changeChildTagValue(t, \"version\", resolvedNewVersion, ctx);\n                             }\n-                            changed = true;\n                         } catch (MavenDownloadingException e) {\n                             return e.warn(t);\n                         }\n                     }\n-                    if (changed) {\n+                    if (t != tag) {\n                         maybeUpdateModel();\n                         doAfterVisit(new RemoveRedundantDependencyVersions(null, null, null, null).getVisitor());\n                         if (isNewDependencyPresent) {\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\nindex a55e83188c6..24f6e8096d6 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\n@@ -23,11 +23,8 @@\n import org.openrewrite.Recipe;\n import org.openrewrite.TreeVisitor;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n-import org.openrewrite.xml.ChangeTagValueVisitor;\n import org.openrewrite.xml.tree.Xml;\n \n-import java.util.Optional;\n-\n @Value\n @EqualsAndHashCode(callSuper = false)\n public class ChangePluginGroupIdAndArtifactId extends Recipe {\n@@ -105,14 +102,6 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 //noinspection ConstantConditions\n                 return t;\n             }\n-\n-            private Xml.Tag changeChildTagValue(Xml.Tag tag, String childTagName, String newValue, ExecutionContext ctx) {\n-                Optional<Xml.Tag> childTag = tag.getChild(childTagName);\n-                if (childTag.isPresent() && !newValue.equals(childTag.get().getValue().orElse(null))) {\n-                    tag = (Xml.Tag) new ChangeTagValueVisitor<>(childTag.get(), newValue).visitNonNull(tag, ctx);\n-                }\n-                return tag;\n-            }\n         };\n     }\n }\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\nindex 13677eceedd..ce43da0e338 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n@@ -21,6 +21,7 @@\n import org.openrewrite.TreeVisitor;\n import org.openrewrite.maven.internal.MavenPomDownloader;\n import org.openrewrite.maven.tree.*;\n+import org.openrewrite.xml.ChangeTagValueVisitor;\n import org.openrewrite.xml.XPathMatcher;\n import org.openrewrite.xml.XmlVisitor;\n import org.openrewrite.xml.tree.Xml;\n@@ -47,6 +48,11 @@ public class MavenVisitor<P> extends XmlVisitor<P> {\n     static final XPathMatcher PARENT_MATCHER = new XPathMatcher(\"/project/parent\");\n     static final XPathMatcher PROJECT_MATCHER = new XPathMatcher(\"/project\");\n \n+    // there are several implicitly defined version properties that we should never attempt to update\n+    private static final Set<String> IMPLICITLY_DEFINED_VERSION_PROPERTIES = new HashSet<>(Arrays.asList(\n+            \"${version}\", \"${project.version}\", \"${pom.version}\", \"${project.parent.version}\"\n+    ));\n+\n     private transient Xml.@Nullable Document document;\n \n     @Nullable\n@@ -269,6 +275,32 @@ private boolean isTag(String name) {\n         return getCursor().getValue() instanceof Xml.Tag && name.equals(getCursor().<Xml.Tag>getValue().getName());\n     }\n \n+    protected Xml.Tag changeChildTagValue(Xml.Tag tag, String childTagName, @Nullable String newValue, P p) {\n+        return changeChildTagValue(tag, childTagName, newValue, false, p);\n+    }\n+\n+    protected Xml.Tag changeChildTagValue(Xml.Tag tag, String childTagName, @Nullable String newValue, @Nullable Boolean addPropertyIfMissing, P p) {\n+        Optional<Xml.Tag> childTag = tag.getChild(childTagName);\n+        if (childTag.isPresent()) {\n+            String oldValue = childTag.get().getValue().orElse(null);\n+            if (newValue != null && !newValue.equals(oldValue)) {\n+                if (isProperty(oldValue)) {\n+                    String propertyName = oldValue.substring(2, oldValue.length() - 1);\n+                    if (getResolutionResult().getPom().getRequested().getProperties().containsKey(propertyName)) {\n+                        doAfterVisit((TreeVisitor<?, P>) new ChangePropertyValue(propertyName, newValue, addPropertyIfMissing, false).getVisitor());\n+                    }\n+                } else {\n+                    tag = (Xml.Tag) new ChangeTagValueVisitor<>(childTag.get(), newValue).visitNonNull(tag, p);\n+                }\n+            }\n+        }\n+        return tag;\n+    }\n+\n+    protected boolean isProperty(@Nullable String value) {\n+        return value != null && value.startsWith(\"${\") && !IMPLICITLY_DEFINED_VERSION_PROPERTIES.contains(value);\n+    }\n+\n     public @Nullable ResolvedDependency findDependency(Xml.Tag tag) {\n         Map<Scope, List<ResolvedDependency>> dependencies = getResolutionResult().getDependencies();\n         Scope scope = Scope.fromName(tag.getChildValue(\"scope\").orElse(\"compile\"));\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java b/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\nindex c6cdb44568f..83be12577c2 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\n@@ -52,11 +52,6 @@ public class UpgradeDependencyVersion extends ScanningRecipe<UpgradeDependencyVe\n     @EqualsAndHashCode.Exclude\n     transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);\n \n-    // there are several implicitly defined version properties that we should never attempt to update\n-    private static final Collection<String> implicitlyDefinedVersionProperties = Arrays.asList(\n-            \"${version}\", \"${project.version}\", \"${pom.version}\", \"${project.parent.version}\"\n-    );\n-\n     @Option(displayName = \"Group\",\n             description = \"The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression.\",\n             example = \"com.fasterxml.jackson*\")\n@@ -156,8 +151,7 @@ public Xml.Tag visitTag(final Xml.Tag tag, final ExecutionContext ctx) {\n                                 Optional<Xml.Tag> version = tag.getChild(\"version\");\n                                 if (version.isPresent()) {\n                                     String requestedVersion = d.getRequested().getVersion();\n-                                    if (requestedVersion != null && requestedVersion.startsWith(\"${\") &&\n-                                        !implicitlyDefinedVersionProperties.contains(requestedVersion)) {\n+                                    if (isProperty(requestedVersion)) {\n                                         String propertyName = requestedVersion.substring(2, requestedVersion.length() - 1);\n                                         if (!getResolutionResult().getPom().getRequested().getProperties().containsKey(propertyName)) {\n                                             storeParentPomProperty(getResolutionResult().getParent(), propertyName, newerVersion);\n@@ -180,8 +174,7 @@ public Xml.Tag visitTag(final Xml.Tag tag, final ExecutionContext ctx) {\n              * @param propertyName the name of the property to update, if found in any the parent pom source file\n              * @param newerVersion the resolved newer version that any matching parent pom property should be updated to\n              */\n-            private void storeParentPomProperty(\n-                    @Nullable MavenResolutionResult currentMavenResolutionResult, String propertyName, String newerVersion) {\n+            private void storeParentPomProperty(@Nullable MavenResolutionResult currentMavenResolutionResult, String propertyName, String newerVersion) {\n                 if (currentMavenResolutionResult == null) {\n                     return; // No parent contained the property; might then be in the same source file, or an import BOM\n                 }\n@@ -270,10 +263,8 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 }\n \n                 private void retainVersions() {\n-                    for (Recipe retainVersionRecipe : RetainVersions.plan(this, retainVersions == null ?\n-                            emptyList() : retainVersions)) {\n-                        doAfterVisit(retainVersionRecipe.getVisitor());\n-                    }\n+                    RetainVersions.plan(this, retainVersions == null ? emptyList() : retainVersions)\n+                            .forEach(it -> doAfterVisit(it.getVisitor()));\n                 }\n             }\n \n@@ -284,26 +275,13 @@ private Xml.Tag upgradeDependency(ExecutionContext ctx, Xml.Tag t) throws MavenD\n                     // as a source file, attempt to find a new version.\n                     String newerVersion = findNewerVersion(d.getGroupId(), d.getArtifactId(), d.getVersion(), ctx);\n                     if (newerVersion != null) {\n-                        Optional<Xml.Tag> version = t.getChild(\"version\");\n-                        if (version.isPresent()) {\n-                            String requestedVersion = d.getRequested().getVersion();\n-                            if (requestedVersion != null && requestedVersion.startsWith(\"${\") && !implicitlyDefinedVersionProperties.contains(requestedVersion)) {\n-                                String propertyName = requestedVersion.substring(2, requestedVersion.length() - 1);\n-                                if (getResolutionResult().getPom().getRequested().getProperties().containsKey(propertyName)) {\n-                                    doAfterVisit(new ChangePropertyValue(propertyName, newerVersion, overrideManagedVersion, false).getVisitor());\n-                                }\n-                            } else {\n-                                t = (Xml.Tag) new ChangeTagValueVisitor<>(version.get(), newerVersion).visitNonNull(t, 0, getCursor().getParentOrThrow());\n-                            }\n+                        if (t.getChild(\"version\").isPresent()) {\n+                            t = changeChildTagValue(t, \"version\", newerVersion, overrideManagedVersion, ctx);\n                         } else if (Boolean.TRUE.equals(overrideManagedVersion)) {\n                             ResolvedManagedDependency dm = findManagedDependency(t);\n                             // if a managed dependency is expressed as a property, change the property value\n                             // do this only when a requested bom is absent, otherwise changing property has no effect\n-                            if (dm != null &&\n-                                dm.getRequested().getVersion() != null &&\n-                                dm.getRequested().getVersion().startsWith(\"${\") &&\n-                                !implicitlyDefinedVersionProperties.contains(dm.getRequested().getVersion()) &&\n-                                dm.getRequestedBom() == null) {\n+                            if (dm != null && isProperty(dm.getRequested().getVersion()) && dm.getRequestedBom() == null) {\n                                 doAfterVisit(new ChangePropertyValue(dm.getRequested().getVersion().substring(2,\n                                         dm.getRequested().getVersion().length() - 1),\n                                         newerVersion, overrideManagedVersion, false).getVisitor());\n@@ -359,20 +337,14 @@ private Xml.Tag upgradePluginDependency(ExecutionContext ctx, Xml.Tag t) throws\n                 if (groupId != null && artifactId != null && version != null) {\n                     String newerVersion = findNewerVersion(groupId, artifactId, resolveVersion(version), ctx);\n                     if (newerVersion != null) {\n-                        if (version.startsWith(\"${\") && !implicitlyDefinedVersionProperties.contains(version)) {\n-                            doAfterVisit(new ChangePropertyValue(version.substring(2, version.length() - 1), newerVersion, overrideManagedVersion, false).getVisitor());\n-                        } else {\n-                            Optional<Xml.Tag> versionTag = t.getChild(\"version\");\n-                            assert versionTag.isPresent();\n-                            t = (Xml.Tag) new ChangeTagValueVisitor<>(versionTag.get(), newerVersion).visitNonNull(t, 0, getCursor().getParentOrThrow());\n-                        }\n+                        t = changeChildTagValue(t, \"version\", newerVersion, overrideManagedVersion, ctx);\n                     }\n                 }\n                 return t;\n             }\n \n             private String resolveVersion(String version) {\n-                if (version.startsWith(\"${\") && !implicitlyDefinedVersionProperties.contains(version)) {\n+                if (isProperty(version)) {\n                     Map<String, String> properties = getResolutionResult().getPom().getProperties();\n                     String property = version.substring(2, version.length() - 1);\n                     return properties.getOrDefault(property, version);\n@@ -384,7 +356,7 @@ private String resolveVersion(String version) {\n                 String newerVersion = findNewerVersion(groupId, artifactId, version2, ctx);\n                 if (newerVersion == null) {\n                     return null;\n-                } else if (requestedVersion != null && requestedVersion.startsWith(\"${\")) {\n+                } else if (isProperty(requestedVersion)) {\n                     //noinspection unchecked\n                     return (TreeVisitor<Xml, ExecutionContext>) new ChangePropertyValue(requestedVersion.substring(2, requestedVersion.length() - 1), newerVersion, overrideManagedVersion, false)\n                             .getVisitor();\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\nindex a0fb4005f9c..95d6395d49f 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\n@@ -1624,4 +1624,56 @@ void changePluginDependencyGroupIdAndArtifactId() {\n           )\n         );\n     }\n+\n+    @Test\n+    void changeDependencyGroupIdAndArtifactIdWithVersionProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependencyGroupIdAndArtifactId(\n+            \"javax.activation\",\n+            \"javax.activation-api\",\n+            \"jakarta.activation\",\n+            \"jakarta.activation-api\",\n+            \"1.2.x\",\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <properties>\n+                      <activation.api>1.2.0</activation.api>\n+                  </properties>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>javax.activation</groupId>\n+                          <artifactId>javax.activation-api</artifactId>\n+                          <version>${activation.api}</version>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <properties>\n+                      <activation.api>1.2.2</activation.api>\n+                  </properties>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                          <version>${activation.api}</version>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java\nindex 442e575e54c..8f0f7af3d67 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java\n@@ -329,14 +329,14 @@ void changeManagedDependencyWithPropertyVersion() {\n                   <artifactId>my-app</artifactId>\n                   <version>1</version>\n                   <properties>\n-                      <version.property>1.2.0</version.property>\n+                      <version.property>1.2.2</version.property>\n                   </properties>\n                   <dependencyManagement>\n                       <dependencies>\n                           <dependency>\n                               <groupId>jakarta.activation</groupId>\n                               <artifactId>jakarta.activation-api</artifactId>\n-                              <version>1.2.2</version>\n+                              <version>${version.property}</version>\n                           </dependency>\n                       </dependencies>\n                   </dependencyManagement>\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5497",
    "pr_id": 5497,
    "issue_id": 5411,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Fails to parse Javadoc with multiline XML comment\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using\n\n- OpenRewrite Maven Plugin v6.8.0 and 6.9.0\n- Current main as well\n\n## How are you running OpenRewrite?\nJUnit Testcase\n\n## What is the smallest, simplest way to reproduce the problem?\n```java\n  @Test\n    @ExpectedToFail(\"Multiline HTML comments are not handled correctly by the parser\")\n    void htmlCommentMultiline() {\n        rewriteRun(\n          java(\n            \"\"\"\n              /** \n              * First line of comment\n              * <!-- comment \n              *   Second line of comment\n              * -->\n              * Final comment line\n              */\n              class Test {\n              }\n              \"\"\"\n          )\n        );\n    }\n```\n\n## What did you expect to see?\nA successfull test.\n\n## What did you see instead?\nFailing Test\n\n## What is the full stack trace of any errors you encountered?\n\n```diff\n/**\n * First line of comment\n * <!-- comment\n-*   Second line of comment\n-* -->\n+   Second line of comment\n+ -->\n * Final comment line\n+*\n+*\n */\n class Test {\n }\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\n",
    "issue_word_count": 308,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java"
    ],
    "base_commit": "b9bdbdcb9f5960527e95a348da1b441f7a1d053c",
    "head_commit": "9667bce39d400b98bf0df32c70ed34e8f8590829",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5497",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5497",
    "dockerfile": "",
    "pr_merged_at": "2025-05-26T20:39:47.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\nindex 5b64ba5956f..97084215c50 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\n@@ -289,6 +289,8 @@ public Tree visitDocComment(DocCommentTree node, List<Javadoc> body) {\n             }\n             if (docTree instanceof DCTree.DCText) {\n                 body.addAll(visitText(((DCTree.DCText) docTree).getBody()));\n+            } else if (docTree instanceof DCTree.DCComment) {\n+                body.addAll(visitText(((DCTree.DCComment) docTree).getBody()));\n             } else {\n                 body.add((Javadoc) scan(docTree, body));\n             }\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\nindex 62c9c93d692..36ae7d77381 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\n@@ -290,8 +290,10 @@ public Tree visitDocComment(DocCommentTree node, List<Javadoc> body) {\n             if (!(docTree instanceof DCTree.DCText && i > 0)) {\n                 body.addAll(whitespaceBefore());\n             }\n-            if (docTree instanceof DCTree.DCText) {\n-                body.addAll(visitText(((DCTree.DCText) docTree).getBody()));\n+            if (docTree instanceof DCTree.DCText textNode) {\n+                body.addAll(visitText(textNode.getBody()));\n+            } else if (docTree instanceof DCTree.DCComment commentNode) {\n+                body.addAll(visitText(commentNode.getBody()));\n             } else {\n                 body.add((Javadoc) scan(docTree, body));\n             }\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\nindex 415c7a5f78e..872208ac2d5 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\n@@ -290,8 +290,10 @@ public Tree visitDocComment(DocCommentTree node, List<Javadoc> body) {\n             if (!(docTree instanceof DCTree.DCText && i > 0)) {\n                 body.addAll(whitespaceBefore());\n             }\n-            if (docTree instanceof DCTree.DCText) {\n-                body.addAll(visitText(((DCTree.DCText) docTree).getBody()));\n+            if (docTree instanceof DCTree.DCText textNode) {\n+                body.addAll(visitText(textNode.getBody()));\n+            } else if (docTree instanceof DCTree.DCComment commentNode) {\n+                body.addAll(visitText(commentNode.getBody()));\n             } else {\n                 body.add((Javadoc) scan(docTree, body));\n             }\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\nindex 3df6399cb27..b4b66a24b23 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\n@@ -289,6 +289,8 @@ public Tree visitDocComment(DocCommentTree node, List<Javadoc> body) {\n             }\n             if (docTree instanceof DCTree.DCText) {\n                 body.addAll(visitText(((DCTree.DCText) docTree).getBody()));\n+            } else if (docTree instanceof DCTree.DCComment) {\n+                body.addAll(visitText(((DCTree.DCComment) docTree).getBody()));\n             } else {\n                 body.add((Javadoc) scan(docTree, body));\n             }\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\nindex 9e12014f5c1..5833fd7ebd0 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\n@@ -2052,4 +2052,25 @@ public void foo() {}\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5411\")\n+    void multilineHtmlCommentInJavadoc() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              /** \n+              * First line of comment\n+              * <!-- comment \n+              *   Second line of comment\n+              * -->\n+              * <!-- another comment -->\n+              * Final comment line\n+              */\n+              class Test {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5469",
    "pr_id": 5469,
    "issue_id": 5444,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Javadoc parsing fails to roundtrip with extra whitespace in type\n## What version of OpenRewrite are you using?\n\n* org.openrewrite:rewrite-core:8.52.1\n\n## What is the smallest, simplest way to reproduce the problem?\n\nThis is a case the Javadoc is invalid, but where the parser should yet not fail. This was found in our code base but have since been fixed so this is not a blocker for us.\n\n```java\n  @Test\n  void parsingJavadocTypeWhitespace() {\n    rewriteRun(\n        // language=java\n        java(\n            \"\"\"\n            import java.util.Optional;\n\n            public class Foo {\n                private void bar(Optional<String> b) {}\n\n                /**\n                This has an extra whitespace {@link #bar(Optional <String>)}\n                */\n                public void foo() {}\n            }\n            \"\"\"));\n  }\n```\n\nFails with:\n\n```\norg.opentest4j.AssertionFailedError: [When parsing and printing the source code back to text without modifications, the printed source didn't match the original source code. This means there is a bug in the parser implementation itself. Please open an issue to report this, providing a sample of the code that generated this error for \"Foo.java\":\n```\n```diff\ndiff --git a/Foo.java b/Foo.java\nindex 5da3e63..70a3fd8 100644\n--- a/Foo.java\n+++ b/Foo.java\n@@ -4,7 +4,7 @@\n     private void bar(Optional<String> b) {}\n\n     /**\n-    This has an extra whitespace {@link #bar(Optional <String>)}\n+    This has an extra whitespace {@link #bar(Optional<Stringg>)}\n     */\n     public void foo() {}\n }\n\\ No newline at end of file\n```\n```\n]\nexpected:\n  \"import java.util.Optional;\n\n  public class Foo {\n      private void bar(Optional<String> b) {}\n\n      /**\n      This has an extra whitespace {@link #bar(Optional <String>)}\n      */\n      public void foo() {}\n  }\"\n but was:\n  \"import java.util.Optional;\n\n  public class Foo {\n      private void bar(Optional<String> b) {}\n\n      /**\n      This has an extra whitespace {@link #bar(Optional<Stringg>)}\n      */\n      public void foo() {}\n  }\"\n\tat org.openrewrite.test.RewriteTest.assertContentEquals(RewriteTest.java:622)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:311)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:130)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:125)\n```",
    "issue_word_count": 306,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java"
    ],
    "base_commit": "cca75e890371e5e657b10aa051ffc7ef1c58677a",
    "head_commit": "5af67752dd511a5463e3e1b4a4d3d458cb782fad",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5469",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5469",
    "dockerfile": "",
    "pr_merged_at": "2025-05-24T00:54:58.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\nindex ac3fa9c4771..c71a5093cab 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\n@@ -1223,6 +1223,7 @@ private Space whitespace() {\n         public J visitParameterizedType(ParameterizedTypeTree node, Space fmt) {\n             NameTree id = (NameTree) javaVisitor.scan(node.getType(), Space.EMPTY);\n             List<JRightPadded<Expression>> expressions = new ArrayList<>(node.getTypeArguments().size());\n+            String spaceBeforeTypeParams = whitespaceBeforeAsString();\n             cursor += 1; // skip '<', JavaDocVisitor does not interpret List <Integer> as Parameterized.\n             int argsSize = node.getTypeArguments().size();\n             for (int i = 0; i < argsSize; i++) {\n@@ -1237,7 +1238,9 @@ public J visitParameterizedType(ParameterizedTypeTree node, Space fmt) {\n                 expression = expression.withAfter(after);\n                 expressions.add(expression);\n             }\n-            return new J.ParameterizedType(randomId(), fmt, Markers.EMPTY, id, JContainer.build(expressions), typeMapping.type(node));\n+            JContainer<Expression> typeArgs = JContainer.build(expressions)\n+                    .withBefore(Space.build(spaceBeforeTypeParams, emptyList()));\n+            return new J.ParameterizedType(randomId(), fmt, Markers.EMPTY, id, typeArgs, typeMapping.type(node));\n         }\n     }\n }\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\nindex dd6c4c8d43f..5fe0e329074 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\n@@ -1228,6 +1228,7 @@ private Space whitespace() {\n         public J visitParameterizedType(ParameterizedTypeTree node, Space fmt) {\n             NameTree id = (NameTree) javaVisitor.scan(node.getType(), Space.EMPTY);\n             List<JRightPadded<Expression>> expressions = new ArrayList<>(node.getTypeArguments().size());\n+            String spaceBeforeTypeParams = whitespaceBeforeAsString();\n             cursor += 1; // skip '<', JavaDocVisitor does not interpret List <Integer> as Parameterized.\n             int argsSize = node.getTypeArguments().size();\n             for (int i = 0; i < argsSize; i++) {\n@@ -1242,7 +1243,9 @@ public J visitParameterizedType(ParameterizedTypeTree node, Space fmt) {\n                 expression = expression.withAfter(after);\n                 expressions.add(expression);\n             }\n-            return new J.ParameterizedType(randomId(), fmt, Markers.EMPTY, id, JContainer.build(expressions), typeMapping.type(node));\n+            JContainer<Expression> typeArgs = JContainer.build(expressions)\n+                    .withBefore(Space.build(spaceBeforeTypeParams, emptyList()));\n+            return new J.ParameterizedType(randomId(), fmt, Markers.EMPTY, id, typeArgs, typeMapping.type(node));\n         }\n     }\n }\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\nindex eb9074fc58a..c3b47e7840b 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\n@@ -1227,6 +1227,7 @@ private Space whitespace() {\n         public J visitParameterizedType(ParameterizedTypeTree node, Space fmt) {\n             NameTree id = (NameTree) javaVisitor.scan(node.getType(), Space.EMPTY);\n             List<JRightPadded<Expression>> expressions = new ArrayList<>(node.getTypeArguments().size());\n+            String spaceBeforeTypeParams = whitespaceBeforeAsString();\n             cursor += 1; // skip '<', JavaDocVisitor does not interpret List <Integer> as Parameterized.\n             int argsSize = node.getTypeArguments().size();\n             for (int i = 0; i < argsSize; i++) {\n@@ -1241,7 +1242,9 @@ public J visitParameterizedType(ParameterizedTypeTree node, Space fmt) {\n                 expression = expression.withAfter(after);\n                 expressions.add(expression);\n             }\n-            return new J.ParameterizedType(randomId(), fmt, Markers.EMPTY, id, JContainer.build(expressions), typeMapping.type(node));\n+            JContainer<Expression> typeArgs = JContainer.build(expressions)\n+                    .withBefore(Space.build(spaceBeforeTypeParams, emptyList()));\n+            return new J.ParameterizedType(randomId(), fmt, Markers.EMPTY, id, typeArgs, typeMapping.type(node));\n         }\n     }\n }\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\nindex 004cc16f982..3d32c8bc45c 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\n@@ -1150,6 +1150,7 @@ private Space whitespace() {\n         public J visitParameterizedType(ParameterizedTypeTree node, Space fmt) {\n             NameTree id = (NameTree) javaVisitor.scan(node.getType(), Space.EMPTY);\n             List<JRightPadded<Expression>> expressions = new ArrayList<>(node.getTypeArguments().size());\n+            String spaceBeforeTypeParams = whitespaceBeforeAsString();\n             cursor += 1; // skip '<', JavaDocVisitor does not interpret List <Integer> as Parameterized.\n             int argsSize = node.getTypeArguments().size();\n             for (int i = 0; i < argsSize; i++) {\n@@ -1164,7 +1165,9 @@ public J visitParameterizedType(ParameterizedTypeTree node, Space fmt) {\n                 expression = expression.withAfter(after);\n                 expressions.add(expression);\n             }\n-            return new J.ParameterizedType(randomId(), fmt, Markers.EMPTY, id, JContainer.build(expressions), typeMapping.type(node));\n+            JContainer<Expression> typeArgs = JContainer.build(expressions)\n+                    .withBefore(Space.build(spaceBeforeTypeParams, emptyList()));\n+            return new J.ParameterizedType(randomId(), fmt, Markers.EMPTY, id, typeArgs, typeMapping.type(node));\n         }\n     }\n }\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\nindex ec58680f309..9e12014f5c1 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\n@@ -2029,4 +2029,27 @@ interface Test {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5444\")\n+    void whitespaceInGenericTypesInJavadocTags() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+            import java.util.Optional;\n+\n+            public class Foo {\n+                private void bar(Optional<String> b) {}\n+\n+                /**\n+                 * This has an extra whitespace {@link #bar(Optional <String>)}\n+                 * This has 3 extra whitespaces {@link #bar(Optional   <String>)}\n+                 * This has no extra whitespace {@link #bar(Optional<String>)}\n+                 */\n+                public void foo() {}\n+            }\n+            \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5465",
    "pr_id": 5465,
    "issue_id": 5446,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Improve gradle dependency resolution/handling\n## What problem are you trying to solve?\nUp until the introduction of lockfiles we could \"decently\" resolve dependencies for gradle projects using the Maven classes. During the introduction of lockfiles we had some improvements of the transitive dependency gradle project marker but this only showed the gaps for gradle using the maven resolution even more. \n\nTogether with @shanman190 we decided to create this ticket to at least log the impact of not doing a gradle specific dependency resolution. I quote _the legend himself_:\n> We have made it a LONG way by only using the Maven-worldview. Given lockfiles are a Gradle specific feature, we have now kinda opened that door and have inadvertently raised this long known, but hidden behind the closed door of Gradle specific dependency resolution. Now that is the very question that I think we(larger collective) probably need to answer or write a ticket for.\n\nAt the moment, there are a few gaps that make gradle specific stuff hard like: \n- Complete dependency information\n  - Project (ie. Other projects of a multi module build)\n  - Ivy\n  - File/FileTree\n  - Attributes\n    - Platforms\n    - Variants\n    - Constrainted? Plugin managed? ...\n- Customized projects such as user specified paths, customized buildscript file name, ...\n- Dependency locking\n- gradle intra-project relationships (eg. a dependency on another module in same project)\n- ...\n\n(FEEL FREE TO EDIT TICKET DESCRIPTION TO ADD/EDIT!)\n\n## Describe the solution you'd like\nNothing just yet. But we need to identify, discuss, divide in subtickets and take up...",
    "issue_word_count": 246,
    "test_files_count": 1,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateDependencyLock.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/LockDependencyVersionsTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/LockDependencyVersionsTest.java"
    ],
    "base_commit": "35d4e3f319edc6039a2913e6ac30b77486c15da6",
    "head_commit": "10a4273590914789ec603b8948878e968e10abf5",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5465",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5465",
    "dockerfile": "",
    "pr_merged_at": "2025-05-22T00:34:28.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateDependencyLock.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateDependencyLock.java\nindex 08c08d1b14a..c0b6aa5ca07 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateDependencyLock.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateDependencyLock.java\n@@ -39,6 +39,12 @@\n @EqualsAndHashCode(callSuper = false)\n public class UpdateDependencyLock extends PlainTextVisitor<ExecutionContext> {\n \n+    /**\n+     * There is a shortcoming in  GradleProject model where we don't maintain the intra-project relationships.\n+     * Ultimately an improvement should be made to GradleProject model, but in the meantime work around it in the recipe\n+     */\n+    Set<GradleProject> modules;\n+\n     @Override\n     public boolean isAcceptable(SourceFile sourceFile, ExecutionContext executionContext) {\n         return sourceFile instanceof PlainText && sourceFile.getSourcePath().endsWith(\"gradle.lockfile\");\n@@ -65,15 +71,26 @@ public boolean isAcceptable(SourceFile sourceFile, ExecutionContext executionCon\n             return plainText;\n         }\n \n+        GradleProject project = gradleProject.get();\n+\n         Arrays.stream(text.split(\"\\n\")).forEach(lock -> {\n             if (isComment(lock)) {\n                 comments.add(lock);\n             } else {\n                 lockedConfigurations.addAll(parseLockedConfigurations(lock));\n+                parseLockedConfigurations(lock)\n+                        .forEach(lockedConf -> {\n+                            GradleDependencyConfiguration conf = project.getNameToConfiguration().get(lockedConf);\n+                            // we do not want to remove locks present in the lockfile which where previously locked but now not present anymore (e.g. by removing a plugin) as that would be a different recipe's task (e.g. CleanupDependencyLock)\n+                            if (conf == null || !conf.isCanBeResolved()) {\n+                                GroupArtifactVersion gav = parseLockedArtifact(lock);\n+                                if (gav != null) {\n+                                    lockedVersions.computeIfAbsent(gav, k -> new TreeSet<>()).add(lockedConf);\n+                                }\n+                            }\n+                        });\n             }\n         });\n-\n-        GradleProject project = gradleProject.get();\n         project.getConfigurations().stream()\n                 .filter(GradleDependencyConfiguration::isCanBeResolved)\n                 .filter(configuration -> lockedConfigurations.contains(configuration.getName()))\n@@ -83,8 +100,16 @@ public boolean isAcceptable(SourceFile sourceFile, ExecutionContext executionCon\n                     if (transitivelyResolvedDependencies.isEmpty()) {\n                         empty.add(configuration);\n                     } else {\n+                        boolean anyChanged = false;\n                         for (ResolvedDependency resolved : transitivelyResolvedDependencies) {\n+                            if (isDependencyOnAnotherModule(resolved, project)) {\n+                                continue;\n+                            }\n                             lockedVersions.computeIfAbsent(resolved.getGav().asGroupArtifactVersion(), k -> new TreeSet<>()).add(configuration);\n+                            anyChanged = true;\n+                        }\n+                        if (!anyChanged) {\n+                            empty.add(configuration);\n                         }\n                     }\n                 });\n@@ -133,6 +158,25 @@ private static boolean isComment(String entry) {\n         return entry.startsWith(\"# \");\n     }\n \n+    private boolean isDependencyOnAnotherModule(ResolvedDependency resolved, GradleProject project) {\n+        if (Objects.equals(project.getGroup(), resolved.getGroupId())) {\n+            return modules.stream().anyMatch(module -> resolved.getArtifactId().equals(module.getName()));\n+        }\n+        return false;\n+    }\n+\n+    private @Nullable GroupArtifactVersion parseLockedArtifact(String lock) {\n+        String[] parts = lock.split(\"=\");\n+        if (parts.length != 2) {\n+            return null;\n+        }\n+        String[] gavParts = parts[0].split(\":\");\n+        if (gavParts.length != 3) {\n+            return null;\n+        }\n+        return new GroupArtifactVersion(gavParts[0], gavParts[1], gavParts[2]);\n+    }\n+\n     private Set<String> parseLockedConfigurations(String lock) {\n         String[] parts = lock.split(\"=\");\n         if (parts.length != 2) {\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java\nindex 516ac615e46..2951901d086 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java\n@@ -51,7 +51,6 @@\n import org.openrewrite.semver.VersionComparator;\n \n import java.util.*;\n-import java.util.function.Function;\n \n import static java.util.Collections.*;\n \n@@ -135,6 +134,7 @@ public static class DependencyVersionState {\n         Map<GroupArtifact, Object> gaToNewVersion = new HashMap<>();\n \n         Map<String, Map<GroupArtifact, Set<String>>> configurationPerGAPerModule = new HashMap<>();\n+        Set<GradleProject> modules = new HashSet<>();\n     }\n \n     @Override\n@@ -159,8 +159,10 @@ public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {\n             @Override\n             public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n                 if (tree instanceof JavaSourceFile) {\n-                    gradleProject = tree.getMarkers().findFirst(GradleProject.class)\n-                            .orElse(null);\n+                    gradleProject = tree.getMarkers().findFirst(GradleProject.class).orElse(null);\n+                    if (gradleProject != null) {\n+                        acc.modules.add(gradleProject);\n+                    }\n                 }\n                 return super.visit(tree, ctx);\n             }\n@@ -397,7 +399,7 @@ public TreeVisitor<?, ExecutionContext> getVisitor(DependencyVersionState acc) {\n         return new TreeVisitor<Tree, ExecutionContext>() {\n             private final UpdateGradle updateGradle = new UpdateGradle(acc);\n             private final UpdateProperties updateProperties = new UpdateProperties(acc);\n-            private final UpdateDependencyLock updateLockFile = new UpdateDependencyLock();\n+            private final UpdateDependencyLock updateLockFile = new UpdateDependencyLock(acc.modules);\n \n             @Override\n             public boolean isAcceptable(SourceFile sf, ExecutionContext ctx) {\n@@ -881,17 +883,18 @@ public static GradleProject replaceVersion(GradleProject gp, ExecutionContext ct\n             for (GradleDependencyConfiguration gdc : nameToConfiguration.values()) {\n                 GradleDependencyConfiguration newGdc = gdc\n                         .withRequested(ListUtils.map(gdc.getRequested(), requested -> maybeUpdateDependency(requested, newRequested)))\n-                        .withDirectResolved(ListUtils.map(gdc.getDirectResolved(), resolved -> maybeUpdateResolvedDependency(resolved, newDep, new HashSet<>())));\n+                        .withDirectResolved(ListUtils.map(gdc.getDirectResolved(), resolved -> maybeUpdateResolvedDependency(gp, resolved, newDep, new HashSet<>())));\n                 if (hasBomWithoutDependencies(newDep)) {\n                     for (ResolvedManagedDependency resolvedDependency : resolvedPom.getDependencyManagement()) {\n-                        newGdc = newGdc.withDirectResolved(ListUtils.map(newGdc.getDirectResolved(), maybeUpdateManagedResolvedDependency(resolvedDependency.getGav())));\n+                        ResolvedGroupArtifactVersion resolvedGav = new ResolvedGroupArtifactVersion(null, resolvedDependency.getGroupId(), resolvedDependency.getArtifactId(), resolvedDependency.getVersion(), null);\n+                        newGdc = newGdc.withDirectResolved(ListUtils.map(newGdc.getDirectResolved(), resolved -> maybeUpdateManagedResolvedDependency(gp, resolved, resolvedGav, new HashSet<>())));\n                     }\n                 }\n                 anyChanged |= newGdc != gdc;\n                 newNameToConfiguration.put(newGdc.getName(), newGdc);\n             }\n             if (anyChanged) {\n-                gp = gp.withNameToConfiguration(newNameToConfiguration);\n+                return gp.withNameToConfiguration(newNameToConfiguration);\n             }\n         } catch (MavenDownloadingException | MavenDownloadingExceptions e) {\n             return gp;\n@@ -911,38 +914,71 @@ private static org.openrewrite.maven.tree.Dependency maybeUpdateDependency(\n         return dep;\n     }\n \n-    private static Function<ResolvedDependency, ResolvedDependency> maybeUpdateManagedResolvedDependency(GroupArtifactVersion gav) {\n-        return resolved -> {\n-            ResolvedDependency newResolvedDependency = ResolvedDependency.builder()\n-                    .gav(resolved.getGav().withGroupArtifact(gav.asGroupArtifact()).withVersion(gav.getVersion()))\n-                    .requested(resolved.getRequested())\n-                    .dependencies(resolved.getDependencies())\n-                    .build();\n-            return maybeUpdateResolvedDependency(resolved, newResolvedDependency, new HashSet<>());\n-        };\n+    private static ResolvedDependency maybeUpdateManagedResolvedDependency(\n+            GradleProject gp,\n+            ResolvedDependency dep,\n+            ResolvedGroupArtifactVersion gav,\n+            Set<ResolvedDependency> traversalHistory) {\n+        if (traversalHistory.contains(dep)) {\n+            return dep;\n+        }\n+        if (Objects.equals(dep.getGroupId(), gav.getGroupId()) && Objects.equals(dep.getArtifactId(), gav.getArtifactId()) && Objects.equals(dep.getVersion(), gav.getVersion())\n+                || wouldDowngrade(dep.getGav().asGroupArtifactVersion(), gav.asGroupArtifactVersion())) {\n+            return dep;\n+        }\n+        if (Objects.equals(dep.getGroupId(), gav.getGroupId()) && Objects.equals(dep.getArtifactId(), gav.getArtifactId())) {\n+            if (!isSpringPluginManaged(gp, dep)) {\n+                return dep.withGav(gav);\n+            }\n+        }\n+        traversalHistory.add(dep);\n+        return dep.withDependencies(ListUtils.map(dep.getDependencies(), d -> maybeUpdateManagedResolvedDependency(gp, d, gav, new HashSet<>(traversalHistory))));\n     }\n \n     private static ResolvedDependency maybeUpdateResolvedDependency(\n+            GradleProject gp,\n             ResolvedDependency dep,\n             ResolvedDependency newDep,\n             Set<ResolvedDependency> traversalHistory) {\n         if (traversalHistory.contains(dep)) {\n             return dep;\n         }\n-        if (Objects.equals(dep.getGroupId(), newDep.getGroupId()) && Objects.equals(dep.getArtifactId(), newDep.getArtifactId()) && Objects.equals(dep.getVersion(), newDep.getVersion())) {\n+        if (Objects.equals(dep.getGroupId(), newDep.getGroupId()) && Objects.equals(dep.getArtifactId(), newDep.getArtifactId()) && Objects.equals(dep.getVersion(), newDep.getVersion())\n+                || wouldDowngrade(dep.getGav().asGroupArtifactVersion(), newDep.getGav().asGroupArtifactVersion())) {\n             return dep;\n         }\n         if (Objects.equals(dep.getGroupId(), newDep.getGroupId()) && Objects.equals(dep.getArtifactId(), newDep.getArtifactId())) {\n+            if (isSpringPluginManaged(gp, newDep)) {\n+                //Spring plugin overwrites versions that are not set in constraints or similar blocks so the transitive dependencies would remain the same except for the current lib.\n+                return dep.withGav(newDep.getGav());\n+            }\n             return newDep;\n         }\n         traversalHistory.add(dep);\n-        return dep.withDependencies(ListUtils.map(dep.getDependencies(), d -> maybeUpdateResolvedDependency(d, newDep, new HashSet<>(traversalHistory))));\n+        return dep.withDependencies(ListUtils.map(dep.getDependencies(), d -> maybeUpdateResolvedDependency(gp, d, newDep, new HashSet<>(traversalHistory))));\n+    }\n+\n+    private static boolean wouldDowngrade(GroupArtifactVersion from, GroupArtifactVersion to) {\n+        if (from.getGroupId().equals(to.getGroupId()) && from.getArtifactId().equals(to.getArtifactId())) {\n+            Version fromVersion = new Version(from.getVersion());\n+            Version toVersion = new Version(to.getVersion());\n+            return fromVersion.compareTo(toVersion) > 0;\n+        }\n+        return false;\n+    }\n+\n+    private static boolean isSpringPluginManaged(GradleProject gp, ResolvedDependency newDep) {\n+        if (gp.getPlugins().stream().anyMatch(plugin -> \"io.spring.dependency-management\".equals(plugin.getId()))) {\n+            //TODO build a more complete list of dependencies that are managed by the spring plugin so that the sub-dependencies of the managed ones are not updated as these are most likely also managed by the plugin.\n+            return newDep.getGroupId().startsWith(\"org.springframework\");\n+        }\n+        return false;\n     }\n \n     // Some dependencies like jackson-bom do not publish a .module file and only contain dependencyManagement section.\n     // In that case we want to update the versions of the managed dependencies.\n     // If a module file is pushed, and it contains dependencies, we do not need to resolve using dependencyManagement as the bom will have dependencies on the overridden versions.\n-    private static boolean hasBomWithoutDependencies(ResolvedDependency dep) {\n+    static boolean hasBomWithoutDependencies(ResolvedDependency dep) {\n         if (\"bom\".equals(dep.getType()) && dep.getDependencies().isEmpty()) {\n             return true;\n         }\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\nindex d8407cd87b3..5a7572130e9 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\n@@ -175,6 +175,7 @@ public Validated<Object> validate() {\n     @Value\n     public static class DependencyVersionState {\n         Map<String, Map<GroupArtifact, Map<GradleDependencyConfiguration, String>>> updatesPerProject = new LinkedHashMap<>();\n+        Set<GradleProject> modules = new HashSet<>();\n     }\n \n     @Override\n@@ -200,6 +201,7 @@ public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {\n             public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n                 if (tree instanceof JavaSourceFile) {\n                     gradleProject = tree.getMarkers().findFirst(GradleProject.class).orElseThrow(() -> new IllegalStateException(\"Unable to find GradleProject marker.\"));\n+                    acc.modules.add(gradleProject);\n                     acc.updatesPerProject.putIfAbsent(getGradleProjectKey(gradleProject), new HashMap<>());\n \n                     DependencyVersionSelector versionSelector = new DependencyVersionSelector(metadataFailures, gradleProject, null);\n@@ -341,7 +343,7 @@ public TreeVisitor<?, ExecutionContext> getVisitor(DependencyVersionState acc) {\n         final DependencyMatcher dependencyMatcher = new DependencyMatcher(groupId, artifactId, null);\n         return Preconditions.check(new FindGradleProject(FindGradleProject.SearchCriteria.Marker), new TreeVisitor<Tree, ExecutionContext>() {\n             private final UpdateGradle updateGradle = new UpdateGradle(acc.getUpdatesPerProject());\n-            private final UpdateDependencyLock updateLockFile = new UpdateDependencyLock();\n+            private final UpdateDependencyLock updateLockFile = new UpdateDependencyLock(acc.modules);\n \n             @Override\n             public boolean isAcceptable(SourceFile sf, ExecutionContext ctx) {\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/LockDependencyVersionsTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/LockDependencyVersionsTest.java\nindex 1db0fb12472..d1d82cf9abd 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/LockDependencyVersionsTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/LockDependencyVersionsTest.java\n@@ -20,6 +20,8 @@\n import org.openrewrite.test.RecipeSpec;\n import org.openrewrite.test.RewriteTest;\n \n+import java.util.Collections;\n+\n import static org.openrewrite.gradle.Assertions.*;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n \n@@ -44,7 +46,7 @@ class LockDependencyVersionsTest implements RewriteTest {\n \n     @Override\n     public void defaults(RecipeSpec spec) {\n-        spec.recipe(RewriteTest.toRecipe(UpdateDependencyLock::new));\n+        spec.recipe(RewriteTest.toRecipe(() -> new UpdateDependencyLock(Collections.emptySet())));\n     }\n \n     @Test\n@@ -144,6 +146,8 @@ void onlyUpdateExistingConfigurations() {\n               # This file is expected to be part of source control.\n               org.apache.tomcat.embed:tomcat-embed-core:10.0.0-M1=compileClasspath,runtimeClasspath,testCompileClasspath,testRuntimeClasspath\n               org.apache.tomcat:tomcat-annotations-api:10.0.0-M1=compileClasspath,runtimeClasspath,testCompileClasspath,testRuntimeClasspath\n+              org.jacoco:org.jacoco.agent:0.8.12=jacocoAgent,jacocoAnt\n+              org.jacoco:org.jacoco.ant:0.8.12=jacocoAnt\n               empty=annotationProcessor,testAnnotationProcessor\n               \"\"\",\n             \"\"\"\n@@ -152,6 +156,8 @@ void onlyUpdateExistingConfigurations() {\n               # This file is expected to be part of source control.\n               org.apache.tomcat.embed:tomcat-embed-core:10.0.27=compileClasspath,runtimeClasspath,testCompileClasspath,testRuntimeClasspath\n               org.apache.tomcat:tomcat-annotations-api:10.0.27=compileClasspath,runtimeClasspath,testCompileClasspath,testRuntimeClasspath\n+              org.jacoco:org.jacoco.agent:0.8.12=jacocoAgent,jacocoAnt\n+              org.jacoco:org.jacoco.ant:0.8.12=jacocoAnt\n               empty=annotationProcessor,testAnnotationProcessor\n               \"\"\"\n           )\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5450",
    "pr_id": 5450,
    "issue_id": 983,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Add UsesJavaVersion visitor to filter applicability by target version of java\n",
    "issue_word_count": 11,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java"
    ],
    "base_commit": "8261b9038496cb446697b6b30fb82c470a247f02",
    "head_commit": "07047f978c0b71500eb268e51a3fb32f62a220be",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5450",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5450",
    "dockerfile": "",
    "pr_merged_at": "2025-05-27T19:50:12.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\nindex 00f94dab45d..e7c360952fa 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\n@@ -445,7 +445,7 @@ private void resolveParentDependenciesRecursively(List<Pom> pomAncestry) throws\n             }\n             Map<GroupArtifactScope, ResolvedManagedDependencyDepth> gaToNearest = dependencyManagement.stream()\n                     .collect(Collectors.toMap(\n-                            d -> new GroupArtifactScope(d.getGav().asGroupArtifact(), d.getScope(), d.getClassifier()),\n+                            d -> new GroupArtifactScope(d.getGav().asGroupArtifact(), d.getType(), d.getScope(), d.getClassifier()),\n                             d -> new ResolvedManagedDependencyDepth(d, 0),\n                             (x, y) -> y,\n                             LinkedHashMap::new));\n@@ -835,13 +835,44 @@ private void mergeProperties(Map<String, String> incomingProperties, Pom pom) {\n             }\n         }\n \n-        @Value\n         private class GroupArtifactScope {\n-            GroupArtifact ga;\n+            final GroupArtifact ga;\n+            @Nullable\n+            final String type; // Added type field to prevent different types from overwriting each other\n             @Nullable\n-            Scope scope;\n+            final Scope scope;\n             @Nullable\n-            String classifier;\n+            final String classifier;\n+            \n+            GroupArtifactScope(GroupArtifact ga, @Nullable String type, @Nullable Scope scope, @Nullable String classifier) {\n+                this.ga = ga;\n+                this.type = type;\n+                this.scope = scope;\n+                this.classifier = classifier;\n+            }\n+            \n+            @Override\n+            public boolean equals(Object o) {\n+                if (this == o) return true;\n+                if (!(o instanceof GroupArtifactScope)) return false;\n+                GroupArtifactScope that = (GroupArtifactScope) o;\n+                \n+                // Normalize type: null and \"jar\" are Maven-equivalent for dependency matching\n+                String normalizedThisType = this.type == null ? \"jar\" : this.type;\n+                String normalizedThatType = that.type == null ? \"jar\" : that.type;\n+                \n+                return Objects.equals(ga, that.ga) &&\n+                       Objects.equals(normalizedThisType, normalizedThatType) &&\n+                       Objects.equals(scope, that.scope) &&\n+                       Objects.equals(classifier, that.classifier);\n+            }\n+            \n+            @Override\n+            public int hashCode() {\n+                // Ensure consistent hashing with type normalization to maintain equals/hashCode contract\n+                String normalizedType = this.type == null ? \"jar\" : this.type;\n+                return Objects.hash(ga, normalizedType, scope, classifier);\n+            }\n         }\n \n         @Value\n@@ -871,13 +902,12 @@ private void mergeDependencyManagement(\n                             .withRequestedBom(d)\n                             .withBomGav(bom.getGav()));\n                     for (ResolvedManagedDependency managed : bomManaged) {\n-                        gaToNearest.compute(new GroupArtifactScope(managed.getGav().asGroupArtifact(), managed.getScope(), managed.getClassifier()), (ga, existing) -> {\n+                        gaToNearest.compute(new GroupArtifactScope(managed.getGav().asGroupArtifact(), managed.getType(), managed.getScope(), managed.getClassifier()), (ga, existing) -> {\n                             // Add one to the depth to account for the BOM which brings it in\n                             int depthPlusBom = depth + 1;\n-                            if (existing == null || existing.depth > depthPlusBom ||\n-                                    // If they have the same depth prefer the explicitly defined one\n-                                    (existing.depth == depthPlusBom && existing.getDependency().getBomGav() != null && managed.getBomGav() == null)) {\n-\n+                            if (existing == null || existing.depth > depthPlusBom) {\n+                                // New BOM entry wins if no existing entry or if it's closer (smaller depth).\n+                                // At same depth: existing entry wins (direct DM beats BOM, first BOM beats later BOM).\n                                 return new ResolvedManagedDependencyDepth(managed, depthPlusBom);\n                             }\n                             return existing;\n@@ -888,8 +918,10 @@ private void mergeDependencyManagement(\n                     MavenExecutionContextView.view(ctx)\n                             .getResolutionListener()\n                             .dependencyManagement(defined.withGav(getValues(defined.getGav())), pom);\n-                    gaToNearest.compute(new GroupArtifactScope(defined.getGav().asGroupArtifact(), defined.getScope() == null ? null : Scope.fromName(defined.getScope()), defined.getClassifier()), (ga, existing) -> {\n+                    gaToNearest.compute(new GroupArtifactScope(defined.getGav().asGroupArtifact(), getValue(defined.getType()), defined.getScope() == null ? null : Scope.fromName(getValue(defined.getScope())), getValue(defined.getClassifier())), (ga, existing) -> {\n                         if (existing == null || existing.depth > depth || (existing.depth == depth && existing.getDependency().getBomGav() != null)) {\n+                            // Direct DM entry wins over BOM entry at same depth (implements \"Parent Nearer Than BOM\" rule).\n+                            // This ensures parent POM's direct DM beats child POM's imported BOM DM.\n                             return new ResolvedManagedDependencyDepth(new ResolvedManagedDependency(\n                                     getValues(defined.getGav()),\n                                     defined.getScope() == null ? null : Scope.fromName(getValue(defined.getScope())),\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\nindex e8a22c4d08c..372defa080e 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\n@@ -4377,5 +4377,143 @@ void twoDependencyManagementEntries_twoDependencies() {\n               )\n             );\n         }\n+        @Issue(\"https://github.com/openrewrite/rewrite/issues/5402\")\n+        @Test\n+        void allDependencyManagementEntryVariants_allDependencyVariants() {\n+            rewriteRun(\n+              mavenProject(\n+                \"my-bom\",\n+                pomXml(\n+                  \"\"\"\n+                    <project>\n+                      <groupId>com.mycompany.app</groupId>\n+                      <artifactId>my-bom</artifactId>\n+                      <version>1</version>\n+                      <dependencyManagement>\n+                         <dependencies>\n+                             <dependency>\n+                                 <groupId>io.flux-capacitor</groupId>\n+                                 <artifactId>common</artifactId>\n+                                 <version>0.1148.0</version>\n+                             </dependency>\n+                             <dependency>\n+                                 <groupId>io.flux-capacitor</groupId>\n+                                 <artifactId>common</artifactId>\n+                                 <version>0.1148.0</version>\n+                                 <type>jar</type>\n+                             </dependency>\n+                             <dependency>\n+                                 <groupId>io.flux-capacitor</groupId>\n+                                 <artifactId>common</artifactId>\n+                                 <version>0.1148.0</version>\n+                                 <scope>compile</scope>\n+                             </dependency>\n+                             <dependency>\n+                                 <groupId>io.flux-capacitor</groupId>\n+                                 <artifactId>common</artifactId>\n+                                 <version>0.1148.0</version>\n+                                 <type>jar</type>\n+                                 <scope>compile</scope>\n+                             </dependency>\n+                             <dependency>\n+                                 <groupId>io.flux-capacitor</groupId>\n+                                 <artifactId>common</artifactId>\n+                                 <version>0.1148.0</version>\n+                                 <type>pom</type>\n+                             </dependency>\n+                             <dependency>\n+                                 <groupId>io.flux-capacitor</groupId>\n+                                 <artifactId>common</artifactId>\n+                                 <version>0.1148.0</version>\n+                                 <classifier>sources</classifier>\n+                             </dependency>\n+                             <dependency>\n+                                 <groupId>io.flux-capacitor</groupId>\n+                                 <artifactId>common</artifactId>\n+                                 <version>0.1148.0</version>\n+                                 <classifier>javadoc</classifier>\n+                             </dependency>\n+                             <dependency>\n+                                 <groupId>io.flux-capacitor</groupId>\n+                                 <artifactId>common</artifactId>\n+                                 <version>0.1148.0</version>\n+                                 <type>test-jar</type>\n+                                 <scope>test</scope>\n+                             </dependency>\n+                         </dependencies>\n+                      </dependencyManagement>\n+                    </project>\n+                    \"\"\"\n+                ),\n+                mavenProject(\n+                  \"my-app\",\n+                  pomXml(\n+                    \"\"\"\n+                      <project>\n+                        <groupId>com.mycompany.app</groupId>\n+                        <artifactId>my-app</artifactId>\n+                        <version>1</version>\n+                        <dependencyManagement>\n+                          <dependencies>\n+                            <dependency>\n+                              <groupId>com.mycompany.app</groupId>\n+                              <artifactId>my-bom</artifactId>\n+                              <version>1</version>\n+                              <scope>import</scope>\n+                              <type>pom</type>\n+                            </dependency>\n+                          </dependencies>\n+                        </dependencyManagement>\n+                        <dependencies>\n+                           <dependency>\n+                             <groupId>io.flux-capacitor</groupId>\n+                             <artifactId>common</artifactId>\n+                           </dependency>\n+                           <dependency>\n+                             <groupId>io.flux-capacitor</groupId>\n+                             <artifactId>common</artifactId>\n+                             <type>jar</type>\n+                           </dependency>\n+                           <dependency>\n+                             <groupId>io.flux-capacitor</groupId>\n+                             <artifactId>common</artifactId>\n+                             <scope>compile</scope>\n+                           </dependency>\n+                           <dependency>\n+                             <groupId>io.flux-capacitor</groupId>\n+                             <artifactId>common</artifactId>\n+                             <type>jar</type>\n+                             <scope>compile</scope>\n+                           </dependency>\n+                           <dependency>\n+                             <groupId>io.flux-capacitor</groupId>\n+                             <artifactId>common</artifactId>\n+                             <type>pom</type>\n+                           </dependency>\n+                           <dependency>\n+                             <groupId>io.flux-capacitor</groupId>\n+                             <artifactId>common</artifactId>\n+                             <classifier>sources</classifier>\n+                           </dependency>\n+                           <dependency>\n+                             <groupId>io.flux-capacitor</groupId>\n+                             <artifactId>common</artifactId>\n+                             <classifier>javadoc</classifier>\n+                           </dependency>\n+                           <dependency>\n+                             <groupId>io.flux-capacitor</groupId>\n+                             <artifactId>common</artifactId>\n+                             <type>test-jar</type>\n+                             <scope>test</scope>\n+                           </dependency>\n+                        </dependencies>\n+                      </project>\n+                      \"\"\"\n+                  )\n+                )\n+              )\n+            );\n+        }\n+\n     }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5417",
    "pr_id": 5417,
    "issue_id": 4983,
    "repo": "openrewrite/rewrite",
    "problem_statement": "A managed dependency with 'RELEASE' version is not resolved correctly\n`<version>RELEASE</version>` doesn't get resolved to the latest release.\n\nThe POM I have below works if I use it with `mvn:3.9.9`.\n\n## What version of OpenRewrite are you using?\n\n`main` branch, `rewrite-maven` module\n\n## How are you running OpenRewrite?\n\nIDE\n\n## What is the smallest, simplest way to reproduce the problem?\n\nAdd the following to `MavenParserTest`:\n\n```java\n    @Test\n    @DisplayName(\"Using RELEASE for GAV version in dependency management\")\n    void releaseInDepMgmt() {\n        rewriteRun(\n          pomXml(\n            \"\"\"\n              <project>\n                <groupId>com.mycompany.app</groupId>\n                <artifactId>my-app</artifactId>\n                <version>1</version>\n                \n                <dependencyManagement>\n                  <dependencies>\n                     <dependency>\n                      <groupId>org.springframework.boot</groupId>\n                      <artifactId>spring-boot-dependencies</artifactId>\n                      <version>RELEASE</version>\n                      <type>pom</type>\n                      <scope>import</scope>\n                    </dependency>\n                  </dependencies>\n                </dependencyManagement>\n                <dependencies>\n                  <dependency>\n                    <groupId>org.junit.jupiter</groupId>\n                    <artifactId>junit-jupiter</artifactId>\n                  </dependency>\n                </dependencies>\n              </project>\n              \"\"\"\n          )\n        );\n    }\n```\n\n## What did you see instead?\n\nI expected no error, but got a failing test:\n\n```\nCaused by: org.openrewrite.maven.MavenDownloadingException: org.springframework.boot:spring-boot-dependencies:RELEASE failed. Unable to download POM: org.springframework.boot:spring-boot-dependencies:RELEASE. Tried repositories:\nhttps://repo.maven.apache.org/maven2: HTTP 404\n\tat org.openrewrite.maven.internal.MavenPomDownloader.download(MavenPomDownloader.java:660)\n\tat org.openrewrite.maven.tree.ResolvedPom$Resolver.mergeDependencyManagement(ResolvedPom.java:812)\n\tat org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentDependenciesRecursively(ResolvedPom.java:445)\n\tat org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentsRecursively(ResolvedPom.java:397)\n\tat org.openrewrite.maven.tree.ResolvedPom$Resolver.resolve(ResolvedPom.java:368)\n\tat org.openrewrite.maven.tree.ResolvedPom.resolve(ResolvedPom.java:182)\n\tat org.openrewrite.maven.tree.Pom.resolve(Pom.java:193)\n\tat org.openrewrite.maven.tree.Pom.resolve(Pom.java:175)\n\tat org.openrewrite.maven.MavenParser.parseInputs(MavenParser.java:113)\n\t... 7 more\n```\n\n",
    "issue_word_count": 280,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java"
    ],
    "base_commit": "d17fc1d218934b70ed01d60b4b46f2b22a33be79",
    "head_commit": "10c08aa40d893bd5fada672912726f3492cb6a94",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5417",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5417",
    "dockerfile": "",
    "pr_merged_at": "2025-05-15T12:08:25.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\nindex 6b002b2f373..9c5554ab3a3 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\n@@ -68,6 +68,9 @@ public class MavenPomDownloader {\n     private static final Pattern SNAPSHOT_TIMESTAMP = Pattern.compile(\"^(.*-)?([0-9]{8}\\\\.[0-9]{6}-[0-9]+)$\");\n \n     private static final String SNAPSHOT = \"SNAPSHOT\";\n+    private static final String LATEST = \"LATEST\";\n+    private static final String RELEASE = \"RELEASE\";\n+    private static final List<String> NAMED_VERSIONS = Arrays.asList(LATEST, RELEASE);\n \n \n     private final MavenPomCache mavenCache;\n@@ -259,7 +262,7 @@ public MavenMetadata downloadMetadata(GroupArtifactVersion gav, @Nullable Resolv\n                     String baseUri = repo.getUri() + (repo.getUri().endsWith(\"/\") ? \"\" : \"/\") +\n                                      requireNonNull(gav.getGroupId()).replace('.', '/') + '/' +\n                                      gav.getArtifactId() + '/' +\n-                                     (gav.getVersion() == null ? \"\" : gav.getVersion() + '/');\n+                                     (gav.getVersion() == null || NAMED_VERSIONS.contains(gav.getVersion().toUpperCase()) ? \"\" : gav.getVersion() + '/');\n \n                     if (\"file\".equals(scheme)) {\n                         // A maven repository can be expressed as a URI with a file scheme\n@@ -534,8 +537,9 @@ public Pom download(GroupArtifactVersion gav,\n         Timer.Builder timer = Timer.builder(\"rewrite.maven.download\").tag(\"type\", \"pom\");\n \n         Map<MavenRepository, String> repositoryResponses = new LinkedHashMap<>();\n-        String versionMaybeDatedSnapshot = datedSnapshotVersion(gav, containingPom, repositories, ctx);\n         GroupArtifactVersion originalGav = gav;\n+        gav = resolveNamedVersion(gav, containingPom, repositories, ctx);\n+        String versionMaybeDatedSnapshot = datedSnapshotVersion(gav, containingPom, repositories, ctx);\n         gav = handleSnapshotTimestampVersion(gav);\n         List<String> uris = new ArrayList<>();\n \n@@ -755,6 +759,29 @@ private GroupArtifactVersion handleSnapshotTimestampVersion(GroupArtifactVersion\n         return gav.getVersion();\n     }\n \n+    private GroupArtifactVersion resolveNamedVersion(GroupArtifactVersion gav, @Nullable ResolvedPom containingPom, List<MavenRepository> repositories, ExecutionContext ctx) {\n+        if (gav.getVersion() == null) {\n+            return gav;\n+        }\n+        String version = gav.getVersion().toUpperCase();\n+        if (NAMED_VERSIONS.contains(version)) {\n+            MavenMetadata mavenMetadata;\n+            try {\n+                mavenMetadata = downloadMetadata(gav, containingPom, repositories);\n+            } catch (MavenDownloadingException e) {\n+                //This can happen if the artifact only exists in the local maven cache. In this case, just return the original\n+                return gav;\n+            }\n+\n+            if (RELEASE.equals(version)) {\n+                return gav.withVersion(mavenMetadata.getVersioning().getRelease());\n+            } else if (LATEST.equals(version)) {\n+                return gav.withVersion(mavenMetadata.getVersioning().getLatest());\n+            }\n+        }\n+        return gav;\n+    }\n+\n     Iterable<MavenRepository> distinctNormalizedRepositories(\n             List<MavenRepository> repositories,\n             @Nullable ResolvedPom containingPom,\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\nindex 33603efdcd8..d4f343a1790 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\n@@ -28,6 +28,8 @@\n import org.junit.jupiter.api.DisplayName;\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n import org.openrewrite.*;\n import org.openrewrite.maven.http.OkHttpSender;\n import org.openrewrite.maven.internal.MavenParsingException;\n@@ -4000,4 +4002,39 @@ void jaxbRuntime() {\n           )\n         );\n     }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"latest\", \"release\"})\n+    void latestOrReleaseVersionInDependencyManagement(String version) {\n+        rewriteRun(\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+              \n+                <dependencyManagement>\n+                  <dependencies>\n+                     <dependency>\n+                      <groupId>org.springframework.boot</groupId>\n+                      <artifactId>spring-boot-dependencies</artifactId>\n+                      <version>%s</version>\n+                      <type>pom</type>\n+                      <scope>import</scope>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.junit.jupiter</groupId>\n+                    <artifactId>junit-jupiter</artifactId>\n+                  </dependency>\n+                </dependencies>\n+              </project>\n+              \"\"\".formatted(version)\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5398",
    "pr_id": 5398,
    "issue_id": 5334,
    "repo": "openrewrite/rewrite",
    "problem_statement": "PropertyPlaceholderHelper doesn't handle properties without separation\n## What version of OpenRewrite are you using?\nI am using\n\n- rewrite-core v8.50.2\n\n## How are you running OpenRewrite?\nI am writing a Java recipe.\n\n## What is the smallest, simplest way to reproduce the problem?\nRemove the space in the existing single PropertyPlaceholderHelperTest test case\n```java\nclass PropertyPlaceholderHelperTest {\n\t@Test\n\tvoid noSpace() {\n\t\tvar helper = new PropertyPlaceholderHelper(\"%%{\", \"}\", null);\n\t\tvar s = helper.replacePlaceholders(\"%%{k1}%%{k2}\", k -> switch (k) {\n\t\t\tcase \"k1\" -> \"hi\";\n\t\t\tcase \"k2\" -> \"jon\";\n\t\t\tdefault -> throw new UnsupportedOperationException();\n\t\t});\n\t\tassertThat(s).isEqualTo(\"hijon\");\n\t}\n}\n```\n\n## What did you expect to see?\n`\"hijon\"`\n\n## What did you see instead?\n`\"hi%%{k2}\"`\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\nI am unfortunately unable to do so.",
    "issue_word_count": 128,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/internal/PropertyPlaceholderHelper.java",
      "rewrite-core/src/test/java/org/openrewrite/internal/PropertyPlaceholderHelperTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-core/src/test/java/org/openrewrite/internal/PropertyPlaceholderHelperTest.java"
    ],
    "base_commit": "f358c66b101c3673223f8b84948d264e9dc2c8e6",
    "head_commit": "babe2e1ed374ee2908ea281a7c7dd7da2aede845",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5398",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5398",
    "dockerfile": "",
    "pr_merged_at": "2025-05-07T20:39:40.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/internal/PropertyPlaceholderHelper.java b/rewrite-core/src/main/java/org/openrewrite/internal/PropertyPlaceholderHelper.java\nindex a0b61904c39..049768f645b 100644\n--- a/rewrite-core/src/main/java/org/openrewrite/internal/PropertyPlaceholderHelper.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/internal/PropertyPlaceholderHelper.java\n@@ -121,7 +121,7 @@ protected String parseStringValue(String value, Function<String, @Nullable Strin\n                 }\n \n                 // Proceed with unprocessed value.\n-                startIndex = result.indexOf(placeholderPrefix, endIndex + placeholderSuffix.length());\n+                startIndex = result.indexOf(placeholderPrefix, endIndex);\n                 visitedPlaceholders.remove(originalPlaceholder);\n             } else {\n                 startIndex = -1;\n",
    "test_patch": "diff --git a/rewrite-core/src/test/java/org/openrewrite/internal/PropertyPlaceholderHelperTest.java b/rewrite-core/src/test/java/org/openrewrite/internal/PropertyPlaceholderHelperTest.java\nindex 532bdd46c93..380fa9f14f0 100644\n--- a/rewrite-core/src/test/java/org/openrewrite/internal/PropertyPlaceholderHelperTest.java\n+++ b/rewrite-core/src/test/java/org/openrewrite/internal/PropertyPlaceholderHelperTest.java\n@@ -22,7 +22,40 @@\n class PropertyPlaceholderHelperTest {\n \n     @Test\n-    void dashed() {\n+    void nested() {\n+        var helper = new PropertyPlaceholderHelper(\"%%{\", \"}\", null);\n+        var s = helper.replacePlaceholders(\"%%{%%{k1}}\", k -> switch (k) {\n+            case \"k1\" -> \"k2\";\n+            case \"k2\" -> \"jon\";\n+            default -> throw new UnsupportedOperationException();\n+        });\n+        assertThat(s).isEqualTo(\"jon\");\n+    }\n+\n+    @Test\n+    void notOnlyPlaceholders() {\n+        var helper = new PropertyPlaceholderHelper(\"%%{\", \"}\", null);\n+        var s = helper.replacePlaceholders(\"Oh, %%{k1} there %%{k2}!\", k -> switch (k) {\n+            case \"k1\" -> \"hi\";\n+            case \"k2\" -> \"jon\";\n+            default -> throw new UnsupportedOperationException();\n+        });\n+        assertThat(s).isEqualTo(\"Oh, hi there jon!\");\n+    }\n+\n+    @Test\n+    void dashedSeparation() {\n+        var helper = new PropertyPlaceholderHelper(\"%%{\", \"}\", null);\n+        var s = helper.replacePlaceholders(\"%%{k1}-%%{k2}\", k -> switch (k) {\n+            case \"k1\" -> \"hi\";\n+            case \"k2\" -> \"jon\";\n+            default -> throw new UnsupportedOperationException();\n+        });\n+        assertThat(s).isEqualTo(\"hi-jon\");\n+    }\n+\n+    @Test\n+    void spaceSeparation() {\n         var helper = new PropertyPlaceholderHelper(\"%%{\", \"}\", null);\n         var s = helper.replacePlaceholders(\"%%{k1} %%{k2}\", k -> switch (k) {\n             case \"k1\" -> \"hi\";\n@@ -31,4 +64,39 @@ void dashed() {\n         });\n         assertThat(s).isEqualTo(\"hi jon\");\n     }\n+\n+    @Test\n+    void noSeparation() {\n+        var helper = new PropertyPlaceholderHelper(\"%%{\", \"}\", null);\n+        var s = helper.replacePlaceholders(\"%%{k1}%%{k2}\", k -> switch (k) {\n+            case \"k1\" -> \"hi\";\n+            case \"k2\" -> \"jon\";\n+            default -> throw new UnsupportedOperationException();\n+        });\n+        assertThat(s).isEqualTo(\"hijon\");\n+    }\n+\n+    @Test\n+    void withValueSeparatorAndValueReplacement() {\n+        var helper = new PropertyPlaceholderHelper(\"%%{\", \"}\", \",\");\n+        var s = helper.replacePlaceholders(\"%%{k1,oh} %%{k2}\", k -> switch (k) {\n+            case \"k1\" -> \"hi\";\n+            case \"k2\" -> \"jon\";\n+            // Note: this needs to not throw an exception because there won't be a match for \"k1,oh\" as a placeholder\n+            default -> null;\n+        });\n+        assertThat(s).isEqualTo(\"hi jon\");\n+    }\n+\n+    @Test\n+    void withValueSeparatorAndNullReplacement() {\n+        var helper = new PropertyPlaceholderHelper(\"%%{\", \"}\", \",\");\n+        var s = helper.replacePlaceholders(\"%%{k1,oh}%%{k2}\", k -> switch (k) {\n+            case \"k1\" -> null;\n+            case \"k2\" -> \"jon\";\n+            // Note: this needs to not throw an exception because there won't be a match for \"k1,oh\" as a placeholder\n+            default -> null;\n+        });\n+        assertThat(s).isEqualTo(\"ohjon\");\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5394",
    "pr_id": 5394,
    "issue_id": 1150,
    "repo": "openrewrite/rewrite",
    "problem_statement": "XmlParser throws NPE when parsing a DTC without an externalId\nAlso got something similar while executing the same version of rewrite plugin against https://github.com/jhipster/jhipster-sample-app:\r\n```log\r\n[INFO] --- rewrite-maven-plugin:4.14.1:dryRun (default-cli) @ jhipster-sample-application ---\r\n[INFO] Using active recipe(s) [org.openrewrite.java.format.RemoveTrailingWhitespace]\r\n[INFO] Using active styles(s) []\r\n[INFO] Validating active recipes...\r\n[INFO] Parsing Java main files...\r\n[ERROR] Error parsing\r\njava.lang.IllegalStateException: /tmp/jhipster-sample-app/src/main/resources/logback-spring.xml null\r\n    at org.openrewrite.xml.XmlParser.lambda$parseInputs$0 (XmlParser.java:63)\r\n    at java.util.stream.ReferencePipeline$3$1.accept (ReferencePipeline.java:195)\r\n    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining (ArrayList.java:1655)\r\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:484)\r\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:474)\r\n    at java.util.stream.ReduceOps$ReduceOp.evaluateSequential (ReduceOps.java:913)\r\n    at java.util.stream.AbstractPipeline.evaluate (AbstractPipeline.java:234)\r\n    at java.util.stream.ReferencePipeline.collect (ReferencePipeline.java:578)\r\n    at org.openrewrite.xml.XmlParser.parseInputs (XmlParser.java:68)\r\n    at org.openrewrite.Parser.parse (Parser.java:39)\r\n    at org.openrewrite.maven.ResourceParser.parseSourceFiles (ResourceParser.java:78)\r\n    at org.openrewrite.maven.ResourceParser.parse (ResourceParser.java:40)\r\n    at org.openrewrite.maven.MavenMojoProjectParser.listSourceFiles (MavenMojoProjectParser.java:178)\r\n    at org.openrewrite.maven.AbstractRewriteMojo.listResults (AbstractRewriteMojo.java:171)\r\n    at org.openrewrite.maven.RewriteDryRunMojo.execute (RewriteDryRunMojo.java:48)\r\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:957)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:289)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:193)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:566)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347)\r\n    at org.codehaus.classworlds.Launcher.main (Launcher.java:47)\r\nCaused by: java.lang.NullPointerException\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.lambda$visitDoctypedecl$16 (XmlParserVisitor.java:251)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.convert (XmlParserVisitor.java:291)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.lambda$visitDoctypedecl$19 (XmlParserVisitor.java:251)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.convert (XmlParserVisitor.java:291)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.visitDoctypedecl (XmlParserVisitor.java:248)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.visitDoctypedecl (XmlParserVisitor.java:36)\r\n    at org.openrewrite.xml.internal.grammar.XMLParser$DoctypedeclContext.accept (XMLParser.java:417)\r\n    at org.antlr.v4.runtime.tree.AbstractParseTreeVisitor.visitChildren (AbstractParseTreeVisitor.java:46)\r\n    at org.openrewrite.xml.internal.grammar.XMLParserBaseVisitor.visitMisc (XMLParserBaseVisitor.java:56)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.visitMisc (XmlParserVisitor.java:80)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.visitMisc (XmlParserVisitor.java:36)\r\n    at org.openrewrite.xml.internal.grammar.XMLParser$MiscContext.accept (XMLParser.java:340)\r\n    at org.antlr.v4.runtime.tree.AbstractParseTreeVisitor.visit (AbstractParseTreeVisitor.java:18)\r\n    at java.util.stream.ReferencePipeline$3$1.accept (ReferencePipeline.java:195)\r\n    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining (ArrayList.java:1655)\r\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:484)\r\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:474)\r\n    at java.util.stream.ReduceOps$ReduceOp.evaluateSequential (ReduceOps.java:913)\r\n    at java.util.stream.AbstractPipeline.evaluate (AbstractPipeline.java:234)\r\n    at java.util.stream.ReferencePipeline.collect (ReferencePipeline.java:578)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.lambda$visitProlog$1 (XmlParserVisitor.java:68)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.convert (XmlParserVisitor.java:291)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.visitProlog (XmlParserVisitor.java:63)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.lambda$visitDocument$0 (XmlParserVisitor.java:55)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.convert (XmlParserVisitor.java:291)\r\n    at org.openrewrite.xml.internal.XmlParserVisitor.visitDocument (XmlParserVisitor.java:50)\r\n    at org.openrewrite.xml.XmlParser.lambda$parseInputs$0 (XmlParser.java:58)\r\n    at java.util.stream.ReferencePipeline$3$1.accept (ReferencePipeline.java:195)\r\n    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining (ArrayList.java:1655)\r\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:484)\r\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:474)\r\n    at java.util.stream.ReduceOps$ReduceOp.evaluateSequential (ReduceOps.java:913)\r\n    at java.util.stream.AbstractPipeline.evaluate (AbstractPipeline.java:234)\r\n    at java.util.stream.ReferencePipeline.collect (ReferencePipeline.java:578)\r\n    at org.openrewrite.xml.XmlParser.parseInputs (XmlParser.java:68)\r\n    at org.openrewrite.Parser.parse (Parser.java:39)\r\n    at org.openrewrite.maven.ResourceParser.parseSourceFiles (ResourceParser.java:78)\r\n    at org.openrewrite.maven.ResourceParser.parse (ResourceParser.java:40)\r\n    at org.openrewrite.maven.MavenMojoProjectParser.listSourceFiles (MavenMojoProjectParser.java:178)\r\n    at org.openrewrite.maven.AbstractRewriteMojo.listResults (AbstractRewriteMojo.java:171)\r\n    at org.openrewrite.maven.RewriteDryRunMojo.execute (RewriteDryRunMojo.java:48)\r\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)\r\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)\r\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)\r\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)\r\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)\r\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)\r\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)\r\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:957)\r\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:289)\r\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:193)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)\r\n    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)\r\n    at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke (Method.java:566)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)\r\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347)\r\n    at org.codehaus.classworlds.Launcher.main (Launcher.java:47)\r\n```\r\nXML file is https://github.com/jhipster/jhipster-sample-app/blob/main/src/main/resources/logback-spring.xml\r\n\r\n_Originally posted by @murdos in https://github.com/openrewrite/rewrite/issues/1136#issuecomment-949691160_",
    "issue_word_count": 1139,
    "test_files_count": 5,
    "non_test_files_count": 10,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsAssertions.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypesTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateGenericsTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateMatchTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/RenameVariableTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/JavaTemplateSemanticallyEqual.java",
      "rewrite-java/src/main/java/org/openrewrite/java/RenameVariable.java",
      "rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java",
      "rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java",
      "rewrite-java/src/main/java/org/openrewrite/java/tree/Types.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypesTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateGenericsTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateMatchTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/RenameVariableTest.java"
    ],
    "base_commit": "1728a9436d3495fa5ea4389a014eea36c38300ae",
    "head_commit": "1ad91db46663c2af6a1a673cf6387c66cbe5a8ff",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5394",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5394",
    "dockerfile": "",
    "pr_merged_at": "2025-05-07T12:10:12.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\nindex 537faaeff9d..ac3fa9c4771 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\n@@ -740,7 +740,7 @@ private boolean paramTypeMatches(JavaType parameterType, Type javadocType) {\n     private static boolean paramTypeMatches(JavaType parameterType, JavaType mappedJavadocType) {\n         if (parameterType instanceof JavaType.Array && mappedJavadocType instanceof JavaType.Array) {\n             if (((JavaType.Array) parameterType).getElemType() instanceof JavaType.Primitive) {\n-                return TypeUtils.isAssignableTo(parameterType, mappedJavadocType);\n+                return TypeUtils.isAssignableTo(parameterType, mappedJavadocType, TypeUtils.TypePosition.In);\n             }\n             return paramTypeMatches(((JavaType.Array) parameterType).getElemType(), ((JavaType.Array) mappedJavadocType).getElemType());\n         } else if (parameterType instanceof JavaType.GenericTypeVariable && !((JavaType.GenericTypeVariable) parameterType).getBounds().isEmpty()) {\n@@ -750,7 +750,7 @@ private static boolean paramTypeMatches(JavaType parameterType, JavaType mappedJ\n         } else if (parameterType instanceof JavaType.Parameterized && !(mappedJavadocType instanceof JavaType.Parameterized)) {\n             return paramTypeMatches(((JavaType.Parameterized) parameterType).getType(), mappedJavadocType);\n         }\n-        return TypeUtils.isAssignableTo(parameterType, mappedJavadocType);\n+        return TypeUtils.isAssignableTo(parameterType, mappedJavadocType, TypeUtils.TypePosition.In);\n     }\n \n     private JavaType.@Nullable Variable fieldReferenceType(DCTree.DCReference ref, @Nullable JavaType type) {\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\nindex 85723081aec..dd6c4c8d43f 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\n@@ -743,7 +743,7 @@ private boolean paramTypeMatches(JavaType parameterType, Type javadocType) {\n     private static boolean paramTypeMatches(JavaType parameterType, JavaType mappedJavadocType) {\n         if (parameterType instanceof JavaType.Array && mappedJavadocType instanceof JavaType.Array) {\n             if (((JavaType.Array) parameterType).getElemType() instanceof JavaType.Primitive) {\n-                return TypeUtils.isAssignableTo(parameterType, mappedJavadocType);\n+                return TypeUtils.isAssignableTo(parameterType, mappedJavadocType, TypeUtils.TypePosition.In);\n             }\n             return paramTypeMatches(((JavaType.Array) parameterType).getElemType(), ((JavaType.Array) mappedJavadocType).getElemType());\n         } else if (parameterType instanceof JavaType.GenericTypeVariable && !((JavaType.GenericTypeVariable) parameterType).getBounds().isEmpty()) {\n@@ -753,7 +753,7 @@ private static boolean paramTypeMatches(JavaType parameterType, JavaType mappedJ\n         } else if (parameterType instanceof JavaType.Parameterized && !(mappedJavadocType instanceof JavaType.Parameterized)) {\n             return paramTypeMatches(((JavaType.Parameterized) parameterType).getType(), mappedJavadocType);\n         }\n-        return TypeUtils.isAssignableTo(parameterType, mappedJavadocType);\n+        return TypeUtils.isAssignableTo(parameterType, mappedJavadocType, TypeUtils.TypePosition.In);\n     }\n \n     private JavaType.@Nullable Variable fieldReferenceType(DCTree.DCReference ref, @Nullable JavaType type) {\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\nindex aa00513c42f..eb9074fc58a 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\n@@ -743,7 +743,7 @@ private boolean paramTypeMatches(JavaType parameterType, Type javadocType) {\n     private static boolean paramTypeMatches(JavaType parameterType, JavaType mappedJavadocType) {\n         if (parameterType instanceof JavaType.Array && mappedJavadocType instanceof JavaType.Array) {\n             if (((JavaType.Array) parameterType).getElemType() instanceof JavaType.Primitive) {\n-                return TypeUtils.isAssignableTo(parameterType, mappedJavadocType);\n+                return TypeUtils.isAssignableTo(parameterType, mappedJavadocType, TypeUtils.TypePosition.In);\n             }\n             return paramTypeMatches(((JavaType.Array) parameterType).getElemType(), ((JavaType.Array) mappedJavadocType).getElemType());\n         } else if (parameterType instanceof JavaType.GenericTypeVariable && !((JavaType.GenericTypeVariable) parameterType).getBounds().isEmpty()) {\n@@ -753,7 +753,7 @@ private static boolean paramTypeMatches(JavaType parameterType, JavaType mappedJ\n         } else if (parameterType instanceof JavaType.Parameterized && !(mappedJavadocType instanceof JavaType.Parameterized)) {\n             return paramTypeMatches(((JavaType.Parameterized) parameterType).getType(), mappedJavadocType);\n         }\n-        return TypeUtils.isAssignableTo(parameterType, mappedJavadocType);\n+        return TypeUtils.isAssignableTo(parameterType, mappedJavadocType, TypeUtils.TypePosition.In);\n     }\n \n     private JavaType.@Nullable Variable fieldReferenceType(DCTree.DCReference ref, @Nullable JavaType type) {\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\nindex 72eee4d3f01..004cc16f982 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\n@@ -700,7 +700,7 @@ private boolean paramTypeMatches(JavaType parameterType, Type javadocType) {\n     private static boolean paramTypeMatches(JavaType parameterType, JavaType mappedJavadocType) {\n         if (parameterType instanceof JavaType.Array && mappedJavadocType instanceof JavaType.Array) {\n             if (((JavaType.Array) parameterType).getElemType() instanceof JavaType.Primitive) {\n-                return TypeUtils.isAssignableTo(parameterType, mappedJavadocType);\n+                return TypeUtils.isAssignableTo(parameterType, mappedJavadocType, TypeUtils.TypePosition.In);\n             }\n             return paramTypeMatches(((JavaType.Array) parameterType).getElemType(), ((JavaType.Array) mappedJavadocType).getElemType());\n         } else if (parameterType instanceof JavaType.GenericTypeVariable && !((JavaType.GenericTypeVariable) parameterType).getBounds().isEmpty()) {\n@@ -710,7 +710,7 @@ private static boolean paramTypeMatches(JavaType parameterType, JavaType mappedJ\n         } else if (parameterType instanceof JavaType.Parameterized && !(mappedJavadocType instanceof JavaType.Parameterized)) {\n             return paramTypeMatches(((JavaType.Parameterized) parameterType).getType(), mappedJavadocType);\n         }\n-        return TypeUtils.isAssignableTo(parameterType, mappedJavadocType);\n+        return TypeUtils.isAssignableTo(parameterType, mappedJavadocType, TypeUtils.TypePosition.In);\n     }\n \n     private JavaType.@Nullable Variable fieldReferenceType(DCTree.DCReference ref, @Nullable JavaType type) {\n\ndiff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsAssertions.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsAssertions.java\nindex 487dc200254..24eb0db353b 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsAssertions.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsAssertions.java\n@@ -66,7 +66,7 @@ public BooleanAssert isAssignableTo(String to, String from) {\n     public BooleanAssert isAssignableTo(String to, String from, boolean capture) {\n         JavaType toType = getFirst(to);\n         JavaType fromType = getLast(from);\n-        return assertThat(new Types(capture).isAssignableTo(toType, fromType))\n+        return assertThat(TypeUtils.isAssignableTo(toType, fromType))\n           .describedAs(\"isAssignableTo(%s, %s, %s)\", to, from, capture);\n     }\n \n@@ -77,7 +77,7 @@ public BooleanAssert isOfType(String to, String from) {\n     public BooleanAssert isOfType(String to, String from, boolean capture) {\n         JavaType toType = getFirst(to);\n         JavaType fromType = getLast(from);\n-        return assertThat(new Types(capture).isOfType(toType, fromType))\n+        return assertThat(TypeUtils.isOfType(toType, fromType))\n           .describedAs(\"isOfType(%s, %s, %s)\", to, from, capture);\n     }\n \n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavaTemplateSemanticallyEqual.java b/rewrite-java/src/main/java/org/openrewrite/java/JavaTemplateSemanticallyEqual.java\nindex edfe3ddc54c..48408eac9c9 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavaTemplateSemanticallyEqual.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavaTemplateSemanticallyEqual.java\n@@ -136,7 +136,6 @@ private static TemplateMatchResult matchTemplate(J templateTree, Cursor cursor)\n     @SuppressWarnings(\"ConstantConditions\")\n     private static class JavaTemplateSemanticallyEqualVisitor extends SemanticallyEqualVisitor {\n         final Map<J, String> matchedParameters = new LinkedHashMap<>();\n-        final Types types = new Types(true);\n \n         public JavaTemplateSemanticallyEqualVisitor() {\n             super(true);\n@@ -159,7 +158,7 @@ private boolean matchTemplateParameterPlaceholder(J.Empty empty, J j) {\n                 }\n \n                 if (TypeUtils.isObject(marker.getType()) ||\n-                    isAssignableTo(marker.getType(), ((TypedTree) j).getType())) {\n+                    TypeUtils.isAssignableTo(marker.getType(), ((TypedTree) j).getType())) {\n                     registerMatch(j, marker.getName());\n                     return true;\n                 }\n@@ -196,15 +195,5 @@ private static boolean isTemplateParameterPlaceholder(J.Empty empty) {\n             Markers markers = empty.getMarkers();\n             return markers.getMarkers().size() == 1 && markers.getMarkers().get(0) instanceof TemplateParameter;\n         }\n-\n-        @Override\n-        protected boolean isOfType(@Nullable JavaType target, @Nullable JavaType source) {\n-            return target == source || isAssignableTo(target, source);\n-        }\n-\n-        @Override\n-        protected boolean isAssignableTo(@Nullable JavaType target, @Nullable JavaType source) {\n-            return types.isAssignableTo(target, source);\n-        }\n     }\n }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/RenameVariable.java b/rewrite-java/src/main/java/org/openrewrite/java/RenameVariable.java\nindex abe78ed768a..b54bd34379c 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/RenameVariable.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/RenameVariable.java\n@@ -90,11 +90,7 @@ public J.Identifier visitIdentifier(J.Identifier ident, P p) {\n             }\n             Cursor parent = getCursor().getParentTreeCursor();\n             if (ident.getSimpleName().equals(renameVariable.getSimpleName())) {\n-                if (ident.getFieldType() != null && TypeUtils.isOfType(ident.getFieldType(), renameVariable.getVariableType())) {\n-                    parent.putMessage(\"renamed\", true);\n-                    return ident.withFieldType(ident.getFieldType().withName(newName)).withSimpleName(newName);\n-                } else if (parent.getValue() instanceof J.FieldAccess &&\n-                        !ident.equals(((J.FieldAccess) parent.getValue()).getTarget())) {\n+                if (parent.getValue() instanceof J.FieldAccess) {\n                     if (fieldAccessTargetsVariable(parent.getValue())) {\n                         if (ident.getFieldType() != null) {\n                             ident = ident.withFieldType(ident.getFieldType().withName(newName));\n@@ -153,18 +149,50 @@ private boolean isVariableName(Object value, J.Identifier ident) {\n         }\n \n         /**\n-         * FieldAccess targets the variable if its target type equals variable.Name.FieldType.Owner.\n+         * FieldAccess targets the variable if its target is an Identifier and either\n+         * its target FieldType equals variable.Name.FieldType\n+         * or its target Type equals variable.Name.FieldType.Owner\n+         * or if FieldAccess targets a TypCast and either\n+         * its type equals variable.Name.FieldType\n+         * or its type equals variable.Name.FieldType.Owner.\n+         * In case the FieldAccess targets another FieldAccess, the target is followed\n+         * until it is either an Identifier or a TypeCast.\n          */\n         private boolean fieldAccessTargetsVariable(J.FieldAccess fieldAccess) {\n-            if (renameVariable.getName().getFieldType() != null &&\n-                    fieldAccess.getTarget().getType() != null) {\n-                JavaType targetType = resolveType(fieldAccess.getTarget().getType());\n+            if (renameVariable.getName().getFieldType() != null) {\n+                Expression target = getTarget(fieldAccess);\n+                JavaType targetType = resolveType(target.getType());\n                 JavaType.Variable variableNameFieldType = renameVariable.getName().getFieldType();\n-                return TypeUtils.isOfType(resolveType(variableNameFieldType.getOwner()), targetType);\n+                if (TypeUtils.isOfType(variableNameFieldType.getOwner(), targetType)) {\n+                    return true;\n+                }\n+                if (target instanceof J.TypeCast) {\n+                    return TypeUtils.isOfType(variableNameFieldType, targetType);\n+                } else if (target instanceof J.Identifier) {\n+                    return TypeUtils.isOfType(variableNameFieldType, ((J.Identifier) target).getFieldType());\n+                }\n             }\n             return false;\n         }\n \n+        private @Nullable Expression getTarget(J.FieldAccess fieldAccess) {\n+            Expression target = fieldAccess.getTarget();\n+            if (target instanceof J.Identifier) {\n+                return target;\n+            }\n+            if (target instanceof J.FieldAccess) {\n+                return getTarget((J.FieldAccess) target);\n+            }\n+            if (target instanceof J.Parentheses<?>) {\n+                J tree = ((J.Parentheses<?>) target).getTree();\n+                if (tree instanceof J.TypeCast) {\n+                    return (J.TypeCast) tree;\n+                }\n+                return null;\n+            }\n+            return null;\n+        }\n+\n         private @Nullable JavaType resolveType(@Nullable JavaType type) {\n             return type instanceof JavaType.Parameterized ? ((JavaType.Parameterized) type).getType() : type;\n         }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java b/rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java\nindex 8ad6f5a0c72..0b4665c508f 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java\n@@ -24,6 +24,9 @@\n import java.util.*;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n+import static org.openrewrite.java.tree.TypeUtils.isAssignableTo;\n+import static org.openrewrite.java.tree.TypeUtils.isOfType;\n+\n /**\n  * Recursively checks the equality of each element of two ASTs to determine if two trees are semantically equal.\n  * <p>\n@@ -929,7 +932,6 @@ public J.MemberReference visitMemberReference(J.MemberReference memberRef, J j)\n                     return memberRef;\n                 }\n \n-                visit(memberRef.getContaining(), compareTo.getContaining());\n                 visitList(memberRef.getTypeParameters(), compareTo.getTypeParameters());\n             }\n             return memberRef;\n@@ -1525,13 +1527,5 @@ public <N extends NameTree> N visitTypeName(N firstTypeName, J j) {\n             }\n             return firstTypeName;\n         }\n-\n-        protected boolean isOfType(@Nullable JavaType target, @Nullable JavaType source) {\n-            return TypeUtils.isOfType(target, source);\n-        }\n-\n-        protected boolean isAssignableTo(@Nullable JavaType target, @Nullable JavaType source) {\n-            return TypeUtils.isAssignableTo(target, source);\n-        }\n     }\n }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java\nindex 974792d7781..eb0c6ef075e 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java\n@@ -17,6 +17,8 @@\n \n import org.jspecify.annotations.Nullable;\n import org.openrewrite.Incubating;\n+import org.openrewrite.java.JavaTypeSignatureBuilder;\n+import org.openrewrite.java.internal.DefaultJavaTypeSignatureBuilder;\n import org.openrewrite.java.internal.JavaReflectionTypeMapping;\n import org.openrewrite.java.internal.JavaTypeCache;\n \n@@ -123,10 +125,38 @@ public static boolean isOfType(@Nullable JavaType type1, @Nullable JavaType type\n         if (type1 == type2) {\n             return true;\n         }\n-        if (type1 instanceof JavaType.Method || type2 instanceof JavaType.Method) {\n-            if (!(type1 instanceof JavaType.Method) || !(type2 instanceof JavaType.Method)) {\n-                return false;\n+        if (type1 == null || type2 == null) {\n+            return false;\n+        }\n+        // Strings, uniquely amongst all other types, can be either primitives or classes depending on the context\n+        if (TypeUtils.isString(type1) && TypeUtils.isString(type2)) {\n+            return true;\n+        }\n+        if (type1 instanceof JavaType.Primitive && type2 instanceof JavaType.Primitive) {\n+            return ((JavaType.Primitive) type1).getKeyword().equals(((JavaType.Primitive) type2).getKeyword());\n+        }\n+        if (type1 instanceof JavaType.FullyQualified && type2 instanceof JavaType.FullyQualified) {\n+            if (TypeUtils.fullyQualifiedNamesAreEqual(\n+                    ((JavaType.FullyQualified) type1).getFullyQualifiedName(),\n+                    ((JavaType.FullyQualified) type2).getFullyQualifiedName())) {\n+                if (type1 instanceof JavaType.Class && type2 instanceof JavaType.Class) {\n+                    return true;\n+                } else if (type1 instanceof JavaType.Parameterized && type2 instanceof JavaType.Parameterized) {\n+                    JavaTypeSignatureBuilder signatureBuilder = new DefaultJavaTypeSignatureBuilder();\n+                    return signatureBuilder.signature(type1).equals(signatureBuilder.signature(type2));\n+                } else if (type1 instanceof JavaType.Annotation && type2 instanceof JavaType.Annotation) {\n+                    return isOfType((JavaType.Annotation) type1, (JavaType.Annotation) type2);\n+                }\n             }\n+        }\n+        if (type1 instanceof JavaType.Array && type2 instanceof JavaType.Array) {\n+            return isOfType(((JavaType.Array) type1).getElemType(), ((JavaType.Array) type2).getElemType());\n+        }\n+        if (type1 instanceof JavaType.GenericTypeVariable && type2 instanceof JavaType.GenericTypeVariable) {\n+            JavaTypeSignatureBuilder signatureBuilder = new DefaultJavaTypeSignatureBuilder();\n+            return signatureBuilder.signature(type1).equals(signatureBuilder.signature(type2));\n+        }\n+        if (type1 instanceof JavaType.Method && type2 instanceof JavaType.Method) {\n             JavaType.Method method1 = (JavaType.Method) type1;\n             JavaType.Method method2 = (JavaType.Method) type2;\n             if (!method1.getName().equals(method2.getName()) ||\n@@ -150,21 +180,12 @@ public static boolean isOfType(@Nullable JavaType type1, @Nullable JavaType type\n             }\n             return true;\n         }\n-        if (type1 instanceof JavaType.Variable || type2 instanceof JavaType.Variable) {\n-            if (!(type1 instanceof JavaType.Variable) || !(type2 instanceof JavaType.Variable)) {\n-                return false;\n-            }\n+        if(type1 instanceof JavaType.Variable && type2 instanceof JavaType.Variable) {\n             JavaType.Variable var1 = (JavaType.Variable) type1;\n             JavaType.Variable var2 = (JavaType.Variable) type2;\n             return isOfType((var1).getType(), var2.getType()) && isOfType(var1.getOwner(), var2.getOwner());\n         }\n-        if (type1 instanceof JavaType.Annotation || type2 instanceof JavaType.Annotation) {\n-            if (!(type1 instanceof JavaType.Annotation) || !(type2 instanceof JavaType.Annotation)) {\n-                return false;\n-            }\n-            return isOfType((JavaType.Annotation) type1, (JavaType.Annotation) type2);\n-        }\n-        return new Types().isOfType(type1, type2);\n+        return type1.equals(type2);\n     }\n \n     private static boolean isOfType(JavaType.Annotation annotation1, JavaType.Annotation annotation2) {\n@@ -286,8 +307,287 @@ public static boolean isOfTypeWithName(\n         return false;\n     }\n \n+    public enum TypePosition {\n+        In, Out, Invariant\n+    }\n+\n     public static boolean isAssignableTo(@Nullable JavaType to, @Nullable JavaType from) {\n-        return new Types().isAssignableTo(to, from);\n+        return isAssignableTo(to, from, TypePosition.Invariant);\n+    }\n+\n+    public static boolean isAssignableTo(@Nullable JavaType to, @Nullable JavaType from, TypePosition position) {\n+        try {\n+            if (to instanceof JavaType.Unknown || from instanceof JavaType.Unknown) {\n+                return false;\n+            }\n+            if (to == from) {\n+                return true;\n+            }\n+            if (from == JavaType.Primitive.Null) {\n+                return !(to instanceof JavaType.Primitive);\n+            }\n+\n+            // Handle parameterized types (e.g., List<String>)\n+            if (to instanceof JavaType.Parameterized) {\n+                JavaType.Parameterized toParameterized = (JavaType.Parameterized) to;\n+\n+                // If 'from' is not parameterized but the 'to' type is,\n+                // this would be an unsafe raw type conversion - disallow it unless for wildcards\n+                if (!(from instanceof JavaType.Parameterized)) {\n+                    for (JavaType typeParameter : toParameterized.getTypeParameters()) {\n+                        if (typeParameter instanceof JavaType.GenericTypeVariable && ((JavaType.GenericTypeVariable) typeParameter).getName().equals(\"?\")) {\n+                            continue;\n+                        }\n+                        return false;\n+                    }\n+                    // all wildcards case\n+                    return isAssignableTo(toParameterized.getType(), from);\n+                }\n+\n+                JavaType.Parameterized fromParameterized = (JavaType.Parameterized) from;\n+                List<JavaType> toParameters = toParameterized.getTypeParameters();\n+                List<JavaType> fromParameters = fromParameterized.getTypeParameters();\n+\n+                // First check if the raw types are assignable\n+                if (toParameters.size() != fromParameters.size() ||\n+                    !isAssignableTo(toParameterized.getType(), fromParameterized.getType(), position)) {\n+                    return false;\n+                }\n+\n+                // Check type parameters with appropriate variance\n+                for (int i = 0; i < toParameters.size(); i++) {\n+                    JavaType toParam = toParameters.get(i);\n+                    JavaType fromParam = fromParameters.get(i);\n+\n+                    if (toParam instanceof JavaType.GenericTypeVariable) {\n+                        JavaType.GenericTypeVariable toGeneric = (JavaType.GenericTypeVariable) toParam;\n+\n+                        // Special handling for wildcards\n+                        if (toGeneric.getName().equals(\"?\")) {\n+                            // If both are wildcards, check their compatibility\n+                            if (fromParam instanceof JavaType.GenericTypeVariable &&\n+                                ((JavaType.GenericTypeVariable) fromParam).getName().equals(\"?\")) {\n+\n+                                // If both are unbounded wildcards, they're compatible\n+                                if (toGeneric.getBounds().isEmpty() &&\n+                                    ((JavaType.GenericTypeVariable) fromParam).getBounds().isEmpty()) {\n+                                    continue;  // Skip to next parameter, these wildcards match\n+                                }\n+\n+                                // If they have bounds, check bound compatibility\n+                                return areWildcardBoundsCompatible(toGeneric, (JavaType.GenericTypeVariable) fromParam, position);\n+                            }\n+\n+                            // Wildcard to non-wildcard case\n+                            if (toGeneric.getBounds().isEmpty()) {\n+                                // Unbounded wildcard accepts anything\n+                                return true;\n+                            } else {\n+                                // Bounded wildcard - use the variance from the wildcard\n+                                TypePosition wildcardPosition = convertVarianceToPosition(toGeneric.getVariance());\n+                                for (JavaType bound : toGeneric.getBounds()) {\n+                                    if (!isAssignableTo(bound, fromParam, wildcardPosition)) {\n+                                        return false;\n+                                    }\n+                                }\n+                                return true;\n+                            }\n+                        }\n+                    }\n+\n+                    // For all non-wildcard cases, use invariant position\n+                    if (!isOfType(toParam, fromParam)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            // Handle generic type variables (e.g., T extends Collection<String>)\n+            else if (to instanceof JavaType.GenericTypeVariable) {\n+                JavaType.GenericTypeVariable toGeneric = (JavaType.GenericTypeVariable) to;\n+\n+                switch (position) {\n+                    case In:\n+                        // In parameter position (contravariant), the provided type must be a supertype\n+                        // of at least one possible type that could satisfy the bounds\n+                        for (JavaType bound : toGeneric.getBounds()) {\n+                            if (isAssignableTo(from, bound, TypePosition.Invariant)) {\n+                                return true;\n+                            }\n+                        }\n+                        return false;\n+\n+                    case Out:\n+                        // In return position (covariant), we can assign any subtype that satisfies the bounds\n+                        for (JavaType bound : toGeneric.getBounds()) {\n+                            if (!isAssignableTo(bound, from, TypePosition.Invariant)) {\n+                                return false;\n+                            }\n+                        }\n+                        return true;\n+\n+                    case Invariant:\n+                        // In invariant position, types must match exactly\n+                        if (from instanceof JavaType.GenericTypeVariable) {\n+                            return toGeneric.getName().equals(((JavaType.GenericTypeVariable) from).getName());\n+                        }\n+                        return false;\n+                }\n+            }\n+\n+            // Handle fully qualified types (e.g., java.util.List)\n+            else if (to instanceof JavaType.FullyQualified) {\n+                JavaType.FullyQualified toFq = (JavaType.FullyQualified) to;\n+                if (from instanceof JavaType.Primitive) {\n+                    return isAssignableTo(to, BOXED_TYPES.get((JavaType.Primitive) from), position);\n+                } else if (from instanceof JavaType.Intersection) {\n+                    for (JavaType intersectionType : ((JavaType.Intersection) from).getBounds()) {\n+                        if (isAssignableTo(to, intersectionType, position)) {\n+                            return true;\n+                        }\n+                    }\n+                    return false;\n+                }\n+                return !(from instanceof JavaType.GenericTypeVariable) && isAssignableTo(toFq.getFullyQualifiedName(), from);\n+            }\n+\n+            // Rest of the existing cases, passing through the position parameter\n+            else if (to instanceof JavaType.Variable) {\n+                return isAssignableTo(((JavaType.Variable) to).getType(), from, position);\n+            } else if (to instanceof JavaType.Method) {\n+                return isAssignableTo(((JavaType.Method) to).getReturnType(), from, position);\n+            } else if (to instanceof JavaType.Array && from instanceof JavaType.Array) {\n+                JavaType.Array toArray = (JavaType.Array) to;\n+                JavaType.Array fromArray = (JavaType.Array) from;\n+                if (toArray.getElemType() instanceof JavaType.Primitive || fromArray.getElemType() instanceof JavaType.Primitive) {\n+                    return isOfType(toArray.getElemType(), fromArray.getElemType());\n+                }\n+                // Arrays are invariant in Java\n+                return isAssignableTo(toArray.getElemType(), fromArray.getElemType(), TypePosition.Invariant);\n+            }\n+\n+            // Handle primitives with their existing logic\n+            else if (to instanceof JavaType.Primitive) {\n+                // Primitive handling remains unchanged as they don't involve variance\n+                return handlePrimitiveAssignability((JavaType.Primitive) to, from);\n+            }\n+\n+        } catch (Exception ignored) {\n+        }\n+        return false;\n+    }\n+\n+    private static boolean areWildcardBoundsCompatible(JavaType.GenericTypeVariable to, JavaType.GenericTypeVariable from, TypePosition position) {\n+        // If both wildcards are unbounded, they're compatible\n+        if (to.getBounds().isEmpty() && from.getBounds().isEmpty()) {\n+            return true;\n+        }\n+\n+        // If we have a bounded and unbounded wildcard:\n+        if (to.getBounds().isEmpty()) {\n+            // Unbounded target only accepts unbounded source\n+            return false;\n+        }\n+        if (from.getBounds().isEmpty()) {\n+            // Source being unbounded is never safe when target is bounded\n+            return false;\n+        }\n+\n+        // Both wildcards are bounded\n+        switch (position) {\n+            case Out:\n+                // In covariant position, source bounds must be more specific than target bounds\n+                for (JavaType bound : to.getBounds()) {\n+                    if (!isAssignableTo(bound, from.getBounds().get(0), TypePosition.Invariant)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            case In:\n+                // In contravariant position, target bounds must be more specific than source bounds\n+                for (JavaType bound : from.getBounds()) {\n+                    if (!isAssignableTo(bound, to.getBounds().get(0), TypePosition.Invariant)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            case Invariant:\n+                // In invariant position, bounds must match exactly\n+                return to.getBounds().equals(from.getBounds());\n+        }\n+        return false;\n+    }\n+\n+    private static TypePosition convertVarianceToPosition(JavaType.GenericTypeVariable.Variance variance) {\n+        switch (variance) {\n+            case COVARIANT:\n+                return TypePosition.Out;\n+            case CONTRAVARIANT:\n+                return TypePosition.In;\n+            default:\n+                return TypePosition.Invariant;\n+        }\n+    }\n+\n+    private static boolean handlePrimitiveAssignability(JavaType.Primitive to, @Nullable JavaType from) {\n+        if (from instanceof JavaType.FullyQualified) {\n+            // Account for auto-unboxing\n+            JavaType.FullyQualified fromFq = (JavaType.FullyQualified) from;\n+            JavaType.Primitive fromPrimitive = JavaType.Primitive.fromClassName(fromFq.getFullyQualifiedName());\n+            return handlePrimitiveAssignability(to, fromPrimitive);\n+        } else if (from instanceof JavaType.Primitive) {\n+            JavaType.Primitive fromPrimitive = (JavaType.Primitive) from;\n+            switch (fromPrimitive) {\n+                case Void:\n+                case None:\n+                case Null:\n+                case String:\n+                    return false;\n+                case Boolean:\n+                    return fromPrimitive == to;\n+                default:\n+                    switch (to) {\n+                        case Byte:\n+                        case Char:\n+                            return fromPrimitive == to;\n+                        case Short:\n+                            switch (fromPrimitive) {\n+                                case Byte:\n+                                case Char:\n+                                case Short:\n+                                    return true;\n+                            }\n+                            return false;\n+                        case Int:\n+                            switch (fromPrimitive) {\n+                                case Byte:\n+                                case Char:\n+                                case Short:\n+                                case Int:\n+                                    return true;\n+                            }\n+                            return false;\n+                        case Long:\n+                            switch (fromPrimitive) {\n+                                case Byte:\n+                                case Char:\n+                                case Short:\n+                                case Int:\n+                                case Long:\n+                                    return true;\n+                            }\n+                            return false;\n+                        case Float:\n+                            return fromPrimitive != JavaType.Primitive.Double;\n+                        case Double:\n+                            return true;\n+                        default:\n+                            return false;\n+                    }\n+            }\n+        }\n+        return false;\n     }\n \n     public static boolean isAssignableTo(String to, @Nullable JavaType from) {\n@@ -413,10 +713,6 @@ public static boolean isAssignableTo(Predicate<JavaType> predicate, @Nullable Ja\n         return null;\n     }\n \n-    public static JavaType asBoxedType(JavaType.Primitive type) {\n-        return BOXED_TYPES.get(type);\n-    }\n-\n     /**\n      * Determine if a method overrides a method from a superclass or interface.\n      *\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/Types.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/Types.java\ndeleted file mode 100644\nindex 05181b1ee4b..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/Types.java\n+++ /dev/null\n@@ -1,546 +0,0 @@\n-/*\n- * Copyright 2025 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.tree;\n-\n-import lombok.Value;\n-import org.jspecify.annotations.Nullable;\n-\n-import java.util.*;\n-\n-public class Types {\n-    private final Map<JavaType.GenericTypeVariable, JavaType.Intersection> boundsCache = new IdentityHashMap<>();\n-    private final Set<TypePair> visiting = new HashSet<>();\n-    private final boolean infer;\n-\n-    public Types() {\n-        this(false);\n-    }\n-\n-    public Types(boolean infer) {\n-        this.infer = infer;\n-    }\n-\n-    public boolean isOfType(@Nullable JavaType to, @Nullable JavaType from) {\n-        return isOfType(normalize(to), normalize(from), infer ? InferSide.TO : InferSide.NONE);\n-    }\n-\n-    public boolean isAssignableTo(@Nullable JavaType to, @Nullable JavaType from) {\n-        return isAssignableTo(normalize(to), normalize(from), infer ? InferSide.TO : InferSide.NONE);\n-    }\n-\n-    private boolean isOfType(@Nullable JavaType to, @Nullable JavaType from, InferSide mode) {\n-        if (isUnknown(to) || isUnknown(from)) {\n-            return false;\n-        } else if (to == from) {\n-            return true;\n-        }\n-\n-        TypePair key = new TypePair(Operation.IS_OF_TYPE, mode, to, from);\n-        if (visiting.add(key)) {\n-            try {\n-                return isOfTypeCore(to, from, mode);\n-            } finally {\n-                visiting.remove(key);\n-            }\n-        } else {\n-            // We are already visiting this type pair, so we can assume it is of the same type.\n-            return true;\n-        }\n-    }\n-\n-    private boolean isOfTypeCore(JavaType to, JavaType from, InferSide mode) {\n-        // Try to match captures\n-        if (mode == InferSide.TO && isTypeVariable(to) ||\n-                mode == InferSide.FROM && isTypeVariable(from)) {\n-            return isAssignableTo(to, from, mode);\n-        }\n-\n-        // Rest of cases\n-        if (to instanceof JavaType.GenericTypeVariable && from instanceof JavaType.GenericTypeVariable) {\n-            return isOfTypeGeneric((JavaType.GenericTypeVariable) to, (JavaType.GenericTypeVariable) from, mode);\n-        } else if (to instanceof JavaType.FullyQualified && from instanceof JavaType.FullyQualified) {\n-            return isOfTypeFullyQualified((JavaType.FullyQualified) to, (JavaType.FullyQualified) from, mode);\n-        } else if (to instanceof JavaType.Primitive && from instanceof JavaType.Primitive) {\n-            return isOfTypePrimitive((JavaType.Primitive) to, (JavaType.Primitive) from, mode);\n-        } else if (to instanceof JavaType.Array && from instanceof JavaType.Array) {\n-            return isOfTypeArray((JavaType.Array) to, (JavaType.Array) from, mode);\n-        } else if (to instanceof JavaType.Intersection && from instanceof JavaType.Intersection) {\n-            return isOfTypeList(((JavaType.Intersection) to).getBounds(),\n-                    ((JavaType.Intersection) from).getBounds(), mode);\n-        } else if (to instanceof JavaType.MultiCatch && from instanceof JavaType.MultiCatch) {\n-            return isOfTypeList(((JavaType.MultiCatch) to).getThrowableTypes(),\n-                    ((JavaType.MultiCatch) from).getThrowableTypes(), mode);\n-        }\n-        return false;\n-    }\n-\n-    private boolean isOfTypeFullyQualified(JavaType.FullyQualified to, JavaType.FullyQualified from, InferSide mode) {\n-        if (!TypeUtils.fullyQualifiedNamesAreEqual(to.getFullyQualifiedName(), from.getFullyQualifiedName())) {\n-            return false;\n-        }\n-        if (to instanceof JavaType.Class && from instanceof JavaType.Class) {\n-            return true;\n-        } else if (to instanceof JavaType.Parameterized && from instanceof JavaType.Parameterized) {\n-            if (to.getTypeParameters().size() != from.getTypeParameters().size()) {\n-                return false;\n-            }\n-            List<JavaType> toTypeParams = to.getTypeParameters();\n-            List<JavaType> fromTypeParams = from.getTypeParameters();\n-            for (int i = 0; i < toTypeParams.size(); i++) {\n-                if (!isOfType(toTypeParams.get(i), fromTypeParams.get(i), mode)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private boolean isOfTypePrimitive(JavaType.Primitive to, JavaType.Primitive from, InferSide mode) {\n-        return to == from;\n-    }\n-\n-    private boolean isOfTypeArray(JavaType.Array to, JavaType.Array from, InferSide mode) {\n-        if (to.getElemType() instanceof JavaType.Primitive || from.getElemType() instanceof JavaType.Primitive) {\n-            // Avoid incorrect inference of array types\n-            return to.getElemType() == from.getElemType();\n-        }\n-        return isOfType(to.getElemType(), from.getElemType(), mode);\n-    }\n-\n-    private boolean isOfTypeGeneric(JavaType.GenericTypeVariable to, JavaType.GenericTypeVariable from, InferSide mode) {\n-        if (!to.getName().equals(from.getName()) ||\n-                to.getVariance() != from.getVariance() ||\n-                to.getBounds().size() != from.getBounds().size()) {\n-            return false;\n-        }\n-        for (int i = 0; i < to.getBounds().size(); i++) {\n-            if (!isOfType(to.getBounds().get(i), from.getBounds().get(i), mode)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private boolean isOfTypeList(List<JavaType> to, List<JavaType> from, InferSide mode) {\n-        if (to.size() != from.size() ||\n-                to.stream().anyMatch(e -> !(e instanceof JavaType.FullyQualified)) ||\n-                from.stream().anyMatch(e -> !(e instanceof JavaType.FullyQualified))) {\n-            return false;\n-        }\n-\n-        JavaType.FullyQualified[] toFq = to.stream()\n-                .map(e -> (JavaType.FullyQualified) e)\n-                .sorted(Comparator.comparing(JavaType.FullyQualified::getFullyQualifiedName))\n-                .toArray(JavaType.FullyQualified[]::new);\n-        JavaType.FullyQualified[] fromFq = from.stream()\n-                .map(e -> (JavaType.FullyQualified) e)\n-                .sorted(Comparator.comparing(JavaType.FullyQualified::getFullyQualifiedName))\n-                .toArray(JavaType.FullyQualified[]::new);\n-        for (int i = 0; i < toFq.length; i++) {\n-            if (!isOfType(toFq[i], fromFq[i], mode)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private boolean isAssignableTo(@Nullable JavaType to, @Nullable JavaType from, InferSide mode) {\n-        if (isUnknown(to) || isUnknown(from)) {\n-            return false;\n-        }\n-        if (from == JavaType.Primitive.Null) {\n-            return !(to instanceof JavaType.Primitive);\n-        }\n-        if (to == from || TypeUtils.isObject(to)) {\n-            return true;\n-        }\n-\n-        TypePair key = new TypePair(Operation.IS_ASSIGNABLE_TO, mode, to, from);\n-        if (visiting.add(key)) {\n-            try {\n-                return isAssignableToCore(to, from, mode);\n-            } finally {\n-                visiting.remove(key);\n-            }\n-        } else {\n-            // We are already visiting this type pair, so we can assume it is assignable.\n-            return true;\n-        }\n-    }\n-\n-    private boolean isAssignableToCore(JavaType to, JavaType from, InferSide mode) {\n-        // Handle generic type variables (e.g., T extends Collection<String>)\n-        if (mode == InferSide.FROM && isTypeVariable(from)) {\n-            // Is there anything we can validate?\n-            return true;\n-        } else if (to instanceof JavaType.GenericTypeVariable) {\n-            return isAssignableToGeneric((JavaType.GenericTypeVariable) to, from, mode);\n-        } else if (from instanceof JavaType.GenericTypeVariable) {\n-            return isAssignableFromGeneric(to, (JavaType.GenericTypeVariable) from, mode);\n-        }\n-\n-        // Handle intersection types (e.g., T extends A & B)\n-        if (to instanceof JavaType.Intersection) {\n-            List<JavaType> bounds = ((JavaType.Intersection) to).getBounds();\n-            return bounds.stream().allMatch(e -> isAssignableTo(e, from, mode));\n-        } else if (to instanceof JavaType.MultiCatch) {\n-            List<JavaType> throwableTypes = ((JavaType.MultiCatch) to).getThrowableTypes();\n-            return throwableTypes.stream().anyMatch(e -> isAssignableTo(e, from, mode));\n-        } else if (from instanceof JavaType.Intersection) {\n-            List<JavaType> bounds = ((JavaType.Intersection) from).getBounds();\n-            return bounds.stream().anyMatch(e -> isAssignableTo(to, e, mode));\n-        } else if (from instanceof JavaType.MultiCatch) {\n-            List<JavaType> throwableTypes = ((JavaType.MultiCatch) from).getThrowableTypes();\n-            return throwableTypes.stream().allMatch(e -> isAssignableTo(to, e, mode));\n-        }\n-\n-        // Handle fully qualified types (e.g., java.util.List, java.util.List<String>)\n-        if (to instanceof JavaType.FullyQualified) {\n-            return isAssignableToFullyQualified((JavaType.FullyQualified) to, from, mode);\n-        }\n-        // Handle arrays types (e.g., String[])\n-        else if (to instanceof JavaType.Array) {\n-            return isAssignableToArray((JavaType.Array) to, from, mode);\n-        }\n-        // Handle primitive types (e.g., int, boolean)\n-        else if (to instanceof JavaType.Primitive) {\n-            // Primitive handling remains unchanged as they don't involve variance\n-            return isAssignableToPrimitive((JavaType.Primitive) to, from, mode);\n-        }\n-\n-        return false;\n-    }\n-\n-    private boolean isAssignableToGeneric(JavaType.GenericTypeVariable to, JavaType from, InferSide mode) {\n-        if (isWildcard(to) || mode == InferSide.TO) {\n-            // If target \"to\" wildcard is unbounded, it accepts anything\n-            if (to.getBounds().isEmpty()) {\n-                return true;\n-            }\n-\n-            // Extract the target bound\n-            JavaType target = getBounds(to);\n-\n-            // Determine if \"from\" is a wildcard and handle it unless capture.\n-            JavaType source = from;\n-            if (isWildcard(from) && isWildcard(to)) {\n-                JavaType.GenericTypeVariable fromGeneric = (JavaType.GenericTypeVariable) from;\n-\n-                // Unbounded \"from\" wildcard is incompatible with a bounded \"to\" wildcard\n-                if (fromGeneric.getBounds().isEmpty()) {\n-                    return false;\n-                }\n-\n-                // If variances mismatch, the wildcards are incompatible\n-                if (fromGeneric.getVariance() != to.getVariance()) {\n-                    return false;\n-                }\n-\n-                // Set the source to the bound of the \"from\" wildcard\n-                source = Objects.requireNonNull(getBounds(fromGeneric));\n-            }\n-\n-            // Handle variance and type assignability\n-            switch (to.getVariance()) {\n-                case COVARIANT:\n-                    // ? extends TARGET. Source must be assignable to target\n-                    return isAssignableTo(target, source, mode);\n-                case CONTRAVARIANT:\n-                    // ? super TARGET. Source must be assignable from target.\n-                    return isAssignableTo(source, target, mode.reverse());\n-                default:\n-                    // In Java, an invariant wildcard with bounds (e.g., ? T) is not valid syntax\n-                    // Could a capture come this way?\n-                    assert mode == InferSide.TO;\n-                    return isAssignableTo(target, source, mode);\n-            }\n-        }\n-\n-        // Only same T or U extends T can be assigned to T\n-        if (!(from instanceof JavaType.GenericTypeVariable)) {\n-            // Only a generic type variable can be assigned to another generic type variable in bound mode\n-            return false;\n-        }\n-\n-        JavaType.GenericTypeVariable fromGeneric = (JavaType.GenericTypeVariable) from;\n-        if (to.getName().equals(fromGeneric.getName())) {\n-            return isOfType(to, from, mode);\n-        }\n-\n-        for (JavaType bound : fromGeneric.getBounds()) {\n-            if (isAssignableTo(to, bound, mode)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // Handle cases\n-    private boolean isAssignableFromGeneric(JavaType to, JavaType.GenericTypeVariable from, InferSide mode) {\n-        if (from.getVariance() == JavaType.GenericTypeVariable.Variance.CONTRAVARIANT) {\n-            return isAssignableTo(getBounds(from), to, mode.reverse());\n-        } else {\n-            return isAssignableTo(to, getBounds(from), mode);\n-        }\n-    }\n-\n-    // Contract, from is FullyQualified, Array or Primitive\n-    private boolean isAssignableToFullyQualified(JavaType.FullyQualified to, @Nullable JavaType from, InferSide mode) {\n-        if (from instanceof JavaType.FullyQualified) {\n-            JavaType.FullyQualified classFrom = (JavaType.FullyQualified) from;\n-            if (!TypeUtils.fullyQualifiedNamesAreEqual(to.getFullyQualifiedName(), classFrom.getFullyQualifiedName())) {\n-                if (isAssignableToFullyQualified(to, maybeResolveParameters(classFrom, classFrom.getSupertype()), mode)) {\n-                    return true;\n-                }\n-                for (JavaType.FullyQualified i : classFrom.getInterfaces()) {\n-                    if (isAssignableToFullyQualified(to, maybeResolveParameters(classFrom, i), mode)) {\n-                        return true;\n-                    }\n-                }\n-                return false;\n-            }\n-\n-            // If 'to' is not parameterized is safe conversion,\n-            if (!(to instanceof JavaType.Parameterized)) {\n-                return true;\n-            }\n-\n-            // If 'from' is not parameterized but the 'to' type is,\n-            // this would be an unsafe raw type conversion - disallow it unless for wildcards\n-            if (!(from instanceof JavaType.Parameterized)) {\n-                for (JavaType typeParameter : to.getTypeParameters()) {\n-                    if (!isWildcard(typeParameter) || !((JavaType.GenericTypeVariable) typeParameter).getBounds().isEmpty()) {\n-                        return false;\n-                    }\n-                }\n-                // all wildcards case\n-                return true;\n-            }\n-\n-            // Both are parameterized, check type parameters\n-            JavaType.Parameterized fromParameterized = (JavaType.Parameterized) from;\n-            List<JavaType> toParameters = to.getTypeParameters();\n-            List<JavaType> fromParameters = fromParameterized.getTypeParameters();\n-\n-            if (toParameters.size() != fromParameters.size()) {\n-                return false;\n-            }\n-            for (int i = 0; i < toParameters.size(); i++) {\n-                JavaType toParam = toParameters.get(i);\n-                JavaType fromParam = fromParameters.get(i);\n-\n-                if (isWildcard(toParam) && isAssignableTo(toParam, fromParam, mode) ||\n-                        !isWildcard(toParam) && isOfType(toParam, fromParam, mode)) {\n-                    continue;\n-                }\n-                return false;\n-            }\n-            return true;\n-        } else if (from instanceof JavaType.Array) {\n-            String fqn = to.getFullyQualifiedName();\n-            return \"java.io.Serializable\".equals(fqn) || \"java.lang.Cloneable\".equals(fqn);\n-        } else if (from instanceof JavaType.Primitive) {\n-            return isAssignableToFullyQualified(to, TypeUtils.asBoxedType((JavaType.Primitive) from), mode);\n-        }\n-        return false;\n-    }\n-\n-    private @Nullable JavaType maybeResolveParameters(JavaType.FullyQualified source, JavaType.@Nullable FullyQualified target) {\n-        if (!(source instanceof JavaType.Parameterized) || !(target instanceof JavaType.Parameterized)) {\n-            return target;\n-        }\n-        JavaType.Parameterized src = (JavaType.Parameterized) source;\n-        JavaType.Parameterized tgt = (JavaType.Parameterized) target;\n-\n-        if (src.getTypeParameters().size() != src.getType().getTypeParameters().size()) {\n-            return tgt;\n-        }\n-\n-        Map<JavaType.GenericTypeVariable, JavaType> typeVariableMap = new IdentityHashMap<>();\n-        for (int i = 0; i < src.getTypeParameters().size(); i++) {\n-            if (src.getType().getTypeParameters().get(i) instanceof JavaType.GenericTypeVariable) {\n-                typeVariableMap.put((JavaType.GenericTypeVariable) src.getType().getTypeParameters().get(i), src.getTypeParameters().get(i));\n-            }\n-        }\n-        List<JavaType> resolvedTypeParameters = new ArrayList<>();\n-        for (JavaType tp : target.getTypeParameters()) {\n-            //noinspection SuspiciousMethodCalls\n-            resolvedTypeParameters.add(typeVariableMap.getOrDefault(tp, tp));\n-        }\n-        return tgt.withTypeParameters(resolvedTypeParameters);\n-    }\n-\n-    // Contract: from is FullyQualified, Array or Primitive\n-    private boolean isAssignableToArray(JavaType.Array to, JavaType from, InferSide mode) {\n-        if (from instanceof JavaType.Array) {\n-            JavaType.Array fromArray = (JavaType.Array) from;\n-            if (to.getElemType() instanceof JavaType.Primitive || fromArray.getElemType() instanceof JavaType.Primitive) {\n-                // Avoid boxing or incorrect inference of array types\n-                return to.getElemType() == fromArray.getElemType();\n-            }\n-            return isAssignableTo(to.getElemType(), fromArray.getElemType(), mode);\n-        }\n-        return false;\n-    }\n-\n-    // Contract: from is FullyQualified, Array or Primitive\n-    private boolean isAssignableToPrimitive(JavaType.Primitive to, @Nullable JavaType from, InferSide mode) {\n-        if (from instanceof JavaType.FullyQualified) {\n-            // Account for auto-unboxing\n-            JavaType.FullyQualified fromFq = (JavaType.FullyQualified) from;\n-            JavaType.Primitive fromPrimitive = JavaType.Primitive.fromClassName(fromFq.getFullyQualifiedName());\n-            return isAssignableToPrimitive(to, fromPrimitive, mode);\n-        } else if (from instanceof JavaType.Primitive) {\n-            JavaType.Primitive fromPrimitive = (JavaType.Primitive) from;\n-            switch (fromPrimitive) {\n-                case Void:\n-                case None:\n-                case Null:\n-                case String:\n-                    return false;\n-                case Boolean:\n-                    return fromPrimitive == to;\n-                default:\n-                    switch (to) {\n-                        case Byte:\n-                        case Char:\n-                            return fromPrimitive == to;\n-                        case Short:\n-                            switch (fromPrimitive) {\n-                                case Byte:\n-                                case Char:\n-                                case Short:\n-                                    return true;\n-                            }\n-                            return false;\n-                        case Int:\n-                            switch (fromPrimitive) {\n-                                case Byte:\n-                                case Char:\n-                                case Short:\n-                                case Int:\n-                                    return true;\n-                            }\n-                            return false;\n-                        case Long:\n-                            switch (fromPrimitive) {\n-                                case Byte:\n-                                case Char:\n-                                case Short:\n-                                case Int:\n-                                case Long:\n-                                    return true;\n-                            }\n-                            return false;\n-                        case Float:\n-                            return fromPrimitive != JavaType.Primitive.Double;\n-                        case Double:\n-                            return true;\n-                        default:\n-                            return false;\n-                    }\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private @Nullable JavaType getBounds(JavaType.GenericTypeVariable type) {\n-        if (type.getBounds().isEmpty()) {\n-            return null;\n-        } else if (type.getBounds().size() == 1) {\n-            return type.getBounds().get(0);\n-        } else {\n-            return boundsCache.computeIfAbsent(type, e -> new JavaType.Intersection(e.getBounds()));\n-        }\n-    }\n-\n-    private boolean isTypeVariable(JavaType type) {\n-        if (isWildcard(type)) {\n-            JavaType.GenericTypeVariable generic = (JavaType.GenericTypeVariable) type;\n-            return !generic.getBounds().isEmpty() && isTypeVariable(generic.getBounds().get(0));\n-        }\n-        return type instanceof JavaType.GenericTypeVariable;\n-    }\n-\n-    private boolean isWildcard(JavaType type) {\n-        return type instanceof JavaType.GenericTypeVariable && ((JavaType.GenericTypeVariable) type).getName().equals(\"?\");\n-    }\n-\n-    private boolean isUnknown(@Nullable JavaType to) {\n-        return to == null || to instanceof JavaType.Unknown;\n-    }\n-\n-    private @Nullable JavaType normalize(@Nullable JavaType type) {\n-        if (type instanceof JavaType.Method) {\n-            return normalize(((JavaType.Method) type).getReturnType());\n-        } else if (type instanceof JavaType.Variable) {\n-            return normalize(((JavaType.Variable) type).getType());\n-        } else if (type == JavaType.Primitive.String) {\n-            return TypeUtils.asBoxedType(JavaType.Primitive.String);\n-        } else {\n-            return type;\n-        }\n-    }\n-\n-    enum Operation {\n-        IS_OF_TYPE,\n-        IS_ASSIGNABLE_TO\n-    }\n-\n-    enum InferSide {\n-        NONE,\n-        TO,\n-        FROM;\n-\n-        InferSide reverse() {\n-            switch (this) {\n-                case TO:\n-                    return FROM;\n-                case FROM:\n-                    return TO;\n-                default:\n-                    return NONE;\n-            }\n-        }\n-    }\n-\n-    @Value\n-    static class TypePair {\n-        Operation operation;\n-        InferSide mode;\n-        JavaType to;\n-        JavaType from;\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (!(o instanceof TypePair)) return false;\n-\n-            TypePair that = (TypePair) o;\n-            return operation == that.operation && mode == that.mode && to == that.to && from == that.from;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            int result = operation.hashCode();\n-            result = 31 * result + mode.hashCode();\n-            result = 31 * result + System.identityHashCode(to);\n-            result = 31 * result + System.identityHashCode(from);\n-            return result;\n-        }\n-    }\n-}\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java\nindex e36606d1411..2407bc5782a 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java\n@@ -33,6 +33,8 @@\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.openrewrite.java.Assertions.java;\n+import static org.openrewrite.java.tree.TypeUtils.TypePosition.Invariant;\n+import static org.openrewrite.java.tree.TypeUtils.TypePosition.Out;\n import static org.openrewrite.test.RewriteTest.toRecipe;\n \n @SuppressWarnings(\"ConstantConditions\")\n@@ -334,7 +336,7 @@ public J.VariableDeclarations.NamedVariable visitVariable(J.VariableDeclarations\n     }\n \n     @Test\n-    void isAssignableToGenericTypeVariable1() {\n+    void isAssignableToGenericTypeVariable() {\n         rewriteRun(\n           java(\n             \"\"\"\n@@ -389,8 +391,8 @@ public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, Ob\n                     if (method.getSimpleName().equals(\"test\")) {\n                         J.Return return_ = (J.Return) method.getBody().getStatements().get(0);\n                         J.TypeCast cast = (J.TypeCast) return_.getExpression();\n-                        assertThat(TypeUtils.isAssignableTo(cast.getType(), cast.getExpression().getType())).isFalse();\n-                        assertThat(new Types(true).isAssignableTo(cast.getType(), cast.getExpression().getType())).isTrue();\n+                        assertThat(TypeUtils.isAssignableTo(cast.getType(), cast.getExpression().getType(), Invariant)).isFalse();\n+                        assertThat(TypeUtils.isAssignableTo(cast.getType(), cast.getExpression().getType(), Out)).isTrue();\n                     }\n                     return method;\n                 }\n@@ -435,8 +437,8 @@ public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, Ob\n                         JavaType consumeClassParamType = ((J.VariableDeclarations) consumeClass.getParameters().get(0)).getVariables().get(0).getType();\n                         JavaType consumeMethodParamType = ((J.VariableDeclarations) consumeMethod.getParameters().get(0)).getVariables().get(0).getType();\n \n-                        assertThat(new Types(true).isAssignableTo(consumeClassParamType, list.getType())).isTrue();\n-                        assertThat(new Types(true).isAssignableTo(consumeMethodParamType, list.getType())).isTrue();\n+                        assertThat(TypeUtils.isAssignableTo(consumeClassParamType, list.getType(), Out)).isTrue();\n+                        assertThat(TypeUtils.isAssignableTo(consumeMethodParamType, list.getType(), Out)).isTrue();\n                     }\n                     return method;\n                 }\n@@ -622,12 +624,11 @@ void isAssignableToVoid() {\n \n     @Test\n     void isAssignableToString() {\n-        EnumSet<JavaType.Primitive> others = EnumSet.complementOf(EnumSet.of(JavaType.Primitive.String, JavaType.Primitive.Null));\n+        EnumSet<JavaType.Primitive> others = EnumSet.complementOf(EnumSet.of(JavaType.Primitive.String));\n         for (JavaType.Primitive other : others) {\n             assertFalse(TypeUtils.isAssignableTo(JavaType.Primitive.String, other));\n         }\n         assertTrue(TypeUtils.isAssignableTo(JavaType.Primitive.String, JavaType.Primitive.String));\n-        assertTrue(TypeUtils.isAssignableTo(JavaType.Primitive.String, JavaType.Primitive.Null));\n     }\n \n     @Test\n\ndiff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypesTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypesTest.java\ndeleted file mode 100644\nindex e07ffc1d3de..00000000000\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypesTest.java\n+++ /dev/null\n@@ -1,633 +0,0 @@\n-/*\n- * Copyright 2022 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.tree;\n-\n-import org.junit.jupiter.api.Test;\n-import org.openrewrite.java.MinimumJava11;\n-import org.openrewrite.test.RewriteTest;\n-\n-import static org.openrewrite.java.Assertions.java;\n-\n-@SuppressWarnings(\"ConstantConditions\")\n-class TypesTest implements RewriteTest {\n-\n-    @Test\n-    @SuppressWarnings(\"rawtypes\")\n-    void isOfType() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import java.util.List;\n-              import java.util.Map;\n-              \n-              class Test<T extends Number, U extends List<String>, V extends U, X> {\n-                  Integer integer;\n-                  int[] intArray;\n-                  Integer[] integerArray;\n-                  String[] stringArray;\n-                  List<String>[] genericArray;\n-                  Integer[][] nestedArray;\n-                  T[] tArray;\n-                  U[] uArray;\n-                  V[] vArray;\n-                  X[] xArray;\n-              \n-                  T numberType;\n-                  U listType;\n-                  V nestedListType;\n-                  X generic;\n-              \n-                  List<T> numberList;\n-                  List<String> listString;\n-                  Map<String, T> stringToNumberMap;\n-                  Map<String, X> stringToGenericMap;\n-              \n-                  List<? extends Number> extendsNumberList;\n-                  List<? super Integer> superIntegerList;\n-              \n-                  Map<String, List<Map<Integer, String>>> complexNested;\n-              }\n-              \"\"\",\n-            spec -> spec.afterRecipe(cu -> {\n-                  try (TypeUtilsAssertions assertions = new TypeUtilsAssertions(cu)) {\n-                      // 1. Primitive exact matches\n-                      assertions.isOfType(\"int\", \"int\").isTrue();\n-                      assertions.isOfType(\"int\", \"Integer\").isFalse();\n-                      assertions.isOfType(\"Integer\", \"int\").isFalse();\n-\n-                      // 2. Array matches\n-                      assertions.isOfType(\"int[]\", \"int[]\").isTrue();\n-                      assertions.isOfType(\"Integer[]\", \"Integer[]\").isTrue();\n-                      assertions.isOfType(\"Integer[]\", \"int[]\").isFalse();\n-                      assertions.isOfType(\"int[]\", \"Integer[]\").isFalse();\n-                      assertions.isOfType(\"Integer[][]\", \"Integer[][]\").isTrue();\n-                      assertions.isOfType(\"List<String>[]\", \"List<String>[]\").isTrue();\n-                      assertions.isOfType(\"List<String>[]\", \"String[]\").isFalse();\n-                      assertions.isOfType(\"int[]\", \"String[]\").isFalse();\n-                      assertions.isOfType(\"List<String>[]\", \"String[]\").isFalse();\n-\n-                      // 3. Generic array matches\n-                      assertions.isOfType(\"T[]\", \"T[]\").isTrue();\n-                      assertions.isOfType(\"U[]\", \"U[]\").isTrue();\n-                      assertions.isOfType(\"T[]\", \"Integer[]\").isFalse();\n-                      assertions.isOfType(\"U[]\", \"List<String>[]\").isFalse();\n-                      assertions.isOfType(\"Integer[][]\", \"T[]\").isFalse();\n-                      assertions.isOfType(\"T[]\", \"Integer[][]\").isFalse();\n-                      assertions.isOfType(\"U[]\", \"Integer[][]\").isFalse();\n-                      assertions.isOfType(\"U[]\", \"V[]\").isFalse();\n-                      assertions.isOfType(\"V[]\", \"U[]\").isFalse();\n-                      assertions.isOfType(\"Integer[][]\", \"int[]\").isFalse();\n-\n-                      // 4. Type variable matches <T extends Number, U extends List<String>, V extends U>\n-                      assertions.isOfType(\"T\", \"T\").isTrue();\n-                      assertions.isOfType(\"U\", \"U\").isTrue();\n-                      assertions.isOfType(\"V\", \"V\").isTrue();\n-                      assertions.isOfType(\"T\", \"Integer\").isFalse();\n-                      assertions.isOfType(\"T\", \"Integer\").isFalse();\n-                      assertions.isOfType(\"U\", \"V\").isFalse();\n-                      assertions.isOfType(\"T\", \"U\").isFalse();\n-\n-                      // 5. Parameterized types\n-                      assertions.isOfType(\"List<T>\", \"List<T>\").isTrue();\n-                      assertions.isOfType(\"List<? extends Number>\", \"List<? extends Number>\").isTrue();\n-                      assertions.isOfType(\"Map<String, List<Map<Integer, String>>>\", \"Map<String, List<Map<Integer, String>>>\").isTrue();\n-                      assertions.isOfType(\"List<T>\", \"List<? extends Number>\").isFalse();\n-                      assertions.isOfType(\"List<? extends Number>\", \"List<T>\").isFalse();\n-\n-                      // 6. With INFER mode <T extends Number, U extends List<String>, V extends U>\n-                      assertions.isOfType(\"T\", \"Integer\", true).isTrue();\n-                      assertions.isOfType(\"U\", \"Integer\", true).isFalse();\n-                      assertions.isOfType(\"U\", \"List<String>\", true).isTrue();\n-                      assertions.isOfType(\"V\", \"List<String>\", true).isTrue();\n-                      assertions.isOfType(\"T\", \"Integer[]\", true).isFalse();\n-                      assertions.isOfType(\"X\", \"Integer[]\", true).isTrue();\n-                      assertions.isOfType(\"T\", \"int[]\", true).isFalse();\n-                      assertions.isOfType(\"X\", \"int[]\", true).isTrue();\n-                      assertions.isOfType(\"T[]\", \"int[]\", true).isFalse();\n-                      assertions.isOfType(\"X[]\", \"int[]\", true).isFalse();\n-                      assertions.isOfType(\"T[]\", \"Integer[]\", true).isTrue();\n-                      assertions.isOfType(\"X[]\", \"Integer[]\", true).isTrue();\n-                      assertions.isOfType(\"U[]\", \"List<String>[]\", true).isTrue();\n-                      assertions.isOfType(\"V[]\", \"List<String>[]\", true).isTrue();\n-                      assertions.isOfType(\"Integer[][]\", \"T[]\", true).isFalse();\n-                      assertions.isOfType(\"X[]\", \"Integer[][]\", true).isTrue();\n-                      assertions.isOfType(\"T[]\", \"Integer[][]\", true).isFalse();\n-                      assertions.isOfType(\"U[]\", \"V[]\", true).isTrue();\n-                      assertions.isOfType(\"V[]\", \"U[]\", true).isTrue();\n-                      assertions.isOfType(\"Integer[][]\", \"int[]\", true).isFalse();\n-                      assertions.isOfType(\"Map<String, T>\", \"Map<String, List<Map<Integer, String>>>\", true).isFalse();\n-                      assertions.isOfType(\"Map<String, X>\", \"Map<String, List<Map<Integer, String>>>\", true).isTrue();\n-                      assertions.isOfType(\"Map<String, List<Map<Integer, String>>>\", \"Map<String, T>\", true).isFalse();\n-                  }\n-              }\n-            )\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void isClassAssignableTo() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import java.io.Serializable;\n-              import java.util.ArrayList;\n-              import java.util.Collection;\n-              import java.util.List;\n-              \n-              @SuppressWarnings(\"all\")\n-              class Test<T extends Number & Serializable, U> {\n-                  Integer integer;\n-                  Boolean bool;\n-                  Double bool;\n-                  Number number;\n-                  Cloneable cloneable;\n-                  Serializable serializable;\n-                  String[] array;\n-              \n-                  Object obj;\n-                  String str;\n-                  List listRaw;\n-                  Collection collectionRaw;\n-                  ArrayList arrayListRaw;\n-                  List<String> listString;\n-                  T genericBounded;\n-                  U generic;\n-              }\n-              \"\"\",\n-            spec -> spec.afterRecipe(cu -> {\n-                  try (TypeUtilsAssertions assertions = new TypeUtilsAssertions(cu)) {\n-                      // Boxed from primitives\n-                      assertions.isAssignableTo(\"Integer\", \"int\").isTrue();\n-                      assertions.isAssignableTo(\"Number\", \"int\").isTrue();\n-                      assertions.isAssignableTo(\"Serializable\", \"int\").isTrue();\n-                      assertions.isAssignableTo(\"Boolean\", \"boolean\").isTrue();\n-                      assertions.isAssignableTo(\"Number\", \"boolean\").isFalse();\n-                      assertions.isAssignableTo(\"Serializable\", \"boolean\").isTrue();\n-                      assertions.isAssignableTo(\"Double\", \"double\").isTrue();\n-                      assertions.isAssignableTo(\"Number\", \"double\").isTrue();\n-                      assertions.isAssignableTo(\"Serializable\", \"double\").isTrue();\n-                      assertions.isAssignableTo(\"String\", \"int\").isFalse();\n-\n-                      // FullyQualified direct\n-                      assertions.isAssignableTo(\"Object\", \"String\").isTrue();\n-                      assertions.isAssignableTo(\"String\", \"Object\").isFalse();\n-                      assertions.isAssignableTo(\"List\", \"String\").isFalse();\n-\n-                      // Null type (assignable to any reference type)\n-                      assertions.isAssignableTo(\"String\", \"null\").isTrue();\n-                      assertions.isAssignableTo(\"List\", \"null\").isTrue();\n-\n-                      // Parameterized type to raw type\n-                      assertions.isAssignableTo(\"List\", \"List<String>\").isTrue();\n-\n-                      // Class to interface\n-                      assertions.isAssignableTo(\"Serializable\", \"String\").isTrue();\n-                      assertions.isAssignableTo(\"Collection\", \"ArrayList\").isTrue();\n-\n-                      // Interface to class\n-                      assertions.isAssignableTo(\"String\", \"Serializable\").isFalse();\n-\n-                      // Array assignability\n-                      assertions.isAssignableTo(\"Object\", \"String[]\").isTrue();\n-                      assertions.isAssignableTo(\"Cloneable\", \"String[]\").isTrue();\n-                      assertions.isAssignableTo(\"Serializable\", \"String[]\").isTrue();\n-\n-                      // Generic type <T extends Number & Serializable, U>\n-                      assertions.isAssignableTo(\"Serializable\", \"T\").isTrue();\n-                      assertions.isAssignableTo(\"Number\", \"T\").isTrue();\n-                      assertions.isAssignableTo(\"String\", \"T\").isFalse();\n-                      assertions.isAssignableTo(\"Object\", \"T\").isTrue();\n-                      assertions.isAssignableTo(\"Number\", \"U\").isFalse();\n-                      assertions.isAssignableTo(\"Number\", \"U\").isFalse();\n-                      assertions.isAssignableTo(\"Object\", \"U\").isTrue();\n-                  }\n-              }\n-            )\n-          )\n-        );\n-    }\n-\n-    @Test\n-    @SuppressWarnings(\"rawtypes\")\n-    void isParameterizedAssignableTo() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import java.util.*;\n-              import java.util.function.Supplier;\n-              \n-              class Test<T, U extends T, N extends Number, CS extends CharSequence> {\n-                  ArrayList v1;\n-                  Comparable<?> v2;\n-                  Comparable<ImplementsComparable> v3;\n-                  Comparable<Number> v4;\n-                  Comparable<String> v5;\n-                  ComparableSupplier<String, Number> v6;\n-                  ExtendsComparable v7;\n-                  List v8;\n-                  List<? extends CharSequence> v9;\n-                  List<? extends List<? extends CharSequence>> v10;\n-                  List<? super String> v11;\n-                  List<? super CharSequence> v25;\n-                  List<? super T> v26;\n-                  List<? super U> v27;\n-                  List<?> v12;\n-                  List<CS> v13;\n-                  List<CharSequence> v14;\n-                  List<List<? extends CharSequence>> v15;\n-                  List<List<String>> v16;\n-                  List<N> v17;\n-                  List<String> v18;\n-                  List<T> v19;\n-                  List<U> v20;\n-                  MySupplier<Number> v21;\n-                  Supplier<Number> v22;\n-                  Supplier<String> v23;\n-                  ImplementsComparable v24;\n-                  Map<N, N> mapNN;\n-                  Map<String, String> mapSS;\n-                  Map<Integer, Integer> mapII;\n-                  Map<Long, Integer> mapLI;\n-              \n-                  static abstract class ImplementsComparable implements Comparable<ImplementsComparable> {}\n-                  static abstract class ExtendsComparable extends ImplementsComparable {}\n-                  static abstract class MySupplier<T> implements Supplier<T> {}\n-                  static abstract class ComparableSupplier<T, U> extends MySupplier<U> implements Comparable<T> {}\n-              }\n-              \"\"\",\n-            spec -> spec.afterRecipe(cu -> {\n-                  try (TypeUtilsAssertions assertions = new TypeUtilsAssertions(cu)) {\n-                      // 1. Generic Variance\n-                      assertions.isAssignableTo(\"List<? extends CharSequence>\", \"List<String>\").isTrue();\n-                      assertions.isAssignableTo(\"List<String>\", \"List<? extends CharSequence>\").isFalse();\n-                      assertions.isAssignableTo(\"List<? super String>\", \"List<CharSequence>\").isTrue();\n-\n-                      // 2. Wildcards and Raw Types\n-                      assertions.isAssignableTo(\"List<?>\", \"List<String>\").isTrue();\n-                      assertions.isAssignableTo(\"List<?>\", \"ArrayList\").isTrue();\n-                      assertions.isAssignableTo(\"List<String>\", \"List\").isFalse(); // We don't allow unsafe assignments\n-                      assertions.isAssignableTo(\"List<?>\", \"List\").isTrue(); // Except for wildcards\n-\n-                      // 3. Type Hierarchy with Generics (String, Number)\n-                      assertions.isAssignableTo(\"Comparable<?>\", \"ImplementsComparable\").isTrue();\n-                      assertions.isAssignableTo(\"Comparable<ImplementsComparable>\", \"ImplementsComparable\").isTrue();\n-                      assertions.isAssignableTo(\"Comparable<ImplementsComparable>\", \"ExtendsComparable\").isTrue();\n-                      assertions.isAssignableTo(\"Comparable<?>\", \"ExtendsComparable\").isTrue();\n-                      assertions.isAssignableTo(\"Comparable<String>\", \"ExtendsComparable\").isFalse();\n-\n-                      assertions.isAssignableTo(\"Comparable<String>\", \"ComparableSupplier<String, Number>\").isTrue();\n-                      assertions.isAssignableTo(\"Comparable<Number>\", \"ComparableSupplier<String, Number>\").isFalse();\n-                      assertions.isAssignableTo(\"Supplier<Number>\", \"ComparableSupplier<String, Number>\").isTrue();\n-                      assertions.isAssignableTo(\"Supplier<String>\", \"ComparableSupplier<String, Number>\").isFalse();\n-                      assertions.isAssignableTo(\"MySupplier<Number>\", \"ComparableSupplier<String, Number>\").isTrue();\n-                      assertions.isAssignableTo(\"Comparable<?>\", \"ComparableSupplier<String, Number>\").isTrue();\n-\n-                      // 4. Type Variables\n-                      assertions.isAssignableTo(\"List<T>\", \"List<String>\").isFalse();\n-                      assertions.isAssignableTo(\"List<T>\", \"List<U>\").isFalse();\n-                      assertions.isAssignableTo(\"List<? extends CharSequence>\", \"List<CS>\").isTrue();\n-                      assertions.isAssignableTo(\"List<? super U>\", \"List<? super T>\").isTrue();\n-                      assertions.isAssignableTo(\"List<? super String>\", \"List<? super CharSequence>\").isTrue();\n-                      assertions.isAssignableTo(\"List<? super T>\", \"List<? super U>\").isFalse();\n-                      assertions.isAssignableTo(\"List<? super CharSequence>\", \"List<? super String>\").isFalse();\n-\n-                      // 5. Edge Cases\n-                      assertions.isAssignableTo(\"List<? extends List<? extends CharSequence>>\", \"List<List<String>>\").isTrue();\n-                      assertions.isAssignableTo(\"List<List<? extends CharSequence>>\", \"List<List<String>>\").isFalse();\n-\n-                      // 6. Inference Mode\n-                      assertions.isAssignableTo(\"List<T>\", \"List<String>\", true).isTrue();\n-                      assertions.isAssignableTo(\"List<CS>\", \"List<String>\", true).isTrue();\n-                      assertions.isAssignableTo(\"List<N>\", \"List<String>\", true).isFalse();\n-                      assertions.isAssignableTo(\"List<? super T>\", \"List<? super String>\", true).isTrue();\n-                      assertions.isAssignableTo(\"Map<N, N>\", \"Map<String, String>\", true).isFalse();\n-                      assertions.isAssignableTo(\"Map<N, N>\", \"Map<Integer, Integer>\", true).isTrue();\n-                      assertions.isAssignableTo(\"Map<N, N>\", \"Map<Long, Integer>\", true).isTrue(); // This should be false\n-                  }\n-              }\n-            )\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void isAssignableToArray() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              class Test<T extends CharSequence, U, V extends Number> {\n-                  Object[] objectArray;\n-                  String[] stringArray;\n-                  CharSequence[] charSequenceArray;\n-                  int[] intArray;\n-                  double[] doubleArray;\n-                  Integer[] integerArray;\n-                  Double[][] double2DArray;\n-                  Number[][] number2DArray;\n-                  Object[][] object2DArray;\n-                  String[][] string2DArray;\n-                  T[] genericCsArray;\n-                  U[] genericArray;\n-                  V[] genericNumericArray;\n-                  U generic;\n-              }\n-              \"\"\",\n-            spec -> spec.afterRecipe(cu -> {\n-                  try (TypeUtilsAssertions assertions = new TypeUtilsAssertions(cu)) {\n-                      // Identity and exact match\n-                      assertions.isAssignableTo(\"String[]\", \"String[]\").isTrue();\n-\n-                      // Covariant assignability of reference types\n-                      assertions.isAssignableTo(\"Object[]\", \"String[]\").isTrue();\n-                      assertions.isAssignableTo(\"CharSequence[]\", \"String[]\").isTrue();\n-\n-                      // Reverse should fail\n-                      assertions.isAssignableTo(\"String[]\", \"Object[]\").isFalse();\n-                      assertions.isAssignableTo(\"String[]\", \"CharSequence[]\").isFalse();\n-\n-                      // Primitive arrays are not assignable to Object[]\n-                      assertions.isAssignableTo(\"Object[]\", \"int[]\").isFalse();\n-                      assertions.isAssignableTo(\"Object[]\", \"Integer[]\").isTrue();\n-\n-                      // Primitive identity\n-                      assertions.isAssignableTo(\"int[]\", \"int[]\").isTrue();\n-                      assertions.isAssignableTo(\"int[]\", \"Integer[]\").isFalse();\n-                      assertions.isAssignableTo(\"Integer[]\", \"int[]\").isFalse();\n-\n-                      // Different primitives are not assignable\n-                      assertions.isAssignableTo(\"int[]\", \"double[]\").isFalse();\n-\n-                      // 2D array covariance\n-                      assertions.isAssignableTo(\"Object[][]\", \"String[][]\").isTrue();\n-                      assertions.isAssignableTo(\"Number[][]\", \"Double[][]\").isTrue();\n-                      assertions.isAssignableTo(\"Double[][]\", \"Number[][]\").isFalse();\n-\n-                      // Incompatible inner dimension\n-                      assertions.isAssignableTo(\"Number[][]\", \"Integer[]\").isFalse();\n-\n-                      // Generics: <T extends CharSequence, U>\n-                      assertions.isAssignableTo(\"T[]\", \"String[]\").isFalse();\n-                      assertions.isAssignableTo(\"T[]\", \"CharSequence[]\").isFalse();\n-                      assertions.isAssignableTo(\"Object[]\", \"T[]\").isTrue();\n-                      assertions.isAssignableTo(\"CharSequence[]\", \"T[]\").isTrue();\n-                      assertions.isAssignableTo(\"U[]\", \"CharSequence[]\").isFalse();\n-                      assertions.isAssignableTo(\"Object[]\", \"U[]\").isTrue();\n-\n-                      // Infer mode: <T extends CharSequence, U>\n-                      assertions.isAssignableTo(\"T[]\", \"String[]\", true).isTrue();\n-                      assertions.isAssignableTo(\"T[]\", \"CharSequence[]\", true).isTrue();\n-                      assertions.isAssignableTo(\"T[]\", \"String[][]\", true).isFalse();\n-\n-                      assertions.isAssignableTo(\"U\", \"String[]\", true).isTrue();\n-                      assertions.isAssignableTo(\"U\", \"CharSequence[]\", true).isTrue();\n-                      assertions.isAssignableTo(\"U\", \"String[][]\", true).isTrue();\n-                      assertions.isAssignableTo(\"U\", \"int[]\", true).isTrue();\n-                      assertions.isAssignableTo(\"U\", \"double[]\", true).isTrue();\n-\n-                      assertions.isAssignableTo(\"U[]\", \"String[]\", true).isTrue();\n-                      assertions.isAssignableTo(\"U[]\", \"CharSequence[]\", true).isTrue();\n-                      assertions.isAssignableTo(\"U[]\", \"String[][]\", true).isTrue();\n-                      assertions.isAssignableTo(\"U[]\", \"int[]\", true).isFalse();\n-                      assertions.isAssignableTo(\"V[]\", \"int[]\", true).isFalse();\n-                      assertions.isAssignableTo(\"V[]\", \"Integer[]\", true).isTrue();\n-                      assertions.isAssignableTo(\"U[]\", \"double[]\", true).isFalse();\n-                  }\n-              }\n-            )\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void isAssignableToPrimitive() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              class Test<T, U extends Number> {\n-                  Byte boxedByte;\n-                  Character boxedChar;\n-                  Short boxedShort;\n-                  Integer boxedInt;\n-                  Long boxedLong;\n-                  Float boxedFloat;\n-                  Double boxedDouble;\n-                  Boolean boxedBoolean;\n-              \n-                  T genericT;\n-                  U genericU;\n-              }\n-              \"\"\",\n-            spec -> spec.afterRecipe(cu -> {\n-                  try (TypeUtilsAssertions assertions = new TypeUtilsAssertions(cu)) {\n-                      // Direct primitive assignability\n-                      assertions.isAssignableTo(\"int\", \"byte\").isTrue();\n-                      assertions.isAssignableTo(\"int\", \"char\").isTrue();\n-                      assertions.isAssignableTo(\"int\", \"short\").isTrue();\n-                      assertions.isAssignableTo(\"int\", \"int\").isTrue();\n-                      assertions.isAssignableTo(\"int\", \"long\").isFalse();\n-                      assertions.isAssignableTo(\"float\", \"int\").isTrue();\n-                      assertions.isAssignableTo(\"double\", \"float\").isTrue();\n-                      assertions.isAssignableTo(\"float\", \"double\").isFalse();\n-\n-                      // Boolean isn't compatible with numeric types\n-                      assertions.isAssignableTo(\"int\", \"boolean\").isFalse();\n-                      assertions.isAssignableTo(\"boolean\", \"boolean\").isTrue();\n-                      assertions.isAssignableTo(\"boolean\", \"int\").isFalse();\n-\n-                      // Auto-unboxing\n-                      assertions.isAssignableTo(\"int\", \"Integer\").isTrue();\n-                      assertions.isAssignableTo(\"double\", \"Double\").isTrue();\n-                      assertions.isAssignableTo(\"boolean\", \"Boolean\").isTrue();\n-                      assertions.isAssignableTo(\"Integer\", \"int\").isTrue();\n-                      assertions.isAssignableTo(\"Double\", \"double\").isTrue();\n-                      assertions.isAssignableTo(\"Boolean\", \"boolean\").isTrue();\n-\n-                      // Mismatched boxed types\n-                      assertions.isAssignableTo(\"int\", \"Boolean\").isFalse();\n-                      assertions.isAssignableTo(\"boolean\", \"Integer\").isFalse();\n-                      assertions.isAssignableTo(\"Boolean\", \"int\").isFalse();\n-                      assertions.isAssignableTo(\"Integer\", \"boolean\").isFalse();\n-\n-                      // Generics <T, U extends Number>\n-                      assertions.isAssignableTo(\"T\", \"byte\", true).isTrue();\n-                      assertions.isAssignableTo(\"T\", \"short\", true).isTrue();\n-                      assertions.isAssignableTo(\"T\", \"char\", true).isTrue();\n-                      assertions.isAssignableTo(\"T\", \"int\", true).isTrue();\n-                      assertions.isAssignableTo(\"T\", \"long\", true).isTrue();\n-                      assertions.isAssignableTo(\"T\", \"float\", true).isTrue();\n-                      assertions.isAssignableTo(\"T\", \"double\", true).isTrue();\n-                      assertions.isAssignableTo(\"T\", \"boolean\", true).isTrue();\n-\n-                      assertions.isAssignableTo(\"U\", \"byte\", true).isTrue();\n-                      assertions.isAssignableTo(\"U\", \"short\", true).isTrue();\n-                      assertions.isAssignableTo(\"U\", \"int\", true).isTrue();\n-                      assertions.isAssignableTo(\"U\", \"long\", true).isTrue();\n-                      assertions.isAssignableTo(\"U\", \"float\", true).isTrue();\n-                      assertions.isAssignableTo(\"U\", \"double\", true).isTrue();\n-                      assertions.isAssignableTo(\"U\", \"char\", true).isFalse();\n-                      assertions.isAssignableTo(\"U\", \"boolean\", true).isFalse();\n-                  }\n-              }\n-            )\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void isAssignableToGenericTypeVariable() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              class Test {\n-                  class A<T, U extends T, V extends U, X> {\n-                      T t;\n-                      U u;\n-                      V v;\n-                      X x;\n-                  }\n-              \n-                  class B<T, U extends T, V extends U, X> {\n-                      T t;\n-                      U u;\n-                      V v;\n-                      X x;\n-                  }\n-              }\n-              \"\"\",\n-            spec -> spec.afterRecipe(cu -> {\n-                  try (TypeUtilsAssertions assertions = new TypeUtilsAssertions(cu)) {\n-                      // 1. Same variable name\n-                      assertions.isAssignableTo(\"T\", \"T\").isTrue();\n-                      assertions.isAssignableTo(\"U\", \"U\").isTrue();\n-                      assertions.isOfType(\"T\", \"T\").isTrue();\n-\n-                      // 2. Different variables with compatible bounds\n-                      // class <T, U extends T, V extends U>\n-                      assertions.isAssignableTo(\"T\", \"U\").isTrue(); // U is assignable to T\n-                      assertions.isAssignableTo(\"U\", \"T\").isFalse(); // T not assignable to U (U more specific)\n-                      assertions.isAssignableTo(\"T\", \"V\").isTrue(); // V -> U -> T\n-                      assertions.isAssignableTo(\"U\", \"V\").isTrue(); // V -> U\n-                      assertions.isAssignableTo(\"V\", \"T\").isFalse(); // T is more general\n-\n-                      // 3. Unrelated variables\n-                      // class <T, X>\n-                      assertions.isAssignableTo(\"T\", \"X\").isFalse();\n-                      assertions.isAssignableTo(\"X\", \"T\").isFalse();\n-\n-                      // 4. isOfType tests for completeness\n-                      assertions.isOfType(\"T\", \"T\").isTrue();\n-                      assertions.isOfType(\"U\", \"U\").isTrue();\n-                      assertions.isOfType(\"T\", \"U\").isFalse();\n-                      assertions.isOfType(\"U\", \"T\").isFalse();\n-                  }\n-              }\n-            )\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void recursiveTypes() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              abstract class Comp implements Comparable<Comp> {}\n-              abstract class Ext extends Comp {}\n-              enum EnumType { A, B, C }\n-              \n-              class Test<E extends Enum<E>, C extends Comparable<? super C>, T> {\n-                  E e;\n-                  C c;\n-                  T free;\n-                  Comp comp;\n-                  Ext ext;\n-                  EnumType enumType;\n-                  Comparable<Comp> comparable;\n-              }\n-              \"\"\",\n-            spec -> spec.afterRecipe(cu -> {\n-                  try (TypeUtilsAssertions assertions = new TypeUtilsAssertions(cu)) {\n-                      assertions.isOfType(\"Comp\", \"Comp\").isTrue();\n-                      assertions.isOfType(\"Ext\", \"Ext\").isTrue();\n-                      assertions.isOfType(\"EnumType\", \"EnumType\").isTrue();\n-\n-                      assertions.isAssignableTo(\"E\", \"EnumType\", false).isFalse();\n-                      assertions.isAssignableTo(\"E\", \"EnumType\", true).isTrue();\n-\n-                      assertions.isAssignableTo(\"C\", \"Comp\", false).isFalse();\n-                      assertions.isAssignableTo(\"C\", \"Ext\", false).isFalse();\n-\n-                      assertions.isAssignableTo(\"C\", \"Comp\", true).isTrue();\n-                      assertions.isAssignableTo(\"C\", \"Ext\", true).isTrue();\n-\n-                      assertions.isAssignableTo(\"C\", \"Comparable<Comp>\", false).isFalse();\n-                      assertions.isAssignableTo(\"C\", \"Comparable<Comp>\", true).isTrue();\n-\n-                      assertions.isAssignableTo(\"Comparable<Comp>\", \"Comp\").isTrue();\n-                      assertions.isAssignableTo(\"Comparable<Comp>\", \"Ext\").isTrue();\n-                  }\n-              }\n-            )\n-          )\n-        );\n-    }\n-\n-    @Test\n-    @MinimumJava11\n-    void intersectionTypes() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import java.io.*;\n-              import java.util.*;\n-              \n-              @SuppressWarnings(\"all\")\n-              public class Test {\n-                  void test() {\n-                      var intersection1 = (Cloneable & Serializable) null;\n-                      var intersection2 = (Serializable & Cloneable) null;\n-                      Serializable serializable;\n-                      Cloneable cloneable;\n-                      int[] arrayPrimitive;\n-                      DuplicateFormatFlagsException extendIllegal;\n-                      RuntimeException exception;\n-                      try {} catch (NullPointerException | IllegalArgumentException exception1) {}\n-                      try {} catch (IllegalArgumentException | NullPointerException exception2) {}\n-                  }\n-              }\n-              \"\"\",\n-            spec -> spec.afterRecipe(cu -> {\n-                  try (TypeUtilsAssertions assertions = new TypeUtilsAssertions(cu)) {\n-                      assertions.isOfType(\"intersection1\", \"intersection2\").isTrue();\n-                      assertions.isAssignableTo(\"intersection1\", \"int[]\").isTrue();\n-                      assertions.isAssignableTo(\"int[]\", \"intersection1\").isFalse();\n-                      assertions.isAssignableTo(\"Serializable\", \"intersection1\").isTrue();\n-                      assertions.isAssignableTo(\"Cloneable\", \"intersection1\").isTrue();\n-\n-                      assertions.isOfType(\"NullPointerException | IllegalArgumentException\", \"IllegalArgumentException | NullPointerException\").isTrue();\n-                      assertions.isAssignableTo(\"NullPointerException | IllegalArgumentException\", \"DuplicateFormatFlagsException\").isTrue();\n-                      assertions.isAssignableTo(\"DuplicateFormatFlagsException\", \"NullPointerException | IllegalArgumentException\").isFalse();\n-                      assertions.isAssignableTo(\"NullPointerException | IllegalArgumentException\", \"RuntimeException\").isFalse();\n-                      assertions.isAssignableTo(\"RuntimeException\", \"NullPointerException | IllegalArgumentException\").isTrue();\n-                      assertions.isAssignableTo(\"exception2\", \"NullPointerException | IllegalArgumentException\").isTrue();\n-                  }\n-              }\n-            )\n-          )\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateGenericsTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateGenericsTest.java\nindex 5d3600db27d..bbd47e40287 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateGenericsTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateGenericsTest.java\n@@ -16,6 +16,7 @@\n package org.openrewrite.java;\n \n import org.junit.jupiter.api.Test;\n+import org.junitpioneer.jupiter.ExpectedToFail;\n import org.openrewrite.ExecutionContext;\n import org.openrewrite.java.tree.Expression;\n import org.openrewrite.java.tree.J;\n@@ -87,6 +88,7 @@ void test() {\n     }\n \n     @Test\n+    @ExpectedToFail(\"PR #5374 was reverted, due to regressions\")\n     void expressionTest() {\n         var template = JavaTemplate.builder(\"!#{iterable:any(java.lang.Iterable<T>)}.iterator().hasNext()\")\n           .genericTypes(\"T\")\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateMatchTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateMatchTest.java\nindex a29ef32165e..631d5732fd4 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateMatchTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateMatchTest.java\n@@ -18,6 +18,7 @@\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.ValueSource;\n+import org.junitpioneer.jupiter.ExpectedToFail;\n import org.openrewrite.DocumentExample;\n import org.openrewrite.ExecutionContext;\n import org.openrewrite.Issue;\n@@ -1001,6 +1002,7 @@ void test() {\n     }\n \n     @Test\n+    @ExpectedToFail(\"PR #5374 was reverted, due to regressions\")\n     void matchMemberReferenceContainingParameter() {\n         rewriteRun(\n           spec -> spec\n@@ -1023,7 +1025,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n           java(\n             \"\"\"\n               import java.util.Optional;\n-              \n+\n               class Foo {\n                   @SuppressWarnings(\"all\")\n                   void test() {\n@@ -1033,7 +1035,7 @@ void test() {\n               \"\"\",\n             \"\"\"\n               import java.util.Optional;\n-              \n+\n               class Foo {\n                   @SuppressWarnings(\"all\")\n                   void test() {\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/RenameVariableTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/RenameVariableTest.java\nindex 9b1cf033089..7818837398e 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/RenameVariableTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/RenameVariableTest.java\n@@ -16,11 +16,13 @@\n package org.openrewrite.java;\n \n import org.junit.jupiter.api.Test;\n+import org.junitpioneer.jupiter.ExpectedToFail;\n import org.openrewrite.DocumentExample;\n import org.openrewrite.ExecutionContext;\n import org.openrewrite.Issue;\n import org.openrewrite.Recipe;\n import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.Statement;\n import org.openrewrite.test.RewriteTest;\n \n import java.util.ArrayList;\n@@ -121,7 +123,7 @@ void renameFieldWithSameNameAsParameterWithJavaDoc() {\n             \"\"\"\n               public class A {\n                   private String name;\n-                  \n+              \n                   /**\n                    * The length of <code>name</code> added to the length of {@link #name}.\n                    *\n@@ -135,7 +137,7 @@ int fooA(String name) {\n             \"\"\"\n               public class A {\n                   private String _name;\n-                  \n+              \n                   /**\n                    * The length of <code>name</code> added to the length of {@link #_name}.\n                    *\n@@ -222,11 +224,11 @@ void isParameterizedClass() {\n           java(\n             \"\"\"\n               package org.openrewrite;\n-                            \n+              \n               public class A<T> {\n                   private String _val;\n                   private String name;\n-                   \n+              \n                   A(String name, String _val) {\n                       this._val = _val;\n                       this.name = name;\n@@ -235,11 +237,11 @@ public class A<T> {\n               \"\"\",\n             \"\"\"\n               package org.openrewrite;\n-                            \n+              \n               public class A<T> {\n                   private String v;\n                   private String name;\n-                   \n+              \n                   A(String name, String v) {\n                       this.v = v;\n                       this.name = name;\n@@ -820,7 +822,7 @@ public J visitVariableDeclarations(J.VariableDeclarations multiVariable, Executi\n             \"\"\"\n               public class B {\n                   int n;\n-                            \n+              \n                   {\n                       n++; // do not change.\n                       int n;\n@@ -829,7 +831,7 @@ public class B {\n                       if(n + 1 == 2) {}\n                       n++;\n                   }\n-                 \n+              \n                   public int foo(int n) {\n                       return n + this.n;\n                   }\n@@ -838,7 +840,7 @@ public int foo(int n) {\n             \"\"\"\n               public class B {\n                   int n;\n-                            \n+              \n                   {\n                       n++; // do not change.\n                       int n1;\n@@ -847,7 +849,7 @@ public class B {\n                       if(n1 + 1 == 2) {}\n                       n1++;\n                   }\n-                 \n+              \n                   public int foo(int n2) {\n                       return n2 + this.n;\n                   }\n@@ -1035,6 +1037,7 @@ public A setN(int n1) {\n     }\n \n     @Test\n+    @ExpectedToFail(\"PR #5372 was reverted, due to regressions\")\n     void hiddenVariablesHierarchyRenameBase() {\n         rewriteRun(\n           spec -> spec.recipe(toRecipe(() -> new JavaVisitor<>() {\n@@ -1130,6 +1133,7 @@ public Extended test(Base hidden) {\n     }\n \n     @Test\n+    @ExpectedToFail(\"PR #5372 was reverted, due to regressions\")\n     void hiddenVariablesHierarchyRenameExtended() {\n         rewriteRun(\n           spec -> spec.recipe(toRecipe(() -> new JavaVisitor<>() {\n@@ -1225,6 +1229,7 @@ public Extended test(Base hidden) {\n     }\n \n     @Test\n+    @ExpectedToFail(\"PR #5372 was reverted, due to regressions\")\n     void hiddenVariablesHierarchyRenameLocal() {\n         rewriteRun(\n           spec -> spec.recipe(toRecipe(() -> new JavaVisitor<>() {\n@@ -1318,4 +1323,112 @@ public Extended test(Base changed) {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/pull/5369\")\n+    void hiddenVariablesGetRenamedCorrectlyInBlocks() {\n+        rewriteRun(\n+          spec -> spec.recipe(toRecipe(() -> new JavaVisitor<>() {\n+              @Override\n+              public J visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {\n+                  if (multiVariable.getVariables().get(0).isField(getCursor()) || multiVariable.getPrefix().getComments().isEmpty()) {\n+                      return multiVariable;\n+                  }\n+                  doAfterVisit(new RenameVariable<>(multiVariable.getVariables().get(0), \"n1\"));\n+                  return super.visitVariableDeclarations(multiVariable, ctx);\n+              }\n+          })),\n+          java(\n+            \"\"\"\n+              public class A {\n+                  int n;\n+  \n+                  public void blocks() {\n+                      {\n+                          //only this one is in scope\n+                          int n = 0;\n+                          int x = n;\n+                      }\n+                      {\n+                          int n = 0;\n+                          int x = n;\n+                      }\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              public class A {\n+                  int n;\n+  \n+                  public void blocks() {\n+                      {\n+                          //only this one is in scope\n+                          int n1 = 0;\n+                          int x = n1;\n+                      }\n+                      {\n+                          int n = 0;\n+                          int x = n;\n+                      }\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/pull/5369\")\n+    void hiddenVariablesGetRenamedCorrectlyInClass() {\n+        rewriteRun(\n+          spec -> spec.recipe(toRecipe(() -> new JavaVisitor<>() {\n+\n+              @Override\n+              public J visitBlock(J.Block block, ExecutionContext ctx) {\n+                  if (getCursor().getParent() != null && getCursor().getParent().getValue() instanceof J.ClassDeclaration) {\n+                      for (Statement statement : block.getStatements()) {\n+                          if (statement instanceof J.VariableDeclarations) {\n+                              doAfterVisit(new RenameVariable<>(((J.VariableDeclarations) statement).getVariables().get(0), \"n1\"));\n+                          }\n+                      }\n+                  }\n+                  return super.visitBlock(block, ctx);\n+              }\n+          })),\n+          java(\n+            \"\"\"\n+              public class A {\n+                  int n;\n+  \n+                  public void blocks() {\n+                      {\n+                          int n = 0;\n+                          int x = n;\n+                      }\n+                      {\n+                          int n = 0;\n+                          int x = n;\n+                      }\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              public class A {\n+                  int n1;\n+  \n+                  public void blocks() {\n+                      {\n+                          int n = 0;\n+                          int x = n;\n+                      }\n+                      {\n+                          int n = 0;\n+                          int x = n;\n+                      }\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5380",
    "pr_id": 5380,
    "issue_id": 5379,
    "repo": "openrewrite/rewrite",
    "problem_statement": "JCase where guard is not present has invalid syntax after calling WithGuard\n## What version of OpenRewrite are you using?\nI am using `latest.release` of gradle plugin\n\n## How are you running OpenRewrite?\ngradle plugin to run the unit test/write recipe\n\n## What is the smallest, simplest way to reproduce the problem?\nCall `withGuard` on the second `JCase`\n```java\nclass Test {\n    void guardedCases(Object o) {\n        switch (o) {\n            case Integer i when i > 0 -> System.out.println(\"Perfect\");\n            case String s -> System.out.println(\"Great\");\n            default -> System.out.println(\"Ok\");\n        }\n    }\n}\n```\n\n## What did you expect to see?\n```java\ncase String s when \"YES\".equalsIgnoreCase(s) -> System.out.println(\"Great\");\n```\n\n## What did you see instead?\nNo space between the labels and the newly added guard\n```java\ncase String swhen \"YES\".equalsIgnoreCase(s) -> System.out.println(\"Great\");\n```\n\n## What is the full stack trace of any errors you encountered?\n`getLabels` returns a `JContainer` of `JRightPadded` labels. When a guard is present, the last rightpadded contains a space/newline/... to print before the when. When the original case has no JRightPadded space (as the lambda has the space?) and we add a guard, the when is printed immediatly after. \nWe could also change this in the Printer itself -> print \" when\" if the labels last expression had no/empty space.\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\nbranch on the way\n",
    "issue_word_count": 236,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-java-21/build.gradle.kts",
      "rewrite-java-21/src/test/java/org/openrewrite/java/SwitchEnhancementsTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/format/MinimumViableSpacingVisitor.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-21/src/test/java/org/openrewrite/java/SwitchEnhancementsTest.java"
    ],
    "base_commit": "0b690af9bb052bac20c77099f587ed7456f61411",
    "head_commit": "4fa549debfc63be59fa2f2ad12215a6fcc189eaf",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5380",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5380",
    "dockerfile": "",
    "pr_merged_at": "2025-05-08T23:10:43.000Z",
    "patch": "diff --git a/rewrite-java-21/build.gradle.kts b/rewrite-java-21/build.gradle.kts\nindex 8dcc7049c81..4a1be282103 100644\n--- a/rewrite-java-21/build.gradle.kts\n+++ b/rewrite-java-21/build.gradle.kts\n@@ -26,6 +26,7 @@ dependencies {\n     implementation(\"org.ow2.asm:asm:latest.release\")\n \n     testImplementation(project(\":rewrite-test\"))\n+    testImplementation(\"org.antlr:antlr4-runtime:4.13.2\")\n     \"javaTck\"(project(\":rewrite-java-tck\"))\n }\n \n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/format/MinimumViableSpacingVisitor.java b/rewrite-java/src/main/java/org/openrewrite/java/format/MinimumViableSpacingVisitor.java\nindex d67926dbf4e..e7ed1fce2a9 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/format/MinimumViableSpacingVisitor.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/format/MinimumViableSpacingVisitor.java\n@@ -211,6 +211,20 @@ public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations m\n         return v;\n     }\n \n+    @Override\n+    public J.Case visitCase(J.Case _case, P p) {\n+        J.Case c = super.visitCase(_case, p);\n+\n+        if (c.getGuard() != null) {\n+            // At a minimum, we need a space between the guard and the case label\n+            JContainer.Padding<J> padding = c.getPadding().getCaseLabels().getPadding();\n+            return c.getPadding().withCaseLabels(padding.withElements(ListUtils.mapLast(padding.getElements(),\n+                    last -> last != null && last.getAfter().isEmpty() ? last.withAfter(Space.SINGLE_SPACE) : last)));\n+        }\n+\n+        return c;\n+    }\n+\n     @Override\n     public @Nullable J postVisit(J tree, P p) {\n         if (stopAfter != null && stopAfter.isScope(tree)) {\n",
    "test_patch": "diff --git a/rewrite-java-21/src/test/java/org/openrewrite/java/SwitchEnhancementsTest.java b/rewrite-java-21/src/test/java/org/openrewrite/java/SwitchEnhancementsTest.java\nnew file mode 100644\nindex 00000000000..49de9d9422c\n--- /dev/null\n+++ b/rewrite-java-21/src/test/java/org/openrewrite/java/SwitchEnhancementsTest.java\n@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.Cursor;\n+import org.openrewrite.ExecutionContext;\n+import org.openrewrite.java.tree.Expression;\n+import org.openrewrite.java.tree.J;\n+import org.openrewrite.test.RewriteTest;\n+\n+import static org.openrewrite.java.Assertions.java;\n+\n+class SwitchEnhancementsTest implements RewriteTest {\n+\n+    @Test\n+    void addSwitchGuard() {\n+        rewriteRun(\n+          spec -> spec\n+            .recipe(RewriteTest.toRecipe(() -> new JavaIsoVisitor<>() {\n+                @Override\n+                public J.Case visitCase(J.Case case_, ExecutionContext ctx) {\n+                    if (case_.getBody() == null || case_.getGuard() != null || case_.getCaseLabels().getFirst() instanceof J.Identifier) {\n+                        return case_;\n+                    }\n+                    J.Identifier s = ((J.VariableDeclarations) case_.getCaseLabels().getFirst()).getVariables().getFirst().getName();\n+                    Expression expression = JavaTemplate.apply(\n+                      \"\\\"YES\\\".equalsIgnoreCase(#{any(String)})\",\n+                      new Cursor(getCursor(), case_.getBody()),\n+                      ((Expression) case_.getBody()).getCoordinates().replace(),\n+                      s);\n+                    return autoFormat(case_.withGuard(expression), ctx);\n+                }\n+            })),\n+          //language=java\n+          java(\n+            \"\"\"\n+              class Test {\n+                  void guardedCases(Object o) {\n+                      switch (o) {\n+                          case Integer i when i > 0 -> System.out.println(\"Perfect\");\n+                          case String s -> System.out.println(\"Great\");\n+                          default -> System.out.println(\"Ok\");\n+                      }\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              class Test {\n+                  void guardedCases(Object o) {\n+                      switch (o) {\n+                          case Integer i when i > 0 -> System.out.println(\"Perfect\");\n+                          case String s when \"YES\".equalsIgnoreCase(s) -> System.out.println(\"Great\");\n+                          default -> System.out.println(\"Ok\");\n+                      }\n+                  }\n+              }\n+              \"\"\"\n+          ));\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5375",
    "pr_id": 5375,
    "issue_id": 4868,
    "repo": "openrewrite/rewrite",
    "problem_statement": "RemoveDuplicateDependencies Removes Dependency with Classifier, Breaking Maven Build\n\r\n## What version of OpenRewrite are you using?\r\n8.42.4\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\n- OpenRewrite v8.42.4\r\n- Maven/Gradle plugin v5.47.3\r\n- rewrite-_module_ v2.31.0\r\n\r\n## How are you running OpenRewrite?\r\n\r\n`mvnw org.openrewrite.maven:rewrite-maven-plugin:5.47.3:run  -Drewrite.recipeArtifactCoordinates=org.openrewrite.recipe:rewrite-migrate-java:LATEST -Drewrite.activeRecipes=org.openrewrite.maven.RemoveDuplicateDependencies`\r\n\r\nThe issue can be reproduced: https://github.com/torsten-liermann/orw-problem-removeduplicatesdependencies\r\n\r\n`RemoveDuplicateDependencies` mistakenly removes a dependency from the dependency management. The peculiarity of this dependency is that it appears twice in the dependency management: once with a classifier and once without a classifier. Depending on the order of these two dependencies, one of them gets removed, resulting in a non-functional build. The demo contains the setup that triggers this error. \r\n\r\n```\r\n         <dependencyManagement>\r\n              <dependencies>\r\n                <dependency>\r\n                        <groupId>com.adobe.aio.cloudmanager</groupId>\r\n                        <artifactId>aio-lib-cloudmanager</artifactId>\r\n                        <classifier>java8</classifier>\r\n                        <version>2.0.0</version>\r\n                </dependency>\r\n                <dependency>\r\n                        <groupId>com.adobe.aio.cloudmanager</groupId>\r\n                        <artifactId>aio-lib-cloudmanager</artifactId>\r\n                        <version>2.0.0</version>\r\n                </dependency>\r\n            </dependencies>\r\n        </dependencyManagement>\r\n```\r\n\r\n\r\nReordering the dependencies resolves the issue.\r\n\r\n```\r\n        <dependencyManagement>\r\n              <dependencies>\r\n                <dependency>\r\n                        <groupId>com.adobe.aio.cloudmanager</groupId>\r\n                        <artifactId>aio-lib-cloudmanager</artifactId>\r\n                        <version>2.0.0</version>\r\n                </dependency>\r\n                <dependency>\r\n                        <groupId>com.adobe.aio.cloudmanager</groupId>\r\n                        <artifactId>aio-lib-cloudmanager</artifactId>\r\n                        <classifier>java8</classifier>\r\n                        <version>2.0.0</version>\r\n                </dependency>\r\n            </dependencies>\r\n        </dependencyManagement>\r\n```\r\n\r\n",
    "issue_word_count": 328,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/RemoveDuplicateDependenciesTest.java",
      "rewrite-maven/src/test/resources/junit-platform.properties"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/RemoveDuplicateDependenciesTest.java",
      "rewrite-maven/src/test/resources/junit-platform.properties"
    ],
    "base_commit": "ae69105d4df3ef3d981fdab270008621baf27db9",
    "head_commit": "07587d3f6f1c18015d4420034b9a2cb46d139ad4",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5375",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5375",
    "dockerfile": "",
    "pr_merged_at": "2025-05-04T13:15:31.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\nindex 91d50d56855..7eb87780d9e 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n@@ -293,7 +293,7 @@ private boolean isTag(String name) {\n                 .orElse(getResolutionResult().getPom().getGroupId()));\n         String artifactId = getResolutionResult().getPom().getValue(tag.getChildValue(\"artifactId\").orElse(\"\"));\n         String classifier = getResolutionResult().getPom().getValue(tag.getChildValue(\"classifier\").orElse(null));\n-        String type = getResolutionResult().getPom().getValue(tag.getChildValue(\"type\").orElse(null));\n+        String type = getResolutionResult().getPom().getValue(tag.getChildValue(\"type\").orElse(\"jar\"));\n         if (groupId != null && artifactId != null) {\n             return findManagedDependency(groupId, artifactId, classifier, type);\n         }\n@@ -305,15 +305,15 @@ private boolean isTag(String name) {\n     }\n \n     private @Nullable ResolvedManagedDependency findManagedDependency(String groupId, String artifactId, @Nullable String classifier) {\n-        return findManagedDependency(groupId, artifactId, classifier, null);\n+        return findManagedDependency(groupId, artifactId, classifier, \"jar\");\n     }\n \n-    private @Nullable ResolvedManagedDependency findManagedDependency(String groupId, String artifactId, @Nullable String classifier, @Nullable String type) {\n+    private @Nullable ResolvedManagedDependency findManagedDependency(String groupId, String artifactId, @Nullable String classifier, String type) {\n         for (ResolvedManagedDependency d : getResolutionResult().getPom().getDependencyManagement()) {\n             if (groupId.equals(d.getGroupId()) &&\n                 artifactId.equals(d.getArtifactId()) &&\n-                (classifier == null || classifier.equals(d.getClassifier())) &&\n-                (type == null || type.equals(d.getType()))) {\n+                Objects.equals(classifier, d.getClassifier()) &&\n+                Objects.equals(type, d.getType())) {\n                 return d;\n             }\n         }\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveDuplicateDependenciesTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveDuplicateDependenciesTest.java\nindex 03461047494..09637f70523 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveDuplicateDependenciesTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveDuplicateDependenciesTest.java\n@@ -554,4 +554,36 @@ void retainDuplicateManagedDependenciesWithDifferentClassifier() {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4868\")\n+    @Test\n+    void retainWithAndWithoutClassifier() {\n+        rewriteRun(\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencyManagement>\n+                      <dependencies>\n+                          <dependency>\n+                              <groupId>com.adobe.aio.cloudmanager</groupId>\n+                              <artifactId>aio-lib-cloudmanager</artifactId>\n+                              <classifier>java8</classifier>\n+                              <version>2.0.0</version>\n+                          </dependency>\n+                          <dependency>\n+                              <groupId>com.adobe.aio.cloudmanager</groupId>\n+                              <artifactId>aio-lib-cloudmanager</artifactId>\n+                              <version>2.0.0</version>\n+                          </dependency>\n+                      </dependencies>\n+                  </dependencyManagement>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-maven/src/test/resources/junit-platform.properties b/rewrite-maven/src/test/resources/junit-platform.properties\nnew file mode 100644\nindex 00000000000..5483e834e87\n--- /dev/null\n+++ b/rewrite-maven/src/test/resources/junit-platform.properties\n@@ -0,0 +1,18 @@\n+#\n+# Copyright 2025 the original author or authors.\n+# <p>\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+# <p>\n+# https://www.apache.org/licenses/LICENSE-2.0\n+# <p>\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+junit.jupiter.execution.parallel.enabled = true\n+junit.jupiter.execution.parallel.mode.default = concurrent\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5371",
    "pr_id": 5371,
    "issue_id": 5357,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Support adding platform dependencies to Gradle project\n<!--\nThank you for suggesting an improvement to OpenRewrite!\nFeel free to delete any sections that don't apply to your request.\n-->\n## What problem are you trying to solve?\nIt would be useful to be able to add platform dependencies to a project.\n\nFollowing from this, with [RemoveRedundantDependencyVersions](https://docs.openrewrite.org/recipes/gradle/removeredundantdependencyversions)\n\n- #3290\n\nmay become possible via a declarative recipe?\n\n## Describe the solution you'd like\nImprove the `AddDependency` recipe to support adding platform dependencies\n\n## Are you interested in [contributing this feature to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#new-features)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\nYes",
    "issue_word_count": 126,
    "test_files_count": 6,
    "non_test_files_count": 6,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/AddPlatformDependency.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleConfigurationFilter.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/internal/AddDependencyVisitor.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/JvmTestSuite.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/Traits.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/AddPlatformDependencyTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindJVMTestSuitesTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/trait/JvmTestSuiteTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/JvmTestSuite.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/AddPlatformDependencyTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindJVMTestSuitesTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/trait/JvmTestSuiteTest.java"
    ],
    "base_commit": "982ad13ca1282bc9831864670f8bb800454c8e04",
    "head_commit": "d01c72117d37b9f2f2335139f9678f703a8b0fa6",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5371",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5371",
    "dockerfile": "",
    "pr_merged_at": "2025-06-09T23:56:44.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java\nindex e437684e928..55e8bad033e 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java\n@@ -19,9 +19,9 @@\n import lombok.Value;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n-import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n import org.openrewrite.gradle.search.FindJVMTestSuites;\n+import org.openrewrite.gradle.trait.JvmTestSuite;\n import org.openrewrite.internal.StringUtils;\n import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.marker.JavaProject;\n@@ -30,13 +30,12 @@\n import org.openrewrite.java.tree.J;\n import org.openrewrite.java.tree.JavaSourceFile;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n+import org.openrewrite.maven.tree.GroupArtifact;\n import org.openrewrite.semver.Semver;\n \n import java.util.*;\n-import java.util.function.Predicate;\n \n import static java.util.Collections.singletonList;\n-import static java.util.Objects.requireNonNull;\n \n @Value\n @EqualsAndHashCode(callSuper = false)\n@@ -144,7 +143,6 @@ public Validated<Object> validate() {\n     public static class Scanned {\n         Map<JavaProject, Boolean> usingType = new HashMap<>();\n         Map<JavaProject, Set<String>> configurationsByProject = new HashMap<>();\n-        Map<JavaProject, Set<String>> customJvmTestSuitesWithDependencies = new HashMap<>();\n     }\n \n     @Override\n@@ -177,9 +175,6 @@ private boolean usesType(SourceFile sourceFile, ExecutionContext ctx) {\n                 SourceFile sourceFile = (SourceFile) tree;\n                 sourceFile.getMarkers().findFirst(JavaProject.class).ifPresent(javaProject -> {\n                     acc.usingType.compute(javaProject, (jp, usingType) -> Boolean.TRUE.equals(usingType) || usesType(sourceFile, ctx));\n-                    acc.customJvmTestSuitesWithDependencies\n-                            .computeIfAbsent(javaProject, ignored -> new HashSet<>())\n-                            .addAll(FindJVMTestSuites.jvmTestSuiteNames(tree, true));\n \n                     Set<String> configurations = acc.configurationsByProject.computeIfAbsent(javaProject, ignored -> new HashSet<>());\n                     sourceFile.getMarkers().findFirst(JavaSourceSet.class).ifPresent(sourceSet ->\n@@ -202,20 +197,14 @@ public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {\n                         }\n                         JavaSourceFile s = (JavaSourceFile) tree;\n                         Optional<JavaProject> maybeJp = s.getMarkers().findFirst(JavaProject.class);\n-                        if (!maybeJp.isPresent()) {\n-                            return s;\n-                        }\n-\n-                        JavaProject jp = maybeJp.get();\n-                        if ((onlyIfUsing != null && !acc.usingType.getOrDefault(jp, false)) || !acc.configurationsByProject.containsKey(jp)) {\n-                            return s;\n-                        }\n-\n                         Optional<GradleProject> maybeGp = s.getMarkers().findFirst(GradleProject.class);\n-                        if (!maybeGp.isPresent()) {\n+                        if (!maybeJp.isPresent() ||\n+                                (onlyIfUsing != null && !acc.usingType.getOrDefault(maybeJp.get(), false)) || !acc.configurationsByProject.containsKey(maybeJp.get()) ||\n+                                !maybeGp.isPresent()) {\n                             return s;\n                         }\n \n+                        JavaProject jp = maybeJp.get();\n                         GradleProject gp = maybeGp.get();\n \n                         Set<String> resolvedConfigurations = StringUtils.isBlank(configuration) ?\n@@ -224,36 +213,26 @@ public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {\n                         if (resolvedConfigurations.isEmpty()) {\n                             resolvedConfigurations.add(\"implementation\");\n                         }\n-                        Set<String> tmpConfigurations = new HashSet<>(resolvedConfigurations);\n-                        for (String tmpConfiguration : tmpConfigurations) {\n-                            GradleDependencyConfiguration gdc = gp.getConfiguration(tmpConfiguration);\n-                            if (gdc == null || gdc.findRequestedDependency(groupId, artifactId) != null) {\n-                                resolvedConfigurations.remove(tmpConfiguration);\n-                            }\n-                        }\n \n-                        tmpConfigurations = new HashSet<>(resolvedConfigurations);\n-                        for (String tmpConfiguration : tmpConfigurations) {\n-                            GradleDependencyConfiguration gdc = requireNonNull((gp.getConfiguration(tmpConfiguration)));\n-                            for (GradleDependencyConfiguration transitive : gp.configurationsExtendingFrom(gdc, true)) {\n-                                if (resolvedConfigurations.contains(transitive.getName()) ||\n-                                        (Boolean.TRUE.equals(acceptTransitive) && transitive.findResolvedDependency(groupId, artifactId) != null)) {\n-                                    resolvedConfigurations.remove(transitive.getName());\n-                                }\n-                            }\n-                        }\n+                        GradleConfigurationFilter gradleConfigurationFilter = new GradleConfigurationFilter(gp, resolvedConfigurations);\n+                        gradleConfigurationFilter.removeTransitiveConfigurations();\n+                        gradleConfigurationFilter.removeConfigurationsContainingDependency(new GroupArtifact(groupId, artifactId));\n+                        gradleConfigurationFilter.removeConfigurationsContainingTransitiveDependency(new GroupArtifact(groupId, artifactId));\n+                        resolvedConfigurations = gradleConfigurationFilter.getFilteredConfigurations();\n \n                         if (resolvedConfigurations.isEmpty()) {\n                             return s;\n                         }\n \n+                        Set<JvmTestSuite> jvmTestSuites = FindJVMTestSuites.jvmTestSuites(s);\n                         for (String resolvedConfiguration : resolvedConfigurations) {\n-                            if (targetsCustomJVMTestSuite(resolvedConfiguration, acc.customJvmTestSuitesWithDependencies.get(jp))) {\n-                                s = (JavaSourceFile) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, purgeSourceSet(configuration),\n-                                        classifier, extension, metadataFailures, isMatchingJVMTestSuite(resolvedConfiguration)).visitNonNull(s, ctx);\n+                            JvmTestSuite jvmTestSuite = maybeJvmTestSuite(resolvedConfiguration, jvmTestSuites);\n+                            if (jvmTestSuite != null) {\n+                                s = (JavaSourceFile) jvmTestSuite.addDependency(resolvedConfiguration, groupId, artifactId, version, versionPattern, classifier, extension, metadataFailures, null, ctx)\n+                                        .visitNonNull(s, ctx);\n                             } else {\n                                 s = (JavaSourceFile) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, resolvedConfiguration,\n-                                        classifier, extension, metadataFailures, this::isTopLevel).visitNonNull(s, ctx);\n+                                        classifier, extension, metadataFailures, this::isTopLevel, null).visitNonNull(s, ctx);\n                             }\n                         }\n \n@@ -264,59 +243,13 @@ private boolean isTopLevel(Cursor cursor) {\n                         return cursor.getParentOrThrow().firstEnclosing(J.MethodInvocation.class) == null;\n                     }\n \n-                    private Predicate<Cursor> isMatchingJVMTestSuite(String resolvedConfiguration) {\n-                        return cursor -> {\n-                            String sourceSet = purgeConfigurationSuffix(resolvedConfiguration);\n-                            J.MethodInvocation methodInvocation = cursor.getParentOrThrow().firstEnclosing(J.MethodInvocation.class);\n-                            return methodInvocation != null && sourceSet.equals(methodInvocation.getSimpleName());\n-                        };\n-                    }\n-\n-                    private final Set<String> gradleStandardConfigurations = new HashSet<>(Arrays.asList(\n-                            \"api\",\n-                            \"implementation\",\n-                            \"compileOnly\",\n-                            \"compileOnlyApi\",\n-                            \"runtimeOnly\",\n-                            \"testImplementation\",\n-                            \"testCompileOnly\",\n-                            \"testRuntimeOnly\"));\n-\n-                    boolean targetsCustomJVMTestSuite(String configuration, Set<String> customJvmTestSuites) {\n-                        if (gradleStandardConfigurations.contains(configuration) || \"default\".equals(configuration)) {\n-                            return false;\n-                        }\n-\n-                        String sourceSet = purgeConfigurationSuffix(configuration);\n-                        return customJvmTestSuites.contains(sourceSet);\n-                    }\n-\n-                    private String purgeConfigurationSuffix(String configuration) {\n-                        if (configuration.endsWith(\"Implementation\")) {\n-                            return configuration.substring(0, configuration.length() - 14);\n-                        } else if (configuration.endsWith(\"CompileOnly\")) {\n-                            return configuration.substring(0, configuration.length() - 11);\n-                        } else if (configuration.endsWith(\"RuntimeOnly\")) {\n-                            return configuration.substring(0, configuration.length() - 11);\n-                        } else if (configuration.endsWith(\"AnnotationProcessor\")) {\n-                            return configuration.substring(0, configuration.length() - 19);\n-                        } else {\n-                            return configuration;\n-                        }\n-                    }\n-\n-                    private String purgeSourceSet(@Nullable String configuration) {\n-                        if (StringUtils.isBlank(configuration) || configuration.endsWith(\"Implementation\")) {\n-                            return \"implementation\";\n-                        } else if (configuration.endsWith(\"CompileOnly\")) {\n-                            return \"compileOnly\";\n-                        } else if (configuration.endsWith(\"RuntimeOnly\")) {\n-                            return \"runtimeOnly\";\n-                        } else if (configuration.endsWith(\"AnnotationProcessor\")) {\n-                            return \"annotationProcessor\";\n-                        } else {\n-                            return configuration;\n+                    private @Nullable JvmTestSuite maybeJvmTestSuite(String configuration, Set<JvmTestSuite> jvmTestSuites) {\n+                        for (JvmTestSuite jvmTestSuite : jvmTestSuites) {\n+                            if (jvmTestSuite.isAcceptable(configuration)) {\n+                                return jvmTestSuite;\n+                            }\n                         }\n+                        return null;\n                     }\n                 })\n         );\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\nindex d07ceb664e8..be762ea59fe 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\n@@ -19,46 +19,23 @@\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.Cursor;\n import org.openrewrite.ExecutionContext;\n-import org.openrewrite.SourceFile;\n import org.openrewrite.Tree;\n-import org.openrewrite.gradle.internal.InsertDependencyComparator;\n import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n-import org.openrewrite.groovy.tree.G;\n-import org.openrewrite.internal.ListUtils;\n import org.openrewrite.internal.StringUtils;\n import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.MethodMatcher;\n import org.openrewrite.java.tree.J;\n import org.openrewrite.java.tree.JavaSourceFile;\n-import org.openrewrite.java.tree.Space;\n-import org.openrewrite.java.tree.Statement;\n import org.openrewrite.kotlin.tree.K;\n-import org.openrewrite.marker.Markup;\n import org.openrewrite.maven.MavenDownloadingException;\n-import org.openrewrite.maven.MavenDownloadingExceptions;\n-import org.openrewrite.maven.internal.MavenPomDownloader;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n-import org.openrewrite.maven.tree.*;\n-import org.openrewrite.tree.ParseError;\n+import org.openrewrite.maven.tree.GroupArtifact;\n+import org.openrewrite.maven.tree.GroupArtifactVersion;\n \n-import java.io.ByteArrayInputStream;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Paths;\n-import java.util.*;\n import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.util.Collections.emptyList;\n-import static java.util.Collections.singletonList;\n-import static java.util.Objects.requireNonNull;\n \n @RequiredArgsConstructor\n public class AddDependencyVisitor extends JavaIsoVisitor<ExecutionContext> {\n-    private static final MethodMatcher DEPENDENCIES_DSL_MATCHER = new MethodMatcher(\"RewriteGradleProject dependencies(..)\");\n-    private static final GradleParser GRADLE_PARSER = GradleParser.builder().build();\n-\n     private final String groupId;\n     private final String artifactId;\n \n@@ -85,354 +62,63 @@ public class AddDependencyVisitor extends JavaIsoVisitor<ExecutionContext> {\n     @Nullable\n     private final Predicate<Cursor> insertPredicate;\n \n+    @Nullable\n+    private final DependencyModifier dependencyModifier;\n+\n+    @Nullable\n+    private transient GradleProject gradleProject;\n+\n+    private transient boolean isKotlinDsl;\n+\n     @Override\n     public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n         if (tree instanceof JavaSourceFile) {\n-            JavaSourceFile cu = (JavaSourceFile) super.visit(tree, ctx);\n-            Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);\n-            if (!maybeGp.isPresent()) {\n-                return cu;\n+            JavaSourceFile sourceFile = (JavaSourceFile) tree;\n+            gradleProject = sourceFile.getMarkers().findFirst(GradleProject.class).orElse(null);\n+            if (gradleProject == null) {\n+                return sourceFile;\n             }\n \n-            GradleProject gp = maybeGp.get();\n-            GradleDependencyConfiguration gdc = gp.getConfiguration(configuration);\n+            GradleDependencyConfiguration gdc = gradleProject.getConfiguration(configuration);\n             if (gdc == null || gdc.findRequestedDependency(groupId, artifactId) != null) {\n-                return cu;\n-            }\n-\n-            boolean dependenciesBlockMissing = true;\n-            if (cu instanceof G.CompilationUnit) {\n-                G.CompilationUnit g = (G.CompilationUnit) cu;\n-                for (Statement statement : g.getStatements()) {\n-                    if (statement instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) statement)) {\n-                        dependenciesBlockMissing = false;\n-                    }\n-                }\n-            } else if (cu instanceof K.CompilationUnit) {\n-                K.CompilationUnit k = (K.CompilationUnit) cu;\n-                for (Statement statement : ((J.Block) k.getStatements().get(0)).getStatements()) {\n-                    if (statement instanceof J.MethodInvocation && ((J.MethodInvocation) statement).getSimpleName().equals(\"dependencies\")) {\n-                        dependenciesBlockMissing = false;\n-                    }\n-                }\n-            }\n-\n-            if (dependenciesBlockMissing) {\n-                if (cu instanceof G.CompilationUnit) {\n-                    G.CompilationUnit g = (G.CompilationUnit) cu;\n-                    Statement dependenciesInvocation = GRADLE_PARSER.parse(ctx, \"dependencies {}\")\n-                            .findFirst()\n-                            .map(G.CompilationUnit.class::cast)\n-                            .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"))\n-                            .getStatements().get(0);\n-                    Cursor parent = getCursor();\n-                    setCursor(new Cursor(parent, g));\n-                    dependenciesInvocation = autoFormat(dependenciesInvocation, ctx, new Cursor(parent, g));\n-                    setCursor(parent);\n-                    cu = g.withStatements(ListUtils.concat(g.getStatements(),\n-                            g.getStatements().isEmpty() ?\n-                                    dependenciesInvocation :\n-                                    dependenciesInvocation.withPrefix(Space.format(\"\\n\\n\"))));\n-                } else {\n-                    K.CompilationUnit k = (K.CompilationUnit) cu;\n-                    J.MethodInvocation dependenciesInvocation = (J.MethodInvocation) ((J.Block) GRADLE_PARSER.parseInputs(Collections.singletonList(new GradleParser.Input(Paths.get(\"build.gradle.kts\"), () -> new ByteArrayInputStream(\"dependencies {}\".getBytes(StandardCharsets.UTF_8)))), null, ctx)\n-                            .findFirst()\n-                            .map(K.CompilationUnit.class::cast)\n-                            .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"))\n-                            .getStatements().get(0)).getStatements().get(0);\n-                    Cursor parent = getCursor();\n-                    setCursor(new Cursor(parent, k));\n-                    dependenciesInvocation = autoFormat(dependenciesInvocation, ctx, new Cursor(getCursor(), k));\n-                    setCursor(parent);\n-                    dependenciesInvocation = dependenciesInvocation.withArguments(ListUtils.mapFirst(dependenciesInvocation.getArguments(), arg -> {\n-                        J.Lambda lambda = (J.Lambda) requireNonNull(arg);\n-                        J.Block block = (J.Block) lambda.getBody();\n-                        return lambda.withBody(block.withEnd(Space.format(\"\\n\")));\n-                    }));\n-                    cu = k.withStatements(ListUtils.concat(k.getStatements(),\n-                            k.getStatements().isEmpty() ?\n-                                    dependenciesInvocation :\n-                                    dependenciesInvocation.withPrefix(Space.format(\"\\n\\n\"))));\n-                }\n-            }\n-\n-            cu = (JavaSourceFile) new InsertDependencyInOrder(configuration, gp)\n-                    .visitNonNull(cu, ctx);\n-\n-            if (cu != tree) {\n-                String versionWithPattern = StringUtils.isBlank(resolvedVersion) || resolvedVersion.startsWith(\"$\") ? null : resolvedVersion;\n-                cu = addDependency(cu,\n-                        gdc,\n-                        new GroupArtifactVersion(groupId, artifactId, versionWithPattern),\n-                        classifier,\n-                        ctx);\n-            }\n-            return cu;\n-        }\n-        return super.visit(tree, ctx);\n-    }\n-\n-    /**\n-     * Update the dependency model, adding the specified dependency to the specified configuration and all configurations\n-     * which extend from it.\n-     *\n-     * @param buildScript   compilation unit owning the {@link GradleProject} marker\n-     * @param configuration the configuration to add the dependency to\n-     * @param gav           the group, artifact, and version of the dependency to add\n-     * @param classifier    the classifier of the dependency to add\n-     * @param ctx           context which will be used to download the pom for the dependency\n-     * @return a copy of buildScript with the dependency added\n-     */\n-    static JavaSourceFile addDependency(\n-            JavaSourceFile buildScript,\n-            @Nullable GradleDependencyConfiguration configuration,\n-            GroupArtifactVersion gav,\n-            @Nullable String classifier,\n-            ExecutionContext ctx) {\n-        if (gav.getGroupId() == null || gav.getArtifactId() == null || configuration == null) {\n-            return buildScript;\n-        }\n-        GradleProject gp = buildScript.getMarkers().findFirst(GradleProject.class)\n-                .orElseThrow(() -> new IllegalArgumentException(\"Could not find GradleProject\"));\n-\n-        try {\n-            ResolvedGroupArtifactVersion resolvedGav;\n-            List<ResolvedDependency> transitiveDependencies;\n-            if (gav.getVersion() == null) {\n-                resolvedGav = null;\n-                transitiveDependencies = Collections.emptyList();\n-            } else {\n-                MavenPomDownloader mpd = new MavenPomDownloader(ctx);\n-                Pom pom = mpd.download(gav, null, null, gp.getMavenRepositories());\n-                ResolvedPom resolvedPom = pom.resolve(emptyList(), mpd, gp.getMavenRepositories(), ctx);\n-                resolvedGav = resolvedPom.getGav();\n-                transitiveDependencies = resolvedPom.resolveDependencies(Scope.Runtime, mpd, ctx);\n-            }\n-            Map<String, GradleDependencyConfiguration> nameToConfiguration = gp.getNameToConfiguration();\n-            Map<String, GradleDependencyConfiguration> newNameToConfiguration = new HashMap<>(nameToConfiguration.size());\n-\n-            Set<GradleDependencyConfiguration> configurationsToAdd = Stream.concat(\n-                            Stream.of(configuration),\n-                            gp.configurationsExtendingFrom(configuration, true).stream())\n-                    .collect(Collectors.toSet());\n-\n-            for (GradleDependencyConfiguration gdc : nameToConfiguration.values()) {\n-                if (!configurationsToAdd.contains(gdc)) {\n-                    newNameToConfiguration.put(gdc.getName(), gdc);\n-                    continue;\n-                }\n-\n-                GradleDependencyConfiguration newGdc = gdc;\n-                org.openrewrite.maven.tree.Dependency newRequested = new org.openrewrite.maven.tree.Dependency(\n-                        gav, classifier, \"jar\", gdc.getName(), emptyList(), null);\n-                newGdc = newGdc.withRequested(ListUtils.concat(\n-                        ListUtils.map(gdc.getRequested(), requested -> {\n-                            // Remove any existing dependency with the same group and artifact id\n-                            if (Objects.equals(requested.getGroupId(), gav.getGroupId()) && Objects.equals(requested.getArtifactId(), gav.getArtifactId())) {\n-                                return null;\n-                            }\n-                            return requested;\n-                        }),\n-                        newRequested));\n-                if (newGdc.isCanBeResolved() && resolvedGav != null) {\n-                    newGdc = newGdc.withDirectResolved(ListUtils.concat(\n-                            ListUtils.map(gdc.getDirectResolved(), resolved -> {\n-                                // Remove any existing dependency with the same group and artifact id\n-                                if (Objects.equals(resolved.getGroupId(), resolvedGav.getGroupId()) && Objects.equals(resolved.getArtifactId(), resolvedGav.getArtifactId())) {\n-                                    return null;\n-                                }\n-                                return resolved;\n-                            }),\n-                            new ResolvedDependency(null, resolvedGav, newRequested, transitiveDependencies,\n-                                    emptyList(), \"jar\", classifier, null, 0, null)));\n-                }\n-                newNameToConfiguration.put(newGdc.getName(), newGdc);\n-            }\n-            gp = gp.withNameToConfiguration(newNameToConfiguration);\n-        } catch (MavenDownloadingException | MavenDownloadingExceptions | IllegalArgumentException e) {\n-            return Markup.warn(buildScript, e);\n-        }\n-        return buildScript.withMarkers(buildScript.getMarkers().setByType(gp));\n-    }\n-\n-    @RequiredArgsConstructor\n-    private class InsertDependencyInOrder extends JavaIsoVisitor<ExecutionContext> {\n-        private final String configuration;\n-\n-        private final GradleProject gp;\n-\n-        @Override\n-        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n-            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n-            boolean isKotlinDsl = getCursor().firstEnclosing(JavaSourceFile.class) instanceof K.CompilationUnit;\n-            if (!DEPENDENCIES_DSL_MATCHER.matches(m) && !(isKotlinDsl && m.getSimpleName().equals(\"dependencies\"))) {\n-                return m;\n-            }\n-\n-            if (insertPredicate != null && !insertPredicate.test(getCursor())) {\n-                return m;\n-            }\n-\n-            J.Lambda dependenciesBlock = (J.Lambda) m.getArguments().get(0);\n-            if (!(dependenciesBlock.getBody() instanceof J.Block)) {\n-                return m;\n+                return sourceFile;\n             }\n \n+            isKotlinDsl = sourceFile instanceof K.CompilationUnit;\n             if (version != null) {\n                 if (version.startsWith(\"$\")) {\n                     resolvedVersion = version;\n                 } else {\n                     try {\n-                        resolvedVersion = new DependencyVersionSelector(metadataFailures, gp, null)\n+                        resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)\n                                 .select(new GroupArtifact(groupId, artifactId), configuration, version, versionPattern, ctx);\n                     } catch (MavenDownloadingException e) {\n-                        return e.warn(m);\n+                        return (J) e.warn(tree);\n                     }\n                 }\n             }\n \n-            J.Block body = (J.Block) dependenciesBlock.getBody();\n-\n-            String codeTemplate;\n-            DependencyStyle style = autodetectDependencyStyle(body.getStatements());\n-            if (style == DependencyStyle.String) {\n-                if (!isKotlinDsl) {\n-                    codeTemplate = \"dependencies {\\n\" +\n-                                   escapeIfNecessary(configuration) + \" \\\"\" + groupId + \":\" + artifactId + (resolvedVersion == null ? \"\" : \":\" + resolvedVersion) + (resolvedVersion == null || classifier == null ? \"\" : \":\" + classifier) + (extension == null ? \"\" : \"@\" + extension) + \"\\\"\" +\n-                                   \"\\n}\";\n-                } else {\n-                    codeTemplate = \"dependencies {\\n\" +\n-                                   configuration + \"(\\\"\" + groupId + \":\" + artifactId + (resolvedVersion == null ? \"\" : \":\" + resolvedVersion) + (resolvedVersion == null || classifier == null ? \"\" : \":\" + classifier) + (extension == null ? \"\" : \"@\" + extension) + \"\\\")\" +\n-                                   \"\\n}\";\n-                }\n-            } else {\n-                if (!isKotlinDsl) {\n-                    codeTemplate = \"dependencies {\\n\" +\n-                                   escapeIfNecessary(configuration) + \" group: \\\"\" + groupId + \"\\\", name: \\\"\" + artifactId + \"\\\"\" + (resolvedVersion == null ? \"\" : \", version: \\\"\" + resolvedVersion + \"\\\"\") + (classifier == null ? \"\" : \", classifier: \\\"\" + classifier + \"\\\"\") + (extension == null ? \"\" : \", ext: \\\"\" + extension + \"\\\"\") +\n-                                   \"\\n}\";\n-                } else {\n-                    codeTemplate = \"dependencies {\\n\" +\n-                                   configuration + \"(group = \\\"\" + groupId + \"\\\", name = \\\"\" + artifactId + \"\\\"\" + (resolvedVersion == null ? \"\" : \", version = \\\"\" + resolvedVersion + \"\\\"\") + (classifier == null ? \"\" : \", classifier = \\\"\" + classifier + \"\\\"\") + (extension == null ? \"\" : \", ext = \\\"\" + extension + \"\\\"\") + \")\" +\n-                                   \"\\n}\";\n-                }\n-            }\n-\n-            Boolean requirePrintEqualsInput = ctx.getMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT);\n-            ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, false);\n-            SourceFile parsed;\n-            if (!isKotlinDsl) {\n-                parsed = GRADLE_PARSER.parse(ctx, codeTemplate)\n-                        .findFirst()\n-                        .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"));\n-            } else {\n-                parsed = GRADLE_PARSER.parseInputs(Collections.singletonList(new GradleParser.Input(Paths.get(\"build.gradle.kts\"), () -> new ByteArrayInputStream(codeTemplate.getBytes(StandardCharsets.UTF_8)))), null, ctx)\n-                        .findFirst()\n-                        .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"));\n-            }\n-            ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, requirePrintEqualsInput);\n-\n-            if (parsed instanceof ParseError) {\n-                throw ((ParseError) parsed).toException();\n-            }\n-\n-            J.MethodInvocation addDependencyInvocation;\n-            if (!isKotlinDsl) {\n-                addDependencyInvocation = requireNonNull((J.MethodInvocation) ((J.Return) (((J.Block) ((J.Lambda) ((J.MethodInvocation)\n-                        ((G.CompilationUnit) parsed).getStatements().get(0)).getArguments().get(0)).getBody()).getStatements().get(0))).getExpression());\n-            } else {\n-                addDependencyInvocation = requireNonNull((J.MethodInvocation) (((J.Block) ((J.Lambda) ((J.MethodInvocation)\n-                        ((J.Block) ((K.CompilationUnit) parsed).getStatements().get(0)).getStatements().get(0)).getArguments().get(0)).getBody()).getStatements().get(0)));\n-            }\n-            addDependencyInvocation = autoFormat(addDependencyInvocation, ctx, new Cursor(getCursor(), body));\n-            InsertDependencyComparator dependencyComparator = new InsertDependencyComparator(body.getStatements(), addDependencyInvocation);\n-\n-            List<Statement> statements = new ArrayList<>(body.getStatements());\n-            int i = 0;\n-            for (; i < body.getStatements().size(); i++) {\n-                Statement currentStatement = body.getStatements().get(i);\n-                if (dependencyComparator.compare(currentStatement, addDependencyInvocation) > 0) {\n-                    if (dependencyComparator.getBeforeDependency() != null) {\n-                        J.MethodInvocation beforeDependency = (J.MethodInvocation) (dependencyComparator.getBeforeDependency() instanceof J.Return ?\n-                                requireNonNull(((J.Return) dependencyComparator.getBeforeDependency()).getExpression()) :\n-                                dependencyComparator.getBeforeDependency());\n-                        if (i == 0) {\n-                            if (!addDependencyInvocation.getSimpleName().equals(beforeDependency.getSimpleName())) {\n-                                statements.set(i, currentStatement.withPrefix(Space.format(\"\\n\\n\" + currentStatement.getPrefix().getIndent())));\n-                            }\n-                        } else {\n-                            Space originalPrefix = addDependencyInvocation.getPrefix();\n-                            addDependencyInvocation = addDependencyInvocation.withPrefix(currentStatement.getPrefix());\n+            sourceFile = (JavaSourceFile) new org.openrewrite.gradle.internal.AddDependencyVisitor(configuration, groupId, artifactId, resolvedVersion, classifier, extension, insertPredicate, dependencyModifier, isKotlinDsl)\n+                    .visitNonNull(sourceFile, ctx);\n \n-                            if (addDependencyInvocation.getSimpleName().equals(beforeDependency.getSimpleName())) {\n-                                if (!currentStatement.getPrefix().equals(originalPrefix)) {\n-                                    statements.set(i, currentStatement.withPrefix(originalPrefix));\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    statements.add(i, addDependencyInvocation);\n-                    break;\n-                }\n-            }\n-            if (body.getStatements().size() == i) {\n-                if (!body.getStatements().isEmpty()) {\n-                    Statement lastStatement;\n-                    if (statements.get(i - 1) instanceof J.Return) {\n-                        J.Return r = (J.Return) statements.remove(i - 1);\n-                        lastStatement = requireNonNull(r.getExpression()).withPrefix(r.getPrefix());\n-                        statements.add(lastStatement);\n-                    } else {\n-                        lastStatement = statements.get(i - 1);\n-                    }\n-                    if (lastStatement instanceof J.MethodInvocation && !((J.MethodInvocation) lastStatement).getSimpleName().equals(addDependencyInvocation.getSimpleName())) {\n-                        addDependencyInvocation = addDependencyInvocation.withPrefix(Space.format(\"\\n\\n\" + addDependencyInvocation.getPrefix().getIndent()));\n-                    }\n-                }\n-                statements.add(addDependencyInvocation);\n+            if (sourceFile != tree) {\n+                String versionWithPattern = StringUtils.isBlank(resolvedVersion) || resolvedVersion.startsWith(\"$\") ? null : resolvedVersion;\n+                sourceFile = org.openrewrite.gradle.internal.AddDependencyVisitor.addDependency(\n+                        sourceFile,\n+                        gradleProject.getConfiguration(configuration),\n+                        new GroupArtifactVersion(groupId, artifactId, versionWithPattern),\n+                        classifier,\n+                        ctx\n+                );\n             }\n-            body = body.withStatements(statements);\n-            m = m.withArguments(singletonList(dependenciesBlock.withBody(body)));\n \n-            return m;\n+            return sourceFile;\n         }\n+        return (J) tree;\n     }\n \n-    private String escapeIfNecessary(String configurationName) {\n-        // default is a gradle configuration created by the base plugin and a groovy keyword if\n-        // it is used it needs to be escaped\n-        return configurationName.equals(\"default\") ? \"'\" + configurationName + \"'\" : configurationName;\n-    }\n-\n-    enum DependencyStyle {\n-        Map, String\n-    }\n-\n-    private DependencyStyle autodetectDependencyStyle(List<Statement> statements) {\n-        int string = 0;\n-        int map = 0;\n-        for (Statement statement : statements) {\n-            if (statement instanceof J.Return && ((J.Return) statement).getExpression() instanceof J.MethodInvocation) {\n-                J.MethodInvocation invocation = (J.MethodInvocation) ((J.Return) statement).getExpression();\n-                if (invocation.getArguments().get(0) instanceof J.Literal || invocation.getArguments().get(0) instanceof G.GString) {\n-                    string++;\n-                } else if (invocation.getArguments().get(0) instanceof G.MapEntry) {\n-                    map++;\n-                } else if (invocation.getArguments().get(0) instanceof J.Assignment) {\n-                    map++;\n-                }\n-            } else if (statement instanceof J.MethodInvocation) {\n-                J.MethodInvocation invocation = (J.MethodInvocation) statement;\n-                if (invocation.getArguments().get(0) instanceof J.Literal || invocation.getArguments().get(0) instanceof G.GString) {\n-                    string++;\n-                } else if (invocation.getArguments().get(0) instanceof G.MapEntry) {\n-                    map++;\n-                } else if (invocation.getArguments().get(0) instanceof J.Assignment) {\n-                    map++;\n-                }\n-            }\n-        }\n-\n-        return string >= map ? DependencyStyle.String : DependencyStyle.Map;\n+    public enum DependencyModifier {\n+        PLATFORM,\n+        ENFORCED_PLATFORM;\n     }\n }\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddPlatformDependency.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddPlatformDependency.java\nnew file mode 100644\nindex 00000000000..d4f72368f2e\n--- /dev/null\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddPlatformDependency.java\n@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.Value;\n+import org.jspecify.annotations.Nullable;\n+import org.openrewrite.*;\n+import org.openrewrite.gradle.marker.GradleProject;\n+import org.openrewrite.gradle.search.FindJVMTestSuites;\n+import org.openrewrite.gradle.trait.JvmTestSuite;\n+import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n+import org.openrewrite.java.marker.JavaProject;\n+import org.openrewrite.java.marker.JavaSourceSet;\n+import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaSourceFile;\n+import org.openrewrite.maven.table.MavenMetadataFailures;\n+import org.openrewrite.maven.tree.GroupArtifact;\n+import org.openrewrite.semver.Semver;\n+\n+import java.util.*;\n+\n+import static java.lang.Boolean.TRUE;\n+import static java.util.Collections.singletonList;\n+import static org.openrewrite.gradle.AddDependencyVisitor.DependencyModifier.ENFORCED_PLATFORM;\n+import static org.openrewrite.gradle.AddDependencyVisitor.DependencyModifier.PLATFORM;\n+\n+@Value\n+@EqualsAndHashCode(callSuper = false)\n+public class AddPlatformDependency extends ScanningRecipe<AddPlatformDependency.Scanned> {\n+\n+    @EqualsAndHashCode.Exclude\n+    MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);\n+\n+    @Option(displayName = \"Group\",\n+            description = \"The first part of a dependency coordinate 'com.google.guava:guava:VERSION'.\",\n+            example = \"com.google.guava\")\n+    String groupId;\n+\n+    @Option(displayName = \"Artifact\",\n+            description = \"The second part of a dependency coordinate 'com.google.guava:guava:VERSION'\",\n+            example = \"guava\")\n+    String artifactId;\n+\n+    @Option(displayName = \"Version\",\n+            description = \"An exact version number or node-style semver selector used to select the version number. \" +\n+                    \"You can also use `latest.release` for the latest available version and `latest.patch` if \" +\n+                    \"the current version is a valid semantic version. For more details, you can look at the documentation \" +\n+                    \"page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors).\",\n+            example = \"29.X\",\n+            required = false)\n+    @Nullable\n+    String version;\n+\n+    @Option(displayName = \"Version pattern\",\n+            description = \"Allows version selection to be extended beyond the original Node Semver semantics. So for example, \" +\n+                    \"Setting 'version' to \\\"25-29\\\" can be paired with a metadata pattern of \\\"-jre\\\" to select Guava 29.0-jre\",\n+            example = \"-jre\",\n+            required = false)\n+    @Nullable\n+    String versionPattern;\n+\n+    @Option(displayName = \"Configuration\",\n+            description = \"A configuration to use when it is not what can be inferred from usage. Most of the time this will be left empty, but \" +\n+                    \"is used when adding a new as of yet unused dependency.\",\n+            example = \"implementation\",\n+            required = false)\n+    @Nullable\n+    String configuration;\n+\n+    @Option(displayName = \"Enforced\",\n+            description = \"Used to determine whether the platform dependency should be enforcedPlatform.\",\n+            example = \"true\",\n+            required = false)\n+    @Nullable\n+    Boolean enforced;\n+\n+    @Override\n+    public String getDisplayName() {\n+        return \"Add Gradle platform dependency\";\n+    }\n+\n+    @Override\n+    public String getInstanceNameSuffix() {\n+        return String.format(\"`%s:%s:%s`\", groupId, artifactId, version);\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"Add a gradle platform dependency to a `build.gradle` file in the correct configuration based on where it is used.\";\n+    }\n+\n+    @Override\n+    public Validated<Object> validate() {\n+        Validated<Object> validated = super.validate();\n+        if (version != null) {\n+            validated = validated.and(Semver.validate(version, versionPattern));\n+        }\n+        return validated;\n+    }\n+\n+    public static class Scanned {\n+        Map<JavaProject, Set<String>> configurationsByProject = new HashMap<>();\n+    }\n+\n+    @Override\n+    public Scanned getInitialValue(ExecutionContext ctx) {\n+        return new Scanned();\n+    }\n+\n+    @Override\n+    public TreeVisitor<?, ExecutionContext> getScanner(Scanned acc) {\n+        return new TreeVisitor<Tree, ExecutionContext>() {\n+\n+            @Override\n+            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                if (!(tree instanceof SourceFile)) {\n+                    return tree;\n+                }\n+                SourceFile sourceFile = (SourceFile) tree;\n+                sourceFile.getMarkers().findFirst(JavaProject.class).ifPresent(javaProject -> {\n+                    Set<String> configurations = acc.configurationsByProject.computeIfAbsent(javaProject, ignored -> new HashSet<>());\n+                    sourceFile.getMarkers().findFirst(JavaSourceSet.class).ifPresent(sourceSet ->\n+                            configurations.add(\"main\".equals(sourceSet.getName()) ? \"implementation\" : sourceSet.getName() + \"Implementation\"));\n+                });\n+                return tree;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {\n+        return Preconditions.check(!acc.configurationsByProject.isEmpty(),\n+                Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {\n+\n+                    @Override\n+                    public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                        if (!(tree instanceof JavaSourceFile)) {\n+                            return (J) tree;\n+                        }\n+                        JavaSourceFile s = (JavaSourceFile) tree;\n+                        Optional<JavaProject> maybeJp = s.getMarkers().findFirst(JavaProject.class);\n+                        Optional<GradleProject> maybeGp = s.getMarkers().findFirst(GradleProject.class);\n+                        if (!maybeJp.isPresent() || !acc.configurationsByProject.containsKey(maybeJp.get()) || !maybeGp.isPresent()) {\n+                            return s;\n+                        }\n+\n+                        JavaProject jp = maybeJp.get();\n+                        GradleProject gp = maybeGp.get();\n+\n+                        Set<String> resolvedConfigurations = StringUtils.isBlank(configuration) ?\n+                                acc.configurationsByProject.getOrDefault(jp, new HashSet<>()) :\n+                                new HashSet<>(singletonList(configuration));\n+                        if (resolvedConfigurations.isEmpty()) {\n+                            resolvedConfigurations.add(\"implementation\");\n+                        }\n+\n+                        GradleConfigurationFilter gradleConfigurationFilter = new GradleConfigurationFilter(gp, resolvedConfigurations);\n+                        gradleConfigurationFilter.removeTransitiveConfigurations();\n+                        gradleConfigurationFilter.removeConfigurationsContainingDependency(new GroupArtifact(groupId, artifactId));\n+                        resolvedConfigurations = gradleConfigurationFilter.getFilteredConfigurations();\n+\n+                        if (resolvedConfigurations.isEmpty()) {\n+                            return s;\n+                        }\n+\n+                        Set<JvmTestSuite> jvmTestSuites = FindJVMTestSuites.jvmTestSuites(s);\n+                        AddDependencyVisitor.DependencyModifier modifier = TRUE.equals(enforced) ? ENFORCED_PLATFORM : PLATFORM;\n+                        for (String resolvedConfiguration : resolvedConfigurations) {\n+                            JvmTestSuite jvmTestSuite = maybeJvmTestSuite(resolvedConfiguration, jvmTestSuites);\n+                            if (jvmTestSuite != null) {\n+                                s = (JavaSourceFile) jvmTestSuite.addDependency(resolvedConfiguration, groupId, artifactId, version, versionPattern,\n+                                                null, null, metadataFailures, modifier, ctx).visitNonNull(s, ctx);\n+                            } else {\n+                                s = (JavaSourceFile) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, resolvedConfiguration,\n+                                        null, null, metadataFailures, this::isTopLevel, modifier).visitNonNull(s, ctx);\n+                            }\n+                        }\n+\n+                        return s;\n+                    }\n+\n+                    private boolean isTopLevel(Cursor cursor) {\n+                        return cursor.getParentOrThrow().firstEnclosing(J.MethodInvocation.class) == null;\n+                    }\n+\n+                    private @Nullable JvmTestSuite maybeJvmTestSuite(String configuration, Set<JvmTestSuite> jvmTestSuites) {\n+                        for (JvmTestSuite jvmTestSuite : jvmTestSuites) {\n+                            if (jvmTestSuite.isAcceptable(configuration)) {\n+                                return jvmTestSuite;\n+                            }\n+                        }\n+                        return null;\n+                    }\n+                }));\n+    }\n+}\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleConfigurationFilter.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleConfigurationFilter.java\nnew file mode 100644\nindex 00000000000..44fa009684b\n--- /dev/null\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleConfigurationFilter.java\n@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Moderne Source Available License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://docs.moderne.io/licensing/moderne-source-available-license\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle;\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n+import org.openrewrite.gradle.marker.GradleProject;\n+import org.openrewrite.maven.tree.GroupArtifact;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+@RequiredArgsConstructor\n+class GradleConfigurationFilter {\n+    private final GradleProject gradleProject;\n+\n+    @Getter\n+    private final Set<String> filteredConfigurations;\n+\n+    public void removeTransitiveConfigurations() {\n+        Set<String> tmpConfigurations = new HashSet<>(filteredConfigurations);\n+        for (String tmpConfiguration : tmpConfigurations) {\n+            GradleDependencyConfiguration gdc = requireNonNull((gradleProject.getConfiguration(tmpConfiguration)));\n+            for (GradleDependencyConfiguration transitive : gradleProject.configurationsExtendingFrom(gdc, true)) {\n+                filteredConfigurations.remove(transitive.getName());\n+            }\n+        }\n+    }\n+\n+    public void removeConfigurationsContainingDependency(GroupArtifact dependency) {\n+        Set<String> tmpConfigurations = new HashSet<>(filteredConfigurations);\n+        for (String tmpConfiguration : tmpConfigurations) {\n+            GradleDependencyConfiguration gdc = gradleProject.getConfiguration(tmpConfiguration);\n+            if (gdc == null || gdc.findRequestedDependency(dependency.getGroupId(), dependency.getArtifactId()) != null) {\n+                filteredConfigurations.remove(tmpConfiguration);\n+            }\n+        }\n+    }\n+\n+    public void removeConfigurationsContainingTransitiveDependency(GroupArtifact dependency) {\n+        Set<String> tmpConfigurations = new HashSet<>(filteredConfigurations);\n+        for (String tmpConfiguration : tmpConfigurations) {\n+            GradleDependencyConfiguration gdc = requireNonNull(gradleProject.getConfiguration(tmpConfiguration));\n+            for (GradleDependencyConfiguration transitive : gradleProject.configurationsExtendingFrom(gdc, true)) {\n+                if (transitive.findResolvedDependency(dependency.getGroupId(), dependency.getArtifactId()) != null) {\n+                    filteredConfigurations.remove(tmpConfiguration);\n+                }\n+            }\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/internal/AddDependencyVisitor.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/internal/AddDependencyVisitor.java\nnew file mode 100644\nindex 00000000000..b2c20174dfb\n--- /dev/null\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/internal/AddDependencyVisitor.java\n@@ -0,0 +1,459 @@\n+/*\n+ * Copyright 2022 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle.internal;\n+\n+import lombok.RequiredArgsConstructor;\n+import lombok.Value;\n+import org.jspecify.annotations.Nullable;\n+import org.openrewrite.Cursor;\n+import org.openrewrite.ExecutionContext;\n+import org.openrewrite.Tree;\n+import org.openrewrite.gradle.GradleParser;\n+import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n+import org.openrewrite.gradle.marker.GradleProject;\n+import org.openrewrite.gradle.trait.GradleDependency;\n+import org.openrewrite.groovy.tree.G;\n+import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n+import org.openrewrite.java.MethodMatcher;\n+import org.openrewrite.java.RandomizeIdVisitor;\n+import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaSourceFile;\n+import org.openrewrite.java.tree.Space;\n+import org.openrewrite.java.tree.Statement;\n+import org.openrewrite.kotlin.tree.K;\n+import org.openrewrite.marker.Markup;\n+import org.openrewrite.maven.MavenDownloadingException;\n+import org.openrewrite.maven.MavenDownloadingExceptions;\n+import org.openrewrite.maven.internal.MavenPomDownloader;\n+import org.openrewrite.maven.tree.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Objects.requireNonNull;\n+import static org.openrewrite.gradle.AddDependencyVisitor.DependencyModifier.ENFORCED_PLATFORM;\n+import static org.openrewrite.gradle.AddDependencyVisitor.DependencyModifier.PLATFORM;\n+import static org.openrewrite.gradle.trait.Traits.gradleDependency;\n+\n+@RequiredArgsConstructor\n+public class AddDependencyVisitor extends JavaIsoVisitor<ExecutionContext> {\n+    private static final MethodMatcher DEPENDENCIES_DSL_MATCHER = new MethodMatcher(\"* dependencies(..)\");\n+    private static final GradleParser GRADLE_PARSER = GradleParser.builder().build();\n+    private static final String TEMPLATE_CACHE_MESSAGE_KEY = \"__org.openrewrite.gradle.internal.AddDependencyVisitor.cache__\";\n+    public static final String KOTLIN_MAP_SEPARATOR = \" = \";\n+    public static final String GROOVY_MAP_SEPARATOR = \": \";\n+\n+    private final String configuration;\n+    private final String groupId;\n+    private final String artifactId;\n+\n+    @Nullable\n+    private final String version;\n+\n+    @Nullable\n+    private final String classifier;\n+\n+    @Nullable\n+    private final String extension;\n+\n+    @Nullable\n+    private final Predicate<Cursor> insertPredicate;\n+\n+    private final org.openrewrite.gradle.AddDependencyVisitor.@Nullable DependencyModifier dependencyModifier;\n+\n+    private final boolean isKotlinDsl;\n+\n+    @Override\n+    public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+        J j = super.visit(tree, ctx);\n+\n+        if (j instanceof JavaSourceFile) {\n+            JavaSourceFile cu = (JavaSourceFile) j;\n+\n+            if (j == tree && insertPredicate != null && insertPredicate.test(new Cursor(getCursor(), j))) {\n+                if (cu instanceof G.CompilationUnit) {\n+                    G.CompilationUnit g = (G.CompilationUnit) cu;\n+\n+                    if (!hasDependenciesBlock(g.getStatements())) {\n+                        Cursor parent = getCursor();\n+                        setCursor(new Cursor(parent, g));\n+                        J.MethodInvocation dependencies = dependenciesDeclaration(ctx)\n+                                .withPrefix(Space.format(\"\\n\\n\"));\n+                        cu = g.withStatements(ListUtils.concat(g.getStatements(), dependencies));\n+                        setCursor(parent);\n+                    }\n+                }\n+            }\n+\n+            return cu;\n+        }\n+        return j;\n+    }\n+\n+    @Override\n+    public J.Block visitBlock(J.Block block, ExecutionContext ctx) {\n+        J.Block b = super.visitBlock(block, ctx);\n+        if (b == block && insertPredicate != null && insertPredicate.test(getCursor())) {\n+            if (!hasDependenciesBlock(b.getStatements())) {\n+                Cursor parent = getCursor().dropParentUntil(value -> value instanceof J.MethodInvocation || value == Cursor.ROOT_VALUE);\n+                Space prefix = b.getStatements().isEmpty() ? Space.format(\"\\n\") : Space.format(\"\\n\\n\");\n+                Statement dependencies = parent.isRoot() ?\n+                        dependenciesDeclaration(ctx).withPrefix(prefix) :\n+                        autoFormat(dependenciesDeclaration(ctx).withPrefix(prefix), ctx, getCursor());\n+                return b.withStatements(ListUtils.concat(b.getStatements(), dependencies));\n+            }\n+        }\n+        return b;\n+    }\n+\n+    @Override\n+    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n+        J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n+        if (DEPENDENCIES_DSL_MATCHER.matches(m, true)) {\n+            if (insertPredicate != null && !insertPredicate.test(getCursor())) {\n+                return m;\n+            }\n+\n+            Optional<GradleDependency> maybeDependency = gradleDependency()\n+                    .configuration(configuration)\n+                    .groupId(groupId)\n+                    .artifactId(artifactId)\n+                    .lower(getCursor())\n+                    .findFirst();\n+            if (maybeDependency.isPresent()) {\n+                return m;\n+            }\n+\n+            return m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {\n+                if (arg instanceof J.Lambda) {\n+                    J.Lambda lambda = (J.Lambda) arg;\n+                    J.Block body = (J.Block) lambda.getBody();\n+                    J.MethodInvocation addDependencyInvocation = dependencyDeclaration(body, ctx, new Cursor(new Cursor(getCursor(), lambda), body));\n+                    InsertDependencyComparator dependencyComparator = new InsertDependencyComparator(body.getStatements(), addDependencyInvocation);\n+\n+                    List<Statement> statements = new ArrayList<>(body.getStatements());\n+                    int i = 0;\n+                    for (; i < body.getStatements().size(); i++) {\n+                        Statement currentStatement = body.getStatements().get(i);\n+                        if (dependencyComparator.compare(currentStatement, addDependencyInvocation) > 0) {\n+                            if (dependencyComparator.getBeforeDependency() != null) {\n+                                J.MethodInvocation beforeDependency = (J.MethodInvocation) (dependencyComparator.getBeforeDependency() instanceof J.Return ?\n+                                        requireNonNull(((J.Return) dependencyComparator.getBeforeDependency()).getExpression()) :\n+                                        dependencyComparator.getBeforeDependency());\n+                                if (i == 0) {\n+                                    if (!addDependencyInvocation.getSimpleName().equals(beforeDependency.getSimpleName())) {\n+                                        statements.set(i, currentStatement.withPrefix(Space.format(\"\\n\\n\" + currentStatement.getPrefix().getIndent())));\n+                                    }\n+                                } else {\n+                                    Space originalPrefix = addDependencyInvocation.getPrefix();\n+                                    addDependencyInvocation = addDependencyInvocation.withPrefix(currentStatement.getPrefix());\n+\n+                                    if (addDependencyInvocation.getSimpleName().equals(beforeDependency.getSimpleName())) {\n+                                        if (!currentStatement.getPrefix().equals(originalPrefix)) {\n+                                            statements.set(i, currentStatement.withPrefix(originalPrefix));\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            statements.add(i, addDependencyInvocation);\n+                            break;\n+                        }\n+                    }\n+                    if (body.getStatements().size() == i) {\n+                        if (!body.getStatements().isEmpty()) {\n+                            Statement lastStatement;\n+                            if (statements.get(i - 1) instanceof J.Return) {\n+                                J.Return r = (J.Return) statements.remove(i - 1);\n+                                lastStatement = requireNonNull(r.getExpression()).withPrefix(r.getPrefix());\n+                                statements.add(lastStatement);\n+                            } else {\n+                                lastStatement = statements.get(i - 1);\n+                            }\n+                            if (lastStatement instanceof J.MethodInvocation && !((J.MethodInvocation) lastStatement).getSimpleName().equals(addDependencyInvocation.getSimpleName())) {\n+                                addDependencyInvocation = addDependencyInvocation.withPrefix(Space.format(\"\\n\\n\" + addDependencyInvocation.getPrefix().getIndent()));\n+                            }\n+                        }\n+                        statements.add(addDependencyInvocation);\n+                    }\n+                    body = body.withStatements(statements);\n+                    return lambda.withBody(body.withStatements(statements));\n+                }\n+                return arg;\n+            }));\n+        }\n+        return m;\n+    }\n+\n+    /**\n+     * Update the dependency model, adding the specified dependency to the specified configuration and all configurations\n+     * which extend from it.\n+     *\n+     * @param buildScript   compilation unit owning the {@link GradleProject} marker\n+     * @param configuration the configuration to add the dependency to\n+     * @param gav           the group, artifact, and version of the dependency to add\n+     * @param classifier    the classifier of the dependency to add\n+     * @param ctx           context which will be used to download the pom for the dependency\n+     * @return a copy of buildScript with the dependency added\n+     */\n+    public static JavaSourceFile addDependency(\n+            JavaSourceFile buildScript,\n+            @Nullable GradleDependencyConfiguration configuration,\n+            GroupArtifactVersion gav,\n+            @Nullable String classifier,\n+            ExecutionContext ctx) {\n+        if (gav.getGroupId() == null || gav.getArtifactId() == null || configuration == null) {\n+            return buildScript;\n+        }\n+        GradleProject gp = buildScript.getMarkers().findFirst(GradleProject.class)\n+                .orElseThrow(() -> new IllegalArgumentException(\"Could not find GradleProject\"));\n+\n+        try {\n+            ResolvedGroupArtifactVersion resolvedGav;\n+            List<ResolvedDependency> transitiveDependencies;\n+            if (gav.getVersion() == null) {\n+                resolvedGav = null;\n+                transitiveDependencies = Collections.emptyList();\n+            } else {\n+                MavenPomDownloader mpd = new MavenPomDownloader(ctx);\n+                Pom pom = mpd.download(gav, null, null, gp.getMavenRepositories());\n+                ResolvedPom resolvedPom = pom.resolve(emptyList(), mpd, gp.getMavenRepositories(), ctx);\n+                resolvedGav = resolvedPom.getGav();\n+                transitiveDependencies = resolvedPom.resolveDependencies(Scope.Runtime, mpd, ctx);\n+            }\n+            Map<String, GradleDependencyConfiguration> nameToConfiguration = gp.getNameToConfiguration();\n+            Map<String, GradleDependencyConfiguration> newNameToConfiguration = new HashMap<>(nameToConfiguration.size());\n+\n+            Set<GradleDependencyConfiguration> configurationsToAdd = Stream.concat(\n+                            Stream.of(configuration),\n+                            gp.configurationsExtendingFrom(configuration, true).stream())\n+                    .collect(Collectors.toSet());\n+\n+            for (GradleDependencyConfiguration gdc : nameToConfiguration.values()) {\n+                if (!configurationsToAdd.contains(gdc)) {\n+                    newNameToConfiguration.put(gdc.getName(), gdc);\n+                    continue;\n+                }\n+\n+                GradleDependencyConfiguration newGdc = gdc;\n+                org.openrewrite.maven.tree.Dependency newRequested = new org.openrewrite.maven.tree.Dependency(\n+                        gav, classifier, \"jar\", gdc.getName(), emptyList(), null);\n+                newGdc = newGdc.withRequested(ListUtils.concat(\n+                        ListUtils.map(gdc.getRequested(), requested -> {\n+                            // Remove any existing dependency with the same group and artifact id\n+                            if (Objects.equals(requested.getGroupId(), gav.getGroupId()) && Objects.equals(requested.getArtifactId(), gav.getArtifactId())) {\n+                                return null;\n+                            }\n+                            return requested;\n+                        }),\n+                        newRequested));\n+                if (newGdc.isCanBeResolved() && resolvedGav != null) {\n+                    newGdc = newGdc.withDirectResolved(ListUtils.concat(\n+                            ListUtils.map(gdc.getDirectResolved(), resolved -> {\n+                                // Remove any existing dependency with the same group and artifact id\n+                                if (Objects.equals(resolved.getGroupId(), resolvedGav.getGroupId()) && Objects.equals(resolved.getArtifactId(), resolvedGav.getArtifactId())) {\n+                                    return null;\n+                                }\n+                                return resolved;\n+                            }),\n+                            new ResolvedDependency(null, resolvedGav, newRequested, transitiveDependencies,\n+                                    emptyList(), \"jar\", classifier, null, 0, null)));\n+                }\n+                newNameToConfiguration.put(newGdc.getName(), newGdc);\n+            }\n+            gp = gp.withNameToConfiguration(newNameToConfiguration);\n+        } catch (MavenDownloadingException | MavenDownloadingExceptions | IllegalArgumentException e) {\n+            return Markup.warn(buildScript, e);\n+        }\n+        return buildScript.withMarkers(buildScript.getMarkers().setByType(gp));\n+    }\n+\n+    enum DependencyStyle {\n+        Map, String\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <J2 extends J> List<J2> cache(Cursor cursor, Object key, Supplier<List<? extends J>> ifAbsent) {\n+        List<J2> js = null;\n+\n+        Cursor root = cursor.getRoot();\n+        Map<Object, List<J2>> cache = root.getMessage(TEMPLATE_CACHE_MESSAGE_KEY);\n+        if (cache == null) {\n+            cache = new HashMap<>();\n+            root.putMessage(TEMPLATE_CACHE_MESSAGE_KEY, cache);\n+        } else {\n+            js = cache.get(key);\n+        }\n+\n+        if (js == null) {\n+            js = (List<J2>) ifAbsent.get();\n+            cache.put(key, js);\n+        }\n+\n+        return ListUtils.map(js, j -> (J2) new RandomizeIdVisitor<Integer>().visit(j, 0));\n+    }\n+\n+    private boolean hasDependenciesBlock(List<Statement> statements) {\n+        for (Statement statement : statements) {\n+            if (statement instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) statement, true)) {\n+                return true;\n+            } else if (statement instanceof J.Return &&\n+                    ((J.Return) statement).getExpression() instanceof J.MethodInvocation &&\n+                    DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) ((J.Return) statement).getExpression(), true)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private J.MethodInvocation dependenciesDeclaration(ExecutionContext ctx) {\n+        String template = templateDependencies();\n+        return (J.MethodInvocation) cache(getCursor(), new ContextFreeCacheKey(template, isKotlinDsl, J.MethodInvocation.class), () -> {\n+            Boolean requirePrintEqualsInput = ctx.getMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT);\n+            try {\n+                J.MethodInvocation dependencies;\n+                ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, false);\n+                if (isKotlinDsl) {\n+                    dependencies = (J.MethodInvocation) ((J.Block) GRADLE_PARSER.parseInputs(Collections.singletonList(new GradleParser.Input(Paths.get(\"build.gradle.kts\"), () -> new ByteArrayInputStream(template.getBytes(StandardCharsets.UTF_8)))), null, ctx)\n+                            .findFirst()\n+                            .map(K.CompilationUnit.class::cast)\n+                            .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"))\n+                            .getStatements().get(0)).getStatements().get(0);\n+                } else {\n+                    dependencies = (J.MethodInvocation) GRADLE_PARSER.parse(ctx, template)\n+                            .findFirst()\n+                            .map(G.CompilationUnit.class::cast)\n+                            .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"))\n+                            .getStatements().get(0);\n+                }\n+                return Collections.singletonList(dependencies);\n+            } finally {\n+                ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, requirePrintEqualsInput);\n+            }\n+        }).get(0);\n+    }\n+\n+    private J.MethodInvocation dependencyDeclaration(J.Block body, ExecutionContext ctx, Cursor cursor) {\n+        String template = templateDependency(body);\n+        return (J.MethodInvocation) autoFormat(cache(cursor, new ContextFreeCacheKey(template, isKotlinDsl, J.MethodInvocation.class), () -> {\n+            Boolean requirePrintEqualsInput = ctx.getMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT);\n+            try {\n+                J.MethodInvocation dependency;\n+                ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, false);\n+                if (isKotlinDsl) {\n+                    dependency = (J.MethodInvocation) ((J.Block) GRADLE_PARSER.parseInputs(Collections.singletonList(new GradleParser.Input(Paths.get(\"build.gradle.kts\"), () -> new ByteArrayInputStream(template.getBytes(StandardCharsets.UTF_8)))), null, ctx)\n+                            .findFirst()\n+                            .map(K.CompilationUnit.class::cast)\n+                            .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"))\n+                            .getStatements().get(0)).getStatements().get(0);\n+                } else {\n+                    dependency = (J.MethodInvocation) GRADLE_PARSER.parse(ctx, template)\n+                            .findFirst()\n+                            .map(G.CompilationUnit.class::cast)\n+                            .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"))\n+                            .getStatements().get(0);\n+                }\n+                return Collections.singletonList(dependency.withPrefix(Space.format(\"\\n\")));\n+            } finally {\n+                ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, requirePrintEqualsInput);\n+            }\n+        }).get(0), ctx, cursor);\n+    }\n+\n+    private String templateDependencies() {\n+        return \"dependencies {\\n    \" + templateDependency(null) + \"\\n}\";\n+    }\n+\n+    private String templateDependency(J.@Nullable Block body) {\n+        DependencyStyle style = autodetectDependencyStyle(body);\n+        if (isKotlinDsl) {\n+            return escapeIfNecessary(configuration) + \"(\" + templatePlatform(templateDependencyNotation(KOTLIN_MAP_SEPARATOR, style)) + \")\";\n+        } else {\n+            return escapeIfNecessary(configuration) + \" \" + templatePlatform(templateDependencyNotation(GROOVY_MAP_SEPARATOR, style));\n+        }\n+    }\n+\n+    private String templatePlatform(String dependencyNotation) {\n+        if (dependencyModifier == PLATFORM) {\n+            return \"platform(\" + dependencyNotation + \")\";\n+        } else if (dependencyModifier == ENFORCED_PLATFORM) {\n+            return \"enforcedPlatform(\" + dependencyNotation + \")\";\n+        }\n+        return dependencyNotation;\n+    }\n+\n+    private String templateDependencyNotation(String mapSeparator, DependencyStyle style) {\n+        if (style == DependencyStyle.String) {\n+            return \"\\\"\" + groupId + \":\" + artifactId + (version == null ? \"\" : \":\" + version) + (version == null || classifier == null ? \"\" : \":\" + classifier) + (extension == null ? \"\" : \"@\" + extension) + \"\\\"\";\n+        } else {\n+            return \"group\" + mapSeparator + \"\\\"\" + groupId + \"\\\", name\" + mapSeparator + \"\\\"\" + artifactId + \"\\\"\" + (version == null ? \"\" : \", version\" + mapSeparator + \"\\\"\" + version + \"\\\"\") + (classifier == null ? \"\" : \", classifier\" + mapSeparator + \"\\\"\" + classifier + \"\\\"\") + (extension == null ? \"\" : \", ext\" + mapSeparator + \"\\\"\" + extension + \"\\\"\");\n+        }\n+    }\n+\n+    private String escapeIfNecessary(String configurationName) {\n+        // default is a gradle configuration created by the base plugin and a groovy keyword if\n+        // it is used it needs to be escaped\n+        return configurationName.equals(\"default\") ? \"'\" + configurationName + \"'\" : configurationName;\n+    }\n+\n+    private DependencyStyle autodetectDependencyStyle(J.@Nullable Block block) {\n+        if (block == null) {\n+            return DependencyStyle.String;\n+        }\n+\n+        List<Statement> statements = block.getStatements();\n+        int string = 0;\n+        int map = 0;\n+        for (Statement statement : statements) {\n+            if (statement instanceof J.Return && ((J.Return) statement).getExpression() instanceof J.MethodInvocation) {\n+                J.MethodInvocation invocation = (J.MethodInvocation) ((J.Return) statement).getExpression();\n+                if (invocation.getArguments().get(0) instanceof J.Literal || invocation.getArguments().get(0) instanceof G.GString) {\n+                    string++;\n+                } else if (invocation.getArguments().get(0) instanceof G.MapEntry) {\n+                    map++;\n+                } else if (invocation.getArguments().get(0) instanceof J.Assignment) {\n+                    map++;\n+                }\n+            } else if (statement instanceof J.MethodInvocation) {\n+                J.MethodInvocation invocation = (J.MethodInvocation) statement;\n+                if (invocation.getArguments().get(0) instanceof J.Literal || invocation.getArguments().get(0) instanceof G.GString) {\n+                    string++;\n+                } else if (invocation.getArguments().get(0) instanceof G.MapEntry) {\n+                    map++;\n+                } else if (invocation.getArguments().get(0) instanceof J.Assignment) {\n+                    map++;\n+                }\n+            }\n+        }\n+\n+        return string >= map ? DependencyStyle.String : DependencyStyle.Map;\n+    }\n+\n+    @Value\n+    private static class ContextFreeCacheKey {\n+        String template;\n+        boolean isKotlinDsl;\n+        Class<? extends J> expected;\n+    }\n+}\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/Traits.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/Traits.java\nindex 356c2d2dd68..16fa0f94e22 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/Traits.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/Traits.java\n@@ -22,4 +22,8 @@ private Traits() {\n     public static GradleDependency.Matcher gradleDependency() {\n         return new GradleDependency.Matcher();\n     }\n+\n+    public static JvmTestSuite.Matcher jvmTestSuite() {\n+        return new JvmTestSuite.Matcher();\n+    }\n }\n",
    "test_patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java\nindex 7d71d133e43..5bf805199ad 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java\n@@ -21,28 +21,21 @@\n import org.openrewrite.*;\n import org.openrewrite.gradle.IsBuildGradle;\n import org.openrewrite.gradle.table.JVMTestSuitesDefined;\n-import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.tree.Expression;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.Statement;\n+import org.openrewrite.gradle.trait.JvmTestSuite;\n import org.openrewrite.marker.SearchResult;\n \n-import java.util.HashSet;\n-import java.util.Iterator;\n+import java.util.Collections;\n import java.util.Set;\n import java.util.stream.Collectors;\n \n+import static org.openrewrite.gradle.trait.Traits.jvmTestSuite;\n+\n @Value\n @EqualsAndHashCode(callSuper = false)\n public class FindJVMTestSuites extends Recipe {\n \n     transient JVMTestSuitesDefined jvmTestSuitesDefined = new JVMTestSuitesDefined(this);\n \n-    @Option(displayName = \"Requires dependencies\",\n-            description = \"Whether the test suite configuration defines dependencies to be resolved. Defaults to false.\")\n-    @Nullable\n-    Boolean definesDependencies;\n-\n     @Option(displayName = \"Insert rows\",\n             description = \"Whether to insert rows into the table. Defaults to true.\")\n     @Nullable\n@@ -60,58 +53,21 @@ public String getDescription() {\n \n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        boolean requireDependencies = definesDependencies != null && definesDependencies;\n         boolean tableAvailable = this.insertRows == null || this.insertRows;\n-        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {\n-            private boolean isJVMTestSuitesBlock() {\n-                Cursor parent = getCursor().getParent();\n-                if (parent != null) {\n-                    Iterator<Object> path = parent.getPath(J.MethodInvocation.class::isInstance);\n-                    if (path.hasNext() && \"suites\".equals(((J.MethodInvocation) path.next()).getSimpleName())) {\n-                        return path.hasNext() && \"testing\".equals(((J.MethodInvocation) path.next()).getSimpleName());\n-                    }\n-                }\n-                return false;\n-            }\n-\n-            private boolean definesDependencies(J.MethodInvocation suite) {\n-                for (Expression suiteDefinition : suite.getArguments()) {\n-                    if (suiteDefinition instanceof J.Lambda) {\n-                        for (Statement statement : ((J.Block) ((J.Lambda) suiteDefinition).getBody()).getStatements()) {\n-                            if (statement instanceof J.Return) {\n-                                Expression expression = ((J.Return) statement).getExpression();\n-                                if (expression instanceof J.MethodInvocation) {\n-                                    if (\"dependencies\".equals(((J.MethodInvocation) expression).getSimpleName())) {\n-                                        return true;\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                return false;\n-            }\n-\n-            @Override\n-            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n-                if (isJVMTestSuitesBlock()) {\n-                    if (tableAvailable) {\n-                        jvmTestSuitesDefined.insertRow(ctx, new JVMTestSuitesDefined.Row(method.getSimpleName()));\n-                    }\n-                    return !requireDependencies || definesDependencies(method) ? SearchResult.found(method) : method;\n-                }\n-                return super.visitMethodInvocation(method, ctx);\n+        return Preconditions.check(new IsBuildGradle<>(), jvmTestSuite().asVisitor((suite, ctx) -> {\n+            if (tableAvailable) {\n+                jvmTestSuitesDefined.insertRow(ctx, new JVMTestSuitesDefined.Row(suite.getName()));\n             }\n-        });\n+            return SearchResult.found(suite.getTree());\n+        }));\n     }\n \n-    public static Set<String> jvmTestSuiteNames(Tree tree, boolean definesDependencies) {\n-        return TreeVisitor.collect(new FindJVMTestSuites(definesDependencies, false).getVisitor(), tree, new HashSet<>())\n-                .stream()\n-                .filter(J.MethodInvocation.class::isInstance)\n-                .map(J.MethodInvocation.class::cast)\n-                .filter(m -> m.getMarkers().findFirst(SearchResult.class).isPresent())\n-                .map(J.MethodInvocation::getSimpleName)\n+    public static Set<JvmTestSuite> jvmTestSuites(SourceFile sourceFile) {\n+        if (!IsBuildGradle.matches(sourceFile.getSourcePath())) {\n+            return Collections.emptySet();\n+        }\n+\n+        return jvmTestSuite().lower(sourceFile)\n                 .collect(Collectors.toSet());\n     }\n }\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/JvmTestSuite.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/JvmTestSuite.java\nnew file mode 100644\nindex 00000000000..e9473f3f218\n--- /dev/null\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/JvmTestSuite.java\n@@ -0,0 +1,321 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle.trait;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import org.jspecify.annotations.Nullable;\n+import org.openrewrite.Cursor;\n+import org.openrewrite.ExecutionContext;\n+import org.openrewrite.Tree;\n+import org.openrewrite.TreeVisitor;\n+import org.openrewrite.gradle.DependencyVersionSelector;\n+import org.openrewrite.gradle.internal.AddDependencyVisitor;\n+import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n+import org.openrewrite.gradle.marker.GradleProject;\n+import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n+import org.openrewrite.java.JavaVisitor;\n+import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaSourceFile;\n+import org.openrewrite.java.tree.JavaType;\n+import org.openrewrite.java.tree.Statement;\n+import org.openrewrite.kotlin.tree.K;\n+import org.openrewrite.marker.SearchResult;\n+import org.openrewrite.maven.MavenDownloadingException;\n+import org.openrewrite.maven.table.MavenMetadataFailures;\n+import org.openrewrite.maven.tree.GroupArtifact;\n+import org.openrewrite.maven.tree.GroupArtifactVersion;\n+import org.openrewrite.trait.Trait;\n+import org.openrewrite.trait.VisitFunction2;\n+\n+import java.util.*;\n+\n+@AllArgsConstructor\n+public class JvmTestSuite implements Trait<Statement> {\n+    private static final String[] JVM_TEST_SUITE_SUFFIXES = new String[] {\n+            \"annotationProcessor\",\n+            \"compileOnly\",\n+            \"implementation\",\n+            \"runtimeOnly\"\n+    };\n+\n+    @Getter\n+    Cursor cursor;\n+\n+    GradleProject gradleProject;\n+\n+    @Getter\n+    String name;\n+\n+    public TreeVisitor<J, ExecutionContext> addDependency(\n+            String configuration,\n+            String groupId,\n+            String artifactId,\n+            @Nullable String version,\n+            @Nullable String versionPattern,\n+            @Nullable String classifier,\n+            @Nullable String extension,\n+            MavenMetadataFailures metadataFailures,\n+            org.openrewrite.gradle.AddDependencyVisitor.@Nullable DependencyModifier dependencyModifier,\n+            ExecutionContext ctx\n+    ) {\n+        if (!isAcceptable(configuration)) {\n+            return TreeVisitor.noop();\n+        }\n+\n+        String resolvedConfiguration = configuration.startsWith(name) ?\n+                Character.toLowerCase(configuration.charAt(name.length())) + configuration.substring(name.length() + 1) :\n+                configuration;\n+\n+        String targetConfiguration = configuration.startsWith(name) ?\n+                configuration :\n+                name + Character.toUpperCase(configuration.charAt(0)) + configuration.substring(1);\n+\n+        boolean isKotlinDsl = isKotlinDsl();\n+        try {\n+            String resolvedVersion = resolveVersion(resolvedConfiguration, groupId, artifactId, version, versionPattern, metadataFailures, ctx);\n+\n+            return new JavaIsoVisitor<ExecutionContext>() {\n+                @Override\n+                public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                    J j = new AddDependencyVisitor(resolvedConfiguration, groupId, artifactId, version, classifier, extension, JvmTestSuite.this::isScope, dependencyModifier, isKotlinDsl)\n+                            .visit(tree, ctx, getCursor());\n+\n+                    if (j instanceof JavaSourceFile && j != tree) {\n+                        return AddDependencyVisitor.addDependency(\n+                                (JavaSourceFile) j,\n+                                gradleProject.getConfiguration(targetConfiguration),\n+                                new GroupArtifactVersion(groupId, artifactId, resolvedVersion),\n+                                classifier,\n+                                ctx\n+                        );\n+                    }\n+\n+                    return j;\n+                }\n+            };\n+        } catch (MavenDownloadingException e) {\n+            return new JavaVisitor<ExecutionContext>() {\n+                @Override\n+                public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                    if (tree == null) {\n+                        return null;\n+                    }\n+\n+                    return (J) e.warn(tree);\n+                }\n+            };\n+        }\n+    }\n+\n+    private @Nullable String resolveVersion(String configuration, String groupId, String artifactId, @Nullable String version, @Nullable String versionPattern, MavenMetadataFailures metadataFailures, ExecutionContext ctx) throws MavenDownloadingException{\n+        if (version == null) {\n+            return null;\n+        }\n+\n+        if (version.startsWith(\"$\")) {\n+            return version;\n+        }\n+        return new DependencyVersionSelector(metadataFailures, gradleProject, null)\n+                .select(new GroupArtifact(groupId, artifactId), configuration, version, versionPattern, ctx);\n+    }\n+\n+    public boolean isAcceptable(String configuration) {\n+        for (String suffix : JVM_TEST_SUITE_SUFFIXES) {\n+            if (configuration.equals(suffix)) {\n+                return true;\n+            } else if (configuration.equals(name + Character.toUpperCase(suffix.charAt(0)) + suffix.substring(1))) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isKotlinDsl() {\n+        return getCursor().firstEnclosing(JavaSourceFile.class) instanceof K.CompilationUnit;\n+    }\n+\n+    private boolean isScope(Cursor cursor) {\n+        Statement statement = getTree();\n+        Cursor c = cursor.dropParentUntil(value -> (value instanceof J && statement.isScope((J) value)) || (value instanceof J.MethodInvocation && !\"registering\".equals(((J.MethodInvocation) value).getSimpleName()) && !\"getting\".equals(((J.MethodInvocation) value).getSimpleName())) || value == Cursor.ROOT_VALUE);\n+        return !c.isRoot() && statement.isScope(c.getValue());\n+    }\n+\n+    public static class Matcher extends GradleTraitMatcher<JvmTestSuite> {\n+        @Nullable\n+        protected String name;\n+\n+        private transient Map<GradleProject, Set<String>> sourceSets = new HashMap<>();\n+\n+        public Matcher name(@Nullable String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        @Override\n+        public <P> TreeVisitor<? extends Tree, P> asVisitor(VisitFunction2<JvmTestSuite, P> visitor) {\n+            return new JavaVisitor<P>() {\n+                @Override\n+                public J visitMethodInvocation(J.MethodInvocation method, P p) {\n+                    JvmTestSuite suite = test(getCursor());\n+                    return suite != null ?\n+                            (J) visitor.visit(suite, p) :\n+                            super.visitMethodInvocation(method, p);\n+                }\n+\n+                @Override\n+                public J visitVariableDeclarations(J.VariableDeclarations multiVariable, P p) {\n+                    JvmTestSuite suite = test(getCursor());\n+                    return suite != null ?\n+                            (J) visitor.visit(suite, p) :\n+                            super.visitVariableDeclarations(multiVariable, p);\n+                }\n+            };\n+        }\n+\n+        @Override\n+        protected @Nullable JvmTestSuite test(Cursor cursor) {\n+            if (!withinSuitesBlock(cursor)) {\n+                return null;\n+            }\n+\n+            if (cursor.getValue() instanceof J.MethodInvocation) {\n+                J.MethodInvocation m = cursor.getValue();\n+\n+                if (\"register\".equals(m.getSimpleName())) {\n+                    if (!(m.getArguments().get(0) instanceof J.Literal)) {\n+                        return null;\n+                    }\n+\n+                    J.Literal literal = (J.Literal) m.getArguments().get(0);\n+                    if (literal.getType() != JavaType.Primitive.String) {\n+                        return null;\n+                    }\n+\n+                    if (literal.getValue() == null) {\n+                        return null;\n+                    }\n+\n+                    return maybeJvmTestSuite(cursor, (String) literal.getValue());\n+                } else {\n+                    return maybeJvmTestSuite(cursor, m.getSimpleName());\n+                }\n+            } else {\n+                J.VariableDeclarations variables = cursor.getValue();\n+                J.VariableDeclarations.NamedVariable variable = variables.getVariables().get(0);\n+\n+                if (!(variable.getInitializer() instanceof J.MethodInvocation)) {\n+                    return null;\n+                }\n+\n+                J.MethodInvocation initializer = (J.MethodInvocation) variable.getInitializer();\n+                if (!\"getting\".equals(initializer.getSimpleName()) && !\"registering\".equals(initializer.getSimpleName())) {\n+                    return null;\n+                }\n+\n+                return maybeJvmTestSuite(cursor, variable.getSimpleName());\n+            }\n+        }\n+\n+        private @Nullable JvmTestSuite maybeJvmTestSuite(Cursor cursor, String simpleName) {\n+            Set<String> sourceSets = getSourceSets(cursor);\n+            if (sourceSets.isEmpty()) {\n+                if (!hasDependenciesBlock(cursor)) {\n+                    return null;\n+                }\n+            } else if (!sourceSets.contains(simpleName)) {\n+                return null;\n+            }\n+\n+            if (!StringUtils.isBlank(name) && !name.equals(simpleName)) {\n+                return null;\n+            }\n+\n+            return new JvmTestSuite(cursor, getGradleProject(cursor), simpleName);\n+        }\n+\n+        private boolean withinBlock(Cursor cursor, String name) {\n+            Cursor parentCursor = cursor.getParent();\n+            while (parentCursor != null) {\n+                if (parentCursor.getValue() instanceof J.MethodInvocation) {\n+                    J.MethodInvocation m = parentCursor.getValue();\n+                    if (m.getSimpleName().equals(name)) {\n+                        return true;\n+                    }\n+                }\n+                parentCursor = parentCursor.getParent();\n+            }\n+\n+            return false;\n+        }\n+\n+        private boolean withinTestingBlock(Cursor cursor) {\n+            return withinBlock(cursor, \"testing\");\n+        }\n+\n+        private boolean withinSuitesBlock(Cursor cursor) {\n+            return withinBlock(cursor, \"suites\") && withinTestingBlock(cursor);\n+        }\n+\n+        private Set<String> getSourceSets(Cursor cursor) {\n+            GradleProject gp = getGradleProject(cursor);\n+            if (gp == null) {\n+                return Collections.emptySet();\n+            }\n+\n+            return sourceSets.computeIfAbsent(gp, key -> {\n+                Set<String> sourceSets = new HashSet<>();\n+                for (GradleDependencyConfiguration configuration : gp.getConfigurations()) {\n+                    String maybeSourceSet = removeSuffix(configuration.getName());\n+                    if (maybeSourceSet != null) {\n+                        sourceSets.add(maybeSourceSet);\n+                    }\n+                }\n+                return sourceSets;\n+            });\n+        }\n+\n+        private boolean hasDependenciesBlock(Cursor cursor) {\n+            Statement original = cursor.getValue();\n+            Statement updated = (Statement) new JavaIsoVisitor<Integer>() {\n+                @Override\n+                public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Integer ctx) {\n+                    J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n+                    if (m.getSimpleName().equals(\"dependencies\")) {\n+                        return SearchResult.found(m);\n+                    }\n+                    return m;\n+                }\n+            }.visitNonNull(original, 0);\n+            return updated != original;\n+        }\n+\n+        /**\n+         * This gives us the best estimate to a project's source sets. This would be better coming from the GradleProject marker.\n+         */\n+        private static @Nullable String removeSuffix(String configuration) {\n+            for (String suffix : JVM_TEST_SUITE_SUFFIXES) {\n+                if (configuration.equals(suffix)) {\n+                    return \"main\";\n+                } else if (configuration.endsWith(Character.toUpperCase(suffix.charAt(0)) + suffix.substring(1))) {\n+                    return configuration.substring(0, configuration.length() - suffix.length());\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java\nindex 75ede738f10..1caefd75297 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java\n@@ -1370,8 +1370,6 @@ void addToJVMSuite() {\n                     testing {\n                         suites {\n                             integrationTest(JvmTestSuite) {\n-                                dependencies {\n-                                }\n                             }\n                         }\n                     }\n@@ -1428,10 +1426,7 @@ void actNormalForDefaultTestWithoutSuiteDefinition() {\n                     \n                     testing {\n                         suites {\n-                            integrationTest(JvmTestSuite) {\n-                                dependencies {\n-                                }\n-                            }\n+                            integrationTest(JvmTestSuite)\n                         }\n                     }\n                     \"\"\",\n@@ -1453,62 +1448,9 @@ void actNormalForDefaultTestWithoutSuiteDefinition() {\n                     \n                     testing {\n                         suites {\n-                            integrationTest(JvmTestSuite) {\n-                                dependencies {\n-                                }\n-                            }\n-                        }\n-                    }\n-                    \"\"\"\n-                )));\n-        }\n-\n-        @Test\n-        void actNormalForSuiteWithoutDependencyBlock() {\n-            rewriteRun(\n-              spec -> spec.recipe(addDependency(\"com.google.guava:guava:29.0-jre\")),\n-              mavenProject(\"project\",\n-                srcMainJava(\n-                  java(usingGuavaIntMath, sourceSpecs -> sourceSet(sourceSpecs, \"integrationTest\"))),\n-                buildGradle(\n-                  //language=groovy\n-                  \"\"\"\n-                    plugins {\n-                        id \"java-library\"\n-                        id 'jvm-test-suite'\n-                    }\n-                    \n-                    repositories {\n-                        mavenCentral()\n-                    }\n-                    \n-                    testing {\n-                        suites {\n-                            integrationTest(JvmTestSuite) {\n-                            }\n+                            integrationTest(JvmTestSuite)\n                         }\n                     }\n-                    \"\"\",\n-                  \"\"\"\n-                    plugins {\n-                        id \"java-library\"\n-                        id 'jvm-test-suite'\n-                    }\n-                    \n-                    repositories {\n-                        mavenCentral()\n-                    }\n-                    \n-                    testing {\n-                        suites {\n-                            integrationTest(JvmTestSuite) {\n-                            }\n-                        }\n-                    }\n-                    \n-                    dependencies {\n-                        integrationTestImplementation \"com.google.guava:guava:29.0-jre\"\n-                    }\n                     \"\"\"\n                 )));\n         }\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddPlatformDependencyTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddPlatformDependencyTest.java\nnew file mode 100644\nindex 00000000000..a2f8076afce\n--- /dev/null\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddPlatformDependencyTest.java\n@@ -0,0 +1,402 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle;\n+\n+import org.intellij.lang.annotations.Language;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.openrewrite.java.JavaParser;\n+import org.openrewrite.test.RecipeSpec;\n+import org.openrewrite.test.RewriteTest;\n+import org.openrewrite.test.TypeValidation;\n+\n+import static org.openrewrite.gradle.Assertions.buildGradle;\n+import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n+import static org.openrewrite.java.Assertions.*;\n+\n+class AddPlatformDependencyTest implements RewriteTest {\n+    @Override\n+    public void defaults(RecipeSpec spec) {\n+        spec.beforeRecipe(withToolingApi())\n+          .parser(JavaParser.fromJavaVersion().classpath(\"junit-jupiter-api\", \"guava\", \"jackson-databind\", \"jackson-core\", \"lombok\"));\n+    }\n+\n+    @Language(\"java\")\n+    private final String usingGuavaIntMath = \"\"\"\n+            import com.google.common.math.IntMath;\n+            public class A {\n+                boolean getMap() {\n+                    return IntMath.isPrime(5);\n+                }\n+            }\n+      \"\"\";\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+      \"implementation\",\n+      \"compileOnly\",\n+      \"runtimeOnly\",\n+      \"annotationProcessor\"})\n+    void addPlatformWithExplicitConfiguration(String configuration) {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\"org.springframework.boot\", \"spring-boot-dependencies\", \"3.2.4\", null, configuration, null)),\n+          mavenProject(\"project\",\n+            srcMainJava(java(usingGuavaIntMath)),\n+            buildGradle(\n+              //language=groovy\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \"\"\",\n+              //language=groovy\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    %s platform(\"org.springframework.boot:spring-boot-dependencies:3.2.4\")\n+                }\n+                \"\"\".formatted(configuration)\n+            )));\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+      \"implementation\",\n+      \"compileOnly\",\n+      \"runtimeOnly\",\n+      \"annotationProcessor\"})\n+    void addEnforcedPlatformWithExplicitConfiguration(String configuration) {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\"org.springframework.boot\", \"spring-boot-dependencies\", \"3.2.4\", null, configuration, true)),\n+          mavenProject(\"project\",\n+            srcMainJava(java(usingGuavaIntMath)),\n+            buildGradle(\n+              //language=groovy\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \"\"\",\n+              //language=groovy\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    %s enforcedPlatform(\"org.springframework.boot:spring-boot-dependencies:3.2.4\")\n+                }\n+                \"\"\".formatted(configuration)\n+            )));\n+    }\n+\n+    @Test\n+    void addsToTestScopeWhenNoConfigurationSpecified() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\"org.springframework.boot\", \"spring-boot-dependencies\", \"3.2.4\", null, null, null)),\n+          mavenProject(\"project\",\n+            srcTestJava(java(usingGuavaIntMath)),\n+            buildGradle(\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \"\"\",\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    testImplementation platform(\"org.springframework.boot:spring-boot-dependencies:3.2.4\")\n+                }\n+                \"\"\"\n+            )\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addsToSmokeTestScopeWhenNoConfigurationSpecified() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\"org.springframework.boot\", \"spring-boot-dependencies\", \"3.2.4\", null, null, null)),\n+          mavenProject(\"project\",\n+            srcSmokeTestJava(java(usingGuavaIntMath)),\n+            buildGradle(\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                    id \"com.netflix.nebula.facet\" version \"10.1.3\"\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                facets {\n+                    smokeTest {\n+                        parentSourceSet = \"test\"\n+                    }\n+                }\n+                \"\"\",\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                    id \"com.netflix.nebula.facet\" version \"10.1.3\"\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                facets {\n+                    smokeTest {\n+                        parentSourceSet = \"test\"\n+                    }\n+                }\n+                \n+                dependencies {\n+                    smokeTestImplementation platform(\"org.springframework.boot:spring-boot-dependencies:3.2.4\")\n+                }\n+                \"\"\"\n+            )\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addsToImplementationScopeWhenNoConfigurationSpecified() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\"org.springframework.boot\", \"spring-boot-dependencies\", \"3.2.4\", null, null, null))\n+            .typeValidationOptions(TypeValidation.none()),\n+          mavenProject(\"project\",\n+            srcMainJava(java(usingGuavaIntMath)),\n+            buildGradle(\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \"\"\",\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation platform(\"org.springframework.boot:spring-boot-dependencies:3.2.4\")\n+                }\n+                \"\"\"\n+            )\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void onlyAddsToParentConfigurationWhenNoConfigurationSpecified() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\"org.springframework.boot\", \"spring-boot-dependencies\", \"3.2.4\", null, null, null))\n+            .typeValidationOptions(TypeValidation.none()),\n+          mavenProject(\"project\",\n+            srcMainJava(java(usingGuavaIntMath)),\n+            srcTestJava(java(usingGuavaIntMath)),\n+            buildGradle(\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \"\"\",\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation platform(\"org.springframework.boot:spring-boot-dependencies:3.2.4\")\n+                }\n+                \"\"\"\n+            )\n+          )\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+      \"integrationTestImplementation,implementation\",\n+      \"integrationTestCompileOnly,compileOnly\",\n+      \"integrationTestRuntimeOnly,runtimeOnly\",\n+      \"integrationTestAnnotationProcessor,annotationProcessor\"})\n+    void addPlatformDependencyWithExplicitConfiguration(String recipeConfiguration, String gradleConfiguration) {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\"org.springframework.boot\", \"spring-boot-dependencies\", \"3.2.4\", null, recipeConfiguration, null)),\n+          mavenProject(\"project\",\n+            srcMainJava(java(usingGuavaIntMath, sourceSpecs -> sourceSet(sourceSpecs, \"integrationTest\"))),\n+            buildGradle(\n+              //language=groovy\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                    id 'jvm-test-suite'\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation \"org.apache.logging.log4j:log4j-core:2.22.1\"\n+                }\n+                \n+                testing {\n+                    suites {\n+                        integrationTest(JvmTestSuite) {\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+              //language=groovy\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                    id 'jvm-test-suite'\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation \"org.apache.logging.log4j:log4j-core:2.22.1\"\n+                }\n+                \n+                testing {\n+                    suites {\n+                        integrationTest(JvmTestSuite) {\n+                            dependencies {\n+                                %s platform(\"org.springframework.boot:spring-boot-dependencies:3.2.4\")\n+                            }\n+                        }\n+                    }\n+                }\n+                \"\"\".formatted(gradleConfiguration)\n+            )));\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+      \"integrationTestImplementation,implementation\",\n+      \"integrationTestCompileOnly,compileOnly\",\n+      \"integrationTestRuntimeOnly,runtimeOnly\",\n+      \"integrationTestAnnotationProcessor,annotationProcessor\"})\n+    void addEnforcedPlatformDependencyWithExplicitConfiguration(String recipeConfiguration, String gradleConfiguration) {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPlatformDependency(\"org.springframework.boot\", \"spring-boot-dependencies\", \"3.2.4\", null, recipeConfiguration, true)),\n+          mavenProject(\"project\",\n+            srcMainJava(java(usingGuavaIntMath, sourceSpecs -> sourceSet(sourceSpecs, \"integrationTest\"))),\n+            buildGradle(\n+              //language=groovy\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                    id 'jvm-test-suite'\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation \"org.apache.logging.log4j:log4j-core:2.22.1\"\n+                }\n+                \n+                testing {\n+                    suites {\n+                        integrationTest(JvmTestSuite) {\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+              //language=groovy\n+              \"\"\"\n+                plugins {\n+                    id \"java-library\"\n+                    id 'jvm-test-suite'\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation \"org.apache.logging.log4j:log4j-core:2.22.1\"\n+                }\n+                \n+                testing {\n+                    suites {\n+                        integrationTest(JvmTestSuite) {\n+                            dependencies {\n+                                %s enforcedPlatform(\"org.springframework.boot:spring-boot-dependencies:3.2.4\")\n+                            }\n+                        }\n+                    }\n+                }\n+                \"\"\".formatted(gradleConfiguration)\n+            )));\n+    }\n+}\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindJVMTestSuitesTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindJVMTestSuitesTest.java\nindex f8e34ed5d69..401cd603e2b 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindJVMTestSuitesTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindJVMTestSuitesTest.java\n@@ -36,7 +36,7 @@ class NoDependency {\n         @Test\n         void configNull() {\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(null, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(\n                 withoutDependency,\n                 withoutDependencyFound\n@@ -47,21 +47,13 @@ void configNull() {\n         @Test\n         void configFalse() {\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(false, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(\n                 withoutDependency,\n                 withoutDependencyFound\n               )\n             );\n         }\n-\n-        @Test\n-        void configTrue() {\n-            rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(true, null)),\n-              buildGradle(withoutDependency)\n-            );\n-        }\n     }\n \n     @Nested\n@@ -69,7 +61,7 @@ class WithDependency {\n         @Test\n         void configNull() {\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(null, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(\n                 withDependency,\n                 withDependencyFound\n@@ -80,7 +72,7 @@ void configNull() {\n         @Test\n         void configFalse() {\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(false, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(\n                 withDependency,\n                 withDependencyFound\n@@ -91,7 +83,7 @@ void configFalse() {\n         @Test\n         void configTrue() {\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(true, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(\n                 withDependency,\n                 withDependencyFound\n@@ -105,15 +97,15 @@ class NoPlugin {\n         @Test\n         void noSuiteDefined() {\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(null, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(noSuiteDefined)\n             );\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(false, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(noSuiteDefined)\n             );\n             rewriteRun(\n-              spec -> spec.recipe(new FindJVMTestSuites(true, null)),\n+              spec -> spec.recipe(new FindJVMTestSuites(null)),\n               buildGradle(noSuiteDefined)\n             );\n         }\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/trait/JvmTestSuiteTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/trait/JvmTestSuiteTest.java\nnew file mode 100644\nindex 00000000000..4bc0444a537\n--- /dev/null\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/trait/JvmTestSuiteTest.java\n@@ -0,0 +1,412 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle.trait;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.DocumentExample;\n+import org.openrewrite.marker.SearchResult;\n+import org.openrewrite.maven.table.MavenMetadataFailures;\n+import org.openrewrite.test.RecipeSpec;\n+import org.openrewrite.test.RewriteTest;\n+\n+import static org.openrewrite.gradle.Assertions.buildGradle;\n+import static org.openrewrite.gradle.Assertions.buildGradleKts;\n+import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n+import static org.openrewrite.gradle.trait.Traits.jvmTestSuite;\n+\n+class JvmTestSuiteTest implements RewriteTest {\n+    @Override\n+    public void defaults(RecipeSpec spec) {\n+        spec.beforeRecipe(withToolingApi())\n+          .recipe(RewriteTest.toRecipe(() -> jvmTestSuite().asVisitor(suite ->\n+            SearchResult.found(suite.getTree()))));\n+    }\n+\n+    @Nested\n+    class GroovyDsl {\n+        @DocumentExample\n+        @Test\n+        void all() {\n+            rewriteRun(\n+              buildGradle(\n+                \"\"\"\n+                  plugins {\n+                      id \"java\"\n+                      id \"jvm-test-suite\"\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          test {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          integrationTest(JvmTestSuite) {\n+                              dependencies {\n+                                  implementation project()\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \"\"\",\n+                \"\"\"\n+                  plugins {\n+                      id \"java\"\n+                      id \"jvm-test-suite\"\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          /*~~>*/test {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          /*~~>*/integrationTest(JvmTestSuite) {\n+                              dependencies {\n+                                  implementation project()\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void findByName() {\n+            rewriteRun(\n+              spec -> spec.recipe(RewriteTest.toRecipe(() -> jvmTestSuite().name(\"integrationTest\").asVisitor(suite ->\n+                SearchResult.found(suite.getTree())))),\n+              buildGradle(\n+                \"\"\"\n+                  plugins {\n+                      id \"java\"\n+                      id \"jvm-test-suite\"\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          test {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          integrationTest(JvmTestSuite) {\n+                              dependencies {\n+                                  implementation project()\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \"\"\",\n+                \"\"\"\n+                  plugins {\n+                      id \"java\"\n+                      id \"jvm-test-suite\"\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          test {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          /*~~>*/integrationTest(JvmTestSuite) {\n+                              dependencies {\n+                                  implementation project()\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void addDependency() {\n+            rewriteRun(\n+              spec -> spec.recipe(RewriteTest.toRecipe((recipe) -> jvmTestSuite().asVisitor((suite, ctx) ->\n+                suite.addDependency(\"implementation\", \"com.google.guava\", \"guava\", \"29.0-jre\", null, null, null, new MavenMetadataFailures(recipe), null, ctx).visitNonNull(suite.getTree(), ctx, suite.getCursor().getParentOrThrow())))),\n+              buildGradle(\n+                \"\"\"\n+                  plugins {\n+                      id \"java\"\n+                      id \"jvm-test-suite\"\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          test {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          integrationTest(JvmTestSuite) {\n+                              dependencies {\n+                                  implementation project()\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \"\"\",\n+                \"\"\"\n+                  plugins {\n+                      id \"java\"\n+                      id \"jvm-test-suite\"\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          test {\n+                              useJUnitJupiter()\n+                  \n+                              dependencies {\n+                                  implementation \"com.google.guava:guava:29.0-jre\"\n+                              }\n+                          }\n+                  \n+                          integrationTest(JvmTestSuite) {\n+                              dependencies {\n+                                  implementation project()\n+                                  implementation \"com.google.guava:guava:29.0-jre\"\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+    }\n+\n+    @Nested\n+    class KotlinDsl {\n+        @DocumentExample\n+        @Test\n+        void all() {\n+            rewriteRun(\n+              buildGradleKts(\n+                \"\"\"\n+                  plugins {\n+                      java\n+                      `jvm-test-suite`\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          val test by getting(JvmTestSuite::class) {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          register<JvmTestSuite>(\"integrationTest\") {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                  \n+                          val functionalTest by registering(JvmTestSuite::class) {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \"\"\",\n+                \"\"\"\n+                  plugins {\n+                      java\n+                      `jvm-test-suite`\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          /*~~>*/val test by getting(JvmTestSuite::class) {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          /*~~>*/register<JvmTestSuite>(\"integrationTest\") {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                  \n+                          /*~~>*/val functionalTest by registering(JvmTestSuite::class) {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void findByName() {\n+            rewriteRun(\n+              spec -> spec.recipe(RewriteTest.toRecipe(() -> jvmTestSuite().name(\"integrationTest\").asVisitor(suite ->\n+                SearchResult.found(suite.getTree())))),\n+              buildGradleKts(\n+                \"\"\"\n+                  plugins {\n+                      java\n+                      `jvm-test-suite`\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          val test by getting(JvmTestSuite::class) {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          register<JvmTestSuite>(\"integrationTest\") {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \"\"\",\n+                \"\"\"\n+                  plugins {\n+                      java\n+                      `jvm-test-suite`\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          val test by getting(JvmTestSuite::class) {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          /*~~>*/register<JvmTestSuite>(\"integrationTest\") {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void addDependency() {\n+            rewriteRun(\n+              spec -> spec.recipe(RewriteTest.toRecipe((recipe) -> jvmTestSuite().asVisitor((suite, ctx) ->\n+                suite.addDependency(\"implementation\", \"com.google.guava\", \"guava\", \"29.0-jre\", null, null, null, new MavenMetadataFailures(recipe), null, ctx).visitNonNull(suite.getTree(), ctx, suite.getCursor().getParentOrThrow())))),\n+              buildGradleKts(\n+                \"\"\"\n+                  plugins {\n+                      java\n+                      `jvm-test-suite`\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          val test by getting(JvmTestSuite::class) {\n+                              useJUnitJupiter()\n+                          }\n+                  \n+                          register<JvmTestSuite>(\"integrationTest\") {\n+                              dependencies {\n+                                  implementation(project())\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \"\"\",\n+                \"\"\"\n+                  plugins {\n+                      java\n+                      `jvm-test-suite`\n+                  }\n+                  \n+                  repositories {\n+                      mavenCentral()\n+                  }\n+                  \n+                  testing {\n+                      suites {\n+                          val test by getting(JvmTestSuite::class) {\n+                              useJUnitJupiter()\n+                  \n+                              dependencies {\n+                                  implementation(\"com.google.guava:guava:29.0-jre\")\n+                              }\n+                          }\n+                  \n+                          register<JvmTestSuite>(\"integrationTest\") {\n+                              dependencies {\n+                                  implementation(project())\n+                                  implementation(\"com.google.guava:guava:29.0-jre\")\n+                              }\n+                          }\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5370",
    "pr_id": 5370,
    "issue_id": 5362,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Parsing Lombok's `@SuperBuilder` with a `@Builder.Default`\n## What version of OpenRewrite are you using?\n\nI am using\n\n- OpenRewrite v8.51.0\n- Gradle plugin v7.5.0\n- `org.openrewrite.recipe:rewrite-migrate-java` v3.8.0\n\n## How are you running OpenRewrite?\n\nI am using the Gradle plugin, and my project is a single module project.\n```groovy\nplugins {\n    id 'java'\n    id \"org.openrewrite.rewrite\" version \"7.5.0\"\n}\n```\n\n## What is the smallest, simplest way to reproduce the problem?\n\n```java\nimport lombok.Builder;\nimport lombok.experimental.SuperBuilder;\n\n@SuperBuilder\npublic class Test {\n    @Builder.Default\n    private final boolean foo = true;\n}\n```\nTaken from: [yuri1969/parsing-test](https://github.com/yuri1969/parsing-test)\n\n## What did you see instead?\n\n> There were problems parsing src/main/java/org/example/Test.java\n\n## What is the full stack trace of any errors you encountered?\n\n<details><summary>Stack trace</summary>\n<pre>\n2025-05-01T19:56:08.452+0200 [INFO] [org.openrewrite.gradle.RewriteDryRunTask] Error during rewrite dry run\njava.lang.IllegalArgumentException: fromIndex(237) > toIndex(182)\n        at org.openrewrite.java.tree.Space.rangeCheck(Space.java:464)\n        at org.openrewrite.java.tree.Space.format(Space.java:145)\n        at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitCompilationUnit(ReloadableJava21ParserVisitor.java:597)\n        at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitCompilationUnit(ReloadableJava21ParserVisitor.java:77)\n        at com.sun.tools.javac.tree.JCTree$JCCompilationUnit.accept(JCTree.java:623)\n        at com.sun.source.util.TreePathScanner.scan(TreePathScanner.java:92)\n        at org.openrewrite.java.isolated.ReloadableJava21Parser.lambda$parseInputs$1(ReloadableJava21Parser.java:188)\n        at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\n        at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)\n        at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1939)\n        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\n        at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\n        at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n        at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)\n        at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)\n        at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\n        at java.base/java.util.stream.Streams$StreamBuilderImpl.forEachRemaining(Streams.java:411)\n        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735)\n        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735)\n        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734)\n        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735)\n        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734)\n        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734)\n        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734)\n        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735)\n        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)\n        at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n        at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.listResults(DefaultProjectParser.java:1382)\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.dryRun(DefaultProjectParser.java:334)\n        at org.openrewrite.gradle.DelegatingProjectParser.lambda$dryRun$3(DelegatingProjectParser.java:123)\n        at org.openrewrite.gradle.DelegatingProjectParser.unwrapInvocationException(DelegatingProjectParser.java:164)\n        at org.openrewrite.gradle.DelegatingProjectParser.dryRun(DelegatingProjectParser.java:122)\n        at org.openrewrite.gradle.RewriteDryRunTask.run(RewriteDryRunTask.java:52)\n        at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\n        at java.base/java.lang.reflect.Method.invoke(Method.java:580)\n        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:125)\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.doExecute(StandardTaskAction.java:58)\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:51)\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:29)\n        at org.gradle.api.internal.tasks.execution.TaskExecution$3.run(TaskExecution.java:244)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:29)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:26)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:166)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.run(DefaultBuildOperationRunner.java:47)\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeAction(TaskExecution.java:229)\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeActions(TaskExecution.java:212)\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeWithPreviousOutputFiles(TaskExecution.java:195)\n        at org.gradle.api.internal.tasks.execution.TaskExecution.execute(TaskExecution.java:162)\n        at org.gradle.internal.execution.steps.ExecuteStep.executeInternal(ExecuteStep.java:105)\n        at org.gradle.internal.execution.steps.ExecuteStep.access$000(ExecuteStep.java:44)\n        at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:59)\n        at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:56)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:209)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:166)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\n        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:56)\n        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:44)\n        at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:42)\n        at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:75)\n        at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:55)\n        at org.gradle.internal.execution.steps.PreCreateOutputParentsStep.execute(PreCreateOutputParentsStep.java:50)\n        at org.gradle.internal.execution.steps.PreCreateOutputParentsStep.execute(PreCreateOutputParentsStep.java:28)\n        at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:67)\n        at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:37)\n        at org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:61)\n        at org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:26)\n        at org.gradle.internal.execution.steps.CaptureOutputsAfterExecutionStep.execute(CaptureOutputsAfterExecutionStep.java:69)\n        at org.gradle.internal.execution.steps.CaptureOutputsAfterExecutionStep.execute(CaptureOutputsAfterExecutionStep.java:46)\n        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:40)\n        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:29)\n        at org.gradle.internal.execution.steps.BuildCacheStep.executeWithoutCache(BuildCacheStep.java:189)\n        at org.gradle.internal.execution.steps.BuildCacheStep.lambda$execute$1(BuildCacheStep.java:75)\n        at org.gradle.internal.Either$Right.fold(Either.java:175)\n        at org.gradle.internal.execution.caching.CachingState.fold(CachingState.java:62)\n        at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:73)\n        at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:48)\n        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:46)\n        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:35)\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:75)\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$2(SkipUpToDateStep.java:53)\n        at java.base/java.util.Optional.orElseGet(Optional.java:364)\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:53)\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:35)\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:37)\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:27)\n        at org.gradle.internal.execution.steps.ResolveIncrementalCachingStateStep.executeDelegate(ResolveIncrementalCachingStateStep.java:49)\n        at org.gradle.internal.execution.steps.ResolveIncrementalCachingStateStep.executeDelegate(ResolveIncrementalCachingStateStep.java:27)\n        at org.gradle.internal.execution.steps.AbstractResolveCachingStateStep.execute(AbstractResolveCachingStateStep.java:71)\n        at org.gradle.internal.execution.steps.AbstractResolveCachingStateStep.execute(AbstractResolveCachingStateStep.java:39)\n        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:65)\n        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:36)\n        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:107)\n        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:56)\n        at org.gradle.internal.execution.steps.AbstractCaptureStateBeforeExecutionStep.execute(AbstractCaptureStateBeforeExecutionStep.java:64)\n        at org.gradle.internal.execution.steps.AbstractCaptureStateBeforeExecutionStep.execute(AbstractCaptureStateBeforeExecutionStep.java:43)\n        at org.gradle.internal.execution.steps.AbstractSkipEmptyWorkStep.executeWithNonEmptySources(AbstractSkipEmptyWorkStep.java:125)\n        at org.gradle.internal.execution.steps.AbstractSkipEmptyWorkStep.execute(AbstractSkipEmptyWorkStep.java:56)\n        at org.gradle.internal.execution.steps.AbstractSkipEmptyWorkStep.execute(AbstractSkipEmptyWorkStep.java:36)\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:38)\n        at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:36)\n        at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:23)\n        at org.gradle.internal.execution.steps.HandleStaleOutputsStep.execute(HandleStaleOutputsStep.java:75)\n        at org.gradle.internal.execution.steps.HandleStaleOutputsStep.execute(HandleStaleOutputsStep.java:41)\n        at org.gradle.internal.execution.steps.AssignMutableWorkspaceStep.lambda$execute$0(AssignMutableWorkspaceStep.java:35)\n        at org.gradle.api.internal.tasks.execution.TaskExecution$4.withWorkspace(TaskExecution.java:289)\n        at org.gradle.internal.execution.steps.AssignMutableWorkspaceStep.execute(AssignMutableWorkspaceStep.java:31)\n        at org.gradle.internal.execution.steps.AssignMutableWorkspaceStep.execute(AssignMutableWorkspaceStep.java:22)\n        at org.gradle.internal.execution.steps.ChoosePipelineStep.execute(ChoosePipelineStep.java:40)\n        at org.gradle.internal.execution.steps.ChoosePipelineStep.execute(ChoosePipelineStep.java:23)\n        at org.gradle.internal.execution.steps.ExecuteWorkBuildOperationFiringStep.lambda$execute$2(ExecuteWorkBuildOperationFiringStep.java:67)\n        at java.base/java.util.Optional.orElseGet(Optional.java:364)\n        at org.gradle.internal.execution.steps.ExecuteWorkBuildOperationFiringStep.execute(ExecuteWorkBuildOperationFiringStep.java:67)\n        at org.gradle.internal.execution.steps.ExecuteWorkBuildOperationFiringStep.execute(ExecuteWorkBuildOperationFiringStep.java:39)\n        at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:46)\n        at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:34)\n        at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:48)\n        at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:35)\n        at org.gradle.internal.execution.impl.DefaultExecutionEngine$1.execute(DefaultExecutionEngine.java:61)\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:127)\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:116)\n        at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)\n        at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)\n        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)\n        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:74)\n        at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:209)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:166)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)\n        at org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:42)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:331)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:318)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.lambda$execute$0(DefaultTaskExecutionGraph.java:314)\n        at org.gradle.internal.operations.CurrentBuildOperationRef.with(CurrentBuildOperationRef.java:85)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:314)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:303)\n        at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:459)\n        at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:376)\n        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)\n        at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:48)\n        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)\n        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)\n        at java.base/java.lang.Thread.run(Thread.java:1583)\n</pre>\n</details> \n",
    "issue_word_count": 2254,
    "test_files_count": 1,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/BuilderHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SuperBuilderHandler.java",
      "rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java"
    ],
    "base_commit": "8be98cd0c83b9ba1d0f4b38914d42fcd6137bb7e",
    "head_commit": "11df5081e1339163a92484c7cbeba0ce3178b37b",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5370",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5370",
    "dockerfile": "",
    "pr_merged_at": "2025-05-07T07:25:47.000Z",
    "patch": "diff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/BuilderHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/BuilderHandler.java\nindex 73c8b434f30..f6d56e20191 100644\n--- a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/BuilderHandler.java\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/BuilderHandler.java\n@@ -57,6 +57,7 @@ public void handle(AnnotationValues<Builder> annotationValues, JCTree.JCAnnotati\n             // which is unlikely to be called in original code. Therefore, it is safe to temporarily remove the\n             // @Builder.Default annotation during processing.\n             for (JavacNode fieldNode : HandleConstructor.findAllFields(parent, true)) {\n+                @SuppressWarnings(\"unchecked\") // if the cast fails the resulting parser error is clear enough\n                 LombokImmutableList<JavacNode> children = (LombokImmutableList<JavacNode>) childrenField.get(fieldNode);\n                 nodeToChildrenMap.put(fieldNode, children);\n                 LombokImmutableList<JavacNode> filtered = children;\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SuperBuilderHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SuperBuilderHandler.java\nnew file mode 100644\nindex 00000000000..cdd76958030\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SuperBuilderHandler.java\n@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.ListBuffer;\n+import lombok.core.AnnotationValues;\n+import lombok.core.HandlerPriority;\n+import lombok.core.LombokImmutableList;\n+import lombok.core.LombokNode;\n+import lombok.experimental.SuperBuilder;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+import lombok.javac.handlers.HandleConstructor;\n+import lombok.javac.handlers.HandleSuperBuilder;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static lombok.core.AST.Kind.ANNOTATION;\n+\n+/**\n+ * A crude copy of {@link BuilderHandler}.\n+ */\n+@HandlerPriority(-1024)\n+public class SuperBuilderHandler extends JavacAnnotationHandler<SuperBuilder> {\n+    @Override\n+    public void handle(AnnotationValues<SuperBuilder> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+        JavacNode parent = javacNode.up();\n+        if (!(parent.get() instanceof JCTree.JCClassDecl)) {\n+            new HandleSuperBuilder().handle(annotationValues, jcAnnotation, javacNode);\n+            return;\n+        }\n+        Map<JCTree.JCModifiers, FlagAndAnnotations> modifiersRestoreMap = new HashMap<>();\n+        Map<JavacNode, LombokImmutableList<JavacNode>> nodeToChildrenMap = new HashMap<>();\n+        Field childrenField = null;\n+        try {\n+            childrenField = LombokNode.class.getDeclaredField(\"children\");\n+            childrenField.setAccessible(true);\n+            // The Lombok handler for the @SuperBuilder annotation sets the init expression to null for fields annotated\n+            // with @Builder.Default. Unlike typical Lombok behavior, which either creates new methods or fields, the\n+            // handler for SuperBuilder annotation modifies the existing variable declaration. As a result, the AST-to-LST\n+            // converter never encounters the init expression, causing it to behave unexpectedly.\n+            // Additionally, the @Builder.Default annotation generates a private method named $default$<varname>,\n+            // which is unlikely to be called in original code. Therefore, it is safe to temporarily remove the\n+            // @Builder.Default annotation during processing.\n+            for (JavacNode fieldNode : HandleConstructor.findAllFields(parent, true)) {\n+                @SuppressWarnings(\"unchecked\") // if the cast fails the resulting parser error is clear enough\n+                LombokImmutableList<JavacNode> children = (LombokImmutableList<JavacNode>) childrenField.get(fieldNode);\n+                nodeToChildrenMap.put(fieldNode, children);\n+                LombokImmutableList<JavacNode> filtered = children;\n+                for (int i : findBuilderDefaultIndexes(children)) {\n+                    filtered = filtered.removeElementAt(i);\n+                }\n+                childrenField.set(fieldNode, filtered);\n+                JCTree.JCVariableDecl fd = (JCTree.JCVariableDecl) fieldNode.get();\n+                JCTree.JCModifiers modifiers = fd.getModifiers();\n+\n+                modifiersRestoreMap.put(modifiers, new FlagAndAnnotations(modifiers.flags, modifiers.annotations));\n+                modifiers.annotations = removeBuilderDefault(modifiers.annotations);\n+                modifiers.flags = modifiers.flags & (~(1 << 4) /*final mask*/);\n+            }\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            // On exception just continue with the original handler\n+        }\n+        new HandleSuperBuilder().handle(annotationValues, jcAnnotation, javacNode);\n+\n+        // restore values\n+        for (Map.Entry<JCTree.JCModifiers, FlagAndAnnotations> entry : modifiersRestoreMap.entrySet()) {\n+            entry.getKey().flags = entry.getValue().flags;\n+            entry.getKey().annotations = entry.getValue().annotations;\n+        }\n+        for (Map.Entry<JavacNode, LombokImmutableList<JavacNode>> entry : nodeToChildrenMap.entrySet()) {\n+            try {\n+                childrenField.set(entry.getKey(), entry.getValue());\n+            } catch (IllegalAccessException e) {\n+                // Not possible.\n+            }\n+        }\n+    }\n+\n+    private List<JCTree.JCAnnotation> removeBuilderDefault(List<JCTree.JCAnnotation> annotations) {\n+        ListBuffer<JCTree.JCAnnotation> filteredAnnotations = new ListBuffer<>();\n+        for (JCTree.JCAnnotation annotation : annotations) {\n+            if (annotation.getAnnotationType().toString().equals(\"lombok.Builder.Default\")) {\n+                continue;\n+            }\n+            filteredAnnotations = filteredAnnotations.append(annotation);\n+        }\n+        return filteredAnnotations.toList();\n+    }\n+\n+    private List<Integer> findBuilderDefaultIndexes(LombokImmutableList<JavacNode> nodes) {\n+        ListBuffer<Integer> indexes = new ListBuffer<>();\n+        for (int i = 0; i < nodes.size(); i++) {\n+            JavacNode node = nodes.get(i);\n+            if (node.getKind() == ANNOTATION && \"lombok.Builder.Default\".equals(node.get().type.toString())) {\n+                indexes.add(i);\n+            }\n+        }\n+        return indexes.toList();\n+    }\n+\n+    private static class FlagAndAnnotations {\n+        long flags;\n+        List<JCTree.JCAnnotation> annotations;\n+\n+        FlagAndAnnotations(long flags, List<JCTree.JCAnnotation> annotations) {\n+            this.flags = flags;\n+            this.annotations = annotations;\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler b/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler\nindex b556f06f95e..6d19a192856 100644\n--- a/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler\n+++ b/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler\n@@ -29,4 +29,5 @@ org.openrewrite.java.lombok.NonNullNoOpHandler\n org.openrewrite.java.lombok.RequiredArgsConstructorHandler\n org.openrewrite.java.lombok.SetterHandler\n org.openrewrite.java.lombok.SneakyThrowsNoOpHandler\n+org.openrewrite.java.lombok.SuperBuilderHandler\n org.openrewrite.java.lombok.SynchronizedNoOpHandler\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\nindex 5a0d663fd65..6e4467ff09d 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\n@@ -122,74 +122,200 @@ void test() {\n         );\n     }\n \n-    @Test\n-    void builder() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import lombok.Builder;\n-              \n-              @Builder\n-              class A {\n-                  boolean b;\n-                  int n;\n-                  String s;\n-              \n-                  void test() {\n-                      A a = A.builder().n(1).b(true).s(\"foo\").build();\n+    @Nested\n+    class Builder {\n+        @Test\n+        void simple() {\n+            rewriteRun(\n+              java(\n+                \"\"\"\n+                  import lombok.Builder;\n+                  \n+                  @Builder\n+                  class A {\n+                      boolean b;\n+                      int n;\n+                      String s;\n+                  \n+                      void test() {\n+                          A a = A.builder().n(1).b(true).s(\"foo\").build();\n+                      }\n                   }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n+                  \"\"\"\n+              )\n+            );\n+        }\n \n-    @Test\n-    void builderWithDefault() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import lombok.Builder;\n-              \n-              @Builder\n-              class A {\n-                  @Builder.Default boolean b = false;\n-                  @Builder.Default int n = 0;\n-                  @Builder.Default String s = \"Hello, Anshuman!\";\n-              \n-                  void test() {\n-                      A x = A.builder().n(1).b(true).s(\"foo\").build();\n-                      A y = A.builder().n(1).b(true).build();\n-                      A z = A.builder().n(1).build();\n+        @Test\n+        void withDefault() {\n+            rewriteRun(\n+              java(\n+                \"\"\"\n+                  import lombok.Builder;\n+                  \n+                  @Builder\n+                  class A {\n+                      @Builder.Default boolean b = false;\n+                      @Builder.Default int n = 0;\n+                      @Builder.Default String s = \"Hello, Anshuman!\";\n+                  \n+                      void test() {\n+                          A x = A.builder().n(1).b(true).s(\"foo\").build();\n+                          A y = A.builder().n(1).b(true).build();\n+                          A z = A.builder().n(1).build();\n+                      }\n                   }\n-              }\n-              \"\"\"\n-          )\n-        );\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void withDefaultAndFinal() {\n+            rewriteRun(\n+              java(\n+                \"\"\"\n+                  import lombok.Builder;\n+                  \n+                  @Builder\n+                  class A {\n+                      @Builder.Default private final boolean b = false;\n+                      @Builder.Default public final int n = 0;\n+                      @Builder.Default protected final String s = \"Hello, Anshuman!\";\n+                  \n+                      void test() {\n+                          A x = A.builder().n(1).b(true).s(\"foo\").build();\n+                          A y = A.builder().n(1).b(true).build();\n+                          A z = A.builder().n(1).build();\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n     }\n \n-    @Test\n-    void builderWithDefaultAndFinal() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import lombok.Builder;\n-              \n-              @Builder\n-              class A {\n-                  @Builder.Default private final boolean b = false;\n-                  @Builder.Default public final int n = 0;\n-                  @Builder.Default protected final String s = \"Hello, Anshuman!\";\n-              \n-                  void test() {\n-                      A x = A.builder().n(1).b(true).s(\"foo\").build();\n-                      A y = A.builder().n(1).b(true).build();\n-                      A z = A.builder().n(1).build();\n+    @Nested\n+    class SuperBuilder {\n+\n+        @Test\n+        void withHierarchy() {\n+            rewriteRun(\n+              java(\n+                \"\"\"\n+                  import lombok.experimental.SuperBuilder;\n+                  \n+                  @SuperBuilder\n+                  public class Parent {\n+                      String lastName;\n                   }\n-              }\n-              \"\"\"\n-          )\n-        );\n+                  \"\"\"\n+              ),\n+              java(\n+                \"\"\"\n+                  import lombok.experimental.SuperBuilder;\n+                  \n+                  @SuperBuilder\n+                  public class Child extends Parent {\n+                      String firstName;\n+                  }\n+                  \"\"\"\n+              ),\n+              java(\n+                \"\"\"\n+                  class Test {\n+                      void test() {\n+                          Child child = Child.builder()\n+                            .firstName(\"John\")\n+                            .lastName(\"Doe\")\n+                            .build();\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void withHierarchy2() {\n+            rewriteRun(\n+              java(\n+                \"\"\"\n+                  import lombok.experimental.SuperBuilder;\n+                  \n+                  @SuperBuilder\n+                  class Parent {\n+                      String lastName;\n+                  }\n+                  \n+                  @SuperBuilder\n+                  class Child extends Parent {\n+                      String firstName;\n+                  }\n+                  \n+                  class Test {\n+                      void test() {\n+                          Child child = Child.builder()\n+                            .firstName(\"John\")\n+                            .lastName(\"Doe\")\n+                            .build();\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void withDefault() {\n+            rewriteRun(\n+              java(\n+                \"\"\"\n+                  import lombok.Builder;\n+                  import lombok.experimental.SuperBuilder;\n+                  \n+                  @SuperBuilder\n+                  class A {\n+                      @Builder.Default boolean b = false;\n+                      @Builder.Default int n = 0;\n+                      @Builder.Default String s = \"Hello, Anshuman!\";\n+                  \n+                      void test() {\n+                          A x = A.builder().n(1).b(true).s(\"foo\").build();\n+                          A y = A.builder().n(1).b(true).build();\n+                          A z = A.builder().n(1).build();\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void withDefaultAndFinal() {\n+            rewriteRun(\n+              java(\n+                \"\"\"\n+                  import lombok.Builder;\n+                  import lombok.experimental.SuperBuilder;\n+                  \n+                  @SuperBuilder\n+                  class A {\n+                      @Builder.Default private final boolean b = false;\n+                      @Builder.Default public final int n = 0;\n+                      @Builder.Default protected final String s = \"Hello, Anshuman!\";\n+                  \n+                      void test() {\n+                          A x = A.builder().n(1).b(true).s(\"foo\").build();\n+                          A y = A.builder().n(1).b(true).build();\n+                          A z = A.builder().n(1).build();\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n     }\n \n     @Test\n@@ -985,7 +1111,7 @@ class LessSupported {\n          */\n \n         @Test\n-        // TODO: Find solution and remove this test\n+            // TODO: Find solution and remove this test\n         void jacksonizedForJava8() {\n             rewriteRun(\n               spec -> spec\n@@ -995,7 +1121,7 @@ void jacksonizedForJava8() {\n                     FindMissingTypes.MissingTypeResult result = (FindMissingTypes.MissingTypeResult) o;\n                     // Using the @Jacksonized annotation in java 8 just breaks it all\n                     return result.getPath().startsWith(\"ClassDeclaration->CompilationUnit\") ||\n-                      result.getPath().startsWith(\"Identifier->Annotation\")||\n+                      result.getPath().startsWith(\"Identifier->Annotation\") ||\n                       result.getPath().startsWith(\"Identifier->ParameterizedType\");\n                 }).build()),\n               java(\n@@ -1016,7 +1142,7 @@ public class JacksonExample {\n         }\n \n         @Test\n-        // TODO: Find solution and remove this test\n+            // TODO: Find solution and remove this test\n         void onConstructorForJava8() {\n             rewriteRun(\n               spec -> spec.typeValidationOptions(TypeValidation.builder().allowMissingType(o -> {\n@@ -1058,7 +1184,7 @@ public void test() {\n         }\n \n         @Test\n-        // TODO: Find solution and remove this test\n+            // TODO: Find solution and remove this test\n         void onConstructorNoArgsForJava8() {\n             rewriteRun(\n               spec -> spec.typeValidationOptions(TypeValidation.builder().allowMissingType(o -> {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5360",
    "pr_id": 5360,
    "issue_id": 5335,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Failure to parse multiple assignments in Groovy when variable name is prefixed by type name\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using latest in main.\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\n```java\n    @Test\n    void multipleAssignmentsAtMultipleLineStaticTypeWithTypePrefixingName() {\n        rewriteRun(\n          groovy(\n            \"\"\"\n               int a = 1    ,  \n                  intB = 2\n              \"\"\"\n          )\n        );\n    }\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\nTest passes.\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\n```java\n    expected: \n      \"int a = 1    ,\n         intB = 2\"\n     but was: \n      \"int a = 1    ,\n         intintBB = 2\"\n```",
    "issue_word_count": 330,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AssignmentTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AssignmentTest.java"
    ],
    "base_commit": "aacae38451bcce8e5696565e0e4aa3a4ef9acdae",
    "head_commit": "be92c0e1990ec14ae31bcf03c2fd497cdcc79b32",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5360",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5360",
    "dockerfile": "",
    "pr_merged_at": "2025-04-30T13:29:57.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex 18447b85acb..9dd0eb6e116 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -2085,8 +2085,11 @@ public TypeTree visitVariableExpressionType(VariableExpression expression) {\n             String typeName = \"\";\n \n             if (!expression.isDynamicTyped() && source.startsWith(expression.getOriginType().getUnresolvedName(), cursor)) {\n-                typeName = expression.getOriginType().getUnresolvedName();\n-                skip(typeName);\n+                if (cursor + expression.getOriginType().getUnresolvedName().length() < source.length()\n+                    && !Character.isJavaIdentifierPart(source.charAt(cursor + expression.getOriginType().getUnresolvedName().length()))) {\n+                    typeName = expression.getOriginType().getUnresolvedName();\n+                    skip(typeName);\n+                }\n             }\n             J.Identifier ident = new J.Identifier(randomId(),\n                     EMPTY,\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AssignmentTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AssignmentTest.java\nindex 1d04f9bd706..6b0cfa9b256 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AssignmentTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AssignmentTest.java\n@@ -196,4 +196,15 @@ void multipleAssignmentsAtMultipleLineStaticType() {\n           )\n         );\n     }\n+\n+    @Test\n+    void staticTypeWithTypeAsPrefix() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+            int a = 1    ,\n+            intB = 2\n+            \"\"\"\n+          ));\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5359",
    "pr_id": 5359,
    "issue_id": 534,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Inexpensive single-source applicability tests UsesType and UsesMethod \nSupersedes `HasTypes`, which will be deleted here as well. cc / @pway99 ",
    "issue_word_count": 19,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/UnwrapParenthesesTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/UnwrapParentheses.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/UnwrapParenthesesTest.java"
    ],
    "base_commit": "a379b8c6b1fe0f816267cd42253f71d20757ffaa",
    "head_commit": "8b1122388095583cfd014016f3cbba8b191b84ae",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5359",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5359",
    "dockerfile": "",
    "pr_merged_at": "2025-04-30T10:39:08.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/UnwrapParentheses.java b/rewrite-java/src/main/java/org/openrewrite/java/UnwrapParentheses.java\nindex 08eff31fb25..a59aecb997f 100755\n--- a/rewrite-java/src/main/java/org/openrewrite/java/UnwrapParentheses.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/UnwrapParentheses.java\n@@ -29,7 +29,7 @@ public UnwrapParentheses(J.Parentheses<?> scope) {\n \n     @Override\n     public <T extends J> J visitParentheses(J.Parentheses<T> parens, P p) {\n-        if (scope.isScope(parens) && isUnwrappable(getCursor())) {\n+        if (scope.isScope(parens) && isUnwrappable(getCursor()) && !(parens.getTree() instanceof J.SwitchExpression)) {\n             J tree = parens.getTree().withPrefix(parens.getPrefix());\n             if (tree.getPrefix().isEmpty()) {\n                 Object parent = getCursor().getParentOrThrow().getValue();\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/UnwrapParenthesesTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/UnwrapParenthesesTest.java\nindex df0b4d03714..625627c1cae 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/UnwrapParenthesesTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/UnwrapParenthesesTest.java\n@@ -254,4 +254,21 @@ public class A {\n           )\n         );\n     }\n+\n+    @Test\n+    void parensAroundSwitchAreNecessary() {\n+        rewriteRun(\n+          // language=java\n+          java(\n+            \"\"\"\n+            public class Foo {\n+                public int foo(int i) {\n+                    return (switch(i) {\n+                        default -> \"foo\";\n+                    }).length();\n+               }\n+            }\n+            \"\"\"\n+          ));\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5356",
    "pr_id": 5356,
    "issue_id": 5355,
    "repo": "openrewrite/rewrite",
    "problem_statement": "UpgradeTransitiveDependencyVersion adds constraint despite dependency being defined at depth 0\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using latest in main\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\nAdded below to `UpgradeTransitiveDependencyVersionTest`:\n```java\n    @Test\n    void test() {\n        rewriteRun(\n          buildGradle(\n            \"\"\"\n              plugins {\n                id 'java'\n              }\n              repositories { mavenCentral() }\n              \n              dependencies {\n                  implementation('com.fasterxml.jackson.core:jackson-core:2.12.0')\n                  implementation('com.fasterxml.jackson.core:jackson-databind:2.12.0')\n              }\n              \"\"\"\n          )\n        );\n    }\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\nAccording to [the docs](https://docs.openrewrite.org/recipes/java/dependencies/upgradetransitivedependencyversion), it would seem a constraint shouldn't be added since `jackson-core` is a direct dependency (as well as being a nested dependency of `jackson-databind`).\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result.\n```java\nclass A {\n    void foo(String bar) {\n        int i = 5;\n    }\n}```\n-->\n\nIt is treated as a transitive dependency and adds a constraint. Since Gradle prefers versions closer to the root, I would think this would be treated as a dependency of depth 0.\n```\n    expected: \n      \"plugins {\n        id 'java'\n      }\n      repositories { mavenCentral() }\n  \n      dependencies {\n          implementation('com.fasterxml.jackson.core:jackson-core:2.12.0')\n          implementation('com.fasterxml.jackson.core:jackson-databind:2.12.0')\n      }\"\n     but was: \n      \"plugins {\n        id 'java'\n      }\n      repositories { mavenCentral() }\n  \n      dependencies {\n          constraints {\n              implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {\n                  because 'CVE-2024-BAD'\n              }\n          }\n  \n          implementation('com.fasterxml.jackson.core:jackson-core:2.12.0')\n          implementation('com.fasterxml.jackson.core:jackson-databind:2.12.0')\n      }\"\n```\n\nI expected this to behave the same way as:\n```java\n    @Test\n    void test() {\n        rewriteRun(\n          buildGradle(\n            \"\"\"\n              plugins {\n                id 'java'\n              }\n              repositories { mavenCentral() }\n              \n              dependencies {\n                  implementation('com.fasterxml.jackson.core:jackson-core:2.12.0')\n              }\n              \"\"\"\n          )\n        );\n    }\n```\nwhich passes.\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\nYes",
    "issue_word_count": 559,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java"
    ],
    "base_commit": "b7e18bf506c4f5e5d1d89fb2b9d9977207c30896",
    "head_commit": "6aaecdf0abe6e21e6de8a097429c520921f9574e",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5356",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5356",
    "dockerfile": "",
    "pr_merged_at": "2025-04-28T20:37:16.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\nindex 1462084a3c6..dc499bfc66e 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\n@@ -42,6 +42,7 @@\n import org.openrewrite.marker.SearchResult;\n import org.openrewrite.maven.MavenDownloadingException;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n+import org.openrewrite.maven.tree.Dependency;\n import org.openrewrite.maven.tree.GroupArtifact;\n import org.openrewrite.maven.tree.GroupArtifactVersion;\n import org.openrewrite.maven.tree.ResolvedDependency;\n@@ -186,7 +187,14 @@ public J visit(@Nullable Tree tree, ExecutionContext ctx) {\n                     Map<GroupArtifact, Map<GradleDependencyConfiguration, String>> toUpdate = new LinkedHashMap<>();\n \n                     DependencyVersionSelector versionSelector = new DependencyVersionSelector(metadataFailures, gradleProject, null);\n+                    configurations:\n                     for (GradleDependencyConfiguration configuration : gradleProject.getConfigurations()) {\n+                        // Skip when there's a direct dependency, as per openrewrite/rewrite#5355\n+                        for (Dependency dependency : configuration.getRequested()) {\n+                            if (dependencyMatcher.matches(dependency.getGroupId(), dependency.getArtifactId())) {\n+                                continue configurations;\n+                            }\n+                        }\n                         for (ResolvedDependency resolved : configuration.getResolved()) {\n                             if (resolved.getDepth() > 0 && dependencyMatcher.matches(resolved.getGroupId(),\n                                     resolved.getArtifactId(), resolved.getVersion())) {\n@@ -407,7 +415,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                         .withMarkers(Markers.EMPTY);\n \n                 return autoFormat(m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {\n-                    if(!(arg instanceof J.Lambda)) {\n+                    if (!(arg instanceof J.Lambda)) {\n                         return arg;\n                     }\n                     J.Lambda dependencies = (J.Lambda) arg;\n@@ -450,7 +458,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                         .withMarkers(Markers.EMPTY);\n \n                 return m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {\n-                    if(!(arg instanceof J.Lambda)) {\n+                    if (!(arg instanceof J.Lambda)) {\n                         return arg;\n                     }\n                     J.Lambda dependencies = (J.Lambda) arg;\n@@ -484,7 +492,7 @@ private static class AddConstraint extends JavaIsoVisitor<ExecutionContext> {\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n-            if(!CONSTRAINTS_MATCHER.matches(m) && !(isKotlinDsl && m.getSimpleName().equals(\"constraints\") && withinBlock(getCursor(), \"dependencies\"))) {\n+            if (!CONSTRAINTS_MATCHER.matches(m) && !(isKotlinDsl && m.getSimpleName().equals(\"constraints\") && withinBlock(getCursor(), \"dependencies\"))) {\n                 return m;\n             }\n             String ga = gav.getGroupId() + \":\" + gav.getArtifactId();\n@@ -493,7 +501,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n             MethodMatcher constraintMatcher = new MethodMatcher(CONSTRAINT_MATCHER, true);\n             for (Statement statement : ((J.Block) ((J.Lambda) m.getArguments().get(0)).getBody()).getStatements()) {\n                 if (statement instanceof J.MethodInvocation || (statement instanceof J.Return && ((J.Return) statement).getExpression() instanceof J.MethodInvocation)) {\n-                    J.MethodInvocation m2 = (J.MethodInvocation) (statement instanceof J.Return ? ((J.Return) statement).getExpression() :  statement);\n+                    J.MethodInvocation m2 = (J.MethodInvocation) (statement instanceof J.Return ? ((J.Return) statement).getExpression() : statement);\n                     if (constraintMatcher.matches(m2)) {\n                         if (m2.getSimpleName().equals(config) && matchesConstraint(m2, ga)) {\n                             existingConstraint = m2;\n@@ -510,7 +518,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n             if (Objects.equals(gav.getVersion(), existingConstraintVersion)) {\n                 return m;\n             }\n-            if(existingConstraint == null) {\n+            if (existingConstraint == null) {\n                 m = (J.MethodInvocation) new CreateConstraintVisitor(config, gav, because, isKotlinDsl)\n                         .visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));\n             } else {\n@@ -658,7 +666,7 @@ public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n             }\n \n             m = autoFormat(m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {\n-                if(!(arg instanceof J.Lambda)) {\n+                if (!(arg instanceof J.Lambda)) {\n                     return arg;\n                 }\n                 J.Lambda dependencies = (J.Lambda) arg;\n@@ -691,13 +699,13 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                 return method;\n             }\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n-            if(existingConstraint.isScope(m)) {\n+            if (existingConstraint.isScope(m)) {\n                 AtomicBoolean updatedBecause = new AtomicBoolean(false);\n                 m = m.withArguments(ListUtils.map(m.getArguments(), arg -> {\n-                    if(arg instanceof J.Literal) {\n+                    if (arg instanceof J.Literal) {\n                         String valueSource = ((J.Literal) arg).getValueSource();\n                         char quote;\n-                        if(valueSource == null) {\n+                        if (valueSource == null) {\n                             quote = '\\'';\n                         } else {\n                             quote = valueSource.charAt(0);\n@@ -707,17 +715,17 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                     } else if (arg instanceof J.Lambda) {\n                         arg = (Expression) new RemoveVersionVisitor().visitNonNull(arg, ctx);\n                     }\n-                    if(because != null) {\n+                    if (because != null) {\n                         Expression arg2 = (Expression) new UpdateBecauseTextVisitor(because)\n                                 .visitNonNull(arg, ctx, getCursor());\n-                        if(arg2 != arg) {\n+                        if (arg2 != arg) {\n                             updatedBecause.set(true);\n                         }\n                         return arg2;\n                     }\n                     return arg;\n                 }));\n-                if(because != null && !updatedBecause.get()) {\n+                if (because != null && !updatedBecause.get()) {\n                     m = (J.MethodInvocation) new CreateBecauseVisitor(because, isKotlinDsl).visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));\n                 }\n             }\n@@ -729,18 +737,18 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n     private static class RemoveVersionVisitor extends JavaIsoVisitor<ExecutionContext> {\n \n         @Override\n-        public  J.@Nullable Return visitReturn(J.Return _return, ExecutionContext ctx) {\n+        public J.@Nullable Return visitReturn(J.Return _return, ExecutionContext ctx) {\n             J.Return r = super.visitReturn(_return, ctx);\n-            if(r.getExpression() == null) {\n+            if (r.getExpression() == null) {\n                 return null;\n             }\n             return r;\n         }\n \n         @Override\n-        public  J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n+        public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n-            if(\"version\".equals(m.getSimpleName()) && m.getArguments().size() == 1 && m.getArguments().get(0) instanceof J.Lambda) {\n+            if (\"version\".equals(m.getSimpleName()) && m.getArguments().size() == 1 && m.getArguments().get(0) instanceof J.Lambda) {\n                 return null;\n             }\n             return m;\n@@ -751,16 +759,17 @@ private static class RemoveVersionVisitor extends JavaIsoVisitor<ExecutionContex\n     @EqualsAndHashCode(callSuper = false)\n     private static class UpdateBecauseTextVisitor extends JavaIsoVisitor<ExecutionContext> {\n         String because;\n+\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n-            if(!\"because\".equals(m.getSimpleName())) {\n+            if (!\"because\".equals(m.getSimpleName())) {\n                 return m;\n             }\n             m = m.withArguments(ListUtils.map(m.getArguments(), arg -> {\n-                if(arg instanceof J.Literal) {\n+                if (arg instanceof J.Literal) {\n                     char quote;\n-                    if(((J.Literal) arg).getValueSource() == null) {\n+                    if (((J.Literal) arg).getValueSource() == null) {\n                         quote = '\"';\n                     } else {\n                         quote = ((J.Literal) arg).getValueSource().charAt(0);\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java\nindex 87645e5d1f0..0b5112b2c09 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java\n@@ -678,6 +678,25 @@ void useResolutionStrategyWhenSpringDependencyManagementPluginIsPresent() {\n         );\n     }\n \n+    @Test\n+    void noChangesIfDependencyIsAlsoPresentOnProject() {\n+        rewriteRun(\n+          buildGradle(\n+            \"\"\"\n+              plugins {\n+                id 'java'\n+              }\n+              repositories { mavenCentral() }\n+              \n+              dependencies {\n+                  implementation('com.fasterxml.jackson.core:jackson-core:2.12.0')\n+                  implementation('com.fasterxml.jackson.core:jackson-databind:2.12.0')\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void kotlinDslAddConstraint() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5354",
    "pr_id": 5354,
    "issue_id": 4072,
    "repo": "openrewrite/rewrite",
    "problem_statement": "GroovyParser issue with variable assignment using Map\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\n\r\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\n- OpenRewrite 6.8.4\r\n- Maven/Gradle plugin 7.4.2\r\n- rewrite-_module_ v1.2.3\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\nI am using the Gradle plugin, and my project is a single module project.\r\n```xml\r\nplugins {\r\n    id 'maven-publish'\r\n    id 'groovy'\r\n    id 'idea'\r\n    id 'net.researchgate.release' version '2.8.1'\r\n    id \"com.github.ben-manes.versions\" version \"0.36.0\"\r\n    id \"com.gorylenko.gradle-git-properties\" version \"2.3.2\"\r\n    id 'java-library'\r\n    id 'org.openrewrite.rewrite' version '6.8.4'\r\n}\r\n\r\nrewrite {\r\n    activeRecipe(\"org.openrewrite.java.RemoveUnusedImports\")\r\n}\r\n```\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\n```java\r\npackage openrewrite.issues\r\n\r\n\r\nclass MapIssue {\r\n    Map<String, Integer> mapTest() {\r\n        Map map0 = new HashMap()  // No parsing issue\r\n        Map map1 = [:]  // No parsing issue\r\n        Map<String, Object> map2 = [:] // No parsing issue\r\n        Map<String, Object> map3 = [:] as Map<String, Object> // No parsing issue\r\n        Map<String, Object> map4 = buildMap()  // No Parsing issue\r\n\r\n        Map error0 = new HashMap<>()  // Parsing issue due to the <>\r\n        Map error1 = [:] as Map<String, Object> // Parsing issue\r\n        Map error2 = buildMap()  // Parsing issue\r\n\r\n        return map\r\n    }\r\n\r\n    Map<String, Object> buildMap() {\r\n        return [:] as Map<String, Object>\r\n    }\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\nNo Parsing issues\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\nGroovy parsing exception\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\r\n```\r\nError during rewrite dry run\r\norg.openrewrite.groovy.GroovyParsingException: Failed to parse src\\test\\groovy\\openrewrite\\issues\\MapIssue.groovy, cursor position likely inaccurate.\r\n\tat org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:170)\r\n\tat org.openrewrite.groovy.GroovyParser.lambda$parseInputs$4(GroovyParser.java:154)\r\n\tat java.base@17.0.6/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\r\n\tat java.base@17.0.6/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\r\n\tat java.base@17.0.6/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\r\n\tat java.base@17.0.6/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.base@17.0.6/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)\r\n\tat java.base@17.0.6/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)\r\n\tat java.base@17.0.6/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\r\n\tat java.base@17.0.6/java.util.stream.Streams$StreamBuilderImpl.forEachRemaining(Streams.java:411)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\r\n\tat java.base@17.0.6/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\r\n\tat java.base@17.0.6/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\r\n\tat java.base@17.0.6/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\r\n\tat java.base@17.0.6/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\r\n\tat java.base@17.0.6/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\r\n\tat java.base@17.0.6/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\r\n\tat java.base@17.0.6/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\r\n\tat java.base@17.0.6/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\r\n\tat java.base@17.0.6/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\r\n\tat java.base@17.0.6/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\r\n\tat java.base@17.0.6/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\r\n\tat java.base@17.0.6/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\r\n\tat java.base@17.0.6/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)\r\n\tat java.base@17.0.6/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.base@17.0.6/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)\r\n\tat org.openrewrite.gradle.isolated.DefaultProjectParser.listResults(DefaultProjectParser.java:1206)\r\n\tat org.openrewrite.gradle.isolated.DefaultProjectParser.dryRun(DefaultProjectParser.java:330)\r\n\tat org.openrewrite.gradle.DelegatingProjectParser.lambda$dryRun$3(DelegatingProjectParser.java:107)\r\n\tat org.openrewrite.gradle.DelegatingProjectParser.unwrapInvocationException(DelegatingProjectParser.java:147)\r\n\tat org.openrewrite.gradle.DelegatingProjectParser.dryRun(DelegatingProjectParser.java:106)\r\n\tat org.openrewrite.gradle.RewriteDryRunTask.run(RewriteDryRunTask.java:47)\r\n\tat java.base@17.0.6/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat java.base@17.0.6/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\r\n\tat java.base@17.0.6/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.base@17.0.6/java.lang.reflect.Method.invoke(Method.java:568)\r\n\tat org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:125)\r\n\tat org.gradle.api.internal.project.taskfactory.StandardTaskAction.doExecute(StandardTaskAction.java:58)\r\n\tat org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:51)\r\n\tat org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:29)\r\n\tat org.gradle.api.internal.tasks.execution.TaskExecution$3.run(TaskExecution.java:248)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:29)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:26)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.run(DefaultBuildOperationRunner.java:47)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:68)\r\n\tat org.gradle.api.internal.tasks.execution.TaskExecution.executeAction(TaskExecution.java:233)\r\n\tat org.gradle.api.internal.tasks.execution.TaskExecution.executeActions(TaskExecution.java:216)\r\n\tat org.gradle.api.internal.tasks.execution.TaskExecution.executeWithPreviousOutputFiles(TaskExecution.java:199)\r\n\tat org.gradle.api.internal.tasks.execution.TaskExecution.execute(TaskExecution.java:166)\r\n\tat org.gradle.internal.execution.steps.ExecuteStep.executeInternal(ExecuteStep.java:105)\r\n\tat org.gradle.internal.execution.steps.ExecuteStep.access$000(ExecuteStep.java:44)\r\n\tat org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:59)\r\n\tat org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:56)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\r\n\tat org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:56)\r\n\tat org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:44)\r\n\tat org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:67)\r\n\tat org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:37)\r\n\tat org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:41)\r\n\tat org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:74)\r\n\tat org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:55)\r\n\tat org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:50)\r\n\tat org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:28)\r\n\tat org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.executeDelegateBroadcastingChanges(CaptureStateAfterExecutionStep.java:100)\r\n\tat org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:72)\r\n\tat org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:50)\r\n\tat org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:40)\r\n\tat org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:29)\r\n\tat org.gradle.internal.execution.steps.BuildCacheStep.executeWithoutCache(BuildCacheStep.java:179)\r\n\tat org.gradle.internal.execution.steps.BuildCacheStep.lambda$execute$1(BuildCacheStep.java:70)\r\n\tat org.gradle.internal.Either$Right.fold(Either.java:175)\r\n\tat org.gradle.internal.execution.caching.CachingState.fold(CachingState.java:59)\r\n\tat org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:68)\r\n\tat org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:46)\r\n\tat org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:36)\r\n\tat org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:25)\r\n\tat org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:36)\r\n\tat org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:22)\r\n\tat org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:91)\r\n\tat org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$2(SkipUpToDateStep.java:55)\r\n\tat java.base@17.0.6/java.util.Optional.orElseGet(Optional.java:364)\r\n\tat org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:55)\r\n\tat org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:37)\r\n\tat org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:65)\r\n\tat org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:36)\r\n\tat org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:37)\r\n\tat org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:27)\r\n\tat org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:76)\r\n\tat org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:37)\r\n\tat org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:108)\r\n\tat org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:55)\r\n\tat org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:71)\r\n\tat org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:45)\r\n\tat org.gradle.internal.execution.steps.SkipEmptyWorkStep.executeWithNonEmptySources(SkipEmptyWorkStep.java:177)\r\n\tat org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:81)\r\n\tat org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:53)\r\n\tat org.gradle.internal.execution.steps.RemoveUntrackedExecutionStateStep.execute(RemoveUntrackedExecutionStateStep.java:32)\r\n\tat org.gradle.internal.execution.steps.RemoveUntrackedExecutionStateStep.execute(RemoveUntrackedExecutionStateStep.java:21)\r\n\tat org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:38)\r\n\tat org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:36)\r\n\tat org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:23)\r\n\tat org.gradle.internal.execution.steps.CleanupStaleOutputsStep.execute(CleanupStaleOutputsStep.java:75)\r\n\tat org.gradle.internal.execution.steps.CleanupStaleOutputsStep.execute(CleanupStaleOutputsStep.java:41)\r\n\tat org.gradle.internal.execution.steps.ExecuteWorkBuildOperationFiringStep.lambda$execute$2(ExecuteWorkBuildOperationFiringStep.java:66)\r\n\tat java.base@17.0.6/java.util.Optional.orElseGet(Optional.java:364)\r\n\tat org.gradle.internal.execution.steps.ExecuteWorkBuildOperationFiringStep.execute(ExecuteWorkBuildOperationFiringStep.java:66)\r\n\tat org.gradle.internal.execution.steps.ExecuteWorkBuildOperationFiringStep.execute(ExecuteWorkBuildOperationFiringStep.java:38)\r\n\tat org.gradle.internal.execution.steps.AssignWorkspaceStep.lambda$execute$0(AssignWorkspaceStep.java:32)\r\n\tat org.gradle.api.internal.tasks.execution.TaskExecution$4.withWorkspace(TaskExecution.java:293)\r\n\tat org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:30)\r\n\tat org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:21)\r\n\tat org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:37)\r\n\tat org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:27)\r\n\tat org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:47)\r\n\tat org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:34)\r\n\tat org.gradle.internal.execution.impl.DefaultExecutionEngine$1.execute(DefaultExecutionEngine.java:64)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:145)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:134)\r\n\tat org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)\r\n\tat org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)\r\n\tat org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)\r\n\tat org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:74)\r\n\tat org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)\r\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)\r\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)\r\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\r\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)\r\n\tat org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:42)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:331)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:318)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.lambda$execute$0(DefaultTaskExecutionGraph.java:314)\r\n\tat org.gradle.internal.operations.CurrentBuildOperationRef.with(CurrentBuildOperationRef.java:80)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:314)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:303)\r\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:463)\r\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:380)\r\n\tat org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)\r\n\tat org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:47)\r\n\tat java.base@17.0.6/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\r\n\tat java.base@17.0.6/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\r\n\tat java.base@17.0.6/java.lang.Thread.run(Thread.java:833)\r\nCaused by: java.lang.StringIndexOutOfBoundsException: begin 704, end 712, length 710\r\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4602)\r\n\tat java.base/java.lang.String.substring(String.java:2705)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitMethodCallExpression(GroovyParserVisitor.java:1531)\r\nCaused by: java.lang.StringIndexOutOfBoundsException: begin 704, end 712, length 710\r\n\r\n\tat org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:76)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:572)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitDeclarationExpression(GroovyParserVisitor.java:1278)\r\n\tat org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:89)\r\n\tat org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitExpressionStatement$6(GroovyParserVisitor.java:1305)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.labeled(GroovyParserVisitor.java:638)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitExpressionStatement(GroovyParserVisitor.java:1304)\r\n\tat org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:572)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitBlockStatement(GroovyParserVisitor.java:918)\r\n\tat org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:572)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.access$1200(GroovyParserVisitor.java:560)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.visitMethod(GroovyParserVisitor.java:537)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.lambda$visitClassBlock$3(GroovyParserVisitor.java:334)\r\n\tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\r\n\tat java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625)\r\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\r\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\r\n\tat java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\r\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\r\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)\r\n\tat java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)\r\n\tat java.base/java.util.TreeMap$ValueSpliterator.forEachRemaining(TreeMap.java:3215)\r\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\r\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\r\n\tat java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)\r\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.visitClassBlock(GroovyParserVisitor.java:341)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.visitClass(GroovyParserVisitor.java:282)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor.convertTopLevelStatement(GroovyParserVisitor.java:2023)\r\n\tat org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:161)\r\n\t... 175 more\r\nThere were problems parsing some source files, run with --info to see full stack traces\r\nThere were problems parsing src\\test\\groovy\\openrewrite\\issues\\MapIssue.groovy\r\nAll sources parsed, running active recipes: org.openrewrite.java.RemoveUnusedImports\r\nApplying recipes would make no changes. No report generated.\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\n",
    "issue_word_count": 3230,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyParserTest.java"
    ],
    "base_commit": "9d332bdace9f9f23c41ec1a5bbf6a9314bf1b8ff",
    "head_commit": "ef0d5cca77905dd78672ccdfd26f1d636dbb78ba",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5354",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5354",
    "dockerfile": "",
    "pr_merged_at": "2025-04-28T12:20:27.000Z",
    "patch": "",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyParserTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyParserTest.java\nindex 8d912f9437b..a41159e38a9 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyParserTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyParserTest.java\n@@ -16,37 +16,70 @@\n package org.openrewrite.groovy;\n \n import org.junit.jupiter.api.Test;\n+import org.openrewrite.Issue;\n+import org.openrewrite.test.RewriteTest;\n \n-import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.openrewrite.groovy.Assertions.groovy;\n \n-class GroovyParserTest {\n+class GroovyParserTest implements RewriteTest {\n \n     @Test\n     void groovyPackageDefinition() {\n-        assertThatCode(() ->\n-            GroovyParser.builder().build()\n-              .parse(\n-                \"\"\"\n-                  package org.openrewrite.groovy\n-                  \n-                  class A {\n-                      static void main(String[] args) {\n-                         String name = \"John\"\n-                         println(name)\n-                      }\n-                   }\n-                  \"\"\",\n-                \"\"\"\n-                  package org.openrewrite.groovy;\n-                  \n-                  class B {\n-                      static void main(String[] args) {\n-                         String name = \"Doe\"\n-                         println(name)\n-                      }\n-                   }\n-                  \"\"\"\n-              )).doesNotThrowAnyException();\n+        rewriteRun(\n+          groovy(\n+              \"\"\"\n+              package org.openrewrite.groovy\n+              \n+              class A {\n+                  static void main(String[] args) {\n+                     String name = \"John\"\n+                     println(name)\n+                  }\n+               }\n+              \"\"\"\n+          ),\n+          groovy(\n+            \"\"\"\n+              package org.openrewrite.groovy;\n+              \n+              class B {\n+                  static void main(String[] args) {\n+                     String name = \"Doe\"\n+                     println(name)\n+                  }\n+               }\n+              \"\"\"\n+          ));\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4072\")\n+    void groovySpecialCharacters() {\n+        rewriteRun(\n+          groovy(\n+              \"\"\"\n+              package openrewrite.issues\n+              \n+              class MapIssue {\n+                  Map<String, Integer> mapTest() {\n+                      Map map0 = new HashMap()\n+                      Map map1 = [:]\n+                      Map<String, Object> map2 = [:]\n+                      Map<String, Object> map3 = [:] as Map<String, Object>\n+                      Map<String, Object> map4 = buildMap()\n+                      Map error0 = new HashMap<>()\n+                      Map error1 = [:] as Map<String, Object>\n+                      Map error2 = buildMap()\n+              \n+                      return map\n+                  }\n+              \n+                  Map<String, Object> buildMap() {\n+                      return [:] as Map<String, Object>\n+                  }\n+              }\n+              \"\"\"\n+          ));\n     }\n \n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5353",
    "pr_id": 5353,
    "issue_id": 5553,
    "repo": "openrewrite/rewrite",
    "problem_statement": "YAML with anchor and list not idempotent\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\n```java\n    @Test\n    void anchorAndList() {\n        rewriteRun(\n          yaml(\n            \"\"\"\n            root: &anchor\n            - key1: value1\n            - key2: value2\n            \"\"\"\n          )\n        );\n    }\n```\n\n## What did you expect to see?\npassing test\n\n## What did you see instead?\nidempotency error\n\n```\n    expected: \"root: &anchor\n    - key1: value1\n    - key2: value2\"\n     but was: \"root: &anchor\n     key1: value1\n    - key2: value2\"\n```\nThe hyphen on key1: value1 is lost. Happens only in files that contain the `&anchor` part.\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\nYAML is not my domain, so probably not.",
    "issue_word_count": 198,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java"
    ],
    "base_commit": "fdeacd0db519dc3ead871f59230867ec02b6394d",
    "head_commit": "a06c3fe4cdf3db04b21e0d5e0b9cce0a281fbc59",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5353",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5353",
    "dockerfile": "",
    "pr_merged_at": "2025-06-06T14:36:18.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\nindex 4133b36d1d2..d57061ceb62 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n@@ -352,19 +352,24 @@ private Yaml.Documents parseFromInput(Path sourceFile, EncodingDetectingInputStr\n                         newLine = \"\";\n \n                         SequenceStartEvent sse = (SequenceStartEvent) event;\n+                        int nextLastEnd = event.getEndMark().getIndex();\n+                        if (shouldUseYamlParserBugWorkaround(sse)) {\n+                            nextLastEnd--;\n+                        }\n+\n                         Yaml.Anchor anchor = null;\n                         if (sse.getAnchor() != null) {\n-                            anchor = buildYamlAnchor(reader, lastEnd, fmt, sse.getAnchor(), event.getEndMark().getIndex(), false);\n+                            anchor = buildYamlAnchor(reader, lastEnd, fmt, sse.getAnchor(), nextLastEnd, false);\n                             anchors.put(sse.getAnchor(), anchor);\n \n                             lastEnd = lastEnd + sse.getAnchor().length() + fmt.length() + 1;\n-                            fmt = reader.readStringFromBuffer(lastEnd, event.getEndMark().getIndex());\n+                            fmt = reader.readStringFromBuffer(lastEnd, nextLastEnd);\n                             int dashPrefixIndex = commentAwareIndexOf('-', fmt);\n                             if (dashPrefixIndex > -1) {\n                                 fmt = fmt.substring(0, dashPrefixIndex);\n                             }\n                         }\n-                        String fullPrefix = reader.readStringFromBuffer(lastEnd, event.getEndMark().getIndex());\n+                        String fullPrefix = reader.readStringFromBuffer(lastEnd, nextLastEnd);\n                         String startBracketPrefix = null;\n                         int openingBracketIndex = commentAwareIndexOf('[', fullPrefix);\n                         int startIndex = commentAwareIndexOf(Arrays.asList(':', '-'), fullPrefix) + 1;\n@@ -385,10 +390,7 @@ private Yaml.Documents parseFromInput(Path sourceFile, EncodingDetectingInputStr\n                             String tagSuffix = prefixAfterColon.substring(i, prefixAfterColon.length() - 2);\n                             tag = createTag(tagPrefix, Markers.EMPTY, tagName, tagSuffix);\n                         }\n-                        lastEnd = event.getEndMark().getIndex();\n-                        if (shouldUseYamlParserBugWorkaround(sse)) {\n-                            lastEnd--;\n-                        }\n+                        lastEnd = nextLastEnd;\n                         blockStack.push(new SequenceBuilder(fmt, startBracketPrefix, anchor, tag));\n                         break;\n                     }\n@@ -430,7 +432,7 @@ private Yaml.Documents parseFromInput(Path sourceFile, EncodingDetectingInputStr\n     }\n \n     /*\n-    The yaml-parser library unfortunately returns inconsistent marks.\n+    The SnakeYAML parser library unfortunately returns inconsistent marks.\n     If the dashes of the sequence have an indentation, the end mark and the start mark point to the dash.\n     If the dashes of the sequence do not have an indentation, the end mark will point to the character AFTER the dash.\n     */\n@@ -442,6 +444,9 @@ private boolean shouldUseYamlParserBugWorkaround(SequenceStartEvent event) {\n         }\n         int startChar = event.getStartMark().getBuffer()[startCharIndex];\n         int endChar = event.getEndMark().getBuffer()[endCharIndex];\n+        if (startChar == '&') { // anchor\n+            return event.getEndMark().getBuffer()[endCharIndex - 1] == '-' && endChar != '-';\n+        }\n         return startChar == '-' && endChar != '-';\n     }\n \n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\nindex e93d424e6e4..c9cb4ce395e 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\n@@ -409,4 +409,59 @@ void withMultipleUnicodeCharactersPerLine() {\n           )\n         );\n     }\n+\n+    @Test\n+    void withAnchorScalar() {\n+        rewriteRun(\n+          yaml(\n+            \"\"\"\n+              anchored_content: &anchor_name This string will appear as the value.\n+              other_anchor: *anchor_name\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void withAnchorMap() {\n+        rewriteRun(\n+          yaml(\n+            \"\"\"\n+              anchored_content: &anchor_name\n+                anchor_key: 1\n+                another_anchor_key: 2\n+              other_anchor: *anchor_name\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void withAnchorSequence() {\n+        rewriteRun(\n+          yaml(\n+            \"\"\"\n+              anchored_content: &anchor\n+                - item1\n+                - item2\n+              other_anchor: *anchor\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5553\")\n+    void withAnchorSequenceOnRootLevel() {\n+        rewriteRun(\n+          yaml(\n+            \"\"\"\n+              anchored_content: &anchor\n+              - item1\n+              - item2\n+              other_anchor: *anchor\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5351",
    "pr_id": 5351,
    "issue_id": 5349,
    "repo": "openrewrite/rewrite",
    "problem_statement": "GroovyParsingException when using Map literal notation in gradle dependency with spaces\n## What version of OpenRewrite are you using?\nI am using\n\n- OpenRewrite latest version\n\n## How are you running OpenRewrite?\nI am running a unit test to test some other issue fix\n\n## What is the smallest, simplest way to reproduce the problem?\n```groovy\nplugins {\n    id 'java'\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation( [group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\"] )\n}\n```\n\n## What did you expect to see?\nSuccessful parsing of the groovy gradle file\n\n## What did you see instead?\nAn error during parsing\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n```\njava.lang.AssertionError: Failed to parse sources or run recipe\n\n\tat org.openrewrite.test.RewriteTest.lambda$defaultExecutionContext$14(RewriteTest.java:641)\n\tat org.openrewrite.groovy.GroovyParser.lambda$parseInputs$3(GroovyParser.java:158)\n\tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\n\tat java.base/java.util.Collections$2.tryAdvance(Collections.java:4853)\n\tat java.base/java.util.Collections$2.forEachRemaining(Collections.java:4861)\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n\tat java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)\n\tat java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)\n\tat java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)\n\tat java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1845)\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n\tat java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n\tat java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:282)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:130)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:125)\n\tat org.openrewrite.gradle.GradleParserTest.dependencyNotations(GradleParserTest.java:193)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:569)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\nCaused by: org.openrewrite.groovy.GroovyParsingException: Failed to parse build.gradle, cursor position likely inaccurate.\n\tat org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:205)\n\tat org.openrewrite.groovy.GroovyParser.lambda$parseInputs$3(GroovyParser.java:147)\n\t... 24 more\nCaused by: java.lang.StringIndexOutOfBoundsException: begin 190, end 190, length 178\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4606)\n\tat java.base/java.lang.String.substring(String.java:2709)\n\tat org.openrewrite.groovy.GroovyParserVisitor.whitespace(GroovyParserVisitor.java:2303)\n\tat org.openrewrite.groovy.GroovyParserVisitor.access$000(GroovyParserVisitor.java:82)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitArgumentlistExpression(GroovyParserVisitor.java:752)\n\tat org.codehaus.groovy.ast.expr.ArgumentListExpression.visit(ArgumentListExpression.java:73)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:620)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitMethodCallExpression$10(GroovyParserVisitor.java:1688)\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\nSure\n",
    "issue_word_count": 560,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/GradleParserTest.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/GradleParserTest.java"
    ],
    "base_commit": "60475b8b72080fd041c0cb0c21374ca83abee53e",
    "head_commit": "464a8019201158cbf6839eb3679e196c648b07c3",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5351",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5351",
    "dockerfile": "",
    "pr_merged_at": "2025-04-28T11:40:39.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex ea3f55aa300..9090135e182 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -719,7 +719,6 @@ public void visitArgumentlistExpression(ArgumentListExpression expression) {\n                 // If it is wrapped in \"[]\" then this isn't a named arguments situation, and we should not lift the parameters out of the enclosing MapExpression\n                 saveCursor = cursor;\n                 whitespace();\n-                cursor = saveCursor;\n                 if ('[' != source.charAt(cursor)) {\n                     // Bring named parameters out of their containing MapExpression so that they can be parsed correctly\n                     MapExpression namedArgExpressions = (MapExpression) unparsedArgs.get(0);\n@@ -729,6 +728,7 @@ public void visitArgumentlistExpression(ArgumentListExpression expression) {\n                                             unparsedArgs.subList(1, unparsedArgs.size()).stream())\n                                     .collect(toList());\n                 }\n+                cursor = saveCursor;\n             }\n \n             if (unparsedArgs.isEmpty()) {\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/GradleParserTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/GradleParserTest.java\nindex 6746c717f5a..b2e1c3bcd7b 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/GradleParserTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/GradleParserTest.java\n@@ -188,6 +188,64 @@ void handleImportsThatArentTheFirstStatement() {\n         );\n     }\n \n+    @Test\n+    void dependencyNotations() {\n+        rewriteRun(\n+          buildGradle(\n+            \"\"\"\n+              plugins {\n+                  id 'java'\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+              \n+                  // String notation\n+                  implementation \"org.openrewrite:rewrite-java:latest.release\"\n+                  implementation (\"org.openrewrite:rewrite-java:latest.release\")\n+                  implementation (\"org.openrewrite:rewrite-java:latest.release\") { transitive = false }\n+                  implementation (\"org.openrewrite:rewrite-java:latest.release\") {\n+                      transitive = false\n+                  }\n+                  implementation ( \"org.openrewrite:rewrite-java:latest.release\" )\n+                  implementation ( \"org.openrewrite:rewrite-java:latest.release\" ) { transitive = false }\n+                  implementation ( \"org.openrewrite:rewrite-java:latest.release\" ) {\n+                      transitive = false\n+                  }\n+              \n+                  // Map notation\n+                  implementation group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\"\n+                  implementation(group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\")\n+                  implementation(group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\") { transitive = false }\n+                  implementation(group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\") {\n+                      transitive = false\n+                  }\n+                  implementation( group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\" )\n+                  implementation( group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\" ) { transitive = false }\n+                  implementation( group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\" ) {\n+                      transitive = false\n+                  }\n+                  \n+                  // Map literal notation\n+                  implementation([group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\"])\n+                  implementation([group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\"]) { transitive = false }\n+                  implementation([group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\"]) {\n+                      transitive = false\n+                  }\n+                  implementation( [group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\"] )\n+                  implementation( [group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\"] ) { transitive = false }\n+                  implementation( [group: \"org.openrewrite\", name: \"rewrite-java\", version: \"latest.release\"] ) {\n+                      transitive = false\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void kotlinDsl() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5323",
    "pr_id": 5323,
    "issue_id": 5289,
    "repo": "openrewrite/rewrite",
    "problem_statement": "`StackOverFlowException` when parsing a Java file with recursive type definitions\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using\n\n<!-- OpenRewrite versions   -->\n<rewrite-maven-plugin.version>6.4.0</rewrite-maven-plugin.version>\n<rewrite-testing-frameworks.version>3.6.1</rewrite-testing-frameworks.version>\n<rewrite-static-analysis.version>2.6.0</rewrite-static-analysis.version>\n<rewrite-migrate-java.version>3.7.0</rewrite-migrate-java.version>\n<rewrite-recommendations.version>1.15.0</rewrite-recommendations.version>\n\n## How are you running OpenRewrite?\n<!--\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\nIs your project a single module or a multi-module project?\n\nCan you share your configuration so that we can rule out any configuration issues?\n\nIs your project public? If so, can you share a link to it?\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\n-->\n\nMaven, see   https://github.com/jenkinsci/analysis-pom-plugin/blob/307b0a997b11b90498cb744bffb191aa8b9e8ec2/pom.xml#L269-L315\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\n\nThe original problem occurred for [DeltaComputationITest.java](https://github.com/jenkinsci/coverage-plugin/blob/main/plugin/src/test/java/io/jenkins/plugins/coverage/metrics/steps/DeltaComputationITest.java), I stripped it down to:\n\n```java\nimport java.util.Optional;\n\nimport static org.assertj.core.api.Assertions.*;\n\nclass BugTest {\n    void run() {\n        One<?, ?> firstBuild = null;\n        assertThat(Optional.of(firstBuild))\n                .isPresent()\n                .satisfies(reference -> assertThat(reference.get()).isEqualTo(firstBuild));\n    }\n\n    abstract static class One<TwoT extends Two<TwoT, OneT>, OneT extends One<TwoT, OneT>> {\n    }\n\n    abstract static class Two<TwoT extends Two<TwoT, OneT>, OneT extends One<TwoT, OneT>> {\n    }\n}\n```\n\n## What did you expect to see?\n\nThe file should be read. \n\n## What did you see instead?\n\nException, see below.\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n\n```\nCaused by: org.apache.maven.plugin.PluginExecutionException: Execution default-cli of goal org.openrewrite.maven:rewrite-maven-plugin:6.4.0:run failed: Error while visiting plugin/src/test/java/io/jenkins/plugins/coverage/metrics/steps/BugTest.java: java.lang.StackOverflowError: null\n  java.base/java.lang.StringBuilder.<init>(StringBuilder.java:106)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:884)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:911)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:890)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:911)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:890)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:911)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:890)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:911)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:890)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:911)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:890)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:911)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:890)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:911)\n  org.openrewrite.java.tree.TypeUtils.toString(TypeUtils.java:890)\n  ...\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:133)\n```\n\n## Are you interested in [contributing a fix to OpenRewrite]\n\nNot right now.",
    "issue_word_count": 739,
    "test_files_count": 2,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/internal/template/Substitutions.java",
      "rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateTest.java"
    ],
    "base_commit": "8c3ae32b9945e72b2d27d6506deebe55abe81c3f",
    "head_commit": "31d6f4f010208973247d2968cac2d80bb7657d04",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5323",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5323",
    "dockerfile": "",
    "pr_merged_at": "2025-04-23T08:28:15.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/internal/template/Substitutions.java b/rewrite-java/src/main/java/org/openrewrite/java/internal/template/Substitutions.java\nindex b8c904b6913..ecca2d46833 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/internal/template/Substitutions.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/internal/template/Substitutions.java\n@@ -207,6 +207,7 @@ private void extractTypeVariables(@Nullable JavaType type) {\n         if (type == null) {\n             return;\n         }\n+        Set<JavaType> visited = Collections.newSetFromMap(new IdentityHashMap<>());\n         new JavaTypeVisitor<Integer>() {\n             @Override\n             public JavaType visitAnnotation(JavaType.Annotation annotation, Integer p) {\n@@ -226,9 +227,10 @@ public JavaType visitClass(JavaType.Class aClass, Integer p) {\n \n             @Override\n             public JavaType visitGenericTypeVariable(JavaType.GenericTypeVariable generic, Integer p) {\n-                if (typeVariables.contains(generic)) {\n+                if (!visited.add(generic)) {\n                     return generic;\n-                } else if (!generic.getName().equals(\"?\")) {\n+                }\n+                if (!generic.getName().equals(\"?\")) {\n                     typeVariables.add(generic);\n                 }\n                 return super.visitGenericTypeVariable(generic, p);\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java\nindex 7c8a28c623b..eb0c6ef075e 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java\n@@ -903,31 +903,62 @@ static boolean deepEquals(@Nullable JavaType t, @Nullable JavaType t2) {\n     }\n \n     public static String toString(JavaType type) {\n+        return toString(type, new IdentityHashMap<>());\n+    }\n+\n+    private static String toString(JavaType type, IdentityHashMap<JavaType, Boolean> recursiveTypes) {\n         if (type instanceof JavaType.Primitive) {\n             return ((JavaType.Primitive) type).getKeyword();\n         } else if (type instanceof JavaType.Class) {\n             return ((JavaType.Class) type).getFullyQualifiedName();\n         } else if (type instanceof JavaType.Parameterized) {\n             JavaType.Parameterized parameterized = (JavaType.Parameterized) type;\n-            String base = toString(parameterized.getType());\n+            String base = toString(parameterized.getType(), recursiveTypes);\n             StringJoiner joiner = new StringJoiner(\", \", \"<\", \">\");\n             for (JavaType parameter : parameterized.getTypeParameters()) {\n-                joiner.add(toString(parameter));\n+                joiner.add(toString(parameter, recursiveTypes));\n             }\n             return base + joiner;\n         } else if (type instanceof JavaType.GenericTypeVariable) {\n             JavaType.GenericTypeVariable genericType = (JavaType.GenericTypeVariable) type;\n             if (!genericType.getName().equals(\"?\")) {\n                 return genericType.getName();\n-            } else if (genericType.getVariance() == JavaType.GenericTypeVariable.Variance.INVARIANT\n-                    || genericType.getBounds().size() != 1) { // Safe check, wildcards don't allow additional bounds\n+            } else if (genericType.getVariance() == JavaType.GenericTypeVariable.Variance.INVARIANT ||\n+                    genericType.getBounds().size() != 1) { // Safe check, wildcards don't allow additional bounds\n+                return \"?\";\n+            } else if (recursiveTypes.containsKey(genericType)) {\n+                recursiveTypes.put(genericType, true);\n                 return \"?\";\n             } else {\n+                recursiveTypes.put(genericType, false);\n                 String variance = genericType.getVariance() == JavaType.GenericTypeVariable.Variance.COVARIANT ? \"? extends \" : \"? super \";\n-                return variance + toString(genericType.getBounds().get(0));\n+                String bound = toString(genericType.getBounds().get(0), recursiveTypes);\n+                if (!recursiveTypes.get(genericType)) {\n+                    recursiveTypes.remove(genericType);\n+                    return variance + bound;\n+                }\n+                return \"?\";\n             }\n         } else if (type instanceof JavaType.Array) {\n-            return toString(((JavaType.Array) type).getElemType()) + \"[]\";\n+            return toString(((JavaType.Array) type).getElemType(), recursiveTypes) + \"[]\";\n+        } else if (type instanceof JavaType.Intersection) {\n+            JavaType.Intersection intersection = (JavaType.Intersection) type;\n+            StringJoiner joiner = new StringJoiner(\" & \");\n+            for (JavaType bound : intersection.getBounds()) {\n+                joiner.add(toString(bound, recursiveTypes));\n+            }\n+            return joiner.toString();\n+        } else if (type instanceof JavaType.MultiCatch) {\n+            JavaType.MultiCatch multiCatch = (JavaType.MultiCatch) type;\n+            StringJoiner joiner = new StringJoiner(\" | \");\n+            for (JavaType throwableType : multiCatch.getThrowableTypes()) {\n+                joiner.add(toString(throwableType, recursiveTypes));\n+            }\n+            return joiner.toString();\n+        } else if (type instanceof JavaType.Method) {\n+            return toString(((JavaType.Method) type).getReturnType(), recursiveTypes);\n+        } else if (type instanceof JavaType.Variable) {\n+            return toString(((JavaType.Variable) type).getType(), recursiveTypes);\n         }\n         return type.toString();\n     }\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java\nindex 2a01ebb4fcc..cd461811de5 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java\n@@ -15,6 +15,10 @@\n  */\n package org.openrewrite.java.tree;\n \n+import org.assertj.core.api.BooleanAssert;\n+import org.assertj.core.api.ObjectAssert;\n+import org.assertj.core.api.SoftAssertions;\n+import org.assertj.core.api.StringAssert;\n import org.junit.jupiter.api.Test;\n import org.openrewrite.ExecutionContext;\n import org.openrewrite.InMemoryExecutionContext;\n@@ -24,7 +28,7 @@\n import org.openrewrite.test.RewriteTest;\n import org.openrewrite.test.SourceSpec;\n \n-import java.util.EnumSet;\n+import java.util.*;\n import java.util.function.Consumer;\n \n import static java.util.Collections.emptyList;\n@@ -741,20 +745,27 @@ static <T extends Serializable> T method1() {\n     }\n \n     @Test\n-    void generatesValidToString() {\n+    void typeToString() {\n         rewriteRun(\n           java(\n             \"\"\"\n-              import java.io.Serializable;\n-              import java.util.Optional;\n+              import java.io.*;\n+              import java.util.*;\n+              \n+              @SuppressWarnings(\"all\")              \n+              public class Test<A extends B, B extends Number, C extends Comparable<? super C> & Serializable> {\n               \n-              class Test<A extends B, B extends Number, C extends Comparable<? super C> & Serializable> {\n+                  // Plain generics\n                   A a;\n                   B b;\n                   C c;\n+              \n+                  // Parameterized\n                   Optional<A> oa;\n                   Optional<B> ob;\n                   Optional<C> oc;\n+              \n+                  // Wildcards\n                   Optional<?> ow;\n                   Optional<? extends A> oea;\n                   Optional<? extends B> oeb;\n@@ -762,51 +773,221 @@ class Test<A extends B, B extends Number, C extends Comparable<? super C> & Seri\n                   Optional<? super A> osa;\n                   Optional<? super B> osb;\n                   Optional<? super C> osc;\n+              \n+                  // === Raw types ===\n+                  List rawList;\n+                  Map rawMap;\n+              \n+                  // === Recursive generic ===\n+                  static class Recursive<T extends Comparable<T>> {}\n+                  Recursive<Recursive<String>> rec;\n+              \n+                  // === Arrays ===\n+                  int[] intArray;\n+                  boolean[] boolArray;\n+                  String[] stringArray;\n+                  Map<?, String>[][] wildcardArray;\n               }\n               \"\"\",\n             spec -> spec.afterRecipe(cu -> new JavaIsoVisitor<>() {\n                 @Override\n-                public J.VariableDeclarations.NamedVariable visitVariable(J.VariableDeclarations.NamedVariable variable, Object o) {\n-                    JavaType variableType = variable.getVariableType().getType();\n-                    switch (variable.getSimpleName()) {\n-                        case \"a\" -> assertThat(variableType).satisfies(\n-                          hasToString(\"A\"),\n-                          hasGenericString(\"A extends B\"));\n-                        case \"b\" -> assertThat(variableType).satisfies(\n-                          hasToString(\"B\"),\n-                          hasGenericString(\"B extends java.lang.Number\"));\n-                        case \"c\" -> assertThat(variableType).satisfies(\n-                          hasToString(\"C\"),\n-                          hasGenericString(\"C extends java.lang.Comparable<? super C> & java.io.Serializable\"));\n-                        case \"oa\" -> assertThat(variableType).satisfies(hasToString(\"java.util.Optional<A>\"));\n-                        case \"ob\" -> assertThat(variableType).satisfies(hasToString(\"java.util.Optional<B>\"));\n-                        case \"oc\" -> assertThat(variableType).satisfies(hasToString(\"java.util.Optional<C>\"));\n-                        case \"ow\" -> assertThat(variableType).satisfies(hasToString(\"java.util.Optional<?>\"));\n-                        case \"oea\" -> assertThat(variableType).satisfies(hasToString(\"java.util.Optional<? extends A>\"));\n-                        case \"oeb\" -> assertThat(variableType).satisfies(hasToString(\"java.util.Optional<? extends B>\"));\n-                        case \"oec\" -> assertThat(variableType).satisfies(hasToString(\"java.util.Optional<? extends C>\"));\n-                        case \"osa\" -> assertThat(variableType).satisfies(hasToString(\"java.util.Optional<? super A>\"));\n-                        case \"osb\" -> assertThat(variableType).satisfies(hasToString(\"java.util.Optional<? super B>\"));\n-                        case \"osc\" -> assertThat(variableType).satisfies(hasToString(\"java.util.Optional<? super C>\"));\n+                public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, Object o) {\n+                    try (TypeUtilsAssertions assertions = new TypeUtilsAssertions(cu)) {\n+                        assertions.toGenericTypeString(\"A\").isEqualTo(\"A extends B\");\n+                        assertions.toGenericTypeString(\"B\").isEqualTo(\"B extends java.lang.Number\");\n+                        assertions.toGenericTypeString(\"C\").isEqualTo(\"C extends java.lang.Comparable<? super C> & java.io.Serializable\");\n+\n+                        assertions.toString(\"int\").isEqualTo(\"int\");\n+                        assertions.toString(\"long\").isEqualTo(\"long\");\n+                        assertions.toString(\"double\").isEqualTo(\"double\");\n+                        assertions.toString(\"boolean\").isEqualTo(\"boolean\");\n+\n+                        assertions.toString(\"A\").isEqualTo(\"A\");\n+                        assertions.toString(\"B\").isEqualTo(\"B\");\n+                        assertions.toString(\"C\").isEqualTo(\"C\");\n+\n+                        assertions.toString(\"Optional<A>\").isEqualTo(\"java.util.Optional<A>\");\n+                        assertions.toString(\"Optional<B>\").isEqualTo(\"java.util.Optional<B>\");\n+                        assertions.toString(\"Optional<C>\").isEqualTo(\"java.util.Optional<C>\");\n+\n+                        assertions.toString(\"Optional<?>\").isEqualTo(\"java.util.Optional<?>\");\n+                        assertions.toString(\"Optional<? extends A>\").isEqualTo(\"java.util.Optional<? extends A>\");\n+                        assertions.toString(\"Optional<? extends B>\").isEqualTo(\"java.util.Optional<? extends B>\");\n+                        assertions.toString(\"Optional<? extends C>\").isEqualTo(\"java.util.Optional<? extends C>\");\n+                        assertions.toString(\"Optional<? super A>\").isEqualTo(\"java.util.Optional<? super A>\");\n+                        assertions.toString(\"Optional<? super B>\").isEqualTo(\"java.util.Optional<? super B>\");\n+                        assertions.toString(\"Optional<? super C>\").isEqualTo(\"java.util.Optional<? super C>\");\n+\n+                        assertions.toString(\"List\").isEqualTo(\"java.util.List\");\n+                        assertions.toString(\"Map\").isEqualTo(\"java.util.Map\");\n+\n+                        assertions.toString(\"Recursive<Recursive<String>>\").isEqualTo(\"Test$Recursive<Test$Recursive<java.lang.String>>\");\n+\n+                        assertions.toString(\"int[]\").isEqualTo(\"int[]\");\n+                        assertions.toString(\"boolean[]\").isEqualTo(\"boolean[]\");\n+                        assertions.toString(\"String[]\").isEqualTo(\"java.lang.String[]\");\n+                        assertions.toString(\"Map<?, String>[][]\").isEqualTo(\"java.util.Map<?, java.lang.String>[][]\");\n                     }\n-                    return variable;\n+                    return cu;\n                 }\n+            }.visit(cu, new InMemoryExecutionContext()))\n+          )\n+        );\n+    }\n \n-                private Consumer<JavaType> hasToString(String value) {\n-                    return type -> {\n-                        assertThat(type).matches(TypeUtils::isWellFormedType);\n-                        assertThat(TypeUtils.toString(type)).isEqualTo(value);\n-                    };\n+    @Test\n+    @MinimumJava11\n+    void typeToString2() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import java.io.*;\n+              import java.util.*;\n+              \n+              @SuppressWarnings(\"all\")\n+              public class Test {\n+                  void test() {\n+                      var intersection = (Cloneable & Serializable) null;\n+                      try {} catch (NullPointerException | IllegalArgumentException exception) {}\n+                  }\n+              }\n+              \"\"\",\n+            spec -> spec.afterRecipe(cu -> new JavaIsoVisitor<>() {\n+                @Override\n+                public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, Object o) {\n+                    try (TypeUtilsAssertions assertions = new TypeUtilsAssertions(cu)) {\n+                        assertions.toString(\"intersection\").isEqualTo(\"java.lang.Cloneable & java.io.Serializable\");\n+                        assertions.toString(\"exception\").isEqualTo(\"java.lang.RuntimeException\");\n+                        assertions.toString(\"NullPointerException | IllegalArgumentException\").isEqualTo(\"java.lang.NullPointerException | java.lang.IllegalArgumentException\");\n+                    }\n+                    return cu;\n                 }\n+            }.visit(cu, new InMemoryExecutionContext()))\n+          )\n+        );\n+    }\n \n-                private Consumer<JavaType> hasGenericString(String value) {\n-                    return type -> {\n-                        assertThat(type).matches(TypeUtils::isWellFormedType);\n-                        assertThat(TypeUtils.toGenericTypeString((JavaType.GenericTypeVariable) type)).isEqualTo(value);\n-                    };\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5289\")\n+    void toStringRecursiveType() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import java.io.*;\n+              import java.util.*;\n+              \n+              abstract class Rec<T extends Rec<T>> {}\n+              \n+              abstract class One<TwoT extends Two<TwoT, OneT>, OneT extends One<TwoT, OneT>> {}\n+              abstract class Two<TwoT extends Two<TwoT, OneT>, OneT extends One<TwoT, OneT>> {}\n+              \n+              @SuppressWarnings(\"all\")\n+              public class Test {\n+                  void run(Rec<?> r, One<?, ?> m) {\n+                      Optional.of(r).get();\n+                      Optional.of(m).get();\n+              \n+                      Optional.of(r).ifPresent(sr -> {});\n+                      Optional.of(m).ifPresent(sm -> {});\n+                  }\n+              }\n+              \"\"\",\n+            spec -> spec.afterRecipe(cu -> new JavaIsoVisitor<>() {\n+                @Override\n+                public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, Object o) {\n+                    try (TypeUtilsAssertions assertions = new TypeUtilsAssertions(cu)) {\n+                        assertions.toString(\"r\").isEqualTo(\"Rec<?>\");\n+                        assertions.toString(\"Optional.of(r)\").isEqualTo(\"java.util.Optional<Rec<?>>\");\n+                        assertions.toString(\"Optional.of(r).get()\").isEqualTo(\"Rec<?>\");\n+                        assertions.toString(\"sr\").isEqualTo(\"Rec<?>\");\n+\n+                        assertions.toString(\"m\").isEqualTo(\"One<?, ?>\");\n+                        assertions.toString(\"Optional.of(m)\").isEqualTo(\"java.util.Optional<One<?, ?>>\");\n+                        assertions.toString(\"Optional.of(m).get()\").isEqualTo(\"One<?, ?>\");\n+                        assertions.toString(\"sm\").isEqualTo(\"One<?, ?>\");\n+                    }\n+                    return cu;\n                 }\n             }.visit(cu, new InMemoryExecutionContext()))\n           )\n         );\n     }\n+\n+    static class TypeUtilsAssertions implements AutoCloseable {\n+        SoftAssertions softly = new SoftAssertions();\n+        Map<String, List<JavaType>> types = new HashMap<>();\n+\n+        public TypeUtilsAssertions(J.CompilationUnit cu) {\n+            EnumSet.complementOf(EnumSet.of(JavaType.Primitive.String, JavaType.Primitive.None))\n+              .forEach(e -> types.put(e.getKeyword(), new ArrayList<>(Collections.singletonList(e))));\n+            new JavaIsoVisitor<Integer>() {\n+                @Override\n+                public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, Integer o) {\n+                    if (multiVariable.getTypeExpression() != null) {\n+                        String type = multiVariable.getTypeExpression().printTrimmed(getCursor());\n+                        types.computeIfAbsent(type, k -> new ArrayList<>(2)).add(multiVariable.getTypeExpression().getType());\n+                    }\n+                    for (J.VariableDeclarations.NamedVariable variable : multiVariable.getVariables()) {\n+                        types.computeIfAbsent(variable.getSimpleName(), k -> new ArrayList<>(2)).add(variable.getVariableType());\n+                    }\n+                    return super.visitVariableDeclarations(multiVariable, o);\n+                }\n+\n+                @Override\n+                public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Integer o) {\n+                    String type = method.printTrimmed(getCursor());\n+                    types.computeIfAbsent(type, k -> new ArrayList<>(2)).add(method.getMethodType());\n+                    return super.visitMethodInvocation(method, o);\n+                }\n+            }.visit(cu, 0);\n+        }\n+\n+        public ObjectAssert<JavaType> type(String type) {\n+            JavaType javaType = getFirst(type);\n+            return softly.assertThat(javaType);\n+        }\n+\n+        public BooleanAssert isAssignableTo(String to, String from) {\n+            JavaType toType = getFirst(to);\n+            JavaType fromType = getLast(from);\n+            return softly.assertThat(TypeUtils.isAssignableTo(toType, fromType))\n+              .describedAs(\"isAssignableTo(%s, %s)\", to, from);\n+        }\n+\n+        public BooleanAssert isOfType(String to, String from) {\n+            JavaType toType = getFirst(to);\n+            JavaType fromType = getLast(from);\n+            return softly.assertThat(TypeUtils.isOfType(toType, fromType))\n+              .describedAs(\"isOfType(%s, %s)\", to, from);\n+        }\n+\n+        public StringAssert toString(String type) {\n+            JavaType javaType = getFirst(type);\n+            return softly.assertThat(TypeUtils.toString(javaType))\n+              .describedAs(\"toString(%s)\", type);\n+        }\n+\n+        public StringAssert toGenericTypeString(String type) {\n+            JavaType javaType = getFirst(type);\n+            return softly.assertThat(TypeUtils.toGenericTypeString((JavaType.GenericTypeVariable) javaType))\n+              .describedAs(\"toGenericTypeString(%s)\", type);\n+        }\n+\n+        private JavaType getFirst(String type) {\n+            return Optional.ofNullable(types.get(type))\n+              .flatMap(list -> list.stream().findFirst())\n+              .orElseThrow(() -> new IllegalArgumentException(\"Type not found: \" + type));\n+        }\n+\n+        private JavaType getLast(String type) {\n+            return Optional.ofNullable(types.get(type))\n+              .map(list -> list.get(list.size() - 1))\n+              .orElseThrow(() -> new IllegalArgumentException(\"Type not found: \" + type));\n+        }\n+\n+        @Override\n+        public void close() {\n+            softly.assertAll();\n+        }\n+    }\n }\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateTest.java\nindex 16016d72174..3fff5094fe5 100755\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateTest.java\n@@ -129,7 +129,7 @@ void assignmentWithinIfPredicate() {\n               @Override\n               public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext ctx) {\n                   if ((assignment.getAssignment() instanceof J.Literal) &&\n-                      ((J.Literal) assignment.getAssignment()).getValue().equals(1)) {\n+                    ((J.Literal) assignment.getAssignment()).getValue().equals(1)) {\n                       return JavaTemplate.builder(\"value = 0\")\n                         .contextSensitive()\n                         .build()\n@@ -186,7 +186,7 @@ void trigger() {\n                   }\n               }\n               \"\"\",\n-                \"\"\"\n+            \"\"\"\n               import java.io.Serializable;\n               \n               abstract class Outer<T extends Serializable> {\n@@ -920,7 +920,7 @@ public class ArrayHelper {\n                   public static Object[] of(Object... objects){ return null;}\n               }\n               \"\"\",\n-                SourceSpec::skip\n+            SourceSpec::skip\n           ),\n           java(\n             \"\"\"\n@@ -1335,7 +1335,7 @@ class A {\n                   String testMethod(@NotNull final String test) {}\n               }\n               \"\"\",\n-                \"\"\"\n+            \"\"\"\n               import lombok.NonNull;\n               \n               class A {\n@@ -1406,7 +1406,7 @@ void replaceMethodArgumentsInIfStatementWithoutBraces() {\n               public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n                   J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);\n                   if (new MethodMatcher(\"Foo bar(..)\").matches(mi) &&\n-                      mi.getArguments().get(0) instanceof J.Binary) {\n+                    mi.getArguments().get(0) instanceof J.Binary) {\n                       return JavaTemplate.builder(\"\\\"Hello, {}\\\", \\\"World!\\\"\")\n                         .build()\n                         .apply(new Cursor(getCursor().getParent(), mi), mi.getCoordinates().replaceArguments());\n@@ -1478,4 +1478,50 @@ void bar(List<String> lst) {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5289\")\n+    void recursiveType() {\n+        rewriteRun(\n+          spec -> spec.expectedCyclesThatMakeChanges(1).cycles(1)\n+            .recipe(toRecipe(() -> new JavaVisitor<>() {\n+                @Override\n+                public J.Lambda visitLambda(J.Lambda lambda, ExecutionContext o) {\n+                    J.VariableDeclarations param = (J.VariableDeclarations) lambda.getParameters().getParameters().get(0);\n+                    J.VariableDeclarations.NamedVariable variable = param.getVariables().get(0);\n+\n+                    return JavaTemplate.builder(\"reference -> System.out.println(#{any()})\")\n+                      .contextSensitive()\n+                      .build()\n+                      .apply(getCursor(), lambda.getCoordinates().replace(), variable.getName());\n+                }\n+            })),\n+          java(\n+            \"\"\"\n+              import java.util.Optional;\n+              \n+              class BugTest {\n+                  void run(One<?, ?> firstBuild) {\n+                      Optional.of(firstBuild).ifPresent(reference -> {});\n+                  }\n+              \n+                  abstract static class One<TwoT extends Two<TwoT, OneT>, OneT extends One<TwoT, OneT>> {}\n+                  abstract static class Two<TwoT extends Two<TwoT, OneT>, OneT extends One<TwoT, OneT>> {}\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import java.util.Optional;\n+              \n+              class BugTest {\n+                  void run(One<?, ?> firstBuild) {\n+                      Optional.of(firstBuild).ifPresent(reference -> System.out.println(reference));\n+                  }\n+              \n+                  abstract static class One<TwoT extends Two<TwoT, OneT>, OneT extends One<TwoT, OneT>> {}\n+                  abstract static class Two<TwoT extends Two<TwoT, OneT>, OneT extends One<TwoT, OneT>> {}\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5321",
    "pr_id": 5321,
    "issue_id": 5298,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Groovy idempotency issue with parsing new array with fixed size\n## What version of OpenRewrite are you using?\n\nCurrent main = b504c17eb4055e959ac7d5edd5616c84664667f2\n\n## What is the smallest, simplest way to reproduce the problem?\n\nThe following test:\n```\n    @Test\n    void newArrayWithSize() {\n        rewriteRun(groovy(\n                \"\"\"\n        class A {\n            static void main(String[] argv) {\n                int[] addr = new int[4];\n            }\n        }\n        \"\"\"\n        ));\n    }\n```\n\nfails the idempotency check with:\n```diff\n- int[] addr = new int[4];\n+ int[] addr = 4}ew int[4];\n```\nwhich is clearly invalid.\n\n## Context\n\nThe same pattern has been found to cause problems in: https://github.com/spinnaker/spinnaker/blob/97cee4f3da768323984a4e1f404c96a9addf5306/clouddriver/clouddriver-azure/src/main/groovy/com/netflix/spinnaker/clouddriver/azure/common/AzureUtilities.groovy#L226\n",
    "issue_word_count": 104,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyVisitorTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyVisitorTest.java"
    ],
    "base_commit": "9d332bdace9f9f23c41ec1a5bbf6a9314bf1b8ff",
    "head_commit": "fa29a6fa253ebae36fcd84eb5b24aced2a124fce",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5321",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5321",
    "dockerfile": "",
    "pr_merged_at": "2025-04-28T14:51:08.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex 9090135e182..18447b85acb 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -681,6 +681,58 @@ private Statement labeled(org.codehaus.groovy.ast.stmt.Statement statement, Supp\n             return s;\n         }\n \n+        @Override\n+        public void visitArrayExpression(ArrayExpression expression) {\n+            Space prefix = whitespace();\n+            skip(\"new\");\n+            TypeTree typeTree = visitTypeTree(expression.getElementType());\n+            List<J.ArrayDimension> dimensions = buildNewArrayDimensions(expression);\n+            JContainer<Expression> initializer = buildNewArrayInitializer(expression);\n+            queue.add(new J.NewArray(randomId(), prefix, Markers.EMPTY, typeTree, dimensions, initializer, typeMapping.type(expression.getElementType())));\n+        }\n+\n+        private JContainer<Expression> buildNewArrayInitializer(ArrayExpression expression) {\n+            if (expression.getSizeExpression() != null) {\n+                return null;\n+            }\n+\n+            Space fmt = sourceBefore(\"{\");\n+\n+            List<JRightPadded<Expression>> expressions;\n+            if (expression.getExpressions().isEmpty()) {\n+                expressions = singletonList(padRight(new J.Empty(randomId(), sourceBefore(\"}\"), Markers.EMPTY), EMPTY));\n+            } else {\n+                expressions = convertAll(expression.getExpressions(), n -> sourceBefore(\",\"), n -> whitespace(), n -> {\n+                    if (n == expression.getExpression(expression.getExpressions().size() - 1) && source.charAt(cursor) == ',') {\n+                        cursor++;\n+                        return Markers.build(singletonList(new TrailingComma(randomId(), whitespace())));\n+                    }\n+                    return Markers.EMPTY;\n+                });\n+                skip(\"}\");\n+            }\n+\n+            return JContainer.build(fmt, expressions, Markers.EMPTY);\n+        }\n+\n+        private List<J.ArrayDimension> buildNewArrayDimensions(ArrayExpression expression) {\n+            List<J.ArrayDimension> dimensions = new ArrayList<>();\n+            for (int i = 0; expression.getSizeExpression() != null && i < expression.getSizeExpression().size(); i++) {\n+                dimensions.add(new J.ArrayDimension(randomId(), sourceBefore(\"[\"), Markers.EMPTY, padRight(visit(expression.getSizeExpression().get(i)), sourceBefore(\"]\"))));\n+            }\n+            while (true) {\n+                int beginBracket = indexOfNextNonWhitespace(cursor, source);\n+                if (source.charAt(beginBracket) != '[') {\n+                    break;\n+                }\n+\n+                int endBracket = indexOfNextNonWhitespace(beginBracket + 1, source);\n+                dimensions.add(new J.ArrayDimension(randomId(), format(source, cursor, beginBracket), Markers.EMPTY, padRight(new J.Empty(randomId(), format(source, beginBracket + 1, endBracket), Markers.EMPTY), EMPTY)));\n+                cursor = endBracket + 1;\n+            }\n+            return dimensions;\n+        }\n+\n         @Override\n         public void visitArgumentlistExpression(ArgumentListExpression expression) {\n             List<JRightPadded<Expression>> args = new ArrayList<>(expression.getExpressions().size());\n@@ -2024,6 +2076,10 @@ public void visitSpreadExpression(SpreadExpression spreadExpression) {\n         }\n \n         public TypeTree visitVariableExpressionType(VariableExpression expression) {\n+            if (!expression.isDynamicTyped() && expression.getOriginType().isArray()) {\n+                return visitTypeTree(expression.getOriginType());\n+            }\n+\n             JavaType type = typeMapping.type(staticType(((org.codehaus.groovy.ast.expr.Expression) expression)));\n             Space prefix = whitespace();\n             String typeName = \"\";\n@@ -2077,20 +2133,31 @@ public void visitWhileLoop(WhileStatement loop) {\n \n         private <J2 extends J> List<JRightPadded<J2>> convertAll(List<? extends ASTNode> nodes,\n                                                                  Function<ASTNode, Space> innerSuffix,\n-                                                                 Function<ASTNode, Space> suffix) {\n+                                                                 Function<ASTNode, Space> suffix,\n+                                                                 Function<ASTNode, Markers> markers) {\n             if (nodes.isEmpty()) {\n                 return emptyList();\n             }\n             List<JRightPadded<J2>> converted = new ArrayList<>(nodes.size());\n             for (int i = 0; i < nodes.size(); i++) {\n-                converted.add(convert(nodes.get(i), i == nodes.size() - 1 ? suffix : innerSuffix));\n+                converted.add(convert(nodes.get(i), i == nodes.size() - 1 ? suffix : innerSuffix, markers));\n             }\n             return converted;\n         }\n \n+        private <J2 extends J> List<JRightPadded<J2>> convertAll(List<? extends ASTNode> nodes,\n+                                                                 Function<ASTNode, Space> innerSuffix,\n+                                                                 Function<ASTNode, Space> suffix) {\n+            return convertAll(nodes, innerSuffix, suffix, n -> Markers.EMPTY);\n+        }\n+\n         private <J2 extends J> JRightPadded<J2> convert(ASTNode node, Function<ASTNode, Space> suffix) {\n+            return convert(node, suffix, n -> Markers.EMPTY);\n+        }\n+\n+        private <J2 extends J> JRightPadded<J2> convert(ASTNode node, Function<ASTNode, Space> suffix, Function<ASTNode, Markers> markers) {\n             J2 j = visit(node);\n-            return padRight(j, suffix.apply(node));\n+            return padRight(j, suffix.apply(node), markers.apply(node));\n         }\n \n         private List<JRightPadded<Statement>> convertStatements(List<? extends ASTNode> nodes) {\n@@ -2249,7 +2316,11 @@ public int compareTo(@NonNull LineColumn lc) {\n     }\n \n     private <T> JRightPadded<T> padRight(T tree, Space right) {\n-        return new JRightPadded<>(tree, right, Markers.EMPTY);\n+        return padRight(tree, right, Markers.EMPTY);\n+    }\n+\n+    private <T> JRightPadded<T> padRight(T tree, Space right, Markers markers) {\n+        return new JRightPadded<>(tree, right, markers);\n     }\n \n     private <T> JLeftPadded<T> padLeft(Space left, T tree) {\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyVisitorTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyVisitorTest.java\nindex fd95f09cf42..85612db3ac3 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyVisitorTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyVisitorTest.java\n@@ -54,7 +54,86 @@ public J visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n           )\n         );\n     }\n+  \n+    @Test\n+    void newArrayWithSize() {\n+        rewriteRun(groovy(\n+          \"\"\"\n+          class A {\n+              static void main(String[] argv) {\n+                  int[][][] addr = new int[4+3][3][5];\n+              }\n+          }\n+          \"\"\"\n+        ));\n+    }\n+\n+    @Test\n+    void newArrayWithEmptyInitializer() {\n+        rewriteRun(groovy(\n+          \"\"\"\n+          class A {\n+              static void main(String[] argv) {int[] addr = new int[]{}}\n+          }\n+          \"\"\"\n+        ));\n+    }\n+\n+    @Test\n+    void newArrayOfListOfStrings() {\n+        rewriteRun(groovy(\n+          \"\"\"\n+          class A {\n+              static void main(String[] argv) {\n+                  List<String>[] l = new List<String>[]{ new ArrayList<String>() };\n+              }\n+          }\n+          \"\"\"\n+        ));\n+    }\n+\n+    @Test\n+    void newArrayWithInitializer() {\n+        rewriteRun(groovy(\n+          \"\"\"\n+          class A {\n+              static void main(String[] argv) {\n+                  int[] addr = new int[] {\n+                      123,\n+                      new Integer(456).intValue()\n+                  };\n+              }\n+          }\n+          \"\"\"\n+        ));\n+    }\n \n+    @Test\n+    void dynamicallyTypedNewArrayWithSize() {\n+        rewriteRun(groovy(\n+          \"\"\"\n+          class A {\n+              static void main(String[] argv) {\n+                  def addr = new int[4+3][3][5];\n+              }\n+          }\n+          \"\"\"\n+        ));\n+    }\n+\n+    @Test\n+    void returnNewArray() {\n+        rewriteRun(groovy(\n+          \"\"\"\n+            class TestMe{\n+              String[] getArgs() {\n+                return new String[0]\n+              }\n+            }\n+            \"\"\"\n+        ));\n+    }\n+  \n     @Test\n     void spreadOperator() {\n         rewriteRun(groovy(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5317",
    "pr_id": 5317,
    "issue_id": 5297,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Groovy idempotency issue with parsing code with spread operator\n## What version of OpenRewrite are you using?\n\nCurrent main = b504c17eb4055e959ac7d5edd5616c84664667f2\n\n## What is the smallest, simplest way to reproduce the problem?\n```\n    @Test\n    void spreadOperator() {\n        rewriteRun(groovy(\n                \"\"\"\n        class A {\n            static void main(String[] argv) {\n                def l = [1,2,3]\n                System.out.printf(\"%d, %d, %d\", *l);\n            }\n        }\n        \"\"\"\n        ));\n    }\n```\nfails with idempotency issue, basically removing the asterisk `*`.\n\n## Context\n\nThis pattern is used in a lot of places in Spinnaker code base, e.g. https://github.com/spinnaker/spinnaker/blob/97cee4f3da768323984a4e1f404c96a9addf5306/clouddriver/clouddriver-aws/src/test/groovy/com/netflix/spinnaker/clouddriver/aws/deploy/asg/asgbuilders/AsgWithLaunchConfigurationBuilderSpec.groovy#L594C9-L594C47",
    "issue_word_count": 102,
    "test_files_count": 1,
    "non_test_files_count": 6,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyVisitor.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/GLeftPadded.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/GSpace.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyVisitorTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyVisitorTest.java"
    ],
    "base_commit": "9569cfb6b7c88d015ba1369fa5639bcf23db4dc0",
    "head_commit": "bc3625e24b37b49e1aace1804e483179f9e0be02",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5317",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5317",
    "dockerfile": "",
    "pr_merged_at": "2025-04-22T18:26:28.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex 47d988fb1f5..ea3f55aa300 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -2016,6 +2016,13 @@ public void visitPrefixExpression(PrefixExpression unary) {\n                     null));\n         }\n \n+        @Override\n+        public void visitSpreadExpression(SpreadExpression spreadExpression) {\n+            Space fmt = whitespace();\n+            skip(\"*\");\n+            queue.add(new G.Unary(randomId(), fmt, Markers.EMPTY, JLeftPadded.build(G.Unary.Type.Spread), visit(spreadExpression.getExpression()), null));\n+        }\n+\n         public TypeTree visitVariableExpressionType(VariableExpression expression) {\n             JavaType type = typeMapping.type(staticType(((org.codehaus.groovy.ast.expr.Expression) expression)));\n             Space prefix = whitespace();\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\nindex 1f484efa663..065f4a7e02b 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\n@@ -36,6 +36,7 @@\n import java.util.function.UnaryOperator;\n \n import static org.openrewrite.groovy.internal.Delimiter.DOUBLE_QUOTE_STRING;\n+import static org.openrewrite.groovy.tree.G.Unary.Type.Spread;\n \n public class GroovyPrinter<P> extends GroovyVisitor<PrintOutputCapture<P>> {\n     private final GroovyJavaPrinter delegate = new GroovyJavaPrinter();\n@@ -132,6 +133,21 @@ public J visitMapLiteral(G.MapLiteral mapLiteral, PrintOutputCapture<P> p) {\n         return mapLiteral;\n     }\n \n+    @Override\n+    public J visitUnary(G.Unary unary, PrintOutputCapture<P> p) {\n+        beforeSyntax(unary, Space.Location.UNARY_PREFIX, p);\n+        switch (unary.getOperator()) {\n+            case Spread:\n+                p.append(\"*\");\n+                visit(unary.getExpression(), p);\n+                break;\n+            default:\n+                throw new UnsupportedOperationException(\"Unknown unary operator.\");\n+        }\n+        afterSyntax(unary, p);\n+        return unary;\n+    }\n+\n     @Override\n     public J visitBinary(G.Binary binary, PrintOutputCapture<P> p) {\n         String keyword = \"\";\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyVisitor.java\nindex 4ddd4d26f7f..2edfd8aec7a 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyVisitor.java\n@@ -120,6 +120,22 @@ public J visitMapLiteral(G.MapLiteral mapLiteral, P p) {\n         return m;\n     }\n \n+    public J visitUnary(G.Unary unary, P p) {\n+        G.Unary u = unary;\n+        u = u.withPrefix(visitSpace(u.getPrefix(), GSpace.Location.UNARY_PREFIX, p));\n+        u = u.withMarkers(visitMarkers(u.getMarkers(), p));\n+        Expression temp = (Expression) visitExpression(u, p);\n+        if (!(temp instanceof G.Unary)) {\n+            return temp;\n+        } else {\n+            u = (G.Unary) temp;\n+        }\n+        u = u.getPadding().withOperator(visitLeftPadded(u.getPadding().getOperator(), GLeftPadded.Location.UNARY_OPERATOR, p));\n+        u = u.withExpression(visitAndCast(u.getExpression(), p));\n+        u = u.withType(visitType(u.getType(), p));\n+        return u;\n+    }\n+\n     public J visitBinary(G.Binary binary, P p) {\n         G.Binary b = binary;\n         b = b.withPrefix(visitSpace(b.getPrefix(), GSpace.Location.BINARY_PREFIX, p));\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java\nindex 5143bc823fc..3c3dfe605c2 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java\n@@ -931,4 +931,92 @@ public Range withInclusive(JLeftPadded<Boolean> inclusive) {\n             }\n         }\n     }\n+\n+    @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n+    @EqualsAndHashCode(callSuper = false, onlyExplicitlyIncluded = true)\n+    @RequiredArgsConstructor\n+    @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+    @Data\n+    final class Unary implements G, Expression, TypedTree {\n+\n+        @Nullable\n+        @NonFinal\n+        transient WeakReference<Padding> padding;\n+\n+        @With\n+        @EqualsAndHashCode.Include\n+        @Getter\n+        UUID id;\n+\n+        @With\n+        @Getter\n+        Space prefix;\n+\n+        @With\n+        @Getter\n+        Markers markers;\n+\n+        JLeftPadded<G.Unary.Type> operator;\n+\n+        public G.Unary.Type getOperator() {\n+            return operator.getElement();\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        public G.Unary withOperator(G.Unary.Type operator) {\n+            return getPadding().withOperator(this.operator.withElement(operator));\n+        }\n+\n+        @With\n+        @Getter\n+        Expression expression;\n+\n+        @With\n+        @Nullable\n+        @Getter\n+        JavaType type;\n+\n+        @Override\n+        public <P> J acceptGroovy(GroovyVisitor<P> v, P p) {\n+            return v.visitUnary(this, p);\n+        }\n+\n+        @Transient\n+        @Override\n+        public CoordinateBuilder.Expression getCoordinates() {\n+            return new CoordinateBuilder.Expression(this);\n+        }\n+\n+        public enum Type {\n+            Spread\n+        }\n+\n+        public Padding getPadding() {\n+            Padding p;\n+            if (this.padding == null) {\n+                p = new Padding(this);\n+                this.padding = new WeakReference<>(p);\n+            } else {\n+                p = this.padding.get();\n+                if (p == null || p.t != this) {\n+                    p = new Padding(this);\n+                    this.padding = new WeakReference<>(p);\n+                }\n+            }\n+            return p;\n+        }\n+\n+        @RequiredArgsConstructor\n+        public static class Padding {\n+            private final G.Unary t;\n+\n+            public JLeftPadded<G.Unary.Type> getOperator() {\n+                return t.operator;\n+            }\n+\n+            public G.Unary withOperator(JLeftPadded<G.Unary.Type> operator) {\n+                return t.operator == operator ? t : new G.Unary(t.id, t.prefix, t.markers, operator, t.expression, t.type);\n+            }\n+        }\n+    }\n }\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/GLeftPadded.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/GLeftPadded.java\nindex 473667dd9a0..0510dc6c986 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/GLeftPadded.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/GLeftPadded.java\n@@ -17,6 +17,7 @@\n \n public class GLeftPadded {\n     public enum Location {\n+        UNARY_OPERATOR(GSpace.Location.UNARY_OPERATOR),\n         BINARY_OPERATOR(GSpace.Location.BINARY_OPERATOR),\n         RANGE_INCLUSION(GSpace.Location.RANGE_INCLUSION);\n \n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/GSpace.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/GSpace.java\nindex 21728b63ab6..e99e37fda8a 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/GSpace.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/GSpace.java\n@@ -17,6 +17,8 @@\n \n public class GSpace {\n     public enum Location {\n+        UNARY_PREFIX,\n+        UNARY_OPERATOR,\n         BINARY_PREFIX,\n         BINARY_OPERATOR,\n         BINARY_SUFFIX,\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyVisitorTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyVisitorTest.java\nindex 511113f6350..61bb4c2cab7 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyVisitorTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/GroovyVisitorTest.java\n@@ -25,6 +25,20 @@\n \n class GroovyVisitorTest implements RewriteTest {\n \n+    @Test\n+    void spreadOperator() {\n+        rewriteRun(groovy(\n+          \"\"\"\n+            class A {\n+                static void main(String[] argv) {\n+                    def l = [1,2,3]\n+                    System.out.printf(\"%d, %d, %d\", *l);\n+                }\n+            }\n+            \"\"\"\n+        ));\n+    }\n+\n     @DocumentExample\n     @Test\n     void autoFormatIncludesOmitParentheses() {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5269",
    "pr_id": 5269,
    "issue_id": 1,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Proper sorting of imports based on project configuration\n(run on spring-cloud-gateway, RetryGatewayFilterFactoryIntegrationTests)\r\n\r\n![image](https://user-images.githubusercontent.com/1697736/84090885-880f4480-a9b8-11ea-987f-7e3a0b44fd62.png)\r\n",
    "issue_word_count": 28,
    "test_files_count": 14,
    "non_test_files_count": 11,
    "pr_changed_files": [
      "rewrite-core/src/main/resources/META-INF/rewrite/jspecify.yml",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/ExecutionContextParameterNameTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/FindRecipesTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/MissingOptionExampleTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/RecipeEqualsAndHashCodeCallSuperTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SelectRecipeExamplesTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SetDefaultEstimatedEffortPerOccurrenceTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SourceSpecTextBlockIndentationTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/BlankLinesAroundFieldsWithAnnotations.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/ExecutionContextParameterName.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/FindRecipes.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/MissingOptionExample.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/NoMutableStaticFieldsInRecipes.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/RecipeEqualsAndHashCodeCallSuper.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/RewriteTestClassesShouldNotBePublic.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/SelectRecipeExamples.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/SetDefaultEstimatedEffortPerOccurrence.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/SourceSpecTextBlockIndentation.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/UseTreeRandomId.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/package-info.java",
      "rewrite-java/src/test/java/org/openrewrite/java/recipes/BlankLinesAroundFieldsWithAnnotationsTest.java",
      "rewrite-java/src/test/java/org/openrewrite/java/recipes/NoMutableStaticFieldsInRecipesTest.java",
      "rewrite-java/src/test/java/org/openrewrite/java/recipes/RewriteTestClassesShouldNotBePublicTest.java",
      "rewrite-java/src/test/java/org/openrewrite/java/recipes/UseTreeRandomIdTest.java",
      "rewrite-test/src/test/java/org/openrewrite/test/RecipePrinterTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/ExecutionContextParameterNameTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/FindRecipesTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/MissingOptionExampleTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/RecipeEqualsAndHashCodeCallSuperTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SelectRecipeExamplesTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SetDefaultEstimatedEffortPerOccurrenceTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SourceSpecTextBlockIndentationTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/RewriteTestClassesShouldNotBePublic.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/SetDefaultEstimatedEffortPerOccurrence.java",
      "rewrite-java/src/test/java/org/openrewrite/java/recipes/BlankLinesAroundFieldsWithAnnotationsTest.java",
      "rewrite-java/src/test/java/org/openrewrite/java/recipes/NoMutableStaticFieldsInRecipesTest.java",
      "rewrite-java/src/test/java/org/openrewrite/java/recipes/RewriteTestClassesShouldNotBePublicTest.java",
      "rewrite-java/src/test/java/org/openrewrite/java/recipes/UseTreeRandomIdTest.java",
      "rewrite-test/src/test/java/org/openrewrite/test/RecipePrinterTest.java"
    ],
    "base_commit": "8c6c538321773bb7a4d745182da94d398eb8cb88",
    "head_commit": "016f83821b824f2b382f332c9dd6a8e4754db779",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5269",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5269",
    "dockerfile": "",
    "pr_merged_at": "2025-04-09T09:57:32.000Z",
    "patch": "diff --git a/rewrite-core/src/main/resources/META-INF/rewrite/jspecify.yml b/rewrite-core/src/main/resources/META-INF/rewrite/jspecify.yml\ndeleted file mode 100644\nindex 35daf1538b8..00000000000\n--- a/rewrite-core/src/main/resources/META-INF/rewrite/jspecify.yml\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-#\n-# Copyright 2024 the original author or authors.\n-# <p>\n-# Licensed under the Apache License, Version 2.0 (the \"License\");\n-# you may not use this file except in compliance with the License.\n-# You may obtain a copy of the License at\n-# <p>\n-# https://www.apache.org/licenses/LICENSE-2.0\n-# <p>\n-# Unless required by applicable law or agreed to in writing, software\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# See the License for the specific language governing permissions and\n-# limitations under the License.\n-#\n-\n-type: specs.openrewrite.org/v1beta/recipe\n-name: org.openrewrite.java.jspecify.MigrateFromOpenRewriteAnnotations\n-displayName: Migrate from OpenRewrite annotations to JSpecify\n-description: Migrate from OpenRewrite's JSR-305 meta-annotations to JSpecify.\n-recipeList:\n-  - org.openrewrite.staticanalysis.java.MoveFieldAnnotationToType:\n-      annotationType: org.openrewrite.internal.lang.*\n-  - org.openrewrite.java.ChangeType:\n-      oldFullyQualifiedTypeName: org.openrewrite.internal.lang.Nullable\n-      newFullyQualifiedTypeName: org.jspecify.annotations.Nullable\n-      ignoreDefinition: true\n-  - org.openrewrite.java.ChangeType:\n-      oldFullyQualifiedTypeName: org.openrewrite.internal.lang.NonNullApi\n-      newFullyQualifiedTypeName: org.jspecify.annotations.NullMarked\n-      ignoreDefinition: true\n-  - org.openrewrite.java.ChangeType:\n-      oldFullyQualifiedTypeName: org.openrewrite.internal.lang.NonNull\n-      newFullyQualifiedTypeName: org.jspecify.annotations.NonNull\n-      ignoreDefinition: true\n-  - org.openrewrite.java.dependencies.AddDependency:\n-      groupId: org.jspecify\n-      artifactId: jspecify\n-      version: latest.release\n-      onlyIfUsing: org.openrewrite.internal.lang.*Null*\n-      configuration: implementation\n-      scope: compile\n-      acceptTransitive: true\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/BlankLinesAroundFieldsWithAnnotations.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/BlankLinesAroundFieldsWithAnnotations.java\ndeleted file mode 100644\nindex 24a9c937e43..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/BlankLinesAroundFieldsWithAnnotations.java\n+++ /dev/null\n@@ -1,81 +0,0 @@\n-/*\n- * Copyright 2024 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.Recipe;\n-import org.openrewrite.TreeVisitor;\n-import org.openrewrite.internal.ListUtils;\n-import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.format.BlankLinesVisitor;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.Statement;\n-\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-public class BlankLinesAroundFieldsWithAnnotations extends Recipe {\n-\n-    @Override\n-    public String getDisplayName() {\n-        return \"Add a blank line around fields with annotations\";\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return \"Fields with annotations should have a blank line \" +\n-               \"before them to clearly separate them from the field above. \" +\n-               \"If another field follows, it should also have a blank line after \" +\n-               \"so that the field with the annotation has space on either side of it, \" +\n-               \"visually distinguishing it from its neighbors.\";\n-    }\n-\n-    @Override\n-    public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return new JavaIsoVisitor<ExecutionContext>() {\n-            @Override\n-            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {\n-                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);\n-                if (classDecl.getBody() != null) {\n-                    List<Statement> statements = requireNonNull(cd).getBody().getStatements();\n-                    AtomicBoolean precedingFieldHadAnnotation = new AtomicBoolean();\n-                    cd = cd.withBody(cd.getBody().withStatements(ListUtils.map(statements, (i, s) -> {\n-                        if (precedingFieldHadAnnotation.get()) {\n-                            precedingFieldHadAnnotation.set(false);\n-                            if (s instanceof J.VariableDeclarations) {\n-                                s = s.withPrefix(s.getPrefix().withWhitespace(BlankLinesVisitor.minimumLines(s.getPrefix().getWhitespace(), 1)));\n-                            }\n-                        }\n-                        if (s instanceof J.VariableDeclarations) {\n-                            J.VariableDeclarations mv = (J.VariableDeclarations) s;\n-                            if (!mv.getLeadingAnnotations().isEmpty()) {\n-                                if (i > 0 && statements.get(i - 1) instanceof J.VariableDeclarations) {\n-                                    mv = mv.withPrefix(mv.getPrefix().withWhitespace(BlankLinesVisitor.minimumLines(mv.getPrefix().getWhitespace(), 1)));\n-                                }\n-                                precedingFieldHadAnnotation.set(true);\n-                            }\n-                            return mv;\n-                        }\n-                        return s;\n-                    })));\n-                }\n-                return cd;\n-            }\n-        };\n-    }\n-}\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/ExecutionContextParameterName.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/ExecutionContextParameterName.java\ndeleted file mode 100644\nindex bd04328ca55..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/ExecutionContextParameterName.java\n+++ /dev/null\n@@ -1,64 +0,0 @@\n-/*\n- * Copyright 2021 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.Preconditions;\n-import org.openrewrite.Recipe;\n-import org.openrewrite.TreeVisitor;\n-import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.RenameVariable;\n-import org.openrewrite.java.search.UsesType;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.Statement;\n-import org.openrewrite.java.tree.TypeUtils;\n-\n-public class ExecutionContextParameterName extends Recipe {\n-\n-    @Override\n-    public String getDisplayName() {\n-        return \"Use a standard name for `ExecutionContext`\";\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return \"Visitors that are parameterized with `ExecutionContext` should use the parameter name `ctx`.\";\n-    }\n-\n-    @Override\n-    public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(Preconditions.or(\n-                        new UsesType<>(\"org.openrewrite.Recipe\", false),\n-                        new UsesType<>(\"org.openrewrite.Visitor\", false)),\n-                new JavaIsoVisitor<ExecutionContext>() {\n-                    @Override\n-                    public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {\n-                        J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);\n-                        for (Statement parameter : m.getParameters()) {\n-                            if (parameter instanceof J.VariableDeclarations) {\n-                                J.VariableDeclarations param = (J.VariableDeclarations) parameter;\n-                                if (TypeUtils.isOfClassType(param.getType(),\n-                                        \"org.openrewrite.ExecutionContext\")) {\n-                                    m = (J.MethodDeclaration) new RenameVariable<ExecutionContext>(param.getVariables().get(0), \"ctx\")\n-                                            .visitNonNull(m, ctx);\n-                                }\n-                            }\n-                        }\n-                        return m;\n-                    }\n-                });\n-    }\n-}\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/FindRecipes.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/FindRecipes.java\ndeleted file mode 100644\nindex d460a4ffa7a..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/FindRecipes.java\n+++ /dev/null\n@@ -1,261 +0,0 @@\n-/*\n- * Copyright 2022 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import com.fasterxml.jackson.databind.node.ArrayNode;\n-import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-import com.fasterxml.jackson.databind.node.ValueNode;\n-import org.jspecify.annotations.NonNull;\n-import org.jspecify.annotations.Nullable;\n-import org.openrewrite.*;\n-import org.openrewrite.java.AnnotationMatcher;\n-import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.MethodMatcher;\n-import org.openrewrite.java.search.UsesType;\n-import org.openrewrite.java.tree.Expression;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.TypeUtils;\n-import org.openrewrite.marker.SearchResult;\n-import org.openrewrite.table.RewriteRecipeSource;\n-import org.openrewrite.yaml.YamlIsoVisitor;\n-import org.openrewrite.yaml.search.FindProperty;\n-import org.openrewrite.yaml.tree.Yaml;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Set;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-public class FindRecipes extends Recipe {\n-    RewriteRecipeSource recipeSource = new RewriteRecipeSource(this);\n-\n-    @Override\n-    public String getDisplayName() {\n-        return \"Find OpenRewrite recipes\";\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return \"This recipe finds all OpenRewrite recipes, primarily to produce a data table that is being used \" +\n-               \"to experiment with fine-tuning a large language model to produce more recipes.\";\n-    }\n-\n-    @Override\n-    public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        TreeVisitor<?, ExecutionContext> findImperativeRecipes = findImperativeRecipes();\n-        TreeVisitor<?, ExecutionContext> findRefasterRecipes = findRefasterRecipes();\n-        TreeVisitor<?, ExecutionContext> findYamlRecipes = findYamlRecipes();\n-        return new TreeVisitor<Tree, ExecutionContext>() {\n-            @Override\n-            public @Nullable Tree preVisit(@NonNull Tree tree, ExecutionContext ctx) {\n-                stopAfterPreVisit();\n-                tree = findImperativeRecipes.visit(tree, ctx);\n-                tree = findRefasterRecipes.visit(tree, ctx);\n-                tree = findYamlRecipes.visit(tree, ctx);\n-                return tree;\n-            }\n-        };\n-    }\n-\n-    private TreeVisitor<?, ExecutionContext> findRefasterRecipes() {\n-        String recipeDescriptor = \"org.openrewrite.java.template.RecipeDescriptor\";\n-        AnnotationMatcher annotationMatcher = new AnnotationMatcher(\"@\" + recipeDescriptor);\n-        return Preconditions.check(new UsesType<>(recipeDescriptor, false), new JavaIsoVisitor<ExecutionContext>() {\n-            @Override\n-            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {\n-                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);\n-                for (J.Annotation annotation : cd.getLeadingAnnotations()) {\n-                    if (annotationMatcher.matches(annotation)) {\n-                        String name = null;\n-                        String description = null;\n-                        for (Expression argument : annotation.getArguments()) {\n-                            if (argument instanceof J.Assignment) {\n-                                J.Assignment assignment = (J.Assignment) argument;\n-                                if (assignment.getVariable() instanceof J.Identifier) {\n-                                    String simpleName = ((J.Identifier) assignment.getVariable()).getSimpleName();\n-                                    if (\"name\".equals(simpleName)) {\n-                                        if (assignment.getAssignment() instanceof J.Literal) {\n-                                            name = (String) ((J.Literal) assignment.getAssignment()).getValue();\n-                                        }\n-                                    } else if (\"description\".equals(simpleName)) {\n-                                        if (assignment.getAssignment() instanceof J.Literal) {\n-                                            description = (String) ((J.Literal) assignment.getAssignment()).getValue();\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        if (name != null && description != null) {\n-                            recipeSource.insertRow(ctx, new RewriteRecipeSource.Row(\n-                                    name,\n-                                    description,\n-                                    RewriteRecipeSource.RecipeType.Refaster,\n-                                    cd.printTrimmed(getCursor()),\n-                                    \"[]\"\n-                            ));\n-                            return SearchResult.found(cd);\n-                        }\n-                    }\n-                }\n-                return cd;\n-            }\n-        });\n-    }\n-\n-    private TreeVisitor<?, ExecutionContext> findImperativeRecipes() {\n-        MethodMatcher getDisplayName = new MethodMatcher(\"org.openrewrite.Recipe getDisplayName()\", true);\n-        MethodMatcher getDescription = new MethodMatcher(\"org.openrewrite.Recipe getDescription()\", true);\n-        AnnotationMatcher optionAnnotation = new AnnotationMatcher(\"@org.openrewrite.Option\");\n-        return Preconditions.check(new UsesType<>(\"org.openrewrite.Recipe\", false), new JavaIsoVisitor<ExecutionContext>() {\n-            final List<J.VariableDeclarations> options = new ArrayList<>();\n-\n-            @Override\n-            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {\n-                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);\n-                if (TypeUtils.isAssignableTo(\"org.openrewrite.Recipe\", classDecl.getType())) {\n-                    recipeSource.insertRow(ctx, new RewriteRecipeSource.Row(\n-                            getCursor().getMessage(\"displayName\"),\n-                            getCursor().getMessage(\"description\"),\n-                            RewriteRecipeSource.RecipeType.Java,\n-                            getCursor().firstEnclosingOrThrow(J.CompilationUnit.class).printAllTrimmed(),\n-                            convertOptionsToJSON(options)\n-                    ));\n-                    return classDecl.withName(SearchResult.found(classDecl.getName()));\n-                }\n-                return cd;\n-            }\n-\n-            @Override\n-            public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {\n-                if (multiVariable.getLeadingAnnotations().stream().anyMatch(optionAnnotation::matches)) {\n-                    options.add(multiVariable);\n-                }\n-                return super.visitVariableDeclarations(multiVariable, ctx);\n-            }\n-\n-            @Override\n-            public J.Return visitReturn(J.Return aReturn, ExecutionContext ctx) {\n-                J j = getCursor().dropParentUntil(it -> it instanceof J.MethodDeclaration || it instanceof J.ClassDeclaration).getValue();\n-                if (j instanceof J.MethodDeclaration) {\n-                    J.MethodDeclaration method = (J.MethodDeclaration) j;\n-                    if (getDisplayName.matches(method.getMethodType()) && aReturn.getExpression() instanceof J.Literal) {\n-                        getCursor().putMessageOnFirstEnclosing(J.ClassDeclaration.class, \"displayName\",\n-                                requireNonNull(((J.Literal) aReturn.getExpression()).getValue()));\n-                    }\n-                    if (getDescription.matches(method.getMethodType()) && aReturn.getExpression() instanceof J.Literal) {\n-                        getCursor().putMessageOnFirstEnclosing(J.ClassDeclaration.class, \"description\",\n-                                requireNonNull(((J.Literal) aReturn.getExpression()).getValue()));\n-                    }\n-                }\n-\n-                return super.visitReturn(aReturn, ctx);\n-            }\n-\n-            private String convertOptionsToJSON(List<J.VariableDeclarations> options) {\n-                ArrayNode optionsArray = JsonNodeFactory.instance.arrayNode();\n-                for (J.VariableDeclarations option : options) {\n-                    ObjectNode optionNode = optionsArray.addObject();\n-                    optionNode.put(\"name\", option.getVariables().get(0).getSimpleName());\n-                    mapOptionAnnotation(option.getLeadingAnnotations(), optionNode);\n-                }\n-                return optionsArray.toString();\n-            }\n-\n-            private void mapOptionAnnotation(List<J.Annotation> leadingAnnotations, ObjectNode optionNode) {\n-                for (J.Annotation annotation : leadingAnnotations) {\n-                    if (optionAnnotation.matches(annotation) && annotation.getArguments() != null) {\n-                        for (Expression argument : annotation.getArguments()) {\n-                            if (argument instanceof J.Assignment) {\n-                                J.Assignment assignment = (J.Assignment) argument;\n-                                if (assignment.getVariable() instanceof J.Identifier) {\n-                                    J.Identifier identifier = (J.Identifier) assignment.getVariable();\n-                                    if (assignment.getAssignment() instanceof J.Literal) {\n-                                        optionNode.set(identifier.getSimpleName(), mapValue(((J.Literal) assignment.getAssignment()).getValue()));\n-                                    } else if (assignment.getAssignment() instanceof J.NewArray) {\n-                                        J.NewArray newArray = (J.NewArray) assignment.getAssignment();\n-                                        if (newArray.getInitializer() != null) {\n-                                            ArrayNode valuesArray = optionNode.putArray(identifier.getSimpleName());\n-                                            for (Expression expression : newArray.getInitializer()) {\n-                                                if (expression instanceof J.Literal) {\n-                                                    valuesArray.add(mapValue(((J.Literal) expression).getValue()));\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            private ValueNode mapValue(@Nullable Object value) {\n-                if (value instanceof String) {\n-                    return JsonNodeFactory.instance.textNode((String) value);\n-                } else if (value instanceof Boolean) {\n-                    return JsonNodeFactory.instance.booleanNode((Boolean) value);\n-                } else if (value instanceof Integer) {\n-                    return JsonNodeFactory.instance.numberNode((Integer) value);\n-                } else if (value == null) {\n-                    return JsonNodeFactory.instance.nullNode();\n-                }\n-                throw new IllegalArgumentException(String.valueOf(value));\n-            }\n-        });\n-    }\n-\n-    private TreeVisitor<?, ExecutionContext> findYamlRecipes() {\n-        return Preconditions.check(\n-                new FindProperty(\"type\", false, \"specs.openrewrite.org/v1beta/recipe\"),\n-                new YamlIsoVisitor<ExecutionContext>() {\n-                    @Override\n-                    public Yaml.Document visitDocument(Yaml.Document document, ExecutionContext ctx) {\n-                        Yaml.Document doc = super.visitDocument(document, ctx);\n-\n-                        if (\"specs.openrewrite.org/v1beta/recipe\".equals(extractValue(doc, \"type\"))) {\n-                            String displayName = extractValue(doc, \"displayName\");\n-                            String description = extractValue(doc, \"description\");\n-                            if (displayName != null && description != null) {\n-                                recipeSource.insertRow(ctx, new RewriteRecipeSource.Row(\n-                                        displayName,\n-                                        description,\n-                                        RewriteRecipeSource.RecipeType.Yaml,\n-                                        doc.withPrefix(\"\").printTrimmed(getCursor()),\n-                                        \"[]\"\n-                                ));\n-                                return SearchResult.found(doc);\n-                            }\n-                        }\n-                        return doc;\n-                    }\n-\n-                    private @Nullable String extractValue(Yaml yaml, String key) {\n-                        Set<Yaml.Block> blocks = FindProperty.find(yaml, key, false);\n-                        if (!blocks.isEmpty()) {\n-                            Yaml.Block first = blocks.iterator().next();\n-                            if (first instanceof Yaml.Scalar) {\n-                                return ((Yaml.Scalar) first).getValue();\n-                            }\n-                        }\n-                        return null;\n-                    }\n-                }\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/MissingOptionExample.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/MissingOptionExample.java\ndeleted file mode 100644\nindex 100279d44dc..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/MissingOptionExample.java\n+++ /dev/null\n@@ -1,88 +0,0 @@\n-/*\n- * Copyright 2024 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.openrewrite.*;\n-import org.openrewrite.java.AddOrUpdateAnnotationAttribute;\n-import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.search.UsesType;\n-import org.openrewrite.java.tree.Expression;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.JavaType;\n-import org.openrewrite.java.tree.TypeUtils;\n-\n-public class MissingOptionExample extends Recipe {\n-\n-    private static final String ORG_OPENREWRITE_OPTION = \"org.openrewrite.Option\";\n-\n-    @Override\n-    public String getDisplayName() {\n-        return \"Find missing `@Option` `example` values\";\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return \"Find `@Option` annotations that are missing `example` values for documentation.\";\n-    }\n-\n-    @Override\n-    public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(new UsesType<>(ORG_OPENREWRITE_OPTION, false),\n-                new JavaIsoVisitor<ExecutionContext>() {\n-                    @Override\n-                    public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {\n-                        J.Annotation an = super.visitAnnotation(annotation, ctx);\n-                        if (!TypeUtils.isOfClassType(annotation.getType(), ORG_OPENREWRITE_OPTION) || an.getArguments() == null) {\n-                            return an;\n-                        }\n-\n-                        // Skip if there is already an example value, or valid options\n-                        boolean hasExample = an.getArguments().stream().anyMatch(exp -> {\n-                            if (exp instanceof J.Assignment) {\n-                                Expression variable = ((J.Assignment) exp).getVariable();\n-                                if (variable instanceof J.Identifier) {\n-                                    String simpleName = ((J.Identifier) variable).getSimpleName();\n-                                    return \"example\".equals(simpleName) || \"valid\".equals(simpleName);\n-                                }\n-                            }\n-                            return false;\n-                        });\n-                        if (hasExample) {\n-                            return an;\n-                        }\n-\n-                        // Skip boolean and non-String primitive fields, as examples there are trivial\n-                        Cursor parent = getCursor().getParent();\n-                        if (parent != null && parent.getValue() instanceof J.VariableDeclarations) {\n-                            J.VariableDeclarations variableDeclarations = parent.getValue();\n-                            if (variableDeclarations.getTypeExpression() != null) {\n-                                JavaType type = variableDeclarations.getTypeExpression().getType();\n-                                if (!TypeUtils.isString(type)) {\n-                                    if (type instanceof JavaType.Primitive ||\n-                                        type instanceof JavaType.FullyQualified &&\n-                                        \"java.lang\".equals(((JavaType.FullyQualified) type).getPackageName())) {\n-                                        return an;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        AddOrUpdateAnnotationAttribute addOrUpdateAnnotationAttribute = new AddOrUpdateAnnotationAttribute(ORG_OPENREWRITE_OPTION, \"example\", \"TODO Provide a usage example for the docs\", null, true, false);\n-                        return (J.Annotation) addOrUpdateAnnotationAttribute.getVisitor().visitNonNull(an, ctx, getCursor().getParent());\n-                    }\n-                });\n-    }\n-}\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/NoMutableStaticFieldsInRecipes.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/NoMutableStaticFieldsInRecipes.java\ndeleted file mode 100644\nindex e04b14addbb..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/NoMutableStaticFieldsInRecipes.java\n+++ /dev/null\n@@ -1,70 +0,0 @@\n-/*\n- * Copyright 2024 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.Preconditions;\n-import org.openrewrite.Recipe;\n-import org.openrewrite.TreeVisitor;\n-import org.openrewrite.internal.ListUtils;\n-import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.search.FindAnnotations;\n-import org.openrewrite.java.search.UsesType;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.TypeUtils;\n-\n-public class NoMutableStaticFieldsInRecipes extends Recipe {\n-    @Override\n-    public String getDisplayName() {\n-        return \"Recipe classes should not have mutable `static` fields\";\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return \"Remove mutable static fields from Recipe classes to discourage their use.\";\n-    }\n-\n-    @Override\n-    public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(\n-                new UsesType<>(\"org.openrewrite.Recipe\", true),\n-                new JavaIsoVisitor<ExecutionContext>() {\n-                    @Override\n-                    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {\n-                        J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);\n-                        if (TypeUtils.isAssignableTo(\"org.openrewrite.Recipe\", cd.getType())) {\n-                            return cd.withBody(cd.getBody().withStatements(ListUtils.map(cd.getBody().getStatements(), stmt -> {\n-                                        if (stmt instanceof J.VariableDeclarations) {\n-                                            J.VariableDeclarations field = (J.VariableDeclarations) stmt;\n-                                            if (field.hasModifier(J.Modifier.Type.Static) &&\n-                                                !field.hasModifier(J.Modifier.Type.Final) &&\n-                                                FindAnnotations.find(field, \"@java.lang.SuppressWarnings\").isEmpty()) {\n-                                                // We want to discourage the use of mutable static fields in recipes,\n-                                                // so rather than make them immutable, we'll just remove the field.\n-                                                // Any fields that were intended as constants should be made final.\n-                                                return null;\n-                                            }\n-                                        }\n-                                        return stmt;\n-                                    })\n-                            ));\n-                        }\n-                        return cd;\n-                    }\n-                }\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/RecipeEqualsAndHashCodeCallSuper.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/RecipeEqualsAndHashCodeCallSuper.java\ndeleted file mode 100644\nindex 0f8f9989e2a..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/RecipeEqualsAndHashCodeCallSuper.java\n+++ /dev/null\n@@ -1,68 +0,0 @@\n-/*\n- * Copyright 2024 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.Preconditions;\n-import org.openrewrite.Recipe;\n-import org.openrewrite.TreeVisitor;\n-import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.search.UsesType;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.TypeUtils;\n-\n-public class RecipeEqualsAndHashCodeCallSuper extends Recipe {\n-\n-    @Override\n-    public String getDisplayName() {\n-        return \"Use of `@EqualsAndHashCode` on `Recipe`\";\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return \"Recipes are value objects, so should use `@EqualsAndHashCode(callSuper = false)`. \" +\n-               \"While in most cases recipes do not extend other classes and so the option is moot, as \" +\n-               \"a matter of stylistic consistency and to enforce the idea that recipes are value objects, \" +\n-               \"this value should be set to `false`.\";\n-    }\n-\n-    @Override\n-    public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(\n-                new UsesType<>(\"org.openrewrite.Recipe\", true),\n-                new JavaIsoVisitor<ExecutionContext>() {\n-                    @Override\n-                    public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {\n-                        if (TypeUtils.isOfClassType(annotation.getType(), \"lombok.EqualsAndHashCode\") &&\n-                            getCursor().getParentTreeCursor().getValue() instanceof J.ClassDeclaration) {\n-                            return (J.Annotation) new JavaIsoVisitor<ExecutionContext>() {\n-                                @Override\n-                                public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext ctx) {\n-                                    if (assignment.getVariable() instanceof J.Identifier &&\n-                                        \"callSuper\".equals(((J.Identifier) assignment.getVariable()).getSimpleName()) &&\n-                                        J.Literal.isLiteralValue(assignment.getAssignment(), true)) {\n-                                        return assignment.withAssignment(((J.Literal) assignment.getAssignment())\n-                                                .withValue(false).withValueSource(\"false\"));\n-                                    }\n-                                    return super.visitAssignment(assignment, ctx);\n-                                }\n-                            }.visitNonNull(annotation, ctx, getCursor().getParentOrThrow());\n-                        }\n-                        return super.visitAnnotation(annotation, ctx);\n-                    }\n-                });\n-    }\n-}\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/SelectRecipeExamples.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/SelectRecipeExamples.java\ndeleted file mode 100644\nindex 56cd343878e..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/SelectRecipeExamples.java\n+++ /dev/null\n@@ -1,162 +0,0 @@\n-/*\n- * Copyright 2023 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.Preconditions;\n-import org.openrewrite.Recipe;\n-import org.openrewrite.TreeVisitor;\n-import org.openrewrite.java.*;\n-import org.openrewrite.java.search.UsesType;\n-import org.openrewrite.java.tree.Expression;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.TypeUtils;\n-\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import static java.util.Comparator.comparing;\n-\n-public class SelectRecipeExamples extends Recipe {\n-\n-    private static final String DOCUMENT_EXAMPLE_ANNOTATION_FQN = \"org.openrewrite.DocumentExample\";\n-    private static final AnnotationMatcher TEST_ANNOTATION_MATCHER = new AnnotationMatcher(\"@org.junit.jupiter.api.Test\");\n-    private static final AnnotationMatcher ISSUE_ANNOTATION_MATCHER = new AnnotationMatcher(\"@org.openrewrite.Issue\");\n-    private static final AnnotationMatcher DISABLED_ANNOTATION_MATCHER = new AnnotationMatcher(\"@org.junit.jupiter.api.Disabled\");\n-    private static final AnnotationMatcher NESTED_ANNOTATION_MATCHER = new AnnotationMatcher(\"@org.junit.jupiter.api.Nested\");\n-    private static final AnnotationMatcher DOCUMENT_EXAMPLE_ANNOTATION_MATCHER =\n-            new AnnotationMatcher(\"@\" + DOCUMENT_EXAMPLE_ANNOTATION_FQN);\n-\n-    private static final MethodMatcher REWRITE_RUN_METHOD_MATCHER_ALL =\n-            new MethodMatcher(\"org.openrewrite.test.RewriteTest rewriteRun(..)\");\n-\n-    private static final MethodMatcher REWRITE_RUN_METHOD_MATCHER_WITH_SPEC =\n-            new MethodMatcher(\"org.openrewrite.test.RewriteTest rewriteRun(java.util.function.Consumer, org.openrewrite.test.SourceSpecs[])\");\n-\n-    private static final String REWRITE_TEST_FQN = \"org.openrewrite.test.RewriteTest\";\n-\n-    @Override\n-    public String getDisplayName() {\n-        return \"Automatically select recipe examples from the unit test cases of a recipe\";\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return \"Add `@DocumentExample` to the first non-issue and not a disabled unit test of a recipe as an example,\" +\n-               \" if there are not any examples yet.\";\n-    }\n-\n-    @Override\n-    public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(Preconditions.not(new UsesType<>(DOCUMENT_EXAMPLE_ANNOTATION_FQN, false)), new JavaIsoVisitor<ExecutionContext>() {\n-            private int selectedCount = 0;\n-\n-            @Override\n-            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl,\n-                                                            ExecutionContext ctx) {\n-                if (classDecl.getImplements() != null && !classDecl.getImplements().isEmpty()) {\n-                    if (!TypeUtils.isOfClassType(classDecl.getImplements().get(0).getType(), REWRITE_TEST_FQN)) {\n-                        return classDecl;\n-                    }\n-                }\n-                selectedCount = 0;\n-                return super.visitClassDeclaration(classDecl, ctx);\n-            }\n-\n-            @Override\n-            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method,\n-                                                              ExecutionContext ctx) {\n-                if (selectedCount > 0) {\n-                    return method;\n-                }\n-\n-                List<J.Annotation> annotations = method.getLeadingAnnotations();\n-\n-                boolean isTest = annotations.stream().anyMatch(TEST_ANNOTATION_MATCHER::matches);\n-                if (!isTest) {\n-                    return method;\n-                }\n-\n-                boolean hasIssueOrDisabledAnnotation =\n-                        annotations.stream().anyMatch(a -> ISSUE_ANNOTATION_MATCHER.matches(a) ||\n-                                                           DISABLED_ANNOTATION_MATCHER.matches(a) ||\n-                                                           DOCUMENT_EXAMPLE_ANNOTATION_MATCHER.matches(a)\n-                        );\n-\n-                if (hasIssueOrDisabledAnnotation) {\n-                    return method;\n-                }\n-\n-                J.ClassDeclaration clazz = getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance).getValue();\n-                boolean insideNestedClass = clazz != null && clazz.getLeadingAnnotations().stream().anyMatch(NESTED_ANNOTATION_MATCHER::matches);\n-                if (insideNestedClass) {\n-                    return method;\n-                }\n-\n-                // a good recipe example should have both before and after.\n-                boolean isAGoodExample = new JavaIsoVisitor<AtomicBoolean>() {\n-                    @Override\n-                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method,\n-                                                                    AtomicBoolean isGood) {\n-                        if (REWRITE_RUN_METHOD_MATCHER_ALL.matches(method)) {\n-                            int argIndex = 0;\n-                            if (REWRITE_RUN_METHOD_MATCHER_WITH_SPEC.matches(method)) {\n-                                argIndex = 1;\n-                            }\n-\n-                            Expression arg = method.getArguments().get(argIndex);\n-\n-                            if (arg instanceof J.MethodInvocation) {\n-\n-                                J.MethodInvocation methodInvocation = (J.MethodInvocation) arg;\n-                                methodInvocation.getArguments();\n-                                if (methodInvocation.getArguments().size() > 1) {\n-                                    Expression arg0 = methodInvocation.getArguments().get(0);\n-                                    Expression arg1 = methodInvocation.getArguments().get(1);\n-\n-                                    if (isStringLiteral(arg0) && isStringLiteral(arg1)) {\n-                                        isGood.set(true);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        return method;\n-                    }\n-                }.reduce(method, new AtomicBoolean()).get();\n-\n-                if (!isAGoodExample) {\n-                    return method;\n-                }\n-\n-                maybeAddImport(DOCUMENT_EXAMPLE_ANNOTATION_FQN);\n-\n-                selectedCount++;\n-                return JavaTemplate.builder(\"@DocumentExample\")\n-                        .contextSensitive()\n-                        .imports(DOCUMENT_EXAMPLE_ANNOTATION_FQN)\n-                        .javaParser(JavaParser.fromJavaVersion()\n-                                .classpath(JavaParser.runtimeClasspath()))\n-                        .build()\n-                        .apply(getCursor(), method.getCoordinates().addAnnotation(comparing(J.Annotation::getSimpleName)));\n-            }\n-        });\n-    }\n-\n-    private static boolean isStringLiteral(Expression expression) {\n-        return expression instanceof J.Literal && TypeUtils.isString(((J.Literal) expression).getType());\n-    }\n-\n-}\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/SourceSpecTextBlockIndentation.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/SourceSpecTextBlockIndentation.java\ndeleted file mode 100644\nindex bc943d87670..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/SourceSpecTextBlockIndentation.java\n+++ /dev/null\n@@ -1,119 +0,0 @@\n-/*\n- * Copyright 2022 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.Recipe;\n-import org.openrewrite.TreeVisitor;\n-import org.openrewrite.internal.ListUtils;\n-import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.Space;\n-import org.openrewrite.java.tree.TypeUtils;\n-\n-import java.util.Arrays;\n-import java.util.StringJoiner;\n-import java.util.regex.Pattern;\n-\n-public class SourceSpecTextBlockIndentation extends Recipe {\n-    @Override\n-    public String getDisplayName() {\n-        return \"Minimal indentation for `SourceSpecs` text blocks\";\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return \"Text blocks that assert before and after source code should have minimal indentation.\";\n-    }\n-\n-    @Override\n-    public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return new JavaIsoVisitor<ExecutionContext>() {\n-            final Pattern endTextBlockOnOwnLine = Pattern.compile(\"\\\\s+\\\"\\\"\\\"\\\\s*$\");\n-\n-            @Override\n-            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n-                if (method.getMethodType() != null && TypeUtils.isOfClassType(method.getMethodType().getReturnType(),\n-                        \"org.openrewrite.test.SourceSpecs\")) {\n-                    return method.withArguments(ListUtils.map(method.getArguments(), argument -> {\n-                        if (TypeUtils.isString(argument.getType()) && argument instanceof J.Literal) {\n-                            J.Literal source = (J.Literal) argument;\n-                            if (source.getValueSource() != null && source.getValueSource().startsWith(\"\\\"\\\"\\\"\") &&\n-                                endTextBlockOnOwnLine.matcher(source.getValueSource()).find()) {\n-\n-                                String[] lines = source.getValueSource().split(\"\\n\");\n-                                int[] indentations = new int[lines.length - 1];\n-                                boolean[] nonSpaceCharacter = new boolean[lines.length - 1];\n-                                Arrays.fill(indentations, 0);\n-                                Arrays.fill(nonSpaceCharacter, false);\n-\n-                                nextLine:\n-                                for (int i = 1; i < lines.length; i++) {\n-                                    String line = lines[i];\n-                                    for (int j = 0; j < line.length(); j++) {\n-                                        if (line.charAt(j) == ' ') {\n-                                            indentations[i - 1]++;\n-                                        } else {\n-                                            nonSpaceCharacter[i - 1] = true;\n-                                            continue nextLine;\n-                                        }\n-                                    }\n-                                }\n-\n-                                int expectedIndent = indentations[indentations.length - 1];\n-                                if (indentations.length >= 2 &&\n-                                    nonSpaceCharacter[0] &&\n-                                    nonSpaceCharacter[indentations.length - 2] &&\n-                                    indentations[0] == indentations[indentations.length - 2] &&\n-                                    indentations[0] >= expectedIndent) {\n-\n-                                    for (int i = 0; i < indentations.length - 1; i++) {\n-                                        if (nonSpaceCharacter[i] && indentations[i] < indentations[0]) {\n-                                            // the first and last lines of the source code are further\n-                                            // right that some other block of code in the middle\n-                                            return argument;\n-                                        }\n-                                    }\n-\n-                                    int marginTrim = indentations[0] - expectedIndent;\n-                                    StringJoiner fixedSource = new StringJoiner(\"\\n\");\n-                                    for (int i = 0; i < lines.length; i++) {\n-                                        String line = lines[i];\n-                                        if (i == 0 || i == lines.length - 1 || indentations[i - 1] < expectedIndent) {\n-                                            fixedSource.add(line);\n-                                        } else {\n-                                            fixedSource.add(line.substring(marginTrim));\n-                                        }\n-                                    }\n-\n-                                    J.Literal withFixedSource = source.withValueSource(fixedSource.toString());\n-                                    if (withFixedSource.getPrefix().getComments().isEmpty() &&\n-                                        withFixedSource.getPrefix().getWhitespace().isEmpty()) {\n-                                        return maybeAutoFormat(withFixedSource, withFixedSource.withPrefix(Space.format(\"\\n\")), ctx);\n-                                    }\n-                                    return withFixedSource;\n-                                }\n-\n-                            }\n-                        }\n-                        return argument;\n-                    }));\n-                }\n-                return super.visitMethodInvocation(method, ctx);\n-            }\n-        };\n-    }\n-}\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/UseTreeRandomId.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/UseTreeRandomId.java\ndeleted file mode 100644\nindex 32c40d8b682..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/UseTreeRandomId.java\n+++ /dev/null\n@@ -1,84 +0,0 @@\n-/*\n- * Copyright 2024 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import lombok.EqualsAndHashCode;\n-import lombok.Value;\n-import org.openrewrite.*;\n-import org.openrewrite.internal.ListUtils;\n-import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.MethodMatcher;\n-import org.openrewrite.java.TypeMatcher;\n-import org.openrewrite.java.search.UsesMethod;\n-import org.openrewrite.java.search.UsesType;\n-import org.openrewrite.java.tree.Expression;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.JavaType;\n-\n-import java.util.Collections;\n-\n-@Value\n-@EqualsAndHashCode(callSuper = false)\n-public class UseTreeRandomId extends Recipe {\n-\n-    @Override\n-    public String getDisplayName() {\n-        return \"Use `Tree.randomId()` in LST constructors\";\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return \"Replaces occurrences of `UUID.randomUUID()` with `Tree.randomId()` when passed as an argument to a constructor call for LST elements.\";\n-    }\n-\n-    @Override\n-    public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        final TypeMatcher treeMatcher = new TypeMatcher(\"org.openrewrite.Tree\", true);\n-        final MethodMatcher randomUUIDMatcher = new MethodMatcher(\"java.util.UUID randomUUID()\");\n-        return Preconditions.check(\n-                Preconditions.and(\n-                        new UsesType<>(\"org.openrewrite.Tree\", true),\n-                        new UsesMethod<>(randomUUIDMatcher)),\n-                new JavaIsoVisitor<ExecutionContext>() {\n-                    @Override\n-                    public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {\n-                        J.NewClass n = super.visitNewClass(newClass, ctx);\n-                        if (!treeMatcher.matches(n.getType())) {\n-                            return n;\n-                        }\n-                        return n.withArguments(ListUtils.mapFirst(n.getArguments(), this::maybeReplace));\n-                    }\n-\n-                    private Expression maybeReplace(Expression expression) {\n-                        if (!randomUUIDMatcher.matches(expression)) {\n-                            return expression;\n-                        }\n-                        maybeAddImport(\"org.openrewrite.Tree\");\n-                        maybeRemoveImport(\"java.util.UUID\");\n-\n-                        J.MethodInvocation mi = (J.MethodInvocation) expression;\n-                        JavaType.Class classType = JavaType.ShallowClass.build(\"org.openrewrite.Tree\");\n-                        JavaType.Method methodType = mi.getMethodType().withName(\"randomId\").withDeclaringType(classType);\n-                        mi = mi.withName(mi.getName().withSimpleName(\"randomId\").withType(methodType));\n-                        if (mi.getSelect() instanceof J.Identifier) {\n-                            return mi.withSelect(((J.Identifier) mi.getSelect()).withSimpleName(\"Tree\").withType(classType));\n-                        }\n-                        return mi.withSelect(new J.Identifier(\n-                                Tree.randomId(), mi.getPrefix(), mi.getMarkers(), Collections.emptyList(), \"Tree\", classType, null));\n-                    }\n-                });\n-    }\n-}\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/package-info.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/package-info.java\ndeleted file mode 100644\nindex 4abf2d19b99..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/package-info.java\n+++ /dev/null\n@@ -1,21 +0,0 @@\n-/*\n- * Copyright 2020 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-@NullMarked\n-@NonNullFields\n-package org.openrewrite.java.recipes;\n-\n-import org.jspecify.annotations.NullMarked;\n-import org.openrewrite.internal.lang.NonNullFields;\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/ExecutionContextParameterNameTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/ExecutionContextParameterNameTest.java\ndeleted file mode 100644\nindex 0ad8e2adc72..00000000000\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/ExecutionContextParameterNameTest.java\n+++ /dev/null\n@@ -1,115 +0,0 @@\n-/*\n- * Copyright 2021 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.junit.jupiter.api.Test;\n-import org.openrewrite.DocumentExample;\n-import org.openrewrite.java.JavaParser;\n-import org.openrewrite.test.RecipeSpec;\n-import org.openrewrite.test.RewriteTest;\n-\n-import static org.openrewrite.java.Assertions.java;\n-\n-class ExecutionContextParameterNameTest implements RewriteTest {\n-\n-    @Override\n-    public void defaults(RecipeSpec spec) {\n-        spec\n-          .recipe(new ExecutionContextParameterName())\n-          .parser(JavaParser.fromJavaVersion()\n-            .dependsOn(\n-\n-              \"\"\"\n-                package org.openrewrite;\n-                public class Recipe {}\n-                \"\"\",\n-              \"\"\"\n-                package org.openrewrite;\n-                public class Visitor {}\n-                \"\"\",\n-              \"\"\"\n-                package org.openrewrite;\n-                public class TreeVisitor extends Visitor {}\n-                \"\"\",\n-              \"\"\"\n-                package org.openrewrite;\n-                public class ExecutionContext {}\n-                \"\"\"\n-            ));\n-    }\n-\n-    @DocumentExample\n-    @Test\n-    void recipe() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.*;\n-              class SampleRecipe extends Recipe {\n-                  public void test(ExecutionContext executionContext) {}\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.*;\n-              class SampleRecipe extends Recipe {\n-                  public void test(ExecutionContext ctx) {}\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-\n-    @Test\n-    void visitor() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.*;\n-              class SampleVisitor extends Visitor {\n-                  public void test(ExecutionContext executionContext) {}\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.*;\n-              class SampleVisitor extends Visitor {\n-                  public void test(ExecutionContext ctx) {}\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void treeVisitor() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.*;\n-              class SampleTreeVisitor extends TreeVisitor {\n-                  public void test(ExecutionContext executionContext) {}\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.*;\n-              class SampleTreeVisitor extends TreeVisitor {\n-                  public void test(ExecutionContext ctx) {}\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/FindRecipesTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/FindRecipesTest.java\ndeleted file mode 100644\nindex 3624f6bfe8e..00000000000\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/FindRecipesTest.java\n+++ /dev/null\n@@ -1,250 +0,0 @@\n-/*\n- * Copyright 2022 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.junit.jupiter.api.Test;\n-import org.openrewrite.DocumentExample;\n-import org.openrewrite.java.JavaParser;\n-import org.openrewrite.table.RewriteRecipeSource;\n-import org.openrewrite.test.RecipeSpec;\n-import org.openrewrite.test.RewriteTest;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.openrewrite.java.Assertions.java;\n-import static org.openrewrite.yaml.Assertions.yaml;\n-\n-class FindRecipesTest implements RewriteTest {\n-\n-    @Override\n-    public void defaults(RecipeSpec spec) {\n-        spec.recipe(new FindRecipes()).parser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()));\n-    }\n-\n-    @DocumentExample\n-    @Test\n-    void findRecipes() {\n-        rewriteRun(\n-          spec -> spec\n-            .dataTable(RewriteRecipeSource.Row.class, rows -> {\n-                assertThat(rows).hasSize(1);\n-                RewriteRecipeSource.Row row = rows.get(0);\n-                assertThat(row.getDisplayName()).isEqualTo(\"My recipe\");\n-                assertThat(row.getDescription()).isEqualTo(\"This is my recipe.\");\n-                assertThat(row.getOptions()).isEqualTo(\"[{\\\"name\\\":\\\"methodPattern\\\",\\\"displayName\\\":\\\"Method pattern\\\",\\\"description\\\":\\\"A method pattern that is used to find matching method declarations/invocations.\\\",\\\"example\\\":\\\"org.mockito.Matchers anyVararg()\\\"},{\\\"name\\\":\\\"newAccessLevel\\\",\\\"displayName\\\":\\\"New access level\\\",\\\"description\\\":\\\"New method access level to apply to the method, like \\\\\\\"public\\\\\\\".\\\",\\\"example\\\":\\\"public\\\",\\\"valid\\\":[\\\"private\\\",\\\"protected\\\",\\\"package\\\",\\\"public\\\"],\\\"required\\\":false}]\");\n-            }),\n-          java(\n-            \"\"\"\n-              import org.openrewrite.Option;\n-              import org.openrewrite.internal.lang.NonNullApi;\n-              import org.openrewrite.Recipe;\n-              import org.openrewrite.internal.lang.Nullable;\n-              \n-              @NonNullApi\n-              class MyRecipe extends Recipe {\n-                @Option(displayName = \"Method pattern\",\n-                        description = \"A method pattern that is used to find matching method declarations/invocations.\",\n-                        example = \"org.mockito.Matchers anyVararg()\")\n-                String methodPattern;\n-              \n-                @Option(displayName = \"New access level\",\n-                        description = \"New method access level to apply to the method, like \\\\\"public\\\\\".\",\n-                        example = \"public\",\n-                        valid = {\"private\", \"protected\", \"package\", \"public\"},\n-                        required = false)\n-                String newAccessLevel;\n-              \n-                @Override\n-                public String getDisplayName() {\n-                    return \"My recipe\";\n-                }\n-              \n-                @Override\n-                public String getDescription() {\n-                    return \"This is my recipe.\";\n-                }\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.Option;\n-              import org.openrewrite.internal.lang.NonNullApi;\n-              import org.openrewrite.Recipe;\n-              import org.openrewrite.internal.lang.Nullable;\n-              \n-              @NonNullApi\n-              class /*~~>*/MyRecipe extends Recipe {\n-                @Option(displayName = \"Method pattern\",\n-                        description = \"A method pattern that is used to find matching method declarations/invocations.\",\n-                        example = \"org.mockito.Matchers anyVararg()\")\n-                String methodPattern;\n-              \n-                @Option(displayName = \"New access level\",\n-                        description = \"New method access level to apply to the method, like \\\\\"public\\\\\".\",\n-                        example = \"public\",\n-                        valid = {\"private\", \"protected\", \"package\", \"public\"},\n-                        required = false)\n-                String newAccessLevel;\n-              \n-                @Override\n-                public String getDisplayName() {\n-                    return \"My recipe\";\n-                }\n-              \n-                @Override\n-                public String getDescription() {\n-                    return \"This is my recipe.\";\n-                }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void returnInLambda() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import java.util.function.UnaryOperator;\n-              \n-              class SomeTest {\n-                  private final UnaryOperator<String> notEmpty = actual -> {\n-                      //noinspection CodeBlock2Expr\n-                      return actual + \"\\\\n\";\n-                  };\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void findRefasterRecipe() {\n-        rewriteRun(\n-          spec -> spec.parser(JavaParser.fromJavaVersion().dependsOn(\n-              \"\"\"\n-                package org.openrewrite.java.template;\n-                import java.lang.annotation.ElementType;\n-                import java.lang.annotation.Target;\n-                @Target(ElementType.TYPE)\n-                public @interface RecipeDescriptor {\n-                    String name();\n-                    String description();\n-                }\n-                \"\"\"\n-            ))\n-            .dataTable(RewriteRecipeSource.Row.class, rows -> {\n-                assertThat(rows).hasSize(1);\n-                RewriteRecipeSource.Row row = rows.get(0);\n-                assertThat(row.getDisplayName()).isEqualTo(\"Some refaster rule\");\n-                assertThat(row.getDescription()).isEqualTo(\"This is a refaster rule.\");\n-            }),\n-          java(\n-            \"\"\"\n-              import org.openrewrite.java.template.RecipeDescriptor;\n-              \n-              @RecipeDescriptor(\n-                  name = \"Some refaster rule\",\n-                  description = \"This is a refaster rule.\"\n-              )\n-              class SomeRefasterRule {\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.java.template.RecipeDescriptor;\n-              \n-              /*~~>*/@RecipeDescriptor(\n-                  name = \"Some refaster rule\",\n-                  description = \"This is a refaster rule.\"\n-              )\n-              class SomeRefasterRule {\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void findYamlRecipe() {\n-        rewriteRun(\n-          spec -> spec.parser(JavaParser.fromJavaVersion().dependsOn(\n-              \"\"\"\n-                package org.openrewrite.java.template;\n-                import java.lang.annotation.ElementType;\n-                import java.lang.annotation.Target;\n-                @Target(ElementType.TYPE)\n-                public @interface RecipeDescriptor {\n-                    String name();\n-                    String description();\n-                }\n-                \"\"\"\n-            ))\n-            .dataTable(RewriteRecipeSource.Row.class, rows -> {\n-                assertThat(rows).hasSize(2);\n-                assertThat(rows.get(0).getDisplayName()).isEqualTo(\"Migrates to Apache Commons Lang 3.x\");\n-                assertThat(rows.get(0).getSourceCode()).startsWith(\n-                  \"---\\ntype: specs.openrewrite.org/v1beta/recipe\\nname: org.openrewrite.apache.commons.lang.UpgradeApacheCommonsLang_2_3\");\n-                assertThat(rows.get(1).getDisplayName()).isEqualTo(\"Migrates to Apache POI 3.17\");\n-                assertThat(rows.get(1).getSourceCode()).startsWith(\n-                  \"---\\ntype: specs.openrewrite.org/v1beta/recipe\\nname: org.openrewrite.apache.poi.UpgradeApachePoi_3_17\");\n-            }),\n-          yaml(\n-            \"\"\"\n-              # Apache Commons Lang\n-              ---\n-              type: specs.openrewrite.org/v1beta/recipe\n-              name: org.openrewrite.apache.commons.lang.UpgradeApacheCommonsLang_2_3\n-              displayName: Migrates to Apache Commons Lang 3.x\n-              description: >-\n-                Migrate applications to the latest Apache Commons Lang 3.x release. This recipe modifies\\s\n-                application's build files, and changes the package as per [the migration release notes](https://commons.apache.org/proper/commons-lang/article3_0.html).\n-              tags:\n-                - apache\n-                - commons\n-                - lang\n-              recipeList:\n-                - org.openrewrite.java.dependencies.ChangeDependency:\n-                    oldGroupId: commons-lang\n-                    oldArtifactId: commons-lang\n-                    newGroupId: org.apache.commons\n-                    newArtifactId: commons-lang3\n-                    newVersion: 3.x\n-                - org.openrewrite.java.ChangePackage:\n-                    oldPackageName: org.apache.commons.lang\n-                    newPackageName: org.apache.commons.lang3\n-              ---\n-              type: specs.openrewrite.org/v1beta/recipe\n-              name: org.openrewrite.apache.poi.UpgradeApachePoi_3_17\n-              displayName: Migrates to Apache POI 3.17\n-              description: Migrates to the last Apache POI 3.x release. This recipe modifies build files and makes changes to deprecated/preferred APIs that have changed between versions.\n-              tags:\n-                - apache\n-                - poi\n-              recipeList:\n-                - org.openrewrite.java.dependencies.ChangeDependency:\n-                    oldGroupId: poi\n-                    oldArtifactId: poi\n-                    newGroupId: org.apache.poi\n-                    newArtifactId: poi\n-                    newVersion: 3.x\n-              \"\"\",\n-            spec -> spec.path(\"rewrite.yml\").after(after -> {\n-                assertThat(after).contains(\"~~>\");\n-                return after;\n-            })\n-          )\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/MissingOptionExampleTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/MissingOptionExampleTest.java\ndeleted file mode 100644\nindex b6d485abd19..00000000000\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/MissingOptionExampleTest.java\n+++ /dev/null\n@@ -1,165 +0,0 @@\n-/*\n- * Copyright 2024 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.ValueSource;\n-import org.openrewrite.DocumentExample;\n-import org.openrewrite.java.JavaParser;\n-import org.openrewrite.test.RecipeSpec;\n-import org.openrewrite.test.RewriteTest;\n-\n-import static org.openrewrite.java.Assertions.java;\n-\n-class MissingOptionExampleTest implements RewriteTest {\n-    @Override\n-    public void defaults(RecipeSpec spec) {\n-        spec.recipe(new MissingOptionExample())\n-          .parser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()));\n-    }\n-\n-    @DocumentExample\n-    @Test\n-    void lacksExample() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.Option;\n-              import org.openrewrite.Recipe;\n-              \n-              class SomeRecipe extends Recipe {\n-                  @Option(displayName = \"Test\", description = \"Test\")\n-                  private String test;\n-              \n-                  @Override\n-                  public String getDisplayName() {\n-                      return \"Find missing `@Option` `example` values\";\n-                  }\n-                  @Override\n-                  public String getDescription() {\n-                      return \"Find `@Option` annotations that are missing `example` values.\";\n-                  }\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.Option;\n-              import org.openrewrite.Recipe;\n-\n-              class SomeRecipe extends Recipe {\n-                  @Option(example = \"TODO Provide a usage example for the docs\", displayName = \"Test\", description = \"Test\")\n-                  private String test;\n-              \n-                  @Override\n-                  public String getDisplayName() {\n-                      return \"Find missing `@Option` `example` values\";\n-                  }\n-                  @Override\n-                  public String getDescription() {\n-                      return \"Find `@Option` annotations that are missing `example` values.\";\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void hasExampleAlready() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.Option;\n-              import org.openrewrite.Recipe;\n-              \n-              class SomeRecipe extends Recipe {\n-                  @Option(displayName = \"Test\", description = \"Test\", example = \"true\")\n-                  private boolean test = true;\n-              \n-                  @Override\n-                  public String getDisplayName() {\n-                      return \"Find missing `@Option` `example` values\";\n-                  }\n-                  @Override\n-                  public String getDescription() {\n-                      return \"Find `@Option` annotations that are missing `example` values.\";\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @ParameterizedTest\n-    @ValueSource(strings = {\n-      \"boolean\",\n-      \"Boolean\",\n-      \"int\",\n-      \"Integer\",\n-      \"long\",\n-      \"Long\"\n-    })\n-    void skipBoolean(String type) {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.Option;\n-              import org.openrewrite.Recipe;\n-              \n-              class SomeRecipe extends Recipe {\n-                  @Option(displayName = \"Test\", description = \"Test\")\n-                  private %s test;\n-              \n-                  @Override\n-                  public String getDisplayName() {\n-                      return \"Find missing `@Option` `example` values\";\n-                  }\n-                  @Override\n-                  public String getDescription() {\n-                      return \"Find `@Option` annotations that are missing `example` values.\";\n-                  }\n-              }\n-              \"\"\".formatted(type)\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void skipValidOptions() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.Option;\n-              import org.openrewrite.Recipe;\n-              \n-              class SomeRecipe extends Recipe {\n-                  @Option(displayName = \"Test\", description = \"Test\", valid = {\"foo\", \"bar\"})\n-                  private String test;\n-              \n-                  @Override\n-                  public String getDisplayName() {\n-                      return \"Find missing `@Option` `example` values\";\n-                  }\n-                  @Override\n-                  public String getDescription() {\n-                      return \"Find `@Option` annotations that are missing `example` values.\";\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/RecipeEqualsAndHashCodeCallSuperTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/RecipeEqualsAndHashCodeCallSuperTest.java\ndeleted file mode 100644\nindex bc83373ebbc..00000000000\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/RecipeEqualsAndHashCodeCallSuperTest.java\n+++ /dev/null\n@@ -1,111 +0,0 @@\n-/*\n- * Copyright 2024 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.junit.jupiter.api.Test;\n-import org.openrewrite.DocumentExample;\n-import org.openrewrite.java.JavaParser;\n-import org.openrewrite.test.RecipeSpec;\n-import org.openrewrite.test.RewriteTest;\n-\n-import static org.openrewrite.java.Assertions.java;\n-\n-class RecipeEqualsAndHashCodeCallSuperTest implements RewriteTest {\n-\n-    @Override\n-    public void defaults(RecipeSpec spec) {\n-        spec.recipe(new RecipeEqualsAndHashCodeCallSuper())\n-          .parser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()));\n-    }\n-\n-    @DocumentExample\n-    @Test\n-    void recipeEqualsAndHashCodeCallSuper() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.Recipe;\n-              import lombok.EqualsAndHashCode;\n-              import lombok.Value;\n-              \n-              @Value\n-              @EqualsAndHashCode(callSuper = true)\n-              class MyRecipe extends Recipe {\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.Recipe;\n-              import lombok.EqualsAndHashCode;\n-              import lombok.Value;\n-              \n-              @Value\n-              @EqualsAndHashCode(callSuper = false)\n-              class MyRecipe extends Recipe {\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void retainExclude() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.Recipe;\n-              import lombok.EqualsAndHashCode;\n-              import lombok.Value;\n-              \n-              @Value\n-              @EqualsAndHashCode(callSuper = true, exclude = \"messages\")\n-              class MyRecipe extends Recipe {\n-                  String messages;\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.Recipe;\n-              import lombok.EqualsAndHashCode;\n-              import lombok.Value;\n-              \n-              @Value\n-              @EqualsAndHashCode(callSuper = false, exclude = \"messages\")\n-              class MyRecipe extends Recipe {\n-                  String messages;\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void skipFalse() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.Recipe;\n-              import lombok.EqualsAndHashCode;\n-              import lombok.Value;\n-              \n-              @Value\n-              @EqualsAndHashCode(callSuper = false, exclude = \"messages\")\n-              class MyRecipe extends Recipe {\n-                  String messages;\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SelectRecipeExamplesTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SelectRecipeExamplesTest.java\ndeleted file mode 100644\nindex ebeaae33823..00000000000\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SelectRecipeExamplesTest.java\n+++ /dev/null\n@@ -1,440 +0,0 @@\n-/*\n- * Copyright 2023 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.junit.jupiter.api.Test;\n-import org.openrewrite.DocumentExample;\n-import org.openrewrite.java.JavaParser;\n-import org.openrewrite.test.RecipeSpec;\n-import org.openrewrite.test.RewriteTest;\n-\n-import static org.openrewrite.java.Assertions.java;\n-\n-class SelectRecipeExamplesTest implements RewriteTest {\n-\n-    @Override\n-    public void defaults(RecipeSpec spec) {\n-        spec.recipe(new SelectRecipeExamples())\n-          .parser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()));\n-    }\n-\n-    @DocumentExample\n-    @Test\n-    void selectFirstExample() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              package org.openrewrite.java.cleanup;\n-                           \n-              import org.junit.jupiter.api.Test;\n-              import org.openrewrite.Recipe;\n-              import org.openrewrite.test.RecipeSpec;\n-              import org.openrewrite.test.RewriteTest;\n-\n-              import static org.openrewrite.java.Assertions.java;\n-\n-              class UnnecessaryParenthesesTest implements RewriteTest {\n-                  @Override\n-                  public void defaults(RecipeSpec spec) {\n-                      spec.recipe(Recipe.noop());\n-                  }\n-\n-                  @Test\n-                  void test1() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\",\n-                          \\\"\"\"\n-                            AFTER\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-\n-                  @Test\n-                  void test2() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\",\n-                          \\\"\"\"\n-                            AFTER\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-              }\n-              \"\"\",\n-            \"\"\"\n-              package org.openrewrite.java.cleanup;\n-                           \n-              import org.junit.jupiter.api.Test;\n-              import org.openrewrite.DocumentExample;\n-              import org.openrewrite.Recipe;\n-              import org.openrewrite.test.RecipeSpec;\n-              import org.openrewrite.test.RewriteTest;\n-\n-              import static org.openrewrite.java.Assertions.java;\n-\n-              class UnnecessaryParenthesesTest implements RewriteTest {\n-                  @Override\n-                  public void defaults(RecipeSpec spec) {\n-                      spec.recipe(Recipe.noop());\n-                  }\n-\n-                  @DocumentExample\n-                  @Test\n-                  void test1() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\",\n-                          \\\"\"\"\n-                            AFTER\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-\n-                  @Test\n-                  void test2() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\",\n-                          \\\"\"\"\n-                            AFTER\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void skipNotChangedTest() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              package org.openrewrite.java.cleanup;\n-                           \n-              import org.junit.jupiter.api.Test;\n-              import org.openrewrite.Recipe;\n-              import org.openrewrite.test.RecipeSpec;\n-              import org.openrewrite.test.RewriteTest;\n-\n-              import static org.openrewrite.java.Assertions.java;\n-\n-              class UnnecessaryParenthesesTest implements RewriteTest {\n-                  @Override\n-                  public void defaults(RecipeSpec spec) {\n-                      spec.recipe(Recipe.noop());\n-                  }\n-\n-                  @Test\n-                  void test1() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-\n-                  @Test\n-                  void test2() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\",\n-                          \\\"\"\"\n-                            AFTER\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-              }\n-              \"\"\",\n-            \"\"\"\n-              package org.openrewrite.java.cleanup;\n-                           \n-              import org.junit.jupiter.api.Test;\n-              import org.openrewrite.DocumentExample;\n-              import org.openrewrite.Recipe;\n-              import org.openrewrite.test.RecipeSpec;\n-              import org.openrewrite.test.RewriteTest;\n-                           \n-              import static org.openrewrite.java.Assertions.java;\n-                            \n-              class UnnecessaryParenthesesTest implements RewriteTest {\n-                  @Override\n-                  public void defaults(RecipeSpec spec) {\n-                      spec.recipe(Recipe.noop());\n-                  }\n-\n-                  @Test\n-                  void test1() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-\n-                  @DocumentExample\n-                  @Test\n-                  void test2() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\",\n-                          \\\"\"\"\n-                            AFTER\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void skipIssueAnnotatedTests() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              package org.openrewrite.java.cleanup;\n-                           \n-              import org.junit.jupiter.api.Test;\n-              import org.openrewrite.Issue;\n-              import org.openrewrite.Recipe;\n-              import org.openrewrite.test.RecipeSpec;\n-              import org.openrewrite.test.RewriteTest;\n-                           \n-              import static org.openrewrite.java.Assertions.java;\n-                            \n-              class UnnecessaryParenthesesTest implements RewriteTest {\n-                  @Override\n-                  public void defaults(RecipeSpec spec) {\n-                      spec.recipe(Recipe.noop());\n-                  }\n-\n-                  @Issue(\"https://github.com/openrewrite/rewrite/issues/x\")\n-                  @Test\n-                  void test1() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\",\n-                          \\\"\"\"\n-                            AFTER\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-\n-                  @Test\n-                  void test2() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\",\n-                          \\\"\"\"\n-                            AFTER\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-              }\n-              \"\"\",\n-            \"\"\"\n-              package org.openrewrite.java.cleanup;\n-                           \n-              import org.junit.jupiter.api.Test;\n-              import org.openrewrite.DocumentExample;\n-              import org.openrewrite.Issue;\n-              import org.openrewrite.Recipe;\n-              import org.openrewrite.test.RecipeSpec;\n-              import org.openrewrite.test.RewriteTest;\n-                           \n-              import static org.openrewrite.java.Assertions.java;\n-                            \n-              class UnnecessaryParenthesesTest implements RewriteTest {\n-                  @Override\n-                  public void defaults(RecipeSpec spec) {\n-                      spec.recipe(Recipe.noop());\n-                  }\n-\n-                  @Issue(\"https://github.com/openrewrite/rewrite/issues/x\")\n-                  @Test\n-                  void test1() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\",\n-                          \\\"\"\"\n-                            AFTER\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-                  \n-                  @DocumentExample\n-                  @Test\n-                  void test2() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\",\n-                          \\\"\"\"\n-                            AFTER\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-\n-    @Test\n-    void skipDisabledAnnotatedTests() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              package org.openrewrite.java.cleanup;\n-                           \n-              import org.junit.jupiter.api.Disabled;\n-              import org.junit.jupiter.api.Test;\n-              import org.openrewrite.Recipe;\n-              import org.openrewrite.test.RecipeSpec;\n-              import org.openrewrite.test.RewriteTest;\n-                           \n-              import static org.openrewrite.java.Assertions.java;\n-                            \n-              class UnnecessaryParenthesesTest implements RewriteTest {\n-                  @Override\n-                  public void defaults(RecipeSpec spec) {\n-                      spec.recipe(Recipe.noop());\n-                  }\n-\n-                  @Disabled(\"some reason\")\n-                  @Test\n-                  void test1() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\",\n-                          \\\"\"\"\n-                            AFTER\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void ignoreIfHasAnnotated() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              package org.openrewrite.java.cleanup;\n-                           \n-              import org.junit.jupiter.api.Test;\n-              import org.openrewrite.Recipe;\n-              import org.openrewrite.DocumentExample;\n-              import org.openrewrite.test.RecipeSpec;\n-              import org.openrewrite.test.RewriteTest;\n-                           \n-              import static org.openrewrite.java.Assertions.java;\n-                            \n-              class UnnecessaryParenthesesTest implements RewriteTest {\n-                  @Override\n-                  public void defaults(RecipeSpec spec) {\n-                      spec.recipe(Recipe.noop());\n-                  }\n-\n-                  @DocumentExample\n-                  @Test\n-                  void test1() {\n-                      rewriteRun(\n-                        java(\n-                          \\\"\"\"\n-                            BEFORE\n-                            \\\"\"\",\n-                          \\\"\"\"\n-                            AFTER\n-                            \\\"\"\"\n-                        )\n-                      );\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void skipNestedClasses() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.junit.jupiter.api.Nested;\n-              import org.junit.jupiter.api.Test;\n-              import org.openrewrite.test.RewriteTest;\n-              \n-              import static org.openrewrite.test.SourceSpecs.text;\n-\n-              class OuterClass implements RewriteTest {\n-                @Nested\n-                class InnerClass {\n-                  @Test\n-                  void test1() {\n-                    rewriteRun(text(\"before\", \"after\"));\n-                  }\n-                }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SetDefaultEstimatedEffortPerOccurrenceTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SetDefaultEstimatedEffortPerOccurrenceTest.java\ndeleted file mode 100644\nindex 04b1761bac7..00000000000\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SetDefaultEstimatedEffortPerOccurrenceTest.java\n+++ /dev/null\n@@ -1,70 +0,0 @@\n-/*\n- * Copyright 2021 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.junit.jupiter.api.Test;\n-import org.openrewrite.test.RewriteTest;\n-\n-import static org.openrewrite.java.Assertions.java;\n-\n-class SetDefaultEstimatedEffortPerOccurrenceTest implements RewriteTest {\n-\n-    @SuppressWarnings(\"NullableProblems\")\n-    @Test\n-    void setDefault() {\n-        rewriteRun(\n-          spec -> spec.recipe(new SetDefaultEstimatedEffortPerOccurrence()),\n-          java(\n-            \"\"\"\n-              package org.openrewrite;\n-              import java.time.Duration;\n-\n-              public class Recipe {\n-                  public Duration getEstimatedEffortPerOccurrence() {\n-                      return null;\n-                  }\n-              }\n-              \"\"\"\n-          ),\n-          java(\n-            \"\"\"\n-              import org.openrewrite.Recipe;\n-              class SampleRecipe extends Recipe {\n-                  public String getDisplayName() { return null; }\n-              \n-                  public Object getVisitor() { return null; }\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.Recipe;\n-              \n-              import java.time.Duration;\n-              \n-              class SampleRecipe extends Recipe {\n-                  public String getDisplayName() { return null; }\n-              \n-                  @Override\n-                  public Duration getEstimatedEffortPerOccurrence() {\n-                      return Duration.ofMinutes(5);\n-                  }\n-              \n-                  public Object getVisitor() { return null; }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SourceSpecTextBlockIndentationTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SourceSpecTextBlockIndentationTest.java\ndeleted file mode 100644\nindex e6ced48b1c7..00000000000\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/recipes/SourceSpecTextBlockIndentationTest.java\n+++ /dev/null\n@@ -1,140 +0,0 @@\n-/*\n- * Copyright 2022 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.junit.jupiter.api.Test;\n-import org.openrewrite.DocumentExample;\n-import org.openrewrite.java.JavaParser;\n-import org.openrewrite.test.RecipeSpec;\n-import org.openrewrite.test.RewriteTest;\n-\n-import static org.openrewrite.java.Assertions.java;\n-\n-class SourceSpecTextBlockIndentationTest implements RewriteTest {\n-\n-    @Override\n-    public void defaults(RecipeSpec spec) {\n-        spec.recipe(new SourceSpecTextBlockIndentation())\n-          .parser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()));\n-    }\n-\n-    @DocumentExample\n-    @Test\n-    void minimalIndentation() {\n-        rewriteRun(\n-          spec -> spec.expectedCyclesThatMakeChanges(2),\n-          java(\n-            \"\"\"\n-              import org.openrewrite.test.RewriteTest;\n-              import static org.openrewrite.test.SourceSpecs.text;\n-\n-              class MyRecipeTest implements RewriteTest {\n-                  void test() {\n-                    rewriteRun(\n-                       text(\n-                         \\\"\"\"\n-                             class Test {\n-              \\s\n-                                \\s\n-                                 void test() {\n-                                     System.out.println(\"Hello, world!\");\n-                                 }\n-                             }\n-                           \\\"\"\"\n-                       )\n-                    );\n-                  }\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.test.RewriteTest;\n-              import static org.openrewrite.test.SourceSpecs.text;\n-\n-              class MyRecipeTest implements RewriteTest {\n-                  void test() {\n-                    rewriteRun(\n-                       text(\n-                         \\\"\"\"\n-                           class Test {\n-              \\s\n-                              \\s\n-                               void test() {\n-                                   System.out.println(\"Hello, world!\");\n-                               }\n-                           }\n-                           \\\"\"\"\n-                       )\n-                    );\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void startsOnNewline() {\n-        rewriteRun(\n-          spec -> spec.expectedCyclesThatMakeChanges(2),\n-          java(\n-            \"\"\"\n-              import org.openrewrite.test.RewriteTest;\n-              import static org.openrewrite.test.SourceSpecs.text;\n-\n-              class MyRecipeTest implements RewriteTest {\n-                  void test() {\n-                    rewriteRun(\n-                       text(\\\"\"\"\n-                           class Test {\n-              \\s\n-                              \\s\n-                               void test() {\n-                                   System.out.println(\"Hello, world!\");\n-                               }\n-                           }\n-                           \\\"\"\"\n-                       )\n-                    );\n-                  }\n-              }\n-              \"\"\",\n-\n-            \"\"\"\n-              import org.openrewrite.test.RewriteTest;\n-              import static org.openrewrite.test.SourceSpecs.text;\n-\n-              class MyRecipeTest implements RewriteTest {\n-                  void test() {\n-                    rewriteRun(\n-                       text(\n-                            \\\"\"\"\n-                           class Test {\n-              \\s\n-                              \\s\n-                               void test() {\n-                                   System.out.println(\"Hello, world!\");\n-                               }\n-                           }\n-                           \\\"\"\"\n-                       )\n-                    );\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/RewriteTestClassesShouldNotBePublic.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/RewriteTestClassesShouldNotBePublic.java\ndeleted file mode 100644\nindex 84e3e33ae10..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/RewriteTestClassesShouldNotBePublic.java\n+++ /dev/null\n@@ -1,98 +0,0 @@\n-/*\n- * Copyright 2024 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.Preconditions;\n-import org.openrewrite.Recipe;\n-import org.openrewrite.TreeVisitor;\n-import org.openrewrite.internal.ListUtils;\n-import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.search.UsesType;\n-import org.openrewrite.java.tree.Comment;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.TypeUtils;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-// Not handled by org.openrewrite.java.testing.cleanup.TestsShouldNotBePublicTest for classes that @Override defaults()\n-public class RewriteTestClassesShouldNotBePublic extends Recipe {\n-    @Override\n-    public String getDisplayName() {\n-        return \"RewriteTest classes should not be public\";\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return \"Remove the public modifier from classes that implement RewriteTest.\";\n-    }\n-\n-    @Override\n-    public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(\n-                new UsesType<>(\"org.openrewrite.test.RewriteTest\", true),\n-                new JavaIsoVisitor<ExecutionContext>() {\n-                    @Override\n-                    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {\n-                        J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);\n-                        if (TypeUtils.isAssignableTo(\"org.openrewrite.test.RewriteTest\", cd.getType()) &&\n-                            cd.getKind() != J.ClassDeclaration.Kind.Type.Interface &&\n-                            cd.getModifiers().stream().anyMatch(mod -> mod.getType() == J.Modifier.Type.Public) &&\n-                            cd.getModifiers().stream().noneMatch(mod -> mod.getType() == J.Modifier.Type.Abstract) &&\n-                            !hasPublicStaticFieldOrMethod(cd)) {\n-\n-                            // Remove public modifier and move associated comment\n-                            final List<Comment> modifierComments = new ArrayList<>();\n-                            List<J.Modifier> modifiers = ListUtils.map(cd.getModifiers(), mod -> {\n-                                if (mod.getType() == J.Modifier.Type.Public) {\n-                                    modifierComments.addAll(mod.getComments());\n-                                    return null;\n-                                }\n-                                // copy access level modifier comment to next modifier if it exists\n-                                if (!modifierComments.isEmpty()) {\n-                                    J.Modifier nextModifier = mod.withComments(ListUtils.concatAll(new ArrayList<>(modifierComments), mod.getComments()));\n-                                    modifierComments.clear();\n-                                    return nextModifier;\n-                                }\n-                                return mod;\n-                            });\n-                            // if no following modifier exists, add comments to method itself\n-                            if (!modifierComments.isEmpty()) {\n-                                cd = cd.withComments(ListUtils.concatAll(cd.getComments(), modifierComments));\n-                            }\n-                            cd = maybeAutoFormat(cd, cd.withModifiers(modifiers), cd.getName(), ctx, getCursor().getParentTreeCursor());\n-                        }\n-                        return cd;\n-                    }\n-\n-                    private boolean hasPublicStaticFieldOrMethod(J.ClassDeclaration cd) {\n-                        if (cd.getBody().getStatements().stream()\n-                                .filter(J.MethodDeclaration.class::isInstance)\n-                                .map(J.MethodDeclaration.class::cast)\n-                                .anyMatch(method -> method.hasModifier(J.Modifier.Type.Public) && method.hasModifier(J.Modifier.Type.Static))) {\n-                            return true;\n-                        }\n-                        return cd.getBody().getStatements().stream()\n-                                .filter(J.VariableDeclarations.class::isInstance)\n-                                .map(J.VariableDeclarations.class::cast)\n-                                .anyMatch(field -> field.hasModifier(J.Modifier.Type.Public) && field.hasModifier(J.Modifier.Type.Static));\n-\n-                    }\n-                }\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/SetDefaultEstimatedEffortPerOccurrence.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/SetDefaultEstimatedEffortPerOccurrence.java\ndeleted file mode 100644\nindex 8038ef4bc78..00000000000\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/SetDefaultEstimatedEffortPerOccurrence.java\n+++ /dev/null\n@@ -1,93 +0,0 @@\n-/*\n- * Copyright 2021 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.Preconditions;\n-import org.openrewrite.Recipe;\n-import org.openrewrite.TreeVisitor;\n-import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.JavaTemplate;\n-import org.openrewrite.java.search.UsesType;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.JavaType;\n-import org.openrewrite.java.tree.Statement;\n-import org.openrewrite.java.tree.TypeUtils;\n-\n-import java.text.ParseException;\n-import java.text.RuleBasedCollator;\n-import java.time.Duration;\n-import java.util.Comparator;\n-\n-public class SetDefaultEstimatedEffortPerOccurrence extends Recipe {\n-    @Override\n-    public String getDisplayName() {\n-        return \"Set default estimated effort\";\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return \"Retrofit recipes with a default estimated effort per occurrence.\";\n-    }\n-\n-    @Override\n-    public Duration getEstimatedEffortPerOccurrence() {\n-        return Duration.ofMinutes(1);\n-    }\n-\n-    @Override\n-    public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(new UsesType<>(\"org.openrewrite.Recipe\", false), new JavaIsoVisitor<ExecutionContext>() {\n-            final JavaTemplate addMethod = JavaTemplate.builder(\n-                            \"@Override public Duration getEstimatedEffortPerOccurrence() {\\n\" +\n-                            \"return Duration.ofMinutes(5);\\n\" +\n-                            \"}\")\n-                    .imports(\"java.time.Duration\")\n-                    .build();\n-\n-            @Override\n-            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {\n-                JavaType.FullyQualified type = TypeUtils.asFullyQualified(classDecl.getType());\n-                if (TypeUtils.isAssignableTo(\"org.openrewrite.Recipe\", type)) {\n-                    assert type != null;\n-                    for (Statement statement : classDecl.getBody().getStatements()) {\n-                        if (statement instanceof J.MethodDeclaration) {\n-                            J.MethodDeclaration method = (J.MethodDeclaration) statement;\n-                            if (\"getEstimatedEffortPerOccurrence\".equals(method.getSimpleName())) {\n-                                return classDecl;\n-                            }\n-                        }\n-                    }\n-\n-                    maybeAddImport(\"java.time.Duration\");\n-\n-                    try {\n-                        return addMethod.apply(\n-                                getCursor(),\n-                                classDecl.getBody().getCoordinates().addMethodDeclaration(Comparator.comparing(\n-                                        J.MethodDeclaration::getSimpleName,\n-                                        new RuleBasedCollator(\"< getDisplayName < getDescription < getEstimatedEffortPerOccurrence < getVisitor\")\n-                                ))\n-                        );\n-                    } catch (ParseException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-                return super.visitClassDeclaration(classDecl, ctx);\n-            }\n-        });\n-    }\n-}\n\ndiff --git a/rewrite-java/src/test/java/org/openrewrite/java/recipes/BlankLinesAroundFieldsWithAnnotationsTest.java b/rewrite-java/src/test/java/org/openrewrite/java/recipes/BlankLinesAroundFieldsWithAnnotationsTest.java\ndeleted file mode 100644\nindex e623263487d..00000000000\n--- a/rewrite-java/src/test/java/org/openrewrite/java/recipes/BlankLinesAroundFieldsWithAnnotationsTest.java\n+++ /dev/null\n@@ -1,63 +0,0 @@\n-/*\n- * Copyright 2024 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.junit.jupiter.api.Test;\n-import org.openrewrite.DocumentExample;\n-import org.openrewrite.test.RecipeSpec;\n-import org.openrewrite.test.RewriteTest;\n-\n-import static org.openrewrite.java.Assertions.java;\n-\n-class BlankLinesAroundFieldsWithAnnotationsTest implements RewriteTest {\n-\n-    @Override\n-    public void defaults(RecipeSpec spec) {\n-        spec.recipe(new BlankLinesAroundFieldsWithAnnotations());\n-    }\n-\n-    @Test\n-    @DocumentExample\n-    void spaceBetweenFields() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              class Test {\n-                  @Deprecated\n-                  int a;\n-                  int b;\n-                  @Deprecated\n-                  int c;\n-                  int d;\n-              }\n-              \"\"\",\n-            \"\"\"\n-              class Test {\n-                  @Deprecated\n-                  int a;\n-    \n-                  int b;\n-    \n-                  @Deprecated\n-                  int c;\n-    \n-                  int d;\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java/src/test/java/org/openrewrite/java/recipes/NoMutableStaticFieldsInRecipesTest.java b/rewrite-java/src/test/java/org/openrewrite/java/recipes/NoMutableStaticFieldsInRecipesTest.java\ndeleted file mode 100644\nindex a7612e1606c..00000000000\n--- a/rewrite-java/src/test/java/org/openrewrite/java/recipes/NoMutableStaticFieldsInRecipesTest.java\n+++ /dev/null\n@@ -1,91 +0,0 @@\n-/*\n- * Copyright 2024 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.junit.jupiter.api.Test;\n-import org.openrewrite.DocumentExample;\n-import org.openrewrite.java.JavaParser;\n-import org.openrewrite.test.RecipeSpec;\n-import org.openrewrite.test.RewriteTest;\n-\n-import static org.openrewrite.java.Assertions.java;\n-\n-class NoMutableStaticFieldsInRecipesTest implements RewriteTest {\n-\n-    @Override\n-    public void defaults(RecipeSpec spec) {\n-        spec\n-          .recipe(new NoMutableStaticFieldsInRecipes())\n-          .parser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()));\n-    }\n-\n-    @Test\n-    @DocumentExample\n-    void removeNonFinalStaticFields() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.Recipe;\n-              \n-              public class A extends Recipe {\n-                  static final int immutable = 0;\n-                  static int mutable = 0;\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.Recipe;\n-              \n-              public class A extends Recipe {\n-                  static final int immutable = 0;\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void retainFieldsOutsideRecipes() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.Recipe;\n-              \n-              public class A {\n-                  static final int immutable = 0;\n-                  static int mutable = 0;\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void retainWhenWarningsSuppressed() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.Recipe;\n-              \n-              public class A extends Recipe {\n-                  static final int immutable = 0;\n-                  @SuppressWarnings(\"unused\")\n-                  static int mutable = 0;\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java/src/test/java/org/openrewrite/java/recipes/RewriteTestClassesShouldNotBePublicTest.java b/rewrite-java/src/test/java/org/openrewrite/java/recipes/RewriteTestClassesShouldNotBePublicTest.java\ndeleted file mode 100644\nindex 56d974009dc..00000000000\n--- a/rewrite-java/src/test/java/org/openrewrite/java/recipes/RewriteTestClassesShouldNotBePublicTest.java\n+++ /dev/null\n@@ -1,141 +0,0 @@\n-/*\n- * Copyright 2024 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.junit.jupiter.api.Test;\n-import org.openrewrite.DocumentExample;\n-import org.openrewrite.java.JavaParser;\n-import org.openrewrite.test.RecipeSpec;\n-import org.openrewrite.test.RewriteTest;\n-\n-import static org.openrewrite.java.Assertions.java;\n-\n-class RewriteTestClassesShouldNotBePublicTest implements RewriteTest {\n-    @Override\n-    public void defaults(RecipeSpec spec) {\n-        spec.parser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()))\n-          .recipe(new RewriteTestClassesShouldNotBePublic());\n-    }\n-\n-    @Test\n-    @DocumentExample\n-    void rewriteTestThatOverridesDefaults() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.test.RecipeSpec;\n-              import org.openrewrite.test.RewriteTest;\n-              \n-              // org.openrewrite.java.testing.cleanup.TestsShouldNotBePublicTest skips classes that override defaults()\n-              public class ATest implements RewriteTest {\n-                  @Override\n-                  public void defaults(RecipeSpec spec) {\n-                  }\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.test.RecipeSpec;\n-              import org.openrewrite.test.RewriteTest;\n-\n-              // org.openrewrite.java.testing.cleanup.TestsShouldNotBePublicTest skips classes that override defaults()\n-              class ATest implements RewriteTest {\n-                  @Override\n-                  public void defaults(RecipeSpec spec) {\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void rewriteTestClassesNotPublic() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.test.RewriteTest;\n-              \n-              public class ATest implements RewriteTest {\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.test.RewriteTest;\n-\n-              class ATest implements RewriteTest {\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void noChangePublicStaticMethod() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.test.RewriteTest;\n-              \n-              public class ATest implements RewriteTest {\n-                  public static void helper() {}\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void noChangePublicStaticField() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.test.RewriteTest;\n-              \n-              public class ATest implements RewriteTest {\n-                  public static String helper = \"helper\";\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void noChangeNotPublic() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.test.RewriteTest;\n-\n-              class ATest implements RewriteTest {\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void noChangeNotRewriteTest() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              public class ATest {\n-                  void testMethod() {\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-java/src/test/java/org/openrewrite/java/recipes/UseTreeRandomIdTest.java b/rewrite-java/src/test/java/org/openrewrite/java/recipes/UseTreeRandomIdTest.java\ndeleted file mode 100644\nindex e1c821034d9..00000000000\n--- a/rewrite-java/src/test/java/org/openrewrite/java/recipes/UseTreeRandomIdTest.java\n+++ /dev/null\n@@ -1,114 +0,0 @@\n-/*\n- * Copyright 2024 the original author or authors.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * <p>\n- * https://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.openrewrite.java.recipes;\n-\n-import org.junit.jupiter.api.Test;\n-import org.openrewrite.DocumentExample;\n-import org.openrewrite.java.JavaParser;\n-import org.openrewrite.test.RecipeSpec;\n-import org.openrewrite.test.RewriteTest;\n-\n-import static org.openrewrite.java.Assertions.java;\n-\n-class UseTreeRandomIdTest implements RewriteTest {\n-    @Override\n-    public void defaults(RecipeSpec spec) {\n-        spec.recipe(new UseTreeRandomId())\n-          .parser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()));\n-    }\n-\n-    @Test\n-    @DocumentExample\n-    void replacesUUIDRandomId() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.java.tree.J;\n-              import org.openrewrite.java.tree.JavaType;\n-              import org.openrewrite.marker.Markers;\n-              import org.openrewrite.java.tree.Space;\n-              \n-              import java.util.UUID;\n-              import static java.util.UUID.randomUUID;\n-              \n-              class Foo {\n-                  void bar() {\n-                      J.Literal literal1 = new J.Literal(UUID.randomUUID(), Space.EMPTY, Markers.EMPTY, null, null, null, JavaType.Primitive.Boolean);\n-                      J.Literal literal2 = new J.Literal(randomUUID(), Space.EMPTY, Markers.EMPTY, null, null, null, JavaType.Primitive.Boolean);\n-                  }\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.Tree;\n-              import org.openrewrite.java.tree.J;\n-              import org.openrewrite.java.tree.JavaType;\n-              import org.openrewrite.marker.Markers;\n-              import org.openrewrite.java.tree.Space;\n-              \n-              class Foo {\n-                  void bar() {\n-                      J.Literal literal1 = new J.Literal(Tree.randomId(), Space.EMPTY, Markers.EMPTY, null, null, null, JavaType.Primitive.Boolean);\n-                      J.Literal literal2 = new J.Literal(Tree.randomId(), Space.EMPTY, Markers.EMPTY, null, null, null, JavaType.Primitive.Boolean);\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-\n-    @Test\n-    void doNotReplaceRegularUse() {\n-        rewriteRun(\n-          java(\n-            \"\"\"\n-              import org.openrewrite.java.tree.J;\n-              import org.openrewrite.java.tree.JavaType;\n-              import org.openrewrite.marker.Markers;\n-              import org.openrewrite.java.tree.Space;\n-              \n-              import java.util.UUID;\n-              \n-              class Foo {\n-                  Foo(UUID uuid) {}\n-              \n-                  void bar() {\n-                      J.Literal literal1 = new J.Literal(UUID.randomUUID(), Space.EMPTY, Markers.EMPTY, null, null, null, JavaType.Primitive.Boolean);\n-                      Foo untouched = new Foo(UUID.randomUUID());\n-                  }\n-              }\n-              \"\"\",\n-            \"\"\"\n-              import org.openrewrite.Tree;\n-              import org.openrewrite.java.tree.J;\n-              import org.openrewrite.java.tree.JavaType;\n-              import org.openrewrite.marker.Markers;\n-              import org.openrewrite.java.tree.Space;\n-              \n-              import java.util.UUID;\n-              \n-              class Foo {\n-                  Foo(UUID uuid) {}\n-              \n-                  void bar() {\n-                      J.Literal literal1 = new J.Literal(Tree.randomId(), Space.EMPTY, Markers.EMPTY, null, null, null, JavaType.Primitive.Boolean);\n-                      Foo untouched = new Foo(UUID.randomUUID());\n-                  }\n-              }\n-              \"\"\"\n-          )\n-        );\n-    }\n-}\n\ndiff --git a/rewrite-test/src/test/java/org/openrewrite/test/RecipePrinterTest.java b/rewrite-test/src/test/java/org/openrewrite/test/RecipePrinterTest.java\nindex 0fcf58c98dc..75bf2ef3ae6 100644\n--- a/rewrite-test/src/test/java/org/openrewrite/test/RecipePrinterTest.java\n+++ b/rewrite-test/src/test/java/org/openrewrite/test/RecipePrinterTest.java\n@@ -22,7 +22,6 @@\n import org.openrewrite.Option;\n import org.openrewrite.Recipe;\n import org.openrewrite.config.CompositeRecipe;\n-import org.openrewrite.java.recipes.SelectRecipeExamples;\n \n import java.util.Arrays;\n import java.util.Collections;\n@@ -42,19 +41,19 @@ void beforeEach() {\n     void printRecipeTreeForSimpleRecipe() {\n         rewriteRun(\n           spec -> spec\n-            .recipe(new SelectRecipeExamples())\n+            .recipe(new AnotherTestRecipe())\n             .printRecipe(() -> sb::append)\n         );\n \n-        assertThat(sb.toString()).isEqualTo(SelectRecipeExamples.class.getName() + System.lineSeparator());\n+        assertThat(sb.toString()).isEqualTo(AnotherTestRecipe.class.getName() + System.lineSeparator());\n     }\n \n     @Test\n     void printRecipeTreeForRecipeWithNestedRecipes() {\n         Recipe recipe = new CompositeRecipe(Arrays.asList(\n           new TestRecipe(\"the option\"),\n-          new SelectRecipeExamples(),\n-          new CompositeRecipe(Collections.singletonList(new SelectRecipeExamples()))\n+          new AnotherTestRecipe(),\n+          new CompositeRecipe(Collections.singletonList(new AnotherTestRecipe()))\n         ));\n         rewriteRun(\n           spec -> spec\n@@ -70,7 +69,7 @@ void printRecipeTreeForRecipeWithNestedRecipes() {\n           \"  %3$s%n\" +\n           \"  %1$s%n\" +\n           \"    %3$s%n\",\n-          CompositeRecipe.class.getName(), TestRecipe.class.getName(), SelectRecipeExamples.class.getName()\n+          CompositeRecipe.class.getName(), TestRecipe.class.getName(), AnotherTestRecipe.class.getName()\n         );\n \n         assertThat(output).isEqualTo(expected);\n@@ -95,4 +94,19 @@ public String getDescription() {\n             return \"Test recipe.\";\n         }\n     }\n+\n+    @Value\n+    @EqualsAndHashCode(callSuper = false)\n+    private static class AnotherTestRecipe extends Recipe {\n+\n+        @Override\n+        public String getDisplayName() {\n+            return \"Another Test recipe\";\n+        }\n+\n+        @Override\n+        public String getDescription() {\n+            return \"Another Test recipe.\";\n+        }\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5259",
    "pr_id": 5259,
    "issue_id": 5232,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Mojang/DataFixerUpper - GroovyParsingException: Failed to parse build.gradle\n\n## What version of OpenRewrite are you using?\nI am using\n\n- Gradle plugin 7.3.0\n- Java Dependencies 1.31.0\n\n## How are you running OpenRewrite?\n\nProject (note the old revision): https://github.com/Mojang/DataFixerUpper/blob/c100ef03c2ab321e5de4f25ffbe277e924aa7ca5/build.gradle\n\nrefactorings.yml:\n```\ntype: specs.openrewrite.org/v1beta/recipe\nname: com.example.MyRecipe\nrecipeList:\n- org.openrewrite.gradle.AddDependency: {groupId: org.mockito, artifactId: mockito-core,\n    version: 5.16.0, onlyIfUsing: '*..*', configuration: testImplementation}\n```\n\nrewrite.gradle:\n```\ninitscript {\n  repositories {\n    maven { url \"https://plugins.gradle.org/m2\" }\n  }\n  dependencies {\n    classpath(\"org.openrewrite.rewrite:org.openrewrite.rewrite.gradle.plugin:7.3.0\")\n  }\n}\n\nrootProject {\n  plugins.apply(org.openrewrite.gradle.RewritePlugin)\n\n  repositories {\n    maven { url \"https://plugins.gradle.org/m2\" }\n  }\n\n  dependencies {\n    rewrite(\"org.openrewrite.recipe:rewrite-java-dependencies:1.31.0\")\n  }\n\n  rewrite {\n    activeRecipe(\"com.example.MyRecipe\")\n    activeStyle(\"org.openrewrite.java.Autodetect\")\n    configFile = System.getProperty(\"configFile\")\n  }\n\n}\n```\n\nCommand: `./gradlew :rewriteRun --init-script=rewrite.gradle -DconfigFile=refactorings.yml --info`\n\n\n## What is the smallest, simplest way to reproduce the problem?\n\nThe above is as minimal as I've been able to get things, other than editing the original build.gradle.\n\n## What did you expect to see?\n\nThe mockito dependency added to `build.gradle`\n\n## What did you see instead?\n\nAn exception:\n```\n> Task :rewriteRun\nCaching disabled for task ':rewriteRun' because:\n  Build cache is disabled\nTask ':rewriteRun' is not up-to-date because:\n  Task has not declared any outputs despite executing actions.\nValidating active recipes\nScanning sources in project :\nUsing active styles []\nScanned 162 Java sources in :/main\nScanned 1 Java sources in :/test\nError during rewrite run\norg.openrewrite.groovy.GroovyParsingException: Failed to parse build.gradle, cursor position likely inaccurate.\n        at org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:204)\n        at org.openrewrite.groovy.GroovyParser.lambda$parseInputs$3(GroovyParser.java:147)\n...\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.listResults(DefaultProjectParser.java:1382)\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.run(DefaultProjectParser.java:420)\n        at org.openrewrite.gradle.DelegatingProjectParser.lambda$run$2(DelegatingProjectParser.java:115)\n        at org.openrewrite.gradle.DelegatingProjectParser.unwrapInvocationException(DelegatingProjectParser.java:164)\n        at org.openrewrite.gradle.DelegatingProjectParser.run(DelegatingProjectParser.java:114)\n        at org.openrewrite.gradle.RewriteRunTask.run(RewriteRunTask.java:36)\n...\nCaused by: java.lang.StringIndexOutOfBoundsException: String index out of range: -2\n        at java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n        at java.base/java.lang.String.charAt(String.java:1517)\n        at org.openrewrite.groovy.GroovyParserVisitor.sourceSubstring(GroovyParserVisitor.java:2448)\n        at org.openrewrite.groovy.GroovyParserVisitor.access$2500(GroovyParserVisitor.java:81)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitConstantExpression$3(GroovyParserVisitor.java:1261)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.insideParentheses(GroovyParserVisitor.java:660)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitConstantExpression(GroovyParserVisitor.java:1213)\n        at org.codehaus.groovy.ast.expr.ConstantExpression.visit(ConstantExpression.java:80)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitArgumentlistExpression(GroovyParserVisitor.java:740)\n        at org.codehaus.groovy.ast.expr.ArgumentListExpression.visit(ArgumentListExpression.java:73)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitMethodCallExpression$10(GroovyParserVisitor.java:1681)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.insideParentheses(GroovyParserVisitor.java:653)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitMethodCallExpression(GroovyParserVisitor.java:1606)\n        at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:76)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitDeclarationExpression(GroovyParserVisitor.java:1380)\n        at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:89)\n        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitExpressionStatement$6(GroovyParserVisitor.java:1421)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.labeled(GroovyParserVisitor.java:675)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitExpressionStatement(GroovyParserVisitor.java:1420)\n        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitBlockStatement(GroovyParserVisitor.java:989)\n        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitIfElse(GroovyParserVisitor.java:1501)\n        at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:41)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitBlockStatement(GroovyParserVisitor.java:989)\n        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitClosureExpression(GroovyParserVisitor.java:1183)\n        at org.codehaus.groovy.ast.expr.ClosureExpression.visit(ClosureExpression.java:46)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitArgumentlistExpression(GroovyParserVisitor.java:740)\n        at org.codehaus.groovy.ast.expr.ArgumentListExpression.visit(ArgumentListExpression.java:73)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitMethodCallExpression$10(GroovyParserVisitor.java:1681)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.insideParentheses(GroovyParserVisitor.java:653)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitMethodCallExpression(GroovyParserVisitor.java:1606)\n        at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:76)\n        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitExpressionStatement$6(GroovyParserVisitor.java:1421)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.labeled(GroovyParserVisitor.java:675)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitExpressionStatement(GroovyParserVisitor.java:1420)\n        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitBlockStatement(GroovyParserVisitor.java:989)\n        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitClosureExpression(GroovyParserVisitor.java:1183)\n        at org.codehaus.groovy.ast.expr.ClosureExpression.visit(ClosureExpression.java:46)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitArgumentlistExpression(GroovyParserVisitor.java:740)\n        at org.codehaus.groovy.ast.expr.ArgumentListExpression.visit(ArgumentListExpression.java:73)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitMethodCallExpression$10(GroovyParserVisitor.java:1681)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.insideParentheses(GroovyParserVisitor.java:653)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitMethodCallExpression(GroovyParserVisitor.java:1606)\n        at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:76)\n        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitExpressionStatement$6(GroovyParserVisitor.java:1421)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.labeled(GroovyParserVisitor.java:675)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitExpressionStatement(GroovyParserVisitor.java:1420)\n        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitBlockStatement(GroovyParserVisitor.java:989)\n        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitIfElse(GroovyParserVisitor.java:1504)\n        at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:41)\n        at org.openrewrite.groovy.GroovyParserVisitor.convertTopLevelStatement(GroovyParserVisitor.java:2148)\n        at org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:196)\n        ... 170 more\nThere were problems parsing some source files, run with --info to see full stack traces\nThere were problems parsing build.gradle\n```\n\n## What is the full stack trace of any errors you encountered?\n\nSee above for stack trace with java.base and org.gradle elements dropped.\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n\nDon't have active plans to contribute a fix but if there's some guidance available then am happy to consider it.",
    "issue_word_count": 1238,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/RealWorldGroovyTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/RealWorldGroovyTest.java"
    ],
    "base_commit": "13634b6467757a2226e91d020300db8651b6ef46",
    "head_commit": "2687e2220bb40f857ac6025b013a101cc8964a1d",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5259",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5259",
    "dockerfile": "",
    "pr_merged_at": "2025-04-06T15:35:17.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex a863ffb62b4..b4950680e8a 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -2442,6 +2442,25 @@ private boolean sourceStartsWith(String delimiter, String... optionalSuffixes) {\n         return false;\n     }\n \n+\n+    /**\n+     * Determines if the character at the specified {@code index} in the {@code source} is escaped.\n+     * A character is considered escaped if it is preceded by an odd number of consecutive backslashes.\n+     *\n+     * @param index The index in the string to check for escaping.\n+     *              This must be a valid index within the range of {@code source}.\n+     * @return {@code true} if the character at the given index is escaped, {@code false} otherwise.\n+     * @throws StringIndexOutOfBoundsException If the {@code index} is not within the valid range of the source string.\n+     */\n+    private boolean isEscaped(int index) {\n+        int backslashCount = 0;\n+        while (index >= 0 && source.charAt(index) == '\\\\') {\n+            backslashCount++;\n+            index--;\n+        }\n+        return backslashCount % 2 != 0;\n+    }\n+\n     /**\n      * Returns a string that is a part of this source. The substring begins at the specified beginIndex and extends until delimiter.\n      * The cursor will not be moved.\n@@ -2449,7 +2468,8 @@ private boolean sourceStartsWith(String delimiter, String... optionalSuffixes) {\n     private String sourceSubstring(int beginIndex, String untilDelim) {\n         int endIndex = source.indexOf(untilDelim, Math.max(beginIndex, cursor + untilDelim.length()));\n         // don't stop if last char is escaped.\n-        while (source.charAt(endIndex - 1) == '\\\\') {\n+        // Fixed potential infinite loop by correctly handling escaped delimiters in the source string.\n+        while (endIndex > 0 && isEscaped(endIndex - 1)) {\n             endIndex = source.indexOf(untilDelim, endIndex + 1);\n         }\n         return source.substring(beginIndex, endIndex);\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/RealWorldGroovyTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/RealWorldGroovyTest.java\nindex dbe952f113f..ac9ccf13429 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/RealWorldGroovyTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/RealWorldGroovyTest.java\n@@ -441,4 +441,16 @@ task distZip(type: Zip, dependsOn: [docsZip, schemaZip]) {\n           )\n         );\n     }\n+\n+    @Test\n+    void stringWithMultipleBackslashes() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              \"\".replaceAll('\\\\\\\\', '/')\n+              \"a\\\\b\".replaceAll('\\\\\\\\', '/')\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5253",
    "pr_id": 5253,
    "issue_id": 5236,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Parenthesised ConstructorCallExpression and ConstantExpressions failing to parse with Groovy 2\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using\n\n- OpenRewrite v8.49.0\n- Gradle plugin v7.3.0\n- rewrite-groovy v8.49.0\n- Gradle 6.9.1\n\n## How are you running OpenRewrite?\n<!--\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\nIs your project a single module or a multi-module project?\n\nCan you share your configuration so that we can rule out any configuration issues?\n\nIs your project public? If so, can you share a link to it?\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\n-->\nOriginally I found this bug whilst using the Gradle plugin with Gradle 6, but have since reproduced with a test.\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\nAdded the below to `GroovyParserTest` in the Groovy 2 test suite:\n```java\n    @Test\n    void shouldBeAbleToParseParenthesisedConstructorCallExpressions() {\n        rewriteRun(\n            groovy(\n                \"\"\"\n                (new BigDecimal(10))\n                \"\"\"\n            )\n        );\n    }\n\n    @Test\n    void shouldBeAbleToParseParenthesisedConstantExpressions() {\n        rewriteRun(\n                groovy(\n                        \"\"\"\n                        (100)\n                        \"\"\"\n                )\n        );\n    }\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\nThe tests pass.\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\nThe tests fail.\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n```\nexpected: \"(new BigDecimal(10))\"\n but was: \"new(10w BigDecimal(10))\"\n```\n```\nexpected: \"(100)\"\n but was: \"1000)\"\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\nYes\n",
    "issue_word_count": 528,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/groovy2Test/java/org/openrewrite/groovy/GroovyParserTest.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/groovy2Test/java/org/openrewrite/groovy/GroovyParserTest.java"
    ],
    "base_commit": "c08ea6273755822643bdb6d95e8350b50abf5be3",
    "head_commit": "9af9e5f34d2ed22ab4644ed23226cdbaad39d449",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5253",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5253",
    "dockerfile": "",
    "pr_merged_at": "2025-04-07T08:40:17.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex 03fa30c810e..828895b12e8 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -2459,14 +2459,27 @@ private String sourceSubstring(int beginIndex, String untilDelim) {\n         } else if (rawIpl instanceof Integer) {\n             // On Java 8 _INSIDE_PARENTHESES_LEVEL is a regular Integer\n             return (Integer) rawIpl;\n-        } else if (node instanceof MethodCallExpression && !isOlderThanGroovy3()) {\n-            // Only for groovy 3+, because lower versions do always return `-1` for objectExpression.lineNumber / objectExpression.columnNumber\n-            MethodCallExpression expr = (MethodCallExpression) node;\n-            return determineParenthesisLevel(expr, expr.getObjectExpression().getLineNumber(), expr.getLineNumber(), expr.getObjectExpression().getColumnNumber(), expr.getColumnNumber());\n-        } else if (node instanceof BinaryExpression) {\n-            BinaryExpression expr = (BinaryExpression) node;\n-            return determineParenthesisLevel(expr, expr.getLeftExpression().getLineNumber(), expr.getLineNumber(), expr.getLeftExpression().getColumnNumber(), expr.getColumnNumber());\n         }\n+\n+        if (isOlderThanGroovy3()) {\n+            if (node instanceof ConstantExpression) {\n+                ConstantExpression expr = (ConstantExpression) node;\n+                return determineParenthesisLevel(expr, expr.getLineNumber(), expr.getLastLineNumber(), expr.getColumnNumber(), expr.getLastColumnNumber());\n+            } else if (node instanceof ConstructorCallExpression) {\n+                ConstructorCallExpression expr = (ConstructorCallExpression) node;\n+                return determineParenthesisLevel(expr, expr.getArguments().getLineNumber(), expr.getLineNumber(), expr.getArguments().getColumnNumber(), expr.getColumnNumber()) - 1;\n+            } else if (node instanceof BinaryExpression) {\n+                BinaryExpression expr = (BinaryExpression) node;\n+                return determineParenthesisLevel(expr, expr.getLeftExpression().getLineNumber(), expr.getLineNumber(), expr.getLeftExpression().getColumnNumber(), expr.getColumnNumber());\n+            }\n+        } else {\n+            if (node instanceof MethodCallExpression) {\n+                // Only for groovy 3+, because lower versions do always return `-1` for objectExpression.lineNumber / objectExpression.columnNumber\n+                MethodCallExpression expr = (MethodCallExpression) node;\n+                return determineParenthesisLevel(expr, expr.getObjectExpression().getLineNumber(), expr.getLineNumber(), expr.getObjectExpression().getColumnNumber(), expr.getColumnNumber());\n+            }\n+        }\n+\n         return null;\n     }\n \n@@ -2514,7 +2527,7 @@ private int determineParenthesisLevel(ASTNode node, int childLineNumber, int par\n                 if (delimiter == null) {\n                     if (source.charAt(i) == '(') {\n                         count++;\n-                    } else if (source.charAt(i) == ')') {\n+                    } else if (source.charAt(i) == ')' && !(node instanceof ConstantExpression)) {\n                         count--;\n                     }\n                 } else {\n",
    "test_patch": "diff --git a/rewrite-groovy/src/groovy2Test/java/org/openrewrite/groovy/GroovyParserTest.java b/rewrite-groovy/src/groovy2Test/java/org/openrewrite/groovy/GroovyParserTest.java\nindex a0327125b3d..1b5ea5b105c 100644\n--- a/rewrite-groovy/src/groovy2Test/java/org/openrewrite/groovy/GroovyParserTest.java\n+++ b/rewrite-groovy/src/groovy2Test/java/org/openrewrite/groovy/GroovyParserTest.java\n@@ -45,4 +45,49 @@ void shouldHandleUsingSlashyStringsWithDivision() {\n                 )\n         );\n     }\n+\n+    @Test\n+    void shouldBeAbleToParseParenthesisedConstructorCallExpressions() {\n+        rewriteRun(\n+                groovy(\n+                        \"\"\"\n+                        (new BigDecimal(10))\n+                        \"\"\"\n+                )\n+        );\n+    }\n+\n+    @Test\n+    void shouldBeAbleToParseParenthesisedSlashyStringConstantExpressions() {\n+        rewriteRun(\n+                groovy(\n+                        \"\"\"\n+                        ((/test/))\n+                        \"\"\"\n+                )\n+        );\n+    }\n+\n+    @Test\n+    void shouldBeAbleToParseParenthesisedQuotedConstantExpressions() {\n+        rewriteRun(\n+                groovy(\n+                        \"\"\"\n+                        ((\"test\"))\n+                        \"\"\"\n+                )\n+        );\n+    }\n+\n+    @Test\n+    void shouldBeAbleToParseParenthesisedIntegerConstantExpressions() {\n+        rewriteRun(\n+                groovy(\n+                        \"\"\"\n+                        (100)\n+                        \"\"\"\n+                )\n+        );\n+    }\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5251",
    "pr_id": 5251,
    "issue_id": 5180,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Support for Groovy spaceship operator\n## What version of OpenRewrite are you using?\nI am using\n\n- OpenRewrite Plugin v7.2.0\n- Gradle plugin v8.13.1\n- rewrite-gradle v8.48.0\n\n## How are you running OpenRewrite?\n\nSingle module project. Using rewrite-gradle plugin\n\n## What is the smallest, simplest way to reproduce the problem?\n\nIn any `build.gradle` file, add the Groovy spaceship operator (<=>) in any form, like:\n\n\n```\next{\n    \"a\" <=> \"b\" ?: true\n}\n```\n\n## What did you expect to see?\nExpected rewrite plugin to successfully parse `build.gradle` file.\n\n## What did you see instead?\nReceive an error instead:\n```java\nThere were problems parsing some source files, run with --info to see full stack traces\nThere were problems parsing build.gradle\n```\n\n## Stack trace\n`Error during rewrite run\norg.openrewrite.groovy.GroovyParsingException: Failed to parse build.gradle at cursor position 1048. The next 10 characters in the original source are ` ?: true\n}`\n        at org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:209)\n        at org.openrewrite.groovy.GroovyParser.lambda$parseInputs$3(GroovyParser.java:147)\n        at java.base@17.0.12/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\n        at java.base@17.0.12/java.util.Collections$2.tryAdvance(Collections.java:4853)\n        at java.base@17.0.12/java.util.Collections$2.forEachRemaining(Collections.java:4861)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base@17.0.12/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\n        at java.base@17.0.12/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n        at java.base@17.0.12/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)\n        at java.base@17.0.12/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)\n        at java.base@17.0.12/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base@17.0.12/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base@17.0.12/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734)\n        at java.base@17.0.12/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base@17.0.12/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base@17.0.12/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base@17.0.12/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base@17.0.12/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base@17.0.12/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base@17.0.12/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base@17.0.12/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\n        at java.base@17.0.12/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n        at java.base@17.0.12/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)\n        at java.base@17.0.12/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n        at java.base@17.0.12/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.listResults(DefaultProjectParser.java:1378)\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.run(DefaultProjectParser.java:420)\n        at org.openrewrite.gradle.DelegatingProjectParser.lambda$run$2(DelegatingProjectParser.java:115)\n        at org.openrewrite.gradle.DelegatingProjectParser.unwrapInvocationException(DelegatingProjectParser.java:164)\n        at org.openrewrite.gradle.DelegatingProjectParser.run(DelegatingProjectParser.java:114)\n        at org.openrewrite.gradle.RewriteRunTask.run(RewriteRunTask.java:36)\n        at java.base@17.0.12/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at java.base@17.0.12/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n        at java.base@17.0.12/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.base@17.0.12/java.lang.reflect.Method.invoke(Method.java:569)\n        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:125)\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.doExecute(StandardTaskAction.java:58)\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:51)\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:29)\n        at org.gradle.api.internal.tasks.execution.TaskExecution$3.run(TaskExecution.java:244)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:29)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:26)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:166)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.run(DefaultBuildOperationRunner.java:47)\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeAction(TaskExecution.java:229)\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeActions(TaskExecution.java:212)\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeWithPreviousOutputFiles(TaskExecution.java:195)\n        at org.gradle.api.internal.tasks.execution.TaskExecution.execute(TaskExecution.java:162)\n        at org.gradle.internal.execution.steps.ExecuteStep.executeInternal(ExecuteStep.java:105)\n        at org.gradle.internal.execution.steps.ExecuteStep.access$000(ExecuteStep.java:44)\n        at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:59)\n        at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:56)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:209)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:166)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\n        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:56)\n        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:44)\n        at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:42)\n        at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:75)\n        at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:55)\n        at org.gradle.internal.execution.steps.PreCreateOutputParentsStep.execute(PreCreateOutputParentsStep.java:50)\n        at org.gradle.internal.execution.steps.PreCreateOutputParentsStep.execute(PreCreateOutputParentsStep.java:28)\n        at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:67)\n        at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:37)\n        at org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:61)\n        at org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:26)\n        at org.gradle.internal.execution.steps.CaptureOutputsAfterExecutionStep.execute(CaptureOutputsAfterExecutionStep.java:69)\n        at org.gradle.internal.execution.steps.CaptureOutputsAfterExecutionStep.execute(CaptureOutputsAfterExecutionStep.java:46)\n        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:40)\n        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:29)\n        at org.gradle.internal.execution.steps.BuildCacheStep.executeWithoutCache(BuildCacheStep.java:189)\n        at org.gradle.internal.execution.steps.BuildCacheStep.lambda$execute$1(BuildCacheStep.java:75)\n        at org.gradle.internal.Either$Right.fold(Either.java:175)\n        at org.gradle.internal.execution.caching.CachingState.fold(CachingState.java:62)\n        at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:73)\n        at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:48)\n        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:46)\n        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:35)\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:75)\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$2(SkipUpToDateStep.java:53)\n        at java.base@17.0.12/java.util.Optional.orElseGet(Optional.java:364)\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:53)\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:35)\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:37)\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:27)\n        at org.gradle.internal.execution.steps.ResolveIncrementalCachingStateStep.executeDelegate(ResolveIncrementalCachingStateStep.java:49)\n        at org.gradle.internal.execution.steps.ResolveIncrementalCachingStateStep.executeDelegate(ResolveIncrementalCachingStateStep.java:27)\n        at org.gradle.internal.execution.steps.AbstractResolveCachingStateStep.execute(AbstractResolveCachingStateStep.java:71)\n        at org.gradle.internal.execution.steps.AbstractResolveCachingStateStep.execute(AbstractResolveCachingStateStep.java:39)\n        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:65)\n        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:36)\n        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:107)\n        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:56)\n        at org.gradle.internal.execution.steps.AbstractCaptureStateBeforeExecutionStep.execute(AbstractCaptureStateBeforeExecutionStep.java:64)\n        at org.gradle.internal.execution.steps.AbstractCaptureStateBeforeExecutionStep.execute(AbstractCaptureStateBeforeExecutionStep.java:43)\n        at org.gradle.internal.execution.steps.AbstractSkipEmptyWorkStep.executeWithNonEmptySources(AbstractSkipEmptyWorkStep.java:125)\n        at org.gradle.internal.execution.steps.AbstractSkipEmptyWorkStep.execute(AbstractSkipEmptyWorkStep.java:56)\n        at org.gradle.internal.execution.steps.AbstractSkipEmptyWorkStep.execute(AbstractSkipEmptyWorkStep.java:36)\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:38)\n        at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:36)\n        at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:23)\n        at org.gradle.internal.execution.steps.HandleStaleOutputsStep.execute(HandleStaleOutputsStep.java:75)\n        at org.gradle.internal.execution.steps.HandleStaleOutputsStep.execute(HandleStaleOutputsStep.java:41)\n        at org.gradle.internal.execution.steps.AssignMutableWorkspaceStep.lambda$execute$0(AssignMutableWorkspaceStep.java:35)\n        at org.gradle.api.internal.tasks.execution.TaskExecution$4.withWorkspace(TaskExecution.java:289)\n        at org.gradle.internal.execution.steps.AssignMutableWorkspaceStep.execute(AssignMutableWorkspaceStep.java:31)\n        at org.gradle.internal.execution.steps.AssignMutableWorkspaceStep.execute(AssignMutableWorkspaceStep.java:22)\n        at org.gradle.internal.execution.steps.ChoosePipelineStep.execute(ChoosePipelineStep.java:40)\n        at org.gradle.internal.execution.steps.ChoosePipelineStep.execute(ChoosePipelineStep.java:23)\n        at org.gradle.internal.execution.steps.ExecuteWorkBuildOperationFiringStep.lambda$execute$2(ExecuteWorkBuildOperationFiringStep.java:67)\n        at java.base@17.0.12/java.util.Optional.orElseGet(Optional.java:364)\n        at org.gradle.internal.execution.steps.ExecuteWorkBuildOperationFiringStep.execute(ExecuteWorkBuildOperationFiringStep.java:67)\n        at org.gradle.internal.execution.steps.ExecuteWorkBuildOperationFiringStep.execute(ExecuteWorkBuildOperationFiringStep.java:39)\n        at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:46)\n        at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:34)\n        at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:48)\n        at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:35)\n        at org.gradle.internal.execution.impl.DefaultExecutionEngine$1.execute(DefaultExecutionEngine.java:61)\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:127)\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:116)\n        at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)\n        at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)\n        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)\n        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:74)\n        at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:209)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:166)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)\n        at org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:42)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:331)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:318)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.lambda$execute$0(DefaultTaskExecutionGraph.java:314)\n        at org.gradle.internal.operations.CurrentBuildOperationRef.with(CurrentBuildOperationRef.java:85)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:314)\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:303)\n        at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:459)\n        at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:376)\n        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)\n        at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:48)\n        at java.base@17.0.12/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\n        at java.base@17.0.12/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\n        at java.base@17.0.12/java.lang.Thread.run(Thread.java:840)\nCaused by: java.lang.IllegalStateException: Unknown binary expression BinaryExpression\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitBinaryExpression$1(GroovyParserVisitor.java:967)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.insideParentheses(GroovyParserVisitor.java:653)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitBinaryExpression(GroovyParserVisitor.java:819)\n        at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:58)\n        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBooleanExpression(CodeVisitorSupport.java:229)\n        at org.codehaus.groovy.ast.expr.BooleanExpression.visit(BooleanExpression.java:41)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitShortTernaryExpression$14(GroovyParserVisitor.java:1835)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.insideParentheses(GroovyParserVisitor.java:660)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitShortTernaryExpression(GroovyParserVisitor.java:1834)\n        at org.codehaus.groovy.ast.expr.ElvisOperatorExpression.visit(ElvisOperatorExpression.java:59)\n        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitExpressionStatement$6(GroovyParserVisitor.java:1421)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.labeled(GroovyParserVisitor.java:675)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitExpressionStatement(GroovyParserVisitor.java:1420)\n        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitBlockStatement(GroovyParserVisitor.java:989)\n        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitClosureExpression(GroovyParserVisitor.java:1183)\n        at org.codehaus.groovy.ast.expr.ClosureExpression.visit(ClosureExpression.java:46)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitArgumentlistExpression(GroovyParserVisitor.java:740)\n        at org.codehaus.groovy.ast.expr.ArgumentListExpression.visit(ArgumentListExpression.java:73)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:619)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitMethodCallExpression$10(GroovyParserVisitor.java:1681)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.insideParentheses(GroovyParserVisitor.java:653)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitMethodCallExpression(GroovyParserVisitor.java:1606)\n        at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:76)\n        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitExpressionStatement$6(GroovyParserVisitor.java:1421)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.labeled(GroovyParserVisitor.java:675)\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitExpressionStatement(GroovyParserVisitor.java:1420)\n        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\n        at org.openrewrite.groovy.GroovyParserVisitor.convertTopLevelStatement(GroovyParserVisitor.java:2148)\n        at org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:196)\n        ... 170 more\nThere were problems parsing some source files, run with --info to see full stack traces\nThere were problems parsing build.gradle`\n",
    "issue_word_count": 2618,
    "test_files_count": 2,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/tree/ExtTest.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/BinaryTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/tree/ExtTest.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/BinaryTest.java"
    ],
    "base_commit": "c08ea6273755822643bdb6d95e8350b50abf5be3",
    "head_commit": "defe1e7bed58b72246e460a9e2d7679302509780",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5251",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5251",
    "dockerfile": "",
    "pr_merged_at": "2025-04-04T06:49:01.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex 03fa30c810e..73ab5f91cd8 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -934,6 +934,9 @@ public void visitBinaryExpression(BinaryExpression binary) {\n                     case \"in\":\n                         gBinaryOp = G.Binary.Type.In;\n                         break;\n+                    case \"<=>\":\n+                        gBinaryOp = G.Binary.Type.Spaceship;\n+                        break;\n                 }\n \n                 cursor += binary.getOperation().getText().length();\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\nindex a87fe3389c0..8c8aab5c988 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\n@@ -148,6 +148,9 @@ public J visitBinary(G.Binary binary, PrintOutputCapture<P> p) {\n             case In:\n                 keyword = \"in\";\n                 break;\n+            case Spaceship:\n+                keyword = \"<=>\";\n+                break;\n         }\n         beforeSyntax(binary, GSpace.Location.BINARY_PREFIX, p);\n         visit(binary.getLeft(), p);\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java\nindex 982210b2e60..23b196bda0b 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/tree/G.java\n@@ -793,7 +793,8 @@ public enum Type {\n             Find,\n             Match,\n             In,\n-            Access\n+            Access,\n+            Spaceship\n         }\n \n         public Padding getPadding() {\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/tree/ExtTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/tree/ExtTest.java\nindex b2c6501960d..06c8b0ed702 100755\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/tree/ExtTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/tree/ExtTest.java\n@@ -36,4 +36,17 @@ void basicExt() {\n           )\n         );\n     }\n+\n+    @Test\n+    void extWithSpaceShip(){\n+        rewriteRun(\n+          buildGradle(\n+            \"\"\"\n+              ext{\n+                  \"a\" <=> \"b\" ?: true\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/BinaryTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/BinaryTest.java\nindex aca502d3571..0c564a2d26a 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/BinaryTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/BinaryTest.java\n@@ -261,4 +261,20 @@ def differenceInDays(int time) {\n           )\n         );\n     }\n+\n+    @Test\n+    void spaceShipOperator() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              def justPrint(){\n+                  println(1 <=> 2)\n+                  println('a' <=> 'z')\n+                  def a = 'tiger'\n+                  def b = 'cheetah'\n+                  println(a <=> b)\n+              }\n+              \"\"\"\n+          ));\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5247",
    "pr_id": 5247,
    "issue_id": 5177,
    "repo": "openrewrite/rewrite",
    "problem_statement": "YAML parser swallows a single character when Unicode is used\n## What version of OpenRewrite are you using?\n\nCurrent main = 27f7bd7172193860aed6dee3f807b3b687f1708a\n\n## What is the smallest, simplest way to reproduce the problem?\n\nThe following unit test case:\n```java\n    @Test\n    void unicodeCharacters() {\n        rewriteRun(\n          yaml(\n              \"\"\"\n                - name: Autobuild\n                # 📚COMMENT\n                - name: Perform CodeQL Analysis\n              \"\"\")\n        );\n    }\n```\nin `rewrite-yaml`\n\nfails with:\n```diff\n  - name: Autobuild\n  # 📚COMMENT\n- - name: Perform CodeQL Analysis\n+ - ame: Perform CodeQL Analysis\n```\n\n## Context\n\n- Extracted from real-life: https://github.com/jenkinsci/dimensionsscm-plugin/blob/510dc415363a64fb6334ebba4f9a1cd318010efe/.github/workflows/codeql-analysis.yml\n- Likely somehow related to: #4924 as it had similar symptoms",
    "issue_word_count": 93,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java"
    ],
    "base_commit": "e0f6566854796d34be715cc48ed58909ce2027b0",
    "head_commit": "7ade32c2976664623d14b5ac33a06eb5160b4d42",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5247",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5247",
    "dockerfile": "",
    "pr_merged_at": "2025-04-03T04:42:08.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\nindex 1a795e424ad..4133b36d1d2 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n@@ -245,6 +245,9 @@ private Yaml.Documents parseFromInput(Path sourceFile, EncodingDetectingInputStr\n                             tag = createTag(tagPrefix, Markers.EMPTY, tagName, tagSuffix);\n                         }\n \n+                        // Adjust `valueStart` by subtracting the count of supplementary Unicode characters in `fmt`.\n+                        valueStart -= fmt.codePoints().map(c -> Character.isSupplementaryCodePoint(c) ? 1 : 0).sum();\n+\n                         String scalarValue;\n                         switch (scalar.getScalarStyle()) {\n                             case DOUBLE_QUOTED:\n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\nindex badb146c095..dbd9d249d5f 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\n@@ -339,4 +339,68 @@ void parseFlowSequenceAtBufferBoundary() {\n           yaml(yaml)\n         );\n     }\n+\n+    @Test\n+    void withUnicodeCharacters() {\n+        rewriteRun(\n+          yaml(\n+            \"\"\"\n+            - name: Elephant\n+            - #🦍COMMENT: unicode\n+            - action: Do something\n+            \"\"\")\n+        );\n+    }\n+\n+    @Test\n+    void withUnicodeCharactersInSingleLine() {\n+        rewriteRun(\n+          yaml(\n+            \"\"\"\n+            - name: Elephant\n+            - #🦍COMMENT: 🐶unicode\n+            - action: Do something\n+            \"\"\")\n+        );\n+    }\n+\n+    @Test\n+    void withoutUnicodeCharacters() {\n+        rewriteRun(\n+          yaml(\n+            \"\"\"\n+            - name: Elephant\n+            - #COMMENT: unicode\n+            - action: Do something\n+            \"\"\")\n+        );\n+    }\n+\n+    @Test\n+    void withMultipleUnicodeCharacters() {\n+        rewriteRun(\n+          yaml(\n+            \"\"\"\n+            - name: Rat\n+            - #🐀COMMENT: unicode\n+            - color: Black\n+            - #🦍COMMENT: unicode\n+            - action: Escape\n+            \"\"\")\n+        );\n+    }\n+\n+    @Test\n+    void withMultipleUnicodeCharactersPerLine() {\n+        rewriteRun(\n+          yaml(\n+            \"\"\"\n+            - name: Rat\n+            - #🐀COMMENT: 🦍unicode\n+            - color: Black\n+            - #🦍COMMENT: 🎱unicode\n+            - action: Escape\n+            \"\"\")\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5243",
    "pr_id": 5243,
    "issue_id": 5217,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Enhance UseMavenCompilerPluginReleaseConfiguration Recipe to update the plugin configuration in profile section\n<!--\nThank you for suggesting an improvement to OpenRewrite!\nFeel free to delete any sections that don't apply to your request.\n-->\n## What problem are you trying to solve?\n\nThe current OpenRewrite recipe UseMavenCompilerPluginReleaseConfiguration only looks for the Maven Compiler Plugin configuration within the \"[/project/build//plugins](https://github.com/openrewrite/rewrite/blob/68de1e09beb07fc064ff5e4884729928ae28f3b5/rewrite-maven/src/main/java/org/openrewrite/maven/UseMavenCompilerPluginReleaseConfiguration.java#L36C75-L36C98)\" section of the pom.xml\n\nMaven allows plugin configurations to also be defined within \"[/project/profiles/profile/build/plugins]\" sections as well.\n\nThis means that if the compiler plugin configuration is in a profile, the OpenRewrite recipe will not find it and therefore won't update it.\n\n\n## Describe the solution you'd like\n\nModify the UseMavenCompilerPluginReleaseConfiguration recipe to also search for the Maven Compiler Plugin configuration within the \"[/project/profiles/profile/build/plugins]\" section of the pom.xml.\n\n## Have you considered any alternatives or workarounds?\n\nFlexibility for Consumers: Allow users of the recipe to provide a custom regular expression for the path to search. This would be a more general solution\n\n## Additional context\n<!-- Any thoughts that come to mind, or similar items on the backlog already. -->\n\n## Are you interested in [contributing this feature to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#new-features)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\n\nYes I can work on this further.",
    "issue_word_count": 250,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/UseMavenCompilerPluginReleaseConfiguration.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/UseMavenCompilerPluginReleaseConfigurationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/UseMavenCompilerPluginReleaseConfigurationTest.java"
    ],
    "base_commit": "d21bb4175596e935e94b287b68b6611b5d351a81",
    "head_commit": "430ff0c20c84307b502d29fa0f4485263cc809fc",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5243",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5243",
    "dockerfile": "",
    "pr_merged_at": "2025-04-04T16:07:15.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/UseMavenCompilerPluginReleaseConfiguration.java b/rewrite-maven/src/main/java/org/openrewrite/maven/UseMavenCompilerPluginReleaseConfiguration.java\nindex c126accf448..129e3e55e92 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/UseMavenCompilerPluginReleaseConfiguration.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/UseMavenCompilerPluginReleaseConfiguration.java\n@@ -33,7 +33,7 @@\n @Value\n @EqualsAndHashCode(callSuper = false)\n public class UseMavenCompilerPluginReleaseConfiguration extends Recipe {\n-    private static final XPathMatcher PLUGINS_MATCHER = new XPathMatcher(\"/project/build//plugins\");\n+    private static final XPathMatcher PLUGINS_MATCHER = new XPathMatcher(\"/project//build//plugins\");\n \n     @Option(\n             displayName = \"Release version\",\n@@ -87,11 +87,9 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                         child -> !(\"source\".equals(child.getName()) || \"target\".equals(child.getName())));\n                 String releaseVersionValue = hasJavaVersionProperty(getCursor().firstEnclosingOrThrow(Xml.Document.class)) ?\n                         \"${java.version}\" : releaseVersion.toString();\n-                updated = addOrUpdateChild(updated, compilerPluginConfig,\n+                return addOrUpdateChild(updated, compilerPluginConfig,\n                         Xml.Tag.build(\"<release>\" + releaseVersionValue + \"</release>\"), getCursor().getParentOrThrow());\n-                return updated;\n             }\n-\n         };\n     }\n \n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/UseMavenCompilerPluginReleaseConfigurationTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/UseMavenCompilerPluginReleaseConfigurationTest.java\nindex ce23a97daa5..468b1226da7 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/UseMavenCompilerPluginReleaseConfigurationTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/UseMavenCompilerPluginReleaseConfigurationTest.java\n@@ -558,4 +558,65 @@ void pluginManagement() {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5217\")\n+    @Test\n+    void replacesSourceAndTargetConfig_InProfileSection() {\n+        rewriteRun(\n+          //language=xml\n+          pomXml(\n+            \"\"\"\n+              <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+              <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                <modelVersion>4.0.0</modelVersion>\n+                <groupId>org.sample</groupId>\n+                <artifactId>sample</artifactId>\n+                <version>1.0.0</version>\n+                <profiles>\n+                  <profile>\n+                    <build>\n+                      <plugins>\n+                        <plugin>\n+                          <groupId>org.apache.maven.plugins</groupId>\n+                          <artifactId>maven-compiler-plugin</artifactId>\n+                          <version>3.8.0</version>\n+                          <configuration>\n+                            <source>1.8</source>\n+                            <target>1.8</target>\n+                          </configuration>\n+                        </plugin>\n+                      </plugins>\n+                    </build>\n+                  </profile>\n+                </profiles>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+              <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                <modelVersion>4.0.0</modelVersion>\n+                <groupId>org.sample</groupId>\n+                <artifactId>sample</artifactId>\n+                <version>1.0.0</version>\n+                <profiles>\n+                  <profile>\n+                    <build>\n+                      <plugins>\n+                        <plugin>\n+                          <groupId>org.apache.maven.plugins</groupId>\n+                          <artifactId>maven-compiler-plugin</artifactId>\n+                          <version>3.8.0</version>\n+                          <configuration>\n+                            <release>11</release>\n+                          </configuration>\n+                        </plugin>\n+                      </plugins>\n+                    </build>\n+                  </profile>\n+                </profiles>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5226",
    "pr_id": 5226,
    "issue_id": 5199,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Idempotency issue with Java parser when no space between modifier and annotation: `private@Annotation`\n## What version of OpenRewrite are you using?\n\nCurrent main = 45ca3c98d074f7434f8d4aec781228619b21313d\n\n## What is the smallest, simplest way to reproduce the problem?\n```java\n    @Test\n    void modifierNoSpaceThenAnnotation() {\n        rewriteRun(\n          java(\n            \"\"\"\n            public class Main {\n              public@jdk.jfr.Name(\"A\") static void main(String[] argv) {\n               System.out.println(\"A\");\n              }\n            }\n            \"\"\"\n          )\n        );\n    }\n```\n\n## What did you expect to see?\nno change\n\n## What did you see instead?\n```diff\n- public@jdk.jfr.Name(\"A\") static void main(String[] argv) {\n+ @jdklic@jdk.jfr.Name(\"A\") void main(String[] argv) {\n```\n\n## Context\n\nInspired by real-life: https://github.com/hivemq/hivemq-community-edition/blob/f13006a4206ebaba44379911b22c6ff571e7b746/src/main/java/com/hivemq/mqtt/services/PublishDistributorImpl.java#L210",
    "issue_word_count": 114,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java"
    ],
    "base_commit": "de929fcacf1bc597954c8ede49837954857e0a9b",
    "head_commit": "48688197e9036240cc93a18da995f4ba014a4600",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5226",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5226",
    "dockerfile": "",
    "pr_merged_at": "2025-04-01T07:52:58.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\nindex b8a933ec410..331ae90f16c 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n@@ -2117,6 +2117,8 @@ private ReloadableJava11ModifierResults sortedModifiersAndAnnotations(ModifiersT\n         final AtomicReference<String> word = new AtomicReference<>(\"\");\n         int afterLastModifierPosition = cursor;\n         int lastAnnotationPosition = cursor;\n+        boolean noSpace = false;\n+\n         for (int i = cursor; i < source.length(); i++) {\n             if (annotationPosTable.containsKey(i)) {\n                 JCAnnotation jcAnnotation = annotationPosTable.get(i);\n@@ -2148,7 +2150,12 @@ private ReloadableJava11ModifierResults sortedModifiersAndAnnotations(ModifiersT\n             } else if (inComment && c == '\\n' || c == '\\r') {\n                 inComment = false;\n             } else if (!inMultilineComment && !inComment) {\n-                if (Character.isWhitespace(c)) {\n+                // Check: char is whitespace OR next char is an `@` (which is an annotation preceded by modifier/annotation without space)\n+                if (Character.isWhitespace(c) || (noSpace = (i + 1 < source.length() && source.charAt(i + 1) == '@'))) {\n+                    if (noSpace) {\n+                        word.getAndUpdate(w -> w + c);\n+                        noSpace = false;\n+                    }\n                     if (!word.get().isEmpty()) {\n                         Modifier matching = null;\n                         for (Modifier modifier : modifiers.getFlags()) {\n@@ -2248,7 +2255,8 @@ private List<J.Annotation> collectAnnotations(Map<Integer, JCAnnotation> annotat\n                     continue;\n                 }\n                 annotations.add(convert(jcAnnotation));\n-                i = cursor;\n+                // Adjusting the index by subtracting 1 to account for the case where annotations are not separated by a space\n+                i = cursor - 1;\n                 continue;\n             }\n             char c = source.charAt(i);\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex d1342026835..675bd5f2ad7 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -2209,6 +2209,7 @@ private ReloadableJava17ModifierResults sortedModifiersAndAnnotations(ModifiersT\n         boolean inMultilineComment = false;\n         int afterLastModifierPosition = cursor;\n         int lastAnnotationPosition = cursor;\n+        boolean noSpace = false;\n \n         int keywordStartIdx = -1;\n         for (int i = cursor; i < source.length(); i++) {\n@@ -2242,9 +2243,10 @@ private ReloadableJava17ModifierResults sortedModifiersAndAnnotations(ModifiersT\n             } else if (inComment && c == '\\n' || c == '\\r') {\n                 inComment = false;\n             } else if (!inMultilineComment && !inComment) {\n-                if (Character.isWhitespace(c)) {\n+                // Check: char is whitespace OR next char is an `@` (which is an annotation preceded by modifier/annotation without space)\n+                if (Character.isWhitespace(c) || (noSpace = (i + 1 < source.length() && source.charAt(i + 1) == '@'))) {\n                     if (keywordStartIdx != -1) {\n-                        Modifier matching = MODIFIER_BY_KEYWORD.get(source.substring(keywordStartIdx, i));\n+                        Modifier matching = MODIFIER_BY_KEYWORD.get(source.substring(keywordStartIdx, noSpace ? i + 1 : i));\n                         keywordStartIdx = -1;\n \n                         if (matching == null) {\n@@ -2342,7 +2344,8 @@ private List<J.Annotation> collectAnnotations(Map<Integer, JCAnnotation> annotat\n                     continue;\n                 }\n                 annotations.add(convert(jcAnnotation));\n-                i = cursor;\n+                // Adjusting the index by subtracting 1 to account for the case where annotations are not separated by a space\n+                i = cursor - 1;\n                 continue;\n             }\n             char c = source.charAt(i);\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex ef361164f9a..4fbb0306fd8 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -2235,6 +2235,7 @@ private ReloadableJava21ModifierResults sortedModifiersAndAnnotations(ModifiersT\n         boolean inMultilineComment = false;\n         int afterLastModifierPosition = cursor;\n         int lastAnnotationPosition = cursor;\n+        boolean noSpace = false;\n \n         int keywordStartIdx = -1;\n         for (int i = cursor; i < source.length(); i++) {\n@@ -2268,9 +2269,10 @@ private ReloadableJava21ModifierResults sortedModifiersAndAnnotations(ModifiersT\n             } else if (inComment && c == '\\n' || c == '\\r') {\n                 inComment = false;\n             } else if (!inMultilineComment && !inComment) {\n-                if (Character.isWhitespace(c)) {\n+                // Check: char is whitespace OR next char is an `@` (which is an annotation preceded by modifier/annotation without space)\n+                if (Character.isWhitespace(c) || (noSpace = (i + 1 < source.length() && source.charAt(i + 1) == '@'))) {\n                     if (keywordStartIdx != -1) {\n-                        Modifier matching = MODIFIER_BY_KEYWORD.get(source.substring(keywordStartIdx, i));\n+                        Modifier matching = MODIFIER_BY_KEYWORD.get(source.substring(keywordStartIdx, noSpace ? i + 1 : i));\n                         keywordStartIdx = -1;\n \n                         if (matching == null) {\n@@ -2368,7 +2370,8 @@ private List<J.Annotation> collectAnnotations(Map<Integer, JCAnnotation> annotat\n                     continue;\n                 }\n                 annotations.add(convert(jcAnnotation));\n-                i = cursor;\n+                // Adjusting the index by subtracting 1 to account for the case where annotations are not separated by a space\n+                i = cursor - 1;\n                 continue;\n             }\n             char c = source.charAt(i);\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\nindex f27c34b48cb..5e0ca5fde39 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n@@ -2113,6 +2113,8 @@ private Java8ModifierResults sortedModifiersAndAnnotations(ModifiersTree modifie\n         final AtomicReference<String> word = new AtomicReference<>(\"\");\n         int afterLastModifierPosition = cursor;\n         int lastAnnotationPosition = cursor;\n+        boolean noSpace = false;\n+\n         for (int i = cursor; i < source.length(); i++) {\n             if (annotationPosTable.containsKey(i)) {\n                 JCAnnotation jcAnnotation = annotationPosTable.get(i);\n@@ -2144,7 +2146,12 @@ private Java8ModifierResults sortedModifiersAndAnnotations(ModifiersTree modifie\n             } else if (inComment && c == '\\n' || c == '\\r') {\n                 inComment = false;\n             } else if (!inMultilineComment && !inComment) {\n-                if (Character.isWhitespace(c)) {\n+                // Check: char is whitespace OR next char is an `@` (which is an annotation preceded by modifier/annotation without space)\n+                if (Character.isWhitespace(c) || (noSpace = (i + 1 < source.length() && source.charAt(i + 1) == '@'))) {\n+                    if (noSpace) {\n+                        word.getAndUpdate(w -> w + c);\n+                        noSpace = false;\n+                    }\n                     if (!word.get().isEmpty()) {\n                         Modifier matching = null;\n                         for (Modifier modifier : modifiers.getFlags()) {\n@@ -2244,7 +2251,8 @@ private List<J.Annotation> collectAnnotations(Map<Integer, JCAnnotation> annotat\n                     continue;\n                 }\n                 annotations.add(convert(jcAnnotation));\n-                i = cursor;\n+                // Adjusting the index by subtracting 1 to account for the case where annotations are not separated by a space\n+                i = cursor - 1;\n                 continue;\n             }\n             char c = source.charAt(i);\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java\nindex ba248552bdb..01ac166b35c 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java\n@@ -543,4 +543,116 @@ class Test {\n           )\n         );\n     }\n+\n+    @Test\n+    void modifierNoSpaceThenAnnotation() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              public class A {\n+                  public@jdk.jfr.Name(\"A\") void test() {\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void modifierWithMultipleSpaceThenAnnotation() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              public class A {\n+                  public   @jdk.jfr.Name(\"A\") void test() {\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void modifierWithMultipleSpaceThenAnnotationScenario2() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              public class A {\n+                  public    @jdk.jfr.Name(\"A\") static   @jdk.jfr.Label(\"2nd\") void test() {\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void modifierNoSpaceThenAnnotationScenario2() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              public class A {\n+                  public@jdk.jfr.Name(\"A\") static@jdk.jfr.Label(\"2nd\") void test() {\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void modifierNoSpaceThenAnnotationScenario3() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              public class A {\n+                  public@jdk.jfr.Name(\"A\")   static  @jdk.jfr.Label(\"2nd\") void test() {\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void modifierNoSpaceThenMultipleAnnotation() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              public class A {\n+                  public@jdk.jfr.Name(\"A\")@jdk.jfr.Label(\"test\") void test() {\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void multipleModifiersNoSpaceThenAnnotation() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              public class A {\n+                  public static@jdk.jfr.Name(\"A\") void test() {\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void modifierWithSpaceThenAnnotation() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              public class A {\n+                  public static @jdk.jfr.Name(\"A\") void test() {\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5225",
    "pr_id": 5225,
    "issue_id": 5224,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ReplaceConstantWithAnotherConstant not work when import is conflict\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using the latest rewrite (8.48.1)\n\n## How are you running OpenRewrite?\n<!--\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\nIs your project a single module or a multi-module project?\n\nCan you share your configuration so that we can rule out any configuration issues?\n\nIs your project public? If so, can you share a link to it?\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\n-->\nI am using the Maven plugin, and my project is a single module project.\n```shell\nmvn org.openrewrite.maven:rewrite-maven-plugin:run ...\n```\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\n\nRun this test, it will failed, because currently we didn't consider the import conflict. For this case, already has a `foo1.Bar` so we cannot add another `foo2.Bar`\n\n```java\n@Test\nvoid shouldFullyQualifyWhenNewTypeIsAmbiguous() {\n    rewriteRun(\n      spec -> spec.recipe(new ReplaceConstantWithAnotherConstant(\"foo1.Bar.QUX1\", \"foo2.Bar.QUX1\")),\n      java(\n        \"\"\"\n          package foo1;\n\n          public class Bar {\n              public static final String QUX1 = \"QUX1_FROM_FOO1\";\n              public static final String QUX2 = \"QUX1_FROM_FOO2\";\n          }\n          \"\"\"\n      ),\n      java(\n        \"\"\"\n          package foo2;\n\n          public class Bar {\n              public static final String QUX1 = \"QUX1_FROM_FOO1\";\n          }\n          \"\"\"\n      ),\n      java(\n        \"\"\"\n          import foo1.Bar;\n\n          class Test {\n              void a() {\n                  System.out.println(Bar.QUX1);\n                  System.out.println(Bar.QUX2);\n              }\n          }\n          \"\"\",\n        \"\"\"\n          import foo1.Bar;\n\n          class Test {\n              void a() {\n                  System.out.println(foo2.Bar.QUX1);\n                  System.out.println(Bar.QUX2);\n              }\n          }\n          \"\"\"\n      )\n    );\n}\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\n```java\nimport foo1.Bar;\n\nclass Test {\n    void a() {\n        System.out.println(foo2.Bar.QUX1);\n        System.out.println(Bar.QUX2);\n    }\n}\n```\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\n```java\nimport foo1.Bar;\nimport foo2.Bar;\n\nclass Test {\n    void a() {\n        System.out.println(Bar.QUX1);\n        System.out.println(Bar.QUX2);\n    }\n}\n```\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n```\nUnexpected result in \"Test.java\":\ndiff --git a/Test.java b/Test.java\nindex 58f9eb2..67b9d58 100644\n--- a/Test.java\n+++ b/Test.java\n@@ -1,8 +1,9 @@ \n import foo1.Bar;\n+import foo2.Bar;\n \n class Test {\n     void a() {\n-        System.out.println(foo2.Bar.QUX1);\n+        System.out.println(Bar.QUX1);\n         System.out.println(Bar.QUX2);\n     }\n }\n\\ No newline at end of file\n] \nexpected: \n  \"import foo1.Bar;\n  \n  class Test {\n      void a() {\n          System.out.println(foo2.Bar.QUX1);\n          System.out.println(Bar.QUX2);\n      }\n  }\"\n but was: \n  \"import foo1.Bar;\n  import foo2.Bar;\n  \n  class Test {\n      void a() {\n          System.out.println(Bar.QUX1);\n          System.out.println(Bar.QUX2);\n      }\n  }\"\n<Click to see difference>\n\n\n\tat org.openrewrite.test.RewriteTest.assertContentEquals(RewriteTest.java:621)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:510)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:130)\n\tat org.openrewrite.java.ReplaceConstantWithAnotherConstantTest.shouldFullyQualifyWhenNewTypeIsAmbiguous(ReplaceConstantWithAnotherConstantTest.java:281)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\nSure.\n",
    "issue_word_count": 792,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ReplaceConstantWithAnotherConstantTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ReplaceConstantWithAnotherConstantTest.java"
    ],
    "base_commit": "74a6d19e57b0b53ad1814ed28f0536858178ce16",
    "head_commit": "8d2fc5ddce49b5a5579ae8217afb58c71e3edd9c",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5225",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5225",
    "dockerfile": "",
    "pr_merged_at": "2025-04-22T23:24:56.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java b/rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java\nindex 03c82362440..80b86ea8964 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java\n@@ -20,10 +20,7 @@\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n import org.openrewrite.java.search.UsesType;\n-import org.openrewrite.java.tree.Expression;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.JavaType;\n-import org.openrewrite.java.tree.TypeUtils;\n+import org.openrewrite.java.tree.*;\n \n @Value\n @EqualsAndHashCode(callSuper = false)\n@@ -57,13 +54,17 @@ private static class ReplaceConstantWithAnotherConstantVisitor extends JavaVisit\n \n         private final String existingOwningType;\n         private final String constantName;\n+        private final JavaType.FullyQualified existingOwningTypeFqn;\n         private final JavaType.FullyQualified newOwningType;\n+        private final JavaType.FullyQualified newTargetType;\n         private final String newConstantName;\n \n         public ReplaceConstantWithAnotherConstantVisitor(String existingFullyQualifiedConstantName, String fullyQualifiedConstantName) {\n             this.existingOwningType = existingFullyQualifiedConstantName.substring(0, existingFullyQualifiedConstantName.lastIndexOf('.'));\n             this.constantName = existingFullyQualifiedConstantName.substring(existingFullyQualifiedConstantName.lastIndexOf('.') + 1);\n+            this.existingOwningTypeFqn = JavaType.ShallowClass.build(existingOwningType);\n             this.newOwningType = JavaType.ShallowClass.build(fullyQualifiedConstantName.substring(0, fullyQualifiedConstantName.lastIndexOf('.')));\n+            this.newTargetType = JavaType.ShallowClass.build(fullyQualifiedConstantName);\n             this.newConstantName = fullyQualifiedConstantName.substring(fullyQualifiedConstantName.lastIndexOf('.') + 1);\n         }\n \n@@ -71,7 +72,8 @@ public ReplaceConstantWithAnotherConstantVisitor(String existingFullyQualifiedCo\n         public J visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {\n             JavaType.Variable fieldType = fieldAccess.getName().getFieldType();\n             if (isConstant(fieldType)) {\n-                return replaceFieldAccess(fieldAccess, fieldType);\n+                JavaSourceFile sf = getCursor().firstEnclosing(JavaSourceFile.class);\n+                return replaceFieldAccess(fieldAccess, fieldType, hasNoConflictingImport(sf));\n             }\n             return super.visitFieldAccess(fieldAccess, ctx);\n         }\n@@ -80,12 +82,13 @@ public J visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {\n         public J visitIdentifier(J.Identifier ident, ExecutionContext ctx) {\n             JavaType.Variable fieldType = ident.getFieldType();\n             if (isConstant(fieldType)) {\n-                return replaceFieldAccess(ident, fieldType);\n+                JavaSourceFile sf = getCursor().firstEnclosing(JavaSourceFile.class);\n+                return replaceFieldAccess(ident, fieldType, hasNoConflictingImport(sf));\n             }\n             return super.visitIdentifier(ident, ctx);\n         }\n \n-        private J replaceFieldAccess(Expression expression, JavaType.Variable fieldType) {\n+        private J replaceFieldAccess(Expression expression, JavaType.Variable fieldType, boolean hasNoConflictingImport) {\n             JavaType owner = fieldType.getOwner();\n             while (owner instanceof JavaType.FullyQualified) {\n                 maybeRemoveImport(((JavaType.FullyQualified) owner).getFullyQualifiedName());\n@@ -93,23 +96,29 @@ private J replaceFieldAccess(Expression expression, JavaType.Variable fieldType)\n             }\n \n             if (expression instanceof J.Identifier) {\n-                maybeAddImport(newOwningType.getFullyQualifiedName(), newConstantName, false);\n+                String realName = hasNoConflictingImport ? newConstantName : newTargetType.getFullyQualifiedName();\n+                if (hasNoConflictingImport) {\n+                    maybeAddImport(newOwningType.getFullyQualifiedName(), newConstantName, false);\n+                }\n                 J.Identifier identifier = (J.Identifier) expression;\n                 return identifier\n-                        .withSimpleName(newConstantName)\n-                        .withFieldType(fieldType.withOwner(newOwningType).withName(newConstantName));\n+                        .withSimpleName(realName)\n+                        .withFieldType(fieldType.withOwner(newOwningType).withName(realName));\n             } else if (expression instanceof J.FieldAccess) {\n-                maybeAddImport(newOwningType.getFullyQualifiedName(), false);\n+                if (hasNoConflictingImport) {\n+                    maybeAddImport(newOwningType.getFullyQualifiedName(), false);\n+                }\n                 J.FieldAccess fieldAccess = (J.FieldAccess) expression;\n                 Expression target = fieldAccess.getTarget();\n                 J.Identifier name = fieldAccess.getName();\n+                String realName = hasNoConflictingImport ? newOwningType.getClassName() : newOwningType.getFullyQualifiedName();\n                 if (target instanceof J.Identifier) {\n-                    target = ((J.Identifier) target).withType(newOwningType).withSimpleName(newOwningType.getClassName());\n+                    target = ((J.Identifier) target).withType(newOwningType).withSimpleName(realName);\n                     name = name\n                             .withFieldType(fieldType.withOwner(newOwningType).withName(newConstantName))\n                             .withSimpleName(newConstantName);\n                 } else {\n-                    target = (((J.FieldAccess) target).getName()).withType(newOwningType).withSimpleName(newOwningType.getClassName());\n+                    target = (((J.FieldAccess) target).getName()).withType(newOwningType).withSimpleName(realName);\n                     name = name\n                             .withFieldType(fieldType.withOwner(newOwningType).withName(newConstantName))\n                             .withSimpleName(newConstantName);\n@@ -125,5 +134,35 @@ private boolean isConstant(JavaType.@Nullable Variable varType) {\n             return varType != null && TypeUtils.isOfClassType(varType.getOwner(), existingOwningType) &&\n                     varType.getName().equals(constantName);\n         }\n+\n+        private boolean hasNoConflictingImport(@Nullable JavaSourceFile sf) {\n+            return hasNoConflictingImport(sf, newOwningType) && hasNoConflictingImport(sf, newTargetType);\n+        }\n+\n+        private boolean hasNoConflictingImport(@Nullable JavaSourceFile sf, JavaType.FullyQualified targetType) {\n+            if (sf == null || targetType == null) {\n+                return true;\n+            }\n+\n+            for (J.Import anImport : sf.getImports()) {\n+                if (anImport.isStatic()) {\n+                    JavaType.FullyQualified fqn = TypeUtils.asFullyQualified(anImport.getQualid().getTarget().getType());\n+                    if (anImport.getQualid().getSimpleName().equals(newConstantName) && !TypeUtils.isOfClassType(fqn, newOwningType.getFullyQualifiedName())) {\n+                        if (!anImport.getQualid().getSimpleName().equals(constantName) || !TypeUtils.isOfClassType(fqn, existingOwningTypeFqn.getFullyQualifiedName())) {\n+                            return false;\n+                        }\n+                    }\n+                } else {\n+                    JavaType.FullyQualified currType = TypeUtils.asFullyQualified(anImport.getQualid().getType());\n+                    if (currType != null &&\n+                            !TypeUtils.isOfType(currType, targetType) &&\n+                            currType.getClassName().equals(targetType.getClassName())) {\n+                        return false;\n+                    }\n+                }\n+\n+            }\n+            return true;\n+        }\n     }\n }\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/ReplaceConstantWithAnotherConstantTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/ReplaceConstantWithAnotherConstantTest.java\nindex f2c8f913c21..e252ca5478a 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/ReplaceConstantWithAnotherConstantTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/ReplaceConstantWithAnotherConstantTest.java\n@@ -275,4 +275,157 @@ void a() {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5224\")\n+    void shouldFullyQualifyWhenNewTypeIsAmbiguous() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ReplaceConstantWithAnotherConstant(\"foo1.Bar.QUX1\", \"foo2.Bar.QUX1\")),\n+          java(\n+            \"\"\"\n+              package foo1;\n+\n+              public class Bar {\n+                  public static final String QUX1 = \"QUX1_FROM_FOO1\";\n+                  public static final String QUX2 = \"QUX1_FROM_FOO2\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              package foo2;\n+\n+              public class Bar {\n+                  public static final String QUX1 = \"QUX1_FROM_FOO1\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import foo1.Bar;\n+\n+              class Test {\n+                  void a() {\n+                      System.out.println(Bar.QUX1);\n+                      System.out.println(Bar.QUX2);\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import foo1.Bar;\n+\n+              class Test {\n+                  void a() {\n+                      System.out.println(foo2.Bar.QUX1);\n+                      System.out.println(Bar.QUX2);\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5224\")\n+    void shouldFullyQualifyWhenNewTypeIsAmbiguous2() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ReplaceConstantWithAnotherConstant(\"foo1.Bar.QUX1\", \"foo3.Bar.QUX2\")),\n+          java(\n+            \"\"\"\n+              package foo1;\n+\n+              public class Bar {\n+                  public static final String QUX1 = \"QUX_FROM_FOO1\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              package foo2;\n+\n+              public class Bar {\n+                  public static final String QUX2 = \"QUX_FROM_FOO2\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              package foo3;\n+\n+              public class Bar {\n+                  public static final String QUX2 = \"QUX_FROM_FOO3\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import static foo1.Bar.QUX1;\n+              import static foo2.Bar.QUX2;\n+\n+              class Test {\n+                  void a() {\n+                      System.out.println(QUX1);\n+                      System.out.println(QUX2);\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import static foo2.Bar.QUX2;\n+\n+              class Test {\n+                  void a() {\n+                      System.out.println(foo3.Bar.QUX2);\n+                      System.out.println(QUX2);\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5224\")\n+    void shouldFullyQualifyWhenNewTypeIsAmbiguous3() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ReplaceConstantWithAnotherConstant(\"foo1.Bar.QUX1\", \"foo2.Bar.QUX1\")),\n+          java(\n+            \"\"\"\n+              package foo1;\n+\n+              public class Bar {\n+                  public static final String QUX1 = \"QUX_FROM_FOO1\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              package foo2;\n+\n+              public class Bar {\n+                  public static final String QUX1 = \"QUX_FROM_FOO2\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import static foo1.Bar.QUX1;\n+\n+              class Test {\n+                  void a() {\n+                      System.out.println(QUX1);\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import static foo2.Bar.QUX1;\n+\n+              class Test {\n+                  void a() {\n+                      System.out.println(QUX1);\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5221",
    "pr_id": 5221,
    "issue_id": 5200,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Java idempotency issue with `instanceof final` pattern matching\n## What version of OpenRewrite are you using?\n\nCurrent main = 45ca3c98d074f7434f8d4aec781228619b21313d\n\n## What is the smallest, simplest way to reproduce the problem?\n\n```java\n    @Test\n    void instanceofFinal() {\n        rewriteRun(\n          java(\n            \"\"\"\n            public class Main {\n              public static void main(String[] argv) {\n                String s = \"a\";\n                if (s instanceof final String s2) {\n                    System.out.println(s2);\n                }\n              }\n            }\n            \"\"\"\n          )\n        );\n    }\n```\n\n## What did you expect to see?\n\nNo change.\n\n## What did you see instead?\n\n```diff\n-       if (s instanceof final String s2) {\n+       if (s instanceof StringString s2) {\n```\n\n## Context\n\nInspired by real-life: https://github.com/PaperMC/Velocity/blob/d9f1016bd57d50f5052bb90222894adb40fd256c/api/src/main/java/com/velocitypowered/api/proxy/server/PingOptions.java#L84",
    "issue_word_count": 105,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/InstanceOfTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java",
      "rewrite-java/src/main/java/org/openrewrite/java/tree/J.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/InstanceOfTest.java"
    ],
    "base_commit": "afd9c55104cf1457d9ce612b7f6f8431da93d043",
    "head_commit": "1c6857774f8d2b610bc430a0fa8b0fa2631c0d8e",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5221",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5221",
    "dockerfile": "",
    "pr_merged_at": "2025-03-26T20:58:49.000Z",
    "patch": "diff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex 63ecdcf9b8c..d1342026835 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -783,14 +783,21 @@ public J visitImport(ImportTree node, Space fmt) {\n \n     @Override\n     public J visitInstanceOf(InstanceOfTree node, Space fmt) {\n+        J pattern = null;\n+        J.Modifier modifier = null;\n         JavaType type = typeMapping.type(node);\n-        return new J.InstanceOf(randomId(), fmt, Markers.EMPTY,\n-                convert(node.getExpression(), t -> sourceBefore(\"instanceof\")),\n-                convert(node.getType()),\n-                node.getPattern() instanceof JCBindingPattern b ?\n-                        new J.Identifier(randomId(), sourceBefore(b.getVariable().getName().toString()), Markers.EMPTY, emptyList(), b.getVariable().getName().toString(),\n-                                type, typeMapping.variableType(b.var.sym)) : null,\n-                type);\n+\n+        JRightPadded<Expression> expression = convert(node.getExpression(), t -> sourceBefore(\"instanceof\"));\n+        //Handling final modifier in instance of pattern matching\n+        if (node.getPattern() instanceof JCBindingPattern b && b.var.mods.flags == Flags.FINAL) {\n+             modifier = new J.Modifier(randomId(), sourceBefore(\"final\"), Markers.EMPTY, null, J.Modifier.Type.Final, emptyList());\n+        }\n+        J clazz = convert(node.getType());\n+        if (node.getPattern() instanceof JCBindingPattern b) {\n+            pattern = new J.Identifier(randomId(), sourceBefore(b.getVariable().getName().toString()), Markers.EMPTY, emptyList(), b.getVariable().getName().toString(),\n+                    type, typeMapping.variableType(b.var.sym));\n+        }\n+        return new J.InstanceOf(randomId(), fmt, Markers.EMPTY, expression, clazz, pattern, type, modifier);\n     }\n \n     @Override\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex 0ea0d39e924..ef361164f9a 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -787,12 +787,16 @@ public J visitImport(ImportTree node, Space fmt) {\n \n     @Override\n     public J visitInstanceOf(InstanceOfTree node, Space fmt) {\n+        J.Modifier modifier = null;\n         JavaType type = typeMapping.type(node);\n-        return new J.InstanceOf(randomId(), fmt, Markers.EMPTY,\n-                convert(node.getExpression(), t -> sourceBefore(\"instanceof\")),\n-                convert(node.getType()),\n-                getNodePattern(node.getPattern(), type),\n-                type);\n+        JRightPadded<Expression> expression = convert(node.getExpression(), t -> sourceBefore(\"instanceof\"));\n+        //Handling final modifier in instance of pattern matching\n+        if (node.getPattern() instanceof JCBindingPattern b && b.var.mods.flags == Flags.FINAL) {\n+            modifier = new J.Modifier(randomId(), sourceBefore(\"final\"), Markers.EMPTY, null, J.Modifier.Type.Final, emptyList());\n+        }\n+        J clazz = convert(node.getType());\n+        J pattern = getNodePattern(node.getPattern(), type);\n+        return new J.InstanceOf(randomId(), fmt, Markers.EMPTY, expression, clazz, pattern, type, modifier);\n     }\n \n     @Override\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java b/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java\nindex d75723c2999..aaab0711750 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java\n@@ -726,6 +726,7 @@ public J visitImport(J.Import import_, PrintOutputCapture<P> p) {\n     public J visitInstanceOf(InstanceOf instanceOf, PrintOutputCapture<P> p) {\n         beforeSyntax(instanceOf, Space.Location.INSTANCEOF_PREFIX, p);\n         visitRightPadded(instanceOf.getPadding().getExpression(), JRightPadded.Location.INSTANCEOF, \"instanceof\", p);\n+        visit(instanceOf.getModifier(), p);\n         visit(instanceOf.getClazz(), p);\n         visit(instanceOf.getPattern(), p);\n         afterSyntax(instanceOf, p);\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java\nindex 8d663018ac7..999bf4d9681 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java\n@@ -2986,6 +2986,11 @@ public InstanceOf withExpression(Expression expression) {\n         @Getter\n         JavaType type;\n \n+        @With\n+        @Nullable\n+        @Getter\n+        Modifier modifier;\n+\n         @Override\n         public <P> J acceptJava(JavaVisitor<P> v, P p) {\n             return v.visitInstanceOf(this, p);\n@@ -3023,6 +3028,18 @@ public Padding getPadding() {\n             return p;\n         }\n \n+        @Deprecated\n+        public InstanceOf(UUID id, Space prefix, Markers markers, JRightPadded<Expression> expression, J clazz, @Nullable J pattern, @Nullable JavaType type) {\n+            this.id = id;\n+            this.prefix = prefix;\n+            this.markers = markers;\n+            this.expression = expression;\n+            this.clazz = clazz;\n+            this.pattern = pattern;\n+            this.type = type;\n+            this.modifier = null;\n+        }\n+\n         @RequiredArgsConstructor\n         public static class Padding {\n             private final InstanceOf t;\n@@ -3032,7 +3049,7 @@ public JRightPadded<Expression> getExpression() {\n             }\n \n             public InstanceOf withExpression(JRightPadded<Expression> expression) {\n-                return t.expression == expression ? t : new InstanceOf(t.id, t.prefix, t.markers, expression, t.clazz, t.pattern, t.type);\n+                return t.expression == expression ? t : new InstanceOf(t.id, t.prefix, t.markers, expression, t.clazz, t.pattern, t.type, t.modifier);\n             }\n \n             @Deprecated\n@@ -3042,7 +3059,7 @@ public JRightPadded<Expression> getExpr() {\n \n             @Deprecated\n             public InstanceOf withExpr(JRightPadded<Expression> expression) {\n-                return t.expression == expression ? t : new InstanceOf(t.id, t.prefix, t.markers, expression, t.clazz, t.pattern, t.type);\n+                return t.expression == expression ? t : new InstanceOf(t.id, t.prefix, t.markers, expression, t.clazz, t.pattern, t.type, t.modifier);\n             }\n         }\n     }\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/InstanceOfTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/InstanceOfTest.java\nindex ca986bd4289..a16f331fc03 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/InstanceOfTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/InstanceOfTest.java\n@@ -67,4 +67,42 @@ public J visitInstanceOf(J.InstanceOf instanceOf, Integer integer) {\n           )\n         );\n     }\n+\n+    @MinimumJava17\n+    @Test\n+    void instanceofPatternMatchWithFinalModifier() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              public class Main {\n+                public static void main(String[] argv) {\n+                  String name = \"Messi\";\n+                  if (name instanceof final String player) {\n+                      System.out.println(player);\n+                  }\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @MinimumJava17\n+    @Test\n+    void instanceofPatternMatchWithoutModifier() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              public class Main {\n+                public static void main(String[] argv) {\n+                  String name = \"Messi\";\n+                  if (name instanceof String player) {\n+                      System.out.println(player);\n+                  }\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5203",
    "pr_id": 5203,
    "issue_id": 5072,
    "repo": "openrewrite/rewrite",
    "problem_statement": "GroovyParsingException when parsing Gradle build file\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using\n\n- OpenRewrite v8.45.0\n- Gradle plugin v7.1.4\n- rewrite-groovy v8.45.0\n- rewrite-gradle v8.45.0\n- Gradle 6.9\n\n## How are you running OpenRewrite?\n<!--\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\nIs your project a single module or a multi-module project?\n\nCan you share your configuration so that we can rule out any configuration issues?\n\nIs your project public? If so, can you share a link to it?\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\n-->\nI am using the Gradle plugin, with an init script.\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.-->\n\nI have simplified my original `build.gradle` to something which produces a similar exception. I have been unable to reproduce this in a unit test since they use Groovy 3, which doesn't seem to produce the exception. I have tried to create a unit test with Groovy 2 dependencies, but it seemed the GroovyParserVisitor then sees a ClassNotFoundException for LamdaExpression, so I'm unsure how to configure a test to compile the Groovy code with Groovy 2 yet have Groovy 3 classes available. The only way I have been able to reproduce is by actually running `gradle --init-script init.gradle rewriteDryRun`.\n\ninit.gradle\n```groovy\ninitscript {\n    repositories {\n        maven { url \"https://plugins.gradle.org/m2\" }\n    }\n    dependencies { classpath(\"org.openrewrite:plugin:latest.release\") }\n}\nrootProject {\n    plugins.apply(org.openrewrite.gradle.RewritePlugin)\n    dependencies {\n        rewrite(\"org.openrewrite:rewrite-java\")\n    }\n    rewrite {\n        activeRecipe(\"org.openrewrite.groovy.format.AutoFormat\")\n        setExportDatatables(true)\n    }\n    afterEvaluate {\n        if (repositories.isEmpty()) {\n            repositories {\n                mavenCentral()\n            }\n        }\n    }\n}\n```\n\nbuild.gradle\n```groovy\ndef x = (1 / 1 ) * 100\nSystem.out.println(\"test\")\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\nNo fail to parse errors.\n\n## What did you see instead?\nFailed to parse error.\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n```\nError during rewrite dry run\norg.openrewrite.groovy.GroovyParsingException: Failed to parse build.gradle, cursor position likely inaccurate.\n\tat org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:203)\n\tat org.openrewrite.groovy.GroovyParser.lambda$parseInputs$3(GroovyParser.java:147)\n\tat java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\n\tat java.util.Collections$2.tryAdvance(Collections.java:4717)\n\tat java.util.Collections$2.forEachRemaining(Collections.java:4725)\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\n\tat java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\n\tat java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\n\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n\tat java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)\n\tat java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:270)\n\tat java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382)\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\n\tat java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:312)\n\tat java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\n\tat java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\n\tat java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743)\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\n\tat java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:312)\n\tat java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743)\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\n\tat java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:312)\n\tat java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\n\tat java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:312)\n\tat java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\n\tat java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:312)\n\tat java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743)\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)\n\tat java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\n\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n\tat java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)\n\tat org.openrewrite.gradle.isolated.DefaultProjectParser.listResults(DefaultProjectParser.java:1387)\n\tat org.openrewrite.gradle.isolated.DefaultProjectParser.dryRun(DefaultProjectParser.java:334)\n\tat org.openrewrite.gradle.DelegatingProjectParser.lambda$dryRun$3(DelegatingProjectParser.java:123)\n\tat org.openrewrite.gradle.DelegatingProjectParser.unwrapInvocationException(DelegatingProjectParser.java:164)\n\tat org.openrewrite.gradle.DelegatingProjectParser.dryRun(DelegatingProjectParser.java:122)\n\tat org.openrewrite.gradle.RewriteDryRunTask.run(RewriteDryRunTask.java:52)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:104)\n\tat org.gradle.api.internal.project.taskfactory.StandardTaskAction.doExecute(StandardTaskAction.java:58)\n\tat org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:51)\n\tat org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:29)\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$2.run(ExecuteActionsTaskExecuter.java:494)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:29)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:26)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:75)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:68)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:153)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:68)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.run(DefaultBuildOperationRunner.java:56)\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.lambda$run$1(DefaultBuildOperationExecutor.java:71)\n\tat org.gradle.internal.operations.UnmanagedBuildOperationWrapper.runWithUnmanagedSupport(UnmanagedBuildOperationWrapper.java:45)\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:71)\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:479)\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:462)\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.access$400(ExecuteActionsTaskExecuter.java:105)\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$TaskExecution.executeWithPreviousOutputFiles(ExecuteActionsTaskExecuter.java:273)\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$TaskExecution.execute(ExecuteActionsTaskExecuter.java:251)\n\tat org.gradle.internal.execution.steps.ExecuteStep.lambda$executeOperation$1(ExecuteStep.java:66)\n\tat java.util.Optional.orElseGet(Optional.java:267)\n\tat org.gradle.internal.execution.steps.ExecuteStep.executeOperation(ExecuteStep.java:66)\n\tat org.gradle.internal.execution.steps.ExecuteStep.access$000(ExecuteStep.java:34)\n\tat org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:47)\n\tat org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:44)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:200)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:195)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:75)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:68)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:153)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:68)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:62)\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.lambda$call$2(DefaultBuildOperationExecutor.java:76)\n\tat org.gradle.internal.operations.UnmanagedBuildOperationWrapper.callWithUnmanagedSupport(UnmanagedBuildOperationWrapper.java:54)\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:76)\n\tat org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:44)\n\tat org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:34)\n\tat org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:72)\n\tat org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:42)\n\tat org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:53)\n\tat org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:39)\n\tat org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:44)\n\tat org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:77)\n\tat org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:58)\n\tat org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:54)\n\tat org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:32)\n\tat org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:57)\n\tat org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:38)\n\tat org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:63)\n\tat org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:30)\n\tat org.gradle.internal.execution.steps.BuildCacheStep.executeWithoutCache(BuildCacheStep.java:176)\n\tat org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:76)\n\tat org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:47)\n\tat org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:43)\n\tat org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:32)\n\tat org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:39)\n\tat org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:25)\n\tat org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:102)\n\tat org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$0(SkipUpToDateStep.java:95)\n\tat java.util.Optional.map(Optional.java:215)\n\tat org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:55)\n\tat org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:39)\n\tat org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:83)\n\tat org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:44)\n\tat org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:37)\n\tat org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:27)\n\tat org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:96)\n\tat org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:52)\n\tat org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:83)\n\tat org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:54)\n\tat org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:74)\n\tat org.gradle.internal.execution.steps.SkipEmptyWorkStep.lambda$execute$2(SkipEmptyWorkStep.java:88)\n\tat java.util.Optional.orElseGet(Optional.java:267)\n\tat org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:88)\n\tat org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:34)\n\tat org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:38)\n\tat org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:46)\n\tat org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:34)\n\tat org.gradle.internal.execution.steps.AssignWorkspaceStep.lambda$execute$0(AssignWorkspaceStep.java:43)\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$TaskExecution$3.withWorkspace(ExecuteActionsTaskExecuter.java:286)\n\tat org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:43)\n\tat org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:33)\n\tat org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:40)\n\tat org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:30)\n\tat org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:54)\n\tat org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:40)\n\tat org.gradle.internal.execution.impl.DefaultExecutionEngine.rebuild(DefaultExecutionEngine.java:46)\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.lambda$executeIfValid$0(ExecuteActionsTaskExecuter.java:182)\n\tat java.util.Optional.map(Optional.java:215)\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:182)\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:173)\n\tat org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:109)\n\tat org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)\n\tat org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:62)\n\tat org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)\n\tat org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:56)\n\tat org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:200)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:195)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:75)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:68)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:153)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:68)\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:62)\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.lambda$call$2(DefaultBuildOperationExecutor.java:76)\n\tat org.gradle.internal.operations.UnmanagedBuildOperationWrapper.callWithUnmanagedSupport(UnmanagedBuildOperationWrapper.java:54)\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:76)\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)\n\tat org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:41)\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:411)\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:398)\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:391)\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:377)\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.lambda$run$0(DefaultPlanExecutor.java:127)\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:191)\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.executeNextNode(DefaultPlanExecutor.java:182)\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:124)\n\tat org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)\n\tat org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 50\n\tat java.lang.String.substring(String.java:1963)\n\tat org.openrewrite.groovy.GroovyParserVisitor.whitespace(GroovyParserVisitor.java:2336)\n\tat org.openrewrite.groovy.GroovyParserVisitor.access$000(GroovyParserVisitor.java:80)\nCaused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 50\n\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.insideParentheses(GroovyParserVisitor.java:681)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitConstantExpression(GroovyParserVisitor.java:1233)\n\tat org.codehaus.groovy.ast.expr.ConstantExpression.visit(ConstantExpression.java:81)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:640)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitBinaryExpression$1(GroovyParserVisitor.java:961)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.insideParentheses(GroovyParserVisitor.java:674)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitBinaryExpression(GroovyParserVisitor.java:840)\n\tat org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:640)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitDeclarationExpression(GroovyParserVisitor.java:1400)\n\tat org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:89)\n\tat org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:120)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitExpressionStatement$8(GroovyParserVisitor.java:1468)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.labeled(GroovyParserVisitor.java:696)\n\tat org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitExpressionStatement(GroovyParserVisitor.java:1467)\n\tat org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\n\tat org.openrewrite.groovy.GroovyParserVisitor.convertTopLevelStatement(GroovyParserVisitor.java:2195)\n\tat org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:195)\n\t... 176 more\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\n",
    "issue_word_count": 2752,
    "test_files_count": 1,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "rewrite-groovy/build.gradle.kts",
      "rewrite-groovy/src/groovy2Test/java/org/openrewrite/groovy/GroovyParserTest.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/FindBinaryOperationVisitor.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/groovy2Test/java/org/openrewrite/groovy/GroovyParserTest.java"
    ],
    "base_commit": "5906014f045b28019992a608b8d6fdf1d2daaaab",
    "head_commit": "315276c997c14528c859afa24dd7114048872c96",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5203",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5203",
    "dockerfile": "",
    "pr_merged_at": "2025-03-26T16:13:14.000Z",
    "patch": "diff --git a/rewrite-groovy/build.gradle.kts b/rewrite-groovy/build.gradle.kts\nindex f34391b3062..a84eb2a428c 100644\n--- a/rewrite-groovy/build.gradle.kts\n+++ b/rewrite-groovy/build.gradle.kts\n@@ -1,7 +1,39 @@\n plugins {\n     id(\"org.openrewrite.build.language-library\")\n+    id(\"jvm-test-suite\")\n }\n \n+testing {\n+    suites {\n+        val test by getting(JvmTestSuite::class) {\n+            useJUnitJupiter()\n+        }\n+\n+        register<JvmTestSuite>(\"groovy2Test\") {\n+            configurations.getByName(\"groovy2TestRuntimeClasspath\") {\n+                resolutionStrategy {\n+                    force(\"org.codehaus.groovy:groovy:2.5.22\")\n+                }\n+            }\n+\n+            dependencies {\n+                implementation(project())\n+                implementation(project(\":rewrite-test\"))\n+                implementation(\"org.assertj:assertj-core:latest.release\")\n+            }\n+\n+            targets {\n+                all {\n+                    testTask.configure {\n+                        shouldRunAfter(test)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n dependencies {\n     api(project(\":rewrite-java\"))\n \n@@ -24,12 +56,6 @@ dependencies {\n     testRuntimeOnly(project(\":rewrite-java-17\"))\n }\n \n-//val testJava8 = tasks.register<Test>(\"testJava8\") {\n-//    javaLauncher.set(javaToolchains.launcherFor {\n-//        languageVersion.set(JavaLanguageVersion.of(8))\n-//    })\n-//}\n-//tasks.named(\"check\").configure {\n-//    // Enable once the java8 tests are passing\n-//    // dependsOn(testJava8)\n-//}\n+tasks.named(\"check\") {\n+    dependsOn(testing.suites.named(\"groovy2Test\"))\n+}\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/FindBinaryOperationVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/FindBinaryOperationVisitor.java\nnew file mode 100644\nindex 00000000000..1b1c4a2b922\n--- /dev/null\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/FindBinaryOperationVisitor.java\n@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.groovy;\n+\n+import lombok.Getter;\n+import org.codehaus.groovy.ast.CodeVisitorSupport;\n+import org.codehaus.groovy.ast.expr.BinaryExpression;\n+\n+public class FindBinaryOperationVisitor extends CodeVisitorSupport {\n+\n+    private final int[] sourceLineNumberOffsets;\n+    private final int index;\n+    private final String tokenToFind;\n+\n+    @Getter\n+    private boolean found = false;\n+\n+    public FindBinaryOperationVisitor(String tokenToFind, int index, int[] sourceLineNumberOffsets) {\n+        this.index = index;\n+        this.tokenToFind = tokenToFind;\n+        this.sourceLineNumberOffsets = sourceLineNumberOffsets;\n+    }\n+\n+    @Override\n+    public void visitBinaryExpression(BinaryExpression be) {\n+        if (toSourceIndex(be.getRightExpression().getLineNumber(), be.getRightExpression().getColumnNumber()) <= index) {\n+            be.getRightExpression().visit(this);\n+        } else if (toSourceIndex(be.getLeftExpression().getLastLineNumber(), be.getLeftExpression().getLastColumnNumber()) > index) {\n+            be.getLeftExpression().visit(this);\n+        } else if (tokenToFind.equals(be.getOperation().getText())) {\n+            found = true;\n+        }\n+    }\n+\n+    private int toSourceIndex(int lineNumber, int columnNumber) {\n+        return sourceLineNumberOffsets[lineNumber - 1] + columnNumber - 1;\n+    }\n+}\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex 38a1da65eaf..03fa30c810e 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -1255,7 +1255,7 @@ public void visitConstantExpression(ConstantExpression expression) {\n                         value = \"@\" + value;\n                         text = \"@\" + text;\n                     } else {\n-                        Delimiter delimiter = getDelimiter(cursor);\n+                        Delimiter delimiter = getDelimiter(expression, cursor);\n                         if (delimiter != null) {\n                             // Get the string literal from the source, so escaping of newlines and the like works out of the box\n                             value = sourceSubstring(cursor + delimiter.open.length(), delimiter.close);\n@@ -1508,7 +1508,7 @@ public void visitIfElse(IfStatement ifElse) {\n         @Override\n         public void visitGStringExpression(GStringExpression gstring) {\n             Space fmt = whitespace();\n-            Delimiter delimiter = getDelimiter(cursor);\n+            Delimiter delimiter = getDelimiter(gstring, cursor);\n             skip(delimiter.open);\n \n             NavigableMap<LineColumn, org.codehaus.groovy.ast.expr.Expression> sortedByPosition = new TreeMap<>();\n@@ -1683,7 +1683,7 @@ public void visitMethodCallExpression(MethodCallExpression call) {\n                 MethodNode methodNode = (MethodNode) call.getNodeMetaData().get(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);\n                 JavaType.Method methodType = null;\n                 if (methodNode == null && call.getObjectExpression() instanceof VariableExpression &&\n-                    ((VariableExpression) call.getObjectExpression()).getAccessedVariable() != null) {\n+                        ((VariableExpression) call.getObjectExpression()).getAccessedVariable() != null) {\n                     // Groovy doesn't know what kind of object this method is being invoked on\n                     // But if this invocation is inside a Closure we may have already enriched its parameters with types from the static type checker\n                     // Use any such type information to attempt to find a matching method\n@@ -2462,22 +2462,23 @@ private String sourceSubstring(int beginIndex, String untilDelim) {\n         } else if (node instanceof MethodCallExpression && !isOlderThanGroovy3()) {\n             // Only for groovy 3+, because lower versions do always return `-1` for objectExpression.lineNumber / objectExpression.columnNumber\n             MethodCallExpression expr = (MethodCallExpression) node;\n-            return determineParenthesisLevel(expr.getObjectExpression().getLineNumber(), expr.getLineNumber(), expr.getObjectExpression().getColumnNumber(), expr.getColumnNumber());\n+            return determineParenthesisLevel(expr, expr.getObjectExpression().getLineNumber(), expr.getLineNumber(), expr.getObjectExpression().getColumnNumber(), expr.getColumnNumber());\n         } else if (node instanceof BinaryExpression) {\n             BinaryExpression expr = (BinaryExpression) node;\n-            return determineParenthesisLevel(expr.getLeftExpression().getLineNumber(), expr.getLineNumber(), expr.getLeftExpression().getColumnNumber(), expr.getColumnNumber());\n+            return determineParenthesisLevel(expr, expr.getLeftExpression().getLineNumber(), expr.getLineNumber(), expr.getLeftExpression().getColumnNumber(), expr.getColumnNumber());\n         }\n         return null;\n     }\n \n     /**\n+     * @param node             the node to determine the parenthesis level of\n      * @param childLineNumber  the beginning line number of the first sub node\n      * @param parentLineNumber the beginning line number of the parent node\n      * @param childColumn      the column on the {@code childLineNumber} line where the sub node starts\n      * @param parentColumn     the column on the {@code parentLineNumber} line where the parent node starts\n      * @return the level of parenthesis parsed from the source\n      */\n-    private int determineParenthesisLevel(int childLineNumber, int parentLineNumber, int childColumn, int parentColumn) {\n+    private int determineParenthesisLevel(ASTNode node, int childLineNumber, int parentLineNumber, int childColumn, int parentColumn) {\n         // Map the coordinates\n         int startingLineNumber;\n         int startingColumn;\n@@ -2509,7 +2510,7 @@ private int determineParenthesisLevel(int childLineNumber, int parentLineNumber,\n         Delimiter delimiter = null;\n         for (int i = start; i < end; i++) {\n             if (delimiter == null) {\n-                delimiter = getDelimiter(i);\n+                delimiter = getDelimiter(node, i);\n                 if (delimiter == null) {\n                     if (source.charAt(i) == '(') {\n                         count++;\n@@ -2531,7 +2532,7 @@ private int determineParenthesisLevel(int childLineNumber, int parentLineNumber,\n      * Grabs a {@link Delimiter} from source if cursor is right in front of a delimiter.\n      * Whitespace characters are NOT excluded, the cursor will not be moved.\n      */\n-    private @Nullable Delimiter getDelimiter(int cursor) {\n+    private @Nullable Delimiter getDelimiter(ASTNode node, int cursor) {\n         boolean isPatternOperator = source.startsWith(\"~\", cursor);\n         int c = cursor;\n         if (isPatternOperator) {\n@@ -2548,7 +2549,7 @@ private int determineParenthesisLevel(int childLineNumber, int parentLineNumber,\n             return SINGLE_LINE_COMMENT;\n         } else if (source.startsWith(\"/*\", c)) {\n             return MULTILINE_COMMENT;\n-        } else if (source.startsWith(\"/\", c)) {\n+        } else if (source.startsWith(\"/\", c) && validateIsDelimiter(node, c)) {\n             return isPatternOperator ? PATTERN_SLASHY_STRING : SLASHY_STRING;\n         } else if (source.startsWith(\"\\\"\", c)) {\n             return isPatternOperator ? PATTERN_DOUBLE_QUOTE_STRING : DOUBLE_QUOTE_STRING;\n@@ -2561,6 +2562,12 @@ private int determineParenthesisLevel(int childLineNumber, int parentLineNumber,\n         return null;\n     }\n \n+    private boolean validateIsDelimiter(ASTNode node, int c) {\n+        FindBinaryOperationVisitor visitor = new FindBinaryOperationVisitor(source.substring(c, c + 1), c, sourceLineNumberOffsets);\n+        node.visit(visitor);\n+        return !visitor.isFound();\n+    }\n+\n     private TypeTree visitTypeTree(ClassNode classNode) {\n         return visitTypeTree(classNode, false);\n     }\n@@ -2830,9 +2837,9 @@ private DeclarationExpression transformBackToDeclarationExpression(ConstantExpre\n             start--;\n         }\n \n-        int startX = indexOfNextNonWhitespace( equalsIndex + 1, str);\n+        int startX = indexOfNextNonWhitespace(equalsIndex + 1, str);\n         int endX = startX;\n-        Delimiter delim = getDelimiter(endX);\n+        Delimiter delim = getDelimiter(expression, endX);\n         if (delim != null) {\n             endX = str.indexOf(delim.close, endX + delim.open.length()) + 1;\n         } else {\n",
    "test_patch": "diff --git a/rewrite-groovy/src/groovy2Test/java/org/openrewrite/groovy/GroovyParserTest.java b/rewrite-groovy/src/groovy2Test/java/org/openrewrite/groovy/GroovyParserTest.java\nnew file mode 100644\nindex 00000000000..a0327125b3d\n--- /dev/null\n+++ b/rewrite-groovy/src/groovy2Test/java/org/openrewrite/groovy/GroovyParserTest.java\n@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.groovy;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.test.RewriteTest;\n+\n+import static org.openrewrite.groovy.Assertions.groovy;\n+\n+class GroovyParserTest implements RewriteTest {\n+\n+    @Test\n+    void shouldNotTreatDivisionAsDelimiter() {\n+        rewriteRun(\n+                groovy(\n+                        \"\"\"\n+                        def x = (1 / 1) * 2\n+                        System.out.println(\"test\")\n+                        \"\"\"\n+                )\n+        );\n+    }\n+\n+    @Test\n+    void shouldHandleUsingSlashyStringsWithDivision() {\n+        rewriteRun(\n+                groovy(\n+                        \"\"\"\n+                        def x = (Integer.parseInt(/3/) / Integer.parseInt(/2/)) * Integer.parseInt(/5/)\n+                        System.out.println(\"test\")\n+                        \"\"\"\n+                )\n+        );\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5195",
    "pr_id": 5195,
    "issue_id": 4390,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ChangeStaticFieldToMethod: ternary expression parsing issue\nI may add a draft PR, but here's the reproducer for `ChangeStaticFieldToMethodTest`:\r\n\r\n```\r\n    @Test\r\n    void migratesTernaryOperator() {\r\n        rewriteRun(\r\n          java(acmeLists),\r\n          java(\r\n            \"\"\"\r\n              import java.util.Collections;\r\n\r\n              class A {\r\n                  static Object empty() {\r\n                      return (1 == 1) ? Collections.EMPTY_LIST : new RuntimeException(\"what universe is this?\");\r\n\r\n                  }\r\n              }\r\n              \"\"\",\r\n            \"\"\"\r\n              import com.acme.Lists;\r\n\r\n              class A {\r\n                  static Object empty() {\r\n                      return (1 == 1) ? Lists.of() : new RuntimeException(\"what universe is this?\");\r\n                  }\r\n              }\r\n              \"\"\"\r\n          )\r\n        );\r\n    }\r\n```\r\n\r\n### Unexpected behavior\r\n\r\n```\r\nChangeStaticFieldToMethodTest > migratesTernaryOperator() FAILED\r\n    java.lang.AssertionError: Failed to parse sources or run recipe\r\n        at org.openrewrite.test.RewriteTest.lambda$defaultExecutionContext$15(RewriteTest.java:632)\r\n        at org.openrewrite.test.RewriteTest$$Lambda$490/0x000000900124dc38.accept(Unknown Source)\r\n        at org.openrewrite.scheduling.RecipeRunCycle.handleError(RecipeRunCycle.java:242)\r\n        at org.openrewrite.scheduling.RecipeRunCycle.lambda$editSources$6(RecipeRunCycle.java:184)\r\n[snip]\r\nCaused by:\r\n        org.openrewrite.internal.RecipeRunException: java.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0\r\n            at app//org.openrewrite.TreeVisitor.visit(TreeVisitor.java:287)\r\n            at app//org.openrewrite.TreeVisitor.visit(TreeVisitor.java:147)\r\n            at app//org.openrewrite.java.JavaTemplate.apply(JavaTemplate.java:115)\r\n            at app//org.openrewrite.java.ChangeStaticFieldToMethod$1.useNewMethod(ChangeStaticFieldToMethod.java:119)\r\n            at app//org.openrewrite.java.ChangeStaticFieldToMethod$1.visitFieldAccess(ChangeStaticFieldToMethod.java:95)\r\n            at app//org.openrewrite.java.ChangeStaticFieldToMethod$1.visitFieldAccess(ChangeStaticFieldToMethod.java:80)\r\n            at app//org.openrewrite.java.tree.J$FieldAccess.acceptJava(J.java:1943)\r\n            at app//org.openrewrite.java.tree.J.accept(J.java:59)\r\n[snip]\r\nCaused by:\r\n            java.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0\r\n                at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:64)\r\n                at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:70)\r\n                at java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:266)\r\n                at java.base/java.util.Objects.checkIndex(Objects.java:361)\r\n                at java.base/java.util.ArrayList.get(ArrayList.java:427)\r\n                at org.openrewrite.java.internal.template.JavaTemplateParser.parseExpression(JavaTemplateParser.java:118)\r\n                at org.openrewrite.java.internal.template.JavaTemplateJavaExtension$1.visitExpression(JavaTemplateJavaExtension.java:232)\r\n                at org.openrewrite.java.internal.template.JavaTemplateJavaExtension$1.visitExpression(JavaTemplateJavaExtension.java:56)\r\n                at org.openrewrite.java.JavaVisitor.visitTernary(JavaVisitor.java:1151)\r\n                at org.openrewrite.java.tree.J$Ternary.acceptJava(J.java:5163)\r\n                at org.openrewrite.java.tree.J.accept(J.java:59)\r\n                at org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\r\n```\r\n\r\n## What version of OpenRewrite are you using?\r\n\r\n`main` branch\r\n_ v1.2.3\r\n\r\n## How are you running OpenRewrite?\r\n\r\ngradle build\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\n",
    "issue_word_count": 425,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangeStaticFieldToMethodTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangeStaticFieldToMethodTest.java"
    ],
    "base_commit": "7de8e67cbdef0c67a2c48d505e549d953f1f684d",
    "head_commit": "e3f3bd16d739b4b4654a224ccef6a6ed280259ba",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5195",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5195",
    "dockerfile": "",
    "pr_merged_at": "2025-03-19T15:12:02.000Z",
    "patch": "",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeStaticFieldToMethodTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeStaticFieldToMethodTest.java\nindex 8559c3583e7..eef44c4f0fc 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeStaticFieldToMethodTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeStaticFieldToMethodTest.java\n@@ -337,4 +337,32 @@ public static String testMe() {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4390\")\n+    void migratesTernaryOperator() {\n+        rewriteRun(\n+          java(acmeLists),\n+          java(\n+            \"\"\"\n+              import java.util.Collections;\n+\n+              class A {\n+                  static Object empty() {\n+                      return (1 == 1) ? Collections.EMPTY_LIST : new RuntimeException(\"what universe is this?\");\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import com.acme.Lists;\n+\n+              class A {\n+                  static Object empty() {\n+                      return (1 == 1) ? Lists.of() : new RuntimeException(\"what universe is this?\");\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5175",
    "pr_id": 5175,
    "issue_id": 5174,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ReplaceConstantWithAnotherConstant not work when use static constant within method\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using the latest rewrite (8.48.0)\n\n## How are you running OpenRewrite?\n<!--\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\nIs your project a single module or a multi-module project?\n\nCan you share your configuration so that we can rule out any configuration issues?\n\nIs your project public? If so, can you share a link to it?\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\n-->\nI am using the Maven plugin, and my project is a single module project.\n```shell\nmvn org.openrewrite.maven:rewrite-maven-plugin:run ...\n```\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\nRun this test, it will failed:\n- Outside the method definition, the `String out = QUX1` will be changed correctly\n- **But within the method definition, the `String in = QUX1` will NOT changed**\n\n```java\n@Test\nvoid shouldUpdateWithinMethod() {\n    rewriteRun(\n      spec -> spec.recipe(new ReplaceConstantWithAnotherConstant(\"foo.Bar.QUX1\", \"foo.Bar.QUX2\")),\n      java(\n        \"\"\"\n          package foo;\n\n          public class Bar {\n              public static final String QUX1 = \"QUX1\";\n              public static final String QUX2 = \"QUX2\";\n          }\n          \"\"\"\n      ),\n      java(\n        \"\"\"\n          import static foo.Bar.QUX1;\n\n          class Test {\n              String out = QUX1;\n              void a() {\n                  String in = QUX1;\n              }\n          }\n          \"\"\",\n        \"\"\"\n          import static foo.Bar.QUX2;\n\n          class Test {\n              String out = QUX2;\n              void a() {\n                  String in = QUX2;\n              }\n          }\n          \"\"\"\n      )\n    );\n}\n```\n\nAs for the reason, I did some troubleshooting and I thinks it's because of the redundant check `!isVariableDeclaration`:\nhttps://github.com/openrewrite/rewrite/blob/main/rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java#L82\nhttps://github.com/openrewrite/rewrite/blob/main/rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java#L129\n\nI really cannot find any useful case for this `!isVariableDeclaration`, and even i remove it, all test cases can be passed. And actually if we are concern about duplicated definition (the same constant name), it won't causes any issue becuase it will be defensed by `isConstant`:\nhttps://github.com/openrewrite/rewrite/blob/main/rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java#L124\n\n```java\n@Test\nvoid shouldUpdateWithinMethod3() {\n    rewriteRun(\n      spec -> spec.recipe(new ReplaceConstantWithAnotherConstant(\"foo.Bar.QUX1\", \"foo.Bar.QUX2\")),\n      java(\n        \"\"\"\n          package foo;\n\n          public class Bar {\n              public static final String QUX1 = \"QUX1\";\n              public static final String QUX2 = \"QUX2\";\n          }\n          \"\"\"\n      ),\n      java(\n        \"\"\"\n          import foo.Bar;\n          \n          import static foo.Bar.QUX2;\n\n          class Test {\n              public static final String QUX1 = \"QUX111\"; // the same name as Bar.QUX1\n\n              void a() {\n                  String in = Bar.QUX1;\n                  String in2 = QUX2;\n              }\n          }\n          \"\"\",\n        \"\"\"\n          import foo.Bar;\n          \n          import static foo.Bar.QUX2;\n\n          class Test {\n              public static final String QUX1 = \"QUX111\"; // the same name as Bar.QUX1\n\n              void a() {\n                  String in = Bar.QUX2;\n                  String in2 = QUX2;\n              }\n          }\n          \"\"\"\n      )\n    );\n}\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\n```java\nimport static foo.Bar.QUX2;\n\nclass Test {\n    String out = QUX2;\n    void a() {\n        String in = QUX2;\n    }\n}\n```\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\n```java\nimport static foo.Bar.QUX1;\nimport static foo.Bar.QUX2;\n\nclass Test {\n    String out = QUX2;\n    void a() {\n        String in = QUX1;\n    }\n}\n```\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n```\ndiff --git a/Test.java b/Test.java\nindex feda5a5..c79bed4 100644\n--- a/Test.java\n+++ b/Test.java\n@@ -1,8 +1,9 @@ \n+import static foo.Bar.QUX1;\n import static foo.Bar.QUX2;\n \n class Test {\n     String out = QUX2;\n     void a() {\n-        String in = QUX2;\n+        String in = QUX1;\n     }\n }\n\\ No newline at end of file\n] \nexpected: \n  \"import static foo.Bar.QUX2;\n  \n  class Test {\n      String out = QUX2;\n      void a() {\n          String in = QUX2;\n      }\n  }\"\n but was: \n  \"import static foo.Bar.QUX1;\n  import static foo.Bar.QUX2;\n  \n  class Test {\n      String out = QUX2;\n      void a() {\n          String in = QUX1;\n      }\n  }\"\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\n\nSure if we agree that this is a bug. And from my own point of view, the easiest way is just delete the redundant `isVariableDeclaration`.\n",
    "issue_word_count": 933,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ReplaceConstantWithAnotherConstantTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ReplaceConstantWithAnotherConstantTest.java"
    ],
    "base_commit": "6e318006dc992f91daf11d73134e73ecae0f7dc4",
    "head_commit": "0d14b2718da452e7c92bb7a9d3b3d4ab815ac5ed",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5175",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5175",
    "dockerfile": "",
    "pr_merged_at": "2025-03-14T15:40:33.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java b/rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java\nindex 5390e813d37..03c82362440 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/ReplaceConstantWithAnotherConstant.java\n@@ -79,7 +79,7 @@ public J visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {\n         @Override\n         public J visitIdentifier(J.Identifier ident, ExecutionContext ctx) {\n             JavaType.Variable fieldType = ident.getFieldType();\n-            if (isConstant(fieldType) && !isVariableDeclaration()) {\n+            if (isConstant(fieldType)) {\n                 return replaceFieldAccess(ident, fieldType);\n             }\n             return super.visitIdentifier(ident, ctx);\n@@ -125,24 +125,5 @@ private boolean isConstant(JavaType.@Nullable Variable varType) {\n             return varType != null && TypeUtils.isOfClassType(varType.getOwner(), existingOwningType) &&\n                     varType.getName().equals(constantName);\n         }\n-\n-        private boolean isVariableDeclaration() {\n-            Cursor maybeVariable = getCursor().dropParentUntil(is -> is instanceof J.VariableDeclarations || is instanceof J.CompilationUnit);\n-            if (!(maybeVariable.getValue() instanceof J.VariableDeclarations)) {\n-                return false;\n-            }\n-            JavaType.Variable variableType = ((J.VariableDeclarations) maybeVariable.getValue()).getVariables().get(0).getVariableType();\n-            if (variableType == null) {\n-                return true;\n-            }\n-\n-            JavaType.FullyQualified ownerFqn = TypeUtils.asFullyQualified(variableType.getOwner());\n-            if (ownerFqn == null) {\n-                return true;\n-            }\n-\n-            return constantName.equals(((J.VariableDeclarations) maybeVariable.getValue()).getVariables().get(0).getSimpleName()) &&\n-                    existingOwningType.equals(ownerFqn.getFullyQualifiedName());\n-        }\n     }\n }\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/ReplaceConstantWithAnotherConstantTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/ReplaceConstantWithAnotherConstantTest.java\nindex cf8d505a9bc..f2c8f913c21 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/ReplaceConstantWithAnotherConstantTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/ReplaceConstantWithAnotherConstantTest.java\n@@ -187,4 +187,92 @@ void foo(@SuppressWarnings(value = File.separator) String param) {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5174\")\n+    void shouldUpdateWithinMethod() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ReplaceConstantWithAnotherConstant(\"foo.Bar.QUX1\", \"foo.Bar.QUX2\")),\n+          java(\n+            \"\"\"\n+              package foo;\n+\n+              public class Bar {\n+                  public static final String QUX1 = \"QUX1\";\n+                  public static final String QUX2 = \"QUX2\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import static foo.Bar.QUX1;\n+\n+              class Test {\n+                  String out = QUX1;\n+                  void a() {\n+                      String in = QUX1;\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import static foo.Bar.QUX2;\n+\n+              class Test {\n+                  String out = QUX2;\n+                  void a() {\n+                      String in = QUX2;\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5174\")\n+    void shouldUpdateWithinMethod2() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ReplaceConstantWithAnotherConstant(\"foo.Bar.QUX1\", \"foo.Bar.QUX2\")),\n+          java(\n+            \"\"\"\n+              package foo;\n+\n+              public class Bar {\n+                  public static final String QUX1 = \"QUX1\";\n+                  public static final String QUX2 = \"QUX2\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import foo.Bar;\n+              \n+              import static foo.Bar.QUX2;\n+\n+              class Test {\n+                  public static final String QUX1 = \"QUX111\"; // the same name as Bar.QUX1\n+\n+                  void a() {\n+                      String in = Bar.QUX1;\n+                      String in2 = QUX2;\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import foo.Bar;\n+              \n+              import static foo.Bar.QUX2;\n+\n+              class Test {\n+                  public static final String QUX1 = \"QUX111\"; // the same name as Bar.QUX1\n+\n+                  void a() {\n+                      String in = Bar.QUX2;\n+                      String in2 = QUX2;\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5158",
    "pr_id": 5158,
    "issue_id": 3291,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Dependency management support for Gradle Kotlin scripts (.kts)\n## What problem are you trying to solve?\r\nGradle supports Groovy and Kotlin as scripting languages for build files. We currently support editing Groovy-based build files. This should be extended to Kotiln.\r\n\r\n## Describe the solution you'd like\r\nFor each Gradle-groovy dependency management recipe there should be a Gradle-kotlin equivalent.\r\n\r\n## Additional context\r\nRequires some enhancements to rewrite-kotlin and rewrite-gradle. ",
    "issue_word_count": 71,
    "test_files_count": 6,
    "non_test_files_count": 12,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/TreeVisitor.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/ChangeDependency.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyConstraintToRule.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/IsBuildGradle.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/IsSettingsGradle.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/RemoveDependency.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/GradleDependency.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/ChangeDependencyTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/RemoveDependencyTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/ChangeDependencyTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/RemoveDependencyTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java"
    ],
    "base_commit": "e0e86d8f520b69013ef69643de889bb1aa3a1a11",
    "head_commit": "c6d50c37203f04b24b376e6ba87b6a76ed6b5646",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5158",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5158",
    "dockerfile": "",
    "pr_merged_at": "2025-04-07T20:05:06.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/TreeVisitor.java b/rewrite-core/src/main/java/org/openrewrite/TreeVisitor.java\nindex 6c3b97126b1..eff307c309e 100644\n--- a/rewrite-core/src/main/java/org/openrewrite/TreeVisitor.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/TreeVisitor.java\n@@ -142,7 +142,8 @@ public final Cursor updateCursor(T currentValue) {\n     }\n \n     public @Nullable T visit(@Nullable Tree tree, P p, Cursor parent) {\n-        assert !(parent.getValue() instanceof Tree) ||\n+        assert parent.isRoot() ||\n+               !(parent.getValue() instanceof Tree) ||\n                !((Tree) parent.getValue()).isScope(tree) ||\n                !(p instanceof ExecutionContext) ||\n                !CursorValidatingExecutionContextView.view((ExecutionContext) p).getValidateCursorAcyclic() :\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java\nindex 8c6a97658fb..e437684e928 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependency.java\n@@ -22,9 +22,8 @@\n import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n import org.openrewrite.gradle.search.FindJVMTestSuites;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n-import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.marker.JavaProject;\n import org.openrewrite.java.marker.JavaSourceSet;\n import org.openrewrite.java.search.UsesType;\n@@ -194,7 +193,7 @@ private boolean usesType(SourceFile sourceFile, ExecutionContext ctx) {\n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {\n         return Preconditions.check(!acc.configurationsByProject.isEmpty(),\n-                Preconditions.check(new IsBuildGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {\n+                Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {\n \n                     @Override\n                     public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n@@ -202,10 +201,6 @@ public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {\n                             return (J) tree;\n                         }\n                         JavaSourceFile s = (JavaSourceFile) tree;\n-                        if (!isAcceptable(s, ctx) || !s.getSourcePath().toString().endsWith(\".gradle\") || s.getSourcePath().getFileName().toString().equals(\"settings.gradle\")) {\n-                            return s;\n-                        }\n-\n                         Optional<JavaProject> maybeJp = s.getMarkers().findFirst(JavaProject.class);\n                         if (!maybeJp.isPresent()) {\n                             return s;\n@@ -252,18 +247,17 @@ public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {\n                             return s;\n                         }\n \n-                        G.CompilationUnit g = (G.CompilationUnit) s;\n                         for (String resolvedConfiguration : resolvedConfigurations) {\n                             if (targetsCustomJVMTestSuite(resolvedConfiguration, acc.customJvmTestSuitesWithDependencies.get(jp))) {\n-                                g = (G.CompilationUnit) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, purgeSourceSet(configuration),\n-                                        classifier, extension, metadataFailures, isMatchingJVMTestSuite(resolvedConfiguration)).visitNonNull(g, ctx);\n+                                s = (JavaSourceFile) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, purgeSourceSet(configuration),\n+                                        classifier, extension, metadataFailures, isMatchingJVMTestSuite(resolvedConfiguration)).visitNonNull(s, ctx);\n                             } else {\n-                                g = (G.CompilationUnit) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, resolvedConfiguration,\n-                                        classifier, extension, metadataFailures, this::isTopLevel).visitNonNull(g, ctx);\n+                                s = (JavaSourceFile) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, resolvedConfiguration,\n+                                        classifier, extension, metadataFailures, this::isTopLevel).visitNonNull(s, ctx);\n                             }\n                         }\n \n-                        return g;\n+                        return s;\n                     }\n \n                     private boolean isTopLevel(Cursor cursor) {\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\nindex 737f55f5c8c..18530a0f95a 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\n@@ -17,20 +17,20 @@\n \n import lombok.RequiredArgsConstructor;\n import org.jspecify.annotations.Nullable;\n-import org.openrewrite.Cursor;\n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.SourceFile;\n+import org.openrewrite.*;\n import org.openrewrite.gradle.internal.InsertDependencyComparator;\n import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.MethodMatcher;\n import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaSourceFile;\n import org.openrewrite.java.tree.Space;\n import org.openrewrite.java.tree.Statement;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.marker.Markup;\n import org.openrewrite.maven.MavenDownloadingException;\n import org.openrewrite.maven.MavenDownloadingExceptions;\n@@ -39,6 +39,9 @@\n import org.openrewrite.maven.tree.*;\n import org.openrewrite.tree.ParseError;\n \n+import java.io.ByteArrayInputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n import java.util.*;\n import java.util.function.Predicate;\n import java.util.stream.Collectors;\n@@ -49,7 +52,7 @@\n import static java.util.Objects.requireNonNull;\n \n @RequiredArgsConstructor\n-public class AddDependencyVisitor extends GroovyIsoVisitor<ExecutionContext> {\n+public class AddDependencyVisitor extends JavaIsoVisitor<ExecutionContext> {\n     private static final MethodMatcher DEPENDENCIES_DSL_MATCHER = new MethodMatcher(\"RewriteGradleProject dependencies(..)\");\n     private static final GradleParser GRADLE_PARSER = GradleParser.builder().build();\n \n@@ -80,51 +83,90 @@ public class AddDependencyVisitor extends GroovyIsoVisitor<ExecutionContext> {\n     private final Predicate<Cursor> insertPredicate;\n \n     @Override\n-    public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n-        Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);\n-        if (!maybeGp.isPresent()) {\n-            return cu;\n-        }\n+    public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+        if (tree instanceof JavaSourceFile) {\n+            JavaSourceFile cu = (JavaSourceFile) super.visit(tree, ctx);\n+            Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);\n+            if (!maybeGp.isPresent()) {\n+                return cu;\n+            }\n \n-        GradleProject gp = maybeGp.get();\n-        GradleDependencyConfiguration gdc = gp.getConfiguration(configuration);\n-        if (gdc == null || gdc.findRequestedDependency(groupId, artifactId) != null) {\n-            return cu;\n-        }\n+            GradleProject gp = maybeGp.get();\n+            GradleDependencyConfiguration gdc = gp.getConfiguration(configuration);\n+            if (gdc == null || gdc.findRequestedDependency(groupId, artifactId) != null) {\n+                return cu;\n+            }\n \n-        G.CompilationUnit g = cu;\n-        boolean dependenciesBlockMissing = true;\n-        for (Statement statement : g.getStatements()) {\n-            if (statement instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) statement)) {\n-                dependenciesBlockMissing = false;\n+            boolean dependenciesBlockMissing = true;\n+            if (cu instanceof G.CompilationUnit) {\n+                G.CompilationUnit g = (G.CompilationUnit) cu;\n+                for (Statement statement : g.getStatements()) {\n+                    if (statement instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) statement)) {\n+                        dependenciesBlockMissing = false;\n+                    }\n+                }\n+            } else if (cu instanceof K.CompilationUnit) {\n+                K.CompilationUnit k = (K.CompilationUnit) cu;\n+                for (Statement statement : ((J.Block) k.getStatements().get(0)).getStatements()) {\n+                    if (statement instanceof J.MethodInvocation && ((J.MethodInvocation) statement).getSimpleName().equals(\"dependencies\")) {\n+                        dependenciesBlockMissing = false;\n+                    }\n+                }\n             }\n-        }\n \n-        if (dependenciesBlockMissing) {\n-            Statement dependenciesInvocation = GRADLE_PARSER.parse(ctx, \"dependencies {}\")\n-                    .findFirst()\n-                    .map(G.CompilationUnit.class::cast)\n-                    .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"))\n-                    .getStatements().get(0);\n-            dependenciesInvocation = autoFormat(dependenciesInvocation, ctx, new Cursor(getCursor(), cu));\n-            g = g.withStatements(ListUtils.concat(g.getStatements(),\n-                    g.getStatements().isEmpty() ?\n-                            dependenciesInvocation :\n-                            dependenciesInvocation.withPrefix(Space.format(\"\\n\\n\"))));\n-        }\n+            if (dependenciesBlockMissing) {\n+                if (cu instanceof G.CompilationUnit) {\n+                    G.CompilationUnit g = (G.CompilationUnit) cu;\n+                    Statement dependenciesInvocation = GRADLE_PARSER.parse(ctx, \"dependencies {}\")\n+                            .findFirst()\n+                            .map(G.CompilationUnit.class::cast)\n+                            .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"))\n+                            .getStatements().get(0);\n+                    Cursor parent = getCursor();\n+                    setCursor(new Cursor(parent, g));\n+                    dependenciesInvocation = autoFormat(dependenciesInvocation, ctx, new Cursor(parent, g));\n+                    setCursor(parent);\n+                    cu = g.withStatements(ListUtils.concat(g.getStatements(),\n+                            g.getStatements().isEmpty() ?\n+                                    dependenciesInvocation :\n+                                    dependenciesInvocation.withPrefix(Space.format(\"\\n\\n\"))));\n+                } else {\n+                    K.CompilationUnit k = (K.CompilationUnit) cu;\n+                    J.MethodInvocation dependenciesInvocation = (J.MethodInvocation) ((J.Block) GRADLE_PARSER.parseInputs(Collections.singletonList(new GradleParser.Input(Paths.get(\"build.gradle.kts\"), () -> new ByteArrayInputStream(\"dependencies {}\".getBytes(StandardCharsets.UTF_8)))), null, ctx)\n+                            .findFirst()\n+                            .map(K.CompilationUnit.class::cast)\n+                            .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"))\n+                            .getStatements().get(0)).getStatements().get(0);\n+                    Cursor parent = getCursor();\n+                    setCursor(new Cursor(parent, k));\n+                    dependenciesInvocation = autoFormat(dependenciesInvocation, ctx, new Cursor(getCursor(), k));\n+                    setCursor(parent);\n+                    dependenciesInvocation = dependenciesInvocation.withArguments(ListUtils.mapFirst(dependenciesInvocation.getArguments(), arg -> {\n+                        J.Lambda lambda = (J.Lambda) requireNonNull(arg);\n+                        J.Block block = (J.Block) lambda.getBody();\n+                        return lambda.withBody(block.withEnd(Space.format(\"\\n\")));\n+                    }));\n+                    cu = k.withStatements(ListUtils.concat(k.getStatements(),\n+                            k.getStatements().isEmpty() ?\n+                                    dependenciesInvocation :\n+                                    dependenciesInvocation.withPrefix(Space.format(\"\\n\\n\"))));\n+                }\n+            }\n \n-        g = (G.CompilationUnit) new InsertDependencyInOrder(configuration, gp)\n-                .visitNonNull(g, ctx, requireNonNull(getCursor().getParent()));\n+            cu = (JavaSourceFile) new InsertDependencyInOrder(configuration, gp)\n+                    .visitNonNull(cu, ctx);\n \n-        if (g != cu) {\n-            String versionWithPattern = StringUtils.isBlank(resolvedVersion) || resolvedVersion.startsWith(\"$\") ? null : resolvedVersion;\n-            g = addDependency(g,\n-                    gdc,\n-                    new GroupArtifactVersion(groupId, artifactId, versionWithPattern),\n-                    classifier,\n-                    ctx);\n+            if (cu != tree) {\n+                String versionWithPattern = StringUtils.isBlank(resolvedVersion) || resolvedVersion.startsWith(\"$\") ? null : resolvedVersion;\n+                cu = addDependency(cu,\n+                        gdc,\n+                        new GroupArtifactVersion(groupId, artifactId, versionWithPattern),\n+                        classifier,\n+                        ctx);\n+            }\n+            return cu;\n         }\n-        return g;\n+        return super.visit(tree, ctx);\n     }\n \n     /**\n@@ -138,8 +180,8 @@ public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionCon\n      * @param ctx           context which will be used to download the pom for the dependency\n      * @return a copy of buildScript with the dependency added\n      */\n-    static G.CompilationUnit addDependency(\n-            G.CompilationUnit buildScript,\n+    static JavaSourceFile addDependency(\n+            JavaSourceFile buildScript,\n             @Nullable GradleDependencyConfiguration configuration,\n             GroupArtifactVersion gav,\n             @Nullable String classifier,\n@@ -211,7 +253,7 @@ static G.CompilationUnit addDependency(\n     }\n \n     @RequiredArgsConstructor\n-    private class InsertDependencyInOrder extends GroovyIsoVisitor<ExecutionContext> {\n+    private class InsertDependencyInOrder extends JavaIsoVisitor<ExecutionContext> {\n         private final String configuration;\n \n         private final GradleProject gp;\n@@ -219,7 +261,8 @@ private class InsertDependencyInOrder extends GroovyIsoVisitor<ExecutionContext>\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n-            if (!DEPENDENCIES_DSL_MATCHER.matches(m)) {\n+            boolean isKotlinDsl = getCursor().firstEnclosing(JavaSourceFile.class) instanceof K.CompilationUnit;\n+            if (!DEPENDENCIES_DSL_MATCHER.matches(m) && !(isKotlinDsl && m.getSimpleName().equals(\"dependencies\"))) {\n                 return m;\n             }\n \n@@ -250,28 +293,53 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n             String codeTemplate;\n             DependencyStyle style = autodetectDependencyStyle(body.getStatements());\n             if (style == DependencyStyle.String) {\n-                codeTemplate = \"dependencies {\\n\" +\n-                               escapeIfNecessary(configuration) + \" \\\"\" + groupId + \":\" + artifactId + (resolvedVersion == null ? \"\" : \":\" + resolvedVersion) + (resolvedVersion == null || classifier == null ? \"\" : \":\" + classifier) + (extension == null ? \"\" : \"@\" + extension) + \"\\\"\" +\n-                               \"\\n}\";\n+                if (!isKotlinDsl) {\n+                    codeTemplate = \"dependencies {\\n\" +\n+                                   escapeIfNecessary(configuration) + \" \\\"\" + groupId + \":\" + artifactId + (resolvedVersion == null ? \"\" : \":\" + resolvedVersion) + (resolvedVersion == null || classifier == null ? \"\" : \":\" + classifier) + (extension == null ? \"\" : \"@\" + extension) + \"\\\"\" +\n+                                   \"\\n}\";\n+                } else {\n+                    codeTemplate = \"dependencies {\\n\" +\n+                                   configuration + \"(\\\"\" + groupId + \":\" + artifactId + (resolvedVersion == null ? \"\" : \":\" + resolvedVersion) + (resolvedVersion == null || classifier == null ? \"\" : \":\" + classifier) + (extension == null ? \"\" : \"@\" + extension) + \"\\\")\" +\n+                                   \"\\n}\";\n+                }\n             } else {\n-                codeTemplate = \"dependencies {\\n\" +\n-                               escapeIfNecessary(configuration) + \" group: \\\"\" + groupId + \"\\\", name: \\\"\" + artifactId + \"\\\"\" + (resolvedVersion == null ? \"\" : \", version: \\\"\" + resolvedVersion + \"\\\"\") + (classifier == null ? \"\" : \", classifier: \\\"\" + classifier + \"\\\"\") + (extension == null ? \"\" : \", ext: \\\"\" + extension + \"\\\"\") +\n-                               \"\\n}\";\n+                if (!isKotlinDsl) {\n+                    codeTemplate = \"dependencies {\\n\" +\n+                                   escapeIfNecessary(configuration) + \" group: \\\"\" + groupId + \"\\\", name: \\\"\" + artifactId + \"\\\"\" + (resolvedVersion == null ? \"\" : \", version: \\\"\" + resolvedVersion + \"\\\"\") + (classifier == null ? \"\" : \", classifier: \\\"\" + classifier + \"\\\"\") + (extension == null ? \"\" : \", ext: \\\"\" + extension + \"\\\"\") +\n+                                   \"\\n}\";\n+                } else {\n+                    codeTemplate = \"dependencies {\\n\" +\n+                                   configuration + \"(group = \\\"\" + groupId + \"\\\", name = \\\"\" + artifactId + \"\\\"\" + (resolvedVersion == null ? \"\" : \", version = \\\"\" + resolvedVersion + \"\\\"\") + (classifier == null ? \"\" : \", classifier = \\\"\" + classifier + \"\\\"\") + (extension == null ? \"\" : \", ext = \\\"\" + extension + \"\\\"\") + \")\" +\n+                                   \"\\n}\";\n+                }\n             }\n \n             Boolean requirePrintEqualsInput = ctx.getMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT);\n             ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, false);\n-            SourceFile parsed = GRADLE_PARSER.parse(ctx, codeTemplate)\n-                    .findFirst()\n-                    .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"));\n+            SourceFile parsed;\n+            if (!isKotlinDsl) {\n+                parsed = GRADLE_PARSER.parse(ctx, codeTemplate)\n+                        .findFirst()\n+                        .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"));\n+            } else {\n+                parsed = GRADLE_PARSER.parseInputs(Collections.singletonList(new GradleParser.Input(Paths.get(\"build.gradle.kts\"), () -> new ByteArrayInputStream(codeTemplate.getBytes(StandardCharsets.UTF_8)))), null, ctx)\n+                        .findFirst()\n+                        .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"));\n+            }\n             ctx.putMessage(ExecutionContext.REQUIRE_PRINT_EQUALS_INPUT, requirePrintEqualsInput);\n \n             if (parsed instanceof ParseError) {\n                 throw ((ParseError) parsed).toException();\n             }\n \n-            J.MethodInvocation addDependencyInvocation = requireNonNull((J.MethodInvocation) ((J.Return) (((J.Block) ((J.Lambda) ((J.MethodInvocation)\n-                    ((G.CompilationUnit) parsed).getStatements().get(0)).getArguments().get(0)).getBody()).getStatements().get(0))).getExpression());\n+            J.MethodInvocation addDependencyInvocation;\n+            if (!isKotlinDsl) {\n+                addDependencyInvocation = requireNonNull((J.MethodInvocation) ((J.Return) (((J.Block) ((J.Lambda) ((J.MethodInvocation)\n+                        ((G.CompilationUnit) parsed).getStatements().get(0)).getArguments().get(0)).getBody()).getStatements().get(0))).getExpression());\n+            } else {\n+                addDependencyInvocation = requireNonNull((J.MethodInvocation) (((J.Block) ((J.Lambda) ((J.MethodInvocation)\n+                        ((J.Block) ((K.CompilationUnit) parsed).getStatements().get(0)).getStatements().get(0)).getArguments().get(0)).getBody()).getStatements().get(0)));\n+            }\n             addDependencyInvocation = autoFormat(addDependencyInvocation, ctx, new Cursor(getCursor(), body));\n             InsertDependencyComparator dependencyComparator = new InsertDependencyComparator(body.getStatements(), addDependencyInvocation);\n \n@@ -347,6 +415,8 @@ private DependencyStyle autodetectDependencyStyle(List<Statement> statements) {\n                     string++;\n                 } else if (invocation.getArguments().get(0) instanceof G.MapEntry) {\n                     map++;\n+                } else if (invocation.getArguments().get(0) instanceof J.Assignment) {\n+                    map++;\n                 }\n             } else if (statement instanceof J.MethodInvocation) {\n                 J.MethodInvocation invocation = (J.MethodInvocation) statement;\n@@ -354,6 +424,8 @@ private DependencyStyle autodetectDependencyStyle(List<Statement> statements) {\n                     string++;\n                 } else if (invocation.getArguments().get(0) instanceof G.MapEntry) {\n                     map++;\n+                } else if (invocation.getArguments().get(0) instanceof J.Assignment) {\n+                    map++;\n                 }\n             }\n         }\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/ChangeDependency.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/ChangeDependency.java\nindex 30c22441aed..ff070a4eaeb 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/ChangeDependency.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/ChangeDependency.java\n@@ -27,13 +27,16 @@\n import org.openrewrite.gradle.marker.GradleProject;\n import org.openrewrite.gradle.search.FindGradleProject;\n import org.openrewrite.gradle.trait.GradleDependency;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.tree.Expression;\n import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaSourceFile;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.maven.MavenDownloadingException;\n+import org.openrewrite.maven.table.MavenMetadataFailures;\n import org.openrewrite.maven.tree.GroupArtifact;\n import org.openrewrite.maven.tree.GroupArtifactVersion;\n import org.openrewrite.maven.tree.ResolvedGroupArtifactVersion;\n@@ -102,6 +105,7 @@ public class ChangeDependency extends Recipe {\n     // Minimize the number of allocations by caching the updated dependencies.\n     transient Map<org.openrewrite.maven.tree.Dependency, org.openrewrite.maven.tree.Dependency> updatedRequested = new HashMap<>();\n     transient Map<org.openrewrite.maven.tree.ResolvedDependency, org.openrewrite.maven.tree.ResolvedDependency> updatedResolved = new HashMap<>();\n+    transient MavenMetadataFailures mavenMetadataFailures = new MavenMetadataFailures(this);\n \n     @Override\n     public String getDisplayName() {\n@@ -140,25 +144,34 @@ public Validated<Object> validate() {\n \n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(new FindGradleProject(FindGradleProject.SearchCriteria.Marker).getVisitor(), new GroovyIsoVisitor<ExecutionContext>() {\n+        return Preconditions.check(new FindGradleProject(FindGradleProject.SearchCriteria.Marker).getVisitor(), new JavaIsoVisitor<ExecutionContext>() {\n             final DependencyMatcher depMatcher = requireNonNull(DependencyMatcher.build(oldGroupId + \":\" + oldArtifactId).getValue());\n \n             GradleProject gradleProject;\n \n             @Override\n-            public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n-                Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);\n-                if (!maybeGp.isPresent()) {\n-                    return cu;\n-                }\n+            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {\n+                return sourceFile instanceof G.CompilationUnit || sourceFile instanceof K.CompilationUnit;\n+            }\n \n-                gradleProject = maybeGp.get();\n+            @Override\n+            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                if (tree instanceof JavaSourceFile) {\n+                    JavaSourceFile sourceFile = (JavaSourceFile) tree;\n+                    Optional<GradleProject> maybeGp = sourceFile.getMarkers().findFirst(GradleProject.class);\n+                    if (!maybeGp.isPresent()) {\n+                        return sourceFile;\n+                    }\n \n-                G.CompilationUnit g = super.visitCompilationUnit(cu, ctx);\n-                if (g != cu) {\n-                    g = g.withMarkers(g.getMarkers().setByType(updateGradleModel(gradleProject)));\n+                    gradleProject = maybeGp.get();\n+\n+                    sourceFile = (JavaSourceFile) super.visit(sourceFile, ctx);\n+                    if (sourceFile != tree) {\n+                        sourceFile = sourceFile.withMarkers(sourceFile.getMarkers().setByType(updateGradleModel(gradleProject)));\n+                    }\n+                    return sourceFile;\n                 }\n-                return g;\n+                return super.visit(tree, ctx);\n             }\n \n             @Override\n@@ -174,7 +187,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                 }\n \n                 List<Expression> depArgs = m.getArguments();\n-                if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry || depArgs.get(0) instanceof G.MapLiteral) {\n+                if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry || depArgs.get(0) instanceof G.MapLiteral || depArgs.get(0) instanceof J.Assignment || depArgs.get(0) instanceof K.StringTemplate) {\n                     m = updateDependency(m, ctx);\n                 } else if (depArgs.get(0) instanceof J.MethodInvocation &&\n                            (((J.MethodInvocation) depArgs.get(0)).getSimpleName().equals(\"platform\") ||\n@@ -425,6 +438,127 @@ private J.MethodInvocation updateDependency(J.MethodInvocation m, ExecutionConte\n                             }));\n                         }));\n                     }\n+                } else if (m.getArguments().get(0) instanceof J.Assignment) {\n+                    J.Assignment groupAssignment = null;\n+                    J.Assignment artifactAssignment = null;\n+                    J.Assignment versionAssignment = null;\n+                    String groupId = null;\n+                    String artifactId = null;\n+                    String version = null;\n+\n+                    for (Expression e : depArgs) {\n+                        if (!(e instanceof J.Assignment)) {\n+                            continue;\n+                        }\n+                        J.Assignment arg = (J.Assignment) e;\n+                        if (!(arg.getVariable() instanceof J.Identifier) || !(arg.getAssignment() instanceof J.Literal)) {\n+                            continue;\n+                        }\n+                        J.Identifier identifier = (J.Identifier) arg.getVariable();\n+                        J.Literal assignment = (J.Literal) arg.getAssignment();\n+                        if (!(assignment.getValue() instanceof String)) {\n+                            continue;\n+                        }\n+                        String valueValue = (String) assignment.getValue();\n+                        switch (identifier.getSimpleName()) {\n+                            case \"group\":\n+                                groupAssignment = arg;\n+                                groupId = valueValue;\n+                                break;\n+                            case \"name\":\n+                                artifactAssignment = arg;\n+                                artifactId = valueValue;\n+                                break;\n+                            case \"version\":\n+                                versionAssignment = arg;\n+                                version = valueValue;\n+                                break;\n+                        }\n+                    }\n+                    if (groupId == null || artifactId == null) {\n+                        return m;\n+                    }\n+                    if (!depMatcher.matches(groupId, artifactId)) {\n+                        return m;\n+                    }\n+                    String updatedGroupId = groupId;\n+                    if (!StringUtils.isBlank(newGroupId) && !updatedGroupId.equals(newGroupId)) {\n+                        updatedGroupId = newGroupId;\n+                    }\n+                    String updatedArtifactId = artifactId;\n+                    if (!StringUtils.isBlank(newArtifactId) && !updatedArtifactId.equals(newArtifactId)) {\n+                        updatedArtifactId = newArtifactId;\n+                    }\n+                    String updatedVersion = version;\n+                    if (!StringUtils.isBlank(newVersion) && (!StringUtils.isBlank(version) || Boolean.TRUE.equals(overrideManagedVersion))) {\n+                        String resolvedVersion;\n+                        try {\n+                            resolvedVersion = new DependencyVersionSelector(mavenMetadataFailures, gradleProject, null)\n+                                    .select(new GroupArtifact(updatedGroupId, updatedArtifactId), m.getSimpleName(), newVersion, versionPattern, ctx);\n+                        } catch (MavenDownloadingException e) {\n+                            return e.warn(m);\n+                        }\n+                        if (resolvedVersion != null && !resolvedVersion.equals(updatedVersion)) {\n+                            updatedVersion = resolvedVersion;\n+                        }\n+                    }\n+\n+                    if (!updatedGroupId.equals(groupId) || !updatedArtifactId.equals(artifactId) || updatedVersion != null && !updatedVersion.equals(version)) {\n+                        J.Assignment finalGroup = groupAssignment;\n+                        String finalGroupIdValue = updatedGroupId;\n+                        J.Assignment finalArtifact = artifactAssignment;\n+                        String finalArtifactIdValue = updatedArtifactId;\n+                        J.Assignment finalVersion = versionAssignment;\n+                        String finalVersionValue = updatedVersion;\n+                        m = m.withArguments(ListUtils.map(m.getArguments(), arg -> {\n+                            if (arg == finalGroup) {\n+                                return finalGroup.withAssignment(ChangeStringLiteral.withStringValue((J.Literal) finalGroup.getAssignment(), finalGroupIdValue));\n+                            }\n+                            if (arg == finalArtifact) {\n+                                return finalArtifact.withAssignment(ChangeStringLiteral.withStringValue((J.Literal) finalArtifact.getAssignment(), finalArtifactIdValue));\n+                            }\n+                            if (arg == finalVersion) {\n+                                return finalVersion.withAssignment(ChangeStringLiteral.withStringValue((J.Literal) finalVersion.getAssignment(), finalVersionValue));\n+                            }\n+                            return arg;\n+                        }));\n+                    }\n+                } else if (depArgs.get(0) instanceof K.StringTemplate) {\n+                    K.StringTemplate template = (K.StringTemplate) depArgs.get(0);\n+                    List<J> strings = template.getStrings();\n+                    if (strings.size() >= 2 && strings.get(0) instanceof J.Literal &&\n+                            ((J.Literal) strings.get(0)).getValue() != null) {\n+\n+                        J.Literal literal = (J.Literal) strings.get(0);\n+                        Dependency original = DependencyStringNotationConverter.parse((String) requireNonNull(literal.getValue()));\n+                        if (original != null) {\n+                            Dependency updated = original;\n+                            if (!StringUtils.isBlank(newGroupId) && !updated.getGroupId().equals(newGroupId)) {\n+                                updated = updated.withGroupId(newGroupId);\n+                            }\n+                            if (!StringUtils.isBlank(newArtifactId) && !updated.getArtifactId().equals(newArtifactId)) {\n+                                updated = updated.withArtifactId(newArtifactId);\n+                            }\n+                            if (!StringUtils.isBlank(newVersion)) {\n+                                String resolvedVersion;\n+                                try {\n+                                    resolvedVersion = new DependencyVersionSelector(mavenMetadataFailures, gradleProject, null)\n+                                            .select(new GroupArtifact(updated.getGroupId(), updated.getArtifactId()), m.getSimpleName(), newVersion, versionPattern, ctx);\n+                                } catch (MavenDownloadingException e) {\n+                                    return e.warn(m);\n+                                }\n+                                if (resolvedVersion != null && !resolvedVersion.equals(updated.getVersion())) {\n+                                    updated = updated.withVersion(resolvedVersion);\n+                                }\n+                            }\n+                            if (original != updated) {\n+                                String replacement = updated.toStringNotation();\n+                                J.Literal newLiteral = literal.withValue(replacement)\n+                                        .withValueSource(template.getDelimiter() + replacement + template.getDelimiter());\n+                                m = m.withArguments(Collections.singletonList(newLiteral));\n+                            }\n+                        }\n+                    }\n                 }\n \n                 return m;\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyConstraintToRule.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyConstraintToRule.java\nindex cccdf2e63ba..58daf572f0d 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyConstraintToRule.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyConstraintToRule.java\n@@ -19,15 +19,21 @@\n import org.intellij.lang.annotations.Language;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n import org.openrewrite.groovy.GroovyParser;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.MethodMatcher;\n import org.openrewrite.java.tree.*;\n+import org.openrewrite.kotlin.KotlinParser;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.marker.Markers;\n \n+import java.io.ByteArrayInputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -59,18 +65,20 @@ public String getDescription() {\n \n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(new IsBuildGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {\n+        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {\n             @Override\n-            public G.CompilationUnit visitCompilationUnit(G.CompilationUnit compilationUnit, ExecutionContext ctx) {\n-                List<GroupArtifactVersionBecause> gavs = new ArrayList<>();\n-                Cursor parent = requireNonNull(getCursor().getParent());\n-                G.CompilationUnit cu = (G.CompilationUnit) new RemoveConstraints().visitNonNull(compilationUnit, gavs, parent);\n-                if (gavs.isEmpty()) {\n-                    return compilationUnit;\n+            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                if (tree instanceof JavaSourceFile) {\n+                    List<GroupArtifactVersionBecause> gavs = new ArrayList<>();\n+                    JavaSourceFile cu = (JavaSourceFile) new RemoveConstraints().visitNonNull(tree, gavs);\n+                    if (gavs.isEmpty()) {\n+                        return (J) tree;\n+                    }\n+                    cu = (JavaSourceFile) new MaybeAddEachDependency().visitNonNull(cu, ctx);\n+                    cu = (JavaSourceFile) new UpdateEachDependency(gavs, cu instanceof K.CompilationUnit).visitNonNull(cu, ctx);\n+                    return cu;\n                 }\n-                cu = (G.CompilationUnit) new MaybeAddEachDependency().visitNonNull(cu, ctx, parent);\n-                cu = (G.CompilationUnit) new UpdateEachDependency(gavs).visitNonNull(cu, ctx, parent);\n-                return cu;\n+                return super.visit(tree, ctx);\n             }\n         });\n     }\n@@ -89,7 +97,7 @@ static class GroupArtifactVersionBecause {\n         String because;\n     }\n \n-    static class RemoveConstraints extends GroovyIsoVisitor<List<GroupArtifactVersionBecause>> {\n+    static class RemoveConstraints extends JavaIsoVisitor<List<GroupArtifactVersionBecause>> {\n \n         @SuppressWarnings({\"DataFlowIssue\", \"NullableProblems\"})\n         @Override\n@@ -122,7 +130,7 @@ static class RemoveConstraints extends GroovyIsoVisitor<List<GroupArtifactVersio\n                         return statement;\n                     }\n                     AtomicReference<String> because = new AtomicReference<>(null);\n-                    new GroovyIsoVisitor<Integer>() {\n+                    new JavaIsoVisitor<Integer>() {\n                         @Override\n                         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Integer integer) {\n                             J.MethodInvocation m1 = super.visitMethodInvocation(method, integer);\n@@ -149,16 +157,17 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Integ\n \n     @Value\n     @EqualsAndHashCode(callSuper = false)\n-    static class UpdateEachDependency extends GroovyIsoVisitor<ExecutionContext> {\n+    static class UpdateEachDependency extends JavaIsoVisitor<ExecutionContext> {\n         List<GroupArtifactVersionBecause> groupArtifactVersions;\n+        boolean isKotlinDsl;\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n             if (isEachDependency(m)) {\n                 Cursor parent = requireNonNull(getCursor().getParent());\n                 for (GroupArtifactVersionBecause gav : groupArtifactVersions) {\n-                    m = (J.MethodInvocation) new MaybeAddIf(gav).visitNonNull(m, ctx, parent);\n-                    m = (J.MethodInvocation) new UpdateIf(gav).visitNonNull(m, ctx, parent);\n+                    m = (J.MethodInvocation) new MaybeAddIf(gav, isKotlinDsl).visitNonNull(m, ctx, parent);\n+                    m = (J.MethodInvocation) new UpdateIf(gav, isKotlinDsl).visitNonNull(m, ctx, parent);\n                 }\n             }\n             return m;\n@@ -166,10 +175,12 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n     }\n \n     @RequiredArgsConstructor\n-    static class MaybeAddIf extends GroovyIsoVisitor<ExecutionContext> {\n+    static class MaybeAddIf extends JavaIsoVisitor<ExecutionContext> {\n         @NonNull\n         GroupArtifactVersionBecause groupArtifactVersion;\n \n+        final boolean isKotlinDsl;\n+\n         boolean containsAnyIfStatement;\n         boolean containsMatchingIfStatement;\n \n@@ -194,19 +205,33 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                 return m;\n             }\n             String p = ((J.VariableDeclarations) rawParam).getVariables().get(0).getSimpleName();\n-            @SuppressWarnings(\"GroovyEmptyStatementBody\") @Language(\"groovy\")\n-            String snippet = \"Object \" + p + \" = null\\n\" +\n-                             \"if (\" + p + \".requested.group == '\" + groupArtifactVersion.getGroupId() + \"' && \" +\n-                             p + \".requested.name == '\" + groupArtifactVersion.getArtifactId() + \"') {\\n}\";\n-            J.If newIf = GroovyParser.builder().build()\n-                    .parse(ctx, snippet)\n-                    .map(G.CompilationUnit.class::cast)\n-                    .map(cu -> cu.getStatements().get(1))\n-                    .map(J.If.class::cast)\n-                    .findFirst()\n-                    .orElseThrow(() -> new IllegalStateException(\"Unable to produce a new if statement\"));\n+            J.If newIf;\n+            if (!isKotlinDsl) {\n+                @SuppressWarnings(\"GroovyEmptyStatementBody\") @Language(\"groovy\")\n+                String snippet = \"Object \" + p + \" = null\\n\" +\n+                                 \"if (\" + p + \".requested.group == '\" + groupArtifactVersion.getGroupId() + \"' && \" +\n+                                 p + \".requested.name == '\" + groupArtifactVersion.getArtifactId() + \"') {\\n}\";\n+                newIf = GroovyParser.builder().build()\n+                        .parse(ctx, snippet)\n+                        .map(G.CompilationUnit.class::cast)\n+                        .map(cu -> cu.getStatements().get(1))\n+                        .map(J.If.class::cast)\n+                        .findFirst()\n+                        .orElseThrow(() -> new IllegalStateException(\"Unable to produce a new if statement\"));\n+            } else {\n+                String snippet = \"var \" + p + \": Any = null\\n\" +\n+                                 \"if (\" + p + \".requested.group == \\\"\" + groupArtifactVersion.getGroupId() + \"\\\" && \" +\n+                                 p + \".requested.name == \\\"\" + groupArtifactVersion.getArtifactId() + \"\\\") {\\n}\";\n+                newIf = KotlinParser.builder().isKotlinScript(true).build()\n+                        .parse(ctx, snippet)\n+                        .map(K.CompilationUnit.class::cast)\n+                        .map(cu -> (J.Block) cu.getStatements().get(0))\n+                        .map(block -> (J.If) block.getStatements().get(1))\n+                        .findFirst()\n+                        .orElseThrow(() -> new IllegalStateException(\"Unable to produce a new if statement\"));\n+            }\n             if (containsAnyIfStatement) {\n-                m = (J.MethodInvocation) new GroovyIsoVisitor<Integer>() {\n+                m = (J.MethodInvocation) new JavaIsoVisitor<Integer>() {\n                     boolean inserted;\n \n                     @Override\n@@ -253,8 +278,9 @@ public J.If visitIf(J.If iff, ExecutionContext ctx) {\n     }\n \n     @AllArgsConstructor\n-    static class UpdateIf extends GroovyIsoVisitor<ExecutionContext> {\n+    static class UpdateIf extends JavaIsoVisitor<ExecutionContext> {\n         GroupArtifactVersionBecause groupArtifactVersionBecause;\n+        boolean isKotlinDsl;\n \n         @Override\n         public J.If visitIf(J.If iff, ExecutionContext ctx) {\n@@ -262,7 +288,7 @@ public J.If visitIf(J.If iff, ExecutionContext ctx) {\n             if (predicateRelatesToGav(anIf, groupArtifactVersionBecause)) {\n                 // The predicate of the if condition will already contain the relevant variable name\n                 AtomicReference<String> variableName = new AtomicReference<>();\n-                new GroovyIsoVisitor<Integer>() {\n+                new JavaIsoVisitor<Integer>() {\n                     @Override\n                     public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, Integer integer) {\n                         // Comparison will involve \"<variable name>.requested.group\"\n@@ -273,18 +299,36 @@ public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, Integer integer\n                         return fieldAccess;\n                     }\n                 }.visit(anIf.getIfCondition(), 0);\n-                @Language(\"groovy\")\n-                String snippet = variableName + \".useVersion('\" + groupArtifactVersionBecause.getVersion() + \"')\\n\";\n-                if(groupArtifactVersionBecause.getBecause() != null) {\n-                    snippet += variableName + \".because('\" + groupArtifactVersionBecause.getBecause() + \"')\\n\";\n+                List<Statement> newStatements;\n+                if (!isKotlinDsl) {\n+                    @Language(\"groovy\")\n+                    String snippet = variableName + \".useVersion('\" + groupArtifactVersionBecause.getVersion() + \"')\\n\";\n+                    if (groupArtifactVersionBecause.getBecause() != null) {\n+                        snippet += variableName + \".because('\" + groupArtifactVersionBecause.getBecause() + \"')\\n\";\n+                    }\n+                    newStatements = GroovyParser.builder()\n+                            .build()\n+                            .parse(ctx, snippet)\n+                            .map(G.CompilationUnit.class::cast)\n+                            .map(G.CompilationUnit::getStatements)\n+                            .findFirst()\n+                            .orElseThrow(() -> new IllegalStateException(\"Unable to produce a new block statement\"));\n+                } else {\n+                    @Language(\"kotlin\")\n+                    String snippet = variableName + \".useVersion(\\\"\" + groupArtifactVersionBecause.getVersion() + \"\\\")\\n\";\n+                    if (groupArtifactVersionBecause.getBecause() != null) {\n+                        snippet += variableName + \".because(\\\"\" + groupArtifactVersionBecause.getBecause() + \"\\\")\\n\";\n+                    }\n+                    newStatements = KotlinParser.builder()\n+                            .isKotlinScript(true)\n+                            .build()\n+                            .parse(ctx, snippet)\n+                            .map(K.CompilationUnit.class::cast)\n+                            .map(cu -> (J.Block) cu.getStatements().get(0))\n+                            .map(J.Block::getStatements)\n+                            .findFirst()\n+                            .orElseThrow(() -> new IllegalStateException(\"Unable to produce a new block statement\"));\n                 }\n-                List<Statement> newStatements = GroovyParser.builder()\n-                        .build()\n-                        .parse(ctx, snippet)\n-                        .map(G.CompilationUnit.class::cast)\n-                        .map(G.CompilationUnit::getStatements)\n-                        .findFirst()\n-                        .orElseThrow(() -> new IllegalStateException(\"Unable to produce a new block statement\"));\n                 J.Block block = (J.Block) anIf.getThenPart();\n                 block = block.withStatements(newStatements);\n                 block = autoFormat(block, ctx, getCursor());\n@@ -294,42 +338,9 @@ public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, Integer integer\n         }\n     }\n \n-    static class MaybeAddEachDependency extends GroovyIsoVisitor<ExecutionContext> {\n+    static class MaybeAddEachDependency extends JavaIsoVisitor<ExecutionContext> {\n         boolean alreadyExists;\n \n-        @Override\n-        public G.CompilationUnit visitCompilationUnit(G.CompilationUnit compilationUnit, ExecutionContext ctx) {\n-            G.CompilationUnit cu = super.visitCompilationUnit(compilationUnit, ctx);\n-            if (alreadyExists) {\n-                return cu;\n-            }\n-            // Prefer to insert before the dependencies block for readability\n-            int insertionIndex = 0;\n-            while (insertionIndex < cu.getStatements().size()) {\n-                Statement s = cu.getStatements().get(insertionIndex);\n-                if (s instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) s)) {\n-                    break;\n-                }\n-                insertionIndex++;\n-            }\n-            J.MethodInvocation m = GradleParser.builder()\n-                    .build()\n-                    .parse(ctx,\n-                           \"\\n\" +\n-                           \"configurations.all {\\n\" +\n-                           \"    resolutionStrategy.eachDependency { details ->\\n\" +\n-                           \"    }\\n\" +\n-                           \"}\")\n-                    .map(G.CompilationUnit.class::cast)\n-                    .map(G.CompilationUnit::getStatements)\n-                    .map(it -> it.get(0))\n-                    .map(J.MethodInvocation.class::cast)\n-                    .findFirst()\n-                    .orElseThrow(() -> new IllegalStateException(\"Unable to create a new configurations.all block\"));\n-            cu = cu.withStatements(ListUtils.insert(cu.getStatements(), m, insertionIndex));\n-            return cu;\n-        }\n-\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n@@ -345,6 +356,88 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n             if (alreadyExists) {\n                 return (J) tree;\n             }\n+            if (tree instanceof JavaSourceFile) {\n+                JavaSourceFile sourceFile = (JavaSourceFile) super.visit(tree, ctx);\n+                if (alreadyExists) {\n+                    return sourceFile;\n+                }\n+                // Prefer to insert before the dependencies block for readability\n+                if (sourceFile instanceof G.CompilationUnit) {\n+                    G.CompilationUnit cu = (G.CompilationUnit) sourceFile;\n+                    int insertionIndex = 0;\n+                    while (insertionIndex < cu.getStatements().size()) {\n+                        Statement s = cu.getStatements().get(insertionIndex);\n+                        if (s instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) s)) {\n+                            break;\n+                        }\n+                        insertionIndex++;\n+                    }\n+                    J.MethodInvocation m = GradleParser.builder()\n+                            .build()\n+                            .parse(ctx,\n+                                    \"\\n\" +\n+                                    \"configurations.all {\\n\" +\n+                                    \"    resolutionStrategy.eachDependency { details ->\\n\" +\n+                                    \"    }\\n\" +\n+                                    \"}\")\n+                            .map(G.CompilationUnit.class::cast)\n+                            .map(G.CompilationUnit::getStatements)\n+                            .map(it -> it.get(0))\n+                            .map(J.MethodInvocation.class::cast)\n+                            .findFirst()\n+                            .orElseThrow(() -> new IllegalStateException(\"Unable to create a new configurations.all block\"));\n+                    cu = cu.withStatements(ListUtils.insert(cu.getStatements(), m, insertionIndex));\n+                    return cu;\n+                } else {\n+                    K.CompilationUnit cu = (K.CompilationUnit) sourceFile;\n+                    J.Block block = (J.Block) cu.getStatements().get(0);\n+                    int insertionIndex = 0;\n+                    while (insertionIndex < block.getStatements().size()) {\n+                        Statement s = block.getStatements().get(insertionIndex);\n+                        if (s instanceof J.MethodInvocation && ((J.MethodInvocation) s).getSimpleName().equals(\"dependencies\")) {\n+                            break;\n+                        }\n+                        insertionIndex++;\n+                    }\n+                    J.MethodInvocation m = GradleParser.builder()\n+                            .build()\n+                            .parseInputs(Collections.singletonList(\n+                                    new Parser.Input(\n+                                            Paths.get(\"build.gradle.kts\"),\n+                                            () -> new ByteArrayInputStream(\n+                                                    (\"\\n\" +\n+                                                     \"configurations.all {\\n\" +\n+                                                     \"    resolutionStrategy.eachDependency { details ->}\\n\" +\n+                                                     \"}\").getBytes(StandardCharsets.UTF_8)))\n+                                    ), null, ctx)\n+                            .map(K.CompilationUnit.class::cast)\n+                            .map(k -> (J.Block) k.getStatements().get(0))\n+                            .map(J.Block::getStatements)\n+                            .map(it -> it.get(0))\n+                            .map(J.MethodInvocation.class::cast)\n+                            .findFirst()\n+                            .map(m2 -> m2.withArguments(ListUtils.mapFirst(m2.getArguments(), arg -> {\n+                                J.Lambda lambda1 = (J.Lambda) arg;\n+                                J.Block block1 = (J.Block) lambda1.getBody();\n+                                return lambda1.withBody(block1.withStatements(ListUtils.mapFirst(block1.getStatements(), arg2 -> {\n+                                    J.MethodInvocation m3 = (J.MethodInvocation) arg2;\n+                                    return m3.withArguments(ListUtils.mapFirst(m3.getArguments(), arg3 -> {\n+                                        J.Lambda lambda2 = (J.Lambda) arg3;\n+                                        return lambda2.withBody(((J.Block) lambda2.getBody()).withEnd(Space.format(\"\\n\")));\n+                                    }));\n+                                })));\n+                            })))\n+                            .orElseThrow(() -> new IllegalStateException(\"Unable to create a new configurations.all block\"));\n+                    final int finalInsertionIndex = insertionIndex;\n+                    cu = cu.withStatements(ListUtils.mapFirst(cu.getStatements(), arg -> {\n+                        if (arg == block) {\n+                            return block.withStatements(ListUtils.insert(block.getStatements(), m, finalInsertionIndex));\n+                        }\n+                        return arg;\n+                    }));\n+                    return cu;\n+                }\n+            }\n             return super.visit(tree, ctx);\n         }\n     }\n@@ -352,7 +445,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n     private static boolean isInDependenciesBlock(Cursor cursor) {\n         Cursor c = cursor.dropParentUntil(value ->\n                 value == Cursor.ROOT_VALUE ||\n-                (value instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) value)));\n+                (value instanceof J.MethodInvocation && ((J.MethodInvocation) value).getSimpleName().equals(\"dependencies\")));\n         return c.getValue() instanceof J.MethodInvocation;\n     }\n \n@@ -375,7 +468,7 @@ private static boolean predicateRelatesToGav(J.If iff, GroupArtifactVersionBecau\n         // GroupId and artifactId might be compared in either order or this could be an unrelated comparison\n         AtomicBoolean groupIdCompared = new AtomicBoolean();\n         AtomicBoolean artifactIdCompared = new AtomicBoolean();\n-        new GroovyIsoVisitor<GroupArtifactVersionBecause>() {\n+        new JavaIsoVisitor<GroupArtifactVersionBecause>() {\n             @Override\n             public J.Binary visitBinary(J.Binary binary, GroupArtifactVersionBecause groupArtifactVersion) {\n                 J.Binary b = super.visitBinary(binary, groupArtifactVersion);\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsBuildGradle.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsBuildGradle.java\nindex 6ec3e360e14..ed636a77d3f 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsBuildGradle.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsBuildGradle.java\n@@ -15,6 +15,7 @@\n  */\n package org.openrewrite.gradle;\n \n+import org.jspecify.annotations.NonNull;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.Tree;\n import org.openrewrite.TreeVisitor;\n@@ -23,18 +24,17 @@\n \n import java.nio.file.Path;\n \n-import static java.util.Objects.requireNonNull;\n-\n public class IsBuildGradle<P> extends TreeVisitor<Tree, P> {\n     @Override\n-    public Tree visit(@Nullable Tree tree, P p) {\n+    public @Nullable Tree preVisit(@NonNull Tree tree, P p) {\n+        stopAfterPreVisit();\n         if (tree instanceof JavaSourceFile) {\n-            JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);\n-            if (matches(cu.getSourcePath())) {\n-                return SearchResult.found(cu);\n+            JavaSourceFile sourceFile = (JavaSourceFile) tree;\n+            if (matches(sourceFile.getSourcePath())) {\n+                return SearchResult.found(sourceFile);\n             }\n         }\n-        return super.visit(tree, p);\n+        return tree;\n     }\n \n     public static boolean matches(Path sourcePath) {\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsSettingsGradle.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsSettingsGradle.java\nindex 8bdf7f559c9..77172dac31f 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsSettingsGradle.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/IsSettingsGradle.java\n@@ -15,24 +15,24 @@\n  */\n package org.openrewrite.gradle;\n \n+import org.jspecify.annotations.NonNull;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.Tree;\n import org.openrewrite.TreeVisitor;\n import org.openrewrite.java.tree.JavaSourceFile;\n import org.openrewrite.marker.SearchResult;\n \n-import static java.util.Objects.requireNonNull;\n-\n public class IsSettingsGradle<P> extends TreeVisitor<Tree, P> {\n     @Override\n-    public Tree visit(@Nullable Tree tree, P p) {\n+    public @Nullable Tree preVisit(@NonNull Tree tree, P p) {\n+        stopAfterPreVisit();\n         if (tree instanceof JavaSourceFile) {\n-            JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);\n+            JavaSourceFile cu = (JavaSourceFile) tree;\n             if (cu.getSourcePath().toString().endsWith(\"settings.gradle\") ||\n-                cu.getSourcePath().toString().endsWith(\"settings.gradle.kts\")) {\n+                    cu.getSourcePath().toString().endsWith(\"settings.gradle.kts\")) {\n                 return SearchResult.found(cu);\n             }\n         }\n-        return super.visit(tree, p);\n+        return tree;\n     }\n }\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/RemoveDependency.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/RemoveDependency.java\nindex b05ac29701b..d9fb94ca5e8 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/RemoveDependency.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/RemoveDependency.java\n@@ -22,11 +22,13 @@\n import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n import org.openrewrite.gradle.trait.GradleDependency;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaSourceFile;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.semver.DependencyMatcher;\n \n import java.util.HashMap;\n@@ -73,7 +75,7 @@ public String getDescription() {\n \n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n-        return Preconditions.check(new IsBuildGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {\n+        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {\n             final GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher()\n                     .configuration(configuration)\n                     .groupId(groupId)\n@@ -83,19 +85,28 @@ public TreeVisitor<?, ExecutionContext> getVisitor() {\n             GradleProject gradleProject;\n \n             @Override\n-            public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n-                Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);\n-                if (!maybeGp.isPresent()) {\n-                    return cu;\n-                }\n+            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {\n+                return sourceFile instanceof G.CompilationUnit || sourceFile instanceof K.CompilationUnit;\n+            }\n+\n+            @Override\n+            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                if (tree instanceof JavaSourceFile) {\n+                    JavaSourceFile sourceFile = (JavaSourceFile) tree;\n+                    Optional<GradleProject> maybeGp = sourceFile.getMarkers().findFirst(GradleProject.class);\n+                    if (!maybeGp.isPresent()) {\n+                        return sourceFile;\n+                    }\n \n-                gradleProject = maybeGp.get();\n+                    gradleProject = maybeGp.get();\n \n-                G.CompilationUnit g = super.visitCompilationUnit(cu, ctx);\n-                if (g != cu) {\n-                    g = g.withMarkers(g.getMarkers().setByType(updateGradleModel(gradleProject)));\n+                    sourceFile = (JavaSourceFile) super.visit(sourceFile, ctx);\n+                    if (sourceFile != tree) {\n+                        sourceFile = sourceFile.withMarkers(sourceFile.getMarkers().setByType(updateGradleModel(gradleProject)));\n+                    }\n+                    return sourceFile;\n                 }\n-                return g;\n+                return super.visit(tree, ctx);\n             }\n \n             @Override\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java\nindex 30a6684577d..c6a16da0dc6 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java\n@@ -27,15 +27,16 @@\n import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n import org.openrewrite.gradle.trait.GradleDependency;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n-import org.openrewrite.groovy.GroovyVisitor;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n+import org.openrewrite.java.JavaVisitor;\n import org.openrewrite.java.tree.Expression;\n import org.openrewrite.java.tree.J;\n import org.openrewrite.java.tree.JavaSourceFile;\n import org.openrewrite.java.tree.JavaType;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.marker.Markup;\n import org.openrewrite.maven.MavenDownloadingException;\n import org.openrewrite.maven.MavenDownloadingExceptions;\n@@ -143,17 +144,23 @@ public DependencyVersionState getInitialValue(ExecutionContext ctx) {\n     public TreeVisitor<?, ExecutionContext> getScanner(DependencyVersionState acc) {\n \n         //noinspection BooleanMethodIsAlwaysInverted\n-        return new GroovyVisitor<ExecutionContext>() {\n+        return new JavaVisitor<ExecutionContext>() {\n             @Nullable\n             GradleProject gradleProject;\n \n             @Override\n-            public J visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n-                if (!cu.getSourcePath().toString().endsWith(\".gradle\")) {\n-                    return cu;\n+            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {\n+                return (sourceFile instanceof G.CompilationUnit && sourceFile.getSourcePath().toString().endsWith(\".gradle\")) ||\n+                        (sourceFile instanceof K.CompilationUnit && sourceFile.getSourcePath().toString().endsWith(\".gradle.kts\"));\n+            }\n+\n+            @Override\n+            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                if (tree instanceof JavaSourceFile) {\n+                    gradleProject = tree.getMarkers().findFirst(GradleProject.class)\n+                            .orElse(null);\n                 }\n-                gradleProject = cu.getMarkers().findFirst(GradleProject.class).orElse(null);\n-                return super.visitCompilationUnit(cu, ctx);\n+                return super.visit(tree, ctx);\n             }\n \n             @Override\n@@ -215,6 +222,71 @@ public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx)\n                             return m;\n                         }\n \n+                        String versionVariableName = declaredVersion;\n+                        GroupArtifact ga = new GroupArtifact(declaredGroupId, declaredArtifactId);\n+                        if (acc.gaToNewVersion.containsKey(ga) || !shouldResolveVersion(declaredGroupId, declaredArtifactId)) {\n+                            return m;\n+                        }\n+                        try {\n+                            String resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)\n+                                    .select(new GroupArtifact(declaredGroupId, declaredArtifactId), m.getSimpleName(), newVersion, versionPattern, ctx);\n+                            acc.versionPropNameToGA.put(versionVariableName, ga);\n+                            // It is fine for this value to be null, record it in the map to avoid future lookups\n+                            //noinspection DataFlowIssue\n+                            acc.gaToNewVersion.put(ga, resolvedVersion);\n+                        } catch (MavenDownloadingException e) {\n+                            acc.gaToNewVersion.put(ga, e);\n+                            return m;\n+                        }\n+                    } else if (m.getArguments().get(0) instanceof J.Assignment) {\n+                        String declaredGroupId = null;\n+                        String declaredArtifactId = null;\n+                        String declaredVersion = null;\n+\n+                        for (Expression e : m.getArguments()) {\n+                            if (!(e instanceof G.MapEntry)) {\n+                                continue;\n+                            }\n+                            J.Assignment assignment = (J.Assignment) e;\n+                            if (!(assignment.getVariable() instanceof J.Identifier)) {\n+                                continue;\n+                            }\n+                            J.Identifier variable = (J.Identifier) assignment.getVariable();\n+                            String valueValue = null;\n+                            if (assignment.getAssignment() instanceof J.Literal) {\n+                                J.Literal value = (J.Literal) assignment.getAssignment();\n+                                if (value.getValue() instanceof String) {\n+                                    valueValue = (String) value.getValue();\n+                                }\n+                            } else if (assignment.getAssignment() instanceof J.Identifier) {\n+                                J.Identifier value = (J.Identifier) assignment.getAssignment();\n+                                valueValue = value.getSimpleName();\n+                            } else if (assignment.getAssignment() instanceof K.StringTemplate) {\n+                                K.StringTemplate value = (K.StringTemplate) assignment.getAssignment();\n+                                List<J> strings = value.getStrings();\n+                                if (!strings.isEmpty() && strings.get(0) instanceof K.StringTemplate.Expression) {\n+                                    K.StringTemplate.Expression versionTemplateValue = (K.StringTemplate.Expression) strings.get(0);\n+                                    if (versionTemplateValue.getTree() instanceof J.Identifier) {\n+                                        valueValue = ((J.Identifier) versionTemplateValue.getTree()).getSimpleName();\n+                                    }\n+                                }\n+                            }\n+                            switch (variable.getSimpleName()) {\n+                                case \"group\":\n+                                    declaredGroupId = valueValue;\n+                                    break;\n+                                case \"name\":\n+                                    declaredArtifactId = valueValue;\n+                                    break;\n+                                case \"version\":\n+                                    declaredVersion = valueValue;\n+                                    break;\n+                            }\n+                        }\n+                        if (declaredGroupId == null || declaredArtifactId == null || declaredVersion == null) {\n+                            return m;\n+                        }\n+\n                         String versionVariableName = declaredVersion;\n                         GroupArtifact ga = new GroupArtifact(declaredGroupId, declaredArtifactId);\n                         if (acc.gaToNewVersion.containsKey(ga) || !shouldResolveVersion(declaredGroupId, declaredArtifactId)) {\n@@ -254,6 +326,19 @@ public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx)\n                                 }\n                                 dep = DependencyStringNotationConverter.parse((String) groupArtifact.getValue());\n                                 versionVariableName = ((J.Identifier) versionValue.getTree()).getSimpleName();\n+                            } else if (depArg instanceof K.StringTemplate) {\n+                                K.StringTemplate template = (K.StringTemplate) depArg;\n+                                List<J> strings = template.getStrings();\n+                                if (strings.size() != 2 || !(strings.get(0) instanceof J.Literal) || !(strings.get(1) instanceof K.StringTemplate.Expression)) {\n+                                    continue;\n+                                }\n+                                J.Literal groupArtifact = (J.Literal) strings.get(0);\n+                                K.StringTemplate.Expression versionValue = (K.StringTemplate.Expression) strings.get(1);\n+                                if (!(versionValue.getTree() instanceof J.Identifier) || !(groupArtifact.getValue() instanceof String)) {\n+                                    continue;\n+                                }\n+                                dep = DependencyStringNotationConverter.parse((String) groupArtifact.getValue());\n+                                versionVariableName = ((J.Identifier) versionValue.getTree()).getSimpleName();\n                             }\n                             if (dep == null || versionVariableName == null) {\n                                 continue;\n@@ -293,12 +378,12 @@ private boolean shouldResolveVersion(String declaredGroupId, String declaredArti\n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor(DependencyVersionState acc) {\n         return new TreeVisitor<Tree, ExecutionContext>() {\n-            private final UpdateGroovy updateGroovy = new UpdateGroovy(acc);\n+            private final UpdateGradle updateGradle = new UpdateGradle(acc);\n             private final UpdateProperties updateProperties = new UpdateProperties(acc);\n \n             @Override\n             public boolean isAcceptable(SourceFile sf, ExecutionContext ctx) {\n-                return updateProperties.isAcceptable(sf, ctx) || updateGroovy.isAcceptable(sf, ctx);\n+                return updateProperties.isAcceptable(sf, ctx) || updateGradle.isAcceptable(sf, ctx);\n             }\n \n             @Override\n@@ -307,8 +392,8 @@ public boolean isAcceptable(SourceFile sf, ExecutionContext ctx) {\n                     SourceFile sf = (SourceFile) t;\n                     if (updateProperties.isAcceptable(sf, ctx)) {\n                         t = updateProperties.visitNonNull(t, ctx);\n-                    } else if (updateGroovy.isAcceptable(sf, ctx)) {\n-                        t = updateGroovy.visitNonNull(t, ctx);\n+                    } else if (updateGradle.isAcceptable(sf, ctx)) {\n+                        t = updateGradle.visitNonNull(t, ctx);\n                     }\n                 }\n                 return t;\n@@ -352,7 +437,7 @@ public org.openrewrite.properties.tree.Properties visitEntry(Properties.Entry en\n     }\n \n     @RequiredArgsConstructor\n-    private class UpdateGroovy extends GroovyVisitor<ExecutionContext> {\n+    private class UpdateGradle extends JavaVisitor<ExecutionContext> {\n         final DependencyVersionState acc;\n \n         @Nullable\n@@ -361,10 +446,20 @@ private class UpdateGroovy extends GroovyVisitor<ExecutionContext> {\n         final DependencyMatcher dependencyMatcher = new DependencyMatcher(groupId, artifactId, null);\n \n         @Override\n-        public J visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n-            gradleProject = cu.getMarkers().findFirst(GradleProject.class)\n-                    .orElse(null);\n-            return super.visitCompilationUnit(cu, ctx);\n+        public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {\n+            return (sourceFile instanceof G.CompilationUnit && sourceFile.getSourcePath().toString().endsWith(\".gradle\")) ||\n+                    (sourceFile instanceof K.CompilationUnit && sourceFile.getSourcePath().toString().endsWith(\".gradle.kts\"));\n+        }\n+\n+        @Override\n+        public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+            if (tree instanceof JavaSourceFile) {\n+                JavaSourceFile sourceFile = (JavaSourceFile) tree;\n+                gradleProject = sourceFile.getMarkers().findFirst(GradleProject.class)\n+                        .orElse(null);\n+                return super.visit(sourceFile, ctx);\n+            }\n+            return super.visit(tree, ctx);\n         }\n \n         @Override\n@@ -395,7 +490,7 @@ public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx)\n \n             if (gradleDependencyMatcher.get(getCursor()).isPresent()) {\n                 List<Expression> depArgs = m.getArguments();\n-                if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry) {\n+                if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry || depArgs.get(0) instanceof J.Assignment || depArgs.get(0) instanceof K.StringTemplate) {\n                     m = updateDependency(m, ctx);\n                 } else if (depArgs.get(0) instanceof J.MethodInvocation &&\n                            (((J.MethodInvocation) depArgs.get(0)).getSimpleName().equals(\"platform\") ||\n@@ -428,6 +523,32 @@ private J.MethodInvocation updateDependency(J.MethodInvocation method, Execution\n                             return arg;\n                         }\n \n+                        String versionVariableName = ((J.Identifier) versionValue.getTree()).getSimpleName();\n+                        getCursor().dropParentUntil(p -> p instanceof SourceFile)\n+                                .computeMessageIfAbsent(VERSION_VARIABLE_KEY, v -> new HashMap<String, Map<GroupArtifact, Set<String>>>())\n+                                .computeIfAbsent(versionVariableName, it -> new HashMap<>())\n+                                .computeIfAbsent(new GroupArtifact(dep.getGroupId(), dep.getArtifactId()), it -> new HashSet<>())\n+                                .add(method.getSimpleName());\n+                    }\n+                } else if (arg instanceof K.StringTemplate) {\n+                    K.StringTemplate template = (K.StringTemplate) arg;\n+                    List<J> strings = template.getStrings();\n+                    if (strings.size() != 2 || !(strings.get(0) instanceof J.Literal) || !(strings.get(1) instanceof K.StringTemplate.Expression)) {\n+                        return arg;\n+                    }\n+                    J.Literal groupArtifact = (J.Literal) strings.get(0);\n+                    K.StringTemplate.Expression versionValue = (K.StringTemplate.Expression) strings.get(1);\n+                    if (!(versionValue.getTree() instanceof J.Identifier) || !(groupArtifact.getValue() instanceof String)) {\n+                        return arg;\n+                    }\n+                    Dependency dep = DependencyStringNotationConverter.parse((String) groupArtifact.getValue());\n+                    if (dep != null && dependencyMatcher.matches(dep.getGroupId(), dep.getArtifactId())) {\n+                        Object scanResult = acc.gaToNewVersion.get(new GroupArtifact(dep.getGroupId(), dep.getArtifactId()));\n+                        if (scanResult instanceof Exception) {\n+                            getCursor().putMessage(UPDATE_VERSION_ERROR_KEY, scanResult);\n+                            return arg;\n+                        }\n+\n                         String versionVariableName = ((J.Identifier) versionValue.getTree()).getSimpleName();\n                         getCursor().dropParentUntil(p -> p instanceof SourceFile)\n                                 .computeMessageIfAbsent(VERSION_VARIABLE_KEY, v -> new HashMap<String, Map<GroupArtifact, Set<String>>>())\n@@ -484,61 +605,119 @@ private J.MethodInvocation updateDependency(J.MethodInvocation method, Execution\n                 m = Markup.warn(m, err);\n             }\n             List<Expression> depArgs = m.getArguments();\n-            if (depArgs.size() >= 3 && depArgs.get(0) instanceof G.MapEntry &&\n-                depArgs.get(1) instanceof G.MapEntry &&\n-                depArgs.get(2) instanceof G.MapEntry) {\n-                Expression groupValue = ((G.MapEntry) depArgs.get(0)).getValue();\n-                Expression artifactValue = ((G.MapEntry) depArgs.get(1)).getValue();\n-                if (!(groupValue instanceof J.Literal) || !(artifactValue instanceof J.Literal)) {\n-                    return m;\n-                }\n-                J.Literal groupLiteral = (J.Literal) groupValue;\n-                J.Literal artifactLiteral = (J.Literal) artifactValue;\n-                if (groupLiteral.getValue() == null || artifactLiteral.getValue() == null || !dependencyMatcher.matches((String) groupLiteral.getValue(), (String) artifactLiteral.getValue())) {\n-                    return m;\n-                }\n-                Object scanResult = acc.gaToNewVersion.get(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()));\n-                if (scanResult instanceof Exception) {\n-                    return Markup.warn(m, (Exception) scanResult);\n-                }\n-                G.MapEntry versionEntry = (G.MapEntry) depArgs.get(2);\n-                Expression versionExp = versionEntry.getValue();\n-                if (versionExp instanceof J.Literal && ((J.Literal) versionExp).getValue() instanceof String) {\n-                    J.Literal versionLiteral = (J.Literal) versionExp;\n-                    String version = (String) versionLiteral.getValue();\n-                    if (version.startsWith(\"$\")) {\n+            if (depArgs.size() >= 3) {\n+                if (depArgs.get(0) instanceof G.MapEntry &&\n+                        depArgs.get(1) instanceof G.MapEntry &&\n+                        depArgs.get(2) instanceof G.MapEntry) {\n+                    Expression groupValue = ((G.MapEntry) depArgs.get(0)).getValue();\n+                    Expression artifactValue = ((G.MapEntry) depArgs.get(1)).getValue();\n+                    if (!(groupValue instanceof J.Literal) || !(artifactValue instanceof J.Literal)) {\n+                        return m;\n+                    }\n+                    J.Literal groupLiteral = (J.Literal) groupValue;\n+                    J.Literal artifactLiteral = (J.Literal) artifactValue;\n+                    if (groupLiteral.getValue() == null || artifactLiteral.getValue() == null || !dependencyMatcher.matches((String) groupLiteral.getValue(), (String) artifactLiteral.getValue())) {\n                         return m;\n                     }\n-                    String selectedVersion;\n-                    try {\n-                        GroupArtifactVersion gav = new GroupArtifactVersion((String) groupLiteral.getValue(), (String) artifactLiteral.getValue(), version);\n-                        selectedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)\n-                                .select(gav, m.getSimpleName(), newVersion, versionPattern, ctx);\n-                    } catch (MavenDownloadingException e) {\n-                        return e.warn(m);\n+                    Object scanResult = acc.gaToNewVersion.get(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()));\n+                    if (scanResult instanceof Exception) {\n+                        return Markup.warn(m, (Exception) scanResult);\n+                    }\n+                    G.MapEntry versionEntry = (G.MapEntry) depArgs.get(2);\n+                    Expression versionExp = versionEntry.getValue();\n+                    if (versionExp instanceof J.Literal && ((J.Literal) versionExp).getValue() instanceof String) {\n+                        J.Literal versionLiteral = (J.Literal) versionExp;\n+                        String version = (String) versionLiteral.getValue();\n+                        if (version.startsWith(\"$\")) {\n+                            return m;\n+                        }\n+                        String selectedVersion;\n+                        try {\n+                            GroupArtifactVersion gav = new GroupArtifactVersion((String) groupLiteral.getValue(), (String) artifactLiteral.getValue(), version);\n+                            selectedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)\n+                                    .select(gav, m.getSimpleName(), newVersion, versionPattern, ctx);\n+                        } catch (MavenDownloadingException e) {\n+                            return e.warn(m);\n+                        }\n+                        if (selectedVersion == null || version.equals(selectedVersion)) {\n+                            return m;\n+                        }\n+                        List<Expression> newArgs = new ArrayList<>(3);\n+                        newArgs.add(depArgs.get(0));\n+                        newArgs.add(depArgs.get(1));\n+                        newArgs.add(versionEntry.withValue(\n+                                versionLiteral\n+                                        .withValueSource(versionLiteral.getValueSource() == null ?\n+                                                selectedVersion :\n+                                                versionLiteral.getValueSource().replace(version, selectedVersion))\n+                                        .withValue(selectedVersion)));\n+                        newArgs.addAll(depArgs.subList(3, depArgs.size()));\n+\n+                        return m.withArguments(newArgs);\n+                    } else if (versionExp instanceof J.Identifier) {\n+                        String versionVariableName = ((J.Identifier) versionExp).getSimpleName();\n+                        getCursor().dropParentUntil(p -> p instanceof SourceFile)\n+                                .computeMessageIfAbsent(VERSION_VARIABLE_KEY, v -> new HashMap<String, Map<GroupArtifact, Set<String>>>())\n+                                .computeIfAbsent(versionVariableName, it -> new HashMap<>())\n+                                .computeIfAbsent(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()), it -> new HashSet<>())\n+                                .add(m.getSimpleName());\n                     }\n-                    if (selectedVersion == null || version.equals(selectedVersion)) {\n+                } else if (depArgs.get(0) instanceof J.Assignment &&\n+                        depArgs.get(1) instanceof J.Assignment &&\n+                        depArgs.get(2) instanceof J.Assignment) {\n+                    Expression groupValue = ((J.Assignment) depArgs.get(0)).getAssignment();\n+                    Expression artifactValue = ((J.Assignment) depArgs.get(1)).getAssignment();\n+                    if (!(groupValue instanceof J.Literal) || !(artifactValue instanceof J.Literal)) {\n                         return m;\n                     }\n-                    List<Expression> newArgs = new ArrayList<>(3);\n-                    newArgs.add(depArgs.get(0));\n-                    newArgs.add(depArgs.get(1));\n-                    newArgs.add(versionEntry.withValue(\n-                            versionLiteral\n-                                    .withValueSource(versionLiteral.getValueSource() == null ?\n-                                            selectedVersion :\n-                                            versionLiteral.getValueSource().replace(version, selectedVersion))\n-                                    .withValue(selectedVersion)));\n-                    newArgs.addAll(depArgs.subList(3, depArgs.size()));\n-\n-                    return m.withArguments(newArgs);\n-                } else if (versionExp instanceof J.Identifier) {\n-                    String versionVariableName = ((J.Identifier) versionExp).getSimpleName();\n-                    getCursor().dropParentUntil(p -> p instanceof SourceFile)\n-                            .computeMessageIfAbsent(VERSION_VARIABLE_KEY, v -> new HashMap<String, Map<GroupArtifact, Set<String>>>())\n-                            .computeIfAbsent(versionVariableName, it -> new HashMap<>())\n-                            .computeIfAbsent(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()), it -> new HashSet<>())\n-                            .add(m.getSimpleName());\n+                    J.Literal groupLiteral = (J.Literal) groupValue;\n+                    J.Literal artifactLiteral = (J.Literal) artifactValue;\n+                    if (groupLiteral.getValue() == null || artifactLiteral.getValue() == null || !dependencyMatcher.matches((String) groupLiteral.getValue(), (String) artifactLiteral.getValue())) {\n+                        return m;\n+                    }\n+                    Object scanResult = acc.gaToNewVersion.get(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()));\n+                    if (scanResult instanceof Exception) {\n+                        return Markup.warn(m, (Exception) scanResult);\n+                    }\n+                    K.Assignment versionEntry = (J.Assignment) depArgs.get(2);\n+                    Expression versionExp = versionEntry.getAssignment();\n+                    if (versionExp instanceof J.Literal && ((J.Literal) versionExp).getValue() instanceof String) {\n+                        J.Literal versionLiteral = (J.Literal) versionExp;\n+                        String version = (String) versionLiteral.getValue();\n+                        if (version.startsWith(\"$\")) {\n+                            return m;\n+                        }\n+                        String selectedVersion;\n+                        try {\n+                            GroupArtifactVersion gav = new GroupArtifactVersion((String) groupLiteral.getValue(), (String) artifactLiteral.getValue(), version);\n+                            selectedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)\n+                                    .select(gav, m.getSimpleName(), newVersion, versionPattern, ctx);\n+                        } catch (MavenDownloadingException e) {\n+                            return e.warn(m);\n+                        }\n+                        if (selectedVersion == null || version.equals(selectedVersion)) {\n+                            return m;\n+                        }\n+                        List<Expression> newArgs = new ArrayList<>(3);\n+                        newArgs.add(depArgs.get(0));\n+                        newArgs.add(depArgs.get(1));\n+                        newArgs.add(versionEntry.withAssignment(\n+                                versionLiteral\n+                                        .withValueSource(versionLiteral.getValueSource() == null ?\n+                                                selectedVersion :\n+                                                versionLiteral.getValueSource().replace(version, selectedVersion))\n+                                        .withValue(selectedVersion)));\n+                        newArgs.addAll(depArgs.subList(3, depArgs.size()));\n+\n+                        return m.withArguments(newArgs);\n+                    } else if (versionExp instanceof J.Identifier) {\n+                        String versionVariableName = ((J.Identifier) versionExp).getSimpleName();\n+                        getCursor().dropParentUntil(p -> p instanceof SourceFile)\n+                                .computeMessageIfAbsent(VERSION_VARIABLE_KEY, v -> new HashMap<String, Map<GroupArtifact, Set<String>>>())\n+                                .computeIfAbsent(versionVariableName, it -> new HashMap<>())\n+                                .computeIfAbsent(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()), it -> new HashSet<>())\n+                                .add(m.getSimpleName());\n+                    }\n                 }\n             }\n \n@@ -547,7 +726,7 @@ private J.MethodInvocation updateDependency(J.MethodInvocation method, Execution\n     }\n \n     @AllArgsConstructor\n-    private class UpdateVariable extends GroovyIsoVisitor<ExecutionContext> {\n+    private class UpdateVariable extends JavaIsoVisitor<ExecutionContext> {\n         private final Map<String, Map<GroupArtifact, Set<String>>> versionVariableNames;\n \n         @Nullable\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\nindex 1745f52c328..7b2047e11c2 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\n@@ -20,22 +20,26 @@\n import lombok.Value;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n+import org.openrewrite.gradle.internal.ChangeStringLiteral;\n+import org.openrewrite.gradle.internal.DependencyStringNotationConverter;\n import org.openrewrite.gradle.marker.GradleDependencyConfiguration;\n import org.openrewrite.gradle.marker.GradleProject;\n import org.openrewrite.gradle.search.FindGradleProject;\n import org.openrewrite.groovy.GroovyIsoVisitor;\n-import org.openrewrite.groovy.GroovyVisitor;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n+import org.openrewrite.java.JavaVisitor;\n import org.openrewrite.java.MethodMatcher;\n import org.openrewrite.java.format.BlankLinesVisitor;\n import org.openrewrite.java.search.FindMethods;\n import org.openrewrite.java.search.UsesMethod;\n-import org.openrewrite.java.tree.Expression;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.Statement;\n+import org.openrewrite.java.tree.*;\n+import org.openrewrite.kotlin.KotlinIsoVisitor;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.marker.Markers;\n import org.openrewrite.marker.Markup;\n+import org.openrewrite.marker.SearchResult;\n import org.openrewrite.maven.MavenDownloadingException;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n import org.openrewrite.maven.tree.GroupArtifact;\n@@ -44,9 +48,11 @@\n import org.openrewrite.semver.DependencyMatcher;\n import org.openrewrite.semver.Semver;\n \n+import java.io.ByteArrayInputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n import java.util.*;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicReference;\n import java.util.stream.Collectors;\n \n import static java.util.Collections.singletonMap;\n@@ -116,15 +122,19 @@ public class UpgradeTransitiveDependencyVersion extends Recipe {\n      * it is much faster to produce these LST elements only once then manipulate their arguments.\n      * This largely mimics how caching works in JavaTemplate. If we create a Gradle/GroovyTemplate this could be refactored.\n      */\n-    private static Map<String, Optional<G.CompilationUnit>> snippetCache(ExecutionContext ctx) {\n+    private static Map<String, Optional<JavaSourceFile>> snippetCache(ExecutionContext ctx) {\n         //noinspection unchecked\n-        return (Map<String, Optional<G.CompilationUnit>>) ctx.getMessages()\n+        return (Map<String, Optional<JavaSourceFile>>) ctx.getMessages()\n                 .computeIfAbsent(UpgradeTransitiveDependencyVersion.class.getName() + \".snippetCache\", k -> new HashMap<String, Optional<G.CompilationUnit>>());\n     }\n \n-    private static Optional<G.CompilationUnit> parseAsGradle(String snippet, ExecutionContext ctx) {\n+    private static Optional<JavaSourceFile> parseAsGradle(String snippet, boolean isKotlinDsl, ExecutionContext ctx) {\n         return snippetCache(ctx)\n-                .computeIfAbsent(snippet, s -> GradleParser.builder().build().parse(ctx, snippet)\n+                .computeIfAbsent(snippet, s -> GradleParser.builder().build().parseInputs(Collections.singletonList(\n+                        new Parser.Input(\n+                                Paths.get(\"build.gradle\" + (isKotlinDsl ? \".kts\" : \"\")),\n+                                () -> new ByteArrayInputStream(snippet.getBytes(StandardCharsets.UTF_8))\n+                        )), null, ctx)\n                         .findFirst()\n                         .map(maybeCu -> {\n                             maybeCu.getMarkers()\n@@ -132,7 +142,7 @@ private static Optional<G.CompilationUnit> parseAsGradle(String snippet, Executi\n                                     .ifPresent(per -> {\n                                         throw new IllegalStateException(\"Encountered exception \" + per.getExceptionType() + \" with message \" + per.getMessage() + \" on snippet:\\n\" + snippet);\n                                     });\n-                            return (G.CompilationUnit) maybeCu;\n+                            return (JavaSourceFile) maybeCu;\n                         }));\n     }\n \n@@ -162,100 +172,123 @@ public Validated<Object> validate() {\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n         DependencyMatcher dependencyMatcher = new DependencyMatcher(groupId, artifactId, null);\n \n-        return Preconditions.check(new FindGradleProject(FindGradleProject.SearchCriteria.Marker), new GroovyVisitor<ExecutionContext>() {\n+        return Preconditions.check(new FindGradleProject(FindGradleProject.SearchCriteria.Marker), new JavaVisitor<ExecutionContext>() {\n             @SuppressWarnings(\"NotNullFieldNotInitialized\")\n             GradleProject gradleProject;\n \n             @Override\n-            public J visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n-                gradleProject = cu.getMarkers().findFirst(GradleProject.class)\n-                        .orElseThrow(() -> new IllegalStateException(\"Unable to find GradleProject marker.\"));\n-\n-                Map<GroupArtifact, Map<GradleDependencyConfiguration, String>> toUpdate = new LinkedHashMap<>();\n-\n-                DependencyVersionSelector versionSelector = new DependencyVersionSelector(metadataFailures, gradleProject, null);\n-                for (GradleDependencyConfiguration configuration : gradleProject.getConfigurations()) {\n-                    for (ResolvedDependency resolved : configuration.getResolved()) {\n-                        if (resolved.getDepth() > 0 && dependencyMatcher.matches(resolved.getGroupId(),\n-                                resolved.getArtifactId(), resolved.getVersion())) {\n-                            try {\n-                                String selected = versionSelector.select(resolved.getGav(), configuration.getName(),\n-                                        version, versionPattern, ctx);\n-                                if (selected == null || resolved.getVersion().equals(selected)) {\n-                                    continue;\n-                                }\n+            public J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                if (tree instanceof JavaSourceFile) {\n+                    JavaSourceFile cu = (JavaSourceFile) tree;\n+                    gradleProject = cu.getMarkers().findFirst(GradleProject.class)\n+                            .orElseThrow(() -> new IllegalStateException(\"Unable to find GradleProject marker.\"));\n+\n+                    Map<GroupArtifact, Map<GradleDependencyConfiguration, String>> toUpdate = new LinkedHashMap<>();\n+\n+                    DependencyVersionSelector versionSelector = new DependencyVersionSelector(metadataFailures, gradleProject, null);\n+                    for (GradleDependencyConfiguration configuration : gradleProject.getConfigurations()) {\n+                        for (ResolvedDependency resolved : configuration.getResolved()) {\n+                            if (resolved.getDepth() > 0 && dependencyMatcher.matches(resolved.getGroupId(),\n+                                    resolved.getArtifactId(), resolved.getVersion())) {\n+                                try {\n+                                    String selected = versionSelector.select(resolved.getGav(), configuration.getName(),\n+                                            version, versionPattern, ctx);\n+                                    if (selected == null || resolved.getVersion().equals(selected)) {\n+                                        continue;\n+                                    }\n \n-                                GradleDependencyConfiguration constraintConfig = constraintConfiguration(configuration);\n-                                if (constraintConfig == null) {\n-                                    continue;\n-                                }\n+                                    GradleDependencyConfiguration constraintConfig = constraintConfiguration(configuration);\n+                                    if (constraintConfig == null) {\n+                                        continue;\n+                                    }\n \n-                                toUpdate.merge(\n-                                        new GroupArtifact(resolved.getGroupId(), resolved.getArtifactId()),\n-                                        singletonMap(constraintConfig, selected),\n-                                        (existing, update) -> {\n-                                            Map<GradleDependencyConfiguration, String> all = new LinkedHashMap<>(existing);\n-                                            all.putAll(update);\n-                                            all.keySet().removeIf(c -> {\n-                                                if (c == null) {\n-                                                    return true; // TODO ?? how does this happen\n-                                                }\n-\n-                                                for (GradleDependencyConfiguration config : all.keySet()) {\n-                                                    if (c.allExtendsFrom().contains(config)) {\n-                                                        return true;\n+                                    toUpdate.merge(\n+                                            new GroupArtifact(resolved.getGroupId(), resolved.getArtifactId()),\n+                                            singletonMap(constraintConfig, selected),\n+                                            (existing, update) -> {\n+                                                Map<GradleDependencyConfiguration, String> all = new LinkedHashMap<>(existing);\n+                                                all.putAll(update);\n+                                                all.keySet().removeIf(c -> {\n+                                                    if (c == null) {\n+                                                        return true; // TODO ?? how does this happen\n                                                     }\n \n-                                                    // TODO there has to be a better way!\n-                                                    if (c.getName().equals(\"runtimeOnly\")) {\n-                                                        if (config.getName().equals(\"implementation\")) {\n+                                                    for (GradleDependencyConfiguration config : all.keySet()) {\n+                                                        if (c.allExtendsFrom().contains(config)) {\n                                                             return true;\n                                                         }\n-                                                    }\n-                                                    if (c.getName().equals(\"testRuntimeOnly\")) {\n-                                                        if (config.getName().equals(\"testImplementation\") ||\n-                                                            config.getName().equals(\"implementation\")) {\n-                                                            return true;\n+\n+                                                        // TODO there has to be a better way!\n+                                                        if (c.getName().equals(\"runtimeOnly\")) {\n+                                                            if (config.getName().equals(\"implementation\")) {\n+                                                                return true;\n+                                                            }\n+                                                        }\n+                                                        if (c.getName().equals(\"testRuntimeOnly\")) {\n+                                                            if (config.getName().equals(\"testImplementation\") ||\n+                                                                    config.getName().equals(\"implementation\")) {\n+                                                                return true;\n+                                                            }\n                                                         }\n                                                     }\n-                                                }\n-                                                return false;\n-                                            });\n-                                            return all;\n-                                        }\n-                                );\n-                            } catch (MavenDownloadingException e) {\n-                                return Markup.warn(cu, e);\n+                                                    return false;\n+                                                });\n+                                                return all;\n+                                            }\n+                                    );\n+                                } catch (MavenDownloadingException e) {\n+                                    return Markup.warn(cu, e);\n+                                }\n                             }\n                         }\n                     }\n-                }\n \n-                if (!toUpdate.isEmpty()) {\n-                    cu = (G.CompilationUnit) Preconditions.check(not(new UsesMethod<>(CONSTRAINTS_MATCHER)),\n-                            new AddConstraintsBlock()).visitNonNull(cu, ctx);\n+                    if (!toUpdate.isEmpty()) {\n+                        cu = (JavaSourceFile) Preconditions.check(\n+                                not(new JavaIsoVisitor<ExecutionContext>() {\n+                                    @Override\n+                                    public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {\n+                                        if (tree instanceof G.CompilationUnit) {\n+                                            return new UsesMethod<>(CONSTRAINTS_MATCHER).visit(tree, ctx);\n+                                        } else {\n+                                            // K is not type attributed, so do things more manually\n+                                            return super.visit(tree, ctx);\n+                                        }\n+                                    }\n \n-                    for (Map.Entry<GroupArtifact, Map<GradleDependencyConfiguration, String>> update : toUpdate.entrySet()) {\n-                        Map<GradleDependencyConfiguration, String> configs = update.getValue();\n-                        for (Map.Entry<GradleDependencyConfiguration, String> config : configs.entrySet()) {\n-                            cu = (G.CompilationUnit) new AddConstraint(config.getKey().getName(), new GroupArtifactVersion(update.getKey().getGroupId(),\n-                                    update.getKey().getArtifactId(), config.getValue()), because).visitNonNull(cu, ctx);\n+                                    @Override\n+                                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n+                                        J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n+                                        if (m.getSimpleName().equals(\"constraints\") && withinBlock(getCursor(), \"dependencies\")) {\n+                                            return SearchResult.found(m);\n+                                        }\n+                                        return m;\n+                                    }\n+                                }),\n+                                new AddConstraintsBlock(cu instanceof K.CompilationUnit)\n+                        ).visitNonNull(cu, ctx);\n+\n+                        for (Map.Entry<GroupArtifact, Map<GradleDependencyConfiguration, String>> update : toUpdate.entrySet()) {\n+                            Map<GradleDependencyConfiguration, String> configs = update.getValue();\n+                            for (Map.Entry<GradleDependencyConfiguration, String> config : configs.entrySet()) {\n+                                cu = (JavaSourceFile) new AddConstraint(cu instanceof K.CompilationUnit, config.getKey().getName(), new GroupArtifactVersion(update.getKey().getGroupId(),\n+                                        update.getKey().getArtifactId(), config.getValue()), because).visitNonNull(cu, ctx);\n+                            }\n                         }\n-                    }\n \n-                    // Update dependency model so chained recipes will have correct information on what dependencies are present\n-                    cu = cu.withMarkers(cu.getMarkers()\n-                            .removeByType(GradleProject.class)\n-                            .add(updatedModel(gradleProject, toUpdate, ctx)));\n+                        // Update dependency model so chained recipes will have correct information on what dependencies are present\n+                        cu = cu.withMarkers(cu.getMarkers().setByType(updatedModel(gradleProject, toUpdate, ctx)));\n \n-                    // Spring dependency management plugin stomps on constraints. Use an alternative mechanism it does not override\n-                    if (gradleProject.getPlugins().stream()\n-                            .anyMatch(plugin -> \"io.spring.dependency-management\".equals(plugin.getId()))) {\n-                        cu = (G.CompilationUnit) new DependencyConstraintToRule().getVisitor().visitNonNull(cu, ctx);\n+                        // Spring dependency management plugin stomps on constraints. Use an alternative mechanism it does not override\n+                        if (gradleProject.getPlugins().stream()\n+                                .anyMatch(plugin -> \"io.spring.dependency-management\".equals(plugin.getId()))) {\n+                            cu = (JavaSourceFile) new DependencyConstraintToRule().getVisitor().visitNonNull(cu, ctx);\n+                        }\n                     }\n-                }\n \n-                return cu;\n+                    return cu;\n+                }\n+                return super.visit(tree, ctx);\n             }\n \n             private GradleProject updatedModel(GradleProject gradleProject, Map<GroupArtifact, Map<GradleDependencyConfiguration, String>> toUpdate, ExecutionContext ctx) {\n@@ -345,19 +378,23 @@ private GradleProject updatedModel(GradleProject gradleProject, Map<GroupArtifac\n         });\n     }\n \n-    private static class AddConstraintsBlock extends GroovyIsoVisitor<ExecutionContext> {\n+    @Value\n+    @EqualsAndHashCode(callSuper = false)\n+    private static class AddConstraintsBlock extends JavaIsoVisitor<ExecutionContext> {\n+        boolean isKotlinDsl;\n+\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n \n             if (DEPENDENCIES_DSL_MATCHER.matches(method)) {\n-                G.CompilationUnit withConstraints = parseAsGradle(\n+                G.CompilationUnit withConstraints = (G.CompilationUnit) parseAsGradle(\n                         //language=groovy\n                         \"plugins { id 'java' }\\n\" +\n                         \"dependencies {\\n\" +\n                         \"    constraints {\\n\" +\n                         \"    }\\n\" +\n-                        \"}\\n\", ctx)\n+                        \"}\\n\", false, ctx)\n                         .orElseThrow(() -> new IllegalStateException(\"Unable to parse constraints block\"));\n \n                 Statement constraints = FindMethods.find(withConstraints, \"org.gradle.api.artifacts.dsl.DependencyHandler constraints(..)\", true)\n@@ -384,6 +421,49 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                     return dependencies.withBody(body.withStatements(\n                             ListUtils.concat(constraints, statements)));\n                 })), constraints, ctx, getCursor().getParentOrThrow());\n+            } else if (isKotlinDsl && m.getSimpleName().equals(\"dependencies\") && getCursor().getParent().firstEnclosing(J.MethodInvocation.class) == null) {\n+                K.CompilationUnit withConstraints = (K.CompilationUnit) parseAsGradle(\n+                        //language=kotlin\n+                        \"plugins { id(\\\"java\\\") }\\n\" +\n+                        \"dependencies {\\n\" +\n+                        \"    constraints {}\\n\" +\n+                        \"}\\n\", true, ctx)\n+                        .orElseThrow(() -> new IllegalStateException(\"Unable to parse constraints block\"));\n+\n+                J.MethodInvocation constraints = withConstraints.getStatements()\n+                        .stream()\n+                        .map(J.Block.class::cast)\n+                        .flatMap(block -> block.getStatements().stream())\n+                        .filter(J.MethodInvocation.class::isInstance)\n+                        .map(J.MethodInvocation.class::cast)\n+                        .filter(m2 -> m2.getSimpleName().equals(\"dependencies\"))\n+                        .flatMap(dependencies -> ((J.Block) ((J.Lambda) dependencies.getArguments().get(0)).getBody()).getStatements().stream())\n+                        .filter(J.MethodInvocation.class::isInstance)\n+                        .map(J.MethodInvocation.class::cast)\n+                        .filter(m2 -> m2.getSimpleName().equals(\"constraints\"))\n+                        .findFirst()\n+                        .map(m2 -> m2.withArguments(ListUtils.mapFirst(m2.getArguments(), arg -> {\n+                            J.Lambda lambda = (J.Lambda) arg;\n+                            return lambda.withBody(((J.Block) lambda.getBody()).withEnd(Space.format(\"\\n\")));\n+                        })))\n+                        .orElseThrow(() -> new IllegalStateException(\"Unable to find constraints block\"))\n+                        .withMarkers(Markers.EMPTY);\n+\n+                return m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {\n+                    if(!(arg instanceof J.Lambda)) {\n+                        return arg;\n+                    }\n+                    J.Lambda dependencies = (J.Lambda) arg;\n+                    if (!(dependencies.getBody() instanceof J.Block)) {\n+                        return m;\n+                    }\n+                    J.Block body = (J.Block) dependencies.getBody();\n+\n+                    List<Statement> statements = ListUtils.mapFirst(body.getStatements(), stat -> stat.withPrefix(stat.getPrefix().withWhitespace(\n+                            BlankLinesVisitor.minimumLines(stat.getPrefix().getWhitespace(), 1))));\n+                    return dependencies.withBody(body.withStatements(\n+                            ListUtils.concat(autoFormat(constraints, ctx, getCursor().getParentOrThrow()), statements)));\n+                }));\n             }\n \n             return m;\n@@ -393,7 +473,8 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n \n     @Value\n     @EqualsAndHashCode(callSuper = false)\n-    private static class AddConstraint extends GroovyIsoVisitor<ExecutionContext> {\n+    private static class AddConstraint extends JavaIsoVisitor<ExecutionContext> {\n+        boolean isKotlinDsl;\n         String config;\n         GroupArtifactVersion gav;\n \n@@ -403,45 +484,54 @@ private static class AddConstraint extends GroovyIsoVisitor<ExecutionContext> {\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n-            if(!CONSTRAINTS_MATCHER.matches(m)) {\n+            if(!CONSTRAINTS_MATCHER.matches(m) && !(isKotlinDsl && m.getSimpleName().equals(\"constraints\") && withinBlock(getCursor(), \"dependencies\"))) {\n                 return m;\n             }\n             String ga = gav.getGroupId() + \":\" + gav.getArtifactId();\n-            AtomicReference<String> existingConstraintVersion = new AtomicReference<>();\n-            J.MethodInvocation existingConstraint = FindMethods.find(m, CONSTRAINT_MATCHER, true).stream()\n-                    .filter(J.MethodInvocation.class::isInstance)\n-                    .map(J.MethodInvocation.class::cast)\n-                    .filter(c -> c.getSimpleName().equals(config) && c.getArguments().stream()\n-                            .anyMatch(arg -> {\n-                                        if (!(arg instanceof J.Literal) || ((J.Literal) arg).getValue() == null) {\n-                                            return false;\n-                                        }\n-                                        String value = ((J.Literal) arg).getValue().toString();\n-                                        if (!value.startsWith(ga)) {\n-                                            return false;\n-                                        }\n-                                        existingConstraintVersion.set(value.substring(value.lastIndexOf(':') + 1));\n-                                        return true;\n-                                    }\n-                            )\n-                    ).findFirst()\n-                    .orElse(null);\n-            if (Objects.equals(gav.getVersion(), existingConstraintVersion.get())) {\n+            String existingConstraintVersion = null;\n+            J.MethodInvocation existingConstraint = null;\n+            MethodMatcher constraintMatcher = new MethodMatcher(CONSTRAINT_MATCHER, true);\n+            for (Statement statement : ((J.Block) ((J.Lambda) m.getArguments().get(0)).getBody()).getStatements()) {\n+                if (statement instanceof J.MethodInvocation || (statement instanceof J.Return && ((J.Return) statement).getExpression() instanceof J.MethodInvocation)) {\n+                    J.MethodInvocation m2 = (J.MethodInvocation) (statement instanceof J.Return ? ((J.Return) statement).getExpression() :  statement);\n+                    if (constraintMatcher.matches(m2)) {\n+                        if (m2.getSimpleName().equals(config) && matchesConstraint(m2, ga)) {\n+                            existingConstraint = m2;\n+                            existingConstraintVersion = DependencyStringNotationConverter.parse((String) requireNonNull(((J.Literal) m2.getArguments().get(0)).getValue())).getVersion();\n+                        }\n+                    } else if (isKotlinDsl && m.getSimpleName().equals(\"constraints\")) {\n+                        if (m2.getSimpleName().equals(config) && matchesConstraint(m2, ga)) {\n+                            existingConstraint = m2;\n+                            existingConstraintVersion = DependencyStringNotationConverter.parse((String) requireNonNull(((J.Literal) m2.getArguments().get(0)).getValue())).getVersion();\n+                        }\n+                    }\n+                }\n+            }\n+            if (Objects.equals(gav.getVersion(), existingConstraintVersion)) {\n                 return m;\n             }\n             if(existingConstraint == null) {\n-                m = (J.MethodInvocation) new CreateConstraintVisitor(config, gav, because)\n+                m = (J.MethodInvocation) new CreateConstraintVisitor(config, gav, because, isKotlinDsl)\n                         .visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));\n             } else {\n-                m = (J.MethodInvocation) new UpdateConstraintVersionVisitor(gav, existingConstraint, because)\n+                m = (J.MethodInvocation) new UpdateConstraintVersionVisitor(gav, existingConstraint, because, isKotlinDsl)\n                         .visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));\n             }\n             return m;\n         }\n+\n+        private static boolean matchesConstraint(J.MethodInvocation m, String ga) {\n+            Expression arg = m.getArguments().get(0);\n+            if (!(arg instanceof J.Literal) || ((J.Literal) arg).getValue() == null) {\n+                return false;\n+            }\n+            String value = ((J.Literal) arg).getValue().toString();\n+            return value.startsWith(ga);\n+        }\n     }\n \n     //language=groovy\n-    private static final String INDIVIDUAL_CONSTRAINT_SNIPPET =\n+    private static final String INDIVIDUAL_CONSTRAINT_SNIPPET_GROOVY =\n             \"plugins {\\n\" +\n             \"    id 'java'\\n\" +\n             \"}\\n\" +\n@@ -450,8 +540,18 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n             \"        implementation('foobar')\\n\" +\n             \"    }\\n\" +\n             \"}\";\n+    //language=kotlin\n+    private static final String INDIVIDUAL_CONSTRAINT_SNIPPET_KOTLIN =\n+            \"plugins {\\n\" +\n+            \"    id(\\\"java\\\")\\n\" +\n+            \"}\\n\" +\n+            \"dependencies {\\n\" +\n+            \"    constraints {\\n\" +\n+            \"        implementation(\\\"foobar\\\")\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n     //language=groovy\n-    private static final String INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET =\n+    private static final String INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_GROOVY =\n             \"plugins {\\n\" +\n             \"    id 'java'\\n\" +\n             \"}\\n\" +\n@@ -462,10 +562,22 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n             \"        }\\n\" +\n             \"    }\\n\" +\n             \"}\";\n+    //language=kotlin\n+    private static final String INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_KOTLIN =\n+            \"plugins {\\n\" +\n+            \"    id(\\\"java\\\")\\n\" +\n+            \"}\\n\" +\n+            \"dependencies {\\n\" +\n+            \"    constraints {\\n\" +\n+            \"        implementation(\\\"foobar\\\") {\\n\" +\n+            \"            because(\\\"because\\\")\\n\" +\n+            \"        }\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n \n     @Value\n     @EqualsAndHashCode(callSuper = false)\n-    private static class CreateConstraintVisitor extends GroovyIsoVisitor<ExecutionContext> {\n+    private static class CreateConstraintVisitor extends JavaIsoVisitor<ExecutionContext> {\n \n         String config;\n         GroupArtifactVersion gav;\n@@ -473,6 +585,8 @@ private static class CreateConstraintVisitor extends GroovyIsoVisitor<ExecutionC\n         @Nullable\n         String because;\n \n+        boolean isKotlinDsl;\n+\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             if (\"version\".equals(method.getSimpleName())) {\n@@ -480,36 +594,68 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n             }\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n \n-            J.MethodInvocation constraint = parseAsGradle(because == null ? INDIVIDUAL_CONSTRAINT_SNIPPET : INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET, ctx)\n-                    .map(it -> (J.MethodInvocation) it.getStatements().get(1))\n-                    .map(dependenciesMethod -> (J.Lambda) dependenciesMethod.getArguments().get(0))\n-                    .map(dependenciesClosure -> (J.Block)dependenciesClosure.getBody())\n-                    .map(dependenciesBody -> (J.Return) dependenciesBody.getStatements().get(0))\n-                    .map(returnConstraints -> (J.MethodInvocation) returnConstraints.getExpression())\n-                    .map(constraintsInvocation -> (J.Lambda) constraintsInvocation.getArguments().get(0))\n-                    .map(constraintsLambda -> (J.Block) constraintsLambda.getBody())\n-                    .map(constraintsBlock -> (J.Return) constraintsBlock.getStatements().get(0))\n-                    .map(returnConfiguration -> (J.MethodInvocation) returnConfiguration.getExpression())\n-                    .map(it -> it.withName(it.getName().withSimpleName(config))\n-                            .withArguments(ListUtils.map(it.getArguments(), arg -> {\n-                                if (arg instanceof J.Literal) {\n-                                    return ((J.Literal) requireNonNull(arg))\n-                                            .withValue(gav.toString())\n-                                            .withValueSource(\"'\" + gav + \"'\");\n-                                } else if (arg instanceof J.Lambda && because != null) {\n-                                    return (Expression) new GroovyIsoVisitor<Integer>() {\n-                                        @Override\n-                                        public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n-                                            return literal.withValue(because)\n-                                                    .withValueSource(\"'\" + because + \"'\");\n-                                        }\n-                                    }.visitNonNull(arg, 0);\n-                                }\n-                                return arg;\n-                            })))\n-                    // Assign a unique ID so multiple constraints can be added\n-                    .map(it -> it.withId(Tree.randomId()))\n-                    .orElseThrow(() -> new IllegalStateException(\"Unable to find constraint\"));\n+            J.MethodInvocation constraint;\n+            if (!isKotlinDsl) {\n+                constraint = parseAsGradle(because == null ? INDIVIDUAL_CONSTRAINT_SNIPPET_GROOVY : INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_GROOVY, false, ctx)\n+                        .map(G.CompilationUnit.class::cast)\n+                        .map(it -> (J.MethodInvocation) it.getStatements().get(1))\n+                        .map(dependenciesMethod -> (J.Lambda) dependenciesMethod.getArguments().get(0))\n+                        .map(dependenciesClosure -> (J.Block) dependenciesClosure.getBody())\n+                        .map(dependenciesBody -> (J.Return) dependenciesBody.getStatements().get(0))\n+                        .map(returnConstraints -> (J.MethodInvocation) returnConstraints.getExpression())\n+                        .map(constraintsInvocation -> (J.Lambda) constraintsInvocation.getArguments().get(0))\n+                        .map(constraintsLambda -> (J.Block) constraintsLambda.getBody())\n+                        .map(constraintsBlock -> (J.Return) constraintsBlock.getStatements().get(0))\n+                        .map(returnConfiguration -> (J.MethodInvocation) returnConfiguration.getExpression())\n+                        .map(it -> it.withName(it.getName().withSimpleName(config))\n+                                .withArguments(ListUtils.map(it.getArguments(), arg -> {\n+                                    if (arg instanceof J.Literal) {\n+                                        return ((J.Literal) requireNonNull(arg))\n+                                                .withValue(gav.toString())\n+                                                .withValueSource(\"'\" + gav + \"'\");\n+                                    } else if (arg instanceof J.Lambda && because != null) {\n+                                        return (Expression) new GroovyIsoVisitor<Integer>() {\n+                                            @Override\n+                                            public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n+                                                return literal.withValue(because)\n+                                                        .withValueSource(\"'\" + because + \"'\");\n+                                            }\n+                                        }.visitNonNull(arg, 0);\n+                                    }\n+                                    return arg;\n+                                })))\n+                        // Assign a unique ID so multiple constraints can be added\n+                        .map(it -> it.withId(Tree.randomId()))\n+                        .orElseThrow(() -> new IllegalStateException(\"Unable to find constraint\"));\n+            } else {\n+                constraint = parseAsGradle(because == null ? INDIVIDUAL_CONSTRAINT_SNIPPET_KOTLIN : INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_KOTLIN, true, ctx)\n+                        .map(K.CompilationUnit.class::cast)\n+                        .map(it -> (J.Block) it.getStatements().get(0))\n+                        .map(it -> (J.MethodInvocation) it.getStatements().get(1))\n+                        .map(dependenciesMethod -> (J.Lambda) dependenciesMethod.getArguments().get(0))\n+                        .map(dependenciesClosure -> (J.Block) dependenciesClosure.getBody())\n+                        .map(dependenciesBody -> (J.MethodInvocation) dependenciesBody.getStatements().get(0))\n+                        .map(constraintsInvocation -> (J.Lambda) constraintsInvocation.getArguments().get(0))\n+                        .map(constraintsLambda -> (J.Block) constraintsLambda.getBody())\n+                        .map(constraintsBlock -> (J.MethodInvocation) constraintsBlock.getStatements().get(0))\n+                        .map(it -> it.withName(it.getName().withSimpleName(config))\n+                                .withArguments(ListUtils.map(it.getArguments(), arg -> {\n+                                    if (arg instanceof J.Literal) {\n+                                        return ChangeStringLiteral.withStringValue((J.Literal) requireNonNull(arg), gav.toString());\n+                                    } else if (arg instanceof J.Lambda && because != null) {\n+                                        return (Expression) new KotlinIsoVisitor<Integer>() {\n+                                            @Override\n+                                            public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n+                                                return ChangeStringLiteral.withStringValue(literal, because);\n+                                            }\n+                                        }.visitNonNull(arg, 0);\n+                                    }\n+                                    return arg;\n+                                })))\n+                        // Assign a unique ID so multiple constraints can be added\n+                        .map(it -> it.withId(Tree.randomId()))\n+                        .orElseThrow(() -> new IllegalStateException(\"Unable to find constraint\"));\n+            }\n \n             m = autoFormat(m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {\n                 if(!(arg instanceof J.Lambda)) {\n@@ -523,7 +669,7 @@ public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n \n                 return dependencies.withBody(body.withStatements(\n                         ListUtils.concat(constraint, body.getStatements())));\n-            })), constraint, ctx, getCursor().getParentOrThrow());\n+            })), ctx, getCursor().getParentOrThrow());\n             return m;\n         }\n     }\n@@ -537,6 +683,8 @@ private static class UpdateConstraintVersionVisitor extends GroovyIsoVisitor<Exe\n         @Nullable\n         String because;\n \n+        boolean isKotlinDsl;\n+\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             if (\"version\".equals(method.getSimpleName())) {\n@@ -570,7 +718,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                     return arg;\n                 }));\n                 if(because != null && !updatedBecause.get()) {\n-                    m = (J.MethodInvocation) new CreateBecauseVisitor(because).visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));\n+                    m = (J.MethodInvocation) new CreateBecauseVisitor(because, isKotlinDsl).visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));\n                 }\n             }\n             return m;\n@@ -630,32 +778,74 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n     @EqualsAndHashCode(callSuper = false)\n     private static class CreateBecauseVisitor extends GroovyIsoVisitor<ExecutionContext> {\n         String because;\n+        boolean isKotlinDsl;\n+\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n-            J.Lambda becauseArg = parseAsGradle(INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET, ctx)\n-                    .map(cu -> (J.MethodInvocation) cu.getStatements().get(1))\n-                    .map(J.MethodInvocation.class::cast)\n-                    .map(dependencies -> (J.Lambda) dependencies.getArguments().get(0))\n-                    .map(dependenciesClosure -> ((J.Block)dependenciesClosure.getBody()).getStatements().get(0))\n-                    .map(J.Return.class::cast)\n-                    .map(returnConstraints -> ((J.MethodInvocation) requireNonNull(returnConstraints.getExpression())).getArguments().get(0))\n-                    .map(J.Lambda.class::cast)\n-                    .map(constraintsClosure -> ((J.Block)constraintsClosure.getBody()).getStatements().get(0))\n-                    .map(J.Return.class::cast)\n-                    .map(returnImplementation -> ((J.MethodInvocation) requireNonNull(returnImplementation.getExpression())).getArguments().get(1))\n-                    .map(J.Lambda.class::cast)\n-                    .map(it -> (J.Lambda) new GroovyIsoVisitor<Integer>() {\n-                        @Override\n-                        public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n-                            return literal.withValue(because)\n-                                    .withValueSource(\"'\" + because + \"'\");\n-                        }\n-                    }.visitNonNull(it, 0))\n-                    .orElseThrow(() -> new IllegalStateException(\"Unable to parse because text\"));\n+            J.Lambda becauseArg;\n+            if (!isKotlinDsl) {\n+                becauseArg = parseAsGradle(INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_GROOVY, false, ctx)\n+                        .map(G.CompilationUnit.class::cast)\n+                        .map(cu -> (J.MethodInvocation) cu.getStatements().get(1))\n+                        .map(dependencies -> (J.Lambda) dependencies.getArguments().get(0))\n+                        .map(dependenciesClosure -> ((J.Block) dependenciesClosure.getBody()).getStatements().get(0))\n+                        .map(J.Return.class::cast)\n+                        .map(returnConstraints -> ((J.MethodInvocation) requireNonNull(returnConstraints.getExpression())).getArguments().get(0))\n+                        .map(J.Lambda.class::cast)\n+                        .map(constraintsClosure -> ((J.Block) constraintsClosure.getBody()).getStatements().get(0))\n+                        .map(J.Return.class::cast)\n+                        .map(returnImplementation -> ((J.MethodInvocation) requireNonNull(returnImplementation.getExpression())).getArguments().get(1))\n+                        .map(J.Lambda.class::cast)\n+                        .map(it -> (J.Lambda) new GroovyIsoVisitor<Integer>() {\n+                            @Override\n+                            public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n+                                return literal.withValue(because)\n+                                        .withValueSource(\"'\" + because + \"'\");\n+                            }\n+                        }.visitNonNull(it, 0))\n+                        .orElseThrow(() -> new IllegalStateException(\"Unable to parse because text\"));\n+            } else {\n+                becauseArg = parseAsGradle(INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_GROOVY, true, ctx)\n+                        .map(K.CompilationUnit.class::cast)\n+                        .map(cu -> (J.Block) cu.getStatements().get(0))\n+                        .map(block -> (J.MethodInvocation) block.getStatements().get(1))\n+                        .map(dependencies -> (J.Lambda) dependencies.getArguments().get(0))\n+                        .map(dependenciesClosure -> ((J.Block) dependenciesClosure.getBody()).getStatements().get(0))\n+                        .map(J.Return.class::cast)\n+                        .map(returnConstraints -> ((J.MethodInvocation) requireNonNull(returnConstraints.getExpression())).getArguments().get(0))\n+                        .map(J.Lambda.class::cast)\n+                        .map(constraintsClosure -> ((J.Block) constraintsClosure.getBody()).getStatements().get(0))\n+                        .map(J.Return.class::cast)\n+                        .map(returnImplementation -> ((J.MethodInvocation) requireNonNull(returnImplementation.getExpression())).getArguments().get(1))\n+                        .map(J.Lambda.class::cast)\n+                        .map(it -> (J.Lambda) new GroovyIsoVisitor<Integer>() {\n+                            @Override\n+                            public J.Literal visitLiteral(J.Literal literal, Integer integer) {\n+                                return literal.withValue(because)\n+                                        .withValueSource(\"'\" + because + \"'\");\n+                            }\n+                        }.visitNonNull(it, 0))\n+                        .orElseThrow(() -> new IllegalStateException(\"Unable to parse because text\"));\n+            }\n             m = m.withArguments(ListUtils.concat(m.getArguments().subList(0, 1), becauseArg));\n             m = autoFormat(m, ctx, getCursor().getParentOrThrow());\n             return m;\n         }\n     }\n+\n+    private static boolean withinBlock(Cursor cursor, String name) {\n+        Cursor parentCursor = cursor.getParent();\n+        while (parentCursor != null) {\n+            if (parentCursor.getValue() instanceof J.MethodInvocation) {\n+                J.MethodInvocation m = parentCursor.getValue();\n+                if (m.getSimpleName().equals(name)) {\n+                    return true;\n+                }\n+            }\n+            parentCursor = parentCursor.getParent();\n+        }\n+\n+        return false;\n+    }\n }\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/GradleDependency.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/GradleDependency.java\nindex 9d433d733a6..16fb59e63f2 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/GradleDependency.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/trait/GradleDependency.java\n@@ -27,6 +27,7 @@\n import org.openrewrite.java.MethodMatcher;\n import org.openrewrite.java.tree.Expression;\n import org.openrewrite.java.tree.J;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.maven.tree.Dependency;\n import org.openrewrite.maven.tree.GroupArtifactVersion;\n import org.openrewrite.maven.tree.ResolvedDependency;\n@@ -99,7 +100,7 @@ public Matcher artifactId(@Nullable String artifactId) {\n \n                 org.openrewrite.gradle.internal.Dependency dependency = null;\n                 Expression argument = methodInvocation.getArguments().get(0);\n-                if (argument instanceof J.Literal || argument instanceof G.GString || argument instanceof G.MapEntry || argument instanceof G.MapLiteral) {\n+                if (argument instanceof J.Literal || argument instanceof G.GString || argument instanceof G.MapEntry || argument instanceof G.MapLiteral || argument instanceof J.Assignment || argument instanceof K.StringTemplate) {\n                     dependency = parseDependency(methodInvocation.getArguments());\n                 } else if (argument instanceof J.MethodInvocation) {\n                     if (((J.MethodInvocation) argument).getSimpleName().equals(\"platform\") ||\n@@ -221,6 +222,42 @@ private boolean withinDependencyConstraintsBlock(Cursor cursor) {\n                 return getMapEntriesDependency(mapEntryExpressions);\n             } else if (argument instanceof G.MapEntry) {\n                 return getMapEntriesDependency(arguments);\n+            } else if (argument instanceof J.Assignment) {\n+                String group = null;\n+                String artifact = null;\n+\n+                for (Expression e : arguments) {\n+                    if (!(e instanceof J.Assignment)) {\n+                        continue;\n+                    }\n+                    J.Assignment arg = (J.Assignment) e;\n+                    if (!(arg.getVariable() instanceof J.Identifier) || !(arg.getAssignment() instanceof J.Literal)) {\n+                        continue;\n+                    }\n+                    J.Identifier identifier = (J.Identifier) arg.getVariable();\n+                    J.Literal value = (J.Literal) arg.getAssignment();\n+                    if (!(value.getValue() instanceof String)) {\n+                        continue;\n+                    }\n+                    String name = identifier.getSimpleName();\n+                    if (\"group\".equals(name)) {\n+                        group = (String) value.getValue();\n+                    } else if (\"name\".equals(name)) {\n+                        artifact = (String) value.getValue();\n+                    }\n+                }\n+\n+                if (group == null || artifact == null) {\n+                    return null;\n+                }\n+\n+                return new org.openrewrite.gradle.internal.Dependency(group, artifact, null, null, null);\n+            } else if (argument instanceof K.StringTemplate) {\n+                K.StringTemplate template = (K.StringTemplate) argument;\n+                List<J> strings = template.getStrings();\n+                if (strings.size() >= 2 && strings.get(0) instanceof J.Literal && ((J.Literal) strings.get(0)).getValue() != null) {\n+                    return DependencyStringNotationConverter.parse((String) ((J.Literal) strings.get(0)).getValue());\n+                }\n             }\n \n             return null;\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java b/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java\nindex 47b61432157..84daa94b20f 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java\n@@ -88,7 +88,10 @@ public <J2 extends J> J2 autoFormat(J2 j, P p, Cursor cursor) {\n \n     @SuppressWarnings({\"ConstantConditions\", \"unchecked\"})\n     public <J2 extends J> J2 autoFormat(J2 j, @Nullable J stopAfter, P p, Cursor cursor) {\n-        AutoFormatService service = getCursor().firstEnclosingOrThrow(JavaSourceFile.class).service(AutoFormatService.class);\n+        JavaSourceFile cu = (j instanceof JavaSourceFile) ?\n+                (JavaSourceFile) j :\n+                getCursor().firstEnclosingOrThrow(JavaSourceFile.class);\n+        AutoFormatService service = cu.service(AutoFormatService.class);\n         return (J2) service.autoFormatVisitor(stopAfter).visit(j, p, cursor);\n     }\n \n",
    "test_patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java\nindex 4f76d21ed0c..7d71d133e43 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/search/FindJVMTestSuites.java\n@@ -19,8 +19,9 @@\n import lombok.Value;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n+import org.openrewrite.gradle.IsBuildGradle;\n import org.openrewrite.gradle.table.JVMTestSuitesDefined;\n-import org.openrewrite.groovy.GroovyIsoVisitor;\n+import org.openrewrite.java.JavaIsoVisitor;\n import org.openrewrite.java.tree.Expression;\n import org.openrewrite.java.tree.J;\n import org.openrewrite.java.tree.Statement;\n@@ -61,7 +62,7 @@ public String getDescription() {\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n         boolean requireDependencies = definesDependencies != null && definesDependencies;\n         boolean tableAvailable = this.insertRows == null || this.insertRows;\n-        return new GroovyIsoVisitor<ExecutionContext>() {\n+        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {\n             private boolean isJVMTestSuitesBlock() {\n                 Cursor parent = getCursor().getParent();\n                 if (parent != null) {\n@@ -101,7 +102,7 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                 }\n                 return super.visitMethodInvocation(method, ctx);\n             }\n-        };\n+        });\n     }\n \n     public static Set<String> jvmTestSuiteNames(Tree tree, boolean definesDependencies) {\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java\nindex 39488b41e95..75ede738f10 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/AddDependencyTest.java\n@@ -33,8 +33,7 @@\n import java.util.Optional;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.openrewrite.gradle.Assertions.buildGradle;\n-import static org.openrewrite.gradle.Assertions.settingsGradle;\n+import static org.openrewrite.gradle.Assertions.*;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n import static org.openrewrite.groovy.Assertions.groovy;\n import static org.openrewrite.groovy.Assertions.srcMainGroovy;\n@@ -1625,6 +1624,85 @@ void onlyNonDependenciesInDirectDependencyBlock() {\n         }\n     }\n \n+    @ParameterizedTest\n+    @ValueSource(strings = {\"com.google.common.math.*\", \"com.google.common.math.IntMath\"})\n+    void kotlinDslOnlyIfUsingTestScope(String onlyIfUsing) {\n+        rewriteRun(\n+          spec -> spec.recipe(addDependency(\"com.google.guava:guava:29.0-jre\", onlyIfUsing)),\n+          mavenProject(\"project\",\n+            srcTestJava(\n+              java(usingGuavaIntMath)\n+            ),\n+            buildGradleKts(\n+              \"\"\"\n+                plugins {\n+                    `java-library`\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \"\"\",\n+              \"\"\"\n+                plugins {\n+                    `java-library`\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    testImplementation(\"com.google.guava:guava:29.0-jre\")\n+                }\n+                \"\"\"\n+            )\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslMatchesDependencyDeclarationStyle() {\n+        rewriteRun(\n+          spec -> spec.recipe(addDependency(\"com.google.guava:guava:29.0-jre\", \"com.google.common.math.IntMath\")),\n+          mavenProject(\"project\",\n+            srcTestJava(\n+              java(usingGuavaIntMath)\n+            ),\n+            buildGradleKts(\n+              \"\"\"\n+                plugins {\n+                    `java-library`\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation(group = \"commons-lang\", name = \"commons-lang\", version = \"1.0\")\n+                }\n+                \"\"\",\n+              \"\"\"\n+                plugins {\n+                    `java-library`\n+                }\n+                \n+                repositories {\n+                    mavenCentral()\n+                }\n+                \n+                dependencies {\n+                    implementation(group = \"commons-lang\", name = \"commons-lang\", version = \"1.0\")\n+                \n+                    testImplementation(group = \"com.google.guava\", name = \"guava\", version = \"29.0-jre\")\n+                }\n+                \"\"\"\n+            )\n+          )\n+        );\n+    }\n+\n     private AddDependency addDependency(@SuppressWarnings(\"SameParameterValue\") String gav) {\n         return addDependency(gav, null, null);\n     }\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/ChangeDependencyTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/ChangeDependencyTest.java\nindex decf3758ce9..c997e7b8688 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/ChangeDependencyTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/ChangeDependencyTest.java\n@@ -21,6 +21,7 @@\n import org.openrewrite.test.RewriteTest;\n \n import static org.openrewrite.gradle.Assertions.buildGradle;\n+import static org.openrewrite.gradle.Assertions.buildGradleKts;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n \n class ChangeDependencyTest implements RewriteTest {\n@@ -445,4 +446,78 @@ void relocateDependencyInJvmTestSuite() {\n             )\n         );\n     }\n+\n+    @Test\n+    void kotlinDsl() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependency(\"commons-lang\", \"commons-lang\", \"org.apache.commons\", \"commons-lang3\", \"3.11.x\", null, null)),\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(\"commons-lang:commons-lang:2.6\")\n+                  implementation(group = \"commons-lang\", name = \"commons-lang\", version = \"2.6\")\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(\"org.apache.commons:commons-lang3:3.11\")\n+                  implementation(group = \"org.apache.commons\", name = \"commons-lang3\", version = \"3.11\")\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslStringInterpolation() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependency(\"commons-lang\", \"commons-lang\", \"org.apache.commons\", \"commons-lang3\", \"3.11.x\", null, null)),\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  val commonsLangVersion = \"2.6\"\n+                  implementation(\"commons-lang:commons-lang:${commonsLangVersion}\")\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  val commonsLangVersion = \"2.6\"\n+                  implementation(\"org.apache.commons:commons-lang3:3.11\")\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/RemoveDependencyTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/RemoveDependencyTest.java\nindex e98dcb0fdd6..4d94fcd9fce 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/RemoveDependencyTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/RemoveDependencyTest.java\n@@ -26,8 +26,7 @@\n import java.util.Optional;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.openrewrite.gradle.Assertions.buildGradle;\n-import static org.openrewrite.gradle.Assertions.settingsGradle;\n+import static org.openrewrite.gradle.Assertions.*;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n import static org.openrewrite.java.Assertions.mavenProject;\n \n@@ -546,4 +545,74 @@ void dependenciesBlockInFreestandingScript() {\n           )\n         );\n     }\n+\n+    @Test\n+    void kotlinDslString() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(\"org.springframework.boot:spring-boot-starter-web:2.7.0\")\n+                  testImplementation(\"org.junit.vintage:junit-vintage-engine:5.6.2\")\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  testImplementation(\"org.junit.vintage:junit-vintage-engine:5.6.2\")\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslMap() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(group = \"org.springframework.boot\", name = \"spring-boot-starter-web\", version = \"2.7.0\")\n+                  testImplementation(group = \"org.junit.vintage\", name = \"junit-vintage-engine\", version = \"5.6.2\")\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  testImplementation(group = \"org.junit.vintage\", name = \"junit-vintage-engine\", version = \"5.6.2\")\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java\nindex 88d3f501e15..fdb3e35ae54 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java\n@@ -29,8 +29,7 @@\n import java.util.regex.Pattern;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.openrewrite.gradle.Assertions.buildGradle;\n-import static org.openrewrite.gradle.Assertions.settingsGradle;\n+import static org.openrewrite.gradle.Assertions.*;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n import static org.openrewrite.properties.Assertions.properties;\n \n@@ -1289,4 +1288,144 @@ void cannotDownloadMetaDataWhenNoRepositoriesAreDefined() {\n           )\n         );\n     }\n+\n+    @Test\n+    void kotlinDslString() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(\"com.google.guava:guava:29.0-jre\")\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(\"com.google.guava:guava:30.1.1-jre\")\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslMap() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(group = \"com.google.guava\", name = \"guava\", version = \"29.0-jre\")\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  implementation(group = \"com.google.guava\", name = \"guava\", version = \"30.1.1-jre\")\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslVariable() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  val guavaVersion = \"29.0-jre\"\n+                  implementation(group = \"com.google.guava\", name = \"guava\", version = guavaVersion)\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  val guavaVersion = \"30.1.1-jre\"\n+                  implementation(group = \"com.google.guava\", name = \"guava\", version = guavaVersion)\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslStringInterpolation() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  val guavaVersion = \"29.0-jre\"\n+                  implementation(\"com.google.guava:guava:${guavaVersion}\")\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \n+              dependencies {\n+                  val guavaVersion = \"30.1.1-jre\"\n+                  implementation(\"com.google.guava:guava:${guavaVersion}\")\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java\nindex 80d0d357b4a..9f544c456c3 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java\n@@ -24,6 +24,7 @@\n import java.util.List;\n \n import static org.openrewrite.gradle.Assertions.buildGradle;\n+import static org.openrewrite.gradle.Assertions.buildGradleKts;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n \n class UpgradeTransitiveDependencyVersionTest implements RewriteTest {\n@@ -456,6 +457,7 @@ void addConstraintToNonTransitiveExtendingTransitiveConfiguration() {\n           )\n         );\n     }\n+\n     @Test\n     void constraintDoesNotGetAddedToNonTransitiveNonExtendingConfiguration() {\n         rewriteRun(\n@@ -479,7 +481,7 @@ void constraintDoesNotGetAddedToNonTransitiveNonExtendingConfiguration() {\n     void constraintDoesNotGetAddedInsideConstraint() {\n         rewriteRun(\n           spec -> spec\n-            .recipe(new UpgradeTransitiveDependencyVersion(\"com.fasterxml.jackson.core\", \"jackson-core\",\"2.12.5\", null, \"CVE-2024-BAD\", null)),\n+            .recipe(new UpgradeTransitiveDependencyVersion(\"com.fasterxml.jackson.core\", \"jackson-core\", \"2.12.5\", null, \"CVE-2024-BAD\", null)),\n           //language=groovy\n           buildGradle(\n             \"\"\"\n@@ -671,4 +673,114 @@ void useResolutionStrategyWhenSpringDependencyManagementPluginIsPresent() {\n           )\n         );\n     }\n+\n+    @Test\n+    void kotlinDslAddConstraint() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                `java-library`\n+              }\n+              repositories { mavenCentral() }\n+              \n+              dependencies {\n+                  implementation(\"org.openrewrite:rewrite-java:7.0.0\")\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                `java-library`\n+              }\n+              repositories { mavenCentral() }\n+              \n+              dependencies {\n+                  constraints {\n+                      implementation(\"com.fasterxml.jackson.core:jackson-core:2.12.5\") {\n+                          because(\"CVE-2024-BAD\")\n+                      }\n+                  }\n+              \n+                  implementation(\"org.openrewrite:rewrite-java:7.0.0\")\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslUpdateConstraint() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \"\"\"\n+              plugins { id(\"java\") }\n+              repositories { mavenCentral() }\n+              \n+              dependencies {\n+                  constraints {\n+                      implementation(\"com.fasterxml.jackson.core:jackson-core:2.12.0\") {\n+                          because(\"some reason\")\n+                      }\n+                  }\n+              \n+                  implementation(\"org.openrewrite:rewrite-java:7.0.0\")\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins { id(\"java\") }\n+              repositories { mavenCentral() }\n+              \n+              dependencies {\n+                  constraints {\n+                      implementation(\"com.fasterxml.jackson.core:jackson-core:2.12.5\") {\n+                          because(\"CVE-2024-BAD\")\n+                      }\n+                  }\n+              \n+                  implementation(\"org.openrewrite:rewrite-java:7.0.0\")\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void kotlinDslUseResolutionStrategyWhenSpringDependencyManagementPluginIsPresent() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+                  id(\"io.spring.dependency-management\") version \"1.1.5\"\n+              }\n+              repositories { mavenCentral() }\n+              \n+              dependencies {\n+              \n+                  implementation(\"org.openrewrite:rewrite-java:7.0.0\")\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+                  id(\"io.spring.dependency-management\") version \"1.1.5\"\n+              }\n+              repositories { mavenCentral() }\n+              configurations.all {\n+                  resolutionStrategy.eachDependency { details ->\n+                      if (details.requested.group == \"com.fasterxml.jackson.core\" && details.requested.name == \"jackson-core\") {\n+                          details.useVersion(\"2.12.5\")\n+                          details.because(\"CVE-2024-BAD\")\n+                      }\n+                  }\n+              }\n+              \n+              dependencies {\n+              \n+                  implementation(\"org.openrewrite:rewrite-java:7.0.0\")\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5154",
    "pr_id": 5154,
    "issue_id": 3650,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Edge cases for Javadoc parsing\n\n## What version of OpenRewrite are you using?\n\nI am using OpenRewrite **8.48.0**.\n\n## What is the smallest, simplest way to reproduce the problem?\n\nThe following are a number of tests that can be inserted into `org.openrewrite.java.tree.JavadocTest`.\nEach detail a minor JavaDoc parsing issue.\n\n```java\n\n@Test\nvoid badlyClosedXmlTags() {\n  rewriteRun(\n    java(\"\"\"\n      /**\n       * <!--Optional:->\n       * <urn:portalId>?</urn:portalId-->\n       */\n      class Test { }\n      \"\"\")\n    );\n}\n\n@Test\nvoid spaceStarAfterStartOfJavaDoc() {\n  // remove the * after /**\n  rewriteRun(\n    java(\"\"\"\n      /** *\n       * @author x\n       */\n      class Test { }\n      \"\"\"));\n}\n```\n\n## What did you expect to see?\nA green test.\nI have no particular interest in exactly how the parser solves the issue (i.e., by ignoring, or correcting), just that it does not fail on the whole file.\n\n## What did you see instead?\nA red test, i.e., parsing stops with an error.\n\n\n",
    "issue_word_count": 131,
    "test_files_count": 1,
    "non_test_files_count": 8,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java",
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java"
    ],
    "base_commit": "6b3b568a5acf6d00075b888ff4d95ee1d41bb641",
    "head_commit": "c6f1463bba5064d3a4371508c84f836d6c1e26e7",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5154",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5154",
    "dockerfile": "",
    "pr_merged_at": "2025-03-12T09:28:18.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\nindex 0ff9afbed53..9ea123dadc2 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11JavadocVisitor.java\n@@ -874,26 +874,29 @@ public Tree visitText(TextTree node, List<Javadoc> body) {\n     public List<Javadoc> visitText(String node) {\n         List<Javadoc> texts = new ArrayList<>();\n \n-        if (!node.isEmpty() && Character.isWhitespace(node.charAt(0)) &&\n-            !Character.isWhitespace(source.charAt(cursor))) {\n+        if (!node.isEmpty() && Character.isWhitespace(node.charAt(0)) && !Character.isWhitespace(source.charAt(cursor))) {\n             node = node.stripLeading();\n         }\n \n         StringBuilder text = new StringBuilder();\n         for (int i = 0; i < node.length(); i++) {\n             char c = node.charAt(i);\n-            cursor++;\n             if (c == '\\n') {\n                 if (text.length() > 0) {\n                     texts.add(new Javadoc.Text(randomId(), Markers.EMPTY, text.toString()));\n                     text = new StringBuilder();\n                 }\n \n+                cursor++;\n                 Javadoc.LineBreak lineBreak = lineBreaks.remove(cursor);\n-                assert lineBreak != null;\n                 texts.add(lineBreak);\n+            } else if (source.charAt(cursor) != c && (source.startsWith(unicodeEscaped(c), cursor) || source.startsWith(unicodeEscaped(c).toLowerCase(), cursor) )) {\n+                int escapedCharLength = unicodeEscaped(c).length();\n+                text.append(source, cursor, cursor + escapedCharLength);\n+                cursor += escapedCharLength;\n             } else {\n                 text.append(c);\n+                cursor++;\n             }\n         }\n \n@@ -904,6 +907,10 @@ public List<Javadoc> visitText(String node) {\n         return texts;\n     }\n \n+    private static String unicodeEscaped(char c) {\n+        return String.format(\"\\\\u%04X\", (int) c);\n+    }\n+\n     @Override\n     public Tree visitThrows(ThrowsTree node, List<Javadoc> body) {\n         boolean throwsKeyword = source.startsWith(\"@throws\", cursor);\n\ndiff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\nindex b1e85e6179c..3b30033be24 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n@@ -2285,20 +2285,16 @@ Space formatWithCommentTree(String prefix, JCTree tree, DCTree.@Nullable DCDocCo\n             }\n \n             AtomicReference<Javadoc.DocComment> javadoc = new AtomicReference<>();\n-            int commentCursor = cursor - prefix.length() + fmt.getWhitespace().length();\n             for (int j = 0; j < comments.size(); j++) {\n-                Comment comment = comments.get(j);\n                 if (i == j) {\n                     javadoc.set((Javadoc.DocComment) new ReloadableJava11JavadocVisitor(\n                             context,\n                             getCurrentPath(),\n                             typeMapping,\n-                            source.substring(commentCursor, source.indexOf(\"*/\", commentCursor + 1)),\n+                            \"/*\" + ((TextComment) comments.get(j)).getText(),\n                             tree\n                     ).scan(commentTree, new ArrayList<>(1)));\n                     break;\n-                } else {\n-                    commentCursor += comment.printComment(new Cursor(null, \"root\")).length() + comment.getSuffix().length();\n                 }\n             }\n \n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\nindex c88faeda547..cae33484690 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17JavadocVisitor.java\n@@ -877,26 +877,29 @@ public Tree visitText(TextTree node, List<Javadoc> body) {\n     public List<Javadoc> visitText(String node) {\n         List<Javadoc> texts = new ArrayList<>();\n \n-        if (!node.isEmpty() && Character.isWhitespace(node.charAt(0)) &&\n-                !Character.isWhitespace(source.charAt(cursor))) {\n+        if (!node.isEmpty() && Character.isWhitespace(node.charAt(0)) && !Character.isWhitespace(source.charAt(cursor))) {\n             node = node.stripLeading();\n         }\n \n         StringBuilder text = new StringBuilder();\n         for (int i = 0; i < node.length(); i++) {\n             char c = node.charAt(i);\n-            cursor++;\n             if (c == '\\n') {\n                 if (text.length() > 0) {\n                     texts.add(new Javadoc.Text(randomId(), Markers.EMPTY, text.toString()));\n                     text = new StringBuilder();\n                 }\n \n+                cursor++;\n                 Javadoc.LineBreak lineBreak = lineBreaks.remove(cursor);\n-                assert lineBreak != null;\n                 texts.add(lineBreak);\n+            } else if (source.charAt(cursor) != c && (source.startsWith(unicodeEscaped(c), cursor) || source.startsWith(unicodeEscaped(c).toLowerCase(), cursor) )) {\n+                int escapedCharLength = unicodeEscaped(c).length();\n+                text.append(source, cursor, cursor + escapedCharLength);\n+                cursor += escapedCharLength;\n             } else {\n                 text.append(c);\n+                cursor++;\n             }\n         }\n \n@@ -907,6 +910,10 @@ public List<Javadoc> visitText(String node) {\n         return texts;\n     }\n \n+    private static String unicodeEscaped(char c) {\n+        return String.format(\"\\\\u%04X\", (int) c);\n+    }\n+\n     @Override\n     public Tree visitThrows(ThrowsTree node, List<Javadoc> body) {\n         boolean throwsKeyword = source.startsWith(\"@throws\", cursor);\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex 11a07dced11..994a22729b2 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -2372,20 +2372,16 @@ Space formatWithCommentTree(String prefix, JCTree tree, @Nullable DocCommentTree\n             }\n \n             AtomicReference<Javadoc.DocComment> javadoc = new AtomicReference<>();\n-            int commentCursor = cursor - prefix.length() + fmt.getWhitespace().length();\n             for (int j = 0; j < comments.size(); j++) {\n-                Comment comment = comments.get(j);\n                 if (i == j) {\n                     javadoc.set((Javadoc.DocComment) new ReloadableJava17JavadocVisitor(\n                             context,\n                             getCurrentPath(),\n                             typeMapping,\n-                            source.substring(commentCursor, source.indexOf(\"*/\", commentCursor + 1)),\n+                            \"/*\" + ((TextComment) comments.get(j)).getText(),\n                             tree\n                     ).scan(commentTree, new ArrayList<>(1)));\n                     break;\n-                } else {\n-                    commentCursor += comment.printComment(new Cursor(null, \"root\")).length() + comment.getSuffix().length();\n                 }\n             }\n \n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\nindex 05fbb3bbe95..1e246e7cfb3 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21JavadocVisitor.java\n@@ -877,26 +877,29 @@ public Tree visitText(TextTree node, List<Javadoc> body) {\n     public List<Javadoc> visitText(String node) {\n         List<Javadoc> texts = new ArrayList<>();\n \n-        if (!node.isEmpty() && Character.isWhitespace(node.charAt(0)) &&\n-                !Character.isWhitespace(source.charAt(cursor))) {\n+        if (!node.isEmpty() && Character.isWhitespace(node.charAt(0)) && !Character.isWhitespace(source.charAt(cursor))) {\n             node = node.stripLeading();\n         }\n \n         StringBuilder text = new StringBuilder();\n         for (int i = 0; i < node.length(); i++) {\n             char c = node.charAt(i);\n-            cursor++;\n             if (c == '\\n') {\n                 if (text.length() > 0) {\n                     texts.add(new Javadoc.Text(randomId(), Markers.EMPTY, text.toString()));\n                     text = new StringBuilder();\n                 }\n \n+                cursor++;\n                 Javadoc.LineBreak lineBreak = lineBreaks.remove(cursor);\n-                assert lineBreak != null;\n                 texts.add(lineBreak);\n+            } else if (source.charAt(cursor) != c && (source.startsWith(unicodeEscaped(c), cursor) || source.startsWith(unicodeEscaped(c).toLowerCase(), cursor) )) {\n+                int escapedCharLength = unicodeEscaped(c).length();\n+                text.append(source, cursor, cursor + escapedCharLength);\n+                cursor += escapedCharLength;\n             } else {\n                 text.append(c);\n+                cursor++;\n             }\n         }\n \n@@ -907,6 +910,10 @@ public List<Javadoc> visitText(String node) {\n         return texts;\n     }\n \n+    private static String unicodeEscaped(char c) {\n+        return String.format(\"\\\\u%04X\", (int) c);\n+    }\n+\n     @Override\n     public Tree visitThrows(ThrowsTree node, List<Javadoc> body) {\n         boolean throwsKeyword = source.startsWith(\"@throws\", cursor);\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex bb9cc80e0dc..1af1452481f 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -2398,20 +2398,16 @@ Space formatWithCommentTree(String prefix, JCTree tree, @Nullable DocCommentTree\n             }\n \n             AtomicReference<Javadoc.DocComment> javadoc = new AtomicReference<>();\n-            int commentCursor = cursor - prefix.length() + fmt.getWhitespace().length();\n             for (int j = 0; j < comments.size(); j++) {\n-                Comment comment = comments.get(j);\n                 if (i == j) {\n                     javadoc.set((Javadoc.DocComment) new ReloadableJava21JavadocVisitor(\n                             context,\n                             getCurrentPath(),\n                             typeMapping,\n-                            source.substring(commentCursor, source.indexOf(\"*/\", commentCursor + 1)),\n+                            \"/*\" + ((TextComment) comments.get(j)).getText(),\n                             tree\n                     ).scan(commentTree, new ArrayList<>(1)));\n                     break;\n-                } else {\n-                    commentCursor += comment.printComment(new Cursor(null, \"root\")).length() + comment.getSuffix().length();\n                 }\n             }\n \n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\nindex d3e9cada02a..94d390eee8a 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8JavadocVisitor.java\n@@ -802,8 +802,7 @@ public Tree visitText(TextTree node, List<Javadoc> body) {\n     public List<Javadoc> visitText(String node) {\n         List<Javadoc> texts = new ArrayList<>();\n \n-        if (!node.isEmpty() && Character.isWhitespace(node.charAt(0)) &&\n-                !Character.isWhitespace(source.charAt(cursor))) {\n+        if (!node.isEmpty() && Character.isWhitespace(node.charAt(0)) && !Character.isWhitespace(source.charAt(cursor))) {\n             int i = 0;\n             for (; i < node.length() && Character.isWhitespace(node.charAt(i)); i++) {\n             }\n@@ -814,18 +813,22 @@ public List<Javadoc> visitText(String node) {\n         StringBuilder text = new StringBuilder();\n         for (int i = 0; i < node.length(); i++) {\n             char c = node.charAt(i);\n-            cursor++;\n             if (c == '\\n') {\n                 if (text.length() > 0) {\n                     texts.add(new Javadoc.Text(randomId(), Markers.EMPTY, text.toString()));\n                     text = new StringBuilder();\n                 }\n \n+                cursor++;\n                 Javadoc.LineBreak lineBreak = lineBreaks.remove(cursor);\n-                assert lineBreak != null;\n                 texts.add(lineBreak);\n+            } else if (source.charAt(cursor) != c && (source.startsWith(unicodeEscaped(c), cursor) || source.startsWith(unicodeEscaped(c).toLowerCase(), cursor) )) {\n+                int escapedCharLength = unicodeEscaped(c).length();\n+                text.append(source, cursor, cursor + escapedCharLength);\n+                cursor += escapedCharLength;\n             } else {\n                 text.append(c);\n+                cursor++;\n             }\n         }\n \n@@ -836,6 +839,10 @@ public List<Javadoc> visitText(String node) {\n         return texts;\n     }\n \n+    private static String unicodeEscaped(char c) {\n+        return String.format(\"\\\\u%04X\", (int) c);\n+    }\n+\n     @Override\n     public Tree visitThrows(ThrowsTree node, List<Javadoc> body) {\n         boolean throwsKeyword = source.startsWith(\"@throws\", cursor);\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\nindex 8aca3953e65..58c12eab302 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n@@ -2281,20 +2281,16 @@ Space formatWithCommentTree(String prefix, JCTree tree, DCTree.@Nullable DCDocCo\n             }\n \n             AtomicReference<Javadoc.DocComment> javadoc = new AtomicReference<>();\n-            int commentCursor = cursor - prefix.length() + fmt.getWhitespace().length();\n             for (int j = 0; j < comments.size(); j++) {\n-                Comment comment = comments.get(j);\n                 if (i == j) {\n                     javadoc.set((Javadoc.DocComment) new ReloadableJava8JavadocVisitor(\n                             context,\n                             getCurrentPath(),\n                             typeMapping,\n-                            source.substring(commentCursor, source.indexOf(\"*/\", commentCursor + 1)),\n+                            \"/*\" + ((TextComment) comments.get(j)).getText(),\n                             tree\n                     ).scan(commentTree, new ArrayList<>(1)));\n                     break;\n-                } else {\n-                    commentCursor += comment.printComment(new Cursor(null, \"root\")).length() + comment.getSuffix().length();\n                 }\n             }\n \n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\nindex 1946e924c83..5daa6c22752 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\n@@ -1808,7 +1808,6 @@ interface Test {\n         );\n     }\n \n-    @Disabled\n     @Test\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/3650\")\n     void unicodeEscape() {\n@@ -1817,7 +1816,11 @@ void unicodeEscape() {\n             \"\"\"\n               interface Test {\n               \t/**\n-              \t * Return the {@code \\\\u0000} codepoint.\n+              \t * <p>Ř\\\\u00e9t\\\\u00FBrn:</p>\n+              \t * \n+              \t * {@code \\\\u0040Override\n+                 * public void method() {}\n+                 * }\n               \t */\n               \tint foo();\n               }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5152",
    "pr_id": 5152,
    "issue_id": 5083,
    "repo": "openrewrite/rewrite",
    "problem_statement": "`org.openrewrite.yaml.MergeYaml` is not respecting the current indentation of the list\nWhen merging into an existing list with no indentation, the modified entry will be indented, causing the new list to be invalid\n\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using\n\n- OpenRewrite v8.47.1\n- Maven plugin v6.2.0\n\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\nI wrote a unit test to reproduce the issue\n\n```java\nclass MergeYamlTest implements RewriteTest {\n    ...\n    @Test\n    void mergeListRespectIndentation() {\n        rewriteRun(spec ->\n            spec.recipe(new MergeYaml(\n              \"$\",\n              //language=yaml\n              \"\"\"\n                widget:\n                  list:\n                  - item 2\n                \"\"\",\n              false,\n              null,\n              null,\n              null,\n              null\n            )),\n          yaml(\n            \"\"\"\n              widget:\n                list:\n                - item 1\n              \"\"\",\n            \"\"\"\n              widget:\n                list:\n                - item 1\n                - item 2\n              \"\"\"\n          )\n        );\n    }\n    ...\n}\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\n```yaml\n widget:\n   list:\n   - item 1\n   - item 2\n```\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\n```yaml\nwidget:\n    list:\n    - item 1\n      - item 2\n```\n",
    "issue_word_count": 388,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYamlVisitor.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "base_commit": "c741362ca7a7c3c1eb7abb9ef63ff71ef0f0350f",
    "head_commit": "375d299bc9b142cc610fd8bd53ddf240cc2c67b2",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5152",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5152",
    "dockerfile": "",
    "pr_merged_at": "2025-03-10T14:14:50.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYamlVisitor.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYamlVisitor.java\nindex 68a6c2a6752..9214467adda 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYamlVisitor.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYamlVisitor.java\n@@ -292,7 +292,9 @@ private Yaml.Sequence mergeSequence(Yaml.Sequence s1, Yaml.Sequence s2, P p, Cur\n                 }\n             }\n \n-            List<Yaml.Sequence.Entry> newEntries = map(incomingEntries, it -> autoFormat(it, p, cursor));\n+            String existingEntryPrefix = s1.getEntries().get(0).getPrefix();\n+            String currentIndent = existingEntryPrefix.substring(existingEntryPrefix.lastIndexOf('\\n'));\n+            List<Yaml.Sequence.Entry> newEntries = ListUtils.map(incomingEntries, it -> it.withPrefix(currentIndent));\n             List<Yaml.Sequence.Entry> mutatedEntries = concatAll(s1.getEntries(), newEntries, it -> ((Yaml.Scalar) it.getBlock()).getValue()).ls;\n \n             return s1.withEntries(mutatedEntries);\n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\nindex 40b3e5406e4..7fad2b6061a 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n@@ -3027,4 +3027,38 @@ void lastEntryShouldKeepItsComment() {\n           )\n         );\n     }\n+\n+    @Test\n+    void mergeListRespectIndentation() {\n+        rewriteRun(spec ->\n+            spec.recipe(new MergeYaml(\n+              \"$\",\n+              //language=yaml\n+              \"\"\"\n+                widget:\n+                  list:\n+                  - item 2\n+                \"\"\",\n+              false,\n+              null,\n+              null,\n+              null,\n+              null,\n+              true\n+            )),\n+          yaml(\n+            \"\"\"\n+              widget:\n+                list:\n+                - item 1\n+              \"\"\",\n+            \"\"\"\n+              widget:\n+                list:\n+                - item 1\n+                - item 2\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5150",
    "pr_id": 5150,
    "issue_id": 5135,
    "repo": "openrewrite/rewrite",
    "problem_statement": "`MergeYaml` edge case: keeps comment at the end of the doc after appending an entry\nSee the test below:\n\n```java\n    @Test\n    void insertInSequenceEntriesWithDeepSearchWithComment_1() {\n        rewriteRun(\n          spec -> spec.recipe(new MergeYaml(\n            \"$..containers\",\n            \"imagePullPolicy: Always\",\n            true,\n            null,\n            null,\n            null,\n            null\n          )),\n          yaml(\n            \"\"\"\n              kind: Pod\n              spec:\n                containers:\n                  - name: <container name>  # comment\n              \"\"\",\n            \"\"\"\n              kind: Pod\n              spec:\n                containers:\n                  - name: <container name>  # comment\n                    imagePullPolicy: Always\n              \"\"\"\n          )\n        );\n    }\n```\n\nThis fails because `# comment` is in DocumentEnd node rather than the yaml block. Not sure what to propose... I'd probably try to keep the inline comment as part of the entry... Or perhaps have a special case for the comment at the end of the document if this would be a less intrusive fix.",
    "issue_word_count": 111,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "base_commit": "c77d9f082d94dfb5de1dc80e41b039622c81b746",
    "head_commit": "f9d71e54f464ccde3d96aa770c1f0ba9506f938e",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5150",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5150",
    "dockerfile": "",
    "pr_merged_at": "2025-03-10T12:17:24.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java\nindex 2bdb7fe1c45..1a6ad265481 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java\n@@ -190,6 +190,9 @@ public Yaml.Document visitDocument(Yaml.Document document, ExecutionContext ctx)\n                             new MergeYamlVisitor<>(d.getBlock(), MergeYaml.parse(snippet), accptTheirs, objectIdentifyingProperty, insertMode, insertProperty)\n                                     .visitNonNull(d.getBlock(), ctx, getCursor()));\n                 }\n+                if (getCursor().getMessage(REMOVE_PREFIX, false)) {\n+                    d = d.withEnd(d.getEnd().withPrefix(\"\"));\n+                }\n                 return d;\n             }\n \n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\nindex 455723b90c2..40b3e5406e4 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n@@ -3002,4 +3002,29 @@ void sourceNull() {\n                 ))\n             ));\n     }\n+\n+    @Test\n+    void lastEntryShouldKeepItsComment() {\n+        rewriteRun(\n+          spec -> spec.recipe(new MergeYaml(\n+            \"$.\",\n+            \"imagePullPolicy: Always\",\n+            true,\n+            null,\n+            null,\n+            null,\n+            null,\n+            true\n+          )),\n+          yaml(\n+            \"\"\"\n+            containers: ALEF # comment\n+            \"\"\",\n+            \"\"\"\n+            containers: ALEF # comment\n+            imagePullPolicy: Always\n+            \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5149",
    "pr_id": 5149,
    "issue_id": 4955,
    "repo": "openrewrite/rewrite",
    "problem_statement": "NPE in MergeYaml\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\nConfigure the `org.openrewrite.yaml.MergeYaml` without any of the required parameters (I just copied a list of recipes taken from the discover goal) and run OpenRewrite.\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n```\n java.lang.NullPointerException: Cannot invoke \"String.getBytes(java.nio.charset.Charset)\" because \"source\" is null\n\tat org.openrewrite.Parser$Input.lambda$fromString$0(Parser.java:175)\n\tat org.openrewrite.Parser$Input.getSource(Parser.java:215)\n\tat org.openrewrite.tree.ParseError.build(ParseError.java:97)\n\tat org.openrewrite.yaml.YamlParser.lambda$parseInputs$0(YamlParser.java:77)\n\tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\n\tat java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179)\n\tat java.base/java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1602)\n\tat java.base/java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:129)\n\tat java.base/java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:527)\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:513)\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n\tat java.base/java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:150)\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n\tat java.base/java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:647)\n\tat org.openrewrite.yaml.MergeYaml.lambda$validate$1(MergeYaml.java:66)\n\tat org.openrewrite.Validated.test(Validated.java:81)\n\tat org.openrewrite.yaml.MergeYaml.validate(MergeYaml.java:64)\n\tat org.openrewrite.Recipe.validate(Recipe.java:383)\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\n",
    "issue_word_count": 387,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "base_commit": "5a1526be834030b8311e1bb44979707630719444",
    "head_commit": "8bf02f5da9f54090db6a156524d2a756a591ac63",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5149",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5149",
    "dockerfile": "",
    "pr_merged_at": "2025-03-10T09:27:10.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java\nindex b78c1553296..2bdb7fe1c45 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java\n@@ -121,6 +121,9 @@ public Validated<Object> validate() {\n         return super.validate()\n                 .and(Validated.test(\"yaml\", \"Must be valid YAML\",\n                         yaml, y -> {\n+                            if (yaml == null) {\n+                                return false;\n+                            }\n                             MergeYaml.maybeParse(yaml).ifPresent(it -> incoming = it);\n                             return incoming != null;\n                         }))\n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\nindex 99fac7ee934..455723b90c2 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n@@ -2984,4 +2984,22 @@ void createNewKeysFalse() {\n           )\n         );\n     }\n+\n+    @Test\n+    void sourceNull() {\n+        assertThrows(AssertionError.class, () ->\n+            rewriteRun(\n+              spec -> spec\n+                .recipe(new MergeYaml(\n+                  \"$.some.object\",\n+                  null,\n+                  false,\n+                  \"name\",\n+                  null,\n+                  null,\n+                  null,\n+                  null\n+                ))\n+            ));\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5147",
    "pr_id": 5147,
    "issue_id": 5146,
    "repo": "openrewrite/rewrite",
    "problem_statement": "semicolon removed in enum w/o values (observed with upgrade rewrite-maven-plugin from 6.2.0 to 6.2.1)\n## What version of OpenRewrite are you using?\nI am using\n\n- Maven plugin v6.2.1\n\n## How are you running OpenRewrite?\nI am using the Maven plugin, and my project is a multi-module project.\n\n## What is the smallest, simplest way to reproduce the problem?\nOriginal code:\n```java\n     public enum A {\n         ;\n         public static final String X = \"receipt-id\";\n     }\n```\n\n- https://github.com/pzrep/rewrite-maven-plugin-953 -> https://github.com/pzrep/rewrite-maven-plugin-953/pull/1 -> https://github.com/pzrep/rewrite-maven-plugin-953/actions/runs/13540330563/job/37839773851?pr=1#step:6:25\n\n## What did you expect to see?\nNo patch created by openrewrite.\n\n## What did you see instead?\n`;` removed which caused `Compilation failure: enum constant expected here`\n\nSeems to be a regression seen after\n- https://github.com/openrewrite/rewrite/pull/5063",
    "issue_word_count": 153,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/EnumTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/EnumTest.java"
    ],
    "base_commit": "5a1526be834030b8311e1bb44979707630719444",
    "head_commit": "937e204cc61d3101433cbb88d70a8738d2e94446",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5147",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5147",
    "dockerfile": "",
    "pr_merged_at": "2025-03-10T11:10:15.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\nindex 0f7ac12128e..b1e85e6179c 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n@@ -458,6 +458,10 @@ public J visitClass(ClassTree node, Space fmt) {\n                     ),\n                     EMPTY\n             );\n+        } else if (kind.getType() == J.ClassDeclaration.Kind.Type.Enum) {\n+            if (positionOfNext(\";\", null) >= 0) {\n+                enumSet = padRight(new J.EnumValueSet(randomId(), sourceBefore(\";\"), Markers.EMPTY, emptyList(), true), EMPTY);\n+            }\n         }\n \n         List<Tree> membersMultiVariablesSeparated = new ArrayList<>(node.getMembers().size());\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex d140418c37c..11a07dced11 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -514,6 +514,10 @@ public J visitClass(ClassTree node, Space fmt) {\n                     ),\n                     EMPTY\n             );\n+        } else if (kind.getType() == J.ClassDeclaration.Kind.Type.Enum) {\n+            if (positionOfNext(\";\", null) >= 0) {\n+                enumSet = padRight(new J.EnumValueSet(randomId(), sourceBefore(\";\"), Markers.EMPTY, emptyList(), true), EMPTY);\n+            }\n         }\n \n         List<Tree> membersMultiVariablesSeparated = new ArrayList<>(node.getMembers().size());\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex 94cfb8b1cd8..bb9cc80e0dc 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -515,6 +515,10 @@ public J visitClass(ClassTree node, Space fmt) {\n                     ),\n                     EMPTY\n             );\n+        } else if (kind.getType() == J.ClassDeclaration.Kind.Type.Enum) {\n+            if (positionOfNext(\";\", null) >= 0) {\n+                enumSet = padRight(new J.EnumValueSet(randomId(), sourceBefore(\";\"), Markers.EMPTY, emptyList(), true), EMPTY);\n+            }\n         }\n \n         List<Tree> membersMultiVariablesSeparated = new ArrayList<>(node.getMembers().size());\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\nindex ddebe1a80cb..8aca3953e65 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n@@ -456,6 +456,10 @@ public J visitClass(ClassTree node, Space fmt) {\n                     ),\n                     EMPTY\n             );\n+        } else if (kind.getType() == J.ClassDeclaration.Kind.Type.Enum) {\n+            if (positionOfNext(\";\", null) >= 0) {\n+                enumSet = padRight(new J.EnumValueSet(randomId(), sourceBefore(\";\"), Markers.EMPTY, emptyList(), true), EMPTY);\n+            }\n         }\n \n         List<Tree> membersMultiVariablesSeparated = new ArrayList<>(node.getMembers().size());\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/EnumTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/EnumTest.java\nindex 90dc6a8d5c1..15860a74712 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/EnumTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/EnumTest.java\n@@ -178,4 +178,24 @@ public enum A {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5146\")\n+    void noValuesJustSemicolon() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+             public enum A {\n+                 ;\n+                 public static final String X = \"receipt-id\";\n+             }\n+             \"\"\",\n+            spec -> spec.afterRecipe( cu -> {\n+                J.EnumValueSet enumValueStatement = (J.EnumValueSet) cu.getClasses().get(0).getBody().getStatements().get(0);\n+                assert enumValueStatement.getEnums().isEmpty();\n+                assert enumValueStatement.isTerminatedWithSemicolon();\n+            })\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5140",
    "pr_id": 5140,
    "issue_id": 5139,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Failure while parsing switch expressions with combined clauses null and default\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using\n\n- Maven/Gradle plugin LATEST (v6.2.2)\n\n\n## How are you running OpenRewrite?\n<!--\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\nIs your project a single module or a multi-module project?\n\nCan you share your configuration so that we can rule out any configuration issues?\n\nIs your project public? If so, can you share a link to it?\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\n-->\nI am using the Maven plugin, and my project is a single module project.\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\n```xml\n❯ cat pom.xml                                                                    \n<project>\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>com.mycompany.app</groupId>\n  <artifactId>my-app</artifactId>\n  <version>1</version>\n\n  <properties>\n      <maven.compiler.target>21</maven.compiler.target>\n      <maven.compiler.source>21</maven.compiler.source>\n      <maven.compiler.release>21</maven.compiler.release>\n  </properties>\n</project> \n```\n```java\n❯ cat src/main/java/Foo.java\npublic class Foo {\n\tpublic static void main(String[] args) {\n\t\tNumber number = null;\n\t\tswitch (number) {\n\t\t\tcase null, default -> System.out.println(\"something\");\n\t\t}\n\t}\n}\n```\n\n\n```\nJAVA_HOME=/usr/lib/jvm/temurin-23-jdk-amd64 \\\n          /opt/maven/apache-maven-3.9.9/bin/mvn \\\n            -Dorg.slf4j.simpleLogger.defaultLogLevel=WARN  \\\n              org.openrewrite.maven:rewrite-maven-plugin:LATEST:run \\\n                -Drewrite.activeRecipes=org.openrewrite.maven.OrderPomElements  \n```\n\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\n\nI expected rewrite to not throw an error. \n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\n\nAn error parsing the Java code. \n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n\n\n```\nJAVA_HOME=/usr/lib/jvm/temurin-23-jdk-amd64 \\\n          /opt/maven/apache-maven-3.9.9/bin/mvn \\\n            -Dorg.slf4j.simpleLogger.defaultLogLevel=WARN  \\\n              org.openrewrite.maven:rewrite-maven-plugin:LATEST:run \\\n                -Drewrite.activeRecipes=org.openrewrite.maven.OrderPomElements  \n[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!\n[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!\n[WARNING] This Gauge has been already registered (MeterId{name='cache.size', tags=[tag(cache=Maven POMs - default)]}), the Gauge registration will be ignored. Note that subsequent logs will be logged at debug level.\n[WARNING] There were problems parsing some source files, run with --errors to see full stack traces\n[WARNING] There were problems parsing src/main/java/Foo.java\n[WARNING] The recipe produced 6 warning(s). Please report this to the recipe author.\n[WARNING] Run with `--debug` or `-Drewrite.exportDatatables=true` to see all warnings.\norg.openrewrite.java.JavaParsingException: Failed to convert for the following cursor stack:--- BEGIN PATH ---\nJCCompilationUnit(sourceFile = /home/flip/Downloads/teste/src/main/java/Foo.java)\nJCClassDecl(name = Foo, line = 1)\nJCMethodDecl(line = 2)\nJCBlock(line = 2)\nJCSwitch(line = 4)\n--- END PATH ---\n\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.reportJavaParsingException (ReloadableJava21ParserVisitor.java:1817)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1784)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1828)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertAll (ReloadableJava21ParserVisitor.java:1896)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertAll (ReloadableJava21ParserVisitor.java:1883)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitSwitch (ReloadableJava21ParserVisitor.java:1281)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitSwitch (ReloadableJava21ParserVisitor.java:77)\n    at com.sun.tools.javac.tree.JCTree$JCSwitch.accept (JCTree.java:1350)\n    at com.sun.source.util.TreePathScanner.scan (TreePathScanner.java:92)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1778)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1828)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1821)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertStatements (ReloadableJava21ParserVisitor.java:2007)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertStatements (ReloadableJava21ParserVisitor.java:1969)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitBlock (ReloadableJava21ParserVisitor.java:326)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitBlock (ReloadableJava21ParserVisitor.java:77)\n    at com.sun.tools.javac.tree.JCTree$JCBlock.accept (JCTree.java:1145)\n    at com.sun.source.util.TreePathScanner.scan (TreePathScanner.java:92)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1778)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitMethod (ReloadableJava21ParserVisitor.java:1075)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitMethod (ReloadableJava21ParserVisitor.java:77)\n    at com.sun.tools.javac.tree.JCTree$JCMethodDecl.accept (JCTree.java:989)\n    at com.sun.source.util.TreePathScanner.scan (TreePathScanner.java:92)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1778)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1828)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1821)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertStatements (ReloadableJava21ParserVisitor.java:2007)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertStatements (ReloadableJava21ParserVisitor.java:1969)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitClass (ReloadableJava21ParserVisitor.java:542)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitClass (ReloadableJava21ParserVisitor.java:77)\n    at com.sun.tools.javac.tree.JCTree$JCClassDecl.accept (JCTree.java:896)\n    at com.sun.source.util.TreePathScanner.scan (TreePathScanner.java:92)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1778)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertAll (ReloadableJava21ParserVisitor.java:1875)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitCompilationUnit (ReloadableJava21ParserVisitor.java:587)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitCompilationUnit (ReloadableJava21ParserVisitor.java:77)\n    at com.sun.tools.javac.tree.JCTree$JCCompilationUnit.accept (JCTree.java:625)\n    at com.sun.source.util.TreePathScanner.scan (TreePathScanner.java:92)\n    at org.openrewrite.java.isolated.ReloadableJava21Parser.lambda$parseInputs$1 (ReloadableJava21Parser.java:188)\n    at java.util.stream.ReferencePipeline$3$1.accept (ReferencePipeline.java:215)\n    at java.util.Iterator.forEachRemaining (Iterator.java:133)\n    at java.util.Spliterators$IteratorSpliterator.forEachRemaining (Spliterators.java:1939)\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:570)\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:560)\n    at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining (StreamSpliterators.java:315)\n    at java.util.stream.Streams$ConcatSpliterator.forEachRemaining (Streams.java:734)\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:570)\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:560)\n    at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining (StreamSpliterators.java:315)\n    at java.util.stream.Streams$ConcatSpliterator.forEachRemaining (Streams.java:734)\n    at java.util.stream.Streams$ConcatSpliterator.forEachRemaining (Streams.java:735)\n    at java.util.stream.Streams$ConcatSpliterator.forEachRemaining (Streams.java:734)\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:570)\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:560)\n    at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining (StreamSpliterators.java:315)\n    at java.util.stream.Streams$ConcatSpliterator.forEachRemaining (Streams.java:734)\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:570)\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:560)\n    at java.util.stream.ForEachOps$ForEachOp.evaluateSequential (ForEachOps.java:151)\n    at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential (ForEachOps.java:174)\n    at java.util.stream.AbstractPipeline.evaluate (AbstractPipeline.java:265)\n    at java.util.stream.ReferencePipeline.forEach (ReferencePipeline.java:636)\n    at java.util.stream.ReferencePipeline$7$1FlatMap.accept (ReferencePipeline.java:294)\n    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining (ArrayList.java:1709)\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:570)\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:560)\n    at java.util.stream.ReduceOps$ReduceOp.evaluateSequential (ReduceOps.java:921)\n    at java.util.stream.AbstractPipeline.evaluate (AbstractPipeline.java:265)\n    at java.util.stream.ReferencePipeline.collect (ReferencePipeline.java:727)\n    at org.openrewrite.maven.AbstractRewriteBaseRunMojo.sourcesWithAutoDetectedStyles (AbstractRewriteBaseRunMojo.java:275)\n    at org.openrewrite.maven.AbstractRewriteBaseRunMojo.loadSourceSet (AbstractRewriteBaseRunMojo.java:237)\n    at org.openrewrite.maven.AbstractRewriteBaseRunMojo.listResults (AbstractRewriteBaseRunMojo.java:152)\n    at org.openrewrite.maven.AbstractRewriteRunMojo.execute (AbstractRewriteRunMojo.java:66)\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:126)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.doExecute2 (MojoExecutor.java:328)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.doExecute (MojoExecutor.java:316)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:212)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:174)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.access$000 (MojoExecutor.java:75)\n    at org.apache.maven.lifecycle.internal.MojoExecutor$1.run (MojoExecutor.java:162)\n    at org.apache.maven.plugin.DefaultMojosExecutionStrategy.execute (DefaultMojosExecutionStrategy.java:39)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:159)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:105)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:73)\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:53)\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:118)\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:261)\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:173)\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:101)\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:906)\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:283)\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:206)\n    at jdk.internal.reflect.DirectMethodHandleAccessor.invoke (DirectMethodHandleAccessor.java:103)\n    at java.lang.reflect.Method.invoke (Method.java:580)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:255)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:201)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:361)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:314)\nCaused by: java.lang.NullPointerException: Cannot invoke \"org.openrewrite.java.tree.JRightPadded.getAfter()\" because \"rightPadded\" is null\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1831)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertAll (ReloadableJava21ParserVisitor.java:1896)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertAll (ReloadableJava21ParserVisitor.java:1883)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitCase (ReloadableJava21ParserVisitor.java:356)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitCase (ReloadableJava21ParserVisitor.java:77)\n    at com.sun.tools.javac.tree.JCTree$JCCase.accept (JCTree.java:1415)\n    at com.sun.source.util.TreePathScanner.scan (TreePathScanner.java:92)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1778)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1828)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertAll (ReloadableJava21ParserVisitor.java:1896)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertAll (ReloadableJava21ParserVisitor.java:1883)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitSwitch (ReloadableJava21ParserVisitor.java:1281)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitSwitch (ReloadableJava21ParserVisitor.java:77)\n    at com.sun.tools.javac.tree.JCTree$JCSwitch.accept (JCTree.java:1350)\n    at com.sun.source.util.TreePathScanner.scan (TreePathScanner.java:92)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1778)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1828)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1821)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertStatements (ReloadableJava21ParserVisitor.java:2007)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertStatements (ReloadableJava21ParserVisitor.java:1969)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitBlock (ReloadableJava21ParserVisitor.java:326)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitBlock (ReloadableJava21ParserVisitor.java:77)\n    at com.sun.tools.javac.tree.JCTree$JCBlock.accept (JCTree.java:1145)\n    at com.sun.source.util.TreePathScanner.scan (TreePathScanner.java:92)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1778)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitMethod (ReloadableJava21ParserVisitor.java:1075)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitMethod (ReloadableJava21ParserVisitor.java:77)\n    at com.sun.tools.javac.tree.JCTree$JCMethodDecl.accept (JCTree.java:989)\n    at com.sun.source.util.TreePathScanner.scan (TreePathScanner.java:92)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1778)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1828)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1821)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertStatements (ReloadableJava21ParserVisitor.java:2007)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertStatements (ReloadableJava21ParserVisitor.java:1969)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitClass (ReloadableJava21ParserVisitor.java:542)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitClass (ReloadableJava21ParserVisitor.java:77)\n    at com.sun.tools.javac.tree.JCTree$JCClassDecl.accept (JCTree.java:896)\n    at com.sun.source.util.TreePathScanner.scan (TreePathScanner.java:92)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convert (ReloadableJava21ParserVisitor.java:1778)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.convertAll (ReloadableJava21ParserVisitor.java:1875)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitCompilationUnit (ReloadableJava21ParserVisitor.java:587)\n    at org.openrewrite.java.isolated.ReloadableJava21ParserVisitor.visitCompilationUnit (ReloadableJava21ParserVisitor.java:77)\n    at com.sun.tools.javac.tree.JCTree$JCCompilationUnit.accept (JCTree.java:625)\n    at com.sun.source.util.TreePathScanner.scan (TreePathScanner.java:92)\n    at org.openrewrite.java.isolated.ReloadableJava21Parser.lambda$parseInputs$1 (ReloadableJava21Parser.java:188)\n    at java.util.stream.ReferencePipeline$3$1.accept (ReferencePipeline.java:215)\n    at java.util.Iterator.forEachRemaining (Iterator.java:133)\n    at java.util.Spliterators$IteratorSpliterator.forEachRemaining (Spliterators.java:1939)\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:570)\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:560)\n    at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining (StreamSpliterators.java:315)\n    at java.util.stream.Streams$ConcatSpliterator.forEachRemaining (Streams.java:734)\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:570)\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:560)\n    at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining (StreamSpliterators.java:315)\n    at java.util.stream.Streams$ConcatSpliterator.forEachRemaining (Streams.java:734)\n    at java.util.stream.Streams$ConcatSpliterator.forEachRemaining (Streams.java:735)\n    at java.util.stream.Streams$ConcatSpliterator.forEachRemaining (Streams.java:734)\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:570)\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:560)\n    at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining (StreamSpliterators.java:315)\n    at java.util.stream.Streams$ConcatSpliterator.forEachRemaining (Streams.java:734)\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:570)\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:560)\n    at java.util.stream.ForEachOps$ForEachOp.evaluateSequential (ForEachOps.java:151)\n    at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential (ForEachOps.java:174)\n    at java.util.stream.AbstractPipeline.evaluate (AbstractPipeline.java:265)\n    at java.util.stream.ReferencePipeline.forEach (ReferencePipeline.java:636)\n    at java.util.stream.ReferencePipeline$7$1FlatMap.accept (ReferencePipeline.java:294)\n    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining (ArrayList.java:1709)\n    at java.util.stream.AbstractPipeline.copyInto (AbstractPipeline.java:570)\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto (AbstractPipeline.java:560)\n    at java.util.stream.ReduceOps$ReduceOp.evaluateSequential (ReduceOps.java:921)\n    at java.util.stream.AbstractPipeline.evaluate (AbstractPipeline.java:265)\n    at java.util.stream.ReferencePipeline.collect (ReferencePipeline.java:727)\n    at org.openrewrite.maven.AbstractRewriteBaseRunMojo.sourcesWithAutoDetectedStyles (AbstractRewriteBaseRunMojo.java:275)\n    at org.openrewrite.maven.AbstractRewriteBaseRunMojo.loadSourceSet (AbstractRewriteBaseRunMojo.java:237)\n    at org.openrewrite.maven.AbstractRewriteBaseRunMojo.listResults (AbstractRewriteBaseRunMojo.java:152)\n    at org.openrewrite.maven.AbstractRewriteRunMojo.execute (AbstractRewriteRunMojo.java:66)\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:126)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.doExecute2 (MojoExecutor.java:328)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.doExecute (MojoExecutor.java:316)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:212)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:174)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.access$000 (MojoExecutor.java:75)\n    at org.apache.maven.lifecycle.internal.MojoExecutor$1.run (MojoExecutor.java:162)\n    at org.apache.maven.plugin.DefaultMojosExecutionStrategy.execute (DefaultMojosExecutionStrategy.java:39)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:159)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:105)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:73)\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:53)\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:118)\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:261)\n    at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:173)\n    at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:101)\n    at org.apache.maven.cli.MavenCli.execute (MavenCli.java:906)\n    at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:283)\n    at org.apache.maven.cli.MavenCli.main (MavenCli.java:206)\n    at jdk.internal.reflect.DirectMethodHandleAccessor.invoke (DirectMethodHandleAccessor.java:103)\n    at java.lang.reflect.Method.invoke (Method.java:580)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:255)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:201)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:361)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:314)\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\n\nYes",
    "issue_word_count": 2838,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java"
    ],
    "base_commit": "6cde40472ed5896620b8ba37b5796ee829d359bd",
    "head_commit": "d2e163a346f35fabacf79b706490e6f621373319",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5140",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5140",
    "dockerfile": "",
    "pr_merged_at": "2025-03-18T01:01:16.000Z",
    "patch": "diff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex 1af1452481f..066fdd91c2b 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -338,6 +338,11 @@ public J visitBreak(BreakTree node, Space fmt) {\n         return new J.Break(randomId(), fmt, Markers.EMPTY, label);\n     }\n \n+    @Override\n+    public J visitDefaultCaseLabel(DefaultCaseLabelTree node, Space space) {\n+        return new J.Identifier(randomId(), space, Markers.EMPTY, emptyList(), skip(\"default\"), null, null);\n+    }\n+\n     @Override\n     public J visitCase(CaseTree node, Space fmt) {\n         J.Case.Type type = node.getCaseKind() == CaseTree.CaseKind.RULE ? J.Case.Type.Rule : J.Case.Type.Statement;\n@@ -351,9 +356,7 @@ public J visitCase(CaseTree node, Space fmt) {\n                 JContainer.build(\n                         node.getLabels().isEmpty() || node.getLabels().getFirst() instanceof DefaultCaseLabelTree ?\n                                 EMPTY : sourceBefore(\"case\"),\n-                        node.getLabels().isEmpty() || node.getLabels().getFirst() instanceof DefaultCaseLabelTree ?\n-                                List.of(JRightPadded.build(new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), skip(\"default\"), null, null))) :\n-                                convertAll(node.getLabels(), commaDelim, ignored -> node.getGuard() != null ? sourceBefore(\"when\", '-') : EMPTY),\n+                        convertAll(node.getLabels(), commaDelim, ignored -> node.getGuard() != null ? sourceBefore(\"when\", '-') : EMPTY),\n                         Markers.EMPTY\n                 ),\n                 convert(node.getGuard()),\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java\nindex 532544031b7..a45013a28e0 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java\n@@ -64,6 +64,24 @@ void fooBarWithNull(String s) {\n           ));\n     }\n \n+    @Test\n+    void shouldSupportParsingNullSwitchCombined() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \"\"\"\n+              class Test {\n+                void fooBarWithNull(String s) {\n+                    switch (s) {\n+                        case \"Foo\", \"Bar\" -> System.out.println(\"Great\");\n+                        case null, default -> System.out.println(\"Ok\");\n+                    }\n+                }\n+              }\n+              \"\"\"\n+          ));\n+    }\n+\n     @Test\n     void shouldParseJava21EnumSupportInSwitch() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5132",
    "pr_id": 5132,
    "issue_id": 4116,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Groovy parser does not support unassigned closure with GString as return value\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\n\r\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\n- OpenRewrite v8.11.5\r\n- Maven/Gradle plugin v5.17.1\r\n- rewrite-groovyv8.21.0\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\nI am using the Maven plugin, and my project is a single module project.\r\n```xml\r\n<plugin>\r\n    <groupId>org.openrewrite.maven</groupId>\r\n    <artifactId>rewrite-maven-plugin</artifactId>\r\n    <version>5.17.1</version>\r\n    <configuration>\r\n        <activeRecipes>\r\n            <recipe>net.test.sample.UpdateJenkinsRecipe</recipe>\r\n        </activeRecipes>\r\n    </configuration>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>net.test.sample</groupId>\r\n            <artifactId>jenkinsrecipe</artifactId>\r\n            <version>1.0.0-SNAPSHOT</version>\r\n        </dependency>\r\n    </dependencies>\r\n</plugin>\r\n```\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\n\r\nplease unit test with this below content which is from from jenkins file - you shoule be able to reproduce the problem.\r\n\r\n```groovy\r\n#!groovy\r\ndef getEndBuild() {\r\n    { steps , config , domain ->\r\n        new net.one.gtu.jenkins.helper.ConsoleLogger(steps).logInfo(\"Intentionally exiting the build early.  Please\" +\r\n                \" disregard subsequent errors; they do not represent real concerns/issues\");\r\n        throw new org.jenkinsci.plugins.workflow.steps.FlowInterruptedException(hudson.model.Result.SUCCESS);\r\n\r\n    }\r\n}\r\ndef buildPipeline1() {\r\n    pipelineRunner {\r\n        yml = 'jenkins_old.yml'\r\n        endBuild = getEndBuild();\r\n    }\r\n}\r\n```\r\n\r\ncreated customVisitor which extend GroovyVisitor and i'm trying to read jenkinsfile and update some static content back to the file.Below is the myvisitor code .the error is occurring during the Parse, not during my custom visit.\r\n```java \r\n@Override\r\npublic TreeVisitor<?, ExecutionContext> getVisitor() {\r\n    log.info(\"I'm in the recipe for jenkins file update\");\r\n    return Preconditions.check(new FindSourceFiles(\"Jenkinsfile\"), new GroovyVisitor<ExecutionContext>() {\r\n\r\n        @Override\r\n        public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\r\n}\r\n)};\r\n}\r\n```\r\nThe issue is happening in below block of code inside the sourceBefore method \r\n```java\r\n @Override\r\n  public void visitBlockStatement(BlockStatement block) {\r\n      Space fmt = EMPTY;\r\n      Object parent = nodeCursor.getParentOrThrow().getValue();\r\n      if (!(parent instanceof ClosureExpression)) {\r\n          fmt = sourceBefore(\"{\");\r\n      }\r\n```\r\n\r\n## What is the smallest, simplest way to reproduce the problem as unit test?\r\n\r\n```java\r\n@Test\r\nvoid closureWithGString() {\r\n    rewriteRun(\r\n        groovy(\r\n            \"\"\"\r\n            { x -> \"${x.y}\" }\r\n            \"\"\"\r\n        )\r\n    );\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\n\r\nExpected to see Parsing successful , the error is occurring during the Parse, not during my custom visit. Which implies that there's an issue either in the source file I'm trying to parse, or, in OpenRewrite's groovy-parsing logic. so i added the content from source file and this file is being used my teams accross my firm\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\n```\r\norg.openrewrite.groovy.GroovyParsingException: Failed to parse Jenkinsfile at cursor position 592. The next 10 characters in the original source are `{\r\n       `\r\n  org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:174)\r\n```\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\r\n```\r\norg.openrewrite.groovy.GroovyParsingException: Failed to parse Jenkinsfile at cursor position 592. The next 10 characters in the original source are `{\r\n       `\r\n  org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:174)\r\n```\r\n\r\nDuring debug found out that inside this closure after domain -> the code is trying to get the nextSourceBefore using delim '{' which is avaialble only in the next method which is  buildPipeline1(). so that's where the parsing issue happening.\r\n  \r\n```\r\n  { steps , config , domain ->\r\n        **new net.jpmchase.gti.jules.helper.ConsoleLogger(steps).**logInfo**(\"Intentionally exiting the build early.  Please\" +\r\n                \" disregard subsequent errors; they do not represent real concerns/issues\");\r\n    } \r\n\r\ndef buildPipeline1()** {\r\n    pipelineRunner {\r\n        yml = 'jenkins_old.yml'\r\n        endBuild = getEndBuild();\r\n    }\r\n}\r\n```\r\n",
    "issue_word_count": 873,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/MethodInvocationTest.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/RealWorldGroovyTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/MethodInvocationTest.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/RealWorldGroovyTest.java"
    ],
    "base_commit": "3c0734b68b48fa914dc9c103683bb15288a3e8b2",
    "head_commit": "b9618e491dc33edad4335422b7a4cc35d69c78c5",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5132",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5132",
    "dockerfile": "",
    "pr_merged_at": "2025-03-06T07:58:50.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex b8a5a9b41ad..38a1da65eaf 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -974,11 +974,12 @@ public void visitBlockStatement(BlockStatement block) {\n             Space staticInitPadding = EMPTY;\n             boolean isStaticInit = sourceStartsWith(\"static\");\n             Object parent = nodeCursor.getParentOrThrow().getValue();\n+            boolean withinClosure = parent instanceof ClosureExpression || (parent instanceof ExpressionStatement && ((ExpressionStatement) parent).getExpression() instanceof ClosureExpression);\n             if (isStaticInit) {\n                 fmt = sourceBefore(\"static\");\n                 staticInitPadding = whitespace();\n                 skip(\"{\");\n-            } else if (!(parent instanceof ClosureExpression)) {\n+            } else if (!withinClosure) {\n                 fmt = sourceBefore(\"{\");\n             }\n             List<JRightPadded<Statement>> statements = new ArrayList<>(block.getStatements().size());\n@@ -1010,7 +1011,7 @@ public void visitBlockStatement(BlockStatement block) {\n                 statements.add(stat);\n             }\n             queue.add(new J.Block(randomId(), fmt, Markers.EMPTY, new JRightPadded<>(isStaticInit, staticInitPadding, Markers.EMPTY), statements, whitespace()));\n-            if (!(parent instanceof ClosureExpression)) {\n+            if (!withinClosure) {\n                 skip(\"}\");\n             }\n         }\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/MethodInvocationTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/MethodInvocationTest.java\nindex c7896db23ed..51edea97eb4 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/MethodInvocationTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/MethodInvocationTest.java\n@@ -229,6 +229,18 @@ def acceptsClosure(Closure cl) {}\n         );\n     }\n \n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4116\")\n+    @Test\n+    void closureWithGString() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+            { x -> \"${x.y}\" }\n+            \"\"\"\n+          )\n+        );\n+    }\n+\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/4766\")\n     @Test\n     void gradleFileWithMultipleClosuresWithoutParentheses() {\n\ndiff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/RealWorldGroovyTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/RealWorldGroovyTest.java\nindex a99ceacbba0..dbe952f113f 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/RealWorldGroovyTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/RealWorldGroovyTest.java\n@@ -26,6 +26,31 @@\n  */\n class RealWorldGroovyTest implements RewriteTest {\n \n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4116\")\n+    void jenkinsFile() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              #!groovy\n+              def getEndBuild() {\n+                  { steps , config , domain ->\n+                      new net.one.gtu.jenkins.helper.ConsoleLogger(steps)\n+                          .logInfo(\"Intentionally exiting the build early. Please disregard subsequent errors; they do not represent real concerns/issues\");\n+                      throw new org.jenkinsci.plugins.workflow.steps.FlowInterruptedException(hudson.model.Result.SUCCESS);\n+                  }\n+              }\n+              def buildPipeline1() {\n+                  pipelineRunner {\n+                      yml = 'jenkins_old.yml'\n+                      endBuild = getEndBuild();\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     @Issue(\"https://github.com/spring-projects/spring-boot/blob/v3.4.1/settings.gradle\")\n     void springBootSettingsGradle() {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5122",
    "pr_id": 5122,
    "issue_id": 3291,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Dependency management support for Gradle Kotlin scripts (.kts)\n## What problem are you trying to solve?\r\nGradle supports Groovy and Kotlin as scripting languages for build files. We currently support editing Groovy-based build files. This should be extended to Kotiln.\r\n\r\n## Describe the solution you'd like\r\nFor each Gradle-groovy dependency management recipe there should be a Gradle-kotlin equivalent.\r\n\r\n## Additional context\r\nRequires some enhancements to rewrite-kotlin and rewrite-gradle. ",
    "issue_word_count": 71,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-gradle/build.gradle.kts",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/Assertions.java",
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleParser.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/GradleParserTest.java",
      "rewrite-kotlin/src/main/java/org/openrewrite/kotlin/KotlinParser.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/GradleParserTest.java"
    ],
    "base_commit": "bd9c7df594d05ab72b87ab368eaf2c02d5ac70e3",
    "head_commit": "02f6c13b899f54a1b3914c5619c49474bfe57b02",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5122",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5122",
    "dockerfile": "",
    "pr_merged_at": "2025-03-07T21:32:32.000Z",
    "patch": "diff --git a/rewrite-gradle/build.gradle.kts b/rewrite-gradle/build.gradle.kts\nindex af442cf07f6..76c35eeb487 100644\n--- a/rewrite-gradle/build.gradle.kts\n+++ b/rewrite-gradle/build.gradle.kts\n@@ -46,6 +46,7 @@ dependencies {\n     api(project(\":rewrite-groovy\")) {\n         exclude(\"org.codehaus.groovy\", \"groovy\")\n     }\n+    api(project(\":rewrite-kotlin\"))\n     api(project(\":rewrite-maven\"))\n     api(\"org.jetbrains:annotations:latest.release\")\n     compileOnly(project(\":rewrite-test\"))\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/Assertions.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/Assertions.java\nindex ab91480d22c..e87b05a158f 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/Assertions.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/Assertions.java\n@@ -21,6 +21,7 @@\n import org.openrewrite.SourceFile;\n import org.openrewrite.groovy.GroovyParser;\n import org.openrewrite.groovy.tree.G;\n+import org.openrewrite.kotlin.tree.K;\n import org.openrewrite.test.SourceSpec;\n import org.openrewrite.test.SourceSpecs;\n import org.openrewrite.test.UncheckedConsumer;\n@@ -101,6 +102,31 @@ public static SourceSpecs buildGradle(@Language(\"groovy\") @Nullable String befor\n         return gradle;\n     }\n \n+    public static SourceSpecs buildGradleKts(@Language(\"kotlin\") @Nullable String before) {\n+        return buildGradleKts(before, s -> {\n+        });\n+    }\n+\n+    public static SourceSpecs buildGradleKts(@Language(\"kotlin\") @Nullable String before, Consumer<SourceSpec<K.CompilationUnit>> spec) {\n+        SourceSpec<K.CompilationUnit> gradle = new SourceSpec<>(K.CompilationUnit.class, \"gradle\", gradleParser, before, null);\n+        gradle.path(Paths.get(\"build.gradle.kts\"));\n+        spec.accept(gradle);\n+        return gradle;\n+    }\n+\n+    public static SourceSpecs buildGradleKts(@Language(\"kotlin\") @Nullable String before, @Language(\"kotlin\") @Nullable String after) {\n+        return buildGradleKts(before, after, s -> {\n+        });\n+    }\n+\n+    public static SourceSpecs buildGradleKts(@Language(\"kotlin\") @Nullable String before, @Language(\"kotlin\") @Nullable String after,\n+                                          Consumer<SourceSpec<K.CompilationUnit>> spec) {\n+        SourceSpec<K.CompilationUnit> gradle = new SourceSpec<>(K.CompilationUnit.class, \"gradle\", gradleParser, before, s -> after);\n+        gradle.path(\"build.gradle.kts\");\n+        spec.accept(gradle);\n+        return gradle;\n+    }\n+\n     public static SourceSpecs settingsGradle(@Language(\"groovy\") @Nullable String before) {\n         return settingsGradle(before, s -> {\n         });\n@@ -125,4 +151,29 @@ public static SourceSpecs settingsGradle(@Language(\"groovy\") @Nullable String be\n         spec.accept(gradle);\n         return gradle;\n     }\n+\n+    public static SourceSpecs settingsGradleKts(@Language(\"kotlin\") @Nullable String before) {\n+        return settingsGradleKts(before, s -> {\n+        });\n+    }\n+\n+    public static SourceSpecs settingsGradleKts(@Language(\"kotlin\") @Nullable String before, Consumer<SourceSpec<K.CompilationUnit>> spec) {\n+        SourceSpec<K.CompilationUnit> gradle = new SourceSpec<>(K.CompilationUnit.class, \"gradle\", gradleParser, before, null);\n+        gradle.path(Paths.get(\"settings.gradle.kts\"));\n+        spec.accept(gradle);\n+        return gradle;\n+    }\n+\n+    public static SourceSpecs settingsGradleKts(@Language(\"kotlin\") @Nullable String before, @Language(\"kotlin\") @Nullable String after) {\n+        return settingsGradleKts(before, after, s -> {\n+        });\n+    }\n+\n+    public static SourceSpecs settingsGradleKts(@Language(\"kotlin\") @Nullable String before, @Language(\"kotlin\") @Nullable String after,\n+                                             Consumer<SourceSpec<K.CompilationUnit>> spec) {\n+        SourceSpec<K.CompilationUnit> gradle = new SourceSpec<>(K.CompilationUnit.class, \"gradle\", gradleParser, before, s -> after);\n+        gradle.path(\"settings.gradle.kts\");\n+        spec.accept(gradle);\n+        return gradle;\n+    }\n }\n\ndiff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleParser.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleParser.java\nindex 22ecd30ec7d..6bf435c2d2c 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleParser.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/GradleParser.java\n@@ -25,6 +25,7 @@\n import org.openrewrite.groovy.GroovyParser;\n import org.openrewrite.groovy.tree.G;\n import org.openrewrite.java.JavaParser;\n+import org.openrewrite.kotlin.KotlinParser;\n \n import java.nio.file.Path;\n import java.util.Collection;\n@@ -38,12 +39,14 @@ public class GradleParser implements Parser {\n     private final GradleParser.Builder base;\n \n     private Collection<Path> defaultClasspath;\n-    private GroovyParser buildParser;\n-    private GroovyParser settingsParser;\n+    private GroovyParser groovyBuildParser;\n+    private GroovyParser groovySettingsParser;\n+    private KotlinParser kotlinBuildParser;\n+    private KotlinParser kotlinSettingsParser;\n \n     @Override\n     public Stream<SourceFile> parseInputs(Iterable<Input> sources, @Nullable Path relativeTo, ExecutionContext ctx) {\n-        if (buildParser == null) {\n+        if (groovyBuildParser == null) {\n             Collection<Path> buildscriptClasspath = base.buildscriptClasspath;\n             if (buildscriptClasspath == null) {\n                 if (defaultClasspath == null) {\n@@ -51,7 +54,7 @@ public Stream<SourceFile> parseInputs(Iterable<Input> sources, @Nullable Path re\n                 }\n                 buildscriptClasspath = defaultClasspath;\n             }\n-            buildParser = GroovyParser.builder(base.groovyParser)\n+            groovyBuildParser = GroovyParser.builder(base.groovyParser)\n                     .classpath(buildscriptClasspath)\n                     .compilerCustomizers(\n                             new DefaultImportsCustomizer(),\n@@ -59,7 +62,19 @@ public Stream<SourceFile> parseInputs(Iterable<Input> sources, @Nullable Path re\n                     )\n                     .build();\n         }\n-        if (settingsParser == null) {\n+        if (kotlinBuildParser == null) {\n+            Collection<Path> buildscriptClasspath = base.buildscriptClasspath;\n+            if (buildscriptClasspath == null) {\n+                if (defaultClasspath == null) {\n+                    defaultClasspath = loadDefaultClasspath();\n+                }\n+                buildscriptClasspath = defaultClasspath;\n+            }\n+            kotlinBuildParser = KotlinParser.builder(base.kotlinParser)\n+                    .classpath(buildscriptClasspath)\n+                    .build();\n+        }\n+        if (groovySettingsParser == null) {\n             Collection<Path> settingsClasspath = base.settingsClasspath;\n             if (settingsClasspath == null) {\n                 if (defaultClasspath == null) {\n@@ -67,7 +82,7 @@ public Stream<SourceFile> parseInputs(Iterable<Input> sources, @Nullable Path re\n                 }\n                 settingsClasspath = defaultClasspath;\n             }\n-            settingsParser = GroovyParser.builder(base.groovyParser)\n+            groovySettingsParser = GroovyParser.builder(base.groovyParser)\n                     .classpath(settingsClasspath)\n                     .compilerCustomizers(\n                             new DefaultImportsCustomizer(),\n@@ -75,19 +90,36 @@ public Stream<SourceFile> parseInputs(Iterable<Input> sources, @Nullable Path re\n                     )\n                     .build();\n         }\n+        if (kotlinSettingsParser == null) {\n+            Collection<Path> settingsClasspath = base.settingsClasspath;\n+            if (settingsClasspath == null) {\n+                if (defaultClasspath == null) {\n+                    loadDefaultClasspath();\n+                }\n+                settingsClasspath = defaultClasspath;\n+            }\n+            kotlinSettingsParser = KotlinParser.builder(base.kotlinParser)\n+                    .classpath(settingsClasspath)\n+                    .build();\n+        }\n \n         return StreamSupport.stream(sources.spliterator(), false)\n                 .flatMap(source -> {\n-                    if (source.getPath().endsWith(\"settings.gradle\")) {\n-                        return settingsParser.parseInputs(Collections.singletonList(source), relativeTo, ctx);\n+                    Path sourcePath = source.getPath();\n+                    if (sourcePath.endsWith(\"settings.gradle.kts\")) {\n+                        return kotlinSettingsParser.parseInputs(Collections.singletonList(source), relativeTo, ctx);\n+                    } else if (sourcePath.endsWith(\"settings.gradle\")) {\n+                        return groovySettingsParser.parseInputs(Collections.singletonList(source), relativeTo, ctx);\n+                    } else if (sourcePath.toString().endsWith(\".gradle.kts\")) {\n+                        return kotlinBuildParser.parseInputs(Collections.singletonList(source), relativeTo, ctx);\n                     }\n-                    return buildParser.parseInputs(Collections.singletonList(source), relativeTo, ctx);\n+                    return groovyBuildParser.parseInputs(Collections.singletonList(source), relativeTo, ctx);\n                 });\n     }\n \n     @Override\n     public boolean accept(Path path) {\n-        return path.toString().endsWith(\".gradle\");\n+        return path.toString().endsWith(\".gradle\") || path.toString().endsWith(\".gradle.kts\");\n     }\n \n     @Override\n@@ -101,6 +133,7 @@ public static Builder builder() {\n \n     public static class Builder extends Parser.Builder {\n         protected GroovyParser.Builder groovyParser = GroovyParser.builder();\n+        protected KotlinParser.Builder kotlinParser = KotlinParser.builder();\n \n         @Nullable\n         private Collection<Path> buildscriptClasspath;\n@@ -117,6 +150,11 @@ public Builder groovyParser(GroovyParser.Builder groovyParser) {\n             return this;\n         }\n \n+        public Builder kotlinParser(KotlinParser.Builder kotlinParser) {\n+            this.kotlinParser = kotlinParser;\n+            return this;\n+        }\n+\n         public Builder buildscriptClasspath(Collection<Path> classpath) {\n             this.buildscriptClasspath = classpath;\n             return this;\n\ndiff --git a/rewrite-kotlin/src/main/java/org/openrewrite/kotlin/KotlinParser.java b/rewrite-kotlin/src/main/java/org/openrewrite/kotlin/KotlinParser.java\nindex 29543496436..b1581427dc4 100644\n--- a/rewrite-kotlin/src/main/java/org/openrewrite/kotlin/KotlinParser.java\n+++ b/rewrite-kotlin/src/main/java/org/openrewrite/kotlin/KotlinParser.java\n@@ -250,6 +250,10 @@ public static Builder builder() {\n         return new Builder();\n     }\n \n+    public static Builder builder(Builder base) {\n+        return new Builder(base);\n+    }\n+\n     @SuppressWarnings(\"unused\")\n     public static class Builder extends Parser.Builder {\n         @Nullable\n@@ -270,6 +274,15 @@ public Builder() {\n             super(K.CompilationUnit.class);\n         }\n \n+        public Builder(Builder base) {\n+            super(K.CompilationUnit.class);\n+            this.classpath = base.classpath;\n+            this.artifactNames = base.artifactNames;\n+            this.typeCache = base.typeCache;\n+            this.logCompilationWarningsAndErrors = base.logCompilationWarningsAndErrors;\n+            this.styles.addAll(base.styles);\n+        }\n+\n         public Builder logCompilationWarningsAndErrors(boolean logCompilationWarningsAndErrors) {\n             this.logCompilationWarningsAndErrors = logCompilationWarningsAndErrors;\n             return this;\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/GradleParserTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/GradleParserTest.java\nindex 7ffb40fcc46..6746c717f5a 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/GradleParserTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/GradleParserTest.java\n@@ -20,8 +20,7 @@\n import org.openrewrite.test.RewriteTest;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.openrewrite.gradle.Assertions.buildGradle;\n-import static org.openrewrite.gradle.Assertions.settingsGradle;\n+import static org.openrewrite.gradle.Assertions.*;\n \n class GradleParserTest implements RewriteTest {\n \n@@ -188,4 +187,21 @@ void handleImportsThatArentTheFirstStatement() {\n           )\n         );\n     }\n+\n+    @Test\n+    void kotlinDsl() {\n+        rewriteRun(\n+          buildGradleKts(\n+            \"\"\"\n+              plugins {\n+                  `java-library`\n+              }\n+              \n+              repositories {\n+                  mavenCentral()\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5118",
    "pr_id": 5118,
    "issue_id": 5117,
    "repo": "openrewrite/rewrite",
    "problem_statement": "RemoveDependency not work when dependency has type=zip\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using the latest rewrite (v8.47.3)\n\n## How are you running OpenRewrite?\n<!--\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\nIs your project a single module or a multi-module project?\n\nCan you share your configuration so that we can rule out any configuration issues?\n\nIs your project public? If so, can you share a link to it?\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\n-->\nI am using the Maven plugin, and my project is a single module project.\n```shell\nmvn org.openrewrite.maven:rewrite-maven-plugin:run ...\n```\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\nRun this test case, it will failed. The `RemoveDependency` should remove `org.elasticsearch.distribution.integ-test-zip:elasticsearch` but actually it did not. Only because the dependency uses `type=zip`.\n\n```java\n@Test\nvoid removeDependencyWithTypeZip() {\n    rewriteRun(\n      spec -> spec.recipe(new RemoveDependency(\"org.elasticsearch.distribution.integ-test-zip\", \"elasticsearch\", null)),\n      pomXml(\n        \"\"\"\n          <project>\n            <modelVersion>4.0.0</modelVersion>\n            \n            <groupId>com.mycompany.app</groupId>\n            <artifactId>my-app</artifactId>\n            <version>1</version>\n            \n            <dependencies>\n              <dependency>\n                <groupId>com.google.guava</groupId>\n                <artifactId>guava</artifactId>\n                <version>29.0-jre</version>\n              </dependency>\n              <dependency>\n                <groupId>org.elasticsearch.distribution.integ-test-zip</groupId>\n                <artifactId>elasticsearch</artifactId>\n                <version>7.17.15</version>\n                <type>zip</type>\n              </dependency>\n            </dependencies>\n          </project>\n          \"\"\",\n        \"\"\"\n          <project>\n            <modelVersion>4.0.0</modelVersion>\n            \n            <groupId>com.mycompany.app</groupId>\n            <artifactId>my-app</artifactId>\n            <version>1</version>\n            \n            <dependencies>\n              <dependency>\n                <groupId>com.google.guava</groupId>\n                <artifactId>guava</artifactId>\n                <version>29.0-jre</version>\n              </dependency>\n            </dependencies>\n          </project>\n          \"\"\"\n      )\n    );\n}\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\nThe `RemoveDependency` should remove `org.elasticsearch.distribution.integ-test-zip:elasticsearch` but actually it did not.\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\n\n```\njava.lang.AssertionError: Recipe was expected to make a change but made no changes.\n```\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n```\njava.lang.AssertionError: Recipe was expected to make a change but made no changes.\n\n\tat org.openrewrite.test.LargeSourceSetCheckingExpectedCycles.afterCycle(LargeSourceSetCheckingExpectedCycles.java:119)\n\tat org.openrewrite.RecipeScheduler.runRecipeCycles(RecipeScheduler.java:98)\n\tat org.openrewrite.RecipeScheduler.scheduleRun(RecipeScheduler.java:41)\n\tat org.openrewrite.Recipe.run(Recipe.java:394)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:374)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:129)\n\tat org.openrewrite.maven.RemoveDependencyTest.removeDependencyWithTypeZip(RemoveDependencyTest.java:268)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\nSure if we agree that this is a bug.\n",
    "issue_word_count": 755,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/RemoveDependencyTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/RemoveDependencyTest.java"
    ],
    "base_commit": "5bc292965dc8a149c55cbb73bd0e7d774c05d701",
    "head_commit": "55f11c66216e06922be5b99c0c68dc876fe9ecb8",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5118",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5118",
    "dockerfile": "",
    "pr_merged_at": "2025-03-03T08:34:29.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\nindex 9f43afdd1a3..057ecf49f04 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\n@@ -890,7 +890,7 @@ public List<ResolvedDependency> resolveDependencies(Scope scope, Map<GroupArtifa\n                         throw new MavenDownloadingException(\"No version provided\", null, dd.getDependency().getGav());\n                     }\n \n-                    if (d.getType() != null && (!\"jar\".equals(d.getType()) && !\"pom\".equals(d.getType()))) {\n+                    if (d.getType() != null && (!\"jar\".equals(d.getType()) && !\"pom\".equals(d.getType()) && !\"zip\".equals(d.getType()))) {\n                         continue;\n                     }\n \n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveDependencyTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveDependencyTest.java\nindex 077ad462ca9..6967b7b1932 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveDependencyTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveDependencyTest.java\n@@ -262,4 +262,54 @@ void updateModelWhenAllDependenciesRemoved() {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5117\")\n+    @Test\n+    void removeDependencyWithTypeZip() {\n+        rewriteRun(\n+          spec -> spec.recipe(new RemoveDependency(\"org.elasticsearch.distribution.integ-test-zip\", \"elasticsearch\", null)),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                \n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+                \n+                <dependencies>\n+                  <dependency>\n+                    <groupId>com.google.guava</groupId>\n+                    <artifactId>guava</artifactId>\n+                    <version>29.0-jre</version>\n+                  </dependency>\n+                  <dependency>\n+                    <groupId>org.elasticsearch.distribution.integ-test-zip</groupId>\n+                    <artifactId>elasticsearch</artifactId>\n+                    <version>7.17.15</version>\n+                    <type>zip</type>\n+                  </dependency>\n+                </dependencies>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                \n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+                \n+                <dependencies>\n+                  <dependency>\n+                    <groupId>com.google.guava</groupId>\n+                    <artifactId>guava</artifactId>\n+                    <version>29.0-jre</version>\n+                  </dependency>\n+                </dependencies>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5101",
    "pr_id": 5101,
    "issue_id": 5065,
    "repo": "openrewrite/rewrite",
    "problem_statement": "UpgradePluginVersion does not support pluginRepositories\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using \n\n- Maven/Gradle plugin v6.1.4\n\n## How are you running OpenRewrite?\n<!--\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\nIs your project a single module or a multi-module project?\n\nCan you share your configuration so that we can rule out any configuration issues?\n\nIs your project public? If so, can you share a link to it?\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\n-->\nI am using the Maven plugin, and my project is a single module project.\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>openrewrite-upgrade-plugin-demo</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>17</maven.compiler.source>\n        <maven.compiler.target>17</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>io.quarkus</groupId>\n                <artifactId>quarkus-maven-plugin</artifactId>\n                <version>3.14.0</version>\n            </plugin>\n        </plugins>\n    </build>\n\n    <!-- Works with Maven, does not work with UpgradePluginVersion -->\n    <pluginRepositories>\n        <pluginRepository>\n            <id>redhat-ga</id>\n            <url>https://maven.repository.redhat.com/ga/</url>\n        </pluginRepository>\n    </pluginRepositories>\n\n    <!-- Does not work with Maven, works with UpgradePluginVersion -->\n<!--\n    <repositories>\n        <repository>\n            <id>redhat-ga</id>\n            <url>https://maven.repository.redhat.com/ga/</url>\n        </repository>\n    </repositories>\n-->\n</project>\n```\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\n\n**rewrite.yml**\n```yml\ntype: specs.openrewrite.org/v1beta/recipe\nname: QuarkusMavenPluginUpgradeVersion\nrecipeList:\n  - org.openrewrite.maven.UpgradePluginVersion:\n      groupId: io.quarkus\n      artifactId: quarkus-maven-plugin\n      newVersion: 3.15.3.redhat-00002\n```\n```bash\nJAVA_HOME=/usr/lib/jvm/java-1.17.0-openjdk-amd64 \\\n  /opt/maven/apache-maven-3.9.9/bin/mvn \\\n      org.openrewrite.maven:rewrite-maven-plugin:6.1.4:run \\\n        -Drewrite.configLocation=rewrite.yml \\\n        -Drewrite.activeRecipes=QuarkusMavenPluginUpgradeVersion\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\n\nI expected openrewrite to be able to upgrade the plugin version when using `pluginRepositories`.\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\n\nOpenrewrite UpgradePluginVersion recipe only upgrades the plugin if the repository is defined in `repositories`. \n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\nN/A\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\nYes, but the code involved seems complex. ",
    "issue_word_count": 720,
    "test_files_count": 1,
    "non_test_files_count": 8,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/UpgradePluginVersion.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/internal/RawPluginRepositories.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/internal/RawPom.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/tree/Pom.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/tree/Profile.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/UpgradePluginVersionTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/UpgradePluginVersionTest.java"
    ],
    "base_commit": "f1761b7d4dd1f4b2d3c7cb18538cfbdf110df755",
    "head_commit": "6e7440f153a3d9e9313f1d7be65c7d94068a5b92",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5101",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5101",
    "dockerfile": "",
    "pr_merged_at": "2025-02-27T15:57:29.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\nindex 5a5b77a16f9..ad52cd5ff3c 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n@@ -389,6 +389,15 @@ public MavenMetadata downloadMetadata(String groupId, String artifactId, @Nullab\n                 .downloadMetadata(new GroupArtifact(groupId, artifactId), containingPom, getResolutionResult().getPom().getRepositories());\n     }\n \n+    public MavenMetadata downloadPluginMetadata(String groupId, String artifactId, ExecutionContext ctx) throws MavenDownloadingException {\n+        return downloadPluginMetadata(groupId, artifactId, null, ctx);\n+    }\n+\n+    public MavenMetadata downloadPluginMetadata(String groupId, String artifactId, @Nullable ResolvedPom containingPom, ExecutionContext ctx) throws MavenDownloadingException {\n+        return new MavenPomDownloader(emptyMap(), ctx, getResolutionResult().getMavenSettings(), getResolutionResult().getActiveProfiles())\n+                .downloadMetadata(new GroupArtifact(groupId, artifactId), containingPom, getResolutionResult().getPom().getPluginRepositories());\n+    }\n+\n     /**\n      * Does the current tag can contain groupId, artifactId and version?\n      */\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradePluginVersion.java b/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradePluginVersion.java\nindex 3da649d8937..4d4346bb40a 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradePluginVersion.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradePluginVersion.java\n@@ -19,7 +19,6 @@\n import lombok.Value;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n-import org.openrewrite.marker.ci.GithubActionsBuildEnvironment;\n import org.openrewrite.maven.search.FindPlugin;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n import org.openrewrite.maven.tree.MavenMetadata;\n@@ -155,7 +154,7 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n \n             private Optional<String> findNewerDependencyVersion(String groupId, String artifactId,\n                                                                 String currentVersion, ExecutionContext ctx) throws MavenDownloadingException {\n-                MavenMetadata mavenMetadata = metadataFailures.insertRows(ctx, () -> downloadMetadata(groupId, artifactId, ctx));\n+                MavenMetadata mavenMetadata = metadataFailures.insertRows(ctx, () -> downloadPluginMetadata(groupId, artifactId, ctx));\n                 Collection<String> availableVersions = new ArrayList<>();\n                 for (String v : mavenMetadata.getVersioning().getVersions()) {\n                     if (versionComparator.isValid(currentVersion, v)) {\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\nindex a81a92022cc..b76633d02cb 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\n@@ -691,7 +691,7 @@ public Pom download(GroupArtifactVersion gav,\n     private RawPom rawPomFromGav(GroupArtifactVersion gav) {\n         return new RawPom(null, null, gav.getGroupId(), gav.getArtifactId(), gav.getVersion(), null,\n                 null, null, null, \"jar\", null, null, null,\n-                null, null, null, null, null, null);\n+                null, null, null, null, null, null, null);\n     }\n \n     /**\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/RawPluginRepositories.java b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/RawPluginRepositories.java\nnew file mode 100644\nindex 00000000000..b8df4a8aaf3\n--- /dev/null\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/RawPluginRepositories.java\n@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.maven.internal;\n+\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+import lombok.*;\n+import lombok.experimental.FieldDefaults;\n+import org.jspecify.annotations.Nullable;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.emptyList;\n+\n+@FieldDefaults(level = AccessLevel.PRIVATE)\n+@Getter\n+@Setter\n+public class RawPluginRepositories {\n+    @JacksonXmlProperty(localName = \"pluginRepository\")\n+    @JacksonXmlElementWrapper(useWrapping = false)\n+    List<PluginRepository> pluginRepositories = emptyList();\n+\n+    @Value\n+    public static class PluginRepository {\n+        @Nullable\n+        String id;\n+\n+        @With\n+        String url;\n+\n+        @Nullable\n+        ArtifactPolicy releases;\n+\n+        @Nullable\n+        ArtifactPolicy snapshots;\n+    }\n+\n+    @Value\n+    public static class ArtifactPolicy {\n+\n+        @Nullable\n+        String enabled;\n+\n+        public ArtifactPolicy(@Nullable String enabled) {\n+            this.enabled = enabled;\n+        }\n+\n+        /**\n+         * Used by Jackson in the event there is an empty tag in the POM.\n+         */\n+        @SuppressWarnings(\"unused\")\n+        public ArtifactPolicy() {\n+            this(\"true\");\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/RawPom.java b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/RawPom.java\nindex 0ea795ee8ea..e0bc7ec77e4 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/RawPom.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/RawPom.java\n@@ -113,6 +113,9 @@ public class RawPom {\n     @Nullable\n     RawRepositories repositories;\n \n+    @Nullable\n+    RawPluginRepositories pluginRepositories;\n+\n     @Nullable\n     Licenses licenses;\n \n@@ -372,6 +375,9 @@ public static class Profile {\n \n         @Nullable\n         RawRepositories repositories;\n+\n+        @Nullable\n+        RawPluginRepositories pluginRepositories;\n     }\n \n     public @Nullable String getGroupId() {\n@@ -421,6 +427,7 @@ public Pom toPom(@Nullable Path inputPath, @Nullable MavenRepository repo) {\n             builder.dependencies(mapRequestedDependencies(getDependencies()))\n                     .dependencyManagement(mapDependencyManagement(getDependencyManagement()))\n                     .repositories(mapRepositories(getRepositories()))\n+                    .pluginRepositories(mapPluginRepositories(getPluginRepositories()))\n                     .plugins(mapPlugins((build != null) ? build.getPlugins() : null))\n                     .pluginManagement(mapPlugins((build != null && build.getPluginManagement() != null) ? build.getPluginManagement().getPlugins() : null));\n         }\n@@ -458,6 +465,7 @@ private List<org.openrewrite.maven.tree.Profile> mapProfiles(@Nullable Profiles\n                             mapRequestedDependencies(p.getDependencies()),\n                             mapDependencyManagement(p.getDependencyManagement()),\n                             mapRepositories(p.getRepositories()),\n+                            mapPluginRepositories(p.getPluginRepositories()),\n                             mapPlugins((build != null) ? build.getPlugins() : null),\n                             mapPlugins((build != null && build.getPluginManagement() != null) ? build.getPluginManagement().getPlugins() : null)\n                     ));\n@@ -487,6 +495,25 @@ private List<MavenRepository> mapRepositories(@Nullable RawRepositories rawRepos\n         return pomRepositories;\n     }\n \n+    @NonNull\n+    private List<MavenRepository> mapPluginRepositories(@Nullable RawPluginRepositories rawRepositories) {\n+        List<MavenRepository> pomRepositories = emptyList();\n+        if (rawRepositories != null) {\n+            List<RawPluginRepositories.PluginRepository> unmappedRepos = rawRepositories.getPluginRepositories();\n+            if (unmappedRepos != null) {\n+                pomRepositories = new ArrayList<>(unmappedRepos.size());\n+                for (RawPluginRepositories.PluginRepository r : unmappedRepos) {\n+                    pomRepositories.add(new MavenRepository(r.getId(), r.getUrl(),\n+                            r.getReleases() == null ? null : r.getReleases().getEnabled(),\n+                            r.getSnapshots() == null ? null : r.getSnapshots().getEnabled(),\n+                            false, null, null, null, null));\n+                }\n+\n+            }\n+        }\n+        return pomRepositories;\n+    }\n+\n     private List<ManagedDependency> mapDependencyManagement(@Nullable DependencyManagement rawDependencyManagement) {\n         List<ManagedDependency> dependencyManagementDependencies = emptyList();\n         if (rawDependencyManagement != null && rawDependencyManagement.getDependencies() != null) {\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Pom.java b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Pom.java\nindex ed15900cf03..eade75bd7c8 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Pom.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Pom.java\n@@ -103,6 +103,9 @@ public static int getModelVersion() {\n     @Builder.Default\n     List<MavenRepository> repositories = emptyList();\n \n+    @Builder.Default\n+    List<MavenRepository> pluginRepositories = emptyList();\n+\n     @Builder.Default\n     List<License> licenses = emptyList();\n \n@@ -206,6 +209,7 @@ public ResolvedPom resolve(Iterable<String> activeProfiles,\n                 emptyList(),\n                 concatAll(initialRepositories, getEffectiveRepositories()),\n                 repositories,\n+                pluginRepositories,\n                 dependencies,\n                 plugins,\n                 pluginManagement,\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Profile.java b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Profile.java\nindex d83565cc23f..b62c325cc66 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Profile.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Profile.java\n@@ -40,6 +40,7 @@ public class Profile {\n     List<Dependency> dependencies;\n     List<ManagedDependency> dependencyManagement;\n     List<MavenRepository> repositories;\n+    List<MavenRepository> pluginRepositories;\n \n     List<Plugin> plugins;\n     List<Plugin> pluginManagement;\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\nindex 17290e38b38..9f43afdd1a3 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\n@@ -60,6 +60,7 @@ public class ResolvedPom {\n     // https://maven.apache.org/ref/3.6.3/maven-model-builder/super-pom.html\n     private static final ResolvedPom SUPER_POM = ResolvedPom.builder()\n             .repositories(singletonList(MavenRepository.MAVEN_CENTRAL))\n+            .pluginRepositories(singletonList(MavenRepository.MAVEN_CENTRAL))\n             .build();\n \n     @With\n@@ -70,17 +71,18 @@ public class ResolvedPom {\n     Iterable<String> activeProfiles = emptyList();\n \n     public ResolvedPom(Pom requested, Iterable<String> activeProfiles) {\n-        this(requested, activeProfiles, emptyMap(), emptyList(), null, emptyList(), emptyList(), emptyList(), emptyList(), emptyList());\n+        this(requested, activeProfiles, emptyMap(), emptyList(), null, emptyList(), emptyList(), emptyList(), emptyList(), emptyList(), emptyList());\n     }\n \n     @JsonCreator\n-    ResolvedPom(Pom requested, Iterable<String> activeProfiles, Map<String, String> properties, List<ResolvedManagedDependency> dependencyManagement, @Nullable List<MavenRepository> initialRepositories, List<MavenRepository> repositories, List<Dependency> requestedDependencies, List<Plugin> plugins, List<Plugin> pluginManagement, List<String> subprojects) {\n+    ResolvedPom(Pom requested, Iterable<String> activeProfiles, Map<String, String> properties, List<ResolvedManagedDependency> dependencyManagement, @Nullable List<MavenRepository> initialRepositories, List<MavenRepository> repositories, List<MavenRepository> pluginRepositories, List<Dependency> requestedDependencies, List<Plugin> plugins, List<Plugin> pluginManagement, List<String> subprojects) {\n         this.requested = requested;\n         this.activeProfiles = activeProfiles;\n         this.properties = properties;\n         this.dependencyManagement = dependencyManagement;\n         this.initialRepositories = initialRepositories;\n         this.repositories = repositories;\n+        this.pluginRepositories = pluginRepositories;\n         this.requestedDependencies = requestedDependencies;\n         this.plugins = plugins;\n         this.pluginManagement = pluginManagement;\n@@ -103,6 +105,10 @@ public ResolvedPom(Pom requested, Iterable<String> activeProfiles) {\n     @Builder.Default\n     List<MavenRepository> repositories = emptyList();\n \n+    @NonFinal\n+    @Builder.Default\n+    List<MavenRepository> pluginRepositories = emptyList();\n+\n     @NonFinal\n     @Builder.Default\n     List<Dependency> requestedDependencies = emptyList();\n@@ -179,6 +185,7 @@ public ResolvedPom resolve(ExecutionContext ctx, MavenPomDownloader downloader)\n                 emptyList(),\n                 emptyList(),\n                 emptyList(),\n+                emptyList(),\n                 emptyList()\n         ).resolver(ctx, downloader).resolve();\n \n@@ -935,7 +942,7 @@ public List<ResolvedDependency> resolveDependencies(Scope scope, Map<GroupArtifa\n                     ResolvedPom resolvedPom = cache.getResolvedDependencyPom(dPom.getGav());\n                     if (resolvedPom == null) {\n                         resolvedPom = new ResolvedPom(dPom, getActiveProfiles(), emptyMap(),\n-                                emptyList(), initialRepositories, emptyList(), emptyList(), emptyList(), emptyList(), emptyList());\n+                                emptyList(), initialRepositories, emptyList(), emptyList(), emptyList(), emptyList(), emptyList(), emptyList());\n                         resolvedPom.resolver(ctx, downloader).resolveParentsRecursively(dPom);\n                         cache.putResolvedDependencyPom(dPom.getGav(), resolvedPom);\n                     }\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradePluginVersionTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradePluginVersionTest.java\nindex db6ca2afb11..3413ae9894e 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradePluginVersionTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradePluginVersionTest.java\n@@ -16,6 +16,7 @@\n package org.openrewrite.maven;\n \n import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n import org.openrewrite.DocumentExample;\n import org.openrewrite.Issue;\n@@ -140,6 +141,149 @@ void handlesPropertyResolution() {\n         );\n     }\n \n+    @Nested\n+    class PluginRepos {\n+\n+        @Test\n+        @Issue(\"https://github.com/openrewrite/rewrite/issues/5065\")\n+        void update() {\n+            rewriteRun(\n+              spec -> spec.recipe(new UpgradePluginVersion(\n+                \"io.quarkus\",\n+                \"quarkus-maven-plugin\",\n+                \"3.15.3.redhat-00002\",\n+                null,\n+                null,\n+                null\n+              )),\n+              pomXml(\n+                \"\"\"\n+                  <project>\n+                    <groupId>org.openrewrite.example</groupId>\n+                    <artifactId>my-app</artifactId>\n+                    <version>1</version>\n+                    <build>\n+                      <plugins>\n+                        <plugin>\n+                          <groupId>io.quarkus</groupId>\n+                          <artifactId>quarkus-maven-plugin</artifactId>\n+                          <version>3.14.0</version>\n+                         </plugin>\n+                      </plugins>\n+                    </build>\n+                    <pluginRepositories>\n+                      <pluginRepository>\n+                        <id>redhat-ga</id>\n+                        <url>https://maven.repository.redhat.com/ga/</url>\n+                      </pluginRepository>\n+                    </pluginRepositories>\n+                  </project>\n+                  \"\"\",\n+                \"\"\"\n+                  <project>\n+                    <groupId>org.openrewrite.example</groupId>\n+                    <artifactId>my-app</artifactId>\n+                    <version>1</version>\n+                    <build>\n+                      <plugins>\n+                        <plugin>\n+                          <groupId>io.quarkus</groupId>\n+                          <artifactId>quarkus-maven-plugin</artifactId>\n+                          <version>3.15.3.redhat-00002</version>\n+                         </plugin>\n+                      </plugins>\n+                    </build>\n+                    <pluginRepositories>\n+                      <pluginRepository>\n+                        <id>redhat-ga</id>\n+                        <url>https://maven.repository.redhat.com/ga/</url>\n+                      </pluginRepository>\n+                    </pluginRepositories>\n+                  </project>\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        @Issue(\"https://github.com/openrewrite/rewrite/issues/5065\")\n+        void repoUnreachable() {\n+            rewriteRun(\n+              spec -> spec.recipe(new UpgradePluginVersion(\n+                \"io.quarkus\",\n+                \"quarkus-maven-plugin\",\n+                \"3.15.3.redhat-00002\",\n+                null,\n+                null,\n+                null\n+              )),\n+              pomXml(\n+                \"\"\"\n+                  <project>\n+                    <groupId>org.openrewrite.example</groupId>\n+                    <artifactId>my-app</artifactId>\n+                    <version>1</version>\n+                    <build>\n+                      <plugins>\n+                        <plugin>\n+                          <groupId>io.quarkus</groupId>\n+                          <artifactId>quarkus-maven-plugin</artifactId>\n+                          <version>3.14.0</version>\n+                         </plugin>\n+                      </plugins>\n+                    </build>\n+                    <pluginRepositories>\n+                      <pluginRepository>\n+                        <id>unreachable</id>\n+                        <url>https://nexus.client.com/repository/maven-public</url>\n+                      </pluginRepository>\n+                    </pluginRepositories>\n+                  </project>\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        @Issue(\"https://github.com/openrewrite/rewrite/issues/5065\")\n+        void noNewerVersion() {\n+            rewriteRun(\n+              spec -> spec.recipe(new UpgradePluginVersion(\n+                \"io.quarkus\",\n+                \"quarkus-maven-plugin\",\n+                \"3.15.3.redhat-00002\",\n+                null,\n+                null,\n+                null\n+              )),\n+              pomXml(\n+                \"\"\"\n+                  <project>\n+                    <groupId>org.openrewrite.example</groupId>\n+                    <artifactId>my-app</artifactId>\n+                    <version>1</version>\n+                    <build>\n+                      <plugins>\n+                        <plugin>\n+                          <groupId>io.quarkus</groupId>\n+                          <artifactId>quarkus-maven-plugin</artifactId>\n+                          <version>3.14.0</version>\n+                         </plugin>\n+                      </plugins>\n+                    </build>\n+                    <pluginRepositories>\n+                      <pluginRepository>\n+                        <id>maven-mirror1</id>\n+                        <url>https://repo1.maven.org/maven2/</url>\n+                      </pluginRepository>\n+                    </pluginRepositories>\n+                  </project>\n+                  \"\"\"\n+              )\n+            );\n+        }\n+    }\n+\n     @Test\n     @Issue(\"Should be changed/removed when this recipe supports dynamic version resolution\")\n     void ignorePluginWithoutExplicitVersionDeclared() {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5100",
    "pr_id": 5100,
    "issue_id": 5099,
    "repo": "openrewrite/rewrite",
    "problem_statement": "IndexOutOfBoundsException parsing valid YAML whose size is equal to StreamReader's buffer size\n## What version of OpenRewrite are you using?\nOpenRewrite 8.40.3 but issue is also present in `main` as of 2025-02-26\n\n## What is the smallest, simplest way to reproduce the problem?\nThe following test fails:\n\n```java\n    @Test\n    void parseFlowSequenceAtBufferBoundary() throws IOException {\n        // May change over time in SnakeYaml, rendering this test fragile\n        var snakeYamlEffectiveStreamReaderBufferSize = 1024 - 1;\n\n        @Language(\"yml\")\n        var yaml = \"a: \" + \"x\".repeat(1000) + \"\\n\" + \"b\".repeat(16) + \": []\";\n        assertEquals(snakeYamlEffectiveStreamReaderBufferSize - 1, yaml.lastIndexOf('['));\n\n        rewriteRun(\n            spec -> spec.recipe(new DeleteKey(\".nonexistent\",\"*\")),\n            yaml(yaml)\n        );\n    }\n```\n\nThe recipe used doesn't matter, it's there just to trigger the YAML parser.\n\nThis test fails with the following exception:\n```\nFailed to parse sources or run recipe\njava.lang.AssertionError: Failed to parse sources or run recipe\n\tat org.openrewrite.test.RewriteTest.lambda$defaultExecutionContext$14(RewriteTest.java:638)\n\tat org.openrewrite.test.RewriteTest$$Lambda$509/0x0000020b8117b730.accept(Unknown Source)\n\tat org.openrewrite.yaml.YamlParser.lambda$parseInputs$0(YamlParser.java:76)\n\tat org.openrewrite.yaml.YamlParser$$Lambda$549/0x0000020b8125f340.apply(Unknown Source)\n\tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\n\tat java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179)\n\tat java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)\n\tat java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1845)\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n\tat java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n\tat java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:281)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:129)\n\tat org.openrewrite.yaml.YamlParserTest.parseFlowSequenceAtBufferBoundary(YamlParserTest.java:335)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\nCaused by: java.lang.IndexOutOfBoundsException: Index 3 out of bounds for length 3\n\tat java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:64)\n\tat java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:70)\n\tat java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:266)\n\tat java.base/java.util.Objects.checkIndex(Objects.java:361)\n\tat java.base/java.util.ArrayList.get(ArrayList.java:427)\n\tat org.openrewrite.yaml.FormatPreservingReader.readStringFromBuffer(FormatPreservingReader.java:112)\n\tat org.openrewrite.yaml.YamlParser.parseFromInput(YamlParser.java:364)\n\tat org.openrewrite.yaml.YamlParser.lambda$parseInputs$0(YamlParser.java:70)\n\t... 16 more\n\n\nIndex 3 out of bounds for length 3\njava.lang.IndexOutOfBoundsException: Index 3 out of bounds for length 3\n\tat java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:64)\n\tat java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:70)\n\tat java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:266)\n\tat java.base/java.util.Objects.checkIndex(Objects.java:361)\n\tat java.base/java.util.ArrayList.get(ArrayList.java:427)\n\tat org.openrewrite.yaml.FormatPreservingReader.readStringFromBuffer(FormatPreservingReader.java:112)\n\tat org.openrewrite.yaml.YamlParser.parseFromInput(YamlParser.java:364)\n\tat org.openrewrite.yaml.YamlParser.lambda$parseInputs$0(YamlParser.java:70)\n\tat org.openrewrite.yaml.YamlParser$$Lambda$549/0x000002389525f340.apply(Unknown Source)\n\tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\n\tat java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179)\n\tat java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)\n\tat java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1845)\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\n\tat java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n\tat java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:281)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:129)\n\tat org.openrewrite.yaml.YamlParserTest.parseFlowSequenceAtBufferBoundary(YamlParserTest.java:335)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n```\n\nWhat happens is `FormatPreservingReader.readStringFromBuffer()` assumes the end mark of an event points to a character in the buffer. However, in the case of an opening bracket in a flow-style sequence (`[`), `event.getEndMark()` points past the character. This is fine if the sequence start character is in the middle of the buffer, but if it happens to be the last character in the buffer, the reader tries to access the character behind it, causing the `IndexOutOfBoundsException`.\n\n## What did you expect to see?\nThe test should pass as the recipe should successfully parse the YAML and not modify it.\n\n## What did you see instead?\nParsing the YAML failed.\n\n## What is the full stack trace of any errors you encountered?\nSee above.\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\nYes:\n- https://github.com/openrewrite/rewrite/pull/5100\n",
    "issue_word_count": 859,
    "test_files_count": 2,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/FormatPreservingReader.java",
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/FormatPreservingReaderTest.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/FormatPreservingReaderTest.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java"
    ],
    "base_commit": "c4baa3e72c9f48bfec69782038794b99fbab4847",
    "head_commit": "325775d5db98f59cbe6f438076b27f76789c5523",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5100",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5100",
    "dockerfile": "",
    "pr_merged_at": "2025-03-03T10:19:51.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/FormatPreservingReader.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/FormatPreservingReader.java\nindex 187c914d58b..f932e7c01bc 100755\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/FormatPreservingReader.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/FormatPreservingReader.java\n@@ -104,7 +104,7 @@ public String readStringFromBuffer(int start, int end) {\n             end = indexes[end + 1] - 1;\n         }\n \n-        int length = end - start + 1;\n+        int length = Math.min(end - start + 1, buffer.size() - start + bufferIndex);\n         char[] readBuff = new char[length];\n         for (int i = 0; i < length; i++) {\n             int bufferOffset = start + i - bufferIndex;\n@@ -119,7 +119,7 @@ public int read(char[] cbuf, int off, int len) throws IOException {\n         if (read > 0) {\n             buffer.ensureCapacity(buffer.size() + read);\n             for (int i = 0; i < read; i++) {\n-                char e = cbuf[i];\n+                char e = cbuf[off + i];\n                 buffer.add(e);\n             }\n         }\n\ndiff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\nindex 1b4d0b5e28a..1a795e424ad 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n@@ -432,8 +432,13 @@ private Yaml.Documents parseFromInput(Path sourceFile, EncodingDetectingInputStr\n     If the dashes of the sequence do not have an indentation, the end mark will point to the character AFTER the dash.\n     */\n     private boolean shouldUseYamlParserBugWorkaround(SequenceStartEvent event) {\n-        int startChar = event.getStartMark().getBuffer()[event.getStartMark().getPointer()];\n-        int endChar = event.getEndMark().getBuffer()[event.getEndMark().getPointer()];\n+        int startCharIndex = event.getStartMark().getPointer();\n+        int endCharIndex = event.getEndMark().getPointer();\n+        if (endCharIndex >= event.getEndMark().getBuffer().length) {\n+            return false;\n+        }\n+        int startChar = event.getStartMark().getBuffer()[startCharIndex];\n+        int endChar = event.getEndMark().getBuffer()[endCharIndex];\n         return startChar == '-' && endChar != '-';\n     }\n \n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/FormatPreservingReaderTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/FormatPreservingReaderTest.java\nindex 43c6eb1d519..bdafd85c3f5 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/FormatPreservingReaderTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/FormatPreservingReaderTest.java\n@@ -15,9 +15,8 @@\n  */\n package org.openrewrite.yaml;\n \n-import org.junit.jupiter.api.Test;\n-\n import java.io.IOException;\n+import org.junit.jupiter.api.Test;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -25,38 +24,78 @@\n class FormatPreservingReaderTest {\n \n     @Test\n-    void allInCurrentBuffer() throws IOException {\n-        var text = \"0123456789\";\n-        var formatPreservingReader = new FormatPreservingReader(text);\n+    void readWithOffset() throws IOException {\n+        try (FormatPreservingReader formatPreservingReader = new FormatPreservingReader(\"0123456789\")) {\n+            char[] charArray = new char[10];\n+            formatPreservingReader.read(charArray, 3, 5);\n+            assertThat(formatPreservingReader.prefix(0, 5)).isEqualTo(\"01234\");\n+        }\n+    }\n \n-        char[] charArray = new char[10];\n-        formatPreservingReader.read(charArray, 0, 10);\n-        assertThat(formatPreservingReader.prefix(0, 3)).isEqualTo(\"012\");\n+    @Test\n+    void allInCurrentBuffer() throws IOException {\n+        try (FormatPreservingReader formatPreservingReader = new FormatPreservingReader(\"0123456789\")) {\n+            char[] charArray = new char[10];\n+            formatPreservingReader.read(charArray, 0, 10);\n+            assertThat(formatPreservingReader.prefix(0, 3)).isEqualTo(\"012\");\n+        }\n     }\n \n     @Test\n-    void allInPreviousBuffer() throws IOException {\n-        var text = \"0123456789\";\n-        var formatPreservingReader = new FormatPreservingReader(text);\n+    void stringAllInCurrentBuffer() throws IOException {\n+        try (FormatPreservingReader formatPreservingReader = new FormatPreservingReader(\"0123456789\")) {\n+            char[] charArray = new char[10];\n+            formatPreservingReader.read(charArray, 0, 10);\n+            assertThat(formatPreservingReader.readStringFromBuffer(0, 3)).isEqualTo(\"0123\");\n+        }\n+    }\n \n-        char[] charArray = new char[10];\n+    @Test\n+    void stringAtEndOfCurrentBuffer() throws IOException {\n+        try (FormatPreservingReader formatPreservingReader = new FormatPreservingReader(\"0123456789\")) {\n+            char[] charArray = new char[10];\n+            formatPreservingReader.read(charArray, 0, 10);\n+            assertThat(formatPreservingReader.readStringFromBuffer(8, 10)).isEqualTo(\"89\");\n+        }\n+    }\n \n-        formatPreservingReader.read(charArray, 0, 5);\n-        formatPreservingReader.read(charArray, 0, 5);\n+    @Test\n+    void allInPreviousBuffer() throws IOException {\n+        try (FormatPreservingReader formatPreservingReader = new FormatPreservingReader(\"0123456789\")) {\n+            char[] charArray = new char[10];\n+            formatPreservingReader.read(charArray, 0, 5);\n+            formatPreservingReader.read(charArray, 0, 5);\n+            assertThat(formatPreservingReader.prefix(0, 3)).isEqualTo(\"012\");\n+        }\n+    }\n \n-        assertThat(formatPreservingReader.prefix(0, 3)).isEqualTo(\"012\");\n+    @Test\n+    void stringAllInPreviousBuffer() throws IOException {\n+        try (FormatPreservingReader formatPreservingReader = new FormatPreservingReader(\"0123456789\")) {\n+            char[] charArray = new char[10];\n+            formatPreservingReader.read(charArray, 0, 5);\n+            formatPreservingReader.read(charArray, 0, 5);\n+            assertThat(formatPreservingReader.readStringFromBuffer(0, 3)).isEqualTo(\"0123\");\n+        }\n     }\n \n     @Test\n     void splitBetweenPrevAndCurrentBuffer() throws IOException {\n-        var text = \"0123456789\";\n-        var formatPreservingReader = new FormatPreservingReader(text);\n-\n-        char[] charArray = new char[10];\n-\n-        formatPreservingReader.read(charArray, 0, 1);\n-        formatPreservingReader.read(charArray, 0, 9);\n+        try (FormatPreservingReader formatPreservingReader = new FormatPreservingReader(\"0123456789\")) {\n+            char[] charArray = new char[10];\n+            formatPreservingReader.read(charArray, 0, 1);\n+            formatPreservingReader.read(charArray, 0, 9);\n+            assertThat(formatPreservingReader.prefix(0, 3)).isEqualTo(\"012\");\n+        }\n+    }\n \n-        assertThat(formatPreservingReader.prefix(0, 3)).isEqualTo(\"012\");\n+    @Test\n+    void stringSplitBetweenPrevAndCurrentBuffer() throws IOException {\n+        try (FormatPreservingReader formatPreservingReader = new FormatPreservingReader(\"0123456789\")) {\n+            char[] charArray = new char[10];\n+            formatPreservingReader.read(charArray, 0, 1);\n+            formatPreservingReader.read(charArray, 0, 9);\n+            assertThat(formatPreservingReader.readStringFromBuffer(0, 3)).isEqualTo(\"0123\");\n+        }\n     }\n }\n\ndiff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\nindex 9bae6befb41..badb146c095 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\n@@ -15,6 +15,8 @@\n  */\n package org.openrewrite.yaml;\n \n+import java.util.List;\n+import java.util.stream.Stream;\n import org.intellij.lang.annotations.Language;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n@@ -25,11 +27,7 @@\n import org.openrewrite.tree.ParseError;\n import org.openrewrite.yaml.tree.Yaml;\n \n-import java.util.List;\n-import java.util.stream.Stream;\n-\n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.within;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.openrewrite.yaml.Assertions.yaml;\n \n@@ -323,4 +321,22 @@ void parseTagInMapping() {\n         assertEquals(\"map\", withinPerson.getTag().getName());\n         assertEquals(Yaml.Tag.Kind.IMPLICIT_GLOBAL, withinPerson.getTag().getKind());\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5099\")\n+    @Test\n+    void parseFlowSequenceAtBufferBoundary() {\n+        // May change over time in SnakeYaml, rendering this test fragile\n+        var snakeYamlEffectiveStreamReaderBufferSize = 1024 - 1;\n+\n+        @Language(\"yml\")\n+        var yaml = \"a: \" + \"x\".repeat(1000) + \"\\n\" + \"b\".repeat(16) + \": []\";\n+        assertEquals(snakeYamlEffectiveStreamReaderBufferSize - 1, yaml.lastIndexOf('['));\n+\n+        rewriteRun(\n+          // Could be whatever recipe, it just proves the `IndexOutOfBoundsException` is not thrown,\n+          // thus proving the parser can handle a flow-style sequence ending at the boundary of the internal buffer used by SnakeYaml StreamReader.\n+          spec -> spec.recipe(new DeleteKey(\".nonexistent\",\"*\")),\n+          yaml(yaml)\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5086",
    "pr_id": 5086,
    "issue_id": 5085,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Regression in `MavenPomDownloader` from 8.42.0\nConsider this unit test:\n\n(The test merely attempts to resolve dependencies and check if compile scope has proper number of dependencies)\n\n```java\n    @Test\n    void resolveDependencies() throws MavenDownloadingExceptions {\n        Xml.Document doc = (Xml.Document) MavenParser.builder().build().parse(\"\"\"\n                  <project>\n                      <parent>\n                          <groupId>org.springframework.boot</groupId>\n                          <artifactId>spring-boot-starter-parent</artifactId>\n                          <version>3.2.0</version>\n                          <relativePath/>\n                      </parent>\n                      <groupId>com.example</groupId>\n                      <artifactId>demo</artifactId>\n                      <version>0.0.1-SNAPSHOT</version>\n                      <name>demo</name>\n                      <dependencies>\n                          <dependency>\n                              <groupId>org.springframework.boot</groupId>\n                              <artifactId>spring-boot-starter-web</artifactId>\n                          </dependency>\n                      </dependencies>\n                  </project>\n        \"\"\").toList().get(0);\n        MavenResolutionResult resolutionResult = doc.getMarkers().findFirst(MavenResolutionResult.class).orElseThrow();\n        resolutionResult = resolutionResult.resolveDependencies(new MavenPomDownloader(Collections.emptyMap(), new InMemoryExecutionContext(), null, null), new InMemoryExecutionContext());\n        List<ResolvedDependency> deps = resolutionResult.getDependencies().get(Scope.Compile);\n        assertThat(deps).hasSize(34);\n    }\n\n```\n\nWith version 8.42.0 and above the number of dependencies is 0. It is 0 because of this (change)[https://github.com/openrewrite/rewrite/pull/4738/files#diff-80e53987f9ebb9e28874fed7053378def4769cef75b303770ccc8ee085fac098]\n\nWhat happens is that for local maven repo if the JAR is around we wouldn't attempt to download the POM using another maven repo. I'm not sure how to correct this yet... probably if we've tried all repos and find a JAR for one of them then we can probably return the artificial POM based on the GAV only...",
    "issue_word_count": 223,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java"
    ],
    "base_commit": "13f3fe333009b63e9bca3016e131f5853635238e",
    "head_commit": "e9c846681c31b986811b2fd7fba200ebe7798ba6",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5086",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5086",
    "dockerfile": "",
    "pr_merged_at": "2025-02-25T00:21:23.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\nindex 58fba38ac2f..a81a92022cc 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\n@@ -539,6 +539,11 @@ public Pom download(GroupArtifactVersion gav,\n         GroupArtifactVersion originalGav = gav;\n         gav = handleSnapshotTimestampVersion(gav);\n         List<String> uris = new ArrayList<>();\n+\n+        // Keep the repo and resolved GAV of the found JAR to avoid throwing if JAR is found\n+        MavenRepository foundJarInRepo = null;\n+        ResolvedGroupArtifactVersion foundResolvedGav = null;\n+\n         for (MavenRepository repo : normalizedRepos) {\n             ctx.getResolutionListener().repository(repo, containingPom);\n             //noinspection DataFlowIssue\n@@ -563,81 +568,89 @@ public Pom download(GroupArtifactVersion gav,\n                     try {\n                         File pomFile = new File(uri);\n                         File jarFile = pomFile.toPath().resolveSibling(gav.getArtifactId() + '-' + versionMaybeDatedSnapshot + \".jar\").toFile();\n-\n+                        boolean jarFileExists = jarFile.exists();\n+                        boolean pomFileExists = pomFile.exists();\n                         //NOTE:\n                         // - The pom may exist without a .jar artifact if the pom packaging is \"pom\"\n                         // - The jar may exist without a pom, if manually installed\n-                        if (!pomFile.exists() && !jarFile.exists()) {\n+                        if (!pomFileExists && !jarFileExists) {\n                             continue;\n                         }\n \n-                        RawPom rawPom;\n-                        if (pomFile.exists()) {\n+                        // If non-empty JAR found in local repo keep the repo and resolved GAV\n+                        if (foundJarInRepo == null && jarFile.length() > 0) {\n+                            foundJarInRepo = repo;\n+                            foundResolvedGav = resolvedGav;\n+                        }\n+\n+                        if (pomFileExists) {\n                             try (FileInputStream fis = new FileInputStream(pomFile)) {\n-                                rawPom = RawPom.parse(fis, Objects.equals(versionMaybeDatedSnapshot, gav.getVersion()) ? null : versionMaybeDatedSnapshot);\n+                                RawPom rawPom = RawPom.parse(fis, Objects.equals(versionMaybeDatedSnapshot, gav.getVersion()) ? null : versionMaybeDatedSnapshot);\n+                                Pom pom = rawPom.toPom(inputPath, repo).withGav(resolvedGav);\n+\n+                                if (pom.getPackaging() == null || pom.hasJarPackaging()) {\n+                                    if (!jarFileExists || jarFile.length() == 0) {\n+                                        // The jar has not been downloaded, making this dependency unusable.\n+                                        continue;\n+                                    }\n+                                }\n+\n+                                if (repo.getUri().equals(MavenRepository.MAVEN_LOCAL_DEFAULT.getUri())) {\n+                                    // so that the repository path is the same regardless of username\n+                                    pom = pom.withRepository(MavenRepository.MAVEN_LOCAL_USER_NEUTRAL);\n+                                }\n+\n+                                if (!Objects.equals(versionMaybeDatedSnapshot, pom.getVersion())) {\n+                                    pom = pom.withGav(pom.getGav().withDatedSnapshotVersion(versionMaybeDatedSnapshot));\n+                                }\n+                                mavenCache.putPom(resolvedGav, pom);\n+                                ctx.getResolutionListener().downloadSuccess(resolvedGav, containingPom);\n+                                sample.stop(timer.tags(\"outcome\", \"from maven local\").register(Metrics.globalRegistry));\n+                                return pom;\n                             }\n                         } else {\n                             // Record the absense of the pom file\n                             ctx.getResolutionListener().downloadError(gav, uris, (containingPom == null) ? null : containingPom.getRequested());\n-                            // infer rawPom from jar\n-                            rawPom = rawPomFromGav(gav);\n-                        }\n-\n-                        Pom pom = rawPom.toPom(inputPath, repo).withGav(resolvedGav);\n-\n-                        if (pom.getPackaging() == null || pom.hasJarPackaging()) {\n-                            if (!jarFile.exists() || jarFile.length() == 0) {\n-                                // The jar has not been downloaded, making this dependency unusable.\n-                                continue;\n-                            }\n-                        }\n-\n-                        if (repo.getUri().equals(MavenRepository.MAVEN_LOCAL_DEFAULT.getUri())) {\n-                            // so that the repository path is the same regardless of username\n-                            pom = pom.withRepository(MavenRepository.MAVEN_LOCAL_USER_NEUTRAL);\n-                        }\n-\n-                        if (!Objects.equals(versionMaybeDatedSnapshot, pom.getVersion())) {\n-                            pom = pom.withGav(pom.getGav().withDatedSnapshotVersion(versionMaybeDatedSnapshot));\n                         }\n-                        mavenCache.putPom(resolvedGav, pom);\n-                        ctx.getResolutionListener().downloadSuccess(resolvedGav, containingPom);\n-                        sample.stop(timer.tags(\"outcome\", \"from maven local\").register(Metrics.globalRegistry));\n-                        return pom;\n                     } catch (IOException e) {\n                         // unable to read the pom from a file-based repository.\n                         repositoryResponses.put(repo, e.getMessage());\n                     }\n                 } else {\n                     try {\n-                        RawPom rawPom;\n                         try {\n                             byte[] responseBody = requestAsAuthenticatedOrAnonymous(repo, uri.toString());\n-                            rawPom = RawPom.parse(\n+\n+                            Path inputPath = Paths.get(gav.getGroupId(), gav.getArtifactId(), gav.getVersion());\n+                            RawPom rawPom = RawPom.parse(\n                                     new ByteArrayInputStream(responseBody),\n                                     Objects.equals(versionMaybeDatedSnapshot, gav.getVersion()) ? null : versionMaybeDatedSnapshot\n                             );\n+                            Pom pom = rawPom.toPom(inputPath, repo).withGav(resolvedGav);\n+                            if (!Objects.equals(versionMaybeDatedSnapshot, pom.getVersion())) {\n+                                pom = pom.withGav(pom.getGav().withDatedSnapshotVersion(versionMaybeDatedSnapshot));\n+                            }\n+                            mavenCache.putPom(resolvedGav, pom);\n+                            ctx.getResolutionListener().downloadSuccess(resolvedGav, containingPom);\n+                            sample.stop(timer.tags(\"outcome\", \"downloaded\").register(Metrics.globalRegistry));\n+                            return pom;\n                         } catch (HttpSenderResponseException e) {\n                             repositoryResponses.put(repo, e.getMessage());\n                             // When `pom` is not found, try to see if `jar` exists for the same GAV\n                             if (!e.isClientSideException() || !jarExistsForPomUri(repo, uri.toString())) {\n                                 throw e;\n                             }\n+\n+                            // JAR has been found but not the POM. Keep the repo and GAV if not already kept\n+                            if (foundJarInRepo == null) {\n+                                foundJarInRepo = repo;\n+                                foundResolvedGav = resolvedGav;\n+                            }\n+\n                             // Record the absense of the pom file\n                             ctx.getResolutionListener().downloadError(gav, uris, (containingPom == null) ? null : containingPom.getRequested());\n \n-                            // Continue with a recreated pom\n-                            rawPom = rawPomFromGav(gav);\n                         }\n-                        Path inputPath = Paths.get(gav.getGroupId(), gav.getArtifactId(), gav.getVersion());\n-                        Pom pom = rawPom.toPom(inputPath, repo).withGav(resolvedGav);\n-                        if (!Objects.equals(versionMaybeDatedSnapshot, pom.getVersion())) {\n-                            pom = pom.withGav(pom.getGav().withDatedSnapshotVersion(versionMaybeDatedSnapshot));\n-                        }\n-                        mavenCache.putPom(resolvedGav, pom);\n-                        ctx.getResolutionListener().downloadSuccess(resolvedGav, containingPom);\n-                        sample.stop(timer.tags(\"outcome\", \"downloaded\").register(Metrics.globalRegistry));\n-                        return pom;\n                     } catch (HttpSenderResponseException e) {\n                         repositoryResponses.put(repo, e.getMessage());\n                         if (e.isClientSideException()) {\n@@ -655,10 +668,24 @@ public Pom download(GroupArtifactVersion gav,\n                 repositoryResponses.put(repo, \"Did not attempt to download because of a previous failure to retrieve from this repository.\");\n             }\n         }\n-        ctx.getResolutionListener().downloadError(gav, uris, (containingPom == null) ? null : containingPom.getRequested());\n-        sample.stop(timer.tags(\"outcome\", \"unavailable\").register(Metrics.globalRegistry));\n-        throw new MavenDownloadingException(\"Unable to download POM: \" + gav + '.', null, originalGav)\n-                .setRepositoryResponses(repositoryResponses);\n+        if (foundJarInRepo != null && foundResolvedGav != null) {\n+            // IF JAR has been found return the artificially created POM not to throw exception\n+            RawPom rawPom = rawPomFromGav(gav);\n+            Path inputPath = Paths.get(gav.getGroupId(), gav.getArtifactId(), gav.getVersion());\n+            Pom pom = rawPom.toPom(inputPath, foundJarInRepo).withGav(foundResolvedGav);\n+            if (!Objects.equals(versionMaybeDatedSnapshot, pom.getVersion())) {\n+                pom = pom.withGav(pom.getGav().withDatedSnapshotVersion(versionMaybeDatedSnapshot));\n+            }\n+            mavenCache.putPom(foundResolvedGav, pom);\n+            ctx.getResolutionListener().downloadSuccess(foundResolvedGav, containingPom);\n+            sample.stop(timer.tags(\"outcome\", \"downloaded\").register(Metrics.globalRegistry));\n+            return pom;\n+        } else {\n+            ctx.getResolutionListener().downloadError(gav, uris, (containingPom == null) ? null : containingPom.getRequested());\n+            sample.stop(timer.tags(\"outcome\", \"unavailable\").register(Metrics.globalRegistry));\n+            throw new MavenDownloadingException(\"Unable to download POM: \" + gav + '.', null, originalGav)\n+                    .setRepositoryResponses(repositoryResponses);\n+        }\n     }\n \n     private RawPom rawPomFromGav(GroupArtifactVersion gav) {\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java\nindex cb54ddd3291..82dffcb995c 100755\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java\n@@ -33,13 +33,11 @@\n import org.openrewrite.*;\n import org.openrewrite.ipc.http.HttpSender;\n import org.openrewrite.ipc.http.HttpUrlConnectionSender;\n-import org.openrewrite.maven.MavenDownloadingException;\n-import org.openrewrite.maven.MavenExecutionContextView;\n-import org.openrewrite.maven.MavenParser;\n-import org.openrewrite.maven.MavenSettings;\n+import org.openrewrite.maven.*;\n import org.openrewrite.maven.http.OkHttpSender;\n import org.openrewrite.maven.tree.*;\n import org.openrewrite.test.RewriteTest;\n+import org.openrewrite.xml.tree.Xml;\n \n import javax.net.ssl.SSLSocketFactory;\n import java.io.IOException;\n@@ -1298,4 +1296,34 @@ public MockResponse dispatch(RecordedRequest recordedRequest) {\n             }\n         }\n     }\n+\n+    @Test\n+    void resolveDependencies() throws MavenDownloadingExceptions {\n+        Xml.Document doc = (Xml.Document) MavenParser.builder().build().parse(\"\"\"\n+                  <project>\n+                      <parent>\n+                          <groupId>org.springframework.boot</groupId>\n+                          <artifactId>spring-boot-starter-parent</artifactId>\n+                          <version>3.2.0</version>\n+                          <relativePath/>\n+                      </parent>\n+                      <groupId>com.example</groupId>\n+                      <artifactId>demo</artifactId>\n+                      <version>0.0.1-SNAPSHOT</version>\n+                      <name>demo</name>\n+                      <dependencies>\n+                          <dependency>\n+                              <groupId>org.springframework.boot</groupId>\n+                              <artifactId>spring-boot-starter-web</artifactId>\n+                          </dependency>\n+                      </dependencies>\n+                  </project>\n+        \"\"\").toList().get(0);\n+        MavenResolutionResult resolutionResult = doc.getMarkers().findFirst(MavenResolutionResult.class).orElseThrow();\n+        resolutionResult = resolutionResult.resolveDependencies(new MavenPomDownloader(Collections.emptyMap(), new InMemoryExecutionContext(), null, null), new InMemoryExecutionContext());\n+        List<ResolvedDependency> deps = resolutionResult.getDependencies().get(Scope.Compile);\n+        assertThat(deps).hasSize(34);\n+    }\n+\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5037",
    "pr_id": 5037,
    "issue_id": 5031,
    "repo": "openrewrite/rewrite",
    "problem_statement": "[YAML] Keys wrongly appended to previous comment\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using\n\n- OpenRewrite v8.45.1\n\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\n```java\n@Test\n    void keysAppendedToPreviousComment() {\n        rewriteRun(spec -> spec\n            .recipe(new MergeYaml(//language=jsonpath\n              \"$\",\n              // language=yaml\n              \"\"\"\n                foo:\n                  new-key: new-value\n                \"\"\",\n              false,\n              null,\n              null,\n              null\n            )),\n\n          yaml(// language=yaml\n            \"\"\"\n              foo:\n                existing-key: existing-value\n              # A simple comment\n              bar: bar-value\n              \"\"\",\n            // language=yaml\n            \"\"\"\n              foo:\n                existing-key: existing-value\n                new-key: new-value\n              # A simple comment\n              bar: bar-value\n              \"\"\"\n          )\n        );\n    }\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\n```yaml\nfoo:\n  existing-key: existing-value\n  new-key: new-value\n# A simple comment\nbar: bar-value\n```\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\n```yml\nfoo:\n    existing-key: existing-value\n    new-key: new-value\n  # A simple commentbar: bar-value\n```\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n``` diff\norg.opentest4j.AssertionFailedError: [Unexpected result in \"file.yaml\":\ndiff --git a/file.yaml b/file.yaml\nindex 3306f5f..39d8232 100644\n--- a/file.yaml\n+++ b/file.yaml\n@@ -1,5 +1,4 @@ \n foo:\n   existing-key: existing-value\n   new-key: new-value\n-# A simple comment\n-bar: bar-value\n\\ No newline at end of file\n+# A simple commentbar: bar-value\n\\ No newline at end of file\n] \nexpected: \n  \"foo:\n    existing-key: existing-value\n    new-key: new-value\n  # A simple comment\n  bar: bar-value\"\n but was: \n  \"foo:\n    existing-key: existing-value\n    new-key: new-value\n  # A simple commentbar: bar-value\"\n\tat org.openrewrite.test.RewriteTest.assertContentEquals(RewriteTest.java:618)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:507)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:129)\n\tat org.openrewrite.yaml.MergeYamlTest.keysAppendedToPreviousComment(MergeYamlTest.java:1974)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:569)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\n",
    "issue_word_count": 610,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "base_commit": "9c6fa9830c20b59a2ae9fefd913fa837588ea81c",
    "head_commit": "3261dc9d828b2784eec5d8c55b8d98f02f102ea2",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5037",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5037",
    "dockerfile": "",
    "pr_merged_at": "2025-02-19T15:09:31.000Z",
    "patch": "",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\nindex 5139f29027c..2c0c455bf5a 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n@@ -2738,4 +2738,86 @@ void insertAfterMergeSequenceMapAddAdditionalObject() {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5031\")\n+    void preventKeysToBeAppendedToPreviousComment() {\n+        rewriteRun(spec -> spec\n+            .recipe(new MergeYaml(//language=jsonpath\n+              \"$\",\n+              // language=yaml\n+              \"\"\"\n+                foo:\n+                  new-key: new-value\n+                \"\"\",\n+              false,\n+              null,\n+              null,\n+              null\n+            )),\n+\n+          yaml(// language=yaml\n+            \"\"\"\n+              #\n+              foo:\n+                existing-key: existing-value\n+              # A simple comment\n+              bar: bar-value\n+              \"\"\",\n+            // language=yaml\n+            \"\"\"\n+              #\n+              foo:\n+                existing-key: existing-value\n+                new-key: new-value\n+              # A simple comment\n+              bar: bar-value\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/5031\")\n+    void preventKeysToBeAppendedToPreviousCommentIfManyLineBreaks() {\n+        rewriteRun(spec -> spec\n+            .recipe(new MergeYaml(//language=jsonpath\n+              \"$\",\n+              // language=yaml\n+              \"\"\"\n+                foo:\n+                  new-key: new-value\n+                \"\"\",\n+              false,\n+              null,\n+              null,\n+              null\n+            )),\n+\n+          yaml(// language=yaml\n+            \"\"\"\n+              #\n+              foo:\n+                existing-key: existing-value\n+              # A simple comment with trailing line breaks\n+              \n+              \n+              \n+              bar: bar-value\n+              \"\"\",\n+            // language=yaml\n+            \"\"\"\n+              #\n+              foo:\n+                existing-key: existing-value\n+                new-key: new-value\n+              # A simple comment with trailing line breaks\n+              \n+              \n+              \n+              bar: bar-value\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5014",
    "pr_id": 5014,
    "issue_id": 4993,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Failure to write out type table for nested types in `hibernate-core:6.5.1.Final`\n## What version of OpenRewrite are you using?\nI am using\n\n- OpenRewrite 8.45.0-SNAPSHOT\n\n## How are you running OpenRewrite?\nI'm running `./gradlew createTypeTable` against [openrewrite/rewrite-hibernate](https://github.com/openrewrite/rewrite-hibernate/blob/d2bc02a1e14f8eb5a96943450fca9d03334c6d65/build.gradle.kts#L9-L12) through a locally installed version of this build plugin\n- https://github.com/openrewrite/rewrite-build-gradle-plugin/pull/75\n\n## What is the smallest, simplest way to reproduce the problem?\n1. Checkout this branch https://github.com/openrewrite/rewrite-build-gradle-plugin/pull/75\n2. Run `./gradlew pTML` on said branch\n3. Checkout openrewrite/rewrite-hibernate\n4. Change settings.gradle.kts to add\n```kotlin\npluginManagement {\n    repositories {\n        mavenLocal()\n        gradlePluginPortal()\n    }\n}\n```\n5. Change `build.gradle.kts` to use `recipe-library` version `latest.integration`\n6. Run `./gradlew createTypeTable`\n7. Delete `src/main/resources/META-INF/rewrite/classpath`\n8. Run the unit tests\n\n## What did you expect to see?\nA successfully created type table used to pass the unit tests.\n\n## What did you see instead?\nA failure to run the unit tests\n\n## What is the full stack trace of any errors you encountered?\n```\njava.lang.IllegalArgumentException: Invalid access flags: 32\n\n\tat org.objectweb.asm.util.CheckClassAdapter.checkAccess(CheckClassAdapter.java:542)\n\tat org.objectweb.asm.util.CheckClassAdapter.visitInnerClass(CheckClassAdapter.java:363)\n\tat org.openrewrite.java.internal.parser.TypeTable$Reader.lambda$writeClassesDir$3(TypeTable.java:207)\n\tat java.base/java.util.HashMap.forEach(HashMap.java:1421)\n\tat org.openrewrite.java.internal.parser.TypeTable$Reader.writeClassesDir(TypeTable.java:180)\n\tat org.openrewrite.java.internal.parser.TypeTable$Reader.read(TypeTable.java:169)\n\tat org.openrewrite.java.internal.parser.TypeTable.<init>(TypeTable.java:97)\n\tat org.openrewrite.java.internal.parser.TypeTable.fromClasspath(TypeTable.java:89)\n\tat org.openrewrite.java.JavaParser.dependenciesFromResources(JavaParser.java:130)\n\tat org.openrewrite.java.JavaParser$Builder.classpathFromResources(JavaParser.java:331)\n\tat org.openrewrite.hibernate.MigrateUserTypeTest.defaults(MigrateUserTypeTest.java:33)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:137)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:129)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:124)\n\tat org.openrewrite.hibernate.MigrateUserTypeTest.shouldMigrateUserType(MigrateUserTypeTest.java:41)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:569)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n```\nWhen attempting to write out these values with ASM.\n![Image](https://github.com/user-attachments/assets/a593675b-efc6-4b93-a4ad-bfb924793469)",
    "issue_word_count": 408,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java/src/main/java/org/openrewrite/java/internal/parser/TypeTable.java",
      "rewrite-java/src/test/java/org/openrewrite/java/internal/parser/TypeTableTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java/src/test/java/org/openrewrite/java/internal/parser/TypeTableTest.java"
    ],
    "base_commit": "41ebc407303661cc28a45b76b0da0c3ae8d0ea0a",
    "head_commit": "d4216624bf5fca9c9148dccdf37e74489d11c78c",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5014",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5014",
    "dockerfile": "",
    "pr_merged_at": "2025-02-12T21:33:28.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/internal/parser/TypeTable.java b/rewrite-java/src/main/java/org/openrewrite/java/internal/parser/TypeTable.java\nindex 1c507db69cc..8321c5a8cf7 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/internal/parser/TypeTable.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/internal/parser/TypeTable.java\n@@ -146,23 +146,25 @@ public void read(InputStream is, Collection<String> artifactNames) throws IOExce\n                     }\n \n                     if (gav != null) {\n-                        Member member = new Member(\n-                                new ClassDefinition(\n-                                        Integer.parseInt(fields[3]),\n-                                        fields[4],\n-                                        fields[5].isEmpty() ? null : fields[5],\n-                                        fields[6].isEmpty() ? null : fields[6],\n-                                        fields[7].isEmpty() ? null : fields[7].split(\"\\\\|\")\n-                                ),\n-                                Integer.parseInt(fields[8]),\n-                                fields[9],\n-                                fields[10],\n-                                fields[11].isEmpty() ? null : fields[11],\n-                                fields[12].isEmpty() ? null : fields[12].split(\"\\\\|\")\n+                        ClassDefinition classDefinition = new ClassDefinition(\n+                                Integer.parseInt(fields[3]),\n+                                fields[4],\n+                                fields[5].isEmpty() ? null : fields[5],\n+                                fields[6].isEmpty() ? null : fields[6],\n+                                fields[7].isEmpty() ? null : fields[7].split(\"\\\\|\")\n                         );\n-                        membersByClassName\n-                                .computeIfAbsent(member.getClassDefinition(), cd -> new ArrayList<>())\n-                                .add(member);\n+                        List<Member> classMembers = membersByClassName.computeIfAbsent(classDefinition, cd -> new ArrayList<>());\n+                        int memberAccess = Integer.parseInt(fields[8]);\n+                        if (memberAccess != -1) {\n+                            classMembers.add(new Member(\n+                                    classDefinition,\n+                                    memberAccess,\n+                                    fields[9],\n+                                    fields[10],\n+                                    fields[11].isEmpty() ? null : fields[11],\n+                                    fields[12].isEmpty() ? null : fields[12].split(\"\\\\|\")\n+                            ));\n+                        }\n                     }\n                 });\n             }\n@@ -321,23 +323,31 @@ public void write(Path jar) {\n                                 new ClassReader(inputStream).accept(new ClassVisitor(Opcodes.ASM9) {\n                                     @Nullable\n                                     ClassDefinition classDefinition;\n+                                    boolean wroteFieldOrMethod;\n \n                                     @Override\n                                     public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-                                        classDefinition = classDefinition(access, name, signature, superName, interfaces);\n+                                        classDefinition = new ClassDefinition(Jar.this, access, name, signature, superName, interfaces);\n+                                        wroteFieldOrMethod = false;\n                                         super.visit(version, access, name, signature, superName, interfaces);\n+                                        if (!wroteFieldOrMethod && !\"module-info\".equals(name)) {\n+                                            // No fields or methods, which can happen for marker annotations for example\n+                                            classDefinition.writeClass();\n+                                        }\n                                     }\n \n                                     @Override\n                                     public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n-                                        requireNonNull(classDefinition).writeField(access, name, descriptor, signature);\n+                                        wroteFieldOrMethod |= requireNonNull(classDefinition)\n+                                                .writeField(access, name, descriptor, signature);\n                                         return super.visitField(access, name, descriptor, signature, value);\n                                     }\n \n                                     @Override\n                                     public MethodVisitor visitMethod(int access, String name, String descriptor,\n                                                                      String signature, String[] exceptions) {\n-                                        requireNonNull(classDefinition).writeMethod(access, name, descriptor, signature, null, exceptions);\n+                                        wroteFieldOrMethod |= requireNonNull(classDefinition)\n+                                                .writeMethod(access, name, descriptor, signature, null, exceptions);\n                                         return super.visitMethod(access, name, descriptor, signature, exceptions);\n                                     }\n                                 }, SKIP_CODE);\n@@ -348,11 +358,6 @@ public MethodVisitor visitMethod(int access, String name, String descriptor,\n                     throw new UncheckedIOException(e);\n                 }\n             }\n-\n-            public ClassDefinition classDefinition(int access, String name, @Nullable String signature,\n-                                                   String superclassName, String @Nullable [] superinterfaceSignatures) {\n-                return new ClassDefinition(this, access, name, signature, superclassName, superinterfaceSignatures);\n-            }\n         }\n \n         @Value\n@@ -367,10 +372,23 @@ public class ClassDefinition {\n             String classSuperclassName;\n             String @Nullable [] classSuperinterfaceSignatures;\n \n-            public void writeMethod(int access, String name, String descriptor,\n-                                    @Nullable String signature,\n-                                    String @Nullable [] parameterNames,\n-                                    String @Nullable [] exceptions) {\n+            public void writeClass() {\n+                if (((Opcodes.ACC_PRIVATE | Opcodes.ACC_SYNTHETIC) & classAccess) == 0) {\n+                    out.printf(\n+                            \"%s\\t%s\\t%s\\t%d\\t%s\\t%s\\t%s\\t%s\\t%d\\t%s\\t%s\\t%s\\t%s\\t%s%n\",\n+                            jar.groupId, jar.artifactId, jar.version,\n+                            classAccess, className,\n+                            classSignature == null ? \"\" : classSignature,\n+                            classSuperclassName,\n+                            classSuperinterfaceSignatures == null ? \"\" : String.join(\"|\", classSuperinterfaceSignatures),\n+                            -1, null, null, null, null, null);\n+                }\n+            }\n+\n+            public boolean writeMethod(int access, String name, String descriptor,\n+                                       @Nullable String signature,\n+                                       String @Nullable [] parameterNames,\n+                                       String @Nullable [] exceptions) {\n                 if (((Opcodes.ACC_PRIVATE | Opcodes.ACC_SYNTHETIC) & access) == 0) {\n                     out.printf(\n                             \"%s\\t%s\\t%s\\t%d\\t%s\\t%s\\t%s\\t%s\\t%d\\t%s\\t%s\\t%s\\t%s\\t%s%n\",\n@@ -384,15 +402,14 @@ public void writeMethod(int access, String name, String descriptor,\n                             parameterNames == null ? \"\" : String.join(\"|\", parameterNames),\n                             exceptions == null ? \"\" : String.join(\"|\", exceptions)\n                     );\n+                    return true;\n                 }\n+                return false;\n             }\n \n-            public void writeField(int access, String name, String descriptor,\n-                                   @Nullable String signature) {\n-                if (((Opcodes.ACC_PRIVATE | Opcodes.ACC_SYNTHETIC) & access) == 0) {\n-                    // Fits into the same table structure\n-                    writeMethod(access, name, descriptor, signature, null, null);\n-                }\n+            public boolean writeField(int access, String name, String descriptor, @Nullable String signature) {\n+                // Fits into the same table structure\n+                return writeMethod(access, name, descriptor, signature, null, null);\n             }\n         }\n     }\n",
    "test_patch": "diff --git a/rewrite-java/src/test/java/org/openrewrite/java/internal/parser/TypeTableTest.java b/rewrite-java/src/test/java/org/openrewrite/java/internal/parser/TypeTableTest.java\nindex 0d84caf4793..eda524726da 100644\n--- a/rewrite-java/src/test/java/org/openrewrite/java/internal/parser/TypeTableTest.java\n+++ b/rewrite-java/src/test/java/org/openrewrite/java/internal/parser/TypeTableTest.java\n@@ -45,7 +45,7 @@ class TypeTableTest implements RewriteTest {\n \n     @BeforeEach\n     void before() {\n-        //TODO Dctx.putMessage(TypeTable.VERIFY_CLASS_WRITING, true);\n+        //TODO ctx.putMessage(TypeTable.VERIFY_CLASS_WRITING, true);\n         JavaParserExecutionContextView.view(ctx).setParserClasspathDownloadTarget(temp.toFile());\n         tsv = temp.resolve(\"types.tsv.zip\");\n         System.out.println(tsv);\n@@ -95,33 +95,45 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n     }\n \n     @Test\n-    void writeReadMicrometer() throws IOException {\n+    void writeReadJunitJupiterApi() throws IOException {\n         try (TypeTable.Writer writer = TypeTable.newWriter(Files.newOutputStream(tsv))) {\n             for (Path classpath : JavaParser.runtimeClasspath()) {\n-                if (classpath.toFile().getName().contains(\"micrometer\")) {\n+                if (classpath.toFile().getName().contains(\"junit-jupiter-api\")) {\n                     writeJar(classpath, writer);\n                 }\n             }\n         }\n \n-        TypeTable table = new TypeTable(ctx, Files.newInputStream(tsv), List.of(\"micrometer\"));\n-        Path micrometerClassesDir = table.load(\"micrometer\");\n+        TypeTable table = new TypeTable(ctx, Files.newInputStream(tsv), List.of(\"junit-jupiter-api\"));\n+        Path classesDir = table.load(\"junit-jupiter-api\");\n \n-        assertThat(micrometerClassesDir).isNotNull();\n+        assertThat(classesDir)\n+          .isNotNull()\n+          .isDirectoryRecursivelyContaining(\"glob:**/Assertions.class\")\n+          .isDirectoryRecursivelyContaining(\"glob:**/BeforeEach.class\"); // No fields or methods\n \n         // Demonstrate that the bytecode we wrote for the classes in this\n         // JAR is sufficient for the compiler to type attribute code that depends\n         // on them.\n         rewriteRun(\n           spec -> spec.parser(JavaParser.fromJavaVersion()\n-            .classpath(List.of(micrometerClassesDir))),\n+            .classpath(List.of(classesDir))),\n           java(\n             \"\"\"\n-              import io.micrometer.core.instrument.Metrics;\n-              import io.micrometer.core.instrument.Timer;\n+              import org.junit.jupiter.api.Assertions;\n+              import org.junit.jupiter.api.BeforeEach;\n+              import org.junit.jupiter.api.Test;\n               \n               class Test {\n-                  Timer timer = Metrics.timer(\"my.timer\");\n+              \n+                  @BeforeEach\n+                  void before() {\n+                  }\n+\n+                  @Test\n+                  void foo() {\n+                      Assertions.assertTrue(true);\n+                  }\n               }\n               \"\"\"\n           )\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-5001",
    "pr_id": 5001,
    "issue_id": 4853,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Groovy parser does not support annotations on variable declarations\n- Seems related to #2538.\r\n- First mentioned in [this discussion](https://github.com/openrewrite/rewrite/discussions/4559).\r\n\r\nThis test added to `rewrite-groovy/../AnnotationsTest.java` will fail, but AFAIK should successfully parse.\r\n\r\n```\r\n    @Test\r\n    void annotatedVariables() {\r\n        rewriteRun(\r\n          groovy(\r\n            \"\"\"\r\n              @Foo abc=123\r\n              \"\"\"\r\n          )\r\n        );\r\n    }\r\n```\r\n\r\nDebugging points a finger at `GroovyParserVisitor#RewriteGroovyVisitor#visitDeclarationExpression`.\r\n\r\n## What version of OpenRewrite are you using?\r\n\r\nCurrently running the test above on your `main` branch, but we are using `8.40.2`.\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n\r\nI'm always interested, but hard to find time.  I may give this a go, but hoping it's easy for your parser gurus..  If I can do something quickly, I'll do it!",
    "issue_word_count": 133,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/internal/Delimiter.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java"
    ],
    "base_commit": "cb6f10c8277ef3cf3f53e5faba1534bf6ff1fae8",
    "head_commit": "f74ffd2a25b77ca83e6abedb8f72c8908bcd4002",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/5001",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/5001",
    "dockerfile": "",
    "pr_merged_at": "2025-02-07T18:17:43.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex d1142d2b19f..d747361483a 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -16,6 +16,7 @@\n package org.openrewrite.groovy;\n \n import groovy.lang.GroovySystem;\n+import groovy.transform.Field;\n import groovy.transform.Generated;\n import groovy.transform.Immutable;\n import groovyjarjarasm.asm.Opcodes;\n@@ -26,6 +27,8 @@\n import org.codehaus.groovy.ast.expr.*;\n import org.codehaus.groovy.ast.stmt.*;\n import org.codehaus.groovy.control.SourceUnit;\n+import org.codehaus.groovy.syntax.Token;\n+import org.codehaus.groovy.syntax.Types;\n import org.codehaus.groovy.transform.stc.StaticTypesMarker;\n import org.jspecify.annotations.NonNull;\n import org.jspecify.annotations.Nullable;\n@@ -61,6 +64,7 @@\n import java.util.stream.Stream;\n \n import static java.lang.Character.isJavaIdentifierPart;\n+import static java.lang.Character.isWhitespace;\n import static java.util.Collections.emptyList;\n import static java.util.Collections.singletonList;\n import static java.util.stream.Collectors.toList;\n@@ -231,7 +235,7 @@ private class RewriteGroovyClassVisitor extends ClassCodeVisitorSupport {\n         @Override\n         public void visitClass(ClassNode clazz) {\n             Space fmt = whitespace();\n-            List<J.Annotation> leadingAnnotations = visitAndGetAnnotations(clazz);\n+            List<J.Annotation> leadingAnnotations = visitAndGetAnnotations(clazz, this);\n             List<J.Modifier> modifiers = visitModifiers(clazz.getModifiers());\n \n             Space kindPrefix = whitespace();\n@@ -414,7 +418,7 @@ private void visitEnumField(@SuppressWarnings(\"unused\") FieldNode fieldNode) {\n         private void visitVariableField(FieldNode field) {\n             RewriteGroovyVisitor visitor = new RewriteGroovyVisitor(field, this);\n \n-            List<J.Annotation> annotations = visitAndGetAnnotations(field);\n+            List<J.Annotation> annotations = visitAndGetAnnotations(field, this);\n             List<J.Modifier> modifiers = visitModifiers(field.getModifiers());\n             TypeTree typeExpr = visitTypeTree(field.getOriginType());\n \n@@ -454,57 +458,14 @@ private void visitVariableField(FieldNode field) {\n \n         @Override\n         protected void visitAnnotation(AnnotationNode annotation) {\n-            RewriteGroovyVisitor bodyVisitor = new RewriteGroovyVisitor(annotation, this);\n-            String lastArgKey = annotation.getMembers().keySet().stream().reduce(\"\", (k1, k2) -> k2);\n-            Space prefix = sourceBefore(\"@\");\n-            NameTree annotationType = visitTypeTree(annotation.getClassNode());\n-            JContainer<Expression> arguments = null;\n-            if (!annotation.getMembers().isEmpty()) {\n-                arguments = JContainer.build(\n-                        sourceBefore(\"(\"),\n-                        annotation.getMembers().entrySet().stream()\n-                                // Non-value implicit properties should not be represented in our LST.\n-                                .filter(it -> sourceStartsWith(it.getKey()) || \"value\".equals(it.getKey()))\n-                                .map(arg -> {\n-                                    boolean isImplicitValue = \"value\".equals(arg.getKey()) && !sourceStartsWith(\"value\");\n-                                    Space argPrefix = isImplicitValue ? whitespace() : sourceBefore(arg.getKey());\n-                                    Space isSign = isImplicitValue ? null : sourceBefore(\"=\");\n-                                    Expression expression;\n-                                    if (arg.getValue() instanceof AnnotationConstantExpression) {\n-                                        visitAnnotation((AnnotationNode) ((AnnotationConstantExpression) arg.getValue()).getValue());\n-                                        expression = (J.Annotation) queue.poll();\n-                                    } else {\n-                                        expression = bodyVisitor.visit(arg.getValue());\n-                                    }\n-                                    Expression element = isImplicitValue ? expression\n-                                            : (new J.Assignment(randomId(), argPrefix, Markers.EMPTY,\n-                                            new J.Identifier(randomId(), EMPTY, Markers.EMPTY, emptyList(), arg.getKey(), null, null),\n-                                            padLeft(isSign, expression), null));\n-                                    return JRightPadded.build(element)\n-                                            .withAfter(arg.getKey().equals(lastArgKey) ? sourceBefore(\")\") : sourceBefore(\",\"));\n-                                })\n-                                .collect(toList()),\n-                        Markers.EMPTY\n-                );\n-                // Rare scenario where annotation does only have non-value implicit properties\n-                if (arguments.getElements().isEmpty()) {\n-                    arguments = null;\n-                }\n-            } else if (sourceStartsWith(\"(\")) {\n-                // Annotation with empty arguments like @Foo()\n-                arguments = JContainer.build(sourceBefore(\"(\"),\n-                        singletonList(JRightPadded.build(new J.Empty(randomId(), sourceBefore(\")\"), Markers.EMPTY))),\n-                        Markers.EMPTY);\n-            }\n-\n-            queue.add(new J.Annotation(randomId(), prefix, Markers.EMPTY, annotationType, arguments));\n+            GroovyParserVisitor.this.visitAnnotation(annotation, this);\n         }\n \n         @Override\n         public void visitMethod(MethodNode method) {\n             Space fmt = whitespace();\n \n-            List<J.Annotation> annotations = visitAndGetAnnotations(method);\n+            List<J.Annotation> annotations = visitAndGetAnnotations(method, this);\n             List<J.Modifier> modifiers = visitModifiers(method.getModifiers());\n             boolean isConstructorOfInnerNonStaticClass = false;\n             RedundantDef redundantDef = getRedundantDefMarker(method);\n@@ -564,7 +525,7 @@ class B {                               class B {\n             for (int i = (isConstructorOfInnerNonStaticClass ? 1 : 0); i < unparsedParams.length; i++) {\n                 Parameter param = unparsedParams[i];\n \n-                List<J.Annotation> paramAnnotations = visitAndGetAnnotations(param);\n+                List<J.Annotation> paramAnnotations = visitAndGetAnnotations(param, this);\n \n                 TypeTree paramType;\n                 if (param.isDynamicTyped()) {\n@@ -658,28 +619,6 @@ varargs, emptyList(),\n             return null;\n         }\n \n-        public List<J.Annotation> visitAndGetAnnotations(AnnotatedNode node) {\n-            if (node.getAnnotations().isEmpty()) {\n-                return emptyList();\n-            }\n-\n-            List<J.Annotation> paramAnnotations = new ArrayList<>(node.getAnnotations().size());\n-            for (AnnotationNode annotationNode : node.getAnnotations()) {\n-                // The groovy compiler can add or remove annotations for AST transformations.\n-                // Because @groovy.transform.Immutable is discarded in favour of other transform annotations, the removed annotation must be parsed by hand.\n-                if (sourceStartsWith(\"@\" + Immutable.class.getSimpleName()) || sourceStartsWith(\"@\" + Immutable.class.getCanonicalName())) {\n-                    visitAnnotation(new AnnotationNode(new ClassNode(Immutable.class)));\n-                    paramAnnotations.add(pollQueue());\n-                }\n-\n-                if (appearsInSource(annotationNode)) {\n-                    visitAnnotation(annotationNode);\n-                    paramAnnotations.add(pollQueue());\n-                }\n-            }\n-            return paramAnnotations;\n-        }\n-\n         @SuppressWarnings({\"ConstantConditions\", \"unchecked\"})\n         private <T> T pollQueue() {\n             return (T) queue.poll();\n@@ -1284,6 +1223,13 @@ public void visitClosureListExpression(ClosureListExpression closureListExpressi\n \n         @Override\n         public void visitConstantExpression(ConstantExpression expression) {\n+            // The groovy compiler can add or remove annotations for AST transformations.\n+            // Because @groovy.transform.Field is transformed to a ConstantExpression, we need to restore the original DeclarationExpression\n+            if (sourceStartsWith(\"@\" + Field.class.getSimpleName()) || sourceStartsWith(\"@\" + Field.class.getCanonicalName())) {\n+                visitDeclarationExpression(transformBackToDeclarationExpression(expression));\n+                return;\n+            }\n+\n             queue.add(insideParentheses(expression, fmt -> {\n                 JavaType.Primitive jType;\n                 // The unaryPlus is not included in the expression and must be handled through the source.\n@@ -1406,6 +1352,7 @@ public void visitNotExpression(NotExpression expression) {\n         @Override\n         public void visitDeclarationExpression(DeclarationExpression expression) {\n             Space prefix = whitespace();\n+            List<J.Annotation> leadingAnnotations = visitAndGetAnnotations(expression, classVisitor);\n             Optional<MultiVariable> multiVariable = maybeMultiVariable();\n             List<J.Modifier> modifiers = getModifiers(expression.getVariableExpression());\n             TypeTree typeExpr = visitVariableExpressionType(expression.getVariableExpression());\n@@ -1437,7 +1384,7 @@ public void visitDeclarationExpression(DeclarationExpression expression) {\n                     randomId(),\n                     prefix,\n                     Markers.EMPTY,\n-                    emptyList(),\n+                    leadingAnnotations,\n                     modifiers,\n                     typeExpr,\n                     null,\n@@ -2228,6 +2175,72 @@ private JRightPadded<Statement> convertTopLevelStatement(SourceUnit unit, ASTNod\n         return maybeSemicolon(groovyVisitor.pollQueue());\n     }\n \n+    public List<J.Annotation> visitAndGetAnnotations(AnnotatedNode node, RewriteGroovyClassVisitor classVisitor) {\n+        if (node.getAnnotations().isEmpty()) {\n+            return emptyList();\n+        }\n+\n+        List<J.Annotation> paramAnnotations = new ArrayList<>(node.getAnnotations().size());\n+        for (AnnotationNode annotationNode : node.getAnnotations()) {\n+            // The groovy compiler can add or remove annotations for AST transformations.\n+            // Because @groovy.transform.Immutable is discarded in favour of other transform annotations, the removed annotation must be parsed by hand.\n+            if (sourceStartsWith(\"@\" + Immutable.class.getSimpleName()) || sourceStartsWith(\"@\" + Immutable.class.getCanonicalName())) {\n+                paramAnnotations.add(visitAnnotation(new AnnotationNode(new ClassNode(Immutable.class)), classVisitor));\n+            }\n+\n+            if (appearsInSource(annotationNode)) {\n+                paramAnnotations.add(visitAnnotation(annotationNode, classVisitor));\n+            }\n+        }\n+        return paramAnnotations;\n+    }\n+\n+    public J.Annotation visitAnnotation(AnnotationNode annotation, RewriteGroovyClassVisitor classVisitor) {\n+        RewriteGroovyVisitor bodyVisitor = new RewriteGroovyVisitor(annotation, classVisitor);\n+        String lastArgKey = annotation.getMembers().keySet().stream().reduce(\"\", (k1, k2) -> k2);\n+        Space prefix = sourceBefore(\"@\");\n+        NameTree annotationType = visitTypeTree(annotation.getClassNode());\n+        JContainer<Expression> arguments = null;\n+        if (!annotation.getMembers().isEmpty()) {\n+            arguments = JContainer.build(\n+                    sourceBefore(\"(\"),\n+                    annotation.getMembers().entrySet().stream()\n+                            // Non-value implicit properties should not be represented in our LST.\n+                            .filter(it -> sourceStartsWith(it.getKey()) || \"value\".equals(it.getKey()))\n+                            .map(arg -> {\n+                                boolean isImplicitValue = \"value\".equals(arg.getKey()) && !sourceStartsWith(\"value\");\n+                                Space argPrefix = isImplicitValue ? whitespace() : sourceBefore(arg.getKey());\n+                                Space isSign = isImplicitValue ? null : sourceBefore(\"=\");\n+                                Expression expression;\n+                                if (arg.getValue() instanceof AnnotationConstantExpression) {\n+                                    expression = visitAnnotation((AnnotationNode) ((AnnotationConstantExpression) arg.getValue()).getValue(), classVisitor);\n+                                } else {\n+                                    expression = bodyVisitor.visit(arg.getValue());\n+                                }\n+                                Expression element = isImplicitValue ? expression\n+                                        : (new J.Assignment(randomId(), argPrefix, Markers.EMPTY,\n+                                        new J.Identifier(randomId(), EMPTY, Markers.EMPTY, emptyList(), arg.getKey(), null, null),\n+                                        padLeft(isSign, expression), null));\n+                                return JRightPadded.build(element)\n+                                        .withAfter(arg.getKey().equals(lastArgKey) ? sourceBefore(\")\") : sourceBefore(\",\"));\n+                            })\n+                            .collect(toList()),\n+                    Markers.EMPTY\n+            );\n+            // Rare scenario where annotation does only have non-value implicit properties\n+            if (arguments.getElements().isEmpty()) {\n+                arguments = null;\n+            }\n+        } else if (sourceStartsWith(\"(\")) {\n+            // Annotation with empty arguments like @Foo()\n+            arguments = JContainer.build(sourceBefore(\"(\"),\n+                    singletonList(JRightPadded.build(new J.Empty(randomId(), sourceBefore(\")\"), Markers.EMPTY))),\n+                    Markers.EMPTY);\n+        }\n+\n+        return new J.Annotation(randomId(), prefix, Markers.EMPTY, annotationType, arguments);\n+    }\n+\n     private static LineColumn pos(ASTNode node) {\n         return new LineColumn(node.getLineNumber(), node.getColumnNumber());\n     }\n@@ -2553,7 +2566,10 @@ private int determineParenthesisLevel(int childLineNumber, int parentLineNumber,\n             return isPatternOperator ? PATTERN_DOUBLE_QUOTE_STRING : DOUBLE_QUOTE_STRING;\n         } else if (source.startsWith(\"'\", c)) {\n             return isPatternOperator ? PATTERN_SINGLE_QUOTE_STRING : SINGLE_QUOTE_STRING;\n+        } else if (source.startsWith(\"[\", c)) {\n+            return ARRAY;\n         }\n+\n         return null;\n     }\n \n@@ -2774,7 +2790,9 @@ private J.TypeParameter visitTypeParameter(GenericsType genericType) {\n      */\n     private boolean appearsInSource(ASTNode node) {\n         if (node instanceof AnnotationNode) {\n-            return sourceStartsWith(\"@\" + ((AnnotationNode) node).getClassNode().getUnresolvedName());\n+            String name = ((AnnotationNode) node).getClassNode().getUnresolvedName();\n+            String[] parts = name.split(\"\\\\.\");\n+            return sourceStartsWith(\"@\" + name) || sourceStartsWith(\"@\" + parts[parts.length - 1]);\n         }\n \n         return node.getColumnNumber() >= 0 && node.getLineNumber() >= 0 && node.getLastColumnNumber() >= 0 && node.getLastLineNumber() >= 0;\n@@ -2834,6 +2852,41 @@ private List<ImportNode> getStaticStarImports(ModuleNode ast) {\n         return completeStaticStarImports;\n     }\n \n+    private DeclarationExpression transformBackToDeclarationExpression(ConstantExpression expression) {\n+        // We don't use `expression` but the raw source\n+        String str = source.substring(cursor);\n+        int equalsIndex = str.indexOf(\"=\");\n+\n+        int end = equalsIndex - 1;\n+        while (end >= 0 && isWhitespace(str.charAt(end))) {\n+            end--;\n+        }\n+        int start = end;\n+        while (start >= 0 && !isWhitespace(str.charAt(start))) {\n+            start--;\n+        }\n+\n+        int startX = indexOfNextNonWhitespace( equalsIndex + 1, str);\n+        int endX = startX;\n+        Delimiter delim = getDelimiter(endX);\n+        if (delim != null) {\n+            endX = str.indexOf(delim.close, endX + delim.open.length()) + 1;\n+        } else {\n+            while (endX < str.length() && (isJavaIdentifierPart(str.charAt(endX)) || str.charAt(endX) == ',' || str.charAt(endX) == '(' || str.charAt(endX) == ')')) {\n+                endX++;\n+            }\n+        }\n+\n+        VariableExpression left = new VariableExpression(str.substring(start + 1, end + 1));\n+        Token operation = new Token(Types.EQUAL, \"=\", -1, -1);\n+        // Notice this give wrong type information if a non-variable is used, but at least we can parse the `right` side of the @Field declaration\n+        ConstantExpression right = new ConstantExpression(str.substring(startX, endX));\n+        DeclarationExpression declarationExpression = new DeclarationExpression(left, operation, right);\n+        declarationExpression.addAnnotations(singletonList(new AnnotationNode(new ClassNode(Field.class))));\n+\n+        return declarationExpression;\n+    }\n+\n     /**\n      * Static type checking for groovy is an add-on that places the type information it discovers into expression metadata.\n      *\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/internal/Delimiter.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/internal/Delimiter.java\nindex 3cc1b527119..657e2a5b233 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/internal/Delimiter.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/internal/Delimiter.java\n@@ -33,7 +33,8 @@ public enum Delimiter {\n     PATTERN_SLASHY_STRING(\"~/\", \"/\"),\n     PATTERN_DOLLAR_SLASHY_STRING(\"~$/\", \"$/\"),\n     SINGLE_LINE_COMMENT(\"//\", \"\\n\"),\n-    MULTILINE_COMMENT(\"/*\", \"*/\");\n+    MULTILINE_COMMENT(\"/*\", \"*/\"),\n+    ARRAY(\"[\", \"]\");\n \n     public final String open;\n     public final String close;\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java\nindex c9f14d23010..444a55354bd 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java\n@@ -163,4 +163,63 @@ class Test {}\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4853\")\n+    @Test\n+    void annotationOnVariable() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              @Foo def a = \"a\"\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void groovyTransformFieldAnnotationOnVariable() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              import groovy.transform.Field\n+              \n+              @Field def a = [1, 2, 3]\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void groovyTransformFieldFQNAnnotationOnVariable() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              @groovy.transform.Field def a = [1, 2, 3]\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void groovyTransformFieldFQNAnnotationOnVariableWithReference() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              def z = 1 + 2\n+              @groovy.transform.Field def a = z\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void groovyTransformFieldFQNAnnotationOnVariableWithMethodInvocation() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              @groovy.transform.Field def a = callSomething()\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4999",
    "pr_id": 4999,
    "issue_id": 4993,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Failure to write out type table for nested types in `hibernate-core:6.5.1.Final`\n## What version of OpenRewrite are you using?\nI am using\n\n- OpenRewrite 8.45.0-SNAPSHOT\n\n## How are you running OpenRewrite?\nI'm running `./gradlew createTypeTable` against [openrewrite/rewrite-hibernate](https://github.com/openrewrite/rewrite-hibernate/blob/d2bc02a1e14f8eb5a96943450fca9d03334c6d65/build.gradle.kts#L9-L12) through a locally installed version of this build plugin\n- https://github.com/openrewrite/rewrite-build-gradle-plugin/pull/75\n\n## What is the smallest, simplest way to reproduce the problem?\n1. Checkout this branch https://github.com/openrewrite/rewrite-build-gradle-plugin/pull/75\n2. Run `./gradlew pTML` on said branch\n3. Checkout openrewrite/rewrite-hibernate\n4. Change settings.gradle.kts to add\n```kotlin\npluginManagement {\n    repositories {\n        mavenLocal()\n        gradlePluginPortal()\n    }\n}\n```\n5. Change `build.gradle.kts` to use `recipe-library` version `latest.integration`\n6. Run `./gradlew createTypeTable`\n7. Delete `src/main/resources/META-INF/rewrite/classpath`\n8. Run the unit tests\n\n## What did you expect to see?\nA successfully created type table used to pass the unit tests.\n\n## What did you see instead?\nA failure to run the unit tests\n\n## What is the full stack trace of any errors you encountered?\n```\njava.lang.IllegalArgumentException: Invalid access flags: 32\n\n\tat org.objectweb.asm.util.CheckClassAdapter.checkAccess(CheckClassAdapter.java:542)\n\tat org.objectweb.asm.util.CheckClassAdapter.visitInnerClass(CheckClassAdapter.java:363)\n\tat org.openrewrite.java.internal.parser.TypeTable$Reader.lambda$writeClassesDir$3(TypeTable.java:207)\n\tat java.base/java.util.HashMap.forEach(HashMap.java:1421)\n\tat org.openrewrite.java.internal.parser.TypeTable$Reader.writeClassesDir(TypeTable.java:180)\n\tat org.openrewrite.java.internal.parser.TypeTable$Reader.read(TypeTable.java:169)\n\tat org.openrewrite.java.internal.parser.TypeTable.<init>(TypeTable.java:97)\n\tat org.openrewrite.java.internal.parser.TypeTable.fromClasspath(TypeTable.java:89)\n\tat org.openrewrite.java.JavaParser.dependenciesFromResources(JavaParser.java:130)\n\tat org.openrewrite.java.JavaParser$Builder.classpathFromResources(JavaParser.java:331)\n\tat org.openrewrite.hibernate.MigrateUserTypeTest.defaults(MigrateUserTypeTest.java:33)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:137)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:129)\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:124)\n\tat org.openrewrite.hibernate.MigrateUserTypeTest.shouldMigrateUserType(MigrateUserTypeTest.java:41)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:569)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\n```\nWhen attempting to write out these values with ASM.\n![Image](https://github.com/user-attachments/assets/a593675b-efc6-4b93-a4ad-bfb924793469)",
    "issue_word_count": 408,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java/src/main/java/org/openrewrite/java/internal/parser/TypeTable.java",
      "rewrite-java/src/test/java/org/openrewrite/java/internal/parser/TypeTableTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java/src/test/java/org/openrewrite/java/internal/parser/TypeTableTest.java"
    ],
    "base_commit": "c50c7460974f2d4ffcf657ee084545901f207a82",
    "head_commit": "a2aae5e770bb6c274e3fd1fc4fffae4690aaff05",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4999",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4999",
    "dockerfile": "",
    "pr_merged_at": "2025-02-10T19:36:24.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/internal/parser/TypeTable.java b/rewrite-java/src/main/java/org/openrewrite/java/internal/parser/TypeTable.java\nindex 3dcb031f123..1c507db69cc 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/internal/parser/TypeTable.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/internal/parser/TypeTable.java\n@@ -185,7 +185,7 @@ private void writeClassesDir() {\n \n                 ClassWriter cw = new ClassWriter(0);\n                 ClassVisitor classWriter = ctx.getMessage(VERIFY_CLASS_WRITING, false) ?\n-                        cw : new CheckClassAdapter(cw);\n+                        new CheckClassAdapter(cw) : cw;\n \n                 classWriter.visit(\n                         V1_8,\n@@ -204,11 +204,12 @@ private void writeClassesDir() {\n                 }\n \n                 for (ClassDefinition innerClass : innerClasses) {\n+                    int lastIndexOf$ = innerClass.getName().lastIndexOf('$');\n                     classWriter.visitInnerClass(\n                             innerClass.getName(),\n-                            classDef.getName(),\n-                            innerClass.getName().substring(innerClass.getName().lastIndexOf('$') + 1),\n-                            innerClass.getAccess()\n+                            innerClass.getName().substring(0, lastIndexOf$),\n+                            innerClass.getName().substring(lastIndexOf$ + 1),\n+                            innerClass.getAccess() & 30239\n                     );\n                 }\n \n",
    "test_patch": "diff --git a/rewrite-java/src/test/java/org/openrewrite/java/internal/parser/TypeTableTest.java b/rewrite-java/src/test/java/org/openrewrite/java/internal/parser/TypeTableTest.java\nindex 9af0b44f1e6..0d84caf4793 100644\n--- a/rewrite-java/src/test/java/org/openrewrite/java/internal/parser/TypeTableTest.java\n+++ b/rewrite-java/src/test/java/org/openrewrite/java/internal/parser/TypeTableTest.java\n@@ -45,7 +45,7 @@ class TypeTableTest implements RewriteTest {\n \n     @BeforeEach\n     void before() {\n-        ctx.putMessage(TypeTable.VERIFY_CLASS_WRITING, true);\n+        //TODO Dctx.putMessage(TypeTable.VERIFY_CLASS_WRITING, true);\n         JavaParserExecutionContextView.view(ctx).setParserClasspathDownloadTarget(temp.toFile());\n         tsv = temp.resolve(\"types.tsv.zip\");\n         System.out.println(tsv);\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4996",
    "pr_id": 4996,
    "issue_id": 4995,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ChangePackage doesn't handle classes with GWT JNSI methods\n\n## What version of OpenRewrite are you using?\n\nI am using OpenRewrite v8.44.2 with the [ChangePackage](https://docs.openrewrite.org/recipes/java/changepackage) recipe.\n\n## What is the smallest, simplest way to reproduce the problem?\n\n```yaml\ntype: specs.openrewrite.org/v1beta/recipe\nname: com.yourorg.ChangePackageExample\ndisplayName: Rename package name example\nrecipeList:\n  - org.openrewrite.java.ChangePackage:\n      oldPackageName: old_package_name\n      newPackageName: new_package_name\n```\n\n```java\npackage old_package_name;\nclass A {\n  native void alert(String msg) /*-{ $wnd.alert(msg); }-*/;\n}\n```\n\n## What did you expect to see?\n\n```java\npackage new_package_name;\nclass A {\n  native void alert(String msg) /*-{ $wnd.alert(msg); }-*/;\n}\n```\n\n## What did you see instead?\nOpenRewrite didn't touch the file. It seems like it ignores Java classes with `native` methods and/or trailing comment.\n\nSee [reproducer](https://github.com/openrewrite/rewrite/pull/4996)",
    "issue_word_count": 135,
    "test_files_count": 2,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/CommentTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/CommentTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java"
    ],
    "base_commit": "abf5dd958ed8581b26afa2cfe68ab62f82ff9e4e",
    "head_commit": "3a0e62ce94809d2989883461ce9e7ba7689b08f0",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4996",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4996",
    "dockerfile": "",
    "pr_merged_at": "2025-02-17T12:10:38.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\nindex 903cd908e54..b85e3fc19ef 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n@@ -1840,9 +1840,7 @@ private Space statementDelim(@Nullable Tree t) {\n         if (t instanceof JCMethodDecl) {\n             JCMethodDecl m = (JCMethodDecl) t;\n             if (m.body == null || m.defaultValue != null) {\n-                String suffix = source.substring(cursor, positionOfNext(\";\", null));\n-                int idx = findFirstNonWhitespaceChar(suffix);\n-                return sourceBefore(idx >= 0 ? \"\" : \";\");\n+                return sourceBefore(\";\");\n             } else {\n                 return sourceBefore(\"\");\n             }\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex d32e582fd35..39512ecb49f 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -1920,9 +1920,7 @@ private Space statementDelim(@Nullable Tree t) {\n             case METHOD:\n                 JCMethodDecl m = (JCMethodDecl) t;\n                 if (m.body == null || m.defaultValue != null) {\n-                    String suffix = source.substring(cursor, positionOfNext(\";\", null));\n-                    int idx = findFirstNonWhitespaceChar(suffix);\n-                    return sourceBefore(idx >= 0 ? \"\" : \";\");\n+                    return sourceBefore(\";\");\n                 } else {\n                     return sourceBefore(\"\");\n                 }\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex 41d6a3469f5..01fa9e51774 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -1953,9 +1953,7 @@ private Space statementDelim(@Nullable Tree t) {\n             case METHOD:\n                 JCMethodDecl m = (JCMethodDecl) t;\n                 if (m.body == null || m.defaultValue != null) {\n-                    String suffix = source.substring(cursor, positionOfNext(\";\", null));\n-                    int idx = findFirstNonWhitespaceChar(suffix);\n-                    return sourceBefore(idx >= 0 ? \"\" : \";\");\n+                    return sourceBefore(\";\");\n                 } else {\n                     return sourceBefore(\"\");\n                 }\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\nindex 97bcd90566c..a81d83221a4 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n@@ -1833,9 +1833,7 @@ private Space statementDelim(@Nullable Tree t) {\n         if (t instanceof JCMethodDecl) {\n             JCMethodDecl m = (JCMethodDecl) t;\n             if (m.body == null || m.defaultValue != null) {\n-                String suffix = source.substring(cursor, positionOfNext(\";\", null));\n-                int idx = findFirstNonWhitespaceChar(suffix);\n-                return sourceBefore(idx >= 0 ? \"\" : \";\");\n+                return sourceBefore(\";\");\n             } else {\n                 return sourceBefore(\"\");\n             }\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/CommentTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/CommentTest.java\nindex 3e98c839b03..82fea32eb63 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/CommentTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/CommentTest.java\n@@ -16,6 +16,7 @@\n package org.openrewrite.java.tree;\n \n import org.junit.jupiter.api.Test;\n+import org.openrewrite.Issue;\n import org.openrewrite.test.RewriteTest;\n \n import static org.openrewrite.java.Assertions.java;\n@@ -50,4 +51,18 @@ class Test {// /*\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4995\")\n+    @Test\n+    void trailingComment() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              abstract class Test {\n+                void alert(String msg) /*-{ $wnd.alert(msg); }-*/;\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\nindex 03f38b11e9b..c3c8e1e829c 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\n@@ -196,7 +196,7 @@ public void test() {\n         package com.example.demo;\n         class FooBar {\n             public void test(int num string msg) {\n-              String a; this.ownerR\n+              String a;\n               System.out.println();\n             }\n         }\n@@ -204,7 +204,7 @@ public void test(int num string msg) {\n       \"\"\"\n         package com.example.demo;\n         class FooBar {\n-            public void test(int num string s, int b) {\n+            public void test() {\n               String a; this.ownerR\n               System.out.println();\n             }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4989",
    "pr_id": 4989,
    "issue_id": 1297,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Support Lombok Annotations\n`org.openrewrite.java.cleanup.ExplicitInitialization` and `org.openrewrite.java.cleanup.UseDiamondOperator` removes the argument type when it's a lombok.val variable.\r\n\r\n`val products = new ArrayList<Product>();`\r\n\r\n`val products = new ArrayList<>();`\r\n\r\nwhich is incorrect and doesn't compile anymore.",
    "issue_word_count": 42,
    "test_files_count": 2,
    "non_test_files_count": 6,
    "pr_changed_files": [
      "IDE.properties.tmp",
      "rewrite-gradle/src/test/java/org/openrewrite/maven/tree/OpenRewriteModelSerializableTest.java",
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11Parser.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17Parser.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21Parser.java",
      "rewrite-java-lombok/build.gradle.kts",
      "rewrite-java-lombok/libs/lombok-1.18.37.jar",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/maven/tree/OpenRewriteModelSerializableTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java"
    ],
    "base_commit": "5541466476b81a12756c280cdb28968322fafc4d",
    "head_commit": "3704153d0ca1d80d45eff859328cfd798a2ad2ce",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4989",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4989",
    "dockerfile": "",
    "pr_merged_at": "2025-02-05T16:53:21.000Z",
    "patch": "diff --git a/IDE.properties.tmp b/IDE.properties.tmp\nindex bbd4e3ee763..8c342fb124e 100644\n--- a/IDE.properties.tmp\n+++ b/IDE.properties.tmp\n@@ -33,6 +33,7 @@ rewrite-json\n rewrite-maven\n rewrite-properties\n rewrite-protobuf\n+rewrite-toml\n rewrite-xml\n rewrite-yaml\n \n\ndiff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11Parser.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11Parser.java\nindex 51103226f9b..96928566824 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11Parser.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11Parser.java\n@@ -124,8 +124,7 @@ private ReloadableJava11Parser(\n         Options.instance(context).put(\"should-stop.ifError\", \"GENERATE\");\n \n         LOMBOK:\n-        if (System.getenv().getOrDefault(\"REWRITE_LOMBOK\", System.getProperty(\"rewrite.lombok\")) != null &&\n-                classpath != null && classpath.stream().anyMatch(it -> it.toString().contains(\"lombok\"))) {\n+        if (classpath != null && classpath.stream().anyMatch(it -> it.toString().contains(\"lombok\"))) {\n             Processor lombokProcessor = null;\n             try {\n                 // https://projectlombok.org/contributing/lombok-execution-path\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17Parser.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17Parser.java\nindex 72c579ed838..c69423d47d8 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17Parser.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17Parser.java\n@@ -122,8 +122,7 @@ private ReloadableJava17Parser(\n         Options.instance(context).put(\"should-stop.ifError\", \"GENERATE\");\n \n         LOMBOK:\n-        if (System.getenv().getOrDefault(\"REWRITE_LOMBOK\", System.getProperty(\"rewrite.lombok\")) != null &&\n-            classpath != null && classpath.stream().anyMatch(it -> it.toString().contains(\"lombok\"))) {\n+        if (classpath != null && classpath.stream().anyMatch(it -> it.toString().contains(\"lombok\"))) {\n             Processor lombokProcessor = null;\n             try {\n                 // https://projectlombok.org/contributing/lombok-execution-path\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21Parser.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21Parser.java\nindex 5b3ac22b69e..ba5fa315735 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21Parser.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21Parser.java\n@@ -122,8 +122,7 @@ private ReloadableJava21Parser(\n         Options.instance(context).put(\"should-stop.ifError\", \"GENERATE\");\n \n         LOMBOK:\n-        if (System.getenv().getOrDefault(\"REWRITE_LOMBOK\", System.getProperty(\"rewrite.lombok\")) != null &&\n-            classpath != null && classpath.stream().anyMatch(it -> it.toString().contains(\"lombok\"))) {\n+        if (classpath != null && classpath.stream().anyMatch(it -> it.toString().contains(\"lombok\"))) {\n             Processor lombokProcessor = null;\n             try {\n                 // https://projectlombok.org/contributing/lombok-execution-path\n\ndiff --git a/rewrite-java-lombok/build.gradle.kts b/rewrite-java-lombok/build.gradle.kts\nindex 28367692d4a..96e262b5825 100644\n--- a/rewrite-java-lombok/build.gradle.kts\n+++ b/rewrite-java-lombok/build.gradle.kts\n@@ -57,7 +57,8 @@ dependencies {\n     runtimeOnly(\"org.projectlombok:lombok:latest.release\")\n \n     // Add lombok dependency to the newly created lombok configuration\n-    lombok(\"org.projectlombok:lombok:latest.release\")\n+    //lombok(\"org.projectlombok:lombok:latest.release\")\n+    lombok(files(\"libs/lombok-1.18.37.jar\")) // Temporary pending the next stable release of lombok\n     compileOnly(files(tools))\n     compileOnly(files(unpackedAndRenamedLombokDir))\n }\n\ndiff --git a/rewrite-java-lombok/libs/lombok-1.18.37.jar b/rewrite-java-lombok/libs/lombok-1.18.37.jar\nnew file mode 100644\nindex 00000000000..cb6e47372fa\nBinary files /dev/null and b/rewrite-java-lombok/libs/lombok-1.18.37.jar differ\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/maven/tree/OpenRewriteModelSerializableTest.java b/rewrite-gradle/src/test/java/org/openrewrite/maven/tree/OpenRewriteModelSerializableTest.java\nindex 8e6e20d4e21..1f9e46430af 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/maven/tree/OpenRewriteModelSerializableTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/maven/tree/OpenRewriteModelSerializableTest.java\n@@ -23,7 +23,7 @@\n import java.io.Serializable;\n \n /**\n- * Every model object that is transferred via the tooling API must implement {@link Serializable}, including\n+ * Every model object that is transferred via the tooling API must implement {@link java.io.Serializable}, including\n  * certain maven model objects that are shared by rewrite-gradle.\n  */\n class OpenRewriteModelSerializableTest {\n\ndiff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\nindex ede1c202240..746239408ca 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\n@@ -38,6 +38,7 @@ class LombokTest implements RewriteTest {\n \n     @BeforeAll\n     static void setUp() {\n+        // Only needed for Java 8, until enabled by default there\n         System.setProperty(\"rewrite.lombok\", \"true\");\n     }\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4982",
    "pr_id": 4982,
    "issue_id": 4068,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Groovy parser fails when using duplicate static star imports\n<!--\nThank you for reporting an issue with OpenRewrite!\nWe appreciate you taking the time to help us improve.\nPlease fill out the template below to help us understand and reproduce the issue.\nFeel free to delete any sections that don't apply to your issue.\n-->\n\n## What version of OpenRewrite are you using?\n<!--\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\nFor patch releases check the GitHub Releases page for the respective project.\n\nWe release every few weeks, so it's possible that your issue has already been fixed.\n\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\nhttps://docs.openrewrite.org/reference/snapshot-instructions\n-->\nI am using\n\n- OpenRewrite 6.8.4\n- Gradle plugin 7.4.2\n- rewrite-_module_ v1.2.3\n\n## How are you running OpenRewrite?\n<!--\nAre you using the gradle plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\nIs your project a single module or a multi-module project?\n\nCan you share your configuration so that we can rule out any configuration issues?\n\nIs your project public? If so, can you share a link to it?\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\n-->\nI am using the Gradle plugin, and my project is a single module project.\n```xml\nplugins {\n    id 'maven-publish'\n    id 'groovy'\n    id 'idea'\n    id 'net.researchgate.release' version '2.8.1'\n    id \"com.github.ben-manes.versions\" version \"0.36.0\"\n    id \"com.gorylenko.gradle-git-properties\" version \"2.3.2\"\n    id 'java-library'\n    id 'org.openrewrite.rewrite' version '6.8.4'\n}\n\nrewrite {\n    activeRecipe(\"org.openrewrite.java.RemoveUnusedImports\")\n}\n```\n\n## What is the smallest, simplest way to reproduce the problem?\n<!--\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\n\nA code snippet can be something simple like this, or similar for other languages:\n-->\n```java\n@Test\nvoid staticStarImport() {\n  rewriteRun(\n    groovy(\n      \"\"\"\n        import static java.util.Collections.*\n        import static java.util.Collections.*\n      \"\"\"\n    )\n  );\n}\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\nNo parsing error\n\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\nparsing  error\n\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n```\nError during rewrite dry run\norg.opentest4j.AssertionFailedError: [When parsing and printing the source code back to text without modifications, the printed source didn't match the original source code. This means there is a bug in the parser implementation itself. Please open an issue to report this, providing a sample of the code that generated this error for \"file.groovy\":\ndiff --git a/file.groovy b/file.groovy\nindex dff510f..56679bc 100644\n--- a/file.groovy\n+++ b/file.groovy\n@@ -1,2 +1,2 @@ \n import static java.util.Collections.*\n-import static java.util.Collections.*\n\\ No newline at end of file\n+import static java.util.Collections.//*\n\\ No newline at end of file\n] \nexpected: \n  \"import static java.util.Collections.*\n  import static java.util.Collections.*\"\n but was: \n  \"import static java.util.Collections.*\n  import static java.util.Collections.//*\"\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\n",
    "issue_word_count": 677,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ImportTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ImportTest.java"
    ],
    "base_commit": "c11da8d3546e4127bef13bc25d8bee3c88471f5b",
    "head_commit": "1e52366072763c4e7c351b61cd0496edc970eb8a",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4982",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4982",
    "dockerfile": "",
    "pr_merged_at": "2025-02-05T07:30:41.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex d2282b0b189..68a9df18da3 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -60,6 +60,7 @@\n import java.util.regex.Pattern;\n import java.util.stream.Stream;\n \n+import static java.lang.Character.isJavaIdentifierPart;\n import static java.util.Collections.emptyList;\n import static java.util.Collections.singletonList;\n import static java.util.stream.Collectors.toList;\n@@ -159,7 +160,7 @@ public G.CompilationUnit visit(SourceUnit unit, ModuleNode ast) throws GroovyPar\n         for (ImportNode anImport : ast.getStaticImports().values()) {\n             sortedByPosition.computeIfAbsent(pos(anImport), i -> new ArrayList<>()).add(anImport);\n         }\n-        for (ImportNode anImport : ast.getStaticStarImports().values()) {\n+        for (ImportNode anImport : getStaticStarImports(ast)) {\n             sortedByPosition.computeIfAbsent(pos(anImport), i -> new ArrayList<>()).add(anImport);\n         }\n \n@@ -2221,40 +2222,15 @@ private JRightPadded<Statement> convertTopLevelStatement(SourceUnit unit, ASTNod\n             return JRightPadded.build(classVisitor.pollQueue());\n         } else if (node instanceof ImportNode) {\n             ImportNode importNode = (ImportNode) node;\n-            Space prefix = sourceBefore(\"import\");\n-            JLeftPadded<Boolean> statik;\n-            if (importNode.isStatic()) {\n-                statik = padLeft(sourceBefore(\"static\"), true);\n-            } else {\n-                statik = padLeft(EMPTY, false);\n-            }\n-            String packageName = importNode.getPackageName();\n-            J.FieldAccess qualid;\n-            if (packageName == null) {\n-                String type = importNode.getType().getName().replace('$', '.');\n-                if (importNode.isStar()) {\n-                    type += \".*\";\n-                } else if (importNode.getFieldName() != null) {\n-                    type += \".\" + importNode.getFieldName();\n-                }\n-                Space space = sourceBefore(type);\n-                qualid = TypeTree.build(type).withPrefix(space);\n-            } else {\n-                if (importNode.isStar()) {\n-                    packageName += \"*\";\n-                }\n-                qualid = TypeTree.build(packageName).withPrefix(sourceBefore(packageName));\n-            }\n-\n+            Space importPrefix = sourceBefore(\"import\");\n+            JLeftPadded<Boolean> statik = importNode.isStatic() ? padLeft(sourceBefore(\"static\"), true) : padLeft(EMPTY, false);\n+            Space space = whitespace();\n+            J.FieldAccess qualid = TypeTree.build(name()).withPrefix(space);\n             JLeftPadded<J.Identifier> alias = null;\n-            int endOfWhitespace = indexOfNextNonWhitespace(cursor, source);\n-            if (endOfWhitespace + 2 <= source.length() && \"as\".equals(source.substring(endOfWhitespace, endOfWhitespace + 2))) {\n-                String simpleName = importNode.getAlias();\n-                alias = padLeft(sourceBefore(\"as\"), new J.Identifier(randomId(), sourceBefore(simpleName), Markers.EMPTY, emptyList(), simpleName, null, null));\n+            if (sourceStartsWith(\"as\")) {\n+                alias = padLeft(sourceBefore(\"as\"), new J.Identifier(randomId(), whitespace(), Markers.EMPTY, emptyList(), name(), null, null));\n             }\n-\n-            J.Import anImport = new J.Import(randomId(), prefix, Markers.EMPTY, statik, qualid, alias);\n-            return maybeSemicolon(anImport);\n+            return maybeSemicolon(new J.Import(randomId(), importPrefix, Markers.EMPTY, statik, qualid, alias));\n         }\n \n         RewriteGroovyVisitor groovyVisitor = new RewriteGroovyVisitor(node, new RewriteGroovyClassVisitor(unit));\n@@ -2672,7 +2648,7 @@ private String name() {\n         for (; i < source.length(); i++) {\n             char c = source.charAt(i);\n             boolean isVarargs = source.length() > (i + 2) && c == '.' && source.charAt(i + 1) == '.' && source.charAt(i + 2) == '.';\n-            if (!(Character.isJavaIdentifierPart(c) || c == '.' || c == '*') || isVarargs) {\n+            if (!(isJavaIdentifierPart(c) || c == '.' || c == '*') || isVarargs) {\n                 break;\n             }\n         }\n@@ -2805,6 +2781,58 @@ private boolean appearsInSource(ASTNode node) {\n         return node.getColumnNumber() >= 0 && node.getLineNumber() >= 0 && node.getLastColumnNumber() >= 0 && node.getLastLineNumber() >= 0;\n     }\n \n+    /**\n+     * Duplicate imports do work out of the box for import, star-import and static-import.\n+     * For static-star-import, this does work though.\n+     * The groovy compiler does only memoize the last duplicate import instead of all, so retrieve all static star imports by hand.\n+     */\n+    private List<ImportNode> getStaticStarImports(ModuleNode ast) {\n+        List<ImportNode> completeStaticStarImports = new ArrayList<>();\n+        Map<String, ImportNode> staticStarImports = ast.getStaticStarImports();\n+        if (!staticStarImports.isEmpty()) {\n+            // Take source code until last static star import for performance reasons\n+            int lastLineNumber = -1;\n+            for (ImportNode anImport : ast.getStaticStarImports().values()) {\n+                lastLineNumber = Math.max(lastLineNumber, anImport.getLastLineNumber());\n+            }\n+            String importSource = sourceLineNumberOffsets.length <= lastLineNumber ? source : source.substring(0, sourceLineNumberOffsets[lastLineNumber]);\n+\n+            // Create a node for each `import static`\n+            String[] lines = importSource.split(\"\\n\");\n+            for (int i = 0; i < lines.length; i++) {\n+                String line = lines[i];\n+                int index = 0;\n+\n+                while (index < line.length()) {\n+                    int importIndex = line.indexOf(\"import\", index);\n+                    if (importIndex == -1) break;\n+\n+                    int maybeStaticIndex = indexOfNextNonWhitespace(importIndex + 6, line);\n+                    if (!line.startsWith(\"static\", maybeStaticIndex)) {\n+                        index = importIndex + 6;\n+                        continue;\n+                    }\n+\n+                    int packageBegin = indexOfNextNonWhitespace( maybeStaticIndex + 6, line);\n+                    int packageEnd = packageBegin;\n+                    while (packageEnd < line.length() && (isJavaIdentifierPart(line.charAt(packageEnd)) || line.charAt(packageEnd) == '.')) {\n+                        packageEnd++;\n+                    }\n+\n+                    if (packageEnd < line.length() && line.charAt(packageEnd) == '*') {\n+                        ImportNode node = new ImportNode(staticStarImports.get(line.substring(packageBegin, packageEnd - 1)).getType());\n+                        node.setLineNumber(i + 1);\n+                        node.setColumnNumber(importIndex + 1);\n+                        completeStaticStarImports.add(node);\n+                    }\n+\n+                    index = packageEnd;\n+                }\n+            }\n+        }\n+        return completeStaticStarImports;\n+    }\n+\n     /**\n      * Static type checking for groovy is an add-on that places the type information it discovers into expression metadata.\n      *\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ImportTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ImportTest.java\nindex 330f44fc599..7322e9298ce 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ImportTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ImportTest.java\n@@ -34,6 +34,17 @@ void classImport() {\n         );\n     }\n \n+    @Test\n+    void multipleImportsOnOneLine() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              import java.util.List;import java.util.Set\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void starImport() {\n         rewriteRun(\n@@ -90,4 +101,21 @@ void staticImportAlias() {\n           )\n         );\n     }\n+\n+    @Test\n+    void duplicateImports() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+                    import static      java.util.Collections.*    ;     import               static      java.util.Collections.*\n+              import java.util.Collections.*  ; import static java.util.Collections.*\n+              import java.util.Collections.*\n+              import static java.util.Collections.singletonList as listOf\n+              import static java.util.Collections.singletonList as listOf\n+              import static java.util.Collections.singletonList;import static java.util.Collections.*\n+              import java.util.Collections.*\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4981",
    "pr_id": 4981,
    "issue_id": 4958,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Style not preserved with MergeYaml when values are written in flow style\n\n## What version of OpenRewrite are you using?\n\nI am using\n\n- OpenRewrite 8.44.1\n## What is the smallest, simplest way to reproduce the problem?\n\nIn order to reproduce the problem, I created this minimalist test that fails :\n\n\n```java\npackage foo.bar;\n\nimport org.junit.jupiter.api.Test;\nimport org.openrewrite.test.RewriteTest;\nimport org.openrewrite.yaml.MergeYaml;\n\nimport static org.openrewrite.yaml.Assertions.yaml;\n\nclass MergeYamlFlowStyleTest implements RewriteTest {\n    @Test\n    void testYamlFlowStyle() {\n        rewriteRun(spec -> spec\n                        .recipe(new MergeYaml(//language=jsonpath\n                                \"$.jobs[?(@.name=='test')].plan[?(@.task=='sonar')]\",\n                                // language=yaml\n                                \"vars: { version: 10.3 }\",\n                                false,\n                                null,\n                                null\n                        )),\n\n                yaml(// language=yaml\n                        \"\"\"\n                                jobs:\n                                - name: test\n                                  plan:\n                                  - task: sonar\n                                \"\"\",\n                        // language=yaml\n                        \"\"\"\n                                jobs:\n                                - name: test\n                                  plan:\n                                  - task: sonar\n                                    vars: { version: 10.3 }\n                                \"\"\"\n                ));\n    }\n}\n\n```\n\n## What did you expect to see?\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\n```yaml\njobs:\n- name: test\n  plan:\n  - task: sonar\n    vars: { version: 10.3 }\n```\n\n## What did you see instead?\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\n```yaml\njobs:\n- name: test\n  plan:\n  - task: sonar\n    vars: {\n      version: 10.3 }\n```\n\n## What is the full stack trace of any errors you encountered?\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\n``` diff\n[ERROR] Failures: \n[ERROR]   MergeYamlFlowStyleTest.testYamlFlowStyle:12 [Unexpected result in \"file.yaml\":\ndiff --git a/file.yaml b/file.yaml\nindex d20dfbb..d455fe4 100644\n--- a/file.yaml\n+++ b/file.yaml\n@@ -2,4 +2,5 @@ \n - name: test\n   plan:\n   - task: sonar\n-    vars: { version: 10.3 }\n\\ No newline at end of file\n+    vars: {\n+      version: 10.3 }\n\\ No newline at end of file\n] \nexpected: \n  \"jobs:\n  - name: test\n    plan:\n    - task: sonar\n      vars: { version: 10.3 }\"\n but was: \n  \"jobs:\n  - name: test\n    plan:\n    - task: sonar\n      vars: {\n        version: 10.3 }\"\n```\n\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\n",
    "issue_word_count": 348,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/format/MinimumViableSpacingVisitor.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "base_commit": "6f8e2ed66f33d08727d5d6cb0eb5ad0e621aa005",
    "head_commit": "aa880cecaeb81fb323bf734519c6d0780427bc2d",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4981",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4981",
    "dockerfile": "",
    "pr_merged_at": "2025-02-04T21:22:01.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/format/MinimumViableSpacingVisitor.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/format/MinimumViableSpacingVisitor.java\nindex cbd3ab9e783..1fa29c5ead9 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/format/MinimumViableSpacingVisitor.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/format/MinimumViableSpacingVisitor.java\n@@ -44,6 +44,10 @@ public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, P p) {\n                     return e;\n                 }\n             }\n+\n+            if (\" \".equals(e.getPrefix())) {\n+                return e;\n+            }\n             return e.withPrefix(\"\\n\");\n         }\n         return e;\n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\nindex e483900df12..e3bf95a40d4 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n@@ -1685,7 +1685,108 @@ void addFoldedStyleMinusBlock() {\n                   script: >-\n                     #!/bin/bash\n                     echo \"hello\"\n-              \"\"\")\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4958\")\n+    @Test\n+    void preserveSpacingWhenMergingFlowStyle() {\n+        rewriteRun(spec -> spec\n+            .recipe(new MergeYaml(//language=jsonpath\n+              \"$.jobs[?(@.name=='test')].plan[?(@.task=='sonar')]\",\n+              // language=yaml\n+              \"vars: { version: 10.3 }\",\n+              false,\n+              null,\n+              null\n+            )),\n+\n+          yaml(// language=yaml\n+            \"\"\"\n+              jobs:\n+              - name: test\n+                plan:\n+                - task: sonar\n+              \"\"\",\n+            // language=yaml\n+            \"\"\"\n+              jobs:\n+              - name: test\n+                plan:\n+                - task: sonar\n+                  vars: { version: 10.3 }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4958\")\n+    @Test\n+    void preserveSpacingWhenMergingFlowStyleNested() {\n+        rewriteRun(spec -> spec\n+            .recipe(new MergeYaml(//language=jsonpath\n+              \"$.jobs[?(@.name=='test')].plan[?(@.task=='sonar')]\",\n+              // language=yaml\n+              \"vars: { mapping: { version: 10.3 } }\",\n+              false,\n+              null,\n+              null\n+            )),\n+\n+          yaml(// language=yaml\n+            \"\"\"\n+              jobs:\n+              - name: test\n+                plan:\n+                - task: sonar\n+              \"\"\",\n+            // language=yaml\n+            \"\"\"\n+              jobs:\n+              - name: test\n+                plan:\n+                - task: sonar\n+                  vars: { mapping: { version: 10.3 } }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4958\")\n+    @Test\n+    void preserveSpacingWhenMergingFlowStyleWithNewline() {\n+        rewriteRun(spec -> spec\n+            .recipe(new MergeYaml(//language=jsonpath\n+              \"$.jobs[?(@.name=='test')].plan[?(@.task=='sonar')]\",\n+              // language=yaml\n+              \"\"\"\n+                vars: {\n+                  version: 10.3 }\n+                \"\"\",\n+              false,\n+              null,\n+              null\n+            )),\n+\n+          yaml(// language=yaml\n+            \"\"\"\n+              jobs:\n+              - name: test\n+                plan:\n+                - task: sonar\n+              \"\"\",\n+            // language=yaml\n+            \"\"\"\n+              jobs:\n+              - name: test\n+                plan:\n+                - task: sonar\n+                  vars: {\n+                    version: 10.3 }\n+              \"\"\"\n+          )\n         );\n     }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4960",
    "pr_id": 4960,
    "issue_id": 4959,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Parsing Failure with mutliple switch statements\n## What version of OpenRewrite are you using?\nlatest\n\n## What is the smallest, simplest way to reproduce the problem?\nThis [pr](https://github.com/openrewrite/rewrite/pull/4661) introduced a bug which caused source files with multiple switch statements to fail with ParserFailure.\n\n### Issue\nPreviously, `node.getExpressions().isEmpty()` returned true for the `default` case. However, the recent PR changed it to `node.getLabels().isEmpty()`, which incorrectly returned false for the `default` case. As a result, the `sourceBefore(\"case\")` method was mistakenly invoked. This issue only caused a failure if another `case` keyword existed after the current cursor position. If no `case` keyword followed the cursor, sourceBefore defaulted to returning EMPTY, and everything worked correctly.\n```\n  class A {\n      void test(int i) {\n          switch (i) {\n              case 1:\n                  System.out.println(\"1\");\n              default:\n                  throw new IllegalStateException(\"Unexpected value: \" + i);\n          }\n          switch (i) {\n              case 1:\n                  System.out.println(\"1\");\n              default:\n                  throw new IllegalStateException(\"Unexpected value: \" + i);\n          }\n      }\n  }\n```\n\n\n\n## What is the full stack trace of any errors you encountered?\n```\n\"java.lang.NullPointerException: Cannot invoke \"\"String.equals(Object)\"\" because the return value of \"\"org.openrewrite.java.tree.J$Identifier.getSimpleName()\"\" is null\n  org.openrewrite.java.JavaPrinter.visitCase(JavaPrinter.java:488)\n  org.openrewrite.java.JavaPrinter.visitCase(JavaPrinter.java:35)\n  org.openrewrite.java.tree.J$Case.acceptJava(J.java:1118)\n  org.openrewrite.java.tree.J.accept(J.java:58)\n  org.openrewrite.TreeVisitor.visit(TreeVisitor.java:250)\n  org.openrewrite.java.JavaPrinter.visitStatement(JavaPrinter.java:403)\n  org.openrewrite.java.JavaPrinter.visitStatements(JavaPrinter.java:394)\n  org.openrewrite.java.JavaPrinter.visitBlock(JavaPrinter.java:385)\n  org.openrewrite.java.JavaPrinter.visitBlock(JavaPrinter.java:35)\n  org.openrewrite.java.tree.J$Block.acceptJava(J.java:837)\n  org.openrewrite.java.tree.J.accept(J.java:58)\n  org.openrewrite.TreeVisitor.visit(TreeVisitor.java:250)\n  org.openrewrite.java.JavaPrinter.visitSwitch(JavaPrinter.java:1028)\n  org.openrewrite.java.JavaPrinter.visitSwitch(JavaPrinter.java:35)\n  org.openrewrite.java.tree.J$Switch.acceptJava(J.java:5167)\n  org.openrewrite.java.tree.J.accept(J.java:58)\n  ...\"\n\n```\n\n## Are you interested in [contributing a fix to OpenRewrite\nYes",
    "issue_word_count": 333,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java"
    ],
    "base_commit": "8d7bd6d3c7629f1f802dcc298b3e2c5bf716713a",
    "head_commit": "bc6b4626a0b0a890dfd52292052bdf07947bca5e",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4960",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4960",
    "dockerfile": "",
    "pr_merged_at": "2025-01-28T09:20:29.000Z",
    "patch": "diff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex ab732ee9579..7160952db91 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -350,7 +350,8 @@ public J visitCase(CaseTree node, Space fmt) {\n                 null,\n                 null,\n                 JContainer.build(\n-                        node.getLabels().isEmpty() ? EMPTY : sourceBefore(\"case\"),\n+                        node.getLabels().isEmpty() || node.getLabels().getFirst() instanceof DefaultCaseLabelTree ?\n+                                EMPTY : sourceBefore(\"case\"),\n                         node.getLabels().isEmpty() || node.getLabels().getFirst() instanceof DefaultCaseLabelTree ?\n                                 List.of(JRightPadded.build(new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), skip(\"default\"), null, null))) :\n                                 convertAll(node.getLabels(), commaDelim, ignored -> node.getGuard() != null ? sourceBefore(\"when\", '-') : EMPTY),\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\nindex 25a75622a02..72f78674a8a 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\n@@ -373,4 +373,30 @@ void filterArtifacts() {\n         assertThat(JavaParser.filterArtifacts(\"rewrite-java\", classpath))\n           .containsOnly(Paths.get(\"/.m2/repository/org/openrewrite/rewrite-java/8.41.1/rewrite-java-8.41.1.jar\"));\n     }\n+\n+    @Test\n+    void multipleSwitchStatements() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              class A {\n+                  void test(int i) {\n+                      switch (i) {\n+                          case 1:\n+                              System.out.println(\"1\");\n+                          default:\n+                              throw new IllegalStateException(\"Unexpected value: \" + i);\n+                      }\n+                      switch (i) {\n+                          case 1:\n+                              System.out.println(\"1\");\n+                          default:\n+                              throw new IllegalStateException(\"Unexpected value: \" + i);\n+                      }\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4939",
    "pr_id": 4939,
    "issue_id": 4634,
    "repo": "openrewrite/rewrite",
    "problem_statement": "`ReplaceAnnotation` fails when there is a `@Nullable` parameter in a Java `record` or `enum` definition\nHi,\n\nI'm getting the exception below when appling `org.openrewrite.java.ReplaceAnnotation` to a java record with a @Nullable parameter:\n```* What went wrong:\nExecution failed for task ':rewriteRun'.\n&gt; java.lang.RuntimeException: Error while visiting src/main/java/com/desantisernesto/openrewrite/SimpleProject/nullable/RecordNullableParam.java: java.lang.IllegalStateException: Unable to parse annotation from template: \n  @org.checkerframework.checker.nullness.qual.Nullable\n  Use JavaTemplate.Builder.doBeforeParseTemplate() to see what stub is being generated and include it in any bug report.\n  ```\nFull log, recipe a record source code in the comments.\nIs it a recipe bug? Should I file an issue for it?\n\n[Slack Message](https://rewriteoss.slack.com/archives/C01A843MWG5/p1730321504441069?thread_ts=1730321504.441069&cid=C01A843MWG5)",
    "issue_word_count": 130,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateAnnotationTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/internal/template/AnnotationTemplateGenerator.java",
      "rewrite-java/src/test/java/org/openrewrite/java/ReplaceAnnotationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateAnnotationTest.java",
      "rewrite-java/src/test/java/org/openrewrite/java/ReplaceAnnotationTest.java"
    ],
    "base_commit": "5c55f077a229fbc811abef104e0be689f247b73f",
    "head_commit": "b45700a3ceb1328bb4d0f754ff7cbd120d6cbc6a",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4939",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4939",
    "dockerfile": "",
    "pr_merged_at": "2025-05-31T14:25:56.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/internal/template/AnnotationTemplateGenerator.java b/rewrite-java/src/main/java/org/openrewrite/java/internal/template/AnnotationTemplateGenerator.java\nindex 631c1fe8c4f..2724f248b82 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/internal/template/AnnotationTemplateGenerator.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/internal/template/AnnotationTemplateGenerator.java\n@@ -230,7 +230,11 @@ private void classDeclaration(StringBuilder before, StringBuilder after, J.Class\n                 }\n             }\n         }\n-        c = c.withBody(J.Block.createEmptyBlock()).withLeadingAnnotations(null).withPrefix(Space.EMPTY);\n+        c = c.withBody(J.Block.createEmptyBlock())\n+                .withLeadingAnnotations(null)\n+                .withPrefix(Space.EMPTY)\n+                .withKind(J.ClassDeclaration.Kind.Type.Class)\n+                .withPrimaryConstructor(null);\n         String printed = c.printTrimmed(cursor);\n         int braceIndex = printed.lastIndexOf('{');\n         if (annotated) {\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateAnnotationTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateAnnotationTest.java\nindex 5a618783ab6..75b0d39b72a 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateAnnotationTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateAnnotationTest.java\n@@ -18,6 +18,7 @@\n import org.junit.jupiter.api.Test;\n import org.openrewrite.DocumentExample;\n import org.openrewrite.ExecutionContext;\n+import org.openrewrite.Issue;\n import org.openrewrite.java.tree.J;\n import org.openrewrite.test.RewriteTest;\n \n@@ -117,4 +118,44 @@ class A {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4634\")\n+    @Test\n+    void replacesInRecordVisitor() {\n+        rewriteRun(\n+          spec -> spec.recipe(toRecipe(() -> new JavaIsoVisitor<>() {\n+              @Override\n+              public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext p) {\n+                  if (annotation.getSimpleName().equals(\"NotNull\")) {\n+                      maybeRemoveImport(\"org.jetbrains.annotations.NotNull\");\n+                      maybeAddImport(\"lombok.NonNull\");\n+                      return JavaTemplate.builder(\"@NonNull\")\n+                        .imports(\"lombok.NonNull\")\n+                        .javaParser(JavaParser.fromJavaVersion().classpath(\"lombok\"))\n+                        .build()\n+                        .apply(getCursor(), annotation.getCoordinates().replace());\n+                  }\n+                  return annotation;\n+              }\n+          })),\n+          java(\n+            \"\"\"\n+              import org.jetbrains.annotations.NotNull;\n+\n+              public record Person(\n+                  @NotNull String firstName,\n+                  @NotNull String lastName\n+              ) {}\n+              \"\"\",\n+            \"\"\"\n+              import lombok.NonNull;\n+\n+              public record Person(\n+                  @NonNull String firstName,\n+                  @NonNull String lastName\n+              ) {}\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-java/src/test/java/org/openrewrite/java/ReplaceAnnotationTest.java b/rewrite-java/src/test/java/org/openrewrite/java/ReplaceAnnotationTest.java\nindex 1ad0bda1e1c..914e3de808d 100644\n--- a/rewrite-java/src/test/java/org/openrewrite/java/ReplaceAnnotationTest.java\n+++ b/rewrite-java/src/test/java/org/openrewrite/java/ReplaceAnnotationTest.java\n@@ -37,7 +37,7 @@ void matchWithPrams() {\n               java(\n                 \"\"\"\n                   import org.jetbrains.annotations.NotNull;\n-                 \n+\n                   class A {\n                       @NotNull(\"Test\")\n                       String testMethod() {}\n@@ -45,7 +45,7 @@ String testMethod() {}\n                   \"\"\",\n                 \"\"\"\n                   import lombok.NonNull;\n-                  \n+\n                   class A {\n                       @NonNull\n                       String testMethod() {}\n@@ -54,6 +54,7 @@ String testMethod() {}\n               )\n             );\n         }\n+\n         @Test\n         void matchNoPrams() {\n             rewriteRun(\n@@ -61,7 +62,7 @@ void matchNoPrams() {\n               java(\n                 \"\"\"\n                   import org.jetbrains.annotations.NotNull;\n-                  \n+\n                   class A {\n                       @NotNull\n                       String testMethod() {}\n@@ -69,7 +70,7 @@ String testMethod() {}\n                   \"\"\",\n                 \"\"\"\n                   import lombok.NonNull;\n-                  \n+\n                   class A {\n                       @NonNull\n                       String testMethod() {}\n@@ -86,7 +87,7 @@ void insertWithParams() {\n               java(\n                 \"\"\"\n                   import lombok.NonNull;\n-                  \n+\n                   class A {\n                       @NonNull\n                       String testMethod() {}\n@@ -94,7 +95,7 @@ String testMethod() {}\n                   \"\"\",\n                 \"\"\"\n                   import org.jetbrains.annotations.NotNull;\n-                  \n+\n                   class A {\n                       @NotNull(\"Test\")\n                       String testMethod() {}\n@@ -113,7 +114,7 @@ void methodWithAnnotatedParameter() {\n                 \"\"\"\n                   import org.jetbrains.annotations.NotNull;\n                   import org.jetbrains.annotations.Nullable;\n-                  \n+\n                   class A {\n                       void methodName(\n                           @Nullable final boolean valueVar) {\n@@ -124,7 +125,7 @@ void methodName(\n                 \"\"\"\n                   import lombok.NonNull;\n                   import org.jetbrains.annotations.Nullable;\n-                  \n+\n                   class A {\n                       void methodName(\n                           @Nullable final boolean valueVar) {\n@@ -135,21 +136,39 @@ void methodName(\n               )\n             );\n         }\n-    }\n \n-    @Nested\n-    class NoMatch {\n         @Test\n-        void noMatchOtherType() {\n+        void enumWithParameter() {\n+\n             rewriteRun(\n-              spec -> spec.recipe(new ReplaceAnnotation(\"@org.jetbrains.annotations.NotNull\", \"@lombok.NonNull\", null)),\n+              spec -> spec.recipe(new ReplaceAnnotation(\"@lombok.NonNull\", \"@org.jetbrains.annotations.NotNull\", null)),\n               java(\n                 \"\"\"\n-                  import org.jetbrains.annotations.Nullable;\n-                  \n-                  class A {\n-                      @Nullable(\"Test\")\n-                      String testMethod() {}\n+                  import lombok.NonNull;\n+\n+                  public enum NullableRecipeValidationEnum {\n+                      INVALID(\"invalid\"),\n+                      CLICKED(\"clicked\");\n+\n+                      private final String value;\n+\n+                      NullableRecipeValidationEnum(@NonNull final String value){\n+                          this.value = value;\n+                      }\n+                  }\n+                  \"\"\",\n+                \"\"\"\n+                  import org.jetbrains.annotations.NotNull;\n+\n+                  public enum NullableRecipeValidationEnum {\n+                      INVALID(\"invalid\"),\n+                      CLICKED(\"clicked\");\n+\n+                      private final String value;\n+\n+                      NullableRecipeValidationEnum(@NotNull final String value){\n+                          this.value = value;\n+                      }\n                   }\n                   \"\"\"\n               )\n@@ -157,20 +176,88 @@ String testMethod() {}\n         }\n \n         @Test\n-        void noMatchParameter() {\n+        void recordWithAttibutesAnnotated() {\n             rewriteRun(\n-              spec -> spec.recipe(new ReplaceAnnotation(\"@org.jetbrains.annotations.NotNull(\\\"Test\\\")\", \"@lombok.NonNull\", null)),\n+              spec -> spec.recipe(new ReplaceAnnotation(\"@org.jetbrains.annotations.NotNull\", \"@lombok.NonNull\", null)),\n               java(\n                 \"\"\"\n-                  import org.jetbrains.annotations.Nullable;\n-                  \n-                  class A {\n-                      @Nullable(\"Other\")\n-                      String testMethod() {}\n+                  import org.jetbrains.annotations.NotNull;\n+\n+                  public record Person(\n+                      @NotNull String firstName,\n+                      @NotNull String lastName\n+                  ) {}\n+                  \"\"\",\n+                \"\"\"\n+                  import lombok.NonNull;\n+\n+                  public record Person(\n+                      @NonNull String firstName,\n+                      @NonNull String lastName\n+                  ) {}\n+                  \"\"\"\n+              ));\n+        }\n+\n+        @Test\n+        void attributesInClass() {\n+            rewriteRun(\n+              spec -> spec.recipe(new ReplaceAnnotation(\"@org.jetbrains.annotations.NotNull\", \"@lombok.NonNull\", null)),\n+              java(\n+                \"\"\"\n+                  import org.jetbrains.annotations.NotNull;\n+\n+                  public class Person {\n+                      @NotNull String firstName=\"\";\n+                      @NotNull String lastName=\"\";\n+                  }\n+                  \"\"\",\n+                \"\"\"\n+                  import lombok.NonNull;\n+\n+                  public class Person {\n+                      @NonNull String firstName=\"\";\n+                      @NonNull String lastName=\"\";\n                   }\n                   \"\"\"\n-              )\n-            );\n+              ));\n+        }\n+\n+        @Nested\n+        class NoMatch {\n+            @Test\n+            void noMatchOtherType() {\n+                rewriteRun(\n+                  spec -> spec.recipe(new ReplaceAnnotation(\"@org.jetbrains.annotations.NotNull\", \"@lombok.NonNull\", null)),\n+                  java(\n+                    \"\"\"\n+                      import org.jetbrains.annotations.Nullable;\n+                      \n+                      class A {\n+                          @Nullable(\"Test\")\n+                          String testMethod() {}\n+                      }\n+                      \"\"\"\n+                  )\n+                );\n+            }\n+\n+            @Test\n+            void noMatchParameter() {\n+                rewriteRun(\n+                  spec -> spec.recipe(new ReplaceAnnotation(\"@org.jetbrains.annotations.NotNull(\\\"Test\\\")\", \"@lombok.NonNull\", null)),\n+                  java(\n+                    \"\"\"\n+                      import org.jetbrains.annotations.Nullable;\n+                      \n+                      class A {\n+                          @Nullable(\"Other\")\n+                          String testMethod() {}\n+                      }\n+                      \"\"\"\n+                  )\n+                );\n+            }\n         }\n     }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4917",
    "pr_id": 4917,
    "issue_id": 509,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Accept YAML mapping values that start with '@' \nPermit Spring-style variables in YAML (not actually valid YAML by spec):\r\n\r\n```yaml\r\ndate: @build.timestamp@\r\nversion: @project.version@\r\n```\r\n\r\nA similar parsing issue has been reported to Spring in various places like https://github.com/spring-projects/spring-boot/issues/8438.",
    "issue_word_count": 48,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java"
    ],
    "base_commit": "b7746cf85bfa915bb68061a756f11273cfeae98d",
    "head_commit": "0890ccf5b1786c782c62c5e531fa9a2aae8e635b",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4917",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4917",
    "dockerfile": "",
    "pr_merged_at": "2025-01-17T10:07:26.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\nindex ca7685f37ba..deac37d20cd 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n@@ -52,7 +52,7 @@\n import static org.openrewrite.Tree.randomId;\n \n public class YamlParser implements org.openrewrite.Parser {\n-    private static final Pattern VARIABLE_PATTERN = Pattern.compile(\":\\\\s*(@[^\\n\\r@]+@)\");\n+    private static final Pattern VARIABLE_PATTERN = Pattern.compile(\":\\\\s+(@[^\\n\\r@]+@)\");\n \n     @Override\n     public Stream<SourceFile> parse(@Language(\"yml\") String... sources) {\n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\nindex e3033a4b827..7b8653cd68a 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\n@@ -216,4 +216,20 @@ void troublesomeYaml() {\n           )\n         );\n     }\n+\n+    @Test\n+    void atSymbols() {\n+        rewriteRun(\n+          yaml(\n+            // BTW, the @ sign is forbidden as the first character of a scalar value by the YAML spec:\n+            // https://github.com/yaml/yaml-spec/blob/1b1a1be43bd6e0cfec45caf0e40af3b5d2bb7f8a/spec/1.2.2/spec.md#L1877\n+            \"\"\"\n+              root:\n+                specifier: npm:@testing-library/vue@5.0.4\n+                date: @build.timestamp@\n+                version: @project.version@\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4905",
    "pr_id": 4905,
    "issue_id": 4902,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ChangePluginGroupIdAndArtifactId does not allow for updating maven plugin versions\n## What problem are you trying to solve?\r\n`ChangePluginGroupIdAndArtifactId` does not let  you update the plugin's `version`.\r\n\r\n[ChangePluginGroupIdAndArtifactId](https://docs.openrewrite.org/recipes/maven/changeplugingroupidandartifactid) allows one to update a maven **plugin** to reflect new:\r\n1. GroupId\r\n2. ArtifactId\r\n\r\nA similar very similar recipe, [ChangeDependencyGroupIdAndArtifactId](https://docs.openrewrite.org/recipes/maven/changedependencygroupidandartifactid), allows one to update a maven **dependency** to reflect new:\r\n1. GroupId\r\n2. ArtifactId\r\n3. **Version**\r\n\r\n## Describe the solution you'd like\r\nI think `ChangePluginGroupIdAndArtifactId` should be brought into closer alignment with `ChangeDependencyGroupIdAndArtifactId` to also support changing a plugin `version`.\r\n\r\n## Have you considered any alternatives or workarounds?\r\nI've checked the other recipes in the [rewrite-maven module](https://github.com/openrewrite/rewrite/tree/main/rewrite-maven) and found no suitable alternative solution.\r\n\r\n## Additional context\r\nAn example of the desired before/after change from this feature might look like this:\r\n\r\n**BEFORE**\r\n```xml\r\n<build>\r\n    <plugins>\r\n        <plugin>\r\n            <groupId>org.jvnet.jaxb2.maven2</groupId>\r\n            <artifactId>maven-jaxb2-plugin</artifactId>\r\n            <version>0.14.0</version>\r\n            <executions>\r\n                <execution>\r\n                    <goals>\r\n                        <goal>generate</goal>\r\n                    </goals>\r\n                </execution>\r\n            </executions>\r\n        </plugin>\r\n    </plugins>\r\n</build>\r\n```\r\n\r\n**AFTER**\r\n```xml\r\n<build>\r\n    <plugins>\r\n        <plugin>\r\n            <groupId>org.jvnet.jaxb</groupId>\r\n            <artifactId>jaxb-maven-plugin</artifactId>\r\n            <version>4.0.8</version>\r\n            <executions>\r\n                <execution>\r\n                    <goals>\r\n                        <goal>generate</goal>\r\n                    </goals>\r\n                </execution>\r\n            </executions>\r\n        </plugin>\r\n    </plugins>\r\n</build>\r\n```\r\n\r\n## Are you interested in [contributing this feature to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#new-features)?\r\nYes, I can offer to open a pull request to add the functionality.  I would like to know from the group if there is consensus we should have this feature.  I may also need design feedback to minimize turn-around-time on the PR.",
    "issue_word_count": 280,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java"
    ],
    "base_commit": "2586748a25b90b3d7f272a8f06bf80ea4628550e",
    "head_commit": "b82ca5d6f7fb0efc6894ab6c43174ab58b4988c2",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4905",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4905",
    "dockerfile": "",
    "pr_merged_at": "2025-01-16T09:59:23.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\nindex ba633f1dd9e..3ca0e66448e 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\n@@ -58,17 +58,12 @@ public class ChangePluginGroupIdAndArtifactId extends Recipe {\n     @Nullable\n     String newArtifactId;\n \n-    /**\n-     * Mistakenly introduced, we restored newArtifactId but let's not break recipes abruptly.\n-     */\n-    @Option(displayName = \"New artifact ID\",\n-        description = \"The new artifact ID to use. Defaults to the existing artifact ID. This property is deprecated, use newArtifactId instead.\",\n-        example = \"my-new-maven-plugin\",\n-        required = false)\n+    @Option(displayName = \"New version\",\n+            description = \"An exact version number or node-style semver selector used to select the version number.\",\n+            example = \"29.X\",\n+            required = false)\n     @Nullable\n-    @Deprecated\n-    @SuppressWarnings(\"DeprecatedIsStillUsed\")\n-    String newArtifact;\n+    String newVersion;\n \n     @Override\n     public String getDisplayName() {\n@@ -82,7 +77,7 @@ public String getInstanceNameSuffix() {\n \n     @Override\n     public String getDescription() {\n-        return \"Change the groupId and/or the artifactId of a specified Maven plugin.\";\n+        return \"Change the groupId and/or the artifactId of a specified Maven plugin. Optionally update the plugin version.\";\n     }\n \n     @Override\n@@ -98,8 +93,9 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                     }\n                     if (newArtifactId != null) {\n                         t = changeChildTagValue(t, \"artifactId\", newArtifactId, ctx);\n-                    } else if (newArtifact != null) {\n-                        t = changeChildTagValue(t, \"artifactId\", newArtifact, ctx);\n+                    }\n+                    if (newVersion != null) {\n+                        t = changeChildTagValue(t, \"version\", newVersion, ctx);\n                     }\n                     if (t != tag) {\n                         maybeUpdateModel();\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java\nindex 55147edecf3..1de416271d6 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java\n@@ -103,14 +103,14 @@ void changePluginGroupIdAndArtifactId() {\n \n     @DocumentExample\n     @Test\n-    void changePluginGroupIdAndArtifactIdDeprecatedNewArtifact() {\n+    void changePluginGroupIdAndArtifactIdWithVersion() {\n         rewriteRun(\n           spec -> spec.recipe(new ChangePluginGroupIdAndArtifactId(\n             \"io.quarkus\",\n             \"quarkus-bootstrap-maven-plugin\",\n             null,\n-            null,\n-            \"quarkus-extension-maven-plugin\"\n+            \"quarkus-extension-maven-plugin\",\n+            \"4.0.0\"\n           )),\n           pomXml(\n             \"\"\"\n@@ -128,6 +128,55 @@ void changePluginGroupIdAndArtifactIdDeprecatedNewArtifact() {\n                           </plugin>\n                       </plugins>\n                   </build>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <build>\n+                      <plugins>\n+                          <plugin>\n+                              <groupId>io.quarkus</groupId>\n+                              <artifactId>quarkus-extension-maven-plugin</artifactId>\n+                              <version>4.0.0</version>\n+                          </plugin>\n+                      </plugins>\n+                  </build>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void changePluginGroupIdAndArtifactIdNoChange() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePluginGroupIdAndArtifactId(\n+            \"io.quarkus\",\n+            \"quarkus-bootstrap-maven-plugin\",\n+            null,\n+            \"quarkus-extension-maven-plugin\",\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <build>\n+                      <plugins>\n+                          <plugin>\n+                              <groupId>io.quarkus</groupId>\n+                              <artifactId>quarkus-extension-maven-plugin</artifactId>\n+                              <version>3.0.0.Beta1</version>\n+                          </plugin>\n+                      </plugins>\n+                  </build>\n                   <profiles>\n                       <profile>\n                           <id>profile</id>\n@@ -135,7 +184,7 @@ void changePluginGroupIdAndArtifactIdDeprecatedNewArtifact() {\n                               <plugins>\n                                   <plugin>\n                                       <groupId>io.quarkus</groupId>\n-                                      <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n+                                      <artifactId>quarkus-extension-maven-plugin</artifactId>\n                                       <version>3.0.0.Beta1</version>\n                                   </plugin>\n                               </plugins>\n@@ -143,7 +192,22 @@ void changePluginGroupIdAndArtifactIdDeprecatedNewArtifact() {\n                       </profile>\n                   </profiles>\n               </project>\n-              \"\"\",\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void changePluginGroupIdAndArtifactIdNoChangeWithVersion() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePluginGroupIdAndArtifactId(\n+            \"io.quarkus\",\n+            \"quarkus-bootstrap-maven-plugin\",\n+            null,\n+            \"quarkus-extension-maven-plugin\",\n+            \"4.0.0\"\n+          )),\n+          pomXml(\n             \"\"\"\n               <project>\n                   <modelVersion>4.0.0</modelVersion>\n@@ -180,7 +244,7 @@ void changePluginGroupIdAndArtifactIdDeprecatedNewArtifact() {\n     }\n \n     @Test\n-    void changePluginGroupIdAndArtifactIdNoChange() {\n+    void changeManagedPluginGroupIdAndArtifactId() {\n         rewriteRun(\n           spec -> spec.recipe(new ChangePluginGroupIdAndArtifactId(\n             \"io.quarkus\",\n@@ -197,6 +261,63 @@ void changePluginGroupIdAndArtifactIdNoChange() {\n                   <artifactId>my-app</artifactId>\n                   <version>1</version>\n                   <build>\n+                      <pluginManagement>\n+                          <plugins>\n+                              <plugin>\n+                                  <groupId>io.quarkus</groupId>\n+                                  <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n+                                  <version>3.0.0.Beta1</version>\n+                              </plugin>\n+                          </plugins>\n+                      </pluginManagement>\n+                      <plugins>\n+                          <plugin>\n+                              <groupId>io.quarkus</groupId>\n+                              <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n+                              <version>3.0.0.Beta1</version>\n+                          </plugin>\n+                      </plugins>\n+                  </build>\n+                  <profiles>\n+                      <profile>\n+                          <id>profile</id>\n+                          <build>\n+                              <pluginManagement>\n+                                  <plugins>\n+                                      <plugin>\n+                                          <groupId>io.quarkus</groupId>\n+                                          <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n+                                          <version>3.0.0.Beta1</version>\n+                                      </plugin>\n+                                  </plugins>\n+                              </pluginManagement>\n+                              <plugins>\n+                                  <plugin>\n+                                      <groupId>io.quarkus</groupId>\n+                                      <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n+                                  </plugin>\n+                              </plugins>\n+                          </build>\n+                      </profile>\n+                  </profiles>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <build>\n+                      <pluginManagement>\n+                          <plugins>\n+                              <plugin>\n+                                  <groupId>io.quarkus</groupId>\n+                                  <artifactId>quarkus-extension-maven-plugin</artifactId>\n+                                  <version>3.0.0.Beta1</version>\n+                              </plugin>\n+                          </plugins>\n+                      </pluginManagement>\n                       <plugins>\n                           <plugin>\n                               <groupId>io.quarkus</groupId>\n@@ -209,11 +330,19 @@ void changePluginGroupIdAndArtifactIdNoChange() {\n                       <profile>\n                           <id>profile</id>\n                           <build>\n+                              <pluginManagement>\n+                                  <plugins>\n+                                      <plugin>\n+                                          <groupId>io.quarkus</groupId>\n+                                          <artifactId>quarkus-extension-maven-plugin</artifactId>\n+                                          <version>3.0.0.Beta1</version>\n+                                      </plugin>\n+                                  </plugins>\n+                              </pluginManagement>\n                               <plugins>\n                                   <plugin>\n                                       <groupId>io.quarkus</groupId>\n                                       <artifactId>quarkus-extension-maven-plugin</artifactId>\n-                                      <version>3.0.0.Beta1</version>\n                                   </plugin>\n                               </plugins>\n                           </build>\n@@ -226,14 +355,14 @@ void changePluginGroupIdAndArtifactIdNoChange() {\n     }\n \n     @Test\n-    void changeManagedPluginGroupIdAndArtifactId() {\n+    void changeManagedPluginGroupIdAndArtifactIdWithVersion() {\n         rewriteRun(\n           spec -> spec.recipe(new ChangePluginGroupIdAndArtifactId(\n             \"io.quarkus\",\n             \"quarkus-bootstrap-maven-plugin\",\n             null,\n             \"quarkus-extension-maven-plugin\",\n-            null\n+            \"4.0.0\"\n           )),\n           pomXml(\n             \"\"\"\n@@ -284,6 +413,69 @@ void changeManagedPluginGroupIdAndArtifactId() {\n                   </profiles>\n               </project>\n               \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <build>\n+                      <pluginManagement>\n+                          <plugins>\n+                              <plugin>\n+                                  <groupId>io.quarkus</groupId>\n+                                  <artifactId>quarkus-extension-maven-plugin</artifactId>\n+                                  <version>4.0.0</version>\n+                              </plugin>\n+                          </plugins>\n+                      </pluginManagement>\n+                      <plugins>\n+                          <plugin>\n+                              <groupId>io.quarkus</groupId>\n+                              <artifactId>quarkus-extension-maven-plugin</artifactId>\n+                              <version>4.0.0</version>\n+                          </plugin>\n+                      </plugins>\n+                  </build>\n+                  <profiles>\n+                      <profile>\n+                          <id>profile</id>\n+                          <build>\n+                              <pluginManagement>\n+                                  <plugins>\n+                                      <plugin>\n+                                          <groupId>io.quarkus</groupId>\n+                                          <artifactId>quarkus-extension-maven-plugin</artifactId>\n+                                          <version>4.0.0</version>\n+                                      </plugin>\n+                                  </plugins>\n+                              </pluginManagement>\n+                              <plugins>\n+                                  <plugin>\n+                                      <groupId>io.quarkus</groupId>\n+                                      <artifactId>quarkus-extension-maven-plugin</artifactId>\n+                                  </plugin>\n+                              </plugins>\n+                          </build>\n+                      </profile>\n+                  </profiles>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void changeManagedPluginGroupIdAndArtifactIdNoChange() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePluginGroupIdAndArtifactId(\n+            \"io.quarkus\",\n+            \"quarkus-bootstrap-maven-plugin\",\n+            null,\n+            \"quarkus-extension-maven-plugin\",\n+            null\n+          )),\n+          pomXml(\n             \"\"\"\n               <project>\n                   <modelVersion>4.0.0</modelVersion>\n@@ -337,14 +529,14 @@ void changeManagedPluginGroupIdAndArtifactId() {\n     }\n \n     @Test\n-    void changeManagedPluginGroupIdAndArtifactIdNoChange() {\n+    void changeManagedPluginGroupIdAndArtifactIdNoChangeWithVersion() {\n         rewriteRun(\n           spec -> spec.recipe(new ChangePluginGroupIdAndArtifactId(\n             \"io.quarkus\",\n             \"quarkus-bootstrap-maven-plugin\",\n             null,\n             \"quarkus-extension-maven-plugin\",\n-            null\n+            \"4.0.0\"\n           )),\n           pomXml(\n             \"\"\"\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4898",
    "pr_id": 4898,
    "issue_id": 4897,
    "repo": "openrewrite/rewrite",
    "problem_statement": "AddOrUpdateAnnotationAttribute unable to handle @Anno(key = ClassB.staticVar)\n## What version of OpenRewrite are you using?\r\nI am using\r\n\r\n- OpenRewrite 8.42.0\r\n- Mavenplugin 5.47.0\r\n\r\n## How are you running OpenRewrite?\r\n\r\nUnit Test, maven plugin\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n\r\n```java\r\n              package com.example;\r\n\r\n              public class Const {\r\n                    public static final String PATH = \"path\";\r\n              }\r\n```\r\n\r\n```java\r\n              import jakarta.ws.rs.Path;\r\n              import com.example.Const;\r\n              \r\n              @Path(value = Const.PATH)\r\n              public class Example {\r\n                  private void methodName() { }\r\n              }\r\n```\r\n\r\n```yaml\r\n  - org.openrewrite.java.AddOrUpdateAnnotationAttribute:\r\n      annotationType: jakarta.ws.rs.Path\r\n      attributeName: value\r\n      attributeValue: \"UnnamedTag\"\r\n      addOnly: false\r\n      appendArray: false\r\n```\r\n\r\n## What did you expect to see?\r\n\r\nNo errors.\r\n\r\n## What did you see instead?\r\n\r\n`Failed to parse sources or run recipe`\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n```\r\nCaused by: java.lang.ClassCastException: class org.openrewrite.java.tree.J$FieldAccess cannot be cast to class org.openrewrite.java.tree.J$Literal (org.openrewrite.java.tree.J$FieldAccess and org.openrewrite.java.tree.J$Literal are in unnamed module of loader 'app')\r\n\tat org.openrewrite.java.AddOrUpdateAnnotationAttribute$1.lambda$visitAnnotation$2(AddOrUpdateAnnotationAttribute.java:189)\r\n\tat org.openrewrite.internal.ListUtils.map(ListUtils.java:243)\r\n\tat org.openrewrite.internal.ListUtils.map(ListUtils.java:265)\r\n\tat org.openrewrite.java.AddOrUpdateAnnotationAttribute$1.visitAnnotation(AddOrUpdateAnnotationAttribute.java:123)\r\n\tat org.openrewrite.java.AddOrUpdateAnnotationAttribute$1.visitAnnotation(AddOrUpdateAnnotationAttribute.java:85)\r\n\tat org.openrewrite.java.tree.J$Annotation.acceptJava(J.java:233)\r\n\tat org.openrewrite.java.tree.J.accept(J.java:59)\r\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:250)\r\n\t... 44 more\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite]\r\nYes, I am trying to make a fix\r\n",
    "issue_word_count": 268,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java"
    ],
    "base_commit": "2586748a25b90b3d7f272a8f06bf80ea4628550e",
    "head_commit": "d4bbc030b3c2c54e2e09d4088656c39c010f1e95",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4898",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4898",
    "dockerfile": "",
    "pr_merged_at": "2025-01-16T10:20:36.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java b/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java\nindex 38cb78f8d66..2f7a8858857 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java\n@@ -23,7 +23,10 @@\n import org.openrewrite.*;\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.java.search.UsesType;\n-import org.openrewrite.java.tree.*;\n+import org.openrewrite.java.tree.Expression;\n+import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaType;\n+import org.openrewrite.java.tree.TypeUtils;\n import org.openrewrite.marker.Marker;\n import org.openrewrite.marker.Markers;\n \n@@ -208,14 +211,24 @@ public J.Annotation visitAnnotation(J.Annotation a, ExecutionContext ctx) {\n \n                                 return as.withAssignment(((J.NewArray) as.getAssignment()).withInitializer(jLiteralList));\n                             } else {\n-                                J.Literal value = (J.Literal) as.getAssignment();\n-                                if (newAttributeValue.equals(value.getValueSource()) || Boolean.TRUE.equals(addOnly)) {\n-                                    return it;\n-                                }\n-                                if (!valueMatches(value, oldAttributeValue)) {\n-                                    return it;\n+                                Expression exp = as.getAssignment();\n+                                if (exp instanceof J.Literal) {\n+                                    J.Literal value = (J.Literal) exp;\n+                                    if (newAttributeValue.equals(value.getValueSource()) || Boolean.TRUE.equals(addOnly)) {\n+                                        return it;\n+                                    }\n+                                    if (!valueMatches(value, oldAttributeValue)) {\n+                                        return it;\n+                                    }\n+                                    return as.withAssignment(value.withValue(newAttributeValue).withValueSource(newAttributeValue));\n+                                } else if (exp instanceof J.FieldAccess) {\n+                                    if (Boolean.TRUE.equals(addOnly)) {\n+                                        return it;\n+                                    }\n+                                    int index = finalA.getArguments().indexOf(as);\n+                                    as = (J.Assignment) ((J.Annotation) JavaTemplate.apply(\"#{} = #{}\", getCursor(), as.getCoordinates().replace(), var.getSimpleName(), newAttributeValue)).getArguments().get(index);\n+                                    return as;\n                                 }\n-                                return as.withAssignment(value.withValue(newAttributeValue).withValueSource(newAttributeValue));\n                             }\n                         } else if (it instanceof J.Literal) {\n                             // The only way anything except an assignment can appear is if there's an implicit assignment to \"value\"\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java\nindex fc520e7f8ab..fa9c34deb28 100755\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java\n@@ -907,6 +907,47 @@ public class A {\n         );\n     }\n \n+    @Test\n+    void updateFieldAccessAttribute() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", \"value\", \"hello\", null, false, null)),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              \n+              public class Const {\n+                    public static final String HI = \"hi\";\n+              }\n+              \"\"\"),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              public @interface Foo {\n+                  String value() default \"\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import org.example.Foo;\n+              import org.example.Const;\n+              \n+              @Foo(value = Const.HI)\n+              public class A {\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import org.example.Foo;\n+              import org.example.Const;\n+              \n+              @Foo(value = \"hello\")\n+              public class A {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void addAttributeToNestedAnnotationArray() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4892",
    "pr_id": 4892,
    "issue_id": 4890,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Toml ClassCastException\n## What version of OpenRewrite are you using?\r\n- OpenRewrite v6.0.0\r\n- Maven/Gradle plugin v7.0.0\r\n- rewrite-spring v6.0.0\r\n\r\n## How are you running OpenRewrite?\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nI am using the Gradle plugin, and my project is a single module project.\r\nI am using toml files for managing dependency versions, with [bundles] tag.\r\n\r\nIs your project a single module or a multi-module project?\r\nThe project is a single module\r\n\r\nIs your project public? If so, can you share a link to it?\r\nManaged to reproduce the bug, in this project: [https://github.com/jarasez/openrewrite-toml](https://github.com/jarasez/openrewrite-toml)\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\nlibs.versions.toml\r\n```toml\r\n[versions]\r\njackson = '2.14.2'\r\n\r\nspring-boot = '2.7.16'\r\nspring-dependency-management = '1.0.14.RELEASE'\r\nopenrewrite = '7.0.0'\r\n\r\n[libraries]\r\njackson-annotations = { module = 'com.fasterxml.jackson.core:jackson-annotations', version.ref = 'jackson' }\r\njackson-core = { module = 'com.fasterxml.jackson.core:jackson-core', version.ref = 'jackson' }\r\njackson-databind = { module = 'com.fasterxml.jackson.core:jackson-databind', version.ref = 'jackson' }\r\n\r\n[bundles]\r\njackson = ['jackson-annotations', 'jackson-core', 'jackson-databind']\r\n\r\n[plugins]\r\nspring-boot = { id = 'org.springframework.boot', version.ref = 'spring-boot' }\r\nspring-boot-dependency-management = { id = 'io.spring.dependency-management', version.ref = 'spring-dependency-management' }\r\nopenrewrite = { id = 'org.openrewrite.rewrite', version.ref = 'openrewrite' }\r\n```\r\n\r\nbuild.gradle\r\n```groovy\r\nplugins {\r\n    id 'java'\r\n    alias(libs.plugins.spring.boot)\r\n    alias(libs.plugins.spring.boot.dependency.management)\r\n    alias(libs.plugins.openrewrite)\r\n}\r\n\r\ngroup = 'test.openrewrite'\r\nversion = '0.0.1-SNAPSHOT'\r\n\r\njava {\r\n    toolchain {\r\n        languageVersion = JavaLanguageVersion.of(17)\r\n    }\r\n}\r\n\r\nrepositories {\r\n    mavenCentral()\r\n}\r\n\r\ndependencies {\r\n    implementation 'org.springframework.boot:spring-boot-starter'\r\n    implementation libs.bundles.jackson\r\n\r\n    rewrite(\"org.openrewrite.recipe:rewrite-spring:6.0.0\")\r\n\r\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\r\n    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'\r\n}\r\n\r\ntasks.named('test') {\r\n    useJUnitPlatform()\r\n}\r\n\r\nrewrite {\r\n    activeRecipe(\"org.openrewrite.java.spring.boot3.UpgradeSpringBoot_3_3\")\r\n//    activeRecipe(\"org.openrewrite.java.spring.boot3.SpringBootProperties_3_3\")\r\n//    activeRecipe(\"org.openrewrite.java.spring.boot3.MigrateThymeleafDependencies\")\r\n//    activeRecipe(\"org.openrewrite.java.spring.boot3.ActuatorEndpointSanitization\")\r\n//    activeRecipe(\"org.openrewrite.java.spring.boot3.SpringBoot3BestPractices\")\r\n\r\n    setExportDatatables(true)\r\n}\r\n```\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\nRun gradle task rewriteRun.\r\n\r\n## What did you expect to see?\r\nSuccessful execution of the gradle task rewriteRun. It seems that the [bundles] section of the toml causes the exception bellow.\r\n\r\n## What did you see instead?\r\nThe gradle task rewriteRun fails.\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n```\r\nCaused by: org.openrewrite.internal.RecipeRunException: java.lang.ClassCastException: class org.openrewrite.toml.tree.Toml$Literal cannot be cast to class org.openrewrite.toml.tree.TomlValue (org.openrewrite.toml.tree.Toml$Literal and org.openrewrite.toml.tree.TomlValue are in unnamed module of loader org.openrewrite.gradle.RewriteClassLoader @41666a7d)\r\n        at org.openrewrite.TreeVisitor.visit(TreeVisitor.java:290)\r\n        at org.openrewrite.toml.TomlVisitor.visitKeyValue(TomlVisitor.java:73)\r\n        at org.openrewrite.toml.tree.Toml$KeyValue.acceptToml(Toml.java:228)\r\n        at org.openrewrite.toml.tree.Toml.accept(Toml.java:37)\r\n        at org.openrewrite.TreeVisitor.visit(TreeVisitor.java:250)\r\n        at org.openrewrite.toml.TomlVisitor.lambda$visitTable$2(TomlVisitor.java:92)\r\n        at org.openrewrite.internal.ListUtils.map(ListUtils.java:243)\r\n        at org.openrewrite.internal.ListUtils.map(ListUtils.java:265)\r\n        at org.openrewrite.toml.TomlVisitor.visitTable(TomlVisitor.java:92)\r\n        at org.openrewrite.toml.tree.Toml$Table.acceptToml(Toml.java:327)\r\n        at org.openrewrite.toml.tree.Toml.accept(Toml.java:37)\r\n        at org.openrewrite.TreeVisitor.visit(TreeVisitor.java:250)\r\n        at org.openrewrite.toml.TomlVisitor.lambda$visitTable$2(TomlVisitor.java:92)\r\n        at org.openrewrite.internal.ListUtils.map(ListUtils.java:243)\r\n        at org.openrewrite.internal.ListUtils.map(ListUtils.java:265)\r\n        at org.openrewrite.toml.TomlVisitor.visitTable(TomlVisitor.java:92)\r\n        at org.openrewrite.toml.tree.Toml$Table.acceptToml(Toml.java:327)\r\n        at org.openrewrite.toml.tree.Toml.accept(Toml.java:37)\r\n        at org.openrewrite.TreeVisitor.visit(TreeVisitor.java:250)\r\n        at org.openrewrite.toml.TomlVisitor.lambda$visitTable$2(TomlVisitor.java:92)\r\n        at org.openrewrite.internal.ListUtils.map(ListUtils.java:243)\r\n        at org.openrewrite.internal.ListUtils.map(ListUtils.java:265)\r\n        at org.openrewrite.toml.TomlVisitor.visitTable(TomlVisitor.java:92)\r\n        at org.openrewrite.toml.tree.Toml$Table.acceptToml(Toml.java:327)\r\n        at org.openrewrite.toml.tree.Toml.accept(Toml.java:37)\r\n        at org.openrewrite.TreeVisitor.visit(TreeVisitor.java:250)\r\n        at org.openrewrite.toml.TomlVisitor.lambda$visitDocument$1(TomlVisitor.java:49)\r\n        at org.openrewrite.internal.ListUtils.map(ListUtils.java:243)\r\n        at org.openrewrite.internal.ListUtils.map(ListUtils.java:265)\r\n        at org.openrewrite.toml.TomlVisitor.visitDocument(TomlVisitor.java:49)\r\n        at org.openrewrite.toml.tree.Toml$Document.acceptToml(Toml.java:149)\r\n        at org.openrewrite.toml.tree.Toml.accept(Toml.java:37)\r\n        at org.openrewrite.TreeVisitor.visit(TreeVisitor.java:250)\r\n        at org.openrewrite.gradle.isolated.ResultsContainer.getRecipeErrors(ResultsContainer.java:107)\r\n        at org.openrewrite.gradle.isolated.ResultsContainer.getFirstException(ResultsContainer.java:87)\r\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.run(DefaultProjectParser.java:416)\r\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.run(DefaultProjectParser.java:409)\r\n        at org.openrewrite.gradle.DelegatingProjectParser.lambda$run$2(DelegatingProjectParser.java:104)\r\n        at org.openrewrite.gradle.DelegatingProjectParser.unwrapInvocationException(DelegatingProjectParser.java:153)\r\n        ... 122 more\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite]\r\nI can get involved.\r\n",
    "issue_word_count": 852,
    "test_files_count": 3,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-toml/src/main/java/org/openrewrite/toml/TomlVisitor.java",
      "rewrite-toml/src/test/java/.editorconfig",
      "rewrite-toml/src/test/java/org/openrewrite/toml/TomlParserTest.java",
      "rewrite-toml/src/test/java/org/openrewrite/toml/TomlVisitorTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-toml/src/test/java/.editorconfig",
      "rewrite-toml/src/test/java/org/openrewrite/toml/TomlParserTest.java",
      "rewrite-toml/src/test/java/org/openrewrite/toml/TomlVisitorTest.java"
    ],
    "base_commit": "4a8a38b4dcda1a6c4044cb332bc29511b196263f",
    "head_commit": "73a2b6492d3af1e278bf460afe4595076b00fe8d",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4892",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4892",
    "dockerfile": "",
    "pr_merged_at": "2025-01-13T10:56:23.000Z",
    "patch": "diff --git a/rewrite-toml/src/main/java/org/openrewrite/toml/TomlVisitor.java b/rewrite-toml/src/main/java/org/openrewrite/toml/TomlVisitor.java\nindex b3707132e10..940d46db59c 100644\n--- a/rewrite-toml/src/main/java/org/openrewrite/toml/TomlVisitor.java\n+++ b/rewrite-toml/src/main/java/org/openrewrite/toml/TomlVisitor.java\n@@ -38,7 +38,7 @@ public Toml visitArray(Toml.Array array, P p) {\n         Toml.Array a = array;\n         a = a.withPrefix(visitSpace(a.getPrefix(), p));\n         a = a.withMarkers(visitMarkers(a.getMarkers(), p));\n-        a = a.withValues(ListUtils.map(a.getValues(), v -> (TomlValue) visit(v, p)));\n+        a = a.withValues(ListUtils.map(a.getValues(), v -> visit(v, p)));\n         return a;\n     }\n \n",
    "test_patch": "diff --git a/rewrite-toml/src/test/java/.editorconfig b/rewrite-toml/src/test/java/.editorconfig\nnew file mode 100644\nindex 00000000000..a4824935e4f\n--- /dev/null\n+++ b/rewrite-toml/src/test/java/.editorconfig\n@@ -0,0 +1,5 @@\n+root = true\n+\n+[*.java]\n+indent_size = 4\n+ij_continuation_indent_size = 2\n\ndiff --git a/rewrite-toml/src/test/java/org/openrewrite/toml/TomlParserTest.java b/rewrite-toml/src/test/java/org/openrewrite/toml/TomlParserTest.java\nindex fefa837ee9b..2693151c649 100644\n--- a/rewrite-toml/src/test/java/org/openrewrite/toml/TomlParserTest.java\n+++ b/rewrite-toml/src/test/java/org/openrewrite/toml/TomlParserTest.java\n@@ -26,8 +26,8 @@ void keyValueString() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-            str = \"I'm a string. \\\\\"You can quote me\\\\\". Name\\\\tJos\\\\u00E9\\\\nLocation\\\\tSF.\"\n-            \"\"\"\n+              str = \"I'm a string. \\\\\"You can quote me\\\\\". Name\\\\tJos\\\\u00E9\\\\nLocation\\\\tSF.\"\n+              \"\"\"\n           )\n         );\n     }\n@@ -37,23 +37,23 @@ void keyValueInteger() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-            int1 = +99\n-            int2 = 42\n-            int3 = 0\n-            int4 = -17\n-            int5 = 1_000\n-\n-            # hexadecimal with prefix `0x`\n-            hex1 = 0xDEADBEEF\n-            hex2 = 0xdeadbeef\n-            hex3 = 0xdead_beef\n-            # octal with prefix `0o`\n-            oct1 = 0o01234567\n-            oct2 = 0o755 # useful for Unix file permissions\n-\n-            # binary with prefix `0b`\n-            bin1 = 0b11010110\n-            \"\"\"\n+              int1 = +99\n+              int2 = 42\n+              int3 = 0\n+              int4 = -17\n+              int5 = 1_000\n+              \n+              # hexadecimal with prefix `0x`\n+              hex1 = 0xDEADBEEF\n+              hex2 = 0xdeadbeef\n+              hex3 = 0xdead_beef\n+              # octal with prefix `0o`\n+              oct1 = 0o01234567\n+              oct2 = 0o755 # useful for Unix file permissions\n+              \n+              # binary with prefix `0b`\n+              bin1 = 0b11010110\n+              \"\"\"\n           )\n         );\n     }\n@@ -63,31 +63,31 @@ void keyValueFloat() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-            # fractional\n-            flt1 = +1.0\n-            flt2 = 3.1415\n-            flt3 = -0.01\n-\n-            # exponent\n-            flt4 = 5e+22\n-            flt5 = 1e06\n-            flt6 = -2E-2\n-\n-            # both\n-            flt7 = 6.626e-34\n-\n-            flt8 = 224_617.445_991_228\n-\n-            # infinity\n-            sf1 = inf  # positive infinity\n-            sf2 = +inf # positive infinity\n-            sf3 = -inf # negative infinity\n-\n-            # not a number\n-            sf4 = nan  # actual sNaN/qNaN encoding is implementation-specific\n-            sf5 = +nan # same as `nan`\n-            sf6 = -nan # valid, actual encoding is implementation-specific\n-            \"\"\"\n+              # fractional\n+              flt1 = +1.0\n+              flt2 = 3.1415\n+              flt3 = -0.01\n+              \n+              # exponent\n+              flt4 = 5e+22\n+              flt5 = 1e06\n+              flt6 = -2E-2\n+              \n+              # both\n+              flt7 = 6.626e-34\n+              \n+              flt8 = 224_617.445_991_228\n+              \n+              # infinity\n+              sf1 = inf  # positive infinity\n+              sf2 = +inf # positive infinity\n+              sf3 = -inf # negative infinity\n+              \n+              # not a number\n+              sf4 = nan  # actual sNaN/qNaN encoding is implementation-specific\n+              sf5 = +nan # same as `nan`\n+              sf6 = -nan # valid, actual encoding is implementation-specific\n+              \"\"\"\n           )\n         );\n     }\n@@ -97,9 +97,9 @@ void keyValueBool() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-            bool1 = true\n-            bool2 = false\n-            \"\"\"\n+              bool1 = true\n+              bool2 = false\n+              \"\"\"\n           )\n         );\n     }\n@@ -109,11 +109,11 @@ void keyValueOffsetDateTime() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-            odt1 = 1979-05-27T07:32:00Z\n-            odt2 = 1979-05-27T00:32:00-07:00\n-            odt3 = 1979-05-27T00:32:00.999999-07:00\n-            odt4 = 1979-05-27 07:32:00Z\n-            \"\"\"\n+              odt1 = 1979-05-27T07:32:00Z\n+              odt2 = 1979-05-27T00:32:00-07:00\n+              odt3 = 1979-05-27T00:32:00.999999-07:00\n+              odt4 = 1979-05-27 07:32:00Z\n+              \"\"\"\n           )\n         );\n     }\n@@ -123,9 +123,9 @@ void keyValueLocalDateTime() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-            ldt1 = 1979-05-27T07:32:00\n-            ldt2 = 1979-05-27T00:32:00.999999\n-            \"\"\"\n+              ldt1 = 1979-05-27T07:32:00\n+              ldt2 = 1979-05-27T00:32:00.999999\n+              \"\"\"\n           )\n         );\n     }\n@@ -135,8 +135,8 @@ void keyValueLocalDate() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-            ld1 = 1979-05-27\n-            \"\"\"\n+              ld1 = 1979-05-27\n+              \"\"\"\n           )\n         );\n     }\n@@ -146,9 +146,9 @@ void keyValueLocalTime() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-            lt1 = 07:32:00\n-            lt2 = 00:32:00.999999\n-            \"\"\"\n+              lt1 = 07:32:00\n+              lt2 = 00:32:00.999999\n+              \"\"\"\n           )\n         );\n     }\n@@ -158,27 +158,27 @@ void keyValueArray() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-            integers = [ 1, 2, 3 ]\n-            colors = [ \"red\", \"yellow\", \"green\" ]\n-            nested_arrays_of_ints = [ [ 1, 2 ], [3, 4, 5] ]\n-            nested_mixed_array = [ [ 1, 2 ], [\"a\", \"b\", \"c\"] ]\n-            string_array = [ \"all\", 'strings', \"\"\\\"are the same\"\"\\\", '''type''' ]\n-\n-            # Mixed-type arrays are allowed\n-            numbers = [ 0.1, 0.2, 0.5, 1, 2, 5 ]\n-            contributors = [\n-              \"Foo Bar <foo@example.com>\",\n-              { name = \"Baz Qux\", email = \"bazqux@example.com\", url = \"https://example.com/bazqux\" }\n-            ]\n-            integers2 = [\n-              1, 2, 3\n-            ]\n-\n-            integers3 = [\n-              1,\n-              2, # this is ok\n-            ]\n-            \"\"\"\n+              integers = [ 1, 2, 3 ]\n+              colors = [ \"red\", \"yellow\", \"green\" ]\n+              nested_arrays_of_ints = [ [ 1, 2 ], [3, 4, 5] ]\n+              nested_mixed_array = [ [ 1, 2 ], [\"a\", \"b\", \"c\"] ]\n+              string_array = [ \"all\", 'strings', \"\"\\\"are the same\"\"\\\", '''type''' ]\n+              \n+              # Mixed-type arrays are allowed\n+              numbers = [ 0.1, 0.2, 0.5, 1, 2, 5 ]\n+              contributors = [\n+                \"Foo Bar <foo@example.com>\",\n+                { name = \"Baz Qux\", email = \"bazqux@example.com\", url = \"https://example.com/bazqux\" }\n+              ]\n+              integers2 = [\n+                1, 2, 3\n+              ]\n+              \n+              integers3 = [\n+                1,\n+                2, # this is ok\n+              ]\n+              \"\"\"\n           )\n         );\n     }\n@@ -188,17 +188,17 @@ void table() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-             [table-1]\n-             key1 = \"some string\"\n-             key2 = 123\n-\n-             [table-2]\n-             key1 = \"another string\"\n-             key2 = 456\n-\n-             [dog.\"tater.man\"]\n-             type.name = \"pug\"\n-             \"\"\"\n+              [table-1]\n+              key1 = \"some string\"\n+              key2 = 123\n+              \n+              [table-2]\n+              key1 = \"another string\"\n+              key2 = 456\n+              \n+              [dog.\"tater.man\"]\n+              type.name = \"pug\"\n+              \"\"\"\n           )\n         );\n     }\n@@ -208,18 +208,18 @@ void arrayTable() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-             [[products]]\n-             name = \"Hammer\"\n-             sku = 738594937\n-\n-             [[products]]  # empty table within the array\n-\n-             [[products]]\n-             name = \"Nail\"\n-             sku = 284758393\n-\n-             color = \"gray\"\n-             \"\"\"\n+              [[products]]\n+              name = \"Hammer\"\n+              sku = 738594937\n+              \n+              [[products]]  # empty table within the array\n+              \n+              [[products]]\n+              name = \"Nail\"\n+              sku = 284758393\n+              \n+              color = \"gray\"\n+              \"\"\"\n           )\n         );\n     }\n@@ -229,11 +229,11 @@ void bareKeys() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-            key = \"value\"\n-            bare_key = \"value\"\n-            bare-key = \"value\"\n-            1234 = \"value\"\n-            \"\"\"\n+              key = \"value\"\n+              bare_key = \"value\"\n+              bare-key = \"value\"\n+              1234 = \"value\"\n+              \"\"\"\n           )\n         );\n     }\n@@ -243,12 +243,12 @@ void quotedKeys() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-             \"127.0.0.1\" = \"value\"\n-             \"character encoding\" = \"value\"\n-             \"ʎǝʞ\" = \"value\"\n-             'key2' = \"value\"\n-             'quoted \"value\"' = \"value\"\n-             \"\"\"\n+              \"127.0.0.1\" = \"value\"\n+              \"character encoding\" = \"value\"\n+              \"ʎǝʞ\" = \"value\"\n+              'key2' = \"value\"\n+              'quoted \"value\"' = \"value\"\n+              \"\"\"\n           )\n         );\n     }\n@@ -258,10 +258,10 @@ void dottedKeys() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-             physical.color = \"orange\"\n-             physical.shape = \"round\"\n-             site.\"google.com\" = true\n-             \"\"\"\n+              physical.color = \"orange\"\n+              physical.shape = \"round\"\n+              site.\"google.com\" = true\n+              \"\"\"\n           )\n         );\n     }\n@@ -271,10 +271,10 @@ void extraWhitespaceDottedKeys() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-            fruit.name = \"banana\"      # this is best practice\n-            fruit. color = \"yellow\"    # same as fruit.color\n-            fruit . flavor = \"banana\"  # same as fruit.flavor\n-            \"\"\"\n+              fruit.name = \"banana\"      # this is best practice\n+              fruit. color = \"yellow\"    # same as fruit.color\n+              fruit . flavor = \"banana\"  # same as fruit.flavor\n+              \"\"\"\n           )\n         );\n     }\n@@ -321,9 +321,9 @@ void trailingComment() {\n         rewriteRun(\n           toml(\n             \"\"\"\n-            str = \"I'm a string. \\\\\"You can quote me\\\\\". Name\\\\tJos\\\\u00E9\\\\nLocation\\\\tSF.\"\n-            # trailing comment\n-            \"\"\"\n+              str = \"I'm a string. \\\\\"You can quote me\\\\\". Name\\\\tJos\\\\u00E9\\\\nLocation\\\\tSF.\"\n+              # trailing comment\n+              \"\"\"\n           )\n         );\n     }\n\ndiff --git a/rewrite-toml/src/test/java/org/openrewrite/toml/TomlVisitorTest.java b/rewrite-toml/src/test/java/org/openrewrite/toml/TomlVisitorTest.java\nnew file mode 100644\nindex 00000000000..f7698844a20\n--- /dev/null\n+++ b/rewrite-toml/src/test/java/org/openrewrite/toml/TomlVisitorTest.java\n@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.toml;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.*;\n+import org.openrewrite.marker.Markup;\n+import org.openrewrite.test.RewriteTest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openrewrite.test.RewriteTest.toRecipe;\n+import static org.openrewrite.toml.Assertions.toml;\n+\n+class TomlVisitorTest implements RewriteTest {\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite-spring/issues/665\")\n+    @Test\n+    void visitMarkupErrorMarkers() {\n+        List<RuntimeException> exceptions = new ArrayList<>();\n+        rewriteRun(\n+          spec -> spec.recipe(toRecipe(() -> new TreeVisitor<>() {\n+              @Override\n+              public Tree preVisit(Tree tree, ExecutionContext ctx) {\n+                  // Mimics what we do in the rewrite-gradle-plugin\n+                  tree.getMarkers().findFirst(Markup.Error.class).ifPresent(e -> {\n+                      Optional<SourceFile> sourceFile = Optional.ofNullable(getCursor().firstEnclosing(SourceFile.class));\n+                      String sourcePath = sourceFile.map(SourceFile::getSourcePath).map(Path::toString).orElse(\"<unknown>\");\n+                      exceptions.add(new RuntimeException(\"Error while visiting \" + sourcePath + \": \" + e.getDetail()));\n+                  });\n+                  return tree;\n+              }\n+          })),\n+          toml(\n+            \"\"\"\n+              [versions]\n+              jackson = '2.14.2'\n+              \n+              [libraries]\n+              jackson-annotations = { module = 'com.fasterxml.jackson.core:jackson-annotations', version.ref = 'jackson' }\n+              jackson-core = { module = 'com.fasterxml.jackson.core:jackson-core', version.ref = 'jackson' }\n+              \n+              [bundles]\n+              jackson = ['jackson-annotations', 'jackson-core']\n+              \"\"\"\n+          )\n+        );\n+        assertThat(exceptions).isEmpty();\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4885",
    "pr_id": 4885,
    "issue_id": 4765,
    "repo": "openrewrite/rewrite",
    "problem_statement": "`AddOrUpdateAnnotationAttribute` not working with nested annotations\nI am using\r\n\r\n- Maven plugin v5.46.1\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\nI am using the Maven plugin, and my project is a single module project.\r\n```xml\r\n<plugin>\r\n   <groupId>org.openrewrite.maven</groupId>\r\n   <artifactId>rewrite-maven-plugin</artifactId>\r\n   <version>5.46.1</version>\r\n   <configuration>\r\n      <exportDatatables>true</exportDatatables>\r\n      <activeRecipes>\r\n         <recipe>test.AddOrUpdateAnnotationAttributeExample</recipe>\r\n      </activeRecipes>\r\n   </configuration>\r\n</plugin>\r\n```\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\n```java\r\n@Test({\r\n        @TestFunction(name = \"a\"),\r\n        @TestFunction(name = \"b\"),\r\n})\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\n```java\r\n@Test({\r\n        @TestFunction(name = \"a\", value = \"\"),\r\n        @TestFunction(name = \"b\", value = \"\"),\r\n})\r\n```\r\n\r\n## What did you see instead?\r\nI am trying to add an attribute to each nested Annotation but no changes are being made. Updating an existing attribute does not work either.",
    "issue_word_count": 297,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java"
    ],
    "base_commit": "cb5a05955373dd36432e0f64ac2e92093d4efe18",
    "head_commit": "ae9447aeddeab4fa2a752ab8062c2fba930fb990",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4885",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4885",
    "dockerfile": "",
    "pr_merged_at": "2025-01-10T18:34:24.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java b/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java\nindex a62f0be4967..05257701bfd 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java\n@@ -87,7 +87,7 @@ public TreeVisitor<?, ExecutionContext> getVisitor() {\n             public J.Annotation visitAnnotation(J.Annotation a, ExecutionContext ctx) {\n                 J.Annotation original = super.visitAnnotation(a, ctx);\n                 if (!TypeUtils.isOfClassType(a.getType(), annotationType)) {\n-                    return a;\n+                    return original;\n                 }\n \n                 String newAttributeValue = maybeQuoteStringArgument(attributeName, attributeValue, a);\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java\nindex ac1b1bc8117..63f16fb0ef1 100755\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java\n@@ -892,4 +892,50 @@ public class A {\n           )\n         );\n     }\n+\n+    @Test\n+    void addAttributeToNestedAnnotationArray() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\n+            \"org.example.Bar\",\n+            \"attribute\",\n+            \"\",\n+            null,\n+            false)),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              public @interface Foo {\n+                  Bar[] array() default {};\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              public @interface Bar {\n+                  String attribute() default \"\";\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import org.example.Foo;\n+              import org.example.Bar;\n+              \n+              @Foo(array = { @Bar() })\n+              public class A {\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import org.example.Foo;\n+              import org.example.Bar;\n+              \n+              @Foo(array = { @Bar(attribute = \"\") })\n+              public class A {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4866",
    "pr_id": 4866,
    "issue_id": 4865,
    "repo": "openrewrite/rewrite",
    "problem_statement": "HCL - commented out lines are sometimes dropped in list literals\n## What version of OpenRewrite are you using?\r\nUsing current main (789ac5ffaadde114b9b5254e7a9351f0029f364a) the following HCL code:\r\n```\r\n              locals {\r\n                resources = [\r\n                   \"arn:aws:s3:::${var.my_precious_bucket}\",\r\n                   \"arn:aws:s3:::${var.waste_bucket}\",\r\n                   #      \"arn:aws:s3:::just-some-bucket/*\",\r\n                ]\r\n              }\r\n```\r\ngets collapsed to:\r\n```\r\n              locals {\r\n                resources = [\r\n                   \"arn:aws:s3:::${var.my_precious_bucket}\",\r\n                   \"arn:aws:s3:::${var.waste_bucket}\"]\r\n              }\r\n```\r\ni.e. the comment lines are dropped.",
    "issue_word_count": 65,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/HclParserVisitor.java",
      "rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java"
    ],
    "base_commit": "6bfac941901f4b774fa21bb2996043d40f6bb2fd",
    "head_commit": "683fea68c927cc732d6dea0716981eb6d7788fdf",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4866",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4866",
    "dockerfile": "",
    "pr_merged_at": "2025-01-08T11:23:16.000Z",
    "patch": "diff --git a/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/HclParserVisitor.java b/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/HclParserVisitor.java\nindex d729bdffc15..1f3e317eaf0 100644\n--- a/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/HclParserVisitor.java\n+++ b/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/HclParserVisitor.java\n@@ -742,8 +742,10 @@ private int positionOfNext(String untilDelim, @Nullable Character stop) {\n \n         int delimIndex = cursor;\n         for (; delimIndex < source.length() - untilDelim.length() + 1; delimIndex++) {\n-            if (inSingleLineComment && source.charAt(delimIndex) == '\\n') {\n-                inSingleLineComment = false;\n+            if (inSingleLineComment) {\n+                if (source.charAt(delimIndex) == '\\n') {\n+                    inSingleLineComment = false;\n+                }\n             } else {\n                 if (source.length() - untilDelim.length() > delimIndex + 1) {\n                     if ('#' == source.charAt(delimIndex)) {\n",
    "test_patch": "diff --git a/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java b/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java\nindex 7750b722d14..e67ff4ad5e6 100644\n--- a/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java\n+++ b/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java\n@@ -175,4 +175,20 @@ void multilineNotStartingInTheFirstCharacter() {\n         );\n     }\n \n+    @Test\n+    void commentedOutLinesInListLiteral() {\n+        rewriteRun(\n+          hcl(\n+            \"\"\"\n+              locals {\n+                resources = [\n+                   \"arn:aws:s3:::${var.my_precious_bucket}\",\n+                   \"arn:aws:s3:::${var.waste_bucket}\",\n+                   #      \"arn:aws:s3:::just-some-bucket/*\",\n+                ]\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4864",
    "pr_id": 4864,
    "issue_id": 4862,
    "repo": "openrewrite/rewrite",
    "problem_statement": "When nesting comments, HCL parser squashes them\n## Steps to reproduce\r\nUsing current main (0e5b4395d7e70225539dd8b8d33001f6246c2345) the following HCL code:\r\n```\r\n/*\r\n# It's important\r\n*/\r\n```\r\ncollapses to weird:\r\n```\r\n# It's important\r\n/**/\r\n```\r\nwhich BTW is still a valid piece of HCL.",
    "issue_word_count": 36,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-hcl/src/main/java/org/openrewrite/hcl/tree/Space.java",
      "rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java"
    ],
    "base_commit": "0e5b4395d7e70225539dd8b8d33001f6246c2345",
    "head_commit": "531e38b176e2b81304489d0d433375d8c757b551",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4864",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4864",
    "dockerfile": "",
    "pr_merged_at": "2025-01-08T07:04:30.000Z",
    "patch": "diff --git a/rewrite-hcl/src/main/java/org/openrewrite/hcl/tree/Space.java b/rewrite-hcl/src/main/java/org/openrewrite/hcl/tree/Space.java\nindex 854b9299aee..31d5fa2f4e8 100644\n--- a/rewrite-hcl/src/main/java/org/openrewrite/hcl/tree/Space.java\n+++ b/rewrite-hcl/src/main/java/org/openrewrite/hcl/tree/Space.java\n@@ -158,14 +158,14 @@ public static Space format(String formatting) {\n                 case '#':\n                     if (Comment.Style.LINE_SLASH == inLineSlashOrHashComment) {\n                         comment.append(c);\n+                    } else if (inSingleLineComment) {\n+                        comment.append(c);\n+                    } else if (inMultiLineComment) {\n+                        comment.append(c);\n                     } else {\n-                        if (inSingleLineComment) {\n-                            comment.append(c);\n-                        } else {\n-                            inSingleLineComment = true;\n-                            inLineSlashOrHashComment = Comment.Style.LINE_HASH;\n-                            comment = new StringBuilder();\n-                        }\n+                        inSingleLineComment = true;\n+                        inLineSlashOrHashComment = Comment.Style.LINE_HASH;\n+                        comment = new StringBuilder();\n                     }\n                     break;\n                 case '/':\n",
    "test_patch": "diff --git a/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java b/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java\nindex 3a6d872b02d..7750b722d14 100644\n--- a/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java\n+++ b/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java\n@@ -130,4 +130,49 @@ void commentsAsTheFinalLines() {\n           )\n         );\n     }\n+\n+    @Test\n+    void singeLineWithinMultiLineHash() {\n+        rewriteRun(\n+          hcl(\n+            \"\"\"\n+              /*\n+              # It's important\n+              */\n+              locals {\n+               Anwil = \"Wloclawek\"\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void singeLineWithinMultiLineSlash() {\n+        rewriteRun(\n+          hcl(\n+            \"\"\"\n+              /*\n+              // It's important\n+              */\n+              locals {\n+               Anwil = \"Wloclawek\"\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void multilineNotStartingInTheFirstCharacter() {\n+        rewriteRun(\n+          hcl(\n+            \"\"\"\n+                  /* An indented comment\n+              */\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4861",
    "pr_id": 4861,
    "issue_id": 4611,
    "repo": "openrewrite/rewrite",
    "problem_statement": "HCL Parser does not accept a comment as the last line in the file\n## What is the smallest, simplest way to reproduce the problem?\r\n```\r\n    @Test\r\n    void commentAsTheLastLine() {\r\n        rewriteRun(\r\n          hcl(\r\n            \"\"\"\r\n              locals {\r\n                a = 3\r\n              }\r\n              # Nice code, right?\r\n            \"\"\"\r\n          )\r\n        );\r\n    }\r\n```\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n```\r\n[...]\r\nCaused by: org.openrewrite.hcl.HclParsingException: Syntax error in file.tf at line 4:0 token recognition error at: '# Nice code, right?'.\r\n\tat org.openrewrite.hcl.HclParser$ForwardingErrorListener.syntaxError(HclParser.java:105)\r\n\t... 130 more\r\nCaused by: LexerNoViableAltException('#')\r\n\tat org.antlr.v4.runtime.atn.LexerATNSimulator.failOrAccept(LexerATNSimulator.java:309)\r\n\tat org.antlr.v4.runtime.atn.LexerATNSimulator.execATN(LexerATNSimulator.java:230)\r\n\tat org.antlr.v4.runtime.atn.LexerATNSimulator.match(LexerATNSimulator.java:114)\r\n\tat org.antlr.v4.runtime.Lexer.nextToken(Lexer.java:141)\r\n\t... 127 more\r\n```\r\n",
    "issue_word_count": 128,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-hcl/src/main/antlr/HCLLexer.g4",
      "rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.interp",
      "rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.java",
      "rewrite-hcl/src/main/java/org/openrewrite/hcl/tree/Space.java",
      "rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java"
    ],
    "base_commit": "b3f17cea87340343832ded6c3a18eb22a9aeea12",
    "head_commit": "5358ce61f685184aada50f06577b7aa449399a69",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4861",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4861",
    "dockerfile": "",
    "pr_merged_at": "2025-01-07T14:47:44.000Z",
    "patch": "diff --git a/rewrite-hcl/src/main/antlr/HCLLexer.g4 b/rewrite-hcl/src/main/antlr/HCLLexer.g4\nindex 6266c3e22ec..7bdf3d0c17f 100644\n--- a/rewrite-hcl/src/main/antlr/HCLLexer.g4\n+++ b/rewrite-hcl/src/main/antlr/HCLLexer.g4\n@@ -49,10 +49,10 @@ Identifier\n \n // Lexical Elements - Comments and Whitespace\n // https://github.com/hashicorp/hcl2/blob/master/hcl/hclsyntax/spec.md#comments-and-whitespace\n-WS              : [ \\t\\r\\u000C]+                   -> channel(HIDDEN);\n-COMMENT         : '/*' .*? '*/'                    -> channel(HIDDEN);\n-LINE_COMMENT    : ('//' | '#') ~[\\r\\n]* '\\r'?'\\n'  -> channel(HIDDEN);\n-NEWLINE         : '\\n'                             -> channel(HIDDEN);\n+WS              : [ \\t\\r\\u000C]+                           -> channel(HIDDEN);\n+COMMENT         : '/*' .*? '*/'                            -> channel(HIDDEN);\n+LINE_COMMENT    : ('//' | '#') ~[\\r\\n]* '\\r'? ('\\n' | EOF) -> channel(HIDDEN);\n+NEWLINE         : '\\n'                                     -> channel(HIDDEN);\n \n fragment LetterOrDigit\n     : Letter\n\ndiff --git a/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.interp b/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.interp\nindex 1c2aaad6d58..9097230066a 100644\n--- a/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.interp\n+++ b/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.interp\n@@ -169,4 +169,4 @@ HEREDOC_PREAMBLE\n HEREDOC\n \n atn:\n-[4, 0, 47, 450, 6, -1, 6, -1, 6, -1, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 5, 0, 126, 8, 0, 10, 0, 12, 0, 129, 9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 142, 8, 1, 10, 1, 12, 1, 145, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 3, 7, 169, 8, 7, 1, 8, 1, 8, 1, 8, 5, 8, 174, 8, 8, 10, 8, 12, 8, 177, 9, 8, 1, 9, 4, 9, 180, 8, 9, 11, 9, 12, 9, 181, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 190, 8, 10, 10, 10, 12, 10, 193, 9, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 3, 11, 203, 8, 11, 1, 11, 5, 11, 206, 8, 11, 10, 11, 12, 11, 209, 9, 11, 1, 11, 3, 11, 212, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 3, 13, 224, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 230, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 250, 8, 15, 1, 16, 1, 16, 1, 17, 4, 17, 255, 8, 17, 11, 17, 12, 17, 256, 1, 17, 1, 17, 5, 17, 261, 8, 17, 10, 17, 12, 17, 264, 9, 17, 1, 17, 3, 17, 267, 8, 17, 1, 17, 4, 17, 270, 8, 17, 11, 17, 12, 17, 271, 1, 17, 1, 17, 4, 17, 276, 8, 17, 11, 17, 12, 17, 277, 3, 17, 280, 8, 17, 1, 18, 1, 18, 3, 18, 284, 8, 18, 1, 18, 4, 18, 287, 8, 18, 11, 18, 12, 18, 288, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 300, 8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 315, 8, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 35, 1, 35, 1, 36, 1, 36, 1, 37, 1, 37, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 4, 49, 386, 8, 49, 11, 49, 12, 49, 387, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 400, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 5, 53, 415, 8, 53, 10, 53, 12, 53, 418, 9, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 4, 56, 437, 8, 56, 11, 56, 12, 56, 438, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 449, 8, 57, 1, 191, 0, 58, 4, 1, 6, 2, 8, 3, 10, 4, 12, 5, 14, 6, 16, 7, 18, 0, 20, 8, 22, 9, 24, 10, 26, 11, 28, 12, 30, 0, 32, 0, 34, 0, 36, 0, 38, 13, 40, 0, 42, 14, 44, 15, 46, 16, 48, 17, 50, 18, 52, 19, 54, 20, 56, 21, 58, 22, 60, 23, 62, 24, 64, 25, 66, 26, 68, 27, 70, 28, 72, 29, 74, 30, 76, 31, 78, 32, 80, 33, 82, 34, 84, 35, 86, 36, 88, 37, 90, 38, 92, 39, 94, 40, 96, 41, 98, 42, 100, 43, 102, 44, 104, 45, 106, 0, 108, 0, 110, 0, 112, 0, 114, 0, 116, 46, 118, 47, 4, 0, 1, 2, 3, 14, 4, 0, 10, 10, 13, 13, 34, 34, 36, 37, 3, 0, 9, 9, 12, 13, 32, 32, 2, 0, 10, 10, 13, 13, 1, 0, 48, 57, 4, 0, 36, 36, 65, 90, 95, 95, 97, 122, 2, 0, 0, 127, 55296, 56319, 1, 0, 55296, 56319, 1, 0, 56320, 57343, 5, 0, 34, 34, 92, 92, 110, 110, 114, 114, 116, 116, 3, 0, 48, 57, 65, 70, 97, 102, 2, 0, 69, 69, 101, 101, 2, 0, 43, 43, 45, 45, 3, 0, 10, 10, 13, 13, 36, 37, 1, 0, 123, 123, 484, 0, 4, 1, 0, 0, 0, 0, 6, 1, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 10, 1, 0, 0, 0, 0, 12, 1, 0, 0, 0, 0, 14, 1, 0, 0, 0, 0, 16, 1, 0, 0, 0, 0, 20, 1, 0, 0, 0, 0, 22, 1, 0, 0, 0, 0, 24, 1, 0, 0, 0, 0, 26, 1, 0, 0, 0, 0, 28, 1, 0, 0, 0, 0, 38, 1, 0, 0, 0, 0, 42, 1, 0, 0, 0, 0, 44, 1, 0, 0, 0, 0, 46, 1, 0, 0, 0, 0, 48, 1, 0, 0, 0, 0, 50, 1, 0, 0, 0, 0, 52, 1, 0, 0, 0, 0, 54, 1, 0, 0, 0, 0, 56, 1, 0, 0, 0, 0, 58, 1, 0, 0, 0, 0, 60, 1, 0, 0, 0, 0, 62, 1, 0, 0, 0, 0, 64, 1, 0, 0, 0, 0, 66, 1, 0, 0, 0, 0, 68, 1, 0, 0, 0, 0, 70, 1, 0, 0, 0, 0, 72, 1, 0, 0, 0, 0, 74, 1, 0, 0, 0, 0, 76, 1, 0, 0, 0, 0, 78, 1, 0, 0, 0, 0, 80, 1, 0, 0, 0, 0, 82, 1, 0, 0, 0, 0, 84, 1, 0, 0, 0, 0, 86, 1, 0, 0, 0, 0, 88, 1, 0, 0, 0, 0, 90, 1, 0, 0, 0, 0, 92, 1, 0, 0, 0, 0, 94, 1, 0, 0, 0, 0, 96, 1, 0, 0, 0, 0, 98, 1, 0, 0, 0, 1, 100, 1, 0, 0, 0, 1, 102, 1, 0, 0, 0, 1, 104, 1, 0, 0, 0, 1, 106, 1, 0, 0, 0, 2, 108, 1, 0, 0, 0, 2, 110, 1, 0, 0, 0, 3, 112, 1, 0, 0, 0, 3, 114, 1, 0, 0, 0, 3, 116, 1, 0, 0, 0, 3, 118, 1, 0, 0, 0, 4, 120, 1, 0, 0, 0, 6, 136, 1, 0, 0, 0, 8, 152, 1, 0, 0, 0, 10, 155, 1, 0, 0, 0, 12, 158, 1, 0, 0, 0, 14, 161, 1, 0, 0, 0, 16, 164, 1, 0, 0, 0, 18, 168, 1, 0, 0, 0, 20, 170, 1, 0, 0, 0, 22, 179, 1, 0, 0, 0, 24, 185, 1, 0, 0, 0, 26, 202, 1, 0, 0, 0, 28, 217, 1, 0, 0, 0, 30, 223, 1, 0, 0, 0, 32, 229, 1, 0, 0, 0, 34, 249, 1, 0, 0, 0, 36, 251, 1, 0, 0, 0, 38, 279, 1, 0, 0, 0, 40, 281, 1, 0, 0, 0, 42, 299, 1, 0, 0, 0, 44, 301, 1, 0, 0, 0, 46, 305, 1, 0, 0, 0, 48, 310, 1, 0, 0, 0, 50, 318, 1, 0, 0, 0, 52, 320, 1, 0, 0, 0, 54, 323, 1, 0, 0, 0, 56, 326, 1, 0, 0, 0, 58, 328, 1, 0, 0, 0, 60, 330, 1, 0, 0, 0, 62, 332, 1, 0, 0, 0, 64, 334, 1, 0, 0, 0, 66, 336, 1, 0, 0, 0, 68, 339, 1, 0, 0, 0, 70, 342, 1, 0, 0, 0, 72, 344, 1, 0, 0, 0, 74, 346, 1, 0, 0, 0, 76, 348, 1, 0, 0, 0, 78, 350, 1, 0, 0, 0, 80, 352, 1, 0, 0, 0, 82, 354, 1, 0, 0, 0, 84, 357, 1, 0, 0, 0, 86, 359, 1, 0, 0, 0, 88, 361, 1, 0, 0, 0, 90, 364, 1, 0, 0, 0, 92, 367, 1, 0, 0, 0, 94, 369, 1, 0, 0, 0, 96, 371, 1, 0, 0, 0, 98, 375, 1, 0, 0, 0, 100, 377, 1, 0, 0, 0, 102, 385, 1, 0, 0, 0, 104, 399, 1, 0, 0, 0, 106, 401, 1, 0, 0, 0, 108, 406, 1, 0, 0, 0, 110, 411, 1, 0, 0, 0, 112, 423, 1, 0, 0, 0, 114, 427, 1, 0, 0, 0, 116, 436, 1, 0, 0, 0, 118, 448, 1, 0, 0, 0, 120, 127, 5, 123, 0, 0, 121, 126, 3, 22, 9, 0, 122, 126, 3, 28, 12, 0, 123, 126, 3, 24, 10, 0, 124, 126, 3, 26, 11, 0, 125, 121, 1, 0, 0, 0, 125, 122, 1, 0, 0, 0, 125, 123, 1, 0, 0, 0, 125, 124, 1, 0, 0, 0, 126, 129, 1, 0, 0, 0, 127, 125, 1, 0, 0, 0, 127, 128, 1, 0, 0, 0, 128, 130, 1, 0, 0, 0, 129, 127, 1, 0, 0, 0, 130, 131, 5, 102, 0, 0, 131, 132, 5, 111, 0, 0, 132, 133, 5, 114, 0, 0, 133, 134, 1, 0, 0, 0, 134, 135, 3, 22, 9, 0, 135, 5, 1, 0, 0, 0, 136, 143, 5, 91, 0, 0, 137, 142, 3, 22, 9, 0, 138, 142, 3, 28, 12, 0, 139, 142, 3, 24, 10, 0, 140, 142, 3, 26, 11, 0, 141, 137, 1, 0, 0, 0, 141, 138, 1, 0, 0, 0, 141, 139, 1, 0, 0, 0, 141, 140, 1, 0, 0, 0, 142, 145, 1, 0, 0, 0, 143, 141, 1, 0, 0, 0, 143, 144, 1, 0, 0, 0, 144, 146, 1, 0, 0, 0, 145, 143, 1, 0, 0, 0, 146, 147, 5, 102, 0, 0, 147, 148, 5, 111, 0, 0, 148, 149, 5, 114, 0, 0, 149, 150, 1, 0, 0, 0, 150, 151, 3, 22, 9, 0, 151, 7, 1, 0, 0, 0, 152, 153, 5, 105, 0, 0, 153, 154, 5, 102, 0, 0, 154, 9, 1, 0, 0, 0, 155, 156, 5, 105, 0, 0, 156, 157, 5, 110, 0, 0, 157, 11, 1, 0, 0, 0, 158, 159, 5, 123, 0, 0, 159, 160, 6, 4, 0, 0, 160, 13, 1, 0, 0, 0, 161, 162, 5, 125, 0, 0, 162, 163, 6, 5, 1, 0, 163, 15, 1, 0, 0, 0, 164, 165, 5, 61, 0, 0, 165, 17, 1, 0, 0, 0, 166, 169, 8, 0, 0, 0, 167, 169, 3, 34, 15, 0, 168, 166, 1, 0, 0, 0, 168, 167, 1, 0, 0, 0, 169, 19, 1, 0, 0, 0, 170, 175, 3, 32, 14, 0, 171, 174, 3, 30, 13, 0, 172, 174, 5, 45, 0, 0, 173, 171, 1, 0, 0, 0, 173, 172, 1, 0, 0, 0, 174, 177, 1, 0, 0, 0, 175, 173, 1, 0, 0, 0, 175, 176, 1, 0, 0, 0, 176, 21, 1, 0, 0, 0, 177, 175, 1, 0, 0, 0, 178, 180, 7, 1, 0, 0, 179, 178, 1, 0, 0, 0, 180, 181, 1, 0, 0, 0, 181, 179, 1, 0, 0, 0, 181, 182, 1, 0, 0, 0, 182, 183, 1, 0, 0, 0, 183, 184, 6, 9, 2, 0, 184, 23, 1, 0, 0, 0, 185, 186, 5, 47, 0, 0, 186, 187, 5, 42, 0, 0, 187, 191, 1, 0, 0, 0, 188, 190, 9, 0, 0, 0, 189, 188, 1, 0, 0, 0, 190, 193, 1, 0, 0, 0, 191, 192, 1, 0, 0, 0, 191, 189, 1, 0, 0, 0, 192, 194, 1, 0, 0, 0, 193, 191, 1, 0, 0, 0, 194, 195, 5, 42, 0, 0, 195, 196, 5, 47, 0, 0, 196, 197, 1, 0, 0, 0, 197, 198, 6, 10, 2, 0, 198, 25, 1, 0, 0, 0, 199, 200, 5, 47, 0, 0, 200, 203, 5, 47, 0, 0, 201, 203, 5, 35, 0, 0, 202, 199, 1, 0, 0, 0, 202, 201, 1, 0, 0, 0, 203, 207, 1, 0, 0, 0, 204, 206, 8, 2, 0, 0, 205, 204, 1, 0, 0, 0, 206, 209, 1, 0, 0, 0, 207, 205, 1, 0, 0, 0, 207, 208, 1, 0, 0, 0, 208, 211, 1, 0, 0, 0, 209, 207, 1, 0, 0, 0, 210, 212, 5, 13, 0, 0, 211, 210, 1, 0, 0, 0, 211, 212, 1, 0, 0, 0, 212, 213, 1, 0, 0, 0, 213, 214, 5, 10, 0, 0, 214, 215, 1, 0, 0, 0, 215, 216, 6, 11, 2, 0, 216, 27, 1, 0, 0, 0, 217, 218, 5, 10, 0, 0, 218, 219, 1, 0, 0, 0, 219, 220, 6, 12, 2, 0, 220, 29, 1, 0, 0, 0, 221, 224, 3, 32, 14, 0, 222, 224, 7, 3, 0, 0, 223, 221, 1, 0, 0, 0, 223, 222, 1, 0, 0, 0, 224, 31, 1, 0, 0, 0, 225, 230, 7, 4, 0, 0, 226, 230, 8, 5, 0, 0, 227, 228, 7, 6, 0, 0, 228, 230, 7, 7, 0, 0, 229, 225, 1, 0, 0, 0, 229, 226, 1, 0, 0, 0, 229, 227, 1, 0, 0, 0, 230, 33, 1, 0, 0, 0, 231, 232, 5, 92, 0, 0, 232, 250, 7, 8, 0, 0, 233, 234, 5, 92, 0, 0, 234, 235, 3, 36, 16, 0, 235, 236, 3, 36, 16, 0, 236, 237, 3, 36, 16, 0, 237, 238, 3, 36, 16, 0, 238, 250, 1, 0, 0, 0, 239, 240, 5, 92, 0, 0, 240, 241, 3, 36, 16, 0, 241, 242, 3, 36, 16, 0, 242, 243, 3, 36, 16, 0, 243, 244, 3, 36, 16, 0, 244, 245, 3, 36, 16, 0, 245, 246, 3, 36, 16, 0, 246, 247, 3, 36, 16, 0, 247, 248, 3, 36, 16, 0, 248, 250, 1, 0, 0, 0, 249, 231, 1, 0, 0, 0, 249, 233, 1, 0, 0, 0, 249, 239, 1, 0, 0, 0, 250, 35, 1, 0, 0, 0, 251, 252, 7, 9, 0, 0, 252, 37, 1, 0, 0, 0, 253, 255, 7, 3, 0, 0, 254, 253, 1, 0, 0, 0, 255, 256, 1, 0, 0, 0, 256, 254, 1, 0, 0, 0, 256, 257, 1, 0, 0, 0, 257, 258, 1, 0, 0, 0, 258, 262, 5, 46, 0, 0, 259, 261, 7, 3, 0, 0, 260, 259, 1, 0, 0, 0, 261, 264, 1, 0, 0, 0, 262, 260, 1, 0, 0, 0, 262, 263, 1, 0, 0, 0, 263, 266, 1, 0, 0, 0, 264, 262, 1, 0, 0, 0, 265, 267, 3, 40, 18, 0, 266, 265, 1, 0, 0, 0, 266, 267, 1, 0, 0, 0, 267, 280, 1, 0, 0, 0, 268, 270, 7, 3, 0, 0, 269, 268, 1, 0, 0, 0, 270, 271, 1, 0, 0, 0, 271, 269, 1, 0, 0, 0, 271, 272, 1, 0, 0, 0, 272, 273, 1, 0, 0, 0, 273, 280, 3, 40, 18, 0, 274, 276, 7, 3, 0, 0, 275, 274, 1, 0, 0, 0, 276, 277, 1, 0, 0, 0, 277, 275, 1, 0, 0, 0, 277, 278, 1, 0, 0, 0, 278, 280, 1, 0, 0, 0, 279, 254, 1, 0, 0, 0, 279, 269, 1, 0, 0, 0, 279, 275, 1, 0, 0, 0, 280, 39, 1, 0, 0, 0, 281, 283, 7, 10, 0, 0, 282, 284, 7, 11, 0, 0, 283, 282, 1, 0, 0, 0, 283, 284, 1, 0, 0, 0, 284, 286, 1, 0, 0, 0, 285, 287, 7, 3, 0, 0, 286, 285, 1, 0, 0, 0, 287, 288, 1, 0, 0, 0, 288, 286, 1, 0, 0, 0, 288, 289, 1, 0, 0, 0, 289, 41, 1, 0, 0, 0, 290, 291, 5, 116, 0, 0, 291, 292, 5, 114, 0, 0, 292, 293, 5, 117, 0, 0, 293, 300, 5, 101, 0, 0, 294, 295, 5, 102, 0, 0, 295, 296, 5, 97, 0, 0, 296, 297, 5, 108, 0, 0, 297, 298, 5, 115, 0, 0, 298, 300, 5, 101, 0, 0, 299, 290, 1, 0, 0, 0, 299, 294, 1, 0, 0, 0, 300, 43, 1, 0, 0, 0, 301, 302, 5, 34, 0, 0, 302, 303, 1, 0, 0, 0, 303, 304, 6, 20, 3, 0, 304, 45, 1, 0, 0, 0, 305, 306, 5, 110, 0, 0, 306, 307, 5, 117, 0, 0, 307, 308, 5, 108, 0, 0, 308, 309, 5, 108, 0, 0, 309, 47, 1, 0, 0, 0, 310, 311, 5, 60, 0, 0, 311, 312, 5, 60, 0, 0, 312, 314, 1, 0, 0, 0, 313, 315, 5, 45, 0, 0, 314, 313, 1, 0, 0, 0, 314, 315, 1, 0, 0, 0, 315, 316, 1, 0, 0, 0, 316, 317, 6, 22, 4, 0, 317, 49, 1, 0, 0, 0, 318, 319, 5, 43, 0, 0, 319, 51, 1, 0, 0, 0, 320, 321, 5, 38, 0, 0, 321, 322, 5, 38, 0, 0, 322, 53, 1, 0, 0, 0, 323, 324, 5, 61, 0, 0, 324, 325, 5, 61, 0, 0, 325, 55, 1, 0, 0, 0, 326, 327, 5, 60, 0, 0, 327, 57, 1, 0, 0, 0, 328, 329, 5, 58, 0, 0, 329, 59, 1, 0, 0, 0, 330, 331, 5, 91, 0, 0, 331, 61, 1, 0, 0, 0, 332, 333, 5, 40, 0, 0, 333, 63, 1, 0, 0, 0, 334, 335, 5, 45, 0, 0, 335, 65, 1, 0, 0, 0, 336, 337, 5, 124, 0, 0, 337, 338, 5, 124, 0, 0, 338, 67, 1, 0, 0, 0, 339, 340, 5, 33, 0, 0, 340, 341, 5, 61, 0, 0, 341, 69, 1, 0, 0, 0, 342, 343, 5, 62, 0, 0, 343, 71, 1, 0, 0, 0, 344, 345, 5, 63, 0, 0, 345, 73, 1, 0, 0, 0, 346, 347, 5, 93, 0, 0, 347, 75, 1, 0, 0, 0, 348, 349, 5, 41, 0, 0, 349, 77, 1, 0, 0, 0, 350, 351, 5, 42, 0, 0, 351, 79, 1, 0, 0, 0, 352, 353, 5, 33, 0, 0, 353, 81, 1, 0, 0, 0, 354, 355, 5, 60, 0, 0, 355, 356, 5, 61, 0, 0, 356, 83, 1, 0, 0, 0, 357, 358, 5, 46, 0, 0, 358, 85, 1, 0, 0, 0, 359, 360, 5, 47, 0, 0, 360, 87, 1, 0, 0, 0, 361, 362, 5, 62, 0, 0, 362, 363, 5, 61, 0, 0, 363, 89, 1, 0, 0, 0, 364, 365, 5, 61, 0, 0, 365, 366, 5, 62, 0, 0, 366, 91, 1, 0, 0, 0, 367, 368, 5, 44, 0, 0, 368, 93, 1, 0, 0, 0, 369, 370, 5, 37, 0, 0, 370, 95, 1, 0, 0, 0, 371, 372, 5, 46, 0, 0, 372, 373, 5, 46, 0, 0, 373, 374, 5, 46, 0, 0, 374, 97, 1, 0, 0, 0, 375, 376, 5, 126, 0, 0, 376, 99, 1, 0, 0, 0, 377, 378, 5, 36, 0, 0, 378, 379, 5, 123, 0, 0, 379, 380, 1, 0, 0, 0, 380, 381, 6, 48, 5, 0, 381, 382, 1, 0, 0, 0, 382, 383, 6, 48, 6, 0, 383, 101, 1, 0, 0, 0, 384, 386, 3, 104, 50, 0, 385, 384, 1, 0, 0, 0, 386, 387, 1, 0, 0, 0, 387, 385, 1, 0, 0, 0, 387, 388, 1, 0, 0, 0, 388, 103, 1, 0, 0, 0, 389, 400, 8, 0, 0, 0, 390, 391, 5, 36, 0, 0, 391, 400, 5, 36, 0, 0, 392, 393, 5, 36, 0, 0, 393, 400, 4, 50, 0, 0, 394, 395, 5, 37, 0, 0, 395, 400, 5, 37, 0, 0, 396, 397, 5, 37, 0, 0, 397, 400, 4, 50, 1, 0, 398, 400, 3, 34, 15, 0, 399, 389, 1, 0, 0, 0, 399, 390, 1, 0, 0, 0, 399, 392, 1, 0, 0, 0, 399, 394, 1, 0, 0, 0, 399, 396, 1, 0, 0, 0, 399, 398, 1, 0, 0, 0, 400, 105, 1, 0, 0, 0, 401, 402, 5, 34, 0, 0, 402, 403, 1, 0, 0, 0, 403, 404, 6, 51, 7, 0, 404, 405, 6, 51, 8, 0, 405, 107, 1, 0, 0, 0, 406, 407, 5, 10, 0, 0, 407, 408, 1, 0, 0, 0, 408, 409, 6, 52, 9, 0, 409, 410, 6, 52, 10, 0, 410, 109, 1, 0, 0, 0, 411, 416, 3, 32, 14, 0, 412, 415, 3, 30, 13, 0, 413, 415, 5, 45, 0, 0, 414, 412, 1, 0, 0, 0, 414, 413, 1, 0, 0, 0, 415, 418, 1, 0, 0, 0, 416, 414, 1, 0, 0, 0, 416, 417, 1, 0, 0, 0, 417, 419, 1, 0, 0, 0, 418, 416, 1, 0, 0, 0, 419, 420, 6, 53, 11, 0, 420, 421, 1, 0, 0, 0, 421, 422, 6, 53, 12, 0, 422, 111, 1, 0, 0, 0, 423, 424, 5, 10, 0, 0, 424, 425, 1, 0, 0, 0, 425, 426, 6, 54, 9, 0, 426, 113, 1, 0, 0, 0, 427, 428, 5, 36, 0, 0, 428, 429, 5, 123, 0, 0, 429, 430, 1, 0, 0, 0, 430, 431, 6, 55, 13, 0, 431, 432, 1, 0, 0, 0, 432, 433, 6, 55, 14, 0, 433, 434, 6, 55, 6, 0, 434, 115, 1, 0, 0, 0, 435, 437, 3, 118, 57, 0, 436, 435, 1, 0, 0, 0, 437, 438, 1, 0, 0, 0, 438, 436, 1, 0, 0, 0, 438, 439, 1, 0, 0, 0, 439, 440, 1, 0, 0, 0, 440, 441, 6, 56, 15, 0, 441, 117, 1, 0, 0, 0, 442, 449, 8, 12, 0, 0, 443, 444, 5, 36, 0, 0, 444, 449, 8, 13, 0, 0, 445, 446, 5, 37, 0, 0, 446, 449, 8, 13, 0, 0, 447, 449, 3, 34, 15, 0, 448, 442, 1, 0, 0, 0, 448, 443, 1, 0, 0, 0, 448, 445, 1, 0, 0, 0, 448, 447, 1, 0, 0, 0, 449, 119, 1, 0, 0, 0, 35, 0, 1, 2, 3, 125, 127, 141, 143, 168, 173, 175, 181, 191, 202, 207, 211, 223, 229, 249, 256, 262, 266, 271, 277, 279, 283, 288, 299, 314, 387, 399, 414, 416, 438, 448, 16, 1, 4, 0, 1, 5, 1, 0, 1, 0, 5, 1, 0, 5, 2, 0, 1, 48, 2, 5, 0, 0, 7, 15, 0, 4, 0, 0, 7, 12, 0, 2, 3, 0, 1, 53, 3, 7, 8, 0, 1, 55, 4, 7, 43, 0, 1, 56, 5]\n\\ No newline at end of file\n+[4, 0, 47, 451, 6, -1, 6, -1, 6, -1, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 5, 0, 126, 8, 0, 10, 0, 12, 0, 129, 9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 142, 8, 1, 10, 1, 12, 1, 145, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 3, 7, 169, 8, 7, 1, 8, 1, 8, 1, 8, 5, 8, 174, 8, 8, 10, 8, 12, 8, 177, 9, 8, 1, 9, 4, 9, 180, 8, 9, 11, 9, 12, 9, 181, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 190, 8, 10, 10, 10, 12, 10, 193, 9, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 3, 11, 203, 8, 11, 1, 11, 5, 11, 206, 8, 11, 10, 11, 12, 11, 209, 9, 11, 1, 11, 3, 11, 212, 8, 11, 1, 11, 3, 11, 215, 8, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 3, 13, 225, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 231, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 251, 8, 15, 1, 16, 1, 16, 1, 17, 4, 17, 256, 8, 17, 11, 17, 12, 17, 257, 1, 17, 1, 17, 5, 17, 262, 8, 17, 10, 17, 12, 17, 265, 9, 17, 1, 17, 3, 17, 268, 8, 17, 1, 17, 4, 17, 271, 8, 17, 11, 17, 12, 17, 272, 1, 17, 1, 17, 4, 17, 277, 8, 17, 11, 17, 12, 17, 278, 3, 17, 281, 8, 17, 1, 18, 1, 18, 3, 18, 285, 8, 18, 1, 18, 4, 18, 288, 8, 18, 11, 18, 12, 18, 289, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 301, 8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 316, 8, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 35, 1, 35, 1, 36, 1, 36, 1, 37, 1, 37, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 4, 49, 387, 8, 49, 11, 49, 12, 49, 388, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 401, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 5, 53, 416, 8, 53, 10, 53, 12, 53, 419, 9, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 4, 56, 438, 8, 56, 11, 56, 12, 56, 439, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 450, 8, 57, 1, 191, 0, 58, 4, 1, 6, 2, 8, 3, 10, 4, 12, 5, 14, 6, 16, 7, 18, 0, 20, 8, 22, 9, 24, 10, 26, 11, 28, 12, 30, 0, 32, 0, 34, 0, 36, 0, 38, 13, 40, 0, 42, 14, 44, 15, 46, 16, 48, 17, 50, 18, 52, 19, 54, 20, 56, 21, 58, 22, 60, 23, 62, 24, 64, 25, 66, 26, 68, 27, 70, 28, 72, 29, 74, 30, 76, 31, 78, 32, 80, 33, 82, 34, 84, 35, 86, 36, 88, 37, 90, 38, 92, 39, 94, 40, 96, 41, 98, 42, 100, 43, 102, 44, 104, 45, 106, 0, 108, 0, 110, 0, 112, 0, 114, 0, 116, 46, 118, 47, 4, 0, 1, 2, 3, 15, 4, 0, 10, 10, 13, 13, 34, 34, 36, 37, 3, 0, 9, 9, 12, 13, 32, 32, 2, 0, 10, 10, 13, 13, 1, 1, 10, 10, 1, 0, 48, 57, 4, 0, 36, 36, 65, 90, 95, 95, 97, 122, 2, 0, 0, 127, 55296, 56319, 1, 0, 55296, 56319, 1, 0, 56320, 57343, 5, 0, 34, 34, 92, 92, 110, 110, 114, 114, 116, 116, 3, 0, 48, 57, 65, 70, 97, 102, 2, 0, 69, 69, 101, 101, 2, 0, 43, 43, 45, 45, 3, 0, 10, 10, 13, 13, 36, 37, 1, 0, 123, 123, 485, 0, 4, 1, 0, 0, 0, 0, 6, 1, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 10, 1, 0, 0, 0, 0, 12, 1, 0, 0, 0, 0, 14, 1, 0, 0, 0, 0, 16, 1, 0, 0, 0, 0, 20, 1, 0, 0, 0, 0, 22, 1, 0, 0, 0, 0, 24, 1, 0, 0, 0, 0, 26, 1, 0, 0, 0, 0, 28, 1, 0, 0, 0, 0, 38, 1, 0, 0, 0, 0, 42, 1, 0, 0, 0, 0, 44, 1, 0, 0, 0, 0, 46, 1, 0, 0, 0, 0, 48, 1, 0, 0, 0, 0, 50, 1, 0, 0, 0, 0, 52, 1, 0, 0, 0, 0, 54, 1, 0, 0, 0, 0, 56, 1, 0, 0, 0, 0, 58, 1, 0, 0, 0, 0, 60, 1, 0, 0, 0, 0, 62, 1, 0, 0, 0, 0, 64, 1, 0, 0, 0, 0, 66, 1, 0, 0, 0, 0, 68, 1, 0, 0, 0, 0, 70, 1, 0, 0, 0, 0, 72, 1, 0, 0, 0, 0, 74, 1, 0, 0, 0, 0, 76, 1, 0, 0, 0, 0, 78, 1, 0, 0, 0, 0, 80, 1, 0, 0, 0, 0, 82, 1, 0, 0, 0, 0, 84, 1, 0, 0, 0, 0, 86, 1, 0, 0, 0, 0, 88, 1, 0, 0, 0, 0, 90, 1, 0, 0, 0, 0, 92, 1, 0, 0, 0, 0, 94, 1, 0, 0, 0, 0, 96, 1, 0, 0, 0, 0, 98, 1, 0, 0, 0, 1, 100, 1, 0, 0, 0, 1, 102, 1, 0, 0, 0, 1, 104, 1, 0, 0, 0, 1, 106, 1, 0, 0, 0, 2, 108, 1, 0, 0, 0, 2, 110, 1, 0, 0, 0, 3, 112, 1, 0, 0, 0, 3, 114, 1, 0, 0, 0, 3, 116, 1, 0, 0, 0, 3, 118, 1, 0, 0, 0, 4, 120, 1, 0, 0, 0, 6, 136, 1, 0, 0, 0, 8, 152, 1, 0, 0, 0, 10, 155, 1, 0, 0, 0, 12, 158, 1, 0, 0, 0, 14, 161, 1, 0, 0, 0, 16, 164, 1, 0, 0, 0, 18, 168, 1, 0, 0, 0, 20, 170, 1, 0, 0, 0, 22, 179, 1, 0, 0, 0, 24, 185, 1, 0, 0, 0, 26, 202, 1, 0, 0, 0, 28, 218, 1, 0, 0, 0, 30, 224, 1, 0, 0, 0, 32, 230, 1, 0, 0, 0, 34, 250, 1, 0, 0, 0, 36, 252, 1, 0, 0, 0, 38, 280, 1, 0, 0, 0, 40, 282, 1, 0, 0, 0, 42, 300, 1, 0, 0, 0, 44, 302, 1, 0, 0, 0, 46, 306, 1, 0, 0, 0, 48, 311, 1, 0, 0, 0, 50, 319, 1, 0, 0, 0, 52, 321, 1, 0, 0, 0, 54, 324, 1, 0, 0, 0, 56, 327, 1, 0, 0, 0, 58, 329, 1, 0, 0, 0, 60, 331, 1, 0, 0, 0, 62, 333, 1, 0, 0, 0, 64, 335, 1, 0, 0, 0, 66, 337, 1, 0, 0, 0, 68, 340, 1, 0, 0, 0, 70, 343, 1, 0, 0, 0, 72, 345, 1, 0, 0, 0, 74, 347, 1, 0, 0, 0, 76, 349, 1, 0, 0, 0, 78, 351, 1, 0, 0, 0, 80, 353, 1, 0, 0, 0, 82, 355, 1, 0, 0, 0, 84, 358, 1, 0, 0, 0, 86, 360, 1, 0, 0, 0, 88, 362, 1, 0, 0, 0, 90, 365, 1, 0, 0, 0, 92, 368, 1, 0, 0, 0, 94, 370, 1, 0, 0, 0, 96, 372, 1, 0, 0, 0, 98, 376, 1, 0, 0, 0, 100, 378, 1, 0, 0, 0, 102, 386, 1, 0, 0, 0, 104, 400, 1, 0, 0, 0, 106, 402, 1, 0, 0, 0, 108, 407, 1, 0, 0, 0, 110, 412, 1, 0, 0, 0, 112, 424, 1, 0, 0, 0, 114, 428, 1, 0, 0, 0, 116, 437, 1, 0, 0, 0, 118, 449, 1, 0, 0, 0, 120, 127, 5, 123, 0, 0, 121, 126, 3, 22, 9, 0, 122, 126, 3, 28, 12, 0, 123, 126, 3, 24, 10, 0, 124, 126, 3, 26, 11, 0, 125, 121, 1, 0, 0, 0, 125, 122, 1, 0, 0, 0, 125, 123, 1, 0, 0, 0, 125, 124, 1, 0, 0, 0, 126, 129, 1, 0, 0, 0, 127, 125, 1, 0, 0, 0, 127, 128, 1, 0, 0, 0, 128, 130, 1, 0, 0, 0, 129, 127, 1, 0, 0, 0, 130, 131, 5, 102, 0, 0, 131, 132, 5, 111, 0, 0, 132, 133, 5, 114, 0, 0, 133, 134, 1, 0, 0, 0, 134, 135, 3, 22, 9, 0, 135, 5, 1, 0, 0, 0, 136, 143, 5, 91, 0, 0, 137, 142, 3, 22, 9, 0, 138, 142, 3, 28, 12, 0, 139, 142, 3, 24, 10, 0, 140, 142, 3, 26, 11, 0, 141, 137, 1, 0, 0, 0, 141, 138, 1, 0, 0, 0, 141, 139, 1, 0, 0, 0, 141, 140, 1, 0, 0, 0, 142, 145, 1, 0, 0, 0, 143, 141, 1, 0, 0, 0, 143, 144, 1, 0, 0, 0, 144, 146, 1, 0, 0, 0, 145, 143, 1, 0, 0, 0, 146, 147, 5, 102, 0, 0, 147, 148, 5, 111, 0, 0, 148, 149, 5, 114, 0, 0, 149, 150, 1, 0, 0, 0, 150, 151, 3, 22, 9, 0, 151, 7, 1, 0, 0, 0, 152, 153, 5, 105, 0, 0, 153, 154, 5, 102, 0, 0, 154, 9, 1, 0, 0, 0, 155, 156, 5, 105, 0, 0, 156, 157, 5, 110, 0, 0, 157, 11, 1, 0, 0, 0, 158, 159, 5, 123, 0, 0, 159, 160, 6, 4, 0, 0, 160, 13, 1, 0, 0, 0, 161, 162, 5, 125, 0, 0, 162, 163, 6, 5, 1, 0, 163, 15, 1, 0, 0, 0, 164, 165, 5, 61, 0, 0, 165, 17, 1, 0, 0, 0, 166, 169, 8, 0, 0, 0, 167, 169, 3, 34, 15, 0, 168, 166, 1, 0, 0, 0, 168, 167, 1, 0, 0, 0, 169, 19, 1, 0, 0, 0, 170, 175, 3, 32, 14, 0, 171, 174, 3, 30, 13, 0, 172, 174, 5, 45, 0, 0, 173, 171, 1, 0, 0, 0, 173, 172, 1, 0, 0, 0, 174, 177, 1, 0, 0, 0, 175, 173, 1, 0, 0, 0, 175, 176, 1, 0, 0, 0, 176, 21, 1, 0, 0, 0, 177, 175, 1, 0, 0, 0, 178, 180, 7, 1, 0, 0, 179, 178, 1, 0, 0, 0, 180, 181, 1, 0, 0, 0, 181, 179, 1, 0, 0, 0, 181, 182, 1, 0, 0, 0, 182, 183, 1, 0, 0, 0, 183, 184, 6, 9, 2, 0, 184, 23, 1, 0, 0, 0, 185, 186, 5, 47, 0, 0, 186, 187, 5, 42, 0, 0, 187, 191, 1, 0, 0, 0, 188, 190, 9, 0, 0, 0, 189, 188, 1, 0, 0, 0, 190, 193, 1, 0, 0, 0, 191, 192, 1, 0, 0, 0, 191, 189, 1, 0, 0, 0, 192, 194, 1, 0, 0, 0, 193, 191, 1, 0, 0, 0, 194, 195, 5, 42, 0, 0, 195, 196, 5, 47, 0, 0, 196, 197, 1, 0, 0, 0, 197, 198, 6, 10, 2, 0, 198, 25, 1, 0, 0, 0, 199, 200, 5, 47, 0, 0, 200, 203, 5, 47, 0, 0, 201, 203, 5, 35, 0, 0, 202, 199, 1, 0, 0, 0, 202, 201, 1, 0, 0, 0, 203, 207, 1, 0, 0, 0, 204, 206, 8, 2, 0, 0, 205, 204, 1, 0, 0, 0, 206, 209, 1, 0, 0, 0, 207, 205, 1, 0, 0, 0, 207, 208, 1, 0, 0, 0, 208, 211, 1, 0, 0, 0, 209, 207, 1, 0, 0, 0, 210, 212, 5, 13, 0, 0, 211, 210, 1, 0, 0, 0, 211, 212, 1, 0, 0, 0, 212, 214, 1, 0, 0, 0, 213, 215, 7, 3, 0, 0, 214, 213, 1, 0, 0, 0, 215, 216, 1, 0, 0, 0, 216, 217, 6, 11, 2, 0, 217, 27, 1, 0, 0, 0, 218, 219, 5, 10, 0, 0, 219, 220, 1, 0, 0, 0, 220, 221, 6, 12, 2, 0, 221, 29, 1, 0, 0, 0, 222, 225, 3, 32, 14, 0, 223, 225, 7, 4, 0, 0, 224, 222, 1, 0, 0, 0, 224, 223, 1, 0, 0, 0, 225, 31, 1, 0, 0, 0, 226, 231, 7, 5, 0, 0, 227, 231, 8, 6, 0, 0, 228, 229, 7, 7, 0, 0, 229, 231, 7, 8, 0, 0, 230, 226, 1, 0, 0, 0, 230, 227, 1, 0, 0, 0, 230, 228, 1, 0, 0, 0, 231, 33, 1, 0, 0, 0, 232, 233, 5, 92, 0, 0, 233, 251, 7, 9, 0, 0, 234, 235, 5, 92, 0, 0, 235, 236, 3, 36, 16, 0, 236, 237, 3, 36, 16, 0, 237, 238, 3, 36, 16, 0, 238, 239, 3, 36, 16, 0, 239, 251, 1, 0, 0, 0, 240, 241, 5, 92, 0, 0, 241, 242, 3, 36, 16, 0, 242, 243, 3, 36, 16, 0, 243, 244, 3, 36, 16, 0, 244, 245, 3, 36, 16, 0, 245, 246, 3, 36, 16, 0, 246, 247, 3, 36, 16, 0, 247, 248, 3, 36, 16, 0, 248, 249, 3, 36, 16, 0, 249, 251, 1, 0, 0, 0, 250, 232, 1, 0, 0, 0, 250, 234, 1, 0, 0, 0, 250, 240, 1, 0, 0, 0, 251, 35, 1, 0, 0, 0, 252, 253, 7, 10, 0, 0, 253, 37, 1, 0, 0, 0, 254, 256, 7, 4, 0, 0, 255, 254, 1, 0, 0, 0, 256, 257, 1, 0, 0, 0, 257, 255, 1, 0, 0, 0, 257, 258, 1, 0, 0, 0, 258, 259, 1, 0, 0, 0, 259, 263, 5, 46, 0, 0, 260, 262, 7, 4, 0, 0, 261, 260, 1, 0, 0, 0, 262, 265, 1, 0, 0, 0, 263, 261, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 267, 1, 0, 0, 0, 265, 263, 1, 0, 0, 0, 266, 268, 3, 40, 18, 0, 267, 266, 1, 0, 0, 0, 267, 268, 1, 0, 0, 0, 268, 281, 1, 0, 0, 0, 269, 271, 7, 4, 0, 0, 270, 269, 1, 0, 0, 0, 271, 272, 1, 0, 0, 0, 272, 270, 1, 0, 0, 0, 272, 273, 1, 0, 0, 0, 273, 274, 1, 0, 0, 0, 274, 281, 3, 40, 18, 0, 275, 277, 7, 4, 0, 0, 276, 275, 1, 0, 0, 0, 277, 278, 1, 0, 0, 0, 278, 276, 1, 0, 0, 0, 278, 279, 1, 0, 0, 0, 279, 281, 1, 0, 0, 0, 280, 255, 1, 0, 0, 0, 280, 270, 1, 0, 0, 0, 280, 276, 1, 0, 0, 0, 281, 39, 1, 0, 0, 0, 282, 284, 7, 11, 0, 0, 283, 285, 7, 12, 0, 0, 284, 283, 1, 0, 0, 0, 284, 285, 1, 0, 0, 0, 285, 287, 1, 0, 0, 0, 286, 288, 7, 4, 0, 0, 287, 286, 1, 0, 0, 0, 288, 289, 1, 0, 0, 0, 289, 287, 1, 0, 0, 0, 289, 290, 1, 0, 0, 0, 290, 41, 1, 0, 0, 0, 291, 292, 5, 116, 0, 0, 292, 293, 5, 114, 0, 0, 293, 294, 5, 117, 0, 0, 294, 301, 5, 101, 0, 0, 295, 296, 5, 102, 0, 0, 296, 297, 5, 97, 0, 0, 297, 298, 5, 108, 0, 0, 298, 299, 5, 115, 0, 0, 299, 301, 5, 101, 0, 0, 300, 291, 1, 0, 0, 0, 300, 295, 1, 0, 0, 0, 301, 43, 1, 0, 0, 0, 302, 303, 5, 34, 0, 0, 303, 304, 1, 0, 0, 0, 304, 305, 6, 20, 3, 0, 305, 45, 1, 0, 0, 0, 306, 307, 5, 110, 0, 0, 307, 308, 5, 117, 0, 0, 308, 309, 5, 108, 0, 0, 309, 310, 5, 108, 0, 0, 310, 47, 1, 0, 0, 0, 311, 312, 5, 60, 0, 0, 312, 313, 5, 60, 0, 0, 313, 315, 1, 0, 0, 0, 314, 316, 5, 45, 0, 0, 315, 314, 1, 0, 0, 0, 315, 316, 1, 0, 0, 0, 316, 317, 1, 0, 0, 0, 317, 318, 6, 22, 4, 0, 318, 49, 1, 0, 0, 0, 319, 320, 5, 43, 0, 0, 320, 51, 1, 0, 0, 0, 321, 322, 5, 38, 0, 0, 322, 323, 5, 38, 0, 0, 323, 53, 1, 0, 0, 0, 324, 325, 5, 61, 0, 0, 325, 326, 5, 61, 0, 0, 326, 55, 1, 0, 0, 0, 327, 328, 5, 60, 0, 0, 328, 57, 1, 0, 0, 0, 329, 330, 5, 58, 0, 0, 330, 59, 1, 0, 0, 0, 331, 332, 5, 91, 0, 0, 332, 61, 1, 0, 0, 0, 333, 334, 5, 40, 0, 0, 334, 63, 1, 0, 0, 0, 335, 336, 5, 45, 0, 0, 336, 65, 1, 0, 0, 0, 337, 338, 5, 124, 0, 0, 338, 339, 5, 124, 0, 0, 339, 67, 1, 0, 0, 0, 340, 341, 5, 33, 0, 0, 341, 342, 5, 61, 0, 0, 342, 69, 1, 0, 0, 0, 343, 344, 5, 62, 0, 0, 344, 71, 1, 0, 0, 0, 345, 346, 5, 63, 0, 0, 346, 73, 1, 0, 0, 0, 347, 348, 5, 93, 0, 0, 348, 75, 1, 0, 0, 0, 349, 350, 5, 41, 0, 0, 350, 77, 1, 0, 0, 0, 351, 352, 5, 42, 0, 0, 352, 79, 1, 0, 0, 0, 353, 354, 5, 33, 0, 0, 354, 81, 1, 0, 0, 0, 355, 356, 5, 60, 0, 0, 356, 357, 5, 61, 0, 0, 357, 83, 1, 0, 0, 0, 358, 359, 5, 46, 0, 0, 359, 85, 1, 0, 0, 0, 360, 361, 5, 47, 0, 0, 361, 87, 1, 0, 0, 0, 362, 363, 5, 62, 0, 0, 363, 364, 5, 61, 0, 0, 364, 89, 1, 0, 0, 0, 365, 366, 5, 61, 0, 0, 366, 367, 5, 62, 0, 0, 367, 91, 1, 0, 0, 0, 368, 369, 5, 44, 0, 0, 369, 93, 1, 0, 0, 0, 370, 371, 5, 37, 0, 0, 371, 95, 1, 0, 0, 0, 372, 373, 5, 46, 0, 0, 373, 374, 5, 46, 0, 0, 374, 375, 5, 46, 0, 0, 375, 97, 1, 0, 0, 0, 376, 377, 5, 126, 0, 0, 377, 99, 1, 0, 0, 0, 378, 379, 5, 36, 0, 0, 379, 380, 5, 123, 0, 0, 380, 381, 1, 0, 0, 0, 381, 382, 6, 48, 5, 0, 382, 383, 1, 0, 0, 0, 383, 384, 6, 48, 6, 0, 384, 101, 1, 0, 0, 0, 385, 387, 3, 104, 50, 0, 386, 385, 1, 0, 0, 0, 387, 388, 1, 0, 0, 0, 388, 386, 1, 0, 0, 0, 388, 389, 1, 0, 0, 0, 389, 103, 1, 0, 0, 0, 390, 401, 8, 0, 0, 0, 391, 392, 5, 36, 0, 0, 392, 401, 5, 36, 0, 0, 393, 394, 5, 36, 0, 0, 394, 401, 4, 50, 0, 0, 395, 396, 5, 37, 0, 0, 396, 401, 5, 37, 0, 0, 397, 398, 5, 37, 0, 0, 398, 401, 4, 50, 1, 0, 399, 401, 3, 34, 15, 0, 400, 390, 1, 0, 0, 0, 400, 391, 1, 0, 0, 0, 400, 393, 1, 0, 0, 0, 400, 395, 1, 0, 0, 0, 400, 397, 1, 0, 0, 0, 400, 399, 1, 0, 0, 0, 401, 105, 1, 0, 0, 0, 402, 403, 5, 34, 0, 0, 403, 404, 1, 0, 0, 0, 404, 405, 6, 51, 7, 0, 405, 406, 6, 51, 8, 0, 406, 107, 1, 0, 0, 0, 407, 408, 5, 10, 0, 0, 408, 409, 1, 0, 0, 0, 409, 410, 6, 52, 9, 0, 410, 411, 6, 52, 10, 0, 411, 109, 1, 0, 0, 0, 412, 417, 3, 32, 14, 0, 413, 416, 3, 30, 13, 0, 414, 416, 5, 45, 0, 0, 415, 413, 1, 0, 0, 0, 415, 414, 1, 0, 0, 0, 416, 419, 1, 0, 0, 0, 417, 415, 1, 0, 0, 0, 417, 418, 1, 0, 0, 0, 418, 420, 1, 0, 0, 0, 419, 417, 1, 0, 0, 0, 420, 421, 6, 53, 11, 0, 421, 422, 1, 0, 0, 0, 422, 423, 6, 53, 12, 0, 423, 111, 1, 0, 0, 0, 424, 425, 5, 10, 0, 0, 425, 426, 1, 0, 0, 0, 426, 427, 6, 54, 9, 0, 427, 113, 1, 0, 0, 0, 428, 429, 5, 36, 0, 0, 429, 430, 5, 123, 0, 0, 430, 431, 1, 0, 0, 0, 431, 432, 6, 55, 13, 0, 432, 433, 1, 0, 0, 0, 433, 434, 6, 55, 14, 0, 434, 435, 6, 55, 6, 0, 435, 115, 1, 0, 0, 0, 436, 438, 3, 118, 57, 0, 437, 436, 1, 0, 0, 0, 438, 439, 1, 0, 0, 0, 439, 437, 1, 0, 0, 0, 439, 440, 1, 0, 0, 0, 440, 441, 1, 0, 0, 0, 441, 442, 6, 56, 15, 0, 442, 117, 1, 0, 0, 0, 443, 450, 8, 13, 0, 0, 444, 445, 5, 36, 0, 0, 445, 450, 8, 14, 0, 0, 446, 447, 5, 37, 0, 0, 447, 450, 8, 14, 0, 0, 448, 450, 3, 34, 15, 0, 449, 443, 1, 0, 0, 0, 449, 444, 1, 0, 0, 0, 449, 446, 1, 0, 0, 0, 449, 448, 1, 0, 0, 0, 450, 119, 1, 0, 0, 0, 36, 0, 1, 2, 3, 125, 127, 141, 143, 168, 173, 175, 181, 191, 202, 207, 211, 214, 224, 230, 250, 257, 263, 267, 272, 278, 280, 284, 289, 300, 315, 388, 400, 415, 417, 439, 449, 16, 1, 4, 0, 1, 5, 1, 0, 1, 0, 5, 1, 0, 5, 2, 0, 1, 48, 2, 5, 0, 0, 7, 15, 0, 4, 0, 0, 7, 12, 0, 2, 3, 0, 1, 53, 3, 7, 8, 0, 1, 55, 4, 7, 43, 0, 1, 56, 5]\n\\ No newline at end of file\n\ndiff --git a/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.java b/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.java\nindex e952ee91f0a..d35cc37fe7c 100644\n--- a/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.java\n+++ b/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.java\n@@ -257,7 +257,7 @@ private boolean TemplateStringLiteralChar_sempred(RuleContext _localctx, int pre\n \t}\n \n \tpublic static final String _serializedATN =\n-\t\t\"\\u0004\\u0000/\\u01c2\\u0006\\uffff\\uffff\\u0006\\uffff\\uffff\\u0006\\uffff\\uffff\"+\n+\t\t\"\\u0004\\u0000/\\u01c3\\u0006\\uffff\\uffff\\u0006\\uffff\\uffff\\u0006\\uffff\\uffff\"+\n \t\t\"\\u0006\\uffff\\uffff\\u0002\\u0000\\u0007\\u0000\\u0002\\u0001\\u0007\\u0001\\u0002\"+\n \t\t\"\\u0002\\u0007\\u0002\\u0002\\u0003\\u0007\\u0003\\u0002\\u0004\\u0007\\u0004\\u0002\"+\n \t\t\"\\u0005\\u0007\\u0005\\u0002\\u0006\\u0007\\u0006\\u0002\\u0007\\u0007\\u0007\\u0002\"+\n@@ -287,24 +287,24 @@ private boolean TemplateStringLiteralChar_sempred(RuleContext _localctx, int pre\n \t\t\"\\b\\n\\n\\n\\f\\n\\u00c1\\t\\n\\u0001\\n\\u0001\\n\\u0001\\n\\u0001\\n\\u0001\\n\\u0001\\u000b\"+\n \t\t\"\\u0001\\u000b\\u0001\\u000b\\u0003\\u000b\\u00cb\\b\\u000b\\u0001\\u000b\\u0005\\u000b\"+\n \t\t\"\\u00ce\\b\\u000b\\n\\u000b\\f\\u000b\\u00d1\\t\\u000b\\u0001\\u000b\\u0003\\u000b\\u00d4\"+\n-\t\t\"\\b\\u000b\\u0001\\u000b\\u0001\\u000b\\u0001\\u000b\\u0001\\u000b\\u0001\\f\\u0001\"+\n-\t\t\"\\f\\u0001\\f\\u0001\\f\\u0001\\r\\u0001\\r\\u0003\\r\\u00e0\\b\\r\\u0001\\u000e\\u0001\"+\n-\t\t\"\\u000e\\u0001\\u000e\\u0001\\u000e\\u0003\\u000e\\u00e6\\b\\u000e\\u0001\\u000f\\u0001\"+\n+\t\t\"\\b\\u000b\\u0001\\u000b\\u0003\\u000b\\u00d7\\b\\u000b\\u0001\\u000b\\u0001\\u000b\"+\n+\t\t\"\\u0001\\f\\u0001\\f\\u0001\\f\\u0001\\f\\u0001\\r\\u0001\\r\\u0003\\r\\u00e1\\b\\r\\u0001\"+\n+\t\t\"\\u000e\\u0001\\u000e\\u0001\\u000e\\u0001\\u000e\\u0003\\u000e\\u00e7\\b\\u000e\\u0001\"+\n \t\t\"\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\"+\n \t\t\"\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\"+\n-\t\t\"\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0003\\u000f\\u00fa\"+\n-\t\t\"\\b\\u000f\\u0001\\u0010\\u0001\\u0010\\u0001\\u0011\\u0004\\u0011\\u00ff\\b\\u0011\"+\n-\t\t\"\\u000b\\u0011\\f\\u0011\\u0100\\u0001\\u0011\\u0001\\u0011\\u0005\\u0011\\u0105\\b\"+\n-\t\t\"\\u0011\\n\\u0011\\f\\u0011\\u0108\\t\\u0011\\u0001\\u0011\\u0003\\u0011\\u010b\\b\\u0011\"+\n-\t\t\"\\u0001\\u0011\\u0004\\u0011\\u010e\\b\\u0011\\u000b\\u0011\\f\\u0011\\u010f\\u0001\"+\n-\t\t\"\\u0011\\u0001\\u0011\\u0004\\u0011\\u0114\\b\\u0011\\u000b\\u0011\\f\\u0011\\u0115\"+\n-\t\t\"\\u0003\\u0011\\u0118\\b\\u0011\\u0001\\u0012\\u0001\\u0012\\u0003\\u0012\\u011c\\b\"+\n-\t\t\"\\u0012\\u0001\\u0012\\u0004\\u0012\\u011f\\b\\u0012\\u000b\\u0012\\f\\u0012\\u0120\"+\n+\t\t\"\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0003\"+\n+\t\t\"\\u000f\\u00fb\\b\\u000f\\u0001\\u0010\\u0001\\u0010\\u0001\\u0011\\u0004\\u0011\\u0100\"+\n+\t\t\"\\b\\u0011\\u000b\\u0011\\f\\u0011\\u0101\\u0001\\u0011\\u0001\\u0011\\u0005\\u0011\"+\n+\t\t\"\\u0106\\b\\u0011\\n\\u0011\\f\\u0011\\u0109\\t\\u0011\\u0001\\u0011\\u0003\\u0011\\u010c\"+\n+\t\t\"\\b\\u0011\\u0001\\u0011\\u0004\\u0011\\u010f\\b\\u0011\\u000b\\u0011\\f\\u0011\\u0110\"+\n+\t\t\"\\u0001\\u0011\\u0001\\u0011\\u0004\\u0011\\u0115\\b\\u0011\\u000b\\u0011\\f\\u0011\"+\n+\t\t\"\\u0116\\u0003\\u0011\\u0119\\b\\u0011\\u0001\\u0012\\u0001\\u0012\\u0003\\u0012\\u011d\"+\n+\t\t\"\\b\\u0012\\u0001\\u0012\\u0004\\u0012\\u0120\\b\\u0012\\u000b\\u0012\\f\\u0012\\u0121\"+\n \t\t\"\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\"+\n-\t\t\"\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0003\\u0013\\u012c\\b\\u0013\\u0001\\u0014\"+\n+\t\t\"\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0003\\u0013\\u012d\\b\\u0013\\u0001\\u0014\"+\n \t\t\"\\u0001\\u0014\\u0001\\u0014\\u0001\\u0014\\u0001\\u0015\\u0001\\u0015\\u0001\\u0015\"+\n \t\t\"\\u0001\\u0015\\u0001\\u0015\\u0001\\u0016\\u0001\\u0016\\u0001\\u0016\\u0001\\u0016\"+\n-\t\t\"\\u0003\\u0016\\u013b\\b\\u0016\\u0001\\u0016\\u0001\\u0016\\u0001\\u0017\\u0001\\u0017\"+\n+\t\t\"\\u0003\\u0016\\u013c\\b\\u0016\\u0001\\u0016\\u0001\\u0016\\u0001\\u0017\\u0001\\u0017\"+\n \t\t\"\\u0001\\u0018\\u0001\\u0018\\u0001\\u0018\\u0001\\u0019\\u0001\\u0019\\u0001\\u0019\"+\n \t\t\"\\u0001\\u001a\\u0001\\u001a\\u0001\\u001b\\u0001\\u001b\\u0001\\u001c\\u0001\\u001c\"+\n \t\t\"\\u0001\\u001d\\u0001\\u001d\\u0001\\u001e\\u0001\\u001e\\u0001\\u001f\\u0001\\u001f\"+\n@@ -312,250 +312,252 @@ private boolean TemplateStringLiteralChar_sempred(RuleContext _localctx, int pre\n \t\t\"#\\u0001#\\u0001$\\u0001$\\u0001%\\u0001%\\u0001&\\u0001&\\u0001\\'\\u0001\\'\\u0001\"+\n \t\t\"\\'\\u0001(\\u0001(\\u0001)\\u0001)\\u0001*\\u0001*\\u0001*\\u0001+\\u0001+\\u0001\"+\n \t\t\"+\\u0001,\\u0001,\\u0001-\\u0001-\\u0001.\\u0001.\\u0001.\\u0001.\\u0001/\\u0001\"+\n-\t\t\"/\\u00010\\u00010\\u00010\\u00010\\u00010\\u00010\\u00010\\u00011\\u00041\\u0182\"+\n-\t\t\"\\b1\\u000b1\\f1\\u0183\\u00012\\u00012\\u00012\\u00012\\u00012\\u00012\\u00012\\u0001\"+\n-\t\t\"2\\u00012\\u00012\\u00032\\u0190\\b2\\u00013\\u00013\\u00013\\u00013\\u00013\\u0001\"+\n-\t\t\"4\\u00014\\u00014\\u00014\\u00014\\u00015\\u00015\\u00015\\u00055\\u019f\\b5\\n5\"+\n-\t\t\"\\f5\\u01a2\\t5\\u00015\\u00015\\u00015\\u00015\\u00016\\u00016\\u00016\\u00016\\u0001\"+\n-\t\t\"7\\u00017\\u00017\\u00017\\u00017\\u00017\\u00017\\u00017\\u00018\\u00048\\u01b5\"+\n-\t\t\"\\b8\\u000b8\\f8\\u01b6\\u00018\\u00018\\u00019\\u00019\\u00019\\u00019\\u00019\\u0001\"+\n-\t\t\"9\\u00039\\u01c1\\b9\\u0001\\u00bf\\u0000:\\u0004\\u0001\\u0006\\u0002\\b\\u0003\\n\"+\n+\t\t\"/\\u00010\\u00010\\u00010\\u00010\\u00010\\u00010\\u00010\\u00011\\u00041\\u0183\"+\n+\t\t\"\\b1\\u000b1\\f1\\u0184\\u00012\\u00012\\u00012\\u00012\\u00012\\u00012\\u00012\\u0001\"+\n+\t\t\"2\\u00012\\u00012\\u00032\\u0191\\b2\\u00013\\u00013\\u00013\\u00013\\u00013\\u0001\"+\n+\t\t\"4\\u00014\\u00014\\u00014\\u00014\\u00015\\u00015\\u00015\\u00055\\u01a0\\b5\\n5\"+\n+\t\t\"\\f5\\u01a3\\t5\\u00015\\u00015\\u00015\\u00015\\u00016\\u00016\\u00016\\u00016\\u0001\"+\n+\t\t\"7\\u00017\\u00017\\u00017\\u00017\\u00017\\u00017\\u00017\\u00018\\u00048\\u01b6\"+\n+\t\t\"\\b8\\u000b8\\f8\\u01b7\\u00018\\u00018\\u00019\\u00019\\u00019\\u00019\\u00019\\u0001\"+\n+\t\t\"9\\u00039\\u01c2\\b9\\u0001\\u00bf\\u0000:\\u0004\\u0001\\u0006\\u0002\\b\\u0003\\n\"+\n \t\t\"\\u0004\\f\\u0005\\u000e\\u0006\\u0010\\u0007\\u0012\\u0000\\u0014\\b\\u0016\\t\\u0018\"+\n \t\t\"\\n\\u001a\\u000b\\u001c\\f\\u001e\\u0000 \\u0000\\\"\\u0000$\\u0000&\\r(\\u0000*\\u000e\"+\n \t\t\",\\u000f.\\u00100\\u00112\\u00124\\u00136\\u00148\\u0015:\\u0016<\\u0017>\\u0018\"+\n \t\t\"@\\u0019B\\u001aD\\u001bF\\u001cH\\u001dJ\\u001eL\\u001fN P!R\\\"T#V$X%Z&\\\\\\'^\"+\n \t\t\"(`)b*d+f,h-j\\u0000l\\u0000n\\u0000p\\u0000r\\u0000t.v/\\u0004\\u0000\\u0001\\u0002\"+\n-\t\t\"\\u0003\\u000e\\u0004\\u0000\\n\\n\\r\\r\\\"\\\"$%\\u0003\\u0000\\t\\t\\f\\r  \\u0002\\u0000\"+\n-\t\t\"\\n\\n\\r\\r\\u0001\\u000009\\u0004\\u0000$$AZ__az\\u0002\\u0000\\u0000\\u007f\\u8000\"+\n-\t\t\"\\ud800\\u8000\\udbff\\u0001\\u0000\\u8000\\ud800\\u8000\\udbff\\u0001\\u0000\\u8000\"+\n-\t\t\"\\udc00\\u8000\\udfff\\u0005\\u0000\\\"\\\"\\\\\\\\nnrrtt\\u0003\\u000009AFaf\\u0002\\u0000\"+\n-\t\t\"EEee\\u0002\\u0000++--\\u0003\\u0000\\n\\n\\r\\r$%\\u0001\\u0000{{\\u01e4\\u0000\\u0004\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0000\\u0006\\u0001\\u0000\\u0000\\u0000\\u0000\\b\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0000\\n\\u0001\\u0000\\u0000\\u0000\\u0000\\f\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u000e\\u0001\\u0000\\u0000\\u0000\\u0000\\u0010\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0014\\u0001\\u0000\\u0000\\u0000\\u0000\\u0016\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0018\\u0001\\u0000\\u0000\\u0000\\u0000\\u001a\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u001c\\u0001\\u0000\\u0000\\u0000\\u0000&\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0000*\\u0001\\u0000\\u0000\\u0000\\u0000,\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n-\t\t\".\\u0001\\u0000\\u0000\\u0000\\u00000\\u0001\\u0000\\u0000\\u0000\\u00002\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u00004\\u0001\\u0000\\u0000\\u0000\\u00006\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u00008\\u0001\\u0000\\u0000\\u0000\\u0000:\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n-\t\t\"<\\u0001\\u0000\\u0000\\u0000\\u0000>\\u0001\\u0000\\u0000\\u0000\\u0000@\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0000B\\u0001\\u0000\\u0000\\u0000\\u0000D\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0000F\\u0001\\u0000\\u0000\\u0000\\u0000H\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n-\t\t\"J\\u0001\\u0000\\u0000\\u0000\\u0000L\\u0001\\u0000\\u0000\\u0000\\u0000N\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0000P\\u0001\\u0000\\u0000\\u0000\\u0000R\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0000T\\u0001\\u0000\\u0000\\u0000\\u0000V\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n-\t\t\"X\\u0001\\u0000\\u0000\\u0000\\u0000Z\\u0001\\u0000\\u0000\\u0000\\u0000\\\\\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0000^\\u0001\\u0000\\u0000\\u0000\\u0000`\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0000b\\u0001\\u0000\\u0000\\u0000\\u0001d\\u0001\\u0000\\u0000\\u0000\\u0001\"+\n-\t\t\"f\\u0001\\u0000\\u0000\\u0000\\u0001h\\u0001\\u0000\\u0000\\u0000\\u0001j\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0002l\\u0001\\u0000\\u0000\\u0000\\u0002n\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0003p\\u0001\\u0000\\u0000\\u0000\\u0003r\\u0001\\u0000\\u0000\\u0000\\u0003\"+\n-\t\t\"t\\u0001\\u0000\\u0000\\u0000\\u0003v\\u0001\\u0000\\u0000\\u0000\\u0004x\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0006\\u0088\\u0001\\u0000\\u0000\\u0000\\b\\u0098\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\n\\u009b\\u0001\\u0000\\u0000\\u0000\\f\\u009e\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u000e\\u00a1\\u0001\\u0000\\u0000\\u0000\\u0010\\u00a4\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0012\\u00a8\\u0001\\u0000\\u0000\\u0000\\u0014\\u00aa\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0016\\u00b3\\u0001\\u0000\\u0000\\u0000\\u0018\\u00b9\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u001a\\u00ca\\u0001\\u0000\\u0000\\u0000\\u001c\\u00d9\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u001e\\u00df\\u0001\\u0000\\u0000\\u0000 \\u00e5\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\\"\\u00f9\\u0001\\u0000\\u0000\\u0000$\\u00fb\\u0001\\u0000\\u0000\\u0000&\\u0117\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000(\\u0119\\u0001\\u0000\\u0000\\u0000*\\u012b\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000,\\u012d\\u0001\\u0000\\u0000\\u0000.\\u0131\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"0\\u0136\\u0001\\u0000\\u0000\\u00002\\u013e\\u0001\\u0000\\u0000\\u00004\\u0140\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u00006\\u0143\\u0001\\u0000\\u0000\\u00008\\u0146\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000:\\u0148\\u0001\\u0000\\u0000\\u0000<\\u014a\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\">\\u014c\\u0001\\u0000\\u0000\\u0000@\\u014e\\u0001\\u0000\\u0000\\u0000B\\u0150\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000D\\u0153\\u0001\\u0000\\u0000\\u0000F\\u0156\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000H\\u0158\\u0001\\u0000\\u0000\\u0000J\\u015a\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"L\\u015c\\u0001\\u0000\\u0000\\u0000N\\u015e\\u0001\\u0000\\u0000\\u0000P\\u0160\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000R\\u0162\\u0001\\u0000\\u0000\\u0000T\\u0165\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000V\\u0167\\u0001\\u0000\\u0000\\u0000X\\u0169\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"Z\\u016c\\u0001\\u0000\\u0000\\u0000\\\\\\u016f\\u0001\\u0000\\u0000\\u0000^\\u0171\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000`\\u0173\\u0001\\u0000\\u0000\\u0000b\\u0177\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000d\\u0179\\u0001\\u0000\\u0000\\u0000f\\u0181\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"h\\u018f\\u0001\\u0000\\u0000\\u0000j\\u0191\\u0001\\u0000\\u0000\\u0000l\\u0196\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000n\\u019b\\u0001\\u0000\\u0000\\u0000p\\u01a7\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000r\\u01ab\\u0001\\u0000\\u0000\\u0000t\\u01b4\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"v\\u01c0\\u0001\\u0000\\u0000\\u0000x\\u007f\\u0005{\\u0000\\u0000y~\\u0003\\u0016\"+\n-\t\t\"\\t\\u0000z~\\u0003\\u001c\\f\\u0000{~\\u0003\\u0018\\n\\u0000|~\\u0003\\u001a\\u000b\"+\n-\t\t\"\\u0000}y\\u0001\\u0000\\u0000\\u0000}z\\u0001\\u0000\\u0000\\u0000}{\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000}|\\u0001\\u0000\\u0000\\u0000~\\u0081\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u007f}\\u0001\\u0000\\u0000\\u0000\\u007f\\u0080\\u0001\\u0000\\u0000\\u0000\\u0080\"+\n-\t\t\"\\u0082\\u0001\\u0000\\u0000\\u0000\\u0081\\u007f\\u0001\\u0000\\u0000\\u0000\\u0082\"+\n-\t\t\"\\u0083\\u0005f\\u0000\\u0000\\u0083\\u0084\\u0005o\\u0000\\u0000\\u0084\\u0085\\u0005\"+\n-\t\t\"r\\u0000\\u0000\\u0085\\u0086\\u0001\\u0000\\u0000\\u0000\\u0086\\u0087\\u0003\\u0016\"+\n-\t\t\"\\t\\u0000\\u0087\\u0005\\u0001\\u0000\\u0000\\u0000\\u0088\\u008f\\u0005[\\u0000\"+\n-\t\t\"\\u0000\\u0089\\u008e\\u0003\\u0016\\t\\u0000\\u008a\\u008e\\u0003\\u001c\\f\\u0000\"+\n-\t\t\"\\u008b\\u008e\\u0003\\u0018\\n\\u0000\\u008c\\u008e\\u0003\\u001a\\u000b\\u0000\\u008d\"+\n-\t\t\"\\u0089\\u0001\\u0000\\u0000\\u0000\\u008d\\u008a\\u0001\\u0000\\u0000\\u0000\\u008d\"+\n-\t\t\"\\u008b\\u0001\\u0000\\u0000\\u0000\\u008d\\u008c\\u0001\\u0000\\u0000\\u0000\\u008e\"+\n-\t\t\"\\u0091\\u0001\\u0000\\u0000\\u0000\\u008f\\u008d\\u0001\\u0000\\u0000\\u0000\\u008f\"+\n-\t\t\"\\u0090\\u0001\\u0000\\u0000\\u0000\\u0090\\u0092\\u0001\\u0000\\u0000\\u0000\\u0091\"+\n-\t\t\"\\u008f\\u0001\\u0000\\u0000\\u0000\\u0092\\u0093\\u0005f\\u0000\\u0000\\u0093\\u0094\"+\n-\t\t\"\\u0005o\\u0000\\u0000\\u0094\\u0095\\u0005r\\u0000\\u0000\\u0095\\u0096\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0096\\u0097\\u0003\\u0016\\t\\u0000\\u0097\\u0007\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0098\\u0099\\u0005i\\u0000\\u0000\\u0099\\u009a\\u0005f\\u0000\\u0000\\u009a\"+\n-\t\t\"\\t\\u0001\\u0000\\u0000\\u0000\\u009b\\u009c\\u0005i\\u0000\\u0000\\u009c\\u009d\"+\n-\t\t\"\\u0005n\\u0000\\u0000\\u009d\\u000b\\u0001\\u0000\\u0000\\u0000\\u009e\\u009f\\u0005\"+\n-\t\t\"{\\u0000\\u0000\\u009f\\u00a0\\u0006\\u0004\\u0000\\u0000\\u00a0\\r\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u00a1\\u00a2\\u0005}\\u0000\\u0000\\u00a2\\u00a3\\u0006\\u0005\\u0001\"+\n-\t\t\"\\u0000\\u00a3\\u000f\\u0001\\u0000\\u0000\\u0000\\u00a4\\u00a5\\u0005=\\u0000\\u0000\"+\n-\t\t\"\\u00a5\\u0011\\u0001\\u0000\\u0000\\u0000\\u00a6\\u00a9\\b\\u0000\\u0000\\u0000\\u00a7\"+\n-\t\t\"\\u00a9\\u0003\\\"\\u000f\\u0000\\u00a8\\u00a6\\u0001\\u0000\\u0000\\u0000\\u00a8\\u00a7\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00a9\\u0013\\u0001\\u0000\\u0000\\u0000\\u00aa\\u00af\"+\n-\t\t\"\\u0003 \\u000e\\u0000\\u00ab\\u00ae\\u0003\\u001e\\r\\u0000\\u00ac\\u00ae\\u0005\"+\n-\t\t\"-\\u0000\\u0000\\u00ad\\u00ab\\u0001\\u0000\\u0000\\u0000\\u00ad\\u00ac\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u00ae\\u00b1\\u0001\\u0000\\u0000\\u0000\\u00af\\u00ad\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u00af\\u00b0\\u0001\\u0000\\u0000\\u0000\\u00b0\\u0015\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u00b1\\u00af\\u0001\\u0000\\u0000\\u0000\\u00b2\\u00b4\\u0007\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u00b3\\u00b2\\u0001\\u0000\\u0000\\u0000\\u00b4\\u00b5\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u00b5\\u00b3\\u0001\\u0000\\u0000\\u0000\\u00b5\\u00b6\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u00b6\\u00b7\\u0001\\u0000\\u0000\\u0000\\u00b7\\u00b8\\u0006\\t\\u0002\"+\n-\t\t\"\\u0000\\u00b8\\u0017\\u0001\\u0000\\u0000\\u0000\\u00b9\\u00ba\\u0005/\\u0000\\u0000\"+\n-\t\t\"\\u00ba\\u00bb\\u0005*\\u0000\\u0000\\u00bb\\u00bf\\u0001\\u0000\\u0000\\u0000\\u00bc\"+\n-\t\t\"\\u00be\\t\\u0000\\u0000\\u0000\\u00bd\\u00bc\\u0001\\u0000\\u0000\\u0000\\u00be\\u00c1\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00bf\\u00c0\\u0001\\u0000\\u0000\\u0000\\u00bf\\u00bd\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00c0\\u00c2\\u0001\\u0000\\u0000\\u0000\\u00c1\\u00bf\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00c2\\u00c3\\u0005*\\u0000\\u0000\\u00c3\\u00c4\\u0005\"+\n-\t\t\"/\\u0000\\u0000\\u00c4\\u00c5\\u0001\\u0000\\u0000\\u0000\\u00c5\\u00c6\\u0006\\n\"+\n-\t\t\"\\u0002\\u0000\\u00c6\\u0019\\u0001\\u0000\\u0000\\u0000\\u00c7\\u00c8\\u0005/\\u0000\"+\n-\t\t\"\\u0000\\u00c8\\u00cb\\u0005/\\u0000\\u0000\\u00c9\\u00cb\\u0005#\\u0000\\u0000\\u00ca\"+\n-\t\t\"\\u00c7\\u0001\\u0000\\u0000\\u0000\\u00ca\\u00c9\\u0001\\u0000\\u0000\\u0000\\u00cb\"+\n-\t\t\"\\u00cf\\u0001\\u0000\\u0000\\u0000\\u00cc\\u00ce\\b\\u0002\\u0000\\u0000\\u00cd\\u00cc\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00ce\\u00d1\\u0001\\u0000\\u0000\\u0000\\u00cf\\u00cd\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00cf\\u00d0\\u0001\\u0000\\u0000\\u0000\\u00d0\\u00d3\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00d1\\u00cf\\u0001\\u0000\\u0000\\u0000\\u00d2\\u00d4\"+\n-\t\t\"\\u0005\\r\\u0000\\u0000\\u00d3\\u00d2\\u0001\\u0000\\u0000\\u0000\\u00d3\\u00d4\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u00d4\\u00d5\\u0001\\u0000\\u0000\\u0000\\u00d5\\u00d6\\u0005\"+\n-\t\t\"\\n\\u0000\\u0000\\u00d6\\u00d7\\u0001\\u0000\\u0000\\u0000\\u00d7\\u00d8\\u0006\\u000b\"+\n-\t\t\"\\u0002\\u0000\\u00d8\\u001b\\u0001\\u0000\\u0000\\u0000\\u00d9\\u00da\\u0005\\n\\u0000\"+\n-\t\t\"\\u0000\\u00da\\u00db\\u0001\\u0000\\u0000\\u0000\\u00db\\u00dc\\u0006\\f\\u0002\\u0000\"+\n-\t\t\"\\u00dc\\u001d\\u0001\\u0000\\u0000\\u0000\\u00dd\\u00e0\\u0003 \\u000e\\u0000\\u00de\"+\n-\t\t\"\\u00e0\\u0007\\u0003\\u0000\\u0000\\u00df\\u00dd\\u0001\\u0000\\u0000\\u0000\\u00df\"+\n-\t\t\"\\u00de\\u0001\\u0000\\u0000\\u0000\\u00e0\\u001f\\u0001\\u0000\\u0000\\u0000\\u00e1\"+\n-\t\t\"\\u00e6\\u0007\\u0004\\u0000\\u0000\\u00e2\\u00e6\\b\\u0005\\u0000\\u0000\\u00e3\\u00e4\"+\n-\t\t\"\\u0007\\u0006\\u0000\\u0000\\u00e4\\u00e6\\u0007\\u0007\\u0000\\u0000\\u00e5\\u00e1\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00e5\\u00e2\\u0001\\u0000\\u0000\\u0000\\u00e5\\u00e3\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00e6!\\u0001\\u0000\\u0000\\u0000\\u00e7\\u00e8\\u0005\"+\n-\t\t\"\\\\\\u0000\\u0000\\u00e8\\u00fa\\u0007\\b\\u0000\\u0000\\u00e9\\u00ea\\u0005\\\\\\u0000\"+\n-\t\t\"\\u0000\\u00ea\\u00eb\\u0003$\\u0010\\u0000\\u00eb\\u00ec\\u0003$\\u0010\\u0000\\u00ec\"+\n-\t\t\"\\u00ed\\u0003$\\u0010\\u0000\\u00ed\\u00ee\\u0003$\\u0010\\u0000\\u00ee\\u00fa\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u00ef\\u00f0\\u0005\\\\\\u0000\\u0000\\u00f0\\u00f1\\u0003$\"+\n-\t\t\"\\u0010\\u0000\\u00f1\\u00f2\\u0003$\\u0010\\u0000\\u00f2\\u00f3\\u0003$\\u0010\\u0000\"+\n-\t\t\"\\u00f3\\u00f4\\u0003$\\u0010\\u0000\\u00f4\\u00f5\\u0003$\\u0010\\u0000\\u00f5\\u00f6\"+\n-\t\t\"\\u0003$\\u0010\\u0000\\u00f6\\u00f7\\u0003$\\u0010\\u0000\\u00f7\\u00f8\\u0003$\"+\n-\t\t\"\\u0010\\u0000\\u00f8\\u00fa\\u0001\\u0000\\u0000\\u0000\\u00f9\\u00e7\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u00f9\\u00e9\\u0001\\u0000\\u0000\\u0000\\u00f9\\u00ef\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u00fa#\\u0001\\u0000\\u0000\\u0000\\u00fb\\u00fc\\u0007\\t\\u0000\"+\n-\t\t\"\\u0000\\u00fc%\\u0001\\u0000\\u0000\\u0000\\u00fd\\u00ff\\u0007\\u0003\\u0000\\u0000\"+\n-\t\t\"\\u00fe\\u00fd\\u0001\\u0000\\u0000\\u0000\\u00ff\\u0100\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0100\\u00fe\\u0001\\u0000\\u0000\\u0000\\u0100\\u0101\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0101\\u0102\\u0001\\u0000\\u0000\\u0000\\u0102\\u0106\\u0005.\\u0000\\u0000\\u0103\"+\n-\t\t\"\\u0105\\u0007\\u0003\\u0000\\u0000\\u0104\\u0103\\u0001\\u0000\\u0000\\u0000\\u0105\"+\n-\t\t\"\\u0108\\u0001\\u0000\\u0000\\u0000\\u0106\\u0104\\u0001\\u0000\\u0000\\u0000\\u0106\"+\n-\t\t\"\\u0107\\u0001\\u0000\\u0000\\u0000\\u0107\\u010a\\u0001\\u0000\\u0000\\u0000\\u0108\"+\n-\t\t\"\\u0106\\u0001\\u0000\\u0000\\u0000\\u0109\\u010b\\u0003(\\u0012\\u0000\\u010a\\u0109\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u010a\\u010b\\u0001\\u0000\\u0000\\u0000\\u010b\\u0118\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u010c\\u010e\\u0007\\u0003\\u0000\\u0000\\u010d\\u010c\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u010e\\u010f\\u0001\\u0000\\u0000\\u0000\\u010f\\u010d\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u010f\\u0110\\u0001\\u0000\\u0000\\u0000\\u0110\\u0111\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0111\\u0118\\u0003(\\u0012\\u0000\\u0112\\u0114\\u0007\"+\n-\t\t\"\\u0003\\u0000\\u0000\\u0113\\u0112\\u0001\\u0000\\u0000\\u0000\\u0114\\u0115\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0115\\u0113\\u0001\\u0000\\u0000\\u0000\\u0115\\u0116\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0116\\u0118\\u0001\\u0000\\u0000\\u0000\\u0117\\u00fe\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0117\\u010d\\u0001\\u0000\\u0000\\u0000\\u0117\\u0113\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0118\\'\\u0001\\u0000\\u0000\\u0000\\u0119\\u011b\\u0007\\n\"+\n-\t\t\"\\u0000\\u0000\\u011a\\u011c\\u0007\\u000b\\u0000\\u0000\\u011b\\u011a\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u011b\\u011c\\u0001\\u0000\\u0000\\u0000\\u011c\\u011e\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u011d\\u011f\\u0007\\u0003\\u0000\\u0000\\u011e\\u011d\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u011f\\u0120\\u0001\\u0000\\u0000\\u0000\\u0120\\u011e\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0120\\u0121\\u0001\\u0000\\u0000\\u0000\\u0121)\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0122\\u0123\\u0005t\\u0000\\u0000\\u0123\\u0124\\u0005r\\u0000\\u0000\\u0124\"+\n-\t\t\"\\u0125\\u0005u\\u0000\\u0000\\u0125\\u012c\\u0005e\\u0000\\u0000\\u0126\\u0127\\u0005\"+\n-\t\t\"f\\u0000\\u0000\\u0127\\u0128\\u0005a\\u0000\\u0000\\u0128\\u0129\\u0005l\\u0000\"+\n-\t\t\"\\u0000\\u0129\\u012a\\u0005s\\u0000\\u0000\\u012a\\u012c\\u0005e\\u0000\\u0000\\u012b\"+\n-\t\t\"\\u0122\\u0001\\u0000\\u0000\\u0000\\u012b\\u0126\\u0001\\u0000\\u0000\\u0000\\u012c\"+\n-\t\t\"+\\u0001\\u0000\\u0000\\u0000\\u012d\\u012e\\u0005\\\"\\u0000\\u0000\\u012e\\u012f\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u012f\\u0130\\u0006\\u0014\\u0003\\u0000\\u0130-\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0131\\u0132\\u0005n\\u0000\\u0000\\u0132\\u0133\\u0005u\\u0000\"+\n-\t\t\"\\u0000\\u0133\\u0134\\u0005l\\u0000\\u0000\\u0134\\u0135\\u0005l\\u0000\\u0000\\u0135\"+\n-\t\t\"/\\u0001\\u0000\\u0000\\u0000\\u0136\\u0137\\u0005<\\u0000\\u0000\\u0137\\u0138\\u0005\"+\n-\t\t\"<\\u0000\\u0000\\u0138\\u013a\\u0001\\u0000\\u0000\\u0000\\u0139\\u013b\\u0005-\\u0000\"+\n-\t\t\"\\u0000\\u013a\\u0139\\u0001\\u0000\\u0000\\u0000\\u013a\\u013b\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u013b\\u013c\\u0001\\u0000\\u0000\\u0000\\u013c\\u013d\\u0006\\u0016\\u0004\"+\n-\t\t\"\\u0000\\u013d1\\u0001\\u0000\\u0000\\u0000\\u013e\\u013f\\u0005+\\u0000\\u0000\\u013f\"+\n-\t\t\"3\\u0001\\u0000\\u0000\\u0000\\u0140\\u0141\\u0005&\\u0000\\u0000\\u0141\\u0142\\u0005\"+\n-\t\t\"&\\u0000\\u0000\\u01425\\u0001\\u0000\\u0000\\u0000\\u0143\\u0144\\u0005=\\u0000\"+\n-\t\t\"\\u0000\\u0144\\u0145\\u0005=\\u0000\\u0000\\u01457\\u0001\\u0000\\u0000\\u0000\\u0146\"+\n-\t\t\"\\u0147\\u0005<\\u0000\\u0000\\u01479\\u0001\\u0000\\u0000\\u0000\\u0148\\u0149\\u0005\"+\n-\t\t\":\\u0000\\u0000\\u0149;\\u0001\\u0000\\u0000\\u0000\\u014a\\u014b\\u0005[\\u0000\"+\n-\t\t\"\\u0000\\u014b=\\u0001\\u0000\\u0000\\u0000\\u014c\\u014d\\u0005(\\u0000\\u0000\\u014d\"+\n-\t\t\"?\\u0001\\u0000\\u0000\\u0000\\u014e\\u014f\\u0005-\\u0000\\u0000\\u014fA\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0150\\u0151\\u0005|\\u0000\\u0000\\u0151\\u0152\\u0005|\\u0000\"+\n-\t\t\"\\u0000\\u0152C\\u0001\\u0000\\u0000\\u0000\\u0153\\u0154\\u0005!\\u0000\\u0000\\u0154\"+\n-\t\t\"\\u0155\\u0005=\\u0000\\u0000\\u0155E\\u0001\\u0000\\u0000\\u0000\\u0156\\u0157\\u0005\"+\n-\t\t\">\\u0000\\u0000\\u0157G\\u0001\\u0000\\u0000\\u0000\\u0158\\u0159\\u0005?\\u0000\"+\n-\t\t\"\\u0000\\u0159I\\u0001\\u0000\\u0000\\u0000\\u015a\\u015b\\u0005]\\u0000\\u0000\\u015b\"+\n-\t\t\"K\\u0001\\u0000\\u0000\\u0000\\u015c\\u015d\\u0005)\\u0000\\u0000\\u015dM\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u015e\\u015f\\u0005*\\u0000\\u0000\\u015fO\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0160\\u0161\\u0005!\\u0000\\u0000\\u0161Q\\u0001\\u0000\\u0000\\u0000\\u0162\"+\n-\t\t\"\\u0163\\u0005<\\u0000\\u0000\\u0163\\u0164\\u0005=\\u0000\\u0000\\u0164S\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0165\\u0166\\u0005.\\u0000\\u0000\\u0166U\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0167\\u0168\\u0005/\\u0000\\u0000\\u0168W\\u0001\\u0000\\u0000\\u0000\\u0169\"+\n-\t\t\"\\u016a\\u0005>\\u0000\\u0000\\u016a\\u016b\\u0005=\\u0000\\u0000\\u016bY\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u016c\\u016d\\u0005=\\u0000\\u0000\\u016d\\u016e\\u0005>\\u0000\"+\n-\t\t\"\\u0000\\u016e[\\u0001\\u0000\\u0000\\u0000\\u016f\\u0170\\u0005,\\u0000\\u0000\\u0170\"+\n-\t\t\"]\\u0001\\u0000\\u0000\\u0000\\u0171\\u0172\\u0005%\\u0000\\u0000\\u0172_\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0173\\u0174\\u0005.\\u0000\\u0000\\u0174\\u0175\\u0005.\\u0000\"+\n-\t\t\"\\u0000\\u0175\\u0176\\u0005.\\u0000\\u0000\\u0176a\\u0001\\u0000\\u0000\\u0000\\u0177\"+\n-\t\t\"\\u0178\\u0005~\\u0000\\u0000\\u0178c\\u0001\\u0000\\u0000\\u0000\\u0179\\u017a\\u0005\"+\n-\t\t\"$\\u0000\\u0000\\u017a\\u017b\\u0005{\\u0000\\u0000\\u017b\\u017c\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u017c\\u017d\\u00060\\u0005\\u0000\\u017d\\u017e\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u017e\\u017f\\u00060\\u0006\\u0000\\u017fe\\u0001\\u0000\\u0000\\u0000\\u0180\\u0182\"+\n-\t\t\"\\u0003h2\\u0000\\u0181\\u0180\\u0001\\u0000\\u0000\\u0000\\u0182\\u0183\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0183\\u0181\\u0001\\u0000\\u0000\\u0000\\u0183\\u0184\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0184g\\u0001\\u0000\\u0000\\u0000\\u0185\\u0190\\b\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0186\\u0187\\u0005$\\u0000\\u0000\\u0187\\u0190\\u0005$\\u0000\\u0000\\u0188\"+\n-\t\t\"\\u0189\\u0005$\\u0000\\u0000\\u0189\\u0190\\u00042\\u0000\\u0000\\u018a\\u018b\\u0005\"+\n-\t\t\"%\\u0000\\u0000\\u018b\\u0190\\u0005%\\u0000\\u0000\\u018c\\u018d\\u0005%\\u0000\"+\n-\t\t\"\\u0000\\u018d\\u0190\\u00042\\u0001\\u0000\\u018e\\u0190\\u0003\\\"\\u000f\\u0000\"+\n-\t\t\"\\u018f\\u0185\\u0001\\u0000\\u0000\\u0000\\u018f\\u0186\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u018f\\u0188\\u0001\\u0000\\u0000\\u0000\\u018f\\u018a\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u018f\\u018c\\u0001\\u0000\\u0000\\u0000\\u018f\\u018e\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0190i\\u0001\\u0000\\u0000\\u0000\\u0191\\u0192\\u0005\\\"\\u0000\\u0000\\u0192\"+\n-\t\t\"\\u0193\\u0001\\u0000\\u0000\\u0000\\u0193\\u0194\\u00063\\u0007\\u0000\\u0194\\u0195\"+\n-\t\t\"\\u00063\\b\\u0000\\u0195k\\u0001\\u0000\\u0000\\u0000\\u0196\\u0197\\u0005\\n\\u0000\"+\n-\t\t\"\\u0000\\u0197\\u0198\\u0001\\u0000\\u0000\\u0000\\u0198\\u0199\\u00064\\t\\u0000\"+\n-\t\t\"\\u0199\\u019a\\u00064\\n\\u0000\\u019am\\u0001\\u0000\\u0000\\u0000\\u019b\\u01a0\"+\n-\t\t\"\\u0003 \\u000e\\u0000\\u019c\\u019f\\u0003\\u001e\\r\\u0000\\u019d\\u019f\\u0005\"+\n-\t\t\"-\\u0000\\u0000\\u019e\\u019c\\u0001\\u0000\\u0000\\u0000\\u019e\\u019d\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u019f\\u01a2\\u0001\\u0000\\u0000\\u0000\\u01a0\\u019e\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u01a0\\u01a1\\u0001\\u0000\\u0000\\u0000\\u01a1\\u01a3\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u01a2\\u01a0\\u0001\\u0000\\u0000\\u0000\\u01a3\\u01a4\\u00065\\u000b\"+\n-\t\t\"\\u0000\\u01a4\\u01a5\\u0001\\u0000\\u0000\\u0000\\u01a5\\u01a6\\u00065\\f\\u0000\"+\n-\t\t\"\\u01a6o\\u0001\\u0000\\u0000\\u0000\\u01a7\\u01a8\\u0005\\n\\u0000\\u0000\\u01a8\"+\n-\t\t\"\\u01a9\\u0001\\u0000\\u0000\\u0000\\u01a9\\u01aa\\u00066\\t\\u0000\\u01aaq\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u01ab\\u01ac\\u0005$\\u0000\\u0000\\u01ac\\u01ad\\u0005{\\u0000\"+\n-\t\t\"\\u0000\\u01ad\\u01ae\\u0001\\u0000\\u0000\\u0000\\u01ae\\u01af\\u00067\\r\\u0000\"+\n-\t\t\"\\u01af\\u01b0\\u0001\\u0000\\u0000\\u0000\\u01b0\\u01b1\\u00067\\u000e\\u0000\\u01b1\"+\n-\t\t\"\\u01b2\\u00067\\u0006\\u0000\\u01b2s\\u0001\\u0000\\u0000\\u0000\\u01b3\\u01b5\\u0003\"+\n-\t\t\"v9\\u0000\\u01b4\\u01b3\\u0001\\u0000\\u0000\\u0000\\u01b5\\u01b6\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u01b6\\u01b4\\u0001\\u0000\\u0000\\u0000\\u01b6\\u01b7\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u01b7\\u01b8\\u0001\\u0000\\u0000\\u0000\\u01b8\\u01b9\\u00068\\u000f\\u0000\"+\n-\t\t\"\\u01b9u\\u0001\\u0000\\u0000\\u0000\\u01ba\\u01c1\\b\\f\\u0000\\u0000\\u01bb\\u01bc\"+\n-\t\t\"\\u0005$\\u0000\\u0000\\u01bc\\u01c1\\b\\r\\u0000\\u0000\\u01bd\\u01be\\u0005%\\u0000\"+\n-\t\t\"\\u0000\\u01be\\u01c1\\b\\r\\u0000\\u0000\\u01bf\\u01c1\\u0003\\\"\\u000f\\u0000\\u01c0\"+\n-\t\t\"\\u01ba\\u0001\\u0000\\u0000\\u0000\\u01c0\\u01bb\\u0001\\u0000\\u0000\\u0000\\u01c0\"+\n-\t\t\"\\u01bd\\u0001\\u0000\\u0000\\u0000\\u01c0\\u01bf\\u0001\\u0000\\u0000\\u0000\\u01c1\"+\n-\t\t\"w\\u0001\\u0000\\u0000\\u0000#\\u0000\\u0001\\u0002\\u0003}\\u007f\\u008d\\u008f\"+\n-\t\t\"\\u00a8\\u00ad\\u00af\\u00b5\\u00bf\\u00ca\\u00cf\\u00d3\\u00df\\u00e5\\u00f9\\u0100\"+\n-\t\t\"\\u0106\\u010a\\u010f\\u0115\\u0117\\u011b\\u0120\\u012b\\u013a\\u0183\\u018f\\u019e\"+\n-\t\t\"\\u01a0\\u01b6\\u01c0\\u0010\\u0001\\u0004\\u0000\\u0001\\u0005\\u0001\\u0000\\u0001\"+\n-\t\t\"\\u0000\\u0005\\u0001\\u0000\\u0005\\u0002\\u0000\\u00010\\u0002\\u0005\\u0000\\u0000\"+\n-\t\t\"\\u0007\\u000f\\u0000\\u0004\\u0000\\u0000\\u0007\\f\\u0000\\u0002\\u0003\\u0000\\u0001\"+\n-\t\t\"5\\u0003\\u0007\\b\\u0000\\u00017\\u0004\\u0007+\\u0000\\u00018\\u0005\";\n+\t\t\"\\u0003\\u000f\\u0004\\u0000\\n\\n\\r\\r\\\"\\\"$%\\u0003\\u0000\\t\\t\\f\\r  \\u0002\\u0000\"+\n+\t\t\"\\n\\n\\r\\r\\u0001\\u0001\\n\\n\\u0001\\u000009\\u0004\\u0000$$AZ__az\\u0002\\u0000\"+\n+\t\t\"\\u0000\\u007f\\u8000\\ud800\\u8000\\udbff\\u0001\\u0000\\u8000\\ud800\\u8000\\udbff\"+\n+\t\t\"\\u0001\\u0000\\u8000\\udc00\\u8000\\udfff\\u0005\\u0000\\\"\\\"\\\\\\\\nnrrtt\\u0003\\u0000\"+\n+\t\t\"09AFaf\\u0002\\u0000EEee\\u0002\\u0000++--\\u0003\\u0000\\n\\n\\r\\r$%\\u0001\\u0000\"+\n+\t\t\"{{\\u01e5\\u0000\\u0004\\u0001\\u0000\\u0000\\u0000\\u0000\\u0006\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0000\\b\\u0001\\u0000\\u0000\\u0000\\u0000\\n\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0000\\f\\u0001\\u0000\\u0000\\u0000\\u0000\\u000e\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0010\\u0001\\u0000\\u0000\\u0000\\u0000\\u0014\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0016\\u0001\\u0000\\u0000\\u0000\\u0000\\u0018\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u001a\\u0001\\u0000\\u0000\\u0000\\u0000\\u001c\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n+\t\t\"&\\u0001\\u0000\\u0000\\u0000\\u0000*\\u0001\\u0000\\u0000\\u0000\\u0000,\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0000.\\u0001\\u0000\\u0000\\u0000\\u00000\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u00002\\u0001\\u0000\\u0000\\u0000\\u00004\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n+\t\t\"6\\u0001\\u0000\\u0000\\u0000\\u00008\\u0001\\u0000\\u0000\\u0000\\u0000:\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0000<\\u0001\\u0000\\u0000\\u0000\\u0000>\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0000@\\u0001\\u0000\\u0000\\u0000\\u0000B\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n+\t\t\"D\\u0001\\u0000\\u0000\\u0000\\u0000F\\u0001\\u0000\\u0000\\u0000\\u0000H\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0000J\\u0001\\u0000\\u0000\\u0000\\u0000L\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0000N\\u0001\\u0000\\u0000\\u0000\\u0000P\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n+\t\t\"R\\u0001\\u0000\\u0000\\u0000\\u0000T\\u0001\\u0000\\u0000\\u0000\\u0000V\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0000X\\u0001\\u0000\\u0000\\u0000\\u0000Z\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0000\\\\\\u0001\\u0000\\u0000\\u0000\\u0000^\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0000`\\u0001\\u0000\\u0000\\u0000\\u0000b\\u0001\\u0000\\u0000\\u0000\\u0001d\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0001f\\u0001\\u0000\\u0000\\u0000\\u0001h\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0001j\\u0001\\u0000\\u0000\\u0000\\u0002l\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0002n\\u0001\\u0000\\u0000\\u0000\\u0003p\\u0001\\u0000\\u0000\\u0000\\u0003r\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0003t\\u0001\\u0000\\u0000\\u0000\\u0003v\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0004x\\u0001\\u0000\\u0000\\u0000\\u0006\\u0088\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\b\\u0098\\u0001\\u0000\\u0000\\u0000\\n\\u009b\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\f\\u009e\\u0001\\u0000\\u0000\\u0000\\u000e\\u00a1\\u0001\\u0000\\u0000\\u0000\\u0010\"+\n+\t\t\"\\u00a4\\u0001\\u0000\\u0000\\u0000\\u0012\\u00a8\\u0001\\u0000\\u0000\\u0000\\u0014\"+\n+\t\t\"\\u00aa\\u0001\\u0000\\u0000\\u0000\\u0016\\u00b3\\u0001\\u0000\\u0000\\u0000\\u0018\"+\n+\t\t\"\\u00b9\\u0001\\u0000\\u0000\\u0000\\u001a\\u00ca\\u0001\\u0000\\u0000\\u0000\\u001c\"+\n+\t\t\"\\u00da\\u0001\\u0000\\u0000\\u0000\\u001e\\u00e0\\u0001\\u0000\\u0000\\u0000 \\u00e6\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\\"\\u00fa\\u0001\\u0000\\u0000\\u0000$\\u00fc\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000&\\u0118\\u0001\\u0000\\u0000\\u0000(\\u011a\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000*\\u012c\\u0001\\u0000\\u0000\\u0000,\\u012e\\u0001\\u0000\\u0000\\u0000.\"+\n+\t\t\"\\u0132\\u0001\\u0000\\u0000\\u00000\\u0137\\u0001\\u0000\\u0000\\u00002\\u013f\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u00004\\u0141\\u0001\\u0000\\u0000\\u00006\\u0144\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u00008\\u0147\\u0001\\u0000\\u0000\\u0000:\\u0149\\u0001\\u0000\\u0000\\u0000<\"+\n+\t\t\"\\u014b\\u0001\\u0000\\u0000\\u0000>\\u014d\\u0001\\u0000\\u0000\\u0000@\\u014f\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000B\\u0151\\u0001\\u0000\\u0000\\u0000D\\u0154\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000F\\u0157\\u0001\\u0000\\u0000\\u0000H\\u0159\\u0001\\u0000\\u0000\\u0000J\"+\n+\t\t\"\\u015b\\u0001\\u0000\\u0000\\u0000L\\u015d\\u0001\\u0000\\u0000\\u0000N\\u015f\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000P\\u0161\\u0001\\u0000\\u0000\\u0000R\\u0163\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000T\\u0166\\u0001\\u0000\\u0000\\u0000V\\u0168\\u0001\\u0000\\u0000\\u0000X\"+\n+\t\t\"\\u016a\\u0001\\u0000\\u0000\\u0000Z\\u016d\\u0001\\u0000\\u0000\\u0000\\\\\\u0170\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000^\\u0172\\u0001\\u0000\\u0000\\u0000`\\u0174\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000b\\u0178\\u0001\\u0000\\u0000\\u0000d\\u017a\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"f\\u0182\\u0001\\u0000\\u0000\\u0000h\\u0190\\u0001\\u0000\\u0000\\u0000j\\u0192\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000l\\u0197\\u0001\\u0000\\u0000\\u0000n\\u019c\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000p\\u01a8\\u0001\\u0000\\u0000\\u0000r\\u01ac\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"t\\u01b5\\u0001\\u0000\\u0000\\u0000v\\u01c1\\u0001\\u0000\\u0000\\u0000x\\u007f\"+\n+\t\t\"\\u0005{\\u0000\\u0000y~\\u0003\\u0016\\t\\u0000z~\\u0003\\u001c\\f\\u0000{~\\u0003\"+\n+\t\t\"\\u0018\\n\\u0000|~\\u0003\\u001a\\u000b\\u0000}y\\u0001\\u0000\\u0000\\u0000}z\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000}{\\u0001\\u0000\\u0000\\u0000}|\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"~\\u0081\\u0001\\u0000\\u0000\\u0000\\u007f}\\u0001\\u0000\\u0000\\u0000\\u007f\\u0080\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0080\\u0082\\u0001\\u0000\\u0000\\u0000\\u0081\\u007f\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0082\\u0083\\u0005f\\u0000\\u0000\\u0083\\u0084\\u0005\"+\n+\t\t\"o\\u0000\\u0000\\u0084\\u0085\\u0005r\\u0000\\u0000\\u0085\\u0086\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0086\\u0087\\u0003\\u0016\\t\\u0000\\u0087\\u0005\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0088\\u008f\\u0005[\\u0000\\u0000\\u0089\\u008e\\u0003\\u0016\\t\\u0000\\u008a\"+\n+\t\t\"\\u008e\\u0003\\u001c\\f\\u0000\\u008b\\u008e\\u0003\\u0018\\n\\u0000\\u008c\\u008e\"+\n+\t\t\"\\u0003\\u001a\\u000b\\u0000\\u008d\\u0089\\u0001\\u0000\\u0000\\u0000\\u008d\\u008a\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u008d\\u008b\\u0001\\u0000\\u0000\\u0000\\u008d\\u008c\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u008e\\u0091\\u0001\\u0000\\u0000\\u0000\\u008f\\u008d\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u008f\\u0090\\u0001\\u0000\\u0000\\u0000\\u0090\\u0092\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0091\\u008f\\u0001\\u0000\\u0000\\u0000\\u0092\\u0093\"+\n+\t\t\"\\u0005f\\u0000\\u0000\\u0093\\u0094\\u0005o\\u0000\\u0000\\u0094\\u0095\\u0005r\"+\n+\t\t\"\\u0000\\u0000\\u0095\\u0096\\u0001\\u0000\\u0000\\u0000\\u0096\\u0097\\u0003\\u0016\"+\n+\t\t\"\\t\\u0000\\u0097\\u0007\\u0001\\u0000\\u0000\\u0000\\u0098\\u0099\\u0005i\\u0000\"+\n+\t\t\"\\u0000\\u0099\\u009a\\u0005f\\u0000\\u0000\\u009a\\t\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u009b\\u009c\\u0005i\\u0000\\u0000\\u009c\\u009d\\u0005n\\u0000\\u0000\\u009d\\u000b\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u009e\\u009f\\u0005{\\u0000\\u0000\\u009f\\u00a0\\u0006\"+\n+\t\t\"\\u0004\\u0000\\u0000\\u00a0\\r\\u0001\\u0000\\u0000\\u0000\\u00a1\\u00a2\\u0005}\"+\n+\t\t\"\\u0000\\u0000\\u00a2\\u00a3\\u0006\\u0005\\u0001\\u0000\\u00a3\\u000f\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u00a4\\u00a5\\u0005=\\u0000\\u0000\\u00a5\\u0011\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u00a6\\u00a9\\b\\u0000\\u0000\\u0000\\u00a7\\u00a9\\u0003\\\"\\u000f\\u0000\"+\n+\t\t\"\\u00a8\\u00a6\\u0001\\u0000\\u0000\\u0000\\u00a8\\u00a7\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u00a9\\u0013\\u0001\\u0000\\u0000\\u0000\\u00aa\\u00af\\u0003 \\u000e\\u0000\\u00ab\"+\n+\t\t\"\\u00ae\\u0003\\u001e\\r\\u0000\\u00ac\\u00ae\\u0005-\\u0000\\u0000\\u00ad\\u00ab\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00ad\\u00ac\\u0001\\u0000\\u0000\\u0000\\u00ae\\u00b1\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00af\\u00ad\\u0001\\u0000\\u0000\\u0000\\u00af\\u00b0\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00b0\\u0015\\u0001\\u0000\\u0000\\u0000\\u00b1\\u00af\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00b2\\u00b4\\u0007\\u0001\\u0000\\u0000\\u00b3\\u00b2\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00b4\\u00b5\\u0001\\u0000\\u0000\\u0000\\u00b5\\u00b3\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00b5\\u00b6\\u0001\\u0000\\u0000\\u0000\\u00b6\\u00b7\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00b7\\u00b8\\u0006\\t\\u0002\\u0000\\u00b8\\u0017\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u00b9\\u00ba\\u0005/\\u0000\\u0000\\u00ba\\u00bb\\u0005*\\u0000\"+\n+\t\t\"\\u0000\\u00bb\\u00bf\\u0001\\u0000\\u0000\\u0000\\u00bc\\u00be\\t\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u00bd\\u00bc\\u0001\\u0000\\u0000\\u0000\\u00be\\u00c1\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u00bf\\u00c0\\u0001\\u0000\\u0000\\u0000\\u00bf\\u00bd\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u00c0\\u00c2\\u0001\\u0000\\u0000\\u0000\\u00c1\\u00bf\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u00c2\\u00c3\\u0005*\\u0000\\u0000\\u00c3\\u00c4\\u0005/\\u0000\\u0000\\u00c4\\u00c5\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00c5\\u00c6\\u0006\\n\\u0002\\u0000\\u00c6\\u0019\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u00c7\\u00c8\\u0005/\\u0000\\u0000\\u00c8\\u00cb\\u0005/\\u0000\"+\n+\t\t\"\\u0000\\u00c9\\u00cb\\u0005#\\u0000\\u0000\\u00ca\\u00c7\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u00ca\\u00c9\\u0001\\u0000\\u0000\\u0000\\u00cb\\u00cf\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u00cc\\u00ce\\b\\u0002\\u0000\\u0000\\u00cd\\u00cc\\u0001\\u0000\\u0000\\u0000\\u00ce\"+\n+\t\t\"\\u00d1\\u0001\\u0000\\u0000\\u0000\\u00cf\\u00cd\\u0001\\u0000\\u0000\\u0000\\u00cf\"+\n+\t\t\"\\u00d0\\u0001\\u0000\\u0000\\u0000\\u00d0\\u00d3\\u0001\\u0000\\u0000\\u0000\\u00d1\"+\n+\t\t\"\\u00cf\\u0001\\u0000\\u0000\\u0000\\u00d2\\u00d4\\u0005\\r\\u0000\\u0000\\u00d3\\u00d2\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00d3\\u00d4\\u0001\\u0000\\u0000\\u0000\\u00d4\\u00d6\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00d5\\u00d7\\u0007\\u0003\\u0000\\u0000\\u00d6\\u00d5\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00d7\\u00d8\\u0001\\u0000\\u0000\\u0000\\u00d8\\u00d9\"+\n+\t\t\"\\u0006\\u000b\\u0002\\u0000\\u00d9\\u001b\\u0001\\u0000\\u0000\\u0000\\u00da\\u00db\"+\n+\t\t\"\\u0005\\n\\u0000\\u0000\\u00db\\u00dc\\u0001\\u0000\\u0000\\u0000\\u00dc\\u00dd\\u0006\"+\n+\t\t\"\\f\\u0002\\u0000\\u00dd\\u001d\\u0001\\u0000\\u0000\\u0000\\u00de\\u00e1\\u0003 \"+\n+\t\t\"\\u000e\\u0000\\u00df\\u00e1\\u0007\\u0004\\u0000\\u0000\\u00e0\\u00de\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u00e0\\u00df\\u0001\\u0000\\u0000\\u0000\\u00e1\\u001f\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u00e2\\u00e7\\u0007\\u0005\\u0000\\u0000\\u00e3\\u00e7\\b\\u0006\\u0000\"+\n+\t\t\"\\u0000\\u00e4\\u00e5\\u0007\\u0007\\u0000\\u0000\\u00e5\\u00e7\\u0007\\b\\u0000\\u0000\"+\n+\t\t\"\\u00e6\\u00e2\\u0001\\u0000\\u0000\\u0000\\u00e6\\u00e3\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u00e6\\u00e4\\u0001\\u0000\\u0000\\u0000\\u00e7!\\u0001\\u0000\\u0000\\u0000\\u00e8\"+\n+\t\t\"\\u00e9\\u0005\\\\\\u0000\\u0000\\u00e9\\u00fb\\u0007\\t\\u0000\\u0000\\u00ea\\u00eb\"+\n+\t\t\"\\u0005\\\\\\u0000\\u0000\\u00eb\\u00ec\\u0003$\\u0010\\u0000\\u00ec\\u00ed\\u0003\"+\n+\t\t\"$\\u0010\\u0000\\u00ed\\u00ee\\u0003$\\u0010\\u0000\\u00ee\\u00ef\\u0003$\\u0010\"+\n+\t\t\"\\u0000\\u00ef\\u00fb\\u0001\\u0000\\u0000\\u0000\\u00f0\\u00f1\\u0005\\\\\\u0000\\u0000\"+\n+\t\t\"\\u00f1\\u00f2\\u0003$\\u0010\\u0000\\u00f2\\u00f3\\u0003$\\u0010\\u0000\\u00f3\\u00f4\"+\n+\t\t\"\\u0003$\\u0010\\u0000\\u00f4\\u00f5\\u0003$\\u0010\\u0000\\u00f5\\u00f6\\u0003$\"+\n+\t\t\"\\u0010\\u0000\\u00f6\\u00f7\\u0003$\\u0010\\u0000\\u00f7\\u00f8\\u0003$\\u0010\\u0000\"+\n+\t\t\"\\u00f8\\u00f9\\u0003$\\u0010\\u0000\\u00f9\\u00fb\\u0001\\u0000\\u0000\\u0000\\u00fa\"+\n+\t\t\"\\u00e8\\u0001\\u0000\\u0000\\u0000\\u00fa\\u00ea\\u0001\\u0000\\u0000\\u0000\\u00fa\"+\n+\t\t\"\\u00f0\\u0001\\u0000\\u0000\\u0000\\u00fb#\\u0001\\u0000\\u0000\\u0000\\u00fc\\u00fd\"+\n+\t\t\"\\u0007\\n\\u0000\\u0000\\u00fd%\\u0001\\u0000\\u0000\\u0000\\u00fe\\u0100\\u0007\"+\n+\t\t\"\\u0004\\u0000\\u0000\\u00ff\\u00fe\\u0001\\u0000\\u0000\\u0000\\u0100\\u0101\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0101\\u00ff\\u0001\\u0000\\u0000\\u0000\\u0101\\u0102\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0102\\u0103\\u0001\\u0000\\u0000\\u0000\\u0103\\u0107\\u0005\"+\n+\t\t\".\\u0000\\u0000\\u0104\\u0106\\u0007\\u0004\\u0000\\u0000\\u0105\\u0104\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0106\\u0109\\u0001\\u0000\\u0000\\u0000\\u0107\\u0105\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0107\\u0108\\u0001\\u0000\\u0000\\u0000\\u0108\\u010b\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0109\\u0107\\u0001\\u0000\\u0000\\u0000\\u010a\\u010c\\u0003(\\u0012\"+\n+\t\t\"\\u0000\\u010b\\u010a\\u0001\\u0000\\u0000\\u0000\\u010b\\u010c\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u010c\\u0119\\u0001\\u0000\\u0000\\u0000\\u010d\\u010f\\u0007\\u0004\\u0000\"+\n+\t\t\"\\u0000\\u010e\\u010d\\u0001\\u0000\\u0000\\u0000\\u010f\\u0110\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0110\\u010e\\u0001\\u0000\\u0000\\u0000\\u0110\\u0111\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0111\\u0112\\u0001\\u0000\\u0000\\u0000\\u0112\\u0119\\u0003(\\u0012\\u0000\"+\n+\t\t\"\\u0113\\u0115\\u0007\\u0004\\u0000\\u0000\\u0114\\u0113\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0115\\u0116\\u0001\\u0000\\u0000\\u0000\\u0116\\u0114\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0116\\u0117\\u0001\\u0000\\u0000\\u0000\\u0117\\u0119\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0118\\u00ff\\u0001\\u0000\\u0000\\u0000\\u0118\\u010e\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0118\\u0114\\u0001\\u0000\\u0000\\u0000\\u0119\\'\\u0001\\u0000\\u0000\\u0000\\u011a\"+\n+\t\t\"\\u011c\\u0007\\u000b\\u0000\\u0000\\u011b\\u011d\\u0007\\f\\u0000\\u0000\\u011c\\u011b\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u011c\\u011d\\u0001\\u0000\\u0000\\u0000\\u011d\\u011f\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u011e\\u0120\\u0007\\u0004\\u0000\\u0000\\u011f\\u011e\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0120\\u0121\\u0001\\u0000\\u0000\\u0000\\u0121\\u011f\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0121\\u0122\\u0001\\u0000\\u0000\\u0000\\u0122)\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0123\\u0124\\u0005t\\u0000\\u0000\\u0124\\u0125\\u0005r\\u0000\"+\n+\t\t\"\\u0000\\u0125\\u0126\\u0005u\\u0000\\u0000\\u0126\\u012d\\u0005e\\u0000\\u0000\\u0127\"+\n+\t\t\"\\u0128\\u0005f\\u0000\\u0000\\u0128\\u0129\\u0005a\\u0000\\u0000\\u0129\\u012a\\u0005\"+\n+\t\t\"l\\u0000\\u0000\\u012a\\u012b\\u0005s\\u0000\\u0000\\u012b\\u012d\\u0005e\\u0000\"+\n+\t\t\"\\u0000\\u012c\\u0123\\u0001\\u0000\\u0000\\u0000\\u012c\\u0127\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u012d+\\u0001\\u0000\\u0000\\u0000\\u012e\\u012f\\u0005\\\"\\u0000\\u0000\"+\n+\t\t\"\\u012f\\u0130\\u0001\\u0000\\u0000\\u0000\\u0130\\u0131\\u0006\\u0014\\u0003\\u0000\"+\n+\t\t\"\\u0131-\\u0001\\u0000\\u0000\\u0000\\u0132\\u0133\\u0005n\\u0000\\u0000\\u0133\\u0134\"+\n+\t\t\"\\u0005u\\u0000\\u0000\\u0134\\u0135\\u0005l\\u0000\\u0000\\u0135\\u0136\\u0005l\"+\n+\t\t\"\\u0000\\u0000\\u0136/\\u0001\\u0000\\u0000\\u0000\\u0137\\u0138\\u0005<\\u0000\\u0000\"+\n+\t\t\"\\u0138\\u0139\\u0005<\\u0000\\u0000\\u0139\\u013b\\u0001\\u0000\\u0000\\u0000\\u013a\"+\n+\t\t\"\\u013c\\u0005-\\u0000\\u0000\\u013b\\u013a\\u0001\\u0000\\u0000\\u0000\\u013b\\u013c\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u013c\\u013d\\u0001\\u0000\\u0000\\u0000\\u013d\\u013e\"+\n+\t\t\"\\u0006\\u0016\\u0004\\u0000\\u013e1\\u0001\\u0000\\u0000\\u0000\\u013f\\u0140\\u0005\"+\n+\t\t\"+\\u0000\\u0000\\u01403\\u0001\\u0000\\u0000\\u0000\\u0141\\u0142\\u0005&\\u0000\"+\n+\t\t\"\\u0000\\u0142\\u0143\\u0005&\\u0000\\u0000\\u01435\\u0001\\u0000\\u0000\\u0000\\u0144\"+\n+\t\t\"\\u0145\\u0005=\\u0000\\u0000\\u0145\\u0146\\u0005=\\u0000\\u0000\\u01467\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0147\\u0148\\u0005<\\u0000\\u0000\\u01489\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0149\\u014a\\u0005:\\u0000\\u0000\\u014a;\\u0001\\u0000\\u0000\\u0000\\u014b\"+\n+\t\t\"\\u014c\\u0005[\\u0000\\u0000\\u014c=\\u0001\\u0000\\u0000\\u0000\\u014d\\u014e\\u0005\"+\n+\t\t\"(\\u0000\\u0000\\u014e?\\u0001\\u0000\\u0000\\u0000\\u014f\\u0150\\u0005-\\u0000\"+\n+\t\t\"\\u0000\\u0150A\\u0001\\u0000\\u0000\\u0000\\u0151\\u0152\\u0005|\\u0000\\u0000\\u0152\"+\n+\t\t\"\\u0153\\u0005|\\u0000\\u0000\\u0153C\\u0001\\u0000\\u0000\\u0000\\u0154\\u0155\\u0005\"+\n+\t\t\"!\\u0000\\u0000\\u0155\\u0156\\u0005=\\u0000\\u0000\\u0156E\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0157\\u0158\\u0005>\\u0000\\u0000\\u0158G\\u0001\\u0000\\u0000\\u0000\\u0159\"+\n+\t\t\"\\u015a\\u0005?\\u0000\\u0000\\u015aI\\u0001\\u0000\\u0000\\u0000\\u015b\\u015c\\u0005\"+\n+\t\t\"]\\u0000\\u0000\\u015cK\\u0001\\u0000\\u0000\\u0000\\u015d\\u015e\\u0005)\\u0000\"+\n+\t\t\"\\u0000\\u015eM\\u0001\\u0000\\u0000\\u0000\\u015f\\u0160\\u0005*\\u0000\\u0000\\u0160\"+\n+\t\t\"O\\u0001\\u0000\\u0000\\u0000\\u0161\\u0162\\u0005!\\u0000\\u0000\\u0162Q\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0163\\u0164\\u0005<\\u0000\\u0000\\u0164\\u0165\\u0005=\\u0000\"+\n+\t\t\"\\u0000\\u0165S\\u0001\\u0000\\u0000\\u0000\\u0166\\u0167\\u0005.\\u0000\\u0000\\u0167\"+\n+\t\t\"U\\u0001\\u0000\\u0000\\u0000\\u0168\\u0169\\u0005/\\u0000\\u0000\\u0169W\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u016a\\u016b\\u0005>\\u0000\\u0000\\u016b\\u016c\\u0005=\\u0000\"+\n+\t\t\"\\u0000\\u016cY\\u0001\\u0000\\u0000\\u0000\\u016d\\u016e\\u0005=\\u0000\\u0000\\u016e\"+\n+\t\t\"\\u016f\\u0005>\\u0000\\u0000\\u016f[\\u0001\\u0000\\u0000\\u0000\\u0170\\u0171\\u0005\"+\n+\t\t\",\\u0000\\u0000\\u0171]\\u0001\\u0000\\u0000\\u0000\\u0172\\u0173\\u0005%\\u0000\"+\n+\t\t\"\\u0000\\u0173_\\u0001\\u0000\\u0000\\u0000\\u0174\\u0175\\u0005.\\u0000\\u0000\\u0175\"+\n+\t\t\"\\u0176\\u0005.\\u0000\\u0000\\u0176\\u0177\\u0005.\\u0000\\u0000\\u0177a\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0178\\u0179\\u0005~\\u0000\\u0000\\u0179c\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u017a\\u017b\\u0005$\\u0000\\u0000\\u017b\\u017c\\u0005{\\u0000\\u0000\\u017c\"+\n+\t\t\"\\u017d\\u0001\\u0000\\u0000\\u0000\\u017d\\u017e\\u00060\\u0005\\u0000\\u017e\\u017f\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u017f\\u0180\\u00060\\u0006\\u0000\\u0180e\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0181\\u0183\\u0003h2\\u0000\\u0182\\u0181\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0183\\u0184\\u0001\\u0000\\u0000\\u0000\\u0184\\u0182\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0184\\u0185\\u0001\\u0000\\u0000\\u0000\\u0185g\\u0001\\u0000\\u0000\\u0000\\u0186\"+\n+\t\t\"\\u0191\\b\\u0000\\u0000\\u0000\\u0187\\u0188\\u0005$\\u0000\\u0000\\u0188\\u0191\"+\n+\t\t\"\\u0005$\\u0000\\u0000\\u0189\\u018a\\u0005$\\u0000\\u0000\\u018a\\u0191\\u00042\"+\n+\t\t\"\\u0000\\u0000\\u018b\\u018c\\u0005%\\u0000\\u0000\\u018c\\u0191\\u0005%\\u0000\\u0000\"+\n+\t\t\"\\u018d\\u018e\\u0005%\\u0000\\u0000\\u018e\\u0191\\u00042\\u0001\\u0000\\u018f\\u0191\"+\n+\t\t\"\\u0003\\\"\\u000f\\u0000\\u0190\\u0186\\u0001\\u0000\\u0000\\u0000\\u0190\\u0187\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0190\\u0189\\u0001\\u0000\\u0000\\u0000\\u0190\\u018b\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0190\\u018d\\u0001\\u0000\\u0000\\u0000\\u0190\\u018f\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0191i\\u0001\\u0000\\u0000\\u0000\\u0192\\u0193\\u0005\\\"\"+\n+\t\t\"\\u0000\\u0000\\u0193\\u0194\\u0001\\u0000\\u0000\\u0000\\u0194\\u0195\\u00063\\u0007\"+\n+\t\t\"\\u0000\\u0195\\u0196\\u00063\\b\\u0000\\u0196k\\u0001\\u0000\\u0000\\u0000\\u0197\"+\n+\t\t\"\\u0198\\u0005\\n\\u0000\\u0000\\u0198\\u0199\\u0001\\u0000\\u0000\\u0000\\u0199\\u019a\"+\n+\t\t\"\\u00064\\t\\u0000\\u019a\\u019b\\u00064\\n\\u0000\\u019bm\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u019c\\u01a1\\u0003 \\u000e\\u0000\\u019d\\u01a0\\u0003\\u001e\\r\\u0000\\u019e\"+\n+\t\t\"\\u01a0\\u0005-\\u0000\\u0000\\u019f\\u019d\\u0001\\u0000\\u0000\\u0000\\u019f\\u019e\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u01a0\\u01a3\\u0001\\u0000\\u0000\\u0000\\u01a1\\u019f\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u01a1\\u01a2\\u0001\\u0000\\u0000\\u0000\\u01a2\\u01a4\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u01a3\\u01a1\\u0001\\u0000\\u0000\\u0000\\u01a4\\u01a5\"+\n+\t\t\"\\u00065\\u000b\\u0000\\u01a5\\u01a6\\u0001\\u0000\\u0000\\u0000\\u01a6\\u01a7\\u0006\"+\n+\t\t\"5\\f\\u0000\\u01a7o\\u0001\\u0000\\u0000\\u0000\\u01a8\\u01a9\\u0005\\n\\u0000\\u0000\"+\n+\t\t\"\\u01a9\\u01aa\\u0001\\u0000\\u0000\\u0000\\u01aa\\u01ab\\u00066\\t\\u0000\\u01ab\"+\n+\t\t\"q\\u0001\\u0000\\u0000\\u0000\\u01ac\\u01ad\\u0005$\\u0000\\u0000\\u01ad\\u01ae\\u0005\"+\n+\t\t\"{\\u0000\\u0000\\u01ae\\u01af\\u0001\\u0000\\u0000\\u0000\\u01af\\u01b0\\u00067\\r\"+\n+\t\t\"\\u0000\\u01b0\\u01b1\\u0001\\u0000\\u0000\\u0000\\u01b1\\u01b2\\u00067\\u000e\\u0000\"+\n+\t\t\"\\u01b2\\u01b3\\u00067\\u0006\\u0000\\u01b3s\\u0001\\u0000\\u0000\\u0000\\u01b4\\u01b6\"+\n+\t\t\"\\u0003v9\\u0000\\u01b5\\u01b4\\u0001\\u0000\\u0000\\u0000\\u01b6\\u01b7\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u01b7\\u01b5\\u0001\\u0000\\u0000\\u0000\\u01b7\\u01b8\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u01b8\\u01b9\\u0001\\u0000\\u0000\\u0000\\u01b9\\u01ba\\u00068\\u000f\"+\n+\t\t\"\\u0000\\u01bau\\u0001\\u0000\\u0000\\u0000\\u01bb\\u01c2\\b\\r\\u0000\\u0000\\u01bc\"+\n+\t\t\"\\u01bd\\u0005$\\u0000\\u0000\\u01bd\\u01c2\\b\\u000e\\u0000\\u0000\\u01be\\u01bf\"+\n+\t\t\"\\u0005%\\u0000\\u0000\\u01bf\\u01c2\\b\\u000e\\u0000\\u0000\\u01c0\\u01c2\\u0003\"+\n+\t\t\"\\\"\\u000f\\u0000\\u01c1\\u01bb\\u0001\\u0000\\u0000\\u0000\\u01c1\\u01bc\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u01c1\\u01be\\u0001\\u0000\\u0000\\u0000\\u01c1\\u01c0\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u01c2w\\u0001\\u0000\\u0000\\u0000$\\u0000\\u0001\\u0002\\u0003}\"+\n+\t\t\"\\u007f\\u008d\\u008f\\u00a8\\u00ad\\u00af\\u00b5\\u00bf\\u00ca\\u00cf\\u00d3\\u00d6\"+\n+\t\t\"\\u00e0\\u00e6\\u00fa\\u0101\\u0107\\u010b\\u0110\\u0116\\u0118\\u011c\\u0121\\u012c\"+\n+\t\t\"\\u013b\\u0184\\u0190\\u019f\\u01a1\\u01b7\\u01c1\\u0010\\u0001\\u0004\\u0000\\u0001\"+\n+\t\t\"\\u0005\\u0001\\u0000\\u0001\\u0000\\u0005\\u0001\\u0000\\u0005\\u0002\\u0000\\u0001\"+\n+\t\t\"0\\u0002\\u0005\\u0000\\u0000\\u0007\\u000f\\u0000\\u0004\\u0000\\u0000\\u0007\\f\"+\n+\t\t\"\\u0000\\u0002\\u0003\\u0000\\u00015\\u0003\\u0007\\b\\u0000\\u00017\\u0004\\u0007\"+\n+\t\t\"+\\u0000\\u00018\\u0005\";\n \tpublic static final ATN _ATN =\n \t\tnew ATNDeserializer().deserialize(_serializedATN.toCharArray());\n \tstatic {\n\ndiff --git a/rewrite-hcl/src/main/java/org/openrewrite/hcl/tree/Space.java b/rewrite-hcl/src/main/java/org/openrewrite/hcl/tree/Space.java\nindex 1b4c56e5bdc..854b9299aee 100644\n--- a/rewrite-hcl/src/main/java/org/openrewrite/hcl/tree/Space.java\n+++ b/rewrite-hcl/src/main/java/org/openrewrite/hcl/tree/Space.java\n@@ -225,6 +225,11 @@ public static Space format(String formatting) {\n             last = c;\n         }\n \n+        if ((comment.length() > 0)) {\n+            comments.add(new Comment(inLineSlashOrHashComment, comment.toString(), prefix.toString(), Markers.EMPTY));\n+            prefix = new StringBuilder();\n+        }\n+\n         // Shift the whitespace on each comment forward to be a suffix of the comment before it, and the\n         // whitespace on the first comment to be the whitespace of the tree element. The remaining prefix is the suffix\n         // of the last comment.\n",
    "test_patch": "diff --git a/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java b/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java\nindex 391964d5319..3a6d872b02d 100644\n--- a/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java\n+++ b/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclCommentTest.java\n@@ -16,7 +16,6 @@\n package org.openrewrite.hcl.tree;\n \n import org.junit.jupiter.api.Test;\n-import org.junitpioneer.jupiter.ExpectedToFail;\n import org.openrewrite.Issue;\n import org.openrewrite.test.RewriteTest;\n \n@@ -101,7 +100,6 @@ void inLineCommentsNextLineAttribute() {\n         );\n     }\n \n-    @ExpectedToFail\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/4611\")\n     @Test\n     void commentAsTheLastLine() {\n@@ -116,4 +114,20 @@ void commentAsTheLastLine() {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4611\")\n+    @Test\n+    void commentsAsTheFinalLines() {\n+        rewriteRun(\n+          hcl(\n+            \"\"\"\n+              locals {\n+                a = 3\n+              }\n+              # Nice code, right?\n+              # Isn't it?\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4860",
    "pr_id": 4860,
    "issue_id": 4781,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Lombok: JavaParser fails with  StringIndexOutOfBoundsException when lombok processor is enabled\n## What version of OpenRewrite are you using?\r\n- OpenRewrite 8.41.2\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\nI haven't debugged the exact root cause yet. the issue seems to occur when annotations are added or removed in the source code. This appears to result in incorrect character positions for the cursor. \r\n(Will add more detail about the issue after debugging)\r\n\r\n```java\r\n  @Getter\r\n  @Builder\r\n  public static class Request {\r\n    @Nonnull private final List<TransportJobId> transportJobIds;\r\n    @Nullable private final UnixTimeMillis estimatedReadyAt;\r\n    @Nonnull private final RegionId regionId;\r\n    @Nonnull private final boolean wasTriggeredFromFulfillmentOrder;\r\n  }\r\n```\r\n\r\n## What did you expect to see?\r\nA valid compilation unit should be generated for the source file.\r\n\r\n## What did you see instead?\r\nA [ParseError](https://github.com/openrewrite/rewrite/blob/a98d83d698dda9971c93a0767b7f85d5866f306d/rewrite-core/src/main/java/org/openrewrite/tree/ParseError.java) instance is generated for the source file instead.\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n\r\n```\r\njava.lang.StringIndexOutOfBoundsException: begin 5327, end 5315, length 5434\r\n  java.base/java.lang.String.checkBoundsBeginEnd(String.java:3319)\r\n  java.base/java.lang.String.substring(String.java:1874)\r\n  org.openrewrite.java.isolated.ReloadableJava17ParserVisitor.visitAnnotation(ReloadableJava17ParserVisitor.java:143)\r\n  org.openrewrite.java.isolated.ReloadableJava17ParserVisitor.visitAnnotation(ReloadableJava17ParserVisitor.java:72)\r\n  com.sun.tools.javac.tree.JCTree$JCAnnotation.accept(JCTree.java:2601)\r\n  com.sun.source.util.TreePathScanner.scan(TreePathScanner.java:82)\r\n  org.openrewrite.java.isolated.ReloadableJava17ParserVisitor.convert(ReloadableJava17ParserVisitor.java:1604)\r\n  ...\r\n\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite]\r\nYes.\r\n",
    "issue_word_count": 247,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-21/build.gradle.kts",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21Parser.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java"
    ],
    "base_commit": "b3f17cea87340343832ded6c3a18eb22a9aeea12",
    "head_commit": "dd795fe5bc301c66d3253ab7e993392bc6bd5583",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4860",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4860",
    "dockerfile": "",
    "pr_merged_at": "2025-01-07T14:45:02.000Z",
    "patch": "diff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex 673d84fff4e..9f56bfb0b3c 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -544,7 +544,6 @@ public J visitCompilationUnit(CompilationUnitTree node, Space fmt) {\n \n         Map<Integer, JCAnnotation> annotationPosTable = mapAnnotations(node.getPackageAnnotations(),\n                 new HashMap<>(node.getPackageAnnotations().size()));\n-\n         List<J.Annotation> packageAnnotations = collectAnnotations(annotationPosTable);\n \n         J.Package packageDecl = null;\n\ndiff --git a/rewrite-java-21/build.gradle.kts b/rewrite-java-21/build.gradle.kts\nindex 143abb855fc..8ab5e091748 100644\n--- a/rewrite-java-21/build.gradle.kts\n+++ b/rewrite-java-21/build.gradle.kts\n@@ -17,6 +17,7 @@ val javaTck = configurations.create(\"javaTck\") {\n dependencies {\n     api(project(\":rewrite-core\"))\n     api(project(\":rewrite-java\"))\n+    runtimeOnly(project(\":rewrite-java-lombok\"))\n \n     compileOnly(\"org.slf4j:slf4j-api:1.7.+\")\n \n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21Parser.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21Parser.java\nindex 823e2103f10..5b3ac22b69e 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21Parser.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21Parser.java\n@@ -21,10 +21,12 @@\n import com.sun.tools.javac.comp.Modules;\n import com.sun.tools.javac.file.JavacFileManager;\n import com.sun.tools.javac.main.JavaCompiler;\n+import com.sun.tools.javac.main.Option;\n import com.sun.tools.javac.tree.JCTree;\n import com.sun.tools.javac.util.Context;\n import com.sun.tools.javac.util.Log;\n import com.sun.tools.javac.util.Options;\n+import lombok.Getter;\n import org.jspecify.annotations.NullMarked;\n import org.jspecify.annotations.Nullable;\n import org.objectweb.asm.ClassReader;\n@@ -33,7 +35,6 @@\n import org.openrewrite.ExecutionContext;\n import org.openrewrite.InMemoryExecutionContext;\n import org.openrewrite.SourceFile;\n-import org.openrewrite.internal.StringUtils;\n import org.openrewrite.java.JavaParser;\n import org.openrewrite.java.JavaParsingException;\n import org.openrewrite.java.internal.JavaTypeCache;\n@@ -43,20 +44,27 @@\n import org.openrewrite.tree.ParseError;\n import org.openrewrite.tree.ParsingEventListener;\n import org.openrewrite.tree.ParsingExecutionContextView;\n+import org.slf4j.LoggerFactory;\n \n+import javax.annotation.processing.Processor;\n import javax.tools.JavaFileManager;\n import javax.tools.JavaFileObject;\n import javax.tools.SimpleJavaFileObject;\n import javax.tools.StandardLocation;\n import java.io.*;\n+import java.lang.reflect.Constructor;\n import java.net.URI;\n+import java.net.URL;\n import java.nio.charset.Charset;\n import java.nio.file.Path;\n+import java.nio.file.Paths;\n import java.util.*;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.stream.Stream;\n import java.util.stream.StreamSupport;\n \n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n import static java.util.stream.Collectors.toList;\n \n /**\n@@ -77,14 +85,16 @@ public class ReloadableJava21Parser implements JavaParser {\n     private final JavaCompiler compiler;\n     private final ResettableLog compilerLog;\n     private final Collection<NamedStyles> styles;\n-\n-    private ReloadableJava21Parser(boolean logCompilationWarningsAndErrors,\n-                                   @Nullable Collection<Path> classpath,\n-                                   Collection<byte[]> classBytesClasspath,\n-                                   @Nullable Collection<Input> dependsOn,\n-                                   Charset charset,\n-                                   Collection<NamedStyles> styles,\n-                                   JavaTypeCache typeCache) {\n+    private final List<Processor> annotationProcessors;\n+\n+    private ReloadableJava21Parser(\n+            boolean logCompilationWarningsAndErrors,\n+            @Nullable Collection<Path> classpath,\n+            Collection<byte[]> classBytesClasspath,\n+            @Nullable Collection<Input> dependsOn,\n+            Charset charset,\n+            Collection<NamedStyles> styles,\n+            JavaTypeCache typeCache) {\n         this.classpath = classpath;\n         this.dependsOn = dependsOn;\n         this.styles = styles;\n@@ -106,6 +116,70 @@ private ReloadableJava21Parser(boolean logCompilationWarningsAndErrors,\n         Options.instance(context).put(\"-g\", \"-g\");\n         Options.instance(context).put(\"-proc\", \"none\");\n \n+        // Ensure type attribution continues despite errors in individual files or nodes.\n+        // If an error occurs in a single file or node, type attribution should still proceed\n+        // for all other source files and unaffected nodes within the same file.\n+        Options.instance(context).put(\"should-stop.ifError\", \"GENERATE\");\n+\n+        LOMBOK:\n+        if (System.getenv().getOrDefault(\"REWRITE_LOMBOK\", System.getProperty(\"rewrite.lombok\")) != null &&\n+            classpath != null && classpath.stream().anyMatch(it -> it.toString().contains(\"lombok\"))) {\n+            Processor lombokProcessor = null;\n+            try {\n+                // https://projectlombok.org/contributing/lombok-execution-path\n+                List<String> overrideClasspath = new ArrayList<>();\n+                for (Path part : classpath) {\n+                    if (part.toString().contains(\"lombok\")) {\n+                        overrideClasspath.add(part.toString());\n+                    }\n+                }\n+                // make sure the rewrite-java-lombok dependency comes first\n+                boolean found = false;\n+                for (int i = 0; i < overrideClasspath.size(); i++) {\n+                    if (overrideClasspath.get(i).contains(\"rewrite-java-lombok\")) {\n+                        overrideClasspath.add(0, overrideClasspath.remove(i));\n+                        found = true;\n+                    }\n+                }\n+                if (!found) {\n+                    // try to find `rewrite-java-lombok` using class loader\n+                    URL resource = getClass().getClassLoader().getResource(\"org/openrewrite/java/lombok/OpenRewriteConfigurationKeysLoader.class\");\n+                    if (resource != null && resource.getProtocol().equals(\"jar\") && resource.getPath().startsWith(\"file:\")) {\n+                        String path = Paths.get(URI.create(resource.getPath().substring(0, resource.getPath().indexOf(\"!\")))).toString();\n+                        overrideClasspath.add(0, path);\n+                    } else {\n+                        break LOMBOK;\n+                    }\n+                }\n+                System.setProperty(\"shadow.override.lombok\", String.join(File.pathSeparator, overrideClasspath));\n+\n+                Class<?> shadowLoaderClass = Class.forName(\"lombok.launch.ShadowClassLoader\", true, getClass().getClassLoader());\n+                Constructor<?> shadowLoaderConstructor = shadowLoaderClass.getDeclaredConstructor(\n+                        Class.forName(\"java.lang.ClassLoader\"),\n+                        Class.forName(\"java.lang.String\"),\n+                        Class.forName(\"java.lang.String\"),\n+                        Class.forName(\"java.util.List\"),\n+                        Class.forName(\"java.util.List\"));\n+                shadowLoaderConstructor.setAccessible(true);\n+\n+                ClassLoader lombokShadowLoader = (ClassLoader) shadowLoaderConstructor.newInstance(\n+                        getClass().getClassLoader(),\n+                        \"lombok\",\n+                        null,\n+                        emptyList(),\n+                        singletonList(\"lombok.patcher.Symbols\")\n+                );\n+                lombokProcessor = (Processor) lombokShadowLoader.loadClass(\"lombok.core.AnnotationProcessor\").getDeclaredConstructor().newInstance();\n+                Options.instance(context).put(Option.PROCESSOR, \"lombok.launch.AnnotationProcessorHider$AnnotationProcessor\");\n+            } catch (ReflectiveOperationException ignore) {\n+                // Lombok was not found or could not be initialized\n+            } finally {\n+                annotationProcessors = lombokProcessor != null ? singletonList(lombokProcessor) : emptyList();\n+            }\n+        } else {\n+            annotationProcessors = emptyList();\n+        }\n+\n         // MUST be created (registered with the context) after pfm and compilerLog\n         compiler = new JavaCompiler(context);\n \n@@ -124,7 +198,7 @@ public void write(char[] cbuf, int off, int len) {\n                 if (logCompilationWarningsAndErrors) {\n                     String log = new String(Arrays.copyOfRange(cbuf, off, len));\n                     if (!log.isBlank()) {\n-                        org.slf4j.LoggerFactory.getLogger(ReloadableJava21Parser.class).warn(log);\n+                        LoggerFactory.getLogger(ReloadableJava21Parser.class).warn(log);\n                     }\n                 }\n             }\n@@ -164,6 +238,7 @@ public Stream<SourceFile> parseInputs(Iterable<Input> sourceFiles, @Nullable Pat\n                 );\n \n                 J.CompilationUnit cu = (J.CompilationUnit) parser.scan(cuByPath.getValue(), Space.EMPTY);\n+                //noinspection DataFlowIssue\n                 cuByPath.setValue(null); // allow memory used by this JCCompilationUnit to be released\n                 parsingListener.parsed(input, cu);\n                 return requirePrintEqualsInput(cu, input, relativeTo, ctx);\n@@ -188,39 +263,46 @@ LinkedHashMap<Input, JCTree.JCCompilationUnit> parseInputsToCompilerAst(Iterable\n         }\n \n         LinkedHashMap<Input, JCTree.JCCompilationUnit> cus = new LinkedHashMap<>();\n-        acceptedInputs(sourceFiles).forEach(input1 -> {\n+        List<ReloadableJava21ParserInputFileObject> inputFileObjects = acceptedInputs(sourceFiles)\n+                .map(input -> new ReloadableJava21ParserInputFileObject(input, ctx))\n+                .toList();\n+        if (!annotationProcessors.isEmpty()) {\n+            compiler.initProcessAnnotations(annotationProcessors, inputFileObjects, emptyList());\n+        }\n+        try {\n+            //noinspection unchecked\n+            com.sun.tools.javac.util.List<JCTree.JCCompilationUnit> jcCompilationUnits = compiler.parseFiles((List<JavaFileObject>) (List<?>) inputFileObjects, true);\n+            for (int i = 0; i < inputFileObjects.size(); i++) {\n+                cus.put(inputFileObjects.get(i).getInput(), jcCompilationUnits.get(i));\n+            }\n             try {\n-                JCTree.JCCompilationUnit jcCompilationUnit = compiler.parse(new ReloadableJava21ParserInputFileObject(input1, ctx));\n-                cus.put(input1, jcCompilationUnit);\n-            } catch (IllegalStateException e) {\n-                if (\"endPosTable already set\".equals(e.getMessage())) {\n-                    throw new IllegalStateException(\n-                            \"Call reset() on JavaParser before parsing another set of source files that \" +\n-                            \"have some of the same fully qualified names. Source file [\" +\n-                            input1.getPath() + \"]\\n[\\n\" + StringUtils.readFully(input1.getSource(ctx), getCharset(ctx)) + \"\\n]\", e);\n+                initModules(cus.values());\n+                enterAll(cus.values());\n+\n+                // For some reason this is necessary in JDK 9+, where the internal block counter that\n+                // annotationsBlocked() tests against remains >0 after attribution.\n+                Annotate annotate = Annotate.instance(context);\n+                while (annotate.annotationsBlocked()) {\n+                    annotate.unblockAnnotations(); // also flushes once unblocked\n                 }\n-                throw e;\n+                if (!annotationProcessors.isEmpty()) {\n+                    compiler.processAnnotations(jcCompilationUnits, emptyList());\n+                }\n+                compiler.attribute(compiler.todo);\n+            } catch (Throwable t) {\n+                // when symbol entering fails on problems like missing types, attribution can often times proceed\n+                // unhindered, but it sometimes cannot (so attribution is always best-effort in the presence of errors)\n+                ctx.getOnError().accept(new JavaParsingException(\"Failed symbol entering or attribution\", t));\n             }\n-        });\n-\n-        try {\n-            initModules(cus.values());\n-            enterAll(cus.values());\n-\n-            // For some reason this is necessary in JDK 9+, where the internal block counter that\n-            // annotationsBlocked() tests against remains >0 after attribution.\n-            Annotate annotate = Annotate.instance(context);\n-            while (annotate.annotationsBlocked()) {\n-                annotate.unblockAnnotations(); // also flushes once unblocked\n+        } catch (IllegalStateException e) {\n+            if (\"endPosTable already set\".equals(e.getMessage())) {\n+                throw new IllegalStateException(\n+                        \"Call reset() on JavaParser before parsing another set of source files that \" +\n+                        \"have some of the same fully qualified names.\", e);\n             }\n-\n-            compiler.attribute(compiler.todo);\n-        } catch (\n-                Throwable t) {\n-            // when symbol entering fails on problems like missing types, attribution can often times proceed\n-            // unhindered, but it sometimes cannot (so attribution is always best-effort in the presence of errors)\n-            ctx.getOnError().accept(new JavaParsingException(\"Failed symbol entering or attribution\", t));\n+            throw e;\n         }\n+\n         return cus;\n     }\n \n@@ -333,9 +415,9 @@ public Iterable<JavaFileObject> list(Location location, String packageName, Set<\n                 Iterable<JavaFileObject> listed = super.list(location, packageName, kinds, recurse);\n                 return classByteClasspath.isEmpty() ? listed :\n                         Stream.concat(classByteClasspath.stream()\n-                                .filter(jfo -> jfo.getPackage().equals(packageName)),\n-                        StreamSupport.stream(listed.spliterator(), false)\n-                ).collect(toList());\n+                                        .filter(jfo -> jfo.getPackage().equals(packageName)),\n+                                StreamSupport.stream(listed.spliterator(), false)\n+                        ).collect(toList());\n             }\n             return super.list(location, packageName, kinds, recurse);\n         }\n@@ -343,6 +425,7 @@ public Iterable<JavaFileObject> list(Location location, String packageName, Set<\n \n     private static class PackageAwareJavaFileObject extends SimpleJavaFileObject {\n         private final String pkg;\n+        @Getter\n         private final String className;\n         private final byte[] classBytes;\n \n@@ -376,10 +459,6 @@ public String getPackage() {\n             return pkg;\n         }\n \n-        public String getClassName() {\n-            return className;\n-        }\n-\n         @Override\n         public InputStream openInputStream() {\n             return new ByteArrayInputStream(classBytes);\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex 0eeba8521e6..c1c20fd3ff4 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -19,6 +19,7 @@\n import com.sun.source.doctree.DocCommentTree;\n import com.sun.source.tree.*;\n import com.sun.source.util.TreePathScanner;\n+import com.sun.tools.javac.code.Attribute;\n import com.sun.tools.javac.code.Flags;\n import com.sun.tools.javac.code.Symbol;\n import com.sun.tools.javac.tree.DocCommentTable;\n@@ -391,6 +392,7 @@ public J visitCatch(CatchTree node, Space fmt) {\n     public J visitClass(ClassTree node, Space fmt) {\n         Map<Integer, JCAnnotation> annotationPosTable = mapAnnotations(node.getModifiers().getAnnotations(),\n                 new HashMap<>(node.getModifiers().getAnnotations().size()));\n+\n         ReloadableJava21ModifierResults modifierResults = sortedModifiersAndAnnotations(node.getModifiers(), annotationPosTable);\n \n         List<J.Annotation> kindAnnotations = collectAnnotations(annotationPosTable);\n@@ -437,7 +439,7 @@ public J visitClass(ClassTree node, Space fmt) {\n         }\n \n         JLeftPadded<TypeTree> extendings = node.getExtendsClause() == null ? null :\n-                padLeft(sourceBefore(\"extends\"), convertOrNull(node.getExtendsClause()));\n+                padLeft(sourceBefore(\"extends\"), convert(node.getExtendsClause()));\n \n         JContainer<TypeTree> implementings = null;\n         if (node.getImplementsClause() != null && !node.getImplementsClause().isEmpty()) {\n@@ -700,7 +702,7 @@ public J visitForLoop(ForLoopTree node, Space fmt) {\n                                 commaDelim.apply(t)\n                 );\n \n-        JRightPadded<Expression> condition = convertOrNull(node.getCondition(), semiDelim);\n+        JRightPadded<Expression> condition = convert(node.getCondition(), semiDelim);\n         if (condition == null) {\n             condition = padRight(new J.Empty(randomId(), sourceBefore(\";\"), Markers.EMPTY), EMPTY);\n         }\n@@ -955,6 +957,7 @@ public J visitMethod(MethodTree node, Space fmt) {\n \n         Map<Integer, JCAnnotation> annotationPosTable = mapAnnotations(node.getModifiers().getAnnotations(),\n                 new HashMap<>(node.getModifiers().getAnnotations().size()));\n+\n         ReloadableJava21ModifierResults modifierResults = sortedModifiersAndAnnotations(node.getModifiers(), annotationPosTable);\n \n         J.TypeParameters typeParams;\n@@ -970,7 +973,7 @@ public J visitMethod(MethodTree node, Space fmt) {\n         }\n \n         List<J.Annotation> returnTypeAnnotations = collectAnnotations(annotationPosTable);\n-        TypeTree returnType = convertOrNull(node.getReturnType());\n+        TypeTree returnType = convert(node.getReturnType());\n         if (returnType != null && !returnTypeAnnotations.isEmpty()) {\n             returnType = new J.AnnotatedType(randomId(), Space.EMPTY, Markers.EMPTY,\n                     returnTypeAnnotations, returnType);\n@@ -1017,7 +1020,7 @@ public J visitMethod(MethodTree node, Space fmt) {\n                 JContainer.build(sourceBefore(\"throws\"), convertAll(node.getThrows(), commaDelim, noDelim),\n                         Markers.EMPTY);\n \n-        J.Block body = convertOrNull(node.getBody());\n+        J.Block body = convert(node.getBody());\n \n         JLeftPadded<Expression> defaultValue = node.getDefaultValue() == null ? null :\n                 padLeft(sourceBefore(\"default\"), convert(node.getDefaultValue()));\n@@ -1043,9 +1046,9 @@ public J visitNewArray(NewArrayTree node, Space fmt) {\n             while (elementType instanceof JCArrayTypeTree) {\n                 elementType = ((JCArrayTypeTree) elementType).elemtype;\n             }\n-            typeExpr = convertOrNull(elementType);\n+            typeExpr = convert(elementType);\n         } else {\n-            typeExpr = convertOrNull(jcVarType);\n+            typeExpr = convert(jcVarType);\n         }\n \n         List<? extends ExpressionTree> nodeDimensions = node.getDimensions();\n@@ -1095,7 +1098,7 @@ public J visitNewClass(NewClassTree node, Space fmt) {\n         }\n \n         // for enum definitions with anonymous class initializers, endPos of node identifier will be -1\n-        TypeTree clazz = endPos(node.getIdentifier()) >= 0 ? convertOrNull(node.getIdentifier()) : null;\n+        TypeTree clazz = endPos(node.getIdentifier()) >= 0 ? convert(node.getIdentifier()) : null;\n \n         JContainer<Expression> args;\n         if (positionOfNext(\"(\", '{') > -1) {\n@@ -1204,7 +1207,7 @@ public J visitPrimitiveType(PrimitiveTypeTree node, Space fmt) {\n     @Override\n     public J visitReturn(ReturnTree node, Space fmt) {\n         skip(\"return\");\n-        Expression expression = convertOrNull(node.getExpression());\n+        Expression expression = convert(node.getExpression());\n         return new J.Return(randomId(), fmt, Markers.EMPTY, expression);\n     }\n \n@@ -1569,8 +1572,14 @@ private J.VariableDeclarations visitVariables(List<VariableTree> nodes, Space fm\n                 // this is a lambda parameter with an inferred type expression\n                 typeExpr = null;\n             } else {\n-                typeExpr = new J.Identifier(randomId(), sourceBefore(\"var\"), Markers.EMPTY, emptyList(), \"var\", typeMapping.type(vartype), null);\n-                typeExpr = typeExpr.withMarkers(typeExpr.getMarkers().add(JavaVarKeyword.build()));\n+                boolean lombokVal = isLombokVal(node);\n+                typeExpr = new J.Identifier(randomId(),\n+                        sourceBefore(lombokVal ? \"val\" : \"var\"),\n+                        Markers.build(singletonList(JavaVarKeyword.build())),\n+                        emptyList(),\n+                        lombokVal ? \"val\" : \"var\",\n+                        typeMapping.type(vartype),\n+                        null);\n             }\n         } else if (vartype instanceof JCArrayTypeTree) {\n             JCExpression elementType = vartype;\n@@ -1590,6 +1599,10 @@ private J.VariableDeclarations visitVariables(List<VariableTree> nodes, Space fm\n             typeExpr = convert(vartype);\n         }\n \n+        if (typeExpr == null && node.declaredUsingVar()) {\n+            typeExpr = new J.Identifier(randomId(), sourceBefore(\"var\"), Markers.build(singletonList(JavaVarKeyword.build())), emptyList(), \"var\", typeMapping.type(vartype), null);\n+        }\n+\n         if (typeExpr != null && !typeExprAnnotations.isEmpty()) {\n             Space prefix = typeExprAnnotations.get(0).getPrefix();\n             typeExpr = new J.AnnotatedType(randomId(), prefix, Markers.EMPTY, ListUtils.mapFirst(typeExprAnnotations, a -> a.withPrefix(EMPTY)), typeExpr);\n@@ -1623,7 +1636,7 @@ private J.VariableDeclarations visitVariables(List<VariableTree> nodes, Space fm\n                             new J.VariableDeclarations.NamedVariable(randomId(), namedVarPrefix, Markers.EMPTY,\n                                     name,\n                                     dimensionsAfterName,\n-                                    n.init != null ? padLeft(sourceBefore(\"=\"), convertOrNull(n.init)) : null,\n+                                    n.init != null ? padLeft(sourceBefore(\"=\"), convert(n.init)) : null,\n                                     (JavaType.Variable) typeMapping.type(n)\n                             ),\n                             i == nodes.size() - 1 ? EMPTY : sourceBefore(\",\")\n@@ -1680,7 +1693,7 @@ public J visitWildcard(WildcardTree node, Space fmt) {\n                 bound = null;\n         }\n \n-        return new J.Wildcard(randomId(), fmt, Markers.EMPTY, bound, convertOrNull(wildcard.inner));\n+        return new J.Wildcard(randomId(), fmt, Markers.EMPTY, bound, convert(wildcard.inner));\n     }\n \n     /**\n@@ -1688,10 +1701,12 @@ public J visitWildcard(WildcardTree node, Space fmt) {\n      * Conversion utilities\n      * --------------\n      */\n-\n-    private <J2 extends J> J2 convert(Tree t) {\n+    private <J2 extends J> @Nullable J2 convert(@Nullable Tree t) {\n+        if (t == null) {\n+            return null;\n+        }\n         try {\n-            String prefix = source.substring(cursor, max(((JCTree) t).getStartPosition(), cursor));\n+            String prefix = source.substring(cursor, Math.max(cursor, getActualStartPosition((JCTree) t)));\n             cursor += prefix.length();\n             // Java 21 and 23 have a different return type from getCommentTree; with reflection we can support both\n             Method getCommentTreeMethod = DocCommentTable.class.getMethod(\"getCommentTree\", JCTree.class);\n@@ -1707,6 +1722,14 @@ private <J2 extends J> J2 convert(Tree t) {\n         }\n     }\n \n+    private static int getActualStartPosition(JCTree t) {\n+        // not sure if this is a bug in Lombok, but the variable's start position is after the `val` annotation\n+        if (t instanceof JCVariableDecl && isLombokVal((JCVariableDecl) t)) {\n+            return ((JCVariableDecl) t).mods.annotations.get(0).getStartPosition();\n+        }\n+        return t.getStartPosition();\n+    }\n+\n     private void reportJavaParsingException(Throwable ex) {\n         // this SHOULD never happen, but is here simply as a diagnostic measure in the event of unexpected exceptions\n         StringBuilder message = new StringBuilder(\"Failed to convert for the following cursor stack:\");\n@@ -1731,7 +1754,10 @@ private void reportJavaParsingException(Throwable ex) {\n         ctx.getOnError().accept(new JavaParsingException(message.toString(), ex));\n     }\n \n-    private <J2 extends J> JRightPadded<J2> convert(Tree t, Function<Tree, Space> suffix) {\n+    private <J2 extends @Nullable J> @Nullable JRightPadded<J2> convert(@Nullable Tree t, Function<Tree, Space> suffix) {\n+        if (t == null) {\n+            return null;\n+        }\n         J2 j = convert(t);\n         @SuppressWarnings(\"ConstantConditions\") JRightPadded<J2> rightPadded = j == null ? null :\n                 new JRightPadded<>(j, suffix.apply(t), Markers.EMPTY);\n@@ -1776,14 +1802,6 @@ private long lineNumber(Tree tree) {\n         return source.substring(0, ((JCTree) tree).getStartPosition()).chars().filter(c -> c == '\\n').count() + 1;\n     }\n \n-    private <T extends J> @Nullable T convertOrNull(@Nullable Tree t) {\n-        return t == null ? null : convert(t);\n-    }\n-\n-    private <J2 extends J> @Nullable JRightPadded<J2> convertOrNull(@Nullable Tree t, Function<Tree, Space> suffix) {\n-        return t == null ? null : convert(t, suffix);\n-    }\n-\n     private <J2 extends J> List<J2> convertAll(List<? extends Tree> trees) {\n         List<J2> converted = new ArrayList<>(trees.size());\n         for (Tree tree : trees) {\n@@ -1888,6 +1906,9 @@ private List<JRightPadded<Statement>> convertStatements(@Nullable List<? extends\n \n         Map<Integer, List<Tree>> treesGroupedByStartPosition = new LinkedHashMap<>();\n         for (Tree t : trees) {\n+            if (isLombokGenerated(t)) {\n+                continue;\n+            }\n             treesGroupedByStartPosition.computeIfAbsent(((JCTree) t).getStartPosition(), k -> new ArrayList<>(1)).add(t);\n         }\n \n@@ -1917,6 +1938,53 @@ private List<JRightPadded<Statement>> convertStatements(@Nullable List<? extends\n         return converted;\n     }\n \n+    private static boolean isLombokVal(JCTree.JCVariableDecl t) {\n+        if (t.sym != null && t.sym.getMetadata() != null) {\n+            for (Attribute.Compound a : t.sym.getDeclarationAttributes()) {\n+                if (\"lombok.val\".equals(a.type.toString())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean isLombokGenerated(Tree t) {\n+        Symbol sym = null;\n+        if (t instanceof JCAnnotation) {\n+            t = ((JCAnnotation) t).getAnnotationType();\n+        }\n+        if (t instanceof JCIdent) {\n+            sym = ((JCIdent) t).sym;\n+        } else if (t instanceof JCTree.JCMethodDecl) {\n+            sym = ((JCMethodDecl) t).sym;\n+        } else if (t instanceof JCTree.JCClassDecl) {\n+            sym = ((JCClassDecl) t).sym;\n+        } else if (t instanceof JCTree.JCVariableDecl) {\n+            sym = ((JCVariableDecl) t).sym;\n+        }\n+        return isLombokGenerated(sym);\n+    }\n+\n+    private static boolean isLombokGenerated(@Nullable Symbol sym) {\n+        if (sym == null) {\n+            return false;\n+        }\n+        // Lombok val is represented as a @lombok.val on a \"final\" modifier, neither which appear in source\n+        if (\"lombok.val\".equals(sym.getQualifiedName().toString())) {\n+            return true;\n+        }\n+        if (sym.getMetadata() == null) {\n+            return false;\n+        }\n+        for (Attribute.Compound a : sym.getDeclarationAttributes()) {\n+            if (\"lombok.Generated\".equals(a.type.toString())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * --------------\n      * Other convenience utilities\n@@ -2093,7 +2161,12 @@ private ReloadableJava21ModifierResults sortedModifiersAndAnnotations(ModifiersT\n         int keywordStartIdx = -1;\n         for (int i = cursor; i < source.length(); i++) {\n             if (annotationPosTable.containsKey(i)) {\n-                J.Annotation annotation = convert(annotationPosTable.get(i));\n+                JCAnnotation jcAnnotation = annotationPosTable.get(i);\n+                // Skip over lombok's \"@val\" annotation which does not actually appear in source\n+                if (isLombokGenerated(jcAnnotation.getAnnotationType())) {\n+                    continue;\n+                }\n+                J.Annotation annotation = convert(jcAnnotation);\n                 if (afterFirstModifier) {\n                     currentAnnotations.add(annotation);\n                 } else {\n@@ -2213,7 +2286,11 @@ private List<J.Annotation> collectAnnotations(Map<Integer, JCAnnotation> annotat\n         boolean inMultilineComment = false;\n         for (int i = cursor; i <= maxAnnotationPosition && i < source.length(); i++) {\n             if (annotationPosTable.containsKey(i)) {\n-                annotations.add(convert(annotationPosTable.get(i)));\n+                JCAnnotation jcAnnotation = annotationPosTable.get(i);\n+                if (isLombokGenerated(jcAnnotation)) {\n+                    continue;\n+                }\n+                annotations.add(convert(jcAnnotation));\n                 i = cursor;\n                 continue;\n             }\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\nindex 3a7f7850365..6a355210012 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\n@@ -34,7 +34,7 @@\n import static org.openrewrite.java.Assertions.java;\n \n @SuppressWarnings({\"CaughtExceptionImmediatelyRethrown\", \"LombokGetterMayBeUsed\", \"LombokSetterMayBeUsed\", \"DefaultAnnotationParam\", \"NotNullFieldNotInitialized\", \"ProtectedMemberInFinalClass\", \"WriteOnlyObject\", \"ConcatenationWithEmptyString\"})\n-@EnabledOnJre({JRE.JAVA_11, JRE.JAVA_17})\n+@EnabledOnJre({JRE.JAVA_11, JRE.JAVA_17, JRE.JAVA_21})\n class LombokTest implements RewriteTest {\n \n     @BeforeAll\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4858",
    "pr_id": 4858,
    "issue_id": 4857,
    "repo": "openrewrite/rewrite",
    "problem_statement": "HCL - parsing fails for comments in multi-line `for` expression\n## Steps to reproduce\r\n\r\nUsing current main (`621dcfa15c597b64e365ef69569e344681bb8106`) try to parse this piece of code:\r\n```\r\nlocals {\r\n a = {\r\n   # this is some super smart logic here\r\n   for i, v in [\"a\", \"b\"]: v => i \r\n }\r\n}\r\n```\r\n(distilled from real-life https://github.com/terraform-aws-modules/terraform-aws-alb/blob/46ec74232f910a22c2756473d24ee96dc62e4d3e/main.tf#L466)\r\n\r\n## Observed\r\nFails with:\r\n```\r\nCaused by: org.openrewrite.hcl.HclParsingException: Syntax error in file.tf at line 4:7 no viable alternative at input '{\\n   # this is some super smart logic here\\n   for i'.\r\n\tat org.openrewrite.hcl.HclParser$ForwardingErrorListener.syntaxError(HclParser.java:105)\r\n\t... 30 more\r\nCaused by: org.antlr.v4.runtime.NoViableAltException\r\n\tat org.antlr.v4.runtime.atn.ParserATNSimulator.noViableAlt(ParserATNSimulator.java:2031)\r\n\tat org.antlr.v4.runtime.atn.ParserATNSimulator.execATN(ParserATNSimulator.java:470)\r\n\tat org.antlr.v4.runtime.atn.ParserATNSimulator.adaptivePredict(ParserATNSimulator.java:396)\r\n\tat org.openrewrite.hcl.internal.grammar.HCLParser.expression(HCLParser.java:592)\r\n\t... 25 more\r\n```\r\n",
    "issue_word_count": 158,
    "test_files_count": 1,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "rewrite-hcl/src/main/antlr/HCLLexer.g4",
      "rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.interp",
      "rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.java",
      "rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclForTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclForTest.java"
    ],
    "base_commit": "621dcfa15c597b64e365ef69569e344681bb8106",
    "head_commit": "0436e42bfba2d5ea27bbb94816ca69aef6ab7d59",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4858",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4858",
    "dockerfile": "",
    "pr_merged_at": "2025-01-07T12:13:30.000Z",
    "patch": "diff --git a/rewrite-hcl/src/main/antlr/HCLLexer.g4 b/rewrite-hcl/src/main/antlr/HCLLexer.g4\nindex 474d5a9babf..6266c3e22ec 100644\n--- a/rewrite-hcl/src/main/antlr/HCLLexer.g4\n+++ b/rewrite-hcl/src/main/antlr/HCLLexer.g4\n@@ -14,8 +14,8 @@ lexer grammar HCLLexer;\n     private Stack<String> heredocIdentifier = new Stack<String>();\n }\n \n-FOR_BRACE             : '{' (WS|NEWLINE)* 'for' WS;\n-FOR_BRACK             : '[' (WS|NEWLINE)* 'for' WS;\n+FOR_BRACE             : '{' (WS|NEWLINE|COMMENT|LINE_COMMENT)* 'for' WS;\n+FOR_BRACK             : '[' (WS|NEWLINE|COMMENT|LINE_COMMENT)* 'for' WS;\n \n IF              : 'if';\n IN              : 'in';\n\ndiff --git a/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.interp b/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.interp\nindex b210722ef06..1c2aaad6d58 100644\n--- a/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.interp\n+++ b/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.interp\n@@ -169,4 +169,4 @@ HEREDOC_PREAMBLE\n HEREDOC\n \n atn:\n-[4, 0, 47, 446, 6, -1, 6, -1, 6, -1, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 1, 0, 1, 0, 1, 0, 5, 0, 124, 8, 0, 10, 0, 12, 0, 127, 9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 5, 1, 138, 8, 1, 10, 1, 12, 1, 141, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 3, 7, 165, 8, 7, 1, 8, 1, 8, 1, 8, 5, 8, 170, 8, 8, 10, 8, 12, 8, 173, 9, 8, 1, 9, 4, 9, 176, 8, 9, 11, 9, 12, 9, 177, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 186, 8, 10, 10, 10, 12, 10, 189, 9, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 3, 11, 199, 8, 11, 1, 11, 5, 11, 202, 8, 11, 10, 11, 12, 11, 205, 9, 11, 1, 11, 3, 11, 208, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 3, 13, 220, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 226, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 246, 8, 15, 1, 16, 1, 16, 1, 17, 4, 17, 251, 8, 17, 11, 17, 12, 17, 252, 1, 17, 1, 17, 5, 17, 257, 8, 17, 10, 17, 12, 17, 260, 9, 17, 1, 17, 3, 17, 263, 8, 17, 1, 17, 4, 17, 266, 8, 17, 11, 17, 12, 17, 267, 1, 17, 1, 17, 4, 17, 272, 8, 17, 11, 17, 12, 17, 273, 3, 17, 276, 8, 17, 1, 18, 1, 18, 3, 18, 280, 8, 18, 1, 18, 4, 18, 283, 8, 18, 11, 18, 12, 18, 284, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 296, 8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 311, 8, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 35, 1, 35, 1, 36, 1, 36, 1, 37, 1, 37, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 4, 49, 382, 8, 49, 11, 49, 12, 49, 383, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 396, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 5, 53, 411, 8, 53, 10, 53, 12, 53, 414, 9, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 4, 56, 433, 8, 56, 11, 56, 12, 56, 434, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 445, 8, 57, 1, 187, 0, 58, 4, 1, 6, 2, 8, 3, 10, 4, 12, 5, 14, 6, 16, 7, 18, 0, 20, 8, 22, 9, 24, 10, 26, 11, 28, 12, 30, 0, 32, 0, 34, 0, 36, 0, 38, 13, 40, 0, 42, 14, 44, 15, 46, 16, 48, 17, 50, 18, 52, 19, 54, 20, 56, 21, 58, 22, 60, 23, 62, 24, 64, 25, 66, 26, 68, 27, 70, 28, 72, 29, 74, 30, 76, 31, 78, 32, 80, 33, 82, 34, 84, 35, 86, 36, 88, 37, 90, 38, 92, 39, 94, 40, 96, 41, 98, 42, 100, 43, 102, 44, 104, 45, 106, 0, 108, 0, 110, 0, 112, 0, 114, 0, 116, 46, 118, 47, 4, 0, 1, 2, 3, 14, 4, 0, 10, 10, 13, 13, 34, 34, 36, 37, 3, 0, 9, 9, 12, 13, 32, 32, 2, 0, 10, 10, 13, 13, 1, 0, 48, 57, 4, 0, 36, 36, 65, 90, 95, 95, 97, 122, 2, 0, 0, 127, 55296, 56319, 1, 0, 55296, 56319, 1, 0, 56320, 57343, 5, 0, 34, 34, 92, 92, 110, 110, 114, 114, 116, 116, 3, 0, 48, 57, 65, 70, 97, 102, 2, 0, 69, 69, 101, 101, 2, 0, 43, 43, 45, 45, 3, 0, 10, 10, 13, 13, 36, 37, 1, 0, 123, 123, 476, 0, 4, 1, 0, 0, 0, 0, 6, 1, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 10, 1, 0, 0, 0, 0, 12, 1, 0, 0, 0, 0, 14, 1, 0, 0, 0, 0, 16, 1, 0, 0, 0, 0, 20, 1, 0, 0, 0, 0, 22, 1, 0, 0, 0, 0, 24, 1, 0, 0, 0, 0, 26, 1, 0, 0, 0, 0, 28, 1, 0, 0, 0, 0, 38, 1, 0, 0, 0, 0, 42, 1, 0, 0, 0, 0, 44, 1, 0, 0, 0, 0, 46, 1, 0, 0, 0, 0, 48, 1, 0, 0, 0, 0, 50, 1, 0, 0, 0, 0, 52, 1, 0, 0, 0, 0, 54, 1, 0, 0, 0, 0, 56, 1, 0, 0, 0, 0, 58, 1, 0, 0, 0, 0, 60, 1, 0, 0, 0, 0, 62, 1, 0, 0, 0, 0, 64, 1, 0, 0, 0, 0, 66, 1, 0, 0, 0, 0, 68, 1, 0, 0, 0, 0, 70, 1, 0, 0, 0, 0, 72, 1, 0, 0, 0, 0, 74, 1, 0, 0, 0, 0, 76, 1, 0, 0, 0, 0, 78, 1, 0, 0, 0, 0, 80, 1, 0, 0, 0, 0, 82, 1, 0, 0, 0, 0, 84, 1, 0, 0, 0, 0, 86, 1, 0, 0, 0, 0, 88, 1, 0, 0, 0, 0, 90, 1, 0, 0, 0, 0, 92, 1, 0, 0, 0, 0, 94, 1, 0, 0, 0, 0, 96, 1, 0, 0, 0, 0, 98, 1, 0, 0, 0, 1, 100, 1, 0, 0, 0, 1, 102, 1, 0, 0, 0, 1, 104, 1, 0, 0, 0, 1, 106, 1, 0, 0, 0, 2, 108, 1, 0, 0, 0, 2, 110, 1, 0, 0, 0, 3, 112, 1, 0, 0, 0, 3, 114, 1, 0, 0, 0, 3, 116, 1, 0, 0, 0, 3, 118, 1, 0, 0, 0, 4, 120, 1, 0, 0, 0, 6, 134, 1, 0, 0, 0, 8, 148, 1, 0, 0, 0, 10, 151, 1, 0, 0, 0, 12, 154, 1, 0, 0, 0, 14, 157, 1, 0, 0, 0, 16, 160, 1, 0, 0, 0, 18, 164, 1, 0, 0, 0, 20, 166, 1, 0, 0, 0, 22, 175, 1, 0, 0, 0, 24, 181, 1, 0, 0, 0, 26, 198, 1, 0, 0, 0, 28, 213, 1, 0, 0, 0, 30, 219, 1, 0, 0, 0, 32, 225, 1, 0, 0, 0, 34, 245, 1, 0, 0, 0, 36, 247, 1, 0, 0, 0, 38, 275, 1, 0, 0, 0, 40, 277, 1, 0, 0, 0, 42, 295, 1, 0, 0, 0, 44, 297, 1, 0, 0, 0, 46, 301, 1, 0, 0, 0, 48, 306, 1, 0, 0, 0, 50, 314, 1, 0, 0, 0, 52, 316, 1, 0, 0, 0, 54, 319, 1, 0, 0, 0, 56, 322, 1, 0, 0, 0, 58, 324, 1, 0, 0, 0, 60, 326, 1, 0, 0, 0, 62, 328, 1, 0, 0, 0, 64, 330, 1, 0, 0, 0, 66, 332, 1, 0, 0, 0, 68, 335, 1, 0, 0, 0, 70, 338, 1, 0, 0, 0, 72, 340, 1, 0, 0, 0, 74, 342, 1, 0, 0, 0, 76, 344, 1, 0, 0, 0, 78, 346, 1, 0, 0, 0, 80, 348, 1, 0, 0, 0, 82, 350, 1, 0, 0, 0, 84, 353, 1, 0, 0, 0, 86, 355, 1, 0, 0, 0, 88, 357, 1, 0, 0, 0, 90, 360, 1, 0, 0, 0, 92, 363, 1, 0, 0, 0, 94, 365, 1, 0, 0, 0, 96, 367, 1, 0, 0, 0, 98, 371, 1, 0, 0, 0, 100, 373, 1, 0, 0, 0, 102, 381, 1, 0, 0, 0, 104, 395, 1, 0, 0, 0, 106, 397, 1, 0, 0, 0, 108, 402, 1, 0, 0, 0, 110, 407, 1, 0, 0, 0, 112, 419, 1, 0, 0, 0, 114, 423, 1, 0, 0, 0, 116, 432, 1, 0, 0, 0, 118, 444, 1, 0, 0, 0, 120, 125, 5, 123, 0, 0, 121, 124, 3, 22, 9, 0, 122, 124, 3, 28, 12, 0, 123, 121, 1, 0, 0, 0, 123, 122, 1, 0, 0, 0, 124, 127, 1, 0, 0, 0, 125, 123, 1, 0, 0, 0, 125, 126, 1, 0, 0, 0, 126, 128, 1, 0, 0, 0, 127, 125, 1, 0, 0, 0, 128, 129, 5, 102, 0, 0, 129, 130, 5, 111, 0, 0, 130, 131, 5, 114, 0, 0, 131, 132, 1, 0, 0, 0, 132, 133, 3, 22, 9, 0, 133, 5, 1, 0, 0, 0, 134, 139, 5, 91, 0, 0, 135, 138, 3, 22, 9, 0, 136, 138, 3, 28, 12, 0, 137, 135, 1, 0, 0, 0, 137, 136, 1, 0, 0, 0, 138, 141, 1, 0, 0, 0, 139, 137, 1, 0, 0, 0, 139, 140, 1, 0, 0, 0, 140, 142, 1, 0, 0, 0, 141, 139, 1, 0, 0, 0, 142, 143, 5, 102, 0, 0, 143, 144, 5, 111, 0, 0, 144, 145, 5, 114, 0, 0, 145, 146, 1, 0, 0, 0, 146, 147, 3, 22, 9, 0, 147, 7, 1, 0, 0, 0, 148, 149, 5, 105, 0, 0, 149, 150, 5, 102, 0, 0, 150, 9, 1, 0, 0, 0, 151, 152, 5, 105, 0, 0, 152, 153, 5, 110, 0, 0, 153, 11, 1, 0, 0, 0, 154, 155, 5, 123, 0, 0, 155, 156, 6, 4, 0, 0, 156, 13, 1, 0, 0, 0, 157, 158, 5, 125, 0, 0, 158, 159, 6, 5, 1, 0, 159, 15, 1, 0, 0, 0, 160, 161, 5, 61, 0, 0, 161, 17, 1, 0, 0, 0, 162, 165, 8, 0, 0, 0, 163, 165, 3, 34, 15, 0, 164, 162, 1, 0, 0, 0, 164, 163, 1, 0, 0, 0, 165, 19, 1, 0, 0, 0, 166, 171, 3, 32, 14, 0, 167, 170, 3, 30, 13, 0, 168, 170, 5, 45, 0, 0, 169, 167, 1, 0, 0, 0, 169, 168, 1, 0, 0, 0, 170, 173, 1, 0, 0, 0, 171, 169, 1, 0, 0, 0, 171, 172, 1, 0, 0, 0, 172, 21, 1, 0, 0, 0, 173, 171, 1, 0, 0, 0, 174, 176, 7, 1, 0, 0, 175, 174, 1, 0, 0, 0, 176, 177, 1, 0, 0, 0, 177, 175, 1, 0, 0, 0, 177, 178, 1, 0, 0, 0, 178, 179, 1, 0, 0, 0, 179, 180, 6, 9, 2, 0, 180, 23, 1, 0, 0, 0, 181, 182, 5, 47, 0, 0, 182, 183, 5, 42, 0, 0, 183, 187, 1, 0, 0, 0, 184, 186, 9, 0, 0, 0, 185, 184, 1, 0, 0, 0, 186, 189, 1, 0, 0, 0, 187, 188, 1, 0, 0, 0, 187, 185, 1, 0, 0, 0, 188, 190, 1, 0, 0, 0, 189, 187, 1, 0, 0, 0, 190, 191, 5, 42, 0, 0, 191, 192, 5, 47, 0, 0, 192, 193, 1, 0, 0, 0, 193, 194, 6, 10, 2, 0, 194, 25, 1, 0, 0, 0, 195, 196, 5, 47, 0, 0, 196, 199, 5, 47, 0, 0, 197, 199, 5, 35, 0, 0, 198, 195, 1, 0, 0, 0, 198, 197, 1, 0, 0, 0, 199, 203, 1, 0, 0, 0, 200, 202, 8, 2, 0, 0, 201, 200, 1, 0, 0, 0, 202, 205, 1, 0, 0, 0, 203, 201, 1, 0, 0, 0, 203, 204, 1, 0, 0, 0, 204, 207, 1, 0, 0, 0, 205, 203, 1, 0, 0, 0, 206, 208, 5, 13, 0, 0, 207, 206, 1, 0, 0, 0, 207, 208, 1, 0, 0, 0, 208, 209, 1, 0, 0, 0, 209, 210, 5, 10, 0, 0, 210, 211, 1, 0, 0, 0, 211, 212, 6, 11, 2, 0, 212, 27, 1, 0, 0, 0, 213, 214, 5, 10, 0, 0, 214, 215, 1, 0, 0, 0, 215, 216, 6, 12, 2, 0, 216, 29, 1, 0, 0, 0, 217, 220, 3, 32, 14, 0, 218, 220, 7, 3, 0, 0, 219, 217, 1, 0, 0, 0, 219, 218, 1, 0, 0, 0, 220, 31, 1, 0, 0, 0, 221, 226, 7, 4, 0, 0, 222, 226, 8, 5, 0, 0, 223, 224, 7, 6, 0, 0, 224, 226, 7, 7, 0, 0, 225, 221, 1, 0, 0, 0, 225, 222, 1, 0, 0, 0, 225, 223, 1, 0, 0, 0, 226, 33, 1, 0, 0, 0, 227, 228, 5, 92, 0, 0, 228, 246, 7, 8, 0, 0, 229, 230, 5, 92, 0, 0, 230, 231, 3, 36, 16, 0, 231, 232, 3, 36, 16, 0, 232, 233, 3, 36, 16, 0, 233, 234, 3, 36, 16, 0, 234, 246, 1, 0, 0, 0, 235, 236, 5, 92, 0, 0, 236, 237, 3, 36, 16, 0, 237, 238, 3, 36, 16, 0, 238, 239, 3, 36, 16, 0, 239, 240, 3, 36, 16, 0, 240, 241, 3, 36, 16, 0, 241, 242, 3, 36, 16, 0, 242, 243, 3, 36, 16, 0, 243, 244, 3, 36, 16, 0, 244, 246, 1, 0, 0, 0, 245, 227, 1, 0, 0, 0, 245, 229, 1, 0, 0, 0, 245, 235, 1, 0, 0, 0, 246, 35, 1, 0, 0, 0, 247, 248, 7, 9, 0, 0, 248, 37, 1, 0, 0, 0, 249, 251, 7, 3, 0, 0, 250, 249, 1, 0, 0, 0, 251, 252, 1, 0, 0, 0, 252, 250, 1, 0, 0, 0, 252, 253, 1, 0, 0, 0, 253, 254, 1, 0, 0, 0, 254, 258, 5, 46, 0, 0, 255, 257, 7, 3, 0, 0, 256, 255, 1, 0, 0, 0, 257, 260, 1, 0, 0, 0, 258, 256, 1, 0, 0, 0, 258, 259, 1, 0, 0, 0, 259, 262, 1, 0, 0, 0, 260, 258, 1, 0, 0, 0, 261, 263, 3, 40, 18, 0, 262, 261, 1, 0, 0, 0, 262, 263, 1, 0, 0, 0, 263, 276, 1, 0, 0, 0, 264, 266, 7, 3, 0, 0, 265, 264, 1, 0, 0, 0, 266, 267, 1, 0, 0, 0, 267, 265, 1, 0, 0, 0, 267, 268, 1, 0, 0, 0, 268, 269, 1, 0, 0, 0, 269, 276, 3, 40, 18, 0, 270, 272, 7, 3, 0, 0, 271, 270, 1, 0, 0, 0, 272, 273, 1, 0, 0, 0, 273, 271, 1, 0, 0, 0, 273, 274, 1, 0, 0, 0, 274, 276, 1, 0, 0, 0, 275, 250, 1, 0, 0, 0, 275, 265, 1, 0, 0, 0, 275, 271, 1, 0, 0, 0, 276, 39, 1, 0, 0, 0, 277, 279, 7, 10, 0, 0, 278, 280, 7, 11, 0, 0, 279, 278, 1, 0, 0, 0, 279, 280, 1, 0, 0, 0, 280, 282, 1, 0, 0, 0, 281, 283, 7, 3, 0, 0, 282, 281, 1, 0, 0, 0, 283, 284, 1, 0, 0, 0, 284, 282, 1, 0, 0, 0, 284, 285, 1, 0, 0, 0, 285, 41, 1, 0, 0, 0, 286, 287, 5, 116, 0, 0, 287, 288, 5, 114, 0, 0, 288, 289, 5, 117, 0, 0, 289, 296, 5, 101, 0, 0, 290, 291, 5, 102, 0, 0, 291, 292, 5, 97, 0, 0, 292, 293, 5, 108, 0, 0, 293, 294, 5, 115, 0, 0, 294, 296, 5, 101, 0, 0, 295, 286, 1, 0, 0, 0, 295, 290, 1, 0, 0, 0, 296, 43, 1, 0, 0, 0, 297, 298, 5, 34, 0, 0, 298, 299, 1, 0, 0, 0, 299, 300, 6, 20, 3, 0, 300, 45, 1, 0, 0, 0, 301, 302, 5, 110, 0, 0, 302, 303, 5, 117, 0, 0, 303, 304, 5, 108, 0, 0, 304, 305, 5, 108, 0, 0, 305, 47, 1, 0, 0, 0, 306, 307, 5, 60, 0, 0, 307, 308, 5, 60, 0, 0, 308, 310, 1, 0, 0, 0, 309, 311, 5, 45, 0, 0, 310, 309, 1, 0, 0, 0, 310, 311, 1, 0, 0, 0, 311, 312, 1, 0, 0, 0, 312, 313, 6, 22, 4, 0, 313, 49, 1, 0, 0, 0, 314, 315, 5, 43, 0, 0, 315, 51, 1, 0, 0, 0, 316, 317, 5, 38, 0, 0, 317, 318, 5, 38, 0, 0, 318, 53, 1, 0, 0, 0, 319, 320, 5, 61, 0, 0, 320, 321, 5, 61, 0, 0, 321, 55, 1, 0, 0, 0, 322, 323, 5, 60, 0, 0, 323, 57, 1, 0, 0, 0, 324, 325, 5, 58, 0, 0, 325, 59, 1, 0, 0, 0, 326, 327, 5, 91, 0, 0, 327, 61, 1, 0, 0, 0, 328, 329, 5, 40, 0, 0, 329, 63, 1, 0, 0, 0, 330, 331, 5, 45, 0, 0, 331, 65, 1, 0, 0, 0, 332, 333, 5, 124, 0, 0, 333, 334, 5, 124, 0, 0, 334, 67, 1, 0, 0, 0, 335, 336, 5, 33, 0, 0, 336, 337, 5, 61, 0, 0, 337, 69, 1, 0, 0, 0, 338, 339, 5, 62, 0, 0, 339, 71, 1, 0, 0, 0, 340, 341, 5, 63, 0, 0, 341, 73, 1, 0, 0, 0, 342, 343, 5, 93, 0, 0, 343, 75, 1, 0, 0, 0, 344, 345, 5, 41, 0, 0, 345, 77, 1, 0, 0, 0, 346, 347, 5, 42, 0, 0, 347, 79, 1, 0, 0, 0, 348, 349, 5, 33, 0, 0, 349, 81, 1, 0, 0, 0, 350, 351, 5, 60, 0, 0, 351, 352, 5, 61, 0, 0, 352, 83, 1, 0, 0, 0, 353, 354, 5, 46, 0, 0, 354, 85, 1, 0, 0, 0, 355, 356, 5, 47, 0, 0, 356, 87, 1, 0, 0, 0, 357, 358, 5, 62, 0, 0, 358, 359, 5, 61, 0, 0, 359, 89, 1, 0, 0, 0, 360, 361, 5, 61, 0, 0, 361, 362, 5, 62, 0, 0, 362, 91, 1, 0, 0, 0, 363, 364, 5, 44, 0, 0, 364, 93, 1, 0, 0, 0, 365, 366, 5, 37, 0, 0, 366, 95, 1, 0, 0, 0, 367, 368, 5, 46, 0, 0, 368, 369, 5, 46, 0, 0, 369, 370, 5, 46, 0, 0, 370, 97, 1, 0, 0, 0, 371, 372, 5, 126, 0, 0, 372, 99, 1, 0, 0, 0, 373, 374, 5, 36, 0, 0, 374, 375, 5, 123, 0, 0, 375, 376, 1, 0, 0, 0, 376, 377, 6, 48, 5, 0, 377, 378, 1, 0, 0, 0, 378, 379, 6, 48, 6, 0, 379, 101, 1, 0, 0, 0, 380, 382, 3, 104, 50, 0, 381, 380, 1, 0, 0, 0, 382, 383, 1, 0, 0, 0, 383, 381, 1, 0, 0, 0, 383, 384, 1, 0, 0, 0, 384, 103, 1, 0, 0, 0, 385, 396, 8, 0, 0, 0, 386, 387, 5, 36, 0, 0, 387, 396, 5, 36, 0, 0, 388, 389, 5, 36, 0, 0, 389, 396, 4, 50, 0, 0, 390, 391, 5, 37, 0, 0, 391, 396, 5, 37, 0, 0, 392, 393, 5, 37, 0, 0, 393, 396, 4, 50, 1, 0, 394, 396, 3, 34, 15, 0, 395, 385, 1, 0, 0, 0, 395, 386, 1, 0, 0, 0, 395, 388, 1, 0, 0, 0, 395, 390, 1, 0, 0, 0, 395, 392, 1, 0, 0, 0, 395, 394, 1, 0, 0, 0, 396, 105, 1, 0, 0, 0, 397, 398, 5, 34, 0, 0, 398, 399, 1, 0, 0, 0, 399, 400, 6, 51, 7, 0, 400, 401, 6, 51, 8, 0, 401, 107, 1, 0, 0, 0, 402, 403, 5, 10, 0, 0, 403, 404, 1, 0, 0, 0, 404, 405, 6, 52, 9, 0, 405, 406, 6, 52, 10, 0, 406, 109, 1, 0, 0, 0, 407, 412, 3, 32, 14, 0, 408, 411, 3, 30, 13, 0, 409, 411, 5, 45, 0, 0, 410, 408, 1, 0, 0, 0, 410, 409, 1, 0, 0, 0, 411, 414, 1, 0, 0, 0, 412, 410, 1, 0, 0, 0, 412, 413, 1, 0, 0, 0, 413, 415, 1, 0, 0, 0, 414, 412, 1, 0, 0, 0, 415, 416, 6, 53, 11, 0, 416, 417, 1, 0, 0, 0, 417, 418, 6, 53, 12, 0, 418, 111, 1, 0, 0, 0, 419, 420, 5, 10, 0, 0, 420, 421, 1, 0, 0, 0, 421, 422, 6, 54, 9, 0, 422, 113, 1, 0, 0, 0, 423, 424, 5, 36, 0, 0, 424, 425, 5, 123, 0, 0, 425, 426, 1, 0, 0, 0, 426, 427, 6, 55, 13, 0, 427, 428, 1, 0, 0, 0, 428, 429, 6, 55, 14, 0, 429, 430, 6, 55, 6, 0, 430, 115, 1, 0, 0, 0, 431, 433, 3, 118, 57, 0, 432, 431, 1, 0, 0, 0, 433, 434, 1, 0, 0, 0, 434, 432, 1, 0, 0, 0, 434, 435, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 437, 6, 56, 15, 0, 437, 117, 1, 0, 0, 0, 438, 445, 8, 12, 0, 0, 439, 440, 5, 36, 0, 0, 440, 445, 8, 13, 0, 0, 441, 442, 5, 37, 0, 0, 442, 445, 8, 13, 0, 0, 443, 445, 3, 34, 15, 0, 444, 438, 1, 0, 0, 0, 444, 439, 1, 0, 0, 0, 444, 441, 1, 0, 0, 0, 444, 443, 1, 0, 0, 0, 445, 119, 1, 0, 0, 0, 35, 0, 1, 2, 3, 123, 125, 137, 139, 164, 169, 171, 177, 187, 198, 203, 207, 219, 225, 245, 252, 258, 262, 267, 273, 275, 279, 284, 295, 310, 383, 395, 410, 412, 434, 444, 16, 1, 4, 0, 1, 5, 1, 0, 1, 0, 5, 1, 0, 5, 2, 0, 1, 48, 2, 5, 0, 0, 7, 15, 0, 4, 0, 0, 7, 12, 0, 2, 3, 0, 1, 53, 3, 7, 8, 0, 1, 55, 4, 7, 43, 0, 1, 56, 5]\n\\ No newline at end of file\n+[4, 0, 47, 450, 6, -1, 6, -1, 6, -1, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 5, 0, 126, 8, 0, 10, 0, 12, 0, 129, 9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 142, 8, 1, 10, 1, 12, 1, 145, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 3, 7, 169, 8, 7, 1, 8, 1, 8, 1, 8, 5, 8, 174, 8, 8, 10, 8, 12, 8, 177, 9, 8, 1, 9, 4, 9, 180, 8, 9, 11, 9, 12, 9, 181, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 190, 8, 10, 10, 10, 12, 10, 193, 9, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 3, 11, 203, 8, 11, 1, 11, 5, 11, 206, 8, 11, 10, 11, 12, 11, 209, 9, 11, 1, 11, 3, 11, 212, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 3, 13, 224, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 230, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 250, 8, 15, 1, 16, 1, 16, 1, 17, 4, 17, 255, 8, 17, 11, 17, 12, 17, 256, 1, 17, 1, 17, 5, 17, 261, 8, 17, 10, 17, 12, 17, 264, 9, 17, 1, 17, 3, 17, 267, 8, 17, 1, 17, 4, 17, 270, 8, 17, 11, 17, 12, 17, 271, 1, 17, 1, 17, 4, 17, 276, 8, 17, 11, 17, 12, 17, 277, 3, 17, 280, 8, 17, 1, 18, 1, 18, 3, 18, 284, 8, 18, 1, 18, 4, 18, 287, 8, 18, 11, 18, 12, 18, 288, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 300, 8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 315, 8, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 35, 1, 35, 1, 36, 1, 36, 1, 37, 1, 37, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 4, 49, 386, 8, 49, 11, 49, 12, 49, 387, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 400, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 5, 53, 415, 8, 53, 10, 53, 12, 53, 418, 9, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 4, 56, 437, 8, 56, 11, 56, 12, 56, 438, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 449, 8, 57, 1, 191, 0, 58, 4, 1, 6, 2, 8, 3, 10, 4, 12, 5, 14, 6, 16, 7, 18, 0, 20, 8, 22, 9, 24, 10, 26, 11, 28, 12, 30, 0, 32, 0, 34, 0, 36, 0, 38, 13, 40, 0, 42, 14, 44, 15, 46, 16, 48, 17, 50, 18, 52, 19, 54, 20, 56, 21, 58, 22, 60, 23, 62, 24, 64, 25, 66, 26, 68, 27, 70, 28, 72, 29, 74, 30, 76, 31, 78, 32, 80, 33, 82, 34, 84, 35, 86, 36, 88, 37, 90, 38, 92, 39, 94, 40, 96, 41, 98, 42, 100, 43, 102, 44, 104, 45, 106, 0, 108, 0, 110, 0, 112, 0, 114, 0, 116, 46, 118, 47, 4, 0, 1, 2, 3, 14, 4, 0, 10, 10, 13, 13, 34, 34, 36, 37, 3, 0, 9, 9, 12, 13, 32, 32, 2, 0, 10, 10, 13, 13, 1, 0, 48, 57, 4, 0, 36, 36, 65, 90, 95, 95, 97, 122, 2, 0, 0, 127, 55296, 56319, 1, 0, 55296, 56319, 1, 0, 56320, 57343, 5, 0, 34, 34, 92, 92, 110, 110, 114, 114, 116, 116, 3, 0, 48, 57, 65, 70, 97, 102, 2, 0, 69, 69, 101, 101, 2, 0, 43, 43, 45, 45, 3, 0, 10, 10, 13, 13, 36, 37, 1, 0, 123, 123, 484, 0, 4, 1, 0, 0, 0, 0, 6, 1, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 10, 1, 0, 0, 0, 0, 12, 1, 0, 0, 0, 0, 14, 1, 0, 0, 0, 0, 16, 1, 0, 0, 0, 0, 20, 1, 0, 0, 0, 0, 22, 1, 0, 0, 0, 0, 24, 1, 0, 0, 0, 0, 26, 1, 0, 0, 0, 0, 28, 1, 0, 0, 0, 0, 38, 1, 0, 0, 0, 0, 42, 1, 0, 0, 0, 0, 44, 1, 0, 0, 0, 0, 46, 1, 0, 0, 0, 0, 48, 1, 0, 0, 0, 0, 50, 1, 0, 0, 0, 0, 52, 1, 0, 0, 0, 0, 54, 1, 0, 0, 0, 0, 56, 1, 0, 0, 0, 0, 58, 1, 0, 0, 0, 0, 60, 1, 0, 0, 0, 0, 62, 1, 0, 0, 0, 0, 64, 1, 0, 0, 0, 0, 66, 1, 0, 0, 0, 0, 68, 1, 0, 0, 0, 0, 70, 1, 0, 0, 0, 0, 72, 1, 0, 0, 0, 0, 74, 1, 0, 0, 0, 0, 76, 1, 0, 0, 0, 0, 78, 1, 0, 0, 0, 0, 80, 1, 0, 0, 0, 0, 82, 1, 0, 0, 0, 0, 84, 1, 0, 0, 0, 0, 86, 1, 0, 0, 0, 0, 88, 1, 0, 0, 0, 0, 90, 1, 0, 0, 0, 0, 92, 1, 0, 0, 0, 0, 94, 1, 0, 0, 0, 0, 96, 1, 0, 0, 0, 0, 98, 1, 0, 0, 0, 1, 100, 1, 0, 0, 0, 1, 102, 1, 0, 0, 0, 1, 104, 1, 0, 0, 0, 1, 106, 1, 0, 0, 0, 2, 108, 1, 0, 0, 0, 2, 110, 1, 0, 0, 0, 3, 112, 1, 0, 0, 0, 3, 114, 1, 0, 0, 0, 3, 116, 1, 0, 0, 0, 3, 118, 1, 0, 0, 0, 4, 120, 1, 0, 0, 0, 6, 136, 1, 0, 0, 0, 8, 152, 1, 0, 0, 0, 10, 155, 1, 0, 0, 0, 12, 158, 1, 0, 0, 0, 14, 161, 1, 0, 0, 0, 16, 164, 1, 0, 0, 0, 18, 168, 1, 0, 0, 0, 20, 170, 1, 0, 0, 0, 22, 179, 1, 0, 0, 0, 24, 185, 1, 0, 0, 0, 26, 202, 1, 0, 0, 0, 28, 217, 1, 0, 0, 0, 30, 223, 1, 0, 0, 0, 32, 229, 1, 0, 0, 0, 34, 249, 1, 0, 0, 0, 36, 251, 1, 0, 0, 0, 38, 279, 1, 0, 0, 0, 40, 281, 1, 0, 0, 0, 42, 299, 1, 0, 0, 0, 44, 301, 1, 0, 0, 0, 46, 305, 1, 0, 0, 0, 48, 310, 1, 0, 0, 0, 50, 318, 1, 0, 0, 0, 52, 320, 1, 0, 0, 0, 54, 323, 1, 0, 0, 0, 56, 326, 1, 0, 0, 0, 58, 328, 1, 0, 0, 0, 60, 330, 1, 0, 0, 0, 62, 332, 1, 0, 0, 0, 64, 334, 1, 0, 0, 0, 66, 336, 1, 0, 0, 0, 68, 339, 1, 0, 0, 0, 70, 342, 1, 0, 0, 0, 72, 344, 1, 0, 0, 0, 74, 346, 1, 0, 0, 0, 76, 348, 1, 0, 0, 0, 78, 350, 1, 0, 0, 0, 80, 352, 1, 0, 0, 0, 82, 354, 1, 0, 0, 0, 84, 357, 1, 0, 0, 0, 86, 359, 1, 0, 0, 0, 88, 361, 1, 0, 0, 0, 90, 364, 1, 0, 0, 0, 92, 367, 1, 0, 0, 0, 94, 369, 1, 0, 0, 0, 96, 371, 1, 0, 0, 0, 98, 375, 1, 0, 0, 0, 100, 377, 1, 0, 0, 0, 102, 385, 1, 0, 0, 0, 104, 399, 1, 0, 0, 0, 106, 401, 1, 0, 0, 0, 108, 406, 1, 0, 0, 0, 110, 411, 1, 0, 0, 0, 112, 423, 1, 0, 0, 0, 114, 427, 1, 0, 0, 0, 116, 436, 1, 0, 0, 0, 118, 448, 1, 0, 0, 0, 120, 127, 5, 123, 0, 0, 121, 126, 3, 22, 9, 0, 122, 126, 3, 28, 12, 0, 123, 126, 3, 24, 10, 0, 124, 126, 3, 26, 11, 0, 125, 121, 1, 0, 0, 0, 125, 122, 1, 0, 0, 0, 125, 123, 1, 0, 0, 0, 125, 124, 1, 0, 0, 0, 126, 129, 1, 0, 0, 0, 127, 125, 1, 0, 0, 0, 127, 128, 1, 0, 0, 0, 128, 130, 1, 0, 0, 0, 129, 127, 1, 0, 0, 0, 130, 131, 5, 102, 0, 0, 131, 132, 5, 111, 0, 0, 132, 133, 5, 114, 0, 0, 133, 134, 1, 0, 0, 0, 134, 135, 3, 22, 9, 0, 135, 5, 1, 0, 0, 0, 136, 143, 5, 91, 0, 0, 137, 142, 3, 22, 9, 0, 138, 142, 3, 28, 12, 0, 139, 142, 3, 24, 10, 0, 140, 142, 3, 26, 11, 0, 141, 137, 1, 0, 0, 0, 141, 138, 1, 0, 0, 0, 141, 139, 1, 0, 0, 0, 141, 140, 1, 0, 0, 0, 142, 145, 1, 0, 0, 0, 143, 141, 1, 0, 0, 0, 143, 144, 1, 0, 0, 0, 144, 146, 1, 0, 0, 0, 145, 143, 1, 0, 0, 0, 146, 147, 5, 102, 0, 0, 147, 148, 5, 111, 0, 0, 148, 149, 5, 114, 0, 0, 149, 150, 1, 0, 0, 0, 150, 151, 3, 22, 9, 0, 151, 7, 1, 0, 0, 0, 152, 153, 5, 105, 0, 0, 153, 154, 5, 102, 0, 0, 154, 9, 1, 0, 0, 0, 155, 156, 5, 105, 0, 0, 156, 157, 5, 110, 0, 0, 157, 11, 1, 0, 0, 0, 158, 159, 5, 123, 0, 0, 159, 160, 6, 4, 0, 0, 160, 13, 1, 0, 0, 0, 161, 162, 5, 125, 0, 0, 162, 163, 6, 5, 1, 0, 163, 15, 1, 0, 0, 0, 164, 165, 5, 61, 0, 0, 165, 17, 1, 0, 0, 0, 166, 169, 8, 0, 0, 0, 167, 169, 3, 34, 15, 0, 168, 166, 1, 0, 0, 0, 168, 167, 1, 0, 0, 0, 169, 19, 1, 0, 0, 0, 170, 175, 3, 32, 14, 0, 171, 174, 3, 30, 13, 0, 172, 174, 5, 45, 0, 0, 173, 171, 1, 0, 0, 0, 173, 172, 1, 0, 0, 0, 174, 177, 1, 0, 0, 0, 175, 173, 1, 0, 0, 0, 175, 176, 1, 0, 0, 0, 176, 21, 1, 0, 0, 0, 177, 175, 1, 0, 0, 0, 178, 180, 7, 1, 0, 0, 179, 178, 1, 0, 0, 0, 180, 181, 1, 0, 0, 0, 181, 179, 1, 0, 0, 0, 181, 182, 1, 0, 0, 0, 182, 183, 1, 0, 0, 0, 183, 184, 6, 9, 2, 0, 184, 23, 1, 0, 0, 0, 185, 186, 5, 47, 0, 0, 186, 187, 5, 42, 0, 0, 187, 191, 1, 0, 0, 0, 188, 190, 9, 0, 0, 0, 189, 188, 1, 0, 0, 0, 190, 193, 1, 0, 0, 0, 191, 192, 1, 0, 0, 0, 191, 189, 1, 0, 0, 0, 192, 194, 1, 0, 0, 0, 193, 191, 1, 0, 0, 0, 194, 195, 5, 42, 0, 0, 195, 196, 5, 47, 0, 0, 196, 197, 1, 0, 0, 0, 197, 198, 6, 10, 2, 0, 198, 25, 1, 0, 0, 0, 199, 200, 5, 47, 0, 0, 200, 203, 5, 47, 0, 0, 201, 203, 5, 35, 0, 0, 202, 199, 1, 0, 0, 0, 202, 201, 1, 0, 0, 0, 203, 207, 1, 0, 0, 0, 204, 206, 8, 2, 0, 0, 205, 204, 1, 0, 0, 0, 206, 209, 1, 0, 0, 0, 207, 205, 1, 0, 0, 0, 207, 208, 1, 0, 0, 0, 208, 211, 1, 0, 0, 0, 209, 207, 1, 0, 0, 0, 210, 212, 5, 13, 0, 0, 211, 210, 1, 0, 0, 0, 211, 212, 1, 0, 0, 0, 212, 213, 1, 0, 0, 0, 213, 214, 5, 10, 0, 0, 214, 215, 1, 0, 0, 0, 215, 216, 6, 11, 2, 0, 216, 27, 1, 0, 0, 0, 217, 218, 5, 10, 0, 0, 218, 219, 1, 0, 0, 0, 219, 220, 6, 12, 2, 0, 220, 29, 1, 0, 0, 0, 221, 224, 3, 32, 14, 0, 222, 224, 7, 3, 0, 0, 223, 221, 1, 0, 0, 0, 223, 222, 1, 0, 0, 0, 224, 31, 1, 0, 0, 0, 225, 230, 7, 4, 0, 0, 226, 230, 8, 5, 0, 0, 227, 228, 7, 6, 0, 0, 228, 230, 7, 7, 0, 0, 229, 225, 1, 0, 0, 0, 229, 226, 1, 0, 0, 0, 229, 227, 1, 0, 0, 0, 230, 33, 1, 0, 0, 0, 231, 232, 5, 92, 0, 0, 232, 250, 7, 8, 0, 0, 233, 234, 5, 92, 0, 0, 234, 235, 3, 36, 16, 0, 235, 236, 3, 36, 16, 0, 236, 237, 3, 36, 16, 0, 237, 238, 3, 36, 16, 0, 238, 250, 1, 0, 0, 0, 239, 240, 5, 92, 0, 0, 240, 241, 3, 36, 16, 0, 241, 242, 3, 36, 16, 0, 242, 243, 3, 36, 16, 0, 243, 244, 3, 36, 16, 0, 244, 245, 3, 36, 16, 0, 245, 246, 3, 36, 16, 0, 246, 247, 3, 36, 16, 0, 247, 248, 3, 36, 16, 0, 248, 250, 1, 0, 0, 0, 249, 231, 1, 0, 0, 0, 249, 233, 1, 0, 0, 0, 249, 239, 1, 0, 0, 0, 250, 35, 1, 0, 0, 0, 251, 252, 7, 9, 0, 0, 252, 37, 1, 0, 0, 0, 253, 255, 7, 3, 0, 0, 254, 253, 1, 0, 0, 0, 255, 256, 1, 0, 0, 0, 256, 254, 1, 0, 0, 0, 256, 257, 1, 0, 0, 0, 257, 258, 1, 0, 0, 0, 258, 262, 5, 46, 0, 0, 259, 261, 7, 3, 0, 0, 260, 259, 1, 0, 0, 0, 261, 264, 1, 0, 0, 0, 262, 260, 1, 0, 0, 0, 262, 263, 1, 0, 0, 0, 263, 266, 1, 0, 0, 0, 264, 262, 1, 0, 0, 0, 265, 267, 3, 40, 18, 0, 266, 265, 1, 0, 0, 0, 266, 267, 1, 0, 0, 0, 267, 280, 1, 0, 0, 0, 268, 270, 7, 3, 0, 0, 269, 268, 1, 0, 0, 0, 270, 271, 1, 0, 0, 0, 271, 269, 1, 0, 0, 0, 271, 272, 1, 0, 0, 0, 272, 273, 1, 0, 0, 0, 273, 280, 3, 40, 18, 0, 274, 276, 7, 3, 0, 0, 275, 274, 1, 0, 0, 0, 276, 277, 1, 0, 0, 0, 277, 275, 1, 0, 0, 0, 277, 278, 1, 0, 0, 0, 278, 280, 1, 0, 0, 0, 279, 254, 1, 0, 0, 0, 279, 269, 1, 0, 0, 0, 279, 275, 1, 0, 0, 0, 280, 39, 1, 0, 0, 0, 281, 283, 7, 10, 0, 0, 282, 284, 7, 11, 0, 0, 283, 282, 1, 0, 0, 0, 283, 284, 1, 0, 0, 0, 284, 286, 1, 0, 0, 0, 285, 287, 7, 3, 0, 0, 286, 285, 1, 0, 0, 0, 287, 288, 1, 0, 0, 0, 288, 286, 1, 0, 0, 0, 288, 289, 1, 0, 0, 0, 289, 41, 1, 0, 0, 0, 290, 291, 5, 116, 0, 0, 291, 292, 5, 114, 0, 0, 292, 293, 5, 117, 0, 0, 293, 300, 5, 101, 0, 0, 294, 295, 5, 102, 0, 0, 295, 296, 5, 97, 0, 0, 296, 297, 5, 108, 0, 0, 297, 298, 5, 115, 0, 0, 298, 300, 5, 101, 0, 0, 299, 290, 1, 0, 0, 0, 299, 294, 1, 0, 0, 0, 300, 43, 1, 0, 0, 0, 301, 302, 5, 34, 0, 0, 302, 303, 1, 0, 0, 0, 303, 304, 6, 20, 3, 0, 304, 45, 1, 0, 0, 0, 305, 306, 5, 110, 0, 0, 306, 307, 5, 117, 0, 0, 307, 308, 5, 108, 0, 0, 308, 309, 5, 108, 0, 0, 309, 47, 1, 0, 0, 0, 310, 311, 5, 60, 0, 0, 311, 312, 5, 60, 0, 0, 312, 314, 1, 0, 0, 0, 313, 315, 5, 45, 0, 0, 314, 313, 1, 0, 0, 0, 314, 315, 1, 0, 0, 0, 315, 316, 1, 0, 0, 0, 316, 317, 6, 22, 4, 0, 317, 49, 1, 0, 0, 0, 318, 319, 5, 43, 0, 0, 319, 51, 1, 0, 0, 0, 320, 321, 5, 38, 0, 0, 321, 322, 5, 38, 0, 0, 322, 53, 1, 0, 0, 0, 323, 324, 5, 61, 0, 0, 324, 325, 5, 61, 0, 0, 325, 55, 1, 0, 0, 0, 326, 327, 5, 60, 0, 0, 327, 57, 1, 0, 0, 0, 328, 329, 5, 58, 0, 0, 329, 59, 1, 0, 0, 0, 330, 331, 5, 91, 0, 0, 331, 61, 1, 0, 0, 0, 332, 333, 5, 40, 0, 0, 333, 63, 1, 0, 0, 0, 334, 335, 5, 45, 0, 0, 335, 65, 1, 0, 0, 0, 336, 337, 5, 124, 0, 0, 337, 338, 5, 124, 0, 0, 338, 67, 1, 0, 0, 0, 339, 340, 5, 33, 0, 0, 340, 341, 5, 61, 0, 0, 341, 69, 1, 0, 0, 0, 342, 343, 5, 62, 0, 0, 343, 71, 1, 0, 0, 0, 344, 345, 5, 63, 0, 0, 345, 73, 1, 0, 0, 0, 346, 347, 5, 93, 0, 0, 347, 75, 1, 0, 0, 0, 348, 349, 5, 41, 0, 0, 349, 77, 1, 0, 0, 0, 350, 351, 5, 42, 0, 0, 351, 79, 1, 0, 0, 0, 352, 353, 5, 33, 0, 0, 353, 81, 1, 0, 0, 0, 354, 355, 5, 60, 0, 0, 355, 356, 5, 61, 0, 0, 356, 83, 1, 0, 0, 0, 357, 358, 5, 46, 0, 0, 358, 85, 1, 0, 0, 0, 359, 360, 5, 47, 0, 0, 360, 87, 1, 0, 0, 0, 361, 362, 5, 62, 0, 0, 362, 363, 5, 61, 0, 0, 363, 89, 1, 0, 0, 0, 364, 365, 5, 61, 0, 0, 365, 366, 5, 62, 0, 0, 366, 91, 1, 0, 0, 0, 367, 368, 5, 44, 0, 0, 368, 93, 1, 0, 0, 0, 369, 370, 5, 37, 0, 0, 370, 95, 1, 0, 0, 0, 371, 372, 5, 46, 0, 0, 372, 373, 5, 46, 0, 0, 373, 374, 5, 46, 0, 0, 374, 97, 1, 0, 0, 0, 375, 376, 5, 126, 0, 0, 376, 99, 1, 0, 0, 0, 377, 378, 5, 36, 0, 0, 378, 379, 5, 123, 0, 0, 379, 380, 1, 0, 0, 0, 380, 381, 6, 48, 5, 0, 381, 382, 1, 0, 0, 0, 382, 383, 6, 48, 6, 0, 383, 101, 1, 0, 0, 0, 384, 386, 3, 104, 50, 0, 385, 384, 1, 0, 0, 0, 386, 387, 1, 0, 0, 0, 387, 385, 1, 0, 0, 0, 387, 388, 1, 0, 0, 0, 388, 103, 1, 0, 0, 0, 389, 400, 8, 0, 0, 0, 390, 391, 5, 36, 0, 0, 391, 400, 5, 36, 0, 0, 392, 393, 5, 36, 0, 0, 393, 400, 4, 50, 0, 0, 394, 395, 5, 37, 0, 0, 395, 400, 5, 37, 0, 0, 396, 397, 5, 37, 0, 0, 397, 400, 4, 50, 1, 0, 398, 400, 3, 34, 15, 0, 399, 389, 1, 0, 0, 0, 399, 390, 1, 0, 0, 0, 399, 392, 1, 0, 0, 0, 399, 394, 1, 0, 0, 0, 399, 396, 1, 0, 0, 0, 399, 398, 1, 0, 0, 0, 400, 105, 1, 0, 0, 0, 401, 402, 5, 34, 0, 0, 402, 403, 1, 0, 0, 0, 403, 404, 6, 51, 7, 0, 404, 405, 6, 51, 8, 0, 405, 107, 1, 0, 0, 0, 406, 407, 5, 10, 0, 0, 407, 408, 1, 0, 0, 0, 408, 409, 6, 52, 9, 0, 409, 410, 6, 52, 10, 0, 410, 109, 1, 0, 0, 0, 411, 416, 3, 32, 14, 0, 412, 415, 3, 30, 13, 0, 413, 415, 5, 45, 0, 0, 414, 412, 1, 0, 0, 0, 414, 413, 1, 0, 0, 0, 415, 418, 1, 0, 0, 0, 416, 414, 1, 0, 0, 0, 416, 417, 1, 0, 0, 0, 417, 419, 1, 0, 0, 0, 418, 416, 1, 0, 0, 0, 419, 420, 6, 53, 11, 0, 420, 421, 1, 0, 0, 0, 421, 422, 6, 53, 12, 0, 422, 111, 1, 0, 0, 0, 423, 424, 5, 10, 0, 0, 424, 425, 1, 0, 0, 0, 425, 426, 6, 54, 9, 0, 426, 113, 1, 0, 0, 0, 427, 428, 5, 36, 0, 0, 428, 429, 5, 123, 0, 0, 429, 430, 1, 0, 0, 0, 430, 431, 6, 55, 13, 0, 431, 432, 1, 0, 0, 0, 432, 433, 6, 55, 14, 0, 433, 434, 6, 55, 6, 0, 434, 115, 1, 0, 0, 0, 435, 437, 3, 118, 57, 0, 436, 435, 1, 0, 0, 0, 437, 438, 1, 0, 0, 0, 438, 436, 1, 0, 0, 0, 438, 439, 1, 0, 0, 0, 439, 440, 1, 0, 0, 0, 440, 441, 6, 56, 15, 0, 441, 117, 1, 0, 0, 0, 442, 449, 8, 12, 0, 0, 443, 444, 5, 36, 0, 0, 444, 449, 8, 13, 0, 0, 445, 446, 5, 37, 0, 0, 446, 449, 8, 13, 0, 0, 447, 449, 3, 34, 15, 0, 448, 442, 1, 0, 0, 0, 448, 443, 1, 0, 0, 0, 448, 445, 1, 0, 0, 0, 448, 447, 1, 0, 0, 0, 449, 119, 1, 0, 0, 0, 35, 0, 1, 2, 3, 125, 127, 141, 143, 168, 173, 175, 181, 191, 202, 207, 211, 223, 229, 249, 256, 262, 266, 271, 277, 279, 283, 288, 299, 314, 387, 399, 414, 416, 438, 448, 16, 1, 4, 0, 1, 5, 1, 0, 1, 0, 5, 1, 0, 5, 2, 0, 1, 48, 2, 5, 0, 0, 7, 15, 0, 4, 0, 0, 7, 12, 0, 2, 3, 0, 1, 53, 3, 7, 8, 0, 1, 55, 4, 7, 43, 0, 1, 56, 5]\n\\ No newline at end of file\n\ndiff --git a/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.java b/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.java\nindex 1a843f9b242..e952ee91f0a 100644\n--- a/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.java\n+++ b/rewrite-hcl/src/main/java/org/openrewrite/hcl/internal/grammar/HCLLexer.java\n@@ -257,7 +257,7 @@ private boolean TemplateStringLiteralChar_sempred(RuleContext _localctx, int pre\n \t}\n \n \tpublic static final String _serializedATN =\n-\t\t\"\\u0004\\u0000/\\u01be\\u0006\\uffff\\uffff\\u0006\\uffff\\uffff\\u0006\\uffff\\uffff\"+\n+\t\t\"\\u0004\\u0000/\\u01c2\\u0006\\uffff\\uffff\\u0006\\uffff\\uffff\\u0006\\uffff\\uffff\"+\n \t\t\"\\u0006\\uffff\\uffff\\u0002\\u0000\\u0007\\u0000\\u0002\\u0001\\u0007\\u0001\\u0002\"+\n \t\t\"\\u0002\\u0007\\u0002\\u0002\\u0003\\u0007\\u0003\\u0002\\u0004\\u0007\\u0004\\u0002\"+\n \t\t\"\\u0005\\u0007\\u0005\\u0002\\u0006\\u0007\\u0006\\u0002\\u0007\\u0007\\u0007\\u0002\"+\n@@ -274,284 +274,288 @@ private boolean TemplateStringLiteralChar_sempred(RuleContext _localctx, int pre\n \t\t\"-\\u0007-\\u0002.\\u0007.\\u0002/\\u0007/\\u00020\\u00070\\u00021\\u00071\\u0002\"+\n \t\t\"2\\u00072\\u00023\\u00073\\u00024\\u00074\\u00025\\u00075\\u00026\\u00076\\u0002\"+\n \t\t\"7\\u00077\\u00028\\u00078\\u00029\\u00079\\u0001\\u0000\\u0001\\u0000\\u0001\\u0000\"+\n-\t\t\"\\u0005\\u0000|\\b\\u0000\\n\\u0000\\f\\u0000\\u007f\\t\\u0000\\u0001\\u0000\\u0001\"+\n-\t\t\"\\u0000\\u0001\\u0000\\u0001\\u0000\\u0001\\u0000\\u0001\\u0000\\u0001\\u0001\\u0001\"+\n-\t\t\"\\u0001\\u0001\\u0001\\u0005\\u0001\\u008a\\b\\u0001\\n\\u0001\\f\\u0001\\u008d\\t\\u0001\"+\n-\t\t\"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\"+\n-\t\t\"\\u0001\\u0002\\u0001\\u0002\\u0001\\u0002\\u0001\\u0003\\u0001\\u0003\\u0001\\u0003\"+\n-\t\t\"\\u0001\\u0004\\u0001\\u0004\\u0001\\u0004\\u0001\\u0005\\u0001\\u0005\\u0001\\u0005\"+\n-\t\t\"\\u0001\\u0006\\u0001\\u0006\\u0001\\u0007\\u0001\\u0007\\u0003\\u0007\\u00a5\\b\\u0007\"+\n-\t\t\"\\u0001\\b\\u0001\\b\\u0001\\b\\u0005\\b\\u00aa\\b\\b\\n\\b\\f\\b\\u00ad\\t\\b\\u0001\\t\\u0004\"+\n-\t\t\"\\t\\u00b0\\b\\t\\u000b\\t\\f\\t\\u00b1\\u0001\\t\\u0001\\t\\u0001\\n\\u0001\\n\\u0001\\n\"+\n-\t\t\"\\u0001\\n\\u0005\\n\\u00ba\\b\\n\\n\\n\\f\\n\\u00bd\\t\\n\\u0001\\n\\u0001\\n\\u0001\\n\\u0001\"+\n-\t\t\"\\n\\u0001\\n\\u0001\\u000b\\u0001\\u000b\\u0001\\u000b\\u0003\\u000b\\u00c7\\b\\u000b\"+\n-\t\t\"\\u0001\\u000b\\u0005\\u000b\\u00ca\\b\\u000b\\n\\u000b\\f\\u000b\\u00cd\\t\\u000b\\u0001\"+\n-\t\t\"\\u000b\\u0003\\u000b\\u00d0\\b\\u000b\\u0001\\u000b\\u0001\\u000b\\u0001\\u000b\\u0001\"+\n-\t\t\"\\u000b\\u0001\\f\\u0001\\f\\u0001\\f\\u0001\\f\\u0001\\r\\u0001\\r\\u0003\\r\\u00dc\\b\"+\n-\t\t\"\\r\\u0001\\u000e\\u0001\\u000e\\u0001\\u000e\\u0001\\u000e\\u0003\\u000e\\u00e2\\b\"+\n-\t\t\"\\u000e\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\"+\n+\t\t\"\\u0001\\u0000\\u0001\\u0000\\u0005\\u0000~\\b\\u0000\\n\\u0000\\f\\u0000\\u0081\\t\"+\n+\t\t\"\\u0000\\u0001\\u0000\\u0001\\u0000\\u0001\\u0000\\u0001\\u0000\\u0001\\u0000\\u0001\"+\n+\t\t\"\\u0000\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0005\"+\n+\t\t\"\\u0001\\u008e\\b\\u0001\\n\\u0001\\f\\u0001\\u0091\\t\\u0001\\u0001\\u0001\\u0001\\u0001\"+\n+\t\t\"\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0001\\u0002\\u0001\\u0002\"+\n+\t\t\"\\u0001\\u0002\\u0001\\u0003\\u0001\\u0003\\u0001\\u0003\\u0001\\u0004\\u0001\\u0004\"+\n+\t\t\"\\u0001\\u0004\\u0001\\u0005\\u0001\\u0005\\u0001\\u0005\\u0001\\u0006\\u0001\\u0006\"+\n+\t\t\"\\u0001\\u0007\\u0001\\u0007\\u0003\\u0007\\u00a9\\b\\u0007\\u0001\\b\\u0001\\b\\u0001\"+\n+\t\t\"\\b\\u0005\\b\\u00ae\\b\\b\\n\\b\\f\\b\\u00b1\\t\\b\\u0001\\t\\u0004\\t\\u00b4\\b\\t\\u000b\"+\n+\t\t\"\\t\\f\\t\\u00b5\\u0001\\t\\u0001\\t\\u0001\\n\\u0001\\n\\u0001\\n\\u0001\\n\\u0005\\n\\u00be\"+\n+\t\t\"\\b\\n\\n\\n\\f\\n\\u00c1\\t\\n\\u0001\\n\\u0001\\n\\u0001\\n\\u0001\\n\\u0001\\n\\u0001\\u000b\"+\n+\t\t\"\\u0001\\u000b\\u0001\\u000b\\u0003\\u000b\\u00cb\\b\\u000b\\u0001\\u000b\\u0005\\u000b\"+\n+\t\t\"\\u00ce\\b\\u000b\\n\\u000b\\f\\u000b\\u00d1\\t\\u000b\\u0001\\u000b\\u0003\\u000b\\u00d4\"+\n+\t\t\"\\b\\u000b\\u0001\\u000b\\u0001\\u000b\\u0001\\u000b\\u0001\\u000b\\u0001\\f\\u0001\"+\n+\t\t\"\\f\\u0001\\f\\u0001\\f\\u0001\\r\\u0001\\r\\u0003\\r\\u00e0\\b\\r\\u0001\\u000e\\u0001\"+\n+\t\t\"\\u000e\\u0001\\u000e\\u0001\\u000e\\u0003\\u000e\\u00e6\\b\\u000e\\u0001\\u000f\\u0001\"+\n \t\t\"\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\"+\n \t\t\"\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\"+\n-\t\t\"\\u000f\\u0003\\u000f\\u00f6\\b\\u000f\\u0001\\u0010\\u0001\\u0010\\u0001\\u0011\\u0004\"+\n-\t\t\"\\u0011\\u00fb\\b\\u0011\\u000b\\u0011\\f\\u0011\\u00fc\\u0001\\u0011\\u0001\\u0011\"+\n-\t\t\"\\u0005\\u0011\\u0101\\b\\u0011\\n\\u0011\\f\\u0011\\u0104\\t\\u0011\\u0001\\u0011\\u0003\"+\n-\t\t\"\\u0011\\u0107\\b\\u0011\\u0001\\u0011\\u0004\\u0011\\u010a\\b\\u0011\\u000b\\u0011\"+\n-\t\t\"\\f\\u0011\\u010b\\u0001\\u0011\\u0001\\u0011\\u0004\\u0011\\u0110\\b\\u0011\\u000b\"+\n-\t\t\"\\u0011\\f\\u0011\\u0111\\u0003\\u0011\\u0114\\b\\u0011\\u0001\\u0012\\u0001\\u0012\"+\n-\t\t\"\\u0003\\u0012\\u0118\\b\\u0012\\u0001\\u0012\\u0004\\u0012\\u011b\\b\\u0012\\u000b\"+\n-\t\t\"\\u0012\\f\\u0012\\u011c\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0001\"+\n-\t\t\"\\u0013\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0003\\u0013\\u0128\"+\n-\t\t\"\\b\\u0013\\u0001\\u0014\\u0001\\u0014\\u0001\\u0014\\u0001\\u0014\\u0001\\u0015\\u0001\"+\n-\t\t\"\\u0015\\u0001\\u0015\\u0001\\u0015\\u0001\\u0015\\u0001\\u0016\\u0001\\u0016\\u0001\"+\n-\t\t\"\\u0016\\u0001\\u0016\\u0003\\u0016\\u0137\\b\\u0016\\u0001\\u0016\\u0001\\u0016\\u0001\"+\n-\t\t\"\\u0017\\u0001\\u0017\\u0001\\u0018\\u0001\\u0018\\u0001\\u0018\\u0001\\u0019\\u0001\"+\n-\t\t\"\\u0019\\u0001\\u0019\\u0001\\u001a\\u0001\\u001a\\u0001\\u001b\\u0001\\u001b\\u0001\"+\n-\t\t\"\\u001c\\u0001\\u001c\\u0001\\u001d\\u0001\\u001d\\u0001\\u001e\\u0001\\u001e\\u0001\"+\n-\t\t\"\\u001f\\u0001\\u001f\\u0001\\u001f\\u0001 \\u0001 \\u0001 \\u0001!\\u0001!\\u0001\"+\n-\t\t\"\\\"\\u0001\\\"\\u0001#\\u0001#\\u0001$\\u0001$\\u0001%\\u0001%\\u0001&\\u0001&\\u0001\"+\n-\t\t\"\\'\\u0001\\'\\u0001\\'\\u0001(\\u0001(\\u0001)\\u0001)\\u0001*\\u0001*\\u0001*\\u0001\"+\n-\t\t\"+\\u0001+\\u0001+\\u0001,\\u0001,\\u0001-\\u0001-\\u0001.\\u0001.\\u0001.\\u0001\"+\n-\t\t\".\\u0001/\\u0001/\\u00010\\u00010\\u00010\\u00010\\u00010\\u00010\\u00010\\u0001\"+\n-\t\t\"1\\u00041\\u017e\\b1\\u000b1\\f1\\u017f\\u00012\\u00012\\u00012\\u00012\\u00012\\u0001\"+\n-\t\t\"2\\u00012\\u00012\\u00012\\u00012\\u00032\\u018c\\b2\\u00013\\u00013\\u00013\\u0001\"+\n-\t\t\"3\\u00013\\u00014\\u00014\\u00014\\u00014\\u00014\\u00015\\u00015\\u00015\\u0005\"+\n-\t\t\"5\\u019b\\b5\\n5\\f5\\u019e\\t5\\u00015\\u00015\\u00015\\u00015\\u00016\\u00016\\u0001\"+\n-\t\t\"6\\u00016\\u00017\\u00017\\u00017\\u00017\\u00017\\u00017\\u00017\\u00017\\u0001\"+\n-\t\t\"8\\u00048\\u01b1\\b8\\u000b8\\f8\\u01b2\\u00018\\u00018\\u00019\\u00019\\u00019\\u0001\"+\n-\t\t\"9\\u00019\\u00019\\u00039\\u01bd\\b9\\u0001\\u00bb\\u0000:\\u0004\\u0001\\u0006\\u0002\"+\n-\t\t\"\\b\\u0003\\n\\u0004\\f\\u0005\\u000e\\u0006\\u0010\\u0007\\u0012\\u0000\\u0014\\b\\u0016\"+\n-\t\t\"\\t\\u0018\\n\\u001a\\u000b\\u001c\\f\\u001e\\u0000 \\u0000\\\"\\u0000$\\u0000&\\r(\\u0000\"+\n-\t\t\"*\\u000e,\\u000f.\\u00100\\u00112\\u00124\\u00136\\u00148\\u0015:\\u0016<\\u0017\"+\n-\t\t\">\\u0018@\\u0019B\\u001aD\\u001bF\\u001cH\\u001dJ\\u001eL\\u001fN P!R\\\"T#V$X%\"+\n-\t\t\"Z&\\\\\\'^(`)b*d+f,h-j\\u0000l\\u0000n\\u0000p\\u0000r\\u0000t.v/\\u0004\\u0000\"+\n-\t\t\"\\u0001\\u0002\\u0003\\u000e\\u0004\\u0000\\n\\n\\r\\r\\\"\\\"$%\\u0003\\u0000\\t\\t\\f\\r\"+\n-\t\t\"  \\u0002\\u0000\\n\\n\\r\\r\\u0001\\u000009\\u0004\\u0000$$AZ__az\\u0002\\u0000\\u0000\"+\n-\t\t\"\\u007f\\u8000\\ud800\\u8000\\udbff\\u0001\\u0000\\u8000\\ud800\\u8000\\udbff\\u0001\"+\n-\t\t\"\\u0000\\u8000\\udc00\\u8000\\udfff\\u0005\\u0000\\\"\\\"\\\\\\\\nnrrtt\\u0003\\u00000\"+\n-\t\t\"9AFaf\\u0002\\u0000EEee\\u0002\\u0000++--\\u0003\\u0000\\n\\n\\r\\r$%\\u0001\\u0000\"+\n-\t\t\"{{\\u01dc\\u0000\\u0004\\u0001\\u0000\\u0000\\u0000\\u0000\\u0006\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0000\\b\\u0001\\u0000\\u0000\\u0000\\u0000\\n\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0000\\f\\u0001\\u0000\\u0000\\u0000\\u0000\\u000e\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0010\\u0001\\u0000\\u0000\\u0000\\u0000\\u0014\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0016\\u0001\\u0000\\u0000\\u0000\\u0000\\u0018\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u001a\\u0001\\u0000\\u0000\\u0000\\u0000\\u001c\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n-\t\t\"&\\u0001\\u0000\\u0000\\u0000\\u0000*\\u0001\\u0000\\u0000\\u0000\\u0000,\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0000.\\u0001\\u0000\\u0000\\u0000\\u00000\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u00002\\u0001\\u0000\\u0000\\u0000\\u00004\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n-\t\t\"6\\u0001\\u0000\\u0000\\u0000\\u00008\\u0001\\u0000\\u0000\\u0000\\u0000:\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0000<\\u0001\\u0000\\u0000\\u0000\\u0000>\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0000@\\u0001\\u0000\\u0000\\u0000\\u0000B\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n-\t\t\"D\\u0001\\u0000\\u0000\\u0000\\u0000F\\u0001\\u0000\\u0000\\u0000\\u0000H\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0000J\\u0001\\u0000\\u0000\\u0000\\u0000L\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0000N\\u0001\\u0000\\u0000\\u0000\\u0000P\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n-\t\t\"R\\u0001\\u0000\\u0000\\u0000\\u0000T\\u0001\\u0000\\u0000\\u0000\\u0000V\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0000X\\u0001\\u0000\\u0000\\u0000\\u0000Z\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0000\\\\\\u0001\\u0000\\u0000\\u0000\\u0000^\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0000`\\u0001\\u0000\\u0000\\u0000\\u0000b\\u0001\\u0000\\u0000\\u0000\\u0001d\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0001f\\u0001\\u0000\\u0000\\u0000\\u0001h\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0001j\\u0001\\u0000\\u0000\\u0000\\u0002l\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0002n\\u0001\\u0000\\u0000\\u0000\\u0003p\\u0001\\u0000\\u0000\\u0000\\u0003r\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0003t\\u0001\\u0000\\u0000\\u0000\\u0003v\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0004x\\u0001\\u0000\\u0000\\u0000\\u0006\\u0086\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\b\\u0094\\u0001\\u0000\\u0000\\u0000\\n\\u0097\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\f\\u009a\\u0001\\u0000\\u0000\\u0000\\u000e\\u009d\\u0001\\u0000\\u0000\\u0000\\u0010\"+\n-\t\t\"\\u00a0\\u0001\\u0000\\u0000\\u0000\\u0012\\u00a4\\u0001\\u0000\\u0000\\u0000\\u0014\"+\n-\t\t\"\\u00a6\\u0001\\u0000\\u0000\\u0000\\u0016\\u00af\\u0001\\u0000\\u0000\\u0000\\u0018\"+\n-\t\t\"\\u00b5\\u0001\\u0000\\u0000\\u0000\\u001a\\u00c6\\u0001\\u0000\\u0000\\u0000\\u001c\"+\n-\t\t\"\\u00d5\\u0001\\u0000\\u0000\\u0000\\u001e\\u00db\\u0001\\u0000\\u0000\\u0000 \\u00e1\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\\"\\u00f5\\u0001\\u0000\\u0000\\u0000$\\u00f7\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000&\\u0113\\u0001\\u0000\\u0000\\u0000(\\u0115\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000*\\u0127\\u0001\\u0000\\u0000\\u0000,\\u0129\\u0001\\u0000\\u0000\\u0000.\"+\n-\t\t\"\\u012d\\u0001\\u0000\\u0000\\u00000\\u0132\\u0001\\u0000\\u0000\\u00002\\u013a\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u00004\\u013c\\u0001\\u0000\\u0000\\u00006\\u013f\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u00008\\u0142\\u0001\\u0000\\u0000\\u0000:\\u0144\\u0001\\u0000\\u0000\\u0000<\"+\n-\t\t\"\\u0146\\u0001\\u0000\\u0000\\u0000>\\u0148\\u0001\\u0000\\u0000\\u0000@\\u014a\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000B\\u014c\\u0001\\u0000\\u0000\\u0000D\\u014f\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000F\\u0152\\u0001\\u0000\\u0000\\u0000H\\u0154\\u0001\\u0000\\u0000\\u0000J\"+\n-\t\t\"\\u0156\\u0001\\u0000\\u0000\\u0000L\\u0158\\u0001\\u0000\\u0000\\u0000N\\u015a\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000P\\u015c\\u0001\\u0000\\u0000\\u0000R\\u015e\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000T\\u0161\\u0001\\u0000\\u0000\\u0000V\\u0163\\u0001\\u0000\\u0000\\u0000X\"+\n-\t\t\"\\u0165\\u0001\\u0000\\u0000\\u0000Z\\u0168\\u0001\\u0000\\u0000\\u0000\\\\\\u016b\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000^\\u016d\\u0001\\u0000\\u0000\\u0000`\\u016f\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000b\\u0173\\u0001\\u0000\\u0000\\u0000d\\u0175\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"f\\u017d\\u0001\\u0000\\u0000\\u0000h\\u018b\\u0001\\u0000\\u0000\\u0000j\\u018d\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000l\\u0192\\u0001\\u0000\\u0000\\u0000n\\u0197\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000p\\u01a3\\u0001\\u0000\\u0000\\u0000r\\u01a7\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"t\\u01b0\\u0001\\u0000\\u0000\\u0000v\\u01bc\\u0001\\u0000\\u0000\\u0000x}\\u0005\"+\n-\t\t\"{\\u0000\\u0000y|\\u0003\\u0016\\t\\u0000z|\\u0003\\u001c\\f\\u0000{y\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000{z\\u0001\\u0000\\u0000\\u0000|\\u007f\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"}{\\u0001\\u0000\\u0000\\u0000}~\\u0001\\u0000\\u0000\\u0000~\\u0080\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u007f}\\u0001\\u0000\\u0000\\u0000\\u0080\\u0081\\u0005f\\u0000\\u0000\"+\n-\t\t\"\\u0081\\u0082\\u0005o\\u0000\\u0000\\u0082\\u0083\\u0005r\\u0000\\u0000\\u0083\\u0084\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0084\\u0085\\u0003\\u0016\\t\\u0000\\u0085\\u0005\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0086\\u008b\\u0005[\\u0000\\u0000\\u0087\\u008a\\u0003\\u0016\"+\n-\t\t\"\\t\\u0000\\u0088\\u008a\\u0003\\u001c\\f\\u0000\\u0089\\u0087\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0089\\u0088\\u0001\\u0000\\u0000\\u0000\\u008a\\u008d\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u008b\\u0089\\u0001\\u0000\\u0000\\u0000\\u008b\\u008c\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u008c\\u008e\\u0001\\u0000\\u0000\\u0000\\u008d\\u008b\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u008e\\u008f\\u0005f\\u0000\\u0000\\u008f\\u0090\\u0005o\\u0000\\u0000\\u0090\"+\n-\t\t\"\\u0091\\u0005r\\u0000\\u0000\\u0091\\u0092\\u0001\\u0000\\u0000\\u0000\\u0092\\u0093\"+\n-\t\t\"\\u0003\\u0016\\t\\u0000\\u0093\\u0007\\u0001\\u0000\\u0000\\u0000\\u0094\\u0095\\u0005\"+\n-\t\t\"i\\u0000\\u0000\\u0095\\u0096\\u0005f\\u0000\\u0000\\u0096\\t\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0097\\u0098\\u0005i\\u0000\\u0000\\u0098\\u0099\\u0005n\\u0000\\u0000\\u0099\"+\n-\t\t\"\\u000b\\u0001\\u0000\\u0000\\u0000\\u009a\\u009b\\u0005{\\u0000\\u0000\\u009b\\u009c\"+\n-\t\t\"\\u0006\\u0004\\u0000\\u0000\\u009c\\r\\u0001\\u0000\\u0000\\u0000\\u009d\\u009e\\u0005\"+\n-\t\t\"}\\u0000\\u0000\\u009e\\u009f\\u0006\\u0005\\u0001\\u0000\\u009f\\u000f\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u00a0\\u00a1\\u0005=\\u0000\\u0000\\u00a1\\u0011\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u00a2\\u00a5\\b\\u0000\\u0000\\u0000\\u00a3\\u00a5\\u0003\\\"\\u000f\\u0000\"+\n-\t\t\"\\u00a4\\u00a2\\u0001\\u0000\\u0000\\u0000\\u00a4\\u00a3\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u00a5\\u0013\\u0001\\u0000\\u0000\\u0000\\u00a6\\u00ab\\u0003 \\u000e\\u0000\\u00a7\"+\n-\t\t\"\\u00aa\\u0003\\u001e\\r\\u0000\\u00a8\\u00aa\\u0005-\\u0000\\u0000\\u00a9\\u00a7\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00a9\\u00a8\\u0001\\u0000\\u0000\\u0000\\u00aa\\u00ad\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00ab\\u00a9\\u0001\\u0000\\u0000\\u0000\\u00ab\\u00ac\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00ac\\u0015\\u0001\\u0000\\u0000\\u0000\\u00ad\\u00ab\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00ae\\u00b0\\u0007\\u0001\\u0000\\u0000\\u00af\\u00ae\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00b0\\u00b1\\u0001\\u0000\\u0000\\u0000\\u00b1\\u00af\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00b1\\u00b2\\u0001\\u0000\\u0000\\u0000\\u00b2\\u00b3\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00b3\\u00b4\\u0006\\t\\u0002\\u0000\\u00b4\\u0017\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u00b5\\u00b6\\u0005/\\u0000\\u0000\\u00b6\\u00b7\\u0005*\\u0000\"+\n-\t\t\"\\u0000\\u00b7\\u00bb\\u0001\\u0000\\u0000\\u0000\\u00b8\\u00ba\\t\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u00b9\\u00b8\\u0001\\u0000\\u0000\\u0000\\u00ba\\u00bd\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u00bb\\u00bc\\u0001\\u0000\\u0000\\u0000\\u00bb\\u00b9\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u00bc\\u00be\\u0001\\u0000\\u0000\\u0000\\u00bd\\u00bb\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u00be\\u00bf\\u0005*\\u0000\\u0000\\u00bf\\u00c0\\u0005/\\u0000\\u0000\\u00c0\\u00c1\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00c1\\u00c2\\u0006\\n\\u0002\\u0000\\u00c2\\u0019\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u00c3\\u00c4\\u0005/\\u0000\\u0000\\u00c4\\u00c7\\u0005/\\u0000\"+\n-\t\t\"\\u0000\\u00c5\\u00c7\\u0005#\\u0000\\u0000\\u00c6\\u00c3\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u00c6\\u00c5\\u0001\\u0000\\u0000\\u0000\\u00c7\\u00cb\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u00c8\\u00ca\\b\\u0002\\u0000\\u0000\\u00c9\\u00c8\\u0001\\u0000\\u0000\\u0000\\u00ca\"+\n-\t\t\"\\u00cd\\u0001\\u0000\\u0000\\u0000\\u00cb\\u00c9\\u0001\\u0000\\u0000\\u0000\\u00cb\"+\n-\t\t\"\\u00cc\\u0001\\u0000\\u0000\\u0000\\u00cc\\u00cf\\u0001\\u0000\\u0000\\u0000\\u00cd\"+\n-\t\t\"\\u00cb\\u0001\\u0000\\u0000\\u0000\\u00ce\\u00d0\\u0005\\r\\u0000\\u0000\\u00cf\\u00ce\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00cf\\u00d0\\u0001\\u0000\\u0000\\u0000\\u00d0\\u00d1\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00d1\\u00d2\\u0005\\n\\u0000\\u0000\\u00d2\\u00d3\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u00d3\\u00d4\\u0006\\u000b\\u0002\\u0000\\u00d4\\u001b\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u00d5\\u00d6\\u0005\\n\\u0000\\u0000\\u00d6\\u00d7\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u00d7\\u00d8\\u0006\\f\\u0002\\u0000\\u00d8\\u001d\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u00d9\\u00dc\\u0003 \\u000e\\u0000\\u00da\\u00dc\\u0007\\u0003\\u0000\\u0000\"+\n-\t\t\"\\u00db\\u00d9\\u0001\\u0000\\u0000\\u0000\\u00db\\u00da\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u00dc\\u001f\\u0001\\u0000\\u0000\\u0000\\u00dd\\u00e2\\u0007\\u0004\\u0000\\u0000\"+\n-\t\t\"\\u00de\\u00e2\\b\\u0005\\u0000\\u0000\\u00df\\u00e0\\u0007\\u0006\\u0000\\u0000\\u00e0\"+\n-\t\t\"\\u00e2\\u0007\\u0007\\u0000\\u0000\\u00e1\\u00dd\\u0001\\u0000\\u0000\\u0000\\u00e1\"+\n-\t\t\"\\u00de\\u0001\\u0000\\u0000\\u0000\\u00e1\\u00df\\u0001\\u0000\\u0000\\u0000\\u00e2\"+\n-\t\t\"!\\u0001\\u0000\\u0000\\u0000\\u00e3\\u00e4\\u0005\\\\\\u0000\\u0000\\u00e4\\u00f6\"+\n-\t\t\"\\u0007\\b\\u0000\\u0000\\u00e5\\u00e6\\u0005\\\\\\u0000\\u0000\\u00e6\\u00e7\\u0003\"+\n-\t\t\"$\\u0010\\u0000\\u00e7\\u00e8\\u0003$\\u0010\\u0000\\u00e8\\u00e9\\u0003$\\u0010\"+\n-\t\t\"\\u0000\\u00e9\\u00ea\\u0003$\\u0010\\u0000\\u00ea\\u00f6\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u00eb\\u00ec\\u0005\\\\\\u0000\\u0000\\u00ec\\u00ed\\u0003$\\u0010\\u0000\\u00ed\"+\n-\t\t\"\\u00ee\\u0003$\\u0010\\u0000\\u00ee\\u00ef\\u0003$\\u0010\\u0000\\u00ef\\u00f0\\u0003\"+\n-\t\t\"$\\u0010\\u0000\\u00f0\\u00f1\\u0003$\\u0010\\u0000\\u00f1\\u00f2\\u0003$\\u0010\"+\n-\t\t\"\\u0000\\u00f2\\u00f3\\u0003$\\u0010\\u0000\\u00f3\\u00f4\\u0003$\\u0010\\u0000\\u00f4\"+\n-\t\t\"\\u00f6\\u0001\\u0000\\u0000\\u0000\\u00f5\\u00e3\\u0001\\u0000\\u0000\\u0000\\u00f5\"+\n-\t\t\"\\u00e5\\u0001\\u0000\\u0000\\u0000\\u00f5\\u00eb\\u0001\\u0000\\u0000\\u0000\\u00f6\"+\n-\t\t\"#\\u0001\\u0000\\u0000\\u0000\\u00f7\\u00f8\\u0007\\t\\u0000\\u0000\\u00f8%\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u00f9\\u00fb\\u0007\\u0003\\u0000\\u0000\\u00fa\\u00f9\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u00fb\\u00fc\\u0001\\u0000\\u0000\\u0000\\u00fc\\u00fa\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u00fc\\u00fd\\u0001\\u0000\\u0000\\u0000\\u00fd\\u00fe\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u00fe\\u0102\\u0005.\\u0000\\u0000\\u00ff\\u0101\\u0007\\u0003\"+\n-\t\t\"\\u0000\\u0000\\u0100\\u00ff\\u0001\\u0000\\u0000\\u0000\\u0101\\u0104\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0102\\u0100\\u0001\\u0000\\u0000\\u0000\\u0102\\u0103\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0103\\u0106\\u0001\\u0000\\u0000\\u0000\\u0104\\u0102\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0105\\u0107\\u0003(\\u0012\\u0000\\u0106\\u0105\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0106\\u0107\\u0001\\u0000\\u0000\\u0000\\u0107\\u0114\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0108\\u010a\\u0007\\u0003\\u0000\\u0000\\u0109\\u0108\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u010a\\u010b\\u0001\\u0000\\u0000\\u0000\\u010b\\u0109\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u010b\\u010c\\u0001\\u0000\\u0000\\u0000\\u010c\\u010d\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u010d\\u0114\\u0003(\\u0012\\u0000\\u010e\\u0110\\u0007\\u0003\\u0000\\u0000\"+\n-\t\t\"\\u010f\\u010e\\u0001\\u0000\\u0000\\u0000\\u0110\\u0111\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0111\\u010f\\u0001\\u0000\\u0000\\u0000\\u0111\\u0112\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0112\\u0114\\u0001\\u0000\\u0000\\u0000\\u0113\\u00fa\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0113\\u0109\\u0001\\u0000\\u0000\\u0000\\u0113\\u010f\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0114\\'\\u0001\\u0000\\u0000\\u0000\\u0115\\u0117\\u0007\\n\\u0000\\u0000\\u0116\"+\n-\t\t\"\\u0118\\u0007\\u000b\\u0000\\u0000\\u0117\\u0116\\u0001\\u0000\\u0000\\u0000\\u0117\"+\n-\t\t\"\\u0118\\u0001\\u0000\\u0000\\u0000\\u0118\\u011a\\u0001\\u0000\\u0000\\u0000\\u0119\"+\n-\t\t\"\\u011b\\u0007\\u0003\\u0000\\u0000\\u011a\\u0119\\u0001\\u0000\\u0000\\u0000\\u011b\"+\n-\t\t\"\\u011c\\u0001\\u0000\\u0000\\u0000\\u011c\\u011a\\u0001\\u0000\\u0000\\u0000\\u011c\"+\n-\t\t\"\\u011d\\u0001\\u0000\\u0000\\u0000\\u011d)\\u0001\\u0000\\u0000\\u0000\\u011e\\u011f\"+\n-\t\t\"\\u0005t\\u0000\\u0000\\u011f\\u0120\\u0005r\\u0000\\u0000\\u0120\\u0121\\u0005u\"+\n-\t\t\"\\u0000\\u0000\\u0121\\u0128\\u0005e\\u0000\\u0000\\u0122\\u0123\\u0005f\\u0000\\u0000\"+\n-\t\t\"\\u0123\\u0124\\u0005a\\u0000\\u0000\\u0124\\u0125\\u0005l\\u0000\\u0000\\u0125\\u0126\"+\n-\t\t\"\\u0005s\\u0000\\u0000\\u0126\\u0128\\u0005e\\u0000\\u0000\\u0127\\u011e\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u0127\\u0122\\u0001\\u0000\\u0000\\u0000\\u0128+\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0129\\u012a\\u0005\\\"\\u0000\\u0000\\u012a\\u012b\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u012b\\u012c\\u0006\\u0014\\u0003\\u0000\\u012c-\\u0001\\u0000\\u0000\\u0000\\u012d\"+\n-\t\t\"\\u012e\\u0005n\\u0000\\u0000\\u012e\\u012f\\u0005u\\u0000\\u0000\\u012f\\u0130\\u0005\"+\n-\t\t\"l\\u0000\\u0000\\u0130\\u0131\\u0005l\\u0000\\u0000\\u0131/\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0132\\u0133\\u0005<\\u0000\\u0000\\u0133\\u0134\\u0005<\\u0000\\u0000\\u0134\"+\n-\t\t\"\\u0136\\u0001\\u0000\\u0000\\u0000\\u0135\\u0137\\u0005-\\u0000\\u0000\\u0136\\u0135\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0136\\u0137\\u0001\\u0000\\u0000\\u0000\\u0137\\u0138\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0138\\u0139\\u0006\\u0016\\u0004\\u0000\\u01391\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u013a\\u013b\\u0005+\\u0000\\u0000\\u013b3\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u013c\\u013d\\u0005&\\u0000\\u0000\\u013d\\u013e\\u0005&\\u0000\\u0000\\u013e\"+\n-\t\t\"5\\u0001\\u0000\\u0000\\u0000\\u013f\\u0140\\u0005=\\u0000\\u0000\\u0140\\u0141\\u0005\"+\n-\t\t\"=\\u0000\\u0000\\u01417\\u0001\\u0000\\u0000\\u0000\\u0142\\u0143\\u0005<\\u0000\"+\n-\t\t\"\\u0000\\u01439\\u0001\\u0000\\u0000\\u0000\\u0144\\u0145\\u0005:\\u0000\\u0000\\u0145\"+\n-\t\t\";\\u0001\\u0000\\u0000\\u0000\\u0146\\u0147\\u0005[\\u0000\\u0000\\u0147=\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0148\\u0149\\u0005(\\u0000\\u0000\\u0149?\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u014a\\u014b\\u0005-\\u0000\\u0000\\u014bA\\u0001\\u0000\\u0000\\u0000\\u014c\"+\n-\t\t\"\\u014d\\u0005|\\u0000\\u0000\\u014d\\u014e\\u0005|\\u0000\\u0000\\u014eC\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u014f\\u0150\\u0005!\\u0000\\u0000\\u0150\\u0151\\u0005=\\u0000\"+\n-\t\t\"\\u0000\\u0151E\\u0001\\u0000\\u0000\\u0000\\u0152\\u0153\\u0005>\\u0000\\u0000\\u0153\"+\n-\t\t\"G\\u0001\\u0000\\u0000\\u0000\\u0154\\u0155\\u0005?\\u0000\\u0000\\u0155I\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u0156\\u0157\\u0005]\\u0000\\u0000\\u0157K\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u0158\\u0159\\u0005)\\u0000\\u0000\\u0159M\\u0001\\u0000\\u0000\\u0000\\u015a\"+\n-\t\t\"\\u015b\\u0005*\\u0000\\u0000\\u015bO\\u0001\\u0000\\u0000\\u0000\\u015c\\u015d\\u0005\"+\n-\t\t\"!\\u0000\\u0000\\u015dQ\\u0001\\u0000\\u0000\\u0000\\u015e\\u015f\\u0005<\\u0000\"+\n-\t\t\"\\u0000\\u015f\\u0160\\u0005=\\u0000\\u0000\\u0160S\\u0001\\u0000\\u0000\\u0000\\u0161\"+\n-\t\t\"\\u0162\\u0005.\\u0000\\u0000\\u0162U\\u0001\\u0000\\u0000\\u0000\\u0163\\u0164\\u0005\"+\n-\t\t\"/\\u0000\\u0000\\u0164W\\u0001\\u0000\\u0000\\u0000\\u0165\\u0166\\u0005>\\u0000\"+\n-\t\t\"\\u0000\\u0166\\u0167\\u0005=\\u0000\\u0000\\u0167Y\\u0001\\u0000\\u0000\\u0000\\u0168\"+\n-\t\t\"\\u0169\\u0005=\\u0000\\u0000\\u0169\\u016a\\u0005>\\u0000\\u0000\\u016a[\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u016b\\u016c\\u0005,\\u0000\\u0000\\u016c]\\u0001\\u0000\\u0000\"+\n-\t\t\"\\u0000\\u016d\\u016e\\u0005%\\u0000\\u0000\\u016e_\\u0001\\u0000\\u0000\\u0000\\u016f\"+\n-\t\t\"\\u0170\\u0005.\\u0000\\u0000\\u0170\\u0171\\u0005.\\u0000\\u0000\\u0171\\u0172\\u0005\"+\n-\t\t\".\\u0000\\u0000\\u0172a\\u0001\\u0000\\u0000\\u0000\\u0173\\u0174\\u0005~\\u0000\"+\n-\t\t\"\\u0000\\u0174c\\u0001\\u0000\\u0000\\u0000\\u0175\\u0176\\u0005$\\u0000\\u0000\\u0176\"+\n-\t\t\"\\u0177\\u0005{\\u0000\\u0000\\u0177\\u0178\\u0001\\u0000\\u0000\\u0000\\u0178\\u0179\"+\n-\t\t\"\\u00060\\u0005\\u0000\\u0179\\u017a\\u0001\\u0000\\u0000\\u0000\\u017a\\u017b\\u0006\"+\n-\t\t\"0\\u0006\\u0000\\u017be\\u0001\\u0000\\u0000\\u0000\\u017c\\u017e\\u0003h2\\u0000\"+\n-\t\t\"\\u017d\\u017c\\u0001\\u0000\\u0000\\u0000\\u017e\\u017f\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u017f\\u017d\\u0001\\u0000\\u0000\\u0000\\u017f\\u0180\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u0180g\\u0001\\u0000\\u0000\\u0000\\u0181\\u018c\\b\\u0000\\u0000\\u0000\\u0182\"+\n-\t\t\"\\u0183\\u0005$\\u0000\\u0000\\u0183\\u018c\\u0005$\\u0000\\u0000\\u0184\\u0185\\u0005\"+\n-\t\t\"$\\u0000\\u0000\\u0185\\u018c\\u00042\\u0000\\u0000\\u0186\\u0187\\u0005%\\u0000\"+\n-\t\t\"\\u0000\\u0187\\u018c\\u0005%\\u0000\\u0000\\u0188\\u0189\\u0005%\\u0000\\u0000\\u0189\"+\n-\t\t\"\\u018c\\u00042\\u0001\\u0000\\u018a\\u018c\\u0003\\\"\\u000f\\u0000\\u018b\\u0181\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u018b\\u0182\\u0001\\u0000\\u0000\\u0000\\u018b\\u0184\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u018b\\u0186\\u0001\\u0000\\u0000\\u0000\\u018b\\u0188\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u018b\\u018a\\u0001\\u0000\\u0000\\u0000\\u018ci\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u018d\\u018e\\u0005\\\"\\u0000\\u0000\\u018e\\u018f\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u018f\\u0190\\u00063\\u0007\\u0000\\u0190\\u0191\\u00063\\b\\u0000\"+\n-\t\t\"\\u0191k\\u0001\\u0000\\u0000\\u0000\\u0192\\u0193\\u0005\\n\\u0000\\u0000\\u0193\"+\n-\t\t\"\\u0194\\u0001\\u0000\\u0000\\u0000\\u0194\\u0195\\u00064\\t\\u0000\\u0195\\u0196\"+\n-\t\t\"\\u00064\\n\\u0000\\u0196m\\u0001\\u0000\\u0000\\u0000\\u0197\\u019c\\u0003 \\u000e\"+\n-\t\t\"\\u0000\\u0198\\u019b\\u0003\\u001e\\r\\u0000\\u0199\\u019b\\u0005-\\u0000\\u0000\"+\n-\t\t\"\\u019a\\u0198\\u0001\\u0000\\u0000\\u0000\\u019a\\u0199\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u019b\\u019e\\u0001\\u0000\\u0000\\u0000\\u019c\\u019a\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u019c\\u019d\\u0001\\u0000\\u0000\\u0000\\u019d\\u019f\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u019e\\u019c\\u0001\\u0000\\u0000\\u0000\\u019f\\u01a0\\u00065\\u000b\\u0000\\u01a0\"+\n-\t\t\"\\u01a1\\u0001\\u0000\\u0000\\u0000\\u01a1\\u01a2\\u00065\\f\\u0000\\u01a2o\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u01a3\\u01a4\\u0005\\n\\u0000\\u0000\\u01a4\\u01a5\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000\\u01a5\\u01a6\\u00066\\t\\u0000\\u01a6q\\u0001\\u0000\\u0000\\u0000\"+\n-\t\t\"\\u01a7\\u01a8\\u0005$\\u0000\\u0000\\u01a8\\u01a9\\u0005{\\u0000\\u0000\\u01a9\\u01aa\"+\n-\t\t\"\\u0001\\u0000\\u0000\\u0000\\u01aa\\u01ab\\u00067\\r\\u0000\\u01ab\\u01ac\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u01ac\\u01ad\\u00067\\u000e\\u0000\\u01ad\\u01ae\\u00067\\u0006\"+\n-\t\t\"\\u0000\\u01aes\\u0001\\u0000\\u0000\\u0000\\u01af\\u01b1\\u0003v9\\u0000\\u01b0\"+\n-\t\t\"\\u01af\\u0001\\u0000\\u0000\\u0000\\u01b1\\u01b2\\u0001\\u0000\\u0000\\u0000\\u01b2\"+\n-\t\t\"\\u01b0\\u0001\\u0000\\u0000\\u0000\\u01b2\\u01b3\\u0001\\u0000\\u0000\\u0000\\u01b3\"+\n-\t\t\"\\u01b4\\u0001\\u0000\\u0000\\u0000\\u01b4\\u01b5\\u00068\\u000f\\u0000\\u01b5u\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u01b6\\u01bd\\b\\f\\u0000\\u0000\\u01b7\\u01b8\\u0005$\\u0000\"+\n-\t\t\"\\u0000\\u01b8\\u01bd\\b\\r\\u0000\\u0000\\u01b9\\u01ba\\u0005%\\u0000\\u0000\\u01ba\"+\n-\t\t\"\\u01bd\\b\\r\\u0000\\u0000\\u01bb\\u01bd\\u0003\\\"\\u000f\\u0000\\u01bc\\u01b6\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u01bc\\u01b7\\u0001\\u0000\\u0000\\u0000\\u01bc\\u01b9\\u0001\"+\n-\t\t\"\\u0000\\u0000\\u0000\\u01bc\\u01bb\\u0001\\u0000\\u0000\\u0000\\u01bdw\\u0001\\u0000\"+\n-\t\t\"\\u0000\\u0000#\\u0000\\u0001\\u0002\\u0003{}\\u0089\\u008b\\u00a4\\u00a9\\u00ab\"+\n-\t\t\"\\u00b1\\u00bb\\u00c6\\u00cb\\u00cf\\u00db\\u00e1\\u00f5\\u00fc\\u0102\\u0106\\u010b\"+\n-\t\t\"\\u0111\\u0113\\u0117\\u011c\\u0127\\u0136\\u017f\\u018b\\u019a\\u019c\\u01b2\\u01bc\"+\n-\t\t\"\\u0010\\u0001\\u0004\\u0000\\u0001\\u0005\\u0001\\u0000\\u0001\\u0000\\u0005\\u0001\"+\n-\t\t\"\\u0000\\u0005\\u0002\\u0000\\u00010\\u0002\\u0005\\u0000\\u0000\\u0007\\u000f\\u0000\"+\n-\t\t\"\\u0004\\u0000\\u0000\\u0007\\f\\u0000\\u0002\\u0003\\u0000\\u00015\\u0003\\u0007\"+\n-\t\t\"\\b\\u0000\\u00017\\u0004\\u0007+\\u0000\\u00018\\u0005\";\n+\t\t\"\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0001\\u000f\\u0003\\u000f\\u00fa\"+\n+\t\t\"\\b\\u000f\\u0001\\u0010\\u0001\\u0010\\u0001\\u0011\\u0004\\u0011\\u00ff\\b\\u0011\"+\n+\t\t\"\\u000b\\u0011\\f\\u0011\\u0100\\u0001\\u0011\\u0001\\u0011\\u0005\\u0011\\u0105\\b\"+\n+\t\t\"\\u0011\\n\\u0011\\f\\u0011\\u0108\\t\\u0011\\u0001\\u0011\\u0003\\u0011\\u010b\\b\\u0011\"+\n+\t\t\"\\u0001\\u0011\\u0004\\u0011\\u010e\\b\\u0011\\u000b\\u0011\\f\\u0011\\u010f\\u0001\"+\n+\t\t\"\\u0011\\u0001\\u0011\\u0004\\u0011\\u0114\\b\\u0011\\u000b\\u0011\\f\\u0011\\u0115\"+\n+\t\t\"\\u0003\\u0011\\u0118\\b\\u0011\\u0001\\u0012\\u0001\\u0012\\u0003\\u0012\\u011c\\b\"+\n+\t\t\"\\u0012\\u0001\\u0012\\u0004\\u0012\\u011f\\b\\u0012\\u000b\\u0012\\f\\u0012\\u0120\"+\n+\t\t\"\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\"+\n+\t\t\"\\u0001\\u0013\\u0001\\u0013\\u0001\\u0013\\u0003\\u0013\\u012c\\b\\u0013\\u0001\\u0014\"+\n+\t\t\"\\u0001\\u0014\\u0001\\u0014\\u0001\\u0014\\u0001\\u0015\\u0001\\u0015\\u0001\\u0015\"+\n+\t\t\"\\u0001\\u0015\\u0001\\u0015\\u0001\\u0016\\u0001\\u0016\\u0001\\u0016\\u0001\\u0016\"+\n+\t\t\"\\u0003\\u0016\\u013b\\b\\u0016\\u0001\\u0016\\u0001\\u0016\\u0001\\u0017\\u0001\\u0017\"+\n+\t\t\"\\u0001\\u0018\\u0001\\u0018\\u0001\\u0018\\u0001\\u0019\\u0001\\u0019\\u0001\\u0019\"+\n+\t\t\"\\u0001\\u001a\\u0001\\u001a\\u0001\\u001b\\u0001\\u001b\\u0001\\u001c\\u0001\\u001c\"+\n+\t\t\"\\u0001\\u001d\\u0001\\u001d\\u0001\\u001e\\u0001\\u001e\\u0001\\u001f\\u0001\\u001f\"+\n+\t\t\"\\u0001\\u001f\\u0001 \\u0001 \\u0001 \\u0001!\\u0001!\\u0001\\\"\\u0001\\\"\\u0001\"+\n+\t\t\"#\\u0001#\\u0001$\\u0001$\\u0001%\\u0001%\\u0001&\\u0001&\\u0001\\'\\u0001\\'\\u0001\"+\n+\t\t\"\\'\\u0001(\\u0001(\\u0001)\\u0001)\\u0001*\\u0001*\\u0001*\\u0001+\\u0001+\\u0001\"+\n+\t\t\"+\\u0001,\\u0001,\\u0001-\\u0001-\\u0001.\\u0001.\\u0001.\\u0001.\\u0001/\\u0001\"+\n+\t\t\"/\\u00010\\u00010\\u00010\\u00010\\u00010\\u00010\\u00010\\u00011\\u00041\\u0182\"+\n+\t\t\"\\b1\\u000b1\\f1\\u0183\\u00012\\u00012\\u00012\\u00012\\u00012\\u00012\\u00012\\u0001\"+\n+\t\t\"2\\u00012\\u00012\\u00032\\u0190\\b2\\u00013\\u00013\\u00013\\u00013\\u00013\\u0001\"+\n+\t\t\"4\\u00014\\u00014\\u00014\\u00014\\u00015\\u00015\\u00015\\u00055\\u019f\\b5\\n5\"+\n+\t\t\"\\f5\\u01a2\\t5\\u00015\\u00015\\u00015\\u00015\\u00016\\u00016\\u00016\\u00016\\u0001\"+\n+\t\t\"7\\u00017\\u00017\\u00017\\u00017\\u00017\\u00017\\u00017\\u00018\\u00048\\u01b5\"+\n+\t\t\"\\b8\\u000b8\\f8\\u01b6\\u00018\\u00018\\u00019\\u00019\\u00019\\u00019\\u00019\\u0001\"+\n+\t\t\"9\\u00039\\u01c1\\b9\\u0001\\u00bf\\u0000:\\u0004\\u0001\\u0006\\u0002\\b\\u0003\\n\"+\n+\t\t\"\\u0004\\f\\u0005\\u000e\\u0006\\u0010\\u0007\\u0012\\u0000\\u0014\\b\\u0016\\t\\u0018\"+\n+\t\t\"\\n\\u001a\\u000b\\u001c\\f\\u001e\\u0000 \\u0000\\\"\\u0000$\\u0000&\\r(\\u0000*\\u000e\"+\n+\t\t\",\\u000f.\\u00100\\u00112\\u00124\\u00136\\u00148\\u0015:\\u0016<\\u0017>\\u0018\"+\n+\t\t\"@\\u0019B\\u001aD\\u001bF\\u001cH\\u001dJ\\u001eL\\u001fN P!R\\\"T#V$X%Z&\\\\\\'^\"+\n+\t\t\"(`)b*d+f,h-j\\u0000l\\u0000n\\u0000p\\u0000r\\u0000t.v/\\u0004\\u0000\\u0001\\u0002\"+\n+\t\t\"\\u0003\\u000e\\u0004\\u0000\\n\\n\\r\\r\\\"\\\"$%\\u0003\\u0000\\t\\t\\f\\r  \\u0002\\u0000\"+\n+\t\t\"\\n\\n\\r\\r\\u0001\\u000009\\u0004\\u0000$$AZ__az\\u0002\\u0000\\u0000\\u007f\\u8000\"+\n+\t\t\"\\ud800\\u8000\\udbff\\u0001\\u0000\\u8000\\ud800\\u8000\\udbff\\u0001\\u0000\\u8000\"+\n+\t\t\"\\udc00\\u8000\\udfff\\u0005\\u0000\\\"\\\"\\\\\\\\nnrrtt\\u0003\\u000009AFaf\\u0002\\u0000\"+\n+\t\t\"EEee\\u0002\\u0000++--\\u0003\\u0000\\n\\n\\r\\r$%\\u0001\\u0000{{\\u01e4\\u0000\\u0004\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0000\\u0006\\u0001\\u0000\\u0000\\u0000\\u0000\\b\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0000\\n\\u0001\\u0000\\u0000\\u0000\\u0000\\f\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u000e\\u0001\\u0000\\u0000\\u0000\\u0000\\u0010\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0014\\u0001\\u0000\\u0000\\u0000\\u0000\\u0016\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0018\\u0001\\u0000\\u0000\\u0000\\u0000\\u001a\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u001c\\u0001\\u0000\\u0000\\u0000\\u0000&\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0000*\\u0001\\u0000\\u0000\\u0000\\u0000,\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n+\t\t\".\\u0001\\u0000\\u0000\\u0000\\u00000\\u0001\\u0000\\u0000\\u0000\\u00002\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u00004\\u0001\\u0000\\u0000\\u0000\\u00006\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u00008\\u0001\\u0000\\u0000\\u0000\\u0000:\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n+\t\t\"<\\u0001\\u0000\\u0000\\u0000\\u0000>\\u0001\\u0000\\u0000\\u0000\\u0000@\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0000B\\u0001\\u0000\\u0000\\u0000\\u0000D\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0000F\\u0001\\u0000\\u0000\\u0000\\u0000H\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n+\t\t\"J\\u0001\\u0000\\u0000\\u0000\\u0000L\\u0001\\u0000\\u0000\\u0000\\u0000N\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0000P\\u0001\\u0000\\u0000\\u0000\\u0000R\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0000T\\u0001\\u0000\\u0000\\u0000\\u0000V\\u0001\\u0000\\u0000\\u0000\\u0000\"+\n+\t\t\"X\\u0001\\u0000\\u0000\\u0000\\u0000Z\\u0001\\u0000\\u0000\\u0000\\u0000\\\\\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0000^\\u0001\\u0000\\u0000\\u0000\\u0000`\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0000b\\u0001\\u0000\\u0000\\u0000\\u0001d\\u0001\\u0000\\u0000\\u0000\\u0001\"+\n+\t\t\"f\\u0001\\u0000\\u0000\\u0000\\u0001h\\u0001\\u0000\\u0000\\u0000\\u0001j\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0002l\\u0001\\u0000\\u0000\\u0000\\u0002n\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0003p\\u0001\\u0000\\u0000\\u0000\\u0003r\\u0001\\u0000\\u0000\\u0000\\u0003\"+\n+\t\t\"t\\u0001\\u0000\\u0000\\u0000\\u0003v\\u0001\\u0000\\u0000\\u0000\\u0004x\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0006\\u0088\\u0001\\u0000\\u0000\\u0000\\b\\u0098\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\n\\u009b\\u0001\\u0000\\u0000\\u0000\\f\\u009e\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u000e\\u00a1\\u0001\\u0000\\u0000\\u0000\\u0010\\u00a4\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0012\\u00a8\\u0001\\u0000\\u0000\\u0000\\u0014\\u00aa\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0016\\u00b3\\u0001\\u0000\\u0000\\u0000\\u0018\\u00b9\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u001a\\u00ca\\u0001\\u0000\\u0000\\u0000\\u001c\\u00d9\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u001e\\u00df\\u0001\\u0000\\u0000\\u0000 \\u00e5\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\\"\\u00f9\\u0001\\u0000\\u0000\\u0000$\\u00fb\\u0001\\u0000\\u0000\\u0000&\\u0117\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000(\\u0119\\u0001\\u0000\\u0000\\u0000*\\u012b\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000,\\u012d\\u0001\\u0000\\u0000\\u0000.\\u0131\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"0\\u0136\\u0001\\u0000\\u0000\\u00002\\u013e\\u0001\\u0000\\u0000\\u00004\\u0140\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u00006\\u0143\\u0001\\u0000\\u0000\\u00008\\u0146\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000:\\u0148\\u0001\\u0000\\u0000\\u0000<\\u014a\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\">\\u014c\\u0001\\u0000\\u0000\\u0000@\\u014e\\u0001\\u0000\\u0000\\u0000B\\u0150\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000D\\u0153\\u0001\\u0000\\u0000\\u0000F\\u0156\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000H\\u0158\\u0001\\u0000\\u0000\\u0000J\\u015a\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"L\\u015c\\u0001\\u0000\\u0000\\u0000N\\u015e\\u0001\\u0000\\u0000\\u0000P\\u0160\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000R\\u0162\\u0001\\u0000\\u0000\\u0000T\\u0165\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000V\\u0167\\u0001\\u0000\\u0000\\u0000X\\u0169\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"Z\\u016c\\u0001\\u0000\\u0000\\u0000\\\\\\u016f\\u0001\\u0000\\u0000\\u0000^\\u0171\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000`\\u0173\\u0001\\u0000\\u0000\\u0000b\\u0177\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000d\\u0179\\u0001\\u0000\\u0000\\u0000f\\u0181\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"h\\u018f\\u0001\\u0000\\u0000\\u0000j\\u0191\\u0001\\u0000\\u0000\\u0000l\\u0196\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000n\\u019b\\u0001\\u0000\\u0000\\u0000p\\u01a7\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000r\\u01ab\\u0001\\u0000\\u0000\\u0000t\\u01b4\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"v\\u01c0\\u0001\\u0000\\u0000\\u0000x\\u007f\\u0005{\\u0000\\u0000y~\\u0003\\u0016\"+\n+\t\t\"\\t\\u0000z~\\u0003\\u001c\\f\\u0000{~\\u0003\\u0018\\n\\u0000|~\\u0003\\u001a\\u000b\"+\n+\t\t\"\\u0000}y\\u0001\\u0000\\u0000\\u0000}z\\u0001\\u0000\\u0000\\u0000}{\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000}|\\u0001\\u0000\\u0000\\u0000~\\u0081\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u007f}\\u0001\\u0000\\u0000\\u0000\\u007f\\u0080\\u0001\\u0000\\u0000\\u0000\\u0080\"+\n+\t\t\"\\u0082\\u0001\\u0000\\u0000\\u0000\\u0081\\u007f\\u0001\\u0000\\u0000\\u0000\\u0082\"+\n+\t\t\"\\u0083\\u0005f\\u0000\\u0000\\u0083\\u0084\\u0005o\\u0000\\u0000\\u0084\\u0085\\u0005\"+\n+\t\t\"r\\u0000\\u0000\\u0085\\u0086\\u0001\\u0000\\u0000\\u0000\\u0086\\u0087\\u0003\\u0016\"+\n+\t\t\"\\t\\u0000\\u0087\\u0005\\u0001\\u0000\\u0000\\u0000\\u0088\\u008f\\u0005[\\u0000\"+\n+\t\t\"\\u0000\\u0089\\u008e\\u0003\\u0016\\t\\u0000\\u008a\\u008e\\u0003\\u001c\\f\\u0000\"+\n+\t\t\"\\u008b\\u008e\\u0003\\u0018\\n\\u0000\\u008c\\u008e\\u0003\\u001a\\u000b\\u0000\\u008d\"+\n+\t\t\"\\u0089\\u0001\\u0000\\u0000\\u0000\\u008d\\u008a\\u0001\\u0000\\u0000\\u0000\\u008d\"+\n+\t\t\"\\u008b\\u0001\\u0000\\u0000\\u0000\\u008d\\u008c\\u0001\\u0000\\u0000\\u0000\\u008e\"+\n+\t\t\"\\u0091\\u0001\\u0000\\u0000\\u0000\\u008f\\u008d\\u0001\\u0000\\u0000\\u0000\\u008f\"+\n+\t\t\"\\u0090\\u0001\\u0000\\u0000\\u0000\\u0090\\u0092\\u0001\\u0000\\u0000\\u0000\\u0091\"+\n+\t\t\"\\u008f\\u0001\\u0000\\u0000\\u0000\\u0092\\u0093\\u0005f\\u0000\\u0000\\u0093\\u0094\"+\n+\t\t\"\\u0005o\\u0000\\u0000\\u0094\\u0095\\u0005r\\u0000\\u0000\\u0095\\u0096\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0096\\u0097\\u0003\\u0016\\t\\u0000\\u0097\\u0007\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0098\\u0099\\u0005i\\u0000\\u0000\\u0099\\u009a\\u0005f\\u0000\\u0000\\u009a\"+\n+\t\t\"\\t\\u0001\\u0000\\u0000\\u0000\\u009b\\u009c\\u0005i\\u0000\\u0000\\u009c\\u009d\"+\n+\t\t\"\\u0005n\\u0000\\u0000\\u009d\\u000b\\u0001\\u0000\\u0000\\u0000\\u009e\\u009f\\u0005\"+\n+\t\t\"{\\u0000\\u0000\\u009f\\u00a0\\u0006\\u0004\\u0000\\u0000\\u00a0\\r\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u00a1\\u00a2\\u0005}\\u0000\\u0000\\u00a2\\u00a3\\u0006\\u0005\\u0001\"+\n+\t\t\"\\u0000\\u00a3\\u000f\\u0001\\u0000\\u0000\\u0000\\u00a4\\u00a5\\u0005=\\u0000\\u0000\"+\n+\t\t\"\\u00a5\\u0011\\u0001\\u0000\\u0000\\u0000\\u00a6\\u00a9\\b\\u0000\\u0000\\u0000\\u00a7\"+\n+\t\t\"\\u00a9\\u0003\\\"\\u000f\\u0000\\u00a8\\u00a6\\u0001\\u0000\\u0000\\u0000\\u00a8\\u00a7\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00a9\\u0013\\u0001\\u0000\\u0000\\u0000\\u00aa\\u00af\"+\n+\t\t\"\\u0003 \\u000e\\u0000\\u00ab\\u00ae\\u0003\\u001e\\r\\u0000\\u00ac\\u00ae\\u0005\"+\n+\t\t\"-\\u0000\\u0000\\u00ad\\u00ab\\u0001\\u0000\\u0000\\u0000\\u00ad\\u00ac\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u00ae\\u00b1\\u0001\\u0000\\u0000\\u0000\\u00af\\u00ad\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u00af\\u00b0\\u0001\\u0000\\u0000\\u0000\\u00b0\\u0015\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u00b1\\u00af\\u0001\\u0000\\u0000\\u0000\\u00b2\\u00b4\\u0007\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u00b3\\u00b2\\u0001\\u0000\\u0000\\u0000\\u00b4\\u00b5\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u00b5\\u00b3\\u0001\\u0000\\u0000\\u0000\\u00b5\\u00b6\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u00b6\\u00b7\\u0001\\u0000\\u0000\\u0000\\u00b7\\u00b8\\u0006\\t\\u0002\"+\n+\t\t\"\\u0000\\u00b8\\u0017\\u0001\\u0000\\u0000\\u0000\\u00b9\\u00ba\\u0005/\\u0000\\u0000\"+\n+\t\t\"\\u00ba\\u00bb\\u0005*\\u0000\\u0000\\u00bb\\u00bf\\u0001\\u0000\\u0000\\u0000\\u00bc\"+\n+\t\t\"\\u00be\\t\\u0000\\u0000\\u0000\\u00bd\\u00bc\\u0001\\u0000\\u0000\\u0000\\u00be\\u00c1\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00bf\\u00c0\\u0001\\u0000\\u0000\\u0000\\u00bf\\u00bd\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00c0\\u00c2\\u0001\\u0000\\u0000\\u0000\\u00c1\\u00bf\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00c2\\u00c3\\u0005*\\u0000\\u0000\\u00c3\\u00c4\\u0005\"+\n+\t\t\"/\\u0000\\u0000\\u00c4\\u00c5\\u0001\\u0000\\u0000\\u0000\\u00c5\\u00c6\\u0006\\n\"+\n+\t\t\"\\u0002\\u0000\\u00c6\\u0019\\u0001\\u0000\\u0000\\u0000\\u00c7\\u00c8\\u0005/\\u0000\"+\n+\t\t\"\\u0000\\u00c8\\u00cb\\u0005/\\u0000\\u0000\\u00c9\\u00cb\\u0005#\\u0000\\u0000\\u00ca\"+\n+\t\t\"\\u00c7\\u0001\\u0000\\u0000\\u0000\\u00ca\\u00c9\\u0001\\u0000\\u0000\\u0000\\u00cb\"+\n+\t\t\"\\u00cf\\u0001\\u0000\\u0000\\u0000\\u00cc\\u00ce\\b\\u0002\\u0000\\u0000\\u00cd\\u00cc\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00ce\\u00d1\\u0001\\u0000\\u0000\\u0000\\u00cf\\u00cd\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00cf\\u00d0\\u0001\\u0000\\u0000\\u0000\\u00d0\\u00d3\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00d1\\u00cf\\u0001\\u0000\\u0000\\u0000\\u00d2\\u00d4\"+\n+\t\t\"\\u0005\\r\\u0000\\u0000\\u00d3\\u00d2\\u0001\\u0000\\u0000\\u0000\\u00d3\\u00d4\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u00d4\\u00d5\\u0001\\u0000\\u0000\\u0000\\u00d5\\u00d6\\u0005\"+\n+\t\t\"\\n\\u0000\\u0000\\u00d6\\u00d7\\u0001\\u0000\\u0000\\u0000\\u00d7\\u00d8\\u0006\\u000b\"+\n+\t\t\"\\u0002\\u0000\\u00d8\\u001b\\u0001\\u0000\\u0000\\u0000\\u00d9\\u00da\\u0005\\n\\u0000\"+\n+\t\t\"\\u0000\\u00da\\u00db\\u0001\\u0000\\u0000\\u0000\\u00db\\u00dc\\u0006\\f\\u0002\\u0000\"+\n+\t\t\"\\u00dc\\u001d\\u0001\\u0000\\u0000\\u0000\\u00dd\\u00e0\\u0003 \\u000e\\u0000\\u00de\"+\n+\t\t\"\\u00e0\\u0007\\u0003\\u0000\\u0000\\u00df\\u00dd\\u0001\\u0000\\u0000\\u0000\\u00df\"+\n+\t\t\"\\u00de\\u0001\\u0000\\u0000\\u0000\\u00e0\\u001f\\u0001\\u0000\\u0000\\u0000\\u00e1\"+\n+\t\t\"\\u00e6\\u0007\\u0004\\u0000\\u0000\\u00e2\\u00e6\\b\\u0005\\u0000\\u0000\\u00e3\\u00e4\"+\n+\t\t\"\\u0007\\u0006\\u0000\\u0000\\u00e4\\u00e6\\u0007\\u0007\\u0000\\u0000\\u00e5\\u00e1\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00e5\\u00e2\\u0001\\u0000\\u0000\\u0000\\u00e5\\u00e3\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u00e6!\\u0001\\u0000\\u0000\\u0000\\u00e7\\u00e8\\u0005\"+\n+\t\t\"\\\\\\u0000\\u0000\\u00e8\\u00fa\\u0007\\b\\u0000\\u0000\\u00e9\\u00ea\\u0005\\\\\\u0000\"+\n+\t\t\"\\u0000\\u00ea\\u00eb\\u0003$\\u0010\\u0000\\u00eb\\u00ec\\u0003$\\u0010\\u0000\\u00ec\"+\n+\t\t\"\\u00ed\\u0003$\\u0010\\u0000\\u00ed\\u00ee\\u0003$\\u0010\\u0000\\u00ee\\u00fa\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u00ef\\u00f0\\u0005\\\\\\u0000\\u0000\\u00f0\\u00f1\\u0003$\"+\n+\t\t\"\\u0010\\u0000\\u00f1\\u00f2\\u0003$\\u0010\\u0000\\u00f2\\u00f3\\u0003$\\u0010\\u0000\"+\n+\t\t\"\\u00f3\\u00f4\\u0003$\\u0010\\u0000\\u00f4\\u00f5\\u0003$\\u0010\\u0000\\u00f5\\u00f6\"+\n+\t\t\"\\u0003$\\u0010\\u0000\\u00f6\\u00f7\\u0003$\\u0010\\u0000\\u00f7\\u00f8\\u0003$\"+\n+\t\t\"\\u0010\\u0000\\u00f8\\u00fa\\u0001\\u0000\\u0000\\u0000\\u00f9\\u00e7\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u00f9\\u00e9\\u0001\\u0000\\u0000\\u0000\\u00f9\\u00ef\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u00fa#\\u0001\\u0000\\u0000\\u0000\\u00fb\\u00fc\\u0007\\t\\u0000\"+\n+\t\t\"\\u0000\\u00fc%\\u0001\\u0000\\u0000\\u0000\\u00fd\\u00ff\\u0007\\u0003\\u0000\\u0000\"+\n+\t\t\"\\u00fe\\u00fd\\u0001\\u0000\\u0000\\u0000\\u00ff\\u0100\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0100\\u00fe\\u0001\\u0000\\u0000\\u0000\\u0100\\u0101\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0101\\u0102\\u0001\\u0000\\u0000\\u0000\\u0102\\u0106\\u0005.\\u0000\\u0000\\u0103\"+\n+\t\t\"\\u0105\\u0007\\u0003\\u0000\\u0000\\u0104\\u0103\\u0001\\u0000\\u0000\\u0000\\u0105\"+\n+\t\t\"\\u0108\\u0001\\u0000\\u0000\\u0000\\u0106\\u0104\\u0001\\u0000\\u0000\\u0000\\u0106\"+\n+\t\t\"\\u0107\\u0001\\u0000\\u0000\\u0000\\u0107\\u010a\\u0001\\u0000\\u0000\\u0000\\u0108\"+\n+\t\t\"\\u0106\\u0001\\u0000\\u0000\\u0000\\u0109\\u010b\\u0003(\\u0012\\u0000\\u010a\\u0109\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u010a\\u010b\\u0001\\u0000\\u0000\\u0000\\u010b\\u0118\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u010c\\u010e\\u0007\\u0003\\u0000\\u0000\\u010d\\u010c\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u010e\\u010f\\u0001\\u0000\\u0000\\u0000\\u010f\\u010d\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u010f\\u0110\\u0001\\u0000\\u0000\\u0000\\u0110\\u0111\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u0111\\u0118\\u0003(\\u0012\\u0000\\u0112\\u0114\\u0007\"+\n+\t\t\"\\u0003\\u0000\\u0000\\u0113\\u0112\\u0001\\u0000\\u0000\\u0000\\u0114\\u0115\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0115\\u0113\\u0001\\u0000\\u0000\\u0000\\u0115\\u0116\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0116\\u0118\\u0001\\u0000\\u0000\\u0000\\u0117\\u00fe\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0117\\u010d\\u0001\\u0000\\u0000\\u0000\\u0117\\u0113\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0118\\'\\u0001\\u0000\\u0000\\u0000\\u0119\\u011b\\u0007\\n\"+\n+\t\t\"\\u0000\\u0000\\u011a\\u011c\\u0007\\u000b\\u0000\\u0000\\u011b\\u011a\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u011b\\u011c\\u0001\\u0000\\u0000\\u0000\\u011c\\u011e\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u011d\\u011f\\u0007\\u0003\\u0000\\u0000\\u011e\\u011d\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u011f\\u0120\\u0001\\u0000\\u0000\\u0000\\u0120\\u011e\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0120\\u0121\\u0001\\u0000\\u0000\\u0000\\u0121)\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0122\\u0123\\u0005t\\u0000\\u0000\\u0123\\u0124\\u0005r\\u0000\\u0000\\u0124\"+\n+\t\t\"\\u0125\\u0005u\\u0000\\u0000\\u0125\\u012c\\u0005e\\u0000\\u0000\\u0126\\u0127\\u0005\"+\n+\t\t\"f\\u0000\\u0000\\u0127\\u0128\\u0005a\\u0000\\u0000\\u0128\\u0129\\u0005l\\u0000\"+\n+\t\t\"\\u0000\\u0129\\u012a\\u0005s\\u0000\\u0000\\u012a\\u012c\\u0005e\\u0000\\u0000\\u012b\"+\n+\t\t\"\\u0122\\u0001\\u0000\\u0000\\u0000\\u012b\\u0126\\u0001\\u0000\\u0000\\u0000\\u012c\"+\n+\t\t\"+\\u0001\\u0000\\u0000\\u0000\\u012d\\u012e\\u0005\\\"\\u0000\\u0000\\u012e\\u012f\"+\n+\t\t\"\\u0001\\u0000\\u0000\\u0000\\u012f\\u0130\\u0006\\u0014\\u0003\\u0000\\u0130-\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0131\\u0132\\u0005n\\u0000\\u0000\\u0132\\u0133\\u0005u\\u0000\"+\n+\t\t\"\\u0000\\u0133\\u0134\\u0005l\\u0000\\u0000\\u0134\\u0135\\u0005l\\u0000\\u0000\\u0135\"+\n+\t\t\"/\\u0001\\u0000\\u0000\\u0000\\u0136\\u0137\\u0005<\\u0000\\u0000\\u0137\\u0138\\u0005\"+\n+\t\t\"<\\u0000\\u0000\\u0138\\u013a\\u0001\\u0000\\u0000\\u0000\\u0139\\u013b\\u0005-\\u0000\"+\n+\t\t\"\\u0000\\u013a\\u0139\\u0001\\u0000\\u0000\\u0000\\u013a\\u013b\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u013b\\u013c\\u0001\\u0000\\u0000\\u0000\\u013c\\u013d\\u0006\\u0016\\u0004\"+\n+\t\t\"\\u0000\\u013d1\\u0001\\u0000\\u0000\\u0000\\u013e\\u013f\\u0005+\\u0000\\u0000\\u013f\"+\n+\t\t\"3\\u0001\\u0000\\u0000\\u0000\\u0140\\u0141\\u0005&\\u0000\\u0000\\u0141\\u0142\\u0005\"+\n+\t\t\"&\\u0000\\u0000\\u01425\\u0001\\u0000\\u0000\\u0000\\u0143\\u0144\\u0005=\\u0000\"+\n+\t\t\"\\u0000\\u0144\\u0145\\u0005=\\u0000\\u0000\\u01457\\u0001\\u0000\\u0000\\u0000\\u0146\"+\n+\t\t\"\\u0147\\u0005<\\u0000\\u0000\\u01479\\u0001\\u0000\\u0000\\u0000\\u0148\\u0149\\u0005\"+\n+\t\t\":\\u0000\\u0000\\u0149;\\u0001\\u0000\\u0000\\u0000\\u014a\\u014b\\u0005[\\u0000\"+\n+\t\t\"\\u0000\\u014b=\\u0001\\u0000\\u0000\\u0000\\u014c\\u014d\\u0005(\\u0000\\u0000\\u014d\"+\n+\t\t\"?\\u0001\\u0000\\u0000\\u0000\\u014e\\u014f\\u0005-\\u0000\\u0000\\u014fA\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0150\\u0151\\u0005|\\u0000\\u0000\\u0151\\u0152\\u0005|\\u0000\"+\n+\t\t\"\\u0000\\u0152C\\u0001\\u0000\\u0000\\u0000\\u0153\\u0154\\u0005!\\u0000\\u0000\\u0154\"+\n+\t\t\"\\u0155\\u0005=\\u0000\\u0000\\u0155E\\u0001\\u0000\\u0000\\u0000\\u0156\\u0157\\u0005\"+\n+\t\t\">\\u0000\\u0000\\u0157G\\u0001\\u0000\\u0000\\u0000\\u0158\\u0159\\u0005?\\u0000\"+\n+\t\t\"\\u0000\\u0159I\\u0001\\u0000\\u0000\\u0000\\u015a\\u015b\\u0005]\\u0000\\u0000\\u015b\"+\n+\t\t\"K\\u0001\\u0000\\u0000\\u0000\\u015c\\u015d\\u0005)\\u0000\\u0000\\u015dM\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u015e\\u015f\\u0005*\\u0000\\u0000\\u015fO\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0160\\u0161\\u0005!\\u0000\\u0000\\u0161Q\\u0001\\u0000\\u0000\\u0000\\u0162\"+\n+\t\t\"\\u0163\\u0005<\\u0000\\u0000\\u0163\\u0164\\u0005=\\u0000\\u0000\\u0164S\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0165\\u0166\\u0005.\\u0000\\u0000\\u0166U\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0167\\u0168\\u0005/\\u0000\\u0000\\u0168W\\u0001\\u0000\\u0000\\u0000\\u0169\"+\n+\t\t\"\\u016a\\u0005>\\u0000\\u0000\\u016a\\u016b\\u0005=\\u0000\\u0000\\u016bY\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u016c\\u016d\\u0005=\\u0000\\u0000\\u016d\\u016e\\u0005>\\u0000\"+\n+\t\t\"\\u0000\\u016e[\\u0001\\u0000\\u0000\\u0000\\u016f\\u0170\\u0005,\\u0000\\u0000\\u0170\"+\n+\t\t\"]\\u0001\\u0000\\u0000\\u0000\\u0171\\u0172\\u0005%\\u0000\\u0000\\u0172_\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u0173\\u0174\\u0005.\\u0000\\u0000\\u0174\\u0175\\u0005.\\u0000\"+\n+\t\t\"\\u0000\\u0175\\u0176\\u0005.\\u0000\\u0000\\u0176a\\u0001\\u0000\\u0000\\u0000\\u0177\"+\n+\t\t\"\\u0178\\u0005~\\u0000\\u0000\\u0178c\\u0001\\u0000\\u0000\\u0000\\u0179\\u017a\\u0005\"+\n+\t\t\"$\\u0000\\u0000\\u017a\\u017b\\u0005{\\u0000\\u0000\\u017b\\u017c\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u017c\\u017d\\u00060\\u0005\\u0000\\u017d\\u017e\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u017e\\u017f\\u00060\\u0006\\u0000\\u017fe\\u0001\\u0000\\u0000\\u0000\\u0180\\u0182\"+\n+\t\t\"\\u0003h2\\u0000\\u0181\\u0180\\u0001\\u0000\\u0000\\u0000\\u0182\\u0183\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0183\\u0181\\u0001\\u0000\\u0000\\u0000\\u0183\\u0184\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u0184g\\u0001\\u0000\\u0000\\u0000\\u0185\\u0190\\b\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u0186\\u0187\\u0005$\\u0000\\u0000\\u0187\\u0190\\u0005$\\u0000\\u0000\\u0188\"+\n+\t\t\"\\u0189\\u0005$\\u0000\\u0000\\u0189\\u0190\\u00042\\u0000\\u0000\\u018a\\u018b\\u0005\"+\n+\t\t\"%\\u0000\\u0000\\u018b\\u0190\\u0005%\\u0000\\u0000\\u018c\\u018d\\u0005%\\u0000\"+\n+\t\t\"\\u0000\\u018d\\u0190\\u00042\\u0001\\u0000\\u018e\\u0190\\u0003\\\"\\u000f\\u0000\"+\n+\t\t\"\\u018f\\u0185\\u0001\\u0000\\u0000\\u0000\\u018f\\u0186\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u018f\\u0188\\u0001\\u0000\\u0000\\u0000\\u018f\\u018a\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u018f\\u018c\\u0001\\u0000\\u0000\\u0000\\u018f\\u018e\\u0001\\u0000\\u0000\\u0000\"+\n+\t\t\"\\u0190i\\u0001\\u0000\\u0000\\u0000\\u0191\\u0192\\u0005\\\"\\u0000\\u0000\\u0192\"+\n+\t\t\"\\u0193\\u0001\\u0000\\u0000\\u0000\\u0193\\u0194\\u00063\\u0007\\u0000\\u0194\\u0195\"+\n+\t\t\"\\u00063\\b\\u0000\\u0195k\\u0001\\u0000\\u0000\\u0000\\u0196\\u0197\\u0005\\n\\u0000\"+\n+\t\t\"\\u0000\\u0197\\u0198\\u0001\\u0000\\u0000\\u0000\\u0198\\u0199\\u00064\\t\\u0000\"+\n+\t\t\"\\u0199\\u019a\\u00064\\n\\u0000\\u019am\\u0001\\u0000\\u0000\\u0000\\u019b\\u01a0\"+\n+\t\t\"\\u0003 \\u000e\\u0000\\u019c\\u019f\\u0003\\u001e\\r\\u0000\\u019d\\u019f\\u0005\"+\n+\t\t\"-\\u0000\\u0000\\u019e\\u019c\\u0001\\u0000\\u0000\\u0000\\u019e\\u019d\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u019f\\u01a2\\u0001\\u0000\\u0000\\u0000\\u01a0\\u019e\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u01a0\\u01a1\\u0001\\u0000\\u0000\\u0000\\u01a1\\u01a3\\u0001\\u0000\"+\n+\t\t\"\\u0000\\u0000\\u01a2\\u01a0\\u0001\\u0000\\u0000\\u0000\\u01a3\\u01a4\\u00065\\u000b\"+\n+\t\t\"\\u0000\\u01a4\\u01a5\\u0001\\u0000\\u0000\\u0000\\u01a5\\u01a6\\u00065\\f\\u0000\"+\n+\t\t\"\\u01a6o\\u0001\\u0000\\u0000\\u0000\\u01a7\\u01a8\\u0005\\n\\u0000\\u0000\\u01a8\"+\n+\t\t\"\\u01a9\\u0001\\u0000\\u0000\\u0000\\u01a9\\u01aa\\u00066\\t\\u0000\\u01aaq\\u0001\"+\n+\t\t\"\\u0000\\u0000\\u0000\\u01ab\\u01ac\\u0005$\\u0000\\u0000\\u01ac\\u01ad\\u0005{\\u0000\"+\n+\t\t\"\\u0000\\u01ad\\u01ae\\u0001\\u0000\\u0000\\u0000\\u01ae\\u01af\\u00067\\r\\u0000\"+\n+\t\t\"\\u01af\\u01b0\\u0001\\u0000\\u0000\\u0000\\u01b0\\u01b1\\u00067\\u000e\\u0000\\u01b1\"+\n+\t\t\"\\u01b2\\u00067\\u0006\\u0000\\u01b2s\\u0001\\u0000\\u0000\\u0000\\u01b3\\u01b5\\u0003\"+\n+\t\t\"v9\\u0000\\u01b4\\u01b3\\u0001\\u0000\\u0000\\u0000\\u01b5\\u01b6\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u01b6\\u01b4\\u0001\\u0000\\u0000\\u0000\\u01b6\\u01b7\\u0001\\u0000\\u0000\"+\n+\t\t\"\\u0000\\u01b7\\u01b8\\u0001\\u0000\\u0000\\u0000\\u01b8\\u01b9\\u00068\\u000f\\u0000\"+\n+\t\t\"\\u01b9u\\u0001\\u0000\\u0000\\u0000\\u01ba\\u01c1\\b\\f\\u0000\\u0000\\u01bb\\u01bc\"+\n+\t\t\"\\u0005$\\u0000\\u0000\\u01bc\\u01c1\\b\\r\\u0000\\u0000\\u01bd\\u01be\\u0005%\\u0000\"+\n+\t\t\"\\u0000\\u01be\\u01c1\\b\\r\\u0000\\u0000\\u01bf\\u01c1\\u0003\\\"\\u000f\\u0000\\u01c0\"+\n+\t\t\"\\u01ba\\u0001\\u0000\\u0000\\u0000\\u01c0\\u01bb\\u0001\\u0000\\u0000\\u0000\\u01c0\"+\n+\t\t\"\\u01bd\\u0001\\u0000\\u0000\\u0000\\u01c0\\u01bf\\u0001\\u0000\\u0000\\u0000\\u01c1\"+\n+\t\t\"w\\u0001\\u0000\\u0000\\u0000#\\u0000\\u0001\\u0002\\u0003}\\u007f\\u008d\\u008f\"+\n+\t\t\"\\u00a8\\u00ad\\u00af\\u00b5\\u00bf\\u00ca\\u00cf\\u00d3\\u00df\\u00e5\\u00f9\\u0100\"+\n+\t\t\"\\u0106\\u010a\\u010f\\u0115\\u0117\\u011b\\u0120\\u012b\\u013a\\u0183\\u018f\\u019e\"+\n+\t\t\"\\u01a0\\u01b6\\u01c0\\u0010\\u0001\\u0004\\u0000\\u0001\\u0005\\u0001\\u0000\\u0001\"+\n+\t\t\"\\u0000\\u0005\\u0001\\u0000\\u0005\\u0002\\u0000\\u00010\\u0002\\u0005\\u0000\\u0000\"+\n+\t\t\"\\u0007\\u000f\\u0000\\u0004\\u0000\\u0000\\u0007\\f\\u0000\\u0002\\u0003\\u0000\\u0001\"+\n+\t\t\"5\\u0003\\u0007\\b\\u0000\\u00017\\u0004\\u0007+\\u0000\\u00018\\u0005\";\n \tpublic static final ATN _ATN =\n \t\tnew ATNDeserializer().deserialize(_serializedATN.toCharArray());\n \tstatic {\n",
    "test_patch": "diff --git a/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclForTest.java b/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclForTest.java\nindex a6730994b79..211b33fa258 100644\n--- a/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclForTest.java\n+++ b/rewrite-hcl/src/test/java/org/openrewrite/hcl/tree/HclForTest.java\n@@ -16,6 +16,7 @@\n package org.openrewrite.hcl.tree;\n \n import org.junit.jupiter.api.Test;\n+import org.openrewrite.Issue;\n import org.openrewrite.test.RewriteTest;\n \n import static org.openrewrite.hcl.Assertions.hcl;\n@@ -74,4 +75,21 @@ void forEach() {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4857\")\n+    void commentInAFor() {\n+        rewriteRun(\n+          hcl(\n+            \"\"\"\n+              locals {\n+               a = {\n+                 # this is some super smart logic here\n+                 for i, v in [\"a\", \"b\"]: v => i\n+               }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4855",
    "pr_id": 4855,
    "issue_id": 4781,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Lombok: JavaParser fails with  StringIndexOutOfBoundsException when lombok processor is enabled\n## What version of OpenRewrite are you using?\r\n- OpenRewrite 8.41.2\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\nI haven't debugged the exact root cause yet. the issue seems to occur when annotations are added or removed in the source code. This appears to result in incorrect character positions for the cursor. \r\n(Will add more detail about the issue after debugging)\r\n\r\n```java\r\n  @Getter\r\n  @Builder\r\n  public static class Request {\r\n    @Nonnull private final List<TransportJobId> transportJobIds;\r\n    @Nullable private final UnixTimeMillis estimatedReadyAt;\r\n    @Nonnull private final RegionId regionId;\r\n    @Nonnull private final boolean wasTriggeredFromFulfillmentOrder;\r\n  }\r\n```\r\n\r\n## What did you expect to see?\r\nA valid compilation unit should be generated for the source file.\r\n\r\n## What did you see instead?\r\nA [ParseError](https://github.com/openrewrite/rewrite/blob/a98d83d698dda9971c93a0767b7f85d5866f306d/rewrite-core/src/main/java/org/openrewrite/tree/ParseError.java) instance is generated for the source file instead.\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n\r\n```\r\njava.lang.StringIndexOutOfBoundsException: begin 5327, end 5315, length 5434\r\n  java.base/java.lang.String.checkBoundsBeginEnd(String.java:3319)\r\n  java.base/java.lang.String.substring(String.java:1874)\r\n  org.openrewrite.java.isolated.ReloadableJava17ParserVisitor.visitAnnotation(ReloadableJava17ParserVisitor.java:143)\r\n  org.openrewrite.java.isolated.ReloadableJava17ParserVisitor.visitAnnotation(ReloadableJava17ParserVisitor.java:72)\r\n  com.sun.tools.javac.tree.JCTree$JCAnnotation.accept(JCTree.java:2601)\r\n  com.sun.source.util.TreePathScanner.scan(TreePathScanner.java:82)\r\n  org.openrewrite.java.isolated.ReloadableJava17ParserVisitor.convert(ReloadableJava17ParserVisitor.java:1604)\r\n  ...\r\n\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite]\r\nYes.\r\n",
    "issue_word_count": 247,
    "test_files_count": 1,
    "non_test_files_count": 14,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-8/build.gradle.kts",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8Parser.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/package-info.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/AllArgsConstructorHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/ExtensionMethodNoOpHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/HelperNoOpHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/JacksonizedNoOpHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NoArgsConstructorHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/RequiredArgsConstructorHandler.java",
      "rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java"
    ],
    "base_commit": "82b61dea078ea32a4686e91362c91ccae9a4ddef",
    "head_commit": "3f2f60b772545ec1061bfaa17071f06ca1d91b36",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4855",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4855",
    "dockerfile": "",
    "pr_merged_at": "2025-01-10T09:07:11.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\nindex a9972f1e672..8c434c84edd 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n@@ -18,7 +18,6 @@\n \n import com.sun.source.tree.*;\n import com.sun.source.util.TreePathScanner;\n-import com.sun.tools.javac.code.Attribute;\n import com.sun.tools.javac.code.Flags;\n import com.sun.tools.javac.code.Symbol;\n import com.sun.tools.javac.tree.DCTree;\n@@ -27,6 +26,7 @@\n import com.sun.tools.javac.tree.JCTree;\n import com.sun.tools.javac.tree.JCTree.*;\n import com.sun.tools.javac.util.Context;\n+import lombok.Generated;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.Cursor;\n import org.openrewrite.ExecutionContext;\n@@ -1519,9 +1519,11 @@ private J.VariableDeclarations visitVariables(List<VariableTree> nodes, Space fm\n                 // this is a lambda parameter with an inferred type expression\n                 typeExpr = null;\n             } else {\n-                boolean lombokVal = isLombokVal(node);\n+                Space space = whitespace();\n+                boolean lombokVal = source.startsWith(\"val\", cursor);\n+                cursor += 3; // skip `val` or `var`\n                 typeExpr = new J.Identifier(randomId(),\n-                        sourceBefore(lombokVal ? \"val\" : \"var\"),\n+                        space,\n                         Markers.build(singletonList(JavaVarKeyword.build())),\n                         emptyList(),\n                         lombokVal ? \"val\" : \"var\",\n@@ -1684,8 +1686,8 @@ public J visitWildcard(WildcardTree node, Space fmt) {\n     }\n \n     private static int getActualStartPosition(JCTree t) {\n-        // not sure if this is a bug in Lombok, but the variable's start position is after the `val` annotation\n-        if (t instanceof JCVariableDecl && isLombokVal((JCVariableDecl) t)) {\n+        // The variable's start position in the source is wrongly after lombok's `@val` annotation\n+        if (t instanceof JCVariableDecl && isLombokGenerated(t)) {\n             return ((JCVariableDecl) t).mods.annotations.get(0).getStartPosition();\n         }\n         return t.getStartPosition();\n@@ -1861,7 +1863,7 @@ private List<JRightPadded<Statement>> convertStatements(@Nullable List<? extends\n \n         Map<Integer, List<Tree>> treesGroupedByStartPosition = new LinkedHashMap<>();\n         for (Tree t : trees) {\n-            if (isLombokGenerated(t)) {\n+            if (!(t instanceof JCVariableDecl) && isLombokGenerated(t)) {\n                 continue;\n             }\n             treesGroupedByStartPosition.computeIfAbsent(((JCTree) t).getStartPosition(), k -> new ArrayList<>(1)).add(t);\n@@ -1893,51 +1895,23 @@ private List<JRightPadded<Statement>> convertStatements(@Nullable List<? extends\n         return converted;\n     }\n \n-    private static boolean isLombokVal(JCTree.JCVariableDecl t) {\n-        if (t.sym != null && t.sym.getMetadata() != null) {\n-            for (Attribute.Compound a : t.sym.getDeclarationAttributes()) {\n-                if (\"lombok.val\".equals(a.type.toString())) {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n     private static boolean isLombokGenerated(Tree t) {\n+        Tree tree = (t instanceof JCAnnotation) ? ((JCAnnotation) t).getAnnotationType() : t;\n+\n         Symbol sym = null;\n-        if (t instanceof JCAnnotation) {\n-            t = ((JCAnnotation) t).getAnnotationType();\n-        }\n-        if (t instanceof JCIdent) {\n-            sym = ((JCIdent) t).sym;\n-        } else if (t instanceof JCTree.JCMethodDecl) {\n-            sym = ((JCMethodDecl) t).sym;\n-        } else if (t instanceof JCTree.JCClassDecl) {\n-            sym = ((JCClassDecl) t).sym;\n-        } else if (t instanceof JCTree.JCVariableDecl) {\n-            sym = ((JCVariableDecl) t).sym;\n+        if (tree instanceof JCIdent) {\n+            sym = ((JCIdent) tree).sym;\n+        } else if (tree instanceof JCTree.JCMethodDecl) {\n+            sym = ((JCMethodDecl) tree).sym;\n+        } else if (tree instanceof JCTree.JCClassDecl) {\n+            sym = ((JCClassDecl) tree).sym;\n+        } else if (tree instanceof JCTree.JCVariableDecl) {\n+            sym = ((JCVariableDecl) tree).sym;\n+            return sym != null && sym.getDeclarationAttributes().stream().anyMatch(a -> \"lombok.val\".equals(a.type.toString()));\n         }\n-        return isLombokGenerated(sym);\n-    }\n \n-    private static boolean isLombokGenerated(@Nullable Symbol sym) {\n-        if (sym == null) {\n-            return false;\n-        }\n-        // Lombok val is represented as a @lombok.val on a \"final\" modifier, neither which appear in source\n-        if (\"lombok.val\".equals(sym.getQualifiedName().toString())) {\n-            return true;\n-        }\n-        if (sym.getMetadata() == null) {\n-            return false;\n-        }\n-        for (Attribute.Compound a : sym.getDeclarationAttributes()) {\n-            if (\"lombok.Generated\".equals(a.type.toString())) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        //noinspection ConstantConditions\n+        return sym != null && (\"lombok.val\".equals(sym.getQualifiedName().toString()) || sym.getAnnotation(Generated.class) != null);\n     }\n \n     /**\n@@ -2117,7 +2091,6 @@ private ReloadableJava11ModifierResults sortedModifiersAndAnnotations(ModifiersT\n         for (int i = cursor; i < source.length(); i++) {\n             if (annotationPosTable.containsKey(i)) {\n                 JCAnnotation jcAnnotation = annotationPosTable.get(i);\n-                // Skip over lombok's \"@val\" annotation which does not actually appear in source\n                 if (isLombokGenerated(jcAnnotation.getAnnotationType())) {\n                     continue;\n                 }\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex 738a3fe7c23..90ba684cfd1 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -19,7 +19,6 @@\n import com.sun.source.doctree.DocCommentTree;\n import com.sun.source.tree.*;\n import com.sun.source.util.TreePathScanner;\n-import com.sun.tools.javac.code.Attribute;\n import com.sun.tools.javac.code.Flags;\n import com.sun.tools.javac.code.Symbol;\n import com.sun.tools.javac.tree.DocCommentTable;\n@@ -27,6 +26,7 @@\n import com.sun.tools.javac.tree.JCTree;\n import com.sun.tools.javac.tree.JCTree.*;\n import com.sun.tools.javac.util.Context;\n+import lombok.Generated;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.Cursor;\n import org.openrewrite.ExecutionContext;\n@@ -1597,9 +1597,11 @@ private J.VariableDeclarations visitVariables(List<VariableTree> nodes, Space fm\n                 // this is a lambda parameter with an inferred type expression\n                 typeExpr = null;\n             } else {\n-                boolean lombokVal = isLombokVal(node);\n+                Space space = whitespace();\n+                boolean lombokVal = source.startsWith(\"val\", cursor);\n+                cursor += 3; // skip `val` or `var`\n                 typeExpr = new J.Identifier(randomId(),\n-                        sourceBefore(lombokVal ? \"val\" : \"var\"),\n+                        space,\n                         Markers.build(singletonList(JavaVarKeyword.build())),\n                         emptyList(),\n                         lombokVal ? \"val\" : \"var\",\n@@ -1747,6 +1749,14 @@ public J visitWildcard(WildcardTree node, Space fmt) {\n         }\n     }\n \n+    private static int getActualStartPosition(JCTree t) {\n+        // The variable's start position in the source is wrongly after lombok's `@val` annotation\n+        if (t instanceof JCVariableDecl && isLombokGenerated(t)) {\n+            return ((JCVariableDecl) t).mods.annotations.get(0).getStartPosition();\n+        }\n+        return t.getStartPosition();\n+    }\n+\n     private void reportJavaParsingException(Throwable ex) {\n         // this SHOULD never happen, but is here simply as a diagnostic measure in the event of unexpected exceptions\n         StringBuilder message = new StringBuilder(\"Failed to convert for the following cursor stack:\");\n@@ -1771,14 +1781,6 @@ private void reportJavaParsingException(Throwable ex) {\n         ctx.getOnError().accept(new JavaParsingException(message.toString(), ex));\n     }\n \n-    private static int getActualStartPosition(JCTree t) {\n-        // not sure if this is a bug in Lombok, but the variable's start position is after the `val` annotation\n-        if (t instanceof JCVariableDecl && isLombokVal((JCVariableDecl) t)) {\n-            return ((JCVariableDecl) t).mods.annotations.get(0).getStartPosition();\n-        }\n-        return t.getStartPosition();\n-    }\n-\n     private <J2 extends @Nullable J> @Nullable JRightPadded<J2> convert(@Nullable Tree t, Function<Tree, Space> suffix) {\n         return convert(t, suffix, j -> Markers.EMPTY);\n     }\n@@ -1942,7 +1944,7 @@ private List<JRightPadded<Statement>> convertStatements(@Nullable List<? extends\n \n         Map<Integer, List<Tree>> treesGroupedByStartPosition = new LinkedHashMap<>();\n         for (Tree t : trees) {\n-            if (isLombokGenerated(t)) {\n+            if (!(t instanceof JCVariableDecl) && isLombokGenerated(t)) {\n                 continue;\n             }\n             treesGroupedByStartPosition.computeIfAbsent(((JCTree) t).getStartPosition(), k -> new ArrayList<>(1)).add(t);\n@@ -1974,51 +1976,23 @@ private List<JRightPadded<Statement>> convertStatements(@Nullable List<? extends\n         return converted;\n     }\n \n-    private static boolean isLombokVal(JCTree.JCVariableDecl t) {\n-        if (t.sym != null && t.sym.getMetadata() != null) {\n-            for (Attribute.Compound a : t.sym.getDeclarationAttributes()) {\n-                if (\"lombok.val\".equals(a.type.toString())) {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n     private static boolean isLombokGenerated(Tree t) {\n+        Tree tree = (t instanceof JCAnnotation) ? ((JCAnnotation) t).getAnnotationType() : t;\n+\n         Symbol sym = null;\n-        if (t instanceof JCAnnotation) {\n-            t = ((JCAnnotation) t).getAnnotationType();\n-        }\n-        if (t instanceof JCIdent) {\n-            sym = ((JCIdent) t).sym;\n-        } else if (t instanceof JCTree.JCMethodDecl) {\n-            sym = ((JCMethodDecl) t).sym;\n-        } else if (t instanceof JCTree.JCClassDecl) {\n-            sym = ((JCClassDecl) t).sym;\n-        } else if (t instanceof JCTree.JCVariableDecl) {\n-            sym = ((JCVariableDecl) t).sym;\n+        if (tree instanceof JCIdent) {\n+            sym = ((JCIdent) tree).sym;\n+        } else if (tree instanceof JCTree.JCMethodDecl) {\n+            sym = ((JCMethodDecl) tree).sym;\n+        } else if (tree instanceof JCTree.JCClassDecl) {\n+            sym = ((JCClassDecl) tree).sym;\n+        } else if (tree instanceof JCTree.JCVariableDecl) {\n+            sym = ((JCVariableDecl) tree).sym;\n+            return sym != null && sym.getDeclarationAttributes().stream().anyMatch(a -> \"lombok.val\".equals(a.type.toString()));\n         }\n-        return isLombokGenerated(sym);\n-    }\n \n-    private static boolean isLombokGenerated(@Nullable Symbol sym) {\n-        if (sym == null) {\n-            return false;\n-        }\n-        // Lombok val is represented as a @lombok.val on a \"final\" modifier, neither which appear in source\n-        if (\"lombok.val\".equals(sym.getQualifiedName().toString())) {\n-            return true;\n-        }\n-        if (sym.getMetadata() == null) {\n-            return false;\n-        }\n-        for (Attribute.Compound a : sym.getDeclarationAttributes()) {\n-            if (\"lombok.Generated\".equals(a.type.toString())) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        //noinspection ConstantConditions\n+        return sym != null && (\"lombok.val\".equals(sym.getQualifiedName().toString()) || sym.getAnnotation(Generated.class) != null);\n     }\n \n     /**\n@@ -2199,7 +2173,6 @@ private ReloadableJava17ModifierResults sortedModifiersAndAnnotations(ModifiersT\n         for (int i = cursor; i < source.length(); i++) {\n             if (annotationPosTable.containsKey(i)) {\n                 JCAnnotation jcAnnotation = annotationPosTable.get(i);\n-                // Skip over lombok's \"@val\" annotation which does not actually appear in source\n                 if (isLombokGenerated(jcAnnotation.getAnnotationType())) {\n                     continue;\n                 }\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex b49c1f1563a..da4ad8b8acd 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -19,7 +19,6 @@\n import com.sun.source.doctree.DocCommentTree;\n import com.sun.source.tree.*;\n import com.sun.source.util.TreePathScanner;\n-import com.sun.tools.javac.code.Attribute;\n import com.sun.tools.javac.code.Flags;\n import com.sun.tools.javac.code.Symbol;\n import com.sun.tools.javac.tree.DocCommentTable;\n@@ -27,6 +26,7 @@\n import com.sun.tools.javac.tree.JCTree;\n import com.sun.tools.javac.tree.JCTree.*;\n import com.sun.tools.javac.util.Context;\n+import lombok.Generated;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.Cursor;\n import org.openrewrite.ExecutionContext;\n@@ -1597,9 +1597,11 @@ private J.VariableDeclarations visitVariables(List<VariableTree> nodes, Space fm\n                 // this is a lambda parameter with an inferred type expression\n                 typeExpr = null;\n             } else {\n-                boolean lombokVal = isLombokVal(node);\n+                Space space = whitespace();\n+                boolean lombokVal = source.startsWith(\"val\", cursor);\n+                cursor += 3; // skip `val` or `var`\n                 typeExpr = new J.Identifier(randomId(),\n-                        sourceBefore(lombokVal ? \"val\" : \"var\"),\n+                        space,\n                         Markers.build(singletonList(JavaVarKeyword.build())),\n                         emptyList(),\n                         lombokVal ? \"val\" : \"var\",\n@@ -1747,6 +1749,14 @@ public J visitWildcard(WildcardTree node, Space fmt) {\n         }\n     }\n \n+    private static int getActualStartPosition(JCTree t) {\n+        // The variable's start position in the source is wrongly after lombok's `@val` annotation\n+        if (t instanceof JCVariableDecl && isLombokGenerated(t)) {\n+            return ((JCVariableDecl) t).mods.annotations.get(0).getStartPosition();\n+        }\n+        return t.getStartPosition();\n+    }\n+\n     private void reportJavaParsingException(Throwable ex) {\n         // this SHOULD never happen, but is here simply as a diagnostic measure in the event of unexpected exceptions\n         StringBuilder message = new StringBuilder(\"Failed to convert for the following cursor stack:\");\n@@ -1771,14 +1781,6 @@ private void reportJavaParsingException(Throwable ex) {\n         ctx.getOnError().accept(new JavaParsingException(message.toString(), ex));\n     }\n \n-    private static int getActualStartPosition(JCTree t) {\n-        // not sure if this is a bug in Lombok, but the variable's start position is after the `val` annotation\n-        if (t instanceof JCVariableDecl && isLombokVal((JCVariableDecl) t)) {\n-            return ((JCVariableDecl) t).mods.annotations.get(0).getStartPosition();\n-        }\n-        return t.getStartPosition();\n-    }\n-\n     private <J2 extends @Nullable J> @Nullable JRightPadded<J2> convert(@Nullable Tree t, Function<Tree, Space> suffix) {\n         return convert(t, suffix, j -> Markers.EMPTY);\n     }\n@@ -1942,7 +1944,7 @@ private List<JRightPadded<Statement>> convertStatements(@Nullable List<? extends\n \n         Map<Integer, List<Tree>> treesGroupedByStartPosition = new LinkedHashMap<>();\n         for (Tree t : trees) {\n-            if (isLombokGenerated(t)) {\n+            if (!(t instanceof JCVariableDecl) && isLombokGenerated(t)) {\n                 continue;\n             }\n             treesGroupedByStartPosition.computeIfAbsent(((JCTree) t).getStartPosition(), k -> new ArrayList<>(1)).add(t);\n@@ -1974,51 +1976,23 @@ private List<JRightPadded<Statement>> convertStatements(@Nullable List<? extends\n         return converted;\n     }\n \n-    private static boolean isLombokVal(JCTree.JCVariableDecl t) {\n-        if (t.sym != null && t.sym.getMetadata() != null) {\n-            for (Attribute.Compound a : t.sym.getDeclarationAttributes()) {\n-                if (\"lombok.val\".equals(a.type.toString())) {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n     private static boolean isLombokGenerated(Tree t) {\n+        Tree tree = (t instanceof JCAnnotation) ? ((JCAnnotation) t).getAnnotationType() : t;\n+\n         Symbol sym = null;\n-        if (t instanceof JCAnnotation) {\n-            t = ((JCAnnotation) t).getAnnotationType();\n-        }\n-        if (t instanceof JCIdent) {\n-            sym = ((JCIdent) t).sym;\n-        } else if (t instanceof JCTree.JCMethodDecl) {\n-            sym = ((JCMethodDecl) t).sym;\n-        } else if (t instanceof JCTree.JCClassDecl) {\n-            sym = ((JCClassDecl) t).sym;\n-        } else if (t instanceof JCTree.JCVariableDecl) {\n-            sym = ((JCVariableDecl) t).sym;\n+        if (tree instanceof JCIdent) {\n+            sym = ((JCIdent) tree).sym;\n+        } else if (tree instanceof JCTree.JCMethodDecl) {\n+            sym = ((JCMethodDecl) tree).sym;\n+        } else if (tree instanceof JCTree.JCClassDecl) {\n+            sym = ((JCClassDecl) tree).sym;\n+        } else if (tree instanceof JCTree.JCVariableDecl) {\n+            sym = ((JCVariableDecl) tree).sym;\n+            return sym != null && sym.getDeclarationAttributes().stream().anyMatch(a -> \"lombok.val\".equals(a.type.toString()));\n         }\n-        return isLombokGenerated(sym);\n-    }\n \n-    private static boolean isLombokGenerated(@Nullable Symbol sym) {\n-        if (sym == null) {\n-            return false;\n-        }\n-        // Lombok val is represented as a @lombok.val on a \"final\" modifier, neither which appear in source\n-        if (\"lombok.val\".equals(sym.getQualifiedName().toString())) {\n-            return true;\n-        }\n-        if (sym.getMetadata() == null) {\n-            return false;\n-        }\n-        for (Attribute.Compound a : sym.getDeclarationAttributes()) {\n-            if (\"lombok.Generated\".equals(a.type.toString())) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        //noinspection ConstantConditions\n+        return sym != null && (\"lombok.val\".equals(sym.getQualifiedName().toString()) || sym.getAnnotation(Generated.class) != null);\n     }\n \n     /**\n@@ -2199,7 +2173,6 @@ private ReloadableJava21ModifierResults sortedModifiersAndAnnotations(ModifiersT\n         for (int i = cursor; i < source.length(); i++) {\n             if (annotationPosTable.containsKey(i)) {\n                 JCAnnotation jcAnnotation = annotationPosTable.get(i);\n-                // Skip over lombok's \"@val\" annotation which does not actually appear in source\n                 if (isLombokGenerated(jcAnnotation.getAnnotationType())) {\n                     continue;\n                 }\n\ndiff --git a/rewrite-java-8/build.gradle.kts b/rewrite-java-8/build.gradle.kts\nindex 5f92a5f85dd..e07e976892e 100644\n--- a/rewrite-java-8/build.gradle.kts\n+++ b/rewrite-java-8/build.gradle.kts\n@@ -17,6 +17,7 @@ dependencies {\n     compileOnly(\"org.slf4j:slf4j-api:1.7.+\")\n \n     implementation(project(\":rewrite-java\"))\n+    runtimeOnly(project(\":rewrite-java-lombok\"))\n     implementation(\"org.ow2.asm:asm:latest.release\")\n \n     implementation(\"io.micrometer:micrometer-core:1.9.+\")\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8Parser.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8Parser.java\nindex de46c937d0a..bad6fc19a4d 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8Parser.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8Parser.java\n@@ -18,12 +18,12 @@\n import com.sun.tools.javac.comp.*;\n import com.sun.tools.javac.file.JavacFileManager;\n import com.sun.tools.javac.main.JavaCompiler;\n+import com.sun.tools.javac.main.Option;\n import com.sun.tools.javac.tree.JCTree;\n import com.sun.tools.javac.util.Context;\n import com.sun.tools.javac.util.Log;\n import com.sun.tools.javac.util.Options;\n-import io.micrometer.core.instrument.Metrics;\n-import io.micrometer.core.instrument.Timer;\n+import lombok.Getter;\n import org.jspecify.annotations.Nullable;\n import org.objectweb.asm.ClassReader;\n import org.objectweb.asm.ClassVisitor;\n@@ -31,7 +31,6 @@\n import org.openrewrite.ExecutionContext;\n import org.openrewrite.InMemoryExecutionContext;\n import org.openrewrite.SourceFile;\n-import org.openrewrite.internal.MetricsHelper;\n import org.openrewrite.internal.StringUtils;\n import org.openrewrite.java.internal.JavaTypeCache;\n import org.openrewrite.java.tree.J;\n@@ -40,19 +39,25 @@\n import org.openrewrite.tree.ParseError;\n import org.openrewrite.tree.ParsingEventListener;\n import org.openrewrite.tree.ParsingExecutionContextView;\n+import org.slf4j.LoggerFactory;\n \n+import javax.annotation.processing.Processor;\n import javax.tools.*;\n import java.io.*;\n+import java.lang.reflect.Constructor;\n import java.net.URI;\n+import java.net.URL;\n import java.nio.charset.Charset;\n import java.nio.file.Path;\n+import java.nio.file.Paths;\n import java.util.*;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n import java.util.stream.Stream;\n import java.util.stream.StreamSupport;\n \n+import static com.sun.tools.javac.util.List.nil;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n import static java.util.stream.Collectors.toList;\n \n class ReloadableJava8Parser implements JavaParser {\n@@ -70,6 +75,7 @@ class ReloadableJava8Parser implements JavaParser {\n     private final JavaCompiler compiler;\n     private final ResettableLog compilerLog;\n     private final Collection<NamedStyles> styles;\n+    private final List<Processor> annotationProcessors;\n \n     ReloadableJava8Parser(@Nullable Collection<Path> classpath,\n                           Collection<byte[]> classBytesClasspath,\n@@ -100,6 +106,70 @@ class ReloadableJava8Parser implements JavaParser {\n         Options.instance(context).put(\"-g\", \"-g\");\n         Options.instance(context).put(\"-proc\", \"none\");\n \n+        // Ensure type attribution continues despite errors in individual files or nodes.\n+        // If an error occurs in a single file or node, type attribution should still proceed\n+        // for all other source files and unaffected nodes within the same file.\n+        Options.instance(context).put(\"should-stop.ifError\", \"GENERATE\");\n+\n+        LOMBOK:\n+        if (System.getenv().getOrDefault(\"REWRITE_LOMBOK\", System.getProperty(\"rewrite.lombok\")) != null &&\n+            classpath != null && classpath.stream().anyMatch(it -> it.toString().contains(\"lombok\"))) {\n+            Processor lombokProcessor = null;\n+            try {\n+                // https://projectlombok.org/contributing/lombok-execution-path\n+                List<String> overrideClasspath = new ArrayList<>();\n+                for (Path part : classpath) {\n+                    if (part.toString().contains(\"lombok\")) {\n+                        overrideClasspath.add(part.toString());\n+                    }\n+                }\n+                // make sure the rewrite-java-lombok dependency comes first\n+                boolean found = false;\n+                for (int i = 0; i < overrideClasspath.size(); i++) {\n+                    if (overrideClasspath.get(i).contains(\"rewrite-java-lombok\")) {\n+                        overrideClasspath.add(0, overrideClasspath.remove(i));\n+                        found = true;\n+                    }\n+                }\n+                if (!found) {\n+                    // try to find `rewrite-java-lombok` using class loader\n+                    URL resource = getClass().getClassLoader().getResource(\"org/openrewrite/java/lombok/OpenRewriteConfigurationKeysLoader.class\");\n+                    if (resource != null && resource.getProtocol().equals(\"jar\") && resource.getPath().startsWith(\"file:\")) {\n+                        String path = Paths.get(URI.create(resource.getPath().substring(0, resource.getPath().indexOf(\"!\")))).toString();\n+                        overrideClasspath.add(0, path);\n+                    } else {\n+                        break LOMBOK;\n+                    }\n+                }\n+                System.setProperty(\"shadow.override.lombok\", String.join(File.pathSeparator, overrideClasspath));\n+\n+                Class<?> shadowLoaderClass = Class.forName(\"lombok.launch.ShadowClassLoader\", true, getClass().getClassLoader());\n+                Constructor<?> shadowLoaderConstructor = shadowLoaderClass.getDeclaredConstructor(\n+                        Class.forName(\"java.lang.ClassLoader\"),\n+                        Class.forName(\"java.lang.String\"),\n+                        Class.forName(\"java.lang.String\"),\n+                        Class.forName(\"java.util.List\"),\n+                        Class.forName(\"java.util.List\"));\n+                shadowLoaderConstructor.setAccessible(true);\n+\n+                ClassLoader lombokShadowLoader = (ClassLoader) shadowLoaderConstructor.newInstance(\n+                        getClass().getClassLoader(),\n+                        \"lombok\",\n+                        null,\n+                        emptyList(),\n+                        singletonList(\"lombok.patcher.Symbols\")\n+                );\n+                lombokProcessor = (Processor) lombokShadowLoader.loadClass(\"lombok.core.AnnotationProcessor\").getDeclaredConstructor().newInstance();\n+                Options.instance(context).put(Option.PROCESSOR, \"lombok.launch.AnnotationProcessorHider$AnnotationProcessor\");\n+            } catch (ReflectiveOperationException ignore) {\n+                // Lombok was not found or could not be initialized\n+            } finally {\n+                annotationProcessors = lombokProcessor != null ? singletonList(lombokProcessor) : emptyList();\n+            }\n+        } else {\n+            annotationProcessors = emptyList();\n+        }\n+\n         // MUST be created (registered with the context) after pfm and compilerLog\n         compiler = new JavaCompiler(context);\n \n@@ -118,7 +188,7 @@ public void write(char[] cbuf, int off, int len) {\n                 if (logCompilationWarningsAndErrors) {\n                     String log = new String(Arrays.copyOfRange(cbuf, off, len));\n                     if (!StringUtils.isBlank(log)) {\n-                        org.slf4j.LoggerFactory.getLogger(ReloadableJava8Parser.class).warn(log);\n+                        LoggerFactory.getLogger(ReloadableJava8Parser.class).warn(log);\n                     }\n                 }\n             }\n@@ -138,45 +208,7 @@ public void close() {\n     @Override\n     public Stream<SourceFile> parseInputs(Iterable<Input> sourceFiles, @Nullable Path relativeTo, ExecutionContext ctx) {\n         ParsingEventListener parsingListener = ParsingExecutionContextView.view(ctx).getParsingListener();\n-        if (classpath != null) { // override classpath\n-            if (context.get(JavaFileManager.class) != pfm) {\n-                throw new IllegalStateException(\"JavaFileManager has been forked unexpectedly\");\n-            }\n-\n-            try {\n-                pfm.setLocation(StandardLocation.CLASS_PATH, classpath.stream().map(Path::toFile).collect(toList()));\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        }\n-\n-        @SuppressWarnings(\"ConstantConditions\") LinkedHashMap<Input, JCTree.JCCompilationUnit> cus = acceptedInputs(sourceFiles)\n-                .collect(Collectors.toMap(\n-                        Function.identity(),\n-                        input -> {\n-                            try {\n-                                return compiler.parse(new Java8ParserInputFileObject(input, ctx));\n-                            } catch (IllegalStateException e) {\n-                                if (\"endPosTable already set\".equals(e.getMessage())) {\n-                                    throw new IllegalStateException(\n-                                            \"Call reset() on JavaParser before parsing another set of source files that \" +\n-                                            \"have some of the same fully qualified names. Source file [\" +\n-                                            input.getPath() + \"]\\n[\\n\" + StringUtils.readFully(input.getSource(ctx), getCharset(ctx)) + \"\\n]\", e);\n-                                }\n-                                throw e;\n-                            }\n-                        },\n-                        (e2, e1) -> e1, LinkedHashMap::new));\n-\n-        try {\n-            enterAll(cus.values());\n-            compiler.attribute(new TimedTodo(compiler.todo));\n-        } catch (Throwable t) {\n-            // when symbol entering fails on problems like missing types, attribution can often times proceed\n-            // unhindered, but it sometimes cannot (so attribution is always a BEST EFFORT in the presence of errors)\n-            ctx.getOnError().accept(new JavaParsingException(\"Failed symbol entering or attribution\", t));\n-        }\n-\n+        LinkedHashMap<Input, JCTree.JCCompilationUnit> cus = parseInputsToCompilerAst(sourceFiles, ctx);\n         return cus.entrySet().stream().map(cuByPath -> {\n             Input input = cuByPath.getKey();\n             parsingListener.startedParsing(input);\n@@ -190,6 +222,7 @@ public Stream<SourceFile> parseInputs(Iterable<Input> sourceFiles, @Nullable Pat\n                         ctx,\n                         context);\n                 J.CompilationUnit cu = (J.CompilationUnit) parser.scan(cuByPath.getValue(), Space.EMPTY);\n+                //noinspection DataFlowIssue\n                 cuByPath.setValue(null); // allow memory used by this JCCompilationUnit to be released\n                 parsingListener.parsed(input, cu);\n                 return requirePrintEqualsInput(cu, input, relativeTo, ctx);\n@@ -200,6 +233,53 @@ public Stream<SourceFile> parseInputs(Iterable<Input> sourceFiles, @Nullable Pat\n         });\n     }\n \n+    LinkedHashMap<Input, JCTree.JCCompilationUnit> parseInputsToCompilerAst(Iterable<Input> sourceFiles, ExecutionContext ctx) {\n+        if (classpath != null) { // override classpath\n+            if (context.get(JavaFileManager.class) != pfm) {\n+                throw new IllegalStateException(\"JavaFileManager has been forked unexpectedly\");\n+            }\n+\n+            try {\n+                pfm.setLocation(StandardLocation.CLASS_PATH, classpath.stream().map(Path::toFile).collect(toList()));\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+\n+        LinkedHashMap<Input, JCTree.JCCompilationUnit> cus = new LinkedHashMap<>();\n+        List<Java8ParserInputFileObject> inputFileObjects = acceptedInputs(sourceFiles)\n+                .map(input -> new Java8ParserInputFileObject(input, ctx))\n+                .collect(toList());\n+        if (!annotationProcessors.isEmpty()) {\n+            compiler.initProcessAnnotations(annotationProcessors);\n+        }\n+        try {\n+            //noinspection unchecked\n+            com.sun.tools.javac.util.List<JCTree.JCCompilationUnit> jcCompilationUnits = compiler.parseFiles((List<JavaFileObject>) (List<?>) inputFileObjects);\n+            for (int i = 0; i < inputFileObjects.size(); i++) {\n+                cus.put(inputFileObjects.get(i).getInput(), jcCompilationUnits.get(i));\n+            }\n+            try {\n+                enterAll(cus.values());\n+                JavaCompiler delegate = annotationProcessors.isEmpty() ? compiler : compiler.processAnnotations(jcCompilationUnits, nil());\n+                delegate.attribute(delegate.todo);\n+            } catch (Throwable t) {\n+                // when symbol entering fails on problems like missing types, attribution can often times proceed\n+                // unhindered, but it sometimes cannot (so attribution is always best-effort in the presence of errors)\n+                ctx.getOnError().accept(new JavaParsingException(\"Failed symbol entering or attribution\", t));\n+            }\n+        } catch (IllegalStateException e) {\n+            if (\"endPosTable already set\".equals(e.getMessage())) {\n+                throw new IllegalStateException(\n+                        \"Call reset() on JavaParser before parsing another set of source files that \" +\n+                                \"have some of the same fully qualified names.\", e);\n+            }\n+            throw e;\n+        }\n+\n+        return cus;\n+    }\n+\n     @Override\n     public ReloadableJava8Parser reset() {\n         typeCache.clear();\n@@ -261,35 +341,6 @@ public void reset(Collection<URI> uris) {\n         }\n     }\n \n-    private static class TimedTodo extends Todo {\n-        private final Todo todo;\n-        private Timer.@Nullable Sample sample;\n-\n-        private TimedTodo(Todo todo) {\n-            super(new Context());\n-            this.todo = todo;\n-        }\n-\n-        @Override\n-        public boolean isEmpty() {\n-            if (sample != null) {\n-                sample.stop(MetricsHelper.successTags(\n-                                Timer.builder(\"rewrite.parse\")\n-                                        .description(\"The time spent by the JDK in type attributing the source file\")\n-                                        .tag(\"file.type\", \"Java\")\n-                                        .tag(\"step\", \"(2) Type attribution\"))\n-                        .register(Metrics.globalRegistry));\n-            }\n-            return todo.isEmpty();\n-        }\n-\n-        @Override\n-        public Env<AttrContext> remove() {\n-            this.sample = Timer.start();\n-            return todo.remove();\n-        }\n-    }\n-\n     private static class ByteArrayCapableJavacFileManager extends JavacFileManager {\n         private final List<PackageAwareJavaFileObject> classByteClasspath;\n \n@@ -332,6 +383,7 @@ public Iterable<JavaFileObject> list(Location location, String packageName, Set<\n \n     private static class PackageAwareJavaFileObject extends SimpleJavaFileObject {\n         private final String pkg;\n+        @Getter\n         private final String className;\n         private final byte[] classBytes;\n \n@@ -365,10 +417,6 @@ public String getPackage() {\n             return pkg;\n         }\n \n-        public String getClassName() {\n-            return className;\n-        }\n-\n         @Override\n         public InputStream openInputStream() {\n             return new ByteArrayInputStream(classBytes);\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\nindex 6b944cff74a..0d6cf8309fc 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n@@ -25,6 +25,7 @@\n import com.sun.tools.javac.tree.JCTree;\n import com.sun.tools.javac.tree.JCTree.*;\n import com.sun.tools.javac.util.Context;\n+import lombok.Generated;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.Cursor;\n import org.openrewrite.ExecutionContext;\n@@ -33,7 +34,6 @@\n import org.openrewrite.internal.EncodingDetectingInputStream;\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.java.internal.JavaTypeCache;\n-import org.openrewrite.java.JavaPrinter;\n import org.openrewrite.java.marker.OmitParentheses;\n import org.openrewrite.java.marker.TrailingComma;\n import org.openrewrite.java.tree.*;\n@@ -339,7 +339,7 @@ public J visitCase(CaseTree node, Space fmt) {\n                         node.getExpression() == null ? EMPTY : sourceBefore(\"case\"),\n                         singletonList(node.getExpression() == null ?\n                                 JRightPadded.build(new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), skip(\"default\"), null, null)) :\n-                                JRightPadded.build(convertOrNull(node.getExpression()))\n+                                JRightPadded.build(convert(node.getExpression()))\n                         ),\n                         Markers.EMPTY\n                 ),\n@@ -391,7 +391,7 @@ public J visitClass(ClassTree node, Space fmt) {\n                 Markers.EMPTY);\n \n         JLeftPadded<TypeTree> extendings = node.getExtendsClause() == null ? null :\n-                padLeft(sourceBefore(\"extends\"), convertOrNull(node.getExtendsClause()));\n+                padLeft(sourceBefore(\"extends\"), convert(node.getExtendsClause()));\n \n         JContainer<TypeTree> implementings = null;\n         if (node.getImplementsClause() != null && !node.getImplementsClause().isEmpty()) {\n@@ -659,7 +659,7 @@ public J visitForLoop(ForLoopTree node, Space fmt) {\n                                 commaDelim.apply(t)\n                 );\n \n-        JRightPadded<Expression> condition = convertOrNull(node.getCondition(), semiDelim);\n+        JRightPadded<Expression> condition = convert(node.getCondition(), semiDelim);\n         if (condition == null) {\n             condition = padRight(new J.Empty(randomId(), sourceBefore(\";\"), Markers.EMPTY), EMPTY);\n         }\n@@ -927,7 +927,7 @@ public J visitMethod(MethodTree node, Space fmt) {\n         }\n \n         List<J.Annotation> returnTypeAnnotations = collectAnnotations(annotationPosTable);\n-        TypeTree returnType = convertOrNull(node.getReturnType());\n+        TypeTree returnType = convert(node.getReturnType());\n         if (returnType != null && !returnTypeAnnotations.isEmpty()) {\n             returnType = new J.AnnotatedType(randomId(), Space.EMPTY, Markers.EMPTY,\n                     returnTypeAnnotations, returnType);\n@@ -970,7 +970,7 @@ public J visitMethod(MethodTree node, Space fmt) {\n                 JContainer.build(sourceBefore(\"throws\"), convertAll(node.getThrows(), commaDelim, noDelim),\n                         Markers.EMPTY);\n \n-        J.Block body = convertOrNull(node.getBody());\n+        J.Block body = convert(node.getBody());\n \n         JLeftPadded<Expression> defaultValue = node.getDefaultValue() == null ? null :\n                 padLeft(sourceBefore(\"default\"), convert(node.getDefaultValue()));\n@@ -994,9 +994,9 @@ public J visitNewArray(NewArrayTree node, Space fmt) {\n             while (elementType instanceof JCArrayTypeTree) {\n                 elementType = ((JCArrayTypeTree) elementType).elemtype;\n             }\n-            typeExpr = convertOrNull(elementType);\n+            typeExpr = convert(elementType);\n         } else {\n-            typeExpr = convertOrNull(jcVarType);\n+            typeExpr = convert(jcVarType);\n         }\n \n         List<? extends ExpressionTree> nodeDimensions = node.getDimensions();\n@@ -1053,7 +1053,7 @@ public J visitNewClass(NewClassTree node, Space fmt) {\n         }\n \n         // for enum definitions with anonymous class initializers, endPos of node identifier will be -1\n-        TypeTree clazz = endPos(node.getIdentifier()) >= 0 ? convertOrNull(node.getIdentifier()) : null;\n+        TypeTree clazz = endPos(node.getIdentifier()) >= 0 ? convert(node.getIdentifier()) : null;\n \n         JContainer<Expression> args;\n         if (positionOfNext(\"(\", '{') > -1) {\n@@ -1161,7 +1161,8 @@ public J visitPrimitiveType(PrimitiveTypeTree node, Space fmt) {\n     @Override\n     public J visitReturn(ReturnTree node, Space fmt) {\n         skip(\"return\");\n-        return new J.Return(randomId(), fmt, Markers.EMPTY, convertOrNull(node.getExpression()));\n+        Expression expression = convert(node.getExpression());\n+        return new J.Return(randomId(), fmt, Markers.EMPTY, expression);\n     }\n \n     @Override\n@@ -1506,6 +1507,17 @@ private J.VariableDeclarations visitVariables(List<VariableTree> nodes, Space fm\n         TypeTree typeExpr;\n         if (vartype == null || endPos(vartype) < 0 || vartype instanceof JCErroneous) {\n             typeExpr = null; // this is a lambda parameter with an inferred type expression\n+        } else if (isLombokGenerated(node)) {\n+            Space space = whitespace();\n+            boolean lombokVal = source.startsWith(\"val\", cursor);\n+            cursor += 3; // skip `val` or `var`\n+            typeExpr = new J.Identifier(randomId(),\n+                    space,\n+                    Markers.build(singletonList(JavaVarKeyword.build())),\n+                    emptyList(),\n+                    lombokVal ? \"val\" : \"var\",\n+                    typeMapping.type(vartype),\n+                    null);\n         } else if (vartype instanceof JCArrayTypeTree) {\n             JCExpression elementType = vartype;\n             while (elementType instanceof JCArrayTypeTree || elementType instanceof JCAnnotatedType) {\n@@ -1542,10 +1554,9 @@ private J.VariableDeclarations visitVariables(List<VariableTree> nodes, Space fm\n \n         List<JRightPadded<J.VariableDeclarations.NamedVariable>> vars = new ArrayList<>(nodes.size());\n         for (int i = 0; i < nodes.size(); i++) {\n-            VariableTree n = nodes.get(i);\n+            JCVariableDecl n = (JCVariableDecl) nodes.get(i);\n \n             Space namedVarPrefix = sourceBefore(n.getName().toString());\n-            JCVariableDecl vd = (JCVariableDecl) n;\n \n             JavaType type = typeMapping.type(n);\n             J.Identifier name = new J.Identifier(randomId(), EMPTY, Markers.EMPTY, emptyList(), n.getName().toString(),\n@@ -1558,7 +1569,7 @@ private J.VariableDeclarations visitVariables(List<VariableTree> nodes, Space fm\n                             new J.VariableDeclarations.NamedVariable(randomId(), namedVarPrefix, Markers.EMPTY,\n                                     name,\n                                     dimensionsAfterName,\n-                                    vd.init != null ? padLeft(sourceBefore(\"=\"), convertOrNull(vd.init)) : null,\n+                                    n.init != null ? padLeft(sourceBefore(\"=\"), convert(n.init)) : null,\n                                     (JavaType.Variable) typeMapping.type(n)\n                             ),\n                             i == nodes.size() - 1 ? EMPTY : sourceBefore(\",\")\n@@ -1615,7 +1626,7 @@ public J visitWildcard(WildcardTree node, Space fmt) {\n                 bound = null;\n         }\n \n-        return new J.Wildcard(randomId(), fmt, Markers.EMPTY, bound, convertOrNull(wildcard.inner));\n+        return new J.Wildcard(randomId(), fmt, Markers.EMPTY, bound, convert(wildcard.inner));\n     }\n \n     /**\n@@ -1623,9 +1634,12 @@ public J visitWildcard(WildcardTree node, Space fmt) {\n      * Conversion utilities\n      * --------------\n      */\n-    private <J2 extends J> J2 convert(Tree t) {\n+    private <J2 extends J> @Nullable J2 convert(@Nullable Tree t) {\n+        if (t == null) {\n+            return null;\n+        }\n         try {\n-            String prefix = source.substring(cursor, max(((JCTree) t).getStartPosition(), cursor));\n+            String prefix = source.substring(cursor, Math.max(cursor, getActualStartPosition((JCTree) t)));\n             cursor += prefix.length();\n             @SuppressWarnings(\"unchecked\") J2 j = (J2) scan(t, formatWithCommentTree(prefix, (JCTree) t, docCommentTable.getCommentTree((JCTree) t)));\n             return j;\n@@ -1655,11 +1669,25 @@ private <J2 extends J> J2 convert(Tree t) {\n         }\n     }\n \n-    private <J2 extends J> JRightPadded<J2> convert(Tree t, Function<Tree, Space> suffix) {\n+    private static int getActualStartPosition(JCTree t) {\n+        // not sure if this is a bug in Lombok, but the variable's start position is after the `val` annotation\n+        if (t instanceof JCVariableDecl && isLombokGenerated(t)) {\n+            return ((JCVariableDecl) t).mods.annotations.get(0).getStartPosition();\n+        }\n+        return t.getStartPosition();\n+    }\n+\n+    private <J2 extends @Nullable J> @Nullable JRightPadded<J2> convert(@Nullable Tree t, Function<Tree, Space> suffix) {\n+        if (t == null) {\n+            return null;\n+        }\n         return convert(t, suffix, j -> Markers.EMPTY);\n     }\n \n-    private <J2 extends J> JRightPadded<J2> convert(Tree t, Function<Tree, Space> suffix, Function<Tree, Markers> markers) {\n+    private <J2 extends @Nullable J> @Nullable JRightPadded<J2> convert(@Nullable Tree t, Function<Tree, Space> suffix, Function<Tree, Markers> markers) {\n+        if (t == null) {\n+            return null;\n+        }\n         J2 j = convert(t);\n         @SuppressWarnings(\"ConstantConditions\") JRightPadded<J2> rightPadded = j == null ? null :\n                 new JRightPadded<>(j, suffix.apply(t), markers.apply(t));\n@@ -1710,14 +1738,6 @@ private long lineNumber(Tree tree) {\n         return lineNumber;\n     }\n \n-    private <T extends J> @Nullable T convertOrNull(@Nullable Tree t) {\n-        return t == null ? null : convert(t);\n-    }\n-\n-    private <J2 extends J> @Nullable JRightPadded<J2> convertOrNull(@Nullable Tree t, Function<Tree, Space> suffix) {\n-        return t == null ? null : convert(t, suffix);\n-    }\n-\n     private <J2 extends J> List<J2> convertAll(List<? extends Tree> trees) {\n         List<J2> converted = new ArrayList<>(trees.size());\n         for (Tree tree : trees) {\n@@ -1836,6 +1856,9 @@ private List<JRightPadded<Statement>> convertStatements(@Nullable List<? extends\n \n         Map<Integer, List<Tree>> treesGroupedByStartPosition = new LinkedHashMap<>();\n         for (Tree t : trees) {\n+            if (!(t instanceof JCVariableDecl) && isLombokGenerated(t)) {\n+                continue;\n+            }\n             treesGroupedByStartPosition.computeIfAbsent(((JCTree) t).getStartPosition(), k -> new ArrayList<>(1)).add(t);\n         }\n \n@@ -1865,6 +1888,32 @@ private List<JRightPadded<Statement>> convertStatements(@Nullable List<? extends\n         return converted;\n     }\n \n+    private static boolean isLombokGenerated(Tree t) {\n+        Tree tree = (t instanceof JCAnnotation) ? ((JCAnnotation) t).getAnnotationType() : t;\n+\n+        Symbol sym = null;\n+        if (tree instanceof JCIdent) {\n+            sym = ((JCIdent) tree).sym;\n+        } else if (tree instanceof JCTree.JCMethodDecl) {\n+            sym = ((JCMethodDecl) tree).sym;\n+            if (sym == null) {\n+                // In java 8 code, a JCMethodDecl does not always have a symbol, so check the possible @Generated annotation directly\n+                return ((JCMethodDecl) tree).getModifiers().getAnnotations().stream().anyMatch(a -> \"@lombok.Generated()\".equals(a.toString()));\n+            }\n+        } else if (tree instanceof JCTree.JCClassDecl) {\n+            sym = ((JCClassDecl) tree).sym;\n+        } else if (tree instanceof JCTree.JCVariableDecl) {\n+            sym = ((JCVariableDecl) tree).sym;\n+            return sym != null && sym.getDeclarationAttributes().stream().anyMatch(a -> \"lombok.val\".equals(a.type.toString()) || \"lombok.var\".equals(a.type.toString()));\n+        }\n+\n+        //noinspection ConstantConditions\n+        return sym != null && (\n+                \"lombok.val\".equals(sym.getQualifiedName().toString()) || \"lombok.var\".equals(sym.getQualifiedName().toString()) ||\n+                sym.getAnnotation(Generated.class) != null\n+        );\n+    }\n+\n     /**\n      * --------------\n      * Other convenience utilities\n@@ -2040,13 +2089,17 @@ private Java8ModifierResults sortedModifiersAndAnnotations(ModifiersTree modifie\n         int lastAnnotationPosition = cursor;\n         for (int i = cursor; i < source.length(); i++) {\n             if (annotationPosTable.containsKey(i)) {\n-                J.Annotation annotation = convert(annotationPosTable.get(i));\n+                JCAnnotation jcAnnotation = annotationPosTable.get(i);\n+                if (isLombokGenerated(jcAnnotation.getAnnotationType())) {\n+                    continue;\n+                }\n+                J.Annotation annotation = convert(jcAnnotation);\n                 if (afterFirstModifier) {\n                     currentAnnotations.add(annotation);\n                 } else {\n                     leadingAnnotations.add(annotation);\n                 }\n-                i = cursor -1;\n+                i = cursor - 1;\n                 lastAnnotationPosition = cursor;\n                 continue;\n             }\n@@ -2160,7 +2213,11 @@ private List<J.Annotation> collectAnnotations(Map<Integer, JCAnnotation> annotat\n         boolean inMultilineComment = false;\n         for (int i = cursor; i <= maxAnnotationPosition && i < source.length(); i++) {\n             if (annotationPosTable.containsKey(i)) {\n-                annotations.add(convert(annotationPosTable.get(i)));\n+                JCAnnotation jcAnnotation = annotationPosTable.get(i);\n+                if (isLombokGenerated(jcAnnotation)) {\n+                    continue;\n+                }\n+                annotations.add(convert(jcAnnotation));\n                 i = cursor;\n                 continue;\n             }\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/package-info.java b/rewrite-java-8/src/main/java/org/openrewrite/java/package-info.java\nnew file mode 100644\nindex 00000000000..e697a3e66c4\n--- /dev/null\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/package-info.java\n@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+@NullMarked\n+@NonNullFields\n+package org.openrewrite.java;\n+\n+import org.jspecify.annotations.NullMarked;\n+import org.openrewrite.internal.lang.NonNullFields;\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/AllArgsConstructorHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/AllArgsConstructorHandler.java\nindex b629bee724a..b4b04d39c1d 100644\n--- a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/AllArgsConstructorHandler.java\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/AllArgsConstructorHandler.java\n@@ -40,7 +40,6 @@ public void handle(AnnotationValues<AllArgsConstructor> annotationValues, JCTree\n                     JCTree.JCIdent ident = (JCTree.JCIdent) assign.getVariable();\n                     String name = ident.getName().toString();\n                     if (name.equals(\"onConstructor\") || name.equals(\"onConstructor_\")) {\n-                        // In Java 1.8+ the parameter is `onConstructor_`\n                         continue;\n                     }\n                 }\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/ExtensionMethodHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/ExtensionMethodNoOpHandler.java\nsimilarity index 91%\nrename from rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/ExtensionMethodHandler.java\nrename to rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/ExtensionMethodNoOpHandler.java\nindex 68b5543da96..dbc6be1dcf4 100644\n--- a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/ExtensionMethodHandler.java\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/ExtensionMethodNoOpHandler.java\n@@ -21,7 +21,7 @@\n import lombok.javac.JavacAnnotationHandler;\n import lombok.javac.JavacNode;\n \n-public class ExtensionMethodHandler extends JavacAnnotationHandler<ExtensionMethod> {\n+public class ExtensionMethodNoOpHandler extends JavacAnnotationHandler<ExtensionMethod> {\n     @Override\n     public void handle(AnnotationValues<ExtensionMethod> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n     }\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/HelperHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/HelperNoOpHandler.java\nsimilarity index 93%\nrename from rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/HelperHandler.java\nrename to rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/HelperNoOpHandler.java\nindex d1ef2b9fa59..6b7a1be1085 100644\n--- a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/HelperHandler.java\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/HelperNoOpHandler.java\n@@ -21,7 +21,7 @@\n import lombok.javac.JavacAnnotationHandler;\n import lombok.javac.JavacNode;\n \n-public class HelperHandler extends JavacAnnotationHandler<Helper> {\n+public class HelperNoOpHandler extends JavacAnnotationHandler<Helper> {\n     @Override\n     public void handle(AnnotationValues<Helper> annotation, JCTree.JCAnnotation ast, JavacNode annotationNode) {\n     }\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/JacksonizedHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/JacksonizedNoOpHandler.java\nsimilarity index 93%\nrename from rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/JacksonizedHandler.java\nrename to rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/JacksonizedNoOpHandler.java\nindex a9ce02cd671..bd66517d6ff 100644\n--- a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/JacksonizedHandler.java\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/JacksonizedNoOpHandler.java\n@@ -24,7 +24,7 @@\n \n @SuppressWarnings(\"SpellCheckingInspection\")\n @HandlerPriority(-512)\n-public class JacksonizedHandler extends JavacAnnotationHandler<Jacksonized> {\n+public class JacksonizedNoOpHandler extends JavacAnnotationHandler<Jacksonized> {\n     @Override\n     public void handle(AnnotationValues<Jacksonized> annotation, JCTree.JCAnnotation ast, JavacNode annotationNode) {\n     }\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NoArgsConstructorHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NoArgsConstructorHandler.java\nindex b5942688f46..1acfcfb96a1 100644\n--- a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NoArgsConstructorHandler.java\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NoArgsConstructorHandler.java\n@@ -38,7 +38,8 @@ public void handle(AnnotationValues<NoArgsConstructor> annotationValues, JCTree.\n                 if (originalArg instanceof JCTree.JCAssign && ((JCTree.JCAssign) originalArg).getVariable() instanceof JCTree.JCIdent) {\n                     JCTree.JCAssign assign = (JCTree.JCAssign) originalArg;\n                     JCTree.JCIdent ident = (JCTree.JCIdent) assign.getVariable();\n-                    if (\"onConstructor\".equals(ident.getName().toString())) {\n+                    String name = ident.getName().toString();\n+                    if (name.equals(\"onConstructor\") || name.equals(\"onConstructor_\")) {\n                         continue;\n                     }\n                 }\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/RequiredArgsConstructorHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/RequiredArgsConstructorHandler.java\nindex e20877acf3d..c376de6bf22 100644\n--- a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/RequiredArgsConstructorHandler.java\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/RequiredArgsConstructorHandler.java\n@@ -38,7 +38,8 @@ public void handle(AnnotationValues<RequiredArgsConstructor> annotationValues, J\n                 if (originalArg instanceof JCTree.JCAssign && ((JCTree.JCAssign) originalArg).getVariable() instanceof JCTree.JCIdent) {\n                     JCTree.JCAssign assign = (JCTree.JCAssign) originalArg;\n                     JCTree.JCIdent ident = (JCTree.JCIdent) assign.getVariable();\n-                    if (\"onConstructor\".equals(ident.getName().toString())) {\n+                    String name = ident.getName().toString();\n+                    if (name.equals(\"onConstructor\") || name.equals(\"onConstructor_\")) {\n                         continue;\n                     }\n                 }\n\ndiff --git a/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler b/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler\nindex 322964dfb1b..b556f06f95e 100644\n--- a/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler\n+++ b/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler\n@@ -17,10 +17,10 @@ org.openrewrite.java.lombok.AllArgsConstructorHandler\n org.openrewrite.java.lombok.BuilderHandler\n org.openrewrite.java.lombok.BuilderDefaultNoOpHandler\n org.openrewrite.java.lombok.CleanupNoOpHandler\n-org.openrewrite.java.lombok.ExtensionMethodHandler\n+org.openrewrite.java.lombok.ExtensionMethodNoOpHandler\n org.openrewrite.java.lombok.GetterHandler\n-org.openrewrite.java.lombok.HelperHandler\n-org.openrewrite.java.lombok.JacksonizedHandler\n+org.openrewrite.java.lombok.HelperNoOpHandler\n+org.openrewrite.java.lombok.JacksonizedNoOpHandler\n org.openrewrite.java.lombok.LockedNoOpHandler\n org.openrewrite.java.lombok.LockedReadNoOpHandler\n org.openrewrite.java.lombok.LockedWriteNoOpHandler\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\nindex 6a355210012..aab176f0a7f 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\n@@ -19,9 +19,8 @@\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.condition.EnabledOnJre;\n-import org.junit.jupiter.api.condition.JRE;\n import org.openrewrite.java.JavaParser;\n+import org.openrewrite.java.MinimumJava11;\n import org.openrewrite.java.search.FindMissingTypes;\n import org.openrewrite.test.RecipeSpec;\n import org.openrewrite.test.RewriteTest;\n@@ -34,7 +33,6 @@\n import static org.openrewrite.java.Assertions.java;\n \n @SuppressWarnings({\"CaughtExceptionImmediatelyRethrown\", \"LombokGetterMayBeUsed\", \"LombokSetterMayBeUsed\", \"DefaultAnnotationParam\", \"NotNullFieldNotInitialized\", \"ProtectedMemberInFinalClass\", \"WriteOnlyObject\", \"ConcatenationWithEmptyString\"})\n-@EnabledOnJre({JRE.JAVA_11, JRE.JAVA_17, JRE.JAVA_21})\n class LombokTest implements RewriteTest {\n \n     @BeforeAll\n@@ -248,6 +246,12 @@ public class ConstructorExample<T> {\n                 public static class NoArgsExample {\n                   @NonNull private String field;\n                 }\n+              \n+                public void test() {\n+                  ConstructorExample<?> x = ConstructorExample.of(\"desc\");\n+                  ConstructorExample<?> y = new ConstructorExample<>(\"1L\");\n+                  ConstructorExample.NoArgsExample z = new ConstructorExample.NoArgsExample();\n+                }\n               }\n               \"\"\"\n           )\n@@ -437,7 +441,7 @@ public class SingularExample<T extends Number> {\n     }\n \n     @Test\n-    void jul() {\n+    void log() {\n         rewriteRun(\n           java(\n             \"\"\"\n@@ -459,6 +463,23 @@ void m() {\n         );\n     }\n \n+    @Test\n+    void var() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.var;\n+              \n+              class Test {\n+                  void test() {\n+                      var s = \"foo\";\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void val() {\n         rewriteRun(\n@@ -696,6 +717,7 @@ public void both(String s) {\n     }\n \n     @Test\n+    @MinimumJava11\n     void jacksonized() {\n         rewriteRun(\n           spec -> spec.parser(JavaParser.fromJavaVersion().classpath(\"jackson-annotations\", \"lombok\")),\n@@ -725,6 +747,11 @@ void standardException() {\n               \n               @StandardException\n               public class ExampleException extends Exception {\n+                  public void test() {\n+                      new ExampleException(\"message\");\n+                      new ExampleException(new RuntimeException(\"message\"));\n+                      new ExampleException(\"message\", new RuntimeException(\"message\"));\n+                  }\n               }\n               \"\"\"\n           )\n@@ -732,29 +759,27 @@ public class ExampleException extends Exception {\n     }\n \n     @Test\n+    @MinimumJava11\n     void onConstructor() {\n         rewriteRun(\n-          spec -> spec.typeValidationOptions(TypeValidation.builder().allowMissingType(o -> {\n-              assert o instanceof FindMissingTypes.MissingTypeResult;\n-              FindMissingTypes.MissingTypeResult result = (FindMissingTypes.MissingTypeResult) o;\n-              // type attribution is missing for annotation args, as it was intentionally removed for processing.\n-              return result.getPath().startsWith(\"Identifier->Annotation->\");\n-          }).build()),\n+          java(\n+            \"\"\"\n+              public @interface Inject {}\n+              public @interface Id {}\n+              public @interface Column { String name(); }\n+              public @interface Max { long value(); }\n+              \"\"\"\n+          ),\n           java(\n             \"\"\"\n               import lombok.AllArgsConstructor;\n               import lombok.Getter;\n               import lombok.Setter;\n               \n-              import javax.inject.Inject;\n-              import javax.persistence.Id;\n-              import javax.persistence.Column;\n-              import javax.validation.constraints.Max;\n-              \n-              @AllArgsConstructor(onConstructor=@__(@Inject))\n+              @AllArgsConstructor(onConstructor_=@Inject)\n               public class OnXExample {\n-                  @Getter(onMethod_={@Id, @Column(name=\"unique-id\")}) //JDK8\n-                  @Setter(onParam_=@Max(10000)) //JDK8\n+                  @Getter(onMethod_={@Id, @Column(name=\"unique-id\")})\n+                  @Setter(onParam_=@Max(10000))\n                   private long unid;\n               \n                   public void test() {\n@@ -769,17 +794,14 @@ public void test() {\n     }\n \n     @Test\n+    @MinimumJava11\n     void onConstructorNoArgs() {\n         rewriteRun(\n-          spec -> spec.typeValidationOptions(TypeValidation.builder().allowMissingType(o -> {\n-              assert o instanceof FindMissingTypes.MissingTypeResult;\n-              FindMissingTypes.MissingTypeResult result = (FindMissingTypes.MissingTypeResult) o;\n-              if (result.getJ() instanceof J.Identifier identifier) {\n-                  // type attribution is missing for annotation args, as it was intentionally removed for processing.\n-                  return identifier.getSimpleName().equals(\"__\") || identifier.getSimpleName().equals(\"Inject\");\n-              }\n-              return false;\n-          }).build()),\n+          java(\n+            \"\"\"\n+              public @interface Inject {}\n+              \"\"\"\n+          ),\n           java(\n             \"\"\"\n               import lombok.NoArgsConstructor;\n@@ -788,8 +810,8 @@ void onConstructorNoArgs() {\n               \n               import javax.inject.Inject;\n               \n-              @NoArgsConstructor(onConstructor = @__(@Inject))\n-              @RequiredArgsConstructor(onConstructor = @__(@Inject))\n+              @NoArgsConstructor(onConstructor_ = @Inject)\n+              @RequiredArgsConstructor(onConstructor_ = @Inject)\n               public class OnXExample {\n                   @NonNull private Long unid;\n               \n@@ -810,6 +832,127 @@ public void test() {\n     @SuppressWarnings(\"MismatchedReadAndWriteOfArray\")\n     @Nested\n     class LessSupported {\n+        /*\n+         java 8 cannot figure out all type checking:\n+         - When the @AllArgsConstructorHandler, @NoArgsConstructorHandler and @NoArgsConstructorHandler annotations are\n+           used with the `onConstructor_` param, Lombok does not call the JavacAnnotationHandlers.\n+         - The @Jacksonized annotation does somehow turns into `ClassDeclaration->CompilationUni` error\n+         */\n+\n+        @Test\n+        // TODO: Find solution and remove this test\n+        void jacksonizedForJava8() {\n+            rewriteRun(\n+              spec -> spec\n+                .parser(JavaParser.fromJavaVersion().classpath(\"jackson-annotations\", \"lombok\"))\n+                .typeValidationOptions(TypeValidation.builder().allowMissingType(o -> {\n+                    assert o instanceof FindMissingTypes.MissingTypeResult;\n+                    FindMissingTypes.MissingTypeResult result = (FindMissingTypes.MissingTypeResult) o;\n+                    // Using the @Jacksonized annotation in java 8 just breaks it all\n+                    return result.getPath().startsWith(\"ClassDeclaration->CompilationUnit\") ||\n+                      result.getPath().startsWith(\"Identifier->Annotation\")||\n+                      result.getPath().startsWith(\"Identifier->ParameterizedType\");\n+                }).build()),\n+              java(\n+                \"\"\"\n+                  import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+                  import lombok.Builder;\n+                  import lombok.extern.jackson.Jacksonized;\n+                  \n+                  @Jacksonized\n+                  @Builder\n+                  @JsonIgnoreProperties(ignoreUnknown = true)\n+                  public class JacksonExample {\n+                      private List<String> strings;\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        // TODO: Find solution and remove this test\n+        void onConstructorForJava8() {\n+            rewriteRun(\n+              spec -> spec.typeValidationOptions(TypeValidation.builder().allowMissingType(o -> {\n+                  assert o instanceof FindMissingTypes.MissingTypeResult;\n+                  FindMissingTypes.MissingTypeResult result = (FindMissingTypes.MissingTypeResult) o;\n+                  // The AllArgsConstructorHandler, GetterHandler and SetterHandler do not run at all for java 8,\n+                  // so no generated constructors and methods, thus no types.\n+                  return result.getPath().startsWith(\"NewClass->\") || result.getPath().startsWith(\"MethodInvocation->\");\n+              }).build()),\n+              java(\n+                \"\"\"\n+                  public @interface Inject {}\n+                  public @interface Id {}\n+                  public @interface Column { String name(); }\n+                  public @interface Max { long value(); }\n+                  \"\"\"\n+              ),\n+              java(\n+                \"\"\"\n+                  import lombok.AllArgsConstructor;\n+                  import lombok.Getter;\n+                  import lombok.Setter;\n+                  \n+                  @AllArgsConstructor(onConstructor_=@Inject)\n+                  public class OnXExample {\n+                      @Getter(onMethod_={@Id, @Column(name=\"unique-id\")})\n+                      @Setter(onParam_=@Max(10000))\n+                      private long unid;\n+                  \n+                      public void test() {\n+                          OnXExample x = new OnXExample(1L);\n+                          x.setUnid(2L);\n+                          System.out.println(x.getUnid());\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        // TODO: Find solution and remove this test\n+        void onConstructorNoArgsForJava8() {\n+            rewriteRun(\n+              spec -> spec.typeValidationOptions(TypeValidation.builder().allowMissingType(o -> {\n+                  assert o instanceof FindMissingTypes.MissingTypeResult;\n+                  FindMissingTypes.MissingTypeResult result = (FindMissingTypes.MissingTypeResult) o;\n+                  // The NoArgsConstructor and RequiredArgsConstructor do not run at all for java 8,\n+                  // so no generated constructors, thus no types.\n+                  return result.getPath().startsWith(\"NewClass->\");\n+              }).build()),\n+              java(\n+                \"\"\"\n+                  public @interface Inject {}\n+                  public @interface Ignore {} // somehow we need this, to prevent `ClassDeclaration->CompilationUnit` errors\n+                  \"\"\"\n+              ),\n+              java(\n+                \"\"\"\n+                  import lombok.NoArgsConstructor;\n+                  import lombok.NonNull;\n+                  import lombok.RequiredArgsConstructor;\n+                  \n+                  import javax.inject.Inject;\n+                  \n+                  @NoArgsConstructor(onConstructor_=@Inject)\n+                  @RequiredArgsConstructor(onConstructor_=@Inject)\n+                  public class OnXExample {\n+                      @NonNull private Long unid;\n+                  \n+                      public void test() {\n+                          new OnXExample();\n+                          new OnXExample(1L);\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+\n         @Test\n         void extensionMethod() {\n             rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4850",
    "pr_id": 4850,
    "issue_id": 4070,
    "repo": "openrewrite/rewrite",
    "problem_statement": "GroovyParser cannot parse package with trailing comma\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\n\r\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\n- OpenRewrite 6.8.4\r\n- Gradle plugin 7.4.2\r\n- rewrite-module v1.2.3\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\nI am using the Gradle plugin, and my project is a single module project.\r\n```xml\r\nplugins {\r\n    id 'maven-publish'\r\n    id 'groovy'\r\n    id 'idea'\r\n    id 'net.researchgate.release' version '2.8.1'\r\n    id \"com.github.ben-manes.versions\" version \"0.36.0\"\r\n    id \"com.gorylenko.gradle-git-properties\" version \"2.3.2\"\r\n    id 'java-library'\r\n    id 'org.openrewrite.rewrite' version '6.8.4'\r\n}\r\n\r\nrewrite {\r\n    activeRecipe(\"org.openrewrite.java.RemoveUnusedImports\")\r\n}\r\n```\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\n```java\r\npackage openrewrite.issues\r\n\r\nimport com.example.demo.AnotherClass\r\n\r\nimport static com.example.demo.AnotherClass.SOME_CONSTANT1\r\n\r\nclass ConstantIssue {\r\n    AnotherClass anotherClass = new AnotherClass()\r\n    public void showIssue() {\r\n        Map a = new HashMap()\r\n//        a.put(AnotherClass.SOME_CONSTANT1, \"value\")  // No parsing error\r\n        a.put(SOME_CONSTANT1, \"value\")  // parsing error\r\n    }\r\n}\r\n\r\n\r\npackage com.example.demo;\r\n\r\npublic class AnotherClass {\r\n    public static final String SOME_CONSTANT1 = \"someConstant\";\r\n    public static final String SOME_CONSTANT2 = \"someConstant\";\r\n    public static final String SOME_CONSTANT3 = \"someConstant\";\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\nNo parsing issue\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\nGet parsing issue\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\r\n```\r\nThere were problems parsing some source files, run with --info to see full stack traces\r\nThere were problems parsing src\\test\\groovy\\openrewrite\\issues\\ConstantIssue.groovy\r\nAll sources parsed, running active recipes: org.openrewrite.java.RemoveUnusedImports\r\nApplying recipes would make no changes. No report generated.\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\n",
    "issue_word_count": 640,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ClassDeclarationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ClassDeclarationTest.java"
    ],
    "base_commit": "a3249f208fab91e0d287b46d05ee8e9f15a9b884",
    "head_commit": "96fdad3f2cb59a138b24fd3c5b27bf147d151aa6",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4850",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4850",
    "dockerfile": "",
    "pr_merged_at": "2025-01-06T14:34:31.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex 09bb6957cc7..bbed7c6c14b 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -136,9 +136,8 @@ public G.CompilationUnit visit(SourceUnit unit, ModuleNode ast) throws GroovyPar\n         JRightPadded<J.Package> pkg = null;\n         if (ast.getPackage() != null) {\n             prefix = whitespace();\n-            cursor += \"package\".length();\n-            pkg = JRightPadded.build(new J.Package(randomId(), EMPTY, Markers.EMPTY,\n-                    typeTree(null), emptyList()));\n+            skip(\"package\");\n+            pkg = maybeSemicolon(new J.Package(randomId(), EMPTY, Markers.EMPTY, typeTree(null), emptyList()));\n         }\n \n         for (ImportNode anImport : ast.getImports()) {\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\nindex 0ab2bb60c2c..69923fd1a1c 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\n@@ -57,6 +57,7 @@ public J visitCompilationUnit(G.CompilationUnit cu, PrintOutputCapture<P> p) {\n         JRightPadded<J.Package> pkg = cu.getPadding().getPackageDeclaration();\n         if (pkg != null) {\n             visit(pkg.getElement(), p);\n+            visitMarkers(pkg.getMarkers(), p);\n             visitSpace(pkg.getAfter(), Space.Location.PACKAGE_SUFFIX, p);\n         }\n \n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ClassDeclarationTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ClassDeclarationTest.java\nindex 6399b556685..c9da577914b 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ClassDeclarationTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ClassDeclarationTest.java\n@@ -138,6 +138,19 @@ public class A{}\n         );\n     }\n \n+    @Test\n+    void hasPackageWithTrailingComma() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\" \n+              package org.openrewrite;\n+\n+              class A{}\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/1736\")\n     @Test\n     void parameterizedFieldDoesNotAffectClassType() {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4848",
    "pr_id": 4848,
    "issue_id": 4254,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Groovy generated transform methods break parser\n I'm seeing this on groovy class that uses groovy transform (`import groovy.transform.*`) such as @ToString, @EqualsAndHashCode.\r\n\r\n\r\n## What version of OpenRewrite are you using?\r\n \r\nI am using https://github.com/gtiwari333/openrewrite-groovy-bug/blob/main/init.gradle\r\n\r\n- org.openrewrite.recipe:rewrite-recipe-bom  - 2.1.20\r\n- org.openrewrite:rewrite-gradle-plugin - latest.release\r\n- groovy 4.0.21\r\n- jdk 17/21\r\n- gradle 8.8\r\n\r\n\r\n \r\n \r\n\r\n## How are you running OpenRewrite?\r\n `%./gradlew  clean rewriteRun --init-script init.gradle --info`\r\n\r\n\r\n \r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n\r\nCheckout the following project and run `./gradlew  clean rewriteRun --init-script init.gradle --info`\r\n\r\nIm seeing similar behavior with both jdk17 and jdk21 \r\n\r\nhttps://github.com/gtiwari333/openrewrite-groovy-bug/blob/main/README.md \r\n\r\n## What did you expect to see?\r\n No failures. AutoFormat recipe should run on the code.\r\n\r\n## What did you see instead?\r\n ```\r\nError during rewrite run\r\norg.openrewrite.groovy.GroovyParsingException: Failed to parse src/main/groovy/com/example/demo/Test.groovy, cursor position likely inaccurate.\r\n        at org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:170)\r\n        at org.openrewrite.groovy.GroovyParser.lambda$parseInputs$4(GroovyParser.java:154)\r\n        at java.base@17.0.9/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\r\n        at java.base@17.0.9/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625)\r\n ...\r\nCaused by: java.lang.StringIndexOutOfBoundsException: begin 137, end 137, length 134\r\n        at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4606)\r\n        at java.base/java.lang.String.substring(String.java:2709)\r\n        at org.openrewrite.groovy.GroovyParserVisitor.whitespace(GroovyParserVisitor.java:2171)\r\n        at org.openrewrite.groovy.GroovyParserVisitor.access$000(GroovyParserVisitor.java:66)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitVariableExpressionType(GroovyParserVisitor.java:1955)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitDeclarationExpression(GroovyParserVisitor.java:1262)\r\n        at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:89)\r\n```\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n Run the `./gradlew  clean rewriteRun --init-script init.gradle --info` command to get full stacktrace. I've provided relevant bits above.\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\n\r\nNot too familiar how AST works. But i can try.\r\n",
    "issue_word_count": 385,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java"
    ],
    "base_commit": "c455436d01e816b96301f474875e8010d1ab8d32",
    "head_commit": "85f5d1d102bf2a2c4366572d0d7cb3654543d5a6",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4848",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4848",
    "dockerfile": "",
    "pr_merged_at": "2025-01-06T13:14:48.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex 421f80ac5da..09bb6957cc7 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -16,6 +16,8 @@\n package org.openrewrite.groovy;\n \n import groovy.lang.GroovySystem;\n+import groovy.transform.Generated;\n+import groovy.transform.Immutable;\n import groovyjarjarasm.asm.Opcodes;\n import lombok.Getter;\n import lombok.RequiredArgsConstructor;\n@@ -305,7 +307,7 @@ J.Block visitClassBlock(ClassNode clazz) {\n                         org.codehaus.groovy.ast.stmt.Statement statement = ((BlockStatement) method.getCode()).getStatements().get(0);\n                         sortedByPosition.computeIfAbsent(pos(statement), i -> new ArrayList<>()).add(statement);\n                     }\n-                } else {\n+                } else if (method.getAnnotations(new ClassNode(Generated.class)).isEmpty()) {\n                     sortedByPosition.computeIfAbsent(pos(method), i -> new ArrayList<>()).add(method);\n                 }\n             }\n@@ -448,7 +450,6 @@ private void visitVariableField(FieldNode field) {\n         @Override\n         protected void visitAnnotation(AnnotationNode annotation) {\n             RewriteGroovyVisitor bodyVisitor = new RewriteGroovyVisitor(annotation, this);\n-\n             String lastArgKey = annotation.getMembers().keySet().stream().reduce(\"\", (k1, k2) -> k2);\n             Space prefix = sourceBefore(\"@\");\n             NameTree annotationType = visitTypeTree(annotation.getClassNode());\n@@ -457,8 +458,10 @@ protected void visitAnnotation(AnnotationNode annotation) {\n                 arguments = JContainer.build(\n                         sourceBefore(\"(\"),\n                         annotation.getMembers().entrySet().stream()\n+                                // Non-value implicit properties should not be represented in our LST.\n+                                .filter(it -> sourceStartsWith(it.getKey()) || \"value\".equals(it.getKey()))\n                                 .map(arg -> {\n-                                    boolean isImplicitValue = \"value\".equals(arg.getKey()) && !source.startsWith(\"value\", indexOfNextNonWhitespace(cursor, source));\n+                                    boolean isImplicitValue = \"value\".equals(arg.getKey()) && !sourceStartsWith(\"value\");\n                                     Space argPrefix = isImplicitValue ? whitespace() : sourceBefore(arg.getKey());\n                                     Space isSign = isImplicitValue ? null : sourceBefore(\"=\");\n                                     Expression expression;\n@@ -478,8 +481,12 @@ protected void visitAnnotation(AnnotationNode annotation) {\n                                 .collect(toList()),\n                         Markers.EMPTY\n                 );\n-            } else if (source.startsWith(\"(\", indexOfNextNonWhitespace(cursor, source))) {\n-                // An annotation with empty arguments like @Foo()\n+                // Rare scenario where annotation does only have non-value implicit properties\n+                if (arguments.getElements().isEmpty()) {\n+                    arguments = null;\n+                }\n+            } else if (sourceStartsWith(\"(\")) {\n+                // Annotation with empty arguments like @Foo()\n                 arguments = JContainer.build(sourceBefore(\"(\"),\n                         singletonList(JRightPadded.build(new J.Empty(randomId(), sourceBefore(\")\"), Markers.EMPTY))),\n                         Markers.EMPTY);\n@@ -551,7 +558,7 @@ class B {                               class B {\n                 }\n \n                 Space varargs = null;\n-                if (paramType instanceof J.ArrayType && hasVarargs()) {\n+                if (paramType instanceof J.ArrayType && sourceStartsWith(\"...\")) {\n                     int varargStart = indexOfNextNonWhitespace(cursor, source);\n                     varargs = format(source, cursor, varargStart);\n                     cursor = varargStart + 3;\n@@ -642,8 +649,17 @@ public List<J.Annotation> visitAndGetAnnotations(AnnotatedNode node) {\n \n             List<J.Annotation> paramAnnotations = new ArrayList<>(node.getAnnotations().size());\n             for (AnnotationNode annotationNode : node.getAnnotations()) {\n-                visitAnnotation(annotationNode);\n-                paramAnnotations.add(pollQueue());\n+                // The groovy compiler can add or remove annotations for AST transformations.\n+                // Because @groovy.transform.Immutable is discarded in favour of other transform annotations, the removed annotation must be parsed by hand.\n+                if (sourceStartsWith(\"@\" + Immutable.class.getSimpleName()) || sourceStartsWith(\"@\" + Immutable.class.getCanonicalName()) ) {\n+                    visitAnnotation(new AnnotationNode(new ClassNode(Immutable.class)));\n+                    paramAnnotations.add(pollQueue());\n+                }\n+\n+                if (appearsInSource(annotationNode)) {\n+                    visitAnnotation(annotationNode);\n+                    paramAnnotations.add(pollQueue());\n+                }\n             }\n             return paramAnnotations;\n         }\n@@ -747,7 +763,7 @@ public void visitArgumentlistExpression(ArgumentListExpression expression) {\n             }\n \n             List<org.codehaus.groovy.ast.expr.Expression> unparsedArgs = expression.getExpressions().stream()\n-                    .filter(GroovyParserVisitor::appearsInSource)\n+                    .filter(GroovyParserVisitor.this::appearsInSource)\n                     .collect(toList());\n             // If the first parameter to a function is a Map, then groovy allows \"named parameters\" style invocations, see:\n             //     https://docs.groovy-lang.org/latest/html/documentation/#_named_parameters_2\n@@ -1017,7 +1033,7 @@ public void visitBinaryExpression(BinaryExpression binary) {\n         public void visitBlockStatement(BlockStatement block) {\n             Space fmt = EMPTY;\n             Space staticInitPadding = EMPTY;\n-            boolean isStaticInit = source.substring(indexOfNextNonWhitespace(cursor, source)).startsWith(\"static\");\n+            boolean isStaticInit = sourceStartsWith(\"static\");\n             Object parent = nodeCursor.getParentOrThrow().getValue();\n             if (isStaticInit) {\n                 fmt = sourceBefore(\"static\");\n@@ -2367,7 +2383,7 @@ private TypeTree arrayType(ClassNode classNode) {\n         }\n         Space prefix = whitespace();\n         TypeTree elemType = typeTree(typeTree);\n-        JLeftPadded<Space> dimension = hasVarargs() ? null : padLeft(sourceBefore(\"[\"), sourceBefore(\"]\"));\n+        JLeftPadded<Space> dimension = sourceStartsWith(\"...\") ? null : padLeft(sourceBefore(\"[\"), sourceBefore(\"]\"));\n         return new J.ArrayType(randomId(), prefix, Markers.EMPTY,\n                 count == 1 ? elemType : mapDimensions(elemType, classNode.getComponentType()),\n                 null,\n@@ -2392,10 +2408,6 @@ private TypeTree mapDimensions(TypeTree baseType, ClassNode classNode) {\n         return baseType;\n     }\n \n-    private boolean hasVarargs() {\n-        return source.startsWith(\"...\", indexOfNextNonWhitespace(cursor, source));\n-    }\n-\n     /**\n      * Get all characters of the source file between the cursor and the given delimiter.\n      * The cursor will be moved past the delimiter.\n@@ -2416,6 +2428,14 @@ private Space sourceBefore(String untilDelim) {\n         return space;\n     }\n \n+    /**\n+     * Tests if the source beginning at the current cursor starts with the specified delimiter.\n+     * Whitespace characters are excluded, the cursor will not be moved.\n+     */\n+    private boolean sourceStartsWith(String delimiter) {\n+        return source.startsWith(delimiter, indexOfNextNonWhitespace(cursor, source));\n+    }\n+\n     /**\n      * Returns a string that is a part of this source. The substring begins at the specified beginIndex and extends until delimiter.\n      * The cursor will not be moved.\n@@ -2708,13 +2728,17 @@ private J.TypeParameter visitTypeParameter(GenericsType genericType) {\n \n     /**\n      * Sometimes the groovy compiler inserts phantom elements into argument lists and class bodies,\n-     * presumably to pass type information around. These elements do not appear in source code and should not\n-     * be represented in our AST.\n+     * presumably to pass type information around. Other times the groovy compiler adds extra transform annotations.\n+     * These elements do not appear in source code and should not be represented in our LST.\n      *\n      * @param node possible phantom node\n      * @return true if the node reports that it does have a position within the source code\n      */\n-    private static boolean appearsInSource(ASTNode node) {\n+    private boolean appearsInSource(ASTNode node) {\n+        if (node instanceof AnnotationNode) {\n+            return sourceStartsWith(\"@\" + ((AnnotationNode) node).getClassNode().getUnresolvedName());\n+        }\n+\n         return node.getColumnNumber() >= 0 && node.getLineNumber() >= 0 && node.getLastColumnNumber() >= 0 && node.getLastLineNumber() >= 0;\n     }\n \n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java\nindex b028da0dfa5..c9f14d23010 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java\n@@ -30,6 +30,21 @@ void simple() {\n           groovy(\n             \"\"\"\n               @Foo\n+              class Test implements Runnable {\n+                  @java.lang.Override\n+                  void run() {}\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void simpleFQN() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              @org.springframework.stereotype.Service\n               class Test {}\n               \"\"\"\n           )\n@@ -48,6 +63,19 @@ class Test {}\n         );\n     }\n \n+    @Test\n+    void inline() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              @Foo class Test implements Runnable {\n+                  @Override void run() {}\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void withProperties() {\n         rewriteRun(\n@@ -84,4 +112,55 @@ class Test {}\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4254\")\n+    @Test\n+    void groovyTransformAnnotation() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              import groovy.transform.EqualsAndHashCode\n+              import groovy.transform.ToString\n+              \n+              @Foo\n+              @ToString\n+              @EqualsAndHashCode\n+              @Bar\n+              class Test {}\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4254\")\n+    @Test\n+    void groovyTransformImmutableAnnotation() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              import groovy.transform.Immutable\n+              import groovy.transform.TupleConstructor\n+              \n+              @Foo\n+              @TupleConstructor\n+              @Immutable\n+              @Bar\n+              class Test {}\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4254\")\n+    @Test\n+    void groovyTransformImmutableFQNAnnotation() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              @groovy.transform.Immutable\n+              class Test {}\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4834",
    "pr_id": 4834,
    "issue_id": 4055,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Problem with parsing groovy files\nI'm trying to run recipe using the gradle wrapper with the init script on a clean Spring Boot 2.7.x application with addition of one single groovy class. When I run build `.\\gradlew --init-script ..\\rewrite-init.gradle rewriteRun`, I am seeing following message:\r\n\r\n```sh\r\nThere were problems parsing src\\main\\groovy\\com\\example\\demo\\Example.groovy\r\n```\r\nwhere `Example.groovy` is\r\n\r\n```groovy\r\npackage com.example.demo\r\n\r\nimport groovy.transform.ToString\r\n\r\n@ToString(includeNames = true)\r\nclass Category {\r\n    String f1\r\n    String f2\r\n    String f3\r\n    String f4\r\n    String f5\r\n}\r\n\r\n```\r\n\r\nand `build.gradle` is\r\n\r\n```gradle\r\nplugins {\r\n\tid 'groovy'\r\n\tid 'org.springframework.boot' version '2.7.11'\r\n\tid 'io.spring.dependency-management' version '1.1.4'\r\n}\r\n\r\ngroup = 'com.example'\r\nversion = '0.0.1-SNAPSHOT'\r\n\r\njava {\r\n\tsourceCompatibility=1.8\r\n\ttargetCompatibility=1.8\r\n}\r\n\r\nrepositories {\r\n\tmavenCentral()\r\n}\r\n\r\ndependencies {\r\n\timplementation 'org.springframework.boot:spring-boot-starter'\r\n\timplementation 'org.codehaus.groovy:groovy-all:3.0.10'\r\n\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\r\n}\r\n\r\ntasks.named('test') {\r\n\tuseJUnitPlatform()\r\n}\r\n```\r\n\r\nand `rewrite-init.gradle` is\r\n\r\n```gradle\r\ninitscript {\r\n    repositories {\r\n        maven { url \"https://plugins.gradle.org/m2\" }\r\n    }\r\n    dependencies { classpath(\"org.openrewrite:plugin:6.8.4\") }\r\n}\r\nrootProject {\r\n    plugins.apply(org.openrewrite.gradle.RewritePlugin)\r\n    dependencies {\r\n        rewrite(platform(\"org.openrewrite.recipe:rewrite-recipe-bom:2.7.1\"))\r\n        rewrite(\"org.openrewrite.recipe:rewrite-spring\")\r\n    }\r\n    rewrite {\r\n        activeRecipe(\"org.openrewrite.java.spring.boot2.UpgradeSpringBoot_2_7\")\r\n    }\r\n    afterEvaluate {\r\n        if (repositories.isEmpty()) {\r\n            repositories {\r\n                mavenCentral()\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis is the stack trace:\r\n\r\n```sh\r\nError during rewrite run\r\norg.openrewrite.groovy.GroovyParsingException: Failed to parse src\\main\\groovy\\com\\example\\demo\\Category.groovy at cursor position 166. The next 10 characters in the original source are `ing f4\r\n  `\r\n        at org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:175)\r\n        at org.openrewrite.groovy.GroovyParser.lambda$parseInputs$4(GroovyParser.java:154)\r\n        at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\r\n        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1384)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\r\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n        at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)\r\n        at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:272)\r\n        at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\r\n        at java.util.stream.Streams$StreamBuilderImpl.forEachRemaining(Streams.java:419)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n        at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:566)\r\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.listResults(DefaultProjectParser.java:1206)\r\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.run(DefaultProjectParser.java:402)\r\n        at org.openrewrite.gradle.DelegatingProjectParser.lambda$run$2(DelegatingProjectParser.java:100)\r\n        at org.openrewrite.gradle.DelegatingProjectParser.unwrapInvocationException(DelegatingProjectParser.java:147)\r\n        at org.openrewrite.gradle.DelegatingProjectParser.run(DelegatingProjectParser.java:99)\r\n        at org.openrewrite.gradle.RewriteRunTask.run(RewriteRunTask.java:36)\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n        at java.lang.reflect.Method.invoke(Method.java:498)\r\n        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:125)\r\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.doExecute(StandardTaskAction.java:58)\r\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:51)\r\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:29)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution$3.run(TaskExecution.java:242)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:29)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:26)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.run(DefaultBuildOperationRunner.java:47)\r\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:68)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeAction(TaskExecution.java:227)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeActions(TaskExecution.java:210)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeWithPreviousOutputFiles(TaskExecution.java:193)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution.execute(TaskExecution.java:166)\r\n        at org.gradle.internal.execution.steps.ExecuteStep.executeInternal(ExecuteStep.java:105)\r\n        at org.gradle.internal.execution.steps.ExecuteStep.access$000(ExecuteStep.java:44)\r\n        at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:59)\r\n        at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:56)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\r\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\r\n        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:56)\r\n        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:44)\r\n        at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:67)\r\n        at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:37)\r\n        at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:41)\r\n        at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:74)\r\n        at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:55)\r\n        at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:50)\r\n        at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:28)\r\n        at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.executeDelegateBroadcastingChanges(CaptureStateAfterExecutionStep.java:100)\r\n        at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:72)\r\n        at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:50)\r\n        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:40)\r\n        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:29)\r\n        at org.gradle.internal.execution.steps.BuildCacheStep.executeWithoutCache(BuildCacheStep.java:166)\r\n        at org.gradle.internal.execution.steps.BuildCacheStep.lambda$execute$1(BuildCacheStep.java:70)\r\n        at org.gradle.internal.Either$Right.fold(Either.java:175)\r\n        at org.gradle.internal.execution.caching.CachingState.fold(CachingState.java:59)\r\n        at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:68)\r\n        at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:46)\r\n        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:36)\r\n        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:25)\r\n        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:36)\r\n        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:22)\r\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:91)\r\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$2(SkipUpToDateStep.java:55)\r\n        at java.util.Optional.orElseGet(Optional.java:267)\r\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:55)\r\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:37)\r\n        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:65)\r\n        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:36)\r\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:37)\r\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:27)\r\n        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:76)\r\n        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:37)\r\n        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:94)\r\n        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:49)\r\n        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:71)\r\n        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:45)\r\n        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.executeWithNonEmptySources(SkipEmptyWorkStep.java:177)\r\n        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:81)\r\n        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:53)\r\n        at org.gradle.internal.execution.steps.RemoveUntrackedExecutionStateStep.execute(RemoveUntrackedExecutionStateStep.java:32)\r\n        at org.gradle.internal.execution.steps.RemoveUntrackedExecutionStateStep.execute(RemoveUntrackedExecutionStateStep.java:21)\r\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:38)\r\n        at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:36)\r\n        at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:23)\r\n        at org.gradle.internal.execution.steps.CleanupStaleOutputsStep.execute(CleanupStaleOutputsStep.java:75)\r\n        at org.gradle.internal.execution.steps.CleanupStaleOutputsStep.execute(CleanupStaleOutputsStep.java:41)\r\n        at org.gradle.internal.execution.steps.AssignWorkspaceStep.lambda$execute$0(AssignWorkspaceStep.java:32)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution$4.withWorkspace(TaskExecution.java:287)\r\n        at org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:30)\r\n        at org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:21)\r\n        at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:37)\r\n        at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:27)\r\n        at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:47)\r\n        at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:34)\r\n        at org.gradle.internal.execution.impl.DefaultExecutionEngine$1.execute(DefaultExecutionEngine.java:64)\r\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:146)\r\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:135)\r\n        at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)\r\n        at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)\r\n        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)\r\n        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:74)\r\n        at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)\r\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)\r\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)\r\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\r\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\r\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)\r\n        at org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:42)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:337)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:324)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:317)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:303)\r\n        at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:463)\r\n        at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:380)\r\n        at org.gradle.execution.plan.DefaultPlanExecutor.process(DefaultPlanExecutor.java:116)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph.executeWithServices(DefaultTaskExecutionGraph.java:138)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph.execute(DefaultTaskExecutionGraph.java:123)\r\n        at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:35)\r\n        at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:51)\r\n        at org.gradle.execution.BuildOperationFiringBuildWorkerExecutor$ExecuteTasks.call(BuildOperationFiringBuildWorkerExecutor.java:54)\r\n        at org.gradle.execution.BuildOperationFiringBuildWorkerExecutor$ExecuteTasks.call(BuildOperationFiringBuildWorkerExecutor.java:43)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\r\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\r\n        at org.gradle.execution.BuildOperationFiringBuildWorkerExecutor.execute(BuildOperationFiringBuildWorkerExecutor.java:40)\r\n        at org.gradle.internal.build.DefaultBuildLifecycleController.lambda$executeTasks$10(DefaultBuildLifecycleController.java:202)\r\n        at org.gradle.internal.model.StateTransitionController.doTransition(StateTransitionController.java:266)\r\n        at org.gradle.internal.model.StateTransitionController.lambda$tryTransition$8(StateTransitionController.java:177)\r\n        at org.gradle.internal.work.DefaultSynchronizer.withLock(DefaultSynchronizer.java:44)\r\n        at org.gradle.internal.model.StateTransitionController.tryTransition(StateTransitionController.java:177)\r\n        at org.gradle.internal.build.DefaultBuildLifecycleController.executeTasks(DefaultBuildLifecycleController.java:202)\r\n        at org.gradle.internal.build.DefaultBuildWorkGraphController$DefaultBuildWorkGraph.runWork(DefaultBuildWorkGraphController.java:209)\r\n        at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:249)\r\n        at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:109)\r\n        at org.gradle.composite.internal.DefaultBuildController.doRun(DefaultBuildController.java:172)\r\n        at org.gradle.composite.internal.DefaultBuildController.access$000(DefaultBuildController.java:47)\r\n        at org.gradle.composite.internal.DefaultBuildController$BuildOpRunnable.run(DefaultBuildController.java:191)\r\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\r\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)\r\n        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:49)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        at java.lang.Thread.run(Thread.java:750)\r\nCaused by: java.lang.IllegalStateException: Unexpected constant type java.lang.Boolean\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitConstantExpression$3(GroovyParserVisitor.java:1196)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.insideParentheses(GroovyParserVisitor.java:623)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitConstantExpression(GroovyParserVisitor.java:1136)\r\n        at org.codehaus.groovy.ast.expr.ConstantExpression.visit(ConstantExpression.java:80)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:572)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitDeclarationExpression(GroovyParserVisitor.java:1278)\r\n        at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:89)\r\n        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitExpressionStatement$6(GroovyParserVisitor.java:1305)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.labeled(GroovyParserVisitor.java:638)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitExpressionStatement(GroovyParserVisitor.java:1304)\r\n        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:572)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitBlockStatement(GroovyParserVisitor.java:918)\r\n        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:572)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.access$1200(GroovyParserVisitor.java:560)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.visitMethod(GroovyParserVisitor.java:537)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.lambda$visitClassBlock$3(GroovyParserVisitor.java:334)\r\n        at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\r\n        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1384)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\r\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n        at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)\r\n        at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:272)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n        at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:566)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.visitClassBlock(GroovyParserVisitor.java:341)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.visitClass(GroovyParserVisitor.java:282)\r\n        at org.openrewrite.groovy.GroovyParserVisitor.convertTopLevelStatement(GroovyParserVisitor.java:2023)\r\n        at org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:161)\r\n        ... 204 more\r\n```\r\n",
    "issue_word_count": 2811,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/MethodInvocationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/MethodInvocationTest.java"
    ],
    "base_commit": "56be668c30808f66509b0e76c8ba152e51e5c129",
    "head_commit": "26410af4a924dc194969fba4385b56adfea38e18",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4834",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4834",
    "dockerfile": "",
    "pr_merged_at": "2025-01-02T16:32:40.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex c34c258ee86..97855816ed0 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -2484,17 +2484,17 @@ private Space sourceBefore(String untilDelim) {\n     private int determineParenthesisLevel(int childLineNumber, int parentLineNumber, int childColumn, int parentColumn) {\n         int saveCursor = cursor;\n         whitespace();\n-        int childBeginCursor = cursor;\n+        int untilCursor = cursor;\n         if (childLineNumber > parentLineNumber) {\n-            for (int i = 0; i < (childColumn - parentLineNumber); i++) {\n-                childBeginCursor = source.indexOf('\\n', childBeginCursor);\n+            for (int i = 0; i < (childLineNumber - parentLineNumber); i++) {\n+                untilCursor = source.indexOf('\\n', untilCursor) + 1; // +1; set cursor past `\\n`\n             }\n-            childBeginCursor += childColumn;\n+            untilCursor += childColumn - 1; // -1; skip previous `\\n`\n         } else {\n-            childBeginCursor += childColumn - parentColumn;\n+            untilCursor += childColumn - parentColumn;\n         }\n         int count = 0;\n-        for (int i = cursor; i < childBeginCursor; i++) {\n+        for (int i = cursor; i < untilCursor; i++) {\n             if (source.charAt(i) == '(') {\n                 count++;\n             }\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/MethodInvocationTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/MethodInvocationTest.java\nindex 31531c0d6ab..4e893f7ffb0 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/MethodInvocationTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/MethodInvocationTest.java\n@@ -362,6 +362,25 @@ void closureReturn() {\n         );\n     }\n \n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4055\")\n+    @Test\n+    void chainOfMethodInvocations() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              Micronaut.build(args)\n+                      .banner(false)\n+                      .propertySources(PropertySource.of(\"my-config\", [name: \"MyApp\"]))\n+                      .environments(\"prod\") // Only prod\n+                      .overrideConfig(\"custom-config.yml\") // Load custom config\n+                      .packages(\"com.company\")\n+                      .mainClass(Application)\n+                      .start()\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/2552\")\n     @Test\n     void closureInvocation() {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4832",
    "pr_id": 4832,
    "issue_id": 4055,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Problem with parsing groovy files\nI'm trying to run recipe using the gradle wrapper with the init script on a clean Spring Boot 2.7.x application with addition of one single groovy class. When I run build `.\\gradlew --init-script ..\\rewrite-init.gradle rewriteRun`, I am seeing following message:\r\n\r\n```sh\r\nThere were problems parsing src\\main\\groovy\\com\\example\\demo\\Example.groovy\r\n```\r\nwhere `Example.groovy` is\r\n\r\n```groovy\r\npackage com.example.demo\r\n\r\nimport groovy.transform.ToString\r\n\r\n@ToString(includeNames = true)\r\nclass Category {\r\n    String f1\r\n    String f2\r\n    String f3\r\n    String f4\r\n    String f5\r\n}\r\n\r\n```\r\n\r\nand `build.gradle` is\r\n\r\n```gradle\r\nplugins {\r\n\tid 'groovy'\r\n\tid 'org.springframework.boot' version '2.7.11'\r\n\tid 'io.spring.dependency-management' version '1.1.4'\r\n}\r\n\r\ngroup = 'com.example'\r\nversion = '0.0.1-SNAPSHOT'\r\n\r\njava {\r\n\tsourceCompatibility=1.8\r\n\ttargetCompatibility=1.8\r\n}\r\n\r\nrepositories {\r\n\tmavenCentral()\r\n}\r\n\r\ndependencies {\r\n\timplementation 'org.springframework.boot:spring-boot-starter'\r\n\timplementation 'org.codehaus.groovy:groovy-all:3.0.10'\r\n\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\r\n}\r\n\r\ntasks.named('test') {\r\n\tuseJUnitPlatform()\r\n}\r\n```\r\n\r\nand `rewrite-init.gradle` is\r\n\r\n```gradle\r\ninitscript {\r\n    repositories {\r\n        maven { url \"https://plugins.gradle.org/m2\" }\r\n    }\r\n    dependencies { classpath(\"org.openrewrite:plugin:6.8.4\") }\r\n}\r\nrootProject {\r\n    plugins.apply(org.openrewrite.gradle.RewritePlugin)\r\n    dependencies {\r\n        rewrite(platform(\"org.openrewrite.recipe:rewrite-recipe-bom:2.7.1\"))\r\n        rewrite(\"org.openrewrite.recipe:rewrite-spring\")\r\n    }\r\n    rewrite {\r\n        activeRecipe(\"org.openrewrite.java.spring.boot2.UpgradeSpringBoot_2_7\")\r\n    }\r\n    afterEvaluate {\r\n        if (repositories.isEmpty()) {\r\n            repositories {\r\n                mavenCentral()\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis is the stack trace:\r\n\r\n```sh\r\nError during rewrite run\r\norg.openrewrite.groovy.GroovyParsingException: Failed to parse src\\main\\groovy\\com\\example\\demo\\Category.groovy at cursor position 166. The next 10 characters in the original source are `ing f4\r\n  `\r\n        at org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:175)\r\n        at org.openrewrite.groovy.GroovyParser.lambda$parseInputs$4(GroovyParser.java:154)\r\n        at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\r\n        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1384)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\r\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n        at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)\r\n        at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:272)\r\n        at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\r\n        at java.util.stream.Streams$StreamBuilderImpl.forEachRemaining(Streams.java:419)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n        at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:566)\r\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.listResults(DefaultProjectParser.java:1206)\r\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.run(DefaultProjectParser.java:402)\r\n        at org.openrewrite.gradle.DelegatingProjectParser.lambda$run$2(DelegatingProjectParser.java:100)\r\n        at org.openrewrite.gradle.DelegatingProjectParser.unwrapInvocationException(DelegatingProjectParser.java:147)\r\n        at org.openrewrite.gradle.DelegatingProjectParser.run(DelegatingProjectParser.java:99)\r\n        at org.openrewrite.gradle.RewriteRunTask.run(RewriteRunTask.java:36)\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n        at java.lang.reflect.Method.invoke(Method.java:498)\r\n        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:125)\r\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.doExecute(StandardTaskAction.java:58)\r\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:51)\r\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:29)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution$3.run(TaskExecution.java:242)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:29)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:26)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.run(DefaultBuildOperationRunner.java:47)\r\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:68)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeAction(TaskExecution.java:227)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeActions(TaskExecution.java:210)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeWithPreviousOutputFiles(TaskExecution.java:193)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution.execute(TaskExecution.java:166)\r\n        at org.gradle.internal.execution.steps.ExecuteStep.executeInternal(ExecuteStep.java:105)\r\n        at org.gradle.internal.execution.steps.ExecuteStep.access$000(ExecuteStep.java:44)\r\n        at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:59)\r\n        at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:56)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\r\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\r\n        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:56)\r\n        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:44)\r\n        at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:67)\r\n        at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:37)\r\n        at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:41)\r\n        at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:74)\r\n        at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:55)\r\n        at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:50)\r\n        at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:28)\r\n        at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.executeDelegateBroadcastingChanges(CaptureStateAfterExecutionStep.java:100)\r\n        at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:72)\r\n        at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:50)\r\n        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:40)\r\n        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:29)\r\n        at org.gradle.internal.execution.steps.BuildCacheStep.executeWithoutCache(BuildCacheStep.java:166)\r\n        at org.gradle.internal.execution.steps.BuildCacheStep.lambda$execute$1(BuildCacheStep.java:70)\r\n        at org.gradle.internal.Either$Right.fold(Either.java:175)\r\n        at org.gradle.internal.execution.caching.CachingState.fold(CachingState.java:59)\r\n        at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:68)\r\n        at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:46)\r\n        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:36)\r\n        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:25)\r\n        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:36)\r\n        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:22)\r\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:91)\r\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$2(SkipUpToDateStep.java:55)\r\n        at java.util.Optional.orElseGet(Optional.java:267)\r\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:55)\r\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:37)\r\n        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:65)\r\n        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:36)\r\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:37)\r\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:27)\r\n        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:76)\r\n        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:37)\r\n        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:94)\r\n        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:49)\r\n        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:71)\r\n        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:45)\r\n        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.executeWithNonEmptySources(SkipEmptyWorkStep.java:177)\r\n        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:81)\r\n        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:53)\r\n        at org.gradle.internal.execution.steps.RemoveUntrackedExecutionStateStep.execute(RemoveUntrackedExecutionStateStep.java:32)\r\n        at org.gradle.internal.execution.steps.RemoveUntrackedExecutionStateStep.execute(RemoveUntrackedExecutionStateStep.java:21)\r\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:38)\r\n        at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:36)\r\n        at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:23)\r\n        at org.gradle.internal.execution.steps.CleanupStaleOutputsStep.execute(CleanupStaleOutputsStep.java:75)\r\n        at org.gradle.internal.execution.steps.CleanupStaleOutputsStep.execute(CleanupStaleOutputsStep.java:41)\r\n        at org.gradle.internal.execution.steps.AssignWorkspaceStep.lambda$execute$0(AssignWorkspaceStep.java:32)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution$4.withWorkspace(TaskExecution.java:287)\r\n        at org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:30)\r\n        at org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:21)\r\n        at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:37)\r\n        at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:27)\r\n        at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:47)\r\n        at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:34)\r\n        at org.gradle.internal.execution.impl.DefaultExecutionEngine$1.execute(DefaultExecutionEngine.java:64)\r\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:146)\r\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:135)\r\n        at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)\r\n        at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)\r\n        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)\r\n        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:74)\r\n        at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)\r\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)\r\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)\r\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\r\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\r\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)\r\n        at org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:42)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:337)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:324)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:317)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:303)\r\n        at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:463)\r\n        at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:380)\r\n        at org.gradle.execution.plan.DefaultPlanExecutor.process(DefaultPlanExecutor.java:116)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph.executeWithServices(DefaultTaskExecutionGraph.java:138)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph.execute(DefaultTaskExecutionGraph.java:123)\r\n        at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:35)\r\n        at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:51)\r\n        at org.gradle.execution.BuildOperationFiringBuildWorkerExecutor$ExecuteTasks.call(BuildOperationFiringBuildWorkerExecutor.java:54)\r\n        at org.gradle.execution.BuildOperationFiringBuildWorkerExecutor$ExecuteTasks.call(BuildOperationFiringBuildWorkerExecutor.java:43)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\r\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\r\n        at org.gradle.execution.BuildOperationFiringBuildWorkerExecutor.execute(BuildOperationFiringBuildWorkerExecutor.java:40)\r\n        at org.gradle.internal.build.DefaultBuildLifecycleController.lambda$executeTasks$10(DefaultBuildLifecycleController.java:202)\r\n        at org.gradle.internal.model.StateTransitionController.doTransition(StateTransitionController.java:266)\r\n        at org.gradle.internal.model.StateTransitionController.lambda$tryTransition$8(StateTransitionController.java:177)\r\n        at org.gradle.internal.work.DefaultSynchronizer.withLock(DefaultSynchronizer.java:44)\r\n        at org.gradle.internal.model.StateTransitionController.tryTransition(StateTransitionController.java:177)\r\n        at org.gradle.internal.build.DefaultBuildLifecycleController.executeTasks(DefaultBuildLifecycleController.java:202)\r\n        at org.gradle.internal.build.DefaultBuildWorkGraphController$DefaultBuildWorkGraph.runWork(DefaultBuildWorkGraphController.java:209)\r\n        at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:249)\r\n        at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:109)\r\n        at org.gradle.composite.internal.DefaultBuildController.doRun(DefaultBuildController.java:172)\r\n        at org.gradle.composite.internal.DefaultBuildController.access$000(DefaultBuildController.java:47)\r\n        at org.gradle.composite.internal.DefaultBuildController$BuildOpRunnable.run(DefaultBuildController.java:191)\r\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\r\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)\r\n        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:49)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        at java.lang.Thread.run(Thread.java:750)\r\nCaused by: java.lang.IllegalStateException: Unexpected constant type java.lang.Boolean\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitConstantExpression$3(GroovyParserVisitor.java:1196)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.insideParentheses(GroovyParserVisitor.java:623)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitConstantExpression(GroovyParserVisitor.java:1136)\r\n        at org.codehaus.groovy.ast.expr.ConstantExpression.visit(ConstantExpression.java:80)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:572)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitDeclarationExpression(GroovyParserVisitor.java:1278)\r\n        at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:89)\r\n        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitExpressionStatement$6(GroovyParserVisitor.java:1305)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.labeled(GroovyParserVisitor.java:638)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitExpressionStatement(GroovyParserVisitor.java:1304)\r\n        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:572)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitBlockStatement(GroovyParserVisitor.java:918)\r\n        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:572)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.access$1200(GroovyParserVisitor.java:560)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.visitMethod(GroovyParserVisitor.java:537)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.lambda$visitClassBlock$3(GroovyParserVisitor.java:334)\r\n        at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\r\n        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1384)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\r\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n        at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)\r\n        at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:272)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n        at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:566)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.visitClassBlock(GroovyParserVisitor.java:341)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.visitClass(GroovyParserVisitor.java:282)\r\n        at org.openrewrite.groovy.GroovyParserVisitor.convertTopLevelStatement(GroovyParserVisitor.java:2023)\r\n        at org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:161)\r\n        ... 204 more\r\n```\r\n",
    "issue_word_count": 2811,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java"
    ],
    "base_commit": "1aee2af8245b444095d2e2abdf82330c68d9f024",
    "head_commit": "ff7b86c6727854d230c6a6387df611450fcd13cf",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4832",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4832",
    "dockerfile": "",
    "pr_merged_at": "2025-01-02T14:50:20.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex 783740c03c2..c34c258ee86 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -60,6 +60,7 @@\n \n import static java.util.Collections.emptyList;\n import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n import static org.openrewrite.Tree.randomId;\n import static org.openrewrite.internal.StringUtils.indexOfNextNonWhitespace;\n import static org.openrewrite.java.tree.Space.EMPTY;\n@@ -408,7 +409,7 @@ class A {\n                                         Statement stat = pollQueue();\n                                         return maybeSemicolon(stat);\n                                     }))\n-                            .collect(Collectors.toList()),\n+                            .collect(toList()),\n                     sourceBefore(\"}\"));\n         }\n \n@@ -483,36 +484,37 @@ protected void visitAnnotation(AnnotationNode annotation) {\n             NameTree annotationType = visitTypeTree(annotation.getClassNode());\n             JContainer<Expression> arguments = null;\n             if (!annotation.getMembers().isEmpty()) {\n-                // This doesn't handle the case where an annotation has empty arguments like @Foo(), but that is rare\n                 arguments = JContainer.build(\n                         sourceBefore(\"(\"),\n                         annotation.getMembers().entrySet().stream()\n                                 .map(arg -> {\n-                                    Space argPrefix;\n-                                    if (\"value\".equals(arg.getKey())) {\n-                                        // Determine whether the value is implicit or explicit\n-                                        int saveCursor = cursor;\n-                                        argPrefix = whitespace();\n-                                        if (!source.startsWith(\"value\", cursor)) {\n-                                            return new JRightPadded<Expression>(\n-                                                    ((Expression) bodyVisitor.visit(arg.getValue())).withPrefix(argPrefix),\n-                                                    arg.getKey().equals(lastArgKey) ? sourceBefore(\")\") : sourceBefore(\",\"),\n-                                                    Markers.EMPTY);\n-                                        }\n-                                        cursor = saveCursor;\n+                                    boolean isImplicitValue = \"value\".equals(arg.getKey()) && !source.startsWith(\"value\", indexOfNextNonWhitespace(cursor, source));\n+                                    Space argPrefix = isImplicitValue ? whitespace() : sourceBefore(arg.getKey());\n+                                    Space isSign = isImplicitValue ? null : sourceBefore(\"=\");\n+                                    Expression expression;\n+                                    if (arg.getValue() instanceof AnnotationConstantExpression) {\n+                                        visitAnnotation((AnnotationNode) ((AnnotationConstantExpression) arg.getValue()).getValue());\n+                                        expression = (J.Annotation) queue.poll();\n+                                    } else {\n+                                        expression = bodyVisitor.visit(arg.getValue());\n                                     }\n-                                    argPrefix = sourceBefore(arg.getKey());\n-                                    J.Identifier argName = new J.Identifier(randomId(), EMPTY, Markers.EMPTY, emptyList(), arg.getKey(), null, null);\n-                                    J.Assignment assign = new J.Assignment(randomId(), argPrefix, Markers.EMPTY,\n-                                            argName, padLeft(sourceBefore(\"=\"), bodyVisitor.visit(arg.getValue())),\n-                                            null);\n-                                    return JRightPadded.build((Expression) assign)\n+                                    Expression element = isImplicitValue ? expression\n+                                            : (new J.Assignment(randomId(), argPrefix, Markers.EMPTY,\n+                                            new J.Identifier(randomId(), EMPTY, Markers.EMPTY, emptyList(), arg.getKey(), null, null),\n+                                            padLeft(isSign, expression), null));\n+                                    return JRightPadded.build(element)\n                                             .withAfter(arg.getKey().equals(lastArgKey) ? sourceBefore(\")\") : sourceBefore(\",\"));\n                                 })\n-                                .collect(Collectors.toList()),\n+                                .collect(toList()),\n                         Markers.EMPTY\n                 );\n+            } else if (source.startsWith(\"(\", indexOfNextNonWhitespace(cursor, source))) {\n+                // An annotation with empty arguments like @Foo()\n+                arguments = JContainer.build(sourceBefore(\"(\"),\n+                        singletonList(JRightPadded.build(new J.Empty(randomId(), sourceBefore(\")\"), Markers.EMPTY))),\n+                        Markers.EMPTY);\n             }\n+\n             queue.add(new J.Annotation(randomId(), prefix, Markers.EMPTY, annotationType, arguments));\n         }\n \n@@ -761,7 +763,7 @@ public void visitArgumentlistExpression(ArgumentListExpression expression) {\n \n             List<org.codehaus.groovy.ast.expr.Expression> unparsedArgs = expression.getExpressions().stream()\n                     .filter(GroovyParserVisitor::appearsInSource)\n-                    .collect(Collectors.toList());\n+                    .collect(toList());\n             // If the first parameter to a function is a Map, then groovy allows \"named parameters\" style invocations, see:\n             //     https://docs.groovy-lang.org/latest/html/documentation/#_named_parameters_2\n             // When named parameters are in use they may appear before, after, or intermixed with any positional arguments\n@@ -778,7 +780,7 @@ public void visitArgumentlistExpression(ArgumentListExpression expression) {\n                                         unparsedArgs.subList(1, unparsedArgs.size()).stream())\n                                 .sorted(Comparator.comparing(ASTNode::getLastLineNumber)\n                                         .thenComparing(ASTNode::getLastColumnNumber))\n-                                .collect(Collectors.toList());\n+                                .collect(toList());\n             } else if (!unparsedArgs.isEmpty() && unparsedArgs.get(0) instanceof MapExpression) {\n                 // The map literal may or may not be wrapped in \"[]\"\n                 // If it is wrapped in \"[]\" then this isn't a named arguments situation, and we should not lift the parameters out of the enclosing MapExpression\n@@ -792,7 +794,7 @@ public void visitArgumentlistExpression(ArgumentListExpression expression) {\n                             Stream.concat(\n                                             namedArgExpressions.getMapEntryExpressions().stream(),\n                                             unparsedArgs.subList(1, unparsedArgs.size()).stream())\n-                                    .collect(Collectors.toList());\n+                                    .collect(toList());\n                 }\n             }\n \n@@ -1323,9 +1325,6 @@ public void visitConstantExpression(ConstantExpression expression) {\n                         text = \"\";\n                     }\n                     jType = JavaType.Primitive.Null;\n-                } else if (expression instanceof AnnotationConstantExpression) {\n-                    classVisitor.visitAnnotation((AnnotationNode) value);\n-                    return ((Expression) classVisitor.pollQueue()).withPrefix(fmt);\n                 } else {\n                     throw new IllegalStateException(\"Unexpected constant type \" + type);\n                 }\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java\nindex a87695e7d71..b028da0dfa5 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java\n@@ -30,8 +30,43 @@ void simple() {\n           groovy(\n             \"\"\"\n               @Foo\n-              class Test {\n-              }\n+              class Test {}\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void withParentheses() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              @Foo()\n+              class Test {}\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void withProperties() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              @Foo(value = \"A\", version = \"1.0\")\n+              class Test {}\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void withImplicitValueProperty() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              @Foo(\"A\")\n+              class Test {}\n               \"\"\"\n           )\n         );\n@@ -43,9 +78,8 @@ void nested() {\n         rewriteRun(\n           groovy(\n             \"\"\"\n-              @Foo(bar = @Bar)\n-              class Test {\n-              }\n+              @Foo(bar = @Bar(@Baz(baz = @Qux(\"1.0\"))))\n+              class Test {}\n               \"\"\"\n           )\n         );\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4798",
    "pr_id": 4798,
    "issue_id": 4779,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Dependencies of plugins are not updated\nUsing the following example recipe:\r\n\r\n```yaml\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: com.my.group.Example\r\ndisplayName: Example\r\ndescription: Example\r\nrecipeList:\r\n  - org.openrewrite.maven.ChangePluginGroupIdAndArtifactId:\r\n      oldGroupId: com.my.group\r\n      oldArtifactId: app-plugin-artifact\r\n      newGroupId: com.my.group.subgroup\r\n  - org.openrewrite.maven.ChangeDependencyGroupIdAndArtifactId:\r\n      oldGroupId: com.my.group\r\n      oldArtifactId: app-plugin-artifact\r\n      newGroupId: com.my.group.subgroup\r\n  - org.openrewrite.maven.ChangeManagedDependencyGroupIdAndArtifactId:\r\n      oldGroupId: com.my.group\r\n      oldArtifactId: app-plugin-artifact\r\n      newArtifactId: app-plugin-artifact\r\n      newGroupId: com.my.group.subgroup\r\n```\r\n\r\nThis fails to update the dependencies of plugins. For example:\r\n\r\n```xml\r\n<project>\r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <groupId>com.app.myapp</groupId>\r\n  <artifactId>awesome-app</artifactId>\r\n  <version>1.0.0</version>\r\n\r\n  <build>\r\n    <plugins>\r\n      <plugin>\r\n        <groupId>com.app.plugins</groupId>\r\n        <artifactId>cool-plugin</artifactId>\r\n        <version>1.0.0</version>\r\n        <dependencies>\r\n          <dependency>\r\n            <groupId>com.my.group</groupId>\r\n            <artifactId>app-plugin-artifact</artifactId>\r\n            <version>1.1.0</version>\r\n          </dependency>\r\n        </dependencies>\r\n      </plugin>\r\n    </plugins>\r\n  </build>\r\n</project>\r\n```\r\n\r\nI would expect at least one of these recipes to update the groupId of the plugin dependency. If there is a recipe that can do this, it's not clear to me which one it would be.",
    "issue_word_count": 191,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java"
    ],
    "base_commit": "65c9cf166faeafa72c6ac81e2bd28c692903ed07",
    "head_commit": "5a85fc6835fc461053178dfb70cc95450cedb57d",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4798",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4798",
    "dockerfile": "",
    "pr_merged_at": "2024-12-18T22:42:07.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\nindex 96e6b4a5eaa..4bb4ccce955 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\n@@ -175,7 +175,7 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                     maybeUpdateModel();\n                     return t;\n                 }\n-                if (isOldDependencyTag) {\n+                if (isOldDependencyTag || isPluginDependencyTag(oldGroupId, oldArtifactId)) {\n                     String groupId = newGroupId;\n                     if (groupId != null) {\n                         t = changeChildTagValue(t, \"groupId\", groupId, ctx);\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\nindex 70bfef61989..a0fb4005f9c 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\n@@ -1557,4 +1557,71 @@ void changeProfileDependencyGroupIdAndArtifactId() {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4779\")\n+    void changePluginDependencyGroupIdAndArtifactId() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependencyGroupIdAndArtifactId(\n+            \"javax.activation\",\n+            \"javax.activation-api\",\n+            \"jakarta.activation\",\n+            \"jakarta.activation-api\",\n+            null,\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+            <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+            \n+                <build>\n+                    <plugins>\n+                        <plugin>\n+                            <groupId>com.mycompany.myplugin</groupId>\n+                            <artifactId>my-plugin</artifactId>\n+                            <version>1.0.0</version>\n+                            <dependencies>\n+                                <dependency>\n+                                    <groupId>javax.activation</groupId>\n+                                    <artifactId>javax.activation-api</artifactId>\n+                                    <version>1.2.0</version>\n+                                </dependency>\n+                            </dependencies>\n+                        </plugin>\n+                    </plugins>\n+                </build>\n+            </project>\n+            \"\"\",\n+            \"\"\"\n+            <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+            \n+                <build>\n+                    <plugins>\n+                        <plugin>\n+                            <groupId>com.mycompany.myplugin</groupId>\n+                            <artifactId>my-plugin</artifactId>\n+                            <version>1.0.0</version>\n+                            <dependencies>\n+                                <dependency>\n+                                    <groupId>jakarta.activation</groupId>\n+                                    <artifactId>jakarta.activation-api</artifactId>\n+                                    <version>1.2.0</version>\n+                                </dependency>\n+                            </dependencies>\n+                        </plugin>\n+                    </plugins>\n+                </build>\n+            </project>\n+            \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4782",
    "pr_id": 4782,
    "issue_id": 4760,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Maven artifact cannot be download when `settings.xml` contains a `<repository>` URL that produces a HTTP 302 redirect\nWhen I set a URL in the repository node of settings. xml that returns 302, it doesn't work",
    "issue_word_count": 37,
    "test_files_count": 3,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-core/build.gradle.kts",
      "rewrite-maven/build.gradle.kts",
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/http/OkHttpSender.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/http/OkHttpSender.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java"
    ],
    "base_commit": "4201b5caf304cb3f8cd922daf16a7525db36576d",
    "head_commit": "e4e373bc6125bd265c3c69d6d9b104ce2043e289",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4782",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4782",
    "dockerfile": "",
    "pr_merged_at": "2024-12-13T12:48:40.000Z",
    "patch": "diff --git a/rewrite-core/build.gradle.kts b/rewrite-core/build.gradle.kts\nindex ef8625e288e..e3a59325a5f 100644\n--- a/rewrite-core/build.gradle.kts\n+++ b/rewrite-core/build.gradle.kts\n@@ -15,10 +15,6 @@ dependencies {\n \n     api(\"org.jspecify:jspecify:latest.release\")\n \n-    // Pinning okhttp while waiting on 5.0.0\n-    // https://github.com/openrewrite/rewrite/issues/1479\n-    compileOnly(\"com.squareup.okhttp3:okhttp:4.9.3\")\n-\n     implementation(\"org.apache.commons:commons-compress:latest.release\")\n \n     implementation(\"io.micrometer:micrometer-core:1.9.+\")\n\ndiff --git a/rewrite-maven/build.gradle.kts b/rewrite-maven/build.gradle.kts\nindex d6efe37c616..ac44b44e905 100755\n--- a/rewrite-maven/build.gradle.kts\n+++ b/rewrite-maven/build.gradle.kts\n@@ -35,6 +35,8 @@ dependencies {\n     implementation(\"org.apache.commons:commons-text:latest.release\")\n \n     testImplementation(project(\":rewrite-test\"))\n+\n+    testImplementation(\"com.squareup.okhttp3:okhttp:4.+\")\n     testImplementation(\"com.squareup.okhttp3:mockwebserver:4.+\")\n     testImplementation(\"com.squareup.okhttp3:okhttp-tls:4.+\")\n     testImplementation(\"com.squareup.okio:okio-jvm:3.9.1\")\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\nindex b3cbe440c88..cef61f90ef3 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\n@@ -31,7 +31,7 @@\n import org.openrewrite.Issue;\n import org.openrewrite.ParseExceptionResult;\n import org.openrewrite.Parser;\n-import org.openrewrite.ipc.http.OkHttpSender;\n+import org.openrewrite.maven.http.OkHttpSender;\n import org.openrewrite.maven.internal.MavenParsingException;\n import org.openrewrite.maven.tree.*;\n import org.openrewrite.test.RewriteTest;\n\ndiff --git a/rewrite-core/src/main/java/org/openrewrite/ipc/http/OkHttpSender.java b/rewrite-maven/src/test/java/org/openrewrite/maven/http/OkHttpSender.java\nsimilarity index 97%\nrename from rewrite-core/src/main/java/org/openrewrite/ipc/http/OkHttpSender.java\nrename to rewrite-maven/src/test/java/org/openrewrite/maven/http/OkHttpSender.java\nindex eb42f70c913..e92a9359c1d 100644\n--- a/rewrite-core/src/main/java/org/openrewrite/ipc/http/OkHttpSender.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/http/OkHttpSender.java\n@@ -13,12 +13,13 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.openrewrite.ipc.http;\n+package org.openrewrite.maven.http;\n \n import okhttp3.MediaType;\n import okhttp3.OkHttpClient;\n import okhttp3.RequestBody;\n import okhttp3.ResponseBody;\n+import org.openrewrite.ipc.http.HttpSender;\n \n import java.io.IOException;\n import java.io.UncheckedIOException;\n\ndiff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java\nindex 152265c02fd..4c19fc87f33 100755\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java\n@@ -33,7 +33,7 @@\n import org.openrewrite.*;\n import org.openrewrite.ipc.http.HttpSender;\n import org.openrewrite.ipc.http.HttpUrlConnectionSender;\n-import org.openrewrite.ipc.http.OkHttpSender;\n+import org.openrewrite.maven.http.OkHttpSender;\n import org.openrewrite.maven.MavenDownloadingException;\n import org.openrewrite.maven.MavenExecutionContextView;\n import org.openrewrite.maven.MavenParser;\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4757",
    "pr_id": 4757,
    "issue_id": 4748,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Groovy parser does not support multiple variable declarations\n## What is the smallest, simplest way to reproduce the problem?\r\n\r\n```groovy\r\n@Test\r\nvoid multipleAssignmentsAtOneLine() {\r\n    rewriteRun(\r\n        groovy(\r\n            \"\"\"\r\n             def a = '1', b = '2'\r\n            \"\"\"\r\n        )\r\n     );\r\n }\r\n```\r\n\r\n## What did you expect to see?\r\nWorking tests\r\n\r\n## What did you see instead?\r\n```\r\nExpected :\"def a = '1', b = '2'\"\r\nActual   :\"def a = '1', bb = '2'\"\r\n```\r\n\r\n\r\n_Multiple variable declarations is also called combined variable declaration. Each variable is independently assigned, and there's no unpacking of a collection like it is with the multiple assignments groovy feature._",
    "issue_word_count": 86,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java",
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/marker/MultiVariable.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AssignmentTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AssignmentTest.java"
    ],
    "base_commit": "601fec7db38de41e05d1cb75a2b86a6963574c2f",
    "head_commit": "7de11c808fa6ddeea0e14c2e41a76c173b56efdd",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4757",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4757",
    "dockerfile": "",
    "pr_merged_at": "2024-12-17T11:55:42.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\nindex 61659730458..64e58977947 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/AddDependencyVisitor.java\n@@ -290,22 +290,10 @@ public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Execu\n                             }\n                         } else {\n                             Space originalPrefix = addDependencyInvocation.getPrefix();\n-                            if (currentStatement instanceof J.VariableDeclarations) {\n-                                J.VariableDeclarations variableDeclarations = (J.VariableDeclarations) currentStatement;\n-                                if (variableDeclarations.getTypeExpression() != null) {\n-                                    addDependencyInvocation = addDependencyInvocation.withPrefix(variableDeclarations.getTypeExpression().getPrefix());\n-                                }\n-                            } else {\n-                                addDependencyInvocation = addDependencyInvocation.withPrefix(currentStatement.getPrefix());\n-                            }\n+                            addDependencyInvocation = addDependencyInvocation.withPrefix(currentStatement.getPrefix());\n \n                             if (addDependencyInvocation.getSimpleName().equals(beforeDependency.getSimpleName())) {\n-                                if (currentStatement instanceof J.VariableDeclarations) {\n-                                    J.VariableDeclarations variableDeclarations = (J.VariableDeclarations) currentStatement;\n-                                    if (variableDeclarations.getTypeExpression() != null && !variableDeclarations.getTypeExpression().getPrefix().equals(originalPrefix)) {\n-                                        statements.set(i, variableDeclarations.withTypeExpression(variableDeclarations.getTypeExpression().withPrefix(originalPrefix)));\n-                                    }\n-                                } else if (!currentStatement.getPrefix().equals(originalPrefix)) {\n+                                if (!currentStatement.getPrefix().equals(originalPrefix)) {\n                                     statements.set(i, currentStatement.withPrefix(originalPrefix));\n                                 }\n                             }\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex e14a122df1f..abf35207e2e 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -39,9 +39,9 @@\n import org.openrewrite.java.marker.OmitParentheses;\n import org.openrewrite.java.marker.Semicolon;\n import org.openrewrite.java.marker.TrailingComma;\n-import org.openrewrite.java.tree.*;\n import org.openrewrite.java.tree.Expression;\n import org.openrewrite.java.tree.Statement;\n+import org.openrewrite.java.tree.*;\n import org.openrewrite.marker.Markers;\n \n import java.math.BigDecimal;\n@@ -113,16 +113,16 @@ private static boolean isOlderThanGroovy3() {\n     }\n \n     /**\n-     *  Groovy methods can be declared with \"def\" AND a return type\n-     *  In these cases the \"def\" is semantically meaningless but needs to be preserved for source code accuracy\n-     *  If there is both a def and a return type, this method returns a RedundantDef object and advances the cursor\n-     *  position past the \"def\" keyword, leaving the return type to be parsed as normal.\n-     *  In any other situation an empty Optional is returned and the cursor is not advanced.\n+     * Groovy methods can be declared with \"def\" AND a return type\n+     * In these cases the \"def\" is semantically meaningless but needs to be preserved for source code accuracy\n+     * If there is both a def and a return type, this method returns a RedundantDef object and advances the cursor\n+     * position past the \"def\" keyword, leaving the return type to be parsed as normal.\n+     * In any other situation an empty Optional is returned and the cursor is not advanced.\n      */\n     private Optional<RedundantDef> maybeRedundantDef(ClassNode type, String name) {\n         int saveCursor = cursor;\n         Space defPrefix = whitespace();\n-        if(source.startsWith(\"def\", cursor)) {\n+        if (source.startsWith(\"def\", cursor)) {\n             skip(\"def\");\n             // The def is redundant only when it is followed by the method's return type\n             // I hope no one puts an annotation between \"def\" and the return type\n@@ -182,8 +182,8 @@ public G.CompilationUnit visit(SourceUnit unit, ModuleNode ast) throws GroovyPar\n         for (ClassNode aClass : ast.getClasses()) {\n             if (aClass.getSuperClass() == null ||\n                 !(\"groovy.lang.Script\".equals(aClass.getSuperClass().getName()) ||\n-                     \"RewriteGradleProject\".equals(aClass.getSuperClass().getName()) ||\n-                     \"RewriteSettings\".equals(aClass.getSuperClass().getName()))) {\n+                  \"RewriteGradleProject\".equals(aClass.getSuperClass().getName()) ||\n+                  \"RewriteSettings\".equals(aClass.getSuperClass().getName()))) {\n                 sortedByPosition.computeIfAbsent(pos(aClass), i -> new ArrayList<>()).add(aClass);\n             }\n         }\n@@ -822,8 +822,8 @@ public void visitArgumentlistExpression(ArgumentListExpression expression) {\n             // When named parameters are in use they may appear before, after, or intermixed with any positional arguments\n             if (unparsedArgs.size() > 1 && unparsedArgs.get(0) instanceof MapExpression &&\n                 (unparsedArgs.get(0).getLastLineNumber() > unparsedArgs.get(1).getLastLineNumber() ||\n-                    (unparsedArgs.get(0).getLastLineNumber() == unparsedArgs.get(1).getLastLineNumber() &&\n-                        unparsedArgs.get(0).getLastColumnNumber() > unparsedArgs.get(1).getLastColumnNumber()))) {\n+                 (unparsedArgs.get(0).getLastLineNumber() == unparsedArgs.get(1).getLastLineNumber() &&\n+                  unparsedArgs.get(0).getLastColumnNumber() > unparsedArgs.get(1).getLastColumnNumber()))) {\n \n                 // Figure out the source-code ordering of the expressions\n                 MapExpression namedArgExpressions = (MapExpression) unparsedArgs.get(0);\n@@ -1099,7 +1099,7 @@ public void visitBlockStatement(BlockStatement block) {\n                 J expr = visit(statement);\n                 if (i == blockStatements.size() - 1 && (expr instanceof Expression)) {\n                     if (parent instanceof ClosureExpression || (parent instanceof MethodNode &&\n-                            !JavaType.Primitive.Void.equals(typeMapping.type(((MethodNode) parent).getReturnType())))) {\n+                                                                !JavaType.Primitive.Void.equals(typeMapping.type(((MethodNode) parent).getReturnType())))) {\n                         expr = new J.Return(randomId(), expr.getPrefix(), Markers.EMPTY,\n                                 expr.withPrefix(EMPTY));\n                         expr = expr.withMarkers(expr.getMarkers().add(new ImplicitReturn(randomId())));\n@@ -1438,7 +1438,10 @@ public void visitNotExpression(NotExpression expression) {\n \n         @Override\n         public void visitDeclarationExpression(DeclarationExpression expression) {\n+            Space prefix = whitespace();\n             Optional<RedundantDef> redundantDef = maybeRedundantDef(expression.getVariableExpression().getType(), expression.getVariableExpression().getName());\n+            Optional<MultiVariable> multiVariable = maybeMultiVariable();\n+            List<J.Modifier> modifiers = getModifiers();\n             TypeTree typeExpr = visitVariableExpressionType(expression.getVariableExpression());\n \n             J.VariableDeclarations.NamedVariable namedVariable;\n@@ -1466,19 +1469,60 @@ public void visitDeclarationExpression(DeclarationExpression expression) {\n \n             J.VariableDeclarations variableDeclarations = new J.VariableDeclarations(\n                     randomId(),\n-                    EMPTY,\n-                    redundantDef.map(Markers.EMPTY::add).orElse(Markers.EMPTY),\n-                    emptyList(),\n+                    prefix,\n+                    Markers.EMPTY,\n                     emptyList(),\n+                    modifiers,\n                     typeExpr,\n                     null,\n                     emptyList(),\n                     singletonList(JRightPadded.build(namedVariable))\n             );\n+            if (redundantDef.isPresent()) {\n+                variableDeclarations = variableDeclarations.withMarkers(variableDeclarations.getMarkers().add(redundantDef.get()));\n+            }\n+            if (multiVariable.isPresent()) {\n+                variableDeclarations = variableDeclarations.withMarkers(variableDeclarations.getMarkers().add(multiVariable.get()));\n+            }\n \n             queue.add(variableDeclarations);\n         }\n \n+        private Optional<MultiVariable> maybeMultiVariable() {\n+            int saveCursor = cursor;\n+            Space commaPrefix = whitespace();\n+            if (source.startsWith(\",\", cursor)) {\n+                skip(\",\");\n+                return Optional.of(new MultiVariable(randomId(), commaPrefix));\n+            }\n+            cursor = saveCursor;\n+            return Optional.empty();\n+        }\n+\n+        private List<J.Modifier> getModifiers() {\n+            List<J.Modifier> modifiers = new ArrayList<>();\n+            int saveCursor = cursor;\n+            Space prefix = whitespace();\n+            while (source.startsWith(\"def\", cursor) || source.startsWith(\"var\", cursor) || source.startsWith(\"final\", cursor)) {\n+                if (source.startsWith(\"var\", cursor)) {\n+                    modifiers.add(new J.Modifier(randomId(), prefix, Markers.EMPTY, \"var\", J.Modifier.Type.LanguageExtension, emptyList()));\n+                    cursor += 3;\n+                } else if (source.startsWith(\"def\", cursor)) {\n+                    modifiers.add(new J.Modifier(randomId(), prefix, Markers.EMPTY, \"def\", J.Modifier.Type.LanguageExtension, emptyList()));\n+                    cursor += 3;\n+                } else if (source.startsWith(\"final\", cursor)) {\n+                    modifiers.add(new J.Modifier(randomId(), prefix, Markers.EMPTY, \"final\", J.Modifier.Type.LanguageExtension, emptyList()));\n+                    cursor += 5;\n+                } else {\n+                    break;\n+                }\n+                saveCursor = cursor;\n+                prefix = whitespace();\n+            }\n+            cursor = saveCursor;\n+            return modifiers;\n+        }\n+\n         @Override\n         public void visitEmptyExpression(EmptyExpression expression) {\n             queue.add(new J.Empty(randomId(), EMPTY, Markers.EMPTY));\n@@ -1766,7 +1810,7 @@ public void visitMethodCallExpression(MethodCallExpression call) {\n                 MethodNode methodNode = (MethodNode) call.getNodeMetaData().get(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);\n                 JavaType.Method methodType = null;\n                 if (methodNode == null && call.getObjectExpression() instanceof VariableExpression &&\n-                        ((VariableExpression) call.getObjectExpression()).getAccessedVariable() != null) {\n+                    ((VariableExpression) call.getObjectExpression()).getAccessedVariable() != null) {\n                     // Groovy doesn't know what kind of object this method is being invoked on\n                     // But if this invocation is inside a Closure we may have already enriched its parameters with types from the static type checker\n                     // Use any such type information to attempt to find a matching method\n@@ -2097,29 +2141,18 @@ public void visitPrefixExpression(PrefixExpression unary) {\n \n         public TypeTree visitVariableExpressionType(VariableExpression expression) {\n             JavaType type = typeMapping.type(staticType(((org.codehaus.groovy.ast.expr.Expression) expression)));\n+            Space prefix = whitespace();\n+            String typeName = \"\";\n \n-            if (expression.isDynamicTyped()) {\n-                Space prefix = whitespace();\n-                String keyword;\n-                if (source.substring(cursor).startsWith(\"final\")) {\n-                    keyword = \"final\";\n-                } else {\n-                    keyword = source.substring(cursor, cursor + 3);\n-                }\n-                cursor += keyword.length();\n-                return new J.Identifier(randomId(),\n-                        prefix,\n-                        Markers.EMPTY,\n-                        emptyList(),\n-                        keyword,\n-                        type, null);\n+            if (!expression.isDynamicTyped() && source.startsWith(expression.getOriginType().getUnresolvedName(), cursor)) {\n+                typeName = expression.getOriginType().getUnresolvedName();\n+                cursor += typeName.length();\n             }\n-            Space prefix = sourceBefore(expression.getOriginType().getUnresolvedName());\n             J.Identifier ident = new J.Identifier(randomId(),\n                     EMPTY,\n                     Markers.EMPTY,\n                     emptyList(),\n-                    expression.getOriginType().getUnresolvedName(),\n+                    typeName,\n                     type, null);\n             if (expression.getOriginType().getGenericsTypes() != null) {\n                 return new J.ParameterizedType(randomId(), prefix, Markers.EMPTY, ident, visitTypeParameterizations(\n@@ -2671,7 +2704,7 @@ private String name() {\n        Can contain a J.FieldAccess, as in a variable declaration with fully qualified type parameterization:\n            List<java.lang.String>\n      */\n-    private JContainer<Expression> visitTypeParameterizations(GenericsType @Nullable[] genericsTypes) {\n+    private JContainer<Expression> visitTypeParameterizations(GenericsType @Nullable [] genericsTypes) {\n         Space prefix = sourceBefore(\"<\");\n         List<JRightPadded<Expression>> parameters;\n \n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\nindex 17e0a466a6c..0ab2bb60c2c 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyPrinter.java\n@@ -265,13 +265,17 @@ public J visitVariableDeclarations(J.VariableDeclarations multiVariable, PrintOu\n             beforeSyntax(multiVariable, Space.Location.VARIABLE_DECLARATIONS_PREFIX, p);\n             visitSpace(Space.EMPTY, Space.Location.ANNOTATIONS, p);\n             visit(multiVariable.getLeadingAnnotations(), p);\n-            for (J.Modifier m : multiVariable.getModifiers()) {\n-                visitModifier(m, p);\n-            }\n             multiVariable.getMarkers().findFirst(RedundantDef.class).ifPresent(def -> {\n                 visitSpace(def.getPrefix(), Space.Location.LANGUAGE_EXTENSION, p);\n                 p.append(\"def\");\n             });\n+            for (J.Modifier m : multiVariable.getModifiers()) {\n+                visitModifier(m, p);\n+            }\n+            multiVariable.getMarkers().findFirst(MultiVariable.class).ifPresent(multiVar -> {\n+                visitSpace(multiVar.getPrefix(), Space.Location.NAMED_VARIABLE_SUFFIX, p);\n+                p.append(\",\");\n+            });\n             visit(multiVariable.getTypeExpression(), p);\n             // For backwards compatibility.\n             for (JLeftPadded<Space> dim : multiVariable.getDimensionsBeforeName()) {\n\ndiff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/marker/MultiVariable.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/marker/MultiVariable.java\nnew file mode 100644\nindex 00000000000..3554529bf6b\n--- /dev/null\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/marker/MultiVariable.java\n@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.groovy.marker;\n+\n+import lombok.Value;\n+import lombok.With;\n+import org.openrewrite.java.tree.Space;\n+import org.openrewrite.marker.Marker;\n+\n+import java.util.UUID;\n+\n+@Value\n+@With\n+public class MultiVariable implements Marker {\n+    UUID id;\n+    Space prefix;\n+}\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AssignmentTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AssignmentTest.java\nindex 8a15073a41b..e1421259a9d 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AssignmentTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AssignmentTest.java\n@@ -24,6 +24,41 @@\n @SuppressWarnings({\"GroovyUnusedAssignment\", \"GrUnnecessarySemicolon\"})\n class AssignmentTest implements RewriteTest {\n \n+    @Test\n+    void noKeyword() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              x = \"s\"\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void simple() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              def x = \"s\"\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void simpleWithFinal() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              final def x = \"x\"\n+              def final y = \"y\"\n+              final z = \"z\"\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void concat() {\n         rewriteRun(\n@@ -91,4 +126,52 @@ void baseNConversions() {\n           )\n         );\n     }\n+\n+    @Test\n+    void multipleAssignmentsAtOneLine() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              def startItem = '|  ', endItem = '  |'\n+              def repeatLength = startItem.length() + output.length() + endItem.length()\n+              println(\"\\\\n\" + (\"-\" * repeatLength) + \"\\\\n\" + startItem + output + endItem + \"\\\\n\" + (\"-\" * repeatLength))\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void multipleAssignmentsAtOneLineSimple() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              def a = '1', b = '2'\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void multipleAssignmentsAtMultipleLineDynamicType() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+               def a = '1'    ,  \n+                  b = '2'\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void multipleAssignmentsAtMultipleLineStaticType() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+               String a = '1'    ,  \n+                  b = '2'\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4753",
    "pr_id": 4753,
    "issue_id": 4589,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Authentication failure when using password encryption through Maven `settings-security.xml`\nHello,\r\n\r\nI have an issue running custom recipie for `org.openrewrite.maven.ChangeParentPom`\r\n\r\nHere is my configuration:\r\nA maven, multi-module project. I want to update the version of the parent of the root's pom.xml file.\r\n\r\nHere is my configuration in rules.yml file:\r\n```\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: my.test.UpgradeParent\r\ndisplayName: Change Maven dependency example\r\nrecipeList:\r\n  - org.openrewrite.maven.ChangeParentPom:\r\n      oldGroupId: com.my.group\r\n      oldArtifactId: my-artifact\r\n      newVersion: 1.0.4\r\n```\r\n\r\nIn my pom.xml I have:\r\n\r\n```\r\n<project>\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <parent>\r\n        <groupId>com.my.group</groupId>\r\n        <artifactId>my-artifact</artifactId>\r\n        <version>1.107</version>\r\n    </parent>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.openrewrite.maven</groupId>\r\n                <artifactId>rewrite-maven-plugin</artifactId>\r\n                <version>5.42.2</version>\r\n                <configuration>\r\n                    <configLocation>rules.yml</configLocation>\r\n                    <activeRecipes>\r\n                        <recipe>my.test.UpgradeParent</recipe>\r\n                    </activeRecipes>\r\n                    <failOnInvalidActiveRecipes>true</failOnInvalidActiveRecipes>\r\n                </configuration>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n...\r\n\r\n```\r\n\r\nBut when I run it with rewrite:run or rewrite:dryRun, it doesn't match my parent pom GAV and don't update it...\r\n\r\n```\r\n[INFO] --- rewrite:5.42.2:dryRun (default-cli) @ XXXXX-module ---\r\n[INFO] Using active recipe(s) [com.bnppf.UpgradeToSf5]\r\n[INFO] Using active styles(s) []\r\n[INFO] Validating active recipes...\r\n[INFO] Project [XXXXX] Resolving Poms...\r\n[INFO] Project [XXXXX] Parsing source files\r\n[INFO] Project [XXXXX-module1] Parsing source files\r\n[INFO] Project [XXXXX-module2] Parsing source files\r\n[INFO] Project [XXXXX-module3] Parsing source files\r\n[INFO] Project [XXXXX-module4] Parsing source files\r\n[INFO] Project [XXXXX-module5] Parsing source files\r\n[INFO] Running recipe(s)...\r\n[INFO] Applying recipes would make no changes. No patch file generated.\r\n```\r\n\r\nI tried to specify newArtifactId, newGroupId, but it changes nothing.... What am I doing wrong?\r\nAny help will be highly appreciated...\r\n\r\nThank you very much in advance!\r\n\r\n\r\nI am using:\r\n\r\n- Maven plugin v5.42.2\r\n- Java version: 1.8 (and 11 and 17)\r\n- Maven version: 3.9.9\r\n\r\n",
    "issue_word_count": 312,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/MavenSecuritySettings.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/MavenSettings.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenSecuritySettingsTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenSecuritySettingsTest.java"
    ],
    "base_commit": "104f7053f2c89358ec036441e2be507c34edd4aa",
    "head_commit": "6c51dc497daa8d5867484ae08c55418629c86341",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4753",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4753",
    "dockerfile": "",
    "pr_merged_at": "2024-12-08T12:09:03.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenSecuritySettings.java b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenSecuritySettings.java\nnew file mode 100644\nindex 00000000000..f5006c9c612\n--- /dev/null\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenSecuritySettings.java\n@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.maven;\n+\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n+import lombok.*;\n+import lombok.experimental.FieldDefaults;\n+import org.jspecify.annotations.Nullable;\n+import org.openrewrite.ExecutionContext;\n+import org.openrewrite.Parser;\n+import org.openrewrite.internal.PropertyPlaceholderHelper;\n+import org.openrewrite.maven.internal.MavenXmlMapper;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Optional;\n+import java.util.function.UnaryOperator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static java.util.Collections.emptyList;\n+\n+@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n+@ToString(onlyExplicitlyIncluded = true)\n+@EqualsAndHashCode(onlyExplicitlyIncluded = true)\n+@Data\n+@AllArgsConstructor\n+@JacksonXmlRootElement(localName = \"settingsSecurity\")\n+public class MavenSecuritySettings {\n+\n+    @Nullable\n+    String master;\n+\n+    @Nullable\n+    String relocation;\n+\n+    private static @Nullable MavenSecuritySettings parse(Parser.Input source, ExecutionContext ctx) {\n+        try {\n+            return new Interpolator().interpolate(\n+                    MavenXmlMapper.readMapper().readValue(source.getSource(ctx), MavenSecuritySettings.class));\n+        } catch (IOException e) {\n+            ctx.getOnError().accept(new IOException(\"Failed to parse \" + source.getPath(), e));\n+            return null;\n+        }\n+    }\n+\n+    private static @Nullable MavenSecuritySettings parse(Path settingsPath, ExecutionContext ctx) {\n+        return parse(new Parser.Input(settingsPath, () -> {\n+            try {\n+                return Files.newInputStream(settingsPath);\n+            } catch (IOException e) {\n+                ctx.getOnError().accept(new IOException(\"Failed to read settings-security.xml at \" + settingsPath, e));\n+                return null;\n+            }\n+        }), ctx);\n+    }\n+\n+    public static @Nullable MavenSecuritySettings readMavenSecuritySettingsFromDisk(ExecutionContext ctx) {\n+        Optional<MavenSecuritySettings> userSettings = Optional.of(userSecuritySettingsPath())\n+                .filter(MavenSecuritySettings::exists)\n+                .map(path -> parse(path, ctx));\n+        MavenSecuritySettings installSettings = findMavenHomeSettings().map(path -> parse(path, ctx)).orElse(null);\n+        MavenSecuritySettings mergedSettings = userSettings\n+                .map(mavenSecuritySettings -> mavenSecuritySettings.merge(installSettings))\n+                .orElse(installSettings);\n+        if (mergedSettings != null && mergedSettings.relocation != null) {\n+            return mergedSettings.merge(parse(Paths.get(mergedSettings.relocation), ctx));\n+        }\n+        return mergedSettings;\n+    }\n+\n+    private static Path userSecuritySettingsPath() {\n+        return Paths.get(System.getProperty(\"user.home\")).resolve(\".m2/settings-security.xml\");\n+    }\n+\n+    private static Optional<Path> findMavenHomeSettings() {\n+        for (String envVariable : Arrays.asList(\"MVN_HOME\", \"M2_HOME\", \"MAVEN_HOME\")) {\n+            for (String s : Optional.ofNullable(System.getenv(envVariable)).map(Arrays::asList).orElse(emptyList())) {\n+                Path resolve = Paths.get(s).resolve(\"conf/settings-security.xml\");\n+                if (exists(resolve)) {\n+                    return Optional.of(resolve);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static boolean exists(Path path) {\n+        try {\n+            return path.toFile().exists();\n+        } catch (SecurityException e) {\n+            return false;\n+        }\n+    }\n+\n+    private MavenSecuritySettings merge(@Nullable MavenSecuritySettings installSettings) {\n+        return installSettings == null ? this : new MavenSecuritySettings(\n+                master == null ? installSettings.master : master,\n+                relocation == null ? installSettings.relocation : relocation\n+        );\n+    }\n+\n+    /**\n+     * Resolve all properties EXCEPT in the profiles section, which can be affected by\n+     * the POM using the settings.\n+     */\n+    private static class Interpolator {\n+        private static final PropertyPlaceholderHelper propertyPlaceholders = new PropertyPlaceholderHelper(\n+                \"${\", \"}\", null);\n+\n+        private static final UnaryOperator<String> propertyResolver = key -> {\n+            String property = System.getProperty(key);\n+            if (property != null) {\n+                return property;\n+            }\n+            if (key.startsWith(\"env.\")) {\n+                return System.getenv().get(key.substring(4));\n+            }\n+            return System.getenv().get(key);\n+        };\n+\n+        public MavenSecuritySettings interpolate(MavenSecuritySettings mavenSecuritySettings) {\n+            return new MavenSecuritySettings(\n+                    interpolate(mavenSecuritySettings.master),\n+                    interpolate(mavenSecuritySettings.relocation)\n+            );\n+        }\n+\n+        private @Nullable String interpolate(@Nullable String s) {\n+            return s == null ? null : propertyPlaceholders.replacePlaceholders(s, propertyResolver);\n+        }\n+    }\n+\n+    @Nullable\n+    String decrypt(@Nullable String fieldValue, @Nullable String password) {\n+        if (fieldValue == null || fieldValue.isEmpty() || password == null) {\n+            return null;\n+        }\n+\n+        try {\n+            byte[] encryptedText = extractPassword(fieldValue);\n+\n+            byte[] salt = new byte[8];\n+            System.arraycopy(encryptedText, 0, salt, 0, 8);\n+\n+            int padLength = encryptedText[8];\n+            byte[] encryptedBytes = new byte[encryptedText.length - 9 - padLength];\n+            System.arraycopy(encryptedText, 9, encryptedBytes, 0, encryptedBytes.length);\n+\n+            byte[] keyAndIV = new byte[32];\n+            byte[] pwdBytes = extractPassword(password);\n+            int offset = 0;\n+            while (offset < 32) {\n+                java.security.MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA-256\");\n+                digest.update(pwdBytes);\n+                digest.update(salt);\n+                byte[] hash = digest.digest();\n+                System.arraycopy(hash, 0, keyAndIV, offset, Math.min(hash.length, 32 - offset));\n+                offset += hash.length;\n+            }\n+\n+            Key key = new SecretKeySpec(keyAndIV, 0, 16, \"AES\");\n+            IvParameterSpec iv = new IvParameterSpec(keyAndIV, 16, 16);\n+            Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n+            cipher.init(Cipher.DECRYPT_MODE, key, iv);\n+            byte[] clearBytes = cipher.doFinal(encryptedBytes);\n+\n+            int paddingLength = clearBytes[clearBytes.length - 1];\n+            byte[] decryptedBytes = new byte[clearBytes.length - paddingLength];\n+            System.arraycopy(clearBytes, 0, decryptedBytes, 0, decryptedBytes.length);\n+            return new String(decryptedBytes, StandardCharsets.UTF_8);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException | BadPaddingException | IllegalBlockSizeException |\n+                 InvalidKeyException | InvalidAlgorithmParameterException | IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    private byte[] extractPassword(String pwd) throws IllegalArgumentException {\n+        Pattern pattern = Pattern.compile(\".*?[^\\\\\\\\]?\\\\{(.*?)}.*\");\n+        Matcher matcher = pattern.matcher(pwd);\n+        if (matcher.find()) {\n+            return Base64.getDecoder().decode(matcher.group(1));\n+        }\n+        return pwd.getBytes(StandardCharsets.UTF_8);\n+    }\n+}\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenSettings.java b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenSettings.java\nindex ae23c9ff06b..2c56bd6ddee 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenSettings.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenSettings.java\n@@ -34,12 +34,25 @@\n import org.openrewrite.maven.tree.MavenRepository;\n import org.openrewrite.maven.tree.ProfileActivation;\n \n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n import java.util.*;\n import java.util.function.UnaryOperator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n import static java.util.Collections.emptyList;\n import static org.openrewrite.maven.tree.MavenRepository.MAVEN_LOCAL_DEFAULT;\n@@ -109,10 +122,40 @@ public MavenSettings(@Nullable String localRepository, @Nullable Profiles profil\n                 .filter(MavenSettings::exists)\n                 .map(path -> parse(path, ctx));\n         final MavenSettings installSettings = findMavenHomeSettings().map(path -> parse(path, ctx)).orElse(null);\n-        return userSettings.map(mavenSettings -> mavenSettings.merge(installSettings))\n+        MavenSettings settings = userSettings.map(mavenSettings -> mavenSettings.merge(installSettings))\n                 .orElse(installSettings);\n+\n+        if (settings != null) {\n+            settings.maybeDecryptPasswords(ctx);\n+        }\n+\n+        return settings;\n     }\n \n+    void maybeDecryptPasswords(ExecutionContext ctx) {\n+        MavenSecuritySettings security = MavenSecuritySettings.readMavenSecuritySettingsFromDisk(ctx);\n+        if (security == null) {\n+            return;\n+        }\n+\n+        String decryptedMasterPassword = security.decrypt(security.getMaster(), \"settings.security\");\n+        if (decryptedMasterPassword != null) {\n+            if (mavenLocal != null) {\n+                String password = security.decrypt(mavenLocal.getPassword(), decryptedMasterPassword);\n+                if (password != null) {\n+                    mavenLocal = mavenLocal.withPassword(password);\n+                }\n+            }\n+            if (servers != null) {\n+                servers.servers = ListUtils.map(servers.servers, server -> {\n+                    String password = security.decrypt(server.getPassword(), decryptedMasterPassword);\n+                    return password == null ? server : server.withPassword(password);\n+                });\n+            }\n+        }\n+    }\n+\n+\n     public static boolean readFromDiskEnabled() {\n         final String propertyValue = System.getProperty(\"org.openrewrite.test.readMavenSettingsFromDisk\");\n         return propertyValue != null && !propertyValue.equalsIgnoreCase(\"false\");\n@@ -158,7 +201,7 @@ public List<RawRepositories.Repository> getActiveRepositories(Iterable<String> a\n         if (profiles != null) {\n             for (Profile profile : profiles.getProfiles()) {\n                 if (profile.isActive(activeProfiles) || (this.activeProfiles != null &&\n-                                                         profile.isActive(this.activeProfiles.getActiveProfiles()))) {\n+                        profile.isActive(this.activeProfiles.getActiveProfiles()))) {\n                     if (profile.repositories != null) {\n                         for (RawRepositories.Repository repository : profile.repositories.getRepositories()) {\n                             activeRepositories.put(repository.getId(), repository);\n@@ -409,7 +452,8 @@ public static class Server {\n     @JsonIgnoreProperties(value = \"httpHeaders\")\n     public static class ServerConfiguration {\n         @JacksonXmlProperty(localName = \"property\")\n-        @JacksonXmlElementWrapper(localName = \"httpHeaders\", useWrapping = true) // wrapping is disabled by default on MavenXmlMapper\n+        @JacksonXmlElementWrapper(localName = \"httpHeaders\", useWrapping = true)\n+        // wrapping is disabled by default on MavenXmlMapper\n         @Nullable\n         List<HttpHeader> httpHeaders;\n \n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenSecuritySettingsTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenSecuritySettingsTest.java\nnew file mode 100644\nindex 00000000000..1166ba41b81\n--- /dev/null\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenSecuritySettingsTest.java\n@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.maven;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.openrewrite.InMemoryExecutionContext;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class MavenSecuritySettingsTest {\n+\n+    private static final String MASTER_PASS_ENCRYPTED = \"FyoLIiN2Fx8HpT8O0aBsTn2/s3pYmtLRRCpoWPzhN4A=\"; // \"master\"\n+    private static final String USER_PASS_ENCRYPTED = \"ERozWEamSJoHRBT+wVx51V2Emr9PazZR9txMntZPlJc=\"; // \"testpass\"\n+    private static final String USER_PASS_DECRYPTED = \"testpass\";\n+\n+    private String originalUserHome;\n+\n+    @TempDir\n+    Path tempDir;\n+\n+    @BeforeEach\n+    void setUp() throws IOException {\n+        originalUserHome = System.getProperty(\"user.home\");\n+        System.setProperty(\"user.home\", tempDir.toString());\n+        Files.createDirectories(tempDir.resolve(\".m2\"));\n+    }\n+\n+    @AfterEach\n+    void tearDown() {\n+        System.setProperty(\"user.home\", originalUserHome);\n+    }\n+\n+    @Test\n+    void decryptCredentials() throws IOException {\n+        // Create settings-security.xml with master password\n+        Files.writeString(tempDir.resolve(\".m2/settings-security.xml\"),\n+          //language=xml\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <settingsSecurity>\n+                <master>{%s}</master>\n+            </settingsSecurity>\n+            \"\"\".formatted(MASTER_PASS_ENCRYPTED));\n+\n+        // Create settings.xml with encrypted password\n+        Files.writeString(tempDir.resolve(\".m2/settings.xml\"),\n+          //language=xml\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <settings>\n+                <servers>\n+                    <server>\n+                        <id>test-server</id>\n+                        <username>admin</username>\n+                        <password>{%s}</password>\n+                    </server>\n+                </servers>\n+            </settings>\n+            \"\"\".formatted(USER_PASS_ENCRYPTED));\n+\n+        // Use the public API to read settings\n+        var ctx = new InMemoryExecutionContext(t -> {\n+            throw new RuntimeException(t);\n+        });\n+        MavenSettings settings = MavenSettings.readMavenSettingsFromDisk(ctx);\n+        assert settings != null && settings.getServers() != null;\n+        assertThat(settings.getServers().getServers())\n+          .hasSize(1)\n+          .first()\n+          .satisfies(server -> {\n+              assertThat(server.getId()).isEqualTo(\"test-server\");\n+              assertThat(server.getUsername()).isEqualTo(\"admin\");\n+              assertThat(server.getPassword()).isEqualTo(USER_PASS_DECRYPTED);\n+          });\n+    }\n+\n+    @Test\n+    void relocatedCredentials() throws IOException {\n+        // Create settings-security.xml with relocation\n+        Path relocated = tempDir.resolve(\".m2/relocation-settings-security.xml\");\n+        Files.writeString(tempDir.resolve(\".m2/settings-security.xml\"),\n+          //language=xml\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <settingsSecurity>\n+                <relocation>%s</relocation>\n+            </settingsSecurity>\n+            \"\"\".formatted(relocated));\n+        // Create relocation-settings-security.xml with master password\n+        Files.writeString(relocated,\n+          //language=xml\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <settingsSecurity>\n+                <master>{%s}</master>\n+            </settingsSecurity>\n+            \"\"\".formatted(MASTER_PASS_ENCRYPTED));\n+\n+        // Create settings.xml with encrypted password\n+        Files.writeString(tempDir.resolve(\".m2/settings.xml\"),\n+          //language=xml\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <settings>\n+                <servers>\n+                    <server>\n+                        <id>test-server</id>\n+                        <username>admin</username>\n+                        <password>{%s}</password>\n+                    </server>\n+                </servers>\n+            </settings>\n+            \"\"\".formatted(USER_PASS_ENCRYPTED));\n+\n+        // Use the public API to read settings\n+        var ctx = new InMemoryExecutionContext(t -> {\n+            throw new RuntimeException(t);\n+        });\n+        MavenSettings settings = MavenSettings.readMavenSettingsFromDisk(ctx);\n+        assert settings != null && settings.getServers() != null;\n+        assertThat(settings.getServers().getServers())\n+          .hasSize(1)\n+          .first()\n+          .satisfies(server -> {\n+              assertThat(server.getId()).isEqualTo(\"test-server\");\n+              assertThat(server.getUsername()).isEqualTo(\"admin\");\n+              assertThat(server.getPassword()).isEqualTo(USER_PASS_DECRYPTED);\n+          });\n+    }\n+\n+    @Test\n+    void handleInvalidEncryptedPassword() throws IOException {\n+        // Create settings-security.xml with master password\n+        Files.writeString(tempDir.resolve(\".m2/settings-security.xml\"),\n+          //language=xml\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <settingsSecurity>\n+                <master>{jSMOWnoPFgsHVpMvz5VrIt5kRbzGpI8u+9EF1iFQyJQ=}</master>\n+            </settingsSecurity>\n+            \"\"\");\n+\n+        // Create settings.xml with invalid encrypted password\n+        Files.writeString(tempDir.resolve(\".m2/settings.xml\"),\n+          //language=xml\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <settings>\n+                <servers>\n+                    <server>\n+                        <id>test-server</id>\n+                        <username>admin</username>\n+                        <password>{invalid_format}</password>\n+                    </server>\n+                </servers>\n+            </settings>\n+            \"\"\");\n+\n+        var ctx = new InMemoryExecutionContext(t -> {\n+            throw new RuntimeException(t);\n+        });\n+        MavenSettings settings = MavenSettings.readMavenSettingsFromDisk(ctx);\n+        assert settings != null && settings.getServers() != null;\n+        assertThat(settings.getServers().getServers()).hasSize(1)\n+          .first()\n+          .satisfies(server -> assertThat(server.getPassword()).isEqualTo(\"{invalid_format}\"));\n+    }\n+\n+    @Test\n+    void noSecuritySettingsNoDecryption() throws IOException {\n+        // Only create settings.xml without settings-security.xml\n+        Files.writeString(tempDir.resolve(\".m2/settings.xml\"),\n+          //language=xml\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <settings>\n+                <servers>\n+                    <server>\n+                        <id>test-server</id>\n+                        <username>admin</username>\n+                        <password>{encrypted_password}</password>\n+                    </server>\n+                </servers>\n+            </settings>\n+            \"\"\");\n+\n+        var ctx = new InMemoryExecutionContext(t -> {\n+            throw new RuntimeException(t);\n+        });\n+        MavenSettings settings = MavenSettings.readMavenSettingsFromDisk(ctx);\n+        assert settings != null && settings.getServers() != null;\n+        assertThat(settings.getServers().getServers())\n+          .hasSize(1)\n+          .first()\n+          .satisfies(server -> assertThat(server.getPassword()).isEqualTo(\"{encrypted_password}\"));\n+    }\n+\n+    @Test\n+    void decryptPasswordWithComments() throws IOException {\n+        // Create settings-security.xml with master password\n+        Files.writeString(tempDir.resolve(\".m2/settings-security.xml\"),\n+          //language=xml\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <settingsSecurity>\n+                <master>{%s}</master>\n+            </settingsSecurity>\n+            \"\"\".formatted(MASTER_PASS_ENCRYPTED));\n+\n+        // Create settings.xml with password containing comments\n+        Files.writeString(tempDir.resolve(\".m2/settings.xml\"),\n+          //language=xml\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <settings>\n+                <servers>\n+                    <server>\n+                        <id>test-server</id>\n+                        <username>admin</username>\n+                        <password>Oleg reset this password on 2009-03-11, expires on 2009-04-11 {%s}</password>\n+                    </server>\n+                </servers>\n+            </settings>\n+            \"\"\".formatted(USER_PASS_ENCRYPTED));\n+\n+        var ctx = new InMemoryExecutionContext(t -> {\n+            throw new RuntimeException(t);\n+        });\n+        MavenSettings settings = MavenSettings.readMavenSettingsFromDisk(ctx);\n+        assert settings != null && settings.getServers() != null;\n+        assertThat(settings.getServers().getServers())\n+          .hasSize(1)\n+          .first()\n+          .satisfies(server -> assertThat(server.getPassword()).isEqualTo(USER_PASS_DECRYPTED));\n+    }\n+\n+    @Test\n+    void invalidMasterPasswordButValidPasswordFormat() throws IOException {\n+        // Create settings-security.xml with invalid master password\n+        Files.writeString(tempDir.resolve(\".m2/settings-security.xml\"),\n+          //language=xml\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <settingsSecurity>\n+                <master>{invalid_master_password}</master>\n+            </settingsSecurity>\n+            \"\"\");\n+\n+        // Create settings.xml with valid encrypted password\n+        Files.writeString(tempDir.resolve(\".m2/settings.xml\"),\n+          //language=xml\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <settings>\n+                <servers>\n+                    <server>\n+                        <id>test-server</id>\n+                        <username>admin</username>\n+                        <password>{%s}</password>\n+                    </server>\n+                </servers>\n+            </settings>\n+            \"\"\".formatted(USER_PASS_ENCRYPTED));\n+\n+        var ctx = new InMemoryExecutionContext(t -> {\n+            throw new RuntimeException(t);\n+        });\n+        MavenSettings settings = MavenSettings.readMavenSettingsFromDisk(ctx);\n+        assert settings != null && settings.getServers() != null;\n+        assertThat(settings.getServers().getServers())\n+          .hasSize(1)\n+          .first()\n+          .satisfies(server ->\n+            // Password should remain in encrypted form since master password is invalid\n+            assertThat(server.getPassword()).isEqualTo(\"{%s}\".formatted(USER_PASS_ENCRYPTED)));\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4746",
    "pr_id": 4746,
    "issue_id": 4745,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Preserve annotation values parsed from dependencies in the classpath\n<!--\r\nThank you for suggesting an improvement to OpenRewrite!\r\nFeel free to delete any sections that don't apply to your request.\r\n-->\r\n## What problem are you trying to solve?\r\nI’m working on a linter for detecting certain methods in our code base. The linting is based on method annotations. The annotation in question has a value attached which I need for making the linting decision. The method in question is only in the classpath, not part of the source files.\r\n\r\nDependency lib in the classpath:\r\n```\r\n@Target({ElementType.FIELD, ElementType.METHOD})\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface EssentialTracker {\r\n  String value();\r\n}\r\n\r\npublic class TestEssentialTracker {\r\n @EssentialTracker(\"aaa\")\r\n public String getEssentialTracker() {\r\n  return \"test-essential-tracker\";\r\n }\r\n}\r\n```\r\n\r\nSource file input I'm linting:\r\n```\r\nString result = new TestEssentialTracker().getEssentialTracker();\r\n```\r\n\r\nIn this case, I want to be able to access the value \"aaa\" in the recipe.\r\n\r\nI did some experiments. It seems in the recipe I can access the annotation type but not the “value” because it was converted into `JavaType.FullyQualified` here without knowledge of the value: https://github.com/openrewrite/rewrite/blob/main/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java#L696\r\n\r\n## Describe the solution you'd like\r\nPreserve the annotation value pairs in the parsed LST.\r\n\r\n## Have you considered any alternatives or workarounds?\r\nI don't think there is a workaround with OpenRewrite. I worked around in my solution by loading all classes and use reflection to inspect the actual annotation values, which is a bit cumbersome.\r\n\r\n## Additional context\r\nn/a\r\n\r\n## Are you interested in [contributing this feature to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#new-features)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\n\r\nYes, here is [the patch](https://github.com/openrewrite/rewrite/pull/4746) I worked on. I don't have good understanding of OpenRewrite implementation holistically though, would love your feedback.",
    "issue_word_count": 329,
    "test_files_count": 3,
    "non_test_files_count": 7,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeMapping.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeMapping.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeMapping.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java",
      "rewrite-java-test/src/main/java/org/openrewrite/java/JavaTypeMappingTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/JavaTypeVisitor.java",
      "rewrite-java/src/main/java/org/openrewrite/java/internal/JavaReflectionTypeMapping.java",
      "rewrite-java/src/main/java/org/openrewrite/java/tree/JavaType.java",
      "rewrite-java/src/test/java/org/openrewrite/java/internal/JavaReflectionTypeMappingTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java",
      "rewrite-java-test/src/main/java/org/openrewrite/java/JavaTypeMappingTest.java",
      "rewrite-java/src/test/java/org/openrewrite/java/internal/JavaReflectionTypeMappingTest.java"
    ],
    "base_commit": "5eb553cdaf9a93e42cc0926846b4e9812c14af99",
    "head_commit": "cf83f5e28d1c2a67887faf2db279f70c1080124b",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4746",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4746",
    "dockerfile": "",
    "pr_merged_at": "2025-01-23T11:07:41.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeMapping.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeMapping.java\nindex 0a7edbbfc46..21d4eacbd88 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeMapping.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeMapping.java\n@@ -18,6 +18,7 @@\n import com.sun.source.tree.Tree;\n import com.sun.tools.javac.code.*;\n import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.Pair;\n import lombok.RequiredArgsConstructor;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.java.JavaTypeMapping;\n@@ -27,14 +28,13 @@\n \n import javax.lang.model.type.NullType;\n import javax.lang.model.type.TypeMirror;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.stream.Collectors;\n \n import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n import static org.openrewrite.java.tree.JavaType.GenericTypeVariable.Variance.*;\n \n @RequiredArgsConstructor\n@@ -686,22 +686,66 @@ private void completeClassSymbol(Symbol.ClassSymbol classSymbol) {\n         }\n     }\n \n-    private @Nullable List<JavaType.FullyQualified> listAnnotations(Symbol symb) {\n+    private @Nullable List<JavaType.FullyQualified> listAnnotations(Symbol sym) {\n         List<JavaType.FullyQualified> annotations = null;\n-        if (!symb.getDeclarationAttributes().isEmpty()) {\n-            annotations = new ArrayList<>(symb.getDeclarationAttributes().size());\n-            for (Attribute.Compound a : symb.getDeclarationAttributes()) {\n-                JavaType.FullyQualified annotType = TypeUtils.asFullyQualified(type(a.type));\n-                if (annotType == null) {\n-                    continue;\n-                }\n-                Retention retention = a.getAnnotationType().asElement().getAnnotation(Retention.class);\n-                if (retention != null && retention.value() == RetentionPolicy.SOURCE) {\n-                    continue;\n-                }\n-                annotations.add(annotType);\n+        if (!sym.getDeclarationAttributes().isEmpty()) {\n+            annotations = new ArrayList<>(sym.getDeclarationAttributes().size());\n+            for (Attribute.Compound a : sym.getDeclarationAttributes()) {\n+                JavaType.Annotation annotation = annotationType(a);\n+                if (annotation == null) continue;\n+                annotations.add(annotation);\n             }\n         }\n         return annotations;\n     }\n+\n+    private JavaType.@Nullable Annotation annotationType(Attribute.Compound compound) {\n+        JavaType.FullyQualified annotType = TypeUtils.asFullyQualified(type(compound.type));\n+        if (annotType == null) {\n+            return null;\n+        }\n+        List<JavaType.Annotation.ElementValue> elementValues = new ArrayList<>();\n+        for (Pair<Symbol.MethodSymbol, Attribute> attr : compound.values) {\n+            Object value = annotationElementValue(attr.snd.getValue());\n+            JavaType.Method element = requireNonNull(methodDeclarationType(attr.fst, annotType));\n+            JavaType.Annotation.ElementValue elementValue = value instanceof Object[] ?\n+                    JavaType.Annotation.ArrayElementValue.from(element, ((Object[]) value)) :\n+                    JavaType.Annotation.SingleElementValue.from(element, value);\n+            elementValues.add(elementValue);\n+        }\n+        return new JavaType.Annotation(annotType, elementValues);\n+    }\n+\n+    private Object annotationElementValue(Object value) {\n+        if (value instanceof Symbol.VarSymbol) {\n+            JavaType.Variable mapped = variableType((Symbol.VarSymbol) value);\n+            return mapped != null ? mapped : JavaType.Unknown.getInstance();\n+        } else if (value instanceof Type.ClassType) {\n+            return type((Type.ClassType) value);\n+        } else if (value instanceof Attribute.Array) {\n+            List<@Nullable Object> list = new ArrayList<>();\n+            for (Attribute attribute : ((Attribute.Array) value).values) {\n+                list.add(annotationElementValue(attribute));\n+            }\n+            return list.toArray(!list.isEmpty() && list.get(0) instanceof JavaType ? JavaType.EMPTY_JAVA_TYPE_ARRAY : new Object[0]);\n+        } else if (value instanceof List<?>) {\n+            List<@Nullable Object> list = new ArrayList<>();\n+            for (Object o : ((List<?>) value)) {\n+                list.add(annotationElementValue(o));\n+            }\n+            return list.toArray(!list.isEmpty() && list.get(0) instanceof JavaType ? JavaType.EMPTY_JAVA_TYPE_ARRAY : new Object[0]);\n+        } else if (value instanceof Attribute.Class) {\n+            return type(((Attribute.Class) value).classType);\n+        } else if (value instanceof Attribute.Compound) {\n+            JavaType.Annotation mapped = annotationType((Attribute.Compound) value);\n+            return mapped != null ? mapped : JavaType.Unknown.getInstance();\n+        } else if (value instanceof Attribute.Constant) {\n+            return annotationElementValue(((Attribute.Constant) value).value);\n+        } else if (value instanceof Attribute.Enum) {\n+            return annotationElementValue(((Attribute.Enum) value).value);\n+        } else if (value instanceof Attribute.Error) {\n+            return JavaType.Unknown.getInstance();\n+        }\n+        return value;\n+    }\n }\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java\nindex 2a4ba541752..e25ee76932c 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java\n@@ -19,6 +19,7 @@\n import com.sun.tools.javac.code.*;\n import com.sun.tools.javac.comp.AttrRecover;\n import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.Pair;\n import lombok.RequiredArgsConstructor;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.java.JavaTypeMapping;\n@@ -28,15 +29,13 @@\n \n import javax.lang.model.type.NullType;\n import javax.lang.model.type.TypeMirror;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n import java.lang.reflect.Field;\n import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.List;\n import java.util.stream.Collectors;\n \n import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n import static org.openrewrite.java.tree.JavaType.GenericTypeVariable.Variance.*;\n \n @RequiredArgsConstructor\n@@ -48,7 +47,7 @@ class ReloadableJava17TypeMapping implements JavaTypeMapping<Tree> {\n \n     public JavaType type(com.sun.tools.javac.code.@Nullable Type type) {\n         if (type == null || type instanceof Type.ErrorType || type instanceof Type.PackageType || type instanceof Type.UnknownType ||\n-            type instanceof NullType) {\n+                type instanceof NullType) {\n             return JavaType.Class.Unknown.getInstance();\n         }\n \n@@ -259,7 +258,7 @@ private JavaType.FullyQualified classType(Type.ClassType classType, String signa\n             List<JavaType.FullyQualified> interfaces = null;\n             if (symType.interfaces_field != null) {\n                 interfaces = new ArrayList<>(symType.interfaces_field.length());\n-                for (com.sun.tools.javac.code.Type iParam : symType.interfaces_field) {\n+                for (Type iParam : symType.interfaces_field) {\n                     JavaType.FullyQualified javaType = TypeUtils.asFullyQualified(type(iParam));\n                     if (javaType != null) {\n                         interfaces.add(javaType);\n@@ -273,8 +272,8 @@ private JavaType.FullyQualified classType(Type.ClassType classType, String signa\n             if (sym.members_field != null) {\n                 for (Symbol elem : sym.members_field.getSymbols()) {\n                     if (elem instanceof Symbol.VarSymbol &&\n-                        (elem.flags_field & (Flags.SYNTHETIC | Flags.BRIDGE | Flags.HYPOTHETICAL |\n-                                             Flags.GENERATEDCONSTR | Flags.ANONCONSTR)) == 0) {\n+                            (elem.flags_field & (Flags.SYNTHETIC | Flags.BRIDGE | Flags.HYPOTHETICAL |\n+                                    Flags.GENERATEDCONSTR | Flags.ANONCONSTR)) == 0) {\n                         if (fqn.equals(\"java.lang.String\") && elem.name.toString().equals(\"serialPersistentFields\")) {\n                             // there is a \"serialPersistentFields\" member within the String class which is used in normal Java\n                             // serialization to customize how the String field is serialized. This field is tripping up Jackson\n@@ -287,7 +286,7 @@ private JavaType.FullyQualified classType(Type.ClassType classType, String signa\n                         }\n                         fields.add(variableType(elem, clazz));\n                     } else if (elem instanceof Symbol.MethodSymbol &&\n-                               (elem.flags_field & (Flags.SYNTHETIC | Flags.BRIDGE | Flags.HYPOTHETICAL | Flags.ANONCONSTR)) == 0) {\n+                            (elem.flags_field & (Flags.SYNTHETIC | Flags.BRIDGE | Flags.HYPOTHETICAL | Flags.ANONCONSTR)) == 0) {\n                         if (methods == null) {\n                             methods = new ArrayList<>();\n                         }\n@@ -524,7 +523,7 @@ public JavaType.Primitive primitive(TypeTag tag) {\n \n             if (!methodType.argtypes.isEmpty()) {\n                 parameterTypes = new ArrayList<>(methodType.argtypes.size());\n-                for (com.sun.tools.javac.code.Type argtype : methodType.argtypes) {\n+                for (Type argtype : methodType.argtypes) {\n                     if (argtype != null) {\n                         JavaType javaType = type(argtype);\n                         parameterTypes.add(javaType);\n@@ -594,7 +593,7 @@ public JavaType.Primitive primitive(TypeTag tag) {\n                             .collect(Collectors.toList());\n                 } else {\n                     try {\n-                        defaultValues = Collections.singletonList(methodSymbol.getDefaultValue().getValue().toString());\n+                        defaultValues = singletonList(methodSymbol.getDefaultValue().getValue().toString());\n                     } catch (UnsupportedOperationException e) {\n                         // not all Attribute implementations define `getValue()`\n                     }\n@@ -603,7 +602,7 @@ public JavaType.Primitive primitive(TypeTag tag) {\n \n             List<String> declaredFormalTypeNames = null;\n             for (Symbol.TypeVariableSymbol typeParam : methodSymbol.getTypeParameters()) {\n-                if(typeParam.owner == methodSymbol) {\n+                if (typeParam.owner == methodSymbol) {\n                     if (declaredFormalTypeNames == null) {\n                         declaredFormalTypeNames = new ArrayList<>();\n                     }\n@@ -668,7 +667,7 @@ public JavaType.Primitive primitive(TypeTag tag) {\n \n                 if (!mt.argtypes.isEmpty()) {\n                     parameterTypes = new ArrayList<>(mt.argtypes.size());\n-                    for (com.sun.tools.javac.code.Type argtype : mt.argtypes) {\n+                    for (Type argtype : mt.argtypes) {\n                         if (argtype != null) {\n                             JavaType javaType = type(argtype);\n                             parameterTypes.add(javaType);\n@@ -697,22 +696,66 @@ private void completeClassSymbol(Symbol.ClassSymbol classSymbol) {\n         }\n     }\n \n-    private @Nullable List<JavaType.FullyQualified> listAnnotations(Symbol symb) {\n+    private @Nullable List<JavaType.FullyQualified> listAnnotations(Symbol sym) {\n         List<JavaType.FullyQualified> annotations = null;\n-        if (!symb.getDeclarationAttributes().isEmpty()) {\n-            annotations = new ArrayList<>(symb.getDeclarationAttributes().size());\n-            for (Attribute.Compound a : symb.getDeclarationAttributes()) {\n-                JavaType.FullyQualified annotType = TypeUtils.asFullyQualified(type(a.type));\n-                if (annotType == null) {\n-                    continue;\n-                }\n-                Retention retention = a.getAnnotationType().asElement().getAnnotation(Retention.class);\n-                if (retention != null && retention.value() == RetentionPolicy.SOURCE) {\n-                    continue;\n-                }\n-                annotations.add(annotType);\n+        if (!sym.getDeclarationAttributes().isEmpty()) {\n+            annotations = new ArrayList<>(sym.getDeclarationAttributes().size());\n+            for (Attribute.Compound a : sym.getDeclarationAttributes()) {\n+                JavaType.Annotation annotation = annotationType(a);\n+                if (annotation == null) continue;\n+                annotations.add(annotation);\n             }\n         }\n         return annotations;\n     }\n+\n+    private JavaType.@Nullable Annotation annotationType(Attribute.Compound compound) {\n+        JavaType.FullyQualified annotType = TypeUtils.asFullyQualified(type(compound.type));\n+        if (annotType == null) {\n+            return null;\n+        }\n+        List<JavaType.Annotation.ElementValue> elementValues = new ArrayList<>();\n+        for (Pair<Symbol.MethodSymbol, Attribute> attr : compound.values) {\n+            Object value = annotationElementValue(attr.snd.getValue());\n+            JavaType.Method element = requireNonNull(methodDeclarationType(attr.fst, annotType));\n+            JavaType.Annotation.ElementValue elementValue = value instanceof Object[] ?\n+                    JavaType.Annotation.ArrayElementValue.from(element, ((Object[]) value)) :\n+                    JavaType.Annotation.SingleElementValue.from(element, value);\n+            elementValues.add(elementValue);\n+        }\n+        return new JavaType.Annotation(annotType, elementValues);\n+    }\n+\n+    private Object annotationElementValue(Object value) {\n+        if (value instanceof Symbol.VarSymbol) {\n+            JavaType.Variable mapped = variableType((Symbol.VarSymbol) value);\n+            return mapped != null ? mapped : JavaType.Unknown.getInstance();\n+        } else if (value instanceof Type.ClassType) {\n+            return type((Type.ClassType) value);\n+        } else if (value instanceof Attribute.Array) {\n+            List<@Nullable Object> list = new ArrayList<>();\n+            for (Attribute attribute : ((Attribute.Array) value).values) {\n+                list.add(annotationElementValue(attribute));\n+            }\n+            return list.toArray(!list.isEmpty() && list.get(0) instanceof JavaType ? JavaType.EMPTY_JAVA_TYPE_ARRAY : new Object[0]);\n+        } else if (value instanceof List<?>) {\n+            List<@Nullable Object> list = new ArrayList<>();\n+            for (Object o : ((List<?>) value)) {\n+                list.add(annotationElementValue(o));\n+            }\n+            return list.toArray(!list.isEmpty() && list.get(0) instanceof JavaType ? JavaType.EMPTY_JAVA_TYPE_ARRAY : new Object[0]);\n+        } else if (value instanceof Attribute.Class) {\n+            return type(((Attribute.Class) value).classType);\n+        } else if (value instanceof Attribute.Compound) {\n+            JavaType.Annotation mapped = annotationType((Attribute.Compound) value);\n+            return mapped != null ? mapped : JavaType.Unknown.getInstance();\n+        } else if (value instanceof Attribute.Constant) {\n+            return annotationElementValue(((Attribute.Constant) value).value);\n+        } else if (value instanceof Attribute.Enum) {\n+            return annotationElementValue(((Attribute.Enum) value).value);\n+        } else if (value instanceof Attribute.Error) {\n+            return JavaType.Unknown.getInstance();\n+        }\n+        return value;\n+    }\n }\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeMapping.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeMapping.java\nindex 82c92931303..2744002ccb6 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeMapping.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeMapping.java\n@@ -19,6 +19,7 @@\n import com.sun.tools.javac.code.*;\n import com.sun.tools.javac.comp.AttrRecover;\n import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.Pair;\n import lombok.RequiredArgsConstructor;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.java.JavaTypeMapping;\n@@ -28,8 +29,6 @@\n \n import javax.lang.model.type.NullType;\n import javax.lang.model.type.TypeMirror;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n import java.lang.reflect.Field;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -37,6 +36,7 @@\n import java.util.stream.Collectors;\n \n import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n import static org.openrewrite.java.tree.JavaType.GenericTypeVariable.Variance.*;\n \n @RequiredArgsConstructor\n@@ -48,7 +48,7 @@ class ReloadableJava21TypeMapping implements JavaTypeMapping<Tree> {\n \n     public JavaType type(com.sun.tools.javac.code.@Nullable Type type) {\n         if (type == null || type instanceof Type.ErrorType || type instanceof Type.PackageType || type instanceof Type.UnknownType ||\n-            type instanceof NullType) {\n+                type instanceof NullType) {\n             return JavaType.Class.Unknown.getInstance();\n         }\n \n@@ -424,7 +424,7 @@ public JavaType.Primitive primitive(TypeTag tag) {\n     }\n \n     private JavaType.@Nullable Variable variableType(@Nullable Symbol symbol,\n-            JavaType.@Nullable FullyQualified owner) {\n+                                                     JavaType.@Nullable FullyQualified owner) {\n         if (!(symbol instanceof Symbol.VarSymbol)) {\n             return null;\n         }\n@@ -598,15 +598,15 @@ public JavaType.Primitive primitive(TypeTag tag) {\n                 }\n             }\n             List<String> defaultValues = null;\n-            if(methodSymbol.getDefaultValue() != null) {\n-                if(methodSymbol.getDefaultValue() instanceof Attribute.Array) {\n+            if (methodSymbol.getDefaultValue() != null) {\n+                if (methodSymbol.getDefaultValue() instanceof Attribute.Array) {\n                     defaultValues = ((Attribute.Array) methodSymbol.getDefaultValue()).getValue().stream()\n                             .map(attr -> attr.getValue().toString())\n                             .collect(Collectors.toList());\n                 } else {\n                     try {\n                         defaultValues = Collections.singletonList(methodSymbol.getDefaultValue().getValue().toString());\n-                    } catch(UnsupportedOperationException e) {\n+                    } catch (UnsupportedOperationException e) {\n                         // not all Attribute implementations define `getValue()`\n                     }\n                 }\n@@ -708,22 +708,66 @@ private void completeClassSymbol(Symbol.ClassSymbol classSymbol) {\n         }\n     }\n \n-    private @Nullable List<JavaType.FullyQualified> listAnnotations(Symbol symb) {\n+    private @Nullable List<JavaType.FullyQualified> listAnnotations(Symbol sym) {\n         List<JavaType.FullyQualified> annotations = null;\n-        if (!symb.getDeclarationAttributes().isEmpty()) {\n-            annotations = new ArrayList<>(symb.getDeclarationAttributes().size());\n-            for (Attribute.Compound a : symb.getDeclarationAttributes()) {\n-                JavaType.FullyQualified annotType = TypeUtils.asFullyQualified(type(a.type));\n-                if (annotType == null) {\n-                    continue;\n-                }\n-                Retention retention = a.getAnnotationType().asElement().getAnnotation(Retention.class);\n-                if (retention != null && retention.value() == RetentionPolicy.SOURCE) {\n-                    continue;\n-                }\n-                annotations.add(annotType);\n+        if (!sym.getDeclarationAttributes().isEmpty()) {\n+            annotations = new ArrayList<>(sym.getDeclarationAttributes().size());\n+            for (Attribute.Compound a : sym.getDeclarationAttributes()) {\n+                JavaType.Annotation annotation = annotationType(a);\n+                if (annotation == null) continue;\n+                annotations.add(annotation);\n             }\n         }\n         return annotations;\n     }\n+\n+    private JavaType.@Nullable Annotation annotationType(Attribute.Compound compound) {\n+        JavaType.FullyQualified annotType = TypeUtils.asFullyQualified(type(compound.type));\n+        if (annotType == null) {\n+            return null;\n+        }\n+        List<JavaType.Annotation.ElementValue> elementValues = new ArrayList<>();\n+        for (Pair<Symbol.MethodSymbol, Attribute> attr : compound.values) {\n+            Object value = annotationElementValue(attr.snd.getValue());\n+            JavaType.Method element = requireNonNull(methodDeclarationType(attr.fst, annotType));\n+            JavaType.Annotation.ElementValue elementValue = value instanceof Object[] ?\n+                    JavaType.Annotation.ArrayElementValue.from(element, ((Object[]) value)) :\n+                    JavaType.Annotation.SingleElementValue.from(element, value);\n+            elementValues.add(elementValue);\n+        }\n+        return new JavaType.Annotation(annotType, elementValues);\n+    }\n+\n+    private Object annotationElementValue(Object value) {\n+        if (value instanceof Symbol.VarSymbol) {\n+            JavaType.Variable mapped = variableType((Symbol.VarSymbol) value);\n+            return mapped != null ? mapped : JavaType.Unknown.getInstance();\n+        } else if (value instanceof Type.ClassType) {\n+            return type((Type.ClassType) value);\n+        } else if (value instanceof Attribute.Array) {\n+            List<@Nullable Object> list = new ArrayList<>();\n+            for (Attribute attribute : ((Attribute.Array) value).values) {\n+                list.add(annotationElementValue(attribute));\n+            }\n+            return list.toArray(!list.isEmpty() && list.getFirst() instanceof JavaType ? JavaType.EMPTY_JAVA_TYPE_ARRAY : new Object[0]);\n+        } else if (value instanceof List<?>) {\n+            List<@Nullable Object> list = new ArrayList<>();\n+            for (Object o : ((List<?>) value)) {\n+                list.add(annotationElementValue(o));\n+            }\n+            return list.toArray(!list.isEmpty() && list.getFirst() instanceof JavaType ? JavaType.EMPTY_JAVA_TYPE_ARRAY : new Object[0]);\n+        } else if (value instanceof Attribute.Class) {\n+            return type(((Attribute.Class) value).classType);\n+        } else if (value instanceof Attribute.Compound) {\n+            JavaType.Annotation mapped = annotationType((Attribute.Compound) value);\n+            return mapped != null ? mapped : JavaType.Unknown.getInstance();\n+        } else if (value instanceof Attribute.Constant) {\n+            return annotationElementValue(((Attribute.Constant) value).value);\n+        } else if (value instanceof Attribute.Enum) {\n+            return annotationElementValue(((Attribute.Enum) value).value);\n+        } else if (value instanceof Attribute.Error) {\n+            return JavaType.Unknown.getInstance();\n+        }\n+        return value;\n+    }\n }\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeMapping.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeMapping.java\nindex 9afe440a506..00a8786479d 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeMapping.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeMapping.java\n@@ -18,6 +18,7 @@\n import com.sun.source.tree.Tree;\n import com.sun.tools.javac.code.*;\n import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.Pair;\n import lombok.RequiredArgsConstructor;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.java.internal.JavaTypeCache;\n@@ -26,14 +27,13 @@\n \n import javax.lang.model.type.NullType;\n import javax.lang.model.type.TypeMirror;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.stream.Collectors;\n \n import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n import static org.openrewrite.java.tree.JavaType.GenericTypeVariable.Variance.CONTRAVARIANT;\n import static org.openrewrite.java.tree.JavaType.GenericTypeVariable.Variance.COVARIANT;\n import static org.openrewrite.java.tree.JavaType.GenericTypeVariable.Variance.INVARIANT;\n@@ -681,22 +681,66 @@ private void completeClassSymbol(Symbol.ClassSymbol classSymbol) {\n         }\n     }\n \n-    private @Nullable List<JavaType.FullyQualified> listAnnotations(Symbol symb) {\n+    private @Nullable List<JavaType.FullyQualified> listAnnotations(Symbol sym) {\n         List<JavaType.FullyQualified> annotations = null;\n-        if (!symb.getDeclarationAttributes().isEmpty()) {\n-            annotations = new ArrayList<>(symb.getDeclarationAttributes().size());\n-            for (Attribute.Compound a : symb.getDeclarationAttributes()) {\n-                JavaType.FullyQualified annotType = TypeUtils.asFullyQualified(type(a.type));\n-                if (annotType == null) {\n-                    continue;\n-                }\n-                Retention retention = a.getAnnotationType().asElement().getAnnotation(Retention.class);\n-                if (retention != null && retention.value() == RetentionPolicy.SOURCE) {\n-                    continue;\n-                }\n-                annotations.add(annotType);\n+        if (!sym.getDeclarationAttributes().isEmpty()) {\n+            annotations = new ArrayList<>(sym.getDeclarationAttributes().size());\n+            for (Attribute.Compound a : sym.getDeclarationAttributes()) {\n+                JavaType.Annotation annotation = annotationType(a);\n+                if (annotation == null) continue;\n+                annotations.add(annotation);\n             }\n         }\n         return annotations;\n     }\n+\n+    private JavaType.@Nullable Annotation annotationType(Attribute.Compound compound) {\n+        JavaType.FullyQualified annotType = TypeUtils.asFullyQualified(type(compound.type));\n+        if (annotType == null) {\n+            return null;\n+        }\n+        List<JavaType.Annotation.ElementValue> elementValues = new ArrayList<>();\n+        for (Pair<Symbol.MethodSymbol, Attribute> attr : compound.values) {\n+            Object value = annotationElementValue(attr.snd.getValue());\n+            JavaType.Method element = requireNonNull(methodDeclarationType(attr.fst, annotType));\n+            JavaType.Annotation.ElementValue elementValue = value instanceof Object[] ?\n+                    JavaType.Annotation.ArrayElementValue.from(element, ((Object[]) value)) :\n+                    JavaType.Annotation.SingleElementValue.from(element, value);\n+            elementValues.add(elementValue);\n+        }\n+        return new JavaType.Annotation(annotType, elementValues);\n+    }\n+\n+    private Object annotationElementValue(Object value) {\n+        if (value instanceof Symbol.VarSymbol) {\n+            JavaType.Variable mapped = variableType((Symbol.VarSymbol) value);\n+            return mapped != null ? mapped : JavaType.Unknown.getInstance();\n+        } else if (value instanceof Type.ClassType) {\n+            return type((Type.ClassType) value);\n+        } else if (value instanceof Attribute.Array) {\n+            List<@Nullable Object> list = new ArrayList<>();\n+            for (Attribute attribute : ((Attribute.Array) value).values) {\n+                list.add(annotationElementValue(attribute));\n+            }\n+            return list.toArray(!list.isEmpty() && list.get(0) instanceof JavaType ? JavaType.EMPTY_JAVA_TYPE_ARRAY : new Object[0]);\n+        } else if (value instanceof List<?>) {\n+            List<@Nullable Object> list = new ArrayList<>();\n+            for (Object o : ((List<?>) value)) {\n+                list.add(annotationElementValue(o));\n+            }\n+            return list.toArray(!list.isEmpty() && list.get(0) instanceof JavaType ? JavaType.EMPTY_JAVA_TYPE_ARRAY : new Object[0]);\n+        } else if (value instanceof Attribute.Class) {\n+            return type(((Attribute.Class) value).classType);\n+        } else if (value instanceof Attribute.Compound) {\n+            JavaType.Annotation mapped = annotationType((Attribute.Compound) value);\n+            return mapped != null ? mapped : JavaType.Unknown.getInstance();\n+        } else if (value instanceof Attribute.Constant) {\n+            return annotationElementValue(((Attribute.Constant) value).value);\n+        } else if (value instanceof Attribute.Enum) {\n+            return annotationElementValue(((Attribute.Enum) value).value);\n+        } else if (value instanceof Attribute.Error) {\n+            return JavaType.Unknown.getInstance();\n+        }\n+        return value;\n+    }\n }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavaTypeVisitor.java b/rewrite-java/src/main/java/org/openrewrite/java/JavaTypeVisitor.java\nindex 29ddbf14870..c87b5d74f84 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavaTypeVisitor.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavaTypeVisitor.java\n@@ -69,6 +69,8 @@ public JavaType visitNonNull(JavaType javaType, P p) {\n \n             if (javaType instanceof JavaType.Array) {\n                 javaType = visitArray((JavaType.Array) javaType, p);\n+            } else if (javaType instanceof JavaType.Annotation) {\n+                javaType = visitAnnotation((JavaType.Annotation) javaType, p);\n             } else if (javaType instanceof JavaType.Class) {\n                 javaType = visitClass((JavaType.Class) javaType, p);\n             } else if (javaType instanceof JavaType.GenericTypeVariable) {\n@@ -105,6 +107,12 @@ public JavaType visitMultiCatch(JavaType.MultiCatch multiCatch, P p) {\n         return multiCatch.withThrowableTypes(ListUtils.map(multiCatch.getThrowableTypes(), tt -> visit(tt, p)));\n     }\n \n+    public JavaType visitAnnotation(JavaType.Annotation annotation, P p) {\n+        JavaType.Annotation a = annotation;\n+        a = a.withType((JavaType.FullyQualified) visit(a.getType(), p));\n+        return a;\n+    }\n+\n     public JavaType visitArray(JavaType.Array array, P p) {\n         JavaType.Array a = array;\n         a = a.withElemType(visit(a.getElemType(), p));\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/internal/JavaReflectionTypeMapping.java b/rewrite-java/src/main/java/org/openrewrite/java/internal/JavaReflectionTypeMapping.java\nindex e242c73e335..d379b047055 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/internal/JavaReflectionTypeMapping.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/internal/JavaReflectionTypeMapping.java\n@@ -153,7 +153,7 @@ private JavaType.FullyQualified classTypeWithoutParameters(Class<?> clazz) {\n                 annotations = new ArrayList<>(clazz.getDeclaredAnnotations().length);\n                 for (Annotation a : clazz.getDeclaredAnnotations()) {\n                     JavaType.FullyQualified type = (JavaType.FullyQualified) type(a.annotationType());\n-                    annotations.add(type);\n+                    annotations.add(new JavaType.Annotation(type, emptyList()));\n                 }\n             }\n \n@@ -298,7 +298,7 @@ private JavaType.Variable field(Field field) {\n             annotations = new ArrayList<>(field.getDeclaredAnnotations().length);\n             for (Annotation a : field.getDeclaredAnnotations()) {\n                 JavaType.FullyQualified type = (JavaType.FullyQualified) type(a.annotationType());\n-                annotations.add(type);\n+                annotations.add(new JavaType.Annotation(type, emptyList()));\n             }\n         }\n \n@@ -359,7 +359,7 @@ private JavaType.Method method(Constructor<?> method, JavaType.FullyQualified de\n             annotations = new ArrayList<>(method.getDeclaredAnnotations().length);\n             for (Annotation a : method.getDeclaredAnnotations()) {\n                 JavaType.FullyQualified fullyQualified = (JavaType.FullyQualified) type(a.annotationType());\n-                annotations.add(fullyQualified);\n+                annotations.add(new JavaType.Annotation(fullyQualified, emptyList()));\n             }\n         }\n \n@@ -478,7 +478,7 @@ private JavaType.Method method(Method method, JavaType.FullyQualified declaringT\n             annotations = new ArrayList<>(method.getDeclaredAnnotations().length);\n             for (Annotation a : method.getDeclaredAnnotations()) {\n                 JavaType.FullyQualified fullyQualified = (JavaType.FullyQualified) type(a.annotationType());\n-                annotations.add(fullyQualified);\n+                annotations.add(new JavaType.Annotation(fullyQualified, emptyList()));\n             }\n         }\n \n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/JavaType.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/JavaType.java\nindex f4a0eac5195..c62550a5d93 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/JavaType.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/JavaType.java\n@@ -19,9 +19,7 @@\n import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n-import lombok.AccessLevel;\n-import lombok.Getter;\n-import lombok.With;\n+import lombok.*;\n import lombok.experimental.FieldDefaults;\n import lombok.experimental.NonFinal;\n import org.jspecify.annotations.Nullable;\n@@ -48,6 +46,7 @@ public interface JavaType {\n     Method[] EMPTY_METHOD_ARRAY = new Method[0];\n     String[] EMPTY_STRING_ARRAY = new String[0];\n     JavaType[] EMPTY_JAVA_TYPE_ARRAY = new JavaType[0];\n+    Annotation.ElementValue[] EMPTY_ANNOTATION_VALUE_ARRAY = new Annotation.ElementValue[0];\n \n     // TODO: To be removed with OpenRewrite 9\n     default @Nullable Integer getManagedReference() {\n@@ -628,6 +627,152 @@ public static ShallowClass build(String fullyQualifiedName) {\n         }\n     }\n \n+    @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n+    class Annotation extends FullyQualified {\n+\n+        @Getter\n+        @With\n+        final FullyQualified type;\n+\n+        final ElementValue @Nullable [] values;\n+\n+        public Annotation(FullyQualified type, List<ElementValue> values) {\n+            this(type, arrayOrNullIfEmpty(values, EMPTY_ANNOTATION_VALUE_ARRAY));\n+        }\n+\n+        Annotation(FullyQualified type, ElementValue @Nullable [] values) {\n+            this.type = type;\n+            this.values = nullIfEmpty(values);\n+        }\n+\n+        public List<ElementValue> getValues() {\n+            return values == null ? emptyList() : Arrays.asList(values);\n+        }\n+\n+        public Annotation withValues(@Nullable List<ElementValue> values) {\n+            ElementValue[] valuesArray = arrayOrNullIfEmpty(values, EMPTY_ANNOTATION_VALUE_ARRAY);\n+            if (Arrays.equals(valuesArray, this.values)) {\n+                return this;\n+            }\n+            return new Annotation(type, valuesArray);\n+        }\n+\n+        @Override\n+        public String getFullyQualifiedName() {\n+            return type.getFullyQualifiedName();\n+        }\n+\n+        @Override\n+        public FullyQualified withFullyQualifiedName(String fullyQualifiedName) {\n+            return withType(type.withFullyQualifiedName(fullyQualifiedName));\n+        }\n+\n+        @Override\n+        public List<FullyQualified> getAnnotations() {\n+            return type.getAnnotations();\n+        }\n+\n+        @Override\n+        public boolean hasFlags(Flag... test) {\n+            return type.hasFlags(test);\n+        }\n+\n+        @Override\n+        public Set<Flag> getFlags() {\n+            return type.getFlags();\n+        }\n+\n+        @Override\n+        public List<FullyQualified> getInterfaces() {\n+            return type.getInterfaces();\n+        }\n+\n+        @Override\n+        public Kind getKind() {\n+            return type.getKind();\n+        }\n+\n+        @Override\n+        public List<Variable> getMembers() {\n+            return type.getMembers();\n+        }\n+\n+        @Override\n+        public List<Method> getMethods() {\n+            return type.getMethods();\n+        }\n+\n+        @Override\n+        public List<JavaType> getTypeParameters() {\n+            return type.getTypeParameters();\n+        }\n+\n+        @Override\n+        public @Nullable FullyQualified getOwningClass() {\n+            return type.getOwningClass();\n+        }\n+\n+        @Override\n+        public @Nullable FullyQualified getSupertype() {\n+            return type.getSupertype();\n+        }\n+\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, property = \"@c\", include = JsonTypeInfo.As.PROPERTY)\n+        public interface ElementValue {\n+            JavaType getElement();\n+\n+            Object getValue();\n+        }\n+\n+        @Value\n+        public static class SingleElementValue implements ElementValue {\n+            JavaType element;\n+\n+            @Nullable\n+            Object constantValue;\n+\n+            @Nullable\n+            JavaType referenceValue;\n+\n+            public static SingleElementValue from(JavaType element, Object value) {\n+                if (value instanceof JavaType) {\n+                    return new SingleElementValue(element, null, (JavaType) value);\n+                } else {\n+                    return new SingleElementValue(element, value, null);\n+                }\n+            }\n+\n+            @Override\n+            public Object getValue() {\n+                return constantValue != null ? constantValue : referenceValue;\n+            }\n+        }\n+\n+        @Value\n+        public static class ArrayElementValue implements ElementValue {\n+            JavaType element;\n+            Object @Nullable [] constantValues;\n+            JavaType @Nullable [] referenceValues;\n+\n+            public static ArrayElementValue from(JavaType element, Object[] values) {\n+                if (values.length > 0 && values[0] instanceof JavaType) {\n+                    return new ArrayElementValue(element, null, (JavaType[]) values);\n+                } else {\n+                    return new ArrayElementValue(element, values, null);\n+                }\n+            }\n+\n+            @Override\n+            public Object getValue() {\n+                return getValues();\n+            }\n+\n+            public List<?> getValues() {\n+                return Arrays.asList(constantValues != null ? constantValues : referenceValues);\n+            }\n+        }\n+    }\n+\n     @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n     class Parameterized extends FullyQualified {\n         @Getter\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java\nindex 51e56507716..92419ead8c5 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/AnnotationTest.java\n@@ -19,13 +19,20 @@\n import org.openrewrite.Cursor;\n import org.openrewrite.ExecutionContext;\n import org.openrewrite.Issue;\n+import org.openrewrite.SourceFile;\n import org.openrewrite.java.JavaIsoVisitor;\n+import org.openrewrite.java.JavaParser;\n+import org.openrewrite.java.MinimumJava21;\n import org.openrewrite.java.service.AnnotationService;\n import org.openrewrite.test.RewriteTest;\n \n+import java.util.List;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n+import static java.util.Collections.singletonList;\n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.openrewrite.java.Assertions.java;\n import static org.openrewrite.test.RewriteTest.toRecipe;\n \n@@ -38,7 +45,14 @@ void annotationWithDefaultArgument() {\n             \"\"\"\n               @SuppressWarnings(\"ALL\")\n               public class A {}\n-               \"\"\"\n+              \"\"\", spec -> spec.afterRecipe(cu -> {\n+                  J.ClassDeclaration c = cu.getClasses().get(0);\n+                  JavaType.Class type = (JavaType.Class) c.getType();\n+                  JavaType.Annotation a = (JavaType.Annotation) type.getAnnotations().get(0);\n+                  assertThat(a.getValues()).hasSize(1);\n+                  assertThat(a.getValues().get(0).getValue()).isEqualTo(singletonList(\"ALL\"));\n+              }\n+            )\n           )\n         );\n     }\n@@ -50,7 +64,7 @@ void annotationWithArgument() {\n             \"\"\"\n               @SuppressWarnings(value = \"ALL\")\n               public class A {}\n-               \"\"\"\n+              \"\"\"\n           )\n         );\n     }\n@@ -62,7 +76,7 @@ void preserveOptionalEmptyParentheses() {\n             \"\"\"\n               @Deprecated ( )\n               public class A {}\n-               \"\"\"\n+              \"\"\"\n           )\n         );\n     }\n@@ -74,7 +88,7 @@ void newArrayArgument() {\n             \"\"\"\n               import java.lang.annotation.Target;\n               import static java.lang.annotation.ElementType.*;\n-\n+              \n               @Target({ FIELD, PARAMETER })\n               public @interface Annotation {}\n               \"\"\"\n@@ -159,7 +173,7 @@ void typeParameterAnnotations() {\n               import java.lang.annotation.*;\n               class TypeAnnotationTest {\n                   List<@A ? extends @A String> list;\n-                           \n+              \n                   @Target({ ElementType.FIELD, ElementType.TYPE_USE, ElementType.TYPE_PARAMETER })\n                   private @interface A {\n                   }\n@@ -230,10 +244,10 @@ public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext p)\n             \"\"\"\n               import java.lang.annotation.*;\n               public class TypeAnnotationTest {\n-                          \n+              \n                   public @Deprecated @A TypeAnnotationTest() {\n                   }\n-                          \n+              \n                   @Target({ ElementType.TYPE, ElementType.TYPE_USE, ElementType.TYPE_PARAMETER })\n                   private @interface A {\n                   }\n@@ -242,10 +256,10 @@ public class TypeAnnotationTest {\n             \"\"\"\n               import java.lang.annotation.*;\n               public class TypeAnnotationTest {\n-                          \n+              \n                   public @Deprecated TypeAnnotationTest() {\n                   }\n-                          \n+              \n                   @Target({ ElementType.TYPE, ElementType.TYPE_USE, ElementType.TYPE_PARAMETER })\n                   private @interface A {\n                   }\n@@ -412,4 +426,88 @@ public J.ArrayType visitArrayType(J.ArrayType arrayType, Object o) {\n           )\n         );\n     }\n+\n+    @Test\n+    void recursiveElementValue() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import java.lang.annotation.ElementType;\n+              import java.lang.annotation.Target;\n+              \n+              @Target(ElementType.TYPE)\n+              @A\n+              private @interface A {\n+                  A[] value() default @A;\n+              }\n+              \n+              @A({@A, @A(@A)})\n+              class TypeAnnotationTest {\n+              }\n+              \"\"\", spec -> spec.afterRecipe(cu -> {\n+                J.ClassDeclaration c = cu.getClasses().get(1);\n+                JavaType.Class type = (JavaType.Class) c.getType();\n+                JavaType.Annotation a = (JavaType.Annotation) type.getAnnotations().get(0);\n+                assertThat(a.getValues()).satisfiesExactly(\n+                  v -> {\n+                      assertThat(v.getElement()).isIn(a.getMethods());\n+                      assertThat((List<JavaType.Annotation>) (((JavaType.Annotation.ArrayElementValue) v).getValues())).satisfiesExactly(\n+                        a1 -> {\n+                            assertThat(a1.getType()).isSameAs(a.getType());\n+                            assertThat(a1.getValues()).isEmpty();\n+                        },\n+                        a2 -> {\n+                            assertThat(a2.getType()).isSameAs(a.getType());\n+                            assertThat(a2.getValues()).hasSize(1);\n+                        }\n+                      );\n+                  }\n+                );\n+            })\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @MinimumJava21 // Because of `@Deprecated#forRemoval`\n+    void annotationElementValues() {\n+        JavaParser p = JavaParser.fromJavaVersion().build();\n+        /*\n+         *     Using these annotations in core library for testing this feature:\n+         *\n+         *     @Deprecated(since=\"1.2\", forRemoval=true)\n+         *     public final void stop()\n+         *\n+         *     @CallerSensitive\n+         *     public ClassLoader getContextClassLoader() {\n+         */\n+        List<SourceFile> sourceFiles = p.parse(\n+          \"\"\"\n+            class Test {\n+              public void test() {\n+                Thread.currentThread().stop();\n+                Thread.currentThread().getContextClassLoader();\n+              }\n+            }\n+            \"\"\"\n+        ).toList();\n+        J.CompilationUnit cu = (J.CompilationUnit) sourceFiles.get(0);\n+\n+        J.MethodDeclaration md = (J.MethodDeclaration) cu.getClasses().get(0).getBody().getStatements().get(0);\n+        J.MethodInvocation mi = (J.MethodInvocation) md.getBody().getStatements().get(0);\n+        JavaType.Annotation annotation = (JavaType.Annotation) mi.getMethodType().getAnnotations().get(0);\n+\n+        // Thread.currentThread().stop();\n+        assertEquals(\"java.lang.Deprecated\" ,annotation.getType().getFullyQualifiedName());\n+        assertEquals(\"since\", ((JavaType.Method) annotation.getValues().get(0).getElement()).getName());\n+        assertEquals(\"1.2\", annotation.getValues().get(0).getValue());\n+        assertEquals(\"forRemoval\", ((JavaType.Method) annotation.getValues().get(1).getElement()).getName());\n+        assertEquals(Boolean.TRUE, annotation.getValues().get(1).getValue());\n+\n+        // Thread.currentThread().getContextClassLoader();\n+        mi = (J.MethodInvocation) md.getBody().getStatements().get(1);\n+        annotation = (JavaType.Annotation) mi.getMethodType().getAnnotations().get(0);\n+        assertEquals(\"jdk.internal.reflect.CallerSensitive\" ,annotation.getType().getFullyQualifiedName());\n+        assertTrue(annotation.getValues().isEmpty());\n+    }\n }\n\ndiff --git a/rewrite-java-test/src/main/java/org/openrewrite/java/JavaTypeMappingTest.java b/rewrite-java-test/src/main/java/org/openrewrite/java/JavaTypeMappingTest.java\nindex 1c010267764..2ba9ad4b339 100644\n--- a/rewrite-java-test/src/main/java/org/openrewrite/java/JavaTypeMappingTest.java\n+++ b/rewrite-java-test/src/main/java/org/openrewrite/java/JavaTypeMappingTest.java\n@@ -261,14 +261,18 @@ default void enumTypeB() {\n     }\n \n     @Test\n-    default void ignoreSourceRetentionAnnotations() {\n+    default void includeSourceRetentionAnnotations() {\n         JavaType.Parameterized goat = goatType();\n-        assertThat(goat.getAnnotations().size()).isEqualTo(1);\n-        assertThat(goat.getAnnotations().get(0).getClassName()).isEqualTo(\"AnnotationWithRuntimeRetention\");\n+        assertThat(goat.getAnnotations()).satisfiesExactlyInAnyOrder(\n+                a -> assertThat(a.getClassName()).isEqualTo(\"AnnotationWithRuntimeRetention\"),\n+                a -> assertThat(a.getClassName()).isEqualTo(\"AnnotationWithSourceRetention\")\n+        );\n \n         JavaType.Method clazzMethod = methodType(\"clazz\");\n-        assertThat(clazzMethod.getAnnotations().size()).isEqualTo(1);\n-        assertThat(clazzMethod.getAnnotations().get(0).getClassName()).isEqualTo(\"AnnotationWithRuntimeRetention\");\n+        assertThat(clazzMethod.getAnnotations()).satisfiesExactlyInAnyOrder(\n+                a -> assertThat(a.getClassName()).isEqualTo(\"AnnotationWithRuntimeRetention\"),\n+                a -> assertThat(a.getClassName()).isEqualTo(\"AnnotationWithSourceRetention\")\n+        );\n     }\n \n     @Issue(\"https://github.com/openrewrite/rewrite/issues/1367\")\n\ndiff --git a/rewrite-java/src/test/java/org/openrewrite/java/internal/JavaReflectionTypeMappingTest.java b/rewrite-java/src/test/java/org/openrewrite/java/internal/JavaReflectionTypeMappingTest.java\nindex e858ccbceef..06d20326f58 100644\n--- a/rewrite-java/src/test/java/org/openrewrite/java/internal/JavaReflectionTypeMappingTest.java\n+++ b/rewrite-java/src/test/java/org/openrewrite/java/internal/JavaReflectionTypeMappingTest.java\n@@ -22,6 +22,8 @@\n import org.openrewrite.java.tree.JavaType;\n import org.openrewrite.java.tree.TypeUtils;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n+\n @SuppressWarnings(\"ConstantConditions\")\n class JavaReflectionTypeMappingTest implements JavaTypeMappingTest {\n     JavaReflectionTypeMapping typeMapping = new JavaReflectionTypeMapping(new JavaTypeCache());\n@@ -56,4 +58,20 @@ public void enumTypeA() {\n     @Override\n     public void enumTypeB() {\n     }\n+\n+    @Test\n+    @Override\n+    // The JavaReflectionTypeMapping cannot include source retention annotations\n+    public void includeSourceRetentionAnnotations() {\n+        JavaType.Parameterized goat = goatType();\n+        assertThat(goat.getAnnotations()).satisfiesExactlyInAnyOrder(\n+          a -> assertThat(a.getClassName()).isEqualTo(\"AnnotationWithRuntimeRetention\")\n+        );\n+\n+        JavaType.Method clazzMethod = methodType(\"clazz\");\n+        assertThat(clazzMethod.getAnnotations()).satisfiesExactlyInAnyOrder(\n+          a -> assertThat(a.getClassName()).isEqualTo(\"AnnotationWithRuntimeRetention\")\n+        );\n+    }\n+\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4741",
    "pr_id": 4741,
    "issue_id": 4740,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Extend YAML CommentOutProperty with option to keep original property uncommented\nCurrently YAML CommentOutProperty adds the comment and always comments out original property.\r\nTo be consistent with property AddPropertyComment recipe, introduce the option to keep original property and just add a comment.\r\nIn the future, it would be nice to align the names and parameters for YAML CommentOutProperty and property AddPropertyComment recipes",
    "issue_word_count": 61,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/CommentOutProperty.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/CommentOutPropertyTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/CommentOutPropertyTest.java"
    ],
    "base_commit": "f9d71bc0b29404da5ac0cff2455b733de57a2433",
    "head_commit": "cf08a9c433cbb8bbb0f1de445e15d5734c758bcf",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4741",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4741",
    "dockerfile": "",
    "pr_merged_at": "2024-12-05T12:13:22.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/CommentOutProperty.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/CommentOutProperty.java\nindex 83d5563bc10..8d94aa04c3b 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/CommentOutProperty.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/CommentOutProperty.java\n@@ -17,7 +17,11 @@\n \n import lombok.EqualsAndHashCode;\n import lombok.Value;\n-import org.openrewrite.*;\n+import org.jspecify.annotations.Nullable;\n+import org.openrewrite.ExecutionContext;\n+import org.openrewrite.Option;\n+import org.openrewrite.Recipe;\n+import org.openrewrite.TreeVisitor;\n import org.openrewrite.yaml.tree.Yaml;\n \n import java.util.ArrayDeque;\n@@ -40,6 +44,12 @@ public class CommentOutProperty extends Recipe {\n             example = \"The `foo` property is deprecated, please migrate\")\n     String commentText;\n \n+    @Option(example = \"true\", displayName = \"Comment out property\",\n+            description = \"If false, property wouldn't be commented out, only comment will be added. By default, set to true\",\n+            required = false)\n+    @Nullable\n+    Boolean commentOutProperty;\n+\n     @Override\n     public String getDisplayName() {\n         return \"Comment out property\";\n@@ -61,6 +71,7 @@ public TreeVisitor<?, ExecutionContext> getVisitor() {\n             private boolean nextDocNeedsNewline;\n             private String comment = \"\";\n             private String indentation = \"\";\n+            private boolean isBlockCommentExists;\n \n             @Override\n             public Yaml.Document visitDocument(Yaml.Document document, ExecutionContext ctx) {\n@@ -72,7 +83,7 @@ public Yaml.Document visitDocument(Yaml.Document document, ExecutionContext ctx)\n                 }\n \n                 // Add any leftover comment to the end of document\n-                if (!comment.isEmpty()) {\n+                if (!comment.isEmpty() && !Boolean.FALSE.equals(commentOutProperty)) {\n                     String newPrefix = String.format(\"%s# %s%s%s\",\n                             indentation,\n                             commentText,\n@@ -89,7 +100,9 @@ public Yaml.Document visitDocument(Yaml.Document document, ExecutionContext ctx)\n             public Yaml.Sequence.Entry visitSequenceEntry(Yaml.Sequence.Entry entry,\n                                                           ExecutionContext ctx) {\n                 indentation = entry.getPrefix();\n-                if (!comment.isEmpty()) {\n+                if (Boolean.FALSE.equals(commentOutProperty)) {\n+                    return addBockCommentIfNecessary(entry, ctx);\n+                } else if (!comment.isEmpty()) {\n                     // add comment and return\n                     String newPrefix = entry.getPrefix() + \"# \" + commentText + comment + entry.getPrefix();\n                     comment = \"\";\n@@ -103,20 +116,13 @@ public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionC\n                 String lastIndentation = indentation;\n                 indentation = entry.getPrefix();\n \n-                if (!comment.isEmpty()) {\n+                if (!comment.isEmpty() && !Boolean.FALSE.equals(commentOutProperty)) {\n                     String newPrefix = entry.getPrefix() + \"# \" + commentText + comment + entry.getPrefix();\n                     comment = \"\";\n                     return entry.withPrefix(newPrefix);\n                 }\n \n-                Deque<Yaml.Mapping.Entry> propertyEntries = getCursor().getPathAsStream()\n-                        .filter(Yaml.Mapping.Entry.class::isInstance)\n-                        .map(Yaml.Mapping.Entry.class::cast)\n-                        .collect(Collectors.toCollection(ArrayDeque::new));\n-\n-                String prop = stream(spliteratorUnknownSize(propertyEntries.descendingIterator(), 0), false)\n-                        .map(e2 -> e2.getKey().getValue())\n-                        .collect(Collectors.joining(\".\"));\n+                String prop = calculateCurrentKeyPath();\n \n                 if (prop.equals(propertyKey)) {\n                     String prefix = entry.getPrefix();\n@@ -128,12 +134,50 @@ public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionC\n                         comment = lastIndentation + \"#\" + entry.print(getCursor().getParentTreeCursor());\n                     }\n \n-                    doAfterVisit(new DeleteProperty(propertyKey, null, null, null).getVisitor());\n+                    if (Boolean.FALSE.equals(commentOutProperty)) {\n+                        if (!entry.getPrefix().contains(commentText) && !isBlockCommentExists) {\n+                            return entry.withPrefix(entry.getPrefix() + \"# \" + commentText + (entry.getPrefix().contains(\"\\n\") ? entry.getPrefix() : \"\\n\" + entry.getPrefix()));\n+                        }\n+                    } else {\n+                        doAfterVisit(new DeleteProperty(propertyKey, null, null, null).getVisitor());\n+                    }\n                     return entry;\n                 }\n \n                 return super.visitMappingEntry(entry, ctx);\n             }\n+\n+            private Yaml.Sequence.Entry addBockCommentIfNecessary(Yaml.Sequence.Entry entry, ExecutionContext ctx) {\n+                boolean propertyExistsInSequence = isPropertyExistsInSequence(entry);\n+                if (propertyExistsInSequence) {\n+                    isBlockCommentExists = true;\n+                    if (!entry.getPrefix().contains(commentText)) {\n+                        return entry.withPrefix(entry.getPrefix() + \"# \" + commentText + (entry.getPrefix().contains(\"\\n\") ? entry.getPrefix() : \"\\n\" + entry.getPrefix()));\n+                    }\n+                }\n+                return super.visitSequenceEntry(entry, ctx);\n+            }\n+\n+            private boolean isPropertyExistsInSequence(Yaml.Sequence.Entry entry) {\n+                if (!(entry.getBlock() instanceof Yaml.Mapping)) {\n+                    return false;\n+                }\n+                Yaml.Mapping mapping = (Yaml.Mapping) entry.getBlock();\n+                String prop = calculateCurrentKeyPath();\n+                return mapping.getEntries().stream()\n+                        .anyMatch(e -> propertyKey.equals(prop + \".\" + e.getKey().getValue()));\n+            }\n+\n+            private String calculateCurrentKeyPath() {\n+                Deque<Yaml.Mapping.Entry> propertyEntries = getCursor().getPathAsStream()\n+                        .filter(Yaml.Mapping.Entry.class::isInstance)\n+                        .map(Yaml.Mapping.Entry.class::cast)\n+                        .collect(Collectors.toCollection(ArrayDeque::new));\n+\n+                return stream(spliteratorUnknownSize(propertyEntries.descendingIterator(), 0), false)\n+                        .map(e2 -> e2.getKey().getValue())\n+                        .collect(Collectors.joining(\".\"));\n+            }\n         };\n     }\n }\n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/CommentOutPropertyTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/CommentOutPropertyTest.java\nindex 57334b24734..9f5d7dcf239 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/CommentOutPropertyTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/CommentOutPropertyTest.java\n@@ -17,24 +17,17 @@\n \n import org.junit.jupiter.api.Test;\n import org.openrewrite.DocumentExample;\n-import org.openrewrite.test.RecipeSpec;\n import org.openrewrite.test.RewriteTest;\n \n import static org.openrewrite.yaml.Assertions.yaml;\n \n class CommentOutPropertyTest implements RewriteTest {\n \n-    @Override\n-    public void defaults(RecipeSpec spec) {\n-        spec.recipe(new CommentOutProperty(\"management.metrics.binders.files.enabled\", \"some comments\"));\n-    }\n-\n     @DocumentExample(\"comment out a map entry\")\n     @Test\n     void regular() {\n         rewriteRun(\n-          spec -> spec.recipe(new CommentOutProperty(\"foo.bar.sequence.propertyA\",\n-            \"Some comments\")),\n+          spec -> spec.recipe(new CommentOutProperty(\"foo.bar.sequence.propertyA\", \"Some comments\", null)),\n           yaml(\n             \"\"\"\n                 foo:\n@@ -63,8 +56,7 @@ void regular() {\n     @Test\n     void commentSequence() {\n         rewriteRun(\n-          spec -> spec.recipe(new CommentOutProperty(\"foo.bar.sequence\",\n-            \"Some comments\")),\n+          spec -> spec.recipe(new CommentOutProperty(\"foo.bar.sequence\", \"Some comments\", null)),\n           yaml(\n             \"\"\"\n               foo:\n@@ -92,8 +84,7 @@ void commentSequence() {\n     @Test\n     void commentSingleProperty() {\n         rewriteRun(\n-          spec -> spec.recipe(new CommentOutProperty(\"with.java-version\",\n-            \"Some comments\")),\n+          spec -> spec.recipe(new CommentOutProperty(\"with.java-version\", \"Some comments\", null)),\n           yaml(\n             \"\"\"\n               with:\n@@ -115,8 +106,7 @@ void commentSingleProperty() {\n     @Test\n     void commentLastPropertyWithIndent() {\n         rewriteRun(\n-          spec -> spec.recipe(new CommentOutProperty(\"with.java-version\",\n-            \"Some comments\")),\n+          spec -> spec.recipe(new CommentOutProperty(\"with.java-version\", \"Some comments\", null)),\n           yaml(\n             \"\"\"\n               with:\n@@ -136,8 +126,7 @@ void commentLastPropertyWithIndent() {\n     @Test\n     void commentLastPropertyOfFirstDocument() {\n         rewriteRun(\n-          spec -> spec.recipe(new CommentOutProperty(\"with.java-version\",\n-            \"Some comments\")),\n+          spec -> spec.recipe(new CommentOutProperty(\"with.java-version\", \"Some comments\", null)),\n           yaml(\n             \"\"\"\n               with:\n@@ -159,8 +148,7 @@ void commentLastPropertyOfFirstDocument() {\n     @Test\n     void commentLastProperty() {\n         rewriteRun(\n-          spec -> spec.recipe(new CommentOutProperty(\"test\",\n-            \"Some comments\")),\n+          spec -> spec.recipe(new CommentOutProperty(\"test\", \"Some comments\", null)),\n           yaml(\n             \"\"\"\n               test: foo\n@@ -172,4 +160,172 @@ void commentLastProperty() {\n           )\n         );\n     }\n+\n+    @DocumentExample(\"comment out a map entry\")\n+    @Test\n+    void sequenceKeepProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new CommentOutProperty(\"foo.bar.sequence.propertyA\",\n+            \"Some comments\", false)),\n+          yaml(\n+            \"\"\"\n+                foo:\n+                  bar:\n+                    sequence:\n+                      - name: name\n+                      - propertyA: fieldA\n+                      - propertyB: fieldB\n+                    scalar: value\n+              \"\"\",\n+            \"\"\"\n+                foo:\n+                  bar:\n+                    sequence:\n+                      - name: name\n+                      # Some comments\n+                      - propertyA: fieldA\n+                      - propertyB: fieldB\n+                    scalar: value\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @DocumentExample(\"comment out a map entry\")\n+    @Test\n+    void sequenceFirstKeepProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new CommentOutProperty(\"foo.bar.sequence.name\", \"Some comments\", false)),\n+          yaml(\n+            \"\"\"\n+                foo:\n+                  bar:\n+                    sequence:\n+                      - name: name\n+                      - propertyA: fieldA\n+                      - propertyB: fieldB\n+                    scalar: value\n+              \"\"\",\n+            \"\"\"\n+                foo:\n+                  bar:\n+                    sequence:\n+                      # Some comments\n+                      - name: name\n+                      - propertyA: fieldA\n+                      - propertyB: fieldB\n+                    scalar: value\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @DocumentExample(\"comment out entire sequence\")\n+    @Test\n+    void commentSequenceKeepProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new CommentOutProperty(\"foo.bar.sequence\", \"Some comments\", false)),\n+          yaml(\n+            \"\"\"\n+              foo:\n+                bar:\n+                  sequence:\n+                    - name: name\n+                    - propertyA: fieldA\n+                    - propertyB: fieldB\n+                  scalar: value\n+              \"\"\",\n+            \"\"\"\n+              foo:\n+                bar:\n+                  # Some comments\n+                  sequence:\n+                    - name: name\n+                    - propertyA: fieldA\n+                    - propertyB: fieldB\n+                  scalar: value\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void commentSinglePropertyKeepProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new CommentOutProperty(\"with.java-version\", \"Some comments\", false)),\n+          yaml(\n+            \"\"\"\n+              with:\n+                java-cache: 'maven'\n+                java-version: 11\n+                test: 'bar'\n+              \"\"\",\n+            \"\"\"\n+              with:\n+                java-cache: 'maven'\n+                # Some comments\n+                java-version: 11\n+                test: 'bar'\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void commentLastPropertyWithIndentKeepProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new CommentOutProperty(\"with.java-version\", \"Some comments\", false)),\n+          yaml(\n+            \"\"\"\n+              with:\n+                java-cache: 'maven'\n+                java-version: 11\n+              \"\"\",\n+            \"\"\"\n+              with:\n+                java-cache: 'maven'\n+                # Some comments\n+                java-version: 11\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void commentLastPropertyOfFirstDocumentKeepProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new CommentOutProperty(\"with.java-version\", \"Some comments\", false)),\n+          yaml(\n+            \"\"\"\n+              with:\n+                java-cache: 'maven'\n+                java-version: 11\n+              ---\n+              \"\"\",\n+            \"\"\"\n+              with:\n+                java-cache: 'maven'\n+                # Some comments\n+                java-version: 11\n+              ---\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void commentLastPropertyKeepProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new CommentOutProperty(\"test\", \"Some comments\", false)),\n+          yaml(\n+            \"\"\"\n+              test: foo\n+              \"\"\",\n+            \"\"\"\n+              # Some comments\n+              test: foo\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4738",
    "pr_id": 4738,
    "issue_id": 4687,
    "repo": "openrewrite/rewrite",
    "problem_statement": "openrewrite maven recipes shoudn't try to resolve every single pom\nHello,\r\n\r\nI have projects with external dependencies that have been installed manually into a local maven repository.\r\nThese artefacts don't have a pom in the repository.\r\nOn these projects 'mvn clean install' succeeds and there is only a warning about the missing pom :\r\n```log\r\n[WARNING] The POM for xxxxxxx is missing, no dependency information available\r\n```\r\n\r\nHowever when I try to run any openrewrite maven recipes on this kind of project, it fails with :\r\n```log\r\n[ERROR] </project>org.openrewrite.maven.MavenDownloadingException: Unable to download POM:xxxxx Tried repositories:\r\n[ERROR] https://repo.maven.apache.org/maven2: HTTP 404\r\n[ERROR]   org.openrewrite.maven.internal.MavenPomDownloader.download(MavenPomDownloader.java:636)\r\n[ERROR]   org.openrewrite.maven.tree.ResolvedPom.resolveDependencies(ResolvedPom.java:929)\r\n[ERROR]   org.openrewrite.maven.tree.ResolvedPom.resolveDependencies(ResolvedPom.java:851)\r\n[ERROR]   org.openrewrite.maven.tree.MavenResolutionResult.resolveDependencies(MavenResolutionResult.java:175)\r\n```\r\n\r\n\r\nWhy openrewrite maven recipes would fail when a maven build succeeds with warnings ?\r\nHow to fix this ?\r\n\r\n\r\nYou can reproduce this bug with this minimal project : [project.zip](https://github.com/user-attachments/files/17821254/project.zip)\r\n\r\n Just install any jar locally with : \r\n```shell\r\nmvn install:install-file -Dfile=<any jar file> -DgroupId=bug.report -DartifactId=somedep -Dversion=1.0 -Dpackaging=jar -DgeneratePom=false\r\n```\r\n\r\nThen 'mvn clean install' will give : \r\n```log\r\n[INFO] Scanning for projects...\r\n[INFO] \r\n[INFO] -------------------------< bug.report:somejar >-------------------------\r\n[INFO] Building somejar 1.0-SNAPSHOT\r\n[INFO] --------------------------------[ jar ]---------------------------------\r\n[WARNING] The POM for bug.report:somedep:jar:1.0 is missing, no dependency information available\r\n[INFO] \r\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ somejar ---\r\n[INFO] Deleting /home/stef/repos_github/bugreport/target\r\n[INFO] \r\n[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ somejar ---\r\n[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!\r\n[INFO] skip non existing resourceDirectory /home/stef/repos_github/bugreport/src/main/resources\r\n[INFO] \r\n[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ somejar ---\r\n[INFO] Changes detected - recompiling the module!\r\n[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!\r\n[INFO] Compiling 1 source file to /home/stef/repos_github/bugreport/target/classes\r\n[INFO] \r\n[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ somejar ---\r\n[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!\r\n[INFO] skip non existing resourceDirectory /home/stef/repos_github/bugreport/src/test/resources\r\n[INFO] \r\n[INFO] --- maven-compiler-plugin:3.8.1:testCompile (default-testCompile) @ somejar ---\r\n[INFO] No sources to compile\r\n[INFO] \r\n[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ somejar ---\r\n[INFO] No tests to run.\r\n[INFO] \r\n[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ somejar ---\r\n[INFO] Building jar: /home/stef/repos_github/bugreport/target/somejar-1.0-SNAPSHOT.jar\r\n[INFO] \r\n[INFO] --- maven-install-plugin:2.4:install (default-install) @ somejar ---\r\n[INFO] Installing /home/stef/repos_github/bugreport/target/somejar-1.0-SNAPSHOT.jar to /home/stef/.m2/repository/bug/report/somejar/1.0-SNAPSHOT/somejar-1.0-SNAPSHOT.jar\r\n[INFO] Installing /home/stef/repos_github/bugreport/pom.xml to /home/stef/.m2/repository/bug/report/somejar/1.0-SNAPSHOT/somejar-1.0-SNAPSHOT.pom\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD SUCCESS\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time:  1.105 s\r\n[INFO] Finished at: 2024-11-19T21:36:09+01:00\r\n```\r\n\r\nThen running 'mvn org.openrewrite.maven:rewrite-maven-plugin:run -Drewrite.activeRecipes=org.openrewrite.maven.cleanup.PrefixlessExpressions`will fail with : \r\n```log\r\n[ERROR] Failed to execute goal org.openrewrite.maven:rewrite-maven-plugin:5.45.0:run (default-cli) on project somejar: Failed to parse or resolve the Maven POM file or one of its dependencies; We can not reliably continue without this information.: Failed to parse or resolve the Maven POM file or one of its dependencies; We can not reliably continue without this information. \r\n[ERROR] <!--~~(Unable to download POM: bug.report:somedep:1.0. Tried repositories:\r\n[ERROR] https://repo.maven.apache.org/maven2: HTTP 404)~~>--><project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n[ERROR]          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n[ERROR]          xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n[ERROR]     <modelVersion>4.0.0</modelVersion>\r\n[ERROR] \r\n[ERROR]     <groupId>bug.report</groupId>\r\n[ERROR]     <artifactId>somejar</artifactId>\r\n[ERROR]     <version>1.0-SNAPSHOT</version>\r\n[ERROR] \r\n[ERROR]     <properties>\r\n[ERROR]         <maven.compiler.source>1.8</maven.compiler.source>\r\n[ERROR]         <maven.compiler.target>1.8</maven.compiler.target>\r\n[ERROR]     </properties>\r\n[ERROR] \r\n[ERROR]     <dependencies>\r\n[ERROR]         <!-- any jar installed with :\r\n[ERROR]         mvn install:install-file -Dfile=<any jar file> -DgroupId=bug.report -DartifactId=somedep -Dversion=1.0 -Dpackaging=jar -DgeneratePom=false\r\n[ERROR]         -->\r\n[ERROR]         <dependency>\r\n[ERROR]             <groupId>bug.report</groupId>\r\n[ERROR]             <artifactId>somedep</artifactId>\r\n[ERROR]             <version>1.0</version>\r\n[ERROR]         </dependency>\r\n[ERROR]     </dependencies>\r\n[ERROR] \r\n[ERROR]     <build>\r\n[ERROR]         <plugins>\r\n[ERROR]             <plugin>\r\n[ERROR]                 <groupId>org.apache.maven.plugins</groupId>\r\n[ERROR]                 <artifactId>maven-compiler-plugin</artifactId>\r\n[ERROR]                 <version>3.8.1</version>\r\n[ERROR]             </plugin>\r\n[ERROR]         </plugins>\r\n[ERROR]     </build>\r\n[ERROR] </project>org.openrewrite.maven.MavenDownloadingException: Unable to download POM: bug.report:somedep:1.0. Tried repositories:\r\n[ERROR] https://repo.maven.apache.org/maven2: HTTP 404\r\n[ERROR]   org.openrewrite.maven.internal.MavenPomDownloader.download(MavenPomDownloader.java:636)\r\n[ERROR]   org.openrewrite.maven.tree.ResolvedPom.resolveDependencies(ResolvedPom.java:929)\r\n[ERROR]   org.openrewrite.maven.tree.ResolvedPom.resolveDependencies(ResolvedPom.java:851)\r\n[ERROR]   org.openrewrite.maven.tree.MavenResolutionResult.resolveDependencies(MavenResolutionResult.java:175)\r\n[ERROR] -> [Help 1]\r\n[ERROR] \r\n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\r\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\r\n[ERROR] \r\n[ERROR] For more information about the errors and possible solutions, please read the following articles:\r\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException\r\n```\r\n",
    "issue_word_count": 941,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/tree/ResolvedPomTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/tree/ResolvedPomTest.java"
    ],
    "base_commit": "5cb394544e43a3b1e4d58229fd41f363bc27843e",
    "head_commit": "c2e10f08243a9589ae472a7b03859e33511b1c15",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4738",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4738",
    "dockerfile": "",
    "pr_merged_at": "2024-12-12T22:21:23.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\nindex 364078042d7..26e59770b35 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\n@@ -561,51 +561,75 @@ public Pom download(GroupArtifactVersion gav,\n                     Path inputPath = Paths.get(gav.getGroupId(), gav.getArtifactId(), gav.getVersion());\n \n                     try {\n-                        File f = new File(uri);\n+                        File pomFile = new File(uri);\n+                        File jarFile = pomFile.toPath().resolveSibling(gav.getArtifactId() + '-' + versionMaybeDatedSnapshot + \".jar\").toFile();\n \n-                        //NOTE: The pom may exist without a .jar artifact if the pom packaging is \"pom\"\n-                        if (!f.exists()) {\n+                        //NOTE:\n+                        // - The pom may exist without a .jar artifact if the pom packaging is \"pom\"\n+                        // - The jar may exist without a pom, if manually installed\n+                        if (!pomFile.exists() && !jarFile.exists()) {\n                             continue;\n                         }\n \n-                        try (FileInputStream fis = new FileInputStream(f)) {\n-                            RawPom rawPom = RawPom.parse(fis, Objects.equals(versionMaybeDatedSnapshot, gav.getVersion()) ? null : versionMaybeDatedSnapshot);\n-                            Pom pom = rawPom.toPom(inputPath, repo).withGav(resolvedGav);\n-\n-                            if (pom.getPackaging() == null || pom.hasJarPackaging()) {\n-                                File jar = f.toPath().resolveSibling(gav.getArtifactId() + '-' + versionMaybeDatedSnapshot + \".jar\").toFile();\n-                                if (!jar.exists() || jar.length() == 0) {\n-                                    // The jar has not been downloaded, making this dependency unusable.\n-                                    continue;\n-                                }\n+                        RawPom rawPom;\n+                        if (pomFile.exists()) {\n+                            try (FileInputStream fis = new FileInputStream(pomFile)) {\n+                                rawPom = RawPom.parse(fis, Objects.equals(versionMaybeDatedSnapshot, gav.getVersion()) ? null : versionMaybeDatedSnapshot);\n                             }\n+                        } else {\n+                            // Record the absense of the pom file\n+                            ctx.getResolutionListener().downloadError(gav, uris, (containingPom == null) ? null : containingPom.getRequested());\n+                            // infer rawPom from jar\n+                            rawPom = rawPomFromGav(gav);\n+                        }\n \n-                            if (repo.getUri().equals(MavenRepository.MAVEN_LOCAL_DEFAULT.getUri())) {\n-                                // so that the repository path is the same regardless of username\n-                                pom = pom.withRepository(MavenRepository.MAVEN_LOCAL_USER_NEUTRAL);\n-                            }\n+                        Pom pom = rawPom.toPom(inputPath, repo).withGav(resolvedGav);\n \n-                            if (!Objects.equals(versionMaybeDatedSnapshot, pom.getVersion())) {\n-                                pom = pom.withGav(pom.getGav().withDatedSnapshotVersion(versionMaybeDatedSnapshot));\n+                        if (pom.getPackaging() == null || pom.hasJarPackaging()) {\n+                            if (!jarFile.exists() || jarFile.length() == 0) {\n+                                // The jar has not been downloaded, making this dependency unusable.\n+                                continue;\n                             }\n-                            mavenCache.putPom(resolvedGav, pom);\n-                            ctx.getResolutionListener().downloadSuccess(resolvedGav, containingPom);\n-                            sample.stop(timer.tags(\"outcome\", \"from maven local\").register(Metrics.globalRegistry));\n-                            return pom;\n                         }\n+\n+                        if (repo.getUri().equals(MavenRepository.MAVEN_LOCAL_DEFAULT.getUri())) {\n+                            // so that the repository path is the same regardless of username\n+                            pom = pom.withRepository(MavenRepository.MAVEN_LOCAL_USER_NEUTRAL);\n+                        }\n+\n+                        if (!Objects.equals(versionMaybeDatedSnapshot, pom.getVersion())) {\n+                            pom = pom.withGav(pom.getGav().withDatedSnapshotVersion(versionMaybeDatedSnapshot));\n+                        }\n+                        mavenCache.putPom(resolvedGav, pom);\n+                        ctx.getResolutionListener().downloadSuccess(resolvedGav, containingPom);\n+                        sample.stop(timer.tags(\"outcome\", \"from maven local\").register(Metrics.globalRegistry));\n+                        return pom;\n                     } catch (IOException e) {\n                         // unable to read the pom from a file-based repository.\n                         repositoryResponses.put(repo, e.getMessage());\n                     }\n                 } else {\n                     try {\n-                        byte[] responseBody = requestAsAuthenticatedOrAnonymous(repo, uri.toString());\n+                        RawPom rawPom;\n+                        try {\n+                            byte[] responseBody = requestAsAuthenticatedOrAnonymous(repo, uri.toString());\n+                            rawPom = RawPom.parse(\n+                                    new ByteArrayInputStream(responseBody),\n+                                    Objects.equals(versionMaybeDatedSnapshot, gav.getVersion()) ? null : versionMaybeDatedSnapshot\n+                            );\n+                        } catch (HttpSenderResponseException e) {\n+                            repositoryResponses.put(repo, e.getMessage());\n+                            // When `pom` is not found, try to see if `jar` exists for the same GAV\n+                            if (!e.isClientSideException() || !jarExistsForPomUri(repo, uri.toString())) {\n+                                throw e;\n+                            }\n+                            // Record the absense of the pom file\n+                            ctx.getResolutionListener().downloadError(gav, uris, (containingPom == null) ? null : containingPom.getRequested());\n \n+                            // Continue with a recreated pom\n+                            rawPom = rawPomFromGav(gav);\n+                        }\n                         Path inputPath = Paths.get(gav.getGroupId(), gav.getArtifactId(), gav.getVersion());\n-                        RawPom rawPom = RawPom.parse(\n-                                new ByteArrayInputStream(responseBody),\n-                                Objects.equals(versionMaybeDatedSnapshot, gav.getVersion()) ? null : versionMaybeDatedSnapshot\n-                        );\n                         Pom pom = rawPom.toPom(inputPath, repo).withGav(resolvedGav);\n                         if (!Objects.equals(versionMaybeDatedSnapshot, pom.getVersion())) {\n                             pom = pom.withGav(pom.getGav().withDatedSnapshotVersion(versionMaybeDatedSnapshot));\n@@ -637,6 +661,12 @@ public Pom download(GroupArtifactVersion gav,\n                 .setRepositoryResponses(repositoryResponses);\n     }\n \n+    private RawPom rawPomFromGav(GroupArtifactVersion gav) {\n+        return new RawPom(null, null, gav.getGroupId(), gav.getArtifactId(), gav.getVersion(), null,\n+                null, null, null, \"jar\", null, null, null,\n+                null, null, null, null, null, null);\n+    }\n+\n     /**\n      * Gets the base version from snapshot timestamp version.\n      */\n@@ -850,6 +880,34 @@ private ReachabilityResult reachable(HttpSender.Request.Builder request) {\n         }\n     }\n \n+    private boolean jarExistsForPomUri(MavenRepository repo, String pomUrl) {\n+        String jarUrl = pomUrl.replaceAll(\"\\\\.pom$\", \".jar\");\n+        try {\n+            try {\n+                return Failsafe.with(retryPolicy).get(() -> {\n+                    HttpSender.Request authenticated = applyAuthenticationAndTimeoutToRequest(repo, httpSender.get(jarUrl)).build();\n+                    try (HttpSender.Response response = httpSender.send(authenticated)) {\n+                        return response.isSuccessful();\n+                    }\n+                });\n+            } catch (FailsafeException failsafeException) {\n+                Throwable cause = failsafeException.getCause();\n+                if (cause instanceof HttpSenderResponseException && hasCredentials(repo) &&\n+                        ((HttpSenderResponseException) cause).isClientSideException()) {\n+                    return Failsafe.with(retryPolicy).get(() -> {\n+                        HttpSender.Request unauthenticated = httpSender.get(jarUrl).build();\n+                        try (HttpSender.Response response = httpSender.send(unauthenticated)) {\n+                            return response.isSuccessful();\n+                        }\n+                    });\n+                }\n+            }\n+        } catch (Throwable e) {\n+            // Not interested in exceptions downloading the jar; we'll throw the original exception for the pom\n+        }\n+        return false;\n+    }\n+\n \n     /**\n      * Replicates Apache Maven's behavior to attempt anonymous download if repository credentials prove invalid\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java\nindex f16810183a6..152265c02fd 100755\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java\n@@ -573,6 +573,42 @@ void skipsLocalInvalidArtifactsEmptyJar(@TempDir Path localRepository) throws IO\n                 .download(new GroupArtifactVersion(\"com.bad\", \"bad-artifact\", \"1\"), null, null, List.of(mavenLocal)));\n         }\n \n+        @Test\n+        void dontAllowPomDowloadFailureWithoutJar(@TempDir Path localRepository) throws IOException, MavenDownloadingException {\n+            MavenRepository mavenLocal = MavenRepository.builder()\n+              .id(\"local\")\n+              .uri(localRepository.toUri().toString())\n+              .snapshots(false)\n+              .knownToExist(true)\n+              .build();\n+\n+            // Do not return invalid dependency\n+            assertThrows(MavenDownloadingException.class, () -> new MavenPomDownloader(emptyMap(), ctx)\n+              .download(new GroupArtifactVersion(\"com.bad\", \"bad-artifact\", \"1\"), null, null, List.of(mavenLocal)));\n+        }\n+\n+        @Test\n+        void allowPomDowloadFailureWithJar(@TempDir Path localRepository) throws IOException, MavenDownloadingException {\n+            MavenRepository mavenLocal = MavenRepository.builder()\n+              .id(\"local\")\n+              .uri(localRepository.toUri().toString())\n+              .snapshots(false)\n+              .knownToExist(true)\n+              .build();\n+\n+            // Create a valid jar\n+            Path localJar = localRepository.resolve(\"com/some/some-artifact/1/some-artifact-1.jar\");\n+            assertThat(localJar.getParent().toFile().mkdirs()).isTrue();\n+            Files.writeString(localJar, \"some content not to be empty\");\n+\n+            // Do not throw exception since we have a jar\n+            var result = new MavenPomDownloader(emptyMap(), ctx)\n+              .download(new GroupArtifactVersion(\"com.some\", \"some-artifact\", \"1\"), null, null, List.of(mavenLocal));\n+            assertThat(result.getGav().getGroupId()).isEqualTo(\"com.some\");\n+            assertThat(result.getGav().getArtifactId()).isEqualTo(\"some-artifact\");\n+            assertThat(result.getGav().getVersion()).isEqualTo(\"1\");\n+        }\n+\n         @Test\n         void doNotRenameRepoForCustomMavenLocal(@TempDir Path tempDir) throws MavenDownloadingException, IOException {\n             GroupArtifactVersion gav = createArtifact(tempDir);\n@@ -1023,5 +1059,62 @@ public MockResponse dispatch(RecordedRequest recordedRequest) {\n                 throw new RuntimeException(e);\n             }\n         }\n+\n+        @Test\n+        @DisplayName(\"Throw exception if there is no pom and no jar for the artifact\")\n+        @Issue(\"https://github.com/openrewrite/rewrite/issues/4687\")\n+        void pomNotFoundWithNoJarShouldThrow() throws Exception {\n+            try (MockWebServer mockRepo = getMockServer()) {\n+                mockRepo.setDispatcher(new Dispatcher() {\n+                    @Override\n+                    public MockResponse dispatch(RecordedRequest recordedRequest) {\n+                        assert recordedRequest.getPath() != null;\n+                        return new MockResponse().setResponseCode(404).setBody(\"\");\n+                    }\n+                });\n+                mockRepo.start();\n+                var repositories = List.of(MavenRepository.builder()\n+                  .id(\"id\")\n+                  .uri(\"http://%s:%d/maven\".formatted(mockRepo.getHostName(), mockRepo.getPort()))\n+                  .username(\"user\")\n+                  .password(\"pass\")\n+                  .build());\n+\n+                var downloader = new MavenPomDownloader(emptyMap(), ctx);\n+                var gav = new GroupArtifactVersion(\"fred\", \"fred\", \"1\");\n+                assertThrows(MavenDownloadingException.class, () -> downloader.download(gav, null, null, repositories));\n+            }\n+        }\n+\n+        @Test\n+        @DisplayName(\"Don't throw exception if there is no pom and but there is a jar for the artifact\")\n+        @Issue(\"https://github.com/openrewrite/rewrite/issues/4687\")\n+        void pomNotFoundWithJarFoundShouldntThrow() throws Exception {\n+            try (MockWebServer mockRepo = getMockServer()) {\n+                mockRepo.setDispatcher(new Dispatcher() {\n+                    @Override\n+                    public MockResponse dispatch(RecordedRequest recordedRequest) {\n+                        assert recordedRequest.getPath() != null;\n+                        if (recordedRequest.getPath().endsWith(\"fred/fred/1/fred-1.pom\"))\n+                            return new MockResponse().setResponseCode(404).setBody(\"\");\n+                        return new MockResponse().setResponseCode(200).setBody(\"some bytes so the jar isn't empty\");\n+                    }\n+                });\n+                mockRepo.start();\n+                var repositories = List.of(MavenRepository.builder()\n+                  .id(\"id\")\n+                  .uri(\"http://%s:%d/maven\".formatted(mockRepo.getHostName(), mockRepo.getPort()))\n+                  .username(\"user\")\n+                  .password(\"pass\")\n+                  .build());\n+\n+                var gav = new GroupArtifactVersion(\"fred\", \"fred\", \"1\");\n+                var downloader = new MavenPomDownloader(emptyMap(), ctx);\n+                Pom downloaded = downloader.download(gav, null, null, repositories);\n+                assertThat(downloaded.getGav().getGroupId()).isEqualTo(\"fred\");\n+                assertThat(downloaded.getGav().getArtifactId()).isEqualTo(\"fred\");\n+                assertThat(downloaded.getGav().getVersion()).isEqualTo(\"1\");\n+            }\n+        }\n     }\n }\n\ndiff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/tree/ResolvedPomTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/tree/ResolvedPomTest.java\nindex 0d2714390ab..b1c0e12f1bd 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/tree/ResolvedPomTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/tree/ResolvedPomTest.java\n@@ -16,9 +16,20 @@\n package org.openrewrite.maven.tree;\n \n import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.intellij.lang.annotations.Language;\n+import org.jspecify.annotations.Nullable;\n+import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.openrewrite.InMemoryExecutionContext;\n+import org.openrewrite.Issue;\n+import org.openrewrite.maven.MavenExecutionContextView;\n import org.openrewrite.test.RewriteTest;\n \n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n import java.util.List;\n \n import static org.assertj.core.api.Assertions.assertThat;\n@@ -278,4 +289,97 @@ void resolveExecutionsFromDifferentParents() {\n           )\n         );\n     }\n+\n+    @Nested\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4687\")\n+    class TolerateMissingPom {\n+\n+        @Language(\"xml\")\n+        private static final String POM_WITH_DEPENDENCY = \"\"\"\n+          <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              <groupId>foo</groupId>\n+              <artifactId>bar</artifactId>\n+              <version>1.0-SNAPSHOT</version>\n+              <dependencies>\n+                  <dependency>\n+                      <groupId>com.some</groupId>\n+                      <artifactId>some-artifact</artifactId>\n+                      <version>1</version>\n+                  </dependency>\n+              </dependencies>\n+          </project>\n+          \"\"\";\n+\n+        @TempDir\n+        Path localRepository;\n+        @TempDir\n+        Path localRepository2;\n+\n+        @Test\n+        void singleRepositoryContainingJar() throws IOException {\n+            MavenRepository mavenLocal = createMavenRepository(localRepository, \"local\");\n+            createJarFile(localRepository);\n+\n+            List<List<@Nullable Object>> downloadErrorArgs = new ArrayList<>();\n+            MavenExecutionContextView ctx = MavenExecutionContextView.view(new InMemoryExecutionContext(Throwable::printStackTrace));\n+            ctx.setRepositories(List.of(mavenLocal));\n+            ctx.setResolutionListener(new ResolutionEventListener() {\n+                @Override\n+                public void downloadError(GroupArtifactVersion gav, List<String> attemptedUris, @Nullable Pom containing) {\n+                    List<Object> list = new ArrayList<>();\n+                    list.add(gav);\n+                    list.add(attemptedUris);\n+                    list.add(containing);\n+                    downloadErrorArgs.add(list);\n+                }\n+            });\n+            rewriteRun(\n+              spec -> spec.executionContext(ctx),\n+              pomXml(POM_WITH_DEPENDENCY)\n+            );\n+            assertThat(downloadErrorArgs).hasSize(1);\n+        }\n+\n+        @Test\n+        void twoRepositoriesSecondContainingJar() throws IOException {\n+            MavenRepository mavenLocal = createMavenRepository(localRepository, \"local\");\n+            MavenRepository mavenLocal2 = createMavenRepository(localRepository2, \"local2\");\n+            createJarFile(localRepository2);\n+\n+            List<List<@Nullable Object>> downloadErrorArgs = new ArrayList<>();\n+            MavenExecutionContextView ctx = MavenExecutionContextView.view(new InMemoryExecutionContext(Throwable::printStackTrace));\n+            ctx.setRepositories(List.of(mavenLocal, mavenLocal2));\n+            ctx.setResolutionListener(new ResolutionEventListener() {\n+                @Override\n+                public void downloadError(GroupArtifactVersion gav, List<String> attemptedUris, @Nullable Pom containing) {\n+                    List<Object> list = new ArrayList<>();\n+                    list.add(gav);\n+                    list.add(attemptedUris);\n+                    list.add(containing);\n+                    downloadErrorArgs.add(list);\n+                }\n+            });\n+            rewriteRun(\n+              spec -> spec.executionContext(ctx),\n+              pomXml(POM_WITH_DEPENDENCY)\n+            );\n+            assertThat(downloadErrorArgs).hasSize(1);\n+        }\n+\n+        private static void createJarFile(Path localRepository1) throws IOException {\n+            Path localJar = localRepository1.resolve(\"com/some/some-artifact/1/some-artifact-1.jar\");\n+            assertThat(localJar.getParent().toFile().mkdirs()).isTrue();\n+            Files.writeString(localJar, \"some content not to be empty\");\n+        }\n+\n+        private static MavenRepository createMavenRepository(Path localRepository, String name) {\n+            return MavenRepository.builder()\n+              .id(name)\n+              .uri(localRepository.toUri().toString())\n+              .snapshots(false)\n+              .knownToExist(true)\n+              .build();\n+        }\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4733",
    "pr_id": 4733,
    "issue_id": 4731,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Add RegEx support to ChangeTageValue & Visitor recipe\n## What problem are you trying to solve?\r\nCurrently the [ChangeTagValueVisitor](https://github.com/openrewrite/rewrite/blob/main/rewrite-xml/src/main/java/org/openrewrite/xml/ChangeTagValueVisitor.java) & [ChangeTagValue](https://github.com/openrewrite/rewrite/blob/main/rewrite-xml/src/main/java/org/openrewrite/xml/ChangeTagValue.java) recipe only support replace the whole value and not subset/sub-string.\r\n\r\nFor my use case plugin configuration changes I need to change the last fragment OAS spec file name from `swagger.json` to `openapi.json`. \r\n\r\nI couldn't find a perfect recipe that does what I what. And ChangeTagValue is the closest but doesn't help solve my use case.\r\n\r\n## Describe the solution you'd like\r\n\r\nAllowing regex support in ChangeTagValue can help fix this.\r\n\r\n## Have you considered any alternatives or workarounds?\r\n\r\nChecked the XML & Maven recipes. Open to suggestions.\r\n\r\n## Additional context\r\n\r\n## Are you interested in [contributing this feature to OpenRewrite]\r\n\r\nYes, I think it'd be useful to do add regex support like how its done in FindAndReplace text recipe. \r\nWrote [this to workaround the use case in my project](https://github.com/openrewrite/rewrite/compare/main...anthochristen:xml-change-value-add-regex?expand=1)...If we agree that this makes sense can make it a full fledged change.",
    "issue_word_count": 213,
    "test_files_count": 2,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/IncrementProjectVersion.java",
      "rewrite-xml/src/main/java/org/openrewrite/xml/ChangeTagValue.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/ChangeTagValueTest.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/ChangeTagValueVisitorTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-xml/src/test/java/org/openrewrite/xml/ChangeTagValueTest.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/ChangeTagValueVisitorTest.java"
    ],
    "base_commit": "4c0f0cab953dcfff64b4bad022b1caab55b91816",
    "head_commit": "bca8551d6e8d82952190005e4093b1dbceb56327",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4733",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4733",
    "dockerfile": "",
    "pr_merged_at": "2024-12-06T12:44:39.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/IncrementProjectVersion.java b/rewrite-maven/src/main/java/org/openrewrite/maven/IncrementProjectVersion.java\nindex b1513956dfa..af1691941b7 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/IncrementProjectVersion.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/IncrementProjectVersion.java\n@@ -172,8 +172,8 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                     return t;\n                 }\n                 t = t.withMarkers(t.getMarkers().add(new AlreadyIncremented(randomId())));\n-                return (Xml.Tag) new ChangeTagValue(\"version\", oldVersion, newVersion).getVisitor()\n-                        .visitNonNull(t, ctx);\n+                return (Xml.Tag) new ChangeTagValue(\"version\", oldVersion, newVersion, null)\n+                        .getVisitor().visitNonNull(t, ctx);\n             }\n         };\n     }\n\ndiff --git a/rewrite-xml/src/main/java/org/openrewrite/xml/ChangeTagValue.java b/rewrite-xml/src/main/java/org/openrewrite/xml/ChangeTagValue.java\nindex 0773c33abba..254fb705ed7 100644\n--- a/rewrite-xml/src/main/java/org/openrewrite/xml/ChangeTagValue.java\n+++ b/rewrite-xml/src/main/java/org/openrewrite/xml/ChangeTagValue.java\n@@ -18,12 +18,16 @@\n import lombok.EqualsAndHashCode;\n import lombok.Value;\n import org.jspecify.annotations.Nullable;\n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.Option;\n-import org.openrewrite.Recipe;\n-import org.openrewrite.TreeVisitor;\n+import org.openrewrite.*;\n+import org.openrewrite.marker.AlreadyReplaced;\n+import org.openrewrite.marker.Markers;\n import org.openrewrite.xml.tree.Xml;\n \n+import java.util.regex.Pattern;\n+\n+import static java.util.Collections.singletonList;\n+import static org.openrewrite.Tree.randomId;\n+\n @Value\n @EqualsAndHashCode(callSuper = false)\n public class ChangeTagValue extends Recipe {\n@@ -34,17 +38,24 @@ public class ChangeTagValue extends Recipe {\n     String elementName;\n \n     @Option(displayName = \"Old value\",\n-            description = \"The old value of the tag.\",\n+            description = \"The old value of the tag. Interpreted as pattern if regex is enabled.\",\n             required = false,\n             example = \"user\")\n     @Nullable\n     String oldValue;\n \n     @Option(displayName = \"New value\",\n-            description = \"The new value for the tag.\",\n+            description = \"The new value for the tag. Supports capture groups when regex is enabled. \" +\n+                    \"If literal $,\\\\ characters are needed in newValue, with regex true, then it should be escaped.\",\n             example = \"user\")\n     String newValue;\n \n+    @Option(displayName = \"Regex\",\n+            description = \"Default false. If true, `oldValue` will be interpreted as a [Regular Expression](https://en.wikipedia.org/wiki/Regular_expression), and capture group contents will be available in `newValue`.\",\n+            required = false)\n+    @Nullable\n+    Boolean regex;\n+\n     @Override\n     public String getDisplayName() {\n         return \"Change XML tag value\";\n@@ -52,7 +63,15 @@ public String getDisplayName() {\n \n     @Override\n     public String getDescription() {\n-        return \"Alters the value of XML tags matching the provided expression.\";\n+        return \"Alters the value of XML tags matching the provided expression. \" +\n+                \"When regex is enabled the replacement happens only for text nodes provided the pattern matches.\";\n+    }\n+\n+    @Override\n+    public Validated<Object> validate(ExecutionContext ctx) {\n+        //noinspection ConstantValue\n+        return super.validate(ctx).and(Validated.test(\"regex\", \"Regex usage requires an `oldValue`\", regex,\n+                value -> value == null || oldValue != null && !oldValue.equals(newValue)));\n     }\n \n     @Override\n@@ -63,9 +82,9 @@ public TreeVisitor<?, ExecutionContext> getVisitor() {\n             @Override\n             public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 if (xPathMatcher.matches(getCursor())) {\n-                    // if either no oldValue is supplied OR oldValue equals the value of this tag\n-                    // then change the value to the newValue supplied\n-                    if (oldValue == null || oldValue.equals(tag.getValue().orElse(null))) {\n+                    if (Boolean.TRUE.equals(regex) && oldValue != null) {\n+                        doAfterVisit(new RegexReplaceVisitor<>(tag, oldValue, newValue));\n+                    } else if (oldValue == null || oldValue.equals(tag.getValue().orElse(null))) {\n                         doAfterVisit(new ChangeTagValueVisitor<>(tag, newValue));\n                     }\n                 }\n@@ -73,4 +92,48 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n             }\n         };\n     }\n+\n+    /**\n+     * This visitor finds and replaces text within a specified XML tag.\n+     * It supports both literal and regular expression replacements.\n+     * Use {@link ChangeTagValueVisitor} if you only wish change the value, irrespective of current data.\n+     *\n+     * @param <P>\n+     */\n+    @Value\n+    @EqualsAndHashCode(callSuper = false)\n+    static class RegexReplaceVisitor<P> extends XmlVisitor<P> {\n+\n+        Xml.Tag scope;\n+        String oldValue;\n+        String newValue;\n+\n+        @Override\n+        public Xml visitTag(Xml.Tag tag, P p) {\n+            Xml.Tag t = (Xml.Tag) super.visitTag(tag, p);\n+            if (scope.isScope(t) &&\n+                    t.getContent() != null &&\n+                    t.getContent().size() == 1 &&\n+                    t.getContent().get(0) instanceof Xml.CharData) {\n+                return updateUsingRegex(t, (Xml.CharData) t.getContent().get(0));\n+            }\n+            return t;\n+        }\n+\n+        private Xml.Tag updateUsingRegex(Xml.Tag t, Xml.CharData content) {\n+            String text = content.getText();\n+            if (Pattern.compile(oldValue).matcher(text).find()) {\n+                Markers oldMarkers = content.getMarkers();\n+                if (oldMarkers\n+                        .findAll(AlreadyReplaced.class)\n+                        .stream()\n+                        .noneMatch(m -> m.getFind().equals(oldValue) && newValue.equals(m.getReplace()))) {\n+                    return t.withContent(singletonList(content\n+                            .withText(text.replaceAll(oldValue, newValue))\n+                            .withMarkers(oldMarkers.add(new AlreadyReplaced(randomId(), oldValue, newValue)))));\n+                }\n+            }\n+            return t;\n+        }\n+    }\n }\n",
    "test_patch": "diff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/ChangeTagValueTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/ChangeTagValueTest.java\nnew file mode 100755\nindex 00000000000..aaa97e84ae6\n--- /dev/null\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/ChangeTagValueTest.java\n@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.xml;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.DocumentExample;\n+import org.openrewrite.ExecutionContext;\n+import org.openrewrite.test.RewriteTest;\n+import org.openrewrite.xml.tree.Xml;\n+\n+import static java.util.Objects.requireNonNull;\n+import static org.openrewrite.test.RewriteTest.toRecipe;\n+import static org.openrewrite.xml.Assertions.xml;\n+\n+class ChangeTagValueTest implements RewriteTest {\n+\n+    @DocumentExample\n+    @Test\n+    void rewriteEmptyTagValue() {\n+        rewriteRun(\n+          spec -> spec.recipe(\n+            new ChangeTagValue(\"/dependency/version\",\n+              null, \"2.0\", null)),\n+          xml(\n+            \"\"\"\n+              <dependency>\n+                  <version/>\n+              </dependency>\n+              \"\"\",\n+            \"\"\"\n+              <dependency>\n+                  <version>2.0</version>\n+              </dependency>\n+              \"\"\")\n+        );\n+    }\n+\n+    @Test\n+    void matchExistingTagValue() {\n+        rewriteRun(\n+          spec -> spec.recipe(\n+            new ChangeTagValue(\"/dependency/version\",\n+              \"1.0\", \"2.0\", null)),\n+          xml(\n+            \"\"\"\n+              <dependency>\n+                  <version>1.0</version>\n+              </dependency>\n+              \"\"\",\n+            \"\"\"\n+              <dependency>\n+                  <version>2.0</version>\n+              </dependency>\n+              \"\"\")\n+        );\n+    }\n+\n+    @Test\n+    void noMatchExistingTagValue() {\n+        rewriteRun(\n+          spec -> spec.recipe(\n+            new ChangeTagValue(\"/dependency/version\",\n+              \"1.0\", \"2.0\", null)),\n+          xml(\n+            \"\"\"\n+              <dependency>\n+                  <version>3.0</version>\n+              </dependency>\n+              \"\"\")\n+        );\n+    }\n+\n+    @Test\n+    void rewriteTagValueSubstring() {\n+        rewriteRun(\n+          spec -> spec.recipe(\n+            new ChangeTagValue(\"/dependency/version\",\n+              \"SNAPSHOT\", \"RELEASE\", true)\n+          ),\n+          xml(\n+            \"\"\"\n+              <dependency>\n+                  <group>com.company.project</group>\n+                  <artifact>artifact</artifact>\n+                  <version>1.2.3-SNAPSHOT</version>\n+              </dependency>\n+              \"\"\",\n+            \"\"\"\n+              <dependency>\n+                  <group>com.company.project</group>\n+                  <artifact>artifact</artifact>\n+                  <version>1.2.3-RELEASE</version>\n+              </dependency>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+\n+    @Test\n+    void appendTagValue() {\n+        rewriteRun(\n+          spec -> spec.recipe(\n+            new ChangeTagValue(\"/dependency/version\",\n+              \"$\", \"-RELEASE\", true)\n+          ),\n+          xml(\n+            \"\"\"\n+              <dependency>\n+                  <group>com.company.project</group>\n+                  <artifact>artifact</artifact>\n+                  <version>1.2.3</version>\n+              </dependency>\n+              \"\"\",\n+            \"\"\"\n+              <dependency>\n+                  <group>com.company.project</group>\n+                  <artifact>artifact</artifact>\n+                  <version>1.2.3-RELEASE</version>\n+              </dependency>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+\n+    @Test\n+    void replaceWithCapturingGroups() {\n+        rewriteRun(\n+          spec -> spec.recipe(\n+            new ChangeTagValue(\"/dependency/version\",\n+              \"(\\\\d).(\\\\d).(\\\\d)\", \"$1.$3.4\", true)\n+          ),\n+          xml(\n+            \"\"\"\n+              <dependency>\n+                  <group>com.company.project</group>\n+                  <artifact>artifact</artifact>\n+                  <version>1.2.3</version>\n+              </dependency>\n+              \"\"\",\n+            \"\"\"\n+              <dependency>\n+                  <group>com.company.project</group>\n+                  <artifact>artifact</artifact>\n+                  <version>1.3.4</version>\n+              </dependency>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void replacedExactlyOnce() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeTagValue(\n+            \"/tag\",\n+            \"(aaa)\",\n+            \"$1-aaa\",\n+            true)),\n+          xml(\n+            \"<tag>aaa</tag>\",\n+            \"<tag>aaa-aaa</tag>\"\n+          )\n+        );\n+    }\n+\n+    @Nested\n+    class FindAndReplaceTagTextVisitorTest {\n+\n+        @Test\n+        void findAndReplace() {\n+            rewriteRun(\n+              spec -> spec.recipe(toRecipe(() -> new XmlVisitor<>() {\n+                  @Override\n+                  public Xml visitDocument(Xml.Document x, ExecutionContext ctx) {\n+                      doAfterVisit(new ChangeTagValue.RegexReplaceVisitor<>(\n+                        (Xml.Tag) requireNonNull(x.getRoot().getContent()).get(0),\n+                        \"2.0\",\n+                        \"3.0\")\n+                      );\n+                      return super.visitDocument(x, ctx);\n+                  }\n+              })),\n+              xml(\n+                \"\"\"\n+                  <dependency>\n+                      <version>\n+                          2.0\n+                      </version>\n+                  </dependency>\n+                  \"\"\",\n+                \"\"\" \n+                  <dependency>\n+                      <version>\n+                          3.0\n+                      </version>\n+                  </dependency>\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void changeContentSubstring() {\n+            rewriteRun(\n+              spec -> spec.recipe(toRecipe(() -> new XmlVisitor<>() {\n+                  @Override\n+                  public Xml visitDocument(Xml.Document x, ExecutionContext ctx) {\n+                      doAfterVisit(new ChangeTagValue.RegexReplaceVisitor<>(\n+                        requireNonNull(x.getRoot()),\n+                        \"SNAPSHOT\",\n+                        \"RELEASE\")\n+                      );\n+                      return super.visitDocument(x, ctx);\n+                  }\n+              })),\n+              xml(\n+                \"<tag>1.2.3-SNAPSHOT</tag>\",\n+                \"<tag>1.2.3-RELEASE</tag>\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void doNothingIfPatternDoesNotMatch() {\n+            rewriteRun(\n+              spec -> spec.recipe(toRecipe(() -> new XmlVisitor<>() {\n+                  @Override\n+                  public Xml visitDocument(Xml.Document x, ExecutionContext ctx) {\n+                      doAfterVisit(new ChangeTagValue.RegexReplaceVisitor<>(\n+                        (Xml.Tag) requireNonNull(x.getRoot().getContent()).get(0),\n+                        \"7.0\",\n+                        \"8.0\")\n+                      );\n+                      return super.visitDocument(x, ctx);\n+                  }\n+              })),\n+              xml(\n+                \"\"\"\n+                  <executions>\n+                      <execution>\n+                          <configs/>\n+                          <goals/>\n+                      </execution>\n+                  </executions>\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void doNothingForNonTextNotFound() {\n+            rewriteRun(\n+              spec -> spec.recipe(toRecipe(() -> new XmlVisitor<>() {\n+                  @Override\n+                  public Xml visitDocument(Xml.Document x, ExecutionContext ctx) {\n+                      doAfterVisit(new ChangeTagValue.RegexReplaceVisitor<>(\n+                        (Xml.Tag) requireNonNull(x.getRoot().getContent()).get(0),\n+                        \"7.0\",\n+                        \"8.0\")\n+                      );\n+                      return super.visitDocument(x, ctx);\n+                  }\n+              })),\n+              xml(\n+                \"\"\"\n+                  <dependency>\n+                      <version>2.0</version>\n+                  </dependency>\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void skipsChildIfNotText() {\n+            rewriteRun(\n+              spec -> spec.recipe(toRecipe(() -> new XmlVisitor<>() {\n+                  @Override\n+                  public Xml visitDocument(Xml.Document x, ExecutionContext ctx) {\n+                      doAfterVisit(new ChangeTagValue.RegexReplaceVisitor<>(\n+                        (Xml.Tag) requireNonNull(x.getRoot().getContent()).get(0),\n+                        \"invalid\",\n+                        \"2.0\")\n+                      );\n+                      return super.visitDocument(x, ctx);\n+                  }\n+              })),\n+              xml(\n+                \"\"\"\n+                  <dependency>\n+                      <version><invalid/></version>\n+                  </dependency>\n+                  \"\"\"\n+              )\n+            );\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/ChangeTagValueVisitorTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/ChangeTagValueVisitorTest.java\nindex 8d844e515bc..808c19e7eb2 100755\n--- a/rewrite-xml/src/test/java/org/openrewrite/xml/ChangeTagValueVisitorTest.java\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/ChangeTagValueVisitorTest.java\n@@ -53,6 +53,26 @@ public Xml visitDocument(Xml.Document x, ExecutionContext ctx) {\n         );\n     }\n \n+    @Test\n+    void noChangeIfAlreadyPresent() {\n+        rewriteRun(\n+          spec -> spec.recipe(toRecipe(() -> new XmlVisitor<>() {\n+              @Override\n+              public Xml visitDocument(Xml.Document x, ExecutionContext ctx) {\n+                  doAfterVisit(new ChangeTagValueVisitor<>((Xml.Tag) requireNonNull(x.getRoot().getContent()).get(0), \"2.0\"));\n+                  return super.visitDocument(x, ctx);\n+              }\n+          })),\n+          xml(\n+            \"\"\"\n+              <dependency>\n+                  <version>2.0</version>\n+              </dependency>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void preserveOriginalFormatting() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4727",
    "pr_id": 4727,
    "issue_id": 4726,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Git Provenance generates a warning when a GitHub organization happens to start with a number\n## What version of OpenRewrite are you using?\r\n\r\nI am using\r\n\r\n- OpenRewrite v8.38.0\r\n- Maven plugin v5.43.4\r\n\r\n## How are you running OpenRewrite?\r\n\r\nWe are running OpenRewrite via the maven plugin.\r\n \r\nThis happens across any of our repositories that have been checked out via SSH: \r\n\r\nOur organization name is `8451LLC` which it appears is tripping up Git Provenance parsing: \r\n\r\n```\r\njava.lang.IllegalArgumentException: Unable to normalize URL: Specifying a port without a scheme is not supported for URL git@github.com:8451LLC/any-repo-in-our-org.git\r\n\tat org.openrewrite.GitRemote$Parser.normalize(GitRemote.java:305)\r\n\tat org.openrewrite.GitRemote$Parser.parse(GitRemote.java:223)\r\n\tat org.openrewrite.marker.GitProvenance.fromGitConfig(GitProvenance.java:259)\r\n\tat org.openrewrite.marker.GitProvenance.fromGitConfig(GitProvenance.java:241)\r\n\tat org.openrewrite.marker.GitProvenance.fromProjectDirectory(GitProvenance.java:224)\r\n\tat org.openrewrite.marker.GitProvenance.fromProjectDirectory(GitProvenance.java:177)\r\n\tat org.openrewrite.maven.MavenMojoProjectParser.lambda$gitProvenance$18(MavenMojoProjectParser.java:795)\r\n\tat java.base/java.util.HashMap.computeIfAbsent(HashMap.java:1134)\r\n\tat org.openrewrite.maven.MavenMojoProjectParser.gitProvenance(MavenMojoProjectParser.java:795)\r\n\tat org.openrewrite.maven.MavenMojoProjectParser.generateProvenance(MavenMojoProjectParser.java:259)\r\n\tat java.base/java.util.stream.Collectors.lambda$uniqKeysMapAccumulator$1(Collectors.java:178)\r\n\tat java.base/java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169)\r\n\tat java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1655)\r\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)\r\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)\r\n\tat java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:913)\r\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:578)\r\n\tat org.openrewrite.maven.MavenMojoProjectParser.listSourceFiles(MavenMojoProjectParser.java:147)\r\n\tat org.openrewrite.maven.AbstractRewriteBaseRunMojo.loadSourceSet(AbstractRewriteBaseRunMojo.java:236)\r\n\tat org.openrewrite.maven.AbstractRewriteBaseRunMojo.listResults(AbstractRewriteBaseRunMojo.java:152)\r\n\tat org.openrewrite.maven.AbstractRewriteRunMojo.execute(AbstractRewriteRunMojo.java:64)\r\n\tat org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:126)\r\n\tat org.apache.maven.lifecycle.internal.MojoExecutor.doExecute2(MojoExecutor.java:328)\r\n\tat org.apache.maven.lifecycle.internal.MojoExecutor.doExecute(MojoExecutor.java:316)\r\n\tat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:212)\r\n\tat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:174)\r\n\tat org.apache.maven.lifecycle.internal.MojoExecutor.access$000(MojoExecutor.java:75)\r\n\tat org.apache.maven.lifecycle.internal.MojoExecutor$1.run(MojoExecutor.java:162)\r\n\tat org.apache.maven.plugin.DefaultMojosExecutionStrategy.execute(DefaultMojosExecutionStrategy.java:39)\r\n\tat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:159)\r\n\tat org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:105)\r\n\tat org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:73)\r\n\tat org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:53)\r\n\tat org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:118)\r\n\tat org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:261)\r\n\tat org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:173)\r\n\tat org.apache.maven.DefaultMaven.execute(DefaultMaven.java:101)\r\n\tat org.apache.maven.cli.MavenCli.execute(MavenCli.java:906)\r\n\tat org.apache.maven.cli.MavenCli.doMain(MavenCli.java:283)\r\n\tat org.apache.maven.cli.MavenCli.main(MavenCli.java:206)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566)\r\n\tat org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:255)\r\n\tat org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:201)\r\n\tat org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:361)\r\n\tat org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:314)\r\n```",
    "issue_word_count": 613,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/GitRemote.java",
      "rewrite-core/src/test/java/org/openrewrite/GitRemoteTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-core/src/test/java/org/openrewrite/GitRemoteTest.java"
    ],
    "base_commit": "860631f0515bfbb6b7950ef12d3a4fe32092f341",
    "head_commit": "c74df09efdc567209f9b5b47233c8d74ae2eefc4",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4727",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4727",
    "dockerfile": "",
    "pr_merged_at": "2024-11-27T22:56:29.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/GitRemote.java b/rewrite-core/src/main/java/org/openrewrite/GitRemote.java\nindex b56b0997ed2..b8ad1320046 100644\n--- a/rewrite-core/src/main/java/org/openrewrite/GitRemote.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/GitRemote.java\n@@ -279,7 +279,7 @@ private String repositoryPath(RemoteServerMatch match, URI normalizedUri) {\n                     .replaceFirst(\"^/\", \"\");\n         }\n \n-        private static final Pattern PORT_PATTERN = Pattern.compile(\":\\\\d+\");\n+        private static final Pattern PORT_PATTERN = Pattern.compile(\":\\\\d+[^-\\\\w]\"); // Allow orgs with numbers in name\n \n         static URI normalize(String url) {\n             try {\n",
    "test_patch": "diff --git a/rewrite-core/src/test/java/org/openrewrite/GitRemoteTest.java b/rewrite-core/src/test/java/org/openrewrite/GitRemoteTest.java\nindex d765cd8aa1d..519fd0044bc 100644\n--- a/rewrite-core/src/test/java/org/openrewrite/GitRemoteTest.java\n+++ b/rewrite-core/src/test/java/org/openrewrite/GitRemoteTest.java\n@@ -32,6 +32,7 @@ public class GitRemoteTest {\n     @CsvSource(textBlock = \"\"\"\n       https://github.com/org/repo, github.com, org/repo, org, repo\n       git@github.com:org/repo.git, github.com, org/repo, org, repo\n+      git@github.com:8451LLC/helm.git, github.com, 8451LLC/helm, 8451LLC, helm\n       ssh://github.com/org/repo.git, github.com, org/repo, org, repo\n       \n       https://gitlab.com/group/repo.git, gitlab.com, group/repo, group, repo\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4723",
    "pr_id": 4723,
    "issue_id": 4722,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Provide recipe to add comment to the specified property\nAdd comment before the specified property.\r\nIf comment is already present, it must not be added second time",
    "issue_word_count": 27,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-properties/src/main/java/org/openrewrite/properties/AddPropertyComment.java",
      "rewrite-properties/src/test/java/org/openrewrite/properties/AddPropertyCommentTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-properties/src/test/java/org/openrewrite/properties/AddPropertyCommentTest.java"
    ],
    "base_commit": "edbeed82d50ed3e4e7192fd6ca559b8638db9ca9",
    "head_commit": "b29833f5683db16f8da407221198017b9ec7b2f1",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4723",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4723",
    "dockerfile": "",
    "pr_merged_at": "2024-11-27T13:23:47.000Z",
    "patch": "diff --git a/rewrite-properties/src/main/java/org/openrewrite/properties/AddPropertyComment.java b/rewrite-properties/src/main/java/org/openrewrite/properties/AddPropertyComment.java\nnew file mode 100755\nindex 00000000000..73048521f1d\n--- /dev/null\n+++ b/rewrite-properties/src/main/java/org/openrewrite/properties/AddPropertyComment.java\n@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.properties;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.Value;\n+import org.jspecify.annotations.Nullable;\n+import org.openrewrite.*;\n+import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.marker.Markers;\n+import org.openrewrite.properties.search.FindProperties;\n+import org.openrewrite.properties.tree.Properties;\n+\n+import java.util.Arrays;\n+import java.util.function.Function;\n+\n+import static org.openrewrite.Tree.randomId;\n+\n+@Value\n+@EqualsAndHashCode(callSuper = false)\n+public class AddPropertyComment extends Recipe {\n+\n+    @Option(displayName = \"Property key\",\n+            description = \"The name of the property to add comment.\",\n+            example = \"management.metrics.binders\")\n+    String propertyKey;\n+\n+    @Option(example = \"comment\", displayName = \"Comment\",\n+            description = \"The comment to be added.\")\n+    String comment;\n+\n+    @Option(example = \"true\", displayName = \"Comment out property\",\n+            description = \"If true, property will be commented out.\",\n+            required = false)\n+    @Nullable\n+    Boolean commentOutProperty;\n+\n+    @Override\n+    public String getDisplayName() {\n+        return \"Add comment before property key\";\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"Add a new comment before a property key if not already present, optionally commenting out the property.\";\n+    }\n+\n+    @Override\n+    public TreeVisitor<?, ExecutionContext> getVisitor() {\n+        PropertiesVisitor<ExecutionContext> propertiesVisitor = new PropertiesVisitor<ExecutionContext>() {\n+            @Override\n+            public Properties visitFile(Properties.File file, ExecutionContext ctx) {\n+                Properties.File p = file.withContent(ListUtils.flatMap(file.getContent(), new Function<Properties.Content, Object>() {\n+                            Properties.@Nullable Content previousContent = null;\n+\n+                            @Override\n+                            public Object apply(Properties.Content c) {\n+                                if (c instanceof Properties.Entry &&\n+                                    ((Properties.Entry) c).getKey().equals(propertyKey) &&\n+                                    !isCommentAlreadyPresent(previousContent, comment)) {\n+                                    Properties.Comment commentContent = new Properties.Comment(\n+                                            randomId(),\n+                                            previousContent == null ? \"\" : \"\\n\",\n+                                            Markers.EMPTY,\n+                                            Properties.Comment.Delimiter.HASH_TAG,\n+                                            \" \" + comment.trim());\n+                                    previousContent = c;\n+                                    return Arrays.asList(commentContent, c.getPrefix().contains(\"\\n\") ?\n+                                            c : c.withPrefix(\"\\n\" + c.getPrefix()));\n+                                }\n+                                previousContent = c;\n+                                return c;\n+                            }\n+                        }\n+                ));\n+                return super.visitFile(p, ctx);\n+            }\n+\n+            @Override\n+            public Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {\n+                if (Boolean.TRUE.equals(commentOutProperty) && entry.getKey().equals(propertyKey)) {\n+                    return new Properties.Comment(\n+                            randomId(),\n+                            entry.getPrefix(),\n+                            entry.getMarkers(),\n+                            Properties.Comment.Delimiter.HASH_TAG,\n+                            \" \" + entry.printTrimmed(getCursor()));\n+                }\n+                return super.visitEntry(entry, ctx);\n+            }\n+        };\n+        return Preconditions.check(new FindProperties(propertyKey, false).getVisitor(), propertiesVisitor);\n+    }\n+\n+    private boolean isCommentAlreadyPresent(Properties.@Nullable Content previousContent, String comment) {\n+        return previousContent instanceof Properties.Comment &&\n+               ((Properties.Comment) previousContent).getMessage().contains(comment.trim());\n+    }\n+}\n",
    "test_patch": "diff --git a/rewrite-properties/src/test/java/org/openrewrite/properties/AddPropertyCommentTest.java b/rewrite-properties/src/test/java/org/openrewrite/properties/AddPropertyCommentTest.java\nnew file mode 100755\nindex 00000000000..05f643df5ce\n--- /dev/null\n+++ b/rewrite-properties/src/test/java/org/openrewrite/properties/AddPropertyCommentTest.java\n@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.properties;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.DocumentExample;\n+import org.openrewrite.test.RewriteTest;\n+\n+import static org.openrewrite.properties.Assertions.properties;\n+\n+class AddPropertyCommentTest implements RewriteTest {\n+\n+    @DocumentExample\n+    @Test\n+    void shouldAddCommentToFirstProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPropertyComment(\n+            \"management.metrics.enable.process.files\",\n+            \"myComment\",\n+            false\n+          )),\n+          properties(\n+            \"\"\"\n+              management.metrics.enable.process.files=true\n+              yyy=true\n+              \"\"\",\n+            \"\"\"\n+              # myComment\n+              management.metrics.enable.process.files=true\n+              yyy=true\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void shouldAddCommentToMiddleProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPropertyComment(\n+            \"management.metrics.enable.process.files\",\n+            \"myComment\",\n+            false\n+          )),\n+          properties(\n+            \"\"\"\n+              xxx=true\n+              management.metrics.enable.process.files=true\n+              yyy=true\n+              \"\"\",\n+            \"\"\"\n+              xxx=true\n+              # myComment\n+              management.metrics.enable.process.files=true\n+              yyy=true\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void shouldAcceptExistingComment() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPropertyComment(\n+            \"management.metrics.enable.process.files\",\n+            \"myComment\",\n+            false\n+          )),\n+          properties(\n+            \"\"\"\n+              # myComment\n+              management.metrics.enable.process.files=true\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void shouldSkipNotExistingProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPropertyComment(\n+            \"xxx\",\n+            \"myComment\",\n+            false\n+          )),\n+          properties(\n+            \"\"\"\n+              yyy=true\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void shouldCommentOutFirstProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPropertyComment(\n+            \"management.metrics.enable.process.files\",\n+            \"myComment\",\n+            true\n+          )),\n+          properties(\n+            \"\"\"\n+              management.metrics.enable.process.files=true\n+              yyy=true\n+              \"\"\",\n+            \"\"\"\n+              # myComment\n+              # management.metrics.enable.process.files=true\n+              yyy=true\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void shouldCommentOutMiddleProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPropertyComment(\n+            \"management.metrics.enable.process.files\",\n+            \"myComment\",\n+            true\n+          )),\n+          properties(\n+            \"\"\"\n+              xxx=true\n+              management.metrics.enable.process.files=true\n+              yyy=true\n+              \"\"\",\n+            \"\"\"\n+              xxx=true\n+              # myComment\n+              # management.metrics.enable.process.files=true\n+              yyy=true\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void shouldAcceptExistingCommentAndCommentOutProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPropertyComment(\n+            \"management.metrics.enable.process.files\",\n+            \"myComment\",\n+            true\n+          )),\n+          properties(\n+            \"\"\"\n+              # myComment\n+              management.metrics.enable.process.files=true\n+              \"\"\",\n+            \"\"\"\n+              # myComment\n+              # management.metrics.enable.process.files=true\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void shouldASkipCommentOutProperty() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddPropertyComment(\n+            \"management.metrics.enable.process.files\",\n+            \"myComment\",\n+            true\n+          )),\n+          properties(\n+            \"\"\"\n+              # myComment\n+              # management.metrics.enable.process.files=true\n+              \"\"\"\n+          )\n+        );\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4719",
    "pr_id": 4719,
    "issue_id": 4716,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Add a new recipe to add comments to a Java method\n<!--\r\nThank you for suggesting a new recipe for OpenRewrite!\r\nFeel free to delete any sections that don't apply to your request.\r\n-->\r\n\r\n## What problem are you trying to solve?\r\n<!-- A description of a problem you encounter that you hope to resolve with a recipe. -->\r\n\r\nI am trying to add a comment to a Java method. This comment could either be single line // or multiline /* */\r\n\r\n## What precondition(s) should be checked before applying this recipe?\r\n<!-- Should we limit execution to certain versions of languages or libraries for instance? -->\r\n\r\nDoes the method exist\r\n\r\n## Describe the situation before applying the recipe\r\n<!-- Ideally as a self-contained code example, as a start to the recipe unit tests. -->\r\n\r\nAdding a single line comment (`isMultiline` is `false`):\r\n\r\n```java\r\nrewriteRun(\r\n    spec -> spec.recipe(new AddCommentToJavaMethod(\" Short comment to add\", \"foo.Foo bar(..)\", false)),\r\n    //language=java\r\n    java(\r\n        \"\"\"\r\n                package foo;\r\n                public class Foo {\r\n                    public void bar(String arg) {}\r\n                }\r\n                \"\"\",\r\n        \"\"\"\r\n                package foo;\r\n                public class Foo {\r\n                    // Short comment to add\r\n                    public void bar(String arg) {}\r\n                }\r\n                \"\"\"\r\n    )\r\n);\r\n```\r\n\r\nAdding a multiline comment (`isMultiline` is `true`):\r\n\r\n```java\r\nrewriteRun(\r\n    spec -> spec.recipe(new AddCommentToJavaMethod(\" This is a very long comment to add. The comment is longer than 80 characters and should use multiline comments, not single line.\", \"foo.Foo bar(..)\", true)),\r\n    //language=java\r\n    java(\r\n        \"\"\"\r\n                package foo;\r\n                public class Foo {\r\n                    public void bar(String arg) {}\r\n                }\r\n                \"\"\",\r\n        \"\"\"\r\n                package foo;\r\n                public class Foo {\r\n                    /* This is a very long comment to add. The comment is longer than 80 characters and should use multiline comments, not single line.*/\r\n                    public void bar(String arg) {}\r\n                }\r\n                \"\"\"\r\n    )\r\n);\r\n```\r\n\r\n## Have you considered any alternatives or workarounds?\r\n<!-- Any other ways to solve the problem, or ways to work around the problem. -->\r\n\r\n## Any additional context\r\n<!-- Any thoughts such as considerations and limitations when applying this recipe, or hints on the implementation. -->\r\n\r\n## Are you interested in [contributing this recipe to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#adding-new-recipes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\n\r\nYes.\r\n",
    "issue_word_count": 344,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java/src/main/java/org/openrewrite/java/AddCommentToMethod.java",
      "rewrite-java/src/test/java/org/openrewrite/java/AddCommentToMethodTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java/src/test/java/org/openrewrite/java/AddCommentToMethodTest.java"
    ],
    "base_commit": "8bd3573ee495863d320d1a5511391b63b1e76886",
    "head_commit": "3666c65dce95512ab636910bc8209bc4203f47e6",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4719",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4719",
    "dockerfile": "",
    "pr_merged_at": "2024-11-26T23:19:54.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/AddCommentToMethod.java b/rewrite-java/src/main/java/org/openrewrite/java/AddCommentToMethod.java\nnew file mode 100644\nindex 00000000000..9a527473b65\n--- /dev/null\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/AddCommentToMethod.java\n@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.Value;\n+import org.jspecify.annotations.Nullable;\n+import org.openrewrite.*;\n+import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.java.search.DeclaresMethod;\n+import org.openrewrite.java.tree.Comment;\n+import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.TextComment;\n+import org.openrewrite.marker.Markers;\n+\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * This recipe adds a comment to a method in a Java source file. The comment can be a single line or a multiline comment.\n+ * <p>\n+ * The {@link AddCommentToMethod#comment} must be supplied and is the comment to add.\n+ * <p>\n+ * The {@link AddCommentToMethod#methodPattern} is a pattern to match methods to add the comment to.\n+ * <p>\n+ * The {@link AddCommentToMethod#isMultiline} is an optional flag (defaulted to false) to indicate if the comment is a multiline comment.\n+ */\n+@Value\n+@EqualsAndHashCode(callSuper = false)\n+public class AddCommentToMethod extends Recipe {\n+    @Override\n+    public String getDisplayName() {\n+        return \"Add comment\";\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"Add a comment to a Java source file.\";\n+    }\n+\n+    @Option(displayName = \"Comment\",\n+            description = \"The comment to add.\",\n+            example = \"This is a comment.\")\n+    String comment;\n+\n+    @Option(displayName = \"Method pattern\",\n+            description = \"A pattern to match methods to add the comment to.\",\n+            example = \"java.util.List add*(..)\")\n+    String methodPattern;\n+\n+    @Option(displayName = \"Multiline\",\n+            description = \"Comments use by default single line // but they can use multiline /* */.\",\n+            required = false)\n+    @Nullable\n+    Boolean isMultiline;\n+\n+    private static final Pattern NEWLINE = Pattern.compile(\"\\\\R\");\n+\n+    @Override\n+    public TreeVisitor<?, ExecutionContext> getVisitor() {\n+        MethodMatcher methodMatcher = new MethodMatcher(methodPattern);\n+        return Preconditions.check(new DeclaresMethod<>(methodMatcher), new JavaIsoVisitor<ExecutionContext>() {\n+            @Override\n+            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {\n+                J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);\n+                J.ClassDeclaration cd = getCursor().firstEnclosingOrThrow(J.ClassDeclaration.class);\n+\n+                if (methodMatcher.matches(md, cd)) {\n+                    String methodPrefixWhitespace = md.getPrefix().getWhitespace();\n+\n+                    boolean isMultiline = Boolean.TRUE.equals(AddCommentToMethod.this.isMultiline);\n+                    Matcher matcher = NEWLINE.matcher(comment);\n+                    String newCommentText = matcher.find() ? matcher.replaceAll(isMultiline ? methodPrefixWhitespace: \" \") : comment;\n+\n+                    if (doesNotHaveComment(newCommentText, md.getComments())) {\n+                        TextComment textComment = new TextComment(isMultiline, newCommentText, methodPrefixWhitespace, Markers.EMPTY);\n+                        return md.withComments(ListUtils.concat(md.getComments(), textComment));\n+                    }\n+                }\n+                return md;\n+            }\n+\n+            private boolean doesNotHaveComment(String lookFor, List<Comment> comments) {\n+                for (Comment c : comments) {\n+                    if (c instanceof TextComment &&\n+                        lookFor.equals(((TextComment) c).getText())) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        });\n+    }\n+}\n",
    "test_patch": "diff --git a/rewrite-java/src/test/java/org/openrewrite/java/AddCommentToMethodTest.java b/rewrite-java/src/test/java/org/openrewrite/java/AddCommentToMethodTest.java\nnew file mode 100644\nindex 00000000000..ae9029e3259\n--- /dev/null\n+++ b/rewrite-java/src/test/java/org/openrewrite/java/AddCommentToMethodTest.java\n@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.DocumentExample;\n+import org.openrewrite.test.RewriteTest;\n+\n+import static org.openrewrite.java.Assertions.java;\n+\n+class AddCommentToMethodTest implements RewriteTest {\n+\n+    private static final String SHORT_COMMENT = \" Short comment to add\";\n+    private static final String LONG_COMMENT = \" This is a very long comment to add. The comment uses multiline comments, not single line.\";\n+\n+    @DocumentExample\n+    @Test\n+    void addSingleLineComment() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddCommentToMethod(SHORT_COMMENT, \"foo.Foo bar(..)\", false)),\n+          //language=java\n+          java(\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\",\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  // Short comment to add\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addLongComment() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddCommentToMethod(LONG_COMMENT, \"foo.Foo bar(..)\", true)),\n+          //language=java\n+          java(\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\",\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  /* This is a very long comment to add. The comment uses multiline comments, not single line.*/\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addMultilineComment() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddCommentToMethod(\"\\nLine 1\\nLine 2\\nLine 3\\n\", \"foo.Foo bar(..)\", true)),\n+          //language=java\n+          java(\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\",\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  /*\n+                  Line 1\n+                  Line 2\n+                  Line 3\n+                  */\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addMultilineCommentOnSingleLine() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddCommentToMethod(\"\\nLine 1\\nLine 2\\nLine 3\\n\", \"foo.Foo bar(..)\", false)),\n+          //language=java\n+          java(\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\",\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  // Line 1 Line 2 Line 3\\s\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addSingleLineCommentToExistingSingleLineComments() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddCommentToMethod(SHORT_COMMENT, \"foo.Foo bar(..)\", false)),\n+          //language=java\n+          java(\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  // Existing single line comment\n+                  // Another existing single line comment\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\",\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  // Existing single line comment\n+                  // Another existing single line comment\n+                  // Short comment to add\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addSingleLineCommentToExistingMultiLineComment() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddCommentToMethod(SHORT_COMMENT, \"foo.Foo bar(..)\", false)),\n+          //language=java\n+          java(\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  /**\n+                   * Existing multi line\n+                   * comment\n+                   */\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\",\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  /**\n+                   * Existing multi line\n+                   * comment\n+                   */\n+                  // Short comment to add\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addLongCommentToExistingMultiLineComment() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddCommentToMethod(LONG_COMMENT, \"foo.Foo bar(..)\", true)),\n+          //language=java\n+          java(\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  /**\n+                   * Existing multi line\n+                   * comment\n+                   */\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\",\n+            \"\"\"\n+              package foo;\n+              public class Foo {\n+                  /**\n+                   * Existing multi line\n+                   * comment\n+                   */\n+                  /* This is a very long comment to add. The comment uses multiline comments, not single line.*/\n+                  public void bar(String arg) {}\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4707",
    "pr_id": 4707,
    "issue_id": 4702,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Groovy parser does not correctly handle variables with nested type parameters.\nWhen we attempt to parse:\r\n```groovy\r\nclass A {\r\n    def map = new HashMap<String, List<String>>()\r\n}\r\n```\r\n\r\nWhat we actually get is:\r\n```groovy\r\nclass A {\r\n    def map = new HashMap<String, List<String>()>()\r\n}\r\n```\r\n\r\nReproduced in [VariableDeclarationsTest.nestedTypeParameters()](https://github.com/openrewrite/rewrite/blob/652654e57c5387c93c0c7d844b957c29ced52871/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/VariableDeclarationsTest.java#L188)",
    "issue_word_count": 64,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/BinaryTest.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/VariableDeclarationsTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/BinaryTest.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/VariableDeclarationsTest.java"
    ],
    "base_commit": "2b76e9c16bd1a3d1517d5307a0b0b39db49bd40c",
    "head_commit": "b5f33e64cbd27c86ed8a99648e3df14e1752fd5e",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4707",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4707",
    "dockerfile": "",
    "pr_merged_at": "2024-11-23T20:43:12.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex c62310c1871..6e0607621ae 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -2585,7 +2585,7 @@ private Expression visitTypeParameterization(GenericsType genericsType) {\n             return new J.Empty(randomId(), prefix, Markers.EMPTY);\n         }\n         cursor = saveCursor;\n-        return typeTree(null)\n+        return typeTree(genericsType.getType())\n                 .withType(typeMapping.type(genericsType));\n     }\n \n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/BinaryTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/BinaryTest.java\nindex fc739904edf..2d2675bfe72 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/BinaryTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/BinaryTest.java\n@@ -207,18 +207,18 @@ void stringMultipliedInParentheses() {\n     void extraParensAroundInfixOperator() {\n         rewriteRun(\n           groovy(\n-                \"\"\"\n-            def foo(Map map) {\n-                ((map.containsKey(\"foo\"))\n-                        && ((map.get(\"foo\")).equals(\"bar\")))\n-            }\n-            def timestamp(int hours, int minutes, int seconds) {\n-                (hours) * 60 * 60 + (minutes * 60) + seconds\n-            }\n-            def differenceInDays(int time) {\n-                return (int) ((time)/(1000*60*60*24))\n-            }\n             \"\"\"\n+              def foo(Map map) {\n+                  ((map.containsKey(\"foo\"))\n+                          && ((map.get(\"foo\")).equals(\"bar\")))\n+              }\n+              def timestamp(int hours, int minutes, int seconds) {\n+                  (hours) * 60 * 60 + (minutes * 60) + seconds\n+              }\n+              def differenceInDays(int time) {\n+                  return (int) ((time)/(1000*60*60*24))\n+              }\n+              \"\"\"\n           )\n         );\n     }\n\ndiff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/VariableDeclarationsTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/VariableDeclarationsTest.java\nindex 5e16609e9b5..3915c6c39f8 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/VariableDeclarationsTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/VariableDeclarationsTest.java\n@@ -49,6 +49,13 @@ void finalKeyword() {\n         );\n     }\n \n+    @Test\n+    void nestedGenerics() {\n+        rewriteRun(\n+          groovy(\"final map = new HashMap<String, List<String>>()\")\n+        );\n+    }\n+\n     @Test\n     void singleVariableDeclaration() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4706",
    "pr_id": 4706,
    "issue_id": 4704,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Groovy parser fails to parse constructor declarations\nI haven't categorized exactly _why_ this fails to parse yet in a way that is fully distinct from other issues, but this code should parse and instead throws an exception:\r\n\r\n```groovy\r\nclass Pair {\r\n    String foo\r\n    String bar\r\n    Pair(String foo, String bar) {\r\n        this.foo = foo\r\n        this.bar = bar\r\n    }\r\n}\r\n\r\nclass A {\r\n    def foo(List l) {\r\n        l.add(new Pair(\"foo\", \"bar\"))\r\n        l.add(new Pair(\"foo\", \"bar\"))\r\n        l.add(new Pair(\"foo\", \"bar\"))\r\n        l.add(new Pair(\"foo\", \"bar\"))\r\n    }\r\n}\r\n```\r\n\r\nReproduced in test [CompilationUnitTest.addingToMaps()](https://github.com/openrewrite/rewrite/blob/2b05fc22d1236e7b2ee51d8c6972d7f7c63e5bcf/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/CompilationUnitTest.java#L130)",
    "issue_word_count": 110,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/CompilationUnitTest.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ConstructorTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/CompilationUnitTest.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ConstructorTest.java"
    ],
    "base_commit": "dcc0ec6d3d12565704fd9b3be7bfd60bb1abec98",
    "head_commit": "45f6962c3103bebf180ed6e8b7d468c31d3071dd",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4706",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4706",
    "dockerfile": "",
    "pr_merged_at": "2024-11-23T20:43:44.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex 6e0607621ae..47b65310df4 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -350,6 +350,12 @@ class A {\n                 }\n                 sortedByPosition.computeIfAbsent(pos(field), i -> new ArrayList<>()).add(field);\n             }\n+            for (ConstructorNode ctor : clazz.getDeclaredConstructors()) {\n+                if (!appearsInSource(ctor)) {\n+                    continue;\n+                }\n+                sortedByPosition.computeIfAbsent(pos(ctor), i -> new ArrayList<>()).add(ctor);\n+            }\n             Iterator<InnerClassNode> innerClassIterator = clazz.getInnerClasses();\n             while (innerClassIterator.hasNext()) {\n                 InnerClassNode icn = innerClassIterator.next();\n@@ -366,6 +372,8 @@ class A {\n                                     .map(ast -> {\n                                         if (ast instanceof FieldNode) {\n                                             visitField((FieldNode) ast);\n+                                        } else if (ast instanceof ConstructorNode) {\n+                                            visitConstructor((ConstructorNode) ast);\n                                         } else if (ast instanceof MethodNode) {\n                                             visitMethod((MethodNode) ast);\n                                         } else if (ast instanceof ClassNode) {\n@@ -595,6 +603,109 @@ null, emptyList(),\n             ));\n         }\n \n+        @Override\n+        public void visitConstructor(ConstructorNode ctor) {\n+            Space fmt = whitespace();\n+\n+            List<J.Annotation> annotations = ctor.getAnnotations().stream()\n+                    .map(a -> {\n+                        visitAnnotation(a);\n+                        return (J.Annotation) pollQueue();\n+                    })\n+                    .collect(Collectors.toList());\n+\n+            List<J.Modifier> modifiers = visitModifiers(ctor.getModifiers());\n+\n+            // Constructor name might be in quotes\n+            Space namePrefix = whitespace();\n+            String ctorName;\n+            if (source.startsWith(ctor.getDeclaringClass().getName(), cursor)) {\n+                ctorName = ctor.getDeclaringClass().getName();\n+            } else {\n+                char openingQuote = source.charAt(cursor);\n+                ctorName = openingQuote + ctor.getName() + openingQuote;\n+            }\n+            cursor += ctorName.length();\n+            J.Identifier name = new J.Identifier(randomId(),\n+                    namePrefix,\n+                    Markers.EMPTY,\n+                    emptyList(),\n+                    ctorName,\n+                    null, null);\n+\n+            RewriteGroovyVisitor bodyVisitor = new RewriteGroovyVisitor(ctor, this);\n+\n+            // Parameter has no visit implementation, so we've got to do this by hand\n+            Space beforeParen = sourceBefore(\"(\");\n+            List<JRightPadded<Statement>> params = new ArrayList<>(ctor.getParameters().length);\n+            Parameter[] unparsedParams = ctor.getParameters();\n+            for (int i = 0; i < unparsedParams.length; i++) {\n+                Parameter param = unparsedParams[i];\n+\n+                List<J.Annotation> paramAnnotations = param.getAnnotations().stream()\n+                        .map(a -> {\n+                            visitAnnotation(a);\n+                            return (J.Annotation) pollQueue();\n+                        })\n+                        .collect(Collectors.toList());\n+\n+                TypeTree paramType;\n+                if (param.isDynamicTyped()) {\n+                    paramType = new J.Identifier(randomId(), EMPTY, Markers.EMPTY, emptyList(), \"\", JavaType.ShallowClass.build(\"java.lang.Object\"), null);\n+                } else {\n+                    paramType = visitTypeTree(param.getOriginType());\n+                }\n+                JRightPadded<J.VariableDeclarations.NamedVariable> paramName = JRightPadded.build(\n+                        new J.VariableDeclarations.NamedVariable(randomId(), EMPTY, Markers.EMPTY,\n+                                new J.Identifier(randomId(), whitespace(), Markers.EMPTY, emptyList(), param.getName(), null, null),\n+                                emptyList(), null, null)\n+                );\n+                cursor += param.getName().length();\n+\n+                org.codehaus.groovy.ast.expr.Expression defaultValue = param.getInitialExpression();\n+                if (defaultValue != null) {\n+                    paramName = paramName.withElement(paramName.getElement().getPadding()\n+                            .withInitializer(new JLeftPadded<>(\n+                                    sourceBefore(\"=\"),\n+                                    new RewriteGroovyVisitor(defaultValue, this).visit(defaultValue),\n+                                    Markers.EMPTY)));\n+                }\n+                Space rightPad = sourceBefore(i == unparsedParams.length - 1 ? \")\" : \",\");\n+\n+                params.add(JRightPadded.build((Statement) new J.VariableDeclarations(randomId(), EMPTY,\n+                        Markers.EMPTY, paramAnnotations, emptyList(), paramType,\n+                        null, emptyList(),\n+                        singletonList(paramName))).withAfter(rightPad));\n+            }\n+\n+            if (unparsedParams.length == 0) {\n+                params.add(JRightPadded.build(new J.Empty(randomId(), sourceBefore(\")\"), Markers.EMPTY)));\n+            }\n+\n+            JContainer<NameTree> throws_ = ctor.getExceptions().length == 0 ? null : JContainer.build(\n+                    sourceBefore(\"throws\"),\n+                    bodyVisitor.visitRightPadded(ctor.getExceptions(), null),\n+                    Markers.EMPTY\n+            );\n+\n+            J.Block body = ctor.getCode() == null ? null :\n+                    bodyVisitor.visit(ctor.getCode());\n+\n+            queue.add(new J.MethodDeclaration(\n+                    randomId(), fmt, Markers.EMPTY,\n+                    annotations,\n+                    modifiers,\n+                    null,\n+                    null,\n+                    new J.MethodDeclaration.IdentifierWithAnnotations(name, emptyList()),\n+                    JContainer.build(beforeParen, params, Markers.EMPTY),\n+                    throws_,\n+                    body,\n+                    null,\n+                    typeMapping.methodType(ctor)\n+            ));\n+        }\n+\n         @SuppressWarnings({\"ConstantConditions\", \"unchecked\"})\n         private <T> T pollQueue() {\n             return (T) queue.poll();\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/CompilationUnitTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/CompilationUnitTest.java\nindex 0e438eb6089..47ff7dd24eb 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/CompilationUnitTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/CompilationUnitTest.java\n@@ -16,7 +16,6 @@\n package org.openrewrite.groovy.tree;\n \n import org.codehaus.groovy.control.customizers.ImportCustomizer;\n-import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n import org.openrewrite.Issue;\n import org.openrewrite.groovy.GroovyParser;\n@@ -125,7 +124,6 @@ void shouldNotFailWhenImportCannotBeResolved() {\n     }\n \n     @Issue(\"https://github.com/openrewrite/rewrite/issues/4704\")\n-    @Disabled\n     @Test\n     void addingToMaps() {\n         rewriteRun(\n\ndiff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ConstructorTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ConstructorTest.java\nindex 802dc558882..16e575e0c96 100644\n--- a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ConstructorTest.java\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/ConstructorTest.java\n@@ -35,6 +35,24 @@ void inParens() {\n         );\n     }\n \n+    @Test\n+    void declaration() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              class Pair {\n+                  String first\n+                  String second\n+                  Pair(String first, String second) {\n+                      this.first = first\n+                      this.second = second\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void anonymousClassDeclarationClosedOverVariable() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4697",
    "pr_id": 4697,
    "issue_id": 4681,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Expand `Reference` to include `.properties` and `.yml`\n## What problem are you trying to solve?\r\nType references can occur in more places; for instance as value in a properties file, or as value or even key in yaml files.\r\n\r\n## Describe the solution you'd like\r\nExpand the recently added Reference and SourceFileWIthReferences to also cover properties and yaml. For Yaml specifically it would be nice to also cover cases where the type might be a key, and not just a value.\r\n```yaml\r\nrecipeList:\r\n  - org.....MyRecipe:\r\n      with: arg\r\n```\r\nFor properties only looking at values is likely enough.\r\n\r\n## Additional context\r\n- https://github.com/openrewrite/rewrite-hibernate/issues/44\r\n- [SpringReference](https://github.com/openrewrite/rewrite/blob/main/rewrite-xml/src/main/java/org/openrewrite/xml/trait/SpringReference.java)\r\n- [Xml.Document](https://github.com/openrewrite/rewrite/blob/main/rewrite-xml/src/main/java/org/openrewrite/xml/tree/Xml.java#L86)\r\n- [Xml.Document reference cache](https://github.com/openrewrite/rewrite/blob/main/rewrite-xml/src/main/java/org/openrewrite/xml/tree/Xml.java#L170-L189)\r\n",
    "issue_word_count": 169,
    "test_files_count": 3,
    "non_test_files_count": 7,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java",
      "rewrite-java/build.gradle.kts",
      "rewrite-java/src/main/java/org/openrewrite/java/PackageMatcher.java",
      "rewrite-java/src/main/java/org/openrewrite/java/TypeMatcher.java",
      "rewrite-properties/src/main/java/org/openrewrite/properties/trait/PropertiesReference.java",
      "rewrite-properties/src/main/java/org/openrewrite/properties/trait/package-info.java",
      "rewrite-properties/src/main/java/org/openrewrite/properties/tree/Properties.java",
      "rewrite-properties/src/main/resources/META-INF/services/org.openrewrite.trait.Reference$Provider",
      "rewrite-properties/src/test/java/org/openrewrite/properties/trait/PropertiesReferenceTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java",
      "rewrite-properties/src/test/java/org/openrewrite/properties/trait/PropertiesReferenceTest.java"
    ],
    "base_commit": "73438cdae260db0c8721b642df6586634b4f17b5",
    "head_commit": "713ced29e3f92f9acbe2ac32e438eae093af72f4",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4697",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4697",
    "dockerfile": "",
    "pr_merged_at": "2024-11-25T12:23:09.000Z",
    "patch": "diff --git a/rewrite-java/build.gradle.kts b/rewrite-java/build.gradle.kts\nindex 92121e1ec1b..1bd4cf059fa 100644\n--- a/rewrite-java/build.gradle.kts\n+++ b/rewrite-java/build.gradle.kts\n@@ -34,6 +34,7 @@ dependencies {\n     api(project(\":rewrite-core\"))\n     api(project(\":rewrite-yaml\"))\n     api(project(\":rewrite-xml\"))\n+    api(project(\":rewrite-properties\"))\n \n     api(\"io.micrometer:micrometer-core:1.9.+\")\n     api(\"org.jetbrains:annotations:latest.release\")\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/PackageMatcher.java b/rewrite-java/src/main/java/org/openrewrite/java/PackageMatcher.java\nindex c6a88019001..7c6333f87e3 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/PackageMatcher.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/PackageMatcher.java\n@@ -21,6 +21,7 @@\n import org.openrewrite.Tree;\n import org.openrewrite.TreeVisitor;\n import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.properties.tree.Properties;\n import org.openrewrite.trait.Reference;\n import org.openrewrite.xml.tree.Xml;\n \n@@ -58,6 +59,10 @@ public TreeVisitor<Tree, ExecutionContext> rename(String newValue) {\n             @Override\n             public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {\n                 if (StringUtils.isNotEmpty(newValue)) {\n+                    if (tree instanceof Properties.Entry) {\n+                        Properties.Entry entry = (Properties.Entry) tree;\n+                        return entry.withValue(entry.getValue().withText(getReplacement(entry.getValue().getText(), targetPackage, newValue)));\n+                    }\n                     if (tree instanceof Xml.Attribute) {\n                         return ((Xml.Attribute) tree).withValue(((Xml.Attribute) tree).getValue().withValue(getReplacement(((Xml.Attribute) tree).getValueAsString(), targetPackage, newValue)));\n                     }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/TypeMatcher.java b/rewrite-java/src/main/java/org/openrewrite/java/TypeMatcher.java\nindex fe5a8cdea9f..85beb5afc21 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/TypeMatcher.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/TypeMatcher.java\n@@ -31,6 +31,7 @@\n import org.openrewrite.java.tree.TypeUtils;\n import org.openrewrite.trait.Reference;\n import org.openrewrite.xml.tree.Xml;\n+import org.openrewrite.properties.tree.Properties;\n \n import java.util.regex.Pattern;\n \n@@ -126,6 +127,9 @@ public TreeVisitor<Tree, ExecutionContext> rename(String newValue) {\n             @Override\n             public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {\n                 if (StringUtils.isNotEmpty(newValue)) {\n+                    if (tree instanceof Properties.Entry) {\n+                        return ((Properties.Entry) tree).withValue(((Properties.Entry) tree).getValue().withText(newValue));\n+                    }\n                     if (tree instanceof Xml.Attribute) {\n                         return ((Xml.Attribute) tree).withValue(((Xml.Attribute) tree).getValue().withValue(newValue));\n                     }\n\ndiff --git a/rewrite-properties/src/main/java/org/openrewrite/properties/trait/PropertiesReference.java b/rewrite-properties/src/main/java/org/openrewrite/properties/trait/PropertiesReference.java\nnew file mode 100644\nindex 00000000000..ed1a5df69c4\n--- /dev/null\n+++ b/rewrite-properties/src/main/java/org/openrewrite/properties/trait/PropertiesReference.java\n@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.properties.trait;\n+\n+import lombok.Value;\n+import org.jspecify.annotations.Nullable;\n+import org.openrewrite.Cursor;\n+import org.openrewrite.SourceFile;\n+import org.openrewrite.properties.tree.Properties;\n+import org.openrewrite.trait.Reference;\n+import org.openrewrite.trait.SimpleTraitMatcher;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+\n+@Value\n+public class PropertiesReference implements Reference {\n+    Cursor cursor;\n+    Kind kind;\n+\n+    @Override\n+    public Kind getKind() {\n+        return kind;\n+    }\n+\n+    @Override\n+    public String getValue() {\n+        if (getTree() instanceof Properties.Entry) {\n+            return ((Properties.Entry) getTree()).getValue().getText();\n+        }\n+        throw new IllegalArgumentException(\"getTree() must be an Properties.Entry: \" + getTree().getClass());\n+    }\n+\n+    @Override\n+    public boolean supportsRename() {\n+        return true;\n+    }\n+\n+    public static class Matcher extends SimpleTraitMatcher<PropertiesReference> {\n+        private static final Predicate<String> javaFullyQualifiedTypeMatcher = Pattern.compile(\n+                \"\\\\p{javaJavaIdentifierStart}\\\\p{javaJavaIdentifierPart}*\\\\.\\\\p{javaJavaIdentifierStart}\\\\p{javaJavaIdentifierPart}*(?:\\\\.\\\\p{javaJavaIdentifierStart}\\\\p{javaJavaIdentifierPart}*)*\").asPredicate();\n+\n+        @Override\n+        protected @Nullable PropertiesReference test(Cursor cursor) {\n+            Object value = cursor.getValue();\n+            if (value instanceof Properties.Entry &&\n+                javaFullyQualifiedTypeMatcher.test(((Properties.Entry) value).getValue().getText())) {\n+                return new PropertiesReference(cursor, determineKind(((Properties.Entry) value).getValue().getText()));\n+            }\n+            return null;\n+        }\n+\n+        private Kind determineKind(String value) {\n+            return Character.isUpperCase(value.charAt(value.lastIndexOf('.') + 1)) ? Kind.TYPE : Kind.PACKAGE;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    public static class Provider implements Reference.Provider {\n+        private static final Predicate<String> applicationPropertiesMatcher = Pattern.compile(\"^application(-\\\\w+)?\\\\.properties$\").asPredicate();\n+\n+        @Override\n+        public Set<Reference> getReferences(SourceFile sourceFile) {\n+            Set<Reference> references = new HashSet<>();\n+            new Matcher().asVisitor(reference -> {\n+                references.add(reference);\n+                return reference.getTree();\n+            }).visit(sourceFile, 0);\n+            return references;\n+        }\n+\n+        @Override\n+        public boolean isAcceptable(SourceFile sourceFile) {\n+            return sourceFile instanceof Properties.File && applicationPropertiesMatcher.test(sourceFile.getSourcePath().getFileName().toString());\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-properties/src/main/java/org/openrewrite/properties/trait/package-info.java b/rewrite-properties/src/main/java/org/openrewrite/properties/trait/package-info.java\nnew file mode 100644\nindex 00000000000..ec499ac0083\n--- /dev/null\n+++ b/rewrite-properties/src/main/java/org/openrewrite/properties/trait/package-info.java\n@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2021 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+@NullMarked\n+@NonNullFields\n+package org.openrewrite.properties.trait;\n+\n+import org.jspecify.annotations.NullMarked;\n+import org.openrewrite.internal.lang.NonNullFields;\n\ndiff --git a/rewrite-properties/src/main/java/org/openrewrite/properties/tree/Properties.java b/rewrite-properties/src/main/java/org/openrewrite/properties/tree/Properties.java\nindex 68dbc300da3..098ea01dd35 100755\n--- a/rewrite-properties/src/main/java/org/openrewrite/properties/tree/Properties.java\n+++ b/rewrite-properties/src/main/java/org/openrewrite/properties/tree/Properties.java\n@@ -15,16 +15,16 @@\n  */\n package org.openrewrite.properties.tree;\n \n-import lombok.AccessLevel;\n-import lombok.EqualsAndHashCode;\n-import lombok.Getter;\n-import lombok.With;\n+import lombok.*;\n+import lombok.experimental.NonFinal;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n import org.openrewrite.marker.Markers;\n import org.openrewrite.properties.PropertiesVisitor;\n import org.openrewrite.properties.internal.PropertiesPrinter;\n \n+import java.beans.Transient;\n+import java.lang.ref.SoftReference;\n import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Path;\n@@ -55,7 +55,9 @@ default <P> boolean isAcceptable(TreeVisitor<?, P> v, P p) {\n \n     @lombok.Value\n     @EqualsAndHashCode(callSuper = false, onlyExplicitlyIncluded = true)\n-    class File implements Properties, SourceFile {\n+    @RequiredArgsConstructor\n+    @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+    class File implements Properties, SourceFileWithReferences {\n         @With\n         @EqualsAndHashCode.Include\n         UUID id;\n@@ -110,6 +112,27 @@ public <P> Properties acceptProperties(PropertiesVisitor<P> v, P p) {\n         public <P> TreeVisitor<?, PrintOutputCapture<P>> printer(Cursor cursor) {\n             return new PropertiesPrinter<>();\n         }\n+\n+        @Nullable\n+        @NonFinal\n+        transient SoftReference<References> references;\n+\n+        @Transient\n+        @Override\n+        public References getReferences() {\n+            References cache;\n+            if (this.references == null) {\n+                cache = References.build(this);\n+                this.references = new SoftReference<>(cache);\n+            } else {\n+                cache = this.references.get();\n+                if (cache == null || cache.getSourceFile() != this) {\n+                    cache = References.build(this);\n+                    this.references = new SoftReference<>(cache);\n+                }\n+            }\n+            return cache;\n+        }\n     }\n \n     interface Content extends Properties {\n\ndiff --git a/rewrite-properties/src/main/resources/META-INF/services/org.openrewrite.trait.Reference$Provider b/rewrite-properties/src/main/resources/META-INF/services/org.openrewrite.trait.Reference$Provider\nnew file mode 100644\nindex 00000000000..d85b14ebccd\n--- /dev/null\n+++ b/rewrite-properties/src/main/resources/META-INF/services/org.openrewrite.trait.Reference$Provider\n@@ -0,0 +1 @@\n+org.openrewrite.properties.trait.PropertiesReference$Provider\n\\ No newline at end of file\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java\nindex c307f330f27..39ca3ed049e 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java\n@@ -30,6 +30,7 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.openrewrite.java.Assertions.java;\n+import static org.openrewrite.properties.Assertions.properties;\n import static org.openrewrite.xml.Assertions.xml;\n \n @SuppressWarnings(\"ConstantConditions\")\n@@ -1725,4 +1726,22 @@ void changePackageInSpringXml() {\n         );\n \n     }\n+\n+    @Test\n+    void changeTypeInPropertiesFile() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePackage(\"java.lang\", \"java.cool\", true)),\n+          properties(\n+            \"\"\"\n+              a.property=java.lang.String\n+              b.property=java.lang.test.String\n+              c.property=String\n+              \"\"\",\n+            \"\"\"\n+              a.property=java.cool.String\n+              b.property=java.cool.test.String\n+              c.property=String\n+              \"\"\", spec -> spec.path(\"application.properties\"))\n+        );\n+    }\n }\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java\nindex d957ef4cf5e..487e56e4a8e 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java\n@@ -29,6 +29,7 @@\n import static org.assertj.core.api.Assertions.assertThat;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.openrewrite.java.Assertions.java;\n+import static org.openrewrite.properties.Assertions.properties;\n import static org.openrewrite.xml.Assertions.xml;\n \n @SuppressWarnings(\"ConstantConditions\")\n@@ -2062,4 +2063,20 @@ public class HelloClass {}\n             }))\n         );\n     }\n+\n+    @Test\n+    void changeTypeInPropertiesFile() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeType(\"java.lang.String\", \"java.lang.Integer\", true)),\n+          properties(\n+            \"\"\"\n+              a.property=java.lang.String\n+              b.property=String\n+              \"\"\",\n+            \"\"\"\n+              a.property=java.lang.Integer\n+              b.property=String\n+              \"\"\", spec -> spec.path(\"application.properties\"))\n+        );\n+    }\n }\n\ndiff --git a/rewrite-properties/src/test/java/org/openrewrite/properties/trait/PropertiesReferenceTest.java b/rewrite-properties/src/test/java/org/openrewrite/properties/trait/PropertiesReferenceTest.java\nnew file mode 100644\nindex 00000000000..5283957a46d\n--- /dev/null\n+++ b/rewrite-properties/src/test/java/org/openrewrite/properties/trait/PropertiesReferenceTest.java\n@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.properties.trait;\n+\n+import org.intellij.lang.annotations.Language;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.openrewrite.test.RewriteTest;\n+import org.openrewrite.trait.Reference;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openrewrite.properties.Assertions.properties;\n+\n+class PropertiesReferenceTest implements RewriteTest {\n+\n+    @Language(\"properties\")\n+    private static final String PROPERTIES = \"\"\"\n+      a.fqt=java.lang.String\n+      b.package=java.lang\n+      c.type=Integer\n+      \"\"\";\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+      \"application.properties\",\n+      \"application-test.properties\",\n+      \"/foo/bar/application-test.properties\",\n+    })\n+    void findJavaReferencesInApplicationProperties(String filename) {\n+        rewriteRun(\n+          properties(\n+            PROPERTIES,\n+            spec -> spec.path(filename).afterRecipe(doc ->\n+              assertThat(doc.getReferences().getReferences())\n+                .satisfiesExactlyInAnyOrder(\n+                  ref -> {\n+                      assertThat(ref.getKind()).isEqualTo(Reference.Kind.TYPE);\n+                      assertThat(ref.getValue()).isEqualTo(\"java.lang.String\");\n+                  },\n+                  ref -> {\n+                      assertThat(ref.getKind()).isEqualTo(Reference.Kind.PACKAGE);\n+                      assertThat(ref.getValue()).isEqualTo(\"java.lang\");\n+                  }\n+                )\n+            )\n+          )\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+      \"application-.properties\",\n+      \"application.test.properties\",\n+      \"other-application.properties\",\n+      \"other.properties\",\n+      \"/foo/bar/other.properties\"\n+    })\n+    void noReferencesInMismatchedFilenames(String filename) {\n+        rewriteRun(\n+          properties(\n+            PROPERTIES,\n+            spec -> spec.path(filename).afterRecipe(doc -> assertThat(doc.getReferences().getReferences()).isEmpty())\n+          )\n+        );\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4677",
    "pr_id": 4677,
    "issue_id": 4676,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Redundant space for DeleteMethodArgument when argumentIndex=0\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\n\r\nBelow case will failed because it will change to `\"public class A {{ B.foo( 1, 2); }}\"` which contains a redundant space before the first argument.\r\n\r\n```java\r\n    @Test\r\n    void deleteFirstArgument() {\r\n        rewriteRun(\r\n          spec -> spec.recipe(new DeleteMethodArgument(\"B foo(int, int, int)\", 0)),\r\n          java(b),\r\n          java(\r\n            \"public class A {{ B.foo(0, 1, 2); }}\",\r\n            \"public class A {{ B.foo(1, 2); }}\"\r\n          )\r\n        );\r\n    }\r\n```\r\n\r\ncorrect answer: `\"public class A {{ B.foo(1, 2); }}\"`, no space before the first `1` element.\r\nactual answer:    `\"public class A {{ B.foo( 1, 2); }}\"` has a redundant space before the first `1` element.\r\n\r\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\n- `main` branch for rewrite.\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\nI am using the `rewrite-maven-plugin` with latest version.\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\n```java\r\n    @Test\r\n    void deleteFirstArgument() {\r\n        rewriteRun(\r\n          spec -> spec.recipe(new DeleteMethodArgument(\"B foo(int, int, int)\", 0)),\r\n          java(b),\r\n          java(\r\n            \"public class A {{ B.foo(0, 1, 2); }}\",\r\n            \"public class A {{ B.foo(1, 2); }}\"\r\n          )\r\n        );\r\n    }\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\n\r\ncorrect answer: `\"public class A {{ B.foo(1, 2); }}\"`, no space before the first `1` element.\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\n\r\n\r\nactual answer:    `\"public class A {{ B.foo( 1, 2); }}\"` has a redundant space before the first `1` element.\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\r\n```\r\n[Unexpected result in \"A.java\":\r\ndiff --git a/A.java b/A.java\r\nindex b7c498e..fda8943 100644\r\n--- a/A.java\r\n+++ b/A.java\r\n@@ -1 +1 @@ \r\n-public class A {{ B.foo(1, 2); }}\r\n\\ No newline at end of file\r\n+public class A {{ B.foo( 1, 2); }}\r\n\\ No newline at end of file\r\n] \r\nexpected: \"public class A {{ B.foo(1, 2); }}\"\r\n but was: \"public class A {{ B.foo( 1, 2); }}\"\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\nSure, will file a PR to fix this.\r\n",
    "issue_word_count": 690,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindPluginsTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/DeleteMethodArgumentTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/DeleteMethodArgument.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindPluginsTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/DeleteMethodArgumentTest.java"
    ],
    "base_commit": "58f15f72924124f961c900ca41589b02b0c5b818",
    "head_commit": "f56de4e3b45c6bdd0adb6eb8c2248243f88ce4aa",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4677",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4677",
    "dockerfile": "",
    "pr_merged_at": "2024-11-15T09:54:50.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/DeleteMethodArgument.java b/rewrite-java/src/main/java/org/openrewrite/java/DeleteMethodArgument.java\nindex 2fd26e66556..c6c4676656d 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/DeleteMethodArgument.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/DeleteMethodArgument.java\n@@ -100,9 +100,11 @@ private MethodCall visitMethodCall(MethodCall methodCall) {\n                                                     .count() >= argumentIndex + 1) {\n                 List<Expression> args = new ArrayList<>(originalArgs);\n \n-                args.remove(argumentIndex);\n+                Expression removed = args.remove(argumentIndex);\n                 if (args.isEmpty()) {\n                     args = singletonList(new J.Empty(randomId(), Space.EMPTY, Markers.EMPTY));\n+                } else if (argumentIndex == 0) {\n+                    args.set(0, args.get(0).withPrefix(removed.getPrefix()));\n                 }\n \n                 m = m.withArguments(args);\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindPluginsTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindPluginsTest.java\nindex ede21f7973d..78cd8c053fc 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindPluginsTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/search/FindPluginsTest.java\n@@ -69,7 +69,8 @@ void findPlugin() {\n     void settingsResolutionStrategy() {\n         rewriteRun(\n           spec -> spec.beforeRecipe(withToolingApi()),\n-          settingsGradle(\"\"\"\n+          settingsGradle(\n+              \"\"\"\n             pluginManagement {\n                 repositories {\n                     mavenLocal()\n@@ -83,7 +84,8 @@ void settingsResolutionStrategy() {\n                     }\n                 }\n             }\n-            \"\"\"),\n+            \"\"\"\n+          ),\n           buildGradle(\n             \"\"\"\n               plugins {\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/DeleteMethodArgumentTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/DeleteMethodArgumentTest.java\nindex 6949a868520..5ad21d41e15 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/DeleteMethodArgumentTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/DeleteMethodArgumentTest.java\n@@ -17,11 +17,14 @@\n \n import org.intellij.lang.annotations.Language;\n import org.junit.jupiter.api.Test;\n+import org.openrewrite.Issue;\n+import org.openrewrite.test.RecipeSpec;\n import org.openrewrite.test.RewriteTest;\n \n import static org.openrewrite.java.Assertions.java;\n \n class DeleteMethodArgumentTest implements RewriteTest {\n+\n     @Language(\"java\")\n     String b = \"\"\"\n       class B {\n@@ -34,11 +37,15 @@ public B(int n) {}\n       }\n       \"\"\";\n \n+    @Override\n+    public void defaults(RecipeSpec spec) {\n+        spec.parser(JavaParser.fromJavaVersion().dependsOn(b));\n+    }\n+\n     @Test\n     void deleteMiddleArgumentDeclarative() {\n         rewriteRun(\n           spec -> spec.recipes(new DeleteMethodArgument(\"B foo(int, int, int)\", 1)),\n-          java(b),\n           java(\n             \"public class A {{ B.foo(0, 1, 2); }}\",\n             \"public class A {{ B.foo(0, 2); }}\"\n@@ -50,7 +57,6 @@ void deleteMiddleArgumentDeclarative() {\n     void deleteMiddleArgument() {\n         rewriteRun(\n           spec -> spec.recipe(new DeleteMethodArgument(\"B foo(int, int, int)\", 1)),\n-          java(b),\n           java(\n             \"public class A {{ B.foo(0, 1, 2); }}\",\n             \"public class A {{ B.foo(0, 2); }}\"\n@@ -65,8 +71,8 @@ void deleteArgumentsConsecutively() {\n             new DeleteMethodArgument(\"B foo(int, int, int)\", 1),\n             new DeleteMethodArgument(\"B foo(int, int)\", 1)\n           ),\n-          java(b),\n-          java(\"public class A {{ B.foo(0, 1, 2); }}\",\n+          java(\n+            \"public class A {{ B.foo(0, 1, 2); }}\",\n             \"public class A {{ B.foo(0); }}\"\n           )\n         );\n@@ -76,7 +82,6 @@ void deleteArgumentsConsecutively() {\n     void doNotDeleteEmptyContainingFormatting() {\n         rewriteRun(\n           spec -> spec.recipe(new DeleteMethodArgument(\"B foo(..)\", 0)),\n-          java(b),\n           java(\"public class A {{ B.foo( ); }}\")\n         );\n     }\n@@ -85,7 +90,6 @@ void doNotDeleteEmptyContainingFormatting() {\n     void insertEmptyWhenLastArgumentIsDeleted() {\n         rewriteRun(\n           spec -> spec.recipe(new DeleteMethodArgument(\"B foo(..)\", 0)),\n-          java(b),\n           java(\n             \"public class A {{ B.foo(1); }}\",\n             \"public class A {{ B.foo(); }}\"\n@@ -97,11 +101,26 @@ void insertEmptyWhenLastArgumentIsDeleted() {\n     void deleteConstructorArgument() {\n         rewriteRun(\n           spec -> spec.recipe(new DeleteMethodArgument(\"B <constructor>(int)\", 0)),\n-          java(b),\n           java(\n             \"public class A { B b = new B(0); }\",\n             \"public class A { B b = new B(); }\"\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4676\")\n+    @Test\n+    void deleteFirstArgument() {\n+        rewriteRun(\n+          spec -> spec.recipe(new DeleteMethodArgument(\"B foo(int, int, int)\", 0)),\n+          java(\n+            \"public class A {{ B.foo(0, 1, 2); }}\",\n+            \"public class A {{ B.foo(1, 2); }}\"\n+          ),\n+          java(\n+            \"public class C {{ B.foo(\\n\\t\\t0, 1, 2); }}\",\n+            \"public class C {{ B.foo(\\n\\t\\t1, 2); }}\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4671",
    "pr_id": 4671,
    "issue_id": 2218,
    "repo": "openrewrite/rewrite",
    "problem_statement": "MergeYamlVisitor - inline comments not taken into account\nHi,\r\n\r\nthe `MergeYamlVisitor` does not take inline comments into account at merging YAMLs. See the test:\r\n\r\n```kotlin\r\n@Test\r\nfun existingEntryBlockWithComment() = assertChanged(\r\n    recipe = MergeYaml(\r\n        \"$\",\r\n        \"\"\"\r\n            spring:\r\n              application:\r\n                description: a description\r\n        \"\"\".trimIndent(),\r\n        false,\r\n        null\r\n    ),\r\n    before = \"\"\"\r\n        spring:\r\n          application:\r\n            name: main #Some comment\r\n    \"\"\",\r\n    after = \"\"\"\r\n        spring:\r\n          application:\r\n            name: main #Some comment\r\n            description: a description\r\n    \"\"\"\r\n)\r\n```\r\n\r\nThe actual result is:\r\n```yaml\r\nspring:\r\n  application:\r\n    name: main\r\n    description: a description #Some comment\r\n```\r\n\r\nThanks and kind regards\r\nThomas",
    "issue_word_count": 74,
    "test_files_count": 1,
    "non_test_files_count": 5,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/Cursor.java",
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java",
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYamlVisitor.java",
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java",
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/tree/Yaml.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "base_commit": "01813e39fdd155a621f3e0113664d4f121a29f16",
    "head_commit": "038b708d813833868d9cdc8ab39b9606597c3cd7",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4671",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4671",
    "dockerfile": "",
    "pr_merged_at": "2024-11-22T09:10:22.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/Cursor.java b/rewrite-core/src/main/java/org/openrewrite/Cursor.java\nindex 3be9d7c15a3..7ed54841f73 100644\n--- a/rewrite-core/src/main/java/org/openrewrite/Cursor.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/Cursor.java\n@@ -57,7 +57,7 @@ public Cursor getRoot() {\n     /**\n      * @return true if this cursor is the root of the tree, false otherwise\n      */\n-    final boolean isRoot() {\n+    final public boolean isRoot() {\n         return ROOT_VALUE.equals(value);\n     }\n \n\ndiff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java\nindex 5361955065f..3b1bf9c1355 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYaml.java\n@@ -84,6 +84,7 @@ public String getDescription() {\n     }\n \n     final static String FOUND_MATCHING_ELEMENT = \"FOUND_MATCHING_ELEMENT\";\n+    final static String REMOVE_PREFIX = \"REMOVE_PREFIX\";\n \n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n@@ -96,7 +97,7 @@ public TreeVisitor<?, ExecutionContext> getVisitor() {\n                     .map(docs -> {\n                         // Any comments will have been put on the parent Document node, preserve by copying to the mapping\n                         Yaml.Document doc = docs.getDocuments().get(0);\n-                        if(doc.getBlock() instanceof Yaml.Mapping) {\n+                        if (doc.getBlock() instanceof Yaml.Mapping) {\n                             Yaml.Mapping m = (Yaml.Mapping) doc.getBlock();\n                             return m.withEntries(ListUtils.mapFirst(m.getEntries(), entry -> entry.withPrefix(doc.getPrefix())));\n                         } else if (doc.getBlock() instanceof Yaml.Sequence) {\n@@ -110,9 +111,11 @@ public TreeVisitor<?, ExecutionContext> getVisitor() {\n             @Override\n             public Yaml.Document visitDocument(Yaml.Document document, ExecutionContext ctx) {\n                 if (\"$\".equals(key)) {\n-                    return document.withBlock((Yaml.Block) new MergeYamlVisitor<>(document.getBlock(), yaml,\n-                            Boolean.TRUE.equals(acceptTheirs), objectIdentifyingProperty).visitNonNull(document.getBlock(),\n-                            ctx, getCursor()));\n+                    Yaml.Document d = document.withBlock((Yaml.Block)\n+                            new MergeYamlVisitor<>(document.getBlock(), yaml, Boolean.TRUE.equals(acceptTheirs), objectIdentifyingProperty)\n+                                    .visitNonNull(document.getBlock(), ctx, getCursor())\n+                    );\n+                    return getCursor().getMessage(REMOVE_PREFIX, false) ? d.withEnd(d.getEnd().withPrefix(\"\")) : d;\n                 }\n                 Yaml.Document d = super.visitDocument(document, ctx);\n                 if (d == document && !getCursor().getMessage(FOUND_MATCHING_ELEMENT, false)) {\n\ndiff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYamlVisitor.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYamlVisitor.java\nindex 66a5f310506..e3d24a32898 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYamlVisitor.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/MergeYamlVisitor.java\n@@ -15,23 +15,47 @@\n  */\n package org.openrewrite.yaml;\n \n-import lombok.AllArgsConstructor;\n import lombok.RequiredArgsConstructor;\n import org.intellij.lang.annotations.Language;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.Cursor;\n import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.style.GeneralFormatStyle;\n import org.openrewrite.yaml.tree.Yaml;\n+import org.openrewrite.yaml.tree.Yaml.Document;\n+import org.openrewrite.yaml.tree.Yaml.Mapping;\n+import org.openrewrite.yaml.tree.Yaml.Mapping.Entry;\n+import org.openrewrite.yaml.tree.Yaml.Scalar;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n import java.util.Optional;\n+import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n-@AllArgsConstructor\n+import static java.lang.System.lineSeparator;\n+import static org.openrewrite.Cursor.ROOT_VALUE;\n+import static org.openrewrite.internal.ListUtils.*;\n+import static org.openrewrite.yaml.MergeYaml.REMOVE_PREFIX;\n+/**\n+ * Visitor class to merge two yaml files.\n+ *\n+ * @implNote Loops recursively through the documents, for every part a new MergeYamlVisitor instance will be created.\n+ * As inline comments are put on the prefix of the next element (which can be an item very much higher in the tree),\n+ * the following solutions are chosen to merge the comments as well:\n+ * <ul>\n+ * <li>when an element has new items, the comment of the next element is copied to the previous element\n+ * <li>the original comment will be removed (either by traversing the children or by using cursor messages)\n+ *\n+ * @param <P> An input object that is passed to every visit method.\n+ */\n @RequiredArgsConstructor\n public class MergeYamlVisitor<P> extends YamlVisitor<P> {\n-    private final Yaml scope;\n+\n+    private static final Pattern LINE_BREAK = Pattern.compile(\"\\\\R\");\n+\n+    private final Yaml existing;\n     private final Yaml incoming;\n     private final boolean acceptTheirs;\n \n@@ -40,6 +64,24 @@ public class MergeYamlVisitor<P> extends YamlVisitor<P> {\n \n     private boolean shouldAutoFormat = true;\n \n+    public MergeYamlVisitor(Yaml.Block block, Yaml incoming, boolean acceptTheirs, @Nullable String objectIdentifyingProperty, boolean shouldAutoFormat) {\n+        this(block, incoming, acceptTheirs, objectIdentifyingProperty);\n+        this.shouldAutoFormat = shouldAutoFormat;\n+    }\n+\n+    @Nullable\n+    private String linebreak = null;\n+\n+    private String linebreak() {\n+        if (linebreak == null) {\n+            linebreak = Optional.ofNullable(getCursor().firstEnclosing(Yaml.Documents.class))\n+                    .map(docs -> docs.getStyle(GeneralFormatStyle.class))\n+                    .map(format -> format.isUseCRLFNewLines() ? \"\\r\\n\" : \"\\n\")\n+                    .orElse(\"\\n\");\n+        }\n+        return linebreak;\n+    }\n+\n     public MergeYamlVisitor(Yaml scope, @Language(\"yml\") String yamlString, boolean acceptTheirs, @Nullable String objectIdentifyingProperty) {\n         this(scope,\n                 new YamlParser().parse(yamlString)\n@@ -47,8 +89,8 @@ public MergeYamlVisitor(Yaml scope, @Language(\"yml\") String yamlString, boolean\n                         .map(Yaml.Documents.class::cast)\n                         .map(docs -> {\n                             // Any comments will have been put on the parent Document node, preserve by copying to the mapping\n-                            Yaml.Document doc = docs.getDocuments().get(0);\n-                            if(doc.getBlock() instanceof Yaml.Mapping) {\n+                            Document doc = docs.getDocuments().get(0);\n+                            if (doc.getBlock() instanceof Yaml.Mapping) {\n                                 Yaml.Mapping m = (Yaml.Mapping) doc.getBlock();\n                                 return m.withEntries(ListUtils.mapFirst(m.getEntries(), entry -> entry.withPrefix(doc.getPrefix())));\n                             } else if (doc.getBlock() instanceof Yaml.Sequence) {\n@@ -64,7 +106,7 @@ public MergeYamlVisitor(Yaml scope, @Language(\"yml\") String yamlString, boolean\n \n     @Override\n     public Yaml visitScalar(Yaml.Scalar existingScalar, P p) {\n-        if (scope.isScope(existingScalar) && incoming instanceof Yaml.Scalar) {\n+        if (existing.isScope(existingScalar) && incoming instanceof Yaml.Scalar) {\n             return mergeScalar(existingScalar, (Yaml.Scalar) incoming);\n         }\n         return super.visitScalar(existingScalar, p);\n@@ -72,15 +114,15 @@ public Yaml visitScalar(Yaml.Scalar existingScalar, P p) {\n \n     @Override\n     public Yaml visitSequence(Yaml.Sequence existingSeq, P p) {\n-        if (scope.isScope(existingSeq)) {\n+        if (existing.isScope(existingSeq)) {\n             if (incoming instanceof Yaml.Mapping) {\n                 // Distribute the incoming mapping to each entry in the sequence\n-                return existingSeq.withEntries(ListUtils.map(existingSeq.getEntries(), (i, existingSeqEntry) -> {\n-                    Yaml.Block b = (Yaml.Block) new MergeYamlVisitor<>(existingSeqEntry.getBlock(), incoming,\n-                            acceptTheirs, objectIdentifyingProperty, shouldAutoFormat)\n-                            .visitNonNull(existingSeqEntry.getBlock(), p, new Cursor(getCursor(), existingSeqEntry));\n-                    return existingSeqEntry.withBlock(b);\n-                }));\n+                return existingSeq.withEntries(map(existingSeq.getEntries(), (i, existingSeqEntry) ->\n+                        existingSeqEntry.withBlock((Yaml.Block)\n+                                new MergeYamlVisitor<>(existingSeqEntry.getBlock(), incoming, acceptTheirs, objectIdentifyingProperty, shouldAutoFormat)\n+                                        .visitNonNull(existingSeqEntry.getBlock(), p, new Cursor(getCursor(), existingSeqEntry))\n+                        )\n+                ));\n             } else if (incoming instanceof Yaml.Sequence) {\n                 return mergeSequence(existingSeq, (Yaml.Sequence) incoming, p, getCursor());\n             }\n@@ -90,14 +132,21 @@ public Yaml visitSequence(Yaml.Sequence existingSeq, P p) {\n \n     @Override\n     public Yaml visitMapping(Yaml.Mapping existingMapping, P p) {\n-        if (scope.isScope(existingMapping) && incoming instanceof Yaml.Mapping) {\n-            return mergeMapping(existingMapping, (Yaml.Mapping) incoming, p, getCursor());\n+        if (existing.isScope(existingMapping) && incoming instanceof Yaml.Mapping) {\n+            Yaml.Mapping mapping = mergeMapping(existingMapping, (Yaml.Mapping) incoming, p, getCursor());\n+\n+            if (getCursor().getMessage(REMOVE_PREFIX, false)) {\n+                List<Yaml.Mapping.Entry> entries = ((Yaml.Mapping) getCursor().getValue()).getEntries();\n+                return mapping.withEntries(mapLast(mapping.getEntries(), it -> it.withPrefix(linebreak() + grabAfterFirstLineBreak(entries.get(entries.size() - 1)))));\n+            }\n+\n+            return mapping;\n         }\n         return super.visitMapping(existingMapping, p);\n     }\n \n-    private static boolean keyMatches(Yaml.Mapping.Entry e1, Yaml.Mapping.Entry e2) {\n-        return e1.getKey().getValue().equals(e2.getKey().getValue());\n+    private static boolean keyMatches(Yaml.Mapping.@Nullable Entry e1, Yaml.Mapping.@Nullable Entry e2) {\n+        return e1 != null && e2 != null && e1.getKey().getValue().equals(e2.getKey().getValue());\n     }\n \n     private boolean keyMatches(Yaml.Mapping m1, Yaml.Mapping m2) {\n@@ -113,33 +162,92 @@ private boolean keyMatches(Yaml.Mapping m1, Yaml.Mapping m2) {\n                 .orElse(false);\n     }\n \n-    private Yaml.Mapping mergeMapping(Yaml.Mapping m1, Yaml.Mapping m2, P p, Cursor cursor) {\n-        List<Yaml.Mapping.Entry> mutatedEntries = ListUtils.map(m1.getEntries(), existingEntry -> {\n-            for (Yaml.Mapping.Entry incomingEntry : m2.getEntries()) {\n+    private Mapping mergeMapping(Yaml.Mapping m1, Yaml.Mapping m2, P p, Cursor cursor) {\n+        List<Yaml.Mapping.Entry> mergedEntries = map(m1.getEntries(), existingEntry -> {\n+            for (Entry incomingEntry : m2.getEntries()) {\n                 if (keyMatches(existingEntry, incomingEntry)) {\n-                    return existingEntry.withValue((Yaml.Block) new MergeYamlVisitor<>(existingEntry.getValue(),\n-                            incomingEntry.getValue(), acceptTheirs, objectIdentifyingProperty, shouldAutoFormat)\n-                            .visitNonNull(existingEntry.getValue(), p, new Cursor(cursor, existingEntry)));\n+                    return existingEntry.withValue((Yaml.Block)\n+                            new MergeYamlVisitor<>(existingEntry.getValue(), incomingEntry.getValue(), acceptTheirs, objectIdentifyingProperty, shouldAutoFormat)\n+                                    .visitNonNull(existingEntry.getValue(), p, new Cursor(cursor, existingEntry)));\n                 }\n             }\n             return existingEntry;\n         });\n \n-        mutatedEntries = ListUtils.concatAll(mutatedEntries, ListUtils.map(m2.getEntries(), incomingEntry -> {\n-            for (Yaml.Mapping.Entry existingEntry : m1.getEntries()) {\n-                if (keyMatches(existingEntry, incomingEntry)) {\n+        List<Entry> mutatedEntries = concatAll(mergedEntries, map(m2.getEntries(), it -> {\n+            for (Entry existingEntry : m1.getEntries()) {\n+                if (keyMatches(existingEntry, it)) {\n                     return null;\n                 }\n             }\n-            if (shouldAutoFormat) {\n-                incomingEntry = autoFormat(incomingEntry, p, cursor);\n+            // workaround: autoFormat cannot handle new inserted values very well\n+            if (!mergedEntries.isEmpty() && it.getValue() instanceof Yaml.Scalar && hasLineBreak(mergedEntries.get(0), 2)) {\n+                return it.withPrefix(linebreak() + grabAfterFirstLineBreak(mergedEntries.get(0)));\n             }\n-            return incomingEntry;\n+            return shouldAutoFormat ? autoFormat(it, p, cursor) : it;\n         }));\n \n+        if (m1.getEntries().size() < mutatedEntries.size() && !getCursor().isRoot()) {\n+            Cursor c = getCursor().dropParentUntil(it -> {\n+                if (ROOT_VALUE.equals(it) || it instanceof Document) {\n+                    return true;\n+                }\n+\n+                if (it instanceof Yaml.Mapping) {\n+                    List<Yaml.Mapping.Entry> entries = ((Yaml.Mapping) it).getEntries();\n+                    // last member should search further upwards until two entries are found\n+                    if (entries.get(entries.size() - 1).equals(getCursor().getParentOrThrow().getValue())) {\n+                        return false;\n+                    }\n+                    return entries.size() > 1;\n+                }\n+\n+                return false;\n+            });\n+\n+            if (c.getValue() instanceof Document || c.getValue() instanceof Yaml.Mapping) {\n+                String comment = null;\n+\n+                if (c.getValue() instanceof Document) {\n+                    comment = ((Document) c.getValue()).getEnd().getPrefix();\n+                } else {\n+                    List<Yaml.Mapping.Entry> entries = ((Yaml.Mapping) c.getValue()).getEntries();\n+\n+                    // get comment from next element in same mapping block\n+                    for (int i = 0; i < entries.size() - 1; i++) {\n+                        if (entries.get(i).getValue().equals(getCursor().getValue())) {\n+                            comment = grabBeforeFirstLineBreak(entries.get(i + 1));\n+                            break;\n+                        }\n+                    }\n+                    // or retrieve it for last item from next element (could potentially be much higher in the tree)\n+                    if (comment == null && hasLineBreak(entries.get(entries.size() - 1), 1)) {\n+                        comment = grabBeforeFirstLineBreak(entries.get(entries.size() - 1));\n+                    }\n+                }\n+\n+                if (comment != null) {\n+                    Yaml.Mapping.Entry last = mutatedEntries.get(mutatedEntries.size() - 1);\n+                    mutatedEntries.set(mutatedEntries.size() - 1, last.withPrefix(comment + last.getPrefix()));\n+                    c.putMessage(REMOVE_PREFIX, true);\n+                }\n+            }\n+        }\n+\n+        removePrefixForDirectChildren(m1.getEntries(), mutatedEntries);\n+\n         return m1.withEntries(mutatedEntries);\n     }\n \n+    private void removePrefixForDirectChildren(List<Yaml.Mapping.Entry> m1Entries, List<Yaml.Mapping.Entry> mutatedEntries) {\n+        for (int i = 0; i < m1Entries.size() - 1; i++) {\n+            if (m1Entries.get(i).getValue() instanceof Yaml.Mapping && mutatedEntries.get(i).getValue() instanceof Yaml.Mapping &&\n+                    ((Yaml.Mapping) m1Entries.get(i).getValue()).getEntries().size() < ((Yaml.Mapping) mutatedEntries.get(i).getValue()).getEntries().size()) {\n+                mutatedEntries.set(i + 1, mutatedEntries.get(i + 1).withPrefix(linebreak() + grabAfterFirstLineBreak(mutatedEntries.get(i + 1))));\n+            }\n+        }\n+    }\n+\n     private Yaml.Sequence mergeSequence(Yaml.Sequence s1, Yaml.Sequence s2, P p, Cursor cursor) {\n         if (acceptTheirs) {\n             return s1;\n@@ -163,22 +271,20 @@ private Yaml.Sequence mergeSequence(Yaml.Sequence s1, Yaml.Sequence s2, P p, Cur\n                 }\n             }\n \n-            return s1.withEntries(ListUtils.concatAll(s1.getEntries(),\n-                    ListUtils.map(incomingEntries, incomingEntry -> autoFormat(incomingEntry, p, cursor))));\n+            return s1.withEntries(concatAll(s1.getEntries(), map(incomingEntries, it -> autoFormat(it, p, cursor))));\n         } else {\n             if (objectIdentifyingProperty == null) {\n                 // No identifier set to match entries on, so cannot continue\n                 return s1;\n             } else {\n-                List<Yaml.Sequence.Entry> mutatedEntries = ListUtils.map(s2.getEntries(), entry -> {\n+                List<Yaml.Sequence.Entry> mutatedEntries = map(s2.getEntries(), entry -> {\n                     Yaml.Mapping incomingMapping = (Yaml.Mapping) entry.getBlock();\n                     for (Yaml.Sequence.Entry existingEntry : s1.getEntries()) {\n                         Yaml.Mapping existingMapping = (Yaml.Mapping) existingEntry.getBlock();\n                         if (keyMatches(existingMapping, incomingMapping)) {\n                             Yaml.Sequence.Entry e1 = existingEntry.withBlock(mergeMapping(existingMapping, incomingMapping, p, cursor));\n-                            if(e1 == existingEntry) {\n+                            if (e1 == existingEntry) {\n                                 // Made no change, no need to consider the entry \"mutated\"\n-                                //noinspection DataFlowIssue\n                                 return null;\n                             }\n                             return e1;\n@@ -190,10 +296,9 @@ private Yaml.Sequence mergeSequence(Yaml.Sequence s1, Yaml.Sequence s2, P p, Cur\n                     return s1;\n                 }\n \n-                List<Yaml.Sequence.Entry> entries = ListUtils.concatAll(\n-                        s1.getEntries().stream().filter(entry -> !mutatedEntries.contains(entry))\n-                                .collect(Collectors.toList()),\n-                        ListUtils.map(mutatedEntries, entry -> autoFormat(entry, p, cursor)));\n+                List<Yaml.Sequence.Entry> entries = concatAll(\n+                        s1.getEntries().stream().filter(entry -> !mutatedEntries.contains(entry)).collect(Collectors.toList()),\n+                        map(mutatedEntries, entry -> autoFormat(entry, p, cursor)));\n \n                 if (entries.size() != s1.getEntries().size()) {\n                     return s1.withEntries(entries);\n@@ -208,7 +313,21 @@ private Yaml.Sequence mergeSequence(Yaml.Sequence s1, Yaml.Sequence s2, P p, Cur\n         }\n     }\n \n-    private Yaml.Scalar mergeScalar(Yaml.Scalar y1, Yaml.Scalar y2) {\n+    private boolean hasLineBreak(Yaml.Mapping.Entry entry, int atLeastParts) {\n+        return LINE_BREAK.matcher(entry.getPrefix()).find() && LINE_BREAK.split(entry.getPrefix()).length >= atLeastParts;\n+    }\n+\n+    private String grabBeforeFirstLineBreak(Yaml.Mapping.Entry entry) {\n+        String[] parts = LINE_BREAK.split(entry.getPrefix());\n+        return parts.length > 0 ? parts[0] : \"\";\n+    }\n+\n+    private String grabAfterFirstLineBreak(Yaml.Mapping.Entry entry) {\n+        String[] parts = LINE_BREAK.split(entry.getPrefix());\n+        return parts.length > 1 ? String.join(linebreak(), Arrays.copyOfRange(parts, 1, parts.length)) : \"\";\n+    }\n+\n+    private Scalar mergeScalar(Yaml.Scalar y1, Yaml.Scalar y2) {\n         String s1 = y1.getValue();\n         String s2 = y2.getValue();\n         return !s1.equals(s2) && !acceptTheirs ? y1.withValue(s2) : y1;\n\ndiff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\nindex 047c91789a8..ca7685f37ba 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n@@ -82,8 +82,9 @@ public Stream<SourceFile> parseInputs(Iterable<Input> sourceFiles, @Nullable Pat\n                         Yaml.Documents docs = (Yaml.Documents) sourceFile;\n                         // ensure there is always at least one Document, even in an empty yaml file\n                         if (docs.getDocuments().isEmpty()) {\n-                            return docs.withDocuments(singletonList(new Yaml.Document(randomId(), \"\", Markers.EMPTY,\n-                                    false, new Yaml.Mapping(randomId(), Markers.EMPTY, null, emptyList(), null, null), null)));\n+                            Yaml.Document.End end = new Yaml.Document.End(randomId(), \"\", Markers.EMPTY, false);\n+                            Yaml.Mapping mapping = new Yaml.Mapping(randomId(), Markers.EMPTY, null, emptyList(), null, null);\n+                            return docs.withDocuments(singletonList(new Yaml.Document(randomId(), \"\", Markers.EMPTY, false, mapping, end)));\n                         }\n                         return docs;\n                     }\n@@ -157,7 +158,7 @@ private Yaml.Documents parseFromInput(Path sourceFile, EncodingDetectingInputStr\n                                 Markers.EMPTY,\n                                 ((DocumentStartEvent) event).getExplicit(),\n                                 new Yaml.Mapping(randomId(), Markers.EMPTY, null, emptyList(), null, null),\n-                                null\n+                                new Yaml.Document.End(randomId(), \"\", Markers.EMPTY, false)\n                         );\n                         lastEnd = event.getEndMark().getIndex();\n                         break;\n\ndiff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/tree/Yaml.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/tree/Yaml.java\nindex a92c0370e54..5245d9ab397 100755\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/tree/Yaml.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/tree/Yaml.java\n@@ -153,7 +153,7 @@ public Document copyPaste() {\n                     Markers.EMPTY,\n                     explicit,\n                     block.copyPaste(),\n-                    end == null ? null : end.copyPaste()\n+                    end.copyPaste()\n             );\n         }\n \n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\nindex fd8bba68811..0e6caad72d6 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n@@ -1010,6 +1010,205 @@ void mergeSequenceMapChangeComplexMapping() {\n         );\n     }\n \n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/2218\")\n+    @Test\n+    void existingEntryBlockWithCommentAtFirstLine() {\n+        rewriteRun(\n+          spec -> spec.recipe(new MergeYaml(\n+            \"$\",\n+            //language=yaml\n+            \"\"\"\n+              A:\n+                B:\n+                  C:\n+                    D:\n+                      4: new desc\n+                    D2:\n+                      2: new description\n+                    D3:\n+                      2: new text\n+                      3: more new text\n+                  E: description\n+              \"\"\",\n+            false,\n+            null,\n+            null\n+          )),\n+          yaml(\n+            \"\"\"\n+              A: # Comment untouched\n+                B:\n+                  C:\n+                    D:\n+                      1: something else\n+                      2: something else\n+                      3: old desc\n+                    D2:\n+                      1: old description\n+                    D3:\n+                      1: old text\n+              \"\"\",\n+            \"\"\"\n+              A: # Comment untouched\n+                B:\n+                  C:\n+                    D:\n+                      1: something else\n+                      2: something else\n+                      3: old desc\n+                      4: new desc\n+                    D2:\n+                      1: old description\n+                      2: new description\n+                    D3:\n+                      1: old text\n+                      2: new text\n+                      3: more new text\n+                  E: description\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/2218\")\n+    @Test\n+    void existingEntryBlockWithCommentAtLastLine() {\n+        rewriteRun(\n+          spec -> spec.recipe(new MergeYaml(\n+            \"$\",\n+            //language=yaml\n+            \"\"\"\n+              spring:\n+                application:\n+                  description: a description\n+              \"\"\",\n+            false,\n+            null,\n+            null\n+          )),\n+          yaml(\n+            \"\"\"\n+              spring:\n+                application:\n+                  name: main # Comment moved from root to previous element\n+              \"\"\",\n+            \"\"\"\n+              spring:\n+                application:\n+                  name: main # Comment moved from root to previous element\n+                  description: a description\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/2218\")\n+    @Test\n+    void existingEntryBlockWithCommentsAllOverThePlace() {\n+        rewriteRun(\n+          spec -> spec.recipe(new MergeYaml(\n+            \"$\",\n+            //language=yaml\n+            \"\"\"\n+              A:\n+                B:\n+                  C:\n+                    D:\n+                      3: new desc\n+                    D2:\n+                      4: d\n+                    D3:\n+                      2: new description\n+                    D4:\n+                      2: new text\n+              \"\"\",\n+            false,\n+            null,\n+            null\n+          )),\n+          yaml(\n+            \"\"\"\n+              A: # Comment untouched 1\n+                B: # Comment untouched 2\n+                  C: # Comment untouched 3\n+                    D: # Comment untouched 4\n+                      1: something else\n+                      2: old desc # Comment moved from prefix D2 to prefix D->3\n+                                  # This is also part of prefix D2, but should NOT be moved to D->3\n+                    D2:\n+                      1: a\n+                      # Comment above tag untouched 1\n+                      2: b                             # Comment with a lot of spaces untouched 5\n+                      3: c\n+                    # Comment above tag untouched 2\n+              # with multilines\n+                    D3: # Comment untouched 6\n+                      1: old description                           # Comment with a lot of spaces moved from prefix D4 to prefix D3->2\n+                    D4: # Comment untouched 7\n+                      1: old text # Comment moved from end document to prefix D4->2\n+              \"\"\",\n+            \"\"\"\n+              A: # Comment untouched 1\n+                B: # Comment untouched 2\n+                  C: # Comment untouched 3\n+                    D: # Comment untouched 4\n+                      1: something else\n+                      2: old desc # Comment moved from prefix D2 to prefix D->3\n+                      3: new desc\n+                                  # This is also part of prefix D2, but should NOT be moved to D->3\n+                    D2:\n+                      1: a\n+                      # Comment above tag untouched 1\n+                      2: b                             # Comment with a lot of spaces untouched 5\n+                      3: c\n+                      4: d\n+                    # Comment above tag untouched 2\n+              # with multilines\n+                    D3: # Comment untouched 6\n+                      1: old description                           # Comment with a lot of spaces moved from prefix D4 to prefix D3->2\n+                      2: new description\n+                    D4: # Comment untouched 7\n+                      1: old text # Comment moved from end document to prefix D4->2\n+                      2: new text\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/2218\")\n+    @Test\n+    void existingEntryBlockWithCommentNotAtLastLine() {\n+        rewriteRun(\n+          spec -> spec.recipe(new MergeYaml(\n+            \"$\",\n+            //language=yaml\n+            \"\"\"\n+              spring:\n+                application:\n+                  description: a description\n+              \"\"\",\n+            false,\n+            null,\n+            null\n+          )),\n+          yaml(\n+            \"\"\"\n+              spring:\n+                application:\n+                  name: main # Some comment\n+                  name2: main\n+              \"\"\",\n+            \"\"\"\n+              spring:\n+                application:\n+                  name: main # Some comment\n+                  name2: main\n+                  description: a description\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void mergeScalar() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4667",
    "pr_id": 4667,
    "issue_id": 4157,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Allow `AddOrUpdateAnnotationAttribute` to add values to an array\n## What problem are you trying to solve?\r\n`AddOrUpdateAnnotationAttribute` can not currently add values to an array. When you try that you get\r\n```\r\nClassCastException: class org.openrewrite.java.tree.J$NewArray cannot be cast to class org.openrewrite.java.tree.J$Literal\r\n```\r\n\r\n## Describe the solution you'd like\r\nTo be able to add a value as seen here\r\n\r\n**Before**\r\n```java\r\n@SpringBootApplication(scanBasePackages = {\"com.abc\"})\r\n```\r\n**After**\r\n```java\r\n@SpringBootApplication(scanBasePackages = {\"com.abc\", \"com.xyz\"})\r\n```\r\n\r\n## Have you considered any alternatives or workarounds?\r\nWe could create a new recipe, or explicitly not allow this.\r\nNot clear yet if we should append to existing array, or overwrite existing value.",
    "issue_word_count": 111,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java",
      "rewrite-java/src/main/java/org/openrewrite/java/recipes/MissingOptionExample.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java"
    ],
    "base_commit": "f2b923248e2692a3d35bdff15285be256cfd69b6",
    "head_commit": "0d411e1f2fda13ad93279900143cf18087cdc907",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4667",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4667",
    "dockerfile": "",
    "pr_merged_at": "2024-11-19T13:54:54.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java b/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java\nindex 39c40e48843..be098009e16 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/AddOrUpdateAnnotationAttribute.java\n@@ -17,22 +17,24 @@\n \n import lombok.EqualsAndHashCode;\n import lombok.Value;\n+import lombok.With;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.java.search.UsesType;\n-import org.openrewrite.java.tree.Expression;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.JavaType;\n-import org.openrewrite.java.tree.TypeUtils;\n+import org.openrewrite.java.tree.*;\n+import org.openrewrite.marker.Marker;\n import org.openrewrite.marker.Markers;\n \n import java.util.Arrays;\n import java.util.List;\n import java.util.Objects;\n+import java.util.UUID;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.stream.Collectors;\n \n+import static org.openrewrite.Tree.randomId;\n+\n @Value\n @EqualsAndHashCode(callSuper = false)\n public class AddOrUpdateAnnotationAttribute extends Recipe {\n@@ -70,6 +72,14 @@ public String getDescription() {\n     @Nullable\n     Boolean addOnly;\n \n+    @Option(displayName = \"Append array\",\n+            description = \"If the attribute is an array, setting this option to `true` will append the value(s). \" +\n+                          \"In conjunction with `addOnly`, it is possible to control duplicates: \" +\n+                          \"`addOnly=true`, always append. \" +\n+                          \"`addOnly=false`, only append if the value is not already present.\")\n+    @Nullable\n+    Boolean appendArray;\n+\n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n         return Preconditions.check(new UsesType<>(annotationType, false), new JavaIsoVisitor<ExecutionContext>() {\n@@ -123,10 +133,28 @@ public J.Annotation visitAnnotation(J.Annotation a, ExecutionContext ctx) {\n                                 return null;\n                             }\n \n-                            if (as.getAssignment() instanceof J.NewArray){\n+                            if (as.getAssignment() instanceof J.NewArray) {\n                                 List<Expression> jLiteralList = ((J.NewArray) as.getAssignment()).getInitializer();\n                                 String attributeValueCleanedUp = attributeValue.replaceAll(\"\\\\s+\",\"\").replaceAll(\"[\\\\s+{}\\\"]\",\"\");\n                                 List<String> attributeList = Arrays.asList(attributeValueCleanedUp.contains(\",\") ? attributeValueCleanedUp.split(\",\") : new String[]{attributeValueCleanedUp});\n+\n+                                if (as.getMarkers().findFirst(AlreadyAppended.class).filter(ap -> ap.getValues().equals(newAttributeValue)).isPresent()) {\n+                                    return as;\n+                                }\n+\n+                                if (Boolean.TRUE.equals(appendArray)) {\n+                                    boolean changed = false;\n+                                    for (String attrListValues : attributeList) {\n+                                        String newAttributeListValue = maybeQuoteStringArgument(attributeName, attrListValues, finalA);\n+                                        if (Boolean.FALSE.equals(addOnly) && attributeValIsAlreadyPresent(jLiteralList, newAttributeListValue)) {\n+                                            continue;\n+                                        }\n+                                        changed = true;\n+                                        jLiteralList.add(new J.Literal(randomId(), Space.EMPTY, Markers.EMPTY, newAttributeListValue, newAttributeListValue, null, JavaType.Primitive.String));\n+                                    }\n+                                    return changed ? as.withAssignment(((J.NewArray) as.getAssignment()).withInitializer(jLiteralList))\n+                                            .withMarkers(as.getMarkers().add(new AlreadyAppended(randomId(), newAttributeValue))) : as;\n+                                }\n                                 int m = 0;\n                                 for (int i = 0; i< Objects.requireNonNull(jLiteralList).size(); i++){\n                                     if (i >= attributeList.size()){\n@@ -152,7 +180,7 @@ public J.Annotation visitAnnotation(J.Annotation a, ExecutionContext ctx) {\n                                     }\n                                     for (int j = m; j < attributeList.size(); j++){\n                                         String newAttributeListValue = maybeQuoteStringArgument(attributeName, attributeList.get(j), finalA);\n-                                        jLiteralList.add(j, new J.Literal(Tree.randomId(), jLiteralList.get(j-1).getPrefix(), Markers.EMPTY, newAttributeListValue, newAttributeListValue, null, JavaType.Primitive.String));\n+                                        jLiteralList.add(j, new J.Literal(randomId(), jLiteralList.get(j - 1).getPrefix(), Markers.EMPTY, newAttributeListValue, newAttributeListValue, null, JavaType.Primitive.String));\n                                     }\n                                 }\n \n@@ -255,4 +283,23 @@ private static boolean attributeIsString(@Nullable String attributeName, J.Annot\n         }\n         return false;\n     }\n+\n+    private static boolean attributeValIsAlreadyPresent(List<Expression> expression, @Nullable String attributeValue) {\n+        for (Expression e : expression) {\n+            if (e instanceof J.Literal) {\n+                J.Literal literal = (J.Literal) e;\n+                if (literal.getValueSource() != null && literal.getValueSource().equals(attributeValue)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Value\n+    @With\n+    private static class AlreadyAppended implements Marker {\n+        UUID id;\n+        String values;\n+    }\n }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/recipes/MissingOptionExample.java b/rewrite-java/src/main/java/org/openrewrite/java/recipes/MissingOptionExample.java\nindex 51d668ac0d2..847f84fdc87 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/recipes/MissingOptionExample.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/recipes/MissingOptionExample.java\n@@ -80,7 +80,7 @@ public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ct\n                             }\n                         }\n \n-                        AddOrUpdateAnnotationAttribute addOrUpdateAnnotationAttribute = new AddOrUpdateAnnotationAttribute(ORG_OPENREWRITE_OPTION, \"example\", \"TODO Provide a usage example for the docs\", true);\n+                        AddOrUpdateAnnotationAttribute addOrUpdateAnnotationAttribute = new AddOrUpdateAnnotationAttribute(ORG_OPENREWRITE_OPTION, \"example\", \"TODO Provide a usage example for the docs\", true, false);\n                         return (J.Annotation) addOrUpdateAnnotationAttribute.getVisitor().visitNonNull(an, ctx, getCursor().getParent());\n                     }\n                 });\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java\nindex fe45a9774b6..ac1b1bc8117 100755\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/AddOrUpdateAnnotationAttributeTest.java\n@@ -25,7 +25,7 @@ class AddOrUpdateAnnotationAttributeTest implements RewriteTest {\n     @Test\n     void addValueAttribute() {\n         rewriteRun(\n-          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, \"hello\", null)),\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, \"hello\", null, null)),\n           java(\n             \"\"\"\n               package org.example;\n@@ -56,7 +56,7 @@ public class A {\n     @Test\n     void addValueAttributeClass() {\n         rewriteRun(\n-          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, \"Integer.class\", null)),\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, \"Integer.class\", null, null)),\n           java(\n             \"\"\"\n               package org.example;\n@@ -87,7 +87,7 @@ public class A {\n     @Test\n     void addValueAttributeFullyQualifiedClass() {\n         rewriteRun(\n-          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, \"java.math.BigDecimal.class\", null)),\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, \"java.math.BigDecimal.class\", null, null)),\n           java(\n             \"\"\"\n               package org.example;\n@@ -118,7 +118,7 @@ public class A {\n     @Test\n     void updateValueAttribute() {\n         rewriteRun(\n-          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, \"hello\", null)),\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, \"hello\", null, null)),\n           java(\n             \"\"\"\n               package org.example;\n@@ -150,7 +150,7 @@ public class A {\n     @Test\n     void updateValueAttributeClass() {\n         rewriteRun(\n-          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, \"Integer.class\", null)),\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, \"Integer.class\", null, null)),\n           java(\n             \"\"\"\n               package org.example;\n@@ -182,7 +182,7 @@ public class A {\n     @Test\n     void removeValueAttribute() {\n         rewriteRun(\n-          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, null, null)),\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, null, null, null)),\n           java(\n             \"\"\"\n               package org.example;\n@@ -214,7 +214,7 @@ public class A {\n     @Test\n     void removeValueAttributeClass() {\n         rewriteRun(\n-          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, null, null)),\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.example.Foo\", null, null, null, null)),\n           java(\n             \"\"\"\n               package org.example;\n@@ -245,7 +245,7 @@ public class A {\n \n     @Test\n     void addNamedAttribute() {\n-        rewriteRun(spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"timeout\", \"500\", null)),\n+        rewriteRun(spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"timeout\", \"500\", null, null)),\n           java(\n             \"\"\"\n               package org.junit;\n@@ -282,7 +282,7 @@ void foo() {\n     @Test\n     void replaceAttribute() {\n         rewriteRun(\n-          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"timeout\", \"500\", null)),\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"timeout\", \"500\", null, null)),\n           java(\n             \"\"\"\n               package org.junit;\n@@ -319,7 +319,7 @@ void foo() {\n     @Test\n     void removeAttribute() {\n         rewriteRun(\n-          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"timeout\", null, null)),\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"timeout\", null, null, null)),\n           java(\n             \"\"\"\n               package org.junit;\n@@ -356,7 +356,7 @@ void foo() {\n     @Test\n     void preserveExistingAttributes() {\n         rewriteRun(\n-          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"timeout\", \"500\", null)),\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"timeout\", \"500\", null, null)),\n           java(\n             \"\"\"\n               package org.junit;\n@@ -394,7 +394,7 @@ void foo() {\n \n     @Test\n     void implicitValueToExplicitValue() {\n-        rewriteRun(spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"other\", \"1\", null)),\n+        rewriteRun(spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"other\", \"1\", null, null)),\n           java(\n             \"\"\"\n               package org.junit;\n@@ -431,7 +431,7 @@ void foo() {\n \n     @Test\n     void implicitValueToExplicitValueClass() {\n-        rewriteRun(spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"other\", \"1\", null)),\n+        rewriteRun(spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"other\", \"1\", null, null)),\n           java(\n             \"\"\"\n               package org.junit;\n@@ -469,7 +469,7 @@ void foo() {\n     @Test\n     void dontChangeWhenSetToAddOnly() {\n         rewriteRun(\n-          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"other\", \"1\", true)),\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\"org.junit.Test\", \"other\", \"1\", true, false)),\n           java(\n             \"\"\"\n               package org.junit;\n@@ -500,6 +500,7 @@ void arrayInAnnotationAttribute() {\n             \"org.example.Foo\",\n             \"array\",\n             \"newTest\",\n+            false,\n             false)),\n           java(\n             \"\"\"\n@@ -535,6 +536,7 @@ void arrayInputMoreThanOneInAnnotationAttribute() {\n             \"org.example.Foo\",\n             \"array\",\n             \"newTest1,newTest2\",\n+            false,\n             false)),\n           java(\n             \"\"\"\n@@ -570,6 +572,7 @@ void addArrayInputInAnnotationAttribute() {\n             \"org.example.Foo\",\n             \"array\",\n             \"newTest1,newTest2\",\n+            false,\n             false)),\n           java(\n             \"\"\"\n@@ -598,6 +601,42 @@ public class A {\n         );\n     }\n \n+    @Test\n+    void addArrayInputInAnnotationAttributeWithAppendTrue() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\n+            \"org.example.Foo\",\n+            \"array\",\n+            \"newTest1,newTest2\",\n+            false,\n+            true)),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              public @interface Foo {\n+                  String[] array() default {};\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import org.example.Foo;\n+              \n+              @Foo\n+              public class A {\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import org.example.Foo;\n+              \n+              @Foo(array = {\"newTest1\", \"newTest2\"})\n+              public class A {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void addArrayInputInAnnotationAttributeEmptyBraces() {\n         rewriteRun(\n@@ -605,7 +644,8 @@ void addArrayInputInAnnotationAttributeEmptyBraces() {\n             \"org.example.Foo\",\n             \"array\",\n             \"newTest1,newTest2\",\n-            false)),\n+            false,\n+            null)),\n           java(\n             \"\"\"\n               package org.example;\n@@ -640,7 +680,8 @@ void removeArrayInputInAnnotationAttribute() {\n             \"org.example.Foo\",\n             \"array\",\n             null,\n-            null)),\n+            null,\n+            false)),\n           java(\n             \"\"\"\n               package org.example;\n@@ -675,7 +716,8 @@ void addOtherAttributeInArrayAnnotation() {\n             \"org.example.Foo\",\n             \"string\",\n             \"test\",\n-            null)),\n+            null,\n+            false)),\n           java(\n             \"\"\"\n               package org.example;\n@@ -703,4 +745,151 @@ public class A {\n           )\n         );\n     }\n+\n+    @Test\n+    void appendSingleValueToExistingArrayAttribute() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\n+            \"org.example.Foo\",\n+            \"array\",\n+            \"b\",\n+            false,\n+            true)),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              public @interface Foo {\n+                  String[] array() default {};\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import org.example.Foo;\n+              \n+              @Foo(array = {\"a\"})\n+              public class A {\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import org.example.Foo;\n+              \n+              @Foo(array = {\"a\", \"b\"})\n+              public class A {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void appendMultipleValuesToExistingArrayAttribute() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\n+            \"org.example.Foo\",\n+            \"array\",\n+            \"b,c\",\n+            false,\n+            true)),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              public @interface Foo {\n+                  String[] array() default {};\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import org.example.Foo;\n+              \n+              @Foo(array = {\"a\"})\n+              public class A {\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import org.example.Foo;\n+              \n+              @Foo(array = {\"a\", \"b\", \"c\"})\n+              public class A {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void appendMultipleValuesToExistingArrayAttributeWithOverlap() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\n+            \"org.example.Foo\",\n+            \"array\",\n+            \"b,c\",\n+            false,\n+            true)),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              public @interface Foo {\n+                  String[] array() default {};\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import org.example.Foo;\n+              \n+              @Foo(array = {\"a\", \"b\"})\n+              public class A {\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import org.example.Foo;\n+              \n+              @Foo(array = {\"a\", \"b\", \"c\"})\n+              public class A {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void appendMultipleValuesToExistingArrayAttributeNonSet() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddOrUpdateAnnotationAttribute(\n+            \"org.example.Foo\",\n+            \"array\",\n+            \"b,c\",\n+            true,\n+            true)),\n+          java(\n+            \"\"\"\n+              package org.example;\n+              public @interface Foo {\n+                  String[] array() default {};\n+              }\n+              \n+              public class A {\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import org.example.Foo;\n+              \n+              @Foo(array = {\"a\", \"b\"})\n+              public class A {\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import org.example.Foo;\n+              \n+              @Foo(array = {\"a\", \"b\", \"b\", \"c\"})\n+              public class A {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4661",
    "pr_id": 4661,
    "issue_id": 4660,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Support JEP-441: Pattern Matching for switch\n<!--\r\nThank you for suggesting an improvement to OpenRewrite!\r\nFeel free to delete any sections that don't apply to your request.\r\n-->\r\n## What problem are you trying to solve?\r\nTo support Java 21 recipes the parser need to be extended to ensure compatibility with JEP 440 (Record Patterns) and JEP 441 (Pattern Matching for switch).\r\n\r\n## Describe the solution you'd like\r\nParsing logic should recognize and handle record patterns and switch pattern matching, for different situations and edge cases, which have already been outlined in the proposal.\r\n\r\n## Additional context\r\n* https://openjdk.org/jeps/441",
    "issue_word_count": 100,
    "test_files_count": 3,
    "non_test_files_count": 13,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/RecordPatternMatchingTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/Assertions.java",
      "rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java",
      "rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java",
      "rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java",
      "rewrite-java/src/main/java/org/openrewrite/java/tree/J.java",
      "rewrite-java/src/main/java/org/openrewrite/java/tree/JContainer.java",
      "rewrite-java/src/main/java/org/openrewrite/java/tree/JRightPadded.java",
      "rewrite-java/src/main/java/org/openrewrite/java/tree/Space.java",
      "rewrite-test/src/main/java/org/openrewrite/test/TypeValidation.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/RecordPatternMatchingTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java",
      "rewrite-test/src/main/java/org/openrewrite/test/TypeValidation.java"
    ],
    "base_commit": "1fd511c3b31787ba6517b8b2db137d73fa05e6bb",
    "head_commit": "472082ffaa1a1ed5f8cc5a1fcfcf11b767011b2b",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4661",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4661",
    "dockerfile": "",
    "pr_merged_at": "2025-01-17T13:08:22.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex d38c154ef76..e36026b986a 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -650,7 +650,7 @@ public List<J.Annotation> visitAndGetAnnotations(AnnotatedNode node) {\n             for (AnnotationNode annotationNode : node.getAnnotations()) {\n                 // The groovy compiler can add or remove annotations for AST transformations.\n                 // Because @groovy.transform.Immutable is discarded in favour of other transform annotations, the removed annotation must be parsed by hand.\n-                if (sourceStartsWith(\"@\" + Immutable.class.getSimpleName()) || sourceStartsWith(\"@\" + Immutable.class.getCanonicalName()) ) {\n+                if (sourceStartsWith(\"@\" + Immutable.class.getSimpleName()) || sourceStartsWith(\"@\" + Immutable.class.getCanonicalName())) {\n                     visitAnnotation(new AnnotationNode(new ClassNode(Immutable.class)));\n                     paramAnnotations.add(pollQueue());\n                 }\n@@ -1135,10 +1135,12 @@ public void visitCaseStatement(CaseStatement statement) {\n                     J.Case.Type.Statement,\n                     null,\n                     JContainer.build(singletonList(JRightPadded.build(visit(statement.getExpression())))),\n+                    null,\n+                    null,\n                     statement.getCode() instanceof EmptyStatement ?\n                             JContainer.build(sourceBefore(\":\"), convertStatements(emptyList()), Markers.EMPTY) :\n-                            JContainer.build(sourceBefore(\":\"), convertStatements(((BlockStatement) statement.getCode()).getStatements()), Markers.EMPTY)\n-                    , null)\n+                            JContainer.build(sourceBefore(\":\"), convertStatements(((BlockStatement) statement.getCode()).getStatements()), Markers.EMPTY),\n+                    null)\n             );\n         }\n \n@@ -1149,6 +1151,8 @@ private J.Case visitDefaultCaseStatement(BlockStatement statement) {\n                     J.Case.Type.Statement,\n                     null,\n                     JContainer.build(singletonList(JRightPadded.build(new J.Identifier(randomId(), EMPTY, Markers.EMPTY, emptyList(), skip(\"default\"), null, null)))),\n+                    null,\n+                    null,\n                     JContainer.build(sourceBefore(\":\"), convertStatements(statement.getStatements()), Markers.EMPTY),\n                     null\n             );\n@@ -1609,7 +1613,7 @@ public void visitGStringExpression(GStringExpression gstring) {\n                 }\n             }\n \n-            queue.add(new G.GString(randomId(), fmt, Markers.EMPTY, delimiter, strings,typeMapping.type(gstring.getType())));\n+            queue.add(new G.GString(randomId(), fmt, Markers.EMPTY, delimiter, strings, typeMapping.type(gstring.getType())));\n             skip(delimiter); // Closing delim for GString\n         }\n \n@@ -2778,6 +2782,7 @@ private static ClassNode staticType(Parameter parameter) {\n     }\n \n     private static final Map<String, J.Modifier.Type> modifierNameToType;\n+\n     static {\n         modifierNameToType = new LinkedHashMap<>();\n         modifierNameToType.put(\"def\", J.Modifier.Type.LanguageExtension);\n\ndiff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\nindex 8c434c84edd..22648604cd2 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n@@ -346,6 +346,8 @@ public J visitCase(CaseTree node, Space fmt) {\n                         ),\n                         Markers.EMPTY\n                 ),\n+                null,\n+                null,\n                 JContainer.build(sourceBefore(\":\"), convertStatements(node.getStatements()), Markers.EMPTY),\n                 null\n         );\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex 7fbd874ed01..4cfa6f14764 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -355,6 +355,8 @@ public J visitCase(CaseTree node, Space fmt) {\n                                 convertAll(node.getExpressions(), commaDelim, t -> EMPTY),\n                         Markers.EMPTY\n                 ),\n+                null,\n+                null,\n                 JContainer.build(\n                         sourceBefore(type == J.Case.Type.Rule ? \"->\" : \":\"),\n                         convertStatements(node.getStatements()),\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex 4a6973da177..0614a13714f 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -348,13 +348,15 @@ public J visitCase(CaseTree node, Space fmt) {\n                 Markers.EMPTY,\n                 type,\n                 null,\n+                null,\n                 JContainer.build(\n-                        node.getExpressions().isEmpty() ? EMPTY : sourceBefore(\"case\"),\n-                        node.getExpressions().isEmpty() ?\n+                        node.getLabels().isEmpty() ? EMPTY : sourceBefore(\"case\"),\n+                        node.getLabels().isEmpty() || node.getLabels().getFirst() instanceof DefaultCaseLabelTree ?\n                                 List.of(JRightPadded.build(new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), skip(\"default\"), null, null))) :\n-                                convertAll(node.getExpressions(), commaDelim, t -> EMPTY),\n+                                convertAll(node.getLabels(), commaDelim, ignored -> node.getGuard() != null ? sourceBefore(\"when\", '-') : EMPTY),\n                         Markers.EMPTY\n                 ),\n+                convert(node.getGuard()),\n                 JContainer.build(\n                         sourceBefore(type == J.Case.Type.Rule ? \"->\" : \":\"),\n                         convertStatements(node.getStatements()),\n@@ -779,12 +781,26 @@ public J visitInstanceOf(InstanceOfTree node, Space fmt) {\n         return new J.InstanceOf(randomId(), fmt, Markers.EMPTY,\n                 convert(node.getExpression(), t -> sourceBefore(\"instanceof\")),\n                 convert(node.getType()),\n-                node.getPattern() instanceof JCBindingPattern b ?\n-                        new J.Identifier(randomId(), sourceBefore(b.getVariable().getName().toString()), Markers.EMPTY, emptyList(), b.getVariable().getName().toString(),\n-                                type, typeMapping.variableType(b.var.sym)) : null,\n+                getNodePattern(node.getPattern(), type),\n                 type);\n     }\n \n+    private @Nullable J getNodePattern(@Nullable PatternTree pattern, JavaType type) {\n+        if (pattern instanceof JCBindingPattern b) {\n+            return new J.Identifier(randomId(), sourceBefore(b.getVariable().getName().toString()), Markers.EMPTY, emptyList(), b.getVariable().getName().toString(),\n+                    type, typeMapping.variableType(b.var.sym));\n+        } else {\n+            if (pattern == null) {\n+                return null;\n+            }\n+            int saveCursor = cursor;\n+            int endCursor = max(endPos(pattern), cursor);\n+            cursor = endCursor;\n+            return new J.Unknown(randomId(), whitespace(), Markers.EMPTY, new J.Unknown.Source(randomId(), whitespace(), Markers.EMPTY, source.substring(saveCursor, endCursor)));\n+\n+        }\n+    }\n+\n     @Override\n     public J visitIntersectionType(IntersectionTypeTree node, Space fmt) {\n         JContainer<TypeTree> bounds = node.getBounds().isEmpty() ? null :\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\nindex 0d6cf8309fc..5d35ffcc46a 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n@@ -343,6 +343,8 @@ public J visitCase(CaseTree node, Space fmt) {\n                         ),\n                         Markers.EMPTY\n                 ),\n+                null,\n+                null,\n                 JContainer.build(sourceBefore(\":\"), convertStatements(node.getStatements()), Markers.EMPTY),\n                 null\n         );\n@@ -1787,17 +1789,17 @@ private <J2 extends J> List<JRightPadded<J2>> convertAll(List<? extends Tree> tr\n \n     private Space statementDelim(@Nullable Tree t) {\n         if (t instanceof JCAssert ||\n-                t instanceof JCAssign ||\n-                t instanceof JCAssignOp ||\n-                t instanceof JCBreak ||\n-                t instanceof JCContinue ||\n-                t instanceof JCDoWhileLoop ||\n-                t instanceof JCImport ||\n-                t instanceof JCMethodInvocation ||\n-                t instanceof JCNewClass ||\n-                t instanceof JCReturn ||\n-                t instanceof JCThrow ||\n-                t instanceof JCUnary) {\n+            t instanceof JCAssign ||\n+            t instanceof JCAssignOp ||\n+            t instanceof JCBreak ||\n+            t instanceof JCContinue ||\n+            t instanceof JCDoWhileLoop ||\n+            t instanceof JCImport ||\n+            t instanceof JCMethodInvocation ||\n+            t instanceof JCNewClass ||\n+            t instanceof JCReturn ||\n+            t instanceof JCThrow ||\n+            t instanceof JCUnary) {\n             return sourceBefore(\";\");\n         }\n \n@@ -1808,7 +1810,7 @@ private Space statementDelim(@Nullable Tree t) {\n         if (t instanceof JCExpressionStatement) {\n             ExpressionTree expTree = ((ExpressionStatementTree) t).getExpression();\n             if (expTree instanceof ErroneousTree) {\n-                return Space.build(source.substring(((JCTree) expTree).getEndPosition(endPosTable),((JCTree) t).getEndPosition(endPosTable)), Collections.emptyList());\n+                return Space.build(source.substring(((JCTree) expTree).getEndPosition(endPosTable), ((JCTree) t).getEndPosition(endPosTable)), Collections.emptyList());\n             } else {\n                 return sourceBefore(\";\");\n             }\n@@ -1972,7 +1974,7 @@ private int positionOfNext(String untilDelim, @Nullable Character stop) {\n                     char c2 = source.charAt(delimIndex + 1);\n                     switch (c1) {\n                         case '/':\n-                            switch(c2) {\n+                            switch (c2) {\n                                 case '/':\n                                     inSingleLineComment = true;\n                                     delimIndex++;\n@@ -1984,7 +1986,7 @@ private int positionOfNext(String untilDelim, @Nullable Character stop) {\n                             }\n                             break;\n                         case '*':\n-                            if(c2 == '/') {\n+                            if (c2 == '/') {\n                                 inMultiLineComment = false;\n                                 delimIndex++;\n                                 continue;\n@@ -2051,7 +2053,7 @@ private List<String> listFlags(long flags) {\n                     try {\n                         // FIXME instanceof probably not right here...\n                         return field.get(null) instanceof Long &&\n-                                field.getName().matches(\"[A-Z_]+\");\n+                               field.getName().matches(\"[A-Z_]+\");\n                     } catch (IllegalAccessException e) {\n                         throw new RuntimeException(e);\n                     }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/Assertions.java b/rewrite-java/src/main/java/org/openrewrite/java/Assertions.java\nindex 1524c72188e..4d2196083ca 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/Assertions.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/Assertions.java\n@@ -74,13 +74,28 @@ public J.Erroneous visitErroneous(J.Erroneous erroneous, List<J.Erroneous> list)\n                             .collect(joining(\"\\n\\n\")));\n                 }\n             }\n+            if (typeValidation.unknown()) {\n+                List<J.Unknown> allUnknown = new JavaIsoVisitor<List<J.Unknown>>() {\n+                    @Override\n+                    public J.Unknown visitUnknown(J.Unknown unknown, List<J.Unknown> list) {\n+                        J.Unknown err = super.visitUnknown(unknown, list);\n+                        list.add(err);\n+                        return err;\n+                    }\n+                }.reduce(source, new ArrayList<>());\n+                if (!allUnknown.isEmpty()) {\n+                    throw new IllegalStateException(\"LST contains erroneous nodes\\n\" + allUnknown.stream()\n+                            .map(unknown -> unknown.getSource().getText())\n+                            .collect(joining(\"\\n\\n\")));\n+                }\n+            }\n         }\n         return source;\n     }\n \n     private static void assertValidTypes(TypeValidation typeValidation, J sf) {\n         if (typeValidation.identifiers() || typeValidation.methodInvocations() || typeValidation.methodDeclarations() || typeValidation.classDeclarations() ||\n-                typeValidation.constructorInvocations()) {\n+            typeValidation.constructorInvocations()) {\n             List<FindMissingTypes.MissingTypeResult> missingTypeResults = FindMissingTypes.findMissingTypes(sf);\n             missingTypeResults = missingTypeResults.stream()\n                     .filter(missingType -> {\n@@ -108,7 +123,7 @@ private static void assertValidTypes(TypeValidation typeValidation, J sf) {\n                         .collect(joining(\"\\n\\n\"));\n                 throw new IllegalStateException(\n                         \"LST contains missing or invalid type information\\n\" + missingTypes +\n-                                \"\\nhttps://docs.openrewrite.org/reference/faq#im-seeing-lst-contains-missing-or-invalid-type-information-in-my-recipe-unit-tests-how-to-resolve\");\n+                        \"\\nhttps://docs.openrewrite.org/reference/faq#im-seeing-lst-contains-missing-or-invalid-type-information-in-my-recipe-unit-tests-how-to-resolve\");\n             }\n         }\n     }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java b/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java\nindex 9743bb1abcd..38e6fc9715b 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavaPrinter.java\n@@ -442,8 +442,8 @@ protected void printStatementTerminator(Statement s, PrintOutputCapture<P> p) {\n                         getCursor()\n                                 .dropParentUntil(\n                                         c -> c instanceof Switch ||\n-                                                c instanceof SwitchExpression ||\n-                                                c == Cursor.ROOT_VALUE\n+                                             c instanceof SwitchExpression ||\n+                                             c == Cursor.ROOT_VALUE\n                                 )\n                                 .getValue();\n                 if (aSwitch instanceof SwitchExpression) {\n@@ -484,11 +484,15 @@ public J visitBreak(Break breakStatement, PrintOutputCapture<P> p) {\n     @Override\n     public J visitCase(Case case_, PrintOutputCapture<P> p) {\n         beforeSyntax(case_, Space.Location.CASE_PREFIX, p);\n-        Expression elem = case_.getExpressions().get(0);\n+        J elem = case_.getCaseLabels().get(0);\n         if (!(elem instanceof Identifier) || !((Identifier) elem).getSimpleName().equals(\"default\")) {\n             p.append(\"case\");\n         }\n-        visitContainer(\"\", case_.getPadding().getExpressions(), JContainer.Location.CASE_EXPRESSION, \",\", \"\", p);\n+        visitContainer(\"\", case_.getPadding().getCaseLabels(), JContainer.Location.CASE_LABEL, \",\", \"\", p);\n+        if (case_.getGuard() != null) {\n+            p.append(\"when\");\n+            visit(case_.getGuard(), p);\n+        }\n         visitSpace(case_.getPadding().getStatements().getBefore(), Space.Location.CASE, p);\n         p.append(case_.getType() == Case.Type.Statement ? \":\" : \"->\");\n         visitStatements(case_.getPadding().getStatements().getPadding()\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java b/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java\nindex be5ca459848..8f8e05bb1bd 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavaVisitor.java\n@@ -423,7 +423,8 @@ public J visitCase(J.Case case_, P p) {\n         } else {\n             c = (J.Case) temp;\n         }\n-        c = c.getPadding().withExpressions(visitContainer(c.getPadding().getExpressions(), JContainer.Location.CASE_EXPRESSION, p));\n+        c = c.getPadding().withCaseLabels(visitContainer(c.getPadding().getCaseLabels(), JContainer.Location.CASE_LABEL, p));\n+        c = c.withGuard(visitAndCast(c.getGuard(), p));\n         c = c.getPadding().withBody(visitRightPadded(c.getPadding().getBody(), JRightPadded.Location.CASE_BODY, p));\n         c = c.getPadding().withStatements(visitContainer(c.getPadding().getStatements(), JContainer.Location.CASE, p));\n         return c;\n@@ -1406,7 +1407,7 @@ public J visitYield(J.Yield yield, P p) {\n     }\n \n     public <J2 extends J> @Nullable JContainer<J2> visitContainer(@Nullable JContainer<J2> container,\n-                                                        JContainer.Location loc, P p) {\n+                                                                  JContainer.Location loc, P p) {\n         if (container == null) {\n             //noinspection ConstantConditions\n             return null;\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java b/rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java\nindex 6260ae2ec1a..3618a95f763 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/search/SemanticallyEqual.java\n@@ -366,7 +366,13 @@ public J.Case visitCase(J.Case _case, J j) {\n                 J.Case compareTo = (J.Case) j;\n                 this.visitList(_case.getStatements(), compareTo.getStatements());\n                 visit(_case.getBody(), compareTo.getBody());\n-                this.visitList(_case.getExpressions(), compareTo.getExpressions());\n+                this.visitList(_case.getCaseLabels(), compareTo.getCaseLabels());\n+                if (_case.getGuard() != null && compareTo.getGuard() != null) {\n+                    visit(_case.getGuard(), compareTo.getGuard());\n+                } else if (nullMissMatch(_case.getGuard(), compareTo.getGuard())) {\n+                    isEqual.set(false);\n+                    return _case;\n+                }\n             }\n             return _case;\n         }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java\nindex 3c6f581bb8a..592e839a3e3 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java\n@@ -1027,14 +1027,36 @@ public Case withPattern(@Nullable Expression pattern) {\n             return withExpressions(ListUtils.mapFirst(getExpressions(), first -> pattern));\n         }\n \n-        JContainer<Expression> expressions;\n-\n+        /**\n+         * @deprecated As of Java 21 this is referred to as case labels and can be broader than just Expressions.\n+         * Use {@link #getCaseLabels} and {@link #withCaseLabels(List)} instead.\n+         */\n+        @Deprecated\n         public List<Expression> getExpressions() {\n-            return expressions.getElements();\n+            return caseLabels.getElements().stream().filter(Expression.class::isInstance).map(Expression.class::cast).collect(toList());\n         }\n \n+        /**\n+         * @deprecated As of Java 21 this is referred to as case labels and can be broader than just Expressions.\n+         * Use {@link #getCaseLabels} and {@link #withCaseLabels(List)} instead.\n+         */\n         public Case withExpressions(List<Expression> expressions) {\n-            return getPadding().withExpressions(requireNonNull(JContainer.withElementsNullable(this.expressions, expressions)));\n+            if (caseLabels.getElements().stream().allMatch(Expression.class::isInstance)) {\n+                //noinspection unchecked\n+                return getPadding().withCaseLabels(requireNonNull(JContainer.withElementsNullable(this.caseLabels, (List<J>) (List<?>) expressions)));\n+            } else {\n+                throw new IllegalStateException(\"caseLabels contains an entry that is not an Expression, use withCaseLabels instead.\");\n+            }\n+        }\n+\n+        JContainer<J> caseLabels;\n+\n+        public List<J> getCaseLabels() {\n+            return caseLabels.getElements();\n+        }\n+\n+        public Case withCaseLabels(List<J> caseLabels) {\n+            return getPadding().withCaseLabels(requireNonNull(JContainer.withElementsNullable(this.caseLabels, caseLabels)));\n         }\n \n         /**\n@@ -1067,17 +1089,27 @@ public Case withBody(J body) {\n             return getPadding().withBody(JRightPadded.withElement(this.body, body));\n         }\n \n+        @Nullable\n+        @Getter\n+        @With\n+        Expression guard;\n+\n         @JsonCreator\n-        public Case(UUID id, Space prefix, Markers markers, Type type, @Deprecated @Nullable Expression pattern, JContainer<Expression> expressions, JContainer<Statement> statements, @Nullable JRightPadded<J> body) {\n+        public Case(UUID id, Space prefix, Markers markers, Type type, @Deprecated @Nullable Expression pattern, @Nullable JContainer<Expression> expressions, @Nullable JContainer<J> caseLabels, @Nullable Expression guard, JContainer<Statement> statements, @Nullable JRightPadded<J> body) {\n             this.id = id;\n             this.prefix = prefix;\n             this.markers = markers;\n             this.type = type;\n             if (pattern != null) {\n-                this.expressions = requireNonNull(JContainer.withElementsNullable(null, singletonList(pattern)));\n+                this.caseLabels = requireNonNull(JContainer.withElementsNullable(null, singletonList(pattern)));\n+            } else if (expressions != null) {\n+                this.caseLabels = JContainer.build(expressions.getBefore(), expressions.getElements().stream().map(J.class::cast).map(JRightPadded::build).collect(toList()), expressions.getMarkers());\n+            } else if (caseLabels != null) {\n+                this.caseLabels = caseLabels;\n             } else {\n-                this.expressions = expressions;\n+                this.caseLabels = JContainer.empty();\n             }\n+            this.guard = guard;\n             this.statements = statements;\n             this.body = body;\n         }\n@@ -1127,7 +1159,7 @@ public static class Padding {\n             }\n \n             public Case withBody(@Nullable JRightPadded<J> body) {\n-                return t.body == body ? t : new Case(t.id, t.prefix, t.markers, t.type, null, t.expressions, t.statements, body);\n+                return t.body == body ? t : new Case(t.id, t.prefix, t.markers, t.type, null, null, t.caseLabels, t.guard, t.statements, body);\n             }\n \n             public JContainer<Statement> getStatements() {\n@@ -1135,15 +1167,38 @@ public JContainer<Statement> getStatements() {\n             }\n \n             public Case withStatements(JContainer<Statement> statements) {\n-                return t.statements == statements ? t : new Case(t.id, t.prefix, t.markers, t.type, null, t.expressions, statements, t.body);\n+                return t.statements == statements ? t : new Case(t.id, t.prefix, t.markers, t.type, null, null, t.caseLabels, t.guard, statements, t.body);\n             }\n \n+            /**\n+             * @deprecated As of Java 21 this is referred to as case labels and can be broader than just Expressions.\n+             * Use {@link #getCaseLabels} and {@link #withCaseLabels(JContainer)} instead.\n+             */\n+            @Deprecated\n             public JContainer<Expression> getExpressions() {\n-                return t.expressions;\n+                return JContainer.build(t.caseLabels.getBefore(), t.caseLabels.getElements().stream().filter(Expression.class::isInstance).map(Expression.class::cast).map(JRightPadded::build).collect(toList()), t.caseLabels.getMarkers());\n             }\n \n+            /**\n+             * @deprecated As of Java 21 this is referred to as case labels and can be broader than just Expressions.\n+             * Use {@link #getCaseLabels} and {@link #withCaseLabels(JContainer)} instead.\n+             */\n+            @Deprecated\n             public Case withExpressions(JContainer<Expression> expressions) {\n-                return t.expressions == expressions ? t : new Case(t.id, t.prefix, t.markers, t.type, null, expressions, t.statements, t.body);\n+                if (t.getExpressions() == expressions) {\n+                    return t;\n+                } else if (t.caseLabels.getElements().stream().allMatch(Expression.class::isInstance)) {\n+                    return new Case(t.id, t.prefix, t.markers, t.type, null, expressions, null, t.guard, t.statements, t.body);\n+                }\n+                throw new IllegalStateException(\"caseLabels contains an entry that is not an Expression, use withCaseLabels instead.\");\n+            }\n+\n+            public JContainer<J> getCaseLabels() {\n+                return t.caseLabels;\n+            }\n+\n+            public Case withCaseLabels(JContainer<J> caseLabels) {\n+                return t.caseLabels == caseLabels ? t : new Case(t.id, t.prefix, t.markers, t.type, null, null, caseLabels, t.guard, t.statements, t.body);\n             }\n         }\n     }\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/JContainer.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/JContainer.java\nindex a299f98da67..c03505a05d2 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/JContainer.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/JContainer.java\n@@ -102,6 +102,7 @@ public enum Location {\n         ANNOTATION_ARGUMENTS(Space.Location.ANNOTATION_ARGUMENTS, JRightPadded.Location.ANNOTATION_ARGUMENT),\n         CASE(Space.Location.CASE, JRightPadded.Location.CASE),\n         CASE_EXPRESSION(Space.Location.CASE_EXPRESSION, JRightPadded.Location.CASE_EXPRESSION),\n+        CASE_LABEL(Space.Location.CASE_LABEL, JRightPadded.Location.CASE_LABEL),\n         IMPLEMENTS(Space.Location.IMPLEMENTS, JRightPadded.Location.IMPLEMENTS),\n         PERMITS(Space.Location.PERMITS, JRightPadded.Location.PERMITS),\n         LANGUAGE_EXTENSION(Space.Location.LANGUAGE_EXTENSION, JRightPadded.Location.LANGUAGE_EXTENSION),\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/JRightPadded.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/JRightPadded.java\nindex 78c65a04a14..b90a9abc19d 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/JRightPadded.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/JRightPadded.java\n@@ -47,6 +47,7 @@ public enum Location {\n         BLOCK_STATEMENT(Space.Location.BLOCK_STATEMENT_SUFFIX),\n         CASE(Space.Location.CASE_SUFFIX),\n         CASE_EXPRESSION(Space.Location.CASE_EXPRESSION),\n+        CASE_LABEL(Space.Location.CASE_LABEL),\n         CASE_BODY(Space.Location.CASE_BODY),\n         CATCH_ALTERNATIVE(Space.Location.CATCH_ALTERNATIVE_SUFFIX),\n         DIMENSION(Space.Location.DIMENSION_SUFFIX),\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/Space.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/Space.java\nindex a334eafa601..a18deff4ce0 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/Space.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/Space.java\n@@ -295,8 +295,8 @@ public String toString() {\n         String whitespaces = printedWs.toString();\n \n         return \"Space(\" +\n-                \"comments=<\" + (comments.size() == 1 ? \"1 comment\" : comments.size() + \" comments\") + \">, \" +\n-                \"whitespace=\" + (whitespaces.isEmpty() ? \"<empty>\" : \"'\" + whitespaces + \"'\") + \")\";\n+               \"comments=<\" + (comments.size() == 1 ? \"1 comment\" : comments.size() + \" comments\") + \">, \" +\n+               \"whitespace=\" + (whitespaces.isEmpty() ? \"<empty>\" : \"'\" + whitespaces + \"'\") + \")\";\n     }\n \n     public enum Location {\n@@ -325,6 +325,7 @@ public enum Location {\n         CASE,\n         CASE_BODY,\n         CASE_EXPRESSION,\n+        CASE_LABEL,\n         CASE_PREFIX,\n         CASE_SUFFIX,\n         CATCH_ALTERNATIVE_SUFFIX,\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/RecordPatternMatchingTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/RecordPatternMatchingTest.java\nnew file mode 100644\nindex 00000000000..6af88fe84f1\n--- /dev/null\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/RecordPatternMatchingTest.java\n@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.tree;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.java.MinimumJava21;\n+import org.openrewrite.test.RecipeSpec;\n+import org.openrewrite.test.RewriteTest;\n+import org.openrewrite.test.TypeValidation;\n+\n+import static org.openrewrite.java.Assertions.java;\n+\n+@MinimumJava21\n+class RecordPatternMatchingTest implements RewriteTest {\n+\n+    @Override\n+    public void defaults(RecipeSpec spec) {\n+        spec.typeValidationOptions(TypeValidation.all().unknown(false));\n+    }\n+\n+    @Test\n+    void shouldParseJava21PatternMatchForRecords() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \"\"\"\n+              record Point(int x, int y) {}\n+              class Test {\n+                  void printSum(Object obj) {\n+                      if (obj instanceof Point(int x, int y)) {\n+                          System.out.println(x+y);\n+                      }\n+                  }\n+              }\n+              \"\"\"\n+          ));\n+    }\n+\n+    @Test\n+    void shouldParseJava21NestedPatternMatchForRecords() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \"\"\"\n+              record Point(int x, int y) {}\n+              enum Color { RED, GREEN, BLUE }\n+              record ColoredPoint(Point p, Color c) {}\n+              record Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}\n+              class Test {\n+                  void printColorOfUpperLeftPoint(Rectangle r) {\n+                      if (r instanceof Rectangle(ColoredPoint(Point p, Color c),\n+                                                 ColoredPoint lr)) {\n+                          System.out.println(c);\n+                      }\n+                  }\n+              }\n+              \"\"\"\n+          ));\n+    }\n+\n+}\n\ndiff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java\nnew file mode 100644\nindex 00000000000..30d89070966\n--- /dev/null\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/SwitchPatternMatchingTest.java\n@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2025 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.tree;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.java.MinimumJava21;\n+import org.openrewrite.test.RewriteTest;\n+\n+import static org.openrewrite.java.Assertions.java;\n+\n+@MinimumJava21\n+class SwitchPatternMatchingTest implements RewriteTest {\n+\n+    @Test\n+    void shouldParseJava21PatternSwitch() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \"\"\"\n+              class Test {\n+                  String formatterPatternSwitch(Object obj) {\n+                      return switch (obj) {\n+                          case Integer i -> String.format(\"int %d\", i);\n+                          case Long l    -> String.format(\"long %d\", l);\n+                          case Double d  -> String.format(\"double %f\", d);\n+                          case String s  -> String.format(\"String %s\", s);\n+                          default        -> obj.toString();\n+                      };\n+                  }\n+              }\n+              \"\"\"\n+          ));\n+    }\n+\n+    @Test\n+    void shouldSupportParsingNullSwitch() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \"\"\"\n+              class Test {\n+                void fooBarWithNull(String s) {\n+                    switch (s) {\n+                        case null -> System.out.println(\"Oops\");\n+                        case \"Foo\", \"Bar\" -> System.out.println(\"Great\");\n+                        default -> System.out.println(\"Ok\");\n+                    }\n+                }\n+              }\n+              \"\"\"\n+          ));\n+    }\n+\n+    @Test\n+    void shouldParseJava21EnumSupportInSwitch() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \"\"\"\n+              enum Coin  { HEADS, TAILS }\n+              \n+              class Test {\n+                  void switchEnum(Coin c) {\n+                      switch (c) {\n+                          case HEADS -> System.out.println(\"Heads\");\n+                          case Coin.TAILS -> System.out.println(\"Tails\");\n+                      }\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void shouldParseJava21ImprovedEnumSupportInSwitch() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \"\"\"\n+              sealed interface I permits Foo, Bar {}\n+              public enum Foo implements I { A, B }\n+              final class Bar implements I {}\n+              \n+              class Test {\n+                  void switchEnumExtendedType(I c) {\n+                      switch (c) {\n+                          case Foo.A -> System.out.println(\"It's Foo A\");\n+                          case Foo.B -> System.out.println(\"It's Foo B\");\n+                          case Bar b -> System.out.println(\"It's Bar\");\n+                      }\n+                  }\n+              }\n+              \"\"\"\n+          ));\n+    }\n+\n+    @Test\n+    void shouldParseJava21SwitchWithRelaxedTypeRestrictions() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \"\"\"\n+              record Point(int i, int j) {}\n+              enum Color { RED, GREEN, BLUE; }\n+              \n+              class Test {\n+                  void typeTester(Object obj) {\n+                       switch (obj) {\n+                           case null     -> System.out.println(\"null\");\n+                           case String s -> System.out.println(\"String\");\n+                           case Color c  -> System.out.println(\"Color: \" + c.toString());\n+                           case Point p  -> System.out.println(\"Record class: \" + p.toString());\n+                           case int[] ia -> System.out.println(\"Array of ints of length\" + ia.length);\n+                           default       -> System.out.println(\"Something else\");\n+                       }\n+                  }\n+              }\n+              \"\"\"\n+          ));\n+    }\n+\n+    @Test\n+    void shouldParseJava21SwitchWithSpecialCases() {\n+        rewriteRun(\n+          java(\n+            //language=java\n+            \"\"\"\n+              class Test {\n+                  void integerTester(Integer i) {\n+                       switch (i) {\n+                           case -1, 1 -> System.out.println(\"special\");\n+                           case Integer j when (j - 1) > -1 -> System.out.println(\"pos\");\n+                           case Integer j -> System.out.println(\"others\");\n+                       }\n+                  }\n+              }\n+              \"\"\"\n+          ));\n+    }\n+\n+}\n\ndiff --git a/rewrite-test/src/main/java/org/openrewrite/test/TypeValidation.java b/rewrite-test/src/main/java/org/openrewrite/test/TypeValidation.java\nindex e395db403da..81bbc478a61 100644\n--- a/rewrite-test/src/main/java/org/openrewrite/test/TypeValidation.java\n+++ b/rewrite-test/src/main/java/org/openrewrite/test/TypeValidation.java\n@@ -103,6 +103,12 @@ public class TypeValidation {\n     @Builder.Default\n     private boolean erroneous = true;\n \n+    /**\n+     * Controls whether the LST is validated not to contain any `J.Unknown` elements.\n+     */\n+    @Builder.Default\n+    private boolean unknown = true;\n+\n     /**\n      * Adding messages to execution context is a side effect which makes the recipe run itself stateful.\n      * Potentially allows recipes to interfere with each other in surprising and hard to debug ways.\n@@ -122,7 +128,7 @@ public static TypeValidation all() {\n      * Skip all invariant validation checks.\n      */\n     public static TypeValidation none() {\n-        return new TypeValidation(false, false, false, false, false, false, false, false, o -> false, false, false);\n+        return new TypeValidation(false, false, false, false, false, false, false, false, o -> false, false, false, false);\n     }\n \n     static TypeValidation before(RecipeSpec testMethodSpec, RecipeSpec testClassSpec) {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4624",
    "pr_id": 4624,
    "issue_id": 4344,
    "repo": "openrewrite/rewrite",
    "problem_statement": "rewrite-java - Parser issue with consecutive comment blocks\nTest case:\r\n```java\r\n    @Test\r\n    void consecutiveCommentBlocks() {\r\n        rewriteRun(\r\n          java(\r\n            \"\"\"\r\n            package org.sample;\r\n\r\n            //import org.apache.log4j.Logger;\r\n            /*import org.apache.logging.log4j.LogManager;\r\n            import org.apache.logging.log4j.Logger;*/\r\n            \r\n            /**\r\n             * Does stuff\r\n             */\r\n            public class MyClass {\r\n            /*//\tprivate static Logger log = Logger.getLogger(MyClass.class);\r\n                private static Logger log = (Logger) LogManager.getLogger(MyClass.class);\r\n                *//**\r\n                 * Does main stuff\r\n                 *\r\n                 * @param arguments\r\n                 *//*\r\n                public static void main(String[] args) {\r\n                }\r\n                *//*public static void main(String[] arguments) {\r\n                    \r\n                }*/\r\n            }\r\n            \"\"\"\r\n          )\r\n        );\r\n    }\r\n```\r\n\r\nResult:\r\n```\r\norg.opentest4j.AssertionFailedError: [When parsing and printing the source code back to text without modifications, the printed source didn't match the original source code. This means there is a bug in the parser implementation itself. Please open an issue to report this, providing a sample of the code that generated this error for \"org\\sample\\MyClass.java\":\r\ndiff --git a/org/sample/MyClass.java b/org/sample/MyClass.java\r\nindex 01d13a3..f0e4660 100644\r\n--- a/org/sample/MyClass.java\r\n+++ b/org/sample/MyClass.java\r\n@@ -14,10 +14,10 @@ \r\n      * Does main stuff\r\n      *\r\n      * @param arguments\r\n-     *//*\r\n+     *////\r\n     public static void main(String[] args) {\r\n     }\r\n-    *//*public static void main(String[] arguments) {\r\n+    //*public static void main(String[] arguments) {\r\n \r\n-    }*/\r\n-}\r\n\\ No newline at end of file\r\n+    }/\r\n+}//*\r\n\\ No newline at end of file\r\n] \r\nexpected: \"package org.sample;\r\n\r\n//import org.apache.log4j.Logger;\r\n/*import org.apache.logging.log4j.LogManager;\r\nimport org.apache.logging.log4j.Logger;*/\r\n\r\n/**\r\n * Does stuff\r\n */\r\npublic class MyClass {\r\n/*//\tprivate static Logger log = Logger.getLogger(MyClass.class);\r\n    private static Logger log = (Logger) LogManager.getLogger(MyClass.class);\r\n    *//**\r\n     * Does main stuff\r\n     *\r\n     * @param arguments\r\n     *//*\r\n    public static void main(String[] args) {\r\n    }\r\n    *//*public static void main(String[] arguments) {\r\n\r\n    }*/\r\n}\"\r\n but was: \"package org.sample;\r\n\r\n//import org.apache.log4j.Logger;\r\n/*import org.apache.logging.log4j.LogManager;\r\nimport org.apache.logging.log4j.Logger;*/\r\n\r\n/**\r\n * Does stuff\r\n */\r\npublic class MyClass {\r\n/*//\tprivate static Logger log = Logger.getLogger(MyClass.class);\r\n    private static Logger log = (Logger) LogManager.getLogger(MyClass.class);\r\n    *//**\r\n     * Does main stuff\r\n     *\r\n     * @param arguments\r\n     *////\r\n    public static void main(String[] args) {\r\n    }\r\n    //*public static void main(String[] arguments) {\r\n\r\n    }/\r\n}//*\"\r\n\tat org.openrewrite.test.RewriteTest.assertContentEquals(RewriteTest.java:616)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:311)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:132)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:127)\r\n\tat org.openrewrite.java.JavaParserTest.consecutiveCommentBlocks(JavaParserTest.java:59)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\r\n```",
    "issue_word_count": 396,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java"
    ],
    "base_commit": "6ba5a6d31f90e8b473f4849bcbcccbf1e0e8347a",
    "head_commit": "ee791cbb14f4b8ab46c74e0bf8fbae5661c6f5cd",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4624",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4624",
    "dockerfile": "",
    "pr_merged_at": "2024-10-30T09:05:28.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\nindex 7e1498d2e10..243acd89904 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n@@ -1815,7 +1815,8 @@ private int positionOfNext(String untilDelim, @Nullable Character stop) {\n                         case '*':\n                             if(c2 == '/') {\n                                 inMultiLineComment = false;\n-                                delimIndex += 2;\n+                                delimIndex++;\n+                                continue;\n                             }\n                             break;\n                     }\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex 7acdf489bcd..e9d67d54a6d 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -1903,7 +1903,8 @@ private int positionOfNext(String untilDelim, @Nullable Character stop) {\n                         case '*':\n                             if (c2 == '/') {\n                                 inMultiLineComment = false;\n-                                delimIndex += 2;\n+                                delimIndex++;\n+                                continue;\n                             }\n                             break;\n                     }\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex 6368c640680..a64eeab242f 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -1900,7 +1900,8 @@ private int positionOfNext(String untilDelim, @Nullable Character stop) {\n                         case '*':\n                             if (c2 == '/') {\n                                 inMultiLineComment = false;\n-                                delimIndex += 2;\n+                                delimIndex++;\n+                                continue;\n                             }\n                             break;\n                     }\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\nindex 53f3aaaea78..b07b7f18999 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n@@ -1808,7 +1808,8 @@ private int positionOfNext(String untilDelim, @Nullable Character stop) {\n                         case '*':\n                             if(c2 == '/') {\n                                 inMultiLineComment = false;\n-                                delimIndex += 2;\n+                                delimIndex++;\n+                                continue;\n                             }\n                             break;\n                     }\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\nindex c5b6fda983a..03c6a38ee89 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\n@@ -154,15 +154,64 @@ void shouldResolvePathUsingPublicClasses(@Language(\"java\") String source) {\n         rewriteRun(\n           java(\n             source,\n-            spec -> spec.afterRecipe(cu -> assertThat(cu.getSourcePath()).isEqualTo(Path.of(\"my\",\"example\",\"PublicClass.java\")))\n+            spec -> spec.afterRecipe(cu -> assertThat(cu.getSourcePath()).isEqualTo(Path.of(\"my\", \"example\", \"PublicClass.java\")))\n           )\n         );\n     }\n \n     @Test\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/1895\")\n-    void moduleInfo(){\n+    void moduleInfo() {\n         // Ignored until properly handled: https://github.com/openrewrite/rewrite/issues/4054#issuecomment-2267605739\n         assertFalse(JavaParser.fromJavaVersion().build().accept(Path.of(\"src/main/java/foo/module-info.java\")));\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/pull/4624\")\n+    void shouldParseComments() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              class A {\n+                  /*\n+                   * public Some getOther() { return other; }\n+                   *\n+                   *//**\n+                   * Sets the value of the other property.\n+                   *\n+                   * @param value allowed object is {@link Some }\n+                   *\n+                   *//*\n+                   * public void setOther(Some value) { this.other =\n+                   * value; }\n+                   */\n+              }\n+              \"\"\",\n+            spec -> spec.afterRecipe(cu -> assertThat(cu.getClasses().get(0).getBody().getEnd().getComments())\n+              .extracting(\"text\")\n+              .containsExactly(\n+                \"\"\"\n+                  \n+                       * public Some getOther() { return other; }\n+                       *\n+                       \\\n+                  \"\"\",\n+                \"\"\"\n+                  *\n+                       * Sets the value of the other property.\n+                       *\n+                       * @param value allowed object is {@link Some }\n+                       *\n+                       \\\n+                  \"\"\",\n+                \"\"\"\n+                  \n+                       * public void setOther(Some value) { this.other =\n+                       * value; }\n+                       \\\n+                  \"\"\"\n+              ))\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4610",
    "pr_id": 4610,
    "issue_id": 3,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Declarative rules aren't executing their visitors\n`CompositeSourceVisitor` delegates for default but not for `visit`.",
    "issue_word_count": 15,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/ExcludeFileFromGitignore.java",
      "rewrite-core/src/test/java/org/openrewrite/ExcludeFileFromGitignoreTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-core/src/test/java/org/openrewrite/ExcludeFileFromGitignoreTest.java"
    ],
    "base_commit": "ac8e34255c584b56c5df0ed155c79530477b6a9d",
    "head_commit": "240b81808f152c3d43425db78d934ec6d21b97a6",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4610",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4610",
    "dockerfile": "",
    "pr_merged_at": "2024-10-28T15:12:42.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/ExcludeFileFromGitignore.java b/rewrite-core/src/main/java/org/openrewrite/ExcludeFileFromGitignore.java\nnew file mode 100644\nindex 00000000000..e03122709ed\n--- /dev/null\n+++ b/rewrite-core/src/main/java/org/openrewrite/ExcludeFileFromGitignore.java\n@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.Value;\n+import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.jgit.ignore.FastIgnoreRule;\n+import org.openrewrite.jgit.ignore.IgnoreNode;\n+import org.openrewrite.text.PlainText;\n+import org.openrewrite.text.PlainTextVisitor;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static java.util.Comparator.comparingInt;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.commons.lang3.StringUtils.join;\n+import static org.openrewrite.ExcludeFileFromGitignore.Repository;\n+import static org.openrewrite.jgit.ignore.IgnoreNode.MatchResult.*;\n+\n+@Value\n+@EqualsAndHashCode(callSuper = false)\n+public class ExcludeFileFromGitignore extends ScanningRecipe<Repository> {\n+\n+    @Option(displayName = \"Paths\", description = \"The paths to find and remove from the gitignore files.\", example = \"/folder/file.txt\")\n+    List<String> paths;\n+\n+    @Override\n+    public String getDisplayName() {\n+        return \"Remove ignoral of files or directories from .gitignore\";\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"This recipe will remove a file or directory from the .gitignore file. \" +\n+               \"If the file or directory is already in the .gitignore file, it will be removed or negated. \" +\n+               \"If the file or directory is not in the .gitignore file, no action will be taken.\";\n+    }\n+\n+    @Override\n+    public Repository getInitialValue(ExecutionContext ctx) {\n+        return new Repository();\n+    }\n+\n+    @Override\n+    public TreeVisitor<?, ExecutionContext> getScanner(Repository acc) {\n+        return Preconditions.check(new FindSourceFiles(\"**/.gitignore\"), new PlainTextVisitor<ExecutionContext>() {\n+            @Override\n+            public PlainText visitText(PlainText text, ExecutionContext ctx) {\n+                try {\n+                    acc.addGitignoreFile(text);\n+                } catch (IOException e) {\n+                    throw new RecipeException(\"Failed to parse the .gitignore file\", e);\n+                }\n+                return super.visitText(text, ctx);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public TreeVisitor<?, ExecutionContext> getVisitor(Repository acc) {\n+\n+        for (String path : paths) {\n+            acc.exclude(path);\n+        }\n+\n+        return Preconditions.check(new FindSourceFiles(\"**/.gitignore\"), new PlainTextVisitor<ExecutionContext>() {\n+            @Override\n+            public PlainText visitText(PlainText text, ExecutionContext ctx) {\n+                String gitignoreFileName = text.getSourcePath().toString();\n+                gitignoreFileName = gitignoreFileName.startsWith(\"/\") ? gitignoreFileName : \"/\" + gitignoreFileName;\n+                IgnoreNode ignoreNode = acc.rules.get(gitignoreFileName.substring(0, gitignoreFileName.lastIndexOf(\"/\") + 1));\n+                if (ignoreNode != null) {\n+                    String separator = text.getText().contains(\"\\r\\n\") ? \"\\r\\n\" : \"\\n\";\n+                    List<String> newRules = ignoreNode.getRules().stream().map(FastIgnoreRule::toString).collect(toList());\n+                    String[] currentContent = text.getText().split(separator);\n+                    return text.withText(join(sortRules(currentContent, newRules), separator));\n+                }\n+                return super.visitText(text, ctx);\n+            }\n+\n+            private List<String> sortRules(String[] originalRules, List<String> newRules) {\n+                LinkedList<String> results = new LinkedList<>();\n+                Arrays.stream(originalRules).filter(line -> {\n+                    if (line.startsWith(\"#\") || StringUtils.isBlank(line)) {\n+                        return true;\n+                    }\n+                    return newRules.stream().anyMatch(line::equalsIgnoreCase);\n+                }).forEach(results::add);\n+\n+                int resultsIndexCurrentlyAt = 0;\n+                for (String newRule : newRules) {\n+                    List<String> resultsSubList = results.subList(resultsIndexCurrentlyAt, results.size());\n+                    if (resultsSubList.stream().noneMatch(rule -> rule.equalsIgnoreCase(newRule))) {\n+                        if (resultsIndexCurrentlyAt >= results.size()) {\n+                            results.add(newRule);\n+                        } else {\n+                            results.add(resultsIndexCurrentlyAt, newRule);\n+                        }\n+                    } else {\n+                        resultsIndexCurrentlyAt += resultsSubList.indexOf(newRule);\n+                    }\n+                    resultsIndexCurrentlyAt++;\n+                }\n+                return results;\n+            }\n+        });\n+    }\n+\n+    public static class Repository {\n+        private final Map<String, IgnoreNode> rules = new HashMap<>();\n+\n+        public void exclude(String path) {\n+            String normalizedPath = path.startsWith(\"/\") ? path : \"/\" + path;\n+            List<String> impactingFiles = rules.keySet()\n+                    .stream()\n+                    .filter(k -> normalizedPath.toLowerCase().startsWith(k.toLowerCase()))\n+                    .sorted(comparingInt(String::length).reversed())\n+                    .collect(toList());\n+\n+            IgnoreNode.MatchResult isIgnored;\n+            for (String impactingFile : impactingFiles) {\n+                IgnoreNode ignoreNode = rules.get(impactingFile);\n+                String nestedPath = normalizedPath.substring(impactingFile.length() - 1);\n+                isIgnored = isIgnored(ignoreNode, nestedPath);\n+                if (CHECK_PARENT == isIgnored) {\n+                    continue;\n+                }\n+                if (IGNORED == isIgnored) {\n+                    List<FastIgnoreRule> remainingRules = new ArrayList<>();\n+                    boolean done = false;\n+                    for (FastIgnoreRule rule : ignoreNode.getRules()) {\n+                        if (!rule.getResult() || !isMatch(rule, nestedPath)) {\n+                            // If this rule has nothing to do with the path to remove / it is a negated rule, we keep it.\n+                            remainingRules.add(rule);\n+                            continue;\n+                        } else if (rule.toString().equals(nestedPath)) {\n+                            // If this rule is an exact match to the path to remove, we remove it.\n+                            continue;\n+                        } else if (isMatch(rule, nestedPath)) {\n+                            // If this rule is a directory match, we need to negate the rule for the given path.\n+                            remainingRules.add(rule);\n+                            // If it's already negated by another rule encountered before, we do not need to add another negation.\n+                            if (!done) {\n+                                remainingRules.add(new FastIgnoreRule(\"!\" + nestedPath));\n+                                done = true;\n+                            }\n+                            continue;\n+                        }\n+                        // If we still have the rule, we keep it. --> not making changes to an unknown flow.\n+                        remainingRules.add(rule);\n+                    }\n+                    IgnoreNode replacedNode = new IgnoreNode(remainingRules);\n+                    rules.put(impactingFile, replacedNode);\n+                    if (CHECK_PARENT == isIgnored(replacedNode, nestedPath)) {\n+                        continue;\n+                    }\n+                }\n+                // There is already an ignore rule for the path, so not needed to check parent rules.\n+                break;\n+            }\n+        }\n+\n+        public void addGitignoreFile(PlainText text) throws IOException {\n+            String gitignoreFileName = text.getSourcePath().toString();\n+            gitignoreFileName = gitignoreFileName.startsWith(\"/\") ? gitignoreFileName : \"/\" + gitignoreFileName;\n+            IgnoreNode ignoreNode = new IgnoreNode();\n+            ignoreNode.parse(gitignoreFileName, new ByteArrayInputStream(text.getText().getBytes()));\n+            rules.put(gitignoreFileName.substring(0, gitignoreFileName.lastIndexOf(\"/\") + 1), ignoreNode);\n+        }\n+\n+        // We do not use jgit's IgnoreNode#isIgnored method because it does not handle the directory correct always.\n+        // See the difference between rule.isMatch in the pathMatch parameter.\n+        private boolean isMatch(FastIgnoreRule rule, String path) {\n+            String rulePath = rule.toString();\n+            if (rulePath.startsWith(\"!\")) {\n+                rulePath = rulePath.substring(1);\n+            }\n+            if (rule.dirOnly() && path.contains(rulePath)) {\n+                return rule.isMatch(path, true, false);\n+            }\n+            return rule.isMatch(path, true, true);\n+        }\n+\n+        private IgnoreNode.MatchResult isIgnored(IgnoreNode ignoreNode, String path) {\n+            IgnoreNode.MatchResult isIgnored = CHECK_PARENT;\n+            for (int i = ignoreNode.getRules().size() - 1; i > -1; i--) {\n+                FastIgnoreRule rule = ignoreNode.getRules().get(i);\n+                if (isMatch(rule, path)) {\n+                    if (rule.getResult()) {\n+                        isIgnored = IGNORED;\n+                    } else {\n+                        return NOT_IGNORED;\n+                    }\n+                }\n+            }\n+            return isIgnored;\n+        }\n+    }\n+}\n",
    "test_patch": "diff --git a/rewrite-core/src/test/java/org/openrewrite/ExcludeFileFromGitignoreTest.java b/rewrite-core/src/test/java/org/openrewrite/ExcludeFileFromGitignoreTest.java\nnew file mode 100644\nindex 00000000000..f77137e5af7\n--- /dev/null\n+++ b/rewrite-core/src/test/java/org/openrewrite/ExcludeFileFromGitignoreTest.java\n@@ -0,0 +1,382 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.test.RewriteTest;\n+\n+import java.util.List;\n+\n+import static org.openrewrite.test.SourceSpecs.text;\n+\n+class ExcludeFileFromGitignoreTest implements RewriteTest {\n+\n+    @DocumentExample\n+    @Test\n+    void removesEntryIfExactPathMatch() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"test.yml\"))),\n+          text(\n+            \"\"\"\n+              /test.yml\n+              \"\"\",\n+            \"\"\"\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addNegationIfFileNameMatch() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"test.yml\"))),\n+          text(\n+            \"\"\"\n+              test.yml\n+              \"\"\",\n+            \"\"\"\n+              test.yml\n+              !/test.yml\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addNegationIfNestedFileNameMatch() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/test.yml\"))),\n+          text(\n+            \"\"\"\n+              test.yml\n+              \"\"\",\n+            \"\"\"\n+              test.yml\n+              !/directory/test.yml\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void commentsAndEmptyLinesUntouched() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/test.yml\"))),\n+          text(\n+            \"\"\"\n+              # comment\n+              \n+              test.yml\n+              \"\"\",\n+            \"\"\"\n+              # comment\n+              \n+              test.yml\n+              !/directory/test.yml\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void looksInNestedGitignoreFiles() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/test.yml\"))),\n+          text(\n+            \"\"\"\n+              test.yml\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          ),\n+          text(\n+            \"\"\"\n+              test.yml\n+              \"\"\",\n+            \"\"\"\n+              test.yml\n+              !/test.yml\n+              \"\"\",\n+            spec -> spec.path(\"directory/.gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void removesInNestedGitignoreFiles() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/test.yml\"))),\n+          text(\n+            \"\"\"\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          ),\n+          text(\n+            \"\"\"\n+              /test.yml\n+              \"\"\",\n+            \"\"\"\n+              \"\"\",\n+            spec -> spec.path(\"directory/.gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void recursivelyLooksInNestedGitignoreFiles() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/test.yml\"))),\n+          text(\n+            \"\"\"\n+              test.yml\n+              \"\"\",\n+            \"\"\"\n+              test.yml\n+              !/directory/test.yml\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          ),\n+          text(\n+            \"\"\"\n+              /test.yml\n+              \"\"\",\n+            \"\"\"\n+              \"\"\",\n+            spec -> spec.path(\"directory/.gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void nothingToRemoveIfPathNotInGitignore() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/test.yml\"))),\n+          text(\n+            \"\"\"\n+              otherfile.yml\n+              otherdirectory/test.yml\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          ),\n+          text(\n+            \"\"\"\n+              otherfile.yml\n+              \"\"\",\n+            spec -> spec.path(\"directory/.gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void multiplePaths() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\n+            \"directory/test.yml\",\n+            \"otherdirectory/otherfile.yml\",\n+            \"directory/nested/not-ignored.yml\"))),\n+          text(\n+            \"\"\"\n+              test.yml\n+              /otherdirectory/otherfile.yml\n+              \"\"\",\n+            \"\"\"\n+              test.yml\n+              !/directory/test.yml\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void negateFileFromIgnoredDirectory() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/test.yml\"))),\n+          text(\n+            \"\"\"\n+              /directory/\n+              \"\"\",\n+            \"\"\"\n+              /directory/\n+              !/directory/test.yml\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void ignoredExactDirectories() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/\"))),\n+          text(\n+            \"\"\"\n+              /directory/\n+              \"\"\",\n+            \"\"\"\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void ignoredDirectories() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/\"))),\n+          text(\n+            \"\"\"\n+              directory/\n+              \"\"\",\n+            \"\"\"\n+              directory/\n+              !/directory/\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void ignoreNestedDirectory() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/nested/\"))),\n+          text(\n+            \"\"\"\n+              /directory/\n+              \"\"\",\n+            \"\"\"\n+              /directory/\n+              !/directory/nested/\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void ignoreNestedDirectoryWithMultipleGitignoreFiles() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/nested/yet-another-nested/test.yml\"))),\n+          text(\n+            \"\"\"\n+              otherfile.yml\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          ),\n+          text(\n+            \"\"\"\n+              /yet-another-nested/\n+              \"\"\",\n+            \"\"\"\n+              /yet-another-nested/\n+              !/yet-another-nested/test.yml\n+              \"\"\",\n+            spec -> spec.path(\"directory/nested/.gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void ignoreWildcardedDirectory() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/nested/\"))),\n+          text(\n+            \"\"\"\n+              /**/nested/\n+              \"\"\",\n+            \"\"\"\n+              /**/nested/\n+              !/directory/nested/\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void ignoreWildcardedFile() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"directory/test.yml\", \"directory/other.txt\"))),\n+          text(\n+            \"\"\"\n+              /test.*\n+              /*.txt\n+              \"\"\",\n+            \"\"\"\n+              /test.*\n+              !/test.yml\n+              /*.txt\n+              !/other.txt\n+              \"\"\",\n+            spec -> spec.path(\"directory/.gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void excludedPathsOnlyGetAddedOnce() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"nested/test.yml\"))),\n+          text(\n+            \"\"\"\n+              test.yml\n+              otherfile.yml\n+              nested/test.yml\n+              \"\"\",\n+            \"\"\"\n+              test.yml\n+              !/nested/test.yml\n+              otherfile.yml\n+              nested/test.yml\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void newRulesGetAddedBesidesExistingRules() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ExcludeFileFromGitignore(List.of(\"/test.yml\", \"/otherfile.yml\", \"end-of-file/file.yml\"))),\n+          text(\n+            \"\"\"\n+              # comment 1\n+              test.yml\n+              /yet-another-file.yml\n+              # comment 2\n+              /otherfile.yml\n+              # comment 3\n+              end-of-file/file.yml\n+              \"\"\",\n+            \"\"\"\n+              # comment 1\n+              test.yml\n+              !/test.yml\n+              /yet-another-file.yml\n+              # comment 2\n+              # comment 3\n+              end-of-file/file.yml\n+              !/end-of-file/file.yml\n+              \"\"\",\n+            spec -> spec.path(\".gitignore\")\n+          )\n+        );\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4602",
    "pr_id": 4602,
    "issue_id": 1297,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Support Lombok Annotations\n`org.openrewrite.java.cleanup.ExplicitInitialization` and `org.openrewrite.java.cleanup.UseDiamondOperator` removes the argument type when it's a lombok.val variable.\r\n\r\n`val products = new ArrayList<Product>();`\r\n\r\n`val products = new ArrayList<>();`\r\n\r\nwhich is incorrect and doesn't compile anymore.",
    "issue_word_count": 42,
    "test_files_count": 7,
    "non_test_files_count": 27,
    "pr_changed_files": [
      "IDE.properties.tmp",
      "rewrite-java-17/build.gradle.kts",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17Parser.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java",
      "rewrite-java-lombok/build.gradle.kts",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/AllArgsConstructorHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/CleanupNoOpHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/ExtensionMethodHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/GetterHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/HelperHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/JacksonizedHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/LockedNoOpHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/LockedReadNoOpHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/LockedWriteNoOpHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NoArgsConstructorHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NonNullNoOpHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/OpenRewriteConfigurationKeysLoader.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/RequiredArgsConstructorHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SetterHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SneakyThrowsNoOpHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SynchronizedNoOpHandler.java",
      "rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/package-info.java",
      "rewrite-java-lombok/src/main/resources/META-INF/services/lombok.core.configuration.ConfigurationKeysLoader",
      "rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/JavaParserTypeMappingTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/VariableDeclarationsTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/format/SpacesTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/search/SemanticallyEqualTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/JavaUnrestrictedClassLoader.java",
      "rewrite-java/src/test/java/org/openrewrite/java/OpenRewriteArchitectureTest.java",
      "settings.gradle.kts"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/JavaParserTypeMappingTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/VariableDeclarationsTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/format/SpacesTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/search/SemanticallyEqualTest.java",
      "rewrite-java/src/test/java/org/openrewrite/java/OpenRewriteArchitectureTest.java"
    ],
    "base_commit": "11cb9db10a9c703f266bff2a537759793da1ab13",
    "head_commit": "8dfacf46ae49305b7389a6ee1d8b1ea77ee2a0de",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4602",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4602",
    "dockerfile": "",
    "pr_merged_at": "2024-11-05T08:51:33.000Z",
    "patch": "diff --git a/IDE.properties.tmp b/IDE.properties.tmp\nindex 154b6a0af1d..bbd4e3ee763 100644\n--- a/IDE.properties.tmp\n+++ b/IDE.properties.tmp\n@@ -18,6 +18,7 @@ rewrite-test\n # language parser.\n \n rewrite-java\n+rewrite-java-lombok\n rewrite-java-test\n rewrite-java-tck\n rewrite-java-17\n\ndiff --git a/rewrite-java-17/build.gradle.kts b/rewrite-java-17/build.gradle.kts\nindex e95a2005b7a..20e369417d1 100644\n--- a/rewrite-java-17/build.gradle.kts\n+++ b/rewrite-java-17/build.gradle.kts\n@@ -14,6 +14,7 @@ val javaTck = configurations.create(\"javaTck\") {\n dependencies {\n     api(project(\":rewrite-core\"))\n     api(project(\":rewrite-java\"))\n+    runtimeOnly(project(\":rewrite-java-lombok\"))\n \n     compileOnly(\"org.slf4j:slf4j-api:1.7.+\")\n \n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17Parser.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17Parser.java\nindex 75d9a2509f6..6e19b20747b 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17Parser.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17Parser.java\n@@ -21,10 +21,12 @@\n import com.sun.tools.javac.comp.Modules;\n import com.sun.tools.javac.file.JavacFileManager;\n import com.sun.tools.javac.main.JavaCompiler;\n+import com.sun.tools.javac.main.Option;\n import com.sun.tools.javac.tree.JCTree;\n import com.sun.tools.javac.util.Context;\n import com.sun.tools.javac.util.Log;\n import com.sun.tools.javac.util.Options;\n+import lombok.Getter;\n import org.jspecify.annotations.NullMarked;\n import org.jspecify.annotations.Nullable;\n import org.objectweb.asm.ClassReader;\n@@ -33,7 +35,6 @@\n import org.openrewrite.ExecutionContext;\n import org.openrewrite.InMemoryExecutionContext;\n import org.openrewrite.SourceFile;\n-import org.openrewrite.internal.StringUtils;\n import org.openrewrite.java.JavaParser;\n import org.openrewrite.java.JavaParsingException;\n import org.openrewrite.java.internal.JavaTypeCache;\n@@ -43,12 +44,16 @@\n import org.openrewrite.tree.ParseError;\n import org.openrewrite.tree.ParsingEventListener;\n import org.openrewrite.tree.ParsingExecutionContextView;\n+import org.slf4j.LoggerFactory;\n \n+import javax.annotation.processing.Processor;\n import javax.tools.JavaFileManager;\n import javax.tools.JavaFileObject;\n import javax.tools.SimpleJavaFileObject;\n import javax.tools.StandardLocation;\n import java.io.*;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n import java.net.URI;\n import java.nio.charset.Charset;\n import java.nio.file.Path;\n@@ -57,6 +62,7 @@\n import java.util.stream.Stream;\n import java.util.stream.StreamSupport;\n \n+import static java.util.Collections.emptyList;\n import static java.util.stream.Collectors.toList;\n \n /**\n@@ -77,14 +83,16 @@ public class ReloadableJava17Parser implements JavaParser {\n     private final JavaCompiler compiler;\n     private final ResettableLog compilerLog;\n     private final Collection<NamedStyles> styles;\n-\n-    private ReloadableJava17Parser(boolean logCompilationWarningsAndErrors,\n-                                   @Nullable Collection<Path> classpath,\n-                                   Collection<byte[]> classBytesClasspath,\n-                                   @Nullable Collection<Input> dependsOn,\n-                                   Charset charset,\n-                                   Collection<NamedStyles> styles,\n-                                   JavaTypeCache typeCache) {\n+    private final List<Processor> annotationProcessors;\n+\n+    private ReloadableJava17Parser(\n+            boolean logCompilationWarningsAndErrors,\n+            @Nullable Collection<Path> classpath,\n+            Collection<byte[]> classBytesClasspath,\n+            @Nullable Collection<Input> dependsOn,\n+            Charset charset,\n+            Collection<NamedStyles> styles,\n+            JavaTypeCache typeCache) {\n         this.classpath = classpath;\n         this.dependsOn = dependsOn;\n         this.styles = styles;\n@@ -106,6 +114,58 @@ private ReloadableJava17Parser(boolean logCompilationWarningsAndErrors,\n         Options.instance(context).put(\"-g\", \"-g\");\n         Options.instance(context).put(\"-proc\", \"none\");\n \n+        if (classpath != null && classpath.stream().anyMatch(it -> it.toString().contains(\"lombok\"))) {\n+            try {\n+                // https://projectlombok.org/contributing/lombok-execution-path\n+                String systemClasspath = System.getProperty(\"java.class.path\");\n+                if (systemClasspath != null && !systemClasspath.isEmpty()) {\n+                    List<String> overrideClasspath = new ArrayList<>();\n+                    for (String part : systemClasspath.split(\"\\\\s*\" + (File.pathSeparatorChar == ';' ? \";\" : \":\") + \"\\\\s*\")) {\n+                        if (part.contains(\"lombok\")) {\n+                            overrideClasspath.add(part);\n+                        }\n+                    }\n+                    // make sure the rewrite-java-lombok dependency comes first\n+                    boolean found = false;\n+                    for (int i = 0; i < overrideClasspath.size(); i++) {\n+                        if (overrideClasspath.get(i).contains(\"rewrite-java-lombok\")) {\n+                            overrideClasspath.add(0, overrideClasspath.remove(i));\n+                            found = true;\n+                        }\n+                    }\n+                    if (!found) {\n+                        throw new IllegalStateException(\"Unable to enable lombok annotation processing, rewrite-java-lombok not found in classpath\");\n+                    }\n+                    System.setProperty(\"shadow.override.lombok\", String.join(File.pathSeparator, overrideClasspath));\n+                }\n+\n+                Class<?> shadowLoaderClass = Class.forName(\"lombok.launch.ShadowClassLoader\", true, getClass().getClassLoader());\n+                Constructor<?> shadowLoaderConstructor = shadowLoaderClass.getDeclaredConstructor(\n+                        Class.forName(\"java.lang.ClassLoader\"),\n+                        Class.forName(\"java.lang.String\"),\n+                        Class.forName(\"java.lang.String\"),\n+                        Class.forName(\"java.util.List\"),\n+                        Class.forName(\"java.util.List\"));\n+                shadowLoaderConstructor.setAccessible(true);\n+\n+                ClassLoader lombokShadowLoader = (ClassLoader) shadowLoaderConstructor.newInstance(\n+                        getClass().getClassLoader(),\n+                        \"lombok\",\n+                        null,\n+                        emptyList(),\n+                        Collections.singletonList(\"lombok.patcher.Symbols\")\n+                );\n+                Processor lombokProcessor = (Processor) lombokShadowLoader.loadClass(\"lombok.core.AnnotationProcessor\").getDeclaredConstructor().newInstance();\n+                annotationProcessors = Collections.singletonList(lombokProcessor);\n+                Options.instance(context).put(Option.PROCESSOR, \"lombok.launch.AnnotationProcessorHider$AnnotationProcessor\");\n+            } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException |\n+                     InvocationTargetException e) {\n+                throw new RuntimeException(e);\n+            }\n+        } else {\n+            annotationProcessors = emptyList();\n+        }\n+\n         // MUST be created (registered with the context) after pfm and compilerLog\n         compiler = new JavaCompiler(context);\n \n@@ -124,7 +184,7 @@ public void write(char[] cbuf, int off, int len) {\n                 if (logCompilationWarningsAndErrors) {\n                     String log = new String(Arrays.copyOfRange(cbuf, off, len));\n                     if (!log.isBlank()) {\n-                        org.slf4j.LoggerFactory.getLogger(ReloadableJava17Parser.class).warn(log);\n+                        LoggerFactory.getLogger(ReloadableJava17Parser.class).warn(log);\n                     }\n                 }\n             }\n@@ -164,6 +224,7 @@ public Stream<SourceFile> parseInputs(Iterable<Input> sourceFiles, @Nullable Pat\n                 );\n \n                 J.CompilationUnit cu = (J.CompilationUnit) parser.scan(cuByPath.getValue(), Space.EMPTY);\n+                //noinspection DataFlowIssue\n                 cuByPath.setValue(null); // allow memory used by this JCCompilationUnit to be released\n                 parsingListener.parsed(input, cu);\n                 return requirePrintEqualsInput(cu, input, relativeTo, ctx);\n@@ -188,39 +249,46 @@ LinkedHashMap<Input, JCTree.JCCompilationUnit> parseInputsToCompilerAst(Iterable\n         }\n \n         LinkedHashMap<Input, JCTree.JCCompilationUnit> cus = new LinkedHashMap<>();\n-        acceptedInputs(sourceFiles).forEach(input1 -> {\n+        List<ReloadableJava17ParserInputFileObject> inputFileObjects = acceptedInputs(sourceFiles)\n+                .map(input -> new ReloadableJava17ParserInputFileObject(input, ctx))\n+                .toList();\n+        if (!annotationProcessors.isEmpty()) {\n+            compiler.initProcessAnnotations(annotationProcessors, inputFileObjects, emptyList());\n+        }\n+        try {\n+            //noinspection unchecked\n+            com.sun.tools.javac.util.List<JCTree.JCCompilationUnit> jcCompilationUnits = compiler.parseFiles((List<JavaFileObject>) (List<?>) inputFileObjects, true);\n+            for (int i = 0; i < inputFileObjects.size(); i++) {\n+                cus.put(inputFileObjects.get(i).getInput(), jcCompilationUnits.get(i));\n+            }\n             try {\n-                JCTree.JCCompilationUnit jcCompilationUnit = compiler.parse(new ReloadableJava17ParserInputFileObject(input1, ctx));\n-                cus.put(input1, jcCompilationUnit);\n-            } catch (IllegalStateException e) {\n-                if (\"endPosTable already set\".equals(e.getMessage())) {\n-                    throw new IllegalStateException(\n-                            \"Call reset() on JavaParser before parsing another set of source files that \" +\n-                            \"have some of the same fully qualified names. Source file [\" +\n-                            input1.getPath() + \"]\\n[\\n\" + StringUtils.readFully(input1.getSource(ctx), getCharset(ctx)) + \"\\n]\", e);\n+                initModules(cus.values());\n+                enterAll(cus.values());\n+\n+                // For some reason this is necessary in JDK 9+, where the internal block counter that\n+                // annotationsBlocked() tests against remains >0 after attribution.\n+                Annotate annotate = Annotate.instance(context);\n+                while (annotate.annotationsBlocked()) {\n+                    annotate.unblockAnnotations(); // also flushes once unblocked\n+                }\n+                if (!annotationProcessors.isEmpty()) {\n+                    compiler.processAnnotations(jcCompilationUnits, emptyList());\n                 }\n-                throw e;\n+                compiler.attribute(compiler.todo);\n+            } catch (Throwable t) {\n+                // when symbol entering fails on problems like missing types, attribution can often times proceed\n+                // unhindered, but it sometimes cannot (so attribution is always best-effort in the presence of errors)\n+                ctx.getOnError().accept(new JavaParsingException(\"Failed symbol entering or attribution\", t));\n             }\n-        });\n-\n-        try {\n-            initModules(cus.values());\n-            enterAll(cus.values());\n-\n-            // For some reason this is necessary in JDK 9+, where the internal block counter that\n-            // annotationsBlocked() tests against remains >0 after attribution.\n-            Annotate annotate = Annotate.instance(context);\n-            while (annotate.annotationsBlocked()) {\n-                annotate.unblockAnnotations(); // also flushes once unblocked\n+        } catch (IllegalStateException e) {\n+            if (\"endPosTable already set\".equals(e.getMessage())) {\n+                throw new IllegalStateException(\n+                        \"Call reset() on JavaParser before parsing another set of source files that \" +\n+                        \"have some of the same fully qualified names.\", e);\n             }\n-\n-            compiler.attribute(compiler.todo);\n-        } catch (\n-                Throwable t) {\n-            // when symbol entering fails on problems like missing types, attribution can often times proceed\n-            // unhindered, but it sometimes cannot (so attribution is always best-effort in the presence of errors)\n-            ctx.getOnError().accept(new JavaParsingException(\"Failed symbol entering or attribution\", t));\n+            throw e;\n         }\n+\n         return cus;\n     }\n \n@@ -333,9 +401,9 @@ public Iterable<JavaFileObject> list(Location location, String packageName, Set<\n                 Iterable<JavaFileObject> listed = super.list(location, packageName, kinds, recurse);\n                 return classByteClasspath.isEmpty() ? listed :\n                         Stream.concat(classByteClasspath.stream()\n-                                .filter(jfo -> jfo.getPackage().equals(packageName)),\n-                        StreamSupport.stream(listed.spliterator(), false)\n-                ).collect(toList());\n+                                        .filter(jfo -> jfo.getPackage().equals(packageName)),\n+                                StreamSupport.stream(listed.spliterator(), false)\n+                        ).collect(toList());\n             }\n             return super.list(location, packageName, kinds, recurse);\n         }\n@@ -343,6 +411,7 @@ public Iterable<JavaFileObject> list(Location location, String packageName, Set<\n \n     private static class PackageAwareJavaFileObject extends SimpleJavaFileObject {\n         private final String pkg;\n+        @Getter\n         private final String className;\n         private final byte[] classBytes;\n \n@@ -376,10 +445,6 @@ public String getPackage() {\n             return pkg;\n         }\n \n-        public String getClassName() {\n-            return className;\n-        }\n-\n         @Override\n         public InputStream openInputStream() {\n             return new ByteArrayInputStream(classBytes);\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex e9d67d54a6d..25b78628c07 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -19,6 +19,7 @@\n import com.sun.source.doctree.DocCommentTree;\n import com.sun.source.tree.*;\n import com.sun.source.util.TreePathScanner;\n+import com.sun.tools.javac.code.Attribute;\n import com.sun.tools.javac.code.Flags;\n import com.sun.tools.javac.code.Symbol;\n import com.sun.tools.javac.tree.DocCommentTable;\n@@ -426,7 +427,7 @@ public J visitClass(ClassTree node, Space fmt) {\n         }\n \n         JLeftPadded<TypeTree> extendings = node.getExtendsClause() == null ? null :\n-                padLeft(sourceBefore(\"extends\"), convertOrNull(node.getExtendsClause()));\n+                padLeft(sourceBefore(\"extends\"), convert(node.getExtendsClause()));\n \n         JContainer<TypeTree> implementings = null;\n         if (node.getImplementsClause() != null && !node.getImplementsClause().isEmpty()) {\n@@ -690,7 +691,7 @@ public J visitForLoop(ForLoopTree node, Space fmt) {\n                                 commaDelim.apply(t)\n                 );\n \n-        JRightPadded<Expression> condition = convertOrNull(node.getCondition(), semiDelim);\n+        JRightPadded<Expression> condition = convert(node.getCondition(), semiDelim);\n         if (condition == null) {\n             condition = padRight(new J.Empty(randomId(), sourceBefore(\";\"), Markers.EMPTY), EMPTY);\n         }\n@@ -961,7 +962,7 @@ public J visitMethod(MethodTree node, Space fmt) {\n         }\n \n         List<J.Annotation> returnTypeAnnotations = collectAnnotations(annotationPosTable);\n-        TypeTree returnType = convertOrNull(node.getReturnType());\n+        TypeTree returnType = convert(node.getReturnType());\n         if (returnType != null && !returnTypeAnnotations.isEmpty()) {\n             returnType = new J.AnnotatedType(randomId(), Space.EMPTY, Markers.EMPTY,\n                     returnTypeAnnotations, returnType);\n@@ -1008,7 +1009,7 @@ public J visitMethod(MethodTree node, Space fmt) {\n                 JContainer.build(sourceBefore(\"throws\"), convertAll(node.getThrows(), commaDelim, noDelim),\n                         Markers.EMPTY);\n \n-        J.Block body = convertOrNull(node.getBody());\n+        J.Block body = convert(node.getBody());\n \n         JLeftPadded<Expression> defaultValue = node.getDefaultValue() == null ? null :\n                 padLeft(sourceBefore(\"default\"), convert(node.getDefaultValue()));\n@@ -1034,9 +1035,9 @@ public J visitNewArray(NewArrayTree node, Space fmt) {\n             while (elementType instanceof JCArrayTypeTree) {\n                 elementType = ((JCArrayTypeTree) elementType).elemtype;\n             }\n-            typeExpr = convertOrNull(elementType);\n+            typeExpr = convert(elementType);\n         } else {\n-            typeExpr = convertOrNull(jcVarType);\n+            typeExpr = convert(jcVarType);\n         }\n \n         List<? extends ExpressionTree> nodeDimensions = node.getDimensions();\n@@ -1086,7 +1087,7 @@ public J visitNewClass(NewClassTree node, Space fmt) {\n         }\n \n         // for enum definitions with anonymous class initializers, endPos of node identifier will be -1\n-        TypeTree clazz = endPos(node.getIdentifier()) >= 0 ? convertOrNull(node.getIdentifier()) : null;\n+        TypeTree clazz = endPos(node.getIdentifier()) >= 0 ? convert(node.getIdentifier()) : null;\n \n         JContainer<Expression> args;\n         if (positionOfNext(\"(\", '{') > -1) {\n@@ -1195,7 +1196,7 @@ public J visitPrimitiveType(PrimitiveTypeTree node, Space fmt) {\n     @Override\n     public J visitReturn(ReturnTree node, Space fmt) {\n         skip(\"return\");\n-        Expression expression = convertOrNull(node.getExpression());\n+        Expression expression = convert(node.getExpression());\n         return new J.Return(randomId(), fmt, Markers.EMPTY, expression);\n     }\n \n@@ -1544,8 +1545,14 @@ private J.VariableDeclarations visitVariables(List<VariableTree> nodes, Space fm\n                 // this is a lambda parameter with an inferred type expression\n                 typeExpr = null;\n             } else {\n-                typeExpr = new J.Identifier(randomId(), sourceBefore(\"var\"), Markers.EMPTY, emptyList(), \"var\", typeMapping.type(vartype), null);\n-                typeExpr = typeExpr.withMarkers(typeExpr.getMarkers().add(JavaVarKeyword.build()));\n+                boolean lombokVal = isLombokVal(node);\n+                typeExpr = new J.Identifier(randomId(),\n+                        sourceBefore(lombokVal ? \"val\" : \"var\"),\n+                        Markers.build(singletonList(JavaVarKeyword.build())),\n+                        emptyList(),\n+                        lombokVal ? \"val\" : \"var\",\n+                        typeMapping.type(vartype),\n+                        null);\n             }\n         } else if (vartype instanceof JCArrayTypeTree) {\n             JCExpression elementType = vartype;\n@@ -1565,6 +1572,10 @@ private J.VariableDeclarations visitVariables(List<VariableTree> nodes, Space fm\n             typeExpr = convert(vartype);\n         }\n \n+        if (typeExpr == null && node.declaredUsingVar()) {\n+            typeExpr = new J.Identifier(randomId(), sourceBefore(\"var\"), Markers.build(singletonList(JavaVarKeyword.build())), emptyList(), \"var\", typeMapping.type(vartype), null);\n+        }\n+\n         if (typeExpr != null && !typeExprAnnotations.isEmpty()) {\n             Space prefix = typeExprAnnotations.get(0).getPrefix();\n             typeExpr = new J.AnnotatedType(randomId(), prefix, Markers.EMPTY, ListUtils.mapFirst(typeExprAnnotations, a -> a.withPrefix(EMPTY)), typeExpr);\n@@ -1598,7 +1609,7 @@ private J.VariableDeclarations visitVariables(List<VariableTree> nodes, Space fm\n                             new J.VariableDeclarations.NamedVariable(randomId(), namedVarPrefix, Markers.EMPTY,\n                                     name,\n                                     dimensionsAfterName,\n-                                    n.init != null ? padLeft(sourceBefore(\"=\"), convertOrNull(n.init)) : null,\n+                                    n.init != null ? padLeft(sourceBefore(\"=\"), convert(n.init)) : null,\n                                     (JavaType.Variable) typeMapping.type(n)\n                             ),\n                             i == nodes.size() - 1 ? EMPTY : sourceBefore(\",\")\n@@ -1655,7 +1666,7 @@ public J visitWildcard(WildcardTree node, Space fmt) {\n                 bound = null;\n         }\n \n-        return new J.Wildcard(randomId(), fmt, Markers.EMPTY, bound, convertOrNull(wildcard.inner));\n+        return new J.Wildcard(randomId(), fmt, Markers.EMPTY, bound, convert(wildcard.inner));\n     }\n \n     /**\n@@ -1663,10 +1674,12 @@ public J visitWildcard(WildcardTree node, Space fmt) {\n      * Conversion utilities\n      * --------------\n      */\n-\n-    private <J2 extends J> J2 convert(Tree t) {\n+    private <J2 extends J> @Nullable J2 convert(@Nullable Tree t) {\n+        if (t == null) {\n+            return null;\n+        }\n         try {\n-            String prefix = source.substring(cursor, max(((JCTree) t).getStartPosition(), cursor));\n+            String prefix = source.substring(cursor, Math.max(cursor, getActualStartPosition((JCTree) t)));\n             cursor += prefix.length();\n             // Java 21 and 23 have a different return type from getCommentTree; with reflection we can support both\n             Method getCommentTreeMethod = DocCommentTable.class.getMethod(\"getCommentTree\", JCTree.class);\n@@ -1682,6 +1695,14 @@ private <J2 extends J> J2 convert(Tree t) {\n         }\n     }\n \n+    private static int getActualStartPosition(JCTree t) {\n+        // not sure if this is a bug in Lombok, but the variable's start position is after the `val` annotation\n+        if (t instanceof JCVariableDecl && isLombokVal((JCVariableDecl) t)) {\n+            return ((JCVariableDecl) t).mods.annotations.get(0).getStartPosition();\n+        }\n+        return t.getStartPosition();\n+    }\n+\n     private void reportJavaParsingException(Throwable ex) {\n         // this SHOULD never happen, but is here simply as a diagnostic measure in the event of unexpected exceptions\n         StringBuilder message = new StringBuilder(\"Failed to convert for the following cursor stack:\");\n@@ -1706,10 +1727,12 @@ private void reportJavaParsingException(Throwable ex) {\n         ctx.getOnError().accept(new JavaParsingException(message.toString(), ex));\n     }\n \n-    private <J2 extends J> JRightPadded<J2> convert(Tree t, Function<Tree, Space> suffix) {\n+    private <J2 extends @Nullable J> @Nullable JRightPadded<J2> convert(@Nullable Tree t, Function<Tree, Space> suffix) {\n+        if (t == null) {\n+            return null;\n+        }\n         J2 j = convert(t);\n-        @SuppressWarnings(\"ConstantConditions\") JRightPadded<J2> rightPadded = j == null ? null :\n-                new JRightPadded<>(j, suffix.apply(t), Markers.EMPTY);\n+        JRightPadded<J2> rightPadded = new JRightPadded<>(j, suffix.apply(t), Markers.EMPTY);\n         cursor(max(endPos(t), cursor)); // if there is a non-empty suffix, the cursor may have already moved past it\n         return rightPadded;\n     }\n@@ -1718,14 +1741,6 @@ private long lineNumber(Tree tree) {\n         return source.substring(0, ((JCTree) tree).getStartPosition()).chars().filter(c -> c == '\\n').count() + 1;\n     }\n \n-    private <T extends J> @Nullable T convertOrNull(@Nullable Tree t) {\n-        return t == null ? null : convert(t);\n-    }\n-\n-    private <J2 extends J> @Nullable JRightPadded<J2> convertOrNull(@Nullable Tree t, Function<Tree, Space> suffix) {\n-        return t == null ? null : convert(t, suffix);\n-    }\n-\n     private <J2 extends J> List<J2> convertAll(List<? extends Tree> trees) {\n         List<J2> converted = new ArrayList<>(trees.size());\n         for (Tree tree : trees) {\n@@ -1805,6 +1820,9 @@ private List<JRightPadded<Statement>> convertStatements(@Nullable List<? extends\n \n         Map<Integer, List<Tree>> treesGroupedByStartPosition = new LinkedHashMap<>();\n         for (Tree t : trees) {\n+            if (isLombokGenerated(t)) {\n+                continue;\n+            }\n             treesGroupedByStartPosition.computeIfAbsent(((JCTree) t).getStartPosition(), k -> new ArrayList<>(1)).add(t);\n         }\n \n@@ -1830,6 +1848,53 @@ private List<JRightPadded<Statement>> convertStatements(@Nullable List<? extends\n         return converted;\n     }\n \n+    private static boolean isLombokVal(JCTree.JCVariableDecl t) {\n+        if (t.sym != null && t.sym.getMetadata() != null) {\n+            for (Attribute.Compound a : t.sym.getDeclarationAttributes()) {\n+                if (\"lombok.val\".equals(a.type.toString())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean isLombokGenerated(Tree t) {\n+        Symbol sym = null;\n+        if (t instanceof JCAnnotation) {\n+            t = ((JCAnnotation) t).getAnnotationType();\n+        }\n+        if (t instanceof JCIdent) {\n+            sym = ((JCIdent) t).sym;\n+        } else if (t instanceof JCTree.JCMethodDecl) {\n+            sym = ((JCMethodDecl) t).sym;\n+        } else if (t instanceof JCTree.JCClassDecl) {\n+            sym = ((JCClassDecl) t).sym;\n+        } else if (t instanceof JCTree.JCVariableDecl) {\n+            sym = ((JCVariableDecl) t).sym;\n+        }\n+        return isLombokGenerated(sym);\n+    }\n+\n+    private static boolean isLombokGenerated(@Nullable Symbol sym) {\n+        if (sym == null) {\n+            return false;\n+        }\n+        // Lombok val is represented as a @lombok.val on a \"final\" modifier, neither which appear in source\n+        if (\"lombok.val\".equals(sym.getQualifiedName().toString())) {\n+            return true;\n+        }\n+        if (sym.getMetadata() == null) {\n+            return false;\n+        }\n+        for (Attribute.Compound a : sym.getDeclarationAttributes()) {\n+            if (\"lombok.Generated\".equals(a.type.toString())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * --------------\n      * Other convenience utilities\n@@ -2006,13 +2071,18 @@ private ReloadableJava17ModifierResults sortedModifiersAndAnnotations(ModifiersT\n         int keywordStartIdx = -1;\n         for (int i = cursor; i < source.length(); i++) {\n             if (annotationPosTable.containsKey(i)) {\n-                J.Annotation annotation = convert(annotationPosTable.get(i));\n+                JCAnnotation jcAnnotation = annotationPosTable.get(i);\n+                // Skip over lombok's \"@val\" annotation which does not actually appear in source\n+                if (isLombokGenerated(jcAnnotation.getAnnotationType())) {\n+                    continue;\n+                }\n+                J.Annotation annotation = convert(jcAnnotation);\n                 if (afterFirstModifier) {\n                     currentAnnotations.add(annotation);\n                 } else {\n                     leadingAnnotations.add(annotation);\n                 }\n-                i = cursor -1;\n+                i = cursor - 1;\n                 lastAnnotationPosition = cursor;\n                 continue;\n             }\n@@ -2126,7 +2196,11 @@ private List<J.Annotation> collectAnnotations(Map<Integer, JCAnnotation> annotat\n         boolean inMultilineComment = false;\n         for (int i = cursor; i <= maxAnnotationPosition && i < source.length(); i++) {\n             if (annotationPosTable.containsKey(i)) {\n-                annotations.add(convert(annotationPosTable.get(i)));\n+                JCAnnotation jcAnnotation = annotationPosTable.get(i);\n+                if (isLombokGenerated(jcAnnotation)) {\n+                    continue;\n+                }\n+                annotations.add(convert(jcAnnotation));\n                 i = cursor;\n                 continue;\n             }\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java\nindex f94b6e4ae19..e31244cfe59 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java\n@@ -357,12 +357,19 @@ private JavaType.FullyQualified.Kind getKind(Symbol.ClassSymbol sym) {\n             return variableType(((JCTree.JCVariableDecl) tree).sym);\n         } else if (tree instanceof JCTree.JCAnnotatedType && ((JCTree.JCAnnotatedType) tree).getUnderlyingType() instanceof JCTree.JCArrayTypeTree) {\n             return annotatedArray((JCTree.JCAnnotatedType) tree);\n+        } else if (tree instanceof JCTree.JCClassDecl) {\n+            symbol = ((JCTree.JCClassDecl) tree).sym;\n+        } else if (tree instanceof JCTree.JCFieldAccess) {\n+            symbol = ((JCTree.JCFieldAccess) tree).sym;\n         }\n \n         return type(((JCTree) tree).type, symbol);\n     }\n \n-    private @Nullable JavaType type(Type type, Symbol symbol) {\n+    private @Nullable JavaType type(@Nullable Type type, @Nullable Symbol symbol) {\n+        if (type == null && symbol != null) {\n+            type = symbol.type;\n+        }\n         if (type instanceof Type.MethodType) {\n             return methodInvocationType(type, symbol);\n         }\n@@ -405,7 +412,7 @@ public JavaType.Primitive primitive(TypeTag tag) {\n     }\n \n     private JavaType.@Nullable Variable variableType(@Nullable Symbol symbol,\n-            JavaType.@Nullable FullyQualified owner) {\n+                                                     JavaType.@Nullable FullyQualified owner) {\n         if (!(symbol instanceof Symbol.VarSymbol)) {\n             return null;\n         }\n\ndiff --git a/rewrite-java-lombok/build.gradle.kts b/rewrite-java-lombok/build.gradle.kts\nnew file mode 100644\nindex 00000000000..28367692d4a\n--- /dev/null\n+++ b/rewrite-java-lombok/build.gradle.kts\n@@ -0,0 +1,87 @@\n+@file:Suppress(\"UnstableApiUsage\")\n+\n+plugins {\n+    id(\"org.openrewrite.build.language-library\")\n+}\n+\n+// Create the lombok configuration and ensure it extends compileOnly\n+val lombok = configurations.create(\"lombok\")\n+configurations.named(\"compileOnly\").configure {\n+    extendsFrom(lombok)\n+}\n+\n+val unpackedAndRenamedLombokDir = layout.buildDirectory.dir(\"lombok\").get().asFile\n+\n+// Lombok hides its internal classes with a \".SCL.lombok\" extension, so we have to undo that to compile with them\n+tasks.register(\"unpackAndRenameLombok\") {\n+    inputs.files(configurations.getByName(\"lombok\"))\n+    outputs.dir(unpackedAndRenamedLombokDir)\n+    doFirst {\n+        mkdir(unpackedAndRenamedLombokDir)\n+        unpackedAndRenamedLombokDir.listFiles()?.forEach { it.delete() }\n+    }\n+    doLast {\n+        copy {\n+            from(zipTree(configurations.getByName(\"lombok\").singleFile))\n+            into(unpackedAndRenamedLombokDir)\n+            include(\"lombok/**/*\")\n+        }\n+        copy {\n+            from(zipTree(configurations.getByName(\"lombok\").singleFile))\n+            into(unpackedAndRenamedLombokDir)\n+            include(\"SCL.lombok/**/*\")\n+            eachFile {\n+                // Drop the first segment and rename the file\n+                val newSegments = relativePath.segments.drop(1).toTypedArray()\n+                if (newSegments.isNotEmpty() && newSegments.last().endsWith(\".SCL.lombok\")) {\n+                    newSegments[newSegments.size - 1] = newSegments.last().replace(\".SCL.lombok\", \".class\")\n+                }\n+                relativePath = RelativePath(true, *newSegments)\n+            }\n+        }\n+    }\n+}\n+\n+tasks.named(\"compileJava\") {\n+    dependsOn(\"unpackAndRenameLombok\")\n+}\n+\n+val compiler = javaToolchains.compilerFor {\n+    languageVersion.set(JavaLanguageVersion.of(8))\n+}\n+\n+val tools = compiler.get().metadata.installationPath.file(\"lib/tools.jar\")\n+\n+dependencies {\n+    implementation(\"org.jspecify:jspecify:latest.release\")\n+    runtimeOnly(\"org.projectlombok:lombok:latest.release\")\n+\n+    // Add lombok dependency to the newly created lombok configuration\n+    lombok(\"org.projectlombok:lombok:latest.release\")\n+    compileOnly(files(tools))\n+    compileOnly(files(unpackedAndRenamedLombokDir))\n+}\n+\n+java {\n+    toolchain {\n+        languageVersion.set(JavaLanguageVersion.of(8))\n+    }\n+}\n+\n+tasks.withType<JavaCompile>().configureEach {\n+    options.isFork = true\n+    options.release.set(null as? Int?) // remove `--release 8` set in `org.openrewrite.java-base`\n+}\n+\n+tasks.withType<Test>().configureEach {\n+    jvmArgs = listOf(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+ShowHiddenFrames\")\n+    javaLauncher.set(javaToolchains.launcherFor {\n+        languageVersion.set(JavaLanguageVersion.of(8))\n+    })\n+}\n+\n+tasks.withType<Javadoc>().configureEach {\n+    executable = javaToolchains.javadocToolFor {\n+        languageVersion.set(JavaLanguageVersion.of(8))\n+    }.get().executablePath.toString()\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/AllArgsConstructorHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/AllArgsConstructorHandler.java\nnew file mode 100644\nindex 00000000000..a8071ede4f7\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/AllArgsConstructorHandler.java\n@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.List;\n+import lombok.AllArgsConstructor;\n+import lombok.core.AnnotationValues;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+import lombok.javac.handlers.HandleConstructor;\n+import lombok.javac.handlers.JavacHandlerUtil;\n+\n+public class AllArgsConstructorHandler extends JavacAnnotationHandler<AllArgsConstructor> {\n+    @Override\n+    public void handle(AnnotationValues<AllArgsConstructor> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+        // \"staticName\" and \"access\" should be retained, but onConstructor is not supported\n+        // Omit onConstructor to simplify AST -> LST translation\n+        if(jcAnnotation.getArguments().isEmpty()) {\n+            new HandleConstructor.HandleAllArgsConstructor().handle(annotationValues, jcAnnotation, javacNode);\n+        } else {\n+            List<JCTree.JCExpression> originalArgs = jcAnnotation.getArguments();\n+            List<JCTree.JCExpression> filteredArgs = List.nil();\n+            for (JCTree.JCExpression originalArg : originalArgs) {\n+                if (originalArg instanceof JCTree.JCAssign && ((JCTree.JCAssign) originalArg).getVariable() instanceof JCTree.JCIdent) {\n+                    JCTree.JCAssign assign = (JCTree.JCAssign) originalArg;\n+                    JCTree.JCIdent ident = (JCTree.JCIdent) assign.getVariable();\n+                    if (\"onConstructor\".equals(ident.getName().toString())) {\n+                        continue;\n+                    }\n+                }\n+                filteredArgs = filteredArgs.append(originalArg);\n+            }\n+\n+            jcAnnotation.args = filteredArgs;\n+\n+            AnnotationValues<AllArgsConstructor> annotation = JavacHandlerUtil.createAnnotation(AllArgsConstructor.class, jcAnnotation, javacNode);\n+            new HandleConstructor.HandleAllArgsConstructor().handle(annotation, jcAnnotation, javacNode);\n+            jcAnnotation.args = originalArgs;\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/CleanupNoOpHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/CleanupNoOpHandler.java\nnew file mode 100644\nindex 00000000000..69f011bedae\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/CleanupNoOpHandler.java\n@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import lombok.Cleanup;\n+import lombok.core.AnnotationValues;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+\n+public class CleanupNoOpHandler extends JavacAnnotationHandler<Cleanup> {\n+    @Override\n+    public void handle(AnnotationValues<Cleanup> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/ExtensionMethodHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/ExtensionMethodHandler.java\nnew file mode 100644\nindex 00000000000..68b5543da96\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/ExtensionMethodHandler.java\n@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import lombok.core.AnnotationValues;\n+import lombok.experimental.ExtensionMethod;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+\n+public class ExtensionMethodHandler extends JavacAnnotationHandler<ExtensionMethod> {\n+    @Override\n+    public void handle(AnnotationValues<ExtensionMethod> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/GetterHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/GetterHandler.java\nnew file mode 100644\nindex 00000000000..c05e979d285\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/GetterHandler.java\n@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.List;\n+import lombok.Getter;\n+import lombok.core.AnnotationValues;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+import lombok.javac.handlers.HandleGetter;\n+import lombok.javac.handlers.JavacHandlerUtil;\n+\n+public class GetterHandler extends JavacAnnotationHandler<Getter> {\n+    @Override\n+    public void handle(AnnotationValues<Getter> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+        // \"lazy\" or \"onMethod\" can significantly complicate the resulting AST\n+        // Simplify the AST -> LST translation omitting these arguments from consideration\n+        if(jcAnnotation.getArguments().isEmpty()) {\n+            new HandleGetter().handle(annotationValues, jcAnnotation, javacNode);\n+        } else {\n+            List<JCTree.JCExpression> originalArgs = jcAnnotation.args;\n+            jcAnnotation.args = List.nil();\n+            AnnotationValues<Getter> annotation = JavacHandlerUtil.createAnnotation(Getter.class, jcAnnotation, javacNode);\n+            new HandleGetter().handle(annotation, jcAnnotation, javacNode);\n+            jcAnnotation.args = originalArgs;\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/HelperHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/HelperHandler.java\nnew file mode 100644\nindex 00000000000..d1ef2b9fa59\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/HelperHandler.java\n@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import lombok.core.AnnotationValues;\n+import lombok.experimental.Helper;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+\n+public class HelperHandler extends JavacAnnotationHandler<Helper> {\n+    @Override\n+    public void handle(AnnotationValues<Helper> annotation, JCTree.JCAnnotation ast, JavacNode annotationNode) {\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/JacksonizedHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/JacksonizedHandler.java\nnew file mode 100644\nindex 00000000000..a9ce02cd671\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/JacksonizedHandler.java\n@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import lombok.core.AnnotationValues;\n+import lombok.core.HandlerPriority;\n+import lombok.extern.jackson.Jacksonized;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+\n+@SuppressWarnings(\"SpellCheckingInspection\")\n+@HandlerPriority(-512)\n+public class JacksonizedHandler extends JavacAnnotationHandler<Jacksonized> {\n+    @Override\n+    public void handle(AnnotationValues<Jacksonized> annotation, JCTree.JCAnnotation ast, JavacNode annotationNode) {\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/LockedNoOpHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/LockedNoOpHandler.java\nnew file mode 100644\nindex 00000000000..35d08af3402\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/LockedNoOpHandler.java\n@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import lombok.Locked;\n+import lombok.core.AnnotationValues;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+\n+public class LockedNoOpHandler extends JavacAnnotationHandler<Locked> {\n+    @Override\n+    public void handle(AnnotationValues<Locked> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/LockedReadNoOpHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/LockedReadNoOpHandler.java\nnew file mode 100644\nindex 00000000000..38c2797a4ce\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/LockedReadNoOpHandler.java\n@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import lombok.Locked;\n+import lombok.core.AnnotationValues;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+\n+public class LockedReadNoOpHandler extends JavacAnnotationHandler<Locked.Read> {\n+    @Override\n+    public void handle(AnnotationValues<Locked.Read> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/LockedWriteNoOpHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/LockedWriteNoOpHandler.java\nnew file mode 100644\nindex 00000000000..db8b9735c01\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/LockedWriteNoOpHandler.java\n@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import lombok.Locked;\n+import lombok.core.AnnotationValues;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+\n+public class LockedWriteNoOpHandler extends JavacAnnotationHandler<Locked.Write> {\n+    @Override\n+    public void handle(AnnotationValues<Locked.Write> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NoArgsConstructorHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NoArgsConstructorHandler.java\nnew file mode 100644\nindex 00000000000..b5942688f46\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NoArgsConstructorHandler.java\n@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.List;\n+import lombok.NoArgsConstructor;\n+import lombok.core.AnnotationValues;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+import lombok.javac.handlers.HandleConstructor;\n+import lombok.javac.handlers.JavacHandlerUtil;\n+\n+public class NoArgsConstructorHandler  extends JavacAnnotationHandler<NoArgsConstructor> {\n+    @Override\n+    public void handle(AnnotationValues<NoArgsConstructor> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+        // \"staticName\" and \"access\" should be retained, but onConstructor is not supported\n+        // Omit onConstructor to simplify AST -> LST translation\n+        if(jcAnnotation.getArguments().isEmpty()) {\n+            new HandleConstructor.HandleNoArgsConstructor().handle(annotationValues, jcAnnotation, javacNode);\n+        } else {\n+            List<JCTree.JCExpression> originalArgs = jcAnnotation.getArguments();\n+            List<JCTree.JCExpression> filteredArgs = List.nil();\n+            for (JCTree.JCExpression originalArg : originalArgs) {\n+                if (originalArg instanceof JCTree.JCAssign && ((JCTree.JCAssign) originalArg).getVariable() instanceof JCTree.JCIdent) {\n+                    JCTree.JCAssign assign = (JCTree.JCAssign) originalArg;\n+                    JCTree.JCIdent ident = (JCTree.JCIdent) assign.getVariable();\n+                    if (\"onConstructor\".equals(ident.getName().toString())) {\n+                        continue;\n+                    }\n+                }\n+                filteredArgs = filteredArgs.append(originalArg);\n+            }\n+\n+            jcAnnotation.args = filteredArgs;\n+\n+            AnnotationValues<NoArgsConstructor> annotation = JavacHandlerUtil.createAnnotation(NoArgsConstructor.class, jcAnnotation, javacNode);\n+            new HandleConstructor.HandleNoArgsConstructor().handle(annotation, jcAnnotation, javacNode);\n+            jcAnnotation.args = originalArgs;\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NonNullNoOpHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NonNullNoOpHandler.java\nnew file mode 100644\nindex 00000000000..9bf4b4902f7\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/NonNullNoOpHandler.java\n@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import lombok.NonNull;\n+import lombok.core.AnnotationValues;\n+import lombok.core.HandlerPriority;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+\n+@HandlerPriority(512)\n+public class NonNullNoOpHandler extends JavacAnnotationHandler<NonNull> {\n+    @Override\n+    public void handle(AnnotationValues<NonNull> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/OpenRewriteConfigurationKeysLoader.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/OpenRewriteConfigurationKeysLoader.java\nnew file mode 100644\nindex 00000000000..f31d755086b\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/OpenRewriteConfigurationKeysLoader.java\n@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import lombok.ConfigurationKeys;\n+import lombok.core.LombokConfiguration;\n+import lombok.core.configuration.*;\n+\n+public class OpenRewriteConfigurationKeysLoader implements ConfigurationKeysLoader {\n+    private static final FileSystemSourceCache cache = new FileSystemSourceCache();\n+\n+    static {\n+        final ConfigurationFileToSource fileToSource = cache.fileToSource(new ConfigurationParser(ConfigurationProblemReporter.CONSOLE));\n+        LombokConfiguration.overrideConfigurationResolverFactory(sourceLocation -> new OpenRewriteConfigurationResolver(cache.forUri(sourceLocation), fileToSource));\n+    }\n+}\n+\n+class OpenRewriteConfigurationResolver extends BubblingConfigurationResolver {\n+    public OpenRewriteConfigurationResolver(ConfigurationFile start, ConfigurationFileToSource fileMapper) {\n+        super(start, fileMapper);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> T resolve(ConfigurationKey<T> key) {\n+        if (key == ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS) {\n+            // ensure the `lombok.Generated` annotation is always added to generated declarations\n+            return (T) Boolean.TRUE;\n+        }\n+        return super.resolve(key);\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/RequiredArgsConstructorHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/RequiredArgsConstructorHandler.java\nnew file mode 100644\nindex 00000000000..e20877acf3d\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/RequiredArgsConstructorHandler.java\n@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.List;\n+import lombok.RequiredArgsConstructor;\n+import lombok.core.AnnotationValues;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+import lombok.javac.handlers.HandleConstructor;\n+import lombok.javac.handlers.JavacHandlerUtil;\n+\n+public class RequiredArgsConstructorHandler extends JavacAnnotationHandler<RequiredArgsConstructor> {\n+    @Override\n+    public void handle(AnnotationValues<RequiredArgsConstructor> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+        // \"staticName\" and \"access\" should be retained, but onConstructor is not supported\n+        // Omit onConstructor to simplify AST -> LST translation\n+        if(jcAnnotation.getArguments().isEmpty()) {\n+            new HandleConstructor.HandleRequiredArgsConstructor().handle(annotationValues, jcAnnotation, javacNode);\n+        } else {\n+            List<JCTree.JCExpression> originalArgs = jcAnnotation.getArguments();\n+            List<JCTree.JCExpression> filteredArgs = List.nil();\n+            for (JCTree.JCExpression originalArg : originalArgs) {\n+                if (originalArg instanceof JCTree.JCAssign && ((JCTree.JCAssign) originalArg).getVariable() instanceof JCTree.JCIdent) {\n+                    JCTree.JCAssign assign = (JCTree.JCAssign) originalArg;\n+                    JCTree.JCIdent ident = (JCTree.JCIdent) assign.getVariable();\n+                    if (\"onConstructor\".equals(ident.getName().toString())) {\n+                        continue;\n+                    }\n+                }\n+                filteredArgs = filteredArgs.append(originalArg);\n+            }\n+\n+            jcAnnotation.args = filteredArgs;\n+\n+            AnnotationValues<RequiredArgsConstructor> annotation = JavacHandlerUtil.createAnnotation(RequiredArgsConstructor.class, jcAnnotation, javacNode);\n+            new HandleConstructor.HandleRequiredArgsConstructor().handle(annotation, jcAnnotation, javacNode);\n+            jcAnnotation.args = originalArgs;\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SetterHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SetterHandler.java\nnew file mode 100644\nindex 00000000000..0ac171a6206\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SetterHandler.java\n@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.List;\n+import lombok.Setter;\n+import lombok.core.AnnotationValues;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+import lombok.javac.handlers.HandleSetter;\n+import lombok.javac.handlers.JavacHandlerUtil;\n+\n+public class SetterHandler extends JavacAnnotationHandler<Setter> {\n+    @Override\n+    public void handle(AnnotationValues<Setter> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+        // \"lazy\" or \"onMethod\" can significantly complicate the resulting AST\n+        // Simplify the AST -> LST translation omitting these arguments from consideration\n+        if(jcAnnotation.getArguments().isEmpty()) {\n+            new HandleSetter().handle(annotationValues, jcAnnotation, javacNode);\n+        } else {\n+            List<JCTree.JCExpression> originalArgs = jcAnnotation.args;\n+            jcAnnotation.args = List.nil();\n+            AnnotationValues<Setter> annotation = JavacHandlerUtil.createAnnotation(Setter.class, jcAnnotation, javacNode);\n+            new HandleSetter().handle(annotation, jcAnnotation, javacNode);\n+            jcAnnotation.args = originalArgs;\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SneakyThrowsNoOpHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SneakyThrowsNoOpHandler.java\nnew file mode 100644\nindex 00000000000..281e38ac57f\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SneakyThrowsNoOpHandler.java\n@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import lombok.SneakyThrows;\n+import lombok.core.AnnotationValues;\n+import lombok.core.HandlerPriority;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+\n+@HandlerPriority(1024)\n+public class SneakyThrowsNoOpHandler extends JavacAnnotationHandler<SneakyThrows> {\n+    @Override\n+    public void handle(AnnotationValues<SneakyThrows> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SynchronizedNoOpHandler.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SynchronizedNoOpHandler.java\nnew file mode 100644\nindex 00000000000..9ef32f5af34\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/SynchronizedNoOpHandler.java\n@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.lombok;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import lombok.Synchronized;\n+import lombok.core.AnnotationValues;\n+import lombok.javac.JavacAnnotationHandler;\n+import lombok.javac.JavacNode;\n+\n+public class SynchronizedNoOpHandler extends JavacAnnotationHandler<Synchronized> {\n+    @Override\n+    public void handle(AnnotationValues<Synchronized> annotationValues, JCTree.JCAnnotation jcAnnotation, JavacNode javacNode) {\n+    }\n+}\n\ndiff --git a/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/package-info.java b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/package-info.java\nnew file mode 100644\nindex 00000000000..88d655e67dd\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/java/org/openrewrite/java/lombok/package-info.java\n@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+@NullMarked\n+package org.openrewrite.java.lombok;\n+\n+import org.jspecify.annotations.NullMarked;\n\ndiff --git a/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.core.configuration.ConfigurationKeysLoader b/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.core.configuration.ConfigurationKeysLoader\nnew file mode 100644\nindex 00000000000..884fb9b7b1c\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.core.configuration.ConfigurationKeysLoader\n@@ -0,0 +1,16 @@\n+#\n+# Copyright 2024 the original author or authors.\n+# <p>\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+# <p>\n+# https://www.apache.org/licenses/LICENSE-2.0\n+# <p>\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+org.openrewrite.java.lombok.OpenRewriteConfigurationKeysLoader\n\\ No newline at end of file\n\ndiff --git a/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler b/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler\nnew file mode 100644\nindex 00000000000..cfecb22a205\n--- /dev/null\n+++ b/rewrite-java-lombok/src/main/resources/META-INF/services/lombok.javac.JavacAnnotationHandler\n@@ -0,0 +1,30 @@\n+#\n+# Copyright 2024 the original author or authors.\n+# <p>\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+# <p>\n+# https://www.apache.org/licenses/LICENSE-2.0\n+# <p>\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+org.openrewrite.java.lombok.AllArgsConstructorHandler\n+org.openrewrite.java.lombok.CleanupNoOpHandler\n+org.openrewrite.java.lombok.ExtensionMethodHandler\n+org.openrewrite.java.lombok.GetterHandler\n+org.openrewrite.java.lombok.HelperHandler\n+org.openrewrite.java.lombok.JacksonizedHandler\n+org.openrewrite.java.lombok.LockedNoOpHandler\n+org.openrewrite.java.lombok.LockedReadNoOpHandler\n+org.openrewrite.java.lombok.LockedWriteNoOpHandler\n+org.openrewrite.java.lombok.NoArgsConstructorHandler\n+org.openrewrite.java.lombok.NonNullNoOpHandler\n+org.openrewrite.java.lombok.RequiredArgsConstructorHandler\n+org.openrewrite.java.lombok.SetterHandler\n+org.openrewrite.java.lombok.SneakyThrowsNoOpHandler\n+org.openrewrite.java.lombok.SynchronizedNoOpHandler\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavaUnrestrictedClassLoader.java b/rewrite-java/src/main/java/org/openrewrite/java/JavaUnrestrictedClassLoader.java\nindex 9d1ac908dcc..417feaa1e19 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavaUnrestrictedClassLoader.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavaUnrestrictedClassLoader.java\n@@ -20,14 +20,18 @@\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.net.MalformedURLException;\n import java.net.URI;\n import java.net.URL;\n+import java.net.URLClassLoader;\n import java.nio.file.FileSystem;\n import java.nio.file.FileSystems;\n import java.nio.file.Files;\n import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.emptyList;\n \n /**\n  * Rewrite's JavaParser is reliant on java's compiler internal classes that are now encapsulated within Java's\n@@ -38,7 +42,7 @@\n  * <p>\n  * NOTE: Any classes in the package \"org.openrewrite.java.isolated\" will be loaded into this isolated classloader.\n  */\n-public class JavaUnrestrictedClassLoader extends ClassLoader {\n+public class JavaUnrestrictedClassLoader extends URLClassLoader {\n \n     static {\n         ClassLoader.registerAsParallelCapable();\n@@ -47,7 +51,25 @@ public class JavaUnrestrictedClassLoader extends ClassLoader {\n     final List<Path> modules;\n \n     public JavaUnrestrictedClassLoader(ClassLoader parentClassloader) {\n-        super(parentClassloader);\n+        this(parentClassloader, getLombok());\n+    }\n+\n+    private static List<URL> getLombok() {\n+        try {\n+            return JavaParser.dependenciesFromClasspath(\"lombok\").stream().map(it -> {\n+                try {\n+                    return it.toUri().toURL();\n+                } catch (MalformedURLException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }).collect(Collectors.toList());\n+        } catch (Exception e) {\n+            return emptyList();\n+        }\n+    }\n+\n+    public JavaUnrestrictedClassLoader(ClassLoader parentClassloader, List<URL> jars) {\n+        super(jars.toArray(new URL[0]), parentClassloader);\n \n         //A list of modules to load internal classes from\n         final FileSystem fs = FileSystems.getFileSystem(URI.create(\"jrt:/\"));\n@@ -90,10 +112,60 @@ public Class<?> loadClass(String name) throws ClassNotFoundException {\n                     throw new RuntimeException(e);\n                 }\n             }\n+            if (name.startsWith(\"lombok\")) {\n+                return findClass(name);\n+            }\n             return super.loadClass(name);\n         }\n     }\n \n+    @Override\n+    public Enumeration<URL> getResources(String name) throws IOException {\n+        // Give precedence to our own Lombok handlers\n+        if (name.startsWith(\"META-INF/services/lombok.\")) {\n+            Objects.requireNonNull(name);\n+            @SuppressWarnings(\"unchecked\")\n+            Enumeration<URL>[] tmp = (Enumeration<URL>[]) new Enumeration<?>[2];\n+            tmp[0] = findResources(name);\n+            tmp[1] = getParent().getResources(name);\n+\n+            return new CompoundEnumeration<>(tmp);\n+        }\n+        return super.getResources(name);\n+    }\n+\n+    private static final class CompoundEnumeration<E> implements Enumeration<E> {\n+        private final Enumeration<E>[] enums;\n+        private int index;\n+\n+        public CompoundEnumeration(Enumeration<E>[] enums) {\n+            this.enums = enums;\n+        }\n+\n+        private boolean next() {\n+            while (index < enums.length) {\n+                if (enums[index].hasMoreElements()) {\n+                    return true;\n+                }\n+                index++;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean hasMoreElements() {\n+            return next();\n+        }\n+\n+        @Override\n+        public E nextElement() {\n+            if (!next()) {\n+                throw new NoSuchElementException();\n+            }\n+            return enums[index].nextElement();\n+        }\n+    }\n+\n     @Override\n     public @Nullable URL getResource(String name) {\n         try {\n\ndiff --git a/settings.gradle.kts b/settings.gradle.kts\nindex 49af5568e86..f280b567997 100644\n--- a/settings.gradle.kts\n+++ b/settings.gradle.kts\n@@ -19,6 +19,7 @@ val allProjects = listOf(\n         \"rewrite-java\",\n         \"rewrite-java-tck\",\n         \"rewrite-java-test\",\n+        \"rewrite-java-lombok\",\n         \"rewrite-java-17\", // remove this when rewrite recipe gradle plugin moves to 21\n         \"rewrite-java-21\",\n         \"rewrite-json\",\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/JavaParserTypeMappingTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/JavaParserTypeMappingTest.java\nindex 031a114214f..8a687fd9ad4 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/JavaParserTypeMappingTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/JavaParserTypeMappingTest.java\n@@ -182,7 +182,7 @@ List<Parent> method(List<Parent> values) {\n     @Test\n     void methodInvocationOnUnknownType() {\n         rewriteRun(\n-          spec -> spec.typeValidationOptions(TypeValidation.builder().identifiers(false).methodDeclarations(false).build()),\n+          spec -> spec.typeValidationOptions(TypeValidation.builder().identifiers(false).methodDeclarations(false).constructorInvocations(false).build()),\n           java(\n             \"\"\"\n               import java.util.ArrayList;\n\ndiff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\nindex 8901f9a3ba0..5ba6384ee71 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/JavadocTest.java\n@@ -1616,14 +1616,14 @@ void multilineWithThrowsAndCRLF() {\n     void paramNoDescriptionWithCRLF() {\n         rewriteRun(\n           java(\"\" +\n-                          \"import org.foo;\\r\\n\" +\n-                          \"\\r\\n\" +\n-                          \"public class A {\\r\\n\" +\n-                          \"    /**\\r\\n\" +\n-                          \"     * @param arg0\\r\\n\" +\n-                          \"     */\\r\\n\" +\n-                          \"    void method(String arg0) {}\\r\\n\" +\n-                          \"}\"\n+               \"import org.foo;\\r\\n\" +\n+               \"\\r\\n\" +\n+               \"public class A {\\r\\n\" +\n+               \"    /**\\r\\n\" +\n+               \"     * @param arg0\\r\\n\" +\n+               \"     */\\r\\n\" +\n+               \"    void method(String arg0) {}\\r\\n\" +\n+               \"}\"\n           )\n         );\n     }\n@@ -1751,7 +1751,6 @@ void emptyAttributes() {\n               /**\n                * DEFINE TENANCY TenantB AS <TenantB OCID>\n                * ENDORSE GROUP <TenantA user group name> TO {OBJECTSTORAGE_NAMESPACE_READ} IN TENANCY TenantB\n-               *\n                * DEFINE TENANCY TenantA AS <TenantA OCID>\n                * DEFINE GROUP TenantAGroup AS <TenantA user group OCID>\n                * ADMIT GROUP TenantAGroup OF TENANCY TenantA TO {OBJECTSTORAGE_NAMESPACE_READ} IN TENANCY\n\ndiff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\nnew file mode 100644\nindex 00000000000..d4d02650c0a\n--- /dev/null\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/LombokTest.java\n@@ -0,0 +1,789 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.tree;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledOnJre;\n+import org.junit.jupiter.api.condition.JRE;\n+import org.openrewrite.java.JavaParser;\n+import org.openrewrite.test.RecipeSpec;\n+import org.openrewrite.test.RewriteTest;\n+import org.openrewrite.test.TypeValidation;\n+\n+import java.util.List;\n+\n+import static java.util.Objects.requireNonNull;\n+import static org.assertj.core.api.CollectionAssert.assertThatCollection;\n+import static org.openrewrite.java.Assertions.java;\n+\n+@SuppressWarnings({\"CaughtExceptionImmediatelyRethrown\", \"LombokGetterMayBeUsed\", \"LombokSetterMayBeUsed\", \"DefaultAnnotationParam\", \"NotNullFieldNotInitialized\", \"ProtectedMemberInFinalClass\", \"WriteOnlyObject\", \"ConcatenationWithEmptyString\"})\n+@EnabledOnJre(JRE.JAVA_17)\n+class LombokTest implements RewriteTest {\n+\n+    @Override\n+    public void defaults(RecipeSpec spec) {\n+        spec.parser(JavaParser.fromJavaVersion().classpath(\"lombok\"));\n+    }\n+\n+    @Test\n+    void cleanup() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.Cleanup;\n+              import java.io.*;\n+              \n+              public class CleanupExample {\n+                public static void main(String[] args) throws IOException {\n+                  @Cleanup InputStream in = new FileInputStream(args[0]);\n+                  @Cleanup OutputStream out = new FileOutputStream(args[1]);\n+                  byte[] b = new byte[10000];\n+                  while (true) {\n+                    int r = in.read(b);\n+                    if (r == -1) break;\n+                    out.write(b, 0, r);\n+                  }\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void getter() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.Getter;\n+              \n+              @Getter\n+              class A {\n+                  int n;\n+              \n+                  void test() {\n+                      System.out.println(getN());\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void builder() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.Builder;\n+              \n+              @Builder\n+              class A {\n+                  boolean b;\n+                  int n;\n+                  String s;\n+              \n+                  void test() {\n+                      A a = A.builder().n(1).b(true).s(\"foo\").build();\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void tostring() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.ToString;\n+              \n+              @ToString\n+              public class ToStringExample {\n+                private static final int STATIC_VAR = 10;\n+                private String name;\n+                private Shape shape = new Square(5, 10);\n+                private String[] tags;\n+                @ToString.Exclude private int id;\n+              \n+                public static class Shape {}\n+              \n+                @ToString(callSuper=true, includeFieldNames=true)\n+                public static class Square extends Shape {\n+                  private final int width, height;\n+              \n+                  public Square(int width, int height) {\n+                    this.width = width;\n+                    this.height = height;\n+                  }\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void equalsAndHashCode() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.EqualsAndHashCode;\n+              \n+              @EqualsAndHashCode\n+              public class ToStringExample {\n+                private static final int STATIC_VAR = 10;\n+                private String name;\n+                @EqualsAndHashCode.Exclude private Shape shape = new Square(5, 10);\n+                private String[] tags;\n+                @EqualsAndHashCode.Exclude private int id;\n+              \n+                public static class Shape {}\n+              \n+                @EqualsAndHashCode(callSuper=true)\n+                public static class Square extends Shape {\n+                  private final int width, height;\n+              \n+                  public Square(int width, int height) {\n+                    this.width = width;\n+                    this.height = height;\n+                  }\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void constructor() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.*;\n+              \n+              @RequiredArgsConstructor(staticName = \"of\")\n+              @AllArgsConstructor(access = AccessLevel.PROTECTED)\n+              public class ConstructorExample<T> {\n+                private int x, y;\n+                @NonNull private T description;\n+              \n+                @NoArgsConstructor\n+                public static class NoArgsExample {\n+                  @NonNull private String field;\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void data() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.AccessLevel;\n+              import lombok.Setter;\n+              import lombok.Data;\n+              import lombok.ToString;\n+              \n+              @Data public class DataExample {\n+                private final String name;\n+                @Setter(AccessLevel.PACKAGE) private int age;\n+                private double score;\n+                private String[] tags;\n+              \n+                @ToString(includeFieldNames=true)\n+                @Data(staticConstructor=\"of\")\n+                public static class Exercise<T> {\n+                  private final String name;\n+                  private final T value;\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void value() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.*;\n+              import lombok.experimental.*;\n+              \n+              @Value public class ValueExample {\n+                String name;\n+                @With(AccessLevel.PACKAGE) @NonFinal int age;\n+                double score;\n+                protected String[] tags;\n+              \n+                @ToString(includeFieldNames=true)\n+                @Value(staticConstructor=\"of\")\n+                public static class Exercise<T> {\n+                  String name;\n+                  T value;\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void synchronize() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.Synchronized;\n+              \n+              public class SynchronizedExample {\n+                private final Object readLock = new Object();\n+              \n+                @Synchronized\n+                public static void hello() {\n+                  System.out.println(\"world\");\n+                }\n+              \n+                @Synchronized\n+                public int answerToLife() {\n+                  return 42;\n+                }\n+              \n+                @Synchronized(\"readLock\")\n+                public void foo() {\n+                  System.out.println(\"bar\");\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void locked() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.Locked;\n+              \n+              public class LockedExample {\n+                private int value = 0;\n+              \n+                @Locked.Read\n+                public int getValue() {\n+                  return value;\n+                }\n+              \n+                @Locked.Write\n+                public void setValue(int newValue) {\n+                  value = newValue;\n+                }\n+              \n+                @Locked(\"baseLock\")\n+                public void foo() {\n+                  System.out.println(\"bar\");\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void with() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.AccessLevel;\n+              import lombok.NonNull;\n+              import lombok.With;\n+              \n+              public class WithExample {\n+                @With(AccessLevel.PROTECTED) @NonNull private final String name;\n+                @With private final int age;\n+              \n+                public WithExample(@NonNull String name, int age) {\n+                  this.name = name;\n+                  this.age = age;\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void lazyGetter() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.Getter;\n+              \n+              public class GetterLazyExample {\n+                @Getter(lazy=true) private final double[] cached = expensive();\n+              \n+                private double[] expensive() {\n+                  double[] result = new double[1000000];\n+                  for (int i = 0; i < result.length; i++) {\n+                    result[i] = Math.asin(i);\n+                  }\n+                  return result;\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void singular() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.Builder;\n+              import lombok.Singular;\n+              import java.util.Collection;\n+              import java.util.Set;\n+              import java.util.SortedMap;\n+              \n+              @Builder\n+              public class SingularExample<T extends Number> {\n+                  private @Singular Set<String> occupations;\n+                  private @Singular SortedMap<Integer, T> elves;\n+                  private @Singular Collection<?> minutiae;\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void jul() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.extern.java.Log;\n+              \n+              import java.util.Map;\n+              \n+              @Log\n+              class A {\n+                  String string;\n+                  Map<String, String> map;\n+                  void m() {\n+                      log.info(\"string = \" + string);\n+                      log.info(() -> \"map = %s\".formatted(map));\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void val() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.val;\n+              \n+              class A {\n+                  void m() {\n+                      val foo = \"foo\";\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void sneakyThrows() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.SneakyThrows;\n+              \n+              import java.io.UnsupportedEncodingException;\n+              import java.nio.charset.StandardCharsets;\n+              \n+              public class SneakyThrowsExample implements Runnable {\n+                  @SneakyThrows(UnsupportedEncodingException.class)\n+                  public String utf8ToString(byte[] bytes) {\n+                      return new String(bytes, StandardCharsets.UTF_8);\n+                  }\n+              \n+                  @SneakyThrows\n+                  public void run() {\n+                      try {\n+                          throw new Throwable();\n+                      } catch (RuntimeException e) {\n+                          throw e;\n+                      }\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void accessors() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.experimental.Accessors;\n+              import lombok.Getter;\n+              import lombok.Setter;\n+              \n+              @Accessors(fluent = true)\n+              public class AccessorsExample {\n+                  @Getter @Setter\n+                  private int age = 10;\n+                  public static void test() {\n+                        new AccessorsExample().age(20);\n+                  }\n+              }\n+              \n+              class PrefixExample {\n+                  @Accessors(prefix = \"f\") @Getter\n+                  private String fName = \"Hello, World!\";\n+                  public static String test() {\n+                      return new PrefixExample().getName();\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void fieldDefaults() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.AccessLevel;\n+              import lombok.experimental.FieldDefaults;\n+              import lombok.experimental.NonFinal;\n+              import lombok.experimental.PackagePrivate;\n+              \n+              @FieldDefaults(makeFinal=true, level=AccessLevel.PRIVATE)\n+              public class FieldDefaultsExample {\n+                public final int a;\n+                int b;\n+                @NonFinal int c;\n+                @PackagePrivate int d;\n+                FieldDefaultsExample() {\n+                  a = 0;\n+                  b = 0;\n+                  d = 0;\n+                }\n+              }\n+              \"\"\",\n+            spec -> spec.afterRecipe(cu -> {\n+                List<Statement> statements = cu.getClasses().get(0).getBody().getStatements();\n+                assertThatCollection(requireNonNull(((J.VariableDeclarations) statements.get(0)).getVariables().get(0).getVariableType()).getFlags())\n+                  .as(\"Field 'a' explicitly specifies its modifiers, overriding the lombok defaults\")\n+                  .containsExactlyInAnyOrder(Flag.Public, Flag.Final);\n+                assertThatCollection(requireNonNull(((J.VariableDeclarations) statements.get(1)).getVariables().get(0).getVariableType()).getFlags())\n+                  .as(\"Field 'b' does not specify its modifiers, so it should use the lombok defaults\")\n+                  .containsExactlyInAnyOrder(Flag.Private, Flag.Final);\n+                assertThatCollection(requireNonNull(((J.VariableDeclarations) statements.get(2)).getVariables().get(0).getVariableType()).getFlags())\n+                  .as(\"Field 'c' is annotated with @NonFinal, so it should not be final\")\n+                  .containsExactlyInAnyOrder(Flag.Private);\n+                assertThatCollection(requireNonNull(((J.VariableDeclarations) statements.get(3)).getVariables().get(0).getVariableType()).getFlags())\n+                  .as(\"Field 'd' is annotated with @PackagePrivate, so it should be package-private\")\n+                  .containsExactlyInAnyOrder(Flag.Final);\n+            })\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void delegate() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import java.util.ArrayList;\n+              import java.util.Collection;\n+              \n+              import lombok.experimental.Delegate;\n+              \n+              public class DelegationExample {\n+                  private interface SimpleCollection {\n+                      boolean add(String item);\n+                      boolean remove(Object item);\n+                  }\n+                  @Delegate(types=SimpleCollection.class)\n+                  private final Collection<String> collection = new ArrayList<>();\n+              \n+                  static void test() {\n+                      DelegationExample example = new DelegationExample();\n+                      example.add(\"s\");\n+                      example.remove(\"s\");\n+                  }\n+              }\n+              \n+              class ExcludesDelegateExample {\n+                  long counter = 0L;\n+                  private interface Add {\n+                      boolean add(String x);\n+                      boolean addAll(Collection<? extends String> x);\n+                  }\n+                  @Delegate(excludes=Add.class)\n+                  private final Collection<String> collection = new ArrayList<>();\n+                  public boolean add(String item) {\n+                      counter++;\n+                      return collection.add(item);\n+                  }\n+                  public boolean addAll(Collection<? extends String> col) {\n+                      counter += col.size();\n+                      return collection.addAll(col);\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void utilityClass() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.experimental.UtilityClass;\n+              \n+              @UtilityClass\n+              public class UtilityClassExample {\n+                private final int CONSTANT = 5;\n+              \n+                public int addSomething(int in) {\n+                  return in + CONSTANT;\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void fieldNameConstants() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.experimental.FieldNameConstants;\n+              \n+              @FieldNameConstants\n+              public class FieldNameConstantsExample {\n+                  private final String iAmAField;\n+                  private final int andSoAmI;\n+                  @FieldNameConstants.Exclude private final int asAmI;\n+              \n+                  public void test() {\n+                      System.out.println(FieldNameConstantsExample.Fields.iAmAField);\n+                      System.out.println(FieldNameConstantsExample.Fields.andSoAmI);\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void tolerate() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.experimental.Tolerate;\n+              import lombok.Setter;\n+              \n+              public class TolerateExample {\n+                  @Setter\n+                  private String s;\n+              \n+                  @Tolerate\n+                  public void setS(Object s) {\n+                      this.s = s.toString();\n+                  }\n+              \n+                  public void both(String s) {\n+                      setS(s);\n+                      setS((Object)s);\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void jacksonized() {\n+        rewriteRun(\n+          spec -> spec.parser(JavaParser.fromJavaVersion().classpath(\"jackson-annotations\", \"lombok\")),\n+          java(\n+            \"\"\"\n+              import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+              import lombok.Builder;\n+              import lombok.extern.jackson.Jacksonized;\n+              \n+              @Jacksonized\n+              @Builder\n+              @JsonIgnoreProperties(ignoreUnknown = true)\n+              public class JacksonExample {\n+                  private List<String> strings;\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void standardException() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import lombok.experimental.StandardException;\n+              \n+              @StandardException\n+              public class ExampleException extends Exception {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    /**\n+     * These test lombok features that we do not fully support.\n+     * Code should still parse and print back to its original source code but type information may be missing.\n+     */\n+    @SuppressWarnings(\"MismatchedReadAndWriteOfArray\")\n+    @Nested\n+    class LessSupported {\n+        @Test\n+        void extensionMethod() {\n+            rewriteRun(\n+              spec -> spec.typeValidationOptions(TypeValidation.none()),\n+              java(\n+                \"\"\"\n+                  import lombok.experimental.ExtensionMethod;\n+                  \n+                  @ExtensionMethod({java.util.Arrays.class, Extensions.class})\n+                  public class ExtensionMethodExample {\n+                      public String test() {\n+                          int[] intArray = {5, 3, 8, 2};\n+                          intArray.sort();\n+                          String iAmNull = null;\n+                          return iAmNull.or(\"hELlO, WORlD!\".toTitleCase());\n+                      }\n+                  }\n+                  \n+                  class Extensions {\n+                      public static <T> T or(T obj, T ifNull) {\n+                          return obj != null ? obj : ifNull;\n+                      }\n+                      public static String toTitleCase(String in) {\n+                          if (in.isEmpty()) return in;\n+                          return \"\" + Character.toTitleCase(in.charAt(0)) + in.substring(1).toLowerCase();\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void onConstructor() {\n+            rewriteRun(\n+              spec -> spec.typeValidationOptions(TypeValidation.none()),\n+              java(\n+                \"\"\"\n+                  import lombok.AllArgsConstructor;\n+                  import lombok.Getter;\n+                  import lombok.Setter;\n+                  \n+                  import javax.inject.Inject;\n+                  import javax.persistence.Id;\n+                  import javax.persistence.Column;\n+                  import javax.validation.constraints.Max;\n+                  \n+                  // @__ missing attribution\n+                  @AllArgsConstructor(onConstructor=@__(@Inject))\n+                  public class OnXExample {\n+                      @Getter(onMethod_={@Id, @Column(name=\"unique-id\")}) //JDK8\n+                      @Setter(onParam_=@Max(10000)) //JDK8\n+                      private long unid;\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void onConstructorNoArgs() {\n+            rewriteRun(\n+              spec -> spec.typeValidationOptions(TypeValidation.none()),\n+              java(\n+                \"\"\"\n+                  import lombok.NoArgsConstructor;\n+                  import lombok.Getter;\n+                  import lombok.RequiredArgsConstructor;import lombok.Setter;\n+                  \n+                  import javax.inject.Inject;\n+                  // @__ missing attribution\n+                  @NoArgsConstructor(onConstructor = @__(@Inject))\n+                  @RequiredArgsConstructor(onConstructor_ = @__(@Inject))\n+                  public class OnXExample {\n+                      private long unid;\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+\n+        @Test\n+        void helper() {\n+            rewriteRun(\n+              spec -> spec.typeValidationOptions(TypeValidation.none()),\n+              java(\n+                \"\"\"\n+                  import lombok.experimental.Helper;\n+                  \n+                  public class HelperExample {\n+                      int someMethod(int arg1) {\n+                          int localVar = 5;\n+                  \n+                          @Helper\n+                          class Helpers {\n+                              int helperMethod(int arg) {\n+                                  return arg + localVar;\n+                              }\n+                          }\n+                  \n+                          // helperMethod missing type attribution\n+                          return helperMethod(10);\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n+    }\n+}\n\ndiff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/VariableDeclarationsTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/VariableDeclarationsTest.java\nindex aaf24e67fa6..080bd2d1fbd 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/VariableDeclarationsTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/VariableDeclarationsTest.java\n@@ -26,6 +26,7 @@\n import static org.assertj.core.api.Assertions.assertThat;\n import static org.openrewrite.java.Assertions.java;\n \n+@SuppressWarnings(\"UnnecessaryLocalVariable\")\n class VariableDeclarationsTest implements RewriteTest {\n \n     @Test\n@@ -35,7 +36,7 @@ void generic() {\n             \"\"\"\n               import java.util.Collections;\n               import java.util.ArrayList;\n-                            \n+              \n               class Test {\n                   void test() {\n                       ArrayList<String> categories = new ArrayList<>();\n@@ -114,7 +115,7 @@ class Test {\n                   int [ ] n2;\n                   String [ ] [ ] s2;\n               }\n-               \"\"\"\n+              \"\"\"\n           )\n         );\n     }\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/format/SpacesTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/format/SpacesTest.java\nindex a36d69ce1d9..f54e21cfd49 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/format/SpacesTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/format/SpacesTest.java\n@@ -4823,7 +4823,7 @@ void preserveSpacePrecedingCommentInSpaceBefore() {\n           java(\n             \"\"\"\n               import java.util.List;\n-              @Deprecated(\"version\" /* some comment */)\n+              @Deprecated(since = \"version\" /* some comment */)\n               class Test {\n                   void foo() {\n                       List.of( // another comment\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/search/SemanticallyEqualTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/search/SemanticallyEqualTest.java\nindex 0e4f98aa4f1..14b8975e434 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/search/SemanticallyEqualTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/search/SemanticallyEqualTest.java\n@@ -193,16 +193,16 @@ void typeCasts() {\n         assertExpressionsEqual(\n           \"\"\"\n             class T {\n-                Number a = (java.lang.Number) \"\";\n-                Number b = (java.lang.Number) \"\";\n+                Number a = (java.lang.Number) null;\n+                Number b = (java.lang.Number) null;\n             }\n             \"\"\"\n         );\n         assertExpressionsEqual(\n           \"\"\"\n             class T {\n-                Number a = (java.lang.Number) \"\";\n-                Number b = (Number) \"\";\n+                Number a = (java.lang.Number) null;\n+                Number b = (Number) null;\n             }\n             \"\"\"\n         );\n@@ -211,8 +211,8 @@ class T {\n             import java.util.List;\n             import java.util.UUID;\n             class T {\n-                Number a = (List<UUID>) \"\";\n-                Number b = (List<java.util.UUID>) \"\";\n+                List a = (List<UUID>) null;\n+                List b = (List<java.util.UUID>) null;\n             }\n             \"\"\"\n         );\n@@ -221,8 +221,8 @@ class T {\n             import java.util.List;\n             import java.util.UUID;\n             class T {\n-                Number a = (List<java.util.UUID>) \"\";\n-                Number b = (java.util.List<UUID>) \"\";\n+                List a = (List<java.util.UUID>) null;\n+                List b = (java.util.List<UUID>) null;\n             }\n             \"\"\"\n         );\n\ndiff --git a/rewrite-java/src/test/java/org/openrewrite/java/OpenRewriteArchitectureTest.java b/rewrite-java/src/test/java/org/openrewrite/java/OpenRewriteArchitectureTest.java\nindex ac8c319d760..24e914e3bef 100644\n--- a/rewrite-java/src/test/java/org/openrewrite/java/OpenRewriteArchitectureTest.java\n+++ b/rewrite-java/src/test/java/org/openrewrite/java/OpenRewriteArchitectureTest.java\n@@ -61,13 +61,13 @@ public void check(JavaPackage javaPackage, ConditionEvents events) {\n                     events.add(SimpleConditionEvent.violated(javaPackage, message));\n                 }\n             }\n-        }.and(new ArchCondition<>(\"be annotated with @NonNullApi\") {\n+        }.and(new ArchCondition<>(\"be annotated with @NullMarked\") {\n             @Override\n             public void check(JavaPackage javaPackage, ConditionEvents events) {\n                 javaPackage.tryGetPackageInfo()\n                         .filter(packageInfo -> !packageInfo.isAnnotatedWith(NullMarked.class))\n                         .ifPresent(packageInfo -> events.add(SimpleConditionEvent.violated(javaPackage,\n-                                String.format(\"Package '%s' is not annotated as @NonNullApi\", javaPackage.getName()))));\n+                                String.format(\"Package '%s' is not annotated as @NullMarked\", javaPackage.getName()))));\n             }\n         });\n     }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4594",
    "pr_id": 4594,
    "issue_id": 4593,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ChangePropertyValue could improve array value behaviour\n## What problem are you trying to solve?\r\nIn our yamls we want to update an entry of a list in the yaml with a certain text value by another text value. If we would fo this with a simple text Find/Replace, the other occurences outside the propertyKey binding would also be updated. \r\n\r\n## Describe the situation before applying the recipe\r\n```yaml\r\njob-name4:\r\n  script:\r\n    - replaceme\r\n    - replaceme\r\n    - do not replaceme\r\n    - replaceme should not be done\r\n  rules:\r\n    - replaceme\r\n```\r\n\r\n## Describe the situation after applying the recipe\r\nWhen running with regex false for replaceme -> replaced\r\n```yaml\r\njob-name4:\r\n  script:\r\n    - replaced\r\n    - replaced\r\n    - do not replaceme\r\n    - replaceme should not be done\r\n  rules:\r\n    - replaceme\r\n```\r\n\r\nWhen running with regex true for (.\\*)replaceme(.\\*) -> $1replaced$2\r\n```yaml\r\njob-name4:\r\n  script:\r\n    - replaced\r\n    - replaced\r\n    - do not replaced\r\n    - replaced should not be done\r\n  rules:\r\n    - replaceme\r\n```\r\n\r\n## Are you interested in [contributing this recipe to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#adding-new-recipes)?\r\nThe branch is present\r\n",
    "issue_word_count": 163,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/ChangePropertyValue.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/ChangePropertyValueTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/ChangePropertyValueTest.java"
    ],
    "base_commit": "ae1a9204a0a6da4471396c4ff77a1ec11f562af1",
    "head_commit": "6534acd691b34ae13c49cf19f1a20c412c5752b7",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4594",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4594",
    "dockerfile": "",
    "pr_merged_at": "2024-10-21T17:01:41.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/ChangePropertyValue.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/ChangePropertyValue.java\nindex 0450162b720..67be849db24 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/ChangePropertyValue.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/ChangePropertyValue.java\n@@ -19,6 +19,7 @@\n import lombok.Value;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n+import org.openrewrite.internal.ListUtils;\n import org.openrewrite.internal.NameCaseConvention;\n import org.openrewrite.internal.StringUtils;\n import org.openrewrite.yaml.tree.Yaml;\n@@ -97,7 +98,7 @@ public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionC\n                 Yaml.Mapping.Entry e = super.visitMappingEntry(entry, ctx);\n                 String prop = getProperty(getCursor());\n                 if (matchesPropertyKey(prop) && matchesOldValue(e.getValue())) {\n-                    Yaml.Scalar updatedValue = updateValue(e.getValue());\n+                    Yaml.Block updatedValue = updateValue(e.getValue());\n                     if (updatedValue != null) {\n                         e = e.withValue(updatedValue);\n                     }\n@@ -108,15 +109,27 @@ public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionC\n     }\n \n     // returns null if value should not change\n-    private Yaml.@Nullable Scalar updateValue(Yaml.Block value) {\n-        if (!(value instanceof Yaml.Scalar)) {\n-            return null;\n+    private Yaml.@Nullable Block updateValue(Yaml.Block value) {\n+        if (value instanceof Yaml.Scalar) {\n+            Yaml.Scalar scalar = (Yaml.Scalar) value;\n+            Yaml.Scalar newScalar = scalar.withValue(Boolean.TRUE.equals(regex) ?\n+                    scalar.getValue().replaceAll(Objects.requireNonNull(oldValue), newValue) :\n+                    newValue);\n+            return scalar.getValue().equals(newScalar.getValue()) ? null : newScalar;\n         }\n-        Yaml.Scalar scalar = (Yaml.Scalar) value;\n-        Yaml.Scalar newScalar = scalar.withValue(Boolean.TRUE.equals(regex) ?\n-                scalar.getValue().replaceAll(Objects.requireNonNull(oldValue), newValue) :\n-                newValue);\n-        return scalar.getValue().equals(newScalar.getValue()) ? null : newScalar;\n+        if (value instanceof Yaml.Sequence) {\n+            Yaml.Sequence sequence = (Yaml.Sequence) value;\n+            return sequence.withEntries(ListUtils.map(sequence.getEntries(), entry -> {\n+                if (matchesOldValue(entry.getBlock())) {\n+                    Yaml.Block updatedValue = updateValue(entry.getBlock());\n+                    if (updatedValue != null) {\n+                        return entry.withBlock(updatedValue);\n+                    }\n+                }\n+                return entry;\n+            }));\n+        }\n+        return null;\n     }\n \n     private boolean matchesPropertyKey(String prop) {\n@@ -126,14 +139,20 @@ private boolean matchesPropertyKey(String prop) {\n     }\n \n     private boolean matchesOldValue(Yaml.Block value) {\n-        if (!(value instanceof Yaml.Scalar)) {\n-            return false;\n+        if (value instanceof Yaml.Scalar) {\n+            Yaml.Scalar scalar = (Yaml.Scalar) value;\n+            return StringUtils.isNullOrEmpty(oldValue) ||\n+                   (Boolean.TRUE.equals(regex) ?\n+                           Pattern.compile(oldValue).matcher(scalar.getValue()).find() :\n+                           scalar.getValue().equals(oldValue));\n+        } else if (value instanceof Yaml.Sequence) {\n+            for (Yaml.Sequence.Entry entry : ((Yaml.Sequence) value).getEntries()) {\n+                if (matchesOldValue(entry.getBlock())) {\n+                    return true;\n+                }\n+            }\n         }\n-        Yaml.Scalar scalar = (Yaml.Scalar) value;\n-        return StringUtils.isNullOrEmpty(oldValue) ||\n-               (Boolean.TRUE.equals(regex) ?\n-                       Pattern.compile(oldValue).matcher(scalar.getValue()).find() :\n-                       scalar.getValue().equals(oldValue));\n+        return false;\n     }\n \n     private static String getProperty(Cursor cursor) {\n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/ChangePropertyValueTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/ChangePropertyValueTest.java\nindex b1db9434ec8..4ffb6a1d3c8 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/ChangePropertyValueTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/ChangePropertyValueTest.java\n@@ -140,6 +140,80 @@ void partialMatchNotReplacedWithoutRegexTrue() {\n         );\n     }\n \n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4593\")\n+    void supportYamlListValues() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePropertyValue(\"**.script\", \"replaced\", \"replaceme\", null, null, null)),\n+          yaml(\n+            \"\"\"\n+              job-name1:\n+                script:\n+                  - replaceme\n+              job-name2:\n+                script:\n+                  - do not replaceme\n+              job-name3:\n+                script:\n+                  - replaceme should not be done\n+              job-name4:\n+                script:\n+                  - replaceme\n+                  - replaceme\n+                  - do not replaceme\n+                  - replaceme should not be done\n+                rules:\n+                  - replaceme\n+              \"\"\", \"\"\"\n+              job-name1:\n+                script:\n+                  - replaced\n+              job-name2:\n+                script:\n+                  - do not replaceme\n+              job-name3:\n+                script:\n+                  - replaceme should not be done\n+              job-name4:\n+                script:\n+                  - replaced\n+                  - replaced\n+                  - do not replaceme\n+                  - replaceme should not be done\n+                rules:\n+                  - replaceme\n+              \"\"\")\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4593\")\n+    void supportYamlListValuesWithRegex() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePropertyValue(\"**.script\", \"$1replaced$2\", \"(.*)replaceme(.*)\", true, null, null)),\n+          yaml(\n+            \"\"\"\n+              job-name:\n+                script:\n+                  - replaceme\n+                  - replaceme\n+                  - this should be replaceme\n+                  - replaceme should be done\n+                rules:\n+                  - replaceme\n+              \"\"\", \"\"\"\n+              job-name:\n+                script:\n+                  - replaced\n+                  - replaced\n+                  - this should be replaced\n+                  - replaced should be done\n+                rules:\n+                  - replaceme\n+              \"\"\")\n+        );\n+    }\n+\n     @Test\n     void validatesThatOldValueIsRequiredIfRegexEnabled() {\n         assertTrue(new ChangePropertyValue(\"my.prop\", \"bar\", null, true, null, null).validate().isInvalid());\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4577",
    "pr_id": 4577,
    "issue_id": 4569,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Minor parsing issue; space after import, before semi-colon\n## What version of OpenRewrite are you using?\r\n- OpenRewrite. Latest: v8.37.x\r\n- Maven/Gradle plugin: N/A -- noticed while reading parser code.\r\n\r\n## How are you running OpenRewrite?\r\nN/A\r\n\r\nThe issue is caused by IMPORT missing here, and applies to all languages: https://github.com/openrewrite/rewrite/blob/main/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n```java\r\n    @Test\r\n    void spaceBeforeSemiColon() {\r\n        rewriteRun(\r\n          java(\r\n            \"\"\"\r\n              import java.util.List ;\r\n              \"\"\"\r\n          )\r\n        );\r\n    }\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\n```java\r\nimport java.util.List ;\r\n```\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\n```java\r\nimport java.util.List; // <- space is removed\r\n```\r\n",
    "issue_word_count": 153,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/ImportTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/ImportTest.java"
    ],
    "base_commit": "b6f178b30a4298eb5f06015783638e17c77a75a9",
    "head_commit": "45fb77a0f80f7b11db5f3dae18776ed8c30fcdc1",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4577",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4577",
    "dockerfile": "",
    "pr_merged_at": "2024-10-12T21:27:56.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\nindex 1932dc4319c..2f1a7c21061 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11ParserVisitor.java\n@@ -1682,6 +1682,7 @@ private Space statementDelim(@Nullable Tree t) {\n                 t instanceof JCBreak ||\n                 t instanceof JCContinue ||\n                 t instanceof JCDoWhileLoop ||\n+                t instanceof JCImport ||\n                 t instanceof JCMethodInvocation ||\n                 t instanceof JCNewClass ||\n                 t instanceof JCReturn ||\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\nindex 65e8cbb7310..3b2f01606f8 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17ParserVisitor.java\n@@ -1761,6 +1761,7 @@ private Space statementDelim(@Nullable Tree t) {\n             case BREAK:\n             case CONTINUE:\n             case DO_WHILE_LOOP:\n+            case IMPORT:\n             case METHOD_INVOCATION:\n             case NEW_CLASS:\n             case RETURN:\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\nindex 016248562e1..b8c8647a64b 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21ParserVisitor.java\n@@ -1771,6 +1771,7 @@ private Space statementDelim(@Nullable Tree t) {\n             case BREAK:\n             case CONTINUE:\n             case DO_WHILE_LOOP:\n+            case IMPORT:\n             case METHOD_INVOCATION:\n             case NEW_CLASS:\n             case RETURN:\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\nindex a871d79ceb3..8079f482883 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8ParserVisitor.java\n@@ -1675,6 +1675,7 @@ private Space statementDelim(@Nullable Tree t) {\n                 t instanceof JCBreak ||\n                 t instanceof JCContinue ||\n                 t instanceof JCDoWhileLoop ||\n+                t instanceof JCImport ||\n                 t instanceof JCMethodInvocation ||\n                 t instanceof JCNewClass ||\n                 t instanceof JCReturn ||\n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/ImportTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/ImportTest.java\nindex eab30e42c40..31ed588fb68 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/ImportTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/ImportTest.java\n@@ -31,10 +31,10 @@ void typeName() {\n             \"\"\"\n               import static java.util.Map.Entry;\n               import java.util.Map.Entry;\n-                            \n+              \n               import java.util.List;\n               import java.util.*;\n-                            \n+              \n               import static java.nio.charset.StandardCharsets.UTF_8;\n               import static java.util.Collections.emptyList;\n               \"\"\",\n@@ -157,15 +157,14 @@ public static class Bar {\n           ),\n           java(\n             \"\"\"\n-                  package org.openrewrite;\n-                  \n-                  import org.openrewrite.BadPackage.Foo;\n-                  import org.openrewrite.BadPackage.Foo.Bar;\n-                  \n-                  public class Bar {\n-                      private Foo foo;\n-                  }\n-                  \n+              package org.openrewrite;\n+              \n+              import org.openrewrite.BadPackage.Foo;\n+              import org.openrewrite.BadPackage.Foo.Bar;\n+              \n+              public class Bar {\n+                  private Foo foo;\n+              }\n               \"\"\",\n             spec -> spec.afterRecipe(cu -> {\n                 assertThat(cu.getImports().get(0).getPackageName()).isEqualTo(\"org.openrewrite.BadPackage\");\n@@ -174,4 +173,16 @@ public class Bar {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4569\")\n+    @Test\n+    void spaceBeforeSemiColon() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import java.util.List ;\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4549",
    "pr_id": 4549,
    "issue_id": 4055,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Problem with parsing groovy files\nI'm trying to run recipe using the gradle wrapper with the init script on a clean Spring Boot 2.7.x application with addition of one single groovy class. When I run build `.\\gradlew --init-script ..\\rewrite-init.gradle rewriteRun`, I am seeing following message:\r\n\r\n```sh\r\nThere were problems parsing src\\main\\groovy\\com\\example\\demo\\Example.groovy\r\n```\r\nwhere `Example.groovy` is\r\n\r\n```groovy\r\npackage com.example.demo\r\n\r\nimport groovy.transform.ToString\r\n\r\n@ToString(includeNames = true)\r\nclass Category {\r\n    String f1\r\n    String f2\r\n    String f3\r\n    String f4\r\n    String f5\r\n}\r\n\r\n```\r\n\r\nand `build.gradle` is\r\n\r\n```gradle\r\nplugins {\r\n\tid 'groovy'\r\n\tid 'org.springframework.boot' version '2.7.11'\r\n\tid 'io.spring.dependency-management' version '1.1.4'\r\n}\r\n\r\ngroup = 'com.example'\r\nversion = '0.0.1-SNAPSHOT'\r\n\r\njava {\r\n\tsourceCompatibility=1.8\r\n\ttargetCompatibility=1.8\r\n}\r\n\r\nrepositories {\r\n\tmavenCentral()\r\n}\r\n\r\ndependencies {\r\n\timplementation 'org.springframework.boot:spring-boot-starter'\r\n\timplementation 'org.codehaus.groovy:groovy-all:3.0.10'\r\n\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\r\n}\r\n\r\ntasks.named('test') {\r\n\tuseJUnitPlatform()\r\n}\r\n```\r\n\r\nand `rewrite-init.gradle` is\r\n\r\n```gradle\r\ninitscript {\r\n    repositories {\r\n        maven { url \"https://plugins.gradle.org/m2\" }\r\n    }\r\n    dependencies { classpath(\"org.openrewrite:plugin:6.8.4\") }\r\n}\r\nrootProject {\r\n    plugins.apply(org.openrewrite.gradle.RewritePlugin)\r\n    dependencies {\r\n        rewrite(platform(\"org.openrewrite.recipe:rewrite-recipe-bom:2.7.1\"))\r\n        rewrite(\"org.openrewrite.recipe:rewrite-spring\")\r\n    }\r\n    rewrite {\r\n        activeRecipe(\"org.openrewrite.java.spring.boot2.UpgradeSpringBoot_2_7\")\r\n    }\r\n    afterEvaluate {\r\n        if (repositories.isEmpty()) {\r\n            repositories {\r\n                mavenCentral()\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis is the stack trace:\r\n\r\n```sh\r\nError during rewrite run\r\norg.openrewrite.groovy.GroovyParsingException: Failed to parse src\\main\\groovy\\com\\example\\demo\\Category.groovy at cursor position 166. The next 10 characters in the original source are `ing f4\r\n  `\r\n        at org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:175)\r\n        at org.openrewrite.groovy.GroovyParser.lambda$parseInputs$4(GroovyParser.java:154)\r\n        at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\r\n        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1384)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\r\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n        at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)\r\n        at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:272)\r\n        at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\r\n        at java.util.stream.Streams$StreamBuilderImpl.forEachRemaining(Streams.java:419)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313)\r\n        at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n        at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:566)\r\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.listResults(DefaultProjectParser.java:1206)\r\n        at org.openrewrite.gradle.isolated.DefaultProjectParser.run(DefaultProjectParser.java:402)\r\n        at org.openrewrite.gradle.DelegatingProjectParser.lambda$run$2(DelegatingProjectParser.java:100)\r\n        at org.openrewrite.gradle.DelegatingProjectParser.unwrapInvocationException(DelegatingProjectParser.java:147)\r\n        at org.openrewrite.gradle.DelegatingProjectParser.run(DelegatingProjectParser.java:99)\r\n        at org.openrewrite.gradle.RewriteRunTask.run(RewriteRunTask.java:36)\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n        at java.lang.reflect.Method.invoke(Method.java:498)\r\n        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:125)\r\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.doExecute(StandardTaskAction.java:58)\r\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:51)\r\n        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:29)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution$3.run(TaskExecution.java:242)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:29)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:26)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.run(DefaultBuildOperationRunner.java:47)\r\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:68)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeAction(TaskExecution.java:227)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeActions(TaskExecution.java:210)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution.executeWithPreviousOutputFiles(TaskExecution.java:193)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution.execute(TaskExecution.java:166)\r\n        at org.gradle.internal.execution.steps.ExecuteStep.executeInternal(ExecuteStep.java:105)\r\n        at org.gradle.internal.execution.steps.ExecuteStep.access$000(ExecuteStep.java:44)\r\n        at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:59)\r\n        at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:56)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\r\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\r\n        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:56)\r\n        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:44)\r\n        at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:67)\r\n        at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:37)\r\n        at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:41)\r\n        at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:74)\r\n        at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:55)\r\n        at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:50)\r\n        at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:28)\r\n        at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.executeDelegateBroadcastingChanges(CaptureStateAfterExecutionStep.java:100)\r\n        at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:72)\r\n        at org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:50)\r\n        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:40)\r\n        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:29)\r\n        at org.gradle.internal.execution.steps.BuildCacheStep.executeWithoutCache(BuildCacheStep.java:166)\r\n        at org.gradle.internal.execution.steps.BuildCacheStep.lambda$execute$1(BuildCacheStep.java:70)\r\n        at org.gradle.internal.Either$Right.fold(Either.java:175)\r\n        at org.gradle.internal.execution.caching.CachingState.fold(CachingState.java:59)\r\n        at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:68)\r\n        at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:46)\r\n        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:36)\r\n        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:25)\r\n        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:36)\r\n        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:22)\r\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:91)\r\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$2(SkipUpToDateStep.java:55)\r\n        at java.util.Optional.orElseGet(Optional.java:267)\r\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:55)\r\n        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:37)\r\n        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:65)\r\n        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:36)\r\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:37)\r\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:27)\r\n        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:76)\r\n        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:37)\r\n        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:94)\r\n        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:49)\r\n        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:71)\r\n        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:45)\r\n        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.executeWithNonEmptySources(SkipEmptyWorkStep.java:177)\r\n        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:81)\r\n        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:53)\r\n        at org.gradle.internal.execution.steps.RemoveUntrackedExecutionStateStep.execute(RemoveUntrackedExecutionStateStep.java:32)\r\n        at org.gradle.internal.execution.steps.RemoveUntrackedExecutionStateStep.execute(RemoveUntrackedExecutionStateStep.java:21)\r\n        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:38)\r\n        at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:36)\r\n        at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:23)\r\n        at org.gradle.internal.execution.steps.CleanupStaleOutputsStep.execute(CleanupStaleOutputsStep.java:75)\r\n        at org.gradle.internal.execution.steps.CleanupStaleOutputsStep.execute(CleanupStaleOutputsStep.java:41)\r\n        at org.gradle.internal.execution.steps.AssignWorkspaceStep.lambda$execute$0(AssignWorkspaceStep.java:32)\r\n        at org.gradle.api.internal.tasks.execution.TaskExecution$4.withWorkspace(TaskExecution.java:287)\r\n        at org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:30)\r\n        at org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:21)\r\n        at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:37)\r\n        at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:27)\r\n        at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:47)\r\n        at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:34)\r\n        at org.gradle.internal.execution.impl.DefaultExecutionEngine$1.execute(DefaultExecutionEngine.java:64)\r\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:146)\r\n        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:135)\r\n        at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)\r\n        at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)\r\n        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)\r\n        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:74)\r\n        at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)\r\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)\r\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)\r\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\r\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\r\n        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)\r\n        at org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:42)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:337)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:324)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:317)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:303)\r\n        at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:463)\r\n        at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:380)\r\n        at org.gradle.execution.plan.DefaultPlanExecutor.process(DefaultPlanExecutor.java:116)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph.executeWithServices(DefaultTaskExecutionGraph.java:138)\r\n        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph.execute(DefaultTaskExecutionGraph.java:123)\r\n        at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:35)\r\n        at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:51)\r\n        at org.gradle.execution.BuildOperationFiringBuildWorkerExecutor$ExecuteTasks.call(BuildOperationFiringBuildWorkerExecutor.java:54)\r\n        at org.gradle.execution.BuildOperationFiringBuildWorkerExecutor$ExecuteTasks.call(BuildOperationFiringBuildWorkerExecutor.java:43)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)\r\n        at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)\r\n        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)\r\n        at org.gradle.execution.BuildOperationFiringBuildWorkerExecutor.execute(BuildOperationFiringBuildWorkerExecutor.java:40)\r\n        at org.gradle.internal.build.DefaultBuildLifecycleController.lambda$executeTasks$10(DefaultBuildLifecycleController.java:202)\r\n        at org.gradle.internal.model.StateTransitionController.doTransition(StateTransitionController.java:266)\r\n        at org.gradle.internal.model.StateTransitionController.lambda$tryTransition$8(StateTransitionController.java:177)\r\n        at org.gradle.internal.work.DefaultSynchronizer.withLock(DefaultSynchronizer.java:44)\r\n        at org.gradle.internal.model.StateTransitionController.tryTransition(StateTransitionController.java:177)\r\n        at org.gradle.internal.build.DefaultBuildLifecycleController.executeTasks(DefaultBuildLifecycleController.java:202)\r\n        at org.gradle.internal.build.DefaultBuildWorkGraphController$DefaultBuildWorkGraph.runWork(DefaultBuildWorkGraphController.java:209)\r\n        at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:249)\r\n        at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:109)\r\n        at org.gradle.composite.internal.DefaultBuildController.doRun(DefaultBuildController.java:172)\r\n        at org.gradle.composite.internal.DefaultBuildController.access$000(DefaultBuildController.java:47)\r\n        at org.gradle.composite.internal.DefaultBuildController$BuildOpRunnable.run(DefaultBuildController.java:191)\r\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\r\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)\r\n        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:49)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        at java.lang.Thread.run(Thread.java:750)\r\nCaused by: java.lang.IllegalStateException: Unexpected constant type java.lang.Boolean\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitConstantExpression$3(GroovyParserVisitor.java:1196)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.insideParentheses(GroovyParserVisitor.java:623)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitConstantExpression(GroovyParserVisitor.java:1136)\r\n        at org.codehaus.groovy.ast.expr.ConstantExpression.visit(ConstantExpression.java:80)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:572)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitDeclarationExpression(GroovyParserVisitor.java:1278)\r\n        at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:89)\r\n        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.lambda$visitExpressionStatement$6(GroovyParserVisitor.java:1305)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.labeled(GroovyParserVisitor.java:638)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitExpressionStatement(GroovyParserVisitor.java:1304)\r\n        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:572)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visitBlockStatement(GroovyParserVisitor.java:918)\r\n        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.visit(GroovyParserVisitor.java:572)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyVisitor.access$1200(GroovyParserVisitor.java:560)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.visitMethod(GroovyParserVisitor.java:537)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.lambda$visitClassBlock$3(GroovyParserVisitor.java:334)\r\n        at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\r\n        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1384)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\r\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n        at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)\r\n        at java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:272)\r\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\r\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\r\n        at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\r\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n        at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:566)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.visitClassBlock(GroovyParserVisitor.java:341)\r\n        at org.openrewrite.groovy.GroovyParserVisitor$RewriteGroovyClassVisitor.visitClass(GroovyParserVisitor.java:282)\r\n        at org.openrewrite.groovy.GroovyParserVisitor.convertTopLevelStatement(GroovyParserVisitor.java:2023)\r\n        at org.openrewrite.groovy.GroovyParserVisitor.visit(GroovyParserVisitor.java:161)\r\n        ... 204 more\r\n```\r\n",
    "issue_word_count": 2811,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java",
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java"
    ],
    "base_commit": "0067a102176930469266bfe0b06ba37669a6bc76",
    "head_commit": "f4ce60a0075b622870d165fd9913f587de2b91d0",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4549",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4549",
    "dockerfile": "",
    "pr_merged_at": "2024-10-04T20:02:08.000Z",
    "patch": "diff --git a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\nindex a1a0f5ed465..39b9da390dc 100644\n--- a/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n+++ b/rewrite-groovy/src/main/java/org/openrewrite/groovy/GroovyParserVisitor.java\n@@ -1205,6 +1205,9 @@ public void visitConstantExpression(ConstantExpression expression) {\n                         text = \"\";\n                     }\n                     jType = JavaType.Primitive.Null;\n+                } else if (expression instanceof AnnotationConstantExpression) {\n+                    classVisitor.visitAnnotation((AnnotationNode) value);\n+                    return ((Expression) classVisitor.pollQueue()).withPrefix(fmt);\n                 } else {\n                     throw new IllegalStateException(\"Unexpected constant type \" + type);\n                 }\n",
    "test_patch": "diff --git a/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java\nnew file mode 100644\nindex 00000000000..a87695e7d71\n--- /dev/null\n+++ b/rewrite-groovy/src/test/java/org/openrewrite/groovy/tree/AnnotationTest.java\n@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2021 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.groovy.tree;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.Issue;\n+import org.openrewrite.test.RewriteTest;\n+\n+import static org.openrewrite.groovy.Assertions.groovy;\n+\n+@SuppressWarnings({\"GroovyUnusedAssignment\", \"GrUnnecessarySemicolon\"})\n+class AnnotationTest implements RewriteTest {\n+\n+    @Test\n+    void simple() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              @Foo\n+              class Test {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4055\")\n+    @Test\n+    void nested() {\n+        rewriteRun(\n+          groovy(\n+            \"\"\"\n+              @Foo(bar = @Bar)\n+              class Test {\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4529",
    "pr_id": 4529,
    "issue_id": 361,
    "repo": "openrewrite/rewrite",
    "problem_statement": "yaml parsing issues on spring-cloud-config\nRunning MavenProjectParser on spring-cloud-config results in several yaml parsing errors\r\n\r\nSample stacktrace:\r\n```\r\njava.lang.ArrayIndexOutOfBoundsException: arraycopy: length -1091 is negative\r\n\tat java.base/java.lang.System.arraycopy(Native Method)\r\n\tat org.openrewrite.yaml.FormatPreservingReader.prefix(FormatPreservingReader.java:53)\r\n\tat org.openrewrite.yaml.FormatPreservingReader.prefix(FormatPreservingReader.java:68)\r\n\tat org.openrewrite.yaml.YamlParser.parseFromInput(YamlParser.java:98)\r\n```\r\nThis occurs on quite a few yaml files in this project. Here are a few examples:\r\nhttps://github.com/spring-cloud/spring-cloud-config/blob/master/spring-cloud-config-server/src/test/resources/resource-encryptor/test.yml\r\nhttps://github.com/spring-cloud/spring-cloud-config/blob/master/spring-cloud-config-server/src/test/resources/ssh/ssh-nested-settings-list.yml",
    "issue_word_count": 125,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/semver/Semver.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/search/ParentPomInsight.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/search/ParentPomInsightTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/search/ParentPomInsightTest.java"
    ],
    "base_commit": "2fba7e130100af749f69803f0b6655c6e92fa923",
    "head_commit": "28fda459abf157b73b23ff2eb93b1b0edc5e90e0",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4529",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4529",
    "dockerfile": "",
    "pr_merged_at": "2024-10-21T22:10:06.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/semver/Semver.java b/rewrite-core/src/main/java/org/openrewrite/semver/Semver.java\nindex 155e3107f6f..d4d6388702a 100644\n--- a/rewrite-core/src/main/java/org/openrewrite/semver/Semver.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/semver/Semver.java\n@@ -34,6 +34,14 @@ public static boolean isVersion(@Nullable String version) {\n         return LatestRelease.RELEASE_PATTERN.matcher(version).matches();\n     }\n \n+    /**\n+     * Validates the given version against an optional pattern\n+     *\n+     * @param toVersion       the version to validate. Node-style [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors) may be used.\n+     * @param metadataPattern optional metadata appended to the version. Allows version selection to be extended beyond the original Node Semver semantics. So for example,\n+     *                        Setting 'version' to \"25-29\" can be paired with a metadata pattern of \"-jre\" to select Guava 29.0-jre\n+     * @return the validation result\n+     */\n     public static Validated<VersionComparator> validate(String toVersion, @Nullable String metadataPattern) {\n         return Validated.<VersionComparator, String>testNone(\n                 \"metadataPattern\",\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/search/ParentPomInsight.java b/rewrite-maven/src/main/java/org/openrewrite/maven/search/ParentPomInsight.java\nindex 176a7a14983..916542e6de5 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/search/ParentPomInsight.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/search/ParentPomInsight.java\n@@ -20,12 +20,18 @@\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n import org.openrewrite.marker.SearchResult;\n+import org.openrewrite.maven.MavenDownloadingException;\n import org.openrewrite.maven.MavenIsoVisitor;\n+import org.openrewrite.maven.internal.MavenPomDownloader;\n import org.openrewrite.maven.table.ParentPomsInUse;\n+import org.openrewrite.maven.tree.MavenResolutionResult;\n+import org.openrewrite.maven.tree.Parent;\n import org.openrewrite.maven.tree.ResolvedPom;\n import org.openrewrite.semver.Semver;\n+import org.openrewrite.semver.VersionComparator;\n import org.openrewrite.xml.tree.Xml;\n \n+import static java.util.Collections.emptyList;\n import static org.openrewrite.internal.StringUtils.matchesGlob;\n \n @EqualsAndHashCode(callSuper = false)\n@@ -52,6 +58,12 @@ public class ParentPomInsight extends Recipe {\n     @Nullable\n     String version;\n \n+    @Option(displayName = \"Recursive\",\n+            description = \"Whether to search recursively through the parents. True by default.\",\n+            required = false)\n+    @Nullable\n+    Boolean recursive;\n+\n     @Override\n     public String getDisplayName() {\n         return \"Maven parent insight\";\n@@ -79,26 +91,43 @@ public Validated<Object> validate() {\n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n         return new MavenIsoVisitor<ExecutionContext>() {\n+            @Nullable\n+            final VersionComparator versionComparator = version == null ? null : Semver.validate(version, null).getValue();\n+\n             @Override\n             public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 Xml.Tag t = super.visitTag(tag, ctx);\n-                if (isParentTag()) {\n-                    ResolvedPom resolvedPom = getResolutionResult().getPom();\n-                    String groupId = resolvedPom.getValue(tag.getChildValue(\"groupId\").orElse(null));\n-                    String artifactId = resolvedPom.getValue(tag.getChildValue(\"artifactId\").orElse(null));\n+                if (!isParentTag()) {\n+                    return t;\n+                }\n+\n+                MavenResolutionResult mrr = getResolutionResult();\n+                MavenPomDownloader mpd = new MavenPomDownloader(mrr.getProjectPoms(), ctx, mrr.getMavenSettings(), mrr.getActiveProfiles());\n+\n+                Parent ancestor = mrr.getPom().getRequested().getParent();\n+                String relativePath = tag.getChildValue(\"relativePath\").orElse(null);\n+                while (ancestor != null) {\n+                    String groupId = ancestor.getGroupId();\n+                    String artifactId = ancestor.getArtifactId();\n                     if (matchesGlob(groupId, groupIdPattern) && matchesGlob(artifactId, artifactIdPattern)) {\n-                        String parentVersion = resolvedPom.getValue(tag.getChildValue(\"version\").orElse(null));\n-                        if (version != null) {\n-                            if (!Semver.validate(version, null).getValue()\n-                                    .isValid(null, parentVersion)) {\n-                                return t;\n-                            }\n+                        String parentVersion = ancestor.getVersion();\n+                        if (versionComparator == null || versionComparator.isValid(null, parentVersion)) {\n+                            // Found a parent pom that matches the criteria\n+                            inUse.insertRow(ctx, new ParentPomsInUse.Row(\n+                                    mrr.getPom().getArtifactId(), groupId, artifactId, parentVersion, relativePath));\n+                            return SearchResult.found(t);\n                         }\n-                        // Found a parent pom that matches the criteria\n-                        String relativePath = tag.getChildValue(\"relativePath\").orElse(null);\n-                        inUse.insertRow(ctx, new ParentPomsInUse.Row(\n-                                resolvedPom.getArtifactId(), groupId, artifactId, parentVersion, relativePath));\n-                        return SearchResult.found(t);\n+                    }\n+                    if (Boolean.FALSE.equals(recursive)) {\n+                        return t;\n+                    }\n+                    try {\n+                        ResolvedPom ancestorPom = mpd.download(ancestor.getGav(), null, null, mrr.getPom().getRepositories())\n+                                .resolve(emptyList(), mpd, ctx);\n+                        ancestor = ancestorPom.getRequested().getParent();\n+                        relativePath = null;\n+                    } catch (MavenDownloadingException e) {\n+                        return e.warn(t);\n                     }\n                 }\n                 return t;\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/search/ParentPomInsightTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/search/ParentPomInsightTest.java\nindex 7101ed97a6b..d98d3ba8816 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/search/ParentPomInsightTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/search/ParentPomInsightTest.java\n@@ -20,6 +20,7 @@\n import org.openrewrite.maven.table.ParentPomsInUse;\n import org.openrewrite.test.RecipeSpec;\n import org.openrewrite.test.RewriteTest;\n+import org.openrewrite.test.SourceSpec;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.openrewrite.java.Assertions.mavenProject;\n@@ -28,7 +29,25 @@\n class ParentPomInsightTest implements RewriteTest {\n     @Override\n     public void defaults(RecipeSpec spec) {\n-        spec.recipe(new ParentPomInsight(\"org.springframework.boot\", \"spring-boot-starter-parent\", null));\n+        spec.recipe(new ParentPomInsight(\"org.springframework.boot\", \"spring-boot-starter-parent\", null, null));\n+    }\n+\n+    @Test\n+    void noParent() {\n+        rewriteRun(\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n     }\n \n     @DocumentExample\n@@ -89,7 +108,7 @@ void findParent() {\n     void multiModuleOnlyRoot() {\n         rewriteRun(\n           spec -> spec\n-            .recipe(new ParentPomInsight(\"*\", \"*\", null))\n+            .recipe(new ParentPomInsight(\"*\", \"*\", null, null))\n             .dataTableAsCsv(ParentPomsInUse.class.getName(), \"\"\"\n               projectArtifactId,groupId,artifactId,version,relativePath\n               sample,org.springframework.boot,\"spring-boot-starter-parent\",2.5.0,\n@@ -105,13 +124,13 @@ void multiModuleOnlyRoot() {\n                   <groupId>org.sample</groupId>\n                   <artifactId>sample</artifactId>\n                   <version>1.0.0</version>\n-                  \n+                \n                   <parent>\n                     <groupId>org.springframework.boot</groupId>\n                     <artifactId>spring-boot-starter-parent</artifactId>\n                     <version>2.5.0</version>\n                   </parent>\n-                  \n+                \n                   <modules>\n                     <module>module1</module>\n                     <module>module2</module>\n@@ -125,13 +144,132 @@ void multiModuleOnlyRoot() {\n                   <groupId>org.sample</groupId>\n                   <artifactId>sample</artifactId>\n                   <version>1.0.0</version>\n-\n+                \n                   <!--~~>--><parent>\n                     <groupId>org.springframework.boot</groupId>\n                     <artifactId>spring-boot-starter-parent</artifactId>\n                     <version>2.5.0</version>\n                   </parent>\n+                \n+                  <modules>\n+                    <module>module1</module>\n+                    <module>module2</module>\n+                  </modules>\n+                </project>\n+                \"\"\"\n+            ),\n+            mavenProject(\"module1\",\n+              pomXml(\n+                \"\"\"\n+                  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                    <modelVersion>4.0.0</modelVersion>\n+                    <parent>\n+                      <groupId>org.sample</groupId>\n+                      <artifactId>sample</artifactId>\n+                      <version>1.0.0</version>\n+                      <relativePath>../</relativePath>\n+                    </parent>\n+                    <artifactId>module1</artifactId>\n+                  </project>\n+                  \"\"\",\n+                \"\"\"\n+                  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                    <modelVersion>4.0.0</modelVersion>\n+                    <!--~~>--><parent>\n+                      <groupId>org.sample</groupId>\n+                      <artifactId>sample</artifactId>\n+                      <version>1.0.0</version>\n+                      <relativePath>../</relativePath>\n+                    </parent>\n+                    <artifactId>module1</artifactId>\n+                  </project>\n+                  \"\"\",\n+                spec -> spec.path(\"module1/pom.xml\")\n+              )),\n+            mavenProject(\"module2\",\n+              pomXml(\n+                \"\"\"\n+                  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                    <modelVersion>4.0.0</modelVersion>\n+                    <parent>\n+                      <groupId>org.sample</groupId>\n+                      <artifactId>sample</artifactId>\n+                      <version>1.0.0</version>\n+                      <relativePath>../</relativePath>\n+                    </parent>\n+                    <artifactId>module2</artifactId>\n+                  </project>\n+                  \"\"\",\n+                \"\"\"\n+                  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                    <modelVersion>4.0.0</modelVersion>\n+                    <!--~~>--><parent>\n+                      <groupId>org.sample</groupId>\n+                      <artifactId>sample</artifactId>\n+                      <version>1.0.0</version>\n+                      <relativePath>../</relativePath>\n+                    </parent>\n+                    <artifactId>module2</artifactId>\n+                  </project>\n+                  \"\"\",\n+                spec -> spec.path(\"module2/pom.xml\")\n+              )\n+            )\n+          )\n+        );\n+    }\n \n+    @Test\n+    void ancestorMatchesVersion() {\n+        rewriteRun(\n+          spec -> spec\n+            .recipe(new ParentPomInsight(\"*\", \"*\", \"2.5.0\", null))\n+            .dataTableAsCsv(ParentPomsInUse.class.getName(), \"\"\"\n+              projectArtifactId,groupId,artifactId,version,relativePath\n+              sample,org.springframework.boot,\"spring-boot-starter-parent\",2.5.0,\n+              module1,org.springframework.boot,\"spring-boot-starter-parent\",2.5.0,\n+              module2,org.springframework.boot,\"spring-boot-starter-parent\",2.5.0,\n+              \"\"\"),\n+          mavenProject(\"sample\",\n+            pomXml(\n+              \"\"\"\n+                <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>org.sample</groupId>\n+                  <artifactId>sample</artifactId>\n+                  <version>1.0.0</version>\n+                \n+                  <parent>\n+                    <groupId>org.springframework.boot</groupId>\n+                    <artifactId>spring-boot-starter-parent</artifactId>\n+                    <version>2.5.0</version>\n+                  </parent>\n+                \n+                  <modules>\n+                    <module>module1</module>\n+                    <module>module2</module>\n+                  </modules>\n+                </project>\n+                \"\"\",\n+              \"\"\"\n+                <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>org.sample</groupId>\n+                  <artifactId>sample</artifactId>\n+                  <version>1.0.0</version>\n+                \n+                  <!--~~>--><parent>\n+                    <groupId>org.springframework.boot</groupId>\n+                    <artifactId>spring-boot-starter-parent</artifactId>\n+                    <version>2.5.0</version>\n+                  </parent>\n+                \n                   <modules>\n                     <module>module1</module>\n                     <module>module2</module>\n@@ -208,7 +346,7 @@ void multiModuleOnlyRoot() {\n     void matchNonSnapshot() {\n         rewriteRun(\n           spec -> spec\n-            .recipe(new ParentPomInsight(\"*\", \"*\", \"~2\"))\n+            .recipe(new ParentPomInsight(\"*\", \"*\", \"~2\", false))\n             .dataTableAsCsv(ParentPomsInUse.class.getName(), \"\"\"\n               projectArtifactId,groupId,artifactId,version,relativePath\n               sample,org.springframework.boot,\"spring-boot-starter-parent\",2.5.0,\n@@ -222,13 +360,13 @@ void matchNonSnapshot() {\n                   <groupId>org.sample</groupId>\n                   <artifactId>sample</artifactId>\n                   <version>1.0.0-SNAPSHOT</version>\n-                  \n+                \n                   <parent>\n                     <groupId>org.springframework.boot</groupId>\n                     <artifactId>spring-boot-starter-parent</artifactId>\n                     <version>2.5.0</version>\n                   </parent>\n-                  \n+                \n                   <modules>\n                     <module>module1</module>\n                     <module>module2</module>\n@@ -242,13 +380,13 @@ void matchNonSnapshot() {\n                   <groupId>org.sample</groupId>\n                   <artifactId>sample</artifactId>\n                   <version>1.0.0-SNAPSHOT</version>\n-\n+                \n                   <!--~~>--><parent>\n                     <groupId>org.springframework.boot</groupId>\n                     <artifactId>spring-boot-starter-parent</artifactId>\n                     <version>2.5.0</version>\n                   </parent>\n-\n+                \n                   <modules>\n                     <module>module1</module>\n                     <module>module2</module>\n@@ -294,4 +432,569 @@ void matchNonSnapshot() {\n           )\n         );\n     }\n+\n+    @Test\n+    void directParentMatchesFullGAV() {\n+        rewriteRun(\n+          spec -> {\n+              spec.recipe(new ParentPomInsight(\"org.springframework.boot\", \"spring-boot-starter-parent\", \"3.3.3\", null));\n+              spec.dataTable(ParentPomsInUse.Row.class, rows -> assertThat(rows)\n+                .singleElement()\n+                .satisfies(row -> {\n+                      assertThat(row.getProjectArtifactId()).isEqualTo(\"my-app\");\n+                      assertThat(row.getGroupId()).isEqualTo(\"org.springframework.boot\");\n+                      assertThat(row.getArtifactId()).isEqualTo(\"spring-boot-starter-parent\");\n+                      assertThat(row.getVersion()).isEqualTo(\"3.3.3\");\n+                      assertThat(row.getRelativePath()).isNull();\n+                  }\n+                ));\n+          },\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\",\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <!--~~>--><parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void directParentMatchesGAVMinorVersion() {\n+        rewriteRun(\n+          spec -> {\n+              spec.recipe(new ParentPomInsight(\"org.springframework.boot\", \"spring-boot-starter-parent\", \"3.3.x\", null));\n+              spec.dataTable(ParentPomsInUse.Row.class, rows -> assertThat(rows)\n+                .singleElement()\n+                .satisfies(row -> {\n+                      assertThat(row.getProjectArtifactId()).isEqualTo(\"my-app\");\n+                      assertThat(row.getGroupId()).isEqualTo(\"org.springframework.boot\");\n+                      assertThat(row.getArtifactId()).isEqualTo(\"spring-boot-starter-parent\");\n+                      assertThat(row.getVersion()).isEqualTo(\"3.3.3\");\n+                      assertThat(row.getRelativePath()).isNull();\n+                  }\n+                ));\n+          },\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\",\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <!--~~>--><parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void directParentMatchesGroupIdGlob() {\n+        rewriteRun(\n+          spec -> {\n+              spec.recipe(new ParentPomInsight(\"org.springframework.*\", \"spring-boot-starter-parent\", null, null));\n+              spec.dataTable(ParentPomsInUse.Row.class, rows -> assertThat(rows)\n+                .singleElement()\n+                .satisfies(row -> {\n+                      assertThat(row.getProjectArtifactId()).isEqualTo(\"my-app\");\n+                      assertThat(row.getGroupId()).isEqualTo(\"org.springframework.boot\");\n+                      assertThat(row.getArtifactId()).isEqualTo(\"spring-boot-starter-parent\");\n+                      assertThat(row.getVersion()).isEqualTo(\"3.3.3\");\n+                      assertThat(row.getRelativePath()).isNull();\n+                  }\n+                ));\n+          },\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\",\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <!--~~>--><parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void directParentMatchesArtifactIdGlob() {\n+        rewriteRun(\n+          spec -> {\n+              spec.recipe(new ParentPomInsight(\"org.springframework.boot\", \"spring-*-parent\", null, null));\n+              spec.dataTable(ParentPomsInUse.Row.class, rows -> assertThat(rows)\n+                .singleElement()\n+                .satisfies(row -> {\n+                      assertThat(row.getProjectArtifactId()).isEqualTo(\"my-app\");\n+                      assertThat(row.getGroupId()).isEqualTo(\"org.springframework.boot\");\n+                      assertThat(row.getArtifactId()).isEqualTo(\"spring-boot-starter-parent\");\n+                      assertThat(row.getVersion()).isEqualTo(\"3.3.3\");\n+                      assertThat(row.getRelativePath()).isNull();\n+                  }\n+                ));\n+          },\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\",\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <!--~~>--><parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void indirectParentMatches() {\n+        rewriteRun(\n+          spec -> {\n+              spec.recipe(new ParentPomInsight(\"org.springframework.boot\", \"spring-boot-dependencies\", null, null));\n+              spec.dataTable(ParentPomsInUse.Row.class, rows -> assertThat(rows)\n+                .singleElement()\n+                .satisfies(row -> {\n+                      assertThat(row.getProjectArtifactId()).isEqualTo(\"my-app\");\n+                      assertThat(row.getGroupId()).isEqualTo(\"org.springframework.boot\");\n+                      assertThat(row.getArtifactId()).isEqualTo(\"spring-boot-dependencies\");\n+                      assertThat(row.getVersion()).isEqualTo(\"3.3.3\");\n+                      assertThat(row.getRelativePath()).isNull();\n+                  }\n+                ));\n+          },\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\",\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <!--~~>--><parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void indirectParentMatchesNonRecursive() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ParentPomInsight(\"org.springframework.boot\", \"spring-boot-dependencies\", null, false)),\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void indirectParentMatchesGAVPattern() {\n+        rewriteRun(\n+          spec -> {\n+              spec.recipe(new ParentPomInsight(\"*.springframework.*\", \"spring-*-dependencies\", \"3.x\", null));\n+              spec.dataTable(ParentPomsInUse.Row.class, rows -> assertThat(rows)\n+                .singleElement()\n+                .satisfies(row -> {\n+                      assertThat(row.getProjectArtifactId()).isEqualTo(\"my-app\");\n+                      assertThat(row.getGroupId()).isEqualTo(\"org.springframework.boot\");\n+                      assertThat(row.getArtifactId()).isEqualTo(\"spring-boot-dependencies\");\n+                      assertThat(row.getVersion()).isEqualTo(\"3.3.3\");\n+                      assertThat(row.getRelativePath()).isNull();\n+                  }\n+                ));\n+          },\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\",\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <!--~~>--><parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void multiModuleParentMatches() {\n+        rewriteRun(\n+          spec -> spec.dataTable(ParentPomsInUse.Row.class, rows -> assertThat(rows)\n+            .singleElement()\n+            .satisfies(row -> {\n+                  assertThat(row.getProjectArtifactId()).isEqualTo(\"child\");\n+                  assertThat(row.getGroupId()).isEqualTo(\"org.springframework.boot\");\n+                  assertThat(row.getArtifactId()).isEqualTo(\"spring-boot-starter-parent\");\n+                  assertThat(row.getVersion()).isEqualTo(\"3.3.3\");\n+                  assertThat(row.getRelativePath()).isNull();\n+              }\n+            )),\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              <modules>\n+              \t<module>child</module>\n+              </modules>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\",\n+            SourceSpec::skip\n+          ),\n+          mavenProject(\"child\",\n+            pomXml(\n+              //language=xml\n+              \"\"\"\n+                <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                \n+                <parent>\n+                \t<groupId>com.mycompany.app</groupId>\n+                \t<artifactId>my-app</artifactId>\n+                \t<version>1</version>\n+                \t<relativePath>../</relativePath>\n+                </parent>\n+                \n+                <artifactId>child</artifactId>\n+                </project>\n+                \"\"\",\n+              //language=xml\n+              \"\"\"\n+                <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                \n+                <!--~~>--><parent>\n+                \t<groupId>com.mycompany.app</groupId>\n+                \t<artifactId>my-app</artifactId>\n+                \t<version>1</version>\n+                \t<relativePath>../</relativePath>\n+                </parent>\n+                \n+                <artifactId>child</artifactId>\n+                </project>\n+                \"\"\"\n+            )\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void groupIdDoesNotMatch() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ParentPomInsight(\"org.springframework.invalid\", \"spring-boot-starter-parent\", null, null)),\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void artifactIdDoesNotMatch() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ParentPomInsight(\"org.springframework.boot\", \"spring-boot-starter-web\", null, null)),\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void versionDoesNotMatch() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ParentPomInsight(\"org.springframework.boot\", \"spring-boot-starter-parent\", \"3.3.4\", null)),\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void minorVersionDoesNotMatch() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ParentPomInsight(\"org.springframework.boot\", \"spring-boot-starter-parent\", \"3.3.x\", null)),\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.0.5</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void doesNotMatchGroupIdGlob() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ParentPomInsight(\"org.invalid.*\", \"spring-boot-starter-parent\", null, null)),\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void doesNotMatchArtifactIdGlob() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ParentPomInsight(\"org.springframework.boot\", \"spring-boot-*-web\", null, null)),\n+          pomXml(\n+            //language=xml\n+            \"\"\"\n+              <project>\n+              <modelVersion>4.0.0</modelVersion>\n+              \n+              <parent>\n+              \t<groupId>org.springframework.boot</groupId>\n+              \t<artifactId>spring-boot-starter-parent</artifactId>\n+              \t<version>3.3.3</version>\n+              </parent>\n+              \n+              <groupId>com.mycompany.app</groupId>\n+              <artifactId>my-app</artifactId>\n+              <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4515",
    "pr_id": 4515,
    "issue_id": 4514,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ChangeDependencyGroupIdAndArtifactId can duplicate new dependency\nIn case if new dependency already exists, it will be doubled:\r\n```java\r\n@Test\r\nvoid shouldNotAddNewIfDependencyAlreadyExistsManaged() {\r\n    rewriteRun(\r\n      spec -> spec.recipe(new ChangeDependencyGroupIdAndArtifactId(\r\n        \"javax.activation\",\r\n        \"javax.activation-api\",\r\n        \"jakarta.activation\",\r\n        \"jakarta.activation-api\",\r\n        null,\r\n        null\r\n      )),\r\n      pomXml(\r\n        \"\"\"\r\n          <project>\r\n              <modelVersion>4.0.0</modelVersion>\r\n              <groupId>com.mycompany.app</groupId>\r\n              <artifactId>my-app</artifactId>\r\n              <version>1</version>\r\n              <dependencies>\r\n                  <dependency>\r\n                      <groupId>javax.activation</groupId>\r\n                      <artifactId>javax.activation-api</artifactId>\r\n                  </dependency>\r\n                  <dependency>\r\n                      <groupId>jakarta.activation</groupId>\r\n                      <artifactId>jakarta.activation-api</artifactId>\r\n                  </dependency>\r\n              </dependencies>\r\n              <dependencyManagement>\r\n                  <dependencies>\r\n                      <dependency>\r\n                          <groupId>javax.activation</groupId>\r\n                          <artifactId>javax.activation-api</artifactId>\r\n                          <version>1.2.0</version>\r\n                      </dependency>\r\n                      <dependency>\r\n                          <groupId>jakarta.activation</groupId>\r\n                          <artifactId>jakarta.activation-api</artifactId>\r\n                          <version>1.2.1</version>\r\n                      </dependency>\r\n                  </dependencies>\r\n              </dependencyManagement>\r\n          </project>\r\n          \"\"\",\r\n        \"\"\"\r\n          <project>\r\n              <modelVersion>4.0.0</modelVersion>\r\n              <groupId>com.mycompany.app</groupId>\r\n              <artifactId>my-app</artifactId>\r\n              <version>1</version>\r\n              <dependencies>\r\n                  <dependency>\r\n                      <groupId>jakarta.activation</groupId>\r\n                      <artifactId>jakarta.activation-api</artifactId>\r\n                  </dependency>\r\n              </dependencies>\r\n              <dependencyManagement>\r\n                  <dependencies>\r\n                      <dependency>\r\n                          <groupId>javax.activation</groupId>\r\n                          <artifactId>javax.activation-api</artifactId>\r\n                          <version>1.2.0</version>\r\n                      </dependency>\r\n                      <dependency>\r\n                          <groupId>jakarta.activation</groupId>\r\n                          <artifactId>jakarta.activation-api</artifactId>\r\n                          <version>1.2.1</version>\r\n                      </dependency>\r\n                  </dependencies>\r\n              </dependencyManagement>\r\n          </project>\r\n          \"\"\"\r\n      )\r\n    );\r\n}\r\n```\r\nOf course, it is possible to add RemoveDuplicateDependencies recipe, but more clean solution is to avoid adding duplicate at all.",
    "issue_word_count": 206,
    "test_files_count": 2,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java"
    ],
    "base_commit": "bf6af04ddf24d0e152cf819b799e4258d2cf8f2a",
    "head_commit": "d4a0cd4972a1688da1b6c1e28a1a3ecd10712d17",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4515",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4515",
    "dockerfile": "",
    "pr_merged_at": "2024-10-11T18:59:46.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\nindex c0cb645d7c0..83c13dca881 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\n@@ -21,10 +21,7 @@\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.*;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n-import org.openrewrite.maven.tree.MavenMetadata;\n-import org.openrewrite.maven.tree.MavenResolutionResult;\n-import org.openrewrite.maven.tree.ResolvedManagedDependency;\n-import org.openrewrite.maven.tree.Scope;\n+import org.openrewrite.maven.tree.*;\n import org.openrewrite.semver.Semver;\n import org.openrewrite.semver.VersionComparator;\n import org.openrewrite.xml.AddToTagVisitor;\n@@ -153,9 +150,11 @@ public TreeVisitor<?, ExecutionContext> getVisitor() {\n             final VersionComparator versionComparator = newVersion != null ? Semver.validate(newVersion, versionPattern).getValue() : null;\n             @Nullable\n             private Collection<String> availableVersions;\n+            private boolean isNewDependencyPresent;\n \n             @Override\n             public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {\n+                isNewDependencyPresent = checkIfNewDependencyPresents(newGroupId, newArtifactId, newVersion);\n                 // Any managed dependency change is unlikely to use the same version, so only update selectively.\n                 if ((changeManagedDependency == null || changeManagedDependency) && newVersion != null || versionPattern != null) {\n                     doAfterVisit(new ChangeManagedDependencyGroupIdAndArtifactId(\n@@ -170,7 +169,13 @@ public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {\n             @Override\n             public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);\n-                if (isDependencyTag(oldGroupId, oldArtifactId)) {\n+                boolean isOldDependencyTag = isDependencyTag(oldGroupId, oldArtifactId);\n+                if (isOldDependencyTag && isNewDependencyPresent) {\n+                    doAfterVisit(new RemoveContentVisitor<>(tag, true));\n+                    maybeUpdateModel();\n+                    return t;\n+                }\n+                if (isOldDependencyTag) {\n                     String groupId = newGroupId;\n                     if (groupId != null) {\n                         t = changeChildTagValue(t, \"groupId\", groupId, ctx);\n@@ -224,6 +229,16 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 return t;\n             }\n \n+            private boolean checkIfNewDependencyPresents(@Nullable String groupId, @Nullable String artifactId, @Nullable String version) {\n+                if ((groupId == null) || (artifactId == null)) {\n+                    return false;\n+                }\n+                List<ResolvedDependency> dependencies = findDependencies(groupId, artifactId);\n+                return dependencies.stream()\n+                        .filter(ResolvedDependency::isDirect)\n+                        .anyMatch(rd -> (version == null) || version.equals(rd.getVersion()));\n+            }\n+\n             private Xml.Tag changeChildTagValue(Xml.Tag tag, String childTagName, String newValue, ExecutionContext ctx) {\n                 Optional<Xml.Tag> childTag = tag.getChild(childTagName);\n                 if (childTag.isPresent() && !newValue.equals(childTag.get().getValue().orElse(null))) {\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\nindex cc7204ea5a3..f7708a25a60 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\n@@ -22,9 +22,11 @@\n import org.openrewrite.*;\n import org.openrewrite.maven.table.MavenMetadataFailures;\n import org.openrewrite.maven.tree.MavenMetadata;\n+import org.openrewrite.maven.tree.ResolvedManagedDependency;\n import org.openrewrite.semver.Semver;\n import org.openrewrite.semver.VersionComparator;\n import org.openrewrite.xml.ChangeTagValueVisitor;\n+import org.openrewrite.xml.RemoveContentVisitor;\n import org.openrewrite.xml.tree.Xml;\n \n import java.util.*;\n@@ -103,8 +105,7 @@ public Validated<Object> validate() {\n         if (newVersion != null) {\n             validated = validated.and(Semver.validate(newVersion, versionPattern));\n         }\n-        validated =\n-            validated.and(test(\n+        validated = validated.and(test(\n                 \"coordinates\",\n                 \"newGroupId OR newArtifactId must be different from before\",\n                 this,\n@@ -113,7 +114,7 @@ public Validated<Object> validate() {\n                     boolean sameArtifactId = isBlank(r.newArtifactId) || Objects.equals(r.oldArtifactId, r.newArtifactId);\n                     return !(sameGroupId && sameArtifactId);\n                 }\n-            ));\n+        ));\n         return validated;\n     }\n \n@@ -134,6 +135,14 @@ public TreeVisitor<?, ExecutionContext> getVisitor() {\n             final VersionComparator versionComparator = newVersion != null ? Semver.validate(newVersion, versionPattern).getValue() : null;\n             @Nullable\n             private Collection<String> availableVersions;\n+            private boolean isNewDependencyPresent;\n+\n+            @Override\n+            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {\n+                isNewDependencyPresent = checkIfNewDependencyPresents(newGroupId, newArtifactId, newVersion);\n+                return super.visitDocument(document, ctx);\n+            }\n+\n             @Override\n             public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n \n@@ -160,18 +169,45 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                                 t = (Xml.Tag) new ChangeTagValueVisitor<>(versionTag.get(), resolvedNewVersion).visitNonNull(t, 0, getCursor().getParentOrThrow());\n                             }\n                             changed = true;\n-                        } catch(MavenDownloadingException e) {\n+                        } catch (MavenDownloadingException e) {\n                             return e.warn(t);\n                         }\n                     }\n                     if (changed) {\n                         maybeUpdateModel();\n                         doAfterVisit(new RemoveRedundantDependencyVersions(null, null, (RemoveRedundantDependencyVersions.Comparator) null, null).getVisitor());\n+                        if (isNewDependencyPresent) {\n+                            doAfterVisit(new RemoveContentVisitor<>(t, true));\n+                            maybeUpdateModel();\n+                        }\n                     }\n                 }\n                 return t;\n             }\n \n+            private boolean checkIfNewDependencyPresents(@Nullable String groupId, @Nullable String artifactId, @Nullable String version) {\n+                if ((groupId == null) || (artifactId == null)) {\n+                    return false;\n+                }\n+                ResolvedManagedDependency managedDependency = findManagedDependency(groupId, artifactId);\n+                if (managedDependency != null) {\n+                    return compareVersions(version, managedDependency.getVersion());\n+                } else {\n+                    return false;\n+                }\n+            }\n+\n+            private boolean compareVersions(@Nullable String targetVersion, @Nullable String foundVersion) {\n+                if (targetVersion == null) {\n+                    return true;\n+                }\n+                if ((versionComparator != null) && (foundVersion != null)) {\n+                    return versionComparator.isValid(targetVersion, foundVersion);\n+                } else {\n+                    return targetVersion.equals(foundVersion);\n+                }\n+            }\n+\n             @SuppressWarnings(\"ConstantConditions\")\n             private String resolveSemverVersion(ExecutionContext ctx, String groupId, String artifactId, @Nullable String currentVersion) throws MavenDownloadingException {\n                 if (versionComparator == null) {\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\nindex c161d490a51..70bfef61989 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactIdTest.java\n@@ -98,6 +98,316 @@ void changeDependencyGroupIdAndArtifactId() {\n         );\n     }\n \n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4514\")\n+    @Test\n+    void shouldNotAddNewIfDependencyAlreadyExists() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependencyGroupIdAndArtifactId(\n+            \"javax.activation\",\n+            \"javax.activation-api\",\n+            \"jakarta.activation\",\n+            \"jakarta.activation-api\",\n+            null,\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>javax.activation</groupId>\n+                          <artifactId>javax.activation-api</artifactId>\n+                          <version>1.2.0</version>\n+                      </dependency>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                          <version>1.2.1</version>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                          <version>1.2.1</version>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4514\")\n+    @Test\n+    void shouldAddNewIfDependencyAlreadyExistsInOlderVersion() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependencyGroupIdAndArtifactId(\n+            \"javax.activation\",\n+            \"javax.activation-api\",\n+            \"jakarta.activation\",\n+            \"jakarta.activation-api\",\n+            \"1.2.2\",\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>javax.activation</groupId>\n+                          <artifactId>javax.activation-api</artifactId>\n+                          <version>1.2.0</version>\n+                      </dependency>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                          <version>1.2.1</version>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                          <version>1.2.2</version>\n+                      </dependency>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                          <version>1.2.1</version>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4514\")\n+    @Test\n+    void shouldNotAddNewIfDependencyAlreadyExistsWithVersion() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependencyGroupIdAndArtifactId(\n+            \"javax.activation\",\n+            \"javax.activation-api\",\n+            \"jakarta.activation\",\n+            \"jakarta.activation-api\",\n+            \"1.2.1\",\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>javax.activation</groupId>\n+                          <artifactId>javax.activation-api</artifactId>\n+                          <version>1.2.0</version>\n+                      </dependency>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                          <version>1.2.1</version>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                          <version>1.2.1</version>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4514\")\n+    @Test\n+    void shouldNotAddNewIfDependencyAlreadyExistsManaged() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependencyGroupIdAndArtifactId(\n+            \"javax.activation\",\n+            \"javax.activation-api\",\n+            \"jakarta.activation\",\n+            \"jakarta.activation-api\",\n+            null,\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>javax.activation</groupId>\n+                          <artifactId>javax.activation-api</artifactId>\n+                      </dependency>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                      </dependency>\n+                  </dependencies>\n+                  <dependencyManagement>\n+                      <dependencies>\n+                          <dependency>\n+                              <groupId>javax.activation</groupId>\n+                              <artifactId>javax.activation-api</artifactId>\n+                              <version>1.2.0</version>\n+                          </dependency>\n+                          <dependency>\n+                              <groupId>jakarta.activation</groupId>\n+                              <artifactId>jakarta.activation-api</artifactId>\n+                              <version>1.2.1</version>\n+                          </dependency>\n+                      </dependencies>\n+                  </dependencyManagement>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                      </dependency>\n+                  </dependencies>\n+                  <dependencyManagement>\n+                      <dependencies>\n+                          <dependency>\n+                              <groupId>javax.activation</groupId>\n+                              <artifactId>javax.activation-api</artifactId>\n+                              <version>1.2.0</version>\n+                          </dependency>\n+                          <dependency>\n+                              <groupId>jakarta.activation</groupId>\n+                              <artifactId>jakarta.activation-api</artifactId>\n+                              <version>1.2.1</version>\n+                          </dependency>\n+                      </dependencies>\n+                  </dependencyManagement>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4514\")\n+    @Test\n+    void shouldNotAddNewIfDependencyAlreadyExistsManagedWithVersion() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependencyGroupIdAndArtifactId(\n+            \"javax.activation\",\n+            \"javax.activation-api\",\n+            \"jakarta.activation\",\n+            \"jakarta.activation-api\",\n+            \"1.2.1\",\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>javax.activation</groupId>\n+                          <artifactId>javax.activation-api</artifactId>\n+                      </dependency>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                      </dependency>\n+                  </dependencies>\n+                  <dependencyManagement>\n+                      <dependencies>\n+                          <dependency>\n+                              <groupId>javax.activation</groupId>\n+                              <artifactId>javax.activation-api</artifactId>\n+                              <version>1.2.0</version>\n+                          </dependency>\n+                          <dependency>\n+                              <groupId>jakarta.activation</groupId>\n+                              <artifactId>jakarta.activation-api</artifactId>\n+                              <version>1.2.1</version>\n+                          </dependency>\n+                      </dependencies>\n+                  </dependencyManagement>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>jakarta.activation</groupId>\n+                          <artifactId>jakarta.activation-api</artifactId>\n+                      </dependency>\n+                  </dependencies>\n+                  <dependencyManagement>\n+                      <dependencies>\n+                          <dependency>\n+                              <groupId>jakarta.activation</groupId>\n+                              <artifactId>jakarta.activation-api</artifactId>\n+                              <version>1.2.1</version>\n+                          </dependency>\n+                      </dependencies>\n+                  </dependencyManagement>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void changeManagedDependencyGroupIdAndArtifactId() {\n         rewriteRun(\n\ndiff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java\nindex b1458dda26d..fa2d894528a 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactIdTest.java\n@@ -127,6 +127,115 @@ void changeManagedDependencyWithDynamicVersion() {\n         );\n     }\n \n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4514\")\n+    @Test\n+    void removeOldDependencyIfNewAlreadyExists() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeManagedDependencyGroupIdAndArtifactId(\n+            \"javax.activation\",\n+            \"javax.activation-api\",\n+            \"jakarta.activation\",\n+            \"jakarta.activation-api\",\n+            \"2.1.0\"\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencyManagement>\n+                      <dependencies>\n+                          <dependency>\n+                              <groupId>javax.activation</groupId>\n+                              <artifactId>javax.activation-api</artifactId>\n+                              <version>1.2.0</version>\n+                          </dependency>\n+                          <dependency>\n+                              <groupId>jakarta.activation</groupId>\n+                              <artifactId>jakarta.activation-api</artifactId>\n+                              <version>2.1.0</version>\n+                          </dependency>\n+                      </dependencies>\n+                  </dependencyManagement>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencyManagement>\n+                      <dependencies>\n+                          <dependency>\n+                              <groupId>jakarta.activation</groupId>\n+                              <artifactId>jakarta.activation-api</artifactId>\n+                              <version>2.1.0</version>\n+                          </dependency>\n+                      </dependencies>\n+                  </dependencyManagement>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4514\")\n+    @Test\n+    void removeOldDependencyVersionWithPattern() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeManagedDependencyGroupIdAndArtifactId(\n+            \"jakarta.activation\",\n+            \"jakarta.activation-api\",\n+            \"com.google.guava\",\n+            \"guava\",\n+            \"32.0.X\",\n+            \"-jre\"\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencyManagement>\n+                      <dependencies>\n+                          <dependency>\n+                             <groupId>com.google.guava</groupId>\n+                             <artifactId>guava</artifactId>\n+                             <version>32.0.1-jre</version>\n+                          </dependency>\n+                          <dependency>\n+                              <groupId>jakarta.activation</groupId>\n+                              <artifactId>jakarta.activation-api</artifactId>\n+                              <version>2.1.0</version>\n+                          </dependency>\n+                      </dependencies>\n+                  </dependencyManagement>\n+              </project>\"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <dependencyManagement>\n+                      <dependencies>\n+                          <dependency>\n+                             <groupId>com.google.guava</groupId>\n+                             <artifactId>guava</artifactId>\n+                             <version>32.0.1-jre</version>\n+                          </dependency>\n+                      </dependencies>\n+                  </dependencyManagement>\n+              </project>\"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void latestPatchMangedDependency() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4511",
    "pr_id": 4511,
    "issue_id": 4325,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Capture `MavenMetadata.lastUpdated` for a recipe that shows outdated dependencies\n## What problem are you trying to solve?\r\nApart from the most recent version, we might also be interested in capturing when that dependency was last updated.\r\n\r\nThis then allows for a recipe that tells out where you might be using dependencies that have not seen a release in a long time,\r\nperhaps because they have been relocated: https://docs.openrewrite.org/recipes/java/dependencies/relocateddependencycheck\r\n\r\n## Describe the solution you'd like\r\nAdd a `lastUpdated` field to `MavenMetadata.Versioning`\r\nhttps://github.com/openrewrite/rewrite/blob/56986647f0c8b8a162d548d52c70572b939f1d0a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/MavenMetadata.java#L55-L63\r\n\r\nBased on the metadata pulblished in Maven repositories.\r\n```xml\r\n<metadata>\r\n  <groupId>org.openrewrite.recipe</groupId>\r\n  <artifactId>rewrite-recipe-bom</artifactId>\r\n  <versioning>\r\n    <latest>2.15.0-SNAPSHOT</latest>\r\n    <versions>\r\n      <version>0.1.0-SNAPSHOT</version>\r\n      <!-- truncated -->\r\n      <version>2.15.0-SNAPSHOT</version>\r\n    </versions>\r\n    <lastUpdated>20240712162001</lastUpdated>\r\n  </versioning>\r\n</metadata>\r\n```\r\nhttps://oss.sonatype.org/service/local/repositories/snapshots/content/org/openrewrite/recipe/rewrite-recipe-bom/maven-metadata.xml\r\nhttps://repo1.maven.org/maven2/org/openrewrite/recipe/rewrite-recipe-bom/maven-metadata.xml\r\n\r\n## Additional context\r\nInspired by https://github.com/Giovds/outdated-maven-plugin",
    "issue_word_count": 198,
    "test_files_count": 1,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenXmlMapper.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/tree/MavenMetadata.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenMetadataTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenMetadataTest.java"
    ],
    "base_commit": "25d374b7c9500c6651dff001f62ea15cff4f9702",
    "head_commit": "81442ec25ae0bfc8e2fcd8636359a91ff619a71e",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4511",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4511",
    "dockerfile": "",
    "pr_merged_at": "2024-09-23T09:47:43.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\nindex 1128692801f..82560e7cd57 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\n@@ -42,6 +42,7 @@\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.time.Duration;\n+import java.time.ZonedDateTime;\n import java.util.*;\n import java.util.concurrent.TimeoutException;\n import java.util.regex.Matcher;\n@@ -392,7 +393,7 @@ public MavenMetadata downloadMetadata(GroupArtifactVersion gav, @Nullable Resolv\n                         versions.add(path.getFileName().toString());\n                     }\n                 }\n-                return new MavenMetadata.Versioning(versions, null, null);\n+                return new MavenMetadata.Versioning(versions, null, null, null);\n             } catch (IOException e) {\n                 throw new MavenDownloadingException(\"Unable to derive metadata from file repository. \" + e.getMessage(), null, gav);\n             }\n@@ -422,7 +423,7 @@ public MavenMetadata downloadMetadata(GroupArtifactVersion gav, @Nullable Resolv\n             return null;\n         }\n \n-        return new MavenMetadata.Versioning(versions, null, null);\n+        return new MavenMetadata.Versioning(versions, null, null, null);\n     }\n \n     String hrefToVersion(String href, String rootUri) {\n@@ -446,10 +447,15 @@ protected MavenMetadata mergeMetadata(MavenMetadata m1, MavenMetadata m2) {\n                 mergeVersions(m1.getVersioning().getVersions(), m2.getVersioning().getVersions()),\n                 Stream.concat(m1.getVersioning().getSnapshotVersions() == null ? Stream.empty() : m1.getVersioning().getSnapshotVersions().stream(),\n                         m2.getVersioning().getSnapshotVersions() == null ? Stream.empty() : m2.getVersioning().getSnapshotVersions().stream()).collect(toList()),\n-                maxSnapshot(m1.getVersioning().getSnapshot(), m2.getVersioning().getSnapshot())\n+                maxSnapshot(m1.getVersioning().getSnapshot(), m2.getVersioning().getSnapshot()),\n+                maxLastUpdated(m1.getVersioning().getLastUpdated(), m2.getVersioning().getLastUpdated())\n         ));\n     }\n \n+    private @Nullable ZonedDateTime maxLastUpdated(@Nullable ZonedDateTime left, @Nullable ZonedDateTime right) {\n+        return left == null ? right : right == null ? left : left.compareTo(right) >= 0 ? left : right;\n+    }\n+\n     private List<String> mergeVersions(List<String> versions1, List<String> versions2) {\n         Set<String> merged = new HashSet<>(versions1);\n         merged.addAll(versions2);\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenXmlMapper.java b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenXmlMapper.java\nindex ac54c3f3969..15fa541779b 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenXmlMapper.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenXmlMapper.java\n@@ -28,6 +28,7 @@\n import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\n+import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\n import com.fasterxml.jackson.module.jaxb.JaxbAnnotationModule;\n import com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\n \n@@ -63,6 +64,7 @@ public class MavenXmlMapper {\n                         .withGetterVisibility(JsonAutoDetect.Visibility.NONE)\n                         .withSetterVisibility(JsonAutoDetect.Visibility.NONE)\n                         .withCreatorVisibility(JsonAutoDetect.Visibility.PUBLIC_ONLY))\n+                .registerModule(new JavaTimeModule())\n                 .registerModule(new StringTrimModule());\n \n         writeMapper = XmlMapper.builder(xmlFactory)\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/MavenMetadata.java b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/MavenMetadata.java\nindex 019c5034b34..2ece965a7f5 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/MavenMetadata.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/MavenMetadata.java\n@@ -15,6 +15,7 @@\n  */\n package org.openrewrite.maven.tree;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n import lombok.AccessLevel;\n import lombok.Getter;\n@@ -22,12 +23,11 @@\n import lombok.experimental.FieldDefaults;\n import org.jspecify.annotations.Nullable;\n import org.openrewrite.maven.internal.MavenXmlMapper;\n-import org.openrewrite.xml.XmlParser;\n \n import java.io.IOException;\n import java.io.InputStream;\n import java.io.UncheckedIOException;\n-import java.nio.file.Path;\n+import java.time.ZonedDateTime;\n import java.util.List;\n \n import static java.util.Collections.emptyList;\n@@ -35,14 +35,7 @@\n @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n @Getter\n public class MavenMetadata {\n-    private static final XmlParser xmlParser = new XmlParser() {\n-        @Override\n-        public boolean accept(Path path) {\n-            return super.accept(path) || path.toString().endsWith(\".pom\");\n-        }\n-    };\n-\n-    public static final MavenMetadata EMPTY = new MavenMetadata(new MavenMetadata.Versioning(emptyList(), emptyList(), null));\n+    public static final MavenMetadata EMPTY = new MavenMetadata(new MavenMetadata.Versioning(emptyList(), emptyList(), null, null));\n \n     Versioning versioning;\n \n@@ -62,10 +55,15 @@ public static class Versioning {\n         @Nullable\n         Snapshot snapshot;\n \n+        @Nullable\n+        ZonedDateTime lastUpdated;\n+\n         public Versioning(\n                 @JacksonXmlElementWrapper(localName = \"versions\") List<String> versions,\n                 @JacksonXmlElementWrapper(localName = \"snapshotVersions\") @Nullable List<SnapshotVersion> snapshotVersions,\n-                @Nullable Snapshot snapshot) {\n+                @Nullable Snapshot snapshot,\n+                @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \"yyyyMMddHHmmss\", timezone = \"UTC\") @Nullable ZonedDateTime lastUpdated) {\n+            this.lastUpdated = lastUpdated;\n             this.versions = versions;\n             this.snapshotVersions = snapshotVersions;\n             this.snapshot = snapshot;\n@@ -83,7 +81,11 @@ public static MavenMetadata parse(InputStream document) {\n     public static @Nullable MavenMetadata parse(byte[] document) throws IOException {\n         MavenMetadata metadata = MavenXmlMapper.readMapper().readValue(document, MavenMetadata.class);\n         if (metadata != null && metadata.getVersioning() != null && metadata.getVersioning().getVersions() == null) {\n-            return new MavenMetadata(new Versioning(emptyList(), metadata.getVersioning().getSnapshotVersions(), metadata.getVersioning().getSnapshot()));\n+            return new MavenMetadata(new Versioning(\n+                    emptyList(),\n+                    metadata.getVersioning().getSnapshotVersions(),\n+                    metadata.getVersioning().getSnapshot(),\n+                    metadata.getVersioning().getLastUpdated()));\n         }\n         return metadata;\n     }\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenMetadataTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenMetadataTest.java\nindex cd3b87a8195..5d38c46284c 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenMetadataTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenMetadataTest.java\n@@ -21,7 +21,9 @@\n import org.openrewrite.maven.tree.MavenMetadata;\n \n import java.io.IOException;\n+import java.time.ZonedDateTime;\n \n+import static java.time.ZoneOffset.UTC;\n import static org.assertj.core.api.Assertions.assertThat;\n \n class MavenMetadataTest {\n@@ -46,6 +48,7 @@ void deserializeMetadata() throws IOException {\n \n         MavenMetadata parsed = MavenMetadata.parse(metadata.getBytes());\n         assertThat(parsed.getVersioning().getVersions()).hasSize(2);\n+        assertThat(parsed.getVersioning().getLastUpdated()).isEqualTo(ZonedDateTime.of(2021, 1, 15, 4, 27, 54, 0, UTC));\n     }\n \n     @SuppressWarnings(\"ConstantConditions\")\n@@ -80,6 +83,7 @@ void deserializeSnapshotMetadata() throws IOException {\n         MavenMetadata parsed = MavenMetadata.parse(metadata.getBytes());\n         MavenMetadata.Versioning versioning = parsed.getVersioning();\n \n+        assertThat(versioning.getLastUpdated()).isNull();\n         assertThat(versioning.getSnapshot().getTimestamp()).isEqualTo(\"20220927.033510\");\n         assertThat(versioning.getSnapshot().getBuildNumber()).isEqualTo(\"223\");\n         assertThat(versioning.getVersions()).isNotNull();\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4505",
    "pr_id": 4505,
    "issue_id": 4003,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Declarative Preconditions - `or` association\n<!--\r\nThank you for suggesting an improvement to OpenRewrite!\r\nFeel free to delete any sections that don't apply to your request.\r\n-->\r\n## What problem are you trying to solve?\r\nDeclarative preconditions currently associate via `AND` if you declare multiple on the same recipe.\r\nIf you want to achieve an `OR` relationship, you can do it, but through a much more verbose \"diamond\" pattern.\r\n\r\nSample:\r\n```yml\r\n---\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: org.sample.DoSomething\r\ndisplayName: Do Something\r\nrecipeList:\r\n  - org.sample.DoSomething.condition.1\r\n  - org.sample.DoSomething.condition.2\r\n  - org.sample.DoSomething.condition.3\r\n\r\n---\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: org.sample.DoSomething.condition.1\r\ndisplayName: Do Something (condition 1)\r\npreconditions:\r\n  - org.openrewrite.FindSourceFiles:\r\n      filePattern: \"**/my.json\"\r\nrecipeList:\r\n  - org.sample.DoSomething.for.real\r\n\r\n---\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: org.sample.DoSomething.condition.2\r\ndisplayName: Do Something (condition 2)\r\npreconditions:\r\n  - org.openrewrite.FindSourceFiles:\r\n      filePattern: \"**/your.json\"\r\nrecipeList:\r\n  - org.sample.DoSomething.for.real  \r\n\r\n---\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: org.sample.DoSomething.condition.3\r\ndisplayName: Do Something (condition 3)\r\npreconditions:\r\n  - org.openrewrite.FindSourceFiles:\r\n      filePattern: \"**/our.json\"\r\nrecipeList:\r\n  - org.sample.DoSomething.for.real\r\n\r\n---\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: org.sample.DoSomething.for.real\r\ndisplayName: Do Something (for real)\r\nrecipeList:\r\n  - org.openrewrite.json.ChangeKey:\r\n      qwe: qwe\r\n\r\n```\r\n(if you imagine graphing how those 5 recipes relate to each other, it kinda looks like a diamond)\r\n\r\n## Describe the solution you'd like\r\n\r\n```yml\r\n---\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: org.sample.DoSomething\r\ndisplayName: Do Something\r\npreconditionAssociation: OR\r\npreconditions:\r\n  - org.openrewrite.FindSourceFiles:\r\n      filePattern: \"**/my.json\"\r\n  - org.openrewrite.FindSourceFiles:\r\n      filePattern: \"**/your.json\"\r\n  - org.openrewrite.FindSourceFiles:\r\n      filePattern: \"**/our.json\"\r\nrecipeList:\r\n  - org.openrewrite.json.ChangeKey:\r\n      qwe: qwe\r\n\r\n```\r\n\r\n## Have you considered any alternatives or workarounds?\r\nSupport for passing nested recipes as recipe arguments in declarative recipes? :)\r\nThis could allow something like:\r\n\r\n```yml\r\n---\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: org.sample.DoSomething\r\ndisplayName: Do Something\r\npreconditionAssociation: OR\r\npreconditions:\r\n  - org.openrewrite.Preconditions.Or:\r\n      recipeList:\r\n        - org.openrewrite.FindSourceFiles:\r\n            filePattern: \"**/my.json\"\r\n        - org.openrewrite.FindSourceFiles:\r\n            filePattern: \"**/your.json\"\r\n        - org.openrewrite.FindSourceFiles:\r\n            filePattern: \"**/our.json\"\r\nrecipeList:\r\n  - org.openrewrite.json.ChangeKey:\r\n      qwe: qwe\r\n\r\n```\r\n\r\n## Additional context\r\n<!-- Any thoughts that come to mind, or similar items on the backlog already. -->\r\ncc @sambsnyd \r\n\r\n## Are you interested in [contributing this feature to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#new-features)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\nAssuming we can bless a design, yeah, I suspect the code won't be too treacherous",
    "issue_word_count": 421,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/config/DeclarativeRecipe.java",
      "rewrite-core/src/test/java/org/openrewrite/config/DeclarativeRecipeTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-core/src/test/java/org/openrewrite/config/DeclarativeRecipeTest.java"
    ],
    "base_commit": "1ed522465adf529a2fdfdb84eff31f0eef8de0cf",
    "head_commit": "456be8c4535b8ba92275df726182262675a60843",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4505",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4505",
    "dockerfile": "",
    "pr_merged_at": "2024-09-20T15:11:43.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/config/DeclarativeRecipe.java b/rewrite-core/src/main/java/org/openrewrite/config/DeclarativeRecipe.java\nindex 150575a3217..0ecfab865fd 100644\n--- a/rewrite-core/src/main/java/org/openrewrite/config/DeclarativeRecipe.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/config/DeclarativeRecipe.java\n@@ -270,7 +270,7 @@ public final List<Recipe> getRecipeList() {\n                         getName() + \" declares the ScanningRecipe \" + precondition.getName() + \" as a precondition.\" +\n                         \"ScanningRecipe cannot be used as Preconditions.\");\n             }\n-            andPreconditions.add(precondition::getVisitor);\n+            andPreconditions.add(() -> orVisitors(precondition));\n         }\n         PreconditionBellwether bellwether = new PreconditionBellwether(Preconditions.and(andPreconditions.toArray(new Supplier[]{})));\n         List<Recipe> recipeListWithBellwether = new ArrayList<>(recipeList.size() + 1);\n@@ -279,6 +279,16 @@ public final List<Recipe> getRecipeList() {\n         return recipeListWithBellwether;\n     }\n \n+    private static TreeVisitor<?, ExecutionContext> orVisitors(Recipe recipe) {\n+        List<TreeVisitor<?, ExecutionContext>> conditions = new ArrayList<>();\n+        conditions.add(recipe.getVisitor());\n+        for (Recipe r : recipe.getRecipeList()) {\n+            conditions.add(orVisitors(r));\n+        }\n+        //noinspection unchecked\n+        return Preconditions.or(conditions.toArray(new TreeVisitor[0]));\n+    }\n+\n     private static boolean isScanningRecipe(Recipe recipe) {\n         if (recipe instanceof ScanningRecipe) {\n             return true;\n",
    "test_patch": "diff --git a/rewrite-core/src/test/java/org/openrewrite/config/DeclarativeRecipeTest.java b/rewrite-core/src/test/java/org/openrewrite/config/DeclarativeRecipeTest.java\nindex a70b9c7701d..22f8f6ee263 100644\n--- a/rewrite-core/src/test/java/org/openrewrite/config/DeclarativeRecipeTest.java\n+++ b/rewrite-core/src/test/java/org/openrewrite/config/DeclarativeRecipeTest.java\n@@ -174,6 +174,65 @@ void yamlPrecondition() {\n         );\n     }\n \n+    @Test\n+    void yamlDeclarativeRecipeAsPrecondition() {\n+        rewriteRun(\n+          spec -> spec.recipeFromYaml(\n+            \"\"\"\n+            type: specs.openrewrite.org/v1beta/recipe\n+            name: org.openrewrite.PreconditionTest\n+            description: Test.\n+            preconditions:\n+              - org.openrewrite.DeclarativePrecondition\n+            recipeList:\n+              - org.openrewrite.text.ChangeText:\n+                 toText: 3\n+            ---\n+            type: specs.openrewrite.org/v1beta/recipe\n+            name: org.openrewrite.DeclarativePrecondition\n+            recipeList:\n+              - org.openrewrite.text.Find:\n+                  find: 1\n+            \"\"\",\n+            \"org.openrewrite.PreconditionTest\"\n+          ),\n+          text(\"1\", \"3\"),\n+          text(\"2\")\n+        );\n+    }\n+\n+    @Test\n+    void orPreconditions() {\n+        // As documented https://docs.openrewrite.org/reference/yaml-format-reference#creating-or-preconditions-instead-of-and\n+        rewriteRun(\n+          spec -> spec.recipeFromYaml(\n+            \"\"\"\n+              type: specs.openrewrite.org/v1beta/recipe\n+              name: org.sample.DoSomething\n+              description: Test.\n+              preconditions:\n+                - org.sample.FindAnyJson\n+              recipeList:\n+                - org.openrewrite.text.ChangeText:\n+                   toText: 2\n+              ---\n+              type: specs.openrewrite.org/v1beta/recipe\n+              name: org.sample.FindAnyJson\n+              recipeList:\n+                - org.openrewrite.FindSourceFiles:\n+                    filePattern: \"**/my.json\"\n+                - org.openrewrite.FindSourceFiles:\n+                    filePattern: \"**/your.json\"\n+                - org.openrewrite.FindSourceFiles:\n+                    filePattern: \"**/our.json\"\n+              \"\"\",\n+            \"org.sample.DoSomething\"\n+          ),\n+          text(\"1\", \"2\", spec -> spec.path(\"a/my.json\")),\n+          text(\"a\", spec -> spec.path(\"a/not-my.json\"))\n+        );\n+    }\n+\n     @Test\n     void yamlPreconditionWithScanningRecipe() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4491",
    "pr_id": 4491,
    "issue_id": 4490,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Update gradle wrapper adds wrong wrapper when customDistributionUrl is requested.\nIn the event of a gradle wrapper that needs to be added to a project that does not contain one AND the distributionUrl is mentioned, this code will no add the correct wrapper. \r\n\r\nIf the outside world is reachable, this try block does not fail -> the distribution url is not used and the wrong wrapper gets added. \r\n\r\nhttps://github.com/openrewrite/rewrite/blob/0b6914b82be589bb6924f273c7ee2cb6c873b853/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateGradleWrapper.java#L124-L160\r\n\r\nThe Gradle wrapper will be created using the outside world services gradle and we will never reach the distributionUrl wrapper additions. \r\n\r\nhttps://github.com/openrewrite/rewrite/blob/0b6914b82be589bb6924f273c7ee2cb6c873b853/rewrite-gradle/src/main/java/org/openrewrite/gradle/util/GradleWrapper.java#L60-L90\r\n\r\n\r\nThe recipe from the list: \r\n<img width=\"683\" alt=\"Screenshot 2024-09-13 at 12 04 19\" src=\"https://github.com/user-attachments/assets/a0c52692-84d6-45f5-b648-7d2d5c2beca1\">\r\n\r\nThe output: \r\n<img width=\"1495\" alt=\"Screenshot 2024-09-13 at 12 04 45\" src=\"https://github.com/user-attachments/assets/d6033978-6bac-48aa-9166-733ed003497e\">\r\n\r\nI think if we rework the getWrapper method we could fix this. \r\n\r\n```java \r\n    private GradleWrapper getGradleWrapper(ExecutionContext ctx) {\r\n        if (gradleWrapper != null) {\r\n            return gradleWrapper;\r\n        }\r\n        if (wrapperUri != null) {\r\n            if (wrapperUri.contains(\"${version})\")) {\r\n                if (version == null) {\r\n                    throw new IllegalArgumentException(\r\n                            \"wrapperUri contains a ${version} interpolation specifier but no version parameter was specified.\");\r\n                }\r\n                if (!version.matches(\"[0-9.]+\")) {\r\n                    throw new IllegalArgumentException(\r\n                            \"Version selectors like \\\"\" + version + \"\\\" are unavailable when custom distribution url is used. \" +\r\n                            \"Specify an exact, literal version number.\");\r\n                }\r\n            }\r\n            String effectiveWrapperUri = wrapperUri\r\n                    .replace(\"${version}\", version == null ? \"\" : version)\r\n                    .replace(\"${distribution}\", distribution == null ? \"bin\" : distribution);\r\n            gradleWrapper = GradleWrapper.create(URI.create(effectiveWrapperUri), ctx);\r\n        } else {\r\n            try {\r\n                gradleWrapper = GradleWrapper.create(distribution, version, null, ctx);\r\n            } catch (Exception e) {\r\n                // services.gradle.org is unreachable, possibly because of a firewall\r\n                // But if the user specified a wrapperUri to an internal repository things might still be workable\r\n                // If the user didn't specify a wrapperUri, but they did provide a specific version we assume they know this version\r\n                // is available from whichever distribution url they were previously using and update the version\r\n                if (!StringUtils.isBlank(version) && Semver.validate(version, null).getValue() instanceof ExactVersion) {\r\n                    gradleWrapper = new GradleWrapper(version, new DistributionInfos(\"\", null, null));\r\n                } else {\r\n                    throw new IllegalArgumentException(\r\n                            \"Could not reach services.gradle.org, no alternative wrapper URI is provided and no exact version is provided. \" +\r\n                            \"To use this recipe in environments where services.gradle.org is unavailable specify a wrapperUri or exact version.\", e);\r\n                }\r\n            }\r\n        }\r\n        return gradleWrapper;\r\n    }\r\n```",
    "issue_word_count": 412,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateGradleWrapper.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpdateGradleWrapperTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpdateGradleWrapperTest.java"
    ],
    "base_commit": "0b6914b82be589bb6924f273c7ee2cb6c873b853",
    "head_commit": "15a8ebc4030706976be1518661c69b78b1e9dbf0",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4491",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4491",
    "dockerfile": "",
    "pr_merged_at": "2024-09-25T17:30:59.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateGradleWrapper.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateGradleWrapper.java\nindex 67ba93dbf15..84f1a9ad0e5 100755\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateGradleWrapper.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateGradleWrapper.java\n@@ -48,7 +48,6 @@\n import static java.util.Objects.requireNonNull;\n import static org.openrewrite.PathUtils.equalIgnoringSeparators;\n import static org.openrewrite.gradle.util.GradleWrapper.*;\n-import static org.openrewrite.internal.StringUtils.formatUriForPropertiesFile;\n import static org.openrewrite.internal.StringUtils.isBlank;\n \n @RequiredArgsConstructor\n@@ -108,9 +107,23 @@ public String getDescription() {\n     @Nullable\n     final String wrapperUri;\n \n+    @Getter\n+    @Option(example = \"29e49b10984e585d8118b7d0bc452f944e386458df27371b49b4ac1dec4b7fda\",\n+            description = \"The SHA-256 checksum of the Gradle distribution. \" +\n+                          \"If specified, the recipe will add the checksum along with the custom distribution URL.\",\n+            required = false)\n+    @Nullable\n+    final String distributionChecksum;\n+\n     @Override\n     public Validated<Object> validate() {\n         Validated<Object> validated = super.validate();\n+        if (wrapperUri != null && (version != null || distribution != null)) {\n+            return Validated.invalid(\"wrapperUri\", wrapperUri, \"WrapperUri cannot be used with version and/or distribution parameter\");\n+        }\n+        if (wrapperUri == null && distributionChecksum != null) {\n+            return Validated.invalid(\"distributionChecksum\", distributionChecksum, \"DistributionChecksum can only be used with wrapperUri\");\n+        }\n         if (version != null) {\n             validated = validated.and(Semver.validate(version, null));\n         }\n@@ -123,37 +136,21 @@ public Validated<Object> validate() {\n \n     private GradleWrapper getGradleWrapper(ExecutionContext ctx) {\n         if (gradleWrapper == null) {\n+            if (wrapperUri != null) {\n+                return gradleWrapper = GradleWrapper.create(URI.create(wrapperUri), ctx);\n+            }\n             try {\n                 gradleWrapper = GradleWrapper.create(distribution, version, null, ctx);\n             } catch (Exception e) {\n-                // services.gradle.org is unreachable, possibly because of a firewall\n-                // But if the user specified a wrapperUri to an internal repository things might still be workable\n-                if (wrapperUri == null) {\n-                    // If the user didn't specify a wrapperUri, but they did provide a specific version we assume they know this version\n-                    // is available from whichever distribution url they were previously using and update the version\n-                    if (!StringUtils.isBlank(version) && Semver.validate(version, null).getValue() instanceof ExactVersion) {\n-                        return gradleWrapper = new GradleWrapper(version, new DistributionInfos(\"\", null, null));\n-                    } else {\n-                        throw new IllegalArgumentException(\n-                                \"Could not reach services.gradle.org, no alternative wrapper URI is provided and no exact version is provided. \" +\n-                                \"To use this recipe in environments where services.gradle.org is unavailable specify a wrapperUri or exact version.\", e);\n-                    }\n+                // services.gradle.org is unreachable\n+                // If the user didn't specify a wrapperUri, but they did provide a specific version we assume they know this version\n+                // is available from whichever distribution url they were previously using and update the version\n+                if (!StringUtils.isBlank(version) && Semver.validate(version, null).getValue() instanceof ExactVersion) {\n+                    return gradleWrapper = new GradleWrapper(version, new DistributionInfos(\"\", null, null));\n                 }\n-                if (wrapperUri.contains(\"${version})\")) {\n-                    if (version == null) {\n-                        throw new IllegalArgumentException(\n-                                \"wrapperUri contains a ${version} interpolation specifier but no version parameter was specified.\", e);\n-                    }\n-                    if (!version.matches(\"[0-9.]+\")) {\n-                        throw new IllegalArgumentException(\n-                                \"Version selectors like \\\"\" + version + \"\\\" are unavailable when services.gradle.org cannot be reached. \" +\n-                                \"Specify an exact, literal version number.\", e);\n-                    }\n-                }\n-                String effectiveWrapperUri = wrapperUri\n-                        .replace(\"${version}\", version == null ? \"\" : version)\n-                        .replace(\"${distribution}\", distribution == null ? \"bin\" : distribution);\n-                gradleWrapper = GradleWrapper.create(URI.create(effectiveWrapperUri), ctx);\n+                throw new IllegalArgumentException(\n+                        \"Could not reach services.gradle.org. \" +\n+                        \"To use this recipe in environments where services.gradle.org is unavailable specify a wrapperUri or exact version.\", e);\n             }\n         }\n         return gradleWrapper;\n@@ -222,16 +219,26 @@ public Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {\n                             return entry;\n                         }\n \n-                        // Typical example: https://services.gradle.org/distributions/gradle-7.4-all.zip\n+                        // Typical example: https://services.gradle.org/distributions/gradle-7.4-all.zip or https://company.com/repo/gradle-8.2-bin.zip\n                         String currentDistributionUrl = entry.getValue().getText();\n \n                         GradleWrapper gradleWrpr = getGradleWrapper(ctx);\n-                        if (StringUtils.isBlank(gradleWrpr.getDistributionUrl()) &&\n-                            !StringUtils.isBlank(version)  && Semver.validate(version, null).getValue() instanceof ExactVersion) {\n+                        if (StringUtils.isBlank(gradleWrpr.getDistributionUrl()) && !StringUtils.isBlank(version) &&\n+                            Semver.validate(version, null).getValue() instanceof ExactVersion) {\n                             String newDownloadUrl = currentDistributionUrl.replace(\"\\\\\", \"\")\n-                                    .replaceAll(\"(.*gradle-)(\\\\d+\\\\.\\\\d+(?:\\\\.\\\\d+)?)(.*-(?:bin|all).zip)\", \"$1\" + gradleWrapper.getVersion() + \"$3\");\n+                                    .replaceAll(\"(.*gradle-)(\\\\d+\\\\.\\\\d+(?:\\\\.\\\\d+)?)(.*-(?:bin|all).zip)\",\n+                                            \"$1\" + gradleWrapper.getVersion() + \"$3\");\n                             gradleWrapper = new GradleWrapper(version, new DistributionInfos(newDownloadUrl, null, null));\n                         }\n+                        String wrapperHost = currentDistributionUrl.substring(0, currentDistributionUrl.lastIndexOf(\"/\")) + \"/gradle-\";\n+                        if (StringUtils.isBlank(wrapperUri) && !StringUtils.isBlank(gradleWrpr.getDistributionUrl()) &&\n+                            !gradleWrpr.getPropertiesFormattedUrl().startsWith(wrapperHost)) {\n+                            String newDownloadUrl = gradleWrpr.getDistributionUrl()\n+                                    .replace(\"\\\\\", \"\")\n+                                    .replaceAll(\"(.*gradle-)(\\\\d+\\\\.\\\\d+(?:\\\\.\\\\d+)?)(.*-(?:bin|all).zip)\",\n+                                            wrapperHost + gradleWrapper.getVersion() + \"$3\");\n+                            gradleWrapper = new GradleWrapper(gradleWrpr.getVersion(), new DistributionInfos(newDownloadUrl, null, null));\n+                        }\n \n                         if (!gradleWrapper.getPropertiesFormattedUrl().equals(currentDistributionUrl)) {\n                             acc.needsWrapperUpdate = true;\n@@ -292,12 +299,17 @@ public Collection<SourceFile> generate(GradleWrapperState acc, ExecutionContext\n         GradleWrapper gradleWrapper = getGradleWrapper(ctx);\n \n         if (acc.addGradleWrapperProperties) {\n+            String checksum = gradleWrapper.getDistributionChecksum() == null ? null : gradleWrapper.getDistributionChecksum().getHexValue();\n+            if (wrapperUri != null && distributionChecksum != null && checksum == null) {\n+                checksum = distributionChecksum;\n+            }\n+\n             //noinspection UnusedProperty\n             Properties.File gradleWrapperProperties = new PropertiesParser().parse(\n                             \"distributionBase=GRADLE_USER_HOME\\n\" +\n                             \"distributionPath=wrapper/dists\\n\" +\n                             \"distributionUrl=\" + gradleWrapper.getPropertiesFormattedUrl() + \"\\n\" +\n-                            ((gradleWrapper.getDistributionChecksum() == null) ? \"\" : \"distributionSha256Sum=\" + gradleWrapper.getDistributionChecksum().getHexValue() + \"\\n\") +\n+                            (checksum == null ? \"\" : \"distributionSha256Sum=\" + checksum + \"\\n\") +\n                             \"zipStoreBase=GRADLE_USER_HOME\\n\" +\n                             \"zipStorePath=wrapper/dists\")\n                     .findFirst()\n@@ -480,6 +492,14 @@ public Properties visitFile(Properties.File file, ExecutionContext ctx) {\n                 Properties.Entry entry = new Properties.Entry(Tree.randomId(), \"\\n\", Markers.EMPTY, DISTRIBUTION_SHA_256_SUM_KEY, \"\", Properties.Entry.Delimiter.EQUALS, propertyValue);\n                 List<Properties.Content> contentList = ListUtils.concat(((Properties.File) p).getContent(), entry);\n                 p = ((Properties.File) p).withContent(contentList);\n+            } else if (!checksumKey.isEmpty() && gradleWrapper.getDistributionChecksum() == null) {\n+                List<Properties.Content> contentList = ListUtils.map(((Properties.File) p).getContent(), c -> {\n+                    if (c instanceof Properties.Entry && DISTRIBUTION_SHA_256_SUM_KEY.equals(((Properties.Entry) c).getKey())) {\n+                        return null;\n+                    }\n+                    return c;\n+                });\n+                p = ((Properties.File) p).withContent(contentList);\n             }\n             return p;\n         }\n@@ -488,22 +508,7 @@ public Properties visitFile(Properties.File file, ExecutionContext ctx) {\n         public Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {\n             if (\"distributionUrl\".equals(entry.getKey())) {\n                 Properties.Value value = entry.getValue();\n-                String currentUrl = value.getText();\n-                // Prefer wrapperUri specified directly in the recipe over other options\n-                // If that isn't set, prefer the existing artifact repository URL over changing to services.gradle.org\n-                if (!StringUtils.isBlank(wrapperUri)) {\n-                    String effectiveWrapperUri = formatUriForPropertiesFile(wrapperUri\n-                            .replace(\"${version}\", gradleWrapper.getVersion())\n-                            .replace(\"${distribution}\", distribution == null ? \"bin\" : distribution));\n-                    return entry.withValue(value.withText(effectiveWrapperUri));\n-                } else if (currentUrl.startsWith(\"https\\\\://services.gradle.org/distributions/\")) {\n-                    return entry.withValue(value.withText(gradleWrapper.getPropertiesFormattedUrl()));\n-                } else {\n-                    String gradleServicesDistributionUrl = gradleWrapper.getDistributionUrl();\n-                    String newDistributionFile = gradleServicesDistributionUrl.substring(gradleServicesDistributionUrl.lastIndexOf('/') + 1);\n-                    String repositoryUrlPrefix = currentUrl.substring(0, currentUrl.lastIndexOf('/'));\n-                    return entry.withValue(value.withText(repositoryUrlPrefix + \"/\" + newDistributionFile));\n-                }\n+                return entry.withValue(value.withText(gradleWrapper.getPropertiesFormattedUrl()));\n             }\n             if (DISTRIBUTION_SHA_256_SUM_KEY.equals(entry.getKey()) && gradleWrapper.getDistributionChecksum() != null) {\n                 return entry.withValue(entry.getValue().withText(gradleWrapper.getDistributionChecksum().getHexValue()));\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpdateGradleWrapperTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpdateGradleWrapperTest.java\nindex 482ad8cf782..8510cd56d64 100755\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpdateGradleWrapperTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpdateGradleWrapperTest.java\n@@ -43,14 +43,9 @@\n import static org.assertj.core.api.Assertions.assertThat;\n import static org.openrewrite.gradle.Assertions.buildGradle;\n import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n-import static org.openrewrite.gradle.util.GradleWrapper.WRAPPER_BATCH_LOCATION;\n-import static org.openrewrite.gradle.util.GradleWrapper.WRAPPER_JAR_LOCATION;\n-import static org.openrewrite.gradle.util.GradleWrapper.WRAPPER_PROPERTIES_LOCATION;\n-import static org.openrewrite.gradle.util.GradleWrapper.WRAPPER_SCRIPT_LOCATION;\n+import static org.openrewrite.gradle.util.GradleWrapper.*;\n import static org.openrewrite.properties.Assertions.properties;\n-import static org.openrewrite.test.SourceSpecs.dir;\n-import static org.openrewrite.test.SourceSpecs.other;\n-import static org.openrewrite.test.SourceSpecs.text;\n+import static org.openrewrite.test.SourceSpecs.*;\n \n @SuppressWarnings(\"UnusedProperty\")\n class UpdateGradleWrapperTest implements RewriteTest {\n@@ -66,10 +61,11 @@ class UpdateGradleWrapperTest implements RewriteTest {\n     private final SourceSpecs gradlew = text(\"\", spec -> spec.path(WRAPPER_SCRIPT_LOCATION).after(notEmpty));\n     private final SourceSpecs gradlewBat = text(\"\", spec -> spec.path(WRAPPER_BATCH_LOCATION).after(notEmpty));\n     private final SourceSpecs gradleWrapperJarQuark = other(\"\", spec -> spec.path(WRAPPER_JAR_LOCATION));\n+    private final String wrapperJarChecksum = \"29e49b10984e585d8118b7d0bc452f944e386458df27371b49b4ac1dec4b7fda\";\n \n     @Override\n     public void defaults(RecipeSpec spec) {\n-        spec.recipe(new UpdateGradleWrapper(\"7.4.2\", null, null, null))\n+        spec.recipe(new UpdateGradleWrapper(\"7.4.2\", null, null, null, null))\n           .beforeRecipe(withToolingApi());\n     }\n \n@@ -238,7 +234,7 @@ void updateChecksumAlreadySet() {\n     @Test\n     void dontAddMissingWrapper() {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateGradleWrapper(\"7.x\", null, Boolean.FALSE, null))\n+          spec -> spec.recipe(new UpdateGradleWrapper(\"7.x\", null, Boolean.FALSE, null, null))\n             .allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"7.4\")))\n             .afterRecipe(run -> assertThat(run.getChangeset().getAllResults()).isEmpty())\n         );\n@@ -248,7 +244,7 @@ void dontAddMissingWrapper() {\n     void updateMultipleWrappers() {\n         rewriteRun(\n           spec -> spec.allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"7.4\")))\n-            .recipe(new UpdateGradleWrapper(\"7.4.2\", null, Boolean.FALSE, null)),\n+            .recipe(new UpdateGradleWrapper(\"7.4.2\", null, Boolean.FALSE, null, null)),\n           dir(\"example1\",\n             properties(\n               \"\"\"\n@@ -307,7 +303,7 @@ void updateMultipleWrappers() {\n     @Test\n     void olderThan6_6() {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateGradleWrapper(\"5.6.4\", null, null, null))\n+          spec -> spec.recipe(new UpdateGradleWrapper(\"5.6.4\", null, null, null, null))\n             .allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"4.0\")))\n             .afterRecipe(run -> {\n                 var gradleSh = result(run, PlainText.class, \"gradlew\");\n@@ -368,7 +364,7 @@ void doNotDowngrade() {\n     @Test\n     void allowUpdatingDistributionTypeWhenSameVersion() {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateGradleWrapper(\"5.6.x\", \"bin\", null, null))\n+          spec -> spec.recipe(new UpdateGradleWrapper(\"5.6.x\", \"bin\", null, null, null))\n             .allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"5.6.4\")))\n             .afterRecipe(run -> {\n                 var gradleSh = result(run, PlainText.class, \"gradlew\");\n@@ -409,7 +405,7 @@ void allowUpdatingDistributionTypeWhenSameVersion() {\n     @Test\n     void defaultsToLatestRelease() {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateGradleWrapper(null, null, null, null))\n+          spec -> spec.recipe(new UpdateGradleWrapper(null, null, null, null, null))\n             .allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"7.4\")))\n             .afterRecipe(run -> {\n                 var gradleSh = result(run, PlainText.class, \"gradlew\");\n@@ -532,18 +528,16 @@ void skipWorkIfUpdatedEarlier() {\n         );\n     }\n \n-    @Issue(\"https://github.com/openrewrite/rewrite/issues/2651\")\n     @Test\n-    void preferExistingDistributionSource() {\n+    void getExactVersionWithPatternFromGradleServices() {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateGradleWrapper(\"8.0.x\", null, null, null))\n-            .expectedCyclesThatMakeChanges(2)\n+          spec -> spec.recipe(new UpdateGradleWrapper(\"8.0.x\", null, null, null, null))\n             .allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"7.4\"))),\n           properties(\n             \"\"\"\n               distributionBase=GRADLE_USER_HOME\n               distributionPath=wrapper/dists\n-              distributionUrl=https\\\\://company.com/repo/gradle-7.4-bin.zip\n+              distributionUrl=https\\\\://services.gradle.org/distributions/gradle-7.4-bin.zip\n               zipStoreBase=GRADLE_USER_HOME\n               zipStorePath=wrapper/dists\n               \"\"\",\n@@ -558,7 +552,7 @@ void preferExistingDistributionSource() {\n                   return \"\"\"\n                     distributionBase=GRADLE_USER_HOME\n                     distributionPath=wrapper/dists\n-                    distributionUrl=https\\\\://company.com/repo/gradle-8.0.2-bin.zip\n+                    distributionUrl=https\\\\://services.gradle.org/distributions/gradle-8.0.2-bin.zip\n                     zipStoreBase=GRADLE_USER_HOME\n                     zipStorePath=wrapper/dists\n                     distributionSha256Sum=%s\n@@ -588,7 +582,7 @@ void preferExistingDistributionSourceWhenServicesGradleOrgUnavailable() {\n           .setHttpSender(unhelpfulSender)\n           .setLargeFileHttpSender(unhelpfulSender);\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateGradleWrapper(\"8.10\", \"bin\", false, null))\n+          spec -> spec.recipe(new UpdateGradleWrapper(\"8.10\", \"bin\", false, null, null))\n             .allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"7.4\")))\n             .executionContext(ctx),\n           properties(\n@@ -615,11 +609,103 @@ void preferExistingDistributionSourceWhenServicesGradleOrgUnavailable() {\n     }\n \n     @Test\n-    void customDistributionUri() {\n+    void addWrapperWithCustomDistributionUri() {\n+        HttpSender customDistributionHost = request -> {\n+            if (request.getUrl().toString().contains(\"company.com\")) {\n+                return new HttpSender.Response(200, UpdateGradleWrapperTest.class.getClassLoader().getResourceAsStream(\"gradle-8.10-bin.zip\"), () -> {\n+                });\n+            }\n+            return new HttpUrlConnectionSender().send(request);\n+        };\n+        HttpSenderExecutionContextView ctx = HttpSenderExecutionContextView.view(new InMemoryExecutionContext())\n+          .setHttpSender(customDistributionHost)\n+          .setLargeFileHttpSender(customDistributionHost);\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateGradleWrapper(\"8.0.x\", null, null, \"https://company.com/repo/gradle-${version}-${distribution}.zip\"))\n-            .expectedCyclesThatMakeChanges(2)\n-            .allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"7.4\"))),\n+          spec -> spec\n+            .recipe(new UpdateGradleWrapper(null, null, null, \"https://company.com/repo/gradle-8.0.2-bin.zip\", null))\n+            .expectedCyclesThatMakeChanges(1)\n+            .executionContext(ctx)\n+            .afterRecipe(run -> {\n+                assertThat(run.getChangeset().getAllResults()).hasSize(4);\n+\n+                var gradleSh = result(run, PlainText.class, \"gradlew\");\n+                assertThat(gradleSh.getSourcePath()).isEqualTo(WRAPPER_SCRIPT_LOCATION);\n+                assertThat(gradleSh.getFileAttributes()).isNotNull();\n+                assertThat(gradleSh.getFileAttributes().isReadable()).isTrue();\n+                assertThat(gradleSh.getFileAttributes().isExecutable()).isTrue();\n+\n+                var gradleBat = result(run, PlainText.class, \"gradlew.bat\");\n+                assertThat(gradleBat.getSourcePath()).isEqualTo(WRAPPER_BATCH_LOCATION);\n+\n+                var gradleWrapperProperties = result(run, Properties.File.class, \"gradle-wrapper.properties\");\n+                assertThat(gradleWrapperProperties.getSourcePath()).isEqualTo(WRAPPER_PROPERTIES_LOCATION);\n+\n+                var gradleWrapperJar = result(run, Remote.class, \"gradle-wrapper.jar\");\n+                assertThat(gradleWrapperJar.getSourcePath()).isEqualTo(WRAPPER_JAR_LOCATION);\n+                assertThat(gradleWrapperJar.getUri()).isEqualTo(URI.create(\"https://company.com/repo/gradle-8.0.2-bin.zip\"));\n+                assertThat(isValidWrapperJar(gradleWrapperJar)).as(\"Wrapper jar is not valid\").isTrue();\n+            }),\n+          buildGradle(\n+            \"\"\"\n+              plugins {\n+                  id \"java\"\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addWrapperWithCustomDistributionUriAndDistributionChecksum() {\n+        HttpSender customDistributionHost = request -> {\n+            if (request.getUrl().toString().contains(\"company.com\")) {\n+                return new HttpSender.Response(200, UpdateGradleWrapperTest.class.getClassLoader().getResourceAsStream(\"gradle-8.10-bin.zip\"), () -> {\n+                });\n+            }\n+            return new HttpUrlConnectionSender().send(request);\n+        };\n+        HttpSenderExecutionContextView ctx = HttpSenderExecutionContextView.view(new InMemoryExecutionContext())\n+          .setHttpSender(customDistributionHost)\n+          .setLargeFileHttpSender(customDistributionHost);\n+        rewriteRun(\n+          spec -> spec\n+            .recipe(new UpdateGradleWrapper(null, null, null, \"https://company.com/repo/gradle-8.0.2-bin.zip\", wrapperJarChecksum))\n+            .expectedCyclesThatMakeChanges(1)\n+            .executionContext(ctx)\n+            .afterRecipe(run -> {\n+                var gradleWrapperProperties = result(run, Properties.File.class, \"gradle-wrapper.properties\");\n+                assertThat(gradleWrapperProperties.getSourcePath()).isEqualTo(WRAPPER_PROPERTIES_LOCATION);\n+                assertThat(gradleWrapperProperties.getContent().stream()\n+                  .filter(Properties.Entry.class::isInstance)\n+                  .map(Properties.Entry.class::cast)\n+                  .anyMatch(prop -> \"distributionSha256Sum\".equals(prop.getKey()) && wrapperJarChecksum.equals(prop.getValue().getText()))).isTrue();\n+            }),\n+          buildGradle(\n+            \"\"\"\n+              plugins {\n+                  id \"java\"\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void migrateToCustomDistributionUri() {\n+        HttpSender customDistributionHost = request -> {\n+            if (request.getUrl().toString().contains(\"company.com\")) {\n+                return new HttpSender.Response(200, UpdateGradleWrapperTest.class.getClassLoader().getResourceAsStream(\"gradle-8.10-bin.zip\"), () -> {\n+                });\n+            }\n+            return new HttpUrlConnectionSender().send(request);\n+        };\n+        HttpSenderExecutionContextView ctx = HttpSenderExecutionContextView.view(new InMemoryExecutionContext())\n+          .setHttpSender(customDistributionHost)\n+          .setLargeFileHttpSender(customDistributionHost);\n+        rewriteRun(\n+          spec -> spec.recipe(new UpdateGradleWrapper(null, null, null, \"https://company.com/repo/gradle-8.10-bin.zip\", null))\n+            .allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"7.4\")))\n+            .executionContext(ctx),\n           properties(\n             \"\"\"\n               distributionBase=GRADLE_USER_HOME\n@@ -628,23 +714,94 @@ void customDistributionUri() {\n               zipStoreBase=GRADLE_USER_HOME\n               zipStorePath=wrapper/dists\n               \"\"\",\n+            \"\"\"\n+              distributionBase=GRADLE_USER_HOME\n+              distributionPath=wrapper/dists\n+              distributionUrl=https\\\\://company.com/repo/gradle-8.10-bin.zip\n+              zipStoreBase=GRADLE_USER_HOME\n+              zipStorePath=wrapper/dists\n+              \"\"\",\n             spec -> spec.path(\"gradle/wrapper/gradle-wrapper.properties\")\n-              .after(after -> {\n-                  Matcher checksumMatcher = Pattern.compile(\"distributionSha256Sum=(.*)\").matcher(after);\n-                  assertThat(checksumMatcher.find()).isTrue();\n-                  String checksum = checksumMatcher.group(1);\n-                  assertThat(checksum).isNotBlank();\n+          ),\n+          gradlew,\n+          gradlewBat,\n+          gradleWrapperJarQuark\n+        );\n+    }\n \n-                  // language=properties\n-                  return \"\"\"\n-                    distributionBase=GRADLE_USER_HOME\n-                    distributionPath=wrapper/dists\n-                    distributionUrl=https\\\\://company.com/repo/gradle-8.0.2-bin.zip\n-                    zipStoreBase=GRADLE_USER_HOME\n-                    zipStorePath=wrapper/dists\n-                    distributionSha256Sum=%s\n-                    \"\"\".formatted(checksum);\n-              })\n+    @Test\n+    void removeShaDuringMigrationToCustomDistributionUri() {\n+        HttpSender customDistributionHost = request -> {\n+            if (request.getUrl().toString().contains(\"company.com\")) {\n+                return new HttpSender.Response(200, UpdateGradleWrapperTest.class.getClassLoader().getResourceAsStream(\"gradle-8.10-bin.zip\"), () -> {\n+                });\n+            }\n+            return new HttpUrlConnectionSender().send(request);\n+        };\n+        HttpSenderExecutionContextView ctx = HttpSenderExecutionContextView.view(new InMemoryExecutionContext())\n+          .setHttpSender(customDistributionHost)\n+          .setLargeFileHttpSender(customDistributionHost);\n+        rewriteRun(\n+          spec -> spec.recipe(new UpdateGradleWrapper(null, null, null, \"https://company.com/repo/gradle-8.10-bin.zip\", null))\n+            .allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"7.4\")))\n+            .executionContext(ctx),\n+          properties(\n+            \"\"\"\n+              distributionBase=GRADLE_USER_HOME\n+              distributionPath=wrapper/dists\n+              distributionUrl=https\\\\://services.gradle.org/distributions/gradle-7.4.2-bin.zip\n+              zipStoreBase=GRADLE_USER_HOME\n+              zipStorePath=wrapper/dists\n+              distributionSha256Sum=29e49b10984e585d8118b7d0bc452f944e386458df27371b49b4ac1dec4b7fda\n+              \"\"\",\n+            \"\"\"\n+              distributionBase=GRADLE_USER_HOME\n+              distributionPath=wrapper/dists\n+              distributionUrl=https\\\\://company.com/repo/gradle-8.10-bin.zip\n+              zipStoreBase=GRADLE_USER_HOME\n+              zipStorePath=wrapper/dists\n+              \"\"\",\n+            spec -> spec.path(\"gradle/wrapper/gradle-wrapper.properties\")\n+          ),\n+          gradlew,\n+          gradlewBat,\n+          gradleWrapperJarQuark\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/2651\")\n+    void updateWithCustomDistributionUri() {\n+        HttpSender customDistributionHost = request -> {\n+            if (request.getUrl().toString().contains(\"company.com\")) {\n+                return new HttpSender.Response(200, UpdateGradleWrapperTest.class.getClassLoader().getResourceAsStream(\"gradle-8.10-bin.zip\"), () -> {\n+                });\n+            }\n+            return new HttpUrlConnectionSender().send(request);\n+        };\n+        HttpSenderExecutionContextView ctx = HttpSenderExecutionContextView.view(new InMemoryExecutionContext())\n+          .setHttpSender(customDistributionHost)\n+          .setLargeFileHttpSender(customDistributionHost);\n+        rewriteRun(\n+          spec -> spec.recipe(new UpdateGradleWrapper(\"8.10\", null, null, null, null))\n+            .allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"7.4\")))\n+            .executionContext(ctx),\n+          properties(\n+            \"\"\"\n+              distributionBase=GRADLE_USER_HOME\n+              distributionPath=wrapper/dists\n+              distributionUrl=https\\\\://company.com/repo/gradle-8.2-bin.zip\n+              zipStoreBase=GRADLE_USER_HOME\n+              zipStorePath=wrapper/dists\n+              \"\"\",\n+            \"\"\"\n+              distributionBase=GRADLE_USER_HOME\n+              distributionPath=wrapper/dists\n+              distributionUrl=https\\\\://company.com/repo/gradle-8.10-bin.zip\n+              zipStoreBase=GRADLE_USER_HOME\n+              zipStorePath=wrapper/dists\n+              \"\"\",\n+            spec -> spec.path(\"gradle/wrapper/gradle-wrapper.properties\")\n           ),\n           gradlew,\n           gradlewBat,\n@@ -664,7 +821,7 @@ void servicesGradleOrgUnavailable() {\n           .setHttpSender(unhelpfulSender)\n           .setLargeFileHttpSender(unhelpfulSender);\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateGradleWrapper(\"8.6\", null, null, \"https://artifactory.moderne.ninja/artifactory/gradle-distributions/gradle-${version}-bin.zip\"))\n+          spec -> spec.recipe(new UpdateGradleWrapper(\"8.6\", null, null, null, null))\n             .allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"7.4\")))\n             .executionContext(ctx),\n           properties(\n@@ -678,7 +835,49 @@ void servicesGradleOrgUnavailable() {\n             \"\"\"\n               distributionBase=GRADLE_USER_HOME\n               distributionPath=wrapper/dists\n-              distributionUrl=https\\\\://artifactory.moderne.ninja/artifactory/gradle-distributions/gradle-8.6-bin.zip\n+              distributionUrl=https\\\\://services.gradle.org/distributions/gradle-8.6-bin.zip\n+              zipStoreBase=GRADLE_USER_HOME\n+              zipStorePath=wrapper/dists\n+              \"\"\",\n+            spec -> spec.path(\"gradle/wrapper/gradle-wrapper.properties\")\n+          ),\n+          text(GRADLEW_TEXT, spec -> spec.path(WRAPPER_SCRIPT_LOCATION)),\n+          text(GRADLEW_BAT_TEXT, spec -> spec.path(WRAPPER_BATCH_LOCATION)),\n+          gradleWrapperJarQuark\n+        );\n+    }\n+\n+    @Test\n+    void servicesGradleOrgUnavailableForCustomDistributionUri() {\n+        HttpSender unhelpfulSender = request -> {\n+            if (request.getUrl().toString().contains(\"services.gradle.org\")) {\n+                throw new RuntimeException(\"I'm sorry Dave, I'm afraid I can't do that.\");\n+            }\n+            if (request.getUrl().toString().contains(\"company.com\")) {\n+                return new HttpSender.Response(200, UpdateGradleWrapperTest.class.getClassLoader().getResourceAsStream(\"gradle-8.10-bin.zip\"), () -> {\n+                });\n+            }\n+            return new HttpUrlConnectionSender().send(request);\n+        };\n+        HttpSenderExecutionContextView ctx = HttpSenderExecutionContextView.view(new InMemoryExecutionContext())\n+          .setHttpSender(unhelpfulSender)\n+          .setLargeFileHttpSender(unhelpfulSender);\n+        rewriteRun(\n+          spec -> spec.recipe(new UpdateGradleWrapper(\"8.10\", null, null, null, null))\n+            .allSources(source -> source.markers(new BuildTool(Tree.randomId(), BuildTool.Type.Gradle, \"7.4\")))\n+            .executionContext(ctx),\n+          properties(\n+            \"\"\"\n+              distributionBase=GRADLE_USER_HOME\n+              distributionPath=wrapper/dists\n+              distributionUrl=https\\\\://company.com/repo/gradle-8.2-bin.zip\n+              zipStoreBase=GRADLE_USER_HOME\n+              zipStorePath=wrapper/dists\n+              \"\"\",\n+            \"\"\"\n+              distributionBase=GRADLE_USER_HOME\n+              distributionPath=wrapper/dists\n+              distributionUrl=https\\\\://company.com/repo/gradle-8.10-bin.zip\n               zipStoreBase=GRADLE_USER_HOME\n               zipStorePath=wrapper/dists\n               \"\"\",\n@@ -743,6 +942,11 @@ void updateWrapperInSubDirectory() {\n         );\n     }\n \n+    @Test\n+    void failRecipeIfBothVersionAndDistributionUriAreProvided() {\n+        assertThat(new UpdateGradleWrapper(\"7.4.2\", \"bin\", false, \"https://company.com/repo/gradle-7.4.2-bin.zip\", null).validate().isInvalid()).isTrue();\n+    }\n+\n     private <S extends SourceFile> S result(RecipeRun run, Class<S> clazz, String endsWith) {\n         return run.getChangeset().getAllResults().stream()\n           .map(Result::getAfter)\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4479",
    "pr_id": 4479,
    "issue_id": 3283,
    "repo": "openrewrite/rewrite",
    "problem_statement": "`org.openrewrite.java.RemoveUnusedImports` should not removed imports for public static inner class usage\norg.openrewrite.java.RemoveUnusedImports doesn't appear to spot static public inner class usage that's used with wildcard imports statements.  \r\n\r\n## What version of OpenRewrite are you using?\r\nI am using version: 7.40.6\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\nConsider the following class\r\n\r\n```java\r\npackage com.a.b.c;\r\npublic final class ParentBaseClass {\r\n  public static abstract class BaseImplClass {\r\n     void foo() {\r\n      } \r\n  }\r\n}\r\n```\r\n\r\nWhich is then used in the following class\r\n\r\n```java\r\nimport com.a.b.c.ParentBaseClass.*\r\nimport java.util.List;\r\npublic class MyClass extends BaseImplClass {\r\n   @Override\r\n   public void foo() {\r\n   }\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\n```java\r\nimport com.a.b.c.ParentBaseClass.*\r\npublic class MyClass extends BaseImplClass {\r\n   @Override\r\n   public void foo() {\r\n   }\r\n}\r\n```\r\n\r\n## What did you see instead?\r\n```java\r\npublic class MyClass extends BaseImplClass {\r\n   @Override\r\n   public void foo() {\r\n   }\r\n}\r\n```\r\n\r\n",
    "issue_word_count": 145,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/RemoveUnusedImports.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java"
    ],
    "base_commit": "4a98c3b9c726905be8f33d474605f47c8a758730",
    "head_commit": "e351329ab2f1aeda525b9879dcb0150e2d9baf0f",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4479",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4479",
    "dockerfile": "",
    "pr_merged_at": "2024-09-10T09:10:54.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/RemoveUnusedImports.java b/rewrite-java/src/main/java/org/openrewrite/java/RemoveUnusedImports.java\nindex 856ca707f2f..86e99d5f313 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/RemoveUnusedImports.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/RemoveUnusedImports.java\n@@ -226,7 +226,7 @@ public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionCon\n                             // add each unfolded import\n                             combinedTypes.stream().map(JavaType.FullyQualified::getClassName).sorted().distinct().forEach(type ->\n                                     anImport.imports.add(new JRightPadded<>(elem\n-                                            .withQualid(qualid.withName(name.withSimpleName(type)))\n+                                            .withQualid(qualid.withName(name.withSimpleName(type.substring(type.lastIndexOf('.') + 1))))\n                                             .withPrefix(Space.format(\"\\n\")), Space.EMPTY, Markers.EMPTY))\n                             );\n \n@@ -236,7 +236,7 @@ public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionCon\n \n                             changed = true;\n                         } else {\n-                            usedWildcardImports.add(elem.getPackageName());\n+                            usedWildcardImports.add(elem.getQualid().getTarget().toString());\n                         }\n                     } else if (combinedTypes.stream().noneMatch(c -> {\n                         if (\"*\".equals(elem.getQualid().getSimpleName())) {\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java\nindex 70637a63134..cae81b2e3b7 100755\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java\n@@ -1906,4 +1906,81 @@ public class Bar {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/3283\")\n+    @Test\n+    void nestedImport() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              package foo;\n+\n+              public interface J {\n+                  final class One implements J {}\n+                  final class Two implements J {}\n+                  final class Three implements J {}\n+                  final class Four implements J {}\n+                  final class Five implements J {}\n+                  final class Six implements J {}\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              package bar;\n+\n+              import foo.J;\n+              import foo.J.*;\n+\n+              class Quz {\n+                void test() {\n+                  J j = null;\n+                  One one = null;\n+                  Two two = null;\n+                  Three three = null;\n+                  Four four = null;\n+                  Five five = null;\n+                  Six six = null;\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/3283\")\n+    @Test\n+    void nestedImportStaticInnerClass() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              package com.a.b.c;\n+              public final class ParentBaseClass {\n+                public static abstract class BaseImplClass {\n+                   void foo() {\n+                    }\n+                }\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import com.a.b.c.ParentBaseClass.*;\n+              public class MyClass extends BaseImplClass {\n+                 @Override\n+                 public void foo() {\n+                 }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import com.a.b.c.ParentBaseClass.BaseImplClass;\n+              public class MyClass extends BaseImplClass {\n+                 @Override\n+                 public void foo() {\n+                 }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4458",
    "pr_id": 4458,
    "issue_id": 4452,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ChangeType is not addressing import conflicts\n## What version of OpenRewrite are you using?\r\n\r\nI am using\r\n\r\n- OpenRewrite v8.33.8\r\n- Gradle plugin v8.4\r\n- rewrite-java v8.33.8\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n```java\r\npublic class ChangeTypeTest implements RewriteTest {\r\n\r\n    @Override\r\n    public void defaults(RecipeSpec spec) {\r\n        spec.recipe(\r\n                new ChangeType(\"javax.annotation.Nonnull\", \"org.checkerframework.checker.nullness.qual.NonNull\", null));\r\n    }\r\n\r\n    @Test\r\n    void conflictingImports() {\r\n\r\n        // language=java\r\n        rewriteRun(\r\n                // dissabling validation to avoid the 'Identifier type is missing or malformed' error. I couldn't add\r\n                // the lombok dependency to the test.\r\n                spec -> spec.typeValidationOptions(TypeValidation.none()),\r\n                java(\r\n                        \"\"\"\r\n                        import lombok.NonNull;\r\n                        import javax.annotation.Nonnull;\r\n                        import org.immutables.value.Value;\r\n\r\n                        @Value.Immutable\r\n                        @Value.Style(passAnnotations = Nonnull.class)\r\n                        public interface ConflictingImports {\r\n                                private void lombokMethod(@NonNull final String lombokNonNull){}\r\n                        }\r\n                        \"\"\",\r\n                        \"\"\"\r\n                        import lombok.NonNull;\r\n                        import org.immutables.value.Value;\r\n\r\n                        @Value.Immutable\r\n                        @Value.Style(passAnnotations = org.checkerframework.checker.nullness.qual.NonNull.class)\r\n                        public interface ConflictingImports {\r\n                                private void lombokMethod(@NonNull final String lombokNonNull){}\r\n                        }\r\n                        \"\"\"));\r\n    }\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\n\r\nIf where is already a class imported with the same name in the original code (lombok.NonNull in the example), the recipe should fully-qualified the new Type included (org.checkerframework.checker.nullness.qual.NonNull). \r\n\r\n## What did you see instead?\r\nI'm seeing two imports for the same name type, from different packages.\r\n\r\n```java\r\nimport lombok.NonNull;\r\nimport org.checkerframework.checker.nullness.qual.NonNull;\r\n```\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n> Unexpected result in \"ConflictingImports.java\":\r\n```diff\r\ndiff --git a/ConflictingImports.java b/ConflictingImports.java\r\nindex 4172665..31c1781 100644\r\n--- a/ConflictingImports.java\r\n+++ b/ConflictingImports.java\r\n@@ -1,8 +1,9 @@ \r\n import lombok.NonNull;\r\n+import org.checkerframework.checker.nullness.qual.NonNull;\r\n import org.immutables.value.Value;\r\n \r\n @Value.Immutable\r\n-@Value.Style(passAnnotations = org.checkerframework.checker.nullness.qual.NonNull.class)\r\n+@Value.Style(passAnnotations = NonNull.class)\r\n public interface ConflictingImports {\r\n         private void lombokMethod(@NonNull final String lombokNonNull){}\r\n }\r\n\\ No newline at end of file\r\n```\r\nexpected: \r\n```java\r\n  import lombok.NonNull;\r\n  import org.immutables.value.Value;\r\n  \r\n  @Value.Immutable\r\n  @Value.Style(passAnnotations = org.checkerframework.checker.nullness.qual.NonNull.class)\r\n  public interface ConflictingImports {\r\n          private void lombokMethod(@NonNull final String lombokNonNull){}\r\n  }\r\n```\r\n\r\n but was: \r\n```java\r\n  import lombok.NonNull;\r\n  import org.checkerframework.checker.nullness.qual.NonNull;\r\n  import org.immutables.value.Value;\r\n  \r\n  @Value.Immutable\r\n  @Value.Style(passAnnotations = NonNull.class)\r\n  public interface ConflictingImports {\r\n          private void lombokMethod(@NonNull final String lombokNonNull){}\r\n  }\r\n```\r\n\r\n## Extra information, slack thread about this issue:\r\nhttps://rewriteoss.slack.com/archives/C01A843MWG5/p1723733741135269?thread_ts=1723658700.585459&cid=C01A843MWG5\r\n\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\nNot at this moment. Maybe in the future. \r\n\r\n",
    "issue_word_count": 456,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/ChangeType.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java"
    ],
    "base_commit": "0805fefab5526d9741597233a0433e30d33055b2",
    "head_commit": "f2849a5b7c506b85e46cb340cefca3443c74e800",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4458",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4458",
    "dockerfile": "",
    "pr_merged_at": "2024-08-30T17:27:47.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/ChangeType.java b/rewrite-java/src/main/java/org/openrewrite/java/ChangeType.java\nindex f6a009a5524..79c1c1277ca 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/ChangeType.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/ChangeType.java\n@@ -205,9 +205,9 @@ private void addImport(JavaType.FullyQualified owningClass) {\n                         if (maybeType instanceof JavaType.FullyQualified) {\n                             JavaType.FullyQualified type = (JavaType.FullyQualified) maybeType;\n                             if (originalType.getFullyQualifiedName().equals(type.getFullyQualifiedName())) {\n-                                sf = (JavaSourceFile) new RemoveImport<ExecutionContext>(originalType.getFullyQualifiedName()).visit(sf, ctx, getCursor().getParentOrThrow());\n+                                sf = (JavaSourceFile) new RemoveImport<ExecutionContext>(originalType.getFullyQualifiedName()).visitNonNull(sf, ctx, getCursor().getParentOrThrow());\n                             } else if (originalType.getOwningClass() != null && originalType.getOwningClass().getFullyQualifiedName().equals(type.getFullyQualifiedName())) {\n-                                sf = (JavaSourceFile) new RemoveImport<ExecutionContext>(originalType.getOwningClass().getFullyQualifiedName()).visit(sf, ctx, getCursor().getParentOrThrow());\n+                                sf = (JavaSourceFile) new RemoveImport<ExecutionContext>(originalType.getOwningClass().getFullyQualifiedName()).visitNonNull(sf, ctx, getCursor().getParentOrThrow());\n                             }\n                         }\n                     }\n@@ -217,20 +217,18 @@ private void addImport(JavaType.FullyQualified owningClass) {\n                 if (fullyQualifiedTarget != null) {\n                     JavaType.FullyQualified owningClass = fullyQualifiedTarget.getOwningClass();\n                     if (!topLevelClassnames.contains(getTopLevelClassName(fullyQualifiedTarget).getFullyQualifiedName())) {\n-                        if (owningClass != null && !\"java.lang\".equals(fullyQualifiedTarget.getPackageName())) {\n-                            addImport(owningClass);\n-                        }\n-                        if (!\"java.lang\".equals(fullyQualifiedTarget.getPackageName())) {\n-                            addImport(fullyQualifiedTarget);\n+                        if (hasNoConflictingImport(sf)) {\n+                            if (owningClass != null && !\"java.lang\".equals(fullyQualifiedTarget.getPackageName())) {\n+                                addImport(owningClass);\n+                            }\n+                            if (!\"java.lang\".equals(fullyQualifiedTarget.getPackageName())) {\n+                                addImport(fullyQualifiedTarget);\n+                            }\n                         }\n                     }\n                 }\n \n-                if (sf != null) {\n-                    sf = sf.withImports(ListUtils.map(sf.getImports(), i -> visitAndCast(i, ctx, super::visitImport)));\n-                }\n-\n-                j = sf;\n+                j = sf.withImports(ListUtils.map(sf.getImports(), i -> visitAndCast(i, ctx, super::visitImport)));\n             }\n \n             return j;\n@@ -301,6 +299,7 @@ public J visitIdentifier(J.Identifier ident, ExecutionContext ctx) {\n                     className = originalType.getFullyQualifiedName().substring(iType.getOwningClass().getFullyQualifiedName().length() + 1);\n                 }\n \n+                JavaSourceFile sf = getCursor().firstEnclosing(JavaSourceFile.class);\n                 if (ident.getSimpleName().equals(className)) {\n                     if (targetType instanceof JavaType.FullyQualified) {\n                         if (((JavaType.FullyQualified) targetType).getOwningClass() != null) {\n@@ -308,7 +307,11 @@ public J visitIdentifier(J.Identifier ident, ExecutionContext ctx) {\n                                     .withType(null)\n                                     .withPrefix(ident.getPrefix()));\n                         } else {\n-                            ident = ident.withSimpleName(((JavaType.FullyQualified) targetType).getClassName());\n+                            if (sf != null && hasNoConflictingImport(sf)) {\n+                                ident = ident.withSimpleName(((JavaType.FullyQualified) targetType).getClassName());\n+                            } else {\n+                                ident = ident.withSimpleName(((JavaType.FullyQualified) targetType).getFullyQualifiedName());\n+                            }\n                         }\n                     } else if (targetType instanceof JavaType.Primitive) {\n                         ident = ident.withSimpleName(((JavaType.Primitive) targetType).getKeyword());\n@@ -316,9 +319,8 @@ public J visitIdentifier(J.Identifier ident, ExecutionContext ctx) {\n                 }\n \n                 // Recreate any static imports as needed\n-                JavaSourceFile cu = getCursor().firstEnclosing(JavaSourceFile.class);\n-                if (cu != null) {\n-                    for (J.Import anImport : cu.getImports()) {\n+                if (sf != null) {\n+                    for (J.Import anImport : sf.getImports()) {\n                         if (anImport.isStatic() && anImport.getQualid().getTarget().getType() != null) {\n                             JavaType.FullyQualified fqn = TypeUtils.asFullyQualified(anImport.getQualid().getTarget().getType());\n                             if (fqn != null && TypeUtils.isOfClassType(fqn, originalType.getFullyQualifiedName()) &&\n@@ -505,6 +507,23 @@ private Expression updateOuterClassTypes(Expression typeTree) {\n         private boolean isTargetFullyQualifiedType(JavaType.@Nullable FullyQualified fq) {\n             return fq != null && TypeUtils.isOfClassType(fq, originalType.getFullyQualifiedName()) && targetType instanceof JavaType.FullyQualified;\n         }\n+\n+        private boolean hasNoConflictingImport(JavaSourceFile sf) {\n+            JavaType.FullyQualified oldType = TypeUtils.asFullyQualified(originalType);\n+            JavaType.FullyQualified newType = TypeUtils.asFullyQualified(targetType);\n+            if (oldType == null || newType == null) {\n+                return false; // No way to be sure\n+            }\n+            for (J.Import anImport : sf.getImports()) {\n+                JavaType.FullyQualified currType = TypeUtils.asFullyQualified(anImport.getQualid().getType());\n+                if (currType != null &&\n+                    !TypeUtils.isOfType(currType, oldType) &&\n+                    currType.getClassName().equals(newType.getClassName())) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n     }\n \n     private static class ChangeClassDefinition extends JavaIsoVisitor<ExecutionContext> {\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java\nindex 5d878133206..f7deeb632b6 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java\n@@ -101,7 +101,7 @@ void starImport() {\n           java(\n             \"\"\"\n               import java.util.logging.*;\n-\n+              \n               class Test {\n                   static void method() {\n                       LoggingMXBean loggingBean = null;\n@@ -111,7 +111,7 @@ static void method() {\n             \"\"\"\n               import java.lang.management.PlatformLoggingMXBean;\n               import java.util.logging.*;\n-\n+              \n               class Test {\n                   static void method() {\n                       PlatformLoggingMXBean loggingBean = null;\n@@ -130,7 +130,7 @@ void allowJavaLangSubpackages() {\n           java(\n             \"\"\"\n               import java.util.logging.LoggingMXBean;\n-                            \n+              \n               class Test {\n                   static void method() {\n                       LoggingMXBean loggingBean = null;\n@@ -139,7 +139,7 @@ static void method() {\n               \"\"\",\n             \"\"\"\n               import java.lang.management.PlatformLoggingMXBean;\n-                            \n+              \n               class Test {\n                   static void method() {\n                       PlatformLoggingMXBean loggingBean = null;\n@@ -159,7 +159,7 @@ void unnecessaryImport() {\n           java(\n             \"\"\"\n               import test.Outer;\n-                            \n+              \n               class Test {\n                   private Outer p = Outer.of();\n                   private Outer p2 = test.Outer.of();\n@@ -169,12 +169,12 @@ class Test {\n           java(\n             \"\"\"\n               package test;\n-                            \n+              \n               public class Outer {\n                   public static Outer of() {\n                       return new Outer();\n                   }\n-                            \n+              \n                   public static class Inner {\n                   }\n               }\n@@ -193,7 +193,7 @@ void changeInnerClassToOuterClass() {\n             \"\"\"\n               import java.util.Map;\n               import java.util.Map.Entry;\n-                            \n+              \n               class Test {\n                   Entry p;\n                   Map.Entry p2;\n@@ -202,7 +202,7 @@ class Test {\n               \"\"\",\n             \"\"\"\n               import java.util.List;\n-                            \n+              \n               class Test {\n                   List p;\n                   List p2;\n@@ -221,14 +221,14 @@ void changeStaticFieldAccess() {\n           java(\n             \"\"\"\n               import java.io.File;\n-                            \n+              \n               class Test {\n                   String p = File.separator;\n               }\n               \"\"\",\n             \"\"\"\n               import my.pkg.List;\n-                            \n+              \n               class Test {\n                   String p = List.separator;\n               }\n@@ -253,14 +253,14 @@ void replaceWithNestedType() {\n           java(\n             \"\"\"\n               import java.io.File;\n-                            \n+              \n               class Test {\n                   File p;\n               }\n               \"\"\",\n             \"\"\"\n               import java.util.Map;\n-                            \n+              \n               class Test {\n                   Map.Entry p;\n               }\n@@ -277,14 +277,14 @@ void replacePrivateNestedType() {\n           java(\n             \"\"\"\n               package a;\n-                            \n+              \n               class A {\n                   private static class B1 {}\n               }\n               \"\"\",\n             \"\"\"\n               package a;\n-                            \n+              \n               class A {\n                   private static class B2 {}\n               }\n@@ -301,7 +301,7 @@ void deeplyNestedInnerClass() {\n           java(\n             \"\"\"\n               package a;\n-                            \n+              \n               class A {\n                   public static class B {\n                       public static class C {\n@@ -311,7 +311,7 @@ public static class C {\n               \"\"\",\n             \"\"\"\n               package a;\n-                            \n+              \n               class A {\n                   public static class B {\n                       public static class C2 {\n@@ -329,12 +329,12 @@ void simpleName() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class B extends A1 {}\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class B extends A2 {}\n               \"\"\"\n           ),\n@@ -375,7 +375,7 @@ void array2() {\n           java(\n             \"\"\"\n               package com.acme.product;\n-                            \n+              \n               public class Pojo {\n               }\n               \"\"\"\n@@ -383,12 +383,12 @@ public class Pojo {\n           java(\n             \"\"\"\n               package com.acme.project.impl;\n-                            \n+              \n               import com.acme.product.Pojo;\n-                            \n+              \n               public class UsePojo2 {\n                   Pojo[] p;\n-                            \n+              \n                   void run() {\n                       p[0] = null;\n                   }\n@@ -396,12 +396,12 @@ void run() {\n               \"\"\",\n             \"\"\"\n               package com.acme.project.impl;\n-                            \n+              \n               import com.acme.product.v2.Pojo;\n-                            \n+              \n               public class UsePojo2 {\n                   Pojo[] p;\n-                            \n+              \n                   void run() {\n                       p[0] = null;\n                   }\n@@ -420,14 +420,14 @@ void array() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class B {\n                  A1[] a = new A1[0];\n               }\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class B {\n                  A2[] a = new A2[0];\n               }\n@@ -444,14 +444,14 @@ void multiDimensionalArray() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class A {\n                   A1[][] multiDimensionalArray;\n               }\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class A {\n                   A2[][] multiDimensionalArray;\n               }\n@@ -478,12 +478,12 @@ void classDecl() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class B extends A1 implements I1 {}\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class B extends A2 implements I2 {}\n               \"\"\"\n           )\n@@ -499,14 +499,14 @@ void method() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class B {\n                  public A1 foo() throws A1 { return null; }\n               }\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class B {\n                  public A2 foo() throws A2 { return null; }\n               }\n@@ -523,10 +523,10 @@ void methodInvocationTypeParametersAndWildcard() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class B {\n                  public <T extends A1> T generic(T n, java.util.List<? super A1> in) {\n-                            \n+              \n                  }\n                  public void test() {\n                      A1.stat();\n@@ -536,10 +536,10 @@ public void test() {\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class B {\n                  public <T extends A2> T generic(T n, java.util.List<? super A2> in) {\n-                            \n+              \n                  }\n                  public void test() {\n                      A2.stat();\n@@ -560,7 +560,7 @@ void multiCatch() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class B {\n                  public void test() {\n                      try {}\n@@ -570,7 +570,7 @@ public void test() {\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class B {\n                  public void test() {\n                      try {}\n@@ -590,14 +590,14 @@ void multiVariable() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class B {\n                  A1 f1, f2;\n               }\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class B {\n                  A2 f1, f2;\n               }\n@@ -614,14 +614,14 @@ void newClass() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class B {\n                  A1 a = new A1();\n               }\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class B {\n                  A2 a = new A2();\n               }\n@@ -641,7 +641,7 @@ void updateAssignments() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               class B {\n                   void method(A1 param) {\n                       A1 a = param;\n@@ -650,7 +650,7 @@ void method(A1 param) {\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               class B {\n                   void method(A2 param) {\n                       A2 a = param;\n@@ -669,18 +669,18 @@ void parameterizedType() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               import java.util.Map;\n-                            \n+              \n               public class B {\n                  Map<A1, A1> m;\n               }\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               import java.util.Map;\n-                            \n+              \n               public class B {\n                  Map<A2, A2> m;\n               }\n@@ -698,14 +698,14 @@ void typeCast() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class B {\n                  A1 a = (A1) null;\n               }\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class B {\n                  A2 a = (A2) null;\n               }\n@@ -722,14 +722,14 @@ void classReference() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class A {\n                   Class<?> clazz = A1.class;\n               }\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class A {\n                   Class<?> clazz = A2.class;\n               }\n@@ -746,7 +746,7 @@ void methodSelect() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class B {\n                  A1 a = null;\n                  public void test() { a.foo(); }\n@@ -754,7 +754,7 @@ public class B {\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class B {\n                  A2 a = null;\n                  public void test() { a.foo(); }\n@@ -773,7 +773,7 @@ void staticImport() {\n           java(\n             \"\"\"\n               import static a.A1.stat;\n-                            \n+              \n               public class B {\n                   public void test() {\n                       stat();\n@@ -782,7 +782,7 @@ public void test() {\n               \"\"\",\n             \"\"\"\n               import static a.A2.stat;\n-                            \n+              \n               public class B {\n                   public void test() {\n                       stat();\n@@ -799,7 +799,7 @@ void staticImports2() {\n           java(\n             \"\"\"\n               package com.acme.product;\n-                            \n+              \n               public class RunnableFactory {\n                   public static String getString() {\n                       return \"hello\";\n@@ -810,9 +810,9 @@ public static String getString() {\n           java(\n             \"\"\"\n               package com.acme.project.impl;\n-                            \n+              \n               import static com.acme.product.RunnableFactory.getString;\n-                            \n+              \n               public class StaticImportWorker {\n                   public void work() {\n                       getString().toLowerCase();\n@@ -821,9 +821,9 @@ public void work() {\n               \"\"\",\n             \"\"\"\n               package com.acme.project.impl;\n-                            \n+              \n               import static com.acme.product.v2.RunnableFactory.getString;\n-                            \n+              \n               public class StaticImportWorker {\n                   public void work() {\n                       getString().toLowerCase();\n@@ -841,7 +841,7 @@ void staticConstant() {\n           java(\n             \"\"\"\n               package com.acme.product;\n-                            \n+              \n               public class RunnableFactory {\n                   public static final String CONSTANT = \"hello\";\n               }\n@@ -850,9 +850,9 @@ public class RunnableFactory {\n           java(\n             \"\"\"\n               package com.acme.project.impl;\n-                            \n+              \n               import static com.acme.product.RunnableFactory.CONSTANT;\n-                            \n+              \n               public class StaticImportWorker {\n                   public void work() {\n                       System.out.println(CONSTANT + \" fred.\");\n@@ -861,9 +861,9 @@ public void work() {\n               \"\"\",\n             \"\"\"\n               package com.acme.project.impl;\n-                            \n+              \n               import static com.acme.product.v2.RunnableFactory.CONSTANT;\n-                            \n+              \n               public class StaticImportWorker {\n                   public void work() {\n                       System.out.println(CONSTANT + \" fred.\");\n@@ -945,23 +945,23 @@ public class B {}\n           java(\n             \"\"\"\n               package com.myorg;\n-                            \n+              \n               import java.util.ArrayList;\n               import com.yourorg.a.A;\n               import java.util.List;\n-                            \n+              \n               public class Foo {\n                   List<A> a = new ArrayList<>();\n               }\n               \"\"\",\n             \"\"\"\n               package com.myorg;\n-                            \n+              \n               import com.myorg.b.B;\n-                            \n+              \n               import java.util.ArrayList;\n               import java.util.List;\n-                            \n+              \n               public class Foo {\n                   List<B> a = new ArrayList<>();\n               }\n@@ -977,10 +977,10 @@ void changeTypeWithInnerClass() {\n           java(\n             \"\"\"\n               package com.acme.product;\n-                            \n+              \n               public class OuterClass {\n                   public static class InnerClass {\n-                            \n+              \n                   }\n               }\n               \"\"\"\n@@ -988,15 +988,15 @@ public static class InnerClass {\n           java(\n             \"\"\"\n               package de;\n-                            \n+              \n               import com.acme.product.OuterClass;\n               import com.acme.product.OuterClass.InnerClass;\n-                            \n+              \n               public class UseInnerClass {\n                   public String work() {\n                       return new InnerClass().toString();\n                   }\n-                            \n+              \n                   public String work2() {\n                       return new OuterClass().toString();\n                   }\n@@ -1004,15 +1004,15 @@ public String work2() {\n               \"\"\",\n             \"\"\"\n               package de;\n-                            \n+              \n               import com.acme.product.v2.OuterClass;\n               import com.acme.product.v2.OuterClass.InnerClass;\n-                            \n+              \n               public class UseInnerClass {\n                   public String work() {\n                       return new InnerClass().toString();\n                   }\n-                            \n+              \n                   public String work2() {\n                       return new OuterClass().toString();\n                   }\n@@ -1030,7 +1030,7 @@ void uppercaseInPackage() {\n           java(\n             \"\"\"\n               package com.acme.product.util.accessDecision;\n-                            \n+              \n               public enum AccessVote {\n                   ABSTAIN\n               }\n@@ -1039,9 +1039,9 @@ public enum AccessVote {\n           java(\n             \"\"\"\n               package de;\n-                            \n+              \n               import com.acme.product.util.accessDecision.AccessVote;\n-                            \n+              \n               public class ProjectVoter {\n                   public AccessVote vote() {\n                       return AccessVote.ABSTAIN;\n@@ -1050,9 +1050,9 @@ public AccessVote vote() {\n               \"\"\",\n             \"\"\"\n               package de;\n-                            \n+              \n               import com.acme.product.v2.util.accessDecision.AccessVote;\n-                            \n+              \n               public class ProjectVoter {\n                   public AccessVote vote() {\n                       return AccessVote.ABSTAIN;\n@@ -1079,7 +1079,7 @@ public interface Procedure {\n           java(\n             \"\"\"\n               import com.acme.product.Procedure;\n-                            \n+              \n               public abstract class Worker {\n                   void callWorker() {\n                       worker(() -> {\n@@ -1090,7 +1090,7 @@ void callWorker() {\n               \"\"\",\n             \"\"\"\n               import com.acme.product.Procedure2;\n-                            \n+              \n               public abstract class Worker {\n                   void callWorker() {\n                       worker(() -> {\n@@ -1111,7 +1111,7 @@ void assignment() {\n           java(\n             \"\"\"\n               package com.acme.product.util.accessDecision;\n-                            \n+              \n               public enum AccessVote {\n                   ABSTAIN,\n                   GRANT\n@@ -1121,9 +1121,9 @@ public enum AccessVote {\n           java(\n             \"\"\"\n               package de;\n-                            \n+              \n               import com.acme.product.util.accessDecision.AccessVote;\n-                            \n+              \n               public class ProjectVoter {\n                   public AccessVote vote(Object input) {\n                       AccessVote fred;\n@@ -1134,9 +1134,9 @@ public AccessVote vote(Object input) {\n               \"\"\",\n             \"\"\"\n               package de;\n-                            \n+              \n               import com.acme.product.v2.util.accessDecision.AccessVote;\n-                            \n+              \n               public class ProjectVoter {\n                   public AccessVote vote(Object input) {\n                       AccessVote fred;\n@@ -1157,7 +1157,7 @@ void ternary() {\n           java(\n             \"\"\"\n               package com.acme.product.util.accessDecision;\n-                            \n+              \n               public enum AccessVote {\n                   ABSTAIN,\n                   GRANT\n@@ -1167,9 +1167,9 @@ public enum AccessVote {\n           java(\n             \"\"\"\n               package de;\n-                            \n+              \n               import com.acme.product.util.accessDecision.AccessVote;\n-                            \n+              \n               public class ProjectVoter {\n                   public AccessVote vote(Object input) {\n                       return input == null ? AccessVote.GRANT : AccessVote.ABSTAIN;\n@@ -1178,9 +1178,9 @@ public AccessVote vote(Object input) {\n               \"\"\",\n             \"\"\"\n               package de;\n-                            \n+              \n               import com.acme.product.v2.util.accessDecision.AccessVote;\n-                            \n+              \n               public class ProjectVoter {\n                   public AccessVote vote(Object input) {\n                       return input == null ? AccessVote.GRANT : AccessVote.ABSTAIN;\n@@ -1230,7 +1230,7 @@ void javadocs() {\n           java(\n             \"\"\"\n               import java.util.List;\n-                            \n+              \n               /**\n                * {@link List} here\n                */\n@@ -1240,7 +1240,7 @@ class Test {\n               \"\"\",\n             \"\"\"\n               import java.util.Collection;\n-                            \n+              \n               /**\n                * {@link Collection} here\n                */\n@@ -1260,7 +1260,7 @@ void onlyUpdateApplicableImport() {\n           java(\n             \"\"\"\n               package com.acme.product.factory;\n-                            \n+              \n               public class V1Factory {\n                   public static String getItem() {\n                       return \"V1Factory\";\n@@ -1271,7 +1271,7 @@ public static String getItem() {\n           java(\n             \"\"\"\n               package com.acme.product.factory;\n-                            \n+              \n               public class V2Factory {\n                   public static String getItem() {\n                       return \"V2Factory\";\n@@ -1282,16 +1282,16 @@ public static String getItem() {\n           java(\n             \"\"\"\n               import com.acme.product.factory.V1Factory;\n-                            \n+              \n               import static com.acme.product.factory.V2Factory.getItem;\n-                            \n+              \n               public class UseFactories {\n                   static class MyV1Factory extends V1Factory {\n                       static String getMyItemInherited() {\n                           return getItem();\n                       }\n                   }\n-                            \n+              \n                   static String getMyItemStaticImport() {\n                       return getItem();\n                   }\n@@ -1299,16 +1299,16 @@ static String getMyItemStaticImport() {\n               \"\"\",\n             \"\"\"\n               import com.acme.product.factory.V1FactoryA;\n-                            \n+              \n               import static com.acme.product.factory.V2Factory.getItem;\n-                            \n+              \n               public class UseFactories {\n                   static class MyV1Factory extends V1FactoryA {\n                       static String getMyItemInherited() {\n                           return getItem();\n                       }\n                   }\n-                            \n+              \n                   static String getMyItemStaticImport() {\n                       return getItem();\n                   }\n@@ -1391,15 +1391,15 @@ void updateImportPrefixWithEmptyPackage() {\n           java(\n             \"\"\"\n               package a.b;\n-                            \n+              \n               import java.util.List;\n-                            \n+              \n               class Original {\n               }\n               \"\"\",\n             \"\"\"\n               import java.util.List;\n-                            \n+              \n               class Target {\n               }\n               \"\"\"\n@@ -1415,7 +1415,7 @@ void updateClassPrefixWithEmptyPackage() {\n           java(\n             \"\"\"\n               package a.b;\n-\n+              \n               class Original {\n               }\n               \"\"\",\n@@ -1535,9 +1535,9 @@ public class A2 {\n           java(\n             \"\"\"\n               package org.foo;\n-                            \n+              \n               import a.A1;\n-                            \n+              \n               public class Example {\n                   public A1 method(A1 a1) {\n                       return a1;\n@@ -1546,9 +1546,9 @@ public A1 method(A1 a1) {\n               \"\"\",\n             \"\"\"\n               package org.foo;\n-                            \n+              \n               import a.A2;\n-                            \n+              \n               public class Example {\n                   public A2 method(A2 a1) {\n                       return a1;\n@@ -1560,7 +1560,7 @@ public A2 method(A2 a1) {\n             \"\"\"\n               import a.A1;\n               import org.foo.Example;\n-                            \n+              \n               public class Test {\n                   A1 local = new Example().method(null);\n               }\n@@ -1568,7 +1568,7 @@ public class Test {\n             \"\"\"\n               import a.A2;\n               import org.foo.Example;\n-                            \n+              \n               public class Test {\n                   A2 local = new Example().method(null);\n               }\n@@ -1596,14 +1596,14 @@ void updateVariableType() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class Test {\n                   A1 a;\n               }\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class Test {\n                   A2 a;\n               }\n@@ -1626,7 +1626,7 @@ void boundedGenericType() {\n           java(\n             \"\"\"\n               import a.A1;\n-                            \n+              \n               public class Test {\n                   <T extends A1> T method(T t) {\n                       return t;\n@@ -1635,7 +1635,7 @@ <T extends A1> T method(T t) {\n               \"\"\",\n             \"\"\"\n               import a.A2;\n-                            \n+              \n               public class Test {\n                   <T extends A2> T method(T t) {\n                       return t;\n@@ -1658,7 +1658,7 @@ void changeConstructor() {\n           java(\n             \"\"\"\n               package a;\n-                            \n+              \n               public class A1 {\n                   public A1() {\n                   }\n@@ -1666,7 +1666,7 @@ public A1() {\n               \"\"\",\n             \"\"\"\n               package a;\n-                            \n+              \n               public class A2 {\n                   public A2() {\n                   }\n@@ -1689,12 +1689,12 @@ void updateJavaTypeClassKindAnnotation() {\n           java(\n             \"\"\"\n               package org.openrewrite;\n-                            \n+              \n               import java.lang.annotation.ElementType;\n               import java.lang.annotation.Retention;\n               import java.lang.annotation.RetentionPolicy;\n               import java.lang.annotation.Target;\n-                            \n+              \n               @Target({ElementType.TYPE, ElementType.METHOD})\n               @Retention(RetentionPolicy.RUNTIME)\n               public @interface Test1 {}\n@@ -1703,12 +1703,12 @@ void updateJavaTypeClassKindAnnotation() {\n           java(\n             \"\"\"\n               package org.openrewrite;\n-                            \n+              \n               import java.lang.annotation.ElementType;\n               import java.lang.annotation.Retention;\n               import java.lang.annotation.RetentionPolicy;\n               import java.lang.annotation.Target;\n-                            \n+              \n               @Target({ElementType.TYPE, ElementType.METHOD})\n               @Retention(RetentionPolicy.RUNTIME)\n               public @interface Test2 {}\n@@ -1717,7 +1717,7 @@ void updateJavaTypeClassKindAnnotation() {\n           java(\n             \"\"\"\n               import org.openrewrite.Test1;\n-                            \n+              \n               public class A {\n                   @Test1\n                   void method() {}\n@@ -1725,7 +1725,7 @@ void method() {}\n               \"\"\",\n             \"\"\"\n               import org.openrewrite.Test2;\n-                            \n+              \n               public class A {\n                   @Test2\n                   void method() {}\n@@ -1800,14 +1800,13 @@ void doesNotModifyInnerClassesIfIgnoreDefinitionTrue() {\n           spec -> spec.recipe(new ChangeType(\"Test.InnerA\", \"Test.InnerB\", true)),\n           java(\n             \"\"\"\n-\n               public class Test {\n                   private class InnerA {\n                   }\n-                            \n+              \n                   private class InnerB {\n                   }\n-                            \n+              \n                   public void test(String s) {\n                       InnerA a = new InnerA();\n                   }\n@@ -1817,10 +1816,10 @@ public void test(String s) {\n               public class Test {\n                   private class InnerA {\n                   }\n-                            \n+              \n                   private class InnerB {\n                   }\n-                            \n+              \n                   public void test(String s) {\n                       InnerB a = new InnerB();\n                   }\n@@ -1851,9 +1850,9 @@ public class Test {\n           java(\n             \"\"\"\n               package org.openrewrite;\n-                            \n+              \n               import org.openrewrite.Test;\n-                            \n+              \n               public class Sibling {\n                   public Test test() {\n                       return new Test();\n@@ -1862,9 +1861,9 @@ public Test test() {\n               \"\"\",\n             \"\"\"\n               package org.openrewrite;\n-                            \n+              \n               import org.openrewrite.subpackage.Test;\n-                            \n+              \n               public class Sibling {\n                   public Test test() {\n                       return new Test();\n@@ -1912,9 +1911,9 @@ public ObjectMapper configure(SerializationConfig.Feature f, boolean state) {\n           java(\n             \"\"\"\n               import org.codehaus.jackson.map.ObjectMapper;\n-\n+              \n               import static org.codehaus.jackson.map.SerializationConfig.Feature.WRAP_ROOT_VALUE;\n-\n+              \n               class A {\n                   void test() {\n                       ObjectMapper mapper = new ObjectMapper();\n@@ -1924,9 +1923,9 @@ void test() {\n               \"\"\",\n             \"\"\"\n               import com.fasterxml.jackson.databind.ObjectMapper;\n-\n+              \n               import static com.fasterxml.jackson.databind.SerializationFeature.WRAP_ROOT_VALUE;\n-\n+              \n               class A {\n                   void test() {\n                       ObjectMapper mapper = new ObjectMapper();\n@@ -1937,4 +1936,39 @@ void test() {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4452\")\n+    void shouldFullyQualifyWhenNewTypeIsAmbiguous() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeType(\n+            \"javax.annotation.Nonnull\",\n+            \"org.checkerframework.checker.nullness.qual.NonNull\",\n+            null)),\n+          // language=java\n+          java(\n+            \"\"\"\n+              import lombok.NonNull;\n+              import javax.annotation.Nonnull;\n+              import org.immutables.value.Value;\n+              \n+              @Value.Immutable\n+              @Value.Style(passAnnotations = Nonnull.class)\n+              interface ConflictingImports {\n+                      void lombokMethod(@NonNull final String lombokNonNull){}\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import lombok.NonNull;\n+              import org.immutables.value.Value;\n+              \n+              @Value.Immutable\n+              @Value.Style(passAnnotations = org.checkerframework.checker.nullness.qual.NonNull.class)\n+              interface ConflictingImports {\n+                      void lombokMethod(@NonNull final String lombokNonNull){}\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4442",
    "pr_id": 4442,
    "issue_id": 4441,
    "repo": "openrewrite/rewrite",
    "problem_statement": "`ReplaceAnnotation` replaces with wrong annotation in method with annotated argument and local variable\n## How are you running OpenRewrite?\r\nUnit test based on https://github.com/openrewrite/rewrite/releases/tag/v8.33.7\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n```java\r\n@Test\r\nvoid methodWithAnnotatedParameter() {\r\n    rewriteRun(\r\n      spec -> spec.recipe(new ReplaceAnnotation(\"@org.jetbrains.annotations.NotNull\", \"@lombok.NonNull\", null)),\r\n      java(\r\n        \"\"\"\r\n          import org.jetbrains.annotations.NotNull;\r\n          import org.jetbrains.annotations.Nullable;\r\n          class ValueAnnotationDuplication {\r\n              void methodName(\r\n                  @Nullable final boolean valueVar) {\r\n                  @NotNull final String nullableVar = \"test\";\r\n              }\r\n          }\r\n          \"\"\",\r\n        \"\"\"\r\n          import lombok.NonNull;\r\n          import org.jetbrains.annotations.Nullable;\r\n          class ValueAnnotationDuplication {\r\n              void methodName(\r\n                  @Nullable final boolean valueVar) {\r\n                  @NonNull final String nullableVar = \"test\";\r\n              }\r\n          }\r\n          \"\"\"\r\n      )\r\n    );\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\nAbove unit test to pass\r\n\r\n## What did you see instead?\r\nIncorrect replacement\r\n```diff\r\ndiff --git a/ValueAnnotationDuplication.java b/ValueAnnotationDuplication.java\r\nindex 3b9317e..a586033 100644\r\n--- a/ValueAnnotationDuplication.java\r\n+++ b/ValueAnnotationDuplication.java\r\n@@ -1,8 +1,7 @@ \r\n-import lombok.NonNull;\r\n import org.jetbrains.annotations.Nullable;\r\n class ValueAnnotationDuplication {\r\n     void methodName(\r\n         @Nullable final boolean valueVar) {\r\n-        @NonNull final String nullableVar = \"test\";\r\n+        @Nullable final String nullableVar = \"test\";\r\n     }\r\n }\r\n\\ No newline at end of file\r\n```\r\n",
    "issue_word_count": 177,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java/src/main/java/org/openrewrite/java/internal/template/AnnotationTemplateGenerator.java",
      "rewrite-java/src/test/java/org/openrewrite/java/ReplaceAnnotationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java/src/test/java/org/openrewrite/java/ReplaceAnnotationTest.java"
    ],
    "base_commit": "1777317716a7076040e3ae3051790042982189a4",
    "head_commit": "f11ea48c5d604ac9830b4dcbc9eff5c2e4d246aa",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4442",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4442",
    "dockerfile": "",
    "pr_merged_at": "2024-08-24T20:56:30.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/internal/template/AnnotationTemplateGenerator.java b/rewrite-java/src/main/java/org/openrewrite/java/internal/template/AnnotationTemplateGenerator.java\nindex 76fef6d8df8..45f9083bb2a 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/internal/template/AnnotationTemplateGenerator.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/internal/template/AnnotationTemplateGenerator.java\n@@ -101,12 +101,13 @@ public List<J.Annotation> listAnnotations(JavaSourceFile cu) {\n \n             @Override\n             public J.Annotation visitAnnotation(J.Annotation annotation, Integer integer) {\n-                J.Annotation withoutTemplateComment = annotation.withComments(\n-                        ListUtils.concatAll(\n-                                ListUtils.map(getCursor().getParentOrThrow().<J>getValue().getComments(), this::filterTemplateComment),\n-                                ListUtils.map(annotation.getComments(), this::filterTemplateComment)\n-                        ));\n-                annotations.add(withoutTemplateComment);\n+                List<Comment> combinedComments = ListUtils.concatAll(\n+                        getCursor().getParentOrThrow().<J>getValue().getComments(),\n+                        annotation.getComments());\n+                List<Comment> filteredComments = ListUtils.map(combinedComments, this::filterTemplateComment);\n+                if (combinedComments != filteredComments) {\n+                    annotations.add(annotation.withComments(filteredComments));\n+                }\n                 return annotation;\n             }\n         }.visit(cu, 0);\n",
    "test_patch": "diff --git a/rewrite-java/src/test/java/org/openrewrite/java/ReplaceAnnotationTest.java b/rewrite-java/src/test/java/org/openrewrite/java/ReplaceAnnotationTest.java\nindex 894e5366777..075c09dc74b 100644\n--- a/rewrite-java/src/test/java/org/openrewrite/java/ReplaceAnnotationTest.java\n+++ b/rewrite-java/src/test/java/org/openrewrite/java/ReplaceAnnotationTest.java\n@@ -18,6 +18,7 @@\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n import org.openrewrite.DocumentExample;\n+import org.openrewrite.Issue;\n import org.openrewrite.test.RewriteTest;\n \n import static org.openrewrite.java.Assertions.java;\n@@ -39,7 +40,7 @@ class A {\n                       String testMethod() {}\n                   }\n                   \"\"\",\n-                  \"\"\"\n+                \"\"\"\n                   import lombok.NonNull;\n \n                   class A {\n@@ -65,7 +66,7 @@ class A {\n                       String testMethod() {}\n                   }\n                   \"\"\",\n-                  \"\"\"\n+                \"\"\"\n                   import lombok.NonNull;\n \n                   class A {\n@@ -101,6 +102,38 @@ String testMethod() {}\n               )\n             );\n         }\n+\n+        @Test\n+        @Issue(\"https://github.com/openrewrite/rewrite/issues/4441\")\n+        void methodWithAnnotatedParameter() {\n+            rewriteRun(\n+              spec -> spec.recipe(new ReplaceAnnotation(\"@org.jetbrains.annotations.NotNull\", \"@lombok.NonNull\", null)),\n+              java(\n+                \"\"\"\n+                  import org.jetbrains.annotations.NotNull;\n+                  import org.jetbrains.annotations.Nullable;\n+\n+                  class A {\n+                      void methodName(\n+                          @Nullable final boolean valueVar) {\n+                          @NotNull final String nullableVar = \"test\";\n+                      }\n+                  }\n+                  \"\"\",\n+                \"\"\"\n+                  import lombok.NonNull;\n+                  import org.jetbrains.annotations.Nullable;\n+\n+                  class A {\n+                      void methodName(\n+                          @Nullable final boolean valueVar) {\n+                          @NonNull final String nullableVar = \"test\";\n+                      }\n+                  }\n+                  \"\"\"\n+              )\n+            );\n+        }\n     }\n \n     @Nested\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4427",
    "pr_id": 4427,
    "issue_id": 4423,
    "repo": "openrewrite/rewrite",
    "problem_statement": "`JavaTemplateSemanticallyEqual` fails to match AssertJ's `assertThat(\"foo\").isEqualTo(\"\")`\n## What version of OpenRewrite are you using?\r\nhttps://github.com/openrewrite/rewrite/releases/tag/v8.33.4\r\n\r\n## Problem statement\r\nThis recipe replicates what's generated from our Refaster template generator:\r\n- https://github.com/openrewrite/rewrite-templating/pull/91\r\n\r\nBased on a Refaster rule defined at Picnic\r\n- https://error-prone.picnic.tech/refasterrules/AssertJStringRules/#abstractstringassertstringisempty\r\n\r\nWe might want to quickly double check the String passed in to `JavaTemplate.builder`.\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n```java\r\nimport org.junit.jupiter.api.Test;\r\nimport org.openrewrite.ExecutionContext;\r\nimport org.openrewrite.Issue;\r\nimport org.openrewrite.java.tree.J;\r\nimport org.openrewrite.marker.SearchResult;\r\nimport org.openrewrite.test.RewriteTest;\r\n\r\nimport static org.openrewrite.java.Assertions.java;\r\nimport static org.openrewrite.test.RewriteTest.toRecipe;\r\n\r\nclass JavaTemplateMatcherTest implements RewriteTest {\r\n\r\n    @Test\r\n    @Issue(\"https://github.com/openrewrite/rewrite-templating/pull/91\")\r\n    void shouldMatchAbstracTStringAssertIsEqualToEmptyString() {\r\n        rewriteRun(\r\n          spec -> spec\r\n            .parser(JavaParser.fromJavaVersion().classpath(\"assertj-core\"))\r\n            .recipe(toRecipe(() -> new JavaIsoVisitor<>() {\r\n                // Mimics what we saw in rewrite-templating\r\n                final JavaTemplate before = JavaTemplate\r\n                  .builder(\"#{stringAssert:any(org.assertj.core.api.AbstractStringAssert<?>)}.isEqualTo(\\\"\\\");\")\r\n                  .javaParser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()))\r\n                  .build();\r\n\r\n                @Override\r\n                public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\r\n                    J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);\r\n                    return before.matches(getCursor()) ? SearchResult.found(mi) : mi;\r\n                }\r\n            })),\r\n          //language=java\r\n          java(\r\n            \"\"\"\r\n              import static org.assertj.core.api.Assertions.assertThat;\r\n              class Foo {\r\n                  void test() {\r\n                      assertThat(\"foo\").isEqualTo(\"\");\r\n                  }\r\n              }\r\n              \"\"\",\r\n            \"\"\"\r\n              import static org.assertj.core.api.Assertions.assertThat;\r\n              class Foo {\r\n                  void test() {\r\n                      /*~~>*/assertThat(\"foo\").isEqualTo(\"\");\r\n                  }\r\n              }\r\n              \"\"\"\r\n          )\r\n        );\r\n\r\n    }\r\n}\r\n```\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n```\r\njava.lang.AssertionError: Recipe was expected to make a change but made no changes.\r\n```",
    "issue_word_count": 271,
    "test_files_count": 1,
    "non_test_files_count": 9,
    "pr_changed_files": [
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeMapping.java",
      "rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeSignatureBuilder.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java",
      "rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeSignatureBuilder.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeMapping.java",
      "rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeSignatureBuilder.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeMapping.java",
      "rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeSignatureBuilder.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateMatchTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateMatchTest.java"
    ],
    "base_commit": "51c3d0142415ded514f4d3567dfc00cf83fc89f2",
    "head_commit": "78a842eabaf7ae5f8d9ce6b046eacedf157e0068",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4427",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4427",
    "dockerfile": "",
    "pr_merged_at": "2024-08-21T08:02:23.000Z",
    "patch": "diff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeMapping.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeMapping.java\nindex 577e2deb923..04d4280e6d9 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeMapping.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeMapping.java\n@@ -196,7 +196,12 @@ private JavaType.GenericTypeVariable generic(Type.WildcardType wildcard, String\n     }\n \n     private JavaType generic(Type.TypeVar type, String signature) {\n-        String name = type.tsym.name.toString();\n+        String name;\n+        if (type instanceof Type.CapturedType && ((Type.CapturedType) type).wildcard.kind == BoundKind.UNBOUND) {\n+            name = \"?\";\n+        } else {\n+            name = type.tsym.name.toString();\n+        }\n         JavaType.GenericTypeVariable gtv = new JavaType.GenericTypeVariable(null,\n                 name, INVARIANT, null);\n         typeCache.put(signature, gtv);\n\ndiff --git a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeSignatureBuilder.java b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeSignatureBuilder.java\nindex 612ce245244..ad236877d51 100644\n--- a/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeSignatureBuilder.java\n+++ b/rewrite-java-11/src/main/java/org/openrewrite/java/isolated/ReloadableJava11TypeSignatureBuilder.java\n@@ -15,6 +15,7 @@\n  */\n package org.openrewrite.java.isolated;\n \n+import com.sun.tools.javac.code.BoundKind;\n import com.sun.tools.javac.code.Symbol;\n import com.sun.tools.javac.code.Type;\n import com.sun.tools.javac.code.TypeTag;\n@@ -51,7 +52,7 @@ private String signature(@Nullable Type type) {\n                 return ((Type.ClassType) type).typarams_field != null && ((Type.ClassType) type).typarams_field.length() > 0 ? parameterizedSignature(type) : classSignature(type);\n             }\n         } else if (type instanceof Type.CapturedType) { // CapturedType must be evaluated before TypeVar\n-            return signature(((Type.CapturedType) type).wildcard);\n+            return genericSignature(type);\n         } else if (type instanceof Type.TypeVar) {\n             return genericSignature(type);\n         } else if (type instanceof Type.JCPrimitiveType) {\n@@ -140,7 +141,12 @@ public String classSignature(Object type) {\n     @Override\n     public String genericSignature(Object type) {\n         Type.TypeVar generic = (Type.TypeVar) type;\n-        String name = generic.tsym.name.toString();\n+        String name;\n+        if (generic instanceof Type.CapturedType && ((Type.CapturedType) generic).wildcard.kind == BoundKind.UNBOUND) {\n+            name = \"?\";\n+        } else {\n+            name = generic.tsym.name.toString();\n+        }\n \n         if (typeVariableNameStack == null) {\n             typeVariableNameStack = new HashSet<>();\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java\nindex 035f87f570b..c4df9e35a1b 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeMapping.java\n@@ -193,7 +193,12 @@ private JavaType.GenericTypeVariable generic(Type.WildcardType wildcard, String\n     }\n \n     private JavaType generic(Type.TypeVar type, String signature) {\n-        String name = type.tsym.name.toString();\n+        String name;\n+        if (type instanceof Type.CapturedType && ((Type.CapturedType) type).wildcard.kind == BoundKind.UNBOUND) {\n+            name = \"?\";\n+        } else {\n+            name = type.tsym.name.toString();\n+        }\n         JavaType.GenericTypeVariable gtv = new JavaType.GenericTypeVariable(null,\n                 name, INVARIANT, null);\n         typeCache.put(signature, gtv);\n\ndiff --git a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeSignatureBuilder.java b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeSignatureBuilder.java\nindex 7e287e11ab4..4e232e1856e 100644\n--- a/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeSignatureBuilder.java\n+++ b/rewrite-java-17/src/main/java/org/openrewrite/java/isolated/ReloadableJava17TypeSignatureBuilder.java\n@@ -15,6 +15,7 @@\n  */\n package org.openrewrite.java.isolated;\n \n+import com.sun.tools.javac.code.BoundKind;\n import com.sun.tools.javac.code.Symbol;\n import com.sun.tools.javac.code.Type;\n import com.sun.tools.javac.code.TypeTag;\n@@ -51,7 +52,7 @@ private String signature(@Nullable Type type) {\n                 return ((Type.ClassType) type).typarams_field != null && ((Type.ClassType) type).typarams_field.length() > 0 ? parameterizedSignature(type) : classSignature(type);\n             }\n         } else if (type instanceof Type.CapturedType) { // CapturedType must be evaluated before TypeVar\n-            return signature(((Type.CapturedType) type).wildcard);\n+            return genericSignature(type);\n         } else if (type instanceof Type.TypeVar) {\n             return genericSignature(type);\n         } else if (type instanceof Type.JCPrimitiveType) {\n@@ -140,7 +141,12 @@ public String classSignature(Object type) {\n     @Override\n     public String genericSignature(Object type) {\n         Type.TypeVar generic = (Type.TypeVar) type;\n-        String name = generic.tsym.name.toString();\n+        String name;\n+        if (generic instanceof Type.CapturedType && ((Type.CapturedType) generic).wildcard.kind == BoundKind.UNBOUND) {\n+            name = \"?\";\n+        } else {\n+            name = generic.tsym.name.toString();\n+        }\n \n         if (typeVariableNameStack == null) {\n             typeVariableNameStack = new HashSet<>();\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeMapping.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeMapping.java\nindex 30e63951d90..b691ed8c166 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeMapping.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeMapping.java\n@@ -47,7 +47,7 @@ class ReloadableJava21TypeMapping implements JavaTypeMapping<Tree> {\n \n     public JavaType type(com.sun.tools.javac.code.@Nullable Type type) {\n         if (type == null || type instanceof Type.ErrorType || type instanceof Type.PackageType || type instanceof Type.UnknownType ||\n-                type instanceof NullType) {\n+            type instanceof NullType) {\n             return JavaType.Class.Unknown.getInstance();\n         }\n \n@@ -211,7 +211,12 @@ private JavaType.GenericTypeVariable generic(Type.WildcardType wildcard, String\n     }\n \n     private JavaType generic(Type.TypeVar type, String signature) {\n-        String name = type.tsym.name.toString();\n+        String name;\n+        if (type instanceof Type.CapturedType && ((Type.CapturedType) type).wildcard.kind == BoundKind.UNBOUND) {\n+            name = \"?\";\n+        } else {\n+            name = type.tsym.name.toString();\n+        }\n         JavaType.GenericTypeVariable gtv = new JavaType.GenericTypeVariable(null,\n                 name, INVARIANT, null);\n         typeCache.put(signature, gtv);\n\ndiff --git a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeSignatureBuilder.java b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeSignatureBuilder.java\nindex 172a58c674e..6ae0e842497 100644\n--- a/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeSignatureBuilder.java\n+++ b/rewrite-java-21/src/main/java/org/openrewrite/java/isolated/ReloadableJava21TypeSignatureBuilder.java\n@@ -15,6 +15,7 @@\n  */\n package org.openrewrite.java.isolated;\n \n+import com.sun.tools.javac.code.BoundKind;\n import com.sun.tools.javac.code.Symbol;\n import com.sun.tools.javac.code.Type;\n import com.sun.tools.javac.code.TypeTag;\n@@ -51,7 +52,7 @@ private String signature(@Nullable Type type) {\n                 return ((Type.ClassType) type).typarams_field != null && ((Type.ClassType) type).typarams_field.length() > 0 ? parameterizedSignature(type) : classSignature(type);\n             }\n         } else if (type instanceof Type.CapturedType) { // CapturedType must be evaluated before TypeVar\n-            return signature(((Type.CapturedType) type).wildcard);\n+            return genericSignature(type);\n         } else if (type instanceof Type.TypeVar) {\n             return genericSignature(type);\n         } else if (type instanceof Type.JCPrimitiveType) {\n@@ -140,7 +141,12 @@ public String classSignature(Object type) {\n     @Override\n     public String genericSignature(Object type) {\n         Type.TypeVar generic = (Type.TypeVar) type;\n-        String name = generic.tsym.name.toString();\n+        String name;\n+        if (generic instanceof Type.CapturedType && ((Type.CapturedType) generic).wildcard.kind == BoundKind.UNBOUND) {\n+            name = \"?\";\n+        } else {\n+            name = generic.tsym.name.toString();\n+        }\n \n         if (typeVariableNameStack == null) {\n             typeVariableNameStack = new HashSet<>();\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeMapping.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeMapping.java\nindex 81161725c50..14787c651c2 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeMapping.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeMapping.java\n@@ -197,7 +197,12 @@ private JavaType.GenericTypeVariable generic(Type.WildcardType wildcard, String\n     }\n \n     private JavaType generic(Type.TypeVar type, String signature) {\n-        String name = type.tsym.name.toString();\n+        String name;\n+        if (type instanceof Type.CapturedType && ((Type.CapturedType) type).wildcard.kind == BoundKind.UNBOUND) {\n+            name = \"?\";\n+        } else {\n+            name = type.tsym.name.toString();\n+        }\n         JavaType.GenericTypeVariable gtv = new JavaType.GenericTypeVariable(null,\n                 name, INVARIANT, null);\n         typeCache.put(signature, gtv);\n\ndiff --git a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeSignatureBuilder.java b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeSignatureBuilder.java\nindex 3a608b88496..dc92ba8f0d3 100644\n--- a/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeSignatureBuilder.java\n+++ b/rewrite-java-8/src/main/java/org/openrewrite/java/ReloadableJava8TypeSignatureBuilder.java\n@@ -15,6 +15,7 @@\n  */\n package org.openrewrite.java;\n \n+import com.sun.tools.javac.code.BoundKind;\n import com.sun.tools.javac.code.Symbol;\n import com.sun.tools.javac.code.Type;\n import com.sun.tools.javac.code.TypeTag;\n@@ -49,8 +50,8 @@ private String signature(@Nullable Type type) {\n             } catch (Symbol.CompletionFailure ignored) {\n                 return ((Type.ClassType) type).typarams_field != null && ((Type.ClassType) type).typarams_field.length() > 0 ? parameterizedSignature(type) : classSignature(type);\n             }\n-        } else if (type instanceof Type.CapturedType) {  // CapturedType must be evaluated before TypeVar\n-            return signature(((Type.CapturedType) type).wildcard);\n+        } else if (type instanceof Type.CapturedType) { // CapturedType must be evaluated before TypeVar\n+            return genericSignature(type);\n         } else if (type instanceof Type.TypeVar) {\n             return genericSignature(type);\n         } else if (type instanceof Type.JCPrimitiveType) {\n@@ -139,7 +140,12 @@ public String classSignature(Object type) {\n     @Override\n     public String genericSignature(Object type) {\n         Type.TypeVar generic = (Type.TypeVar) type;\n-        String name = generic.tsym.name.toString();\n+        String name;\n+        if (generic instanceof Type.CapturedType && ((Type.CapturedType) generic).wildcard.kind == BoundKind.UNBOUND) {\n+            name = \"?\";\n+        } else {\n+            name = generic.tsym.name.toString();\n+        }\n \n         if (typeVariableNameStack == null) {\n             typeVariableNameStack = new HashSet<>();\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java\nindex 7b02cb3ae3c..c895e63158c 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java\n@@ -227,6 +227,9 @@ public static boolean isAssignableTo(@Nullable JavaType to, @Nullable JavaType f\n                 }\n                 return !(from instanceof JavaType.GenericTypeVariable) && isAssignableTo(toFq.getFullyQualifiedName(), from);\n             } else if (to instanceof JavaType.GenericTypeVariable) {\n+                if (from instanceof JavaType.GenericTypeVariable && isOfType(to, from)) {\n+                    return true;\n+                }\n                 JavaType.GenericTypeVariable toGeneric = (JavaType.GenericTypeVariable) to;\n                 List<JavaType> toBounds = toGeneric.getBounds();\n                 if (!toGeneric.getName().equals(\"?\")) {\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateMatchTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateMatchTest.java\nindex df35bfd3471..e1f1186bde5 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateMatchTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaTemplateMatchTest.java\n@@ -18,6 +18,7 @@\n import org.junit.jupiter.api.Test;\n import org.openrewrite.DocumentExample;\n import org.openrewrite.ExecutionContext;\n+import org.openrewrite.Issue;\n import org.openrewrite.java.tree.Expression;\n import org.openrewrite.java.tree.J;\n import org.openrewrite.marker.SearchResult;\n@@ -28,6 +29,48 @@\n \n class JavaTemplateMatchTest implements RewriteTest {\n \n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite-templating/pull/91\")\n+    void shouldMatchAbstractStringAssertIsEqualToEmptyString() {\n+        rewriteRun(\n+          spec -> spec\n+            .parser(JavaParser.fromJavaVersion().classpath(\"assertj-core\"))\n+            .recipe(toRecipe(() -> new JavaIsoVisitor<>() {\n+                // Mimics what we saw in rewrite-templating\n+                final JavaTemplate before = JavaTemplate\n+                  .builder(\"#{stringAssert:any(org.assertj.core.api.AbstractStringAssert<?>)}.isEqualTo(\\\"\\\");\")\n+                  .javaParser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()))\n+                  .build();\n+\n+                @Override\n+                public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n+                    J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);\n+                    return before.matches(getCursor()) ? SearchResult.found(mi) : mi;\n+                }\n+            })),\n+          //language=java\n+          java(\n+            \"\"\"\n+              import static org.assertj.core.api.Assertions.assertThat;\n+              class Foo {\n+                  void test() {\n+                      assertThat(\"foo\").isEqualTo(\"\");\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import static org.assertj.core.api.Assertions.assertThat;\n+              class Foo {\n+                  void test() {\n+                      /*~~>*/assertThat(\"foo\").isEqualTo(\"\");\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+\n+    }\n+\n     @DocumentExample\n     @SuppressWarnings({\"ConstantValue\", \"ConstantConditions\"})\n     @Test\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4421",
    "pr_id": 4421,
    "issue_id": 4420,
    "repo": "openrewrite/rewrite",
    "problem_statement": "newArtifactId changed to newArtifact in ChangePluginGroupIdAndArtifactId\n:wave:\r\n\r\n`newArtifactId` was renamed to `newArtifact` in `ChangePluginGroupIdAndArtifactId`.\r\n\r\nThis is very odd as not consistent with the rest of the properties (you have `oldArtifactId` but `newArtifact`). Also it breaks compatibility for anyone using the recipe.\r\n\r\nThe change was made here: https://github.com/openrewrite/rewrite/pull/3843/files#diff-a3496299541c5119d2fd48e331f97b62173789f41a9ec4f5f25f9e8454ab7518R59\r\n\r\nAnd you can see that there are already a few people complaining there.\r\n\r\nI know the change is not exactly recent but for whatever reason, it just popped up in the Quarkus Updates test.\r\n\r\nIt looks odd to me. Could someone confirm that it was intended?\r\n\r\nThanks!",
    "issue_word_count": 103,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java"
    ],
    "base_commit": "3672f4a0672466ce9dc1f73a68ccdf7579825d1f",
    "head_commit": "945f49ce2a4e3481d0c6511260c87f520515d298",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4421",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4421",
    "dockerfile": "",
    "pr_merged_at": "2024-08-15T11:46:16.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\nindex 25d2e69f2b9..2a772b3d0eb 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactId.java\n@@ -56,6 +56,18 @@ public class ChangePluginGroupIdAndArtifactId extends Recipe {\n             example = \"my-new-maven-plugin\",\n             required = false)\n     @Nullable\n+    String newArtifactId;\n+\n+    /**\n+     * Mistakenly introduced, we restored newArtifactId but let's not break recipes abruptly.\n+     */\n+    @Option(displayName = \"New artifact ID\",\n+        description = \"The new artifact ID to use. Defaults to the existing artifact ID. This property is deprecated, use newArtifactId instead.\",\n+        example = \"my-new-maven-plugin\",\n+        required = false)\n+    @Nullable\n+    @Deprecated\n+    @SuppressWarnings(\"DeprecatedIsStillUsed\")\n     String newArtifact;\n \n     @Override\n@@ -65,7 +77,7 @@ public String getDisplayName() {\n \n     @Override\n     public String getInstanceNameSuffix() {\n-        return String.format(\"`%s:%s`\", newGroupId, newArtifact);\n+        return String.format(\"`%s:%s`\", newGroupId, newArtifactId);\n     }\n \n     @Override\n@@ -84,7 +96,9 @@ public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                     if (newGroupId != null) {\n                         t = changeChildTagValue(t, \"groupId\", newGroupId, ctx);\n                     }\n-                    if (newArtifact != null) {\n+                    if (newArtifactId != null) {\n+                        t = changeChildTagValue(t, \"artifactId\", newArtifactId, ctx);\n+                    } else if (newArtifact != null) {\n                         t = changeChildTagValue(t, \"artifactId\", newArtifact, ctx);\n                     }\n                     if (t != tag) {\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java\nindex 87b02bfab6a..55147edecf3 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java\n@@ -31,6 +31,85 @@ void changePluginGroupIdAndArtifactId() {\n             \"io.quarkus\",\n             \"quarkus-bootstrap-maven-plugin\",\n             null,\n+            \"quarkus-extension-maven-plugin\",\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <build>\n+                      <plugins>\n+                          <plugin>\n+                              <groupId>io.quarkus</groupId>\n+                              <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n+                              <version>3.0.0.Beta1</version>\n+                          </plugin>\n+                      </plugins>\n+                  </build>\n+                  <profiles>\n+                      <profile>\n+                          <id>profile</id>\n+                          <build>\n+                              <plugins>\n+                                  <plugin>\n+                                      <groupId>io.quarkus</groupId>\n+                                      <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n+                                      <version>3.0.0.Beta1</version>\n+                                  </plugin>\n+                              </plugins>\n+                          </build>\n+                      </profile>\n+                  </profiles>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>com.mycompany.app</groupId>\n+                  <artifactId>my-app</artifactId>\n+                  <version>1</version>\n+                  <build>\n+                      <plugins>\n+                          <plugin>\n+                              <groupId>io.quarkus</groupId>\n+                              <artifactId>quarkus-extension-maven-plugin</artifactId>\n+                              <version>3.0.0.Beta1</version>\n+                          </plugin>\n+                      </plugins>\n+                  </build>\n+                  <profiles>\n+                      <profile>\n+                          <id>profile</id>\n+                          <build>\n+                              <plugins>\n+                                  <plugin>\n+                                      <groupId>io.quarkus</groupId>\n+                                      <artifactId>quarkus-extension-maven-plugin</artifactId>\n+                                      <version>3.0.0.Beta1</version>\n+                                  </plugin>\n+                              </plugins>\n+                          </build>\n+                      </profile>\n+                  </profiles>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @DocumentExample\n+    @Test\n+    void changePluginGroupIdAndArtifactIdDeprecatedNewArtifact() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePluginGroupIdAndArtifactId(\n+            \"io.quarkus\",\n+            \"quarkus-bootstrap-maven-plugin\",\n+            null,\n+            null,\n             \"quarkus-extension-maven-plugin\"\n           )),\n           pomXml(\n@@ -107,7 +186,8 @@ void changePluginGroupIdAndArtifactIdNoChange() {\n             \"io.quarkus\",\n             \"quarkus-bootstrap-maven-plugin\",\n             null,\n-            \"quarkus-extension-maven-plugin\"\n+            \"quarkus-extension-maven-plugin\",\n+            null\n           )),\n           pomXml(\n             \"\"\"\n@@ -152,7 +232,8 @@ void changeManagedPluginGroupIdAndArtifactId() {\n             \"io.quarkus\",\n             \"quarkus-bootstrap-maven-plugin\",\n             null,\n-            \"quarkus-extension-maven-plugin\"\n+            \"quarkus-extension-maven-plugin\",\n+            null\n           )),\n           pomXml(\n             \"\"\"\n@@ -262,7 +343,8 @@ void changeManagedPluginGroupIdAndArtifactIdNoChange() {\n             \"io.quarkus\",\n             \"quarkus-bootstrap-maven-plugin\",\n             null,\n-            \"quarkus-extension-maven-plugin\"\n+            \"quarkus-extension-maven-plugin\",\n+            null\n           )),\n           pomXml(\n             \"\"\"\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4406",
    "pr_id": 4406,
    "issue_id": 4405,
    "repo": "openrewrite/rewrite",
    "problem_statement": "NoMissingTypes not work if the missingType is return value of method and the method has param\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\n\r\nNoMissingTypes should find files with unknown imports, but it cannot work with this case:\r\n\r\n```java\r\n// this is an unknown import with invalid path\r\nimport java.util.GenClass1;\r\n                  \r\npublic abstract class Foo {\r\n      public abstract GenClass1 m(String a);\r\n}\r\n```\r\n\r\nIf use `RemoveUnusedImports` which uses `NoMissingTypes` as checker, it will wrongly remove the import.\r\n\r\nBut for below case, it will work for doing nothing.\r\n```java\r\n// this is an unknown import with invalid path\r\nimport java.util.GenClass1;\r\n                  \r\npublic abstract class Foo {\r\n      public abstract GenClass1 m();\r\n}\r\n```\r\n\r\nThe only difference is the first one has param (`String a`).\r\n\r\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n- Maven plugin 5.36.0\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\n\r\n`mvn -X -B org.openrewrite.maven:rewrite-maven-plugin:5.36.0:runNoFork`\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\n```java\r\nimport org.junit.jupiter.api.Test;\r\nimport org.openrewrite.java.RemoveUnusedImports;\r\nimport org.openrewrite.test.RecipeSpec;\r\nimport org.openrewrite.test.RewriteTest;\r\nimport org.openrewrite.test.TypeValidation;\r\n\r\nimport static org.openrewrite.java.Assertions.java;\r\n\r\npublic class RemoveUnuseImportsTest implements RewriteTest {\r\n    @Override\r\n    public void defaults(RecipeSpec spec) {\r\n        spec.recipe(new RemoveUnusedImports());\r\n    }\r\n\r\n    // This test will fail, add it will remove all imports which is incorrect\r\n    // The correct behavior is to remove none of the imports because we should not process files with missing types\r\n    @Test\r\n    void testWithGenClass1() {\r\n        // language=java\r\n        rewriteRun(\r\n          spec -> spec.typeValidationOptions(TypeValidation.none()),\r\n          java(\r\n            \"\"\"\r\n                  import java.util.List;\r\n                  import java.util.GenClass1;\r\n                  \r\n                  public abstract class Foo {\r\n                      public abstract GenClass1 m(String a);\r\n                  }\r\n              \"\"\", \"\"\"\r\n                  import java.util.GenClass1;\r\n                  \r\n                  public abstract class Foo {\r\n                      public abstract GenClass1 m(String a);\r\n                  }\r\n              \"\"\")\r\n        );\r\n    }\r\n\r\n    // This test will fail, but it won't remove any import which is expected because we should not process files with missing types\r\n    @Test\r\n    void testWithGenClass2() {\r\n        // language=java\r\n        rewriteRun(\r\n          spec -> spec.typeValidationOptions(TypeValidation.none()),\r\n          java(\r\n            \"\"\"\r\n                  import java.util.List;\r\n                  import java.util.GenClass1;\r\n                  \r\n                  public abstract class Foo {\r\n                      public abstract GenClass1 m();\r\n                  }\r\n              \"\"\", \"\"\"\r\n                  import java.util.GenClass1;\r\n                  \r\n                  public abstract class Foo {\r\n                      public abstract GenClass1 m();\r\n                  }\r\n              \"\"\")\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\nFor both tests, the correct results should be don't remove any imports, because the `RemoveUnusedImports` recipe uses `NoMissingTypes` as checker:\r\n```java\r\n@Override\r\npublic TreeVisitor<?, ExecutionContext> getVisitor() {\r\n    return Preconditions.check(new NoMissingTypes(), new RemoveUnusedImportsVisitor());\r\n}\r\n```\r\n\r\nSo for both test cases, the recipe should skip the test java file because it has missing types (`import java.util.GenClass1`)\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\nFor test case 1, it wrongly removed all imports:\r\n```log\r\norg.opentest4j.AssertionFailedError: [Unexpected result in \"Foo.java\":\r\ndiff --git a/Foo.java b/Foo.java\r\nindex 7acc7c7..4c7b8a8 100644\r\n--- a/Foo.java\r\n+++ b/Foo.java\r\n@@ -1,5 +1,3 @@ \r\n-import java.util.GenClass1;\r\n-\r\n public abstract class Foo {\r\n     public abstract GenClass1 m(String a);\r\n }\r\n\\ No newline at end of file\r\n] \r\nexpected: \r\n  \"import java.util.GenClass1;\r\n  \r\n  public abstract class Foo {\r\n      public abstract GenClass1 m(String a);\r\n  }\"\r\n but was: \r\n  \"public abstract class Foo {\r\n      public abstract GenClass1 m(String a);\r\n  }\"\r\n```\r\n\r\nFor test case 2: it do nothing which is expected\r\n\r\n",
    "issue_word_count": 833,
    "test_files_count": 4,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/JavaParserTypeMappingTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/FindMissingTypesTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/search/FindMissingTypes.java",
      "rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-tck/src/main/java/org/openrewrite/java/JavaParserTypeMappingTest.java",
      "rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/FindMissingTypesTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java"
    ],
    "base_commit": "a98d83d698dda9971c93a0767b7f85d5866f306d",
    "head_commit": "c97f8b6060c8a99d073dc8eb1249a22735a45b25",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4406",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4406",
    "dockerfile": "",
    "pr_merged_at": "2024-08-16T10:11:39.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/search/FindMissingTypes.java b/rewrite-java/src/main/java/org/openrewrite/java/search/FindMissingTypes.java\nindex ee1cd5a163e..10fe01d333c 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/search/FindMissingTypes.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/search/FindMissingTypes.java\n@@ -19,10 +19,7 @@\n import lombok.Getter;\n import org.openrewrite.*;\n import org.openrewrite.java.JavaIsoVisitor;\n-import org.openrewrite.java.tree.J;\n-import org.openrewrite.java.tree.JavaSourceFile;\n-import org.openrewrite.java.tree.JavaType;\n-import org.openrewrite.java.tree.Javadoc;\n+import org.openrewrite.java.tree.*;\n import org.openrewrite.marker.Marker;\n import org.openrewrite.marker.SearchResult;\n \n@@ -173,7 +170,7 @@ public J.MemberReference visitMemberReference(J.MemberReference memberRef, Execu\n \n         @Override\n         public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {\n-            J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);\n+            J.MethodDeclaration md = method;\n             JavaType.Method type = md.getMethodType();\n             if (!isWellFormedType(type, seenTypes)) {\n                 md = SearchResult.found(md, \"MethodDeclaration type is missing or malformed\");\n@@ -185,7 +182,7 @@ public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, Ex\n                 // A different object in one implies a type has changed, either in the method signature or deeper in the type tree.\n                 md = SearchResult.found(md, \"MethodDeclaration#name#type is not the same instance as the MethodType of MethodDeclaration.\");\n             }\n-            return md;\n+            return super.visitMethodDeclaration(md, ctx);\n         }\n \n         @Override\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java b/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java\nindex 65d58a07eab..7b02cb3ae3c 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/tree/TypeUtils.java\n@@ -557,7 +557,8 @@ private static boolean isWellFormedType0(JavaType type, Set<JavaType> seen) {\n         }\n         if (type instanceof JavaType.Parameterized) {\n             JavaType.Parameterized parameterized = (JavaType.Parameterized) type;\n-            return isWellFormedType(parameterized.getType(), seen) && parameterized.getTypeParameters().stream().allMatch(it -> isWellFormedType(it, seen));\n+            return isWellFormedType(parameterized.getType(), seen) &&\n+                   parameterized.getTypeParameters().stream().allMatch(it -> isWellFormedType(it, seen));\n         } else if (type instanceof JavaType.Array) {\n             JavaType.Array arr = (JavaType.Array) type;\n             return isWellFormedType(arr.getElemType(), seen);\n@@ -572,9 +573,10 @@ private static boolean isWellFormedType0(JavaType type, Set<JavaType> seen) {\n             return mc.getThrowableTypes().stream().allMatch(it -> isWellFormedType(it, seen));\n         } else if (type instanceof JavaType.Method) {\n             JavaType.Method m = (JavaType.Method) type;\n-            return isWellFormedType(m.getReturnType(), seen) && isWellFormedType(m.getDeclaringType(), seen) && m.getParameterTypes().stream().allMatch(it -> isWellFormedType(it, seen));\n+            return isWellFormedType(m.getReturnType(), seen) &&\n+                   isWellFormedType(m.getDeclaringType(), seen) &&\n+                   m.getParameterTypes().stream().allMatch(it -> isWellFormedType(it, seen));\n         }\n-\n         return true;\n     }\n \n",
    "test_patch": "diff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/JavaParserTypeMappingTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/JavaParserTypeMappingTest.java\nindex 96e9ca87765..031a114214f 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/JavaParserTypeMappingTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/JavaParserTypeMappingTest.java\n@@ -182,12 +182,12 @@ List<Parent> method(List<Parent> values) {\n     @Test\n     void methodInvocationOnUnknownType() {\n         rewriteRun(\n-          spec -> spec.typeValidationOptions(TypeValidation.builder().identifiers(false).build()),\n+          spec -> spec.typeValidationOptions(TypeValidation.builder().identifiers(false).methodDeclarations(false).build()),\n           java(\n             \"\"\"\n               import java.util.ArrayList;\n               // do not import List to create an UnknownType\n-                          \n+\n               class Test {\n                   class Base {\n                       private int foo;\n\ndiff --git a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java\nindex 940a84aa208..b484c7a3cc8 100644\n--- a/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java\n+++ b/rewrite-java-tck/src/main/java/org/openrewrite/java/tree/TypeUtilsTest.java\n@@ -16,6 +16,7 @@\n package org.openrewrite.java.tree;\n \n import org.junit.jupiter.api.Test;\n+import org.openrewrite.ExecutionContext;\n import org.openrewrite.InMemoryExecutionContext;\n import org.openrewrite.Issue;\n import org.openrewrite.java.JavaIsoVisitor;\n@@ -27,6 +28,7 @@\n import static java.util.Collections.singletonList;\n import static org.assertj.core.api.Assertions.assertThat;\n import static org.openrewrite.java.Assertions.java;\n+import static org.openrewrite.test.RewriteTest.toRecipe;\n \n @SuppressWarnings(\"ConstantConditions\")\n class TypeUtilsTest implements RewriteTest {\n@@ -114,7 +116,7 @@ void isOverrideParameterizedInterface() {\n           java(\n             \"\"\"\n               import java.util.Comparator;\n-                            \n+\n               class TestComparator implements Comparator<String> {\n                   @Override public int compare(String o1, String o2) {\n                       return 0;\n@@ -162,7 +164,7 @@ interface Interface <T, Y> {\n             \"\"\"\n               class Clazz implements Interface<Integer, String> {\n                   void foo(Integer t, String y) { }\n-                  \n+\n                   @Override\n                   void foo(String y, Integer t) { }\n               }\n@@ -305,7 +307,7 @@ void isAssignableToGenericTypeVariable() {\n             \"\"\"\n               import java.util.Map;\n               import java.util.function.Supplier;\n-                            \n+\n               class Test {\n                   <K, V> void m(Supplier<? extends Map<K, ? extends V>> map) {\n                   }\n@@ -337,7 +339,7 @@ void isAssignableFromIntersection() {\n           java(\n             \"\"\"\n               import java.io.Serializable;\n-                            \n+\n               class Test {\n                   Object o1 = (Serializable & Runnable) null;\n               }\n@@ -372,4 +374,34 @@ public J.VariableDeclarations.NamedVariable visitVariable(J.VariableDeclarations\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4405\")\n+    void isWellFormedType() {\n+        rewriteRun(\n+          spec -> spec.recipe(toRecipe(() -> new JavaIsoVisitor<>() {\n+              @Override\n+              public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {\n+                  assertThat(cu.getTypesInUse().getTypesInUse()).allMatch(TypeUtils::isWellFormedType);\n+                  return cu;\n+              }\n+          })),\n+          java(\n+            \"\"\"\n+              import java.io.Serializable;\n+\n+              class Test {\n+                  static <T extends Serializable &\n+                          Comparable<T>> T method0() {\n+                      return null;\n+                  }\n+\n+                  static <T extends Serializable> T method1() {\n+                      return null;\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/FindMissingTypesTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/FindMissingTypesTest.java\nindex ba401d24714..36bc57e7f9e 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/FindMissingTypesTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/FindMissingTypesTest.java\n@@ -17,6 +17,7 @@\n \n import org.junit.jupiter.api.Test;\n import org.openrewrite.DocumentExample;\n+import org.openrewrite.Issue;\n import org.openrewrite.java.search.FindMissingTypes;\n import org.openrewrite.test.RecipeSpec;\n import org.openrewrite.test.RewriteTest;\n@@ -41,7 +42,7 @@ void missingAnnotationType() {\n           java(\n             \"\"\"\n               import org.junit.Test;\n-              \n+\n               class ATest {\n                   @Test\n                   void foo() {}\n@@ -49,7 +50,7 @@ void foo() {}\n               \"\"\",\n             \"\"\"\n               import org.junit.Test;\n-              \n+\n               class ATest {\n                   @/*~~(Identifier type is missing or malformed)~~>*/Test\n                   void foo() {}\n@@ -109,14 +110,14 @@ void methodReference() {\n           java(\n             \"\"\"\n               import java.util.function.Consumer;\n-              \n+\n               class A {\n                   Consumer<String> r = System.out::printlns;\n               }\n               \"\"\",\n             \"\"\"\n               import java.util.function.Consumer;\n-              \n+\n               class A {\n                   Consumer<String> r = /*~~(MemberReference type is missing or malformed)~~>*/System.out::printlns;\n               }\n@@ -131,7 +132,7 @@ void newClass() {\n           java(\n             \"\"\"\n               import some.org.Unknown;\n-                            \n+\n               class A {\n                   {\n                       Object o = new Unknown();\n@@ -140,7 +141,7 @@ class A {\n               \"\"\",\n             \"\"\"\n               import some.org.Unknown;\n-                            \n+\n               class A {\n                   {\n                       Object o = /*~~(NewClass type is missing or malformed)~~>*/new Unknown();\n@@ -150,4 +151,44 @@ class A {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4405\")\n+    @Test\n+    void missingMethodReturnTypeNoMethodArguments() {\n+        rewriteRun(\n+          spec -> spec.typeValidationOptions(TypeValidation.none()),\n+          java(\n+            \"\"\"\n+              import java.util.GenClass1;\n+\n+              abstract class Foo1 {\n+                  public abstract GenClass1 noArg();\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import java.util.GenClass1;\n+\n+              abstract class Foo1 {\n+                  /*~~(MethodDeclaration type is missing or malformed)~~>*/public abstract GenClass1 noArg();\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import java.util.GenClass1;\n+\n+              abstract class Foo2 {\n+                  public abstract GenClass1 withArg(String a);\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import java.util.GenClass1;\n+\n+              abstract class Foo2 {\n+                  /*~~(MethodDeclaration type is missing or malformed)~~>*/public abstract GenClass1 withArg(String a);\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java\nindex 21eebf2a5ea..a23297e0cb4 100755\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java\n@@ -22,6 +22,7 @@\n import org.openrewrite.style.NamedStyles;\n import org.openrewrite.test.RecipeSpec;\n import org.openrewrite.test.RewriteTest;\n+import org.openrewrite.test.TypeValidation;\n \n import static java.util.Collections.emptySet;\n import static java.util.Collections.singletonList;\n@@ -124,7 +125,7 @@ void usedInJavadocWithThrows() {\n           java(\n             \"\"\"\n               import java.time.DateTimeException;\n-                            \n+\n               class A {\n                   /**\n                    * @throws DateTimeException when ...\n@@ -143,7 +144,7 @@ void usedInJavadoc() {\n             \"\"\"\n               import java.util.List;\n               import java.util.Collection;\n-              \n+\n               /** {@link List} */\n               class A {\n                   /** {@link Collection} */\n@@ -188,7 +189,7 @@ void leaveImportIfAnnotationOnEnum() {\n           java(\n             \"\"\"\n               package com.google.gson.annotations;\n-              \n+\n               import java.lang.annotation.Documented;\n               import java.lang.annotation.ElementType;\n               import java.lang.annotation.Retention;\n@@ -206,7 +207,7 @@ void leaveImportIfAnnotationOnEnum() {\n           java(\n             \"\"\"\n               import com.google.gson.annotations.SerializedName;\n-              \n+\n               public enum PKIState {\n                   @SerializedName(\"active\") ACTIVE,\n                   @SerializedName(\"dismissed\") DISMISSED\n@@ -223,7 +224,7 @@ void leaveImportForStaticImportEnumInAnnotation() {\n           java(\n             \"\"\"\n               package org.openrewrite.test;\n-              \n+\n               public @interface YesOrNo {\n                   Status status();\n                   enum Status {\n@@ -235,9 +236,9 @@ enum Status {\n           java(\n             \"\"\"\n               package org.openrewrite.test;\n-              \n+\n               import static org.openrewrite.test.YesOrNo.Status.YES;\n-              \n+\n               @YesOrNo(status = YES)\n               public class Foo {}\n               \"\"\"\n@@ -289,14 +290,14 @@ void replaceStarImportWithNamedImportIfOnlyOneReferencedTypeRemains() {\n           java(\n             \"\"\"\n               import java.util.*;\n-              \n+\n               class A {\n                   Collection<Integer> c;\n               }\n               \"\"\",\n             \"\"\"\n               import java.util.Collection;\n-              \n+\n               class A {\n                   Collection<Integer> c;\n               }\n@@ -386,10 +387,10 @@ void removeStaticImportIfNotReferenced() {\n           java(\n             \"\"\"\n               import java.time.DayOfWeek;\n-              \n+\n               import static java.time.DayOfWeek.MONDAY;\n               import static java.time.DayOfWeek.TUESDAY;\n-              \n+\n               class WorkWeek {\n                   DayOfWeek shortWeekStarts(){\n                       return TUESDAY;\n@@ -398,9 +399,9 @@ DayOfWeek shortWeekStarts(){\n               \"\"\",\n             \"\"\"\n               import java.time.DayOfWeek;\n-              \n+\n               import static java.time.DayOfWeek.TUESDAY;\n-              \n+\n               class WorkWeek {\n                   DayOfWeek shortWeekStarts(){\n                       return TUESDAY;\n@@ -419,14 +420,14 @@ void leaveNamedStaticImportIfReferenceStillExists() {\n             \"\"\"\n               import static java.util.Collections.emptyList;\n               import static java.util.Collections.emptySet;\n-              \n+\n               class A {\n                  Object o = emptyList();\n               }\n               \"\"\",\n             \"\"\"\n               import static java.util.Collections.emptyList;\n-              \n+\n               class A {\n                  Object o = emptyList();\n               }\n@@ -460,14 +461,14 @@ public class C {\n               import static foo.B.STRING;\n               import static foo.B.STRING2;\n               import static foo.C.*;\n-              \n+\n               public class A {\n                   String a = STRING;\n               }\n               \"\"\",\n             \"\"\"\n               import static foo.B.STRING;\n-              \n+\n               public class A {\n                   String a = STRING;\n               }\n@@ -493,7 +494,7 @@ void removePackageInfoImports() {\n               @Foo\n               @Bar\n               package foo.bar.baz;\n-              \n+\n               import foo.Bar;\n               import foo.Foo;\n               import foo.FooAnnotation;\n@@ -502,7 +503,7 @@ void removePackageInfoImports() {\n               @Foo\n               @Bar\n               package foo.bar.baz;\n-              \n+\n               import foo.Bar;\n               import foo.Foo;\n               \"\"\"\n@@ -526,14 +527,14 @@ void removePackageInfoStarImports() {\n               @Foo\n               @Bar\n               package foo.bar.baz;\n-              \n+\n               import foo.*;\n               \"\"\",\n             \"\"\"\n               @Foo\n               @Bar\n               package foo.bar.baz;\n-              \n+\n               import foo.Bar;\n               import foo.Foo;\n               \"\"\"\n@@ -584,7 +585,7 @@ public class A {\n               \"\"\",\n             \"\"\"\n               package com.example.foo;\n-              \n+\n               public class A {\n               }\n               \"\"\"\n@@ -599,10 +600,10 @@ void doesNotAffectClassBodyFormatting() {\n           java(\n             \"\"\"\n               package com.example.foo;\n-              \n+\n               import java.util.List;\n               import java.util.ArrayList;\n-              \n+\n               public class A {\n               // Intentionally misaligned to ensure formatting is not overzealous\n               ArrayList<String> foo = new ArrayList<>();\n@@ -610,9 +611,9 @@ public class A {\n               \"\"\",\n             \"\"\"\n               package com.example.foo;\n-              \n+\n               import java.util.ArrayList;\n-              \n+\n               public class A {\n               // Intentionally misaligned to ensure formatting is not overzealous\n               ArrayList<String> foo = new ArrayList<>();\n@@ -672,9 +673,9 @@ public static void fooMethod() {}\n           java(\n             \"\"\"\n               package foo.test;\n-              \n+\n               import static org.openrewrite.Foo.*;\n-              \n+\n               public class Test {\n                   int var = FOO_CONSTANT;\n                   private void method() {\n@@ -707,9 +708,9 @@ public static void fooMethod() {}\n           java(\n             \"\"\"\n               package foo.test;\n-              \n+\n               import static org.openrewrite.Foo.*;\n-              \n+\n               public class Test {\n                   int var = FOO_CONSTANT;\n                   private void method() {\n@@ -719,10 +720,10 @@ private void method() {\n               \"\"\",\n             \"\"\"\n               package foo.test;\n-              \n+\n               import static org.openrewrite.Foo.FOO_CONSTANT;\n               import static org.openrewrite.Foo.Bar;\n-              \n+\n               public class Test {\n                   int var = FOO_CONSTANT;\n                   private void method() {\n@@ -754,7 +755,7 @@ void doNotUnfoldPackage() {\n           java(\n             \"\"\"\n               import java.util.*;\n-              \n+\n               import static java.util.Collections.*;\n \n               class Test {\n@@ -785,7 +786,7 @@ void unfoldSubpackage() {\n           java(\n             \"\"\"\n               import java.util.concurrent.*;\n-              \n+\n               import static java.util.Collections.*;\n \n               class Test {\n@@ -795,9 +796,9 @@ class Test {\n               \"\"\",\n             \"\"\"\n               import java.util.concurrent.ConcurrentHashMap;\n-              \n+\n               import static java.util.Collections.emptyMap;\n-              \n+\n               class Test {\n                   Object o = emptyMap();\n                   ConcurrentHashMap<String, String> m;\n@@ -827,9 +828,9 @@ void doNotUnfoldSubpackage() {\n           java(\n             \"\"\"\n               import java.util.concurrent.*;\n-              \n+\n               import static java.util.Collections.*;\n-              \n+\n               class Test {\n                   ConcurrentHashMap<String, String> m = new ConcurrentHashMap<>(emptyMap());\n               }\n@@ -845,7 +846,7 @@ void removeImportsForSamePackage() {\n           java(\n             \"\"\"\n               package com.google.gson.annotations;\n-              \n+\n               import java.lang.annotation.Documented;\n               import java.lang.annotation.ElementType;\n               import java.lang.annotation.Retention;\n@@ -865,7 +866,7 @@ void removeImportsForSamePackage() {\n               package com.google.gson.annotations;\n \n               import com.google.gson.annotations.SerializedName;\n-              \n+\n               public enum PKIState {\n                   @SerializedName(\"active\") ACTIVE,\n                   @SerializedName(\"dismissed\") DISMISSED\n@@ -873,7 +874,7 @@ public enum PKIState {\n               \"\"\",\n             \"\"\"\n               package com.google.gson.annotations;\n-              \n+\n               public enum PKIState {\n                   @SerializedName(\"active\") ACTIVE,\n                   @SerializedName(\"dismissed\") DISMISSED\n@@ -903,7 +904,7 @@ public class a {\n \n               import static com.source.a.SHORT1;\n               import static com.source.a.SHORT2;\n-              \n+\n               class Test {\n                   short uniqueCount = SHORT1;\n               }\n@@ -912,7 +913,7 @@ class Test {\n               package com.test;\n \n               import static com.source.a.SHORT1;\n-              \n+\n               class Test {\n                   short uniqueCount = SHORT1;\n               }\n@@ -941,7 +942,7 @@ public class A {\n \n               import static com.Source.$.A.SHORT1;\n               import static com.Source.$.A.SHORT2;\n-              \n+\n               class Test {\n                   short uniqueCount = SHORT1;\n               }\n@@ -950,7 +951,7 @@ class Test {\n               package com.test;\n \n               import static com.Source.$.A.SHORT1;\n-              \n+\n               class Test {\n                   short uniqueCount = SHORT1;\n               }\n@@ -966,7 +967,7 @@ void correctlyRemoveImportsFromInternalClasses() {\n           java(\n             \"\"\"\n               package com.Source.A;\n-              \n+\n               public class B {\n                 public enum Enums {\n                     B1, B2\n@@ -985,7 +986,7 @@ public static void helloWorld() {\n               import static com.Source.A.B.Enums.B1;\n               import static com.Source.A.B.Enums.B2;\n               import static com.Source.A.B.helloWorld;\n-              \n+\n               class Test {\n                   public static void main(String[] args) {\n                     var uniqueCount = B1;\n@@ -998,7 +999,7 @@ public static void main(String[] args) {\n \n               import static com.Source.A.B.Enums.B1;\n               import static com.Source.A.B.helloWorld;\n-              \n+\n               class Test {\n                   public static void main(String[] args) {\n                     var uniqueCount = B1;\n@@ -1017,12 +1018,12 @@ void correctlyRemoveImportsFromNestedInternalClasses() {\n           java(\n             \"\"\"\n               package com.Source.A;\n-              \n+\n               public class B {\n                 public enum Enums {\n                     B1, B2\n                 }\n-                \n+\n                 public static class C {\n                     public enum Enums {\n                         C1, C2\n@@ -1044,7 +1045,7 @@ public static void helloWorld() {\n               import static com.Source.A.B.C.Enums.C1;\n               import static com.Source.A.B.C.Enums.C2;\n               import static com.Source.A.B.helloWorld;\n-              \n+\n               class Test {\n                   public static void main(String[] args) {\n                     var uniqueCount = B1;\n@@ -1059,7 +1060,7 @@ public static void main(String[] args) {\n               import static com.Source.A.B.Enums.B1;\n               import static com.Source.A.B.C.Enums.C1;\n               import static com.Source.A.B.helloWorld;\n-              \n+\n               class Test {\n                   public static void main(String[] args) {\n                     var uniqueCount = B1;\n@@ -1082,7 +1083,7 @@ void doesNotRemoveReferencedClassesBeingUsedAsParameters() {\n \n               public class A {\n                   public static final short SHORT1 = (short)1;\n-                  \n+\n                   public short getShort1() {\n                     return SHORT1;\n                   }\n@@ -1094,7 +1095,7 @@ public short getShort1() {\n               package com.test;\n \n               import com.Source.mine.A;\n-              \n+\n               class Test {\n                   void f(A classA) {\n                     classA.getShort1();\n@@ -1641,7 +1642,7 @@ void conflictWithRecord() {\n           spec -> spec.parser(JavaParser.fromJavaVersion().dependsOn(\n             \"\"\"\n               package pzrep.p1;\n-                \n+\n               public class Record {\n                 public A theOne() { return new A(); }\n                 public B0 theOther0() { return new B0(); }\n@@ -1724,28 +1725,28 @@ public void f() {}\n               \"\"\"\n           )),\n           java(\n-                \"\"\"\n-            package pzrep.p2;\n-\n-            import pzrep.p1.Record;\n-            import pzrep.p1.*;\n-\n-            class Client2 {\n-                void f(Record r) {\n-                  A a = r.theOne();\n-                  B0 b0 = r.theOther0();\n-                  B1 b1 = r.theOther1();\n-                  B2 b2 = r.theOther2();\n-                  B3 b3 = r.theOther3();\n-                  B4 b4 = r.theOther4();\n-                  B5 b5 = r.theOther5();\n-                  B6 b6 = r.theOther6();\n-                  B7 b7 = r.theOther7();\n-                  B8 b8 = r.theOther8();\n-                  B9 b9 = r.theOther9();\n-                }\n-            }\n-            \"\"\"));\n+            \"\"\"\n+              package pzrep.p2;\n+\n+              import pzrep.p1.Record;\n+              import pzrep.p1.*;\n+\n+              class Client2 {\n+                  void f(Record r) {\n+                    A a = r.theOne();\n+                    B0 b0 = r.theOther0();\n+                    B1 b1 = r.theOther1();\n+                    B2 b2 = r.theOther2();\n+                    B3 b3 = r.theOther3();\n+                    B4 b4 = r.theOther4();\n+                    B5 b5 = r.theOther5();\n+                    B6 b6 = r.theOther6();\n+                    B7 b7 = r.theOther7();\n+                    B8 b8 = r.theOther8();\n+                    B9 b9 = r.theOther9();\n+                  }\n+              }\n+              \"\"\"));\n     }\n \n     @Test\n@@ -1769,4 +1770,48 @@ public LocalDateTime toLocalDateTime(XMLGregorianCalendar cal) {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4405\")\n+    @Test\n+    void missingTypeReturnValueOfMethodWithArguments() {\n+        rewriteRun(\n+          spec -> spec.typeValidationOptions(TypeValidation.none()),\n+          // method with argument should still remove unused import\n+          java(\n+            \"\"\"\n+              import java.util.List;\n+\n+              public abstract class Foo1 {\n+                  public abstract String m(String a);\n+              }\n+              \"\"\",\n+            \"\"\"\n+              public abstract class Foo1 {\n+                  public abstract String m(String a);\n+              }\n+              \"\"\"\n+          ),\n+          // case with missing type should not remove the import\n+          java(\n+            \"\"\"\n+              import java.util.List;\n+              import java.util.GenClass1;\n+\n+              public abstract class Foo3 {\n+                  public abstract GenClass1 m();\n+              }\n+              \"\"\"\n+          ),\n+          // case with missing type and method argument should not remove the import\n+          java(\n+            \"\"\"\n+              import java.util.GenClass1;\n+\n+              public abstract class Foo2 {\n+                  public abstract GenClass1 m(String a);\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4383",
    "pr_id": 4383,
    "issue_id": 4382,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ChangeStaticFieldToMethod has issue when changing nested code\nI'll submit a test for this, but we uncovered the following situation when using the apache commons-collection 3->4 upgrade recipe.\r\n\r\nWe expect that `ChangeStaticFieldToMethod` will be able to change this:\r\n\r\n```\r\nimport java.util.Collections;\r\nclass Foo {\r\n    final Object o = java.util.Arrays(Collections.EMPTY_LIST);\r\n}\r\n```\r\n\r\ninto\r\n\r\n```\r\nimport java.util.Lists;\r\nclass Foo {\r\n    final Object o = java.util.Arrays(Lists.of());\r\n}\r\n```\r\n\r\nHowever, when we use the recipe (via that composite recipe), we get a ClassCastException [here](https://github.com/openrewrite/rewrite/blob/2b3291e948cba4e4b99124b4c94c402a8bd11f6a/rewrite-java/src/main/java/org/openrewrite/java/ChangeStaticFieldToMethod.java#L119):\r\n\r\n```\r\nCaused by: org.openrewrite.internal.RecipeRunException: java.lang.ClassCastException: class org.openrewrite.java.tree.J$NewArray cannot be cast to class org.openrewrite.java.tree.J$Block (org.openrewrite.java.tree.J$NewArray and org.openrewrite.java.tree.J$Block are in unnamed module of loader 'app')\r\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:287)\r\n\tat org.openrewrite.TreeVisitor.visitAndCast(TreeVisitor.java:317)\r\n[snip]\r\nCaused by: java.lang.ClassCastException: class org.openrewrite.java.tree.J$NewArray cannot be cast to class org.openrewrite.java.tree.J$Block (org.openrewrite.java.tree.J$NewArray and org.openrewrite.java.tree.J$Block are in unnamed module of loader 'app')\r\n\tat org.openrewrite.java.ChangeStaticFieldToMethod$1.useNewMethod(ChangeStaticFieldToMethod.java:119)\r\n\tat org.openrewrite.java.ChangeStaticFieldToMethod$1.visitFieldAccess(ChangeStaticFieldToMethod.java:95)\r\n\tat org.openrewrite.java.ChangeStaticFieldToMethod$1.visitFieldAccess(ChangeStaticFieldToMethod.java:80)\r\n\tat org.openrewrite.java.tree.J$FieldAccess.acceptJava(J.java:1943)\r\n\tat org.openrewrite.java.tree.J.accept(J.java:59)\r\n\tat org.openrewrite.TreeVisitor.visit(TreeVisitor.java:245)\r\n```\r\n\r\n## What version of OpenRewrite are you using?\r\n\r\nrewrite's main branch\r\n\r\n## How are you running OpenRewrite?\r\n\r\nIDE - running new test in `ChangeStaticFieldToMethodTest`.  I'll push a draft PR soon.",
    "issue_word_count": 297,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangeStaticFieldToMethodTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/marker/JavaSourceSetTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/ChangeStaticFieldToMethod.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangeStaticFieldToMethodTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/marker/JavaSourceSetTest.java"
    ],
    "base_commit": "e73cb6a5e088d3df301f4cb6515e3c85c9bcd259",
    "head_commit": "b834c0c7408b56a3373f73780207a1e792de17c4",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4383",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4383",
    "dockerfile": "",
    "pr_merged_at": "2024-08-11T10:07:00.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/ChangeStaticFieldToMethod.java b/rewrite-java/src/main/java/org/openrewrite/java/ChangeStaticFieldToMethod.java\nindex be4578b7445..9152f8a45f6 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/ChangeStaticFieldToMethod.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/ChangeStaticFieldToMethod.java\n@@ -116,10 +116,17 @@ private J useNewMethod(TypeTree tree) {\n \n                 Cursor statementCursor = getCursor().dropParentUntil(Statement.class::isInstance);\n                 Statement statement = statementCursor.getValue();\n-                J.Block block = makeNewMethod(newClass).apply(statementCursor, statement.getCoordinates().replace());\n-                J.MethodInvocation method = block.getStatements().get(0).withPrefix(tree.getPrefix());\n-\n-                if (method.getMethodType() == null) {\n+                J applied = makeNewMethod(newClass).apply(statementCursor, statement.getCoordinates().replace());\n+\n+                J.MethodInvocation method = null;\n+                if (applied instanceof J.Block) {\n+                    J.Block block = (J.Block) applied;\n+                    method = block.getStatements().get(0).withPrefix(tree.getPrefix());\n+                } else if (applied instanceof J.NewArray) {\n+                    J.NewArray newArray = (J.NewArray) applied;\n+                    method = (J.MethodInvocation) newArray.getInitializer().get(0);\n+                }\n+                if (method == null || method.getMethodType() == null) {\n                     throw new IllegalArgumentException(\"Error while changing a static field to a method. The generated template using a the new class [\"\n                                                        + newClass + \"] and the method [\" + newMethodName + \"] resulted in a null method type.\");\n                 }\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeStaticFieldToMethodTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeStaticFieldToMethodTest.java\nindex 617379a4942..8559c3583e7 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeStaticFieldToMethodTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeStaticFieldToMethodTest.java\n@@ -165,6 +165,34 @@ class A {\n         );\n     }\n \n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4382\")\n+    void migratesNestedFieldInitializer() {\n+        rewriteRun(\n+          java(acmeLists),\n+          java(\n+            \"\"\"\n+              import java.util.Collections;\n+\n+              class Foo {\n+                  void bar() {\n+                      final Object collection = java.util.Arrays.asList(Collections.EMPTY_LIST);\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import com.acme.Lists;\n+\n+              class Foo {\n+                  void bar() {\n+                      final Object collection = java.util.Arrays.asList(Lists.of());\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void ignoresUnrelatedFields() {\n         rewriteRun(\n@@ -237,7 +265,7 @@ void leavesOwnerAlone() {\n           java(\n             \"\"\"\n               package com.example;\n-                            \n+\n               class Test {\n                   public static Object EXAMPLE = null;\n               }\n@@ -276,7 +304,7 @@ public class HttpResponseStatus {\n                   private HttpResponseStatus(int code) {\n                       this.code = code;\n                   }\n-                  \n+\n                   String codeAsText() {\n                       return String.valueOf(code);\n                   }\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/marker/JavaSourceSetTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/marker/JavaSourceSetTest.java\nindex 53befc08176..f9b4e76f0ec 100755\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/marker/JavaSourceSetTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/marker/JavaSourceSetTest.java\n@@ -48,7 +48,7 @@ void shadedJar() {\n           .filter(o -> o.getFullyQualifiedName().startsWith(\"org.apache.hadoop.hbase.CacheEvictionStats\"))\n           .findAny();\n         assertThat(shaded).isPresent();\n-        assertThat(jss.getTypeToGav().get(shaded.get())).isEqualTo(\"org.apache.hbase:hbase-shaded-client:2.4.11\");\n+        assertThat(jss.getGavToTypes().get(\"org.apache.hbase:hbase-shaded-client:2.4.11\")).contains(shaded.get());\n     }\n \n     @Test\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4380",
    "pr_id": 4380,
    "issue_id": 4054,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Support parsing `module-info.java`\nI am using https://app.moderne.io/ (and also locally)\r\n\r\nGo to https://app.moderne.io/, select \"JabRef\" and run `org.openrewrite.java.logging.slf4j.ParameterizedLogging`\r\n\r\nThere are 0 results reported:\r\n\r\n![image](https://github.com/openrewrite/rewrite-logging-frameworks/assets/1366654/e4380db0-8a83-4ebb-bfa5-67f1f0b9078b)\r\n\r\nHowever, there should be more than 1:\r\n\r\n![image](https://github.com/openrewrite/rewrite-logging-frameworks/assets/1366654/94393cbb-e54a-4f5f-a0d7-c8083150c2e5)\r\n\r\nThat source code is also available at https://github.com/jabref/jabref/.\r\n",
    "issue_word_count": 85,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/JavaParser.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java"
    ],
    "base_commit": "c3bddfe8fe9e0225ddd09c990c76c9251bb481e9",
    "head_commit": "b21893fc47a7b96408d3edba1d68ff9bc6689f2c",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4380",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4380",
    "dockerfile": "",
    "pr_merged_at": "2024-08-04T17:52:05.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/JavaParser.java b/rewrite-java/src/main/java/org/openrewrite/java/JavaParser.java\nindex e912c6b12b6..b3df6b61cd7 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/JavaParser.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/JavaParser.java\n@@ -273,7 +273,7 @@ default Stream<SourceFile> parse(@Language(\"java\") String... sources) {\n \n     @Override\n     default boolean accept(Path path) {\n-        return path.toString().endsWith(\".java\");\n+        return path.toString().endsWith(\".java\") && !path.endsWith(\"module-info.java\");\n     }\n \n     /**\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\nindex b74cd479f67..c5b6fda983a 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/JavaParserTest.java\n@@ -35,6 +35,7 @@\n import java.util.stream.Stream;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.openrewrite.java.Assertions.java;\n \n /**\n@@ -157,4 +158,11 @@ void shouldResolvePathUsingPublicClasses(@Language(\"java\") String source) {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/1895\")\n+    void moduleInfo(){\n+        // Ignored until properly handled: https://github.com/openrewrite/rewrite/issues/4054#issuecomment-2267605739\n+        assertFalse(JavaParser.fromJavaVersion().build().accept(Path.of(\"src/main/java/foo/module-info.java\")));\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4365",
    "pr_id": 4365,
    "issue_id": 2218,
    "repo": "openrewrite/rewrite",
    "problem_statement": "MergeYamlVisitor - inline comments not taken into account\nHi,\r\n\r\nthe `MergeYamlVisitor` does not take inline comments into account at merging YAMLs. See the test:\r\n\r\n```kotlin\r\n@Test\r\nfun existingEntryBlockWithComment() = assertChanged(\r\n    recipe = MergeYaml(\r\n        \"$\",\r\n        \"\"\"\r\n            spring:\r\n              application:\r\n                description: a description\r\n        \"\"\".trimIndent(),\r\n        false,\r\n        null\r\n    ),\r\n    before = \"\"\"\r\n        spring:\r\n          application:\r\n            name: main #Some comment\r\n    \"\"\",\r\n    after = \"\"\"\r\n        spring:\r\n          application:\r\n            name: main #Some comment\r\n            description: a description\r\n    \"\"\"\r\n)\r\n```\r\n\r\nThe actual result is:\r\n```yaml\r\nspring:\r\n  application:\r\n    name: main\r\n    description: a description #Some comment\r\n```\r\n\r\nThanks and kind regards\r\nThomas",
    "issue_word_count": 74,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java"
    ],
    "base_commit": "03ec2e476df790410bf6c1a85b42a485a7445889",
    "head_commit": "2bd45eba49717cce2b315f1b0e16947e2e5cb6fb",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4365",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4365",
    "dockerfile": "",
    "pr_merged_at": "2024-07-31T06:37:57.000Z",
    "patch": "",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\nindex 97800f0ff4a..880721bd197 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/MergeYamlTest.java\n@@ -1136,6 +1136,37 @@ void mergeEmptyStructureFollowedByCopyValue() {\n         );\n     }\n \n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/2218\")\n+    @Test\n+    void mergePropertiesWithExistingComments() {\n+        rewriteRun(\n+          spec -> spec.recipe(new\n+              MergeYaml(\n+              \"$\",\n+              //language=yaml\n+              \"\"\"\n+                widget:\n+                  list:\n+                    currentCount: 3\n+                \"\"\",\n+              true, null, null\n+            )\n+          ),\n+          yaml(\n+            \"\"\"\n+              widget:\n+                list:\n+                  itemCount: 5 #number of existing items in the list\n+              \"\"\",\n+            \"\"\"\n+              widget:\n+                list:\n+                  itemCount: 5 #number of existing items in the list\n+                  currentCount: 3\n+              \"\"\"\n+          )\n+\n     @Test\n     void addLiteralStyleBlockAtRoot() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4339",
    "pr_id": 4339,
    "issue_id": 4333,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Gradle UpgradeDependencyVersion omits versionPattern if exact newVersion specified\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\nWhen running _org.openrewrite.gradle.UpgradeDependencyVersion_ specifying both an exact _newVersion_ (e.g. `32.1.1`) and a _versionPattern_ (e.g. `-jre`)\r\nThe selected version does not include the versionPattern (i.e. returns `32.1.1` instead of `32.1.1-jre`)\r\n\r\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\n- OpenRewrite v8.30.0\r\n- Gradle plugin v6.16.4\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\nI am using the Gradle plugin via the IntelliJ IDEA integration (2024.1.4)\r\nPublic repo with example: https://github.com/gideon-sunbit/openrewrite-examples-public\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\n**rewrite.yml**\r\n```yaml\r\n---\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: com.yourorg.UpgradeDependencyVersionExample\r\ndisplayName: Upgrade Gradle dependency versions example\r\nrecipeList:\r\n  - org.openrewrite.gradle.UpgradeDependencyVersion:\r\n      groupId: com.google.guava\r\n      artifactId: guava\r\n      newVersion: 32.1.1\r\n      versionPattern: '-jre'\r\n```\r\n\r\n**build.gradle**\r\n```groovy\r\nplugins {\r\n    id 'java'\r\n}\r\n\r\nrepositories {\r\n    mavenCentral()\r\n}\r\n\r\ndependencies {\r\n    implementation('com.google.guava:guava:29.0-jre')\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\n```groovy\r\nplugins {\r\n    id 'java'\r\n}\r\n\r\nrepositories {\r\n    mavenCentral()\r\n}\r\n\r\ndependencies {\r\n    implementation('com.google.guava:guava:32.1.1-jre')\r\n}\r\n```\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\n```groovy\r\nplugins {\r\n    id 'java'\r\n}\r\n\r\nrepositories {\r\n    mavenCentral()\r\n}\r\n\r\ndependencies {\r\n    implementation('com.google.guava:guava:32.1.1')\r\n}\r\n```\r\n\r\n## Execution log:\r\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\r\n```\r\n21:55:23: Executing 'rewriteRun'...\r\n\r\nDownload https://plugins.gradle.org/m2/org/openrewrite/plugin/maven-metadata.xml, took 1 s 55 ms\r\nDownload https://plugins.gradle.org/m2/org/openrewrite/plugin/6.16.4/plugin-6.16.4.pom, took 1 s 298 ms\r\nDownload https://plugins.gradle.org/m2/org/openrewrite/plugin/6.16.4/plugin-6.16.4.module, took 869 ms\r\nDownload https://plugins.gradle.org/m2/org/openrewrite/plugin/6.16.4/plugin-6.16.4.jar, took 471 ms\r\n> Task :compileJava\r\n> Task :processResources NO-SOURCE\r\n> Task :classes\r\n> Task :compileTestJava NO-SOURCE\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-java-11/8.30.0/rewrite-java-11-8.30.0.pom, took 317 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-java-21/8.30.0/rewrite-java-21-8.30.0.pom, took 318 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-gradle/8.30.0/rewrite-gradle-8.30.0.pom, took 318 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-kotlin/1.19.0/rewrite-kotlin-1.19.0.pom, took 319 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-groovy/8.30.0/rewrite-groovy-8.30.0.pom, took 318 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-java-8/8.30.0/rewrite-java-8-8.30.0.pom, took 319 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-json/8.30.0/rewrite-json-8.30.0.pom, took 320 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-hcl/8.30.0/rewrite-hcl-8.30.0.pom, took 320 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-java/8.30.0/rewrite-java-8.30.0.pom, took 320 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-properties/8.30.0/rewrite-properties-8.30.0.pom, took 319 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-protobuf/8.30.0/rewrite-protobuf-8.30.0.pom, took 318 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-java-17/8.30.0/rewrite-java-17-8.30.0.pom, took 320 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-yaml/8.30.0/rewrite-yaml-8.30.0.pom, took 59 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-xml/8.30.0/rewrite-xml-8.30.0.pom, took 62 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/recipe/rewrite-migrate-java/2.20.0/rewrite-migrate-java-2.20.0.pom, took 62 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/recipe/rewrite-java-dependencies/1.13.0/rewrite-java-dependencies-1.13.0.pom, took 63 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-polyglot/1.12.4/rewrite-polyglot-1.12.4.pom, took 152 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/recipe/rewrite-jenkins/0.8.3/rewrite-jenkins-0.8.3.pom, took 149 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/recipe/rewrite-github-actions/2.7.0/rewrite-github-actions-2.7.0.pom, took 151 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-templating/1.12.0/rewrite-templating-1.12.0.pom, took 151 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-templating/1.12.0/rewrite-templating-1.12.0.module, took 149 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/recipe/rewrite-jenkins/0.8.3/rewrite-jenkins-0.8.3.jar, took 137 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-polyglot/1.12.4/rewrite-polyglot-1.12.4.jar, took 251 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/recipe/rewrite-github-actions/2.7.0/rewrite-github-actions-2.7.0.jar, took 131 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-templating/1.12.0/rewrite-templating-1.12.0.jar, took 203 ms\r\nDownload https://repo.maven.apache.org/maven2/org/openrewrite/rewrite-kotlin/1.19.0/rewrite-kotlin-1.19.0.jar, took 444 ms\r\n> Task :rewriteResolveDependencies\r\n\r\n> Task :rewriteRun\r\nValidating active recipes\r\nScanning sources in project :\r\nUsing active styles []\r\nAll sources parsed, running active recipes: com.yourorg.UpgradeDependencyVersionExample\r\nChanges have been made to openrewrite-examples/build.gradle by:\r\n    com.yourorg.UpgradeDependencyVersionExample\r\n        org.openrewrite.gradle.UpgradeDependencyVersion: {groupId=com.google.guava, artifactId=guava, newVersion=32.1.1, versionPattern=-jre}\r\nPlease review and commit the results.\r\nEstimate time saved: 5m\r\n\r\nBUILD SUCCESSFUL in 12s\r\n3 actionable tasks: 3 executed\r\n21:55:35: Execution finished 'rewriteRun'.\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\nPossibly. I think the issue is with the way _DependencyVersionSelector_ and _VersionComparator_ handle _ExactVersion_.\r\nBut may need some guidance on best way to fix (e.g. just concat the versionPattern to the selectedVersion? or better fix in VersionComparator/DependencyVersionSelector?)",
    "issue_word_count": 1424,
    "test_files_count": 2,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/semver/ExactVersion.java",
      "rewrite-core/src/main/java/org/openrewrite/semver/ExactVersionWithPattern.java",
      "rewrite-core/src/main/java/org/openrewrite/semver/Semver.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java"
    ],
    "base_commit": "14aef405998f4a07a034c7b87deb3d359b3bb0ae",
    "head_commit": "8e336f9c359128b16052eefb059366b47dee16eb",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4339",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4339",
    "dockerfile": "",
    "pr_merged_at": "2024-07-25T13:57:13.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/semver/ExactVersion.java b/rewrite-core/src/main/java/org/openrewrite/semver/ExactVersion.java\nindex 8995bab9a14..804a77fae79 100755\n--- a/rewrite-core/src/main/java/org/openrewrite/semver/ExactVersion.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/semver/ExactVersion.java\n@@ -45,16 +45,16 @@ public static Validated<ExactVersion> build(String pattern) {\n         }\n         String versionOnly;\n         int hyphenIndex = pattern.indexOf('-');\n-        if(hyphenIndex == -1) {\n+        if (hyphenIndex == -1) {\n             versionOnly = pattern;\n         } else {\n             versionOnly = pattern.substring(0, hyphenIndex);\n         }\n-        if(versionOnly.startsWith(\"latest\") ||\n-                versionOnly.contains(\"x\") ||\n-                versionOnly.contains(\"^\") ||\n-                versionOnly.contains(\"~\") ||\n-                versionOnly.contains(\" \")) {\n+        if (versionOnly.startsWith(\"latest\") ||\n+            versionOnly.contains(\"x\") ||\n+            versionOnly.contains(\"^\") ||\n+            versionOnly.contains(\"~\") ||\n+            versionOnly.contains(\" \")) {\n             return Validated.invalid(\"exactVersion\", pattern, \"not an exact version number\");\n         }\n         return Validated.valid(\"exactVersion\", new ExactVersion(pattern));\n\ndiff --git a/rewrite-core/src/main/java/org/openrewrite/semver/ExactVersionWithPattern.java b/rewrite-core/src/main/java/org/openrewrite/semver/ExactVersionWithPattern.java\nnew file mode 100644\nindex 00000000000..0b4bcae3235\n--- /dev/null\n+++ b/rewrite-core/src/main/java/org/openrewrite/semver/ExactVersionWithPattern.java\n@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.semver;\n+\n+import org.openrewrite.Validated;\n+import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.internal.lang.Nullable;\n+\n+public class ExactVersionWithPattern extends LatestRelease {\n+    private final String version;\n+\n+    public ExactVersionWithPattern(String version, String metadataPattern) {\n+        super(metadataPattern);\n+        this.version = version;\n+    }\n+\n+    @Override\n+    public boolean isValid(@Nullable String currentVersion, String version) {\n+        return super.isValid(currentVersion, version) &&\n+               super.compare(currentVersion, version, this.version) == 0;\n+    }\n+\n+    public static Validated<ExactVersionWithPattern> build(String toVersion, @Nullable String metadataPattern) {\n+        if (StringUtils.isBlank(metadataPattern)) {\n+            return Validated.invalid(\"exactVersionWithPattern\", metadataPattern, \"metadataPattern is null or empty\");\n+        }\n+        if (ExactVersion.build(toVersion).isInvalid()) {\n+            return Validated.invalid(\"exactVersionWithPattern\", toVersion, \"not an exact version number\");\n+        }\n+        return Validated.valid(\"exactVersionWithPattern\", new ExactVersionWithPattern(toVersion, metadataPattern));\n+    }\n+}\n\ndiff --git a/rewrite-core/src/main/java/org/openrewrite/semver/Semver.java b/rewrite-core/src/main/java/org/openrewrite/semver/Semver.java\nindex 09a63a0de0d..619c82d2b88 100644\n--- a/rewrite-core/src/main/java/org/openrewrite/semver/Semver.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/semver/Semver.java\n@@ -53,6 +53,7 @@ public static Validated<VersionComparator> validate(String toVersion, @Nullable\n                 .or(TildeRange.build(toVersion, metadataPattern))\n                 .or(CaretRange.build(toVersion, metadataPattern))\n                 .or(SetRange.build(toVersion, metadataPattern))\n+                .or(ExactVersionWithPattern.build(toVersion, metadataPattern))\n                 .or(ExactVersion.build(toVersion))\n         );\n     }\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java\nindex c204d609383..c7aaf02f417 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java\n@@ -922,4 +922,76 @@ void isAcceptable(){\n         sourceFile = PropertiesParser.builder().build().parse(\"guavaVersion=29.0-jre\").findFirst().orElseThrow();\n         assertThat(visitor.isAcceptable(sourceFile, new InMemoryExecutionContext())).isTrue();\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4333\")\n+    void exactVersionWithExactPattern() {\n+        rewriteRun(\n+          spec -> spec.recipe(new UpgradeDependencyVersion(\"com.google.guava\", \"guava\", \"32.1.1\", \"-jre\")),\n+          buildGradle(\n+            \"\"\"\n+              plugins {\n+                id 'java-library'\n+              }\n+              \n+              repositories {\n+                mavenCentral()\n+              }\n+              \n+              dependencies {\n+                implementation('com.google.guava:guava:29.0-jre')\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                id 'java-library'\n+              }\n+              \n+              repositories {\n+                mavenCentral()\n+              }\n+              \n+              dependencies {\n+                implementation('com.google.guava:guava:32.1.1-jre')\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4333\")\n+    void exactVersionWithRegexPattern() {\n+        rewriteRun(\n+          spec -> spec.recipe(new UpgradeDependencyVersion(\"com.google.guava\", \"guava\", \"32.1.1\", \".*droid\")),\n+          buildGradle(\n+            \"\"\"\n+              plugins {\n+                id 'java-library'\n+              }\n+              \n+              repositories {\n+                mavenCentral()\n+              }\n+              \n+              dependencies {\n+                implementation('com.google.guava:guava:29.0-android')\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                id 'java-library'\n+              }\n+              \n+              repositories {\n+                mavenCentral()\n+              }\n+              \n+              dependencies {\n+                implementation('com.google.guava:guava:32.1.1-android')\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java\nindex e01b34844f4..fdb24cd8ccd 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java\n@@ -1833,4 +1833,42 @@ void multipleRetainVersions() {\n             );\n         }\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4333\")\n+    void exactVersionWithPattern() {\n+        rewriteRun(\n+          spec -> spec.recipe(new UpgradeDependencyVersion(\"com.google.guava\", \"guava\", \"29.0\", \"-jre\", null, null)),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>com.google.guava</groupId>\n+                    <artifactId>guava</artifactId>\n+                    <version>25.0-jre</version>\n+                  </dependency>\n+                </dependencies>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>com.google.guava</groupId>\n+                    <artifactId>guava</artifactId>\n+                    <version>29.0-jre</version>\n+                  </dependency>\n+                </dependencies>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4335",
    "pr_id": 4335,
    "issue_id": 4319,
    "repo": "openrewrite/rewrite",
    "problem_statement": "pom.xml in Maven Multi Module project is not changed\n\r\n## What version of OpenRewrite are you using?\r\nrewrite-maven-plugin: 5.35.0\r\nrewrite-migrate-java: 2.19.0\r\n\r\n## How are you running OpenRewrite?\r\n\r\n`mvn rewrite:dryRun`\r\n\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n\r\nCreate a directory `testprj` with a subdirectory `subm`:\r\n\r\n```\r\nmkdir testprj && mkdir testprj/subm\r\n```\r\n\r\nCreate a `pom.xml` in testprj:\r\n```\r\ncat <<'EOF'> testprj/pom.xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.gepardec.openrewrite</groupId>\r\n    <artifactId>testprj</artifactId>\r\n    <!--version>0.1.0-SNAPSHOT</version-->\r\n    <version>${revision}</version>\r\n    <packaging>pom</packaging>\r\n    <properties>\r\n      <revision>0.1.0-SNAPSHOT</revision>\r\n    </properties>\r\n    <modules>\r\n      <module>subm</module>\r\n    </modules>\r\n    <dependencies>\r\n      <dependency>\r\n          <groupId>javax.persistence</groupId>\r\n          <artifactId>javax.persistence-api</artifactId>\r\n          <version>2.2</version>\r\n      </dependency>\r\n    </dependencies>\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.openrewrite.maven</groupId>\r\n                <artifactId>rewrite-maven-plugin</artifactId>\r\n                <version>5.35.0</version>\r\n                <configuration>\r\n                    <activeRecipes>\r\n\t\t\t    <recipe>org.openrewrite.java.migrate.jakarta.JavaxPersistenceToJakartaPersistence</recipe>\r\n                    </activeRecipes>\r\n                </configuration>\r\n                <dependencies>\r\n                    <dependency>\r\n                        <groupId>org.openrewrite.recipe</groupId>\r\n                        <artifactId>rewrite-migrate-java</artifactId>\r\n                        <version>2.19.0</version>\r\n                    </dependency>\r\n                </dependencies>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n</project>\r\nEOF\r\n```\r\n\r\nCreate a `pom.xml` in testprj/subm:\r\n\r\n```\r\ncat <<'EOF'>testprj/subm/pom.xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n  <modelVersion>4.0.0</modelVersion>\r\n  <parent>\r\n    <groupId>com.gepardec.openrewrite</groupId>\r\n    <artifactId>testprj</artifactId>\r\n    <!--version>0.1.0-SNAPSHOT</version-->\r\n    <version>${revision}</version>\r\n    <relativePath>../pom.xml</relativePath>\r\n  </parent>\r\n  <artifactId>subm</artifactId>\r\n  <packaging>pom</packaging>\r\n  <dependencies>\r\n    <dependency>\r\n      <groupId>javax.persistence</groupId>\r\n      <artifactId>javax.persistence-api</artifactId>\r\n      <version>2.2</version>\r\n    </dependency>\r\n  </dependencies>\r\n</project>\r\nEOF\r\n```\r\n\r\nRun OpenRewrite in `testprj`:\r\n\r\n```\r\ncd testprj\r\nmvn rewrite:dryRun\r\n```\r\nThe output is:\r\n```\r\n...\r\n[WARNING] These recipes would make changes to pom.xml:\r\n[WARNING]     org.openrewrite.java.migrate.jakarta.JavaxPersistenceToJakartaPersistence\r\n[WARNING]         org.openrewrite.java.dependencies.ChangeDependency: {oldGroupId=javax.persistence, oldArtifactId=javax.persistence-api, newGroupId=jakarta.persistence, newArtifactId=jakarta.persistence-api, newVersion=latest.release}\r\n...\r\n```\r\n\r\nObserve, that the dependency `javax.persistence-api` would be changed in the `testprj` but not in `testprj/subm`. However, if you change the `version` tags in both POMs to `<version>0.1.0-SNAPSHOT</version>` it works for both projects.\r\n\r\n\r\n## What did you expect to see?\r\nThe Maven setup is the recommendes setup from [Multi Module Setup](https://maven.apache.org/maven-ci-friendly.html#multi-module-setup). Therefore I expect an output like \r\n\r\n```\r\n[WARNING] These recipes would make changes to pom.xml:\r\n[WARNING]     org.openrewrite.java.migrate.jakarta.JavaxPersistenceToJakartaPersistence\r\n[WARNING]         org.openrewrite.java.dependencies.ChangeDependency: {oldGroupId=javax.persistence, oldArtifactId=javax.persistence-api, newGroupId=jakarta.persistence, newArtifactId=jakarta.persistence-api, newVersion=latest.release}\r\n[WARNING] These recipes would make changes to subm/pom.xml:\r\n[WARNING]     org.openrewrite.java.migrate.jakarta.JavaxPersistenceToJakartaPersistence\r\n[WARNING]         org.openrewrite.java.dependencies.ChangeDependency: {oldGroupId=javax.persistence, oldArtifactId=javax.persistence-api, newGroupId=jakarta.persistence, newArtifactId=jakarta.persistence-api, newVersion=latest.release}\r\n\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\nYes\r\n",
    "issue_word_count": 563,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/MavenParser.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java"
    ],
    "base_commit": "a34eacc7c3a736149a48b5732664d35eac92cfa4",
    "head_commit": "ffd6feda9db8b73a85f732c554cd4e1a42f9b5f0",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4335",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4335",
    "dockerfile": "",
    "pr_merged_at": "2024-07-17T16:08:26.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenParser.java b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenParser.java\nindex a5562c7df97..9839dc8a82a 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenParser.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenParser.java\n@@ -152,7 +152,7 @@ public Stream<SourceFile> parseInputs(Iterable<Input> sources, @Nullable Path re\n                 if (parent != null &&\n                     resolutionResult.getPom().getGroupId().equals(resolutionResult.getPom().getValue(parent.getGroupId())) &&\n                     resolutionResult.getPom().getArtifactId().equals(resolutionResult.getPom().getValue(parent.getArtifactId())) &&\n-                    resolutionResult.getPom().getVersion().equals(resolutionResult.getPom().getValue(parent.getVersion()))) {\n+                    Objects.equals(resolutionResult.getPom().getValue(resolutionResult.getPom().getVersion()), resolutionResult.getPom().getValue(parent.getVersion()))) {\n                     moduleResolutionResult.unsafeSetParent(resolutionResult);\n                     modules.add(moduleResolutionResult);\n                 }\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\nindex 791f5d3208e..3a6cb276ec8 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\n@@ -3157,4 +3157,49 @@ void circularMavenProperty() {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4319\")\n+    void multiModulePropertyVersionShouldAddModules() {\n+        rewriteRun(\n+          mavenProject(\"root\",\n+            pomXml(\n+              \"\"\"\n+                <project>\n+                    <groupId>example</groupId>\n+                    <artifactId>example-root</artifactId>\n+                    <packaging>pom</packaging>\n+                    <version>${revision}</version>\n+\n+                    <properties>\n+                        <revision>1.0.1</revision>\n+                    </properties>\n+\n+                    <modules>\n+                        <module>example-child</module>\n+                    </modules>\n+                </project>\n+                \"\"\",\n+              spec -> spec.afterRecipe(pomXml -> assertThat(\n+                pomXml.getMarkers().findFirst(MavenResolutionResult.class).orElseThrow()\n+                  .getModules()).isNotEmpty())\n+            ),\n+            mavenProject(\"example-child\",\n+              pomXml(\n+                \"\"\"\n+                  <project>\n+                      <parent>\n+                          <groupId>example</groupId>\n+                          <artifactId>example-root</artifactId>\n+                          <version>${revision}</version>\n+                      </parent>\n+\n+                      <artifactId>example-child</artifactId>\n+                  </project>\n+                  \"\"\"\n+              )\n+            )\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4320",
    "pr_id": 4320,
    "issue_id": 4135,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Migrate from Gradle Enterprise gradle plugin to Develocity plugin \n## What problem are you trying to solve?\r\n\r\n> Starting with version 3.17, the plugin is available under the “Develocity” brand. Please see the [Develocity Gradle Plugin User Manual](https://docs.gradle.com/enterprise/gradle-plugin/current) for the latest documentation. Several core functionalities have been deprecated with the rebranding and will be removed in a future plugin version. Therefore, upgrading to the 3.17+ version of the plugin requires more than just updating the version number.\r\n\r\n> Start by updating the plugin’s version to 3.17 and changing the plugin ID to com.gradle.develocity. If you are using the common-custom-user-data-gradle-plugin, update the plugin’s version to 2.0. After running a simple task like ./gradlew help you will be informed about the usage of the deprecated APIs:\r\n\r\n> Most of the violations can be fixed by replacing references of gradleEnterprise with develocity. Some APIs have been replaced by more descriptive and idiomatic alternatives. In this example, those APIs are taskInputFiles and publishAlways(). See [Breaking API changes](https://docs.gradle.com/enterprise/gradle-plugin/legacy/#develocity_replaced_apis) section for this and other examples. After these changes, your build script should look like the following:\r\n\r\nhttps://docs.gradle.com/enterprise/gradle-plugin/legacy/#develocity_migration",
    "issue_word_count": 215,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocity.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocityTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocityTest.java"
    ],
    "base_commit": "1fc661b10b4a2ff1dbc5c322d88f9ebb4db66be1",
    "head_commit": "1b915f3aceb6cd6aceb8c857cb3d177e9c30d1ad",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4320",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4320",
    "dockerfile": "",
    "pr_merged_at": "2024-07-11T21:43:51.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocity.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocity.java\nnew file mode 100644\nindex 00000000000..88d4376f0a5\n--- /dev/null\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocity.java\n@@ -0,0 +1,292 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle.plugins;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.Value;\n+import org.openrewrite.*;\n+import org.openrewrite.gradle.DependencyVersionSelector;\n+import org.openrewrite.gradle.GradleParser;\n+import org.openrewrite.gradle.IsSettingsGradle;\n+import org.openrewrite.gradle.marker.GradleSettings;\n+import org.openrewrite.groovy.GroovyIsoVisitor;\n+import org.openrewrite.groovy.tree.G;\n+import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.internal.lang.Nullable;\n+import org.openrewrite.java.style.IntelliJ;\n+import org.openrewrite.java.style.TabsAndIndentsStyle;\n+import org.openrewrite.java.tree.*;\n+import org.openrewrite.marker.Markers;\n+import org.openrewrite.maven.MavenDownloadingException;\n+import org.openrewrite.maven.tree.GroupArtifact;\n+\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static java.util.Collections.singletonList;\n+\n+@Value\n+@EqualsAndHashCode(callSuper = false)\n+public class MigrateGradleEnterpriseToDevelocity extends Recipe {\n+    @Option(displayName = \"Plugin version\",\n+            description = \"An exact version number or node-style semver selector used to select the version number. \" +\n+                          \"You can also use `latest.release` for the latest available version and `latest.patch` if \" +\n+                          \"the current version is a valid semantic version. For more details, you can look at the documentation \" +\n+                          \"page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors). \" +\n+                          \"Defaults to `latest.release`.\",\n+            example = \"3.x\",\n+            required = false)\n+    @Nullable\n+    String version;\n+\n+    @Override\n+    public String getDisplayName() {\n+        return \"Migrate from Gradle Enterprise to Develocity\";\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"Migrate from the Gradle Enterprise Gradle plugin to the Develocity Gradle plugin.\";\n+    }\n+\n+    @Override\n+    public TreeVisitor<?, ExecutionContext> getVisitor() {\n+        return Preconditions.check(\n+                new IsSettingsGradle<>(),\n+                new GroovyIsoVisitor<ExecutionContext>() {\n+                    @Override\n+                    public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {\n+                        Optional<GradleSettings> maybeGs = cu.getMarkers().findFirst(GradleSettings.class);\n+                        if (!maybeGs.isPresent()) {\n+                            return cu;\n+                        }\n+\n+                        try {\n+                            String newVersion = new DependencyVersionSelector(null, null, maybeGs.get())\n+                                    .select(new GroupArtifact(\"com.gradle.develocity\", \"com.gradle.develocity.gradle.plugin\"), \"classpath\", version, null, ctx);\n+                            if (newVersion == null) {\n+                                // The develocity plugin was first published as of 3.17\n+                                return cu;\n+                            }\n+                        } catch (MavenDownloadingException e) {\n+                            return e.warn(cu);\n+                        }\n+\n+                        G.CompilationUnit g = cu;\n+                        g = (G.CompilationUnit) new ChangePlugin(\"com.gradle.enterprise\", \"com.gradle.develocity\", version).getVisitor()\n+                                .visitNonNull(g, ctx);\n+                        g = (G.CompilationUnit) new ChangePluginVersion(\"com.gradle.common-custom-user-data-gradle-plugin\", \"2.x\", null).getVisitor()\n+                                .visitNonNull(g, ctx);\n+                        g = (G.CompilationUnit) new MigrateConfigurationVisitor().visitNonNull(g, ctx);\n+                        return g;\n+                    }\n+                }\n+        );\n+    }\n+\n+    private static class MigrateConfigurationVisitor extends GroovyIsoVisitor<ExecutionContext> {\n+        @Override\n+        public @Nullable J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n+            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n+            if (m.getSimpleName().equals(\"gradleEnterprise\") && m.getArguments().size() == 1 && m.getArguments().get(0) instanceof J.Lambda) {\n+                return m.withName(m.getName().withSimpleName(\"develocity\"));\n+            }\n+\n+            if (m.getSimpleName().startsWith(\"publishAlways\") && withinMethodInvocations(Arrays.asList(\"gradleEnterprise\", \"buildScan\"))) {\n+                if (m.getSimpleName().equals(\"publishAlways\") && noArguments(m.getArguments())) {\n+                    // As of 3.17+, `publishAlways` is the default, so it is recommended to not configure anything\n+                    return null;\n+                }\n+\n+                if (m.getSimpleName().equals(\"publishAlwaysIf\")) {\n+                    J.MethodInvocation publishingTemplate = develocityPublishAlwaysIfDsl(getIndent(getCursor().firstEnclosing(G.CompilationUnit.class)), ctx);\n+                    if (publishingTemplate == null) {\n+                        return m;\n+                    }\n+\n+                    return publishingTemplate.withArguments(ListUtils.mapFirst(publishingTemplate.getArguments(), arg -> {\n+                        if (arg instanceof J.Lambda) {\n+                            J.Lambda lambda = (J.Lambda) arg;\n+                            J.Block block = (J.Block) lambda.getBody();\n+                            return lambda.withBody(block.withStatements(ListUtils.mapFirst(block.getStatements(), s -> {\n+                                if (s instanceof J.Return) {\n+                                    J.Return _return = (J.Return) s;\n+                                    return _return.withExpression(m.getArguments().get(0));\n+                                }\n+                                return s;\n+                            })));\n+                        }\n+                        return arg;\n+                    }));\n+                }\n+            }\n+\n+            if (m.getSimpleName().startsWith(\"publishOnFailure\") && withinMethodInvocations(Arrays.asList(\"gradleEnterprise\", \"buildScan\"))) {\n+                J.MethodInvocation publishingTemplate = develocityPublishOnFailureIfDsl(getIndent(getCursor().firstEnclosing(G.CompilationUnit.class)), ctx);\n+                if (publishingTemplate == null) {\n+                    return m;\n+                }\n+\n+                if (m.getSimpleName().equals(\"publishOnFailure\") && noArguments(m.getArguments())) {\n+                    return publishingTemplate;\n+                }\n+\n+                if (m.getSimpleName().equals(\"publishOnFailureIf\") && m.getArguments().size() == 1 && m.getArguments().get(0) instanceof J.Binary) {\n+                    return publishingTemplate.withArguments(ListUtils.mapFirst(publishingTemplate.getArguments(), arg -> {\n+                        if (arg instanceof J.Lambda) {\n+                            J.Lambda lambda = (J.Lambda) arg;\n+                            J.Block block = (J.Block) lambda.getBody();\n+                            return lambda.withBody(block.withStatements(ListUtils.mapFirst(block.getStatements(), s -> {\n+                                if (s instanceof J.Return && ((J.Return) s).getExpression() instanceof J.Unary) {\n+                                    J.Return _return = (J.Return) s;\n+                                    return _return.withExpression(new J.Binary(\n+                                            Tree.randomId(),\n+                                            Space.EMPTY,\n+                                            Markers.EMPTY,\n+                                            _return.getExpression(),\n+                                            JLeftPadded.build(J.Binary.Type.And).withBefore(Space.SINGLE_SPACE),\n+                                            Space.formatFirstPrefix(m.getArguments(), Space.SINGLE_SPACE).get(0),\n+                                            JavaType.Primitive.Boolean\n+                                    ));\n+                                }\n+                                return s;\n+                            })));\n+                        }\n+                        return arg;\n+                    }));\n+                }\n+            }\n+\n+            if (m.getSimpleName().equals(\"remote\") && withinMethodInvocations(Arrays.asList(\"gradleEnterprise\", \"buildCache\"))) {\n+                return m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {\n+                    if (arg instanceof J.FieldAccess) {\n+                        J.FieldAccess field = (J.FieldAccess) arg;\n+                        if (field.getSimpleName().equals(\"buildCache\") && field.getTarget() instanceof J.Identifier && ((J.Identifier) field.getTarget()).getSimpleName().equals(\"gradleEnterprise\")) {\n+                            return field.withTarget(((J.Identifier) field.getTarget()).withSimpleName(\"develocity\"));\n+                        }\n+                    }\n+                    return arg;\n+                }));\n+            }\n+            return m;\n+        }\n+\n+        @Override\n+        public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext ctx) {\n+            J.Assignment a = super.visitAssignment(assignment, ctx);\n+\n+            if (a.getVariable() instanceof J.Identifier && ((J.Identifier) a.getVariable()).getSimpleName().equals(\"taskInputFiles\") && withinMethodInvocations(Arrays.asList(\"gradleEnterprise\", \"buildScan\", \"capture\"))) {\n+                return a.withVariable(((J.Identifier) a.getVariable()).withSimpleName(\"fileFingerprints\"));\n+            }\n+\n+            return a;\n+        }\n+\n+        private boolean noArguments(List<Expression> arguments) {\n+            return arguments.isEmpty() || (arguments.size() == 1 && arguments.get(0) instanceof J.Empty);\n+        }\n+\n+        private boolean withinMethodInvocations(List<String> methods) {\n+            Cursor current = getCursor().getParent();\n+            for (int i = methods.size() - 1; i >= 0; i--) {\n+                current = findMethodInvocation(current);\n+                if (current == null) {\n+                    return false;\n+                }\n+\n+                if (!((J.MethodInvocation) current.getValue()).getSimpleName().equals(methods.get(i))) {\n+                    return false;\n+                }\n+\n+                current = current.getParent();\n+            }\n+\n+            return true;\n+        }\n+\n+        private @Nullable Cursor findMethodInvocation(@Nullable Cursor start) {\n+            if (start == null) {\n+                return null;\n+            }\n+\n+            Cursor current = start;\n+            while (current.getParent() != null) {\n+                if (current.getValue() instanceof J.MethodInvocation) {\n+                    return current;\n+                }\n+\n+                current = current.getParent();\n+            }\n+\n+            return null;\n+        }\n+\n+        @Nullable\n+        private J.MethodInvocation develocityPublishAlwaysIfDsl(String indent, ExecutionContext ctx) {\n+            StringBuilder ge = new StringBuilder(\"\\ndevelocity {\\n\");\n+            ge.append(indent).append(\"buildScan {\\n\");\n+            ge.append(indent).append(indent).append(\"publishing.onlyIf { true }\\n\");\n+            ge.append(indent).append(\"}\\n\");\n+            ge.append(\"}\\n\");\n+\n+            G.CompilationUnit cu = GradleParser.builder().build()\n+                    .parseInputs(singletonList(\n+                            Parser.Input.fromString(Paths.get(\"settings.gradle\"), ge.toString())), null, ctx)\n+                    .map(G.CompilationUnit.class::cast)\n+                    .findFirst()\n+                    .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"));\n+\n+            J.MethodInvocation develocity = (J.MethodInvocation) cu.getStatements().get(0);\n+            J.MethodInvocation buildScan = (J.MethodInvocation) ((J.Return) ((J.Block) ((J.Lambda) develocity.getArguments().get(0)).getBody()).getStatements().get(0)).getExpression();\n+            return (J.MethodInvocation) ((J.Return) ((J.Block) ((J.Lambda) buildScan.getArguments().get(0)).getBody()).getStatements().get(0)).getExpression();\n+        }\n+\n+        @Nullable\n+        private J.MethodInvocation develocityPublishOnFailureIfDsl(String indent, ExecutionContext ctx) {\n+            StringBuilder ge = new StringBuilder(\"\\ndevelocity {\\n\");\n+            ge.append(indent).append(\"buildScan {\\n\");\n+            ge.append(indent).append(indent).append(\"publishing.onlyIf { !it.buildResult.failures.empty }\\n\");\n+            ge.append(indent).append(\"}\\n\");\n+            ge.append(\"}\\n\");\n+\n+            G.CompilationUnit cu = GradleParser.builder().build()\n+                    .parseInputs(singletonList(\n+                            Parser.Input.fromString(Paths.get(\"settings.gradle\"), ge.toString())), null, ctx)\n+                    .map(G.CompilationUnit.class::cast)\n+                    .findFirst()\n+                    .orElseThrow(() -> new IllegalArgumentException(\"Could not parse as Gradle\"));\n+\n+            J.MethodInvocation develocity = (J.MethodInvocation) cu.getStatements().get(0);\n+            J.MethodInvocation buildScan = (J.MethodInvocation) ((J.Return) ((J.Block) ((J.Lambda) develocity.getArguments().get(0)).getBody()).getStatements().get(0)).getExpression();\n+            return (J.MethodInvocation) ((J.Return) ((J.Block) ((J.Lambda) buildScan.getArguments().get(0)).getBody()).getStatements().get(0)).getExpression();\n+        }\n+\n+        private String getIndent(G.CompilationUnit cu) {\n+            TabsAndIndentsStyle style = cu.getStyle(TabsAndIndentsStyle.class, IntelliJ.tabsAndIndents());\n+            if (style.getUseTabCharacter()) {\n+                return \"\\t\";\n+            } else {\n+                StringBuilder sb = new StringBuilder();\n+                for (int i = 0; i < style.getIndentSize(); i++) {\n+                    sb.append(\" \");\n+                }\n+                return sb.toString();\n+            }\n+        }\n+    }\n+}\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocityTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocityTest.java\nnew file mode 100644\nindex 00000000000..223c0f2569d\n--- /dev/null\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/plugins/MigrateGradleEnterpriseToDevelocityTest.java\n@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.gradle.plugins;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.DocumentExample;\n+import org.openrewrite.Issue;\n+import org.openrewrite.test.RecipeSpec;\n+import org.openrewrite.test.RewriteTest;\n+\n+import static org.openrewrite.gradle.Assertions.settingsGradle;\n+import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;\n+\n+class MigrateGradleEnterpriseToDevelocityTest implements RewriteTest {\n+    @Override\n+    public void defaults(RecipeSpec spec) {\n+        spec.recipe(new MigrateGradleEnterpriseToDevelocity(\"3.17.x\"))\n+          .beforeRecipe(withToolingApi());\n+    }\n+\n+    @Test\n+    @DocumentExample\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4135\")\n+    void migrate() {\n+        rewriteRun(\n+          settingsGradle(\n+            \"\"\"\n+              plugins {\n+                  id 'com.gradle.enterprise' version '3.16'\n+              }\n+              gradleEnterprise {\n+                  server = 'https://ge.sam.com/'\n+                  allowUntrustedServer = true\n+                  buildScan {\n+                      publishAlways()\n+                      uploadInBackground = true\n+                      capture {\n+                          taskInputFiles = true\n+                      }\n+                  }\n+                  buildCache {\n+                      remote(gradleEnterprise.buildCache) {\n+                          enabled = true\n+                          push = System.getenv(\"CI\") != null\n+                      }\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  id 'com.gradle.develocity' version '3.17.5'\n+              }\n+              develocity {\n+                  server = 'https://ge.sam.com/'\n+                  allowUntrustedServer = true\n+                  buildScan {\n+                      uploadInBackground = true\n+                      capture {\n+                          fileFingerprints = true\n+                      }\n+                  }\n+                  buildCache {\n+                      remote(develocity.buildCache) {\n+                          enabled = true\n+                          push = System.getenv(\"CI\") != null\n+                      }\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void publishAlwaysIf() {\n+        rewriteRun(\n+          settingsGradle(\n+            \"\"\"\n+              plugins {\n+                  id 'com.gradle.enterprise' version '3.16'\n+              }\n+              gradleEnterprise {\n+                  server = 'https://ge.sam.com/'\n+                  buildScan {\n+                      publishAlwaysIf(System.getenv(\"CI\") != null)\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  id 'com.gradle.develocity' version '3.17.5'\n+              }\n+              develocity {\n+                  server = 'https://ge.sam.com/'\n+                  buildScan {\n+                      publishing.onlyIf { System.getenv(\"CI\") != null }\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void publishOnFailure() {\n+        rewriteRun(\n+          settingsGradle(\n+            \"\"\"\n+              plugins {\n+                  id 'com.gradle.enterprise' version '3.16'\n+              }\n+              gradleEnterprise {\n+                  server = 'https://ge.sam.com/'\n+                  buildScan {\n+                      publishOnFailure()\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  id 'com.gradle.develocity' version '3.17.5'\n+              }\n+              develocity {\n+                  server = 'https://ge.sam.com/'\n+                  buildScan {\n+                      publishing.onlyIf { !it.buildResult.failures.empty }\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void publishOnFailureIf() {\n+        rewriteRun(\n+          settingsGradle(\n+            \"\"\"\n+              plugins {\n+                  id 'com.gradle.enterprise' version '3.16'\n+              }\n+              gradleEnterprise {\n+                  server = 'https://ge.sam.com/'\n+                  buildScan {\n+                      publishOnFailureIf(System.getenv(\"CI\") != null)\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  id 'com.gradle.develocity' version '3.17.5'\n+              }\n+              develocity {\n+                  server = 'https://ge.sam.com/'\n+                  buildScan {\n+                      publishing.onlyIf { !it.buildResult.failures.empty && System.getenv(\"CI\") != null }\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void doNothingForTooOldVersions() {\n+        rewriteRun(\n+          spec -> spec.recipe(new MigrateGradleEnterpriseToDevelocity(\"3.16.x\")),\n+          settingsGradle(\n+            \"\"\"\n+              plugins {\n+                  id 'com.gradle.enterprise' version '3.16'\n+              }\n+              gradleEnterprise {\n+                  server = 'https://ge.sam.com/'\n+                  allowUntrustedServer = true\n+                  buildScan {\n+                      publishAlways()\n+                      uploadInBackground = true\n+                      capture {\n+                          taskInputFiles = true\n+                      }\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4317",
    "pr_id": 4317,
    "issue_id": 4316,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Change maven managed dependency classifier\n## What problem are you trying to solve?\r\nRecipe [Change Maven dependency classifier](https://docs.openrewrite.org/recipes/maven/changedependencyclassifier) changes classifier only for dependency. In some case I want to change classifier for managed dependency as well.\r\n\r\n## Describe the situation before applying the recipe\r\npom.xml\r\n```\r\n<project>\r\n...\r\n    <dependencyManagement>\r\n        <dependencies>\r\n                 <groupId>com.google.guava</groupId>\r\n                <artifactId>guava</artifactId>\r\n                <version>${guava.version}</version>\r\n                <classifier>jar</classifier>\r\n        </dependencies>\r\n    </dependencyManagement>\r\n</project>\r\n```\r\n\r\n## Describe the situation after applying the recipe\r\npom.xml\r\n```\r\n<project>\r\n...\r\n    <dependencyManagement>\r\n        <dependencies>\r\n                 <groupId>com.google.guava</groupId>\r\n                <artifactId>guava</artifactId>\r\n                <version>${guava.version}</version>\r\n        </dependencies>\r\n    </dependencyManagement>\r\n</project>\r\n```\r\n\r\n## Are you interested in [contributing this recipe to OpenRewrite]\r\nIt can be implemented by addition an additional check (`isManagedDependencyTag(String groupId, String artifactId)`) to the existing recipe:\r\n[ChangeDependencyClassifier.isDependencyTag](https://github.com/openrewrite/rewrite/blob/03aa6226822c14eea7ed817cc9f52cdb0bb553c9/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyClassifier.java#L77). For backward compatibility this check should be activated via property and disabled by default.\r\n",
    "issue_word_count": 160,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyClassifier.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyClassifierTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyClassifierTest.java"
    ],
    "base_commit": "03aa6226822c14eea7ed817cc9f52cdb0bb553c9",
    "head_commit": "66ac6383b45324ccc8615fd3f9587d591c6c0832",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4317",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4317",
    "dockerfile": "",
    "pr_merged_at": "2024-07-11T21:17:35.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyClassifier.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyClassifier.java\nindex 6a806362123..1a5488b9e07 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyClassifier.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyClassifier.java\n@@ -54,6 +54,13 @@ public class ChangeDependencyClassifier extends Recipe {\n     @Nullable\n     String newClassifier;\n \n+    @Option(displayName = \"Change Maven managed dependency\",\n+            description = \"This flag can be set to explicitly change the classifier in Maven management dependency section. Default `false`.\",\n+            example = \"true\",\n+            required = false)\n+    @Nullable\n+    Boolean changeManagedDependency;\n+\n     @Override\n     public String getDisplayName() {\n         return \"Change Maven dependency classifier\";\n@@ -74,22 +81,21 @@ public TreeVisitor<?, ExecutionContext> getVisitor() {\n         return new MavenVisitor<ExecutionContext>() {\n             @Override\n             public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n-                if (isDependencyTag(groupId, artifactId)) {\n-                    Optional<Xml.Tag> scope = tag.getChild(\"classifier\");\n-                    if (scope.isPresent()) {\n+                if (isDependencyTag(groupId, artifactId) ||\n+                        (Boolean.TRUE.equals(changeManagedDependency) && isManagedDependencyTag(groupId, artifactId))) {\n+                    Optional<Xml.Tag> classifier = tag.getChild(\"classifier\");\n+                    if (classifier.isPresent()) {\n                         if (newClassifier == null) {\n-                            doAfterVisit(new RemoveContentVisitor<>(scope.get(), false));\n-                        } else if (!newClassifier.equals(scope.get().getValue().orElse(null))) {\n-                            doAfterVisit(new ChangeTagValueVisitor<>(scope.get(), newClassifier));\n+                            doAfterVisit(new RemoveContentVisitor<>(classifier.get(), false));\n+                        } else if (!newClassifier.equals(classifier.get().getValue().orElse(null))) {\n+                            doAfterVisit(new ChangeTagValueVisitor<>(classifier.get(), newClassifier));\n                         }\n                     } else if (newClassifier != null) {\n                         doAfterVisit(new AddToTagVisitor<>(tag, Xml.Tag.build(\"<classifier>\" + newClassifier + \"</classifier>\")));\n                     }\n                 }\n-\n                 return super.visitTag(tag, ctx);\n             }\n         };\n     }\n-\n }\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyClassifierTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyClassifierTest.java\nindex de18955e507..285b0c3acfb 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyClassifierTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangeDependencyClassifierTest.java\n@@ -26,7 +26,7 @@ class ChangeDependencyClassifierTest implements RewriteTest {\n \n     @Override\n     public void defaults(RecipeSpec spec) {\n-        spec.recipe(new ChangeDependencyClassifier(\"org.ehcache\", \"ehcache\", \"jakarta\"));\n+        spec.recipe(new ChangeDependencyClassifier(\"org.ehcache\", \"ehcache\", \"jakarta\", false));\n     }\n \n     @DocumentExample\n@@ -37,11 +37,77 @@ void noClassifierToClassifier() {\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-              \n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-              \n+\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.ehcache</groupId>\n+                    <artifactId>ehcache</artifactId>\n+                    <version>3.10.0</version>\n+                  </dependency>\n+                </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                      <!-- classifier not added for managed dependencies by default -->\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.ehcache</groupId>\n+                    <artifactId>ehcache</artifactId>\n+                    <version>3.10.0</version>\n+                    <classifier>jakarta</classifier>\n+                  </dependency>\n+                </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                      <!-- classifier not added for managed dependencies by default -->\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void noClassifierToClassifierManagedDependency() {\n+        rewriteRun(\n+          spec -> spec.recipe(\n+            new ChangeDependencyClassifier(\"org.ehcache\", \"ehcache\", \"jakarta\", true)\n+          ),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+\n                 <dependencies>\n                   <dependency>\n                     <groupId>org.ehcache</groupId>\n@@ -49,16 +115,26 @@ void noClassifierToClassifier() {\n                     <version>3.10.0</version>\n                   </dependency>\n                 </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n               </project>\n               \"\"\",\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-              \n+\n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-              \n+\n                 <dependencies>\n                   <dependency>\n                     <groupId>org.ehcache</groupId>\n@@ -67,6 +143,17 @@ void noClassifierToClassifier() {\n                     <classifier>jakarta</classifier>\n                   </dependency>\n                 </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                      <classifier>jakarta</classifier>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n               </project>\n               \"\"\"\n           )\n@@ -77,17 +164,104 @@ void noClassifierToClassifier() {\n     void addClassifierUsingGlobsExpressions() {\n         rewriteRun(\n           spec -> spec.recipe(\n-            new ChangeDependencyClassifier(\"org.ehcache\", \"*\", \"jakarta\")\n+            new ChangeDependencyClassifier(\"org.ehcache\", \"*\", \"jakarta\", false)\n+          ),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.ehcache</groupId>\n+                    <artifactId>ehcache</artifactId>\n+                    <version>3.10.0</version>\n+                  </dependency>\n+                  <dependency>\n+                    <groupId>org.ehcache</groupId>\n+                    <artifactId>ehcache-transactions</artifactId>\n+                    <version>3.10.0</version>\n+                  </dependency>\n+                </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                    </dependency>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache-transactions</artifactId>\n+                      <version>3.10.0</version>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.ehcache</groupId>\n+                    <artifactId>ehcache</artifactId>\n+                    <version>3.10.0</version>\n+                    <classifier>jakarta</classifier>\n+                  </dependency>\n+                  <dependency>\n+                    <groupId>org.ehcache</groupId>\n+                    <artifactId>ehcache-transactions</artifactId>\n+                    <version>3.10.0</version>\n+                    <classifier>jakarta</classifier>\n+                  </dependency>\n+                </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                    </dependency>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache-transactions</artifactId>\n+                      <version>3.10.0</version>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addClassifierUsingGlobsExpressionsManagedDependency() {\n+        rewriteRun(\n+          spec -> spec.recipe(\n+            new ChangeDependencyClassifier(\"org.ehcache\", \"*\", \"jakarta\", true)\n           ),\n           pomXml(\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-              \n+\n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-              \n+\n                 <dependencies>\n                   <dependency>\n                     <groupId>org.ehcache</groupId>\n@@ -100,16 +274,31 @@ void addClassifierUsingGlobsExpressions() {\n                     <version>3.10.0</version>\n                   </dependency>\n                 </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                        <groupId>org.ehcache</groupId>\n+                        <artifactId>ehcache</artifactId>\n+                        <version>3.10.0</version>\n+                    </dependency>\n+                    <dependency>\n+                        <groupId>org.ehcache</groupId>\n+                        <artifactId>ehcache-transactions</artifactId>\n+                        <version>3.10.0</version>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n               </project>\n               \"\"\",\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-              \n+\n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-              \n+\n                 <dependencies>\n                   <dependency>\n                     <groupId>org.ehcache</groupId>\n@@ -124,6 +313,23 @@ void addClassifierUsingGlobsExpressions() {\n                     <classifier>jakarta</classifier>\n                   </dependency>\n                 </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                      <classifier>jakarta</classifier>\n+                    </dependency>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache-transactions</artifactId>\n+                      <version>3.10.0</version>\n+                      <classifier>jakarta</classifier>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n               </project>\n               \"\"\"\n           )\n@@ -137,11 +343,80 @@ void classifierToClassifier() {\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-                \n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.ehcache</groupId>\n+                    <artifactId>ehcache</artifactId>\n+                    <version>3.10.0</version>\n+                    <classifier>javax</classifier>\n+                  </dependency>\n+                </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                      <classifier>javax</classifier>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.ehcache</groupId>\n+                    <artifactId>ehcache</artifactId>\n+                    <version>3.10.0</version>\n+                    <classifier>jakarta</classifier>\n+                  </dependency>\n+                </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                      <classifier>javax</classifier>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void classifierToClassifierManagedDependency() {\n+        rewriteRun(\n+          spec -> spec.recipe(\n+            new ChangeDependencyClassifier(\"org.ehcache\", \"ehcache\", \"jakarta\", true)\n+          ),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-                \n+\n                 <dependencies>\n                   <dependency>\n                     <groupId>org.ehcache</groupId>\n@@ -150,16 +425,27 @@ void classifierToClassifier() {\n                     <classifier>javax</classifier>\n                   </dependency>\n                 </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                      <classifier>javax</classifier>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n               </project>\n               \"\"\",\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-                \n+\n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-                \n+\n                 <dependencies>\n                   <dependency>\n                     <groupId>org.ehcache</groupId>\n@@ -168,6 +454,17 @@ void classifierToClassifier() {\n                     <classifier>jakarta</classifier>\n                   </dependency>\n                 </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                      <classifier>jakarta</classifier>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n               </project>\n               \"\"\"\n           )\n@@ -177,16 +474,82 @@ void classifierToClassifier() {\n     @Test\n     void classifierToNoClassifier() {\n         rewriteRun(\n-          spec -> spec.recipe(new ChangeDependencyClassifier(\"org.ehcache\", \"ehcache\", null)),\n+          spec -> spec.recipe(new ChangeDependencyClassifier(\"org.ehcache\", \"ehcache\", null, false)),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.ehcache</groupId>\n+                    <artifactId>ehcache</artifactId>\n+                    <version>3.10.0</version>\n+                    <classifier>jakarta</classifier>\n+                  </dependency>\n+                </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                      <classifier>jakarta</classifier>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.ehcache</groupId>\n+                    <artifactId>ehcache</artifactId>\n+                    <version>3.10.0</version>\n+                  </dependency>\n+                </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                      <classifier>jakarta</classifier>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void classifierToNoClassifierManagedDependency() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeDependencyClassifier(\"org.ehcache\", \"ehcache\", null, true)),\n           pomXml(\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-                \n+\n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-                \n+\n                 <dependencies>\n                   <dependency>\n                     <groupId>org.ehcache</groupId>\n@@ -195,16 +558,27 @@ void classifierToNoClassifier() {\n                     <classifier>jakarta</classifier>\n                   </dependency>\n                 </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                      <classifier>jakarta</classifier>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n               </project>\n               \"\"\",\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-                \n+\n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-                \n+\n                 <dependencies>\n                   <dependency>\n                     <groupId>org.ehcache</groupId>\n@@ -212,6 +586,16 @@ void classifierToNoClassifier() {\n                     <version>3.10.0</version>\n                   </dependency>\n                 </dependencies>\n+\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>org.ehcache</groupId>\n+                      <artifactId>ehcache</artifactId>\n+                      <version>3.10.0</version>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n               </project>\n               \"\"\"\n           )\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4307",
    "pr_id": 4307,
    "issue_id": 4304,
    "repo": "openrewrite/rewrite",
    "problem_statement": "UseStaticImport should rewrite if method already exists\n## What version of OpenRewrite are you using?\r\n* org.openrewrite:rewrite-core:jar:8.29.0\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n\r\nUseStaticImport should not rewrite with an import static when there is a method in the scope with the same name (and maybe signature).\r\n\r\nThe second case below I'm not sure how to best deal with, perhaps don't rewrite the `String.valueOf`, or do what the test here does.\r\n\r\n```java\r\n  @Test\r\n  void testUseStaticImport() {\r\n    rewriteRun(\r\n        spec -> spec.recipe(new UseStaticImport(\"java.util.List of(..)\")),\r\n        // language=java\r\n        java(\r\n            \"\"\"\r\n                    package com.helloworld;\r\n\r\n                    import java.util.List;\r\n\r\n                    public class Foo {\r\n\r\n                        void of() {}\r\n\r\n                        void foo() {\r\n                          List.of();\r\n                        }\r\n                    }\r\n            \"\"\"));\r\n  }\r\n\r\n  @Test\r\n  void testUseStaticImport2() {\r\n    rewriteRun(\r\n        spec ->\r\n            spec.recipe(\r\n                new CompositeRecipe(\r\n                    List.of(\r\n                        new UseStaticImport(\"java.lang.String valueOf(..)\"),\r\n                        new UseStaticImport(\"java.lang.Integer valueOf(..)\")))),\r\n        // language=java\r\n        java(\r\n            \"\"\"\r\n                    package com.helloworld;\r\n\r\n                    public class Foo {\r\n                        void foo() {\r\n                          String.valueOf(\"1\");\r\n                          Integer.valueOf(\"1\");\r\n                        }\r\n                    }\r\n            \"\"\",\r\n            \"\"\"\r\n                    package com.helloworld;\r\n\r\n                    import static java.lang.String.valueOf;\r\n        \r\n                    public class Foo {\r\n                        void foo() {\r\n                          valueOf(\"1\");\r\n                          Integer.valueOf(\"1\");\r\n                        }\r\n                    }\r\n            \"\"\"\r\n        ));\r\n  }\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n\r\nHappy to give it a try with some pointers, as usual not sure where to start.\r\n",
    "issue_word_count": 210,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/UseStaticImportTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/search/MaybeUsesImportTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/UseStaticImport.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/UseStaticImportTest.java",
      "rewrite-java-test/src/test/java/org/openrewrite/java/search/MaybeUsesImportTest.java"
    ],
    "base_commit": "c97c7f214634c78b257e6a7eb6705727f3d46900",
    "head_commit": "66948b9d821189045e2d96e6908dd74050e59618",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4307",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4307",
    "dockerfile": "",
    "pr_merged_at": "2024-07-06T11:26:24.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/UseStaticImport.java b/rewrite-java/src/main/java/org/openrewrite/java/UseStaticImport.java\nindex 5f07d36e95b..65b445ff9b7 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/UseStaticImport.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/UseStaticImport.java\n@@ -24,6 +24,7 @@\n import org.openrewrite.java.tree.J;\n import org.openrewrite.java.tree.JavaType;\n import org.openrewrite.java.tree.Javadoc;\n+import org.openrewrite.marker.SearchResult;\n \n @ToString\n @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n@@ -59,7 +60,17 @@ public TreeVisitor<?, ExecutionContext> getVisitor() {\n             int indexBrace = methodPattern.indexOf('(', indexSpace);\n             String methodNameMatcher = methodPattern.substring(indexSpace, indexBrace);\n             preconditions = Preconditions.and(preconditions,\n-                    Preconditions.not(new DeclaresMethod<>(\"* \" + methodNameMatcher + \"(..)\")));\n+                    Preconditions.not(new DeclaresMethod<>(\"*..* \" + methodNameMatcher + \"(..)\")),\n+                    Preconditions.not(new JavaIsoVisitor<ExecutionContext>() {\n+                        @Override\n+                        public J.Import visitImport(J.Import _import, ExecutionContext ctx) {\n+                            if (_import.isStatic() && _import.getQualid().getSimpleName().equals(methodNameMatcher.substring(1))) {\n+                                return SearchResult.found(_import);\n+                            }\n+                            return _import;\n+                        }\n+                    })\n+            );\n         }\n         return Preconditions.check(preconditions, new UseStaticImportVisitor());\n     }\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/UseStaticImportTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/UseStaticImportTest.java\nindex bca92cce98a..7e685fc3a12 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/UseStaticImportTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/UseStaticImportTest.java\n@@ -41,9 +41,9 @@ public static void assertEquals(int m, int n) {}\n           java(\n             \"\"\"\n               package test;\n-                            \n+\n               import asserts.Assert;\n-                            \n+\n               class Test {\n                   void test() {\n                       Assert.assertTrue(true);\n@@ -54,9 +54,9 @@ void test() {\n               \"\"\",\n             \"\"\"\n               package test;\n-                            \n+\n               import static asserts.Assert.*;\n-                            \n+\n               class Test {\n                   void test() {\n                       assertTrue(true);\n@@ -76,15 +76,15 @@ void ignoreMethodsWithTypeParameter() {\n           spec -> spec.recipe(new UseStaticImport(\"java.util.Collections emptyList()\")),\n           java(\n             \"\"\"\n-            import java.util.Collections;\n-            import java.util.List;\n-\n-            public class Reproducer {\n-                public void methodWithTypeParameter() {\n-                    List<Object> list = Collections.<Object>emptyList();\n-                }\n-            }\n-            \"\"\"\n+              import java.util.Collections;\n+              import java.util.List;\n+\n+              public class Reproducer {\n+                  public void methodWithTypeParameter() {\n+                      List<Object> list = Collections.<Object>emptyList();\n+                  }\n+              }\n+              \"\"\"\n           )\n         );\n     }\n@@ -95,18 +95,76 @@ void sameMethodLocallyNoStaticImport() {\n           spec -> spec.recipe(new UseStaticImport(\"java.util.Collections emptyList()\")),\n           java(\n             \"\"\"\n-            import java.util.Collections;\n-            import java.util.List;\n-\n-            public class SameMethodNameLocally {\n-                public void avoidCollision() {\n-                    List<Object> list = Collections.emptyList();\n-                }\n-                \n-                private int emptyList(String canHaveDifferentArguments) {\n-                }\n-            }\n+              package com.helloworld;\n+\n+              import java.util.Collections;\n+              import java.util.List;\n+\n+              public class SameMethodNameLocally {\n+                  public void avoidCollision() {\n+                      List<Object> list = Collections.emptyList();\n+                  }\n+\n+                  private int emptyList(String canHaveDifferentArguments) {\n+                  }\n+              }\n+                \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4304\")\n+    void sameMethodImportedNoStaticImport() {\n+        rewriteRun(\n+          spec -> spec.recipe(new UseStaticImport(\"java.lang.String valueOf(..)\")),\n+          java(\n+            \"\"\"\n+              package com.helloworld;\n+\n+              import static java.lang.Integer.valueOf;\n+\n+              public class SameMethodNameImported {\n+                  public void avoidCollision() {\n+                      String a = String.valueOf(\"1\");\n+                      int b = valueOf(\"1\");\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4304\")\n+    void sameMethodsNoStaticImport() {\n+        rewriteRun(\n+          spec -> spec.recipes(\n+            new UseStaticImport(\"java.lang.String valueOf(..)\"),\n+            new UseStaticImport(\"java.lang.Integer valueOf(..)\")),\n+          java(\n+            \"\"\"\n+              package com.helloworld;\n+\n+              public class SameMethodNames {\n+                  public void avoidCollision() {\n+                      String a = String.valueOf(\"1\");\n+                      int b = Integer.valueOf(\"1\");\n+                  }\n+              }\n+              \"\"\",\n             \"\"\"\n+              package com.helloworld;\n+\n+              import static java.lang.String.valueOf;\n+\n+              public class SameMethodNames {\n+                  public void avoidCollision() {\n+                      String a = valueOf(\"1\");\n+                      int b = Integer.valueOf(\"1\");\n+                  }\n+              }\n+              \"\"\"\n           )\n         );\n     }\n@@ -117,26 +175,26 @@ void doReplaceWhenWildcard() {\n           spec -> spec.recipe(new UseStaticImport(\"java.util.Collections *()\")),\n           java(\n             \"\"\"\n-            import java.util.Collections;\n-            import java.util.List;\n-\n-            class SameMethodNameLocally {\n-                void avoidCollision() {\n-                    List<Object> list = Collections.emptyList();\n-                }\n-            }\n-            \"\"\",\n-            \"\"\"\n-            import java.util.List;\n-            \n-            import static java.util.Collections.emptyList;\n-\n-            class SameMethodNameLocally {\n-                void avoidCollision() {\n-                    List<Object> list = emptyList();\n-                }\n-            }\n+              import java.util.Collections;\n+              import java.util.List;\n+\n+              class SameMethodNameLocally {\n+                  void avoidCollision() {\n+                      List<Object> list = Collections.emptyList();\n+                  }\n+              }\n+              \"\"\",\n             \"\"\"\n+              import java.util.List;\n+\n+              import static java.util.Collections.emptyList;\n+\n+              class SameMethodNameLocally {\n+                  void avoidCollision() {\n+                      List<Object> list = emptyList();\n+                  }\n+              }\n+              \"\"\"\n           )\n         );\n     }\n@@ -186,33 +244,33 @@ void javadocLinkUnchanged() {\n           spec -> spec.recipe(new UseStaticImport(\"java.util.Collections emptyList()\")),\n           java(\n             \"\"\"\n-            import java.util.Collections;\n-            import java.util.List;\n-\n-            public class WithJavadoc {\n-                /**\n-                 * This method uses {@link Collections#emptyList()}.\n-                 */\n-                public void mustNotChangeTheJavadocAbove() {\n-                    List<Object> list = Collections.emptyList();\n-                }\n-            }\n-            \"\"\",\n-            \"\"\"\n-            import java.util.Collections;\n-            import java.util.List;\n-\n-            import static java.util.Collections.emptyList;\n-\n-            public class WithJavadoc {\n-                /**\n-                 * This method uses {@link Collections#emptyList()}.\n-                 */\n-                public void mustNotChangeTheJavadocAbove() {\n-                    List<Object> list = emptyList();\n-                }\n-            }\n+              import java.util.Collections;\n+              import java.util.List;\n+\n+              public class WithJavadoc {\n+                  /**\n+                   * This method uses {@link Collections#emptyList()}.\n+                   */\n+                  public void mustNotChangeTheJavadocAbove() {\n+                      List<Object> list = Collections.emptyList();\n+                  }\n+              }\n+              \"\"\",\n             \"\"\"\n+              import java.util.Collections;\n+              import java.util.List;\n+\n+              import static java.util.Collections.emptyList;\n+\n+              public class WithJavadoc {\n+                  /**\n+                   * This method uses {@link Collections#emptyList()}.\n+                   */\n+                  public void mustNotChangeTheJavadocAbove() {\n+                      List<Object> list = emptyList();\n+                  }\n+              }\n+              \"\"\"\n           )\n         );\n     }\n\ndiff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/search/MaybeUsesImportTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/search/MaybeUsesImportTest.java\nindex 85864b13a61..b75aebcc7ba 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/search/MaybeUsesImportTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/search/MaybeUsesImportTest.java\n@@ -27,8 +27,7 @@ class MaybeUsesImportTest implements RewriteTest {\n     @Test\n     void usesType() {\n         rewriteRun(\n-          spec -> spec.recipe(toRecipe(() -> new\n-            MaybeUsesImport<>(\"java.util.Collections\"))),\n+          spec -> spec.recipe(toRecipe(() -> new MaybeUsesImport<>(\"java.util.Collections\"))),\n           java(\n             \"\"\"\n               import java.io.File;\n@@ -40,7 +39,7 @@ void usesType() {\n               import static java.util.Collections.singleton;\n               import static java.util.Collections.*;\n               import java.util.Map;\n-                              \n+\n               class Test {\n               }\n               \"\"\",\n@@ -54,7 +53,7 @@ class Test {\n               /*~~>*/import static java.util.Collections.singleton;\n               /*~~>*/import static java.util.Collections.*;\n               import java.util.Map;\n-                              \n+\n               class Test {\n               }\n               \"\"\"\n@@ -80,7 +79,7 @@ void usesTypeWildcard() {\n               import static java.util.Collections.singleton;\n               import static java.util.Collections.*;\n               import java.util.concurrent.ConcurrentHashMap;\n-                            \n+\n               class Test {\n               }\n               \"\"\",\n@@ -94,7 +93,7 @@ class Test {\n               /*~~>*/import static java.util.Collections.singleton;\n               /*~~>*/import static java.util.Collections.*;\n               /*~~>*/import java.util.concurrent.ConcurrentHashMap;\n-                            \n+\n               class Test {\n               }\n               \"\"\"\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4296",
    "pr_id": 4296,
    "issue_id": 4244,
    "repo": "openrewrite/rewrite",
    "problem_statement": "org.openrewrite.java.RemoveObjectsIsNull fails on negated expressions\n## What version of OpenRewrite are you using?\r\n\r\n- org.openrewrite:rewrite-core:jar:8.27.4\r\n- org.openrewrite.recipe:rewrite-migrate-java:jar:2.17.0\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n\r\n```java\r\nimport org.junit.jupiter.api.Test;\r\nimport org.openrewrite.java.JavaParser;\r\nimport org.openrewrite.java.RemoveObjectsIsNull;\r\nimport org.openrewrite.test.RecipeSpec;\r\nimport org.openrewrite.test.RewriteTest;\r\n\r\nimport static org.openrewrite.java.Assertions.java;\r\n\r\npublic class KnownBugsTest implements RewriteTest {\r\n\r\n  @Override\r\n  public void defaults(RecipeSpec spec) {\r\n    spec.recipe(new RemoveObjectsIsNull()).parser(JavaParser.fromJavaVersion());\r\n  }\r\n\r\n  @Test\r\n  public void negatedRemoveObjectsIsNull() {\r\n    rewriteRun(\r\n        java(\r\n            \"\"\"\r\n            package com.helloworld;\r\n            \r\n            import java.util.Objects;\r\n\r\n            class Hello {\r\n              public boolean hello(String abc) {\r\n                return !Objects.isNull(abc);\r\n              }\r\n            }\r\n            \"\"\",\r\n            // \"!abc == null\" is not a valid expression\r\n            \"\"\"\r\n            package com.helloworld;\r\n\r\n            class Hello {\r\n              public boolean hello(String abc) {\r\n                return abc != null;\r\n              }\r\n            }\r\n            \"\"\"));\r\n  }\r\n}\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\nYes, possibly. Reporting this in the meantime.\r\n",
    "issue_word_count": 166,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/RemoveObjectsIsNullTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/RemoveObjectsIsNull.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/RemoveObjectsIsNullTest.java"
    ],
    "base_commit": "aabbcde9140719ea646e18ce213b7e7468656c1e",
    "head_commit": "7cd2991b2d77d98df615d850faa42eca61427e60",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4296",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4296",
    "dockerfile": "",
    "pr_merged_at": "2024-07-05T08:25:15.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/RemoveObjectsIsNull.java b/rewrite-java/src/main/java/org/openrewrite/java/RemoveObjectsIsNull.java\nindex 631067d1187..ae007a8ec05 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/RemoveObjectsIsNull.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/RemoveObjectsIsNull.java\n@@ -16,6 +16,7 @@\n package org.openrewrite.java;\n \n import org.openrewrite.*;\n+import org.openrewrite.java.cleanup.SimplifyBooleanExpressionVisitor;\n import org.openrewrite.java.cleanup.UnnecessaryParenthesesVisitor;\n import org.openrewrite.java.search.UsesMethod;\n import org.openrewrite.java.tree.Expression;\n@@ -65,9 +66,23 @@ private Expression replace(ExecutionContext ctx, J.MethodInvocation m, String pa\n                 }\n \n                 // Replace the method invocation with a simple null check\n-                Expression e = m.getArguments().get(0);\n-                Expression replaced = JavaTemplate.apply(pattern, getCursor(), m.getCoordinates().replace(), e);\n-                return (Expression) new UnnecessaryParenthesesVisitor<>().visitNonNull(replaced, ctx, getCursor());\n+                Cursor parentTreeCursor = getCursor().getParentTreeCursor();\n+                if (!(parentTreeCursor.getValue() instanceof J.ControlParentheses) &&\n+                    !(parentTreeCursor.getValue() instanceof J.Parentheses)) {\n+                    pattern = '(' + pattern + ')';\n+                }\n+                parentTreeCursor.putMessage(\"SIMPLIFY_BOOLEAN_EXPRESSION\", true);\n+                Expression replaced = JavaTemplate.apply(pattern, getCursor(), m.getCoordinates().replace(), m.getArguments().get(0));\n+                return (Expression) new UnnecessaryParenthesesVisitor<>().visitNonNull(replaced, ctx);\n+            }\n+\n+            @Override\n+            public J postVisit(J tree, ExecutionContext ctx) {\n+                J j = super.postVisit(tree, ctx);\n+                if (Boolean.TRUE.equals(getCursor().pollMessage(\"SIMPLIFY_BOOLEAN_EXPRESSION\"))) {\n+                    return new SimplifyBooleanExpressionVisitor().visit(j, ctx, getCursor().getParentOrThrow());\n+                }\n+                return j;\n             }\n         });\n     }\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveObjectsIsNullTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveObjectsIsNullTest.java\nindex 21d58247cf7..46523176d54 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveObjectsIsNullTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveObjectsIsNullTest.java\n@@ -166,4 +166,68 @@ public void test(boolean a) {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4244\")\n+    void negatedCallToIsNull() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+            package com.helloworld;\n+            \n+            import java.util.Objects;\n+\n+            class Hello {\n+              public boolean hello(String abc) {\n+                return !Objects.isNull(abc);\n+              }\n+            }\n+            \"\"\",\n+            // \"!abc == null\" is not a valid expression\n+            \"\"\"\n+            package com.helloworld;\n+\n+            class Hello {\n+              public boolean hello(String abc) {\n+                return abc != null;\n+              }\n+            }\n+            \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4244\")\n+    void comparisonOfCallToFalse() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+            package com.helloworld;\n+            \n+            import java.util.Objects;\n+\n+            class Hello {\n+              public boolean hello(String abc) {\n+                if (Objects.isNull(abc) == false) {\n+                  return;\n+                }\n+              }\n+            }\n+            \"\"\",\n+            // \"!abc == null\" is not a valid expression\n+            \"\"\"\n+            package com.helloworld;\n+\n+            class Hello {\n+              public boolean hello(String abc) {\n+                if (!(abc == null)) {\n+                  return;\n+                }\n+              }\n+            }\n+            \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4289",
    "pr_id": 4289,
    "issue_id": 4239,
    "repo": "openrewrite/rewrite",
    "problem_statement": "\"Add Maven Parent\" recipe\n<!--\r\nThank you for suggesting an improvement to OpenRewrite!\r\nFeel free to delete any sections that don't apply to your request.\r\n-->\r\n## What problem are you trying to solve?\r\nI need to add a parent POM to my projects. \r\n\r\n## Describe the solution you'd like\r\nI'd like a recipe for that as there already has one for changing the Maven parent.\r\n\r\n## Have you considered any alternatives or workarounds?\r\nUsing text recipe\r\n\r\n## Additional context\r\n<!-- Any thoughts that come to mind, or similar items on the backlog already. -->\r\n\r\n## Are you interested in [contributing this feature to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#new-features)?\r\nI can try :)\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->",
    "issue_word_count": 134,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/AddParentPom.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/AddParentPomTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/AddParentPomTest.java"
    ],
    "base_commit": "145ff7bbbb01f27426dcce30efc62eeeb5fc6c4d",
    "head_commit": "d5d643326c00cdfebe5ed8395e302fbb245ed65f",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4289",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4289",
    "dockerfile": "",
    "pr_merged_at": "2024-07-03T09:03:47.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/AddParentPom.java b/rewrite-maven/src/main/java/org/openrewrite/maven/AddParentPom.java\nnew file mode 100644\nindex 00000000000..d495affc70f\n--- /dev/null\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/AddParentPom.java\n@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.maven;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.Value;\n+import org.openrewrite.*;\n+import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.internal.lang.Nullable;\n+import org.openrewrite.marker.SearchResult;\n+import org.openrewrite.maven.table.MavenMetadataFailures;\n+import org.openrewrite.maven.tree.MavenMetadata;\n+import org.openrewrite.maven.tree.MavenRepository;\n+import org.openrewrite.semver.Semver;\n+import org.openrewrite.semver.VersionComparator;\n+import org.openrewrite.xml.AddToTagVisitor;\n+import org.openrewrite.xml.tree.Xml;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+@Value\n+@EqualsAndHashCode(callSuper = false)\n+public class AddParentPom extends Recipe {\n+    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);\n+\n+    @Option(displayName = \"Group ID\",\n+            description = \"The group ID of the maven parent pom to be adopted.\",\n+            example = \"org.springframework.boot\")\n+    String groupId;\n+\n+    @Option(displayName = \"Artifact ID\",\n+            description = \"The artifact ID of the maven parent pom to be adopted.\",\n+            example = \"spring-boot-starter-parent\")\n+    String artifactId;\n+\n+    @Option(displayName = \"Version\",\n+            description = \"An exact version number or node-style semver selector used to select the version number.\",\n+            example = \"29.X\")\n+    String version;\n+\n+    @Option(displayName = \"Relative path\",\n+            description = \"New relative path attribute for parent lookup.\",\n+            example = \"../pom.xml\")\n+    @Nullable\n+    String relativePath;\n+\n+    @Option(displayName = \"Version pattern\",\n+            description = \"Allows version selection to be extended beyond the original Node Semver semantics. So for example,\" +\n+                          \"Setting 'version' to \\\"25-29\\\" can be paired with a metadata pattern of \\\"-jre\\\" to select Guava 29.0-jre\",\n+            example = \"-jre\",\n+            required = false)\n+    @Nullable\n+    String versionPattern;\n+\n+    @Override\n+    public String getDisplayName() {\n+        return \"Add Maven parent\";\n+    }\n+\n+    @Override\n+    public String getInstanceNameSuffix() {\n+        return String.format(\"`%s:%s:%s`\", groupId, artifactId, version);\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"Add a parent pom to a Maven pom.xml. Does nothing if a parent pom is already present.\";\n+    }\n+\n+    @Override\n+    public Validated<Object> validate() {\n+        Validated<Object> validated = super.validate();\n+        //noinspection ConstantConditions\n+        if (version != null) {\n+            validated = validated.and(Semver.validate(version, versionPattern));\n+        }\n+        return validated;\n+    }\n+\n+    @Override\n+    public TreeVisitor<?, ExecutionContext> getVisitor() {\n+        return Preconditions.check(new MavenVisitor<ExecutionContext>() {\n+            @Override\n+            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {\n+                Xml.Tag root = document.getRoot();\n+                if (!root.getChild(\"parent\").isPresent()) {\n+                    return SearchResult.found(document);\n+                }\n+                return document;\n+\n+            }\n+        }, new MavenIsoVisitor<ExecutionContext>() {\n+            @Nullable\n+            private Collection<String> availableVersions;\n+\n+            @Override\n+            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {\n+                Xml.Tag root = document.getRoot();\n+                assert !root.getChild(\"parent\").isPresent();\n+\n+                try {\n+                    Optional<String> targetVersion = findAcceptableVersion(groupId, artifactId, ctx);\n+                    if (targetVersion.isPresent()) {\n+                        Xml.Tag parentTag = Xml.Tag.build(\n+                                \"<parent>\\n\" +\n+                                \"<groupId>\" + groupId + \"</groupId>\\n\" +\n+                                \"<artifactId>\" + artifactId + \"</artifactId>\\n\" +\n+                                \"<version>\" + targetVersion.get() + \"</version>\\n\" +\n+                                (relativePath == null ? \"\" : StringUtils.isBlank(relativePath) ?\n+                                        \"<relativePath/>\" : \"<relativePath>\" + relativePath + \"</relativePath>\") +\n+                                \"</parent>\");\n+\n+                        document = (Xml.Document) new AddToTagVisitor<>(root, parentTag, new MavenTagInsertionComparator(root.getChildren()))\n+                                .visitNonNull(document, ctx, getCursor().getParentOrThrow());\n+\n+                        maybeUpdateModel();\n+                        doAfterVisit(new RemoveRedundantDependencyVersions(null, null,\n+                                RemoveRedundantDependencyVersions.Comparator.GTE, null).getVisitor());\n+                    }\n+                } catch (MavenDownloadingException e) {\n+                    for (Map.Entry<MavenRepository, String> repositoryResponse : e.getRepositoryResponses().entrySet()) {\n+                        MavenRepository repository = repositoryResponse.getKey();\n+                        metadataFailures.insertRow(ctx, new MavenMetadataFailures.Row(groupId, artifactId, version,\n+                                repository.getUri(), repository.getSnapshots(), repository.getReleases(), repositoryResponse.getValue()));\n+                    }\n+                    return e.warn(document);\n+                }\n+\n+                return super.visitDocument(document, ctx);\n+            }\n+\n+            private final VersionComparator versionComparator = Objects.requireNonNull(Semver.validate(version, versionPattern).getValue());\n+\n+            private Optional<String> findAcceptableVersion(String groupId, String artifactId, ExecutionContext ctx)\n+                    throws MavenDownloadingException {\n+                if (availableVersions == null) {\n+                    MavenMetadata mavenMetadata = metadataFailures.insertRows(ctx, () -> downloadMetadata(groupId, artifactId, ctx));\n+                    availableVersions = mavenMetadata.getVersioning().getVersions().stream()\n+                            .filter(v -> versionComparator.isValid(null, v))\n+                            .collect(Collectors.toList());\n+                }\n+                return availableVersions.stream().max(versionComparator);\n+            }\n+        });\n+    }\n+}\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/AddParentPomTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/AddParentPomTest.java\nnew file mode 100644\nindex 00000000000..a2575e1e656\n--- /dev/null\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/AddParentPomTest.java\n@@ -0,0 +1,475 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.maven;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.openrewrite.DocumentExample;\n+import org.openrewrite.test.RewriteTest;\n+\n+import static org.openrewrite.java.Assertions.mavenProject;\n+import static org.openrewrite.maven.Assertions.pomXml;\n+\n+class AddParentPomTest implements RewriteTest {\n+\n+    @DocumentExample\n+    @Test\n+    void addParent() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddParentPom(\n+            \"org.springframework.boot\",\n+            \"spring-boot-starter-parent\",\n+            \"1.5.12.RELEASE\",\n+            null,\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                <parent>\n+                  <groupId>org.springframework.boot</groupId>\n+                  <artifactId>spring-boot-starter-parent</artifactId>\n+                  <version>1.5.12.RELEASE</version>\n+                </parent>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+      \"1.5.99.RELEASE\",\n+      \"~1.9\"\n+    })\n+    void shoudNotAddInvalidParentPomVersion(String version) {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddParentPom(\n+            \"org.springframework.boot\",\n+            \"spring-boot-starter-parent\",\n+            version,\n+            null,\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addParentWithRelativePath() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddParentPom(\n+            \"org.springframework.boot\",\n+            \"spring-boot-starter-parent\",\n+            \"1.5.12.RELEASE\",\n+            \"../../pom.xml\",\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                <parent>\n+                  <groupId>org.springframework.boot</groupId>\n+                  <artifactId>spring-boot-starter-parent</artifactId>\n+                  <version>1.5.12.RELEASE</version>\n+                  <relativePath>../../pom.xml</relativePath>\n+                </parent>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void addParentWithRelativePathEmptyValue() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddParentPom(\n+            \"org.springframework.boot\",\n+            \"spring-boot-starter-parent\",\n+            \"1.5.12.RELEASE\",\n+            \"\",\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                <parent>\n+                  <groupId>org.springframework.boot</groupId>\n+                  <artifactId>spring-boot-starter-parent</artifactId>\n+                  <version>1.5.12.RELEASE</version>\n+                  <relativePath/>\n+                </parent>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void multiModuleRelativePath() {\n+        AddParentPom recipe = new AddParentPom(\"org.springframework.boot\", \"spring-boot-starter-parent\", \"1.5.12.RELEASE\", \"\", null);\n+        rewriteRun(\n+          spec -> spec.recipe(recipe),\n+          mavenProject(\"parent\",\n+            pomXml(\n+              \"\"\"\n+                <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>org.sample</groupId>\n+                  <artifactId>sample</artifactId>\n+                  <version>1.0.0</version>\n+\n+                  <modules>\n+                    <module>module1</module>\n+                    <module>module2</module>\n+                  </modules>\n+                </project>\n+                \"\"\",\n+              \"\"\"\n+                <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <parent>\n+                    <groupId>org.springframework.boot</groupId>\n+                    <artifactId>spring-boot-starter-parent</artifactId>\n+                    <version>1.5.12.RELEASE</version>\n+                    <relativePath/>\n+                  </parent>\n+                  <groupId>org.sample</groupId>\n+                  <artifactId>sample</artifactId>\n+                  <version>1.0.0</version>\n+\n+                  <modules>\n+                    <module>module1</module>\n+                    <module>module2</module>\n+                  </modules>\n+                </project>\n+                \"\"\"\n+            ),\n+            mavenProject(\"module1\",\n+              pomXml(\n+                \"\"\"\n+                  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                    <modelVersion>4.0.0</modelVersion>\n+                    <parent>\n+                      <groupId>org.sample</groupId>\n+                      <artifactId>sample</artifactId>\n+                      <version>1.0.0</version>\n+                    </parent>\n+                    <artifactId>module1</artifactId>\n+                  </project>\n+                  \"\"\"\n+              )),\n+            mavenProject(\"module2\",\n+              pomXml(\n+                \"\"\"\n+                  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                    <modelVersion>4.0.0</modelVersion>\n+                    <parent>\n+                      <groupId>org.sample</groupId>\n+                      <artifactId>sample</artifactId>\n+                      <version>1.0.0</version>\n+                    </parent>\n+                    <artifactId>module2</artifactId>\n+                  </project>\n+                  \"\"\"\n+              )\n+            )\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void multiModuleShouldOnlyChangeRoot() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddParentPom(\n+            \"org.springframework.boot\",\n+            \"spring-boot-starter-parent\",\n+            \"1.5.12.RELEASE\",\n+            null, null)),\n+          mavenProject(\"parent\",\n+            pomXml(\n+              \"\"\"\n+                <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>org.sample</groupId>\n+                  <artifactId>sample</artifactId>\n+                  <version>1.0.0</version>\n+\n+                  <modules>\n+                    <module>module1</module>\n+                    <module>module2</module>\n+                  </modules>\n+                </project>\n+                \"\"\",\n+              \"\"\"\n+                <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <parent>\n+                    <groupId>org.springframework.boot</groupId>\n+                    <artifactId>spring-boot-starter-parent</artifactId>\n+                    <version>1.5.12.RELEASE</version>\n+                  </parent>\n+                  <groupId>org.sample</groupId>\n+                  <artifactId>sample</artifactId>\n+                  <version>1.0.0</version>\n+\n+                  <modules>\n+                    <module>module1</module>\n+                    <module>module2</module>\n+                  </modules>\n+                </project>\n+                \"\"\"\n+            ),\n+            mavenProject(\"module1\",\n+              pomXml(\n+                \"\"\"\n+                  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                    <modelVersion>4.0.0</modelVersion>\n+                    <parent>\n+                      <groupId>org.sample</groupId>\n+                      <artifactId>sample</artifactId>\n+                      <version>1.0.0</version>\n+                    </parent>\n+                    <artifactId>module1</artifactId>\n+                  </project>\n+                  \"\"\"\n+              )),\n+            mavenProject(\"module2\",\n+              pomXml(\n+                \"\"\"\n+                  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+                  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                    <modelVersion>4.0.0</modelVersion>\n+                    <parent>\n+                      <groupId>org.sample</groupId>\n+                      <artifactId>sample</artifactId>\n+                      <version>1.0.0</version>\n+                    </parent>\n+                    <artifactId>module2</artifactId>\n+                  </project>\n+                  \"\"\"\n+              )\n+            )\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void shouldResolveWildcardVersion() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddParentPom(\n+            \"org.springframework.boot\",\n+            \"spring-boot-starter-parent\",\n+            \"~1.5\",\n+            null,\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                <parent>\n+                  <groupId>org.springframework.boot</groupId>\n+                  <artifactId>spring-boot-starter-parent</artifactId>\n+                  <version>1.5.22.RELEASE</version>\n+                </parent>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void removesRedundantExplicitVersionsMatchingNewParent() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddParentPom(\n+            \"org.junit\",\n+            \"junit-bom\",\n+            \"5.9.1\",\n+            \"\",\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.junit.jupiter</groupId>\n+                    <artifactId>junit-jupiter-api</artifactId>\n+                    <version>5.9.1</version>\n+                  </dependency>\n+                </dependencies>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                <parent>\n+                  <groupId>org.junit</groupId>\n+                  <artifactId>junit-bom</artifactId>\n+                  <version>5.9.1</version>\n+                  <relativePath/>\n+                </parent>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.junit.jupiter</groupId>\n+                    <artifactId>junit-jupiter-api</artifactId>\n+                  </dependency>\n+                </dependencies>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void takesNewVersionFromParent() {\n+        rewriteRun(\n+          spec -> spec.recipe(new AddParentPom(\n+            \"org.junit\",\n+            \"junit-bom\",\n+            \"5.9.1\",\n+            \"\",\n+            null\n+          )),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.junit.jupiter</groupId>\n+                    <artifactId>junit-jupiter-api</artifactId>\n+                    <version>5.8.0</version>\n+                  </dependency>\n+                </dependencies>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                <modelVersion>4.0.0</modelVersion>\n+                <parent>\n+                  <groupId>org.junit</groupId>\n+                  <artifactId>junit-bom</artifactId>\n+                  <version>5.9.1</version>\n+                  <relativePath/>\n+                </parent>\n+\n+                <groupId>com.mycompany.app</groupId>\n+                <artifactId>my-app</artifactId>\n+                <version>1</version>\n+\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.junit.jupiter</groupId>\n+                    <artifactId>junit-jupiter-api</artifactId>\n+                  </dependency>\n+                </dependencies>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4284",
    "pr_id": 4284,
    "issue_id": 4093,
    "repo": "openrewrite/rewrite",
    "problem_statement": "StackOverflowError on attempt to run against import dependencies\nHi,\r\n\r\nmaven-rewrite-plugin fails with `java.lang.StackOverflowError` when there is a dependency with `import` scope having a parent declaration\r\n`org.openrewrite.maven.tree.ResolvedPom` tries to resolve parent of such dependency, which in turn contains the dependency itself, resulting in circular dependency\r\nOf course, that's a clear problem in target project, but it is ignored by maven during build process so people can easily miss it\r\n\r\n## What version of OpenRewrite are you using?\r\nlatest version of rewrite-maven-plugin (5.25.0)\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\nRun any recipe against a sample project:\r\nhttps://github.com/ZhyliaievD/rewrite-maven-plugin-soe-sample \r\ne.g. sample command to run:\r\n`mvn -U org.openrewrite.maven:rewrite-maven-plugin:run -Drewrite.activeRecipes=org.openrewrite.java.RemoveUnusedImports`\r\n\r\n\r\n<details><summary>OR use the following code snippets to reproduce using the following parent&child poms:</summary>\r\n<p>\r\n\r\nproject structure:\r\n```\r\n/pom.xml.  <-- parent pom\r\n/circular-example-child/pom.xml  <-- child pom\r\n```\r\n\r\nParent pom:\r\n```xml\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <groupId>org.example</groupId>\r\n  <artifactId>circular-example</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n  <packaging>pom</packaging>\r\n\r\n  <name>circular-example</name>\r\n  <url>http://maven.apache.org</url>\r\n\r\n  <modules>\r\n    <module>circular-example-child</module>\r\n  </modules>\r\n\r\n  <properties>\r\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n  </properties>\r\n\r\n  <dependencyManagement>\r\n    <dependencies>\r\n      <dependency>\r\n        <groupId>org.example</groupId>\r\n        <artifactId>circular-example-child</artifactId>\r\n        <version>1.0-SNAPSHOT</version>\r\n        <scope>import</scope>\r\n      </dependency>\r\n    </dependencies>\r\n  </dependencyManagement>\r\n</project>\r\n``` \r\n\r\nchild pom:\r\n```xml\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <parent>\r\n    <groupId>org.example</groupId>\r\n    <artifactId>circular-example</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n  </parent>\r\n\r\n  <artifactId>circular-example-child</artifactId>\r\n  <version>1.0-SNAPSHOT</version>\r\n</project>\r\n```\r\n\r\n</p>\r\n</details> \r\n\r\n\r\n## What did you expect to see?\r\na) plugin taking care of such cases\r\nb) plugin throwing meaningful exception stating about circular dependencies in project\r\n\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\n```java\r\n...\r\n[INFO] Project [circular-example] Resolving Poms...\r\nException in thread \"main\" java.lang.StackOverflowError\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.mergeProperties(ResolvedPom.java:701)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentPropertiesAndRepositoriesRecursively(ResolvedPom.java:388)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentsRecursively(ResolvedPom.java:357)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolve(ResolvedPom.java:346)\r\n        at org.openrewrite.maven.tree.ResolvedPom.resolve(ResolvedPom.java:168)\r\n        at org.openrewrite.maven.tree.Pom.resolve(Pom.java:120)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.mergeDependencyManagement(ResolvedPom.java:725)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentDependenciesRecursively(ResolvedPom.java:423)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentDependenciesRecursively(ResolvedPom.java:441)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentsRecursively(ResolvedPom.java:375)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolve(ResolvedPom.java:346)\r\n        at org.openrewrite.maven.tree.ResolvedPom.resolve(ResolvedPom.java:168)\r\n        at org.openrewrite.maven.tree.Pom.resolve(Pom.java:120)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.mergeDependencyManagement(ResolvedPom.java:725)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentDependenciesRecursively(ResolvedPom.java:423)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentDependenciesRecursively(ResolvedPom.java:441)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentsRecursively(ResolvedPom.java:375)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolve(ResolvedPom.java:346)\r\n        at org.openrewrite.maven.tree.ResolvedPom.resolve(ResolvedPom.java:168)\r\n        at org.openrewrite.maven.tree.Pom.resolve(Pom.java:120)\r\n        ........\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.mergeDependencyManagement(ResolvedPom.java:725)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentDependenciesRecursively(ResolvedPom.java:423)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentDependenciesRecursively(ResolvedPom.java:441)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentsRecursively(ResolvedPom.java:375)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolve(ResolvedPom.java:346)\r\n        at org.openrewrite.maven.tree.ResolvedPom.resolve(ResolvedPom.java:168)\r\n        at org.openrewrite.maven.tree.Pom.resolve(Pom.java:120)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.mergeDependencyManagement(ResolvedPom.java:725)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentDependenciesRecursively(ResolvedPom.java:423)\r\n        at org.openrewrite.maven.tree.ResolvedPom$Resolver.resolveParentDependenciesRecursively(ResolvedPom.java:441)\r\n```\r\n",
    "issue_word_count": 742,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java"
    ],
    "base_commit": "104e0b6a0a96180ca4de100574ff77a295e2fcea",
    "head_commit": "481c9b20d4a85a91e38a1b68665744f9aa73f58c",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4284",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4284",
    "dockerfile": "",
    "pr_merged_at": "2024-07-01T06:26:49.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\nindex a351c9bf890..008da3f933b 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\n@@ -22,7 +22,10 @@\n import com.fasterxml.jackson.databind.node.ArrayNode;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n-import lombok.*;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Value;\n+import lombok.With;\n import lombok.experimental.NonFinal;\n import org.openrewrite.ExecutionContext;\n import org.openrewrite.internal.ListUtils;\n@@ -156,7 +159,7 @@ private static class UniqueDependencyKey {\n     @SuppressWarnings(\"DuplicatedCode\")\n     public ResolvedPom resolve(ExecutionContext ctx, MavenPomDownloader downloader) throws MavenDownloadingException {\n         // If this resolved pom represents an obsolete pom format, refuse to resolve in same as Maven itself would\n-        if(requested.getObsoletePomVersion() != null) {\n+        if (requested.getObsoletePomVersion() != null) {\n             return this;\n         }\n \n@@ -421,12 +424,12 @@ private void resolveParentDependenciesRecursively(List<Pom> pomAncestry) throws\n \n             for (Profile profile : pom.getProfiles()) {\n                 if (profile.isActive(activeProfiles)) {\n-                    mergeDependencyManagement(profile.getDependencyManagement(), pom);\n+                    mergeDependencyManagement(profile.getDependencyManagement(), pomAncestry);\n                     mergeRequestedDependencies(profile.getDependencies());\n                 }\n             }\n \n-            mergeDependencyManagement(pom.getDependencyManagement(), pom);\n+            mergeDependencyManagement(pom.getDependencyManagement(), pomAncestry);\n             mergeRequestedDependencies(pom.getDependencies());\n \n             if (pom.getParent() != null) {\n@@ -768,14 +771,19 @@ private void mergeProperties(Map<String, String> incomingProperties, Pom pom) {\n             }\n         }\n \n-        private void mergeDependencyManagement(List<ManagedDependency> incomingDependencyManagement, Pom pom) throws MavenDownloadingException {\n+        private void mergeDependencyManagement(List<ManagedDependency> incomingDependencyManagement, List<Pom> pomAncestry) throws MavenDownloadingException {\n+            Pom pom = pomAncestry.get(0);\n             if (!incomingDependencyManagement.isEmpty()) {\n                 if (dependencyManagement == null || dependencyManagement.isEmpty()) {\n                     dependencyManagement = new ArrayList<>();\n                 }\n                 for (ManagedDependency d : incomingDependencyManagement) {\n                     if (d instanceof Imported) {\n-                        ResolvedPom bom = downloader.download(getValues(((Imported) d).getGav()), null, ResolvedPom.this, repositories)\n+                        GroupArtifactVersion groupArtifactVersion = getValues(((Imported) d).getGav());\n+                        if (isAlreadyResolved(groupArtifactVersion, pomAncestry)) {\n+                            continue;\n+                        }\n+                        ResolvedPom bom = downloader.download(groupArtifactVersion, null, ResolvedPom.this, repositories)\n                                 .resolve(activeProfiles, downloader, initialRepositories, ctx);\n                         MavenExecutionContextView.view(ctx)\n                                 .getResolutionListener()\n@@ -802,6 +810,19 @@ private void mergeDependencyManagement(List<ManagedDependency> incomingDependenc\n                 }\n             }\n         }\n+\n+        private boolean isAlreadyResolved(GroupArtifactVersion groupArtifactVersion, List<Pom> pomAncestry) {\n+            for (int i = 1; i < pomAncestry.size(); i++) { // skip current pom\n+                Pom pom = pomAncestry.get(i);\n+                ResolvedGroupArtifactVersion alreadyResolvedGav = pom.getGav();\n+                if (alreadyResolvedGav.getGroupId().equals(groupArtifactVersion.getGroupId())\n+                    && alreadyResolvedGav.getArtifactId().equals(groupArtifactVersion.getArtifactId())\n+                    && alreadyResolvedGav.getVersion().equals(groupArtifactVersion.getVersion())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n     }\n \n     public List<ResolvedDependency> resolveDependencies(Scope scope, MavenPomDownloader downloader, ExecutionContext ctx) throws MavenDownloadingExceptions {\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\nindex 26763316dd8..05d37789d11 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\n@@ -3038,4 +3038,73 @@ void runtimeClasspathOnly() {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4093\")\n+    void circularImportDependency() {\n+        rewriteRun(\n+          mavenProject(\"root\",\n+            pomXml(\n+              \"\"\"\n+                <project>\n+                  <groupId>com.example</groupId>\n+                  <artifactId>circular-example-parent</artifactId>\n+                  <version>0.0.1-SNAPSHOT</version>\n+                  <modules>\n+                    <module>circular-example-child</module>\n+                  </modules>\n+                  <dependencyManagement>\n+                    <dependencies>\n+                      <dependency>\n+                        <groupId>com.example</groupId>\n+                        <artifactId>circular-example-child</artifactId>\n+                        <version>0.0.1-SNAPSHOT</version>\n+                        <scope>import</scope>\n+                      </dependency>\n+                    </dependencies>\n+                  </dependencyManagement>\n+                </project>\n+                \"\"\",\n+              spec -> spec.afterRecipe(pomXml -> {\n+                  MavenResolutionResult resolution = pomXml.getMarkers().findFirst(MavenResolutionResult.class).orElseThrow();\n+                  GroupArtifactVersion gav = resolution.getPom().getDependencyManagement().get(0).getGav();\n+                  assertThat(gav.getGroupId()).isEqualTo(\"junit\");\n+                  assertThat(gav.getArtifactId()).isEqualTo(\"junit\");\n+                  assertThat(gav.getVersion()).isEqualTo(\"4.13.2\");\n+              })\n+            ),\n+            mavenProject(\"circular-example-child\",\n+              pomXml(\n+                \"\"\"\n+                  <project>\n+                    <parent>\n+                      <groupId>com.example</groupId>\n+                      <artifactId>circular-example-parent</artifactId>\n+                      <version>0.0.1-SNAPSHOT</version>\n+                    </parent>\n+                    <artifactId>circular-example-child</artifactId>\n+                    <version>0.0.1-SNAPSHOT</version>\n+                    <dependencyManagement>\n+                      <dependencies>\n+                        <dependency>\n+                          <groupId>junit</groupId>\n+                          <artifactId>junit</artifactId>\n+                          <version>4.13.2</version>\n+                        </dependency>\n+                      </dependencies>\n+                    </dependencyManagement>\n+                  </project>\n+                  \"\"\",\n+                spec -> spec.afterRecipe(pomXml -> {\n+                    MavenResolutionResult resolution = pomXml.getMarkers().findFirst(MavenResolutionResult.class).orElseThrow();\n+                    GroupArtifactVersion gav = resolution.getPom().getDependencyManagement().get(0).getGav();\n+                    assertThat(gav.getGroupId()).isEqualTo(\"junit\");\n+                    assertThat(gav.getArtifactId()).isEqualTo(\"junit\");\n+                    assertThat(gav.getVersion()).isEqualTo(\"4.13.2\");\n+                })\n+              )\n+            )\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4276",
    "pr_id": 4276,
    "issue_id": 4275,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ClassCastException in UpgradeDependencyVersion\n## What version of OpenRewrite are you using?\r\nI am using moderne / latest cli\r\n\r\n## How are you running OpenRewrite?\r\nModerne\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n```groovy\r\nplugins {\r\n    id 'java'\r\n}\r\nrepositories {\r\n    mavenCentral()\r\n}\r\ndependencies {\r\n    //Although this one does not belong here, the method invocation with \"true\" is a boolean J.Literal.\r\n    jar {\r\n       enabled(true)\r\n    }\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\nThis line should be ignored as it is not really a dependency configuration. Since it is inside the dependencies block, `isLikelyDependencyConfiguration` will result in true, hence the visitMethodInvocation will be called for that method. \r\n\r\n## What did you see instead?\r\nClassCastException when arg is an instance of J.Literal\r\n<img width=\"750\" alt=\"Screenshot 2024-06-20 at 21 56 01\" src=\"https://github.com/openrewrite/rewrite/assets/25441280/b4c36fea-3384-424b-b144-688af18caa32\">\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n```\r\n# Error:\r\nallowInsecureProtocol(true)\r\n\r\n# Message:\r\nclass java.lang.Boolean cannot be cast to class java.lang.String (java.lang.Boolean and java.lang.String are in module java.base of loader 'bootstrap')\r\n\r\n# Detail:\r\njava.lang.ClassCastException: class java.lang.Boolean cannot be cast to class java.lang.String (java.lang.Boolean and java.lang.String are in module java.base of loader 'bootstrap')\r\norg.openrewrite.gradle.UpgradeDependencyVersion$UpdateGroovy.lambda$updateDependency$8(UpgradeDependencyVersion.java:438)\r\norg.openrewrite.internal.ListUtils.map(ListUtils.java:176)\r\norg.openrewrite.gradle.UpgradeDependencyVersion$UpdateGroovy.updateDependency(UpgradeDependencyVersion.java:409)\r\norg.openrewrite.gradle.UpgradeDependencyVersion$UpdateGroovy.visitMethodInvocation(UpgradeDependencyVersion.java:397)\r\norg.openrewrite.gradle.UpgradeDependencyVersion$UpdateGroovy.visitMethodInvocation(UpgradeDependencyVersion.java:350)\r\norg.openrewrite.java.tree.J$MethodInvocation.acceptJava(J.java:3945)\r\norg.openrewrite.java.tree.J.accept(J.java:59)\r\norg.openrewrite.TreeVisitor.visit(TreeVisitor.java:250)\r\norg.openrewrite.TreeVisitor.visitAndCast(TreeVisitor.java:324)\r\norg.openrewrite.java.JavaVisitor.visitRightPadded(JavaVisitor.java:1369)\r\norg.openrewrite.java.JavaVisitor.lambda$visitBlock$4(JavaVisitor.java:401)\r\norg.openrewrite.internal.ListUtils.map(ListUtils.java:176)\r\norg.openrewrite.java.JavaVisitor.visitBlock(JavaVisitor.java:400)\r\norg.openrewrite.java.tree.J$Block.acceptJava(J.java:841)\r\norg.openrewrite.java.tree.J.accept(J.java:59)\r\norg.openrewrite.TreeVisitor.visit(TreeVisitor.java:250)\r\n...\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\nFix is ready locally.\r\n",
    "issue_word_count": 374,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java"
    ],
    "base_commit": "22ac272d0a37fe1023af153ec68aef3ab7926849",
    "head_commit": "ba6db7a9766121cc9003cf865da760eec571b122",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4276",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4276",
    "dockerfile": "",
    "pr_merged_at": "2024-06-20T20:13:20.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java\nindex 737e767abac..91159ede86f 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeDependencyVersion.java\n@@ -435,6 +435,9 @@ private J.MethodInvocation updateDependency(J.MethodInvocation method, Execution\n                     }\n                 } else if (arg instanceof J.Literal) {\n                     J.Literal literal = (J.Literal) arg;\n+                    if (literal.getType() != JavaType.Primitive.String) {\n+                        return arg;\n+                    }\n                     String gav = (String) literal.getValue();\n                     if (gav == null) {\n                         getCursor().putMessage(UPDATE_VERSION_ERROR_KEY, new IllegalStateException(\"Unable to update version\"));\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java\nindex a243296bf5c..4bbc006a4f6 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeDependencyVersionTest.java\n@@ -882,4 +882,29 @@ void unknownConfiguration() {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4275\")\n+    void noActionForNonStringLiterals() {\n+        rewriteRun(\n+          buildGradle(\n+            \"\"\"\n+              plugins {\n+                id 'java'\n+              }\n+              \n+              repositories {\n+                mavenCentral()\n+              }\n+              \n+              dependencies {\n+                implementation(gradleApi())\n+                jar {\n+                  enabled(true)\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4270",
    "pr_id": 4270,
    "issue_id": 4269,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Maven settings with profiles fails to active other profiles from parent activeByDefault\nWe have a `settings.xml` file that has an `activeProfile` specified.  We have many parent pom files that have profiles with `<activeByDefault>true</active>`.  We primarily use this to group sets of managed dependencies.   All of this builds and works fine with Maven; however, it does not with openrewrite.\r\n\r\nMy read of [Maven's doc on activeByDefault](https://maven.apache.org/guides/introduction/introduction-to-profiles.html#explicit-profile-activation) is the activeByDefault=true profiles should be active in poms that do not have a profile with the same id as the active one specified in our `settings.xml`.\r\n\r\n## What version of OpenRewrite are you using?\r\n\r\n- OpenRewrite v8.27.4\r\n- Maven/Gradle plugin v5.33.0\r\n- rewrite module \r\n\r\n## How are you running OpenRewrite?\r\n\r\nMaven plugin + https://github.com/openrewrite/rewrite/blob/main/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n\r\n[TEST PR](https://github.com/openrewrite/rewrite/pull/4270).  If I've misunderstood some of your testing libs, I can give a sample project that will show the problem.\r\n\r\n## What did you expect to see?\r\n\r\nTest to pass (maven dependency versions resolved)\r\n\r\n## What did you see instead?\r\n\r\nFailure to resolve Maven dependency versions\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n\r\nTook a peek, but may bit a bit too extensive for how much time I have...\r\n\r\n",
    "issue_word_count": 253,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/tree/Pom.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java"
    ],
    "base_commit": "2d9b7dc13ed296eecd3f292e82235237fc53dae8",
    "head_commit": "2cd90625479c5b399c509cb935738965bd5249e2",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4270",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4270",
    "dockerfile": "",
    "pr_merged_at": "2025-02-05T23:08:34.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Pom.java b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Pom.java\nindex 0c0a94b6f60..ed15900cf03 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Pom.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Pom.java\n@@ -30,11 +30,11 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n-import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n import static java.util.Collections.emptyList;\n import static java.util.Collections.emptyMap;\n+import static java.util.stream.Collectors.toList;\n import static org.openrewrite.internal.ListUtils.concatAll;\n \n /**\n@@ -160,7 +160,27 @@ public List<MavenRepository> getEffectiveRepositories() {\n                     return r;\n                 })\n                 .distinct()\n-                .collect(Collectors.toList());\n+                .collect(toList());\n+    }\n+\n+    /**\n+     * \"[activeByDefault] profile will automatically be active for all builds unless another profile in the same POM is\n+     * activated using one of the previously described methods. All profiles that are active by default are automatically\n+     * deactivated when a profile in the POM is activated on the command line or through its activation config.\"\n+     *\n+     * @param explicitActiveProfiles Any profiles explicitly activated on the command line.\n+     * @return the effective profiles, given the explicitly active profiles, or failing that those active by default.\n+     */\n+    List<Profile> effectiveProfiles(Iterable<String> explicitActiveProfiles) {\n+        List<Profile> pomActivatedProfiles = profiles.stream()\n+                .filter(p -> p.isActive(explicitActiveProfiles))\n+                .collect(toList());\n+        if (!pomActivatedProfiles.isEmpty()) {\n+            return pomActivatedProfiles;\n+        }\n+        return profiles.stream()\n+                .filter(p -> p.getActivation() != null && Boolean.TRUE.equals(p.getActivation().getActiveByDefault()))\n+                .collect(toList());\n     }\n \n     /**\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\nindex 7b9b00721d3..74a9ed59f13 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\n@@ -401,19 +401,17 @@ void resolveParentsRecursively(Pom requested) throws MavenDownloadingException {\n         private void resolveParentPropertiesAndRepositoriesRecursively(List<Pom> pomAncestry) throws MavenDownloadingException {\n             Pom pom = pomAncestry.get(0);\n \n+            List<Profile> effectiveProfiles = pom.effectiveProfiles(activeProfiles);\n+\n             //Resolve properties\n-            for (Profile profile : pom.getProfiles()) {\n-                if (profile.isActive(activeProfiles)) {\n-                    mergeProperties(profile.getProperties(), pom);\n-                }\n+            for (Profile profile : effectiveProfiles) {\n+                mergeProperties(profile.getProperties(), pom);\n             }\n             mergeProperties(pom.getProperties(), pom);\n \n             //Resolve repositories (which may rely on properties ^^^)\n-            for (Profile profile : pom.getProfiles()) {\n-                if (profile.isActive(activeProfiles)) {\n-                    mergeRepositories(profile.getRepositories());\n-                }\n+            for (Profile profile : effectiveProfiles) {\n+                mergeRepositories(profile.getRepositories());\n             }\n             mergeRepositories(pom.getRepositories());\n \n@@ -435,11 +433,11 @@ private void resolveParentPropertiesAndRepositoriesRecursively(List<Pom> pomAnce\n         private void resolveParentDependenciesRecursively(List<Pom> pomAncestry) throws MavenDownloadingException {\n             Pom pom = pomAncestry.get(0);\n \n-            for (Profile profile : pom.getProfiles()) {\n-                if (profile.isActive(activeProfiles)) {\n-                    mergeDependencyManagement(profile.getDependencyManagement(), pomAncestry);\n-                    mergeRequestedDependencies(profile.getDependencies());\n-                }\n+            List<Profile> effectiveProfiles = pom.effectiveProfiles(activeProfiles);\n+\n+            for (Profile profile : effectiveProfiles) {\n+                mergeDependencyManagement(profile.getDependencyManagement(), pomAncestry);\n+                mergeRequestedDependencies(profile.getDependencies());\n             }\n \n             mergeDependencyManagement(pom.getDependencyManagement(), pomAncestry);\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\nindex 3b3367c23ff..fac6866d7a6 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/MavenParserTest.java\n@@ -25,28 +25,32 @@\n import okhttp3.tls.HandshakeCertificates;\n import okhttp3.tls.HeldCertificate;\n import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n-import org.openrewrite.HttpSenderExecutionContextView;\n-import org.openrewrite.InMemoryExecutionContext;\n-import org.openrewrite.Issue;\n-import org.openrewrite.ParseExceptionResult;\n-import org.openrewrite.Parser;\n+import org.junit.jupiter.api.function.Executable;\n+import org.openrewrite.*;\n import org.openrewrite.maven.http.OkHttpSender;\n import org.openrewrite.maven.internal.MavenParsingException;\n import org.openrewrite.maven.tree.*;\n import org.openrewrite.test.RewriteTest;\n import org.openrewrite.test.TypeValidation;\n import org.openrewrite.tree.ParseError;\n+import org.opentest4j.AssertionFailedError;\n \n import java.io.IOException;\n import java.net.InetAddress;\n+import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.util.Base64;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n \n+import static java.util.stream.Collectors.groupingBy;\n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.openrewrite.java.Assertions.mavenProject;\n import static org.openrewrite.maven.Assertions.pomXml;\n \n@@ -1013,7 +1017,7 @@ public MockResponse dispatch(RecordedRequest request) {\n             assertThat(maven.getMarkers().findFirst(MavenResolutionResult.class).orElseThrow().getDependencies().get(Scope.Compile))\n               .hasSize(1)\n               .matches(deps -> deps.get(0).getGroupId().equals(\"com.foo\") &&\n-                               deps.get(0).getArtifactId().equals(\"bar\"));\n+                deps.get(0).getArtifactId().equals(\"bar\"));\n             mockRepo.shutdown();\n         }\n     }\n@@ -1251,6 +1255,322 @@ void indirectBomImportedFromParent() {\n         );\n     }\n \n+    @Nested\n+    class Profiles {\n+\n+        @Issue(\"https://github.com/openrewrite/rewrite/issues/4269\")\n+        @DisplayName(\"activeByDefault=true profiles from a POM should be active \" +\n+          \"unless there is another active profile _from the same POM file_\")\n+        @Test\n+        void activeByDefaultWithoutPomLocalActiveProfile() {\n+            rewriteRun(\n+              mavenProject(\"c\",\n+                pomXml(\n+                  \"\"\"\n+                    <project>\n+                        <modelVersion>4.0.0</modelVersion>\n+                        <groupId>org.openrewrite.maven</groupId>\n+                        <artifactId>parent</artifactId>\n+                        <version>0.1.0-SNAPSHOT</version>\n+                        <packaging>pom</packaging>\n+                        <profiles>\n+                            <profile>\n+                                <id>active-profile-1</id>\n+                                <activation>\n+                                    <activeByDefault>true</activeByDefault>\n+                                </activation>\n+                                <properties>\n+                                    <d.version>0.1.0-SNAPSHOT</d.version>\n+                                </properties>\n+                                <dependencyManagement>\n+                                    <dependencies>\n+                                        <dependency>\n+                                            <groupId>org.openrewrite.maven</groupId>\n+                                            <artifactId>d</artifactId>\n+                                            <version>${d.version}</version>\n+                                        </dependency>\n+                                    </dependencies>\n+                                </dependencyManagement>\n+                            </profile>\n+                            <profile>\n+                                <id>active-profile-2</id>\n+                                <activation>\n+                                    <activeByDefault>true</activeByDefault>\n+                                </activation>\n+                                <properties>\n+                                    <e.version>0.2.0-SNAPSHOT</e.version>\n+                                </properties>\n+                                <dependencyManagement>\n+                                    <dependencies>\n+                                        <dependency>\n+                                            <groupId>org.openrewrite.maven</groupId>\n+                                            <artifactId>e</artifactId>\n+                                            <version>${e.version}</version>\n+                                        </dependency>\n+                                    </dependencies>\n+                                </dependencyManagement>\n+                            </profile>\n+                        </profiles>\n+                    </project>\n+                    \"\"\"\n+                )\n+              ),\n+              mavenProject(\"a\",\n+                pomXml(\n+                  \"\"\"\n+                    <project>\n+                        <parent>\n+                            <groupId>org.openrewrite.maven</groupId>\n+                            <artifactId>parent</artifactId>\n+                            <version>0.1.0-SNAPSHOT</version>\n+                            <relativePath />\n+                        </parent>\n+                        <groupId>org.openrewrite.maven</groupId>\n+                        <artifactId>a</artifactId>\n+                        <dependencies>\n+                            <dependency>\n+                                <groupId>org.openrewrite.maven</groupId>\n+                                <artifactId>d</artifactId>\n+                            </dependency>\n+                            <dependency>\n+                                <groupId>org.openrewrite.maven</groupId>\n+                                <artifactId>e</artifactId>\n+                            </dependency>\n+                        </dependencies>\n+                    </project>\n+                    \"\"\", spec -> {\n+                      spec.afterRecipe(pomXml -> {\n+                          Map<String, List<ResolvedDependency>> deps =\n+                            pomXml.getMarkers()\n+                              .findFirst(MavenResolutionResult.class)\n+                              .orElseThrow()\n+                              .getDependencies()\n+                              .get(Scope.Compile)\n+                              .stream()\n+                              .collect(groupingBy(ResolvedDependency::getArtifactId));\n+\n+                          assertThat(deps)\n+                            .hasEntrySatisfying(\"d\", rds -> assertThat(rds)\n+                              .singleElement().extracting(ResolvedDependency::getVersion).isEqualTo(\"0.1.0-SNAPSHOT\"))\n+                            .hasEntrySatisfying(\"e\", rds -> assertThat(rds)\n+                              .singleElement().extracting(ResolvedDependency::getVersion).isEqualTo(\"0.2.0-SNAPSHOT\"));\n+                      });\n+                  }\n+                )\n+              ),\n+              mavenProject(\"d\",\n+                pomXml(\n+                  \"\"\"\n+                    <project>\n+                        <modelVersion>4.0.0</modelVersion>\n+                        <groupId>org.openrewrite.maven</groupId>\n+                        <artifactId>d</artifactId>\n+                        <version>0.1.0-SNAPSHOT</version>\n+                    </project>\n+                    \"\"\"\n+                )\n+              ),\n+              mavenProject(\"e\",\n+                pomXml(\n+                  \"\"\"\n+                    <project>\n+                        <modelVersion>4.0.0</modelVersion>\n+                        <groupId>org.openrewrite.maven</groupId>\n+                        <artifactId>e</artifactId>\n+                        <version>0.2.0-SNAPSHOT</version>\n+                    </project>\n+                    \"\"\"\n+                )\n+              )\n+            );\n+        }\n+\n+        @Issue(\"https://github.com/openrewrite/rewrite/issues/4269\")\n+        @DisplayName(\"activeByDefault=true profiles from a POM should not be active\" +\n+          \" if there is another active profile _from the same POM file_\")\n+        @Test\n+        void activeByDefaultWithPomLocalActiveProfile() {\n+            expectMavenDownloadingException(\"active-profile-1\");\n+        }\n+\n+        @Issue(\"https://github.com/openrewrite/rewrite/issues/4269\")\n+        @DisplayName(\"activeByDefault=true profiles from a POM should not be active\" +\n+          \" if deactivated from the command-line\")\n+        @Test\n+        @Disabled\n+        void activeByDefaultWithProfileDisabled() {\n+            expectMavenDownloadingException(\"!active-profile-1\");\n+            expectMavenDownloadingException(\"-active-profile-1\");\n+        }\n+\n+        private void expectMavenDownloadingException(final String activeProfile) {\n+            Executable fn = () -> rewriteRun(\n+              recipeSpec -> recipeSpec\n+                .executionContext(MavenExecutionContextView.view(new InMemoryExecutionContext()))\n+                .parser(MavenParser.builder().activeProfiles(activeProfile)),\n+              mavenProject(\"c\",\n+                pomXml(\n+                  \"\"\"\n+                    <project>\n+                        <modelVersion>4.0.0</modelVersion>\n+                        <groupId>org.openrewrite.maven</groupId>\n+                        <artifactId>parent</artifactId>\n+                        <version>0.1.0-SNAPSHOT</version>\n+                        <packaging>pom</packaging>\n+                        <profiles>\n+                            <profile>\n+                                <id>active-profile-1</id>\n+                                <activation>\n+                                    <activeByDefault>true</activeByDefault>\n+                                </activation>\n+                                <properties>\n+                                    <d.version>0.1.0-SNAPSHOT</d.version>\n+                                </properties>\n+                                <dependencyManagement>\n+                                    <dependencies>\n+                                        <dependency>\n+                                            <groupId>org.openrewrite.maven</groupId>\n+                                            <artifactId>d</artifactId>\n+                                            <version>${d.version}</version>\n+                                        </dependency>\n+                                    </dependencies>\n+                                </dependencyManagement>\n+                            </profile>\n+                            <profile>\n+                                <id>active-profile-2</id>\n+                                <activation>\n+                                    <activeByDefault>true</activeByDefault>\n+                                </activation>\n+                                <properties>\n+                                    <e.version>0.2.0-SNAPSHOT</e.version>\n+                                </properties>\n+                                <dependencyManagement>\n+                                    <dependencies>\n+                                        <dependency>\n+                                            <groupId>org.openrewrite.maven</groupId>\n+                                            <artifactId>e</artifactId>\n+                                            <version>${e.version}</version>\n+                                        </dependency>\n+                                    </dependencies>\n+                                </dependencyManagement>\n+                            </profile>\n+                        </profiles>\n+                    </project>\n+                    \"\"\"\n+                )\n+              ),\n+              mavenProject(\"a\",\n+                pomXml(\n+                  \"\"\"\n+                    <project>\n+                        <parent>\n+                            <groupId>org.openrewrite.maven</groupId>\n+                            <artifactId>parent</artifactId>\n+                            <version>0.1.0-SNAPSHOT</version>\n+                            <relativePath />\n+                        </parent>\n+                        <groupId>org.openrewrite.maven</groupId>\n+                        <artifactId>a</artifactId>\n+                        <dependencies>\n+                            <dependency>\n+                                <groupId>org.openrewrite.maven</groupId>\n+                                <artifactId>d</artifactId>\n+                            </dependency>\n+                            <dependency>\n+                                <groupId>org.openrewrite.maven</groupId>\n+                                <artifactId>e</artifactId>\n+                            </dependency>\n+                        </dependencies>\n+                    </project>\n+                    \"\"\"\n+                )\n+              ),\n+              mavenProject(\"d\",\n+                pomXml(\n+                  \"\"\"\n+                    <project>\n+                        <modelVersion>4.0.0</modelVersion>\n+                        <groupId>org.openrewrite.maven</groupId>\n+                        <artifactId>d</artifactId>\n+                        <version>0.1.0-SNAPSHOT</version>\n+                    </project>\n+                    \"\"\"\n+                )\n+              ),\n+              mavenProject(\"e\",\n+                pomXml(\n+                  \"\"\"\n+                    <project>\n+                        <modelVersion>4.0.0</modelVersion>\n+                        <groupId>org.openrewrite.maven</groupId>\n+                        <artifactId>e</artifactId>\n+                        <version>0.2.0-SNAPSHOT</version>\n+                    </project>\n+                    \"\"\"\n+                )\n+              )\n+            );\n+\n+            AssertionFailedError err = assertThrows(AssertionFailedError.class, fn);\n+            assertThat(err.getMessage()).contains(\"Problem parsing a/pom.xml\");  // brittle:(, but class above is broad\n+        }\n+\n+        @Test\n+        @Disabled(\"Not yet implemented\")\n+        void settingsActiveProfiles() {\n+            var mavenCtx = MavenExecutionContextView.view(new InMemoryExecutionContext(t -> {\n+                throw new RuntimeException(t);\n+            }));\n+            var settings = MavenSettings.parse(Parser.Input.fromString(Path.of(\"settings.xml\"),\n+              //language=xml\n+              \"\"\"\n+                <settings>\n+                  <activeProfiles>\n+                      <activeProfile>foo</activeProfile>\n+                  </activeProfiles>\n+                </settings>\n+                \"\"\"\n+            ), mavenCtx);\n+            mavenCtx.setMavenSettings(settings);\n+\n+            rewriteRun(\n+              recipeSpec -> recipeSpec.executionContext(mavenCtx),\n+              pomXml(\n+                \"\"\"\n+                  <project>\n+                      <groupId>some.group</groupId>\n+                      <artifactId>some.artifact</artifactId>\n+                      <version>1-SNAPSHOT</version>\n+                      <dependencies>\n+                          <dependency>\n+                              <groupId>commons-io</groupId>\n+                              <artifactId>commons-io</artifactId>\n+                          </dependency>\n+                      </dependencies>\n+                      <profiles>\n+                          <profile>\n+                              <id>foo</id>\n+                              <properties>\n+                                  <commons-io.version>2.11.0</commons-io.version>\n+                              </properties>\n+                              <dependencyManagement>\n+                                  <dependencies>\n+                                      <dependency>\n+                                          <groupId>commons-io</groupId>\n+                                          <artifactId>commons-io</artifactId>\n+                                          <version>${commons-io.version}</version>\n+                                      </dependency>\n+                                  </dependencies>\n+                              </dependencyManagement>\n+                          </profile>\n+                      </profiles>\n+                  </project>\n+                  \"\"\"\n+              )\n+            );\n+        }\n+    }\n+\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/378\")\n     @Test\n     void parseNotInProfileActivation() {\n@@ -1424,7 +1744,7 @@ void parentPomProfileProperty() {\n                 assertThat(pomXml.getMarkers().findFirst(MavenResolutionResult.class).orElseThrow().getDependencies().get(Scope.Compile))\n                   .hasSize(7)\n                   .matches(deps -> deps.get(0).getArtifactId().equals(\"guava\") &&\n-                                   deps.get(0).getVersion().equals(\"29.0-jre\"))\n+                    deps.get(0).getVersion().equals(\"29.0-jre\"))\n               )\n             )\n           )\n@@ -1498,9 +1818,9 @@ void dependencyManagementPropagatesToDependencies() {\n                       .getDependencies().get(Scope.Compile);\n                     assertThat(compileDependencies).hasSize(2);\n                     assertThat(compileDependencies).anyMatch(it -> it.getArtifactId().equals(\"b\") &&\n-                                                                   it.getVersion().equals(\"0.1.0-SNAPSHOT\"));\n+                      it.getVersion().equals(\"0.1.0-SNAPSHOT\"));\n                     assertThat(compileDependencies).anyMatch(it -> it.getArtifactId().equals(\"d\") &&\n-                                                                   it.getVersion().equals(\"0.1.0-SNAPSHOT\"));\n+                      it.getVersion().equals(\"0.1.0-SNAPSHOT\"));\n                 })\n               ),\n               mavenProject(\"b-parent\",\n@@ -1641,7 +1961,7 @@ void managedDependencyInTransitiveAndPom() {\n                   var compileDependencies = pomXml.getMarkers().findFirst(MavenResolutionResult.class).orElseThrow()\n                     .getDependencies().get(Scope.Compile);\n                   assertThat(compileDependencies).anyMatch(it -> it.getArtifactId().equals(\"junit\") &&\n-                                                                 it.getVersion().equals(\"4.11\"));\n+                    it.getVersion().equals(\"4.11\"));\n                   assertThat(compileDependencies).noneMatch(it -> it.getArtifactId().equals(\"hamcrest-core\"));\n               })\n             )\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4242",
    "pr_id": 4242,
    "issue_id": 4241,
    "repo": "openrewrite/rewrite",
    "problem_statement": "No newline in import statements added by maybeAddImport / AddImportVisitor\n## What version of OpenRewrite are you using?\r\nI am using latest openRewrite\r\n\r\n## How are you running OpenRewrite?\r\nUsing unit test case to show the issue.\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n\r\n```java\r\n    @Test\r\n    void combinedChangePackageAndChangeTypeMaintainsImportsCorrectly() {\r\n        rewriteRun(\r\n          spec ->\r\n            spec.recipeFromYaml(\"\"\"\r\n                                type: specs.openrewrite.org/v1beta/recipe\r\n                                name: org.openrewrite.test\r\n                                displayName: Test\r\n                                description: Test.\r\n                                recipeList:\r\n                                  - org.openrewrite.java.ChangePackage:\r\n                                      oldPackageName: org.apache.http.client.methods\r\n                                      newPackageName: org.apache.hc.client5.http.classic.methods\r\n                                  - org.openrewrite.java.ChangeType:\r\n                                      oldFullyQualifiedTypeName: org.apache.hc.client5.http.classic.methods.CloseableHttpResponse\r\n                                      newFullyQualifiedTypeName: org.apache.hc.client5.http.impl.classic.CloseableHttpResponse\r\n                                \"\"\", \"org.openrewrite.test\"),\r\n          //language=java\r\n          java(\r\n            \"\"\"\r\n            import org.apache.http.client.methods.CloseableHttpResponse;\r\n            import org.apache.http.client.methods.HttpUriRequest;\r\n            import org.apache.http.impl.client.CloseableHttpClient;\r\n            import org.apache.http.client.methods.RequestBuilder;\r\n            class A {\r\n                void method() {\r\n                    RequestBuilder requestBuilder = null;\r\n                    HttpUriRequest request = null;\r\n                    CloseableHttpClient instance = null;\r\n                    CloseableHttpResponse response = null;\r\n                }\r\n            }\r\n            \"\"\",\r\n            \"\"\"\r\n            import org.apache.hc.client5.http.classic.methods.HttpUriRequest;\r\n            import org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;\r\n            import org.apache.http.impl.client.CloseableHttpClient;\r\n            import org.apache.hc.client5.http.classic.methods.RequestBuilder;\r\n\r\n            class A {\r\n                void method() {\r\n                    RequestBuilder requestBuilder = null;\r\n                    HttpUriRequest request = null;\r\n                    CloseableHttpClient instance = null;\r\n                    CloseableHttpResponse response = null;\r\n                }\r\n            }\r\n            \"\"\")\r\n        );\r\n    }\r\n```\r\n\r\n## What did you expect to see?\r\nimport statements added on a single line each\r\n\r\n## What did you see instead?\r\n<img width=\"911\" alt=\"issue\" src=\"https://github.com/openrewrite/rewrite/assets/25441280/f2dc0cce-8bd4-4f09-94c8-19e136b75ab5\">\r\n\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\nI have a fix in mind/ready but want to verify with openrewrite core team on the validity.\r\n",
    "issue_word_count": 282,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java/src/main/java/org/openrewrite/java/style/ImportLayoutStyle.java",
      "rewrite-java/src/test/java/org/openrewrite/java/style/ImportLayoutStyleTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java/src/test/java/org/openrewrite/java/style/ImportLayoutStyleTest.java"
    ],
    "base_commit": "28e7b125655fa507d68f80ed1dafa2dee38a38fa",
    "head_commit": "d38c395627991824adfc8cb47a89667c753c22e0",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4242",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4242",
    "dockerfile": "",
    "pr_merged_at": "2024-06-10T10:18:22.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/style/ImportLayoutStyle.java b/rewrite-java/src/main/java/org/openrewrite/java/style/ImportLayoutStyle.java\nindex a074f4efd1b..025ae237dbe 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/style/ImportLayoutStyle.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/style/ImportLayoutStyle.java\n@@ -151,6 +151,7 @@ public List<JRightPadded<J.Import>> addImport(List<JRightPadded<J.Import>> origi\n                     // Find the import in the original list to establish insertion position.\n                     for (int j = 0; j < originalImports.size(); j++) {\n                         if (after != null && after.getElement().equals(originalImports.get(j).getElement()) && addToBlock.accept(after)) {\n+                            insertPosition = j;\n                             break;\n                         } else if (before.getElement().equals(originalImports.get(j).getElement())) {\n                             insertPosition = j + 1;\n",
    "test_patch": "diff --git a/rewrite-java/src/test/java/org/openrewrite/java/style/ImportLayoutStyleTest.java b/rewrite-java/src/test/java/org/openrewrite/java/style/ImportLayoutStyleTest.java\nindex ca19f3a4fd8..9df25df889c 100644\n--- a/rewrite-java/src/test/java/org/openrewrite/java/style/ImportLayoutStyleTest.java\n+++ b/rewrite-java/src/test/java/org/openrewrite/java/style/ImportLayoutStyleTest.java\n@@ -121,4 +121,50 @@ void addImportInPresenceOfDuplicateOtherImport() {\n                 .containsExactlyInAnyOrder(\n                         import1, import1, new JRightPadded<>(importToAdd, Space.EMPTY, Markers.EMPTY));\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4241\")\n+    void addImportWithNewLineInUnsortedImportList() {\n+        ImportLayoutStyle style = new ImportLayoutStyle(\n+          Integer.MAX_VALUE, Integer.MAX_VALUE, Collections.emptyList(), Collections.emptyList());\n+        JRightPadded<J.Import> import0 = new JRightPadded<>(\n+          new J.Import(\n+            randomId(),\n+            Space.EMPTY,\n+            Markers.EMPTY,\n+            new JLeftPadded<>(Space.SINGLE_SPACE, true, Markers.EMPTY),\n+            TypeTree.build(\"pkg.AAA.MEMBER_0\").withPrefix(Space.SINGLE_SPACE),\n+            null),\n+          Space.EMPTY,\n+          Markers.EMPTY);\n+        JRightPadded<J.Import> import1 = new JRightPadded<>(\n+          new J.Import(\n+            randomId(),\n+            Space.EMPTY,\n+            Markers.EMPTY,\n+            new JLeftPadded<>(Space.SINGLE_SPACE, true, Markers.EMPTY),\n+            TypeTree.build(\"pkg.Clazz.MEMBER_3\").withPrefix(Space.SINGLE_SPACE),\n+            null),\n+          Space.EMPTY,\n+          Markers.EMPTY);\n+        JRightPadded<J.Import> import3 = new JRightPadded<>(\n+          new J.Import(\n+            randomId(),\n+            Space.EMPTY,\n+            Markers.EMPTY,\n+            new JLeftPadded<>(Space.SINGLE_SPACE, true, Markers.EMPTY),\n+            TypeTree.build(\"pkg.Clazz.MEMBER_1\").withPrefix(Space.SINGLE_SPACE),\n+            null),\n+          Space.EMPTY,\n+          Markers.EMPTY);\n+        J.Import importToAdd = new J.Import(\n+          randomId(),\n+          Space.EMPTY,\n+          Markers.EMPTY,\n+          new JLeftPadded<>(Space.EMPTY, true, Markers.EMPTY),\n+          TypeTree.build(\"pkg.Clazz.MEMBER_2\").withPrefix(Space.SINGLE_SPACE),\n+          null);\n+\n+        assertThat(style.addImport(List.of(import0, import1, import3), importToAdd, null, Collections.emptyList()).get(1).getElement().getPrefix()).isEqualTo(Space.format(\"\\n\"));\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4229",
    "pr_id": 4229,
    "issue_id": 4228,
    "repo": "openrewrite/rewrite",
    "problem_statement": "UpgradeDependencyVersion creates constraints inside constraint block\n## What version of OpenRewrite are you using?\r\nlatest SNAPSHOT\r\n\r\n## How are you running OpenRewrite?\r\nUnit tests / Moderne\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n\r\n```java\r\n@Test\r\n    void constraintDoesNotGetAddedInsideConstraint() {\r\n        rewriteRun(\r\n          spec -> spec\r\n            .beforeRecipe(withToolingApi())\r\n            .recipe(new UpgradeTransitiveDependencyVersion(\"com.fasterxml.jackson.core\", \"jackson-core\",\"2.12.5\", null, \"CVE-2024-BAD\")),\r\n          //language=groovy\r\n          buildGradle(\r\n            \"\"\"\r\n              plugins {\r\n                  id 'java'\r\n              }\r\n              repositories {\r\n                  mavenCentral()\r\n              }\r\n              dependencies {\r\n                  implementation 'org.openrewrite:rewrite-java:7.0.0'\r\n              \r\n                  constraints {\r\n                      implementation(\"org.apache.logging.log4j:log4j-core\") {\r\n                          version {\r\n                              strictly(\"2.17.0\")\r\n                          }\r\n                          because 'security'\r\n                      }\r\n                  }\r\n              }\r\n              \"\"\", \"\"\"\r\n              plugins {\r\n                  id 'java'\r\n              }\r\n              repositories {\r\n                  mavenCentral()\r\n              }\r\n              dependencies {\r\n                  implementation 'org.openrewrite:rewrite-java:7.0.0'\r\n              \r\n                  constraints {\r\n                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {\r\n                          because 'CVE-2024-BAD'\r\n                      }\r\n                      implementation(\"org.apache.logging.log4j:log4j-core\") {\r\n                          version {\r\n                              strictly(\"2.17.0\")\r\n                          }\r\n                          because 'security'\r\n                      }\r\n                  }\r\n              }\r\n              \"\"\"\r\n          )\r\n        );\r\n    }\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\n```java\r\nplugins {\r\n    id 'java'\r\n}\r\nrepositories {\r\n    mavenCentral()\r\n}\r\ndependencies {\r\n    implementation 'org.openrewrite:rewrite-java:7.0.0'\r\n\r\n    constraints {\r\n        implementation(\"org.apache.logging.log4j:log4j-core:2.17.0\") {\r\n            version {\r\n                strictly(\"2.17.0\")\r\n            }\r\n            because 'security'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## What did you see instead?\r\n```java\r\nplugins {\r\n    id 'java'\r\n}\r\nrepositories {\r\n    mavenCentral()\r\n}\r\ndependencies {\r\n    implementation 'org.openrewrite:rewrite-java:7.0.0'\r\n\r\n    constraints {\r\n        implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {\r\n            because 'CVE-2024-BAD'\r\n        }\r\n        implementation(\"org.apache.logging.log4j:log4j-core:2.17.0\") {\r\n            version {\r\n                implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {\r\n                    because 'CVE-2024-BAD'\r\n                }\r\n                strictly(\"2.17.0\")\r\n            }\r\n            because 'security'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\nDebugging on my fork + added test there already\r\n",
    "issue_word_count": 288,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java"
    ],
    "base_commit": "55811924d912d322b75d8b7822051dac0fa1e749",
    "head_commit": "1b81662c8990dd6316f604b7872509707bdfc418",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4229",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4229",
    "dockerfile": "",
    "pr_merged_at": "2024-06-06T19:43:23.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\nindex 720f80e5809..420b46f3241 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersion.java\n@@ -366,6 +366,9 @@ private static class CreateConstraintVisitor extends GroovyIsoVisitor<ExecutionC\n         String because;\n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n+            if (\"version\".equals(method.getSimpleName())) {\n+                return method;\n+            }\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n             Optional<G.CompilationUnit> withConstraint = GradleParser.builder().build().parse(String.format(\n                     \"plugins {\\n\" +\n@@ -419,6 +422,9 @@ private static class UpdateConstraintVersionVisitor extends GroovyIsoVisitor<Exe\n \n         @Override\n         public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n+            if (\"version\".equals(method.getSimpleName())) {\n+                return method;\n+            }\n             J.MethodInvocation m = super.visitMethodInvocation(method, ctx);\n             if(existingConstraint.isScope(m)) {\n                 AtomicBoolean updatedBecause = new AtomicBoolean(false);\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java\nindex 6567e3aecbe..7405c5bbb39 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpgradeTransitiveDependencyVersionTest.java\n@@ -17,6 +17,7 @@\n \n import org.junit.jupiter.api.Test;\n import org.openrewrite.DocumentExample;\n+import org.openrewrite.Issue;\n import org.openrewrite.test.RecipeSpec;\n import org.openrewrite.test.RewriteTest;\n \n@@ -447,4 +448,59 @@ void constraintDoesNotGetAddedToNonTransitiveNonExtendingConfiguration() {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4228\")\n+    void constraintDoesNotGetAddedInsideConstraint() {\n+        rewriteRun(\n+          spec -> spec\n+            .beforeRecipe(withToolingApi())\n+            .recipe(new UpgradeTransitiveDependencyVersion(\"com.fasterxml.jackson.core\", \"jackson-core\",\"2.12.5\", null, \"CVE-2024-BAD\")),\n+          //language=groovy\n+          buildGradle(\n+            \"\"\"\n+              plugins {\n+                  id 'java'\n+              }\n+              repositories {\n+                  mavenCentral()\n+              }\n+              dependencies {\n+                  implementation 'org.openrewrite:rewrite-java:7.0.0'\n+              \n+                  constraints {\n+                      implementation(\"org.apache.logging.log4j:log4j-core\") {\n+                          version {\n+                              strictly(\"2.17.0\")\n+                          }\n+                          because 'security'\n+                      }\n+                  }\n+              }\n+              \"\"\", \"\"\"\n+              plugins {\n+                  id 'java'\n+              }\n+              repositories {\n+                  mavenCentral()\n+              }\n+              dependencies {\n+                  implementation 'org.openrewrite:rewrite-java:7.0.0'\n+              \n+                  constraints {\n+                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {\n+                          because 'CVE-2024-BAD'\n+                      }\n+                      implementation(\"org.apache.logging.log4j:log4j-core\") {\n+                          version {\n+                              strictly(\"2.17.0\")\n+                          }\n+                          because 'security'\n+                      }\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4214",
    "pr_id": 4214,
    "issue_id": 4193,
    "repo": "openrewrite/rewrite",
    "problem_statement": "UpgradeDependencyVersion does not update dependency version whose value is defined via a property from the parent POM\n## What version of OpenRewrite are you using?\r\nI am using\r\n\r\n- Maven plugin v5.28.0\r\n- rewrite-spring v5.7.0\r\n\r\n## How are you running OpenRewrite?\r\n```\r\nmvn -U org.openrewrite.maven:rewrite-maven-plugin:5.28.0:run -Drewrite.recipeArtifactCoordinates=org.openrewrite.recipe:rewrite-spring:5.7.0 -Drewrite.activeRecipes=org.openrewrite.java.spring.boot3.UpgradeSpringBoot_3_2\r\n```\r\nI am using the Maven plugin, and my project is a two-module project.\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n### Root/Parent\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>org.example</groupId>\r\n    <artifactId>test</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n    <packaging>pom</packaging>\r\n\r\n    <modules>\r\n        <module>test-spring-boot-1</module>\r\n        <module>test-spring-boot-2</module>\r\n    </modules>\r\n\r\n    <properties>\r\n        <jdk.version>1.8</jdk.version>\r\n        <maven.compiler.source>1.8</maven.compiler.source>\r\n        <maven.compiler.target>1.8</maven.compiler.target>\r\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n        <maven.compiler.encoding>UTF-8</maven.compiler.encoding>\r\n        <spring-boot.version>2.1.1.RELEASE</spring-boot.version>\r\n    </properties>\r\n\r\n</project>\r\n```\r\n### Module 1\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <parent>\r\n        <groupId>org.example</groupId>\r\n        <artifactId>test</artifactId>\r\n        <version>1.0-SNAPSHOT</version>\r\n    </parent>\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <artifactId>test-spring-boot-1</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot</artifactId>\r\n            <version>${spring-boot.version}</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-autoconfigure</artifactId>\r\n            <version>${spring-boot.version}</version>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n</project>\r\n```\r\n### Module 2\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <parent>\r\n        <groupId>org.example</groupId>\r\n        <artifactId>test</artifactId>\r\n        <version>1.0-SNAPSHOT</version>\r\n    </parent>\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <artifactId>test-spring-boot-2</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n\r\n    <properties>\r\n        <spring-boot.version>2.1.1.RELEASE</spring-boot.version>\r\n    </properties>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot</artifactId>\r\n            <version>${spring-boot.version}</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-autoconfigure</artifactId>\r\n            <version>${spring-boot.version}</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-actuator</artifactId>\r\n            <version>${spring-boot.version}</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-configuration-processor</artifactId>\r\n            <version>${spring-boot.version}</version>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n</project>\r\n```\r\n\r\n## What did you expect to see?\r\nThe property `spring-boot.version` in root/parent POM is updated to `3.2.5`.\r\n```\r\n        <spring-boot.version>3.2.5</spring-boot.version>\r\n```\r\n\r\n## What did you see instead?\r\nThe property `spring-boot.version` in root/parent POM is unchanged: `2.1.1.RELEASE`. Therefore, Spring Boot in module 1 was not upgraded.\r\n```\r\n        <spring-boot.version>2.1.1.RELEASE</spring-boot.version>\r\n```\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\n",
    "issue_word_count": 629,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java"
    ],
    "base_commit": "22ac272d0a37fe1023af153ec68aef3ab7926849",
    "head_commit": "e0bd56922156252ce36abb1dfd9f4f36a8ad5d88",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4214",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4214",
    "dockerfile": "",
    "pr_merged_at": "2024-06-24T16:37:57.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\nindex 89524e3494f..a98a07dae9f 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n@@ -266,7 +266,8 @@ public ResolvedDependency findDependency(Xml.Tag tag) {\n \n     @Nullable\n     public ResolvedManagedDependency findManagedDependency(Xml.Tag tag) {\n-        String groupId = getResolutionResult().getPom().getValue(tag.getChildValue(\"groupId\").orElse(getResolutionResult().getPom().getGroupId()));\n+        String groupId = getResolutionResult().getPom().getValue(tag.getChildValue(\"groupId\")\n+                .orElse(getResolutionResult().getPom().getGroupId()));\n         String artifactId = getResolutionResult().getPom().getValue(tag.getChildValue(\"artifactId\").orElse(\"\"));\n         String classifier = getResolutionResult().getPom().getValue(tag.getChildValue(\"classifier\").orElse(null));\n         if (groupId != null && artifactId != null) {\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java b/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\nindex 4be51391ccc..6c99dc6f11a 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\n@@ -30,6 +30,7 @@\n import org.openrewrite.xml.XPathMatcher;\n import org.openrewrite.xml.tree.Xml;\n \n+import java.nio.file.Path;\n import java.util.*;\n \n import static java.util.Collections.emptyList;\n@@ -48,7 +49,7 @@\n  */\n @Value\n @EqualsAndHashCode(callSuper = false)\n-public class UpgradeDependencyVersion extends ScanningRecipe<Set<GroupArtifact>> {\n+public class UpgradeDependencyVersion extends ScanningRecipe<UpgradeDependencyVersion.Accumulator> {\n     @EqualsAndHashCode.Exclude\n     transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);\n \n@@ -125,35 +126,104 @@ public String getDescription() {\n     }\n \n     @Override\n-    public Set<GroupArtifact> getInitialValue(ExecutionContext ctx) {\n-        return new HashSet<>();\n+    public Accumulator getInitialValue(ExecutionContext ctx) {\n+        return new Accumulator();\n     }\n \n     @Override\n-    public TreeVisitor<?, ExecutionContext> getScanner(Set<GroupArtifact> projectArtifacts) {\n+    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator accumulator) {\n         return new MavenIsoVisitor<ExecutionContext>() {\n+            private final VersionComparator versionComparator =\n+                    requireNonNull(Semver.validate(newVersion, versionPattern).getValue());\n+\n             @Override\n             public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {\n                 ResolvedPom pom = getResolutionResult().getPom();\n-                projectArtifacts.add(new GroupArtifact(pom.getGroupId(), pom.getArtifactId()));\n-                return document;\n+                accumulator.projectArtifacts.add(new GroupArtifact(pom.getGroupId(), pom.getArtifactId()));\n+                return super.visitDocument(document, ctx);\n+            }\n+\n+            @Override\n+            public Xml.Tag visitTag(final Xml.Tag tag, final ExecutionContext ctx) {\n+                if (isDependencyTag(groupId, artifactId)) {\n+                    ResolvedDependency d = findDependency(tag);\n+                    if (d != null && d.getRepository() != null) {\n+                        // if the resolved dependency exists AND it does not represent an artifact that was parsed\n+                        // as a source file, attempt to find a new version.\n+                        try {\n+                            String newerVersion = findNewerVersion(d.getVersion(),\n+                                    () -> downloadMetadata(d.getGroupId(), d.getArtifactId(), ctx), versionComparator, ctx);\n+                            if (newerVersion != null) {\n+                                Optional<Xml.Tag> version = tag.getChild(\"version\");\n+                                if (version.isPresent()) {\n+                                    String requestedVersion = d.getRequested().getVersion();\n+                                    if (requestedVersion != null && requestedVersion.startsWith(\"${\") &&\n+                                        !implicitlyDefinedVersionProperties.contains(requestedVersion)) {\n+                                        String propertyName = requestedVersion.substring(2, requestedVersion.length() - 1);\n+                                        if (!getResolutionResult().getPom().getRequested().getProperties().containsKey(propertyName)) {\n+                                            storeParentPomProperty(getResolutionResult().getParent(), propertyName, newerVersion);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        } catch (MavenDownloadingException e) {\n+                            return e.warn(tag);\n+                        }\n+                    }\n+                }\n+                return super.visitTag(tag, ctx);\n+            }\n+\n+            /**\n+             * Recursively look for a parent POM that's still part of the sources, which contains the version property.\n+             * If found, store the property in the accumulator, such that we can update that source file later.\n+             * @param currentMavenResolutionResult the current Maven resolution result parent to search for the property\n+             * @param propertyName the name of the property to update, if found in any the parent pom source file\n+             * @param newerVersion the resolved newer version that any matching parent pom property should be updated to\n+             */\n+            private void storeParentPomProperty(\n+                    @Nullable MavenResolutionResult currentMavenResolutionResult, String propertyName, String newerVersion) {\n+                if (currentMavenResolutionResult == null) {\n+                    return; // No parent contained the property; might then be in the same source file, or an import BOM\n+                }\n+                Pom pom = currentMavenResolutionResult.getPom().getRequested();\n+                if (pom.getSourcePath() == null) {\n+                    return; // Not a source file, so nothing to update\n+                }\n+                if (pom.getProperties().containsKey(propertyName)) {\n+                    accumulator.pomProperties.add(new PomProperty(pom.getSourcePath(), propertyName, newerVersion));\n+                    return; // Property found, so no further searching is needed\n+                }\n+                storeParentPomProperty(currentMavenResolutionResult.getParent(), propertyName, newerVersion);\n             }\n         };\n     }\n \n     @Override\n-    public TreeVisitor<?, ExecutionContext> getVisitor(Set<GroupArtifact> projectArtifacts) {\n-        VersionComparator versionComparator = Semver.validate(newVersion, versionPattern).getValue();\n-        assert versionComparator != null;\n-\n+    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator accumulator) {\n         return new MavenIsoVisitor<ExecutionContext>() {\n             private final XPathMatcher PROJECT_MATCHER = new XPathMatcher(\"/project\");\n+            private final VersionComparator versionComparator =\n+                    requireNonNull(Semver.validate(newVersion, versionPattern).getValue());\n \n             @Override\n             public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 Xml.Tag t = super.visitTag(tag, ctx);\n                 try {\n-                    if (isDependencyTag(groupId, artifactId)) {\n+                    if (isPropertyTag()) {\n+                        Path pomSourcePath = getResolutionResult().getPom().getRequested().getSourcePath();\n+                        for (PomProperty pomProperty : accumulator.pomProperties) {\n+                            if (pomProperty.pomFilePath.equals(pomSourcePath) &&\n+                                pomProperty.propertyName.equals(tag.getName())) {\n+                                Optional<String> value = tag.getValue();\n+                                if (!value.isPresent() || !value.get().equals(pomProperty.propertyValue)) {\n+                                    doAfterVisit(new ChangeTagValueVisitor<>(tag, pomProperty.propertyValue));\n+                                    maybeUpdateModel();\n+                                }\n+                                break;\n+                            }\n+                        }\n+                    } else if (isDependencyTag(groupId, artifactId)) {\n                         t = upgradeDependency(ctx, t);\n                     } else if (isManagedDependencyTag(groupId, artifactId)) {\n                         if (isManagedDependencyImportTag(groupId, artifactId)) {\n@@ -220,7 +290,10 @@ private Xml.Tag upgradeDependency(ExecutionContext ctx, Xml.Tag t) throws MavenD\n                         if (version.isPresent()) {\n                             String requestedVersion = d.getRequested().getVersion();\n                             if (requestedVersion != null && requestedVersion.startsWith(\"${\") && !implicitlyDefinedVersionProperties.contains(requestedVersion)) {\n-                                doAfterVisit(new ChangePropertyValue(requestedVersion.substring(2, requestedVersion.length() - 1), newerVersion, overrideManagedVersion, false).getVisitor());\n+                                String propertyName = requestedVersion.substring(2, requestedVersion.length() - 1);\n+                                if (getResolutionResult().getPom().getRequested().getProperties().containsKey(propertyName)) {\n+                                    doAfterVisit(new ChangePropertyValue(propertyName, newerVersion, overrideManagedVersion, false).getVisitor());\n+                                }\n                             } else {\n                                 t = (Xml.Tag) new ChangeTagValueVisitor<>(version.get(), newerVersion).visitNonNull(t, 0, getCursor().getParentOrThrow());\n                             }\n@@ -257,7 +330,7 @@ private TreeVisitor<Xml, ExecutionContext> upgradeManagedDependency(Xml.Tag tag,\n                     String artifactId = managedDependency.getArtifactId();\n                     String version = managedDependency.getVersion();\n                     if (version != null &&\n-                        !projectArtifacts.contains(new GroupArtifact(groupId, artifactId)) &&\n+                        !accumulator.projectArtifacts.contains(new GroupArtifact(groupId, artifactId)) &&\n                         matchesGlob(groupId, UpgradeDependencyVersion.this.groupId) &&\n                         matchesGlob(artifactId, UpgradeDependencyVersion.this.artifactId)) {\n                         return upgradeVersion(ctx, t, managedDependency.getRequested().getVersion(), groupId, artifactId, version);\n@@ -267,7 +340,7 @@ private TreeVisitor<Xml, ExecutionContext> upgradeManagedDependency(Xml.Tag tag,\n                         if (dm.getBomGav() != null) {\n                             String group = getResolutionResult().getPom().getValue(tag.getChildValue(\"groupId\").orElse(getResolutionResult().getPom().getGroupId()));\n                             String artifactId = getResolutionResult().getPom().getValue(tag.getChildValue(\"artifactId\").orElse(\"\"));\n-                            if (!projectArtifacts.contains(new GroupArtifact(group, artifactId))) {\n+                            if (!accumulator.projectArtifacts.contains(new GroupArtifact(group, artifactId))) {\n                                 ResolvedGroupArtifactVersion bom = dm.getBomGav();\n                                 if (Objects.equals(group, bom.getGroupId()) &&\n                                     Objects.equals(artifactId, bom.getArtifactId())) {\n@@ -327,34 +400,55 @@ public TreeVisitor<Xml, ExecutionContext> upgradeVersion(ExecutionContext ctx, X\n             }\n \n             @Nullable\n-            private String findNewerVersion(String groupId, String artifactId, String version, ExecutionContext ctx) throws MavenDownloadingException {\n-                String finalVersion = !Semver.isVersion(version) ? \"0.0.0\" : version;\n+            private String findNewerVersion(String groupId, String artifactId, String version, ExecutionContext ctx)\n+                    throws MavenDownloadingException {\n+                return UpgradeDependencyVersion.this.findNewerVersion(\n+                        version, () -> downloadMetadata(groupId, artifactId, ctx), versionComparator, ctx);\n+            }\n+        };\n+    }\n \n-                // in the case of \"latest.patch\", a new version can only be derived if the\n-                // current version is a semantic version\n-                if (versionComparator instanceof LatestPatch && !versionComparator.isValid(finalVersion, finalVersion)) {\n-                    return null;\n-                }\n+    @Nullable\n+    private String findNewerVersion(\n+            String version, MavenMetadataFailures.MavenMetadataDownloader download, VersionComparator versionComparator, ExecutionContext ctx) throws MavenDownloadingException {\n+        String finalVersion = !Semver.isVersion(version) ? \"0.0.0\" : version;\n+\n+        // in the case of \"latest.patch\", a new version can only be derived if the\n+        // current version is a semantic version\n+        if (versionComparator instanceof LatestPatch && !versionComparator.isValid(finalVersion, finalVersion)) {\n+            return null;\n+        }\n \n-                try {\n-                    MavenMetadata mavenMetadata = metadataFailures.insertRows(ctx, () -> downloadMetadata(groupId, artifactId, ctx));\n-                    List<String> versions = new ArrayList<>();\n-                    for (String v : mavenMetadata.getVersioning().getVersions()) {\n-                        if (versionComparator.isValid(finalVersion, v)) {\n-                            versions.add(v);\n-                        }\n-                    }\n-                    // handle upgrades from non semver versions like \"org.springframework.cloud:spring-cloud-dependencies:Camden.SR5\"\n-                    if (!Semver.isVersion(finalVersion) && !versions.isEmpty()) {\n-                        versions.sort(versionComparator);\n-                        return versions.get(versions.size() - 1);\n-                    }\n-                    return versionComparator.upgrade(finalVersion, versions).orElse(null);\n-                } catch (IllegalStateException e) {\n-                    // this can happen when we encounter exotic versions\n-                    return null;\n+        try {\n+            MavenMetadata mavenMetadata = metadataFailures.insertRows(ctx, download);\n+            List<String> versions = new ArrayList<>();\n+            for (String v : mavenMetadata.getVersioning().getVersions()) {\n+                if (versionComparator.isValid(finalVersion, v)) {\n+                    versions.add(v);\n                 }\n             }\n-        };\n+            // handle upgrades from non semver versions like \"org.springframework.cloud:spring-cloud-dependencies:Camden.SR5\"\n+            if (!Semver.isVersion(finalVersion) && !versions.isEmpty()) {\n+                versions.sort(versionComparator);\n+                return versions.get(versions.size() - 1);\n+            }\n+            return versionComparator.upgrade(finalVersion, versions).orElse(null);\n+        } catch (IllegalStateException e) {\n+            // this can happen when we encounter exotic versions\n+            return null;\n+        }\n+    }\n+\n+    @Value\n+    public static class Accumulator {\n+        Set<GroupArtifact> projectArtifacts = new HashSet<>();\n+        Set<PomProperty> pomProperties = new HashSet<>();\n+    }\n+\n+    @Value\n+    public static class PomProperty {\n+        Path pomFilePath;\n+        String propertyName;\n+        String propertyValue;\n     }\n }\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java\nindex 88eff79aa10..145c21fad5a 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java\n@@ -16,6 +16,7 @@\n package org.openrewrite.maven;\n \n import com.google.common.collect.Lists;\n+import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n@@ -37,7 +38,6 @@\n \n class UpgradeDependencyVersionTest implements RewriteTest {\n \n-    @DocumentExample\n     @Test\n     void doNotOverrideImplicitProperty() {\n         rewriteRun(\n@@ -133,6 +133,7 @@ void doNotOverrideImplicitProperty() {\n         );\n     }\n \n+    @DocumentExample\n     @Test\n     void updateManagedDependencyVersion() {\n         rewriteRun(\n@@ -576,11 +577,11 @@ void upgradePluginDependenciesOnProperty() {\n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-                \n+              \n                 <properties>\n                     <rewrite-spring.version>4.33.0</rewrite-spring.version>\n                 </properties>\n-                \n+              \n                 <build>\n                   <plugins>\n                     <plugin>\n@@ -604,11 +605,11 @@ void upgradePluginDependenciesOnProperty() {\n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-                \n+              \n                 <properties>\n                     <rewrite-spring.version>4.33.2</rewrite-spring.version>\n                 </properties>\n-                \n+              \n                 <build>\n                   <plugins>\n                     <plugin>\n@@ -796,6 +797,168 @@ void upgradeDependencyOnlyTargetsSpecificDependencyProperty() {\n         );\n     }\n \n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4193\")\n+    @Test\n+    void upgradeVersionDefinedViaPropertyInLocalParent() {\n+        rewriteRun(\n+          spec -> spec.recipe(new UpgradeDependencyVersion(\"com.google.guava\", \"guava\", \"14.0\", \"\", false, null)),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <groupId>com.mycompany</groupId>\n+                  <artifactId>my-parent</artifactId>\n+                  <version>1</version>\n+                  <properties>\n+                    <guava.version>13.0</guava.version>\n+                    <junit.version>4.13.2</junit.version>\n+                  </properties>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <groupId>com.mycompany</groupId>\n+                  <artifactId>my-parent</artifactId>\n+                  <version>1</version>\n+                  <properties>\n+                    <guava.version>14.0</guava.version>\n+                    <junit.version>4.13.2</junit.version>\n+                  </properties>\n+              </project>\n+              \"\"\"\n+          ),\n+          mavenProject(\"my-child\",\n+            pomXml(\n+              \"\"\"\n+                <project>\n+                    <parent>\n+                        <groupId>com.mycompany</groupId>\n+                        <artifactId>my-parent</artifactId>\n+                        <version>1</version>\n+                    </parent>\n+                    <groupId>com.mycompany</groupId>\n+                    <artifactId>my-child</artifactId>\n+                    <version>1</version>\n+                    <dependencies>\n+                        <dependency>\n+                            <groupId>com.google.guava</groupId>\n+                            <artifactId>guava</artifactId>\n+                            <version>${guava.version}</version>\n+                        </dependency>\n+                        <dependency>\n+                            <groupId>junit</groupId>\n+                            <artifactId>junit</artifactId>\n+                            <version>${junit.version}</version>\n+                            <scope>test</scope>\n+                        </dependency>\n+                    </dependencies>\n+                </project>\n+                \"\"\"\n+            )\n+          )\n+        );\n+    }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4193\")\n+    @Test\n+    void upgradeVersionDefinedViaImplicitPropertyInRemoteParent() {\n+        rewriteRun(\n+          spec -> spec.recipe(new UpgradeDependencyVersion(\"org.flywaydb\", \"flyway-core\", \"10.15.x\", \"\", true, null)),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <parent>\n+                      <groupId>org.springframework.boot</groupId>\n+                      <artifactId>spring-boot-dependencies</artifactId>\n+                      <version>3.3.0</version>\n+                  </parent>\n+                  <groupId>com.mycompany</groupId>\n+                  <artifactId>my-child</artifactId>\n+                  <version>1</version>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>org.flywaydb</groupId>\n+                          <artifactId>flyway-core</artifactId>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <parent>\n+                      <groupId>org.springframework.boot</groupId>\n+                      <artifactId>spring-boot-dependencies</artifactId>\n+                      <version>3.3.0</version>\n+                  </parent>\n+                  <groupId>com.mycompany</groupId>\n+                  <artifactId>my-child</artifactId>\n+                  <version>1</version>\n+                  <properties>\n+                      <flyway.version>10.15.0</flyway.version>\n+                  </properties>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>org.flywaydb</groupId>\n+                          <artifactId>flyway-core</artifactId>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Disabled(\"Anti-pattern not yet supported\")\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4193\")\n+    @Test\n+    void upgradeVersionDefinedViaExplicitPropertyInRemoteParent() {\n+        rewriteRun(\n+          spec -> spec.recipe(new UpgradeDependencyVersion(\"org.flywaydb\", \"flyway-core\", \"10.15.x\", \"\", true, null)),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <parent>\n+                      <groupId>org.springframework.boot</groupId>\n+                      <artifactId>spring-boot-dependencies</artifactId>\n+                      <version>3.3.0</version>\n+                  </parent>\n+                  <groupId>com.mycompany</groupId>\n+                  <artifactId>my-child</artifactId>\n+                  <version>1</version>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>org.flywaydb</groupId>\n+                          <artifactId>flyway-core</artifactId>\n+                          <version>${flyway.version}</version>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <parent>\n+                      <groupId>org.springframework.boot</groupId>\n+                      <artifactId>spring-boot-dependencies</artifactId>\n+                      <version>3.3.0</version>\n+                  </parent>\n+                  <groupId>com.mycompany</groupId>\n+                  <artifactId>my-child</artifactId>\n+                  <version>1</version>\n+                  <properties>\n+                      <flyway.version>10.15.0</flyway.version>\n+                  </properties>\n+                  <dependencies>\n+                      <dependency>\n+                          <groupId>org.flywaydb</groupId>\n+                          <artifactId>flyway-core</artifactId>\n+                          <version>${flyway.version}</version>\n+                      </dependency>\n+                  </dependencies>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void upgradeBomImport() {\n         rewriteRun(\n@@ -1027,7 +1190,7 @@ void dependencyManagementResolvedFromProperty() {\n     }\n \n     @ParameterizedTest\n-    @ValueSource(strings = { \"3.0.12.RELEASE\", \"=3.0.12.RELEASE\" })\n+    @ValueSource(strings = {\"3.0.12.RELEASE\", \"=3.0.12.RELEASE\"})\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/4166\")\n     void upgradeToExactVersion(String version) {\n         rewriteRun(\n@@ -1202,11 +1365,11 @@ void removesRedundantExplicitVersionsMatchingOldImport() {\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-                \n+              \n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-                \n+              \n                 <dependencyManagement>\n                   <dependencies>\n                     <dependency>\n@@ -1218,7 +1381,7 @@ void removesRedundantExplicitVersionsMatchingOldImport() {\n                     </dependency>\n                   </dependencies>\n                 </dependencyManagement>\n-                \n+              \n                 <dependencies>\n                   <dependency>\n                     <groupId>org.junit.jupiter</groupId>\n@@ -1231,11 +1394,11 @@ void removesRedundantExplicitVersionsMatchingOldImport() {\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-                \n+              \n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-                \n+              \n                 <dependencyManagement>\n                   <dependencies>\n                     <dependency>\n@@ -1247,7 +1410,7 @@ void removesRedundantExplicitVersionsMatchingOldImport() {\n                     </dependency>\n                   </dependencies>\n                 </dependencyManagement>\n-                \n+              \n                 <dependencies>\n                   <dependency>\n                     <groupId>org.junit.jupiter</groupId>\n@@ -1268,11 +1431,11 @@ void removesRedundantExplicitVersionsMatchingNewImport() {\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-                \n+              \n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-                \n+              \n                 <dependencyManagement>\n                   <dependencies>\n                     <dependency>\n@@ -1284,7 +1447,7 @@ void removesRedundantExplicitVersionsMatchingNewImport() {\n                     </dependency>\n                   </dependencies>\n                 </dependencyManagement>\n-                \n+              \n                 <dependencies>\n                   <dependency>\n                     <groupId>org.junit.jupiter</groupId>\n@@ -1297,11 +1460,11 @@ void removesRedundantExplicitVersionsMatchingNewImport() {\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-                \n+              \n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-                \n+              \n                 <dependencyManagement>\n                   <dependencies>\n                     <dependency>\n@@ -1313,7 +1476,7 @@ void removesRedundantExplicitVersionsMatchingNewImport() {\n                     </dependency>\n                   </dependencies>\n                 </dependencyManagement>\n-                \n+              \n                 <dependencies>\n                   <dependency>\n                     <groupId>org.junit.jupiter</groupId>\n@@ -1334,11 +1497,11 @@ void keepsRedundantExplicitVersionsNotMatchingOldOrNewImport() {\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-                \n+              \n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-                \n+              \n                 <dependencyManagement>\n                   <dependencies>\n                     <dependency>\n@@ -1350,7 +1513,7 @@ void keepsRedundantExplicitVersionsNotMatchingOldOrNewImport() {\n                     </dependency>\n                   </dependencies>\n                 </dependencyManagement>\n-                \n+              \n                 <dependencies>\n                   <dependency>\n                     <groupId>org.junit.jupiter</groupId>\n@@ -1363,11 +1526,11 @@ void keepsRedundantExplicitVersionsNotMatchingOldOrNewImport() {\n             \"\"\"\n               <project>\n                 <modelVersion>4.0.0</modelVersion>\n-                \n+              \n                 <groupId>com.mycompany.app</groupId>\n                 <artifactId>my-app</artifactId>\n                 <version>1</version>\n-                \n+              \n                 <dependencyManagement>\n                   <dependencies>\n                     <dependency>\n@@ -1379,7 +1542,7 @@ void keepsRedundantExplicitVersionsNotMatchingOldOrNewImport() {\n                     </dependency>\n                   </dependencies>\n                 </dependencyManagement>\n-                \n+              \n                 <dependencies>\n                   <dependency>\n                     <groupId>org.junit.jupiter</groupId>\n@@ -1408,7 +1571,7 @@ void dependencyWithExplicitVersionRemovedFromDepMgmt() {\n                     <groupId>org.sample</groupId>\n                     <artifactId>sample</artifactId>\n                     <version>1.0.0</version>\n-                    \n+                  \n                     <dependencyManagement>\n                       <dependencies>\n                         <dependency>\n@@ -1420,7 +1583,7 @@ void dependencyWithExplicitVersionRemovedFromDepMgmt() {\n                         </dependency>\n                       </dependencies>\n                     </dependencyManagement>\n-                    \n+                  \n                     <dependencies>\n                       <dependency>\n                         <groupId>com.jcraft</groupId>\n@@ -1437,7 +1600,7 @@ void dependencyWithExplicitVersionRemovedFromDepMgmt() {\n                     <groupId>org.sample</groupId>\n                     <artifactId>sample</artifactId>\n                     <version>1.0.0</version>\n-                    \n+                  \n                     <dependencyManagement>\n                       <dependencies>\n                         <dependency>\n@@ -1449,7 +1612,7 @@ void dependencyWithExplicitVersionRemovedFromDepMgmt() {\n                         </dependency>\n                       </dependencies>\n                     </dependencyManagement>\n-                    \n+                  \n                     <dependencies>\n                       <dependency>\n                         <groupId>com.jcraft</groupId>\n@@ -1474,7 +1637,7 @@ void dependencyWithoutExplicitVersionRemovedFromDepMgmt() {\n                     <groupId>org.sample</groupId>\n                     <artifactId>sample</artifactId>\n                     <version>1.0.0</version>\n-                    \n+                  \n                     <dependencyManagement>\n                       <dependencies>\n                         <dependency>\n@@ -1486,7 +1649,7 @@ void dependencyWithoutExplicitVersionRemovedFromDepMgmt() {\n                         </dependency>\n                       </dependencies>\n                     </dependencyManagement>\n-                    \n+                  \n                     <dependencies>\n                       <dependency>\n                         <groupId>com.jcraft</groupId>\n@@ -1502,7 +1665,7 @@ void dependencyWithoutExplicitVersionRemovedFromDepMgmt() {\n                     <groupId>org.sample</groupId>\n                     <artifactId>sample</artifactId>\n                     <version>1.0.0</version>\n-                    \n+                  \n                     <dependencyManagement>\n                       <dependencies>\n                         <dependency>\n@@ -1514,7 +1677,7 @@ void dependencyWithoutExplicitVersionRemovedFromDepMgmt() {\n                         </dependency>\n                       </dependencies>\n                     </dependencyManagement>\n-                    \n+                  \n                     <dependencies>\n                       <dependency>\n                         <groupId>com.jcraft</groupId>\n@@ -1539,7 +1702,7 @@ void dependencyWithoutExplicitVersionRemovedFromDepMgmtRetainSpecificVersion() {\n                     <groupId>org.sample</groupId>\n                     <artifactId>sample</artifactId>\n                     <version>1.0.0</version>\n-                    \n+                  \n                     <dependencyManagement>\n                       <dependencies>\n                         <dependency>\n@@ -1551,7 +1714,7 @@ void dependencyWithoutExplicitVersionRemovedFromDepMgmtRetainSpecificVersion() {\n                         </dependency>\n                       </dependencies>\n                     </dependencyManagement>\n-                    \n+                  \n                     <dependencies>\n                       <dependency>\n                         <groupId>com.jcraft</groupId>\n@@ -1567,7 +1730,7 @@ void dependencyWithoutExplicitVersionRemovedFromDepMgmtRetainSpecificVersion() {\n                     <groupId>org.sample</groupId>\n                     <artifactId>sample</artifactId>\n                     <version>1.0.0</version>\n-                    \n+                  \n                     <dependencyManagement>\n                       <dependencies>\n                         <dependency>\n@@ -1579,7 +1742,7 @@ void dependencyWithoutExplicitVersionRemovedFromDepMgmtRetainSpecificVersion() {\n                         </dependency>\n                       </dependencies>\n                     </dependencyManagement>\n-                    \n+                  \n                     <dependencies>\n                       <dependency>\n                         <groupId>com.jcraft</groupId>\n@@ -1607,7 +1770,7 @@ void multipleRetainVersions() {\n                     <groupId>org.sample</groupId>\n                     <artifactId>sample</artifactId>\n                     <version>1.0.0</version>\n-                    \n+                  \n                     <dependencyManagement>\n                       <dependencies>\n                         <dependency>\n@@ -1619,7 +1782,7 @@ void multipleRetainVersions() {\n                         </dependency>\n                       </dependencies>\n                     </dependencyManagement>\n-                    \n+                  \n                     <dependencies>\n                       <dependency>\n                         <groupId>com.jcraft</groupId>\n@@ -1639,7 +1802,7 @@ void multipleRetainVersions() {\n                     <groupId>org.sample</groupId>\n                     <artifactId>sample</artifactId>\n                     <version>1.0.0</version>\n-                    \n+                  \n                     <dependencyManagement>\n                       <dependencies>\n                         <dependency>\n@@ -1651,7 +1814,7 @@ void multipleRetainVersions() {\n                         </dependency>\n                       </dependencies>\n                     </dependencyManagement>\n-                    \n+                  \n                     <dependencies>\n                       <dependency>\n                         <groupId>com.jcraft</groupId>\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4205",
    "pr_id": 4205,
    "issue_id": 4204,
    "repo": "openrewrite/rewrite",
    "problem_statement": "yaml: DeleteProperty removes empty sequences\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\n\r\n## What version of OpenRewrite are you using?\r\n- OpenRewrite v8.27.0\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\nThe test below:\r\n```java\r\nrewriteRun(\r\n          spec -> spec.recipe(new DeleteProperty(\"my.key\", false, null)),\r\n          yaml(\r\n            \"\"\"\r\n                my.key: qwe\r\n                seq: []\r\n              \"\"\",\r\n            \"\"\"\r\n                seq: []\r\n              \"\"\"\r\n          )\r\n);\r\n```\r\n\r\n## What did you see instead?\r\nSequence `seq` is removed even though `DeleteProperty` is configured to delete a different key\r\n\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\nYes, I would like to contribute\r\n",
    "issue_word_count": 136,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/DeleteProperty.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/DeletePropertyKeyTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/DeletePropertyKeyTest.java"
    ],
    "base_commit": "87795148796305f670bac983f928fe0df38cf898",
    "head_commit": "3be9a4389cddedcbfe0502668547f62d7d019592",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4205",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4205",
    "dockerfile": "",
    "pr_merged_at": "2024-05-22T20:20:05.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/DeleteProperty.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/DeleteProperty.java\nindex 6b36ea26ed7..db9b1e967dc 100755\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/DeleteProperty.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/DeleteProperty.java\n@@ -118,6 +118,10 @@ private DeletePropertyVisitor(Yaml.Mapping.Entry scope) {\n         public Yaml visitSequence(Yaml.Sequence sequence, P p) {\n             sequence = (Yaml.Sequence) super.visitSequence(sequence, p);\n             List<Yaml.Sequence.Entry> entries = sequence.getEntries();\n+            if (entries.isEmpty()) {\n+                return sequence;\n+            }\n+\n             entries = ListUtils.map(entries, entry -> ToBeRemoved.hasMarker(entry) ? null : entry);\n             return entries.isEmpty() ? ToBeRemoved.withMarker(sequence) : sequence.withEntries(entries);\n         }\n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/DeletePropertyKeyTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/DeletePropertyKeyTest.java\nindex d10bdb914aa..76a1584988a 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/DeletePropertyKeyTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/DeletePropertyKeyTest.java\n@@ -261,4 +261,21 @@ void preservesOriginalIndentStructureOfExistingHierarchy() {\n           )\n         );\n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4204\")\n+    @Test\n+    void preserveEmptySequencesWithOtherKeys() {\n+        rewriteRun(\n+          spec -> spec.recipe(new DeleteProperty(\"my.key\", false, null)),\n+          yaml(\n+            \"\"\"\n+                my.key: qwe\n+                seq: []\n+              \"\"\",\n+            \"\"\"\n+                seq: []\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4197",
    "pr_id": 4197,
    "issue_id": 4196,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Bug adding import to a list of imports containing duplicate imports\n## What version of OpenRewrite are you using?\r\nI am using the latest version from the tip of GitHub's `main` branch.\r\n\r\n## How are you running OpenRewrite?\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\nAdd the below test case to `org.openrewrite.java.style.ImportLayoutStyleTest`\r\n```java\r\n    @Test\r\n    void testAddImport() {\r\n        ImportLayoutStyle style = new ImportLayoutStyle(\r\n          Integer.MAX_VALUE, Integer.MAX_VALUE, Collections.emptyList(), Collections.emptyList());\r\n        JRightPadded<J.Import> import1 = new JRightPadded<>(\r\n          new J.Import(\r\n            randomId(),\r\n            Space.EMPTY,\r\n            Markers.EMPTY,\r\n            new JLeftPadded<>(Space.SINGLE_SPACE, true, Markers.EMPTY),\r\n            TypeTree.build(\"pkg.Clazz.MEMBER_1\").withPrefix(Space.SINGLE_SPACE),\r\n            null),\r\n          Space.EMPTY,\r\n          Markers.EMPTY);\r\n        JRightPadded<J.Import> import2 = new JRightPadded<>(\r\n          new J.Import(\r\n            randomId(),\r\n            Space.EMPTY,\r\n            Markers.EMPTY,\r\n            new JLeftPadded<>(Space.SINGLE_SPACE, true, Markers.EMPTY),\r\n            TypeTree.build(\"pkg.Clazz.MEMBER_1\").withPrefix(Space.SINGLE_SPACE),\r\n            null),\r\n          Space.EMPTY,\r\n          Markers.EMPTY);\r\n        J.Import importToAdd = new J.Import(\r\n          randomId(),\r\n          Space.EMPTY,\r\n          Markers.EMPTY,\r\n          new JLeftPadded<>(Space.SINGLE_SPACE, true, Markers.EMPTY),\r\n          TypeTree.build(\"pkg.Clazz.MEMBER_2\").withPrefix(Space.SINGLE_SPACE),\r\n          null);\r\n        assertThat(style.addImport(List.of(import1, import2), importToAdd, null, Collections.emptyList()))\r\n          .containsExactlyInAnyOrder(import1, import1, new JRightPadded<>(importToAdd, Space.EMPTY, Markers.EMPTY));\r\n    }\r\n```\r\n\r\n## What did you expect to see?\r\n```java\r\ncontainsExactlyInAnyOrder(import1, import1, new JRightPadded<>(importToAdd, Space.EMPTY, Markers.EMPTY))\r\n```\r\n\r\n## What did you see instead?\r\n```java\r\ncontainsExactlyInAnyOrder(import1, import1)\r\n```\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\n",
    "issue_word_count": 268,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java/src/main/java/org/openrewrite/java/style/ImportLayoutStyle.java",
      "rewrite-java/src/test/java/org/openrewrite/java/style/ImportLayoutStyleTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java/src/test/java/org/openrewrite/java/style/ImportLayoutStyleTest.java"
    ],
    "base_commit": "ed6f97a68d58703d689cdad54f05b5c0d4ee54ca",
    "head_commit": "a4bb144ef44ff8067d52cabd69e1f37eff9f70e9",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4197",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4197",
    "dockerfile": "",
    "pr_merged_at": "2024-05-18T23:56:12.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/style/ImportLayoutStyle.java b/rewrite-java/src/main/java/org/openrewrite/java/style/ImportLayoutStyle.java\nindex 126a55e5220..a074f4efd1b 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/style/ImportLayoutStyle.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/style/ImportLayoutStyle.java\n@@ -120,6 +120,14 @@ public List<JRightPadded<J.Import>> addImport(List<JRightPadded<J.Import>> origi\n             return singletonList(paddedToAdd);\n         }\n \n+        // Do not add the import if it is already present.\n+        JavaType addedType = paddedToAdd.getElement().getQualid().getType();\n+        for (JRightPadded<J.Import> originalImport : originalImports) {\n+            if (addedType != null && TypeUtils.isOfType(addedType, originalImport.getElement().getQualid().getType())) {\n+                return originalImports;\n+            }\n+        }\n+\n         // don't star fold just yet, because we are only going to star fold adjacent imports along with\n         // the import to add at most. we don't even want to star fold other non-adjacent imports in the same\n         // block that should be star folded according to the layout style (minimally invasive change).\n@@ -127,23 +135,6 @@ public List<JRightPadded<J.Import>> addImport(List<JRightPadded<J.Import>> origi\n                 new ImportLayoutStyle(Integer.MAX_VALUE, Integer.MAX_VALUE, layout, packagesToFold)\n                         .orderImports(ListUtils.concat(originalImports, paddedToAdd), new HashSet<>());\n \n-        if (ideallyOrdered.size() == originalImports.size()) {\n-            Set<String> originalPaths = new HashSet<>();\n-            for (JRightPadded<J.Import> originalImport : originalImports) {\n-                originalPaths.add(originalImport.getElement().getTypeName());\n-            }\n-            int sharedImports = 0;\n-            for (JRightPadded<J.Import> importJRightPadded : ideallyOrdered) {\n-                if (originalPaths.contains(importJRightPadded.getElement().getTypeName())) {\n-                    sharedImports++;\n-                }\n-            }\n-            if (sharedImports == originalImports.size()) {\n-                // must be a duplicate of an existing import\n-                return originalImports;\n-            }\n-        }\n-\n         JRightPadded<J.Import> before = null;\n         JRightPadded<J.Import> after = null;\n \n",
    "test_patch": "diff --git a/rewrite-java/src/test/java/org/openrewrite/java/style/ImportLayoutStyleTest.java b/rewrite-java/src/test/java/org/openrewrite/java/style/ImportLayoutStyleTest.java\nindex ecfa335c43e..a012ada4684 100644\n--- a/rewrite-java/src/test/java/org/openrewrite/java/style/ImportLayoutStyleTest.java\n+++ b/rewrite-java/src/test/java/org/openrewrite/java/style/ImportLayoutStyleTest.java\n@@ -20,9 +20,17 @@\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\n import org.junit.jupiter.api.Test;\n+import org.openrewrite.Issue;\n import org.openrewrite.config.DeclarativeNamedStyles;\n+import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JLeftPadded;\n+import org.openrewrite.java.tree.JRightPadded;\n+import org.openrewrite.java.tree.Space;\n+import org.openrewrite.java.tree.TypeTree;\n+import org.openrewrite.marker.Markers;\n \n import java.io.IOException;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n \n@@ -80,4 +88,41 @@ void deserializeInDeclarativeNamedStyles() throws IOException {\n \n         mapper.readValue(mapper.writeValueAsBytes(style), DeclarativeNamedStyles.class);\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4196\")\n+    void addImportInPresenceOfDuplicateOtherImport() {\n+        ImportLayoutStyle style = new ImportLayoutStyle(\n+                Integer.MAX_VALUE, Integer.MAX_VALUE, Collections.emptyList(), Collections.emptyList());\n+        JRightPadded<J.Import> import1 = new JRightPadded<>(\n+                new J.Import(\n+                        randomId(),\n+                        Space.EMPTY,\n+                        Markers.EMPTY,\n+                        new JLeftPadded<>(Space.SINGLE_SPACE, true, Markers.EMPTY),\n+                        TypeTree.build(\"pkg.Clazz.MEMBER_1\").withPrefix(Space.SINGLE_SPACE),\n+                        null),\n+                Space.EMPTY,\n+                Markers.EMPTY);\n+        JRightPadded<J.Import> import2 = new JRightPadded<>(\n+                new J.Import(\n+                        randomId(),\n+                        Space.EMPTY,\n+                        Markers.EMPTY,\n+                        new JLeftPadded<>(Space.SINGLE_SPACE, true, Markers.EMPTY),\n+                        TypeTree.build(\"pkg.Clazz.MEMBER_1\").withPrefix(Space.SINGLE_SPACE),\n+                        null),\n+                Space.EMPTY,\n+                Markers.EMPTY);\n+        J.Import importToAdd = new J.Import(\n+                randomId(),\n+                Space.EMPTY,\n+                Markers.EMPTY,\n+                new JLeftPadded<>(Space.SINGLE_SPACE, true, Markers.EMPTY),\n+                TypeTree.build(\"pkg.Clazz.MEMBER_2\").withPrefix(Space.SINGLE_SPACE),\n+            null);\n+        assertThat(style.addImport(List.of(import1, import2), importToAdd, null, Collections.emptyList()))\n+                .containsExactlyInAnyOrder(\n+                        import1, import1, new JRightPadded<>(importToAdd, Space.EMPTY, Markers.EMPTY));\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4189",
    "pr_id": 4189,
    "issue_id": 4188,
    "repo": "openrewrite/rewrite",
    "problem_statement": "org.openrewrite.java.ChangePackage precise match\nhttps://docs.openrewrite.org/recipes/java/changepackage\r\n\r\nWhen I use the above recipe to move/rename/change the types in package `com.test.model.staff` to `com.test.model.data.staff`, it picks up the types in package `com.test.model.staffdetails` too.\r\n\r\nHow can I restrict it to pick up only files from package `.staff` and **not** from `.staffdetails` ?\r\n\r\n",
    "issue_word_count": 66,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/ChangePackage.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java"
    ],
    "base_commit": "8edb760782a836fdc6ccb9d193c1fce26dd0771f",
    "head_commit": "cc8419d99c3401a62b4349df90ad5a2796238973",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4189",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4189",
    "dockerfile": "",
    "pr_merged_at": "2024-05-18T22:26:22.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/ChangePackage.java b/rewrite-java/src/main/java/org/openrewrite/java/ChangePackage.java\nindex f51ab465abd..e31fc73fedb 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/ChangePackage.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/ChangePackage.java\n@@ -339,7 +339,10 @@ private boolean isTargetFullyQualifiedType(@Nullable JavaType.FullyQualified fq)\n         }\n \n         private boolean isTargetRecursivePackageName(String packageName) {\n-            return (recursive == null || recursive) && packageName.startsWith(oldPackageName) && !packageName.startsWith(newPackageName);\n+            return (recursive == null || recursive)\n+                   && packageName.startsWith(oldPackageName + \".\")\n+                   && !packageName.startsWith(newPackageName);\n         }\n+\n     }\n }\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java\nindex f4364afd7f5..3c090ebeaf3 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java\n@@ -399,6 +399,180 @@ class A {\n         );\n     }\n \n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/pull/4189\")\n+    void renamePackageNullRecursiveImportedCheckStrictPackageMatch() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePackage(\n+            \"org.openrewrite.other\",\n+            \"org.openrewrite.test.other\",\n+            null\n+          )),\n+          java(\n+            \"\"\"\n+              package org.openrewrite.other;\n+              public class Test {}\n+              \"\"\",\n+            \"\"\"\n+              package org.openrewrite.test.other;\n+              public class Test {}\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              package org.openrewrite.otherone;\n+              public class OtherTest {}\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import org.openrewrite.otherone.OtherTest;\n+              class B {\n+                  OtherTest test = null;\n+              }\n+              \"\"\",\n+            spec -> spec.afterRecipe(cu -> {\n+                assertThat(cu.findType(\"org.openrewrite.otherone.OtherTest\")).isNotEmpty();\n+                assertThat(cu.findType(\"org.openrewrite.test.otherone.OtherTest\")).isEmpty();\n+            })\n+          ),\n+          java(\n+            \"\"\"\n+              import org.openrewrite.other.Test;\n+              class A {\n+                  Test test = null;\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import org.openrewrite.test.other.Test;\n+              class A {\n+                  Test test = null;\n+              }\n+            \"\"\",\n+            spec -> spec.afterRecipe(cu -> {\n+                assertThat(cu.findType(\"org.openrewrite.other.Test\")).isEmpty();\n+                assertThat(cu.findType(\"org.openrewrite.test.other.Test\")).isNotEmpty();\n+            })\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/pull/4189\")\n+    void renamePackageImportedCheckStrictPackageMatch() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePackage(\n+            \"org.openrewrite.other\",\n+            \"org.openrewrite.test.other\",\n+            false\n+          )),\n+          java(\n+            \"\"\"\n+              package org.openrewrite.other;\n+              public class Test {}\n+              \"\"\",\n+            \"\"\"\n+              package org.openrewrite.test.other;\n+              public class Test {}\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              package org.openrewrite.otherone;\n+              public class OtherTest {}\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import org.openrewrite.otherone.OtherTest;\n+              class B {\n+                  OtherTest test = null;\n+              }\n+              \"\"\",\n+            spec -> spec.afterRecipe(cu -> {\n+                assertThat(cu.findType(\"org.openrewrite.otherone.OtherTest\")).isNotEmpty();\n+                assertThat(cu.findType(\"org.openrewrite.test.otherone.OtherTest\")).isEmpty();\n+            })\n+          ),\n+          java(\n+            \"\"\"\n+              import org.openrewrite.other.Test;\n+              class A {\n+                  Test test = null;\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import org.openrewrite.test.other.Test;\n+              class A {\n+                  Test test = null;\n+              }\n+            \"\"\",\n+            spec -> spec.afterRecipe(cu -> {\n+                assertThat(cu.findType(\"org.openrewrite.other.Test\")).isEmpty();\n+                assertThat(cu.findType(\"org.openrewrite.test.other.Test\")).isNotEmpty();\n+            })\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/pull/4189\")\n+    void renamePackageRecursiveImportedStrictPackageMatch() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePackage(\n+            \"org.openrewrite.other\",\n+            \"org.openrewrite.test.other\",\n+            true\n+          )),\n+          java(\n+            \"\"\"\n+              package org.openrewrite.other;\n+              public class Test {}\n+              \"\"\",\n+            \"\"\"\n+              package org.openrewrite.test.other;\n+              public class Test {}\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              package org.openrewrite.otherone;\n+              public class OtherTest {}\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              import org.openrewrite.otherone.OtherTest;\n+              class B {\n+                  OtherTest test = null;\n+              }\n+              \"\"\",\n+            spec -> spec.afterRecipe(cu -> {\n+                assertThat(cu.findType(\"org.openrewrite.otherone.OtherTest\")).isNotEmpty();\n+                assertThat(cu.findType(\"org.openrewrite.test.otherone.OtherTest\")).isEmpty();\n+            })\n+          ),\n+          java(\n+            \"\"\"\n+              import org.openrewrite.other.Test;\n+              class A {\n+                  Test test = null;\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import org.openrewrite.test.other.Test;\n+              class A {\n+                  Test test = null;\n+              }\n+            \"\"\",\n+            spec -> spec.afterRecipe(cu -> {\n+                assertThat(cu.findType(\"org.openrewrite.other.Test\")).isEmpty();\n+                assertThat(cu.findType(\"org.openrewrite.test.other.Test\")).isNotEmpty();\n+            })\n+          )\n+        );\n+    }\n+\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/1997\")\n     @Test\n     void typeParameter() {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4187",
    "pr_id": 4187,
    "issue_id": 4176,
    "repo": "openrewrite/rewrite",
    "problem_statement": "YAML: Unable to parse lists of lists \n## The Problem\r\nIn YAML documents it is allowed to define lists of lists.\r\n```yaml\r\nlistOfLists:\r\n  - - a\r\n    - b\r\n```\r\n\r\n**OpenRewrite is unable to parse this type of lists correctly.**\r\n\r\n---\r\n\r\nTo better understand the meaning of this document, here is the same document described in JSON:\r\n```json\r\n{\r\n  \"listOfLists\": [\r\n    [\"a\", \"b\"]\r\n  ]\r\n}\r\n```\r\n\r\n## What version of OpenRewrite are you using?\r\nI am using the OpenRewrite Gradle Plugin v6.12.0\r\n\r\n## How are you running OpenRewrite?\r\nI'm using the Gradle Plugin within a single module project.\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\nTo reproduce the problem, create a yaml file containing the following snippet and run the plugin.\r\n```yaml\r\nlistOfLists:\r\n  - - a\r\n    - b\r\n```\r\n\r\nAnother option is to use the unit tests in the rewrite-yaml module e.g. in the `YamlParserTest.java`.\r\nAdd the following test and execute it.\r\n\r\n```java\r\n@Test\r\nvoid listOfLists() {\r\n    rewriteRun(\r\n      yaml(\r\n        \"\"\"\r\n          listOfLists:\r\n            - - a\r\n            - b\r\n          \"\"\"\r\n      )\r\n    );\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\nThe yaml should be parseable. Or: the test should succeed.\r\n\r\n## What did you see instead?\r\nParsing of the yaml fails due to:\r\n`When parsing and printing the source code back to text without modifications, the printed source didn't match the original source code. This means there is a bug in the parser implementation itself.`\r\n\r\n(This is because, the produced source code contains additional `-` signs.)\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n```\r\norg.opentest4j.AssertionFailedError: [When parsing and printing the source code back to text without modifications, the printed source didn't match the original source code. This means there is a bug in the parser implementation itself. Please open an issue to report this, providing a sample of the code that generated this error for \"file.yaml\":\r\ndiff --git a/file.yaml b/file.yaml\r\nindex edb1cf7..8cc0b6c 100644\r\n--- a/file.yaml\r\n+++ b/file.yaml\r\n@@ -1,4 +1,4 @@ \r\n root:\r\n     listOfLists:\r\n-      - - a\r\n+      - - - a\r\n         - b\r\n\\ No newline at end of file\r\n] \r\nexpected: \r\n  \"root:\r\n      listOfLists:\r\n        - - a\r\n          - b\"\r\n but was: \r\n  \"root:\r\n      listOfLists:\r\n        - - - a\r\n          - b\"\r\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\r\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)\r\n\tat java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\r\n\tat java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)\r\n\tat org.openrewrite.test.RewriteTest.assertContentEquals(RewriteTest.java:617)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:312)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:133)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:128)\r\n\tat org.openrewrite.yaml.YamlParserTest.listOfLists(YamlParserTest.java:70)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\nI've already identified the root cause and will create a PR containing the fix later today.\r\n",
    "issue_word_count": 490,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java"
    ],
    "base_commit": "93076a3e658db283c7b0920efde738f346c4c5cb",
    "head_commit": "91dbdaa1f37e73b1943724fb525f040d0fdf22ee",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4187",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4187",
    "dockerfile": "",
    "pr_merged_at": "2024-05-11T08:15:45.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\nindex c8d97be9b06..5647e18cbea 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n@@ -333,7 +333,10 @@ private Yaml.Documents parseFromInput(Path sourceFile, EncodingDetectingInputStr\n                         if (openingBracketIndex != -1) {\n                             int startIndex = commentAwareIndexOf(':', fullPrefix) + 1;\n                             startBracketPrefix = fullPrefix.substring(startIndex, openingBracketIndex);\n-                            lastEnd = event.getEndMark().getIndex();\n+                        }\n+                        lastEnd = event.getEndMark().getIndex();\n+                        if (shouldUseYamlParserBugWorkaround(sse)) {\n+                            lastEnd--;\n                         }\n                         blockStack.push(new SequenceBuilder(fmt, startBracketPrefix, anchor));\n                         break;\n@@ -375,6 +378,17 @@ private Yaml.Documents parseFromInput(Path sourceFile, EncodingDetectingInputStr\n         }\n     }\n \n+    /*\n+    The yaml-parser library unfortunately returns inconsistent marks.\n+    If the dashes of the sequence have an indentation, the end mark and the start mark point to the dash.\n+    If the dashes of the sequence do not have an indentation, the end mark will point to the character AFTER the dash.\n+    */\n+    private boolean shouldUseYamlParserBugWorkaround(SequenceStartEvent event) {\n+        int startChar = event.getStartMark().getBuffer()[event.getStartMark().getIndex()];\n+        int endChar = event.getEndMark().getBuffer()[event.getEndMark().getIndex()];\n+        return startChar == '-' && endChar != '-';\n+    }\n+\n     private Yaml.Anchor buildYamlAnchor(FormatPreservingReader reader, int lastEnd, String eventPrefix, String anchorKey, int eventEndIndex, boolean isForScalar) {\n         int anchorLength = isForScalar ? anchorKey.length() + 1 : anchorKey.length();\n         String whitespaceAndScalar = reader.prefix(\n@@ -398,16 +412,7 @@ private Yaml.Anchor buildYamlAnchor(FormatPreservingReader reader, int lastEnd,\n     }\n \n     private static int commentAwareIndexOf(char target, String s) {\n-        return commentAwareIndexOf(target, s, FindIndexStrategy.FIRST);\n-    }\n-\n-    /**\n-     * Return the first or last index of the target character that appears in a non-comment portion of the String,\n-     * or -1 if it does not appear.\n-     */\n-    private static int commentAwareIndexOf(char target, String s, FindIndexStrategy strategy) {\n         boolean inComment = false;\n-        int lastFoundIndex = -1;\n         for (int i = 0; i < s.length(); i++) {\n             char c = s.charAt(i);\n             if (inComment) {\n@@ -416,21 +421,13 @@ private static int commentAwareIndexOf(char target, String s, FindIndexStrategy\n                 }\n             } else {\n                 if (c == target) {\n-                    if (strategy == FindIndexStrategy.FIRST) {\n-                        return i;\n-                    }\n-                    lastFoundIndex = i;\n+                    return i;\n                 } else if (c == '#') {\n                     inComment = true;\n                 }\n             }\n         }\n-        return lastFoundIndex;\n-    }\n-\n-    private enum FindIndexStrategy {\n-        FIRST,\n-        LAST\n+        return -1;\n     }\n \n     @Override\n@@ -527,7 +524,7 @@ public void push(Yaml.Block block) {\n \n         public void push(Yaml.Block block, @Nullable String commaPrefix) {\n             String rawPrefix = block.getPrefix();\n-            int dashIndex = commentAwareIndexOf('-', rawPrefix, FindIndexStrategy.LAST);\n+            int dashIndex = commentAwareIndexOf('-', rawPrefix);\n             String entryPrefix;\n             String blockPrefix;\n             boolean hasDash = dashIndex != -1;\n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\nindex 72b173f4066..42a3ae292ad 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\n@@ -67,18 +67,38 @@ void fourBytesUnicode() {\n \n     @Test\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/4176\")\n-    void listOfLists() {\n+    void listsAndListsOfLists() {\n         rewriteRun(\n           yaml(\n             \"\"\"\n               root:\n-                  listOfLists:\n-                    - - a\n-                      - b\n-                    - - c\n-                      - d\n-                      - - e\n-                        - f\n+                normalListOfScalars:\n+                - a\n+                -  b\n+                normalListOfScalarsWithIndentation:\n+                  -  a\n+                  - b\n+                normalListOfMappings:\n+                  - a: b\n+                    c:  d\n+                  - e:  f\n+                normalListOfSquareBracketLists:\n+                  -   [ mno, pqr]\n+                  -  [stu , vwx]\n+                squareList: [x, y, z]\n+                listOfListsOfScalars:\n+                - - a\n+                  -  b\n+                listOfListsOfScalarsWithIndentation:\n+                  - - a\n+                    -  b\n+                listOfListsOfMappings:\n+                  - - a:  b\n+                      c: d\n+                    - e:  f\n+                listOfListsOfSquareBracketLists:\n+                  - - [mno, pqr ]\n+                    -  [stu , vwx]\n               \"\"\"\n           )\n         );\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4184",
    "pr_id": 4184,
    "issue_id": 4182,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ChangeType erroneously changes package of unrelated type\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\n- OpenRewrite v8.26.0-SNAPSHOT (via `org.openrewrite.recipe:rewrite-recipe-bom:latest.integration`)\r\n- Gradle plugin v6.13.0\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\nVery simple setup with just two classes and a single recipe via the Gradle plugin. Ignoring Java target and snapshot repository declaration, the build file looks like this:\r\n```kts\r\nplugins {\r\n    base\r\n    `java-library`\r\n    id(\"org.openrewrite.rewrite\") version \"6.13.0\"\r\n}\r\n\r\ndependencies {\r\n    implementation(platform(\"org.openrewrite.recipe:rewrite-recipe-bom:latest.integration\"))\r\n}\r\n\r\nrewrite {\r\n    activeRecipe(\r\n        \"test.ChangeTypeTest\",\r\n    )\r\n}\r\n```\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\nCreate two classes in the same package, where the class that should *not* be changed makes some kind of reference to a class that *should* be changed (e.g. via method parameters/return values, or generic type parameters):\r\n```java\r\npackage com.test; // This will erroneously be changed\r\n\r\npublic final class Test {\r\n\r\n    public A test() { // Any reference to A is required for the issue\r\n        return new A();\r\n    }\r\n}\r\n```\r\n```java\r\npackage com.test;\r\n\r\npublic final class A { // This will correctly be moved to the subpackage\r\n}\r\n```\r\n\r\nThe recipe used:\r\n```yml\r\n---\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: test.ChangeTypeTest\r\nrecipeList:\r\n  - org.openrewrite.java.ChangeType:\r\n      oldFullyQualifiedTypeName: com.test.A\r\n      newFullyQualifiedTypeName: com.test.sub.A\r\n```\r\n\r\n## What did you expect to see?\r\n`A` to be moved without further changes to `Test`\r\n\r\n## What did you see instead?\r\nThe package declaration of `Test` changes to `com.test.sub`. It also fails to add an import for `A`, but that might just be a result of the relevant issue here\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\nSure. I am vaguely familiar with visitor patterns through ASM, although I'd imagine an active contributor might be able to fix this faster than telling me what to look for",
    "issue_word_count": 510,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/ChangeType.java",
      "rewrite-test/src/main/java/org/openrewrite/test/SourceSpec.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java",
      "rewrite-test/src/main/java/org/openrewrite/test/SourceSpec.java"
    ],
    "base_commit": "212296420cd490706a23e1b11ee6c85a2813df61",
    "head_commit": "c9163dde772dead572babd45f5a49a7366f92463",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4184",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4184",
    "dockerfile": "",
    "pr_merged_at": "2024-05-12T09:42:47.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/ChangeType.java b/rewrite-java/src/main/java/org/openrewrite/java/ChangeType.java\nindex 3c2d0769668..41aa4159c41 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/ChangeType.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/ChangeType.java\n@@ -502,6 +502,15 @@ private ChangeClassDefinition(String oldFullyQualifiedTypeName, String newFullyQ\n         public J visit(@Nullable Tree tree, ExecutionContext ctx) {\n             if (tree instanceof JavaSourceFile) {\n                 JavaSourceFile cu = (JavaSourceFile) tree;\n+                for (J.ClassDeclaration declaration : cu.getClasses()) {\n+                    // Check the class name instead of source path, as it might differ\n+                    String fqn = declaration.getType().getFullyQualifiedName();\n+                    if (fqn.equals(originalType.getFullyQualifiedName())) {\n+                        getCursor().putMessage(\"UPDATE_PACKAGE\", true);\n+                        break;\n+                    }\n+                }\n+\n                 String oldPath = cu.getSourcePath().toString().replace('\\\\', '/');\n                 // The old FQN must exist in the path.\n                 String oldFqn = fqnToPath(originalType.getFullyQualifiedName());\n@@ -531,17 +540,20 @@ private boolean updatePath(JavaSourceFile sf, String oldPath, String newPath) {\n \n         @Override\n         public J.Package visitPackage(J.Package pkg, ExecutionContext ctx) {\n-            String original = pkg.getExpression().printTrimmed(getCursor()).replaceAll(\"\\\\s\", \"\");\n-            if (original.equals(originalType.getPackageName())) {\n-                JavaType.FullyQualified fq = TypeUtils.asFullyQualified(targetType);\n-                if (fq != null) {\n-                    if (fq.getPackageName().isEmpty()) {\n-                        getCursor().putMessageOnFirstEnclosing(J.CompilationUnit.class, \"UPDATE_PREFIX\", true);\n-                        //noinspection DataFlowIssue\n-                        return null;\n-                    } else {\n-                        String newPkg = targetType.getPackageName();\n-                        return JavaTemplate.builder(newPkg).contextSensitive().build().apply(getCursor(), pkg.getCoordinates().replace());\n+            Boolean updatePackage = getCursor().pollNearestMessage(\"UPDATE_PACKAGE\");\n+            if (updatePackage != null && updatePackage) {\n+                String original = pkg.getExpression().printTrimmed(getCursor()).replaceAll(\"\\\\s\", \"\");\n+                if (original.equals(originalType.getPackageName())) {\n+                    JavaType.FullyQualified fq = TypeUtils.asFullyQualified(targetType);\n+                    if (fq != null) {\n+                        if (fq.getPackageName().isEmpty()) {\n+                            getCursor().putMessageOnFirstEnclosing(J.CompilationUnit.class, \"UPDATE_PREFIX\", true);\n+                            //noinspection DataFlowIssue\n+                            return null;\n+                        } else {\n+                            String newPkg = targetType.getPackageName();\n+                            return JavaTemplate.builder(newPkg).contextSensitive().build().apply(getCursor(), pkg.getCoordinates().replace());\n+                        }\n                     }\n                 }\n             }\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java\nindex 87e6e654249..cf6e2364688 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangeTypeTest.java\n@@ -1802,4 +1802,48 @@ public void test(String s) {\n         );\n \n     }\n+\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4182\")\n+    @Test\n+    void doesNotModifyPackageOfSibling() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeType(\"org.openrewrite.Test\", \"org.openrewrite.subpackage.Test\", false)),\n+          java(\n+            \"\"\"\n+              package org.openrewrite;\n+              public class Test {\n+              }\n+              \"\"\",\n+            \"\"\"\n+              package org.openrewrite.subpackage;\n+              public class Test {\n+              }\n+              \"\"\"\n+          ),\n+          java(\n+            \"\"\"\n+              package org.openrewrite;\n+              \n+              import org.openrewrite.Test;\n+              \n+              public class Sibling {\n+                  public Test test() {\n+                      return new Test();\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              package org.openrewrite;\n+              \n+              import org.openrewrite.subpackage.Test;\n+              \n+              public class Sibling {\n+                  public Test test() {\n+                      return new Test();\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-test/src/main/java/org/openrewrite/test/SourceSpec.java b/rewrite-test/src/main/java/org/openrewrite/test/SourceSpec.java\nindex 45a5a6567b6..0a3353410cd 100644\n--- a/rewrite-test/src/main/java/org/openrewrite/test/SourceSpec.java\n+++ b/rewrite-test/src/main/java/org/openrewrite/test/SourceSpec.java\n@@ -106,7 +106,7 @@ Path getSourcePath() {\n     protected boolean noTrim = false;\n \n     /**\n-     * @param sourcePath The source path after the recipe is run.\n+     * @param sourcePath The source path before the recipe is run.\n      * @return This source spec.\n      */\n     public SourceSpec<T> path(Path sourcePath) {\n@@ -115,7 +115,7 @@ public SourceSpec<T> path(Path sourcePath) {\n     }\n \n     /**\n-     * @param sourcePath The source path after the recipe is run.\n+     * @param sourcePath The source path before the recipe is run.\n      * @return This source spec.\n      */\n     public SourceSpec<T> path(String sourcePath) {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4178",
    "pr_id": 4178,
    "issue_id": 4176,
    "repo": "openrewrite/rewrite",
    "problem_statement": "YAML: Unable to parse lists of lists \n## The Problem\r\nIn YAML documents it is allowed to define lists of lists.\r\n```yaml\r\nlistOfLists:\r\n  - - a\r\n    - b\r\n```\r\n\r\n**OpenRewrite is unable to parse this type of lists correctly.**\r\n\r\n---\r\n\r\nTo better understand the meaning of this document, here is the same document described in JSON:\r\n```json\r\n{\r\n  \"listOfLists\": [\r\n    [\"a\", \"b\"]\r\n  ]\r\n}\r\n```\r\n\r\n## What version of OpenRewrite are you using?\r\nI am using the OpenRewrite Gradle Plugin v6.12.0\r\n\r\n## How are you running OpenRewrite?\r\nI'm using the Gradle Plugin within a single module project.\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\nTo reproduce the problem, create a yaml file containing the following snippet and run the plugin.\r\n```yaml\r\nlistOfLists:\r\n  - - a\r\n    - b\r\n```\r\n\r\nAnother option is to use the unit tests in the rewrite-yaml module e.g. in the `YamlParserTest.java`.\r\nAdd the following test and execute it.\r\n\r\n```java\r\n@Test\r\nvoid listOfLists() {\r\n    rewriteRun(\r\n      yaml(\r\n        \"\"\"\r\n          listOfLists:\r\n            - - a\r\n            - b\r\n          \"\"\"\r\n      )\r\n    );\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\nThe yaml should be parseable. Or: the test should succeed.\r\n\r\n## What did you see instead?\r\nParsing of the yaml fails due to:\r\n`When parsing and printing the source code back to text without modifications, the printed source didn't match the original source code. This means there is a bug in the parser implementation itself.`\r\n\r\n(This is because, the produced source code contains additional `-` signs.)\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n```\r\norg.opentest4j.AssertionFailedError: [When parsing and printing the source code back to text without modifications, the printed source didn't match the original source code. This means there is a bug in the parser implementation itself. Please open an issue to report this, providing a sample of the code that generated this error for \"file.yaml\":\r\ndiff --git a/file.yaml b/file.yaml\r\nindex edb1cf7..8cc0b6c 100644\r\n--- a/file.yaml\r\n+++ b/file.yaml\r\n@@ -1,4 +1,4 @@ \r\n root:\r\n     listOfLists:\r\n-      - - a\r\n+      - - - a\r\n         - b\r\n\\ No newline at end of file\r\n] \r\nexpected: \r\n  \"root:\r\n      listOfLists:\r\n        - - a\r\n          - b\"\r\n but was: \r\n  \"root:\r\n      listOfLists:\r\n        - - - a\r\n          - b\"\r\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\r\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)\r\n\tat java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\r\n\tat java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)\r\n\tat org.openrewrite.test.RewriteTest.assertContentEquals(RewriteTest.java:617)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:312)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:133)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:128)\r\n\tat org.openrewrite.yaml.YamlParserTest.listOfLists(YamlParserTest.java:70)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\nI've already identified the root cause and will create a PR containing the fix later today.\r\n",
    "issue_word_count": 490,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java"
    ],
    "base_commit": "a2dd37807316fc6397ace0e2dd3de0875cdde75c",
    "head_commit": "c0fb5bdd518ab74b8b1a0d8317e033a2d44c68e1",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4178",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4178",
    "dockerfile": "",
    "pr_merged_at": "2024-05-09T08:59:56.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\nindex 51609566403..c8d97be9b06 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/YamlParser.java\n@@ -129,7 +129,7 @@ private Yaml.Documents parseFromInput(Path sourceFile, EncodingDetectingInputStr\n                 switch (event.getEventId()) {\n                     case DocumentEnd: {\n                         assert document != null;\n-                        if(blockStack.size() == 1 && blockStack.peek() instanceof ScalarBuilder) {\n+                        if (blockStack.size() == 1 && blockStack.peek() instanceof ScalarBuilder) {\n                             // The yaml document consists of a single scalar value not in a mapping or sequence\n                             ScalarBuilder builder = (ScalarBuilder) blockStack.pop();\n                             lastEnd = builder.getLastEnd();\n@@ -270,7 +270,7 @@ private Yaml.Documents parseFromInput(Path sourceFile, EncodingDetectingInputStr\n                             sequenceBuilder.push(finalScalar, commaPrefix);\n \n                         } else if (builder == null) {\n-                            if(!\"\".equals(finalScalar.getValue())) {\n+                            if (!\"\".equals(finalScalar.getValue())) {\n                                 // If the \"scalar\" is just a comment, allow it to accrue to the Document.End rather than create a phantom scalar\n                                 blockStack.push(new ScalarBuilder(finalScalar, event.getEndMark().getIndex()));\n                             }\n@@ -397,11 +397,17 @@ private Yaml.Anchor buildYamlAnchor(FormatPreservingReader reader, int lastEnd,\n         return new Yaml.Anchor(randomId(), prefix, postFix.toString(), Markers.EMPTY, anchorKey);\n     }\n \n+    private static int commentAwareIndexOf(char target, String s) {\n+        return commentAwareIndexOf(target, s, FindIndexStrategy.FIRST);\n+    }\n+\n     /**\n-     * Return the index of the target character if it appears in a non-comment portion of the String, or -1 if it does not appear.\n+     * Return the first or last index of the target character that appears in a non-comment portion of the String,\n+     * or -1 if it does not appear.\n      */\n-    private static int commentAwareIndexOf(char target, String s) {\n+    private static int commentAwareIndexOf(char target, String s, FindIndexStrategy strategy) {\n         boolean inComment = false;\n+        int lastFoundIndex = -1;\n         for (int i = 0; i < s.length(); i++) {\n             char c = s.charAt(i);\n             if (inComment) {\n@@ -410,13 +416,21 @@ private static int commentAwareIndexOf(char target, String s) {\n                 }\n             } else {\n                 if (c == target) {\n-                    return i;\n+                    if (strategy == FindIndexStrategy.FIRST) {\n+                        return i;\n+                    }\n+                    lastFoundIndex = i;\n                 } else if (c == '#') {\n                     inComment = true;\n                 }\n             }\n         }\n-        return -1;\n+        return lastFoundIndex;\n+    }\n+\n+    private enum FindIndexStrategy {\n+        FIRST,\n+        LAST\n     }\n \n     @Override\n@@ -513,7 +527,7 @@ public void push(Yaml.Block block) {\n \n         public void push(Yaml.Block block, @Nullable String commaPrefix) {\n             String rawPrefix = block.getPrefix();\n-            int dashIndex = commentAwareIndexOf('-', rawPrefix);\n+            int dashIndex = commentAwareIndexOf('-', rawPrefix, FindIndexStrategy.LAST);\n             String entryPrefix;\n             String blockPrefix;\n             boolean hasDash = dashIndex != -1;\n@@ -537,6 +551,7 @@ public SequenceWithPrefix build() {\n     private static class ScalarBuilder implements BlockBuilder {\n         Yaml.Scalar scalar;\n         int lastEnd;\n+\n         @Override\n         public void push(Yaml.Block block) {\n             throw new IllegalStateException(\"Unable to push on top of a scalar.\");\n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\nindex 1daf691cbc0..72b173f4066 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/YamlParserTest.java\n@@ -65,6 +65,25 @@ void fourBytesUnicode() {\n         );\n     }\n \n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4176\")\n+    void listOfLists() {\n+        rewriteRun(\n+          yaml(\n+            \"\"\"\n+              root:\n+                  listOfLists:\n+                    - - a\n+                      - b\n+                    - - c\n+                      - d\n+                      - - e\n+                        - f\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n     @ParameterizedTest\n     @ValueSource(strings = {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4174",
    "pr_id": 4174,
    "issue_id": 3200,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Rewrite fully qualified package name used as argument parameter inside annotation when using Change Package Name rewrite rule\nI think that Change package name rule https://docs.openrewrite.org/recipes/java/changepackage#source is ignoring the packages which are inside annotations.\r\n\r\nI see no reference of annotation in the implementation class: https://github.com/openrewrite/rewrite/blob/v7.40.5/rewrite-java/src/main/java/org/openrewrite/java/ChangePackage.java\r\n\r\nI think it is what it is used by the Quarkus OpenRewrite recipe. I reported intially in Quarkus repository: https://github.com/quarkusio/quarkus/issues/33157\r\n",
    "issue_word_count": 96,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/ChangePackage.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java"
    ],
    "base_commit": "ec09e19feba2ccff12cc20d0d684babde9aa7914",
    "head_commit": "60c6ca8283a34a1bd1b55ad16cfb4b74b821a734",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4174",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4174",
    "dockerfile": "",
    "pr_merged_at": "2024-05-09T07:30:23.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/ChangePackage.java b/rewrite-java/src/main/java/org/openrewrite/java/ChangePackage.java\nindex fc53843f647..f51ab465abd 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/ChangePackage.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/ChangePackage.java\n@@ -146,10 +146,12 @@ public J visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {\n         }\n \n         @Override\n-        public J.Package visitPackage(J.Package pkg, ExecutionContext ctx) {\n+        public J visitPackage(J.Package pkg, ExecutionContext ctx) {\n             String original = pkg.getExpression().printTrimmed(getCursor()).replaceAll(\"\\\\s\", \"\");\n             getCursor().putMessageOnFirstEnclosing(JavaSourceFile.class, RENAME_FROM_KEY, original);\n \n+            pkg = pkg.withAnnotations(ListUtils.map(pkg.getAnnotations(), a -> visitAndCast(a, ctx)));\n+\n             if (original.equals(oldPackageName)) {\n                 getCursor().putMessageOnFirstEnclosing(JavaSourceFile.class, RENAME_TO_KEY, newPackageName);\n \n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java\nindex 5db8a3715e0..f4364afd7f5 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/ChangePackageTest.java\n@@ -1546,4 +1546,54 @@ public void test(String s) {\n           )\n         );\n     }\n+\n+    @Test\n+    void packageInfoAnnotation() {\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              package org.openrewrite;\n+                          \n+              import java.lang.annotation.ElementType;\n+              import java.lang.annotation.Retention;\n+              import java.lang.annotation.RetentionPolicy;\n+              import java.lang.annotation.Target;\n+                          \n+              @Target(ElementType.PACKAGE)\n+              @Retention(RetentionPolicy.RUNTIME)\n+              public @interface MyAnnotation {\n+                  MyEnum myEnum() default MyEnum.FOO;\n+              }\n+              \"\"\",\n+            SourceSpec::skip\n+          ),\n+          java(\n+            \"\"\"\n+              package org.openrewrite;\n+                          \n+              public enum MyEnum {\n+                  FOO,\n+                  BAR\n+              }\n+              \"\"\",\n+            SourceSpec::skip\n+          ),\n+          java(\n+            \"\"\"\n+              @org.openrewrite.MyAnnotation(myEnum = org.openrewrite.MyEnum.BAR)\n+              package com.acme;\n+              \"\"\",\n+            \"\"\"\n+              @org.openrewrite.test.MyAnnotation(myEnum = org.openrewrite.test.MyEnum.BAR)\n+              package com.acme;\n+              \"\"\",\n+            spec -> spec.afterRecipe(cu -> {\n+                assertThat(cu.findType(\"org.openrewrite.MyAnnotation\")).isEmpty();\n+                assertThat(cu.findType(\"org.openrewrite.test.MyAnnotation\")).isNotEmpty();\n+                assertThat(cu.findType(\"org.openrewrite.MyEnum\")).isEmpty();\n+                assertThat(cu.findType(\"org.openrewrite.test.MyEnum\")).isNotEmpty();\n+            })\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4167",
    "pr_id": 4167,
    "issue_id": 4166,
    "repo": "openrewrite/rewrite",
    "problem_statement": "UpgradeDependencyVersion should support forcing exact version\n## What problem are you trying to solve?\r\n\r\nAs historic legacy, at my workplace internal maven artifact versions are in the format `major.minor-buildnumber`.\r\nI'm trying to use [UpgradeDependencyVersion](https://github.com/openrewrite/rewrite/blob/main/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java) to upgrade to an exact specific version `2.0-3`.\r\nBut this does not work because it is interpreted as a [hyphenated range](https://docs.openrewrite.org/reference/dependency-version-selectors#hyphenated-range) semver selector. \r\n\r\n## Describe the solution you'd like\r\n\r\nA way to force the version to be interpreted as an exact version.\r\n\r\n## Have you considered any alternatives or workarounds?\r\n\r\nCurrently using [ChangeDependencyGroupIdAndArtifactId](https://github.com/openrewrite/rewrite/blob/main/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeDependencyGroupIdAndArtifactId.java) as a workaround.\r\nThat works, but is not intended for this purpose and results in a recipe validation error \"newGroupId OR newArtifactId must be different from before\". ",
    "issue_word_count": 161,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/semver/ExactVersion.java",
      "rewrite-core/src/test/java/org/openrewrite/semver/SemverTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-core/src/test/java/org/openrewrite/semver/SemverTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java"
    ],
    "base_commit": "735b3931ec1921c6aa01ec88169d05c0935c5586",
    "head_commit": "aa8d6de8cfcbc47a9c2187d03ccc8a0d20af0845",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4167",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4167",
    "dockerfile": "",
    "pr_merged_at": "2024-05-05T09:29:15.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/semver/ExactVersion.java b/rewrite-core/src/main/java/org/openrewrite/semver/ExactVersion.java\nindex 824392a1574..8995bab9a14 100755\n--- a/rewrite-core/src/main/java/org/openrewrite/semver/ExactVersion.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/semver/ExactVersion.java\n@@ -18,12 +18,20 @@\n import org.openrewrite.Validated;\n import org.openrewrite.internal.lang.Nullable;\n \n+/**\n+ * Version selector for matching exact version: either explicitly prefixed with \"=\",\n+ * or implicit default when no other version selectors match.\n+ */\n public class ExactVersion extends LatestRelease {\n     String version;\n \n     public ExactVersion(String pattern) {\n         super(pattern);\n-        this.version = pattern;\n+        if (pattern.startsWith(\"=\")) {\n+            this.version = pattern.substring(1);\n+        } else {\n+            this.version = pattern;\n+        }\n     }\n \n     @Override\n@@ -32,6 +40,9 @@ public boolean isValid(@Nullable String currentVersion, String version) {\n     }\n \n     public static Validated<ExactVersion> build(String pattern) {\n+        if (pattern.startsWith(\"=\")) {\n+            return Validated.valid(\"exactVersion\", new ExactVersion(pattern));\n+        }\n         String versionOnly;\n         int hyphenIndex = pattern.indexOf('-');\n         if(hyphenIndex == -1) {\n",
    "test_patch": "diff --git a/rewrite-core/src/test/java/org/openrewrite/semver/SemverTest.java b/rewrite-core/src/test/java/org/openrewrite/semver/SemverTest.java\nindex b8bddc0aac2..798d964c97d 100644\n--- a/rewrite-core/src/test/java/org/openrewrite/semver/SemverTest.java\n+++ b/rewrite-core/src/test/java/org/openrewrite/semver/SemverTest.java\n@@ -38,5 +38,11 @@ void validToVersion() {\n           .isInstanceOf(CaretRange.class);\n         assertThat(Semver.validate(\"[1.5,2)\", null).getValue())\n           .isInstanceOf(SetRange.class);\n+        assertThat(Semver.validate(\"1.5.1\", null).getValue())\n+          .isInstanceOf(ExactVersion.class);\n+        assertThat(Semver.validate(\"=1.5.1\", null).getValue())\n+          .isInstanceOf(ExactVersion.class);\n+        assertThat(Semver.validate(\"=1.5-1\", null).getValue())\n+          .isInstanceOf(ExactVersion.class);\n     }\n }\n\ndiff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java\nindex de4864b233e..88eff79aa10 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/UpgradeDependencyVersionTest.java\n@@ -20,6 +20,7 @@\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n import org.openrewrite.DocumentExample;\n import org.openrewrite.Issue;\n import org.openrewrite.test.RewriteTest;\n@@ -1025,10 +1026,12 @@ void dependencyManagementResolvedFromProperty() {\n         );\n     }\n \n-    @Test\n-    void upgradeToExactVersion() {\n+    @ParameterizedTest\n+    @ValueSource(strings = { \"3.0.12.RELEASE\", \"=3.0.12.RELEASE\" })\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4166\")\n+    void upgradeToExactVersion(String version) {\n         rewriteRun(\n-          spec -> spec.recipe(new UpgradeDependencyVersion(\"org.thymeleaf\", \"thymeleaf-spring5\", \"3.0.12.RELEASE\", null,\n+          spec -> spec.recipe(new UpgradeDependencyVersion(\"org.thymeleaf\", \"thymeleaf-spring5\", version, null,\n             null, null)),\n           pomXml(\n             \"\"\"\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4155",
    "pr_id": 4155,
    "issue_id": 4154,
    "repo": "openrewrite/rewrite",
    "problem_statement": "No proper blank lines for anonymous inner class\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\n\r\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using:\r\n\r\n- OpenRewrite 8.17.1 (rewrite-recipe-bom:2.7.1)\r\n- Maven/Gradle plugin 3.9.1\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\nI am using the Maven plugin `rewrite-maven-plugin:5.27.0`, and my project is a single module project.\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\nAny recipes that want to refactor the Blank lines for anonymous inner classes can reproduce this issue. For example this simple test case per @timtebeek 's great suggestion.\r\n\r\n (run this test case will get error with `Recipe was expected to make a change but made no changes`)\r\n\r\n```java\r\npublic class BlankLinesTest implements RewriteTest {\r\n\r\n    private static Consumer<RecipeSpec> blankLines() {\r\n        return blankLines(style -> style);\r\n    }\r\n\r\n    private static Consumer<RecipeSpec> blankLines(UnaryOperator<BlankLinesStyle> with) {\r\n        return spec -> spec.recipe(new BlankLines())\r\n          .parser(JavaParser.fromJavaVersion().styles(singletonList(\r\n            new NamedStyles(\r\n              randomId(), \"test\", \"test\", \"test\", emptySet(),\r\n              singletonList(with.apply(IntelliJ.blankLines()))\r\n            )\r\n          )));\r\n    }\r\n\r\n    @Test\r\n    void eachMethodOnItsOwnLineAnonymousInnerClass() {\r\n\r\n        rewriteRun(\r\n          blankLines(),\r\n          java(\r\n            \"\"\"\r\n              public class Test {\r\n                  void c() {\r\n                      new Runnable() {\r\n                          void a() {\r\n                          }\r\n                          void b() {\r\n                          }\r\n                            \r\n                          public void run() {\r\n                          }\r\n                      };\r\n                  }\r\n              }\r\n              \"\"\",\r\n            \"\"\"\r\n              public class Test {\r\n                  void c() {\r\n                      new Runnable() {\r\n                          void a() {\r\n                          }\r\n                              \r\n                          void b() {\r\n                          }\r\n                              \r\n                          public void run() {\r\n                          }\r\n                      };\r\n                  }\r\n              }\r\n              \"\"\"\r\n          )\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\n```java\r\n              public class Test {\r\n                  void c() {\r\n                      new Runnable() {\r\n                          void a() {\r\n                          }\r\n                              \r\n                          void b() {\r\n                          }\r\n                              \r\n                          public void run() {\r\n                          }\r\n                      };\r\n                  }\r\n              }\r\n```\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\n`Recipe was expected to make a change but made no changes`.\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\r\n```\r\njava.lang.AssertionError: Recipe was expected to make a change but made no changes.\r\n\r\n\tat org.openrewrite.test.LargeSourceSetCheckingExpectedCycles.afterCycle(LargeSourceSetCheckingExpectedCycles.java:118)\r\n\tat org.openrewrite.RecipeScheduler.runRecipeCycles(RecipeScheduler.java:97)\r\n\tat org.openrewrite.RecipeScheduler.scheduleRun(RecipeScheduler.java:41)\r\n\tat org.openrewrite.Recipe.run(Recipe.java:344)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:375)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:133)\r\n\tat com.ebay.platform.recipe.ut.BlankLinesTest.eachMethodOnItsOwnLineAnnymousInnerClass(BlankLinesTest.java:39)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\n\r\nSure, once I'm more comfortable with the codebase.\r\n",
    "issue_word_count": 745,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/format/BlankLinesTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/format/BlankLinesVisitor.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/format/BlankLinesTest.java"
    ],
    "base_commit": "345a8f29998d218f8d5b4e75d2d4a1e826b48a9a",
    "head_commit": "1dfc615e573ea8e7042fb4708586f641d21cd059",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4155",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4155",
    "dockerfile": "",
    "pr_merged_at": "2024-04-28T10:39:08.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/format/BlankLinesVisitor.java b/rewrite-java/src/main/java/org/openrewrite/java/format/BlankLinesVisitor.java\nindex 68a4904c9e6..378c49613d6 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/format/BlankLinesVisitor.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/format/BlankLinesVisitor.java\n@@ -226,6 +226,19 @@ public Statement visitStatement(Statement statement, P p) {\n                     }\n                 }\n \n+                j = keepMaximumLines(j, declMax);\n+            } else if (grandparentTree instanceof J.NewClass && parentTree instanceof J.Block) {\n+                J.Block block = (J.Block) parentTree;\n+\n+                int declMax = style.getKeepMaximum().getInDeclarations();\n+\n+                if (!block.getStatements().isEmpty() && !block.getStatements().iterator().next().isScope(j)) {\n+                    if (j instanceof J.MethodDeclaration) {\n+                        declMax = Math.max(declMax, style.getMinimum().getAroundMethod());\n+                        j = minimumLines(j, style.getMinimum().getAroundMethod());\n+                    }\n+                }\n+\n                 j = keepMaximumLines(j, declMax);\n             } else {\n                 return keepMaximumLines(j, style.getKeepMaximum().getInCode());\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/format/BlankLinesTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/format/BlankLinesTest.java\nindex 3d5de986850..e4e72372a5b 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/format/BlankLinesTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/format/BlankLinesTest.java\n@@ -926,4 +926,56 @@ public enum Test {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4154\")\n+    void eachMethodOnItsOwnLineAnonymousInnerClass() {\n+        rewriteRun(\n+          blankLines(),\n+          java(\n+            \"\"\"\n+              public class Test {\n+                  void a() {\n+                      new Runnable() {\n+                          void b() {\n+                          }\n+                          void c() {\n+                          }\n+                            \n+                          public void run() {\n+                          }\n+            \n+                          public void d() {\n+                          }\n+                      };\n+                  }\n+                  void e() {\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              public class Test {\n+                  void a() {\n+                      new Runnable() {\n+                          void b() {\n+                          }\n+                              \n+                          void c() {\n+                          }\n+                              \n+                          public void run() {\n+                          }\n+            \n+                          public void d() {\n+                          }\n+                      };\n+                  }\n+    \n+                  void e() {\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4148",
    "pr_id": 4148,
    "issue_id": 4138,
    "repo": "openrewrite/rewrite",
    "problem_statement": "RemoveRedundantDependencyVersions - restore ability to remove newer version pins\n<!--\r\nThank you for suggesting a new recipe for OpenRewrite!\r\nFeel free to delete any sections that don't apply to your request.\r\n-->\r\n\r\n## What problem are you trying to solve?\r\n<!-- A description of a problem you encounter that you hope to resolve with a recipe. -->\r\nAdd an option for the functionality removed in this commit:\r\nhttps://github.com/openrewrite/rewrite/commit/687fbb55709b7d6ee0a648c425d8b0b94fce65d5\r\n(from @sambsnyd )\r\n\r\n## What precondition(s) should be checked before applying this recipe?\r\n<!-- Should we limit execution to certain versions of languages or libraries for instance? -->\r\nN/A\r\n\r\n## Describe the situation before applying the recipe\r\n<!-- Ideally as a self-contained code example, as a start to the recipe unit tests. -->\r\n```xml\r\n              <project>\r\n                  <modelVersion>4.0.0</modelVersion>\r\n                  <groupId>org.sample</groupId>\r\n                  <artifactId>sample</artifactId>\r\n                  <version>1.0.0</version>\r\n                  <parent>\r\n                      <groupId>org.springframework.boot</groupId>\r\n                      <artifactId>spring-boot-starter-parent</artifactId>\r\n                      <version>2.7.18</version>\r\n                      <relativePath/>\r\n                  </parent>\r\n                  <build>\r\n                      <plugins>\r\n                          <plugin>\r\n                              <groupId>pl.project13.maven</groupId>\r\n                              <artifactId>git-commit-id-plugin</artifactId>\r\n                              <!-- version in pom is 4.9.10, pin is newer-->\r\n                              <version>4.9.11</version>\r\n                          </plugin>\r\n                      </plugins>\r\n                  </build>\r\n              </project>\r\n```\r\n\r\n## Describe the situation after applying the recipe\r\n<!-- Ideally as a self-contained code example, as a start to the recipe unit tests. -->\r\n```xml\r\n              <project>\r\n                  <modelVersion>4.0.0</modelVersion>\r\n                  <groupId>org.sample</groupId>\r\n                  <artifactId>sample</artifactId>\r\n                  <version>1.0.0</version>\r\n                  <parent>\r\n                      <groupId>org.springframework.boot</groupId>\r\n                      <artifactId>spring-boot-starter-parent</artifactId>\r\n                      <version>2.7.18</version>\r\n                      <relativePath/>\r\n                  </parent>\r\n                  <build>\r\n                      <plugins>\r\n                          <plugin>\r\n                              <groupId>pl.project13.maven</groupId>\r\n                              <artifactId>git-commit-id-plugin</artifactId>\r\n                          </plugin>\r\n                      </plugins>\r\n                  </build>\r\n              </project>\r\n```\r\n\r\n## Have you considered any alternatives or workarounds?\r\n<!-- Any other ways to solve the problem, or ways to work around the problem. -->\r\n\r\n## Any additional context\r\n<!-- Any thoughts such as considerations and limitations when applying this recipe, or hints on the implementation. -->\r\nThis (removed) behavior can be useful if you want to strictly rely on parent-provided versions, and implicitly \"distrust\" the validity of existing pinned versions (or anticipate that they will become a problem eventually as the parent version increases)\r\n\r\n## Are you interested in [contributing this recipe to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#adding-new-recipes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\nYes -- mainly opening this issue first in case anyone has design input.\r\n\r\nThe least-intrusive implementation would be a new, additional flag, such as `removeNewerVersions`, which works in conjunction with `onlyIfVersionsMatch`. But the naming/usage starts to get fuzzy -- what if someone sets `onlyIfVersionsMatch` `true` and also `removeNewerVersions` `true`? We can validate those cases out, but, it's unintuitive.\r\n\r\nCould also argue that `onlyIfVersionsMatch` is now an inaccurate name, since on `false`, it does not remove non-matching newer versions.\r\n\r\nReplacing this field with some kind of `removalStrategy` enum could be nice, with values like `matching`, `older`, `any`, but replacing an arg like that can be disruptive for existing usage, and naming the new arg also takes some good thought (I don't love the value names I just suggested, eg).\r\n\r\nEager for any opinions",
    "issue_word_count": 523,
    "test_files_count": 2,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "rewrite-core/src/test/java/org/openrewrite/config/YamlResourceLoaderTest.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/ChangeParentPom.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/RemoveRedundantDependencyVersions.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/RemoveRedundantDependencyVersionsTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-core/src/test/java/org/openrewrite/config/YamlResourceLoaderTest.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/RemoveRedundantDependencyVersionsTest.java"
    ],
    "base_commit": "ec09e19feba2ccff12cc20d0d684babde9aa7914",
    "head_commit": "dae7defa9fa05261922fc9eda35af317cfd0c594",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4148",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4148",
    "dockerfile": "",
    "pr_merged_at": "2024-05-21T22:19:16.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\nindex 96f88519a30..a08059b285e 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeManagedDependencyGroupIdAndArtifactId.java\n@@ -166,7 +166,7 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                     }\n                     if (changed) {\n                         maybeUpdateModel();\n-                        doAfterVisit(new RemoveRedundantDependencyVersions(null, null, null, null).getVisitor());\n+                        doAfterVisit(new RemoveRedundantDependencyVersions(null, null, null, null, null).getVisitor());\n                     }\n                 }\n                 return t;\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeParentPom.java b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeParentPom.java\nindex bf373c977b9..8f81310aa0b 100755\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeParentPom.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/ChangeParentPom.java\n@@ -229,7 +229,8 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                                     doAfterVisit(visitor);\n                                 }\n                                 maybeUpdateModel();\n-                                doAfterVisit(new RemoveRedundantDependencyVersions(null, null, false, null).getVisitor());\n+                                doAfterVisit(new RemoveRedundantDependencyVersions(null, null, null,\n+                                        RemoveRedundantDependencyVersions.Comparator.GTE, null).getVisitor());\n                             }\n                         } catch (MavenDownloadingException e) {\n                             for (Map.Entry<MavenRepository, String> repositoryResponse : e.getRepositoryResponses().entrySet()) {\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/RemoveRedundantDependencyVersions.java b/rewrite-maven/src/main/java/org/openrewrite/maven/RemoveRedundantDependencyVersions.java\nindex 3340f8a2a21..b7401ad1d06 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/RemoveRedundantDependencyVersions.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/RemoveRedundantDependencyVersions.java\n@@ -15,6 +15,7 @@\n  */\n package org.openrewrite.maven;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n import lombok.EqualsAndHashCode;\n import lombok.Value;\n import org.openrewrite.*;\n@@ -58,8 +59,19 @@ public class RemoveRedundantDependencyVersions extends Recipe {\n                           \"Default `true`.\",\n             required = false)\n     @Nullable\n+    @Deprecated\n+    @SuppressWarnings(\"DeprecatedIsStillUsed\")\n     Boolean onlyIfVersionsMatch;\n \n+    @Option(displayName = \"Only if managed version is ...\",\n+            description = \"Only remove the explicit version if the managed version has the specified comparative relationship to the explicit version. \" +\n+                    \"For example, `gte` will only remove the explicit version if the managed version is the same or newer. \" +\n+                    \"Default `eq`.\",\n+            valid = { \"any\", \"eq\", \"lt\", \"lte\", \"gt\", \"gte\" },\n+            required = false)\n+    @Nullable\n+    Comparator onlyIfManagedVersionIs;\n+\n     @Option(displayName = \"Except\",\n             description = \"Accepts a list of GAVs. Dependencies matching a GAV will be ignored by this recipe.\"\n                           + \" GAV versions are ignored if provided.\",\n@@ -68,6 +80,39 @@ public class RemoveRedundantDependencyVersions extends Recipe {\n     @Nullable\n     List<String> except;\n \n+    @Deprecated\n+    public RemoveRedundantDependencyVersions(@Nullable String groupPattern, @Nullable String artifactPattern,\n+            @Nullable Boolean onlyIfVersionsMatch, @Nullable List<String> except) {\n+        this(groupPattern, artifactPattern, onlyIfVersionsMatch, null, except);\n+    }\n+\n+    public RemoveRedundantDependencyVersions(@Nullable String groupPattern, @Nullable String artifactPattern,\n+            @Nullable Comparator onlyIfManagedVersionIs, @Nullable List<String> except) {\n+        this(groupPattern, artifactPattern, null, onlyIfManagedVersionIs, except);\n+    }\n+\n+    @JsonCreator\n+    @Deprecated\n+    @SuppressWarnings(\"DeprecatedIsStillUsed\")\n+    public RemoveRedundantDependencyVersions(@Nullable String groupPattern, @Nullable String artifactPattern,\n+            @Nullable Boolean onlyIfVersionsMatch, @Nullable Comparator onlyIfManagedVersionIs,\n+            @Nullable List<String> except) {\n+        this.groupPattern = groupPattern;\n+        this.artifactPattern = artifactPattern;\n+        this.onlyIfVersionsMatch = onlyIfVersionsMatch;\n+        this.onlyIfManagedVersionIs = onlyIfManagedVersionIs;\n+        this.except = except;\n+    }\n+\n+    public enum Comparator {\n+        ANY,\n+        EQ,\n+        LT,\n+        LTE,\n+        GT,\n+        GTE\n+    }\n+\n     @Override\n     public String getDisplayName() {\n         return \"Remove redundant explicit dependency and plugin versions\";\n@@ -95,18 +140,32 @@ public Validated<Object> validate() {\n                         }));\n             }\n         }\n+        if (onlyIfVersionsMatch != null && onlyIfManagedVersionIs != null) {\n+            validated = validated.and(Validated.invalid(\"onlyIfVersionsMatch\", onlyIfVersionsMatch, \"is deprecated in favor of onlyIfManagedVersionIs, and they cannot be used together\"));\n+        }\n         return validated;\n     }\n \n+    private Comparator determineComparator() {\n+        if (onlyIfVersionsMatch != null) {\n+            return onlyIfVersionsMatch ? Comparator.EQ : Comparator.GTE;\n+        }\n+        if (onlyIfManagedVersionIs != null) {\n+            return onlyIfManagedVersionIs;\n+        }\n+        return Comparator.EQ;\n+    }\n+\n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n+        Comparator comparator = determineComparator();\n         return new MavenIsoVisitor<ExecutionContext>() {\n             @Override\n             public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {\n                 Xml.Document d = super.visitDocument(document, ctx);\n                 if (d != document) {\n                     d = (Xml.Document) new RemoveEmptyDependencyTags().visitNonNull(d, ctx);\n-                    if (onlyIfVersionsMatch == null || !onlyIfVersionsMatch) {\n+                    if (!comparator.equals(Comparator.EQ)) {\n                         maybeUpdateModel();\n                     }\n                 }\n@@ -189,10 +248,7 @@ private boolean matchesVersion(ResolvedManagedDependency d, ExecutionContext ctx\n                     if (versionAccordingToParent == null) {\n                         return false;\n                     }\n-                    if (isExactMatchRequired()) {\n-                        return Objects.equals(versionAccordingToParent, d.getRequested().getVersion());\n-                    }\n-                    return isManagedNewerThanRequested(versionAccordingToParent, d.getRequested().getVersion());\n+                    return matchesComparator(versionAccordingToParent, d.getRequested().getVersion());\n                 } catch (Exception e) {\n                     return false;\n                 }\n@@ -204,10 +260,7 @@ private boolean matchesVersion(ResolvedDependency d) {\n                 }\n                 String managedVersion = getResolutionResult().getPom().getManagedVersion(d.getGroupId(),\n                         d.getArtifactId(), d.getRequested().getType(), d.getRequested().getClassifier());\n-                if (isExactMatchRequired()) {\n-                    return Objects.equals(managedVersion, d.getRequested().getVersion());\n-                }\n-                return isManagedNewerThanRequested(managedVersion, d.getRequested().getVersion());\n+                return matchesComparator(managedVersion, d.getRequested().getVersion());\n             }\n \n             private boolean matchesVersion(Plugin p) {\n@@ -215,19 +268,25 @@ private boolean matchesVersion(Plugin p) {\n                     return false;\n                 }\n                 String managedVersion = getManagedPluginVersion(getResolutionResult().getPom(), p.getGroupId(), p.getArtifactId());\n-                if (isExactMatchRequired()) {\n-                    return Objects.equals(managedVersion, p.getVersion());\n-                }\n-                return isManagedNewerThanRequested(managedVersion, p.getVersion());\n+                return matchesComparator(managedVersion, p.getVersion());\n             }\n \n-            private boolean isManagedNewerThanRequested(@Nullable String managedVersion, String requestedVersion) {\n-                return managedVersion != null && new LatestIntegration(null)\n-                                                         .compare(null, managedVersion, requestedVersion) >= 0;\n-            }\n-\n-            private boolean isExactMatchRequired() {\n-                return onlyIfVersionsMatch == null || onlyIfVersionsMatch;\n+            private boolean matchesComparator(@Nullable String managedVersion, String requestedVersion) {\n+                if (managedVersion == null) {\n+                    return false;\n+                }\n+                if (comparator.equals(Comparator.ANY)) {\n+                    return true;\n+                }\n+                int comparison = new LatestIntegration(null)\n+                        .compare(null, managedVersion, requestedVersion);\n+                if (comparison < 0) {\n+                    return comparator.equals(Comparator.LT) || comparator.equals(Comparator.LTE);\n+                } else if (comparison > 0) {\n+                    return comparator.equals(Comparator.GT) || comparator.equals(Comparator.GTE);\n+                } else {\n+                    return comparator.equals(Comparator.EQ) || comparator.equals(Comparator.LTE) || comparator.equals(Comparator.GTE);\n+                }\n             }\n \n             private boolean isNotExcepted(ResolvedDependency d) {\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java b/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\nindex 765cc12f166..21d584c5d5a 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/UpgradeDependencyVersion.java\n@@ -174,7 +174,7 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n \n                 if (t != tag && PROJECT_MATCHER.matches(getCursor())) {\n                     maybeUpdateModel();\n-                    doAfterVisit(new RemoveRedundantDependencyVersions(groupId, artifactId, true, null).getVisitor());\n+                    doAfterVisit(new RemoveRedundantDependencyVersions(groupId, artifactId, null, null, null).getVisitor());\n                 }\n \n                 return t;\n@@ -189,10 +189,11 @@ public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                             TreeVisitor<Xml, ExecutionContext> upgradeManagedDependency = upgradeManagedDependency(tag, ctx, t);\n                             if (upgradeManagedDependency != null) {\n                                 retainVersions();\n-                                doAfterVisit(new RemoveRedundantDependencyVersions(null, null, true, retainVersions).getVisitor());\n+                                doAfterVisit(new RemoveRedundantDependencyVersions(null, null, null, null,\n+                                        retainVersions).getVisitor());\n                                 doAfterVisit(upgradeManagedDependency);\n                                 maybeUpdateModel();\n-                                doAfterVisit(new RemoveRedundantDependencyVersions(null, null, true, null).getVisitor());\n+                                doAfterVisit(new RemoveRedundantDependencyVersions(null, null, null, null, null).getVisitor());\n                             }\n                         }\n                     } catch (MavenDownloadingException e) {\n",
    "test_patch": "diff --git a/rewrite-core/src/test/java/org/openrewrite/config/YamlResourceLoaderTest.java b/rewrite-core/src/test/java/org/openrewrite/config/YamlResourceLoaderTest.java\nindex a0fe357d1d5..dff4663c754 100644\n--- a/rewrite-core/src/test/java/org/openrewrite/config/YamlResourceLoaderTest.java\n+++ b/rewrite-core/src/test/java/org/openrewrite/config/YamlResourceLoaderTest.java\n@@ -305,7 +305,7 @@ void caseInsensitiveEnums() {\n                     content: \" World!\"\n                     preamble: \"preamble\"\n                     appendNewline : false\n-                    existingFileStrategy: \"Continue\"\n+                    existingFileStrategy: \"cOnTiNuE\"\n               \"\"\",\n             \"org.openrewrite.gradle.testCaseInsensitiveEnumInYaml\"\n           ),\n\ndiff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveRedundantDependencyVersionsTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveRedundantDependencyVersionsTest.java\nindex 5ea1a087b2b..ab4133df140 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveRedundantDependencyVersionsTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveRedundantDependencyVersionsTest.java\n@@ -16,6 +16,8 @@\n package org.openrewrite.maven;\n \n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n import org.openrewrite.DocumentExample;\n import org.openrewrite.Issue;\n import org.openrewrite.test.RecipeSpec;\n@@ -30,7 +32,7 @@ class RemoveRedundantDependencyVersionsTest implements RewriteTest {\n \n     @Override\n     public void defaults(RecipeSpec spec) {\n-        spec.recipe(new RemoveRedundantDependencyVersions(null, null, null, null));\n+        spec.recipe(new RemoveRedundantDependencyVersions(null, null, null, null, null));\n     }\n \n     @Test\n@@ -952,7 +954,7 @@ void givenNestedPomsWhenVersionDoesntMatchAnyDmThenKeepIt() {\n     @Test\n     void onlyIfVersionsMatchFalse() {\n         rewriteRun(\n-          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, false, null)),\n+          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, false, null, null)),\n           pomXml(\n             \"\"\"\n               <project>\n@@ -1016,7 +1018,8 @@ void onlyIfVersionsMatchFalse() {\n     @Test\n     void except() {\n         rewriteRun(\n-          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, false, Collections.singletonList(\"org.junit.jupiter:junit-jupiter-api\"))),\n+          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, RemoveRedundantDependencyVersions.Comparator.GTE,\n+                  Collections.singletonList(\"org.junit.jupiter:junit-jupiter-api\"))),\n           pomXml(\n             \"\"\"\n               <project>\n@@ -1090,9 +1093,9 @@ void unmanagedDependency() {\n \n     @Test\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/3268\")\n-    void unmanagedDependencyOnlyIfVersionsMatchFalse() {\n+    void unmanagedDependencyAnyMatch() {\n         rewriteRun(\n-          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, false, null)),\n+          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, RemoveRedundantDependencyVersions.Comparator.ANY, null)),\n           pomXml(\n             \"\"\"\n               <project>\n@@ -1116,7 +1119,7 @@ void unmanagedDependencyOnlyIfVersionsMatchFalse() {\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/3932\")\n     void removeRedundantVersionsFromPluginsManagedByParent() {\n         rewriteRun(\n-          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, false, null)),\n+          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, RemoveRedundantDependencyVersions.Comparator.GTE, null)),\n           pomXml(\n             \"\"\"\n               <project>\n@@ -1171,7 +1174,7 @@ void removeRedundantVersionsFromPluginsManagedByParent() {\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/3932\")\n     void noChangesIfManagedPluginVersionDoesNotMatch() {\n         rewriteRun(\n-          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, true, null)),\n+          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, RemoveRedundantDependencyVersions.Comparator.EQ, null)),\n           pomXml(\n             \"\"\"\n               <project>\n@@ -1203,7 +1206,7 @@ void noChangesIfManagedPluginVersionDoesNotMatch() {\n     @Test\n     void doesNotDowngradeVersion() {\n         rewriteRun(\n-          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, false, null)),\n+          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, RemoveRedundantDependencyVersions.Comparator.GTE, null)),\n           pomXml(\n             \"\"\"\n               <project>\n@@ -1236,7 +1239,7 @@ void doesNotDowngradeVersion() {\n     @Test\n     void allowUpgradeOfManagedVersion() {\n         rewriteRun(\n-          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, false, null)),\n+          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, RemoveRedundantDependencyVersions.Comparator.GTE, null)),\n           pomXml(\n             \"\"\"\n                 <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n@@ -1292,9 +1295,9 @@ void allowUpgradeOfManagedVersion() {\n     @Test\n     void propertySubstitution() {\n         rewriteRun(\n-          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, false, null)),\n+          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, RemoveRedundantDependencyVersions.Comparator.GTE, null)),\n           pomXml(\n-                \"\"\"\n+            \"\"\"\n             <project>\n                 <parent>\n                     <groupId>org.springframework.boot</groupId>\n@@ -1318,7 +1321,87 @@ void propertySubstitution() {\n                     </plugins>\n                 </build>\n             </project>\n-            \"\"\")\n+            \"\"\"\n+          )\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({ \"GT,2.5.0\", \"GTE,2.5.0\", \"ANY,2.5.0\", \"EQ,2.5.1\", \"LTE,2.5.1\", \"GTE,2.5.1\", \"ANY,2.5.1\", \"LT,2.5.2\", \"LTE,2.5.2\", \"ANY,2.5.2\" })\n+    void onlyIfManagedVersionIs_removals(String comparator, String projectVersion) {\n+        rewriteRun(\n+          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, RemoveRedundantDependencyVersions.Comparator.valueOf(comparator), null)),\n+          pomXml(\n+            String.format(\"\"\"\n+                <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                    <modelVersion>4.0.0</modelVersion>\n+                    <parent>\n+                        <groupId>org.springframework.boot</groupId>\n+                        <artifactId>spring-boot-starter-parent</artifactId>\n+                        <version>2.5.1</version>\n+                    </parent>\n+                    <groupId>com.example</groupId>\n+                    <artifactId>acme</artifactId>\n+                    <version>0.0.1-SNAPSHOT</version>\n+                    <dependencies>\n+                        <dependency>\n+                            <groupId>org.springframework.boot</groupId>\n+                            <artifactId>spring-boot-starter-web</artifactId>\n+                            <version>%s</version>\n+                        </dependency>\n+                    </dependencies>\n+                </project>\n+                \"\"\", projectVersion),\n+            \"\"\"\n+                <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                    <modelVersion>4.0.0</modelVersion>\n+                    <parent>\n+                        <groupId>org.springframework.boot</groupId>\n+                        <artifactId>spring-boot-starter-parent</artifactId>\n+                        <version>2.5.1</version>\n+                    </parent>\n+                    <groupId>com.example</groupId>\n+                    <artifactId>acme</artifactId>\n+                    <version>0.0.1-SNAPSHOT</version>\n+                    <dependencies>\n+                        <dependency>\n+                            <groupId>org.springframework.boot</groupId>\n+                            <artifactId>spring-boot-starter-web</artifactId>\n+                        </dependency>\n+                    </dependencies>\n+                </project>\n+                \"\"\"\n+          )\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({ \"LT,2.5.0\", \"LTE,2.5.0\", \"EQ,2.5.0\", \"LT,2.5.1\", \"GT,2.5.1\", \"GT,2.5.2\", \"GTE,2.5.2\", \"EQ,2.5.2\" })\n+    void onlyIfManagedVersionIs_nonremovals(String comparator, String projectVersion) {\n+        rewriteRun(\n+          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, RemoveRedundantDependencyVersions.Comparator.valueOf(comparator), null)),\n+          pomXml(\n+            String.format(\"\"\"\n+                <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+                    <modelVersion>4.0.0</modelVersion>\n+                    <parent>\n+                        <groupId>org.springframework.boot</groupId>\n+                        <artifactId>spring-boot-starter-parent</artifactId>\n+                        <version>2.5.1</version>\n+                    </parent>\n+                    <groupId>com.example</groupId>\n+                    <artifactId>acme</artifactId>\n+                    <version>0.0.1-SNAPSHOT</version>\n+                    <dependencies>\n+                        <dependency>\n+                            <groupId>org.springframework.boot</groupId>\n+                            <artifactId>spring-boot-starter-web</artifactId>\n+                            <version>%s</version>\n+                        </dependency>\n+                    </dependencies>\n+                </project>\n+                \"\"\", projectVersion)\n+          )\n         );\n     }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4146",
    "pr_id": 4146,
    "issue_id": 4145,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Missing `execution`s from `ResolvedPom`\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\n\r\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\n- OpenRewrite v8.20.0\r\n  - pom `org.openrewrite.recipe:rewrite-recipe-bom:2.8.0`\r\n- Maven/Gradle plugin v1.2.3\r\n- rewrite-core v8.20.0\r\n- rewrite-maven v8.20.0\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\nI am writing a recipe and was running tests for it. This plugin is supposed to cleanup plugins duplicated configuration, i.e., any configuration that is already defined in the `<pluginManagement/>` section for the plugin.\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\nimagine I have a project that is using `com.foo:first-parent:1.0.0` as it’s parent, and `com.foo.first-parent:1.0.0`  is defined as\r\n```xml\r\n<project>\r\n  <parent>\r\n    <groupId>com.foo</groupId>\r\n    <artifactId>grand-parent</artifactId>\r\n    <version>1.0.0</version>\r\n  </parent>\r\n  <groupId>com.foo</groupId>\r\n  <artifactId>first-parent</artifactId>\r\n  <build>\r\n    <pluginManagement>\r\n      <plugins>\r\n        <plugin>\r\n          <groupId>com.foo</groupId>\r\n          <artifactId>plugin-artifact-id</artifactId>\r\n          <executions>\r\n            <execution>\r\n              <id>present-in-first-parent</id>\r\n              <!-- ... configs ... -->\r\n            </execution>\r\n          </executions>\r\n        </plugin>\r\n      </plugins>\r\n    </pluginManagement>\r\n  </build>\r\n</project>\r\n```\r\n\r\nthen the `com.foo:grand-parent:1.0.0` is defined as follows:\r\n\r\n```xml\r\n<!-- grand parent -->\r\n<project>\r\n  <groupId>com.foo</groupId>\r\n  <artifactId>grand-parent</artifactId>\r\n  <version>1.0.0</version>\r\n  \r\n  <build>\r\n    <pluginManagement>\r\n      <plugins>\r\n        <plugin>\r\n          <groupId>com.foo</groupId>\r\n          <artifactId>plugin-artifact-id</artifactId>\r\n          <executions>\r\n            <execution>\r\n              <id>present-in-grand-parent</id>\r\n              <!-- ... configs ... -->\r\n            </execution>\r\n          </executions>\r\n        </plugin>\r\n      </plugins>\r\n    </pluginManagement>\r\n  </build>\r\n</project>\r\n```\r\n\r\nA `mvn help:effective-pom` from a project using `com.foo:first-parent` should look something like\r\n\r\n```xml\r\n<project>\r\n  <parent>\r\n    <groupId>com.foo</groupId>\r\n    <artifactId>first-parent</artifactId>\r\n    <version>1.0.0</version>\r\n  </parent>\r\n  <groupId>com.foo</groupId>\r\n  <artifactId>my-project</artifactId>\r\n\r\n  <build>\r\n    <pluginManagement>\r\n      <plugins>\r\n        <plugin>\r\n          <groupId>com.foo</groupId>\r\n          <artifactId>plugin-artifact-id</artifactId>\r\n          <executions>\r\n            <execution>\r\n              <id>present-in-first-parent</id>\r\n              <!-- ... configs ... -->\r\n            </execution>\r\n            <execution>\r\n              <id>present-in-grand-parent</id>\r\n              <!-- ... configs ... -->\r\n            </execution>\r\n          </executions>\r\n        </plugin>\r\n      </plugins>\r\n    </pluginManagement>\r\n  </build>\r\n</project>\r\n```\r\n\r\ni.e., the `com.foo:plugin-artifact-id` has the `execution` both defined at `com.foo:grand-father` and `com.foo:first-parent`.\r\n\r\nThe problem is that a `getResolutionResult().getPom()` is only returning the execution `present-in-first-parent`.\r\n\r\n## What did you expect to see?\r\n\r\nI expected the `getResolutionResult` to return the same as an effective pom, with both `present-in-first-parent` and `present-in-grand-parent` present in the `getExecutions()`.\r\n\r\n## What did you see instead?\r\n\r\nI've seen only the `present-in-first-parent`\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n\r\nno errors.\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\nI may be able to contribute, but so far I haven't been able to spend much time\r\n",
    "issue_word_count": 766,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/tree/Plugin.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/tree/ResolvedPomTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/tree/ResolvedPomTest.java"
    ],
    "base_commit": "4ddbe4ba9442a1e1802682b634caf09cc60ce37b",
    "head_commit": "6646bb9953410f259b7336ae918d1503fc3889fe",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4146",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4146",
    "dockerfile": "",
    "pr_merged_at": "2024-04-23T10:24:34.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Plugin.java b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Plugin.java\nindex 7816f6adc6e..dee987fe0d9 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Plugin.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/Plugin.java\n@@ -54,6 +54,7 @@ public class Plugin {\n     public static class Execution {\n \n         String id;\n+        @Nullable\n         List<String> goals;\n \n         String phase;\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\nindex 42c72f0b59e..8620050790d 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/tree/ResolvedPom.java\n@@ -40,9 +40,12 @@\n import org.openrewrite.maven.internal.VersionRequirement;\n import org.openrewrite.maven.tree.ManagedDependency.Defined;\n import org.openrewrite.maven.tree.ManagedDependency.Imported;\n+import org.openrewrite.maven.tree.Plugin.Execution;\n \n import java.util.*;\n+import java.util.function.Function;\n import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n \n import static java.util.Collections.*;\n import static org.openrewrite.internal.StringUtils.matchesGlob;\n@@ -607,8 +610,54 @@ private JsonNode combineLists(JsonNode list, JsonNode incomingList) {\n             return ret;\n         }\n \n-        private List<Plugin.Execution> mergePluginExecutions(List<Plugin.Execution> executions, List<Plugin.Execution> incomingExecutions) {\n-            return executions.isEmpty() ? incomingExecutions : executions; // TODO\n+        private List<Plugin.Execution> mergePluginExecutions(List<Plugin.Execution> currentExecutions, List<Plugin.Execution> incomingExecutions) {\n+            if (currentExecutions.isEmpty()) {\n+                return incomingExecutions;\n+            }\n+            if (incomingExecutions.isEmpty()) {\n+                return currentExecutions;\n+            }\n+            Map<String, Plugin.Execution> currentExecutionsById = currentExecutions.stream()\n+                    .collect(Collectors.toMap(Execution::getId, Function.identity()));\n+            List<Plugin.Execution> mergedExecutions = new ArrayList<>(currentExecutions);\n+\n+            for (Plugin.Execution incomingExecution : incomingExecutions) {\n+                String executionId = incomingExecution.getId();\n+                if (!currentExecutionsById.containsKey(executionId)) {\n+                    mergedExecutions.add(incomingExecution);\n+                } else {\n+                    Plugin.Execution currentExecution = currentExecutionsById.get(executionId);\n+                    // GOALS\n+                    Set<String> mergedGoals = new HashSet<>();\n+                    if (currentExecution.getGoals() != null) {\n+                        mergedGoals.addAll(currentExecution.getGoals());\n+                    }\n+                    if (incomingExecution.getGoals() != null) {\n+                        mergedGoals.addAll(incomingExecution.getGoals());\n+                    }\n+                    // PHASE\n+                    String mergedPhase = currentExecution.getPhase();\n+                    if (incomingExecution.getPhase() != null &&\n+                        !Objects.equals(mergedPhase, incomingExecution.getPhase())) {\n+                        mergedPhase = incomingExecution.getPhase();\n+                    }\n+                    // CONFIGURATION\n+                    JsonNode mergedConfiguration = mergePluginConfigurations(\n+                            currentExecution.getConfiguration(),\n+                            incomingExecution.getConfiguration());\n+                    // EXECUTION\n+                    Plugin.Execution mergedExecution = new Plugin.Execution(\n+                            executionId,\n+                            new ArrayList<>(mergedGoals),\n+                            mergedPhase,\n+                            incomingExecution.getInherited(),\n+                            mergedConfiguration);\n+\n+                    mergedExecutions.remove(currentExecution);\n+                    mergedExecutions.add(mergedExecution);\n+                }\n+            }\n+            return mergedExecutions;\n         }\n \n         private Plugin mergePlugins(Plugin plugin, Plugin incoming) {\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/tree/ResolvedPomTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/tree/ResolvedPomTest.java\nindex add21d1e79d..0d2714390ab 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/tree/ResolvedPomTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/tree/ResolvedPomTest.java\n@@ -15,9 +15,13 @@\n  */\n package org.openrewrite.maven.tree;\n \n+import com.fasterxml.jackson.databind.ObjectMapper;\n import org.junit.jupiter.api.Test;\n import org.openrewrite.test.RewriteTest;\n \n+import java.util.List;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.openrewrite.maven.Assertions.pomXml;\n \n class ResolvedPomTest implements RewriteTest {\n@@ -27,67 +31,251 @@ void resolveDependencyWithPlaceholderClassifier() {\n         rewriteRun(\n           pomXml(\n             \"\"\"\n-            <project>\n-              <groupId>org.example</groupId>\n-              <artifactId>foo-parent</artifactId>\n-              <version>1</version>\n-              <properties>\n-                <netty.version>4.1.101.Final</netty.version>\n-                <netty-transport-native-epoll-classifier>linux-x86_64</netty-transport-native-epoll-classifier>\n-              </properties>\n-              <dependencyManagement>\n+              <project>\n+                <groupId>org.example</groupId>\n+                <artifactId>foo-parent</artifactId>\n+                <version>1</version>\n+                <properties>\n+                  <netty.version>4.1.101.Final</netty.version>\n+                  <netty-transport-native-epoll-classifier>linux-x86_64</netty-transport-native-epoll-classifier>\n+                </properties>\n+                <dependencyManagement>\n+                  <dependencies>\n+                    <dependency>\n+                      <groupId>io.netty</groupId>\n+                      <artifactId>netty-transport-native-epoll</artifactId>\n+                      <classifier>${netty-transport-native-epoll-classifier}</classifier>\n+                      <version>${netty.version}</version>\n+                    </dependency>\n+                  </dependencies>\n+                </dependencyManagement>\n+              </project>\n+              \"\"\",\n+            spec -> spec.path(\"pom.xml\")\n+          ),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                <groupId>org.example</groupId>\n+                <artifactId>foo</artifactId>\n+                <version>1</version>\n+                <parent>\n+                  <groupId>org.example</groupId>\n+                  <artifactId>foo-parent</artifactId>\n+                  <version>1</version>\n+                </parent>\n                 <dependencies>\n                   <dependency>\n                     <groupId>io.netty</groupId>\n                     <artifactId>netty-transport-native-epoll</artifactId>\n                     <classifier>${netty-transport-native-epoll-classifier}</classifier>\n-                    <version>${netty.version}</version>\n                   </dependency>\n                 </dependencies>\n-              </dependencyManagement>\n-            </project>\n-            \"\"\",\n-            spec -> spec.path(\"pom.xml\")\n+              </project>\n+              \"\"\",\n+            spec -> spec.path(\"foo/pom.xml\")\n           ),\n           pomXml(\n             \"\"\"\n-            <project>\n-              <groupId>org.example</groupId>\n-              <artifactId>foo</artifactId>\n-              <version>1</version>\n-              <parent>\n+              <project>\n                 <groupId>org.example</groupId>\n-                <artifactId>foo-parent</artifactId>\n+                <artifactId>bar</artifactId>\n                 <version>1</version>\n-              </parent>\n-              <dependencies>\n-                <dependency>\n-                  <groupId>io.netty</groupId>\n-                  <artifactId>netty-transport-native-epoll</artifactId>\n-                  <classifier>${netty-transport-native-epoll-classifier}</classifier>\n-                </dependency>\n-              </dependencies>\n-            </project>\n-            \"\"\",\n-            spec -> spec.path(\"foo/pom.xml\")\n-          ),\n-          pomXml(\n-            \"\"\"\n-            <project>\n-              <groupId>org.example</groupId>\n-              <artifactId>bar</artifactId>\n-              <version>1</version>\n-              <dependencies>\n-                <dependency>\n-                  <groupId>org.example</groupId>\n-                  <artifactId>foo</artifactId>\n-                  <version>1</version>\n-                </dependency>\n-              </dependencies>\n-            </project>\n-            \"\"\",\n+                <dependencies>\n+                  <dependency>\n+                    <groupId>org.example</groupId>\n+                    <artifactId>foo</artifactId>\n+                    <version>1</version>\n+                  </dependency>\n+                </dependencies>\n+              </project>\n+              \"\"\",\n             spec -> spec.path(\"bar/pom.xml\")\n           )\n         );\n     }\n-}\n\\ No newline at end of file\n+\n+    @Test\n+    void resolveExecutionsFromDifferentParents() {\n+        String grandFather = \"\"\"\n+          <project>\n+            <modelVersion>4.0.0</modelVersion>\n+            <groupId>org.example</groupId>\n+            <artifactId>grandfather</artifactId>\n+            <version>1.0.0-SNAPSHOT</version>\n+            <packaging>pom</packaging>\n+            <modules>\n+              <module>father</module>\n+            </modules>\n+            <build>\n+              <pluginManagement>\n+                <plugins>\n+                  <plugin>\n+                    <artifactId>maven-enforcer-plugin</artifactId>\n+                    <dependencies>\n+                      <dependency>\n+                        <groupId>org.codehaus.mojo</groupId>\n+                        <artifactId>extra-enforcer-rules</artifactId>\n+                        <version>1.7.0</version>\n+                      </dependency>\n+                    </dependencies>\n+                    <executions>\n+                      <execution>\n+                        <id>grandfather-execution-id</id>\n+                        <goals>\n+                          <goal>enforce</goal>\n+                        </goals>\n+                        <configuration>\n+                          <rules>\n+                            <requireProperty>\n+                              <property>test</property>\n+                              <message>Missing maven property test</message>\n+                              <regex>.+</regex>\n+                              <regexMessage>Missing maven property test</regexMessage>\n+                            </requireProperty>\n+                            <requirePropertyDiverges>\n+                              <property>test</property>\n+                              <regex>SHOULD_BE_OVERRIDDEN</regex>\n+                            </requirePropertyDiverges>\n+                          </rules>\n+                        </configuration>\n+                      </execution>\n+                    </executions>\n+                  </plugin>\n+                </plugins>\n+              </pluginManagement>\n+            </build>\n+          </project>\n+          \"\"\";\n+        String father = \"\"\"\n+          <project>\n+            <modelVersion>4.0.0</modelVersion>\n+            <parent>\n+              <groupId>org.example</groupId>\n+              <artifactId>grandfather</artifactId>\n+              <version>1.0.0-SNAPSHOT</version>\n+            </parent>\n+            <artifactId>father</artifactId>\n+            <packaging>pom</packaging>\n+            <modules>\n+              <module>child</module>\n+            </modules>\n+            <build>\n+              <pluginManagement>\n+                <plugins>\n+                  <plugin>\n+                    <artifactId>maven-enforcer-plugin</artifactId>\n+                    <executions>\n+                      <execution>\n+                        <id>father-execution-id</id>\n+                        <goals>\n+                          <goal>enforce</goal>\n+                        </goals>\n+                        <phase>process-sources</phase>\n+                        <configuration>\n+                          <rules>\n+                            <RestrictImports>\n+                              <reason>Avoid accidental usage of shaded symbols</reason>\n+                              <bannedImports>\n+                                <bannedImport>**.shaded.**</bannedImport>\n+                                <bannedImport>**.repackaged.**</bannedImport>\n+                                <bannedImport>**.vendor.**</bannedImport>\n+                              </bannedImports>\n+                            </RestrictImports>\n+                          </rules>\n+                        </configuration>\n+                      </execution>\n+                      <execution>\n+                        <id>grandfather-execution-id</id>\n+                        <goals>\n+                          <goal>clean</goal>\n+                        </goals>\n+                        <phase>override-by-father</phase>\n+                      </execution>\n+                    </executions>\n+                  </plugin>\n+                </plugins>\n+              </pluginManagement>\n+            </build>\n+          </project>\n+          \"\"\";\n+        String child = \"\"\"\n+          <project>\n+            <modelVersion>4.0.0</modelVersion>\n+            <parent>\n+              <groupId>org.example</groupId>\n+              <artifactId>father</artifactId>\n+              <version>1.0.0-SNAPSHOT</version>\n+            </parent>\n+            <artifactId>child</artifactId>\n+          </project>\n+          \"\"\";\n+        rewriteRun(\n+          pomXml(grandFather, spec -> spec.path(\"pom.xml\")),\n+          pomXml(father, spec -> spec.path(\"father/pom.xml\")),\n+          pomXml(child, spec -> spec.path(\"father/child/pom.xml\").afterRecipe(doc -> {\n+                List<Plugin> pluginManagement = doc.getMarkers().findFirst(MavenResolutionResult.class)\n+                  .get().getPom().getPluginManagement();\n+                assertThat(pluginManagement).hasSize(1);\n+                Plugin plugin = pluginManagement.get(0);\n+                assertThat(plugin).extracting(Plugin::getArtifactId).isEqualTo(\"maven-enforcer-plugin\");\n+                ObjectMapper objectMapper = new ObjectMapper();\n+                assertThat(plugin.getExecutions())\n+                  .hasSize(2)\n+                  .containsExactlyInAnyOrder(\n+                    new Plugin.Execution(\n+                      \"father-execution-id\",\n+                      List.of(\"enforce\"),\n+                      \"process-sources\",\n+                      null,\n+                      objectMapper.readTree(\n+                        //language=json\n+                        \"\"\"\n+                          {\n+                              \"rules\": {\n+                                  \"RestrictImports\": {\n+                                      \"reason\": \"Avoid accidental usage of shaded symbols\",\n+                                      \"bannedImports\": {\n+                                          \"bannedImport\": [\n+                                              \"**.shaded.**\",\n+                                              \"**.repackaged.**\",\n+                                              \"**.vendor.**\"\n+                                          ]\n+                                      }\n+                                  }\n+                              }\n+                          }\n+                          \"\"\"\n+                      )\n+                    ),\n+                    new Plugin.Execution(\n+                      \"grandfather-execution-id\",\n+                      List.of(\"enforce\", \"clean\"),\n+                      \"override-by-father\",\n+                      null,\n+                      objectMapper.readTree(\n+                        //language=json\n+                        \"\"\"\n+                          {\n+                              \"rules\": {\n+                                  \"requireProperty\": {\n+                                      \"property\": \"test\",\n+                                      \"message\": \"Missing maven property test\",\n+                                      \"regex\": \".+\",\n+                                      \"regexMessage\": \"Missing maven property test\"\n+                                  },\n+                                  \"requirePropertyDiverges\": {\n+                                      \"property\": \"test\",\n+                                      \"regex\": \"SHOULD_BE_OVERRIDDEN\"\n+                                  }\n+                              }\n+                          }\n+                          \"\"\"\n+                      )\n+                    )\n+                  );\n+            })\n+          )\n+        );\n+    }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4133",
    "pr_id": 4133,
    "issue_id": 4132,
    "repo": "openrewrite/rewrite",
    "problem_statement": "XPath Matcher matches too many tags when using relative Paths and conditions\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\n- rewrite-xml v8.23.2\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\nI am authoring custom recipes using the newest bom.\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\n```java\r\nvoid happyDay_propertyUsed_altersVersion() {\r\n        rewriteRun(\r\n                xml(\"\"\"\r\n                                <project>\r\n                                    \r\n                                    <dependencyManagement>\r\n                                        <dependencies>\r\n                                          <dependency>\r\n                                            <groupId>your.groupId</groupId>\r\n                                            <artifactId>your-artifactId</artifactId>\r\n                                            <version>x.x.x</version>\r\n                                            <type>pom</type>\r\n                                            <scope>import</scope>\r\n                                          </dependency>\r\n                                        </dependencies>\r\n                                      </dependencyManagement>\r\n                                </project>\r\n                                \"\"\",\r\n                        \"\"\"\r\n                                 <project>\r\n                                    \r\n                                     <dependencyManagement>\r\n                                         <dependencies>\r\n                                           <dependency>\r\n                                             <groupId>your.groupId</groupId>\r\n                                             <artifactId>your-artifactId</artifactId>\r\n                                             <version>20.9.5</version>\r\n                                             <type>pom</type>\r\n                                             <scope>import</scope>\r\n                                           </dependency>\r\n                                         </dependencies>\r\n                                       </dependencyManagement>\r\n                                 </project>\r\n                                \"\"\")\r\n        );\r\n```\r\n\r\n## What did you expect to see?\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\n```java\r\n     <project>\r\n                                    \r\n                                     <dependencyManagement>\r\n                                         <dependencies>\r\n                                           <dependency>\r\n                                             <groupId>20.9.5</groupId>\r\n                                             <artifactId>20.9.5</artifactId>\r\n                                             <version>20.9.5</version>\r\n                                             <type>20.9.5</type>\r\n                                             <scope>20.9.5</scope>\r\n                                           </dependency>\r\n                                         </dependencies>\r\n                                       </dependencyManagement>\r\n                                 </project>\r\n```\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\r\nIt does not have one because its an recipe test\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\nI think I am responsible for the bug since I tried fixing\r\n- #4119\r\n\r\nI will try to fix it :)\r\n",
    "issue_word_count": 513,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java"
    ],
    "base_commit": "c25a666570dc994d14f3f1a95d29ac8f2b88b174",
    "head_commit": "7bdb40e8ea7c4cac845fba977cdb437ada570a4c",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4133",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4133",
    "dockerfile": "",
    "pr_merged_at": "2024-04-15T10:21:27.000Z",
    "patch": "diff --git a/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java b/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java\nindex 4e45c19959c..9aa28ad3ec2 100644\n--- a/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java\n+++ b/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java\n@@ -72,6 +72,7 @@ public boolean matches(Cursor cursor) {\n \n                 String partWithCondition = null;\n                 Xml.Tag tagForCondition = null;\n+                boolean conditionIsBefore = false;\n                 if (part.endsWith(\"]\") && i < path.size()) {\n                     int index = part.indexOf(\"[\");\n                     if (index < 0) {\n@@ -89,6 +90,7 @@ public boolean matches(Cursor cursor) {\n                         return false;\n                     }\n                     if (!partBefore.contains(\"@\")) {\n+                        conditionIsBefore = true;\n                         partWithCondition = partBefore;\n                         tagForCondition = path.get(parts.length - i);\n                     }\n@@ -97,7 +99,8 @@ public boolean matches(Cursor cursor) {\n                 String partName;\n \n                 Matcher matcher;\n-                if (tagForCondition != null && partWithCondition.endsWith(\"]\") && (matcher = PATTERN.matcher(partWithCondition)).matches()) {\n+                if (tagForCondition != null && partWithCondition.endsWith(\"]\") && (matcher = PATTERN.matcher(\n+                        partWithCondition)).matches()) {\n                     String optionalPartName = matchesCondition(matcher, tagForCondition);\n                     if (optionalPartName == null) {\n                         return false;\n@@ -109,8 +112,8 @@ public boolean matches(Cursor cursor) {\n \n                 if (part.startsWith(\"@\")) {\n                     if (!(cursor.getValue() instanceof Xml.Attribute &&\n-                          (((Xml.Attribute) cursor.getValue()).getKeyAsString().equals(part.substring(1))) ||\n-                          \"*\".equals(part.substring(1)))) {\n+                            (((Xml.Attribute) cursor.getValue()).getKeyAsString().equals(part.substring(1))) ||\n+                            \"*\".equals(part.substring(1)))) {\n                         return false;\n                     }\n \n@@ -127,7 +130,7 @@ public boolean matches(Cursor cursor) {\n                     part = part.substring(0, idx);\n                 }\n                 if (path.size() < i + 1 || (\n-                                                   !(path.get(pathIndex).getName().equals(part)) && !\"*\".equals(part)) && conditionNotFulfilled) {\n+                        !(path.get(pathIndex).getName().equals(part)) && !\"*\".equals(part)) || conditionIsBefore && conditionNotFulfilled) {\n                     return false;\n                 }\n             }\n@@ -184,8 +187,8 @@ public boolean matches(Cursor cursor) {\n \n                 if (part.startsWith(\"@\")) {\n                     return cursor.getValue() instanceof Xml.Attribute &&\n-                           (((Xml.Attribute) cursor.getValue()).getKeyAsString().equals(part.substring(1)) ||\n-                            \"*\".equals(part.substring(1)));\n+                            (((Xml.Attribute) cursor.getValue()).getKeyAsString().equals(part.substring(1)) ||\n+                                    \"*\".equals(part.substring(1)));\n                 }\n \n                 if (path.size() < i + 1 || (tag != null && !tag.getName().equals(partName) && !\"*\".equals(part))) {\n",
    "test_patch": "diff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\nindex 818e4c88b92..0836406afad 100755\n--- a/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\n@@ -190,6 +190,7 @@ void relativePathsWithConditions() {\n         ).toList().get(0);\n         assertThat(match(\"//element1[@foo='bar']\", xml)).isTrue();\n         assertThat(match(\"//element1[foo='baz']/test\", xml)).isTrue();\n+        assertThat(match(\"//element1[foo='baz']/baz\", xml)).isFalse();\n         assertThat(match(\"//element1[foo='bar']/test\", xml)).isFalse();\n     }\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4120",
    "pr_id": 4120,
    "issue_id": 4119,
    "repo": "openrewrite/rewrite",
    "problem_statement": "XPathMatcher does not support paths containing \"//\" and conditions\nI am using\r\n\r\n- OpenRewrite v8.21.0\r\n- Maven plugin v5.25.0\r\n- rewrite-xml_ v8.21.0\r\n\r\n## How are you running OpenRewrite?\r\n\r\nI am using using the OpenRewrite Testing Framework to author a custom Recipe to change XML-tag values or the property used as value. The Custom Recipe is a fork of the ChangeXMLTagValue Recipe.\r\n```xml\r\n <dependencyManagement>\r\n    <dependencies>\r\n      <dependency>\r\n        <groupId>org.openrewrite.recipe</groupId>\r\n        <artifactId>rewrite-recipe-bom</artifactId>\r\n        <version>2.8.1</version>\r\n        <type>pom</type>\r\n        <scope>import</scope>\r\n      </dependency>\r\n    </dependencies>\r\n  </dependencyManagement>\r\n\r\n  <dependencies>\r\n    <!-- rewrite-java dependencies only necessary for Java Recipe development -->\r\n    <dependency>\r\n      <groupId>org.openrewrite</groupId>\r\n      <artifactId>rewrite-java</artifactId>\r\n      <scope>compile</scope>\r\n    </dependency>\r\n\r\n    <!-- You only need the version that corresponds to your current\r\n    Java version. It is fine to add all of them, though, as\r\n    they can coexist on a classpath. -->\r\n    <dependency>\r\n      <groupId>org.openrewrite</groupId>\r\n      <artifactId>rewrite-java-8</artifactId>\r\n      <scope>runtime</scope>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>org.openrewrite</groupId>\r\n      <artifactId>rewrite-java-11</artifactId>\r\n      <scope>runtime</scope>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>org.openrewrite</groupId>\r\n      <artifactId>rewrite-java-17</artifactId>\r\n      <scope>runtime</scope>\r\n    </dependency>\r\n\r\n    <!-- rewrite-maven dependency only necessary for Maven Recipe development -->\r\n    <dependency>\r\n      <groupId>org.openrewrite</groupId>\r\n      <artifactId>rewrite-maven</artifactId>\r\n      <scope>compile</scope>\r\n    </dependency>\r\n\r\n    <!-- rewrite-yaml dependency only necessary for Yaml Recipe development -->\r\n    <dependency>\r\n      <groupId>org.openrewrite</groupId>\r\n      <artifactId>rewrite-yaml</artifactId>\r\n      <scope>compile</scope>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>org.openrewrite</groupId>\r\n      <artifactId>rewrite-json</artifactId>\r\n      <scope>compile</scope>\r\n    </dependency>\r\n\r\n    <!-- rewrite-properties dependency only necessary for Properties Recipe development -->\r\n    <dependency>\r\n      <groupId>org.openrewrite</groupId>\r\n      <artifactId>rewrite-properties</artifactId>\r\n      <scope>compile</scope>\r\n    </dependency>\r\n\r\n    <!-- rewrite-xml dependency only necessary for XML Recipe development -->\r\n    <dependency>\r\n      <groupId>org.openrewrite</groupId>\r\n      <artifactId>rewrite-xml</artifactId>\r\n      <scope>compile</scope>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>org.openrewrite.recipe</groupId>\r\n      <artifactId>rewrite-testing-frameworks</artifactId>\r\n      <version>2.6.0</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>org.openrewrite.recipe</groupId>\r\n      <artifactId>rewrite-static-analysis</artifactId>\r\n      <version>1.4.2</version>\r\n    </dependency>\r\n\r\n    <!-- For authoring tests for any kind of Recipe -->\r\n    <dependency>\r\n      <groupId>org.openrewrite</groupId>\r\n      <artifactId>rewrite-test</artifactId>\r\n      <scope>test</scope>\r\n    </dependency>\r\n\r\n\r\n    <dependency>\r\n      <groupId>org.projectlombok</groupId>\r\n      <artifactId>lombok</artifactId>\r\n      <version>1.18.32</version>\r\n      <scope>compile</scope>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>org.apache.maven</groupId>\r\n      <artifactId>maven-model</artifactId>\r\n      <version>3.9.6</version>\r\n    </dependency>\r\n  </dependencies>\r\n```\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n```java\r\n@Override\r\n    public void defaults(RecipeSpec spec) {\r\n        spec.recipe(\r\n                new ChangeTagValue(\"//dependency[artifactId='your-artifactId']/version\", null,\r\n                        \"20.9.5\"));\r\n    }\r\n\r\n    @Test\r\n    void errorCase_gitHubIssue() {\r\n        rewriteRun(\r\n                xml(\"\"\"\r\n                                <project>                                    \r\n                                    <dependencyManagement>\r\n                                        <dependencies>\r\n                                          <dependency>\r\n                                            <groupId>your.groupId</groupId>\r\n                                            <artifactId>your-artifactId</artifactId>\r\n                                            <version>randomValue</version>\r\n                                            <type>pom</type>\r\n                                            <scope>import</scope>\r\n                                          </dependency>\r\n                                        </dependencies>\r\n                                      </dependencyManagement>\r\n                                </project>\r\n                                \"\"\",\r\n                        \"\"\"\r\n                                 <project>\r\n                                     <dependencyManagement>\r\n                                         <dependencies>\r\n                                           <dependency>\r\n                                             <groupId>your.groupId</groupId>\r\n                                             <artifactId>your-artifactId</artifactId>\r\n                                             <version>20.9.5</version>\r\n                                             <type>pom</type>\r\n                                             <scope>import</scope>\r\n                                           </dependency>\r\n                                         </dependencies>\r\n                                       </dependencyManagement>\r\n                                 </project>\r\n                                \"\"\")\r\n        );\r\n    }\r\n```\r\n\r\n## What did you expect to see?\r\nI would expect the recipe to change the Tag-Value\r\n\r\n## What did you see instead?\r\n```\r\njava.lang.AssertionError: Recipe was expected to make a change but made no changes.\r\n```\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\r\n```\r\nstacktrace output here\r\n```\r\njava.lang.AssertionError: Recipe was expected to make a change but made no changes.\r\n\r\n\tat org.openrewrite.test.LargeSourceSetCheckingExpectedCycles.afterCycle(LargeSourceSetCheckingExpectedCycles.java:118)\r\n\tat org.openrewrite.RecipeScheduler.runRecipeCycles(RecipeScheduler.java:97)\r\n\tat org.openrewrite.RecipeScheduler.scheduleRun(RecipeScheduler.java:41)\r\n\tat org.openrewrite.Recipe.run(Recipe.java:344)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:375)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:133)\r\n\tat org.openrewrite.test.RewriteTest.rewriteRun(RewriteTest.java:128)\r\n\tat de.gothaer.refactorings.openrewrite.recipes.util.ChangeXMLTagValueOrPropertyTest.errorCase_gitHubIssue(ChangeXMLTagValueOrPropertyTest.java:21)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:580)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1596)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1596)\r\n\r\n\r\nProcess finished with exit code -1\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\nI would like to contributing a PR :)\r\n",
    "issue_word_count": 676,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java"
    ],
    "base_commit": "489b8eb2b9e7de2500a5b591a4009f9141297892",
    "head_commit": "be367b60ec589b1d56c3f8c6ccb506b2788863ec",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4120",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4120",
    "dockerfile": "",
    "pr_merged_at": "2024-04-05T12:59:53.000Z",
    "patch": "diff --git a/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java b/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java\nindex f7c5458eb08..4e45c19959c 100644\n--- a/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java\n+++ b/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java\n@@ -17,6 +17,7 @@\n \n import org.openrewrite.Cursor;\n import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.internal.lang.Nullable;\n import org.openrewrite.xml.search.FindTags;\n import org.openrewrite.xml.tree.Xml;\n \n@@ -25,15 +26,16 @@\n import java.util.regex.Pattern;\n \n /**\n- * Supports a limited set of XPath expressions, specifically those\n- * documented on <a href=\"https://www.w3schools.com/xml/xpath_syntax.asp\">this page</a>.\n+ * Supports a limited set of XPath expressions, specifically those documented on <a\n+ * href=\"https://www.w3schools.com/xml/xpath_syntax.asp\">this page</a>.\n  * <p>\n  * Used for checking whether a visitor's cursor meets a certain XPath expression.\n  * <p>\n- * The \"current node\" for XPath evaluation is always the root node of the document.\n- * As a result, '.' and '..' are not recognized.\n+ * The \"current node\" for XPath evaluation is always the root node of the document. As a result, '.' and '..' are not\n+ * recognized.\n  */\n public class XPathMatcher {\n+\n     // Regular expression to support conditional tags like `plugin[artifactId='maven-compiler-plugin']` or foo[@bar='baz']\n     private static final Pattern PATTERN = Pattern.compile(\"([-\\\\w]+)\\\\[(@)?([-\\\\w]+)='([-\\\\w.]+)']\");\n \n@@ -67,6 +69,44 @@ public boolean matches(Cursor cursor) {\n             int pathIndex = 0;\n             for (int i = parts.length - 1; i >= 0; i--, pathIndex++) {\n                 String part = parts[i];\n+\n+                String partWithCondition = null;\n+                Xml.Tag tagForCondition = null;\n+                if (part.endsWith(\"]\") && i < path.size()) {\n+                    int index = part.indexOf(\"[\");\n+                    if (index < 0) {\n+                        return false;\n+                    }\n+                    //if is Attribute\n+                    if (part.charAt(index + 1) == '@') {\n+                        partWithCondition = part;\n+                        tagForCondition = path.get(i);\n+                    }\n+                } else if (i < path.size() && i > 0 && parts[i - 1].endsWith(\"]\")) {\n+                    String partBefore = parts[i - 1];\n+                    int index = partBefore.indexOf(\"[\");\n+                    if (index < 0) {\n+                        return false;\n+                    }\n+                    if (!partBefore.contains(\"@\")) {\n+                        partWithCondition = partBefore;\n+                        tagForCondition = path.get(parts.length - i);\n+                    }\n+                }\n+\n+                String partName;\n+\n+                Matcher matcher;\n+                if (tagForCondition != null && partWithCondition.endsWith(\"]\") && (matcher = PATTERN.matcher(partWithCondition)).matches()) {\n+                    String optionalPartName = matchesCondition(matcher, tagForCondition);\n+                    if (optionalPartName == null) {\n+                        return false;\n+                    }\n+                    partName = optionalPartName;\n+                } else {\n+                    partName = null;\n+                }\n+\n                 if (part.startsWith(\"@\")) {\n                     if (!(cursor.getValue() instanceof Xml.Attribute &&\n                           (((Xml.Attribute) cursor.getValue()).getKeyAsString().equals(part.substring(1))) ||\n@@ -78,7 +118,16 @@ public boolean matches(Cursor cursor) {\n                     continue;\n                 }\n \n-                if (path.size() < i + 1 || (!path.get(pathIndex).getName().equals(part) && !\"*\".equals(part))) {\n+                boolean conditionNotFulfilled =\n+                        tagForCondition == null || (!part.equals(partName) && !tagForCondition.getName()\n+                                .equals(partName));\n+\n+                int idx = part.indexOf(\"[\");\n+                if (idx > 0) {\n+                    part = part.substring(0, idx);\n+                }\n+                if (path.size() < i + 1 || (\n+                                                   !(path.get(pathIndex).getName().equals(part)) && !\"*\".equals(part)) && conditionNotFulfilled) {\n                     return false;\n                 }\n             }\n@@ -124,20 +173,11 @@ public boolean matches(Cursor cursor) {\n \n                 Matcher matcher;\n                 if (tag != null && part.endsWith(\"]\") && (matcher = PATTERN.matcher(part)).matches()) {\n-                    String name = matcher.group(1);\n-                    boolean isAttribute = Objects.equals(matcher.group(2), \"@\");\n-                    String selector = matcher.group(3);\n-                    String value = matcher.group(4);\n-\n-                    boolean matchCondition = isAttribute ? tag.getAttributes().stream().anyMatch(a ->\n-                            a.getKeyAsString().equals(selector) && a.getValueAsString().equals(value)) :\n-                            FindTags.find(tag, selector).stream().anyMatch(t ->\n-                                    t.getValue().map(v -> v.equals(value)).orElse(false)\n-                            );\n-                    if (!matchCondition) {\n+                    String optionalPartName = matchesCondition(matcher, tag);\n+                    if (optionalPartName == null) {\n                         return false;\n                     }\n-                    partName = name;\n+                    partName = optionalPartName;\n                 } else {\n                     partName = part;\n                 }\n@@ -156,4 +196,31 @@ public boolean matches(Cursor cursor) {\n             return cursor.getValue() instanceof Xml.Tag && path.size() == parts.length;\n         }\n     }\n+\n+    @Nullable\n+    private String matchesCondition(Matcher matcher, Xml.Tag tag) {\n+        String name = matcher.group(1);\n+        boolean isAttribute = Objects.equals(matcher.group(2), \"@\");\n+        String selector = matcher.group(3);\n+        String value = matcher.group(4);\n+\n+        boolean matchCondition = false;\n+        if (isAttribute) {\n+            for (Xml.Attribute a : tag.getAttributes()) {\n+                if (a.getKeyAsString().equals(selector) && a.getValueAsString().equals(value)) {\n+                    matchCondition = true;\n+                    break;\n+                }\n+            }\n+        } else {\n+            for (Xml.Tag t : FindTags.find(tag, selector)) {\n+                if (t.getValue().map(v -> v.equals(value)).orElse(false)) {\n+                    matchCondition = true;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return matchCondition ? name : null;\n+    }\n }\n",
    "test_patch": "diff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\nindex 5237afd38c0..818e4c88b92 100755\n--- a/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\n@@ -147,6 +147,8 @@ void matchPom() {\n           pomXml1)).isTrue();\n         assertThat(match(\"/project/build/plugins/plugin[artifactId='maven-compiler-plugin']/configuration/source\",\n           pomXml1)).isTrue();\n+        assertThat(match(\"//plugin[artifactId='maven-compiler-plugin']/configuration/source\",\n+          pomXml1)).isTrue();\n         assertThat(match(\"/project/build/plugins/plugin[groupId='org.apache.maven.plugins']/configuration/source\",\n           pomXml1)).isTrue();\n         assertThat(match(\"/project/build/plugins/plugin[artifactId='somethingElse']/configuration/source\",\n@@ -173,6 +175,24 @@ void attributePredicate() {\n         assertThat(match(\"/root/element1[foo='baz']\", xml)).isTrue();\n     }\n \n+    @Test\n+    void relativePathsWithConditions() {\n+        SourceFile xml = new XmlParser().parse(\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <root>\n+              <element1 foo=\"bar\">\n+                <foo>baz</foo>\n+                <test>asdf</test>\n+              </element1>\n+            </root>\n+            \"\"\"\n+        ).toList().get(0);\n+        assertThat(match(\"//element1[@foo='bar']\", xml)).isTrue();\n+        assertThat(match(\"//element1[foo='baz']/test\", xml)).isTrue();\n+        assertThat(match(\"//element1[foo='bar']/test\", xml)).isFalse();\n+    }\n+\n     @Test\n     @Disabled\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/3919\")\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4117",
    "pr_id": 4117,
    "issue_id": 4115,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Space is missing when adding annotation to variable declarations\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\n\r\n## What version of OpenRewrite are you using?\r\n\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\n- OpenRewrite v1.2.3\r\n- Maven/Gradle plugin v1.2.3\r\n- rewrite-_module_ v1.2.3\r\n\r\n## How are you running OpenRewrite?\r\n\r\nI am using the rewrite recipe starter based on gradle.\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n\r\nWhen running this recipe:\r\n\r\n```java\r\npackage com.example;\r\n\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\n\r\nimport org.openrewrite.Cursor;\r\nimport org.openrewrite.ExecutionContext;\r\nimport org.openrewrite.Recipe;\r\nimport org.openrewrite.TreeVisitor;\r\nimport org.openrewrite.internal.ListUtils;\r\nimport org.openrewrite.java.AnnotationMatcher;\r\nimport org.openrewrite.java.JavaIsoVisitor;\r\nimport org.openrewrite.java.JavaParser;\r\nimport org.openrewrite.java.JavaTemplate;\r\nimport org.openrewrite.java.tree.J;\r\n\r\n\r\npublic class AddAnnotation extends Recipe {\r\n    private static final AnnotationMatcher SIZE = new AnnotationMatcher(\"@jakarta.validation.constraints.Size\");\r\n\r\n    @Override\r\n    public String getDisplayName() {\r\n        return \"Add validation annotations\";\r\n    }\r\n\r\n    @Override\r\n    public String getDescription() {\r\n        return \"something meaningful.\";\r\n    }\r\n\r\n    @Override\r\n    public TreeVisitor<?, ExecutionContext> getVisitor() {\r\n        return new JavaIsoVisitor<ExecutionContext>() {\r\n            @Override\r\n            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {\r\n                return method.withParameters(ListUtils.map(method.getParameters(), p -> {\r\n                    J.VariableDeclarations declarations = (J.VariableDeclarations) p;\r\n                    List<J.Annotation> annotations = declarations.getLeadingAnnotations();\r\n                    if (!(annotations.stream().anyMatch(SIZE::matches))) {\r\n                        maybeAddImport(\"jakarta.validation.constraints.Size\");\r\n                        return JavaTemplate.builder(\" @Size(1) \")\r\n                                .imports(\"jakarta.validation.constraints.Size\").javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, \"jakarta.validation-api\"))\r\n                                .build().apply(\r\n                                        new Cursor(getCursor(), declarations),\r\n                                        declarations.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName))\r\n                                );\r\n                    } else return declarations;\r\n                }));\r\n            }\r\n\r\n        };\r\n    }\r\n}\r\n```\r\n\r\nwith this test:\r\n\r\n```java\r\npackage com.example;\r\n\r\nimport static org.openrewrite.java.Assertions.java;\r\n\r\nimport org.junit.jupiter.api.Test;\r\nimport org.openrewrite.java.JavaParser;\r\nimport org.openrewrite.test.RecipeSpec;\r\nimport org.openrewrite.test.RewriteTest;\r\n\r\nclass AddAnnotationTest implements RewriteTest {\r\n    @Override\r\n    public void defaults(RecipeSpec spec) {\r\n        spec.recipe(new AddAnnotation())\r\n          .parser(JavaParser.fromJavaVersion().classpath(\"jakarta.validation-api\"));\r\n    }\r\n    @Test\r\n    void annotationIsAdded() {\r\n        rewriteRun(\r\n          //language=java\r\n          java(\r\n            \"\"\"\r\n           import jakarta.validation.constraints.NotEmpty;\r\n            \r\n           class A {\r\n            \r\n               public void get(@NotEmpty String reference) {\r\n                    \r\n               }\r\n           }\r\n           \"\"\",\r\n           \"\"\"\r\n          import jakarta.validation.constraints.NotEmpty;\r\n          import jakarta.validation.constraints.Size;\r\n           \r\n          class A {\r\n           \r\n              public void get(@NotEmpty @Size(1) String reference) {\r\n                    \r\n              }\r\n          }\r\n          \"\"\"\r\n          ));\r\n\r\n    }\r\n}\r\n```\r\n\r\nI am getting the following diff:\r\n\r\n```diff\r\n class A {\r\n \r\n-    public void get(@NotEmpty @Size(1) String reference) {\r\n+    public void get(@NotEmpty@Size(1) String reference) {\r\n \r\n     }\r\n }\r\n```\r\n\r\nTechnically, this is correct Java, but the formatting seems very odd.\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\n\r\nUnfortunately, I am not that deep in OpenRewrite.\r\n",
    "issue_word_count": 560,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/format/SpacesTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/format/MinimumViableSpacingVisitor.java",
      "rewrite-java/src/main/java/org/openrewrite/java/format/SpacesVisitor.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/format/SpacesTest.java"
    ],
    "base_commit": "c22c3c642978409bb6b6b5b7ed72d0a98bb91487",
    "head_commit": "58bb08e52a039bb5e1b057bcccc5957c822ec6d4",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4117",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4117",
    "dockerfile": "",
    "pr_merged_at": "2024-04-03T07:07:46.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/format/MinimumViableSpacingVisitor.java b/rewrite-java/src/main/java/org/openrewrite/java/format/MinimumViableSpacingVisitor.java\nindex 517e1f81156..9ab6b5bbc80 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/format/MinimumViableSpacingVisitor.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/format/MinimumViableSpacingVisitor.java\n@@ -136,12 +136,12 @@ public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, P\n                 if (returnTypeExpression instanceof J.AnnotatedType) {\n                     J.AnnotatedType annotatedType = (J.AnnotatedType) returnTypeExpression;\n                     List<J.Annotation> annotations = ListUtils.mapFirst(annotatedType.getAnnotations(), annotation ->\n-                        annotation.withPrefix(annotation.getPrefix().withWhitespace(\" \"))\n+                            annotation.withPrefix(annotation.getPrefix().withWhitespace(\" \"))\n                     );\n                     m = m.withReturnTypeExpression(annotatedType.withAnnotations(annotations));\n                 } else {\n                     m = m.withReturnTypeExpression(returnTypeExpression\n-                        .withPrefix(returnTypeExpression.getPrefix().withWhitespace(\" \")));\n+                            .withPrefix(returnTypeExpression.getPrefix().withWhitespace(\" \")));\n                 }\n             }\n             first = false;\n\ndiff --git a/rewrite-java/src/main/java/org/openrewrite/java/format/SpacesVisitor.java b/rewrite-java/src/main/java/org/openrewrite/java/format/SpacesVisitor.java\nindex 9175527901e..d934ff4252f 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/format/SpacesVisitor.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/format/SpacesVisitor.java\n@@ -180,9 +180,21 @@ private static boolean notSingleSpace(String str) {\n         return onlySpaces(str) && !\" \".equals(str);\n     }\n \n+    private static List<J.Annotation> spaceBetweenAnnotations(List<J.Annotation> annotations) {\n+        return ListUtils.map(annotations, (i, ann) -> {\n+            if (i > 0 && ann.getPrefix().isEmpty()) {\n+                return ann.withPrefix(Space.SINGLE_SPACE);\n+            }\n+            return ann;\n+        });\n+    }\n+\n     @Override\n     public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, P p) {\n         J.ClassDeclaration c = super.visitClassDeclaration(classDecl, p);\n+        if (c.getLeadingAnnotations().size() > 1) {\n+            c = c.withLeadingAnnotations(spaceBetweenAnnotations(c.getLeadingAnnotations()));\n+        }\n         if (c.getBody() != null) {\n             c = c.withBody(spaceBefore(c.getBody(), style.getBeforeLeftBrace().getClassLeftBrace()));\n             if (c.getBody().getStatements().isEmpty()) {\n@@ -242,6 +254,9 @@ public J.Block visitBlock(J.Block block, P p) {\n     @Override\n     public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, P p) {\n         J.MethodDeclaration m = super.visitMethodDeclaration(method, p);\n+        if (m.getLeadingAnnotations().size() > 1) {\n+            m = m.withLeadingAnnotations(spaceBetweenAnnotations(m.getLeadingAnnotations()));\n+        }\n         m = m.getPadding().withParameters(\n                 spaceBefore(m.getPadding().getParameters(), style.getBeforeParentheses().getMethodDeclaration()));\n         if (m.getBody() != null) {\n@@ -706,6 +721,15 @@ public J.AssignmentOperation visitAssignmentOperation(J.AssignmentOperation assi\n         return a;\n     }\n \n+    @Override\n+    public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, P p) {\n+        J.VariableDeclarations vd = super.visitVariableDeclarations(multiVariable, p);\n+        if (vd.getLeadingAnnotations().size() > 1) {\n+            vd = vd.withLeadingAnnotations(spaceBetweenAnnotations(vd.getLeadingAnnotations()));\n+        }\n+        return vd;\n+    }\n+\n     @Override\n     public J.VariableDeclarations.NamedVariable visitVariable(J.VariableDeclarations.NamedVariable variable, P p) {\n         J.VariableDeclarations.NamedVariable v = super.visitVariable(variable, p);\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/format/SpacesTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/format/SpacesTest.java\nindex 4c93be09578..a36d69ce1d9 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/format/SpacesTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/format/SpacesTest.java\n@@ -4836,4 +4836,25 @@ void foo() {\n           )\n         );\n     }\n+\n+    @Test\n+    void spaceBetweenAnnotations() {\n+        rewriteRun(\n+          spaces(),\n+          java(\n+            \"\"\"\n+              class A {\n+                  void m(@Deprecated@SuppressWarnings(\"ALL\") int a) {\n+                  }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              class A {\n+                  void m(@Deprecated @SuppressWarnings(\"ALL\") int a) {\n+                  }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4098",
    "pr_id": 4098,
    "issue_id": 4011,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Create YAML File with remote content\n## What problem are you trying to solve?\r\nI want to create a Yaml file with a remote content\r\n\r\n## What precondition(s) should be checked before applying this recipe?\r\nCheck that the URL exists and the content type is yaml\r\n\r\n## Describe the situation before applying the recipe\r\nNothing\r\n\r\n\r\n## Describe the situation after applying the recipe\r\nWith an URL with content\r\n\r\n```yaml\r\ncontent:\r\n  languages:\r\n    - french\r\n    - english\r\n```\r\n\r\nI want to have a yaml file with this content\r\n\r\n## Have you considered any alternatives or workarounds?\r\nNo\r\n\r\n",
    "issue_word_count": 88,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/CreateYamlFile.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/CreateYamlFileTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/CreateYamlFileTest.java"
    ],
    "base_commit": "c2373dc648d05a01096f6c593a24216b257d4753",
    "head_commit": "695fbe51cd8b2c4700d83047070997f6e5ec70d2",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4098",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4098",
    "dockerfile": "",
    "pr_merged_at": "2024-05-08T08:34:03.000Z",
    "patch": "diff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/CreateYamlFile.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/CreateYamlFile.java\nindex c926ab1859c..4d9309a8597 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/CreateYamlFile.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/CreateYamlFile.java\n@@ -21,8 +21,10 @@\n import org.openrewrite.*;\n import org.openrewrite.internal.StringUtils;\n import org.openrewrite.internal.lang.Nullable;\n+import org.openrewrite.remote.Remote;\n import org.openrewrite.yaml.tree.Yaml;\n \n+import java.net.URI;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.util.Collection;\n@@ -49,6 +51,13 @@ public class CreateYamlFile extends ScanningRecipe<AtomicBoolean> {\n     @Nullable\n     String fileContents;\n \n+    @Option(displayName = \"File contents URL\",\n+            description = \"URL to file containing text content for the file. Use either `fileContents` or `fileContentsUrl` option.\",\n+            example = \"http://foo.bar/baz.yaml\",\n+            required = false)\n+    @Nullable\n+    String fileContentsUrl;\n+\n     @Option(displayName = \"Overwrite existing file\",\n             description = \"If there is an existing file, should it be overwritten.\",\n             required = false)\n@@ -92,14 +101,18 @@ public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean created) {\n             @Override\n             public Yaml visitDocuments(Yaml.Documents documents, ExecutionContext ctx) {\n                 if ((created.get() || Boolean.TRUE.equals(overwriteExisting)) && path.equals(documents.getSourcePath())) {\n-                    if (StringUtils.isBlank(fileContents)) {\n+                    @Language(\"yml\") String yamlContents = fileContents;\n+                    if (yamlContents == null && fileContentsUrl != null) {\n+                        yamlContents = Remote.builder(path, URI.create(fileContentsUrl)).build().printAll(ctx);\n+                    }\n+                    if (StringUtils.isBlank(yamlContents)) {\n                         return documents.withDocuments(emptyList());\n                     }\n-                    if (documents.printAll().equals(fileContents)) {\n+                    if (documents.printAll().equals(yamlContents)) {\n                         return documents;\n                     }\n                     Optional<SourceFile> sourceFiles = YamlParser.builder().build()\n-                            .parse(fileContents)\n+                            .parse(yamlContents)\n                             .findFirst();\n                     if (sourceFiles.isPresent()) {\n                         SourceFile sourceFile = sourceFiles.get();\n",
    "test_patch": "diff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/CreateYamlFileTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/CreateYamlFileTest.java\nindex 31868ca9692..d78f2cd0e25 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/CreateYamlFileTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/CreateYamlFileTest.java\n@@ -15,10 +15,27 @@\n  */\n package org.openrewrite.yaml;\n \n+import org.intellij.lang.annotations.Language;\n import org.junit.jupiter.api.Test;\n import org.openrewrite.DocumentExample;\n+import org.openrewrite.HttpSenderExecutionContextView;\n+import org.openrewrite.InMemoryExecutionContext;\n+import org.openrewrite.internal.lang.Nullable;\n+import org.openrewrite.remote.RemoteArtifactCache;\n+import org.openrewrite.remote.RemoteExecutionContextView;\n+import org.openrewrite.test.MockHttpSender;\n import org.openrewrite.test.RewriteTest;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.function.Consumer;\n+\n import static org.openrewrite.yaml.Assertions.yaml;\n \n class CreateYamlFileTest implements RewriteTest {\n@@ -35,6 +52,7 @@ void hasCreatedFile() {\n           spec -> spec.recipe(new CreateYamlFile(\n             \"test/test.yaml\",\n             fileContents,\n+            null,\n             null\n           )),\n           yaml(\n@@ -52,6 +70,7 @@ void hasOverwrittenFile() {\n           spec -> spec.recipe(new CreateYamlFile(\n             \"test/test.yaml\",\n             \"after: true\",\n+            null,\n             true\n           )),\n           yaml(\n@@ -68,6 +87,7 @@ void shouldNotChangeExistingFile() {\n           spec -> spec.recipe(new CreateYamlFile(\n             \"test/test.yaml\",\n             null,\n+            null,\n             false\n           )),\n           yaml(\n@@ -85,6 +105,7 @@ void shouldNotChangeExistingFileWhenOverwriteNull() {\n           spec -> spec.recipe(new CreateYamlFile(\n             \"test/test.yaml\",\n             null,\n+            null,\n             null\n           )),\n           yaml(\n@@ -100,6 +121,7 @@ void shouldAddAnotherFile() {\n           spec -> spec.recipe(new CreateYamlFile(\n             \"test/test-file-2.yaml\",\n             null,\n+            null,\n             true\n           )),\n           yaml(\n@@ -113,4 +135,77 @@ void shouldAddAnotherFile() {\n           )\n         );\n     }\n+\n+    @Test\n+    void shouldDownloadFileContents() {\n+        @Language(\"yml\")\n+        String yamlContent = \"\"\"\n+          # This is a comment\n+          foo: x\n+          bar:\n+            z: y\n+          \"\"\";\n+        InMemoryExecutionContext ctx = new InMemoryExecutionContext(e -> e.printStackTrace());\n+        MockHttpSender httpSender = new MockHttpSender(() ->\n+          new ByteArrayInputStream(yamlContent.getBytes()));\n+        HttpSenderExecutionContextView.view(ctx)\n+          .setHttpSender(httpSender)\n+          .setLargeFileHttpSender(httpSender);\n+        RemoteExecutionContextView.view(ctx).setArtifactCache(new RemoteArtifactCache() {\n+            @Override\n+            public @Nullable Path get(URI uri) {\n+                return null;\n+            }\n+\n+            @Override\n+            public @Nullable Path put(URI uri, InputStream is, Consumer<Throwable> onError) {\n+                try {\n+                    var file = File.createTempFile(\"rewrite\", \"yaml\");\n+                    Files.copy(is, file.toPath(), StandardCopyOption.REPLACE_EXISTING);\n+                    return file.toPath();\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        });\n+        rewriteRun(\n+          spec -> spec\n+            .executionContext(ctx)\n+            .recipeExecutionContext(ctx)\n+            .recipe(new CreateYamlFile(\n+              \"test/test.yaml\",\n+              null,\n+              \"http://fake.url/test.yaml\",\n+              true)\n+            ),\n+          yaml(\n+            null,\n+            yamlContent,\n+            spec -> spec.path(\"test/test.yaml\")\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void shouldUseFileContentsWhenContentsAndContentsUrlNotNull() {\n+        @Language(\"yml\")\n+        String fileContents = \"\"\"\n+          # This is a comment\n+          x:\n+            y: z\n+          \"\"\";\n+        rewriteRun(\n+          spec -> spec.recipe(new CreateYamlFile(\n+            \"test/test.yaml\",\n+            fileContents,\n+            \"http://foo.bar/baz.yaml\",\n+            true)\n+          ),\n+          yaml(\n+            null,\n+            fileContents,\n+            spec -> spec.path(\"test/test.yaml\")\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4084",
    "pr_id": 4084,
    "issue_id": 4083,
    "repo": "openrewrite/rewrite",
    "problem_statement": "XPathMatcher doesn't find the path in the XML document if searched with tag attribute and hence changeTagValue recipe doesn't work as expected.\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\n\r\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\nLatest openrewrite dependencies in my project\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\nI have written a test case and executing the recipe against that test case\r\n```java\r\n @Test\r\n    void changeAppNameInLog4jXML(){\r\n        rewriteRun(\r\n          spec -> spec\r\n            .recipe(new ChangeTagValue(\"/Configuration/Properties/Property[@name='appname']\",\"abc\",\"def\")),\r\n          xml(\r\n            //language=xml\r\n            \"\"\" \r\n             <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n             <Configuration status=\"trace\" verbose=\"true\">\r\n                 <Properties>\r\n                     <Property name=\"appname\">abc</Property>\r\n                     <Property name=\"logpath\">hello\r\n                     </Property>\r\n                 </Properties>\r\n             </Configuration>\r\n              \"\"\",\r\n            //language=xml\r\n            \"\"\" \r\n             <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n             <Configuration status=\"trace\" verbose=\"true\">\r\n                 <Properties>\r\n                     <Property name=\"appname\">def</Property>\r\n                     <Property name=\"logpath\">hello\r\n                     </Property>\r\n                 </Properties>\r\n             </Configuration>\r\n              \"\"\"\r\n          )\r\n        );\r\n    }\r\n```\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\n```java\r\n @Test\r\n    void changeAppNameInLog4jXML(){\r\n        rewriteRun(\r\n          spec -> spec\r\n            .recipe(new ChangeTagValue(\"/Configuration/Properties/Property[@name='appname']\",\"abc\",\"def\")),\r\n          xml(\r\n            //language=xml\r\n            \"\"\" \r\n             <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n             <Configuration status=\"trace\" verbose=\"true\">\r\n                 <Properties>\r\n                     <Property name=\"appname\">abc</Property>\r\n                     <Property name=\"logpath\">hello\r\n                     </Property>\r\n                 </Properties>\r\n             </Configuration>\r\n              \"\"\",\r\n            //language=xml\r\n            \"\"\" \r\n             <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n             <Configuration status=\"trace\" verbose=\"true\">\r\n                 <Properties>\r\n                     <Property name=\"appname\">def</Property>\r\n                     <Property name=\"logpath\">hello\r\n                     </Property>\r\n                 </Properties>\r\n             </Configuration>\r\n              \"\"\"\r\n          )\r\n        );\r\n    }\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n             <Configuration status=\"trace\" verbose=\"true\">\r\n                 <Properties>\r\n                     <Property name=\"appname\">def</Property>\r\n                     <Property name=\"logpath\">hello\r\n                     </Property>\r\n                 </Properties>\r\n             </Configuration>\r\n```\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\nThe XPathMatcher doesn't reach the Property tag with the name attribute.\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\r\n\r\n",
    "issue_word_count": 617,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java"
    ],
    "base_commit": "40665dd0cb612b5af112111e1c6031d30a852e90",
    "head_commit": "2397052969160b3a00ede61fcb63e13902dc1df1",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4084",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4084",
    "dockerfile": "",
    "pr_merged_at": "2024-03-08T14:30:04.000Z",
    "patch": "diff --git a/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java b/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java\nindex 42295af9ca1..f7c5458eb08 100644\n--- a/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java\n+++ b/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java\n@@ -34,8 +34,8 @@\n  * As a result, '.' and '..' are not recognized.\n  */\n public class XPathMatcher {\n-    // Regular expression to support conditional tags like `plugin[artifactId='maven-compiler-plugin']`\n-    private static final Pattern PATTERN = Pattern.compile(\"([-\\\\w]+)\\\\[([-\\\\w]+)='([-\\\\w.]+)']\");\n+    // Regular expression to support conditional tags like `plugin[artifactId='maven-compiler-plugin']` or foo[@bar='baz']\n+    private static final Pattern PATTERN = Pattern.compile(\"([-\\\\w]+)\\\\[(@)?([-\\\\w]+)='([-\\\\w.]+)']\");\n \n     private final String expression;\n     private final boolean startsWithSlash;\n@@ -125,12 +125,14 @@ public boolean matches(Cursor cursor) {\n                 Matcher matcher;\n                 if (tag != null && part.endsWith(\"]\") && (matcher = PATTERN.matcher(part)).matches()) {\n                     String name = matcher.group(1);\n-                    String subTag = matcher.group(2);\n-                    String subTagValue = matcher.group(3);\n-\n-                    boolean matchCondition =\n-                            FindTags.find(tag, subTag).stream().anyMatch(t ->\n-                                    t.getValue().map(v -> v.equals(subTagValue)).orElse(false)\n+                    boolean isAttribute = Objects.equals(matcher.group(2), \"@\");\n+                    String selector = matcher.group(3);\n+                    String value = matcher.group(4);\n+\n+                    boolean matchCondition = isAttribute ? tag.getAttributes().stream().anyMatch(a ->\n+                            a.getKeyAsString().equals(selector) && a.getValueAsString().equals(value)) :\n+                            FindTags.find(tag, selector).stream().anyMatch(t ->\n+                                    t.getValue().map(v -> v.equals(value)).orElse(false)\n                             );\n                     if (!matchCondition) {\n                         return false;\n",
    "test_patch": "diff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\nindex 3c91fd1179f..5237afd38c0 100755\n--- a/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\n@@ -157,6 +157,22 @@ void matchPom() {\n           pomXml2)).isTrue();\n     }\n \n+    @Test\n+    void attributePredicate() {\n+        SourceFile xml = new XmlParser().parse(\n+          \"\"\"\n+            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+            <root>\n+              <element1 foo=\"bar\"><foo>baz</foo></element1>\n+            </root>\n+            \"\"\"\n+        ).toList().get(0);\n+        assertThat(match(\"/root/element1[@foo='bar']\", xml)).isTrue();\n+        assertThat(match(\"/root/element1[@foo='baz']\", xml)).isFalse();\n+        assertThat(match(\"/root/element1[foo='bar']\", xml)).isFalse();\n+        assertThat(match(\"/root/element1[foo='baz']\", xml)).isTrue();\n+    }\n+\n     @Test\n     @Disabled\n     @Issue(\"https://github.com/openrewrite/rewrite/issues/3919\")\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4082",
    "pr_id": 4082,
    "issue_id": 4059,
    "repo": "openrewrite/rewrite",
    "problem_statement": "RenameVariable does not modify variables referenced through type casts\n## What version of OpenRewrite are you using?\r\n\r\nI am using\r\n\r\n- OpenRewrite v8.17.1\r\n- Maven/Gradle plugin v6.8.4\r\n- rewrite-java v8.17.1\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n\r\n### Before\r\n\r\n```java\r\npackage demo;\r\n\t\r\nimport java.util.Arrays;\r\n\r\npublic class BugDemo {\r\n \r\n  private final Object[] objArray;\r\n\r\n  public BugDemo(Object... objects) {\r\n\tthis.objArray = objects;\r\n  }\r\n\r\n  public boolean isEqualTo(Object object) {\r\n\treturn Arrays.equals(objArray, ((BugDemo) object).objArray);\r\n  }\r\n\r\n  public int length() {\r\n\treturn objArray.length;\r\n  }\r\n} \r\n```\r\n\r\nI run\r\n\r\n```java\r\n@NonNull\r\n@Override\r\npublic TreeVisitor<?, ExecutionContext> getVisitor() {\r\n\treturn new JavaVisitor<ExecutionContext>() {\r\n\r\n\t\tprivate J.VariableDeclarations.NamedVariable variableToRename;\r\n\r\n\t\t@Override\r\n\t\tpublic J visitVariable(J.VariableDeclarations.NamedVariable variable, ExecutionContext executionContext) {\r\n\r\n\t\t\tCursor parentScope = getCursorToParentScope(getCursor());\r\n\r\n\t\t\t// Does support renaming fields in a J.ClassDeclaration.\r\n\t\t\t// We must have a variable type to make safe changes.\r\n\t\t\t// Only make changes to private fields that are not constants.\r\n\t\t\t// Does not apply for instance variables of inner classes\r\n\t\t\t// Only make a change if the variable does not conform to lower camelcase format.\r\n\t\t\tJavaType.Variable type = variable.getVariableType();\r\n\t\t\tif (parentScope.getParent() != null &&\r\n\t\t\t\t\tparentScope.getParent().getValue() instanceof J.ClassDeclaration &&\r\n\t\t\t\t\t!(parentScope.getValue() instanceof J.ClassDeclaration)\r\n\t\t\t\t\t&& type != null && variable.getSimpleName().equals(\"objArray\")) {\r\n\r\n\t\t\t\tvariableToRename = variable;\r\n\t\t\t}\r\n\r\n\t\t\treturn super.visitVariable(variable, executionContext);\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic @Nullable J postVisit(@NonNull J tree, @NonNull ExecutionContext ctx) {\r\n\t\t\tif (tree instanceof JavaSourceFile cu) {\r\n\t\t\t\tcu = (JavaSourceFile) new org.openrewrite.java.RenameVariable<>(variableToRename, \"objects\").visitNonNull(cu, ctx);\r\n\t\t\t\treturn cu;\r\n\t\t\t}\r\n\t\t\treturn super.postVisit(tree, ctx);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns either the current block or a J.Type that may create a reference to a variable.\r\n\t\t * I.E. for(int target = 0; target < N; target++) creates a new name scope for `target`.\r\n\t\t * The name scope in the next J.Block `{}` cannot create new variables with the name `target`.\r\n\t\t * <p>\r\n\t\t * J.* types that may only reference an existing name and do not create a new name scope are excluded.\r\n\t\t */\r\n\t\tprivate Cursor getCursorToParentScope(Cursor cursor) {\r\n\t\t\treturn cursor.dropParentUntil(is -> is instanceof J.ClassDeclaration || is instanceof J.Block || is instanceof SourceFile);\r\n\t\t}\r\n\t};\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\n```java\r\npackage demo;\r\n\r\nimport java.util.Arrays;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\npublic class BugDemo {\r\n\r\n  private final Object[] objects;\r\n\r\n  public BugDemo(Object... objects) {\r\n\tthis.objects = objects;\r\n  }\r\n\r\n  public boolean isEqualTo(Object object) {\r\n\treturn Arrays.equals(objects, ((BugDemo) object).objects);\r\n  }\r\n\r\n  public int length() {\r\n\treturn objects.length;\r\n  }\r\n}\r\n```\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\n```java\r\npackage demo;\r\n\r\nimport java.util.Arrays;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\npublic class BugDemo {\r\n\r\n  private final Object[] objects;\r\n\r\n  public BugDemo(Object... objects) {\r\n\tthis.objects = objects;\r\n  }\r\n\r\n  public boolean isEqualTo(Object object) {\r\n\treturn Arrays.equals(objects, ((BugDemo) object).objArray);\r\n  }\r\n\r\n  public int length() {\r\n\treturn objects.length;\r\n  }\r\n}\r\n```\r\n\r\n>  error: cannot find symbol `.objArray`\r\n\r\n## Syntax Tree Snippet\r\n\r\n```\r\n \\-------J.FieldAccess | \"((BugDemo) object).objArray\"\r\n            |                                   |---J.Parentheses | \"((BugDemo) object)\"\r\n            |                                   |   \\-------J.TypeCast | \"(BugDemo) object\"\r\n            |                                   |           |---J.ControlParentheses | \"(BugDemo)\"\r\n            |                                   |           |   \\-------J.Identifier | \"BugDemo\"\r\n            |                                   |           \\---J.Identifier | \"object\"\r\n            |                                   \\-------J.Identifier | \"objArray\"\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\nNot this time.",
    "issue_word_count": 529,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/RenameVariableTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/RenameVariable.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/RenameVariableTest.java"
    ],
    "base_commit": "487d97c0fcbc5e6d086985ff93c42c866f36316a",
    "head_commit": "1e31e787f3ddc2de646fe9f6368113506faafa01",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4082",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4082",
    "dockerfile": "",
    "pr_merged_at": "2024-03-07T19:15:35.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/RenameVariable.java b/rewrite-java/src/main/java/org/openrewrite/java/RenameVariable.java\nindex 09407432bf8..b7c98f77923 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/RenameVariable.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/RenameVariable.java\n@@ -152,18 +152,53 @@ private boolean isVariableName(Object value, J.Identifier ident) {\n          * FieldAccess targets the variable if its target is an Identifier and either\n          * its target FieldType equals variable.Name.FieldType\n          * or its target Type equals variable.Name.FieldType.Owner\n+         * or if FieldAccess targets a TypCast and either\n+         * its type equals variable.Name.FieldType\n+         * or its type equals variable.Name.FieldType.Owner.\n+         * In case the FieldAccess targets another FieldAccess, the target is followed\n+         * until it is either an Identifier or a TypeCast.\n          */\n         private boolean fieldAccessTargetsVariable(J.FieldAccess fieldAccess) {\n-            if (renameVariable.getName().getFieldType() != null && fieldAccess.getTarget() instanceof J.Identifier) {\n-                J.Identifier fieldAccessTarget = (J.Identifier) fieldAccess.getTarget();\n+            if (renameVariable.getName().getFieldType() != null) {\n+                Expression target = getTarget(fieldAccess);\n+                JavaType targetType = resolveType(target.getType());\n                 JavaType.Variable variableNameFieldType = renameVariable.getName().getFieldType();\n-                JavaType fieldAccessTargetType = fieldAccessTarget.getType() instanceof JavaType.Parameterized ? ((JavaType.Parameterized) fieldAccessTarget.getType()).getType() : fieldAccessTarget.getType();\n-                return variableNameFieldType.equals(fieldAccessTarget.getFieldType()) ||\n-                       (fieldAccessTargetType != null && fieldAccessTargetType.equals(variableNameFieldType.getOwner()));\n+                if (TypeUtils.isOfType(variableNameFieldType.getOwner(), targetType)) {\n+                    return true;\n+                }\n+                if (target instanceof J.TypeCast) {\n+                    return TypeUtils.isOfType(variableNameFieldType, targetType);\n+                } else if (target instanceof J.Identifier) {\n+                    return TypeUtils.isOfType(variableNameFieldType, ((J.Identifier) target).getFieldType());\n+                }\n             }\n             return false;\n         }\n \n+        @Nullable\n+        private Expression getTarget(J.FieldAccess fieldAccess) {\n+            Expression target = fieldAccess.getTarget();\n+            if (target instanceof J.Identifier) {\n+                return target;\n+            }\n+            if (target instanceof J.FieldAccess) {\n+                return getTarget((J.FieldAccess) target);\n+            }\n+            if (target instanceof J.Parentheses<?>) {\n+                J tree = ((J.Parentheses<?>) target).getTree();\n+                if (tree instanceof J.TypeCast) {\n+                    return (J.TypeCast) tree;\n+                }\n+                return null;\n+            }\n+            return null;\n+        }\n+\n+        @Nullable\n+        private JavaType resolveType(@Nullable JavaType type) {\n+            return type instanceof JavaType.Parameterized ? ((JavaType.Parameterized) type).getType() : type;\n+        }\n+\n         @Override\n         public J.VariableDeclarations.NamedVariable visitVariable(J.VariableDeclarations.NamedVariable namedVariable, P p) {\n             boolean nameEquals = namedVariable.getSimpleName().equals(renameVariable.getSimpleName());\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/RenameVariableTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/RenameVariableTest.java\nindex 63f2e64fe42..75ef8d00cf9 100644\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/RenameVariableTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/RenameVariableTest.java\n@@ -77,33 +77,33 @@ void renameFieldWithSameNameAsParameterWithJavaDoc() {\n           spec -> spec.recipe(renameVariableTest(\"name\", \"_name\", false)),\n           java(\n             \"\"\"\n-            public class A {\n-                private String name;\n-                \n-                /**\n-                 * The length of <code>name</code> added to the length of {@link #name}.\n-                 *\n-                 * @param name My parameter.\n-                 */\n-                int fooA(String name) {\n-                    return name.length() + this.name.length();\n-                }\n-            }\n-            \"\"\",\n-            \"\"\"\n-            public class A {\n-                private String _name;\n-                \n-                /**\n-                 * The length of <code>name</code> added to the length of {@link #_name}.\n-                 *\n-                 * @param name My parameter.\n-                 */\n-                int fooA(String name) {\n-                    return name.length() + this._name.length();\n-                }\n-            }\n+              public class A {\n+                  private String name;\n+                  \n+                  /**\n+                   * The length of <code>name</code> added to the length of {@link #name}.\n+                   *\n+                   * @param name My parameter.\n+                   */\n+                  int fooA(String name) {\n+                      return name.length() + this.name.length();\n+                  }\n+              }\n+              \"\"\",\n             \"\"\"\n+              public class A {\n+                  private String _name;\n+                  \n+                  /**\n+                   * The length of <code>name</code> added to the length of {@link #_name}.\n+                   *\n+                   * @param name My parameter.\n+                   */\n+                  int fooA(String name) {\n+                      return name.length() + this._name.length();\n+                  }\n+              }\n+              \"\"\"\n           )\n         );\n     }\n@@ -180,7 +180,7 @@ void isParameterizedClass() {\n           java(\n             \"\"\"\n               package org.openrewrite;\n-              \n+                            \n               public class A<T> {\n                   private String _val;\n                   private String name;\n@@ -193,7 +193,7 @@ public class A<T> {\n               \"\"\",\n             \"\"\"\n               package org.openrewrite;\n-              \n+                            \n               public class A<T> {\n                   private String v;\n                   private String name;\n@@ -820,7 +820,7 @@ public J visitVariableDeclarations(J.VariableDeclarations multiVariable, Executi\n             \"\"\"\n               public class B {\n                   int n;\n-              \n+                            \n                   {\n                       n++; // do not change.\n                       int n;\n@@ -838,7 +838,7 @@ public int foo(int n) {\n             \"\"\"\n               public class B {\n                   int n;\n-              \n+                            \n                   {\n                       n++; // do not change.\n                       int n1;\n@@ -955,4 +955,44 @@ class A {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4059\")\n+    void renameTypeCastedField() {\n+        rewriteRun(\n+          spec -> spec.recipe(renameVariableTest(\"objArray\", \"objects\", false)),\n+          java(\n+            \"\"\"\n+              import java.util.Arrays;\n+\n+              public class A {\n+                private Object[] objArray;\n+\n+                public boolean isEqualTo(Object object) {\n+                  return Arrays.equals(objArray, ((A) object).objArray);\n+                }\n+\n+                public int length() {\n+                  return objArray.length;\n+                }\n+              }\n+              \"\"\",\n+            \"\"\"\n+              import java.util.Arrays;\n+\n+              public class A {\n+                private Object[] objects;\n+\n+                public boolean isEqualTo(Object object) {\n+                  return Arrays.equals(objects, ((A) object).objects);\n+                }\n+\n+                public int length() {\n+                  return objects.length;\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4081",
    "pr_id": 4081,
    "issue_id": 4080,
    "repo": "openrewrite/rewrite",
    "problem_statement": "MavenPomDownloader - UncheckedIOException does not get wrapped into MavenDownloadingException\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\n\r\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\n- rewrite @ main\r\n\r\n## How are you running OpenRewrite?\r\n<!--\r\nAre you using the Maven plugin, Gradle plugin, Moderne CLI, Moderne.io or something else?\r\nIs your project a single module or a multi-module project?\r\n\r\nCan you share your configuration so that we can rule out any configuration issues?\r\n\r\nIs your project public? If so, can you share a link to it?\r\nCode snippets can also be shared privately via [our public Slack](https://join.slack.com/t/rewriteoss/shared_invite/zt-nj42n3ea-b~62rIHzb3Vo0E1APKCXEA).\r\n-->\r\nUnit tests\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\nIn my walled-garden network environment, several tests fail from `MavenPomDownloaderTest`, such as `skipsLocalInvalidArtifactsEmptyJar`, with stack traces like this:\r\n\r\n```\r\norg.opentest4j.AssertionFailedError: Unexpected exception type thrown, \r\nExpected :class org.openrewrite.maven.MavenDownloadingException\r\nActual   :class java.lang.RuntimeException\r\n<Click to see difference>\r\n\r\n\r\n\tat org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151)\r\n\tat org.junit.jupiter.api.AssertThrows.assertThrows(AssertThrows.java:67)\r\n\tat org.junit.jupiter.api.AssertThrows.assertThrows(AssertThrows.java:35)\r\n\tat org.junit.jupiter.api.Assertions.assertThrows(Assertions.java:3115)\r\n\tat org.openrewrite.maven.internal.MavenPomDownloaderTest.skipsLocalInvalidArtifactsEmptyJar(MavenPomDownloaderTest.java:729)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\r\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\r\nCaused by: java.lang.RuntimeException: java.io.UncheckedIOException: java.net.SocketTimeoutException: Connect timed out\r\n\tat org.openrewrite.maven.internal.MavenPomDownloader.requestAsAuthenticatedOrAnonymous(MavenPomDownloader.java:810)\r\n\tat org.openrewrite.maven.internal.MavenPomDownloader.download(MavenPomDownloader.java:572)\r\n\tat org.openrewrite.maven.internal.MavenPomDownloaderTest.lambda$skipsLocalInvalidArtifactsEmptyJar$13(MavenPomDownloaderTest.java:731)\r\n\tat org.junit.jupiter.api.AssertThrows.assertThrows(AssertThrows.java:53)\r\n\t... 6 more\r\nCaused by: java.io.UncheckedIOException: java.net.SocketTimeoutException: Connect timed out\r\n\tat org.openrewrite.ipc.http.HttpUrlConnectionSender.send(HttpUrlConnectionSender.java:116)\r\n\tat org.openrewrite.maven.internal.MavenPomDownloader.lambda$sendRequest$1(MavenPomDownloader.java:142)\r\n\tat dev.failsafe.Functions.lambda$toCtxSupplier$11(Functions.java:243)\r\n\tat dev.failsafe.Functions.lambda$get$0(Functions.java:46)\r\n\tat dev.failsafe.internal.RetryPolicyExecutor.lambda$apply$0(RetryPolicyExecutor.java:74)\r\n\tat dev.failsafe.SyncExecutionImpl.executeSync(SyncExecutionImpl.java:187)\r\n\tat dev.failsafe.FailsafeExecutor.call(FailsafeExecutor.java:376)\r\n\tat dev.failsafe.FailsafeExecutor.get(FailsafeExecutor.java:112)\r\n\tat org.openrewrite.maven.internal.MavenPomDownloader.sendRequest(MavenPomDownloader.java:141)\r\n\tat org.openrewrite.maven.internal.MavenPomDownloader.requestAsAuthenticatedOrAnonymous(MavenPomDownloader.java:802)\r\n\t... 9 more\r\nCaused by: java.net.SocketTimeoutException: Connect timed out\r\n\tat java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:551)\r\n\tat java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:602)\r\n\tat java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)\r\n\tat java.base/java.net.Socket.connect(Socket.java:633)\r\n\tat java.base/sun.security.ssl.SSLSocketImpl.connect(SSLSocketImpl.java:304)\r\n\tat java.base/sun.net.NetworkClient.doConnect(NetworkClient.java:178)\r\n\tat java.base/sun.net.www.http.HttpClient.openServer(HttpClient.java:534)\r\n\tat java.base/sun.net.www.http.HttpClient.openServer(HttpClient.java:639)\r\n\tat java.base/sun.net.www.protocol.https.HttpsClient.<init>(HttpsClient.java:266)\r\n\tat java.base/sun.net.www.protocol.https.HttpsClient.New(HttpsClient.java:380)\r\n\tat java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.getNewHttpClient(AbstractDelegateHttpsURLConnection.java:193)\r\n\tat java.base/sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1242)\r\n\tat java.base/sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:1128)\r\n\tat java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:179)\r\n\tat java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1665)\r\n\tat java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1589)\r\n\tat java.base/java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:529)\r\n\tat java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getResponseCode(HttpsURLConnectionImpl.java:308)\r\n\tat org.openrewrite.ipc.http.HttpUrlConnectionSender.send(HttpUrlConnectionSender.java:97)\r\n\t... 18 more\r\n\r\n```\r\n\r\n## What did you expect to see?\r\n<!-- A code snippet, or a description of the behavior you expected helps us write a test to ensure the issue is fixed. -->\r\nHappy test, or, perhaps an easy-to-read failure from being unable to connect to the default remote Maven repo in my environment.\r\n\r\n## What did you see instead?\r\n<!-- A code snippet, or a description of the behavior you saw instead of the above expected result. -->\r\nThe resultant exception is not wrapped into `MavenDownloadingException` and therefore does not give useful detail about the exact request/artifact that led to an error.\r\n\r\nSo when this happens for real recipe runs, that lack of detail is really inconvenient.\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\r\nSeen above\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\nYes, but, it's a little tricky because I know I'm in a non-standard network. I'd ideally like to define a unit test which simulates the \"connect timeout\" behavior, but, hard for me to know for sure that any given test will achieve that same behavior both in my network and in a \"standard\" network. I might have to spam Actions a little more than usual to validate that.",
    "issue_word_count": 1105,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java"
    ],
    "base_commit": "2b3280554457297112f7062b117c7a149a789cea",
    "head_commit": "0a32e07465313eb7dd23cb3280bd406fb5ad99d9",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4081",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4081",
    "dockerfile": "",
    "pr_merged_at": "2024-03-08T22:33:38.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\nindex d02a639979b..e40b3f4a7ce 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/internal/MavenPomDownloader.java\n@@ -135,7 +135,7 @@ public MavenPomDownloader(Map<Path, Pom> projectPoms, HttpSender httpSender, Exe\n         this.mavenCache = this.ctx.getPomCache();\n     }\n \n-    byte[] sendRequest(HttpSender.Request request) throws Throwable {\n+    byte[] sendRequest(HttpSender.Request request) throws IOException, HttpSenderResponseException {\n         long start = System.nanoTime();\n         try {\n             return Failsafe.with(retryPolicy).get(() -> {\n@@ -148,7 +148,12 @@ byte[] sendRequest(HttpSender.Request request) throws Throwable {\n                 }\n             });\n         } catch (FailsafeException failsafeException) {\n-            throw failsafeException.getCause() == null ? failsafeException : failsafeException.getCause();\n+            if (failsafeException.getCause() instanceof HttpSenderResponseException) {\n+                throw (HttpSenderResponseException) failsafeException.getCause();\n+            }\n+            throw failsafeException;\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n         } finally {\n             this.ctx.recordResolutionTime(Duration.ofNanos(System.nanoTime() - start));\n         }\n@@ -282,7 +287,7 @@ public MavenMetadata downloadMetadata(GroupArtifactVersion gav, @Nullable Resolv\n                                     .increment();\n                             result = Optional.of(derivedMeta);\n                         }\n-                    } catch (HttpSenderResponseException | MavenDownloadingException e) {\n+                    } catch (HttpSenderResponseException | MavenDownloadingException | IOException e) {\n                         repositoryResponses.put(repo, e.getMessage());\n                     }\n                 }\n@@ -328,7 +333,7 @@ public MavenMetadata downloadMetadata(GroupArtifactVersion gav, @Nullable Resolv\n      * @return Metadata or null if the metadata cannot be derived.\n      */\n     @Nullable\n-    private MavenMetadata deriveMetadata(GroupArtifactVersion gav, MavenRepository repo) throws HttpSenderResponseException, MavenDownloadingException {\n+    private MavenMetadata deriveMetadata(GroupArtifactVersion gav, MavenRepository repo) throws HttpSenderResponseException, IOException, MavenDownloadingException {\n         if ((repo.getDeriveMetadataIfMissing() != null && !repo.getDeriveMetadataIfMissing()) || gav.getVersion() != null) {\n             // Do not derive metadata if we cannot navigate/browse the artifacts.\n             // Do not derive metadata if a specific version has been defined.\n@@ -590,6 +595,8 @@ public Pom download(GroupArtifactVersion gav,\n                             //If the exception is a common, client-side exception, cache an empty result.\n                             mavenCache.putPom(resolvedGav, null);\n                         }\n+                    } catch (IOException e) {\n+                        repositoryResponses.put(repo, e.getMessage());\n                     }\n                 }\n             } else if (result.isPresent()) {\n@@ -769,8 +776,6 @@ public MavenRepository normalizeRepository(MavenRepository originalRepository, M\n                                             repository.getSnapshots(),\n                                             repository.getUsername(),\n                                             repository.getPassword());\n-                                } else if (!e.isClientSideException()) {\n-                                    return originalRepository;\n                                 }\n                             } catch (Throwable e) {\n                                 // ok to fall through here and cache a null\n@@ -797,7 +802,7 @@ public MavenRepository normalizeRepository(MavenRepository originalRepository, M\n     /**\n      * Replicates Apache Maven's behavior to attempt anonymous download if repository credentials prove invalid\n      */\n-    private byte[] requestAsAuthenticatedOrAnonymous(MavenRepository repo, String uriString) throws HttpSenderResponseException {\n+    private byte[] requestAsAuthenticatedOrAnonymous(MavenRepository repo, String uriString) throws HttpSenderResponseException, IOException {\n         try {\n             return sendRequest(applyAuthenticationToRequest(repo, httpSender.get(uriString)).build());\n         } catch (HttpSenderResponseException e) {\n@@ -806,12 +811,10 @@ private byte[] requestAsAuthenticatedOrAnonymous(MavenRepository repo, String ur\n             } else {\n                 throw e;\n             }\n-        } catch (Throwable t) {\n-            throw new RuntimeException(t);  // unreachable\n         }\n     }\n \n-    private byte[] retryRequestAnonymously(String uriString, HttpSenderResponseException originalException) throws HttpSenderResponseException {\n+    private byte[] retryRequestAnonymously(String uriString, HttpSenderResponseException originalException) throws HttpSenderResponseException, IOException {\n         try {\n             return sendRequest(httpSender.get(uriString).build());\n         } catch (HttpSenderResponseException retryException) {\n@@ -820,8 +823,6 @@ private byte[] retryRequestAnonymously(String uriString, HttpSenderResponseExcep\n             } else {\n                 throw retryException;\n             }\n-        } catch (Throwable t) {\n-            throw new RuntimeException(t);  // unreachable\n         }\n     }\n \n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java\nindex c2812f5b81a..dbb1f0abbba 100755\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/internal/MavenPomDownloaderTest.java\n@@ -36,6 +36,7 @@\n \n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n+import java.net.UnknownHostException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n@@ -48,7 +49,6 @@\n import static java.util.Collections.emptyMap;\n import static java.util.Collections.singletonList;\n import static java.util.Collections.singletonMap;\n-import static java.util.Objects.requireNonNull;\n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n@@ -86,7 +86,7 @@ void ossSonatype() {\n           null, \"true\", false, null, null, null);\n         MavenRepository repo = new MavenPomDownloader(ctx).normalizeRepository(ossSonatype,\n           MavenExecutionContextView.view(ctx), null);\n-        assertThat(requireNonNull(repo).getUri()).isEqualTo(ossSonatype.getUri());\n+        assertThat(repo).isNotNull().extracting((MavenRepository::getUri)).isEqualTo(ossSonatype.getUri());\n     }\n \n     @Issue(\"https://github.com/openrewrite/rewrite/issues/3908\")\n@@ -188,7 +188,7 @@ public void repositoryAccessFailed(String uri, Throwable e) {\n             // not expected to succeed\n         }\n         assertThat(attemptedUris).isNotEmpty();\n-        assertThat(attemptedUris.get(httpUrl)).hasMessageContaining(\"java.net.UnknownHostException\");\n+        assertThat(attemptedUris.get(httpUrl)).isInstanceOf(UnknownHostException.class);\n         assertThat(discoveredRepositories).isEmpty();\n     }\n \n@@ -742,6 +742,20 @@ void doNotRenameRepoForCustomMavenLocal(@TempDir Path tempDir) throws MavenDownl\n         assertThat(result.getRepository().getUri()).startsWith(tempDir.toUri().toString());\n     }\n \n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4080\")\n+    @Test\n+    void connectTimeout() {\n+        var downloader = new MavenPomDownloader(ctx);\n+        var gav = new GroupArtifactVersion(\"org.openrewrite\", \"rewrite-core\", \"7.0.0\");\n+        var repos = singletonList(MavenRepository.builder()\n+          .id(\"non-routable\").uri(\"http://10.0.0.0/maven\").knownToExist(true).build());\n+\n+        assertThatThrownBy(() -> downloader.download(gav, null, null, repos))\n+          .isInstanceOf(MavenDownloadingException.class)\n+          .hasMessageContaining(\"rewrite-core\")\n+          .hasMessageContaining(\"10.0.0.0\");\n+    }\n+\n     private static GroupArtifactVersion createArtifact(Path repository) throws IOException {\n         Path target = repository.resolve(Paths.get(\"org\", \"openrewrite\", \"rewrite\", \"1.0.0\"));\n         Path pom = target.resolve(\"rewrite-1.0.0.pom\");\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4065",
    "pr_id": 4065,
    "issue_id": 4026,
    "repo": "openrewrite/rewrite",
    "problem_statement": "foo.properties is not print idempotent due to `key==value`\n## What version of OpenRewrite are you using?\r\n<!--\r\nWhenever possible please try to replicate your issue with the latest versions of OpenRewrite.\r\nThe latest major and minor versions of OpenRewrite projects are usually listed here:\r\nhttps://docs.openrewrite.org/reference/latest-versions-of-every-openrewrite-module\r\nFor patch releases check the GitHub Releases page for the respective project.\r\n\r\nWe release every few weeks, so it's possible that your issue has already been fixed.\r\n\r\nIf you want to try the most recent changes that haven't been fully released yet, you can check out our snapshot releases\r\nhttps://docs.openrewrite.org/reference/snapshot-instructions\r\n-->\r\nI am using\r\n\r\n- Maven/Gradle 5.2.1\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\n<!--\r\nSometimes the logs indicate a recipe stumbled over a particular pattern of code.\r\nIf you can share a code snippet that reproduces the issue, that will help us fix it faster.\r\nWe also accept [pull requests that merely replicate an issue](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes), as a step up to a full fix.\r\n\r\nA code snippet can be something simple like this, or similar for other languages:\r\n-->\r\nfoo.properties containing\r\n```properties\r\nkey==value\r\n```\r\n\r\n## What is the full stack trace of any errors you encountered?\r\n<!-- When errors occur, please include the output of `--stacktrace` for Gradle or `--debug` for Maven. -->\r\n```\r\n[WARNING] There were problems parsing foo.properties\r\n[WARNING] java.lang.IllegalStateException: foo.properties is not print idempotent. \r\n... (skipped diff header output)\r\n-key==value\r\n+key=value\r\n...\r\n  org.openrewrite.Parser.requirePrintEqualsInput(Parser.java:52)\r\n```\r\n\r\nI checked the Javadoc of Properties and an equals sign immediately after the first equals should be considered part of the value. Also when loading \"key==value\" into Java properties, it returns \"=value\" when asking for \"key\".\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\nNot for this one.",
    "issue_word_count": 330,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-properties/src/main/java/org/openrewrite/properties/PropertiesParser.java",
      "rewrite-properties/src/test/java/org/openrewrite/properties/PropertiesParserTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-properties/src/test/java/org/openrewrite/properties/PropertiesParserTest.java"
    ],
    "base_commit": "ee496969e6a2f196aa1377a434f6bef93ec7f414",
    "head_commit": "f373f1a58ecd11c3d05a026c36bc44370bed5447",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4065",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4065",
    "dockerfile": "",
    "pr_merged_at": "2024-03-02T07:53:48.000Z",
    "patch": "diff --git a/rewrite-properties/src/main/java/org/openrewrite/properties/PropertiesParser.java b/rewrite-properties/src/main/java/org/openrewrite/properties/PropertiesParser.java\nindex d142c7b6eac..53b516746b9 100755\n--- a/rewrite-properties/src/main/java/org/openrewrite/properties/PropertiesParser.java\n+++ b/rewrite-properties/src/main/java/org/openrewrite/properties/PropertiesParser.java\n@@ -179,48 +179,58 @@ private Properties.Comment commentFromLine(String line, String prefix, Propertie\n         );\n     }\n \n+    static enum State {\n+        WHITESPACE_BEFORE_KEY,\n+        KEY,\n+        KEY_OR_WHITESPACE,\n+        WHITESPACE_OR_DELIMITER,\n+        WHITESPACE_OR_VALUE,\n+        VALUE,\n+        VALUE_OR_TRAILING\n+    }\n+\n     private Properties.Entry entryFromLine(String line, String prefix, StringBuilder trailingWhitespaceBuffer) {\n         StringBuilder prefixBuilder = new StringBuilder(prefix),\n                 key = new StringBuilder(),\n                 equalsPrefix = new StringBuilder(),\n                 valuePrefix = new StringBuilder(),\n                 value = new StringBuilder();\n-\n+        \n         Properties.Entry.Delimiter delimiter = Properties.Entry.Delimiter.NONE;\n         char prev = '$';\n-        int state = 0;\n+        State state = State.WHITESPACE_BEFORE_KEY;\n         for (int i = 0; i < line.length(); i++) {\n             char c = line.charAt(i);\n             switch (state) {\n-                case 0:\n+                case WHITESPACE_BEFORE_KEY:\n                     if (Character.isWhitespace(c)) {\n                         prefixBuilder.append(c);\n                         break;\n                     }\n-                    state++;\n-                case 1:\n+                    state = State.KEY;\n+                case KEY:\n                     if (c == '=' || c == ':') {\n                         if (prev == '\\\\') {\n                             key.append(c);\n                             break;\n                         } else {\n                             delimiter = Properties.Entry.Delimiter.getDelimiter(String.valueOf(c));\n-                            state += 3;\n+                            state = State.WHITESPACE_OR_VALUE;\n                             break;\n                         }\n                     } else if (c == '\\\\') {\n                         key.append(c);\n-                        state++;\n+                        state = State.KEY_OR_WHITESPACE;\n                         break;\n                     } else if (!Character.isWhitespace(c)) {\n                         key.append(c);\n                         break;\n                     } else {\n                         equalsPrefix.append(c);\n-                        state += 2;\n+                        state = State.WHITESPACE_OR_DELIMITER;\n                         break;\n                     }\n-                case 2:\n+                case KEY_OR_WHITESPACE:\n                     if (Character.isWhitespace(c)) {\n                         trailingWhitespaceBuffer.append(c);\n                         break;\n@@ -229,32 +239,35 @@ private Properties.Entry entryFromLine(String line, String prefix, StringBuilder\n                         key.append(trailingWhitespaceBuffer);\n                         trailingWhitespaceBuffer.setLength(0);\n                         key.append(c);\n-                        state--;\n+                        state = State.KEY;\n                         break;\n                     }\n-                case 3:\n+                case WHITESPACE_OR_DELIMITER:\n                     if (Character.isWhitespace(c)) {\n                         equalsPrefix.append(c);\n                         break;\n                     } else if (c == '=' || c == ':') {\n                         delimiter = Properties.Entry.Delimiter.getDelimiter(String.valueOf(c));\n+                        state = State.WHITESPACE_OR_VALUE;\n+                        break;\n                     }\n-                    state++;\n-                case 4:\n-                    if (c == '=' || c == ':') {\n-                        continue;\n-                    } else if (Character.isWhitespace(c)) {\n+                case WHITESPACE_OR_VALUE:\n+                    if (Character.isWhitespace(c)) {\n                         valuePrefix.append(c);\n                         break;\n                     }\n-                    state++;\n-                case 5:\n+                    else {\n+                        value.append(c);\n+                        state = State.VALUE;\n+                        break;\n+                    }\n+                case VALUE:\n                     if (!Character.isWhitespace(c)) {\n                         value.append(c);\n                         break;\n                     }\n-                    state++;\n-                case 6:\n+                    state = State.VALUE_OR_TRAILING;\n+                case VALUE_OR_TRAILING:\n                     if (Character.isWhitespace(c)) {\n                         trailingWhitespaceBuffer.append(c);\n                     } else {\n@@ -262,7 +275,7 @@ private Properties.Entry entryFromLine(String line, String prefix, StringBuilder\n                         value.append(trailingWhitespaceBuffer);\n                         trailingWhitespaceBuffer.setLength(0);\n                         value.append(c);\n-                        state--;\n+                        state = State.VALUE;\n                         break;\n                     }\n             }\n",
    "test_patch": "diff --git a/rewrite-properties/src/test/java/org/openrewrite/properties/PropertiesParserTest.java b/rewrite-properties/src/test/java/org/openrewrite/properties/PropertiesParserTest.java\nindex 82897cf6507..c5b54276c69 100755\n--- a/rewrite-properties/src/test/java/org/openrewrite/properties/PropertiesParserTest.java\n+++ b/rewrite-properties/src/test/java/org/openrewrite/properties/PropertiesParserTest.java\n@@ -233,6 +233,23 @@ void trailingDoubleSlash() {\n         );\n     }\n \n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/4026\")\n+    @Test\n+    void repeatedDelimiter() {\n+        rewriteRun(\n+          properties(\n+            \"\"\"\n+              key1==value1\n+              key2::value2\n+              key3======value3\n+              key4=:value4\n+              key5 = = value5\n+              \"\"\",\n+            containsValues(\"=value1\", \":value2\", \"=====value3\", \":value4\", \"= value5\")\n+          )\n+        );\n+    }\n+\n     private static Consumer<SourceSpec<Properties.File>> containsValues(String... valueAssertions) {\n         return spec -> spec.beforeRecipe(props -> {\n             List<String> values = TreeVisitor.collect(new PropertiesVisitor<>() {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-4004",
    "pr_id": 4004,
    "issue_id": 4005,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Declarative Preconditions - Control applicability to ScanningRecipes\n<!--\r\nThank you for suggesting an improvement to OpenRewrite!\r\nFeel free to delete any sections that don't apply to your request.\r\n-->\r\n## What problem are you trying to solve?\r\nSuppose you want to add a dependency to a Maven project, but only if some other condition is true in the `pom.xml`.\r\nYou might try something like this:\r\n\r\n```yml\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: org.sample.Example\r\ndisplayName: Use AddDependency with a declarative precondition\r\npreconditions:\r\n  - org.openrewrite.maven.FindDependency:\r\n      groupId: org.glassfish.jaxb\r\n      artifactId: *\r\nrecipeList:\r\n  - org.openrewrite.maven.AddDependency:\r\n      groupId: org.glassfish.jaxb\r\n      artifactId: jaxb-runtime\r\n      version: latest.release\r\n      onlyIfUsing: jakarta.xml.bind..*\r\n```\r\n...but this will never pass Preconditions, because `AddDependency`'s scanner targets Java files, but the declarative precondition only matches on Maven files. And declarative preconditions always apply to both the scan and edit phases.\r\n\r\n## Describe the solution you'd like\r\nCould be solved with a new, optional enum field:\r\n```yml\r\ntype: specs.openrewrite.org/v1beta/recipe\r\nname: org.sample.Example\r\ndisplayName: Use AddDependency with a declarative precondition\r\npreconditionPhases: edit # or \"scan\", or (default) \"all\"\r\npreconditions:\r\n  - org.openrewrite.maven.FindDependency:\r\n      groupId: org.glassfish.jaxb\r\n      artifactId: *\r\nrecipeList:\r\n  - org.openrewrite.maven.AddDependency:\r\n      groupId: org.glassfish.jaxb\r\n      artifactId: jaxb-runtime\r\n      version: latest.release\r\n      onlyIfUsing: jakarta.xml.bind..*\r\n```\r\n\r\n## Have you considered any alternatives or workarounds?\r\n- Imperative recipes\r\n- Individual toggle arguments (eg `preconditionsOnScanning: false`, `preconditionsOnEdit: false`)\r\n- Separate precondition sequences per desired phase (eg `scanningPreconditions: # one or more recipes`, `editPreconditions: # one or more recipes`), while the existing `preconditions` option continues to mean \"both scan and edit phase\"\r\n\r\n## Additional context\r\n<!-- Any thoughts that come to mind, or similar items on the backlog already. -->\r\ncc @sambsnyd \r\n\r\n## Are you interested in [contributing this feature to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#new-features)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\nAssuming we can bless a design, yeah, I suspect the code won't be too treacherous",
    "issue_word_count": 334,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/config/DeclarativeRecipe.java",
      "rewrite-core/src/test/java/org/openrewrite/config/DeclarativeRecipeTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-core/src/test/java/org/openrewrite/config/DeclarativeRecipeTest.java"
    ],
    "base_commit": "9fed57a465e7bd70f546bbb67c824abbd7ff4f69",
    "head_commit": "7e64cb2f49c8d46c24749497a4bf12202a6b849e",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/4004",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/4004",
    "dockerfile": "",
    "pr_merged_at": "2024-02-16T12:09:25.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/config/DeclarativeRecipe.java b/rewrite-core/src/main/java/org/openrewrite/config/DeclarativeRecipe.java\nindex b8ce079bad3..44704bf02f0 100644\n--- a/rewrite-core/src/main/java/org/openrewrite/config/DeclarativeRecipe.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/config/DeclarativeRecipe.java\n@@ -197,7 +197,7 @@ public List<Recipe> getRecipeList() {\n \n     @Value\n     @EqualsAndHashCode(callSuper = false)\n-    static class BellwetherDecoratedScanningRecipe<T>  extends ScanningRecipe<T> {\n+    static class BellwetherDecoratedScanningRecipe<T> extends ScanningRecipe<T> {\n \n         DeclarativeRecipe.PreconditionBellwether bellwether;\n         ScanningRecipe<T> delegate;\n@@ -224,7 +224,12 @@ public T getInitialValue(ExecutionContext ctx) {\n \n         @Override\n         public TreeVisitor<?, ExecutionContext> getScanner(T acc) {\n-            return Preconditions.check(bellwether.isPreconditionApplicable(), delegate.getScanner(acc));\n+            return delegate.getScanner(acc);\n+        }\n+\n+        @Override\n+        public Collection<? extends SourceFile> generate(T acc, ExecutionContext ctx) {\n+            return delegate.generate(acc, ctx);\n         }\n \n         @Override\n@@ -240,18 +245,18 @@ public List<Recipe> getRecipeList() {\n \n     @Override\n     public final List<Recipe> getRecipeList() {\n-        if(preconditions.isEmpty()) {\n+        if (preconditions.isEmpty()) {\n             return recipeList;\n         }\n \n         TreeVisitor<?, ExecutionContext> andPreconditions = null;\n         for (Recipe precondition : preconditions) {\n-            if(isScanningRecipe(precondition)) {\n+            if (isScanningRecipe(precondition)) {\n                 throw new IllegalArgumentException(\n                         getName() + \" declares the ScanningRecipe \" + precondition.getName() + \" as a precondition.\" +\n                         \"ScanningRecipe cannot be used as Preconditions.\");\n             }\n-            if(andPreconditions == null) {\n+            if (andPreconditions == null) {\n                 andPreconditions = precondition.getVisitor();\n             } else {\n                 andPreconditions = Preconditions.and(andPreconditions, precondition.getVisitor());\n@@ -265,11 +270,11 @@ public final List<Recipe> getRecipeList() {\n     }\n \n     private static boolean isScanningRecipe(Recipe recipe) {\n-        if(recipe instanceof ScanningRecipe) {\n+        if (recipe instanceof ScanningRecipe) {\n             return true;\n         }\n         for (Recipe r : recipe.getRecipeList()) {\n-            if(isScanningRecipe(r)) {\n+            if (isScanningRecipe(r)) {\n                 return true;\n             }\n         }\n@@ -279,7 +284,7 @@ private static boolean isScanningRecipe(Recipe recipe) {\n     private static List<Recipe> decorateWithPreconditionBellwether(PreconditionBellwether bellwether, List<Recipe> recipeList) {\n         List<Recipe> mappedRecipeList = new ArrayList<>(recipeList.size());\n         for (Recipe recipe : recipeList) {\n-            if(recipe instanceof ScanningRecipe) {\n+            if (recipe instanceof ScanningRecipe) {\n                 mappedRecipeList.add(new BellwetherDecoratedScanningRecipe<>(bellwether, (ScanningRecipe<?>) recipe));\n             } else {\n                 mappedRecipeList.add(new BellwetherDecoratedRecipe(bellwether, recipe));\n@@ -311,8 +316,8 @@ public void addValidation(Validated<Object> validated) {\n     @Override\n     public Validated<Object> validate() {\n         return Validated.<Object>test(\"initialization\",\n-                \"initialize(..) must be called on DeclarativeRecipe prior to use.\",\n-                this, r -> initValidation != null)\n+                        \"initialize(..) must be called on DeclarativeRecipe prior to use.\",\n+                        this, r -> initValidation != null)\n                 .and(validation)\n                 .and(initValidation);\n     }\n",
    "test_patch": "diff --git a/rewrite-core/src/test/java/org/openrewrite/config/DeclarativeRecipeTest.java b/rewrite-core/src/test/java/org/openrewrite/config/DeclarativeRecipeTest.java\nindex 2cfdbe205d4..8aff75f0e5f 100644\n--- a/rewrite-core/src/test/java/org/openrewrite/config/DeclarativeRecipeTest.java\n+++ b/rewrite-core/src/test/java/org/openrewrite/config/DeclarativeRecipeTest.java\n@@ -30,6 +30,7 @@\n import org.openrewrite.text.PlainText;\n import org.openrewrite.text.PlainTextVisitor;\n \n+import java.nio.file.Paths;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.atomic.AtomicInteger;\n@@ -93,6 +94,34 @@ void yamlPrecondition() {\n         );\n     }\n \n+    @Test\n+    void yamlPreconditionWithScanningRecipe() {\n+        rewriteRun(\n+          spec -> spec.recipeFromYaml(\"\"\"\n+            ---\n+            type: specs.openrewrite.org/v1beta/recipe\n+            name: org.openrewrite.PreconditionTest\n+            preconditions:\n+              - org.openrewrite.text.Find:\n+                  find: 1\n+            recipeList:\n+              - org.openrewrite.text.CreateTextFile:\n+                 relativeFileName: test.txt\n+                 fileContents: \"test\"\n+            \"\"\", \"org.openrewrite.PreconditionTest\")\n+            .afterRecipe(run -> {\n+                assertThat(run.getChangeset().getAllResults()).anySatisfy(\n+                  s -> {\n+                      assertThat(s.getAfter()).isNotNull();\n+                      assertThat(s.getAfter().getSourcePath()).isEqualTo(Paths.get(\"test.txt\"));\n+                  }\n+                );\n+            })\n+            .expectedCyclesThatMakeChanges(1),\n+          text(\"1\")\n+        );\n+    }\n+\n     @Test\n     void maxCycles() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-3980",
    "pr_id": 3980,
    "issue_id": 3847,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Add negation support to FindSourceFiles\nEg `**/!(CertainFileName)IT.java`, like HasSourcePath used to support.",
    "issue_word_count": 14,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/PathUtils.java",
      "rewrite-core/src/test/java/org/openrewrite/PathUtilsTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-core/src/test/java/org/openrewrite/PathUtilsTest.java"
    ],
    "base_commit": "cce995320d5fcd5c33ea6000fc18a5fb3d98fece",
    "head_commit": "c1476ba61da271b8b56209ab234bd2bf60761510",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/3980",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/3980",
    "dockerfile": "",
    "pr_merged_at": "2024-02-06T18:14:06.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/PathUtils.java b/rewrite-core/src/main/java/org/openrewrite/PathUtils.java\nindex 764cdb5c9e2..5eac5dd8195 100755\n--- a/rewrite-core/src/main/java/org/openrewrite/PathUtils.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/PathUtils.java\n@@ -22,6 +22,8 @@\n import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n public class PathUtils {\n     private PathUtils() {\n@@ -77,6 +79,18 @@ public static boolean matchesGlob(@Nullable Path path, @Nullable String globPatt\n         if (relativePath.isEmpty() && globPattern.isEmpty()) {\n             return true;\n         }\n+        List<String> excludedPatterns = getExcludedPatterns(globPattern);\n+        if (!excludedPatterns.isEmpty()) {\n+            if (!matchesGlob(convertNegationToWildcard(globPattern), relativePath)) {\n+                return false;\n+            }\n+            for (String excludedPattern : excludedPatterns) {\n+                if (matchesGlob(excludedPattern, relativePath)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n \n         return matchesGlob(globPattern, relativePath);\n     }\n@@ -128,7 +142,7 @@ private static boolean matchesGlob(String pattern, String path) {\n                 return false;\n             }\n             if (pattIdxEnd == (pattTokens.length - 1)\n-                && (isFileSeparator(pattern.charAt(pattern.length() - 1)) ^ isFileSeparator(path.charAt(path.length() - 1)))) {\n+                    && (isFileSeparator(pattern.charAt(pattern.length() - 1)) ^ isFileSeparator(path.charAt(path.length() - 1)))) {\n                 return false;\n             }\n             pattIdxEnd--;\n@@ -188,6 +202,33 @@ private static boolean matchesGlob(String pattern, String path) {\n         return true;\n     }\n \n+    public static String convertNegationToWildcard(String globPattern) {\n+        // Regular expression to match !(...)\n+        String negationPattern = \"\\\\!\\\\((.*?)\\\\)\";\n+        // Replace all negation patterns with *\n+        return globPattern.replaceAll(negationPattern, \"*\");\n+    }\n+\n+    public static List<String> getExcludedPatterns(String globPattern) {\n+        List<String> excludedPatterns = new ArrayList<>();\n+\n+        // Regular expression to match !(...)\n+        String negationPattern = \"\\\\!\\\\((.*?)\\\\)\";\n+        Pattern pattern = Pattern.compile(negationPattern);\n+        Matcher matcher = pattern.matcher(globPattern);\n+\n+        // Find all negation patterns and generate excluded patterns\n+        while (matcher.find()) {\n+            String negationContent = matcher.group(1);\n+            String[] options = negationContent.split(\"\\\\|\");\n+            for (String option : options) {\n+                excludedPatterns.add(globPattern.replace(matcher.group(), option));\n+            }\n+        }\n+\n+        return excludedPatterns;\n+    }\n+\n     private static String[] tokenize(String path) {\n         List<String> tokens = new ArrayList<>();\n         int pathIdxStart = 0;\n",
    "test_patch": "diff --git a/rewrite-core/src/test/java/org/openrewrite/PathUtilsTest.java b/rewrite-core/src/test/java/org/openrewrite/PathUtilsTest.java\nindex 08107fe90c6..a78c8ee3891 100644\n--- a/rewrite-core/src/test/java/org/openrewrite/PathUtilsTest.java\n+++ b/rewrite-core/src/test/java/org/openrewrite/PathUtilsTest.java\n@@ -111,6 +111,17 @@ void eitherOr() {\n         assertThat(matchesGlob(path(\"test/bar\"), \"test/{foo,bar}\")).isTrue();\n     }\n \n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/3847\")\n+    void negation() {\n+        assertThat(matchesGlob(path(\"test.txt\"), \"test.!(txt)\")).isFalse();\n+        assertThat(matchesGlob(path(\"test.java\"), \"test.!(txt)\")).isTrue();\n+        assertThat(matchesGlob(path(\"test/foo\"), \"test/!(foo|bar)\")).isFalse();\n+        assertThat(matchesGlob(path(\"test/bar\"), \"test/!(foo|bar)\")).isFalse();\n+        assertThat(matchesGlob(path(\"test/quz\"), \"test/!(foo|bar)\")).isTrue();\n+        assertThat(matchesGlob(path(\"test/bar\"), \"test/!(f*|b*)\")).isFalse();\n+    }\n+\n     private static Path path(String path) {\n         return Paths.get(path);\n     }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-3972",
    "pr_id": 3972,
    "issue_id": 3932,
    "repo": "openrewrite/rewrite",
    "problem_statement": "RemoveRedundantDependencyVersions for Plugins\n<!--\r\nThank you for suggesting a new recipe for OpenRewrite!\r\nFeel free to delete any sections that don't apply to your request.\r\n-->\r\n\r\n## What problem are you trying to solve?\r\n<!-- A description of a problem you encounter that you hope to resolve with a recipe. -->\r\nLike dependencies, plugins can also have redundant versions when compared to the `pluginManagement`. But, `RemoveRedundantDependencyVersions` only touches dependencies.\r\n\r\n## What precondition(s) should be checked before applying this recipe?\r\n<!-- Should we limit execution to certain versions of languages or libraries for instance? -->\r\nCan't think of any\r\n\r\n## Describe the situation before applying the recipe\r\n<!-- Ideally as a self-contained code example, as a start to the recipe unit tests. -->\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <groupId>org.sample</groupId>\r\n    <artifactId>sample</artifactId>\r\n    <version>1.0.0</version>\r\n    <packaging>jar</packaging>\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.7.18</version>\r\n        <relativePath/>\r\n    </parent>\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>pl.project13.maven</groupId>\r\n                <artifactId>git-commit-id-plugin</artifactId>\r\n                <version>4.9.10</version>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n</project>\r\n\r\n```\r\n\r\n## Describe the situation after applying the recipe\r\n<!-- Ideally as a self-contained code example, as a start to the recipe unit tests. -->\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <groupId>org.sample</groupId>\r\n    <artifactId>sample</artifactId>\r\n    <version>1.0.0</version>\r\n    <packaging>jar</packaging>\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.7.18</version>\r\n        <relativePath/>\r\n    </parent>\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>pl.project13.maven</groupId>\r\n                <artifactId>git-commit-id-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n</project>\r\n\r\n```\r\n\r\n## Have you considered any alternatives or workarounds?\r\n<!-- Any other ways to solve the problem, or ways to work around the problem. -->\r\nImplementation options could include:\r\n- Add this to `RemoveRedundantDependencyVersions`\r\n- Same as above, but with an arg to control the plugin-handling behavior\r\n  - Choice about whether to default the behavior to on or off\r\n- Create a new, separate `RemoveRedundantPluginVersions`\r\n\r\nI'd vote for adding it to `RemoveRedundantDependencyVersions`, active by default, with a new optional arg to disable checking plugins.\r\n\r\n## Any additional context\r\n<!-- Any thoughts such as considerations and limitations when applying this recipe, or hints on the implementation. -->\r\n\r\n## Are you interested in [contributing this recipe to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#adding-new-recipes)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->\r\nI might; priority TBA. This might also be a good first issue for someone else.",
    "issue_word_count": 504,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java",
      "rewrite-maven/src/main/java/org/openrewrite/maven/RemoveRedundantDependencyVersions.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/RemoveRedundantDependencyVersionsTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/RemoveRedundantDependencyVersionsTest.java"
    ],
    "base_commit": "904ca309539fa31e64e0e3dcc4b543598acc8411",
    "head_commit": "ac153f740308204e857bbe69d387501bb259c3fb",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/3972",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/3972",
    "dockerfile": "",
    "pr_merged_at": "2024-02-21T15:00:18.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\nindex c4d55e82369..b296a3ee209 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n@@ -40,11 +40,11 @@ public class MavenVisitor<P> extends XmlVisitor<P> {\n     static final XPathMatcher DEPENDENCY_MATCHER = new XPathMatcher(\"/project/dependencies/dependency\");\n     static final XPathMatcher PLUGIN_DEPENDENCY_MATCHER = new XPathMatcher(\"/project/*/plugins/plugin/dependencies/dependency\");\n     static final XPathMatcher MANAGED_DEPENDENCY_MATCHER = new XPathMatcher(\"/project/dependencyManagement/dependencies/dependency\");\n+    static final XPathMatcher MANAGED_PLUGIN_MATCHER = new XPathMatcher(\"/project/build/pluginManagement/plugins/plugin\");\n     static final XPathMatcher PROPERTY_MATCHER = new XPathMatcher(\"/project/properties/*\");\n     static final XPathMatcher PLUGIN_MATCHER = new XPathMatcher(\"/project/*/plugins/plugin\");\n     static final XPathMatcher PARENT_MATCHER = new XPathMatcher(\"/project/parent\");\n     static final XPathMatcher PROFILE_PLUGIN_MATCHER = new XPathMatcher(\"/project/profiles/*/build/plugins/plugin\");\n-\n     private transient MavenResolutionResult resolutionResult;\n \n     @Override\n@@ -348,4 +348,30 @@ public MavenMetadata downloadMetadata(String groupId, String artifactId, @Nullab\n         return new MavenPomDownloader(emptyMap(), ctx, getResolutionResult().getMavenSettings(), getResolutionResult().getActiveProfiles())\n                 .downloadMetadata(new GroupArtifact(groupId, artifactId), containingPom, getResolutionResult().getPom().getRepositories());\n     }\n+\n+    public boolean isManagedPluginTag() {\n+        return MANAGED_PLUGIN_MATCHER.matches(getCursor());\n+    }\n+\n+    /**\n+     * Does the current tag can contain groupId, artifactId and version?\n+     */\n+    public boolean isDependencyLikeTag() {\n+        return isManagedDependencyTag() || isDependencyTag() || isPluginTag();\n+    }\n+\n+    @Nullable\n+    public Plugin findPlugin(Xml.Tag tag) {\n+        List<Plugin> plugins = getResolutionResult().getPom().getPlugins();\n+        for (Plugin resolvedPlugin : plugins) {\n+            String reqGroup = resolvedPlugin.getGroupId();\n+            String reqVersion = resolvedPlugin.getVersion();\n+            if ((reqGroup == null || reqGroup.equals(tag.getChildValue(\"groupId\").orElse(null))) &&\n+                resolvedPlugin.getArtifactId().equals(tag.getChildValue(\"artifactId\").orElse(null)) &&\n+                (reqVersion == null || reqVersion.equals(tag.getChildValue(\"version\").orElse(null)))) {\n+                return resolvedPlugin;\n+            }\n+        }\n+        return null;\n+    }\n }\n\ndiff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/RemoveRedundantDependencyVersions.java b/rewrite-maven/src/main/java/org/openrewrite/maven/RemoveRedundantDependencyVersions.java\nindex f3b88b1554b..7e9c1a447f8 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/RemoveRedundantDependencyVersions.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/RemoveRedundantDependencyVersions.java\n@@ -21,7 +21,9 @@\n import org.openrewrite.internal.ListUtils;\n import org.openrewrite.internal.StringUtils;\n import org.openrewrite.internal.lang.Nullable;\n+import org.openrewrite.maven.tree.Plugin;\n import org.openrewrite.maven.tree.ResolvedDependency;\n+import org.openrewrite.maven.tree.ResolvedPom;\n import org.openrewrite.xml.tree.Xml;\n \n import java.util.List;\n@@ -33,7 +35,7 @@\n public class RemoveRedundantDependencyVersions extends Recipe {\n     @Option(displayName = \"Group\",\n             description = \"Group glob expression pattern used to match dependencies that should be managed.\" +\n-                    \"Group is the first part of a dependency coordinate `com.google.guava:guava:VERSION`.\",\n+                          \"Group is the first part of a dependency coordinate `com.google.guava:guava:VERSION`.\",\n             example = \"com.google.*\",\n             required = false)\n     @Nullable\n@@ -41,7 +43,7 @@ public class RemoveRedundantDependencyVersions extends Recipe {\n \n     @Option(displayName = \"Artifact\",\n             description = \"Artifact glob expression pattern used to match dependencies that should be managed.\" +\n-                    \"Artifact is the second part of a dependency coordinate `com.google.guava:guava:VERSION`.\",\n+                          \"Artifact is the second part of a dependency coordinate `com.google.guava:guava:VERSION`.\",\n             example = \"guava*\",\n             required = false)\n     @Nullable\n@@ -55,7 +57,7 @@ public class RemoveRedundantDependencyVersions extends Recipe {\n \n     @Option(displayName = \"Except\",\n             description = \"Accepts a list of GAVs. Dependencies matching a GAV will be ignored by this recipe.\"\n-                    + \" GAV versions are ignored if provided.\",\n+                          + \" GAV versions are ignored if provided.\",\n             example = \"com.jcraft:jsch\",\n             required = false)\n     @Nullable\n@@ -63,13 +65,13 @@ public class RemoveRedundantDependencyVersions extends Recipe {\n \n     @Override\n     public String getDisplayName() {\n-        return \"Remove redundant explicit dependency versions\";\n+        return \"Remove redundant explicit dependency and plugin versions\";\n     }\n \n     @Override\n     public String getDescription() {\n-        return \"Remove explicitly-specified dependency versions when a parent POM's dependencyManagement \" +\n-                \"specifies the version.\";\n+        return \"Remove explicitly-specified dependency/plugin versions when a parent POM's `dependencyManagement`/`pluginManagement` \" +\n+               \"specifies the version.\";\n     }\n \n     @Override\n@@ -96,13 +98,21 @@ public TreeVisitor<?, ExecutionContext> getVisitor() {\n         return new MavenIsoVisitor<ExecutionContext>() {\n             @Override\n             public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n-                if (!isManagedDependencyTag()) {\n-                    ResolvedDependency d = findDependency(tag);\n-                    if (d != null && matchesVersion(d) &&\n+                if (isDependencyLikeTag() && !isManagedDependencyTag()) {\n+                    if (isPluginTag()) {\n+                        Plugin p = findPlugin(tag);\n+                        if (p != null && matchesVersion(p) && matchesGroup(p) && matchesArtifact(p)) {\n+                            Xml.Tag version = tag.getChild(\"version\").orElse(null);\n+                            return tag.withContent(ListUtils.map(tag.getContent(), c -> c == version ? null : c));\n+                        }\n+                    } else {\n+                        ResolvedDependency d = findDependency(tag);\n+                        if (d != null && matchesVersion(d) &&\n                             matchesGroup(d) && matchesArtifact(d)\n                             && isNotExcepted(d)) {\n-                        Xml.Tag version = tag.getChild(\"version\").orElse(null);\n-                        return tag.withContent(ListUtils.map(tag.getContent(), c -> c == version ? null : c));\n+                            Xml.Tag version = tag.getChild(\"version\").orElse(null);\n+                            return tag.withContent(ListUtils.map(tag.getContent(), c -> c == version ? null : c));\n+                        }\n                     }\n                 }\n                 return super.visitTag(tag, ctx);\n@@ -112,10 +122,18 @@ private boolean matchesGroup(ResolvedDependency d) {\n                 return StringUtils.isNullOrEmpty(groupPattern) || matchesGlob(d.getGroupId(), groupPattern);\n             }\n \n+            private boolean matchesGroup(Plugin p) {\n+                return StringUtils.isNullOrEmpty(groupPattern) || matchesGlob(p.getGroupId(), groupPattern);\n+            }\n+\n             private boolean matchesArtifact(ResolvedDependency d) {\n                 return StringUtils.isNullOrEmpty(artifactPattern) || matchesGlob(d.getArtifactId(), artifactPattern);\n             }\n \n+            private boolean matchesArtifact(Plugin p) {\n+                return StringUtils.isNullOrEmpty(artifactPattern) || matchesGlob(p.getArtifactId(), artifactPattern);\n+            }\n+\n             private boolean matchesVersion(ResolvedDependency d) {\n                 String managedVersion = getResolutionResult().getPom().getManagedVersion(d.getGroupId(),\n                         d.getArtifactId(), d.getRequested().getType(), d.getRequested().getClassifier());\n@@ -124,6 +142,14 @@ private boolean matchesVersion(ResolvedDependency d) {\n                 );\n             }\n \n+            private boolean matchesVersion(Plugin p) {\n+                ResolvedPom resolvedPom = getResolutionResult().getPom();\n+                String managedVersion = getManagedPluginVersion(resolvedPom, p.getGroupId(), p.getArtifactId());\n+                return managedVersion != null && (\n+                        ignoreVersionMatching() || managedVersion.equals(p.getVersion())\n+                );\n+            }\n+\n             private boolean ignoreVersionMatching() {\n                 return Boolean.FALSE.equals(onlyIfVersionsMatch);\n             }\n@@ -137,7 +163,7 @@ private boolean isNotExcepted(ResolvedDependency d) {\n                     final String exceptedGroupId = split[0];\n                     final String exceptedArtifactId = split[1];\n                     if (matchesGlob(d.getGroupId(), exceptedGroupId)\n-                            && matchesGlob(d.getArtifactId(), exceptedArtifactId)) {\n+                        && matchesGlob(d.getArtifactId(), exceptedArtifactId)) {\n                         return false;\n                     }\n                 }\n@@ -145,4 +171,15 @@ && matchesGlob(d.getArtifactId(), exceptedArtifactId)) {\n             }\n         };\n     }\n+\n+    @Nullable\n+    private static String getManagedPluginVersion(ResolvedPom resolvedPom, String groupId, String artifactId) {\n+        for (Plugin p : resolvedPom.getPluginManagement()) {\n+            if (groupId.equals(p.getGroupId()) && artifactId.equals(p.getArtifactId())) {\n+                return resolvedPom.getValue(p.getVersion());\n+            }\n+        }\n+\n+        return null;\n+    }\n }\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveRedundantDependencyVersionsTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveRedundantDependencyVersionsTest.java\nindex 42b1a9d31ad..103b74db4dd 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveRedundantDependencyVersionsTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/RemoveRedundantDependencyVersionsTest.java\n@@ -1111,4 +1111,92 @@ void unmanagedDependencyOnlyIfVersionsMatchFalse() {\n           )\n         );\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/3932\")\n+    void removeRedundantVersionsFromPluginsManagedByParent() {\n+        rewriteRun(\n+          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, false, null)),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>org.sample</groupId>\n+                  <artifactId>sample</artifactId>\n+                  <version>1.0.0</version>\n+                  <parent>\n+                      <groupId>org.springframework.boot</groupId>\n+                      <artifactId>spring-boot-starter-parent</artifactId>\n+                      <version>2.7.18</version>\n+                      <relativePath/>\n+                  </parent>\n+                  <build>\n+                      <plugins>\n+                          <plugin>\n+                              <groupId>pl.project13.maven</groupId>\n+                              <artifactId>git-commit-id-plugin</artifactId>\n+                              <version>4.9.10</version>\n+                          </plugin>\n+                      </plugins>\n+                  </build>\n+              </project>\n+              \"\"\",\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>org.sample</groupId>\n+                  <artifactId>sample</artifactId>\n+                  <version>1.0.0</version>\n+                  <parent>\n+                      <groupId>org.springframework.boot</groupId>\n+                      <artifactId>spring-boot-starter-parent</artifactId>\n+                      <version>2.7.18</version>\n+                      <relativePath/>\n+                  </parent>\n+                  <build>\n+                      <plugins>\n+                          <plugin>\n+                              <groupId>pl.project13.maven</groupId>\n+                              <artifactId>git-commit-id-plugin</artifactId>\n+                          </plugin>\n+                      </plugins>\n+                  </build>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/3932\")\n+    void noChangesIfManagedPluginVersionDoesNotMatch() {\n+        rewriteRun(\n+          spec -> spec.recipe(new RemoveRedundantDependencyVersions(null, null, true, null)),\n+          pomXml(\n+            \"\"\"\n+              <project>\n+                  <modelVersion>4.0.0</modelVersion>\n+                  <groupId>org.sample</groupId>\n+                  <artifactId>sample</artifactId>\n+                  <version>1.0.0</version>\n+                  <parent>\n+                      <groupId>org.springframework.boot</groupId>\n+                      <artifactId>spring-boot-starter-parent</artifactId>\n+                      <version>2.7.18</version>\n+                      <relativePath/>\n+                  </parent>\n+                  <build>\n+                      <plugins>\n+                          <plugin>\n+                              <groupId>pl.project13.maven</groupId>\n+                              <artifactId>git-commit-id-plugin</artifactId>\n+                              <version>4.9.9</version>\n+                          </plugin>\n+                      </plugins>\n+                  </build>\n+              </project>\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-3967",
    "pr_id": 3967,
    "issue_id": 3966,
    "repo": "openrewrite/rewrite",
    "problem_statement": "`ChangePluginGroupIdAndArtifactId` ignores profile specific plugins\nUsing rewrite-maven-plugin:5.21 via CLI: \r\n`mvn clean org.openrewrite.maven:rewrite-maven-plugin:run -Drewrite.recipeArtifactCoordinates={my-srouce} -Drewrite.activeRecipes=myRecipe`\r\n\r\nProblem is that if a plugin is defined in a profile the recipe ignores it due to the Xml Path defined in the plugin matcher.\r\n\r\nI expect the following test to pass:\r\n```java\r\n\r\n    @Test\r\n    void shouldAddIfNonePresent() {\r\n        Recipe recipe = new ChangePluginGroupIdAndArtifactId(\r\n            \"oldGroup\", \"maven-plugin\",\r\n            \"changedGroup\", \"maven-plugin\"\r\n        );\r\n\r\n        rewriteRun(\r\n            spec -> spec.parser(JavaParser.fromJavaVersion()).recipe(recipe),\r\n            mavenProject(\"project\",\r\n                pomXml(\r\n                    \"\"\"\r\n                        <project>\r\n                           <groupId>com.mycompany.app</groupId>\r\n                              <artifactId>my-app</artifactId>\r\n                              <version>1</version>\r\n                              <profiles>\r\n                                  <profile>\r\n                                      <id>profile</id>\r\n                                      <build>\r\n                                          <plugins>\r\n                                              <plugin>\r\n                                                  <groupId>oldGroup</groupId>\r\n                                                  <artifactId>maven-plugin</artifactId>\r\n                                                  <version>1</version>\r\n                                              </plugin>\r\n                                          </plugins>\r\n                                      </build>\r\n                                  </profile>\r\n                              </profiles>\r\n                          </project>\r\n                        \"\"\", \"\"\"\r\n                        <project>\r\n                           <groupId>com.mycompany.app</groupId>\r\n                              <artifactId>my-app</artifactId>\r\n                              <version>1</version>\r\n                              <profiles>\r\n                                  <profile>\r\n                                      <id>profile</id>\r\n                                      <build>\r\n                                          <plugins>\r\n                                              <plugin>\r\n                                                 not changed, remains the same\r\n                                                  <groupId>changedGroup</groupId>\r\n                                                  <artifactId>maven-plugin</artifactId>\r\n                                                  <version>1</version>\r\n                                              </plugin>\r\n                                          </plugins>\r\n                                      </build>\r\n                                  </profile>\r\n                              </profiles>\r\n                          </project>\r\n                        \"\"\"\r\n                )\r\n            )\r\n        );\r\n    }\r\n```\r\nbut `org.openrewrite.maven.MavenVisitor#isPluginTag()` returns false due to the way the matcher is set up:\r\n`static final XPathMatcher PLUGIN_MATCHER = new XPathMatcher(\"/project/*/plugins/plugin\");`\r\n\r\nIf this behaviour is intentional, could you please explain why?\r\n",
    "issue_word_count": 201,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java",
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java"
    ],
    "base_commit": "9e794d48048dcf4837dd9e64aeda5b776d9705b4",
    "head_commit": "9cfcacc1fa48165842bda38934a08e38ea19a65e",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/3967",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/3967",
    "dockerfile": "",
    "pr_merged_at": "2024-02-02T15:03:47.000Z",
    "patch": "diff --git a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\nindex fed45de4f7e..551d2a6d4c2 100644\n--- a/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n+++ b/rewrite-maven/src/main/java/org/openrewrite/maven/MavenVisitor.java\n@@ -43,6 +43,7 @@ public class MavenVisitor<P> extends XmlVisitor<P> {\n     static final XPathMatcher PROPERTY_MATCHER = new XPathMatcher(\"/project/properties/*\");\n     static final XPathMatcher PLUGIN_MATCHER = new XPathMatcher(\"/project/*/plugins/plugin\");\n     static final XPathMatcher PARENT_MATCHER = new XPathMatcher(\"/project/parent\");\n+    static final XPathMatcher PROFILE_PLUGIN_MATCHER = new XPathMatcher(\"/project/profiles/*/build/plugins/plugin\");\n \n     private transient MavenResolutionResult resolutionResult;\n \n@@ -189,7 +190,7 @@ public void maybeUpdateModel() {\n     }\n \n     public boolean isPluginTag() {\n-        return PLUGIN_MATCHER.matches(getCursor());\n+        return PLUGIN_MATCHER.matches(getCursor()) || PROFILE_PLUGIN_MATCHER.matches(getCursor());\n     }\n \n     public boolean isPluginTag(String groupId, @Nullable String artifactId) {\n",
    "test_patch": "diff --git a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java\nindex 462c8056393..26aa0bd0a48 100644\n--- a/rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java\n+++ b/rewrite-maven/src/test/java/org/openrewrite/maven/ChangePluginGroupIdAndArtifactIdTest.java\n@@ -49,6 +49,20 @@ void changePluginGroupIdAndArtifactId() {\n                           </plugin>\n                       </plugins>\n                   </build>\n+                  <profiles>\n+                      <profile>\n+                          <id>profile</id>\n+                          <build>\n+                              <plugins>\n+                                  <plugin>\n+                                      <groupId>io.quarkus</groupId>\n+                                      <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n+                                      <version>3.0.0.Beta1</version>\n+                                  </plugin>\n+                              </plugins>\n+                          </build>\n+                      </profile>\n+                  </profiles>\n               </project>\n               \"\"\",\n             \"\"\"\n@@ -66,6 +80,20 @@ void changePluginGroupIdAndArtifactId() {\n                           </plugin>\n                       </plugins>\n                   </build>\n+                  <profiles>\n+                      <profile>\n+                          <id>profile</id>\n+                          <build>\n+                              <plugins>\n+                                  <plugin>\n+                                      <groupId>io.quarkus</groupId>\n+                                      <artifactId>quarkus-extension-maven-plugin</artifactId>\n+                                      <version>3.0.0.Beta1</version>\n+                                  </plugin>\n+                              </plugins>\n+                          </build>\n+                      </profile>\n+                  </profiles>\n               </project>\n               \"\"\"\n           )\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-3965",
    "pr_id": 3965,
    "issue_id": 3964,
    "repo": "openrewrite/rewrite",
    "problem_statement": "ChangePropertyValue regex does not allow for multiple replacements of same regex pattern.\n## What problem are you trying to solve?\r\nIn yaml’s ChangePropertyValue I am having issues finding the correct regex that works.\r\nBased on [this line](https://github.com/openrewrite/rewrite/blob/main/rewrite-yaml/src/main/java/org/openrewrite/yaml/ChangePropertyValue.java#L107), it should replace all occurences of the regex with its replacement.\r\nHowever, replacement is not triggered as [this matchesOldValue condition](https://github.com/openrewrite/rewrite/blob/main/rewrite-yaml/src/main/java/org/openrewrite/yaml/ChangePropertyValue.java#L89), renders false.\r\n\r\nBesides that, I found that the properties recipe behaves similar to yaml recipe, but does not have the same checks/safeties built-in. \r\n\r\n## Describe the solution you'd like\r\nWould it be an option if a create PR that accepts another boolean as optional input: eg. partialMatch or partialReplace.\r\nThat boolean would trigger for regex and string a contains mechanism instead of equals.\r\nFor replacement it would trigger all occurences to be changed for regex and for String (rather than sending back new value)\r\n\r\n## Have you considered any alternatives or workarounds?\r\nTriggering this recipe multiple times with regex that does prefix/suffix optionals. (but then, how much occurences of the pattern can you have?)\r\n\r\n## Additional context\r\n<!-- Any thoughts that come to mind, or similar items on the backlog already. -->\r\n\r\n## Are you interested in [contributing this feature to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#new-features)?\r\nPR is following",
    "issue_word_count": 247,
    "test_files_count": 2,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "rewrite-properties/src/main/java/org/openrewrite/properties/ChangePropertyValue.java",
      "rewrite-properties/src/test/java/org/openrewrite/properties/ChangePropertyValueTest.java",
      "rewrite-yaml/src/main/java/org/openrewrite/yaml/ChangePropertyValue.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/ChangePropertyValueTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-properties/src/test/java/org/openrewrite/properties/ChangePropertyValueTest.java",
      "rewrite-yaml/src/test/java/org/openrewrite/yaml/ChangePropertyValueTest.java"
    ],
    "base_commit": "8e5d6d85afa137d46515c5968986fc050cfcb70c",
    "head_commit": "d6927c28d014c4db9691a67e90cbdcef117689b0",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/3965",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/3965",
    "dockerfile": "",
    "pr_merged_at": "2024-02-02T14:36:15.000Z",
    "patch": "diff --git a/rewrite-properties/src/main/java/org/openrewrite/properties/ChangePropertyValue.java b/rewrite-properties/src/main/java/org/openrewrite/properties/ChangePropertyValue.java\nindex 308e0a2c778..c755cb83c27 100755\n--- a/rewrite-properties/src/main/java/org/openrewrite/properties/ChangePropertyValue.java\n+++ b/rewrite-properties/src/main/java/org/openrewrite/properties/ChangePropertyValue.java\n@@ -17,24 +17,21 @@\n \n import lombok.EqualsAndHashCode;\n import lombok.Value;\n-import org.openrewrite.ExecutionContext;\n-import org.openrewrite.Option;\n-import org.openrewrite.Recipe;\n-import org.openrewrite.TreeVisitor;\n+import org.openrewrite.*;\n import org.openrewrite.internal.NameCaseConvention;\n import org.openrewrite.internal.StringUtils;\n import org.openrewrite.internal.lang.Nullable;\n import org.openrewrite.properties.tree.Properties;\n \n-import java.util.Objects;\n+import java.util.regex.Pattern;\n \n @Value\n @EqualsAndHashCode(callSuper = true)\n public class ChangePropertyValue extends Recipe {\n \n     @Option(displayName = \"Property key\",\n-            description = \"The name of the property key whose value is to be changed.\",\n-            example = \"management.metrics.binders.files.enabled\")\n+            description = \"The name of the property key whose value is to be changed. Supports glob patterns.\",\n+            example = \"management.metrics.binders.*.enabled\")\n     String propertyKey;\n \n     @Option(displayName = \"New value\",\n@@ -48,14 +45,15 @@ public class ChangePropertyValue extends Recipe {\n     String oldValue;\n \n     @Option(displayName = \"Regex\",\n-            description = \"Default false. If enabled, `oldValue` will be interpreted as a Regular Expression, and capture group contents will be available in `newValue`\",\n+            description = \"Default `false`. If enabled, `oldValue` will be interpreted as a Regular Expression, \" +\n+                          \"to replace only all parts that match the regex. Capturing group can be used in `newValue`.\",\n             required = false)\n     @Nullable\n     Boolean regex;\n \n     @Option(displayName = \"Use relaxed binding\",\n             description = \"Whether to match the `propertyKey` using [relaxed binding](https://docs.spring.io/spring-boot/docs/2.5.6/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding) \" +\n-                    \"rules. Default is `true`. Set to `false`  to use exact matching.\",\n+                          \"rules. Default is `true`. Set to `false`  to use exact matching.\",\n             required = false)\n     @Nullable\n     Boolean relaxedBinding;\n@@ -70,6 +68,13 @@ public String getDescription() {\n         return \"Change a property value leaving the key intact.\";\n     }\n \n+    @Override\n+    public Validated validate() {\n+        return super.validate().and(\n+                Validated.test(\"oldValue\", \"is required if `regex` is enabled\", oldValue,\n+                        value -> !(Boolean.TRUE.equals(regex) && StringUtils.isNullOrEmpty(value))));\n+    }\n+\n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n         return new ChangePropertyValueVisitor<>();\n@@ -81,29 +86,35 @@ public ChangePropertyValueVisitor() {\n \n         @Override\n         public Properties visitEntry(Properties.Entry entry, P p) {\n-            if (!Boolean.FALSE.equals(relaxedBinding) ? NameCaseConvention.equalsRelaxedBinding(entry.getKey(), propertyKey) : entry.getKey().equals(propertyKey)) {\n-                if (matchesOldValue(entry.getValue())) {\n-                    Properties.Value updatedValue = updateValue(entry.getValue());\n-                    if (updatedValue != null) {\n-                        entry = entry.withValue(updatedValue);\n-                    }\n+            Properties.Entry e = (Properties.Entry) super.visitEntry(entry, p);\n+            if (matchesPropertyKey(e.getKey()) && matchesOldValue(e.getValue())) {\n+                Properties.Value updatedValue = updateValue(e.getValue());\n+                if (updatedValue != null) {\n+                    e = e.withValue(updatedValue);\n                 }\n             }\n-            return super.visitEntry(entry, p);\n+            return e;\n         }\n \n         @Nullable // returns null if value should not change\n         private Properties.Value updateValue(Properties.Value value) {\n             Properties.Value updatedValue = value.withText(Boolean.TRUE.equals(regex)\n-                    ? value.getText().replaceAll(Objects.requireNonNull(oldValue), newValue) : newValue);\n+                    ? value.getText().replaceAll(oldValue, newValue)\n+                    : newValue);\n             return updatedValue.getText().equals(value.getText()) ? null : updatedValue;\n         }\n \n+        private boolean matchesPropertyKey(String prop) {\n+            return !Boolean.FALSE.equals(relaxedBinding)\n+                    ? NameCaseConvention.matchesGlobRelaxedBinding(prop, propertyKey)\n+                    : StringUtils.matchesGlob(prop, propertyKey);\n+        }\n+\n         private boolean matchesOldValue(Properties.Value value) {\n             return StringUtils.isNullOrEmpty(oldValue) ||\n-                    (Boolean.TRUE.equals(regex)\n-                            ? value.getText().matches(oldValue)\n-                            : value.getText().equals(oldValue));\n+                   (Boolean.TRUE.equals(regex)\n+                           ? Pattern.compile(oldValue).matcher(value.getText()).find()\n+                           : value.getText().equals(oldValue));\n         }\n     }\n \n\ndiff --git a/rewrite-yaml/src/main/java/org/openrewrite/yaml/ChangePropertyValue.java b/rewrite-yaml/src/main/java/org/openrewrite/yaml/ChangePropertyValue.java\nindex f579e26ccb9..024c4be6a39 100644\n--- a/rewrite-yaml/src/main/java/org/openrewrite/yaml/ChangePropertyValue.java\n+++ b/rewrite-yaml/src/main/java/org/openrewrite/yaml/ChangePropertyValue.java\n@@ -25,6 +25,7 @@\n \n import java.util.Iterator;\n import java.util.Objects;\n+import java.util.regex.Pattern;\n \n @Value\n @EqualsAndHashCode(callSuper = true)\n@@ -45,7 +46,8 @@ public class ChangePropertyValue extends Recipe {\n     String oldValue;\n \n     @Option(displayName = \"Regex\",\n-            description = \"Defaults to `false`. If enabled, `oldValue` will be interpreted as a regular expression, and the capture group contents will be available in `newValue`\",\n+            description = \"Default `false`. If enabled, `oldValue` will be interpreted as a Regular Expression, \" +\n+                          \"to replace only all parts that match the regex. Capturing group can be used in `newValue`.\",\n             required = false)\n     @Nullable\n     Boolean regex;\n@@ -122,7 +124,7 @@ private boolean matchesOldValue(Yaml.Block value) {\n         Yaml.Scalar scalar = (Yaml.Scalar) value;\n         return StringUtils.isNullOrEmpty(oldValue) ||\n                (Boolean.TRUE.equals(regex)\n-                       ? scalar.getValue().matches(oldValue)\n+                       ? Pattern.compile(oldValue).matcher(scalar.getValue()).find()\n                        : scalar.getValue().equals(oldValue));\n     }\n \n",
    "test_patch": "diff --git a/rewrite-properties/src/test/java/org/openrewrite/properties/ChangePropertyValueTest.java b/rewrite-properties/src/test/java/org/openrewrite/properties/ChangePropertyValueTest.java\nindex cd43551abb6..3c60607cb74 100755\n--- a/rewrite-properties/src/test/java/org/openrewrite/properties/ChangePropertyValueTest.java\n+++ b/rewrite-properties/src/test/java/org/openrewrite/properties/ChangePropertyValueTest.java\n@@ -23,6 +23,7 @@\n import org.openrewrite.test.RecipeSpec;\n import org.openrewrite.test.RewriteTest;\n \n+import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.openrewrite.properties.Assertions.properties;\n \n @SuppressWarnings(\"UnusedProperty\")\n@@ -159,4 +160,40 @@ void regexDefaultOff() {\n           )\n         );\n     }\n+\n+    @Test\n+    void partialMatchRegex() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePropertyValue(\"*\", \"[replaced:$1]\", \"\\\\[replaceme:(.*?)]\", true, null)),\n+          properties(\"\"\"\n+            multiple=[replaceme:1][replaceme:2]\n+            multiple-prefixed=test[replaceme:1]test[replaceme:2]\n+            multiple-suffixed=[replaceme:1]test[replaceme:2]test\n+            multiple-both=test[replaceme:1]test[replaceme:2]test\n+            \"\"\", \"\"\"\n+            multiple=[replaced:1][replaced:2]\n+            multiple-prefixed=test[replaced:1]test[replaced:2]\n+            multiple-suffixed=[replaced:1]test[replaced:2]test\n+            multiple-both=test[replaced:1]test[replaced:2]test\n+            \"\"\")\n+        );\n+    }\n+\n+    @Test\n+    void partialMatchNonRegex() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePropertyValue(\"*\", \"replaced\", \"replaceme\", null, null)),\n+          properties(\"\"\"\n+            multiple=[replaceme:1][replaceme:2]\n+            multiple-prefixed=test[replaceme:1]test[replaceme:2]\n+            multiple-suffixed=[replaceme:1]test[replaceme:2]test\n+            multiple-both=test[replaceme:1]test[replaceme:2]test\n+            \"\"\")\n+        );\n+    }\n+\n+    @Test\n+    void validatesThatOldValueIsRequiredIfRegexEnabled() {\n+        assertTrue(new ChangePropertyValue(\"my.prop\", \"bar\", null, true, null).validate().isInvalid());\n+    }\n }\n\ndiff --git a/rewrite-yaml/src/test/java/org/openrewrite/yaml/ChangePropertyValueTest.java b/rewrite-yaml/src/test/java/org/openrewrite/yaml/ChangePropertyValueTest.java\nindex 8e1f38010fd..3a21b284133 100644\n--- a/rewrite-yaml/src/test/java/org/openrewrite/yaml/ChangePropertyValueTest.java\n+++ b/rewrite-yaml/src/test/java/org/openrewrite/yaml/ChangePropertyValueTest.java\n@@ -17,6 +17,7 @@\n \n import org.junit.jupiter.api.Test;\n import org.openrewrite.DocumentExample;\n+import org.openrewrite.Issue;\n import org.openrewrite.test.RewriteTest;\n \n import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -100,6 +101,44 @@ void regexDefaultOff() {\n         );\n     }\n \n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/3964\")\n+    void partialMatchWithMultipleRegexReplacements() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePropertyValue(\"*\", \"[replaced:$1]\", \"\\\\[replaceme:(.*?)]\", true, null)),\n+          yaml(\n+            \"\"\"\n+              multiple: \"[replaceme:1][replaceme:2]\"\n+              multiple-prefixed: \"test[replaceme:1]test[replaceme:2]\"\n+              multiple-suffixed: \"[replaceme:1]test[replaceme:2]test\"\n+              multiple-both: \"test[replaceme:1]test[replaceme:2]test\"\n+              \"\"\",\n+            \"\"\"\n+              multiple: \"[replaced:1][replaced:2]\"\n+              multiple-prefixed: \"test[replaced:1]test[replaced:2]\"\n+              multiple-suffixed: \"[replaced:1]test[replaced:2]test\"\n+              multiple-both: \"test[replaced:1]test[replaced:2]test\"\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/3964\")\n+    void partialMatchNotReplacedWithoutRegexTrue() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangePropertyValue(\"*\", \"replaced\", \"replaceme\", null, null)),\n+          yaml(\n+            \"\"\"\n+              multiple: \"[replaceme:1][replaceme:2]\"\n+              multiple-prefixed: \"test[replaceme:1]test[replaceme:2]\"\n+              multiple-suffixed: \"[replaceme:1]test[replaceme:2]test\"\n+              multiple-both: \"test[replaceme:1]test[replaceme:2]test\"\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void validatesThatOldValueIsRequiredIfRegexEnabled() {\n         assertTrue(new ChangePropertyValue(\"my.prop\", \"bar\", null, true, null).validate().isInvalid());\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-3960",
    "pr_id": 3960,
    "issue_id": 3959,
    "repo": "openrewrite/rewrite",
    "problem_statement": "DependencyUseStringNotation.coerceToStringNotation method is not compatible with G.GString\n<!--\r\nThank you for reporting an issue with OpenRewrite!\r\nWe appreciate you taking the time to help us improve.\r\nPlease fill out the template below to help us understand and reproduce the issue.\r\nFeel free to delete any sections that don't apply to your issue.\r\n-->\r\n\r\n## What version of OpenRewrite are you using?\r\nI am using\r\n- OpenRewrite latest.release\r\n- Maven/Gradle plugin latest.release\r\n\r\n## How are you running OpenRewrite?\r\nI am using the Moderne tenant, and my project is a single module project.\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\nbuild.gradle\r\n```groovy\r\nplugins {\r\n    id 'java-library'\r\n}\r\n              \r\ndef version = \"latest.release\"\r\ndependencies {\r\n    api(group: 'org.openrewrite', name: 'rewrite-core', version: \"$version\")\r\n    implementation group: 'group', name: 'artifact', version: \"$version\"\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\n```groovy\r\nplugins {\r\n    id 'java-library'\r\n}\r\n              \r\ndef version = \"latest.release\"\r\ndependencies {\r\n    api(\"org.openrewrite:rewrite-core:$version\")\r\n    implementation \"group:artifact:$version\"\r\n}\r\n```\r\n\r\n## What did you see instead?\r\n```groovy\r\nplugins {\r\n    id 'java-library'\r\n}\r\n              \r\ndef version = \"latest.release\"\r\ndependencies {\r\n    api(\"org.openrewrite:rewrite-core\")\r\n    implementation \"group:artifact\"\r\n}\r\n```\r\n\r\n## Are you interested in [contributing a fix to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#contributing-fixes)?\r\nI have a fix ready that will handle the G.Gstring\r\n",
    "issue_word_count": 209,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseStringNotation.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseStringNotationTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseStringNotationTest.java"
    ],
    "base_commit": "43906c545af8fa0f252f75a652c5a3b6d6359f81",
    "head_commit": "9997d0dc197d12b8811f7ea5cc8e37a13d37023d",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/3960",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/3960",
    "dockerfile": "",
    "pr_merged_at": "2024-01-31T11:23:44.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseStringNotation.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseStringNotation.java\nindex 82437d56c1a..d5a5283be31 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseStringNotation.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/DependencyUseStringNotation.java\n@@ -32,6 +32,7 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n \n import static org.openrewrite.Tree.randomId;\n@@ -153,6 +154,21 @@ private String coerceToStringNotation(Expression expression) {\n                     return (String) ((J.Literal) expression).getValue();\n                 } else if (expression instanceof J.Identifier) {\n                     return \"$\" + ((J.Identifier) expression).getSimpleName();\n+                } else if (expression instanceof G.GString) {\n+                    List<J> str = ((G.GString) expression).getStrings();\n+                    StringBuilder sb = new StringBuilder();\n+                    for (J valuePart : str) {\n+                        if (valuePart instanceof Expression) {\n+                            sb.append(coerceToStringNotation((Expression) valuePart));\n+                        } else if (valuePart instanceof G.GString.Value) {\n+                            J tree = ((G.GString.Value) valuePart).getTree();\n+                            if (tree instanceof Expression) {\n+                                sb.append(coerceToStringNotation((Expression) tree));\n+                            }\n+                            //Can it be something else? If so, what?\n+                        }\n+                    }\n+                    return sb.toString();\n                 }\n                 return null;\n             }\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseStringNotationTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseStringNotationTest.java\nindex 98a1d7dd724..cd3bebd7ba2 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseStringNotationTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/DependencyUseStringNotationTest.java\n@@ -114,6 +114,36 @@ void withGString() {\n         );\n     }\n \n+    @Test\n+    void withGStringLiteral() {\n+        rewriteRun(\n+          buildGradle(\n+            \"\"\"\n+              plugins {\n+                  id 'java-library'\n+              }\n+              \n+              def version = \"latest.release\"\n+              dependencies {\n+                  api(group: 'org.openrewrite', name: 'rewrite-core', version: \"$version\")\n+                  implementation group: 'group', name: 'artifact', version: \"$version\"\n+              }\n+              \"\"\",\n+            \"\"\"\n+              plugins {\n+                  id 'java-library'\n+              }\n+              \n+              def version = \"latest.release\"\n+              dependencies {\n+                  api(\"org.openrewrite:rewrite-core:$version\")\n+                  implementation \"group:artifact:$version\"\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n     @Test\n     void withoutVersion() {\n         rewriteRun(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-3939",
    "pr_id": 3939,
    "issue_id": 3938,
    "repo": "openrewrite/rewrite",
    "problem_statement": "`UpgradeSpringBoot_3_2` changes `build.gradle` `sourceCompatibility` and `targetCompatibility` from 21 back to 17\nTitle says it all - sorry for the brief report! Also I think they should ideally be JavaVersion.21 in Gradle 8.5 (to be fair you might already be detecting which convention to use - I had a plain `21` before I ran the script).",
    "issue_word_count": 56,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateJavaCompatibility.java",
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpdateJavaCompatibilityTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-gradle/src/test/java/org/openrewrite/gradle/UpdateJavaCompatibilityTest.java"
    ],
    "base_commit": "b044c5de771a6161d27d5c6170c2487ff5c47d90",
    "head_commit": "9fa99d4a22bcd3ec8f91e3be286a134b91b4bfc8",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/3939",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/3939",
    "dockerfile": "",
    "pr_merged_at": "2024-01-22T03:20:58.000Z",
    "patch": "diff --git a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateJavaCompatibility.java b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateJavaCompatibility.java\nindex a61d720cd64..799fbe6b458 100644\n--- a/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateJavaCompatibility.java\n+++ b/rewrite-gradle/src/main/java/org/openrewrite/gradle/UpdateJavaCompatibility.java\n@@ -57,6 +57,12 @@ public class UpdateJavaCompatibility extends Recipe {\n     @Nullable\n     DeclarationStyle declarationStyle;\n \n+    @Option(displayName = \"Allow Downgrade\",\n+            description = \"Allow downgrading the Java version.\",\n+            required = false)\n+    @Nullable\n+    Boolean allowDowngrade;\n+\n     @Override\n     public String getDisplayName() {\n         return \"Update Gradle project Java compatibility\";\n@@ -108,7 +114,8 @@ public J visitAssignment(J.Assignment assignment, ExecutionContext ctx) {\n \n                 DeclarationStyle currentStyle = getCurrentStyle(a.getAssignment());\n                 int currentMajor = getMajorVersion(a.getAssignment());\n-                if (currentMajor != version || (declarationStyle != null && declarationStyle != currentStyle)) {\n+                if ((currentMajor < version || currentMajor > version && Boolean.TRUE.equals(allowDowngrade))\n+                    || (declarationStyle != null && declarationStyle != currentStyle)) {\n                     DeclarationStyle actualStyle = declarationStyle == null ? currentStyle : declarationStyle;\n                     return a.withAssignment(changeExpression(a.getAssignment(), actualStyle));\n                 }\n",
    "test_patch": "diff --git a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpdateJavaCompatibilityTest.java b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpdateJavaCompatibilityTest.java\nindex 8e2d196ddbb..e933f1f5666 100644\n--- a/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpdateJavaCompatibilityTest.java\n+++ b/rewrite-gradle/src/test/java/org/openrewrite/gradle/UpdateJavaCompatibilityTest.java\n@@ -35,7 +35,7 @@ class UpdateJavaCompatibilityTest implements RewriteTest {\n       \"\"\", quoteCharacter = '`')\n     void sourceAndTarget(String beforeSourceCompatibility, String beforeTargetCompatibility, String afterSourceCompatibility, String afterTargetCompatibility) {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateJavaCompatibility(11, null, null)),\n+          spec -> spec.recipe(new UpdateJavaCompatibility(11, null, null, null)),\n           buildGradle(\n             \"\"\"\n               plugins {\n@@ -60,7 +60,7 @@ void sourceAndTarget(String beforeSourceCompatibility, String beforeTargetCompat\n     @Test\n     void sourceOnly() {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateJavaCompatibility(11, UpdateJavaCompatibility.CompatibilityType.source, null)),\n+          spec -> spec.recipe(new UpdateJavaCompatibility(11, UpdateJavaCompatibility.CompatibilityType.source, null, null)),\n           buildGradle(\n             \"\"\"\n               plugins {\n@@ -85,7 +85,7 @@ void sourceOnly() {\n     @Test\n     void targetOnly() {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateJavaCompatibility(11, UpdateJavaCompatibility.CompatibilityType.target, null)),\n+          spec -> spec.recipe(new UpdateJavaCompatibility(11, UpdateJavaCompatibility.CompatibilityType.target, null, null)),\n           buildGradle(\n             \"\"\"\n               plugins {\n@@ -123,7 +123,7 @@ void targetOnly() {\n       \"\"\", quoteCharacter = '`')\n     void styleChange(String declarationStyle, String beforeCompatibility, String afterCompatibility) {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateJavaCompatibility(8, null, UpdateJavaCompatibility.DeclarationStyle.valueOf(declarationStyle))),\n+          spec -> spec.recipe(new UpdateJavaCompatibility(8, null, UpdateJavaCompatibility.DeclarationStyle.valueOf(declarationStyle), null)),\n           buildGradle(\n             \"\"\"\n               plugins {\n@@ -148,7 +148,7 @@ void styleChange(String declarationStyle, String beforeCompatibility, String aft\n     @Test\n     void handlesJavaExtension() {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateJavaCompatibility(11, null, null)),\n+          spec -> spec.recipe(new UpdateJavaCompatibility(11, null, null, null)),\n           buildGradle(\n             \"\"\"\n               plugins {\n@@ -177,7 +177,7 @@ void handlesJavaExtension() {\n     @Test\n     void handlesJavaToolchains() {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateJavaCompatibility(11, null, null)),\n+          spec -> spec.recipe(new UpdateJavaCompatibility(11, null, null, null)),\n           buildGradle(\n             \"\"\"\n               plugins {\n@@ -211,11 +211,10 @@ void handlesJavaToolchains() {\n       11,\"1.8\",\"11\"\n       11,1.8,11\n       11,8,11\n-      8,11,8\n       \"\"\")\n     void handlesJavaVersionMethodInvocation(int version, String before, String after) {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateJavaCompatibility(version, null, null)),\n+          spec -> spec.recipe(new UpdateJavaCompatibility(version, null, null, null)),\n           buildGradle(\n             \"\"\"\n               java {\n@@ -244,7 +243,7 @@ void handlesJavaVersionMethodInvocation(int version, String before, String after\n       \"\"\", quoteCharacter = '`')\n     void allOptions(String compatibilityType, String declarationStyle, String expectedSourceCompatibility, String expectedTargetCompatibility) {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateJavaCompatibility(11, UpdateJavaCompatibility.CompatibilityType.valueOf(compatibilityType), UpdateJavaCompatibility.DeclarationStyle.valueOf(declarationStyle))),\n+          spec -> spec.recipe(new UpdateJavaCompatibility(11, UpdateJavaCompatibility.CompatibilityType.valueOf(compatibilityType), UpdateJavaCompatibility.DeclarationStyle.valueOf(declarationStyle), null)),\n           buildGradle(\n             \"\"\"\n               plugins {\n@@ -270,7 +269,7 @@ void allOptions(String compatibilityType, String declarationStyle, String expect\n     @Test\n     void onlyModifyCompatibilityAssignments() {\n         rewriteRun(\n-          spec -> spec.recipe(new UpdateJavaCompatibility(11, null, null)),\n+          spec -> spec.recipe(new UpdateJavaCompatibility(11, null, null, null)),\n           buildGradle(\n             \"\"\"\n               version = \"0.1.0-SNAPSHOT\"\n@@ -291,4 +290,47 @@ void onlyModifyCompatibilityAssignments() {\n           )\n         );\n     }\n+\n+    @Test\n+    void doNotDowngradeByDefault() {\n+        rewriteRun(\n+          spec -> spec.recipe(new UpdateJavaCompatibility(17, null, null, null)),\n+          buildGradle(\n+            \"\"\"\n+              plugins {\n+                  id \"java\"\n+              }\n+\n+              sourceCompatibility = 21\n+              targetCompatibility = 21\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void doDowngradeWhenRequested() {\n+        rewriteRun(\n+          spec -> spec.recipe(new UpdateJavaCompatibility(17, null, null, true)),\n+          buildGradle(\n+            \"\"\"\n+              plugins {\n+                  id \"java\"\n+              }\n+\n+              sourceCompatibility = 21\n+              targetCompatibility = 21\n+              \"\"\",\n+\n+            \"\"\"\n+              plugins {\n+                  id \"java\"\n+              }\n+\n+              sourceCompatibility = 17\n+              targetCompatibility = 17\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-3934",
    "pr_id": 3934,
    "issue_id": 3919,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Support for XML Namespaces\n<!--\r\nThank you for suggesting an improvement to OpenRewrite!\r\nFeel free to delete any sections that don't apply to your request.\r\n-->\r\n## What problem are you trying to solve?\r\nChange namespaced tags without being required to know the namespace prefix. For example, on the following XML, I want to replace the `schemaLocation` attribute on the `beans` tag.\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd\r\n                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd\">\r\n</bean>\r\n```\r\n\r\nThere are situations where the namespace URI remains the same, but the prefix changes. I can try change the attribute `xsi:schemaLocation`, but for that the prefix should match.\r\n\r\n## Describe the solution you'd like\r\n- Add regex support to `ChangeTagAttribute` (~~I already have this working, I will contribute a PR~~ #3920);\r\n- Add support to [`name`](https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/name), ~~[`namespace-uri`](https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/namespace-uri) and [`local-name`](https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/local-name)~~ on `XPathMatcher`; #3925 and #4287 \r\n- ~~Add a `namespaces` field on `Xml.Document` and `Xml.Tag`, mapping the declared prefixes and namespaces;~~ #3925 and\r\n- ~~Add a `namespace` or a `namespacePrefix` field on `Xml.Tag` and `Xml.Attribute`, identifying the namespace of that particular tag/attribute.~~ #3925 \r\n- Move tags/attributes between namespaces\r\n\r\n## Have you considered any alternatives or workarounds?\r\nNo.\r\n\r\n## Additional context\r\n<!-- Any thoughts that come to mind, or similar items on the backlog already. -->\r\n\r\n## Are you interested in [contributing this feature to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#new-features)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->",
    "issue_word_count": 332,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java"
    ],
    "base_commit": "3cd3e70444002198e5c1924bf78ef48203a82427",
    "head_commit": "39617d1597a80c39b9d6bd85b4c1c6b599c1484f",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/3934",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/3934",
    "dockerfile": "",
    "pr_merged_at": "2024-01-18T18:50:28.000Z",
    "patch": "",
    "test_patch": "diff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\nindex 5e5fd36e563..9c01d10a588 100755\n--- a/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\n@@ -15,8 +15,10 @@\n  */\n package org.openrewrite.xml;\n \n+import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n import org.openrewrite.ExecutionContext;\n+import org.openrewrite.Issue;\n import org.openrewrite.SourceFile;\n import org.openrewrite.TreeVisitor;\n import org.openrewrite.marker.SearchResult;\n@@ -91,6 +93,22 @@ class XPathMatcherTest {\n         \"\"\"\n     ).toList().get(0);\n \n+    private final SourceFile namespacedXml = new XmlParser().parse(\n+      \"\"\"\n+        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <root xmlns=\"http://www.example.com/namespace1\"\n+              xmlns:ns2=\"http://www.example.com/namespace2\"\n+              xmlns:ns3=\"http://www.example.com/namespace3\"\n+              xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+              xsi:schemaLocation=\"http://www.example.com/namespace1 http://www.example.com/namespace1.xsd\n+                                  http://www.example.com/namespace2 http://www.example.com/namespace2.xsd\n+                                  http://www.example.com/namespace3 http://www.example.com/namespace3.xsd\">\n+          <element1 ns3:attribute1=\"content3\">content1</element1>\n+          <ns2:element2>content2</ns2:element2>\n+        </root>\n+        \"\"\"\n+    ).toList().get(0);\n+\n     @Test\n     void matchAbsolute() {\n         assertThat(match(\"/dependencies/dependency\", xmlDoc)).isTrue();\n@@ -137,6 +155,35 @@ void matchPom() {\n           pomXml2)).isTrue();\n     }\n \n+    @Test\n+    @Disabled\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/3919\")\n+    void matchFunctions() {\n+        assertThat(match(\"/root/element1\", namespacedXml)).isTrue();\n+        assertThat(match(\"/root/ns2:element2\", namespacedXml)).isTrue();\n+        assertThat(match(\"/root/dne\", namespacedXml)).isFalse();\n+\n+        // Namespace functions\n+        assertThat(match(\"/*[local-name()='element1']\", namespacedXml)).isFalse();\n+        assertThat(match(\"//*[local-name()='element1']\", namespacedXml)).isFalse();\n+        assertThat(match(\"/root/*[local-name()='element1']\", namespacedXml)).isTrue();\n+        assertThat(match(\"/root/*[namespace-uri()='http://www.example.com/namespace2']\", namespacedXml)).isTrue();\n+        assertThat(match(\"/*[namespace-uri()='http://www.example.com/namespace2']\", namespacedXml)).isFalse();\n+        assertThat(match(\"//*[namespace-uri()='http://www.example.com/namespace2']\", namespacedXml)).isTrue();\n+        assertThat(match(\"//@*[namespace-uri()='http://www.example.com/namespace3']\", namespacedXml)).isTrue();\n+\n+        // Other common XPath functions\n+        assertThat(match(\"contains(/root/element1, 'content1')\", namespacedXml)).isTrue();\n+        assertThat(match(\"not(contains(/root/element1, 'content1'))\", namespacedXml)).isFalse();\n+        assertThat(match(\"string-length(/root/element1) > 2\", namespacedXml)).isTrue();\n+        assertThat(match(\"starts-with(/root/element1, 'content1')\", namespacedXml)).isTrue();\n+        assertThat(match(\"ends-with(/root/element1, 'content1')\", namespacedXml)).isTrue();\n+        assertThat(match(\"substring-before(/root/element1, '1') = 'content'\", namespacedXml)).isTrue();\n+        assertThat(match(\"substring-after(/root/element1, 'content') = '1'\", namespacedXml)).isTrue();\n+        assertThat(match(\"/root/element1/text()\", namespacedXml)).isTrue();\n+        assertThat(match(\"count(/root/*)\", namespacedXml)).isTrue();\n+    }\n+\n     private boolean match(String xpath, SourceFile x) {\n         XPathMatcher matcher = new XPathMatcher(xpath);\n         return !TreeVisitor.collect(new XmlVisitor<>() {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-3925",
    "pr_id": 3925,
    "issue_id": 3919,
    "repo": "openrewrite/rewrite",
    "problem_statement": "Support for XML Namespaces\n<!--\r\nThank you for suggesting an improvement to OpenRewrite!\r\nFeel free to delete any sections that don't apply to your request.\r\n-->\r\n## What problem are you trying to solve?\r\nChange namespaced tags without being required to know the namespace prefix. For example, on the following XML, I want to replace the `schemaLocation` attribute on the `beans` tag.\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd\r\n                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd\">\r\n</bean>\r\n```\r\n\r\nThere are situations where the namespace URI remains the same, but the prefix changes. I can try change the attribute `xsi:schemaLocation`, but for that the prefix should match.\r\n\r\n## Describe the solution you'd like\r\n- Add regex support to `ChangeTagAttribute` (~~I already have this working, I will contribute a PR~~ #3920);\r\n- Add support to [`name`](https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/name), ~~[`namespace-uri`](https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/namespace-uri) and [`local-name`](https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/local-name)~~ on `XPathMatcher`; #3925 and #4287 \r\n- ~~Add a `namespaces` field on `Xml.Document` and `Xml.Tag`, mapping the declared prefixes and namespaces;~~ #3925 and\r\n- ~~Add a `namespace` or a `namespacePrefix` field on `Xml.Tag` and `Xml.Attribute`, identifying the namespace of that particular tag/attribute.~~ #3925 \r\n- Move tags/attributes between namespaces\r\n\r\n## Have you considered any alternatives or workarounds?\r\nNo.\r\n\r\n## Additional context\r\n<!-- Any thoughts that come to mind, or similar items on the backlog already. -->\r\n\r\n## Are you interested in [contributing this feature to OpenRewrite](https://github.com/openrewrite/.github/blob/main/CONTRIBUTING.md#new-features)?\r\n<!-- Indicate if this is something you would like to work on, and how we can best support you in doing so. -->",
    "issue_word_count": 332,
    "test_files_count": 6,
    "non_test_files_count": 5,
    "pr_changed_files": [
      "rewrite-xml/src/main/java/org/openrewrite/xml/ChangeNamespaceValue.java",
      "rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java",
      "rewrite-xml/src/main/java/org/openrewrite/xml/search/FindNamespacePrefix.java",
      "rewrite-xml/src/main/java/org/openrewrite/xml/search/HasNamespaceUri.java",
      "rewrite-xml/src/main/java/org/openrewrite/xml/tree/Xml.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/ChangeNamespaceValueTest.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/CreateXmlFileTest.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/internal/XmlTest.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/search/FindNamespacePrefixTest.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/search/HasNamespaceUriTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-xml/src/test/java/org/openrewrite/xml/ChangeNamespaceValueTest.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/CreateXmlFileTest.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/internal/XmlTest.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/search/FindNamespacePrefixTest.java",
      "rewrite-xml/src/test/java/org/openrewrite/xml/search/HasNamespaceUriTest.java"
    ],
    "base_commit": "02dc9794060d2080fe9962529f9c232c62a8abc8",
    "head_commit": "e4083b403ea818eb7d1facc7701dd42f7cf759bb",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/3925",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/3925",
    "dockerfile": "",
    "pr_merged_at": "2024-06-20T04:50:56.000Z",
    "patch": "diff --git a/rewrite-xml/src/main/java/org/openrewrite/xml/ChangeNamespaceValue.java b/rewrite-xml/src/main/java/org/openrewrite/xml/ChangeNamespaceValue.java\nindex b821a95421e..6813ed343f2 100644\n--- a/rewrite-xml/src/main/java/org/openrewrite/xml/ChangeNamespaceValue.java\n+++ b/rewrite-xml/src/main/java/org/openrewrite/xml/ChangeNamespaceValue.java\n@@ -19,14 +19,26 @@\n import lombok.Value;\n import org.openrewrite.*;\n import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.internal.StringUtils;\n import org.openrewrite.internal.lang.Nullable;\n+import org.openrewrite.marker.Markers;\n import org.openrewrite.xml.tree.Xml;\n \n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static org.openrewrite.Tree.randomId;\n+\n @Value\n @EqualsAndHashCode(callSuper = false)\n public class ChangeNamespaceValue extends Recipe {\n     private static final String XMLNS_PREFIX = \"xmlns\";\n     private static final String VERSION_PREFIX = \"version\";\n+    private static final String SCHEMA_LOCATION_MATCH_PATTERN = \"(?m)(.*)(%s)(\\\\s+)(.*)\";\n+    private static final String SCHEMA_LOCATION_REPLACEMENT_PATTERN = \"$1%s$3%s\";\n+    private static final String MSG_TAG_UPDATED = \"msg-tag-updated\";\n \n     @Override\n     public String getDisplayName() {\n@@ -65,22 +77,73 @@ public String getDescription() {\n     String versionMatcher;\n \n     @Nullable\n-    @Option(displayName = \"Search All Namespaces\",\n+    @Option(displayName = \"Search all namespaces\",\n             description = \"Specify whether evaluate all namespaces. Defaults to true\",\n             example = \"true\",\n             required = false)\n     Boolean searchAllNamespaces;\n \n+    @Nullable\n+    @Option(displayName = \"New Resource version\",\n+            description = \"The new version of the resource\",\n+            example = \"2.0\")\n+    String newVersion;\n+\n+    @Option(displayName = \"Schema location\",\n+            description = \"The new value to be used for the namespace schema location.\",\n+            example = \"newfoo.bar.attribute.value.string\",\n+            required = false)\n+    @Nullable\n+    String newSchemaLocation;\n+\n+    public static final String XML_SCHEMA_INSTANCE_PREFIX = \"xsi\";\n+    public static final String XML_SCHEMA_INSTANCE_URI = \"http://www.w3.org/2001/XMLSchema-instance\";\n+\n+    /**\n+     * Find the tag that contains the declaration of the {@link #XML_SCHEMA_INSTANCE_URI} namespace.\n+     *\n+     * @param cursor the cursor to search from\n+     * @return the tag that contains the declaration of the given namespace URI.\n+     */\n+    public static Xml.Tag findTagContainingXmlSchemaInstanceNamespace(Cursor cursor) {\n+        while (cursor != null) {\n+            if (cursor.getValue() instanceof Xml.Document) {\n+                return ((Xml.Document) cursor.getValue()).getRoot();\n+            }\n+            Xml.Tag tag = cursor.firstEnclosing(Xml.Tag.class);\n+            if (tag != null) {\n+                if (tag.getNamespaces().containsValue(XML_SCHEMA_INSTANCE_URI)) {\n+                    return tag;\n+                }\n+            }\n+            cursor = cursor.getParent();\n+        }\n+\n+        // Should never happen\n+        throw new IllegalArgumentException(\"Could not find tag containing namespace '\" + XML_SCHEMA_INSTANCE_URI + \"' or the enclosing Xml.Document instance.\");\n+    }\n+\n     @Override\n     public TreeVisitor<?, ExecutionContext> getVisitor() {\n         XPathMatcher elementNameMatcher = elementName != null ? new XPathMatcher(elementName) : null;\n         return new XmlIsoVisitor<ExecutionContext>() {\n+            @Override\n+            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {\n+                Xml.Document d = super.visitDocument(document, ctx);\n+                if (ctx.pollMessage(MSG_TAG_UPDATED, false)) {\n+                    d = d.withRoot(addOrUpdateSchemaLocation(d.getRoot(), getCursor()));\n+                }\n+                return d;\n+            }\n+\n             @Override\n             public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {\n                 Xml.Tag t = super.visitTag(tag, ctx);\n \n                 if (matchesElementName(getCursor()) && matchesVersion(t)) {\n                     t = t.withAttributes(ListUtils.map(t.getAttributes(), this::maybeReplaceNamespaceAttribute));\n+                    t = t.withAttributes(ListUtils.map(t.getAttributes(), this::maybeReplaceVersionAttribute));\n+                    ctx.putMessage(MSG_TAG_UPDATED, true);\n                 }\n \n                 return t;\n@@ -114,6 +177,18 @@ private Xml.Attribute maybeReplaceNamespaceAttribute(Xml.Attribute attribute) {\n                 return attribute;\n             }\n \n+            private Xml.Attribute maybeReplaceVersionAttribute(Xml.Attribute attribute) {\n+                if (isVersionAttribute(attribute) && newVersion != null) {\n+                    return attribute.withValue(\n+                            new Xml.Attribute.Value(attribute.getId(),\n+                                    \"\",\n+                                    attribute.getMarkers(),\n+                                    attribute.getValue().getQuote(),\n+                                    newVersion));\n+                }\n+                return attribute;\n+            }\n+\n             private boolean isXmlnsAttribute(Xml.Attribute attribute) {\n                 boolean searchAll = searchAllNamespaces == null || Boolean.TRUE.equals(searchAllNamespaces);\n                 return searchAll && attribute.getKeyAsString().startsWith(XMLNS_PREFIX) ||\n@@ -129,6 +204,9 @@ private boolean isOldValue(Xml.Attribute attribute) {\n             }\n \n             private boolean isVersionMatch(Xml.Attribute attribute) {\n+                if (versionMatcher == null) {\n+                    return true;\n+                }\n                 String[] versions = versionMatcher.split(\",\");\n                 double dversion = Double.parseDouble(attribute.getValueAsString());\n                 for (String splitVersion : versions) {\n@@ -149,6 +227,87 @@ private boolean isVersionMatch(Xml.Attribute attribute) {\n                 }\n                 return false;\n             }\n+\n+            private Xml.Tag addOrUpdateSchemaLocation(Xml.Tag root, Cursor cursor) {\n+                if (StringUtils.isBlank(newSchemaLocation)) {\n+                    return root;\n+                }\n+                Xml.Tag newRoot = maybeAddNamespace(root);\n+                Optional<Xml.Attribute> maybeSchemaLocation = maybeGetSchemaLocation(cursor, newRoot);\n+                if (maybeSchemaLocation.isPresent() && oldValue != null) {\n+                    newRoot = updateSchemaLocation(newRoot, maybeSchemaLocation.get());\n+                } else if (!maybeSchemaLocation.isPresent()) {\n+                    newRoot = addSchemaLocation(newRoot);\n+                }\n+                return newRoot;\n+            }\n+\n+            private Optional<Xml.Attribute> maybeGetSchemaLocation(Cursor cursor, Xml.Tag tag) {\n+                Xml.Tag schemaLocationTag = findTagContainingXmlSchemaInstanceNamespace(cursor);\n+                Map<String, String> namespaces = tag.getNamespaces();\n+                for (Xml.Attribute attribute : schemaLocationTag.getAttributes()) {\n+                    String attributeNamespace = namespaces.get(Xml.extractNamespacePrefix(attribute.getKeyAsString()));\n+                    if(XML_SCHEMA_INSTANCE_URI.equals(attributeNamespace)\n+                       && attribute.getKeyAsString().endsWith(\"schemaLocation\")) {\n+                        return Optional.of(attribute);\n+                    }\n+                }\n+\n+                return Optional.empty();\n+            }\n+\n+            private Xml.Tag maybeAddNamespace(Xml.Tag root) {\n+                Map<String, String> namespaces = root.getNamespaces();\n+                if (namespaces.containsValue(newValue) && !namespaces.containsValue(XML_SCHEMA_INSTANCE_URI)) {\n+                    namespaces.put(XML_SCHEMA_INSTANCE_PREFIX, XML_SCHEMA_INSTANCE_URI);\n+                    root = root.withNamespaces(namespaces);\n+                }\n+                return root;\n+            }\n+\n+            private Xml.Tag updateSchemaLocation(Xml.Tag newRoot, Xml.Attribute attribute) {\n+                if(oldValue == null) {\n+                    return newRoot;\n+                }\n+                String oldSchemaLocation = attribute.getValueAsString();\n+                Matcher pattern = Pattern.compile(String.format(SCHEMA_LOCATION_MATCH_PATTERN, Pattern.quote(oldValue)))\n+                        .matcher(oldSchemaLocation);\n+                if (pattern.find()) {\n+                    String newSchemaLocationValue = pattern.replaceFirst(\n+                            String.format(SCHEMA_LOCATION_REPLACEMENT_PATTERN, newValue, newSchemaLocation)\n+                    );\n+                    Xml.Attribute newAttribute = attribute.withValue(attribute.getValue().withValue(newSchemaLocationValue));\n+                    newRoot = newRoot.withAttributes(ListUtils.map(newRoot.getAttributes(), a -> a == attribute ? newAttribute : a));\n+                }\n+                return newRoot;\n+            }\n+\n+            private Xml.Tag addSchemaLocation(Xml.Tag newRoot) {\n+                return newRoot.withAttributes(\n+                        ListUtils.concat(\n+                                newRoot.getAttributes(),\n+                                new Xml.Attribute(\n+                                        randomId(),\n+                                        \" \",\n+                                        Markers.EMPTY,\n+                                        new Xml.Ident(\n+                                                randomId(),\n+                                                \"\",\n+                                                Markers.EMPTY,\n+                                                String.format(\"%s:schemaLocation\", XML_SCHEMA_INSTANCE_PREFIX)\n+                                        ),\n+                                        \"\",\n+                                        new Xml.Attribute.Value(\n+                                                randomId(),\n+                                                \"\",\n+                                                Markers.EMPTY,\n+                                                Xml.Attribute.Value.Quote.Double,\n+                                                String.format(\"%s %s\", newValue, newSchemaLocation)\n+                                        )\n+                                )\n+                        )\n+                );\n+            }\n         };\n     }\n }\n\ndiff --git a/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java b/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java\nindex 9aa28ad3ec2..7c6066b72f9 100644\n--- a/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java\n+++ b/rewrite-xml/src/main/java/org/openrewrite/xml/XPathMatcher.java\n@@ -37,7 +37,7 @@\n public class XPathMatcher {\n \n     // Regular expression to support conditional tags like `plugin[artifactId='maven-compiler-plugin']` or foo[@bar='baz']\n-    private static final Pattern PATTERN = Pattern.compile(\"([-\\\\w]+)\\\\[(@)?([-\\\\w]+)='([-\\\\w.]+)']\");\n+    private static final Pattern PATTERN = Pattern.compile(\"([-\\\\w]+|\\\\*)\\\\[((local-name|namespace-uri)\\\\(\\\\)|(@)?([-\\\\w]+|\\\\*))='([-\\\\w.]+)']\");\n \n     private final String expression;\n     private final boolean startsWithSlash;\n@@ -82,6 +82,9 @@ public boolean matches(Cursor cursor) {\n                     if (part.charAt(index + 1) == '@') {\n                         partWithCondition = part;\n                         tagForCondition = path.get(i);\n+                    } else if (part.contains(\"(\") && part.contains(\")\")) { //if is function\n+                        partWithCondition = part;\n+                        tagForCondition = path.get(i);\n                     }\n                 } else if (i < path.size() && i > 0 && parts[i - 1].endsWith(\"]\")) {\n                     String partBefore = parts[i - 1];\n@@ -94,6 +97,8 @@ public boolean matches(Cursor cursor) {\n                         partWithCondition = partBefore;\n                         tagForCondition = path.get(parts.length - i);\n                     }\n+                } else if (part.endsWith(\")\")) { // is xpath method\n+                    // TODO: implement other xpath methods\n                 }\n \n                 String partName;\n@@ -101,7 +106,7 @@ public boolean matches(Cursor cursor) {\n                 Matcher matcher;\n                 if (tagForCondition != null && partWithCondition.endsWith(\"]\") && (matcher = PATTERN.matcher(\n                         partWithCondition)).matches()) {\n-                    String optionalPartName = matchesCondition(matcher, tagForCondition);\n+                    String optionalPartName = matchesCondition(matcher, tagForCondition, cursor);\n                     if (optionalPartName == null) {\n                         return false;\n                     }\n@@ -176,7 +181,7 @@ public boolean matches(Cursor cursor) {\n \n                 Matcher matcher;\n                 if (tag != null && part.endsWith(\"]\") && (matcher = PATTERN.matcher(part)).matches()) {\n-                    String optionalPartName = matchesCondition(matcher, tag);\n+                    String optionalPartName = matchesCondition(matcher, tag, cursor);\n                     if (optionalPartName == null) {\n                         return false;\n                     }\n@@ -191,7 +196,7 @@ public boolean matches(Cursor cursor) {\n                                     \"*\".equals(part.substring(1)));\n                 }\n \n-                if (path.size() < i + 1 || (tag != null && !tag.getName().equals(partName) && !\"*\".equals(part))) {\n+                if (path.size() < i + 1 || (tag != null && !tag.getName().equals(partName) && !partName.equals(\"*\") && !\"*\".equals(part))) {\n                     return false;\n                 }\n             }\n@@ -201,21 +206,34 @@ public boolean matches(Cursor cursor) {\n     }\n \n     @Nullable\n-    private String matchesCondition(Matcher matcher, Xml.Tag tag) {\n+    private String matchesCondition(Matcher matcher, Xml.Tag tag, Cursor cursor) {\n         String name = matcher.group(1);\n-        boolean isAttribute = Objects.equals(matcher.group(2), \"@\");\n-        String selector = matcher.group(3);\n-        String value = matcher.group(4);\n+        boolean isAttribute = matcher.group(4) != null; // either group4 != null, or group 2 startsWith @\n+        String selector = isAttribute ? matcher.group(5) : matcher.group(2);\n+        boolean isFunction = selector.endsWith(\"()\");\n+        String value = matcher.group(6);\n \n         boolean matchCondition = false;\n         if (isAttribute) {\n             for (Xml.Attribute a : tag.getAttributes()) {\n-                if (a.getKeyAsString().equals(selector) && a.getValueAsString().equals(value)) {\n+                if ((a.getKeyAsString().equals(selector) || \"*\".equals(selector)) && a.getValueAsString().equals(value)) {\n                     matchCondition = true;\n                     break;\n                 }\n             }\n-        } else {\n+        } else if (isFunction) {\n+            if (!name.equals(\"*\") && !tag.getLocalName().equals(name)) {\n+                matchCondition = false;\n+            } else if (selector.equals(\"local-name()\")) {\n+                if (tag.getLocalName().equals(value)) {\n+                    matchCondition = true;\n+                }\n+            } else if (selector.equals(\"namespace-uri()\")) {\n+                if (tag.getNamespaceUri(cursor).get().equals(value)) {\n+                    matchCondition = true;\n+                }\n+            }\n+        } else { // other [] conditions\n             for (Xml.Tag t : FindTags.find(tag, selector)) {\n                 if (t.getValue().map(v -> v.equals(value)).orElse(false)) {\n                     matchCondition = true;\n\ndiff --git a/rewrite-xml/src/main/java/org/openrewrite/xml/search/FindNamespacePrefix.java b/rewrite-xml/src/main/java/org/openrewrite/xml/search/FindNamespacePrefix.java\nnew file mode 100644\nindex 00000000000..95623523636\n--- /dev/null\n+++ b/rewrite-xml/src/main/java/org/openrewrite/xml/search/FindNamespacePrefix.java\n@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.xml.search;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.Value;\n+import org.openrewrite.ExecutionContext;\n+import org.openrewrite.Option;\n+import org.openrewrite.Recipe;\n+import org.openrewrite.TreeVisitor;\n+import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.internal.lang.Nullable;\n+import org.openrewrite.marker.SearchResult;\n+import org.openrewrite.xml.XPathMatcher;\n+import org.openrewrite.xml.XmlVisitor;\n+import org.openrewrite.xml.tree.Xml;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@Value\n+@EqualsAndHashCode(callSuper = false)\n+public class FindNamespacePrefix extends Recipe {\n+\n+    @Option(displayName = \"Namespace prefix\",\n+            description = \"The Namespace Prefix to find.\",\n+            example = \"http://www.w3.org/2001/XMLSchema-instance\")\n+    String namespacePrefix;\n+\n+    @Option(displayName = \"XPath\",\n+            description = \"An XPath expression used to find namespace URIs.\",\n+            example = \"/dependencies/dependency\",\n+            required = false)\n+    @Nullable\n+    String xPath;\n+\n+    @Override\n+    public String getDisplayName() {\n+        return \"Find XML namespace prefixes\";\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"Find XML namespace prefixes, optionally restricting the search by a XPath expression.\";\n+    }\n+\n+    @Override\n+    public TreeVisitor<?, ExecutionContext> getVisitor() {\n+        XPathMatcher matcher = StringUtils.isBlank(xPath) ? null : new XPathMatcher(xPath);\n+        return new XmlVisitor<ExecutionContext>() {\n+\n+            @Override\n+            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n+                Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);\n+                if (tag.getNamespaces().containsKey(namespacePrefix) && (matcher == null || matcher.matches(getCursor()))) {\n+                    t = SearchResult.found(t);\n+                }\n+                return t;\n+            }\n+        };\n+    }\n+\n+    public static Set<Xml.Tag> find(Xml x, String namespacePrefix, @Nullable String xPath) {\n+        XPathMatcher matcher = StringUtils.isBlank(xPath) ? null : new XPathMatcher(xPath);\n+        Set<Xml.Tag> ts = new HashSet<>();\n+        new XmlVisitor<Set<Xml.Tag>>() {\n+            @Override\n+            public Xml visitTag(Xml.Tag tag, Set<Xml.Tag> ts) {\n+                if (tag.getNamespaces().containsKey(namespacePrefix) && (matcher == null || matcher.matches(getCursor()))) {\n+                    ts.add(tag);\n+                }\n+                return super.visitTag(tag, ts);\n+            }\n+        }.visit(x, ts);\n+        return ts;\n+    }\n+}\n\ndiff --git a/rewrite-xml/src/main/java/org/openrewrite/xml/search/HasNamespaceUri.java b/rewrite-xml/src/main/java/org/openrewrite/xml/search/HasNamespaceUri.java\nnew file mode 100644\nindex 00000000000..2745aff2264\n--- /dev/null\n+++ b/rewrite-xml/src/main/java/org/openrewrite/xml/search/HasNamespaceUri.java\n@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.xml.search;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.Value;\n+import org.openrewrite.ExecutionContext;\n+import org.openrewrite.Option;\n+import org.openrewrite.Recipe;\n+import org.openrewrite.TreeVisitor;\n+import org.openrewrite.internal.StringUtils;\n+import org.openrewrite.internal.lang.Nullable;\n+import org.openrewrite.marker.SearchResult;\n+import org.openrewrite.xml.XPathMatcher;\n+import org.openrewrite.xml.XmlVisitor;\n+import org.openrewrite.xml.tree.Xml;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@Value\n+@EqualsAndHashCode(callSuper = false)\n+public class HasNamespaceUri extends Recipe {\n+\n+    @Option(displayName = \"Namespace URI\",\n+            description = \"The Namespace URI to find.\",\n+            example = \"http://www.w3.org/2001/XMLSchema-instance\")\n+    String namespaceUri;\n+\n+    @Option(displayName = \"XPath\",\n+            description = \"An XPath expression used to find namespace URIs.\",\n+            example = \"/dependencies/dependency\",\n+            required = false)\n+    @Nullable\n+    String xPath;\n+\n+    @Override\n+    public String getDisplayName() {\n+        return \"Find XML namespace URIs\";\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"Find XML namespace URIs, optionally restricting the search by a XPath expression.\";\n+    }\n+\n+    @Override\n+    public TreeVisitor<?, ExecutionContext> getVisitor() {\n+        XPathMatcher matcher = StringUtils.isBlank(xPath) ? null : new XPathMatcher(xPath);\n+        return new XmlVisitor<ExecutionContext>() {\n+\n+            @Override\n+            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {\n+                Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);\n+                if (tag.getNamespaces().containsValue(namespaceUri) && (matcher == null || matcher.matches(getCursor()))) {\n+                    t = SearchResult.found(t);\n+                }\n+                return t;\n+            }\n+        };\n+    }\n+\n+    public static Set<Xml.Tag> find(Xml x, String namespaceUri, @Nullable String xPath) {\n+        XPathMatcher matcher = StringUtils.isBlank(xPath) ? null : new XPathMatcher(xPath);\n+        Set<Xml.Tag> ts = new HashSet<>();\n+        new XmlVisitor<Set<Xml.Tag>>() {\n+            @Override\n+            public Xml visitTag(Xml.Tag tag, Set<Xml.Tag> ts) {\n+                if (tag.getNamespaces().containsValue(namespaceUri) && (matcher == null || matcher.matches(getCursor()))) {\n+                    ts.add(tag);\n+                }\n+                return super.visitTag(tag, ts);\n+            }\n+        }.visit(x, ts);\n+        return ts;\n+    }\n+}\n\ndiff --git a/rewrite-xml/src/main/java/org/openrewrite/xml/tree/Xml.java b/rewrite-xml/src/main/java/org/openrewrite/xml/tree/Xml.java\nindex ff3be4ba794..caa74a3e842 100755\n--- a/rewrite-xml/src/main/java/org/openrewrite/xml/tree/Xml.java\n+++ b/rewrite-xml/src/main/java/org/openrewrite/xml/tree/Xml.java\n@@ -20,6 +20,8 @@\n import org.apache.commons.text.StringEscapeUtils;\n import org.intellij.lang.annotations.Language;\n import org.openrewrite.*;\n+import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.internal.StringUtils;\n import org.openrewrite.internal.WhitespaceValidationService;\n import org.openrewrite.internal.lang.Nullable;\n import org.openrewrite.marker.Markers;\n@@ -32,10 +34,7 @@\n import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Path;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.UUID;\n+import java.util.*;\n import java.util.stream.Collectors;\n \n import static java.util.Collections.emptyList;\n@@ -75,20 +74,61 @@ default <P> boolean isAcceptable(TreeVisitor<?, P> v, P p) {\n      */\n     Xml withPrefixUnsafe(String prefix);\n \n+    static boolean isNamespaceDefinitionAttribute(String name) {\n+        return name.startsWith(\"xmlns\");\n+    }\n+\n+    static String getAttributeNameForPrefix(String namespacePrefix) {\n+        return namespacePrefix.isEmpty() ? \"xmlns\" : \"xmlns:\" + namespacePrefix;\n+    }\n+\n+    /**\n+     * Extract the namespace prefix from a namespace definition attribute name (xmlns* attributes).\n+     *\n+     * @param name the attribute name or null if not a namespace definition attribute\n+     * @return the namespace prefix\n+     */\n+    static @Nullable String extractPrefixFromNamespaceDefinition(String name) {\n+        if (!isNamespaceDefinitionAttribute(name)) {\n+            return null;\n+        }\n+        return \"xmlns\".equals(name) ? \"\" : extractLocalName(name);\n+    }\n+\n+    /**\n+     * Extract the namespace prefix from a tag or attribute name.\n+     *\n+     * @param name the tag or attribute name\n+     * @return the namespace prefix (empty string for the default namespace)\n+     */\n+    static String extractNamespacePrefix(String name) {\n+        int colon = name.indexOf(':');\n+        return colon == -1 ? \"\" : name.substring(0, colon);\n+    }\n+\n+    /**\n+     * Extract the local name from a tag or attribute name.\n+     *\n+     * @param name the tag or attribute name\n+     * @return the local name\n+     */\n+    static String extractLocalName(String name) {\n+        int colon = name.indexOf(':');\n+        return colon == -1 ? name : name.substring(colon + 1);\n+    }\n+\n+    @Getter\n     @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n     @EqualsAndHashCode(callSuper = false, onlyExplicitlyIncluded = true)\n     @RequiredArgsConstructor\n     class Document implements Xml, SourceFile {\n-        @Getter\n         @With\n         @EqualsAndHashCode.Include\n         UUID id;\n \n-        @Getter\n         @With\n         Path sourcePath;\n \n-        @Getter\n         @With\n         String prefixUnsafe;\n \n@@ -102,26 +142,21 @@ public String getPrefix() {\n             return prefixUnsafe;\n         }\n \n-        @Getter\n         @With\n         Markers markers;\n \n-        @Getter\n         @Nullable // for backwards compatibility\n         @With(AccessLevel.PRIVATE)\n         String charsetName;\n \n         @With\n-        @Getter\n         boolean charsetBomMarked;\n \n         @With\n-        @Getter\n         @Nullable\n         Checksum checksum;\n \n         @With\n-        @Getter\n         @Nullable\n         FileAttributes fileAttributes;\n \n@@ -130,20 +165,24 @@ public Charset getCharset() {\n             return charsetName == null ? StandardCharsets.UTF_8 : Charset.forName(charsetName);\n         }\n \n+        @SuppressWarnings(\"unchecked\")\n         @Override\n-        public SourceFile withCharset(Charset charset) {\n+        public Xml.Document withCharset(Charset charset) {\n             return withCharsetName(charset.name());\n         }\n \n-        @Getter\n         @With\n         Prolog prolog;\n \n-        @Getter\n-        @With\n         Tag root;\n \n-        @Getter\n+        public Document withRoot(Tag root) {\n+            if (this.root == root) {\n+                return this;\n+            }\n+            return new Document(id, sourcePath, prefixUnsafe, markers, charsetName, charsetBomMarked, checksum, fileAttributes, prolog, root, eof);\n+        }\n+\n         String eof;\n \n         public Document withEof(String eof) {\n@@ -275,6 +314,7 @@ public <P> Xml acceptXml(XmlVisitor<P> v, P p) {\n         }\n     }\n \n+    @SuppressWarnings(\"unused\")\n     @Value\n     @EqualsAndHashCode(callSuper = false, onlyExplicitlyIncluded = true)\n     class Tag implements Xml, Content {\n@@ -285,6 +325,123 @@ class Tag implements Xml, Content {\n         @With\n         String prefixUnsafe;\n \n+        /**\n+         * The map returned by this method is a view of the Tag's attributes.\n+         * Modifying the map will NOT modify the tag's attributes.\n+         *\n+         * @return a map of namespace prefixes (without the <code>xmlns</code> prefix) to URIs for this tag.\n+         */\n+        public Map<String, String> getNamespaces() {\n+            final Map<String, String> namespaces = new LinkedHashMap<>(attributes.size());\n+            if (!attributes.isEmpty()) {\n+                for (Attribute attribute : attributes) {\n+                    if(isNamespaceDefinitionAttribute(attribute.getKeyAsString())) {\n+                        namespaces.put(\n+                                extractPrefixFromNamespaceDefinition(attribute.getKeyAsString()),\n+                                attribute.getValueAsString());\n+                    }\n+                }\n+            }\n+            return namespaces;\n+        }\n+\n+        /**\n+         * Gets a map containing all namespaces defined in the current scope, including all parent scopes.\n+         *\n+         * @param cursor     the cursor to search from\n+         * @return a map containing all namespaces defined in the current scope, including all parent scopes.\n+         */\n+        public Map<String, String> getAllNamespaces(Cursor cursor) {\n+            Map<String, String> namespaces = getNamespaces();\n+            while (cursor != null) {\n+                Xml.Tag enclosing = cursor.firstEnclosing(Xml.Tag.class);\n+                if (enclosing != null) {\n+                    for (Map.Entry<String, String> ns : enclosing.getNamespaces().entrySet()) {\n+                        if (namespaces.containsValue(ns.getKey())) {\n+                            throw new IllegalStateException(java.lang.String.format(\"Cannot have two namespaces with the same prefix (%s): '%s' and '%s'\", ns.getKey(), namespaces.get(ns.getKey()), ns.getValue()));\n+                        }\n+                        namespaces.put(ns.getKey(), ns.getValue());\n+                    }\n+                }\n+                cursor = cursor.getParent();\n+            }\n+\n+            return namespaces;\n+        }\n+\n+        public Tag withNamespaces(Map<String, String> namespaces) {\n+            Map<String, String> currentNamespaces = getNamespaces();\n+            if (currentNamespaces.equals(namespaces)) {\n+                return this;\n+            }\n+\n+            List<Xml.Attribute> attributes = this.attributes;\n+            if (attributes.isEmpty()) {\n+                for (Map.Entry<String, String> ns : namespaces.entrySet()) {\n+                    String key = getAttributeNameForPrefix(ns.getKey());\n+                    attributes = ListUtils.concat(attributes, new Xml.Attribute(\n+                            randomId(),\n+                            \"\",\n+                            Markers.EMPTY,\n+                            new Xml.Ident(\n+                                    randomId(),\n+                                    \"\",\n+                                    Markers.EMPTY,\n+                                    key\n+                            ),\n+                            \"\",\n+                            new Xml.Attribute.Value(\n+                                    randomId(),\n+                                    \"\",\n+                                    Markers.EMPTY,\n+                                    Xml.Attribute.Value.Quote.Double, ns.getValue()\n+                            )\n+                    ));\n+                }\n+            } else {\n+                Map<String, Xml.Attribute> attributeByKey = attributes.stream()\n+                        .collect(Collectors.toMap(\n+                                Attribute::getKeyAsString,\n+                                a -> a\n+                        ));\n+\n+                for (Map.Entry<String, String> ns : namespaces.entrySet()) {\n+                    String key = getAttributeNameForPrefix(ns.getKey());\n+                    if (attributeByKey.containsKey(key)) {\n+                        Xml.Attribute attribute = attributeByKey.get(key);\n+                        if (!ns.getValue().equals(attribute.getValueAsString())) {\n+                            ListUtils.map(attributes, a -> a.getKeyAsString().equals(key)\n+                                    ? attribute.withValue(new Xml.Attribute.Value(randomId(), \"\", Markers.EMPTY, Xml.Attribute.Value.Quote.Double, ns.getValue()))\n+                                    : a\n+                            );\n+                        }\n+                    } else {\n+                        attributes = ListUtils.concat(attributes, new Xml.Attribute(\n+                                randomId(),\n+                                \" \",\n+                                Markers.EMPTY,\n+                                new Xml.Ident(\n+                                        randomId(),\n+                                        \"\",\n+                                        Markers.EMPTY,\n+                                        key\n+                                ),\n+                                \"\",\n+                                new Xml.Attribute.Value(\n+                                        randomId(),\n+                                        \"\",\n+                                        Markers.EMPTY,\n+                                        Xml.Attribute.Value.Quote.Double, ns.getValue()\n+                                )\n+                        ));\n+                    }\n+                }\n+            }\n+\n+            return new Tag(id, prefixUnsafe, markers, name, attributes, content, closing,\n+                    beforeTagDelimiterPrefix);\n+        }\n+\n         @Override\n         public Tag withPrefix(String prefix) {\n             return WithPrefix.onlyIfNotEqual(this, prefix);\n@@ -461,6 +618,29 @@ public Tag withContent(@Nullable List<? extends Content> content) {\n         @With\n         String beforeTagDelimiterPrefix;\n \n+        /**\n+         * @return The local name for this tag, without any namespace prefix.\n+         */\n+        public String getLocalName() {\n+            return extractLocalName(name);\n+        }\n+\n+        /**\n+         * @return The namespace prefix for this tag, if any.\n+         */\n+        public Optional<String> getNamespacePrefix() {\n+            String extractedNamespacePrefix = extractNamespacePrefix(name);\n+            return Optional.ofNullable(StringUtils.isNotEmpty(extractedNamespacePrefix) ? extractedNamespacePrefix : null);\n+        }\n+\n+        /**\n+         * @return The namespace URI for this tag, if any.\n+         */\n+        public Optional<String> getNamespaceUri(Cursor cursor) {\n+            Optional<String> maybeNamespacePrefix = getNamespacePrefix();\n+            return maybeNamespacePrefix.flatMap(s -> Optional.ofNullable(getAllNamespaces(cursor).get(s)));\n+        }\n+\n         @Override\n         public <P> Xml acceptXml(XmlVisitor<P> v, P p) {\n             return v.visitTag(this, p);\n",
    "test_patch": "diff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/ChangeNamespaceValueTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/ChangeNamespaceValueTest.java\nindex fc668a0fb8a..38d6e10dfd4 100644\n--- a/rewrite-xml/src/test/java/org/openrewrite/xml/ChangeNamespaceValueTest.java\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/ChangeNamespaceValueTest.java\n@@ -27,7 +27,7 @@ class ChangeNamespaceValueTest implements RewriteTest {\n     @Test\n     void replaceVersion24Test() {\n         rewriteRun(\n-          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", null, \"http://java.sun.com/xml/ns/j2ee\", \"2.4\", false))\n+          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", null, \"http://java.sun.com/xml/ns/j2ee\", \"2.4\", false, null, null))\n             .expectedCyclesThatMakeChanges(2),\n           xml(\n             \"\"\"\n@@ -53,7 +53,7 @@ void replaceVersion24Test() {\n     @Test\n     void replaceVersion25Test() {\n         rewriteRun(\n-          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", null, \"http://java.sun.com/xml/ns/java\", \"2.5,3.0\", false))\n+          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", null, \"http://java.sun.com/xml/ns/java\", \"2.5,3.0\", false, null, null))\n             .expectedCyclesThatMakeChanges(2),\n           xml(\n             \"\"\"\n@@ -79,7 +79,7 @@ void replaceVersion25Test() {\n     @Test\n     void replaceVersion30Test() {\n         rewriteRun(\n-          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", null, \"http://java.sun.com/xml/ns/java\", \"2.5,3.0\", false))\n+          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", null, \"http://java.sun.com/xml/ns/java\", \"2.5,3.0\", false, null, null))\n             .expectedCyclesThatMakeChanges(2),\n           xml(\n             \"\"\"\n@@ -105,7 +105,7 @@ void replaceVersion30Test() {\n     @Test\n     void replaceVersion31Test() {\n         rewriteRun(\n-          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", null, \"http://xmlns.jcp.org/xml/ns/javaee\", \"3.1+\", false))\n+          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", null, \"http://xmlns.jcp.org/xml/ns/javaee\", \"3.1+\", false, null, null))\n             .expectedCyclesThatMakeChanges(2),\n           xml(\n             \"\"\"\n@@ -131,7 +131,7 @@ void replaceVersion31Test() {\n     @Test\n     void replaceVersion32Test() {\n         rewriteRun(\n-          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", null, \"http://xmlns.jcp.org/xml/ns/javaee\", \"3.1+\", false))\n+          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", null, \"http://xmlns.jcp.org/xml/ns/javaee\", \"3.1+\", false, null, null))\n             .expectedCyclesThatMakeChanges(2),\n           xml(\n             \"\"\"\n@@ -157,7 +157,7 @@ void replaceVersion32Test() {\n     @Test\n     void invalidVersionTest() {\n         rewriteRun(\n-          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", null, \"http://java.sun.com/xml/ns/j2ee\", \"2.5\", false)),\n+          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", null, \"http://java.sun.com/xml/ns/j2ee\", \"2.5\", false, null, null)),\n           xml(\n             \"\"\"\n               <web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" version=\"2.4\"\n@@ -174,7 +174,7 @@ void invalidVersionTest() {\n     @Test\n     void namespaceWithPrefixMatched() {\n         rewriteRun(\n-          spec -> spec.recipe(new ChangeNamespaceValue(null, \"http://old.namespace\", \"https://new.namespace\", null, true)),\n+          spec -> spec.recipe(new ChangeNamespaceValue(null, \"http://old.namespace\", \"https://new.namespace\", null, true, null, null)),\n           xml(\n             \"\"\"\n               <ns0:parent\n@@ -197,7 +197,7 @@ void namespaceWithPrefixMatched() {\n     @Test\n     void namespaceWithoutPrefixMatched() {\n         rewriteRun(\n-          spec -> spec.recipe(new ChangeNamespaceValue(null, \"http://old.namespace\", \"https://new.namespace\", null, true)),\n+          spec -> spec.recipe(new ChangeNamespaceValue(null, \"http://old.namespace\", \"https://new.namespace\", null, true, null, null)),\n           xml(\n             \"\"\"\n               <parent\n@@ -220,7 +220,7 @@ void namespaceWithoutPrefixMatched() {\n     @Test\n     void namespaceNotMatched() {\n         rewriteRun(\n-          spec -> spec.recipe(new ChangeNamespaceValue(null, \"http://non.existant.namespace\", \"https://new.namespace\", null, true)),\n+          spec -> spec.recipe(new ChangeNamespaceValue(null, \"http://non.existant.namespace\", \"https://new.namespace\", null, true, null, null)),\n           xml(\n             \"\"\"\n               <ns0:parent\n@@ -232,4 +232,50 @@ void namespaceNotMatched() {\n           )\n         );\n     }\n+\n+    @Test\n+    void replaceNamespaceUriAndSchemaLocation() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", \"http://java.sun.com/xml/ns/j2ee\", \"http://java.sun.com/xml/ns/javaee\", \"2.4\", true, \"2.5\", \"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\")),\n+          xml(\n+            \"\"\"\n+              <web-app xmlns=\"http://java.sun.com/xml/ns/j2ee\" version=\"2.4\"\n+                  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+                  xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"\n+                  id=\"WebApp_ID\">\n+                  <display-name>testWebDDNamespace</display-name>\n+              </web-app>\n+              \"\"\",\n+            \"\"\"\n+              <web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" version=\"2.5\"\n+                  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+                  xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n+                  id=\"WebApp_ID\">\n+                  <display-name>testWebDDNamespace</display-name>\n+              </web-app>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void replaceNamespaceUriAndAddMissingSchemaLocation() {\n+        rewriteRun(\n+          spec -> spec.recipe(new ChangeNamespaceValue(\"web-app\", \"http://java.sun.com/xml/ns/j2ee\", \"http://java.sun.com/xml/ns/javaee\", \"2.4\", true, \"2.5\", \"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\")),\n+          xml(\n+            \"\"\"\n+              <web-app xmlns=\"http://java.sun.com/xml/ns/j2ee\" version=\"2.4\"\n+                  id=\"WebApp_ID\">\n+                  <display-name>testWebDDNamespace</display-name>\n+              </web-app>\n+              \"\"\",\n+            \"\"\"\n+              <web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" version=\"2.5\"\n+                  id=\"WebApp_ID\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n+                  <display-name>testWebDDNamespace</display-name>\n+              </web-app>\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n\ndiff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/CreateXmlFileTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/CreateXmlFileTest.java\nindex 843b3a66b6f..02e216acd83 100644\n--- a/rewrite-xml/src/test/java/org/openrewrite/xml/CreateXmlFileTest.java\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/CreateXmlFileTest.java\n@@ -15,6 +15,7 @@\n  */\n package org.openrewrite.xml;\n \n+import org.intellij.lang.annotations.Language;\n import org.junit.jupiter.api.Test;\n import org.openrewrite.DocumentExample;\n import org.openrewrite.test.RewriteTest;\n@@ -26,6 +27,7 @@ class CreateXmlFileTest implements RewriteTest {\n     @DocumentExample\n     @Test\n     void hasCreatedFile() {\n+        @Language(\"xml\")\n         String fileContents = \"\"\"\n           <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n           <library>\n\ndiff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\nindex 0836406afad..1fefbf336ae 100755\n--- a/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/XPathMatcherTest.java\n@@ -159,20 +159,44 @@ void matchPom() {\n           pomXml2)).isTrue();\n     }\n \n+    private final SourceFile attributeXml = new XmlParser().parse(\n+      \"\"\"\n+        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <root>\n+          <element1 foo=\"bar\"><foo>baz</foo></element1>\n+        </root>\n+        \"\"\"\n+    ).toList().get(0);\n+\n     @Test\n     void attributePredicate() {\n-        SourceFile xml = new XmlParser().parse(\n-          \"\"\"\n-            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-            <root>\n-              <element1 foo=\"bar\"><foo>baz</foo></element1>\n-            </root>\n-            \"\"\"\n-        ).toList().get(0);\n-        assertThat(match(\"/root/element1[@foo='bar']\", xml)).isTrue();\n-        assertThat(match(\"/root/element1[@foo='baz']\", xml)).isFalse();\n-        assertThat(match(\"/root/element1[foo='bar']\", xml)).isFalse();\n-        assertThat(match(\"/root/element1[foo='baz']\", xml)).isTrue();\n+        assertThat(match(\"/root/element1[@foo='bar']\", attributeXml)).isTrue();\n+        assertThat(match(\"/root/element1[@foo='baz']\", attributeXml)).isFalse();\n+        assertThat(match(\"/root/element1[foo='bar']\", attributeXml)).isFalse();\n+        assertThat(match(\"/root/element1[foo='baz']\", attributeXml)).isTrue();\n+    }\n+\n+    @Test\n+    void wildcards() {\n+        // condition with wildcard attribute\n+        assertThat(match(\"/root/element1[@*='bar']\", attributeXml)).isTrue();\n+        assertThat(match(\"/root/element1[@*='baz']\", attributeXml)).isFalse();\n+\n+        // condition with wildcard element\n+        assertThat(match(\"/root/element1[*='bar']\", attributeXml)).isFalse();\n+        assertThat(match(\"/root/element1[*='baz']\", attributeXml)).isTrue();\n+\n+        // absolute xpath with wildcard element\n+        assertThat(match(\"/root/*[@foo='bar']\", attributeXml)).isTrue();\n+        assertThat(match(\"/root/*[@*='bar']\", attributeXml)).isTrue();\n+        assertThat(match(\"/root/*[@foo='baz']\", attributeXml)).isFalse();\n+        assertThat(match(\"/root/*[@*='baz']\", attributeXml)).isFalse();\n+\n+        // relative xpath with wildcard element\n+        assertThat(match(\"//*[@foo='bar']\", attributeXml)).isTrue();\n+        assertThat(match(\"//*[@foo='baz']\", attributeXml)).isFalse();\n+//        assertThat(match(\"//*[foo='bar']\", attributeXml)).isFalse(); // TODO: fix relative xpath with condition\n+        assertThat(match(\"//*[foo='baz']\", attributeXml)).isTrue();\n     }\n \n     @Test\n@@ -188,6 +212,8 @@ void relativePathsWithConditions() {\n             </root>\n             \"\"\"\n         ).toList().get(0);\n+//        assertThat(match(\"//element1[foo='bar']\", xml)).isFalse(); // TODO: fix - was already failing before * changes\n+        assertThat(match(\"//element1[foo='baz']\", xml)).isTrue();\n         assertThat(match(\"//element1[@foo='bar']\", xml)).isTrue();\n         assertThat(match(\"//element1[foo='baz']/test\", xml)).isTrue();\n         assertThat(match(\"//element1[foo='baz']/baz\", xml)).isFalse();\n@@ -204,7 +230,7 @@ void matchFunctions() {\n \n         // Namespace functions\n         assertThat(match(\"/*[local-name()='element1']\", namespacedXml)).isFalse();\n-        assertThat(match(\"//*[local-name()='element1']\", namespacedXml)).isFalse();\n+        assertThat(match(\"//*[local-name()='element1']\", namespacedXml)).isTrue();\n         assertThat(match(\"/root/*[local-name()='element1']\", namespacedXml)).isTrue();\n         assertThat(match(\"/root/*[namespace-uri()='http://www.example.com/namespace2']\", namespacedXml)).isTrue();\n         assertThat(match(\"/*[namespace-uri()='http://www.example.com/namespace2']\", namespacedXml)).isFalse();\n@@ -223,6 +249,22 @@ void matchFunctions() {\n         assertThat(match(\"count(/root/*)\", namespacedXml)).isTrue();\n     }\n \n+    @Test\n+    void testMatchLocalName() {\n+        assertThat(match(\"/*[local-name()='root']\", namespacedXml)).isTrue();\n+        assertThat(match(\"/*[local-name()='element1']\", namespacedXml)).isFalse();\n+        assertThat(match(\"/*[local-name()='element2']\", namespacedXml)).isFalse();\n+        assertThat(match(\"//*[local-name()='element1']\", namespacedXml)).isTrue();\n+        assertThat(match(\"//*[local-name()='element2']\", namespacedXml)).isTrue();\n+        assertThat(match(\"//*[local-name()='dne']\", namespacedXml)).isFalse();\n+\n+        assertThat(match(\"/root[local-name()='root']\", namespacedXml)).isTrue();\n+        assertThat(match(\"//element1[local-name()='element1']\", namespacedXml)).isTrue();\n+        assertThat(match(\"//element2[local-name()='element2']\", namespacedXml)).isFalse();\n+        assertThat(match(\"//ns2:element2[local-name()='element2']\", namespacedXml)).isTrue();\n+        assertThat(match(\"//dne[local-name()='dne']\", namespacedXml)).isFalse();\n+    }\n+\n     private boolean match(String xpath, SourceFile x) {\n         XPathMatcher matcher = new XPathMatcher(xpath);\n         return !TreeVisitor.collect(new XmlVisitor<>() {\n\ndiff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/internal/XmlTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/internal/XmlTest.java\nnew file mode 100644\nindex 00000000000..d029151e856\n--- /dev/null\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/internal/XmlTest.java\n@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2024 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.xml.internal;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.xml.tree.Xml;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class XmlTest {\n+\n+    @Test\n+    void isNamespaceDefinitionAttributeTests() {\n+        assertThat(Xml.isNamespaceDefinitionAttribute(\"xmlns:test\")).isTrue();\n+        assertThat(Xml.isNamespaceDefinitionAttribute(\"test\")).isFalse();\n+    }\n+\n+    @Test\n+    void getAttributeNameForPrefix() {\n+        assertThat(Xml.getAttributeNameForPrefix(\"test\")).isEqualTo(\"xmlns:test\");\n+        assertThat(Xml.getAttributeNameForPrefix(\"\")).isEqualTo(\"xmlns\");\n+    }\n+\n+    @Test\n+    void extractNamespacePrefix() {\n+        assertEquals(\"test\", Xml.extractNamespacePrefix(\"test:tag\"));\n+        assertEquals(\"\", Xml.extractNamespacePrefix(\"tag\"));\n+    }\n+\n+    @Test\n+    void extractLocalName() {\n+        assertEquals(\"tag\", Xml.extractLocalName(\"test:tag\"));\n+        assertEquals(\"tag\", Xml.extractLocalName(\"tag\"));\n+    }\n+\n+    @Test\n+    void extractPrefixFromNamespaceDefinition() {\n+        assertEquals(\"test\", Xml.extractPrefixFromNamespaceDefinition(\"xmlns:test\"));\n+        assertEquals(\"\", Xml.extractPrefixFromNamespaceDefinition(\"xmlns\"));\n+        assertThat(Xml.extractPrefixFromNamespaceDefinition(\"test\")).isEqualTo(null);\n+        assertThat(Xml.extractPrefixFromNamespaceDefinition(\"a:test\")).isEqualTo(null);\n+    }\n+}\n\ndiff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/search/FindNamespacePrefixTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/search/FindNamespacePrefixTest.java\nnew file mode 100644\nindex 00000000000..2e76cdb0c49\n--- /dev/null\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/search/FindNamespacePrefixTest.java\n@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.xml.search;\n+\n+import org.intellij.lang.annotations.Language;\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.DocumentExample;\n+import org.openrewrite.test.RewriteTest;\n+import org.openrewrite.xml.tree.Xml;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openrewrite.xml.Assertions.xml;\n+\n+class FindNamespacePrefixTest implements RewriteTest {\n+\n+    @DocumentExample\n+    @Test\n+    void rootElement() {\n+        rewriteRun(\n+          spec -> spec.recipe(new FindNamespacePrefix(\"xsi\", null)),\n+          xml(\n+            source,\n+            \"\"\"\n+              <!--~~>--><beans xmlns=\"http://www.springframework.org/schema/beans\"\n+                  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+                  xsi:schemaLocation=\"\n+                      http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\n+                      http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n+\n+                  <jaxws:client name=\"{http://cxf.apache.org/hello_world_soap_http}SoapPort\" createdFromAPI=\"true\" xmlns:jaxws=\"http://cxf.apache.org/jaxws\">\n+                      <jaxws:conduitSelector>\n+                          <bean class=\"org.apache.cxf.endpoint.DeferredConduitSelector\"/>\n+                      </jaxws:conduitSelector>\n+                  </jaxws:client>\n+              </beans>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void nestedElement() {\n+        rewriteRun(\n+          spec -> spec.recipe(new FindNamespacePrefix(\"jaxws\", null)),\n+          xml(\n+            source,\n+            \"\"\"\n+              <beans xmlns=\"http://www.springframework.org/schema/beans\"\n+                  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+                  xsi:schemaLocation=\"\n+                      http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\n+                      http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n+\n+                  <!--~~>--><jaxws:client name=\"{http://cxf.apache.org/hello_world_soap_http}SoapPort\" createdFromAPI=\"true\" xmlns:jaxws=\"http://cxf.apache.org/jaxws\">\n+                      <jaxws:conduitSelector>\n+                          <bean class=\"org.apache.cxf.endpoint.DeferredConduitSelector\"/>\n+                      </jaxws:conduitSelector>\n+                  </jaxws:client>\n+              </beans>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void noMatchOnNamespacePrefix() {\n+        rewriteRun(\n+          spec -> spec.recipe(new FindNamespacePrefix(\"foo\", null)),\n+          xml(source)\n+        );\n+    }\n+\n+    @Test\n+    void noMatchOnXPath() {\n+        rewriteRun(\n+          spec -> spec.recipe(new FindNamespacePrefix(\"xsi\", \"/jaxws:client\")),\n+          xml(source)\n+        );\n+    }\n+\n+    @Test\n+    void staticFind() {\n+        rewriteRun(\n+          xml(\n+            source,\n+            spec -> spec.beforeRecipe(xml -> assertThat(FindNamespacePrefix.find(xml, \"xsi\", null))\n+              .isNotEmpty()\n+              .hasSize(1)\n+              .hasOnlyElementsOfType(Xml.Tag.class)\n+            )\n+          )\n+        );\n+    }\n+\n+    @Language(\"xml\")\n+    private final String source = \"\"\"\n+      <beans xmlns=\"http://www.springframework.org/schema/beans\"\n+          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+          xsi:schemaLocation=\"\n+              http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\n+              http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n+\n+          <jaxws:client name=\"{http://cxf.apache.org/hello_world_soap_http}SoapPort\" createdFromAPI=\"true\" xmlns:jaxws=\"http://cxf.apache.org/jaxws\">\n+              <jaxws:conduitSelector>\n+                  <bean class=\"org.apache.cxf.endpoint.DeferredConduitSelector\"/>\n+              </jaxws:conduitSelector>\n+          </jaxws:client>\n+      </beans>\n+      \"\"\";\n+}\n\ndiff --git a/rewrite-xml/src/test/java/org/openrewrite/xml/search/HasNamespaceUriTest.java b/rewrite-xml/src/test/java/org/openrewrite/xml/search/HasNamespaceUriTest.java\nnew file mode 100644\nindex 00000000000..fe788ae0465\n--- /dev/null\n+++ b/rewrite-xml/src/test/java/org/openrewrite/xml/search/HasNamespaceUriTest.java\n@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.xml.search;\n+\n+import org.intellij.lang.annotations.Language;\n+import org.junit.jupiter.api.Test;\n+import org.openrewrite.DocumentExample;\n+import org.openrewrite.test.RewriteTest;\n+import org.openrewrite.xml.tree.Xml;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openrewrite.xml.Assertions.xml;\n+\n+class HasNamespaceUriTest implements RewriteTest {\n+\n+    @DocumentExample\n+    @Test\n+    void rootElement() {\n+        rewriteRun(\n+          spec -> spec.recipe(new HasNamespaceUri(\"http://www.w3.org/2001/XMLSchema-instance\", null)),\n+          xml(\n+            source,\n+            \"\"\"\n+              <!--~~>--><beans xmlns=\"http://www.springframework.org/schema/beans\"\n+                  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+                  xsi:schemaLocation=\"\n+                      http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\n+                      http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n+\n+                  <jaxws:client name=\"{http://cxf.apache.org/hello_world_soap_http}SoapPort\" createdFromAPI=\"true\" xmlns:jaxws=\"http://cxf.apache.org/jaxws\">\n+                      <jaxws:conduitSelector>\n+                          <bean class=\"org.apache.cxf.endpoint.DeferredConduitSelector\"/>\n+                      </jaxws:conduitSelector>\n+                  </jaxws:client>\n+              </beans>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void nestedElement() {\n+        rewriteRun(\n+          spec -> spec.recipe(new HasNamespaceUri(\"http://cxf.apache.org/jaxws\", null)),\n+          xml(\n+            source,\n+            \"\"\"\n+              <beans xmlns=\"http://www.springframework.org/schema/beans\"\n+                  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+                  xsi:schemaLocation=\"\n+                      http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\n+                      http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n+\n+                  <!--~~>--><jaxws:client name=\"{http://cxf.apache.org/hello_world_soap_http}SoapPort\" createdFromAPI=\"true\" xmlns:jaxws=\"http://cxf.apache.org/jaxws\">\n+                      <jaxws:conduitSelector>\n+                          <bean class=\"org.apache.cxf.endpoint.DeferredConduitSelector\"/>\n+                      </jaxws:conduitSelector>\n+                  </jaxws:client>\n+              </beans>\n+              \"\"\"\n+          )\n+        );\n+    }\n+\n+    @Test\n+    void noMatchOnNamespaceUri() {\n+        rewriteRun(\n+          spec -> spec.recipe(new HasNamespaceUri(\"foo\", null)),\n+          xml(source)\n+        );\n+    }\n+\n+    @Test\n+    void noMatchOnXPath() {\n+        rewriteRun(\n+          spec -> spec.recipe(new HasNamespaceUri(\"xsi\", \"/jaxws:client\")),\n+          xml(source)\n+        );\n+    }\n+\n+    @Test\n+    void staticFind() {\n+        rewriteRun(\n+          xml(\n+            source,\n+            spec -> spec.beforeRecipe(xml -> assertThat(HasNamespaceUri.find(xml, \"http://www.w3.org/2001/XMLSchema-instance\", null))\n+              .isNotEmpty()\n+              .hasSize(1)\n+              .hasOnlyElementsOfType(Xml.Tag.class)\n+            )\n+          )\n+        );\n+    }\n+\n+    @Language(\"xml\")\n+    private final String source = \"\"\"\n+      <beans xmlns=\"http://www.springframework.org/schema/beans\"\n+          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+          xsi:schemaLocation=\"\n+              http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\n+              http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n+\n+          <jaxws:client name=\"{http://cxf.apache.org/hello_world_soap_http}SoapPort\" createdFromAPI=\"true\" xmlns:jaxws=\"http://cxf.apache.org/jaxws\">\n+              <jaxws:conduitSelector>\n+                  <bean class=\"org.apache.cxf.endpoint.DeferredConduitSelector\"/>\n+              </jaxws:conduitSelector>\n+          </jaxws:client>\n+      </beans>\n+      \"\"\";\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-3914",
    "pr_id": 3914,
    "issue_id": 3909,
    "repo": "openrewrite/rewrite",
    "problem_statement": "RemoveUnusedImports remove used import\n## What version of OpenRewrite are you using?\r\nI am using\r\n\r\n- OpenRewrite v8.13.2\r\n\r\n## What is the smallest, simplest way to reproduce the problem?\r\nThe problem appear since `8.12.0` version.\r\nUnit test to reproduce the bug:\r\n```java\r\nimport org.junit.jupiter.api.Test;\r\nimport org.openrewrite.java.RemoveUnusedImports;\r\nimport org.openrewrite.test.RecipeSpec;\r\nimport org.openrewrite.test.RewriteTest;\r\n\r\nimport static org.openrewrite.java.Assertions.java;\r\nclass RemoveUnusedImportsTest implements RewriteTest {\r\n\r\n    @Override\r\n    public void defaults(RecipeSpec spec) {\r\n        spec.recipe(new RemoveUnusedImports());\r\n    }\r\n\r\n    @Test\r\n    void bug() {\r\n        // language=java\r\n        rewriteRun(\r\n            java(\r\n                \"\"\"\r\n                  import javax.xml.datatype.XMLGregorianCalendar;\r\n                  import java.time.LocalDateTime;\r\n                  class LocalDateTimeUtil {\r\n                    public LocalDateTime toLocalDateTime(XMLGregorianCalendar cal) {\r\n                        if (cal == null) {\r\n                            return null;\r\n                        }\r\n                        return cal.toGregorianCalendar().toZonedDateTime().toLocalDateTime();\r\n                    }\r\n                  }\r\n                  \"\"\"\r\n            )\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n## What did you expect to see?\r\nNo error\r\n\r\n## What did you see instead?\r\n```\r\n[ERROR] Failures: \r\n[ERROR]   RemoveUnusedImportsTest.bug:20 [The recipe must not make changes to \"LocalDateTimeUtil.java\"] \r\nexpected: \"import javax.xml.datatype.XMLGregorianCalendar;\r\nimport java.time.LocalDateTime;\r\nclass LocalDateTimeUtil {\r\n  public LocalDateTime toLocalDateTime(XMLGregorianCalendar cal) {\r\n      if (cal == null) {\r\n          return null;\r\n      }\r\n      return cal.toGregorianCalendar().toZonedDateTime().toLocalDateTime();\r\n  }\r\n}\"\r\n but was: \"import javax.xml.datatype.XMLGregorianCalendar;\r\nclass LocalDateTimeUtil {\r\n  public LocalDateTime toLocalDateTime(XMLGregorianCalendar cal) {\r\n      if (cal == null) {\r\n          return null;\r\n      }\r\n      return cal.toGregorianCalendar().toZonedDateTime().toLocalDateTime();\r\n  }\r\n}\"\r\n```",
    "issue_word_count": 197,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java",
      "rewrite-java/src/main/java/org/openrewrite/java/internal/TypesInUse.java"
    ],
    "pr_changed_test_files": [
      "rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java"
    ],
    "base_commit": "670dd5c84620852c2b90158e35a0530ea9efe38c",
    "head_commit": "5dcd6a87f06cafac709aee19fdd63ef6d062aa93",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/3914",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/3914",
    "dockerfile": "",
    "pr_merged_at": "2024-01-15T10:05:47.000Z",
    "patch": "diff --git a/rewrite-java/src/main/java/org/openrewrite/java/internal/TypesInUse.java b/rewrite-java/src/main/java/org/openrewrite/java/internal/TypesInUse.java\nindex 468851b400f..fde5207f29e 100644\n--- a/rewrite-java/src/main/java/org/openrewrite/java/internal/TypesInUse.java\n+++ b/rewrite-java/src/main/java/org/openrewrite/java/internal/TypesInUse.java\n@@ -65,8 +65,11 @@ public J.Import visitImport(J.Import _import, Integer p) {\n         @Override\n         public J.Identifier visitIdentifier(J.Identifier identifier, Integer p) {\n             Object parent = Objects.requireNonNull(getCursor().getParent()).getValue();\n-            if (parent instanceof J.ClassDeclaration || parent instanceof J.MethodDeclaration) {\n-                // skip type of class and method declaration name\n+            if (parent instanceof J.ClassDeclaration) {\n+                // skip type of class\n+                return identifier;\n+            } else if (parent instanceof J.MethodDeclaration && ((J.MethodDeclaration) parent).getName() == identifier) {\n+                // skip method name\n                 return identifier;\n             }\n             return super.visitIdentifier(identifier, p);\n",
    "test_patch": "diff --git a/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java b/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java\nindex 45595b3883c..516a30be96d 100755\n--- a/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java\n+++ b/rewrite-java-test/src/test/java/org/openrewrite/java/RemoveUnusedImportsTest.java\n@@ -1745,4 +1745,26 @@ void f(Record r) {\n             }\n             \"\"\"));\n     }\n+\n+    @Test\n+    @Issue(\"https://github.com/openrewrite/rewrite/issues/3909\")\n+    void importUsedOnlyInReturnType() {\n+        // language=java\n+        rewriteRun(\n+          java(\n+            \"\"\"\n+              import javax.xml.datatype.XMLGregorianCalendar;\n+              import java.time.LocalDateTime;\n+              class LocalDateTimeUtil {\n+                public LocalDateTime toLocalDateTime(XMLGregorianCalendar cal) {\n+                    if (cal == null) {\n+                        return null;\n+                    }\n+                    return cal.toGregorianCalendar().toZonedDateTime().toLocalDateTime();\n+                }\n+              }\n+              \"\"\"\n+          )\n+        );\n+    }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "openrewrite__rewrite-3906",
    "pr_id": 3906,
    "issue_id": 3333,
    "repo": "openrewrite/rewrite",
    "problem_statement": "NameCaseConvention.LOWER_CAMEL should handle mixed case more properly\nActual:\r\n\r\n```diff\r\n-      PdfDocumentViewModel PDFviewModel = new PdfDocumentViewModel(mockPDF);\r\n+      PdfDocumentViewModel pDFviewModel = new PdfDocumentViewModel(mockPDF);\r\n```\r\n\r\nExpected\r\n\r\n```diff\r\n-      PdfDocumentViewModel PDFviewModel = new PdfDocumentViewModel(mockPDF);\r\n+      PdfDocumentViewModel pdfViewModel = new PdfDocumentViewModel(mockPdf);\r\n```\r\n\r\n**Update** `mockPdf` instead of `mockPDF`.\r\n\r\n(This was originally reported at https://github.com/openrewrite/rewrite-static-analysis/issues/12#issuecomment-1588208014)",
    "issue_word_count": 53,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "rewrite-core/src/main/java/org/openrewrite/internal/NameCaseConvention.java",
      "rewrite-core/src/test/java/org/openrewrite/internal/NameCaseConventionTest.java"
    ],
    "pr_changed_test_files": [
      "rewrite-core/src/test/java/org/openrewrite/internal/NameCaseConventionTest.java"
    ],
    "base_commit": "3aaf8311d0a5ee256f246123933baf2b132c7869",
    "head_commit": "640eace767aff67f0e7331092025071fab4a1d61",
    "repo_url": "https://github.com/openrewrite/rewrite/pull/3906",
    "swe_url": "https://swe-bench-plus.turing.com/repos/openrewrite__rewrite/3906",
    "dockerfile": "",
    "pr_merged_at": "2024-01-13T01:11:52.000Z",
    "patch": "diff --git a/rewrite-core/src/main/java/org/openrewrite/internal/NameCaseConvention.java b/rewrite-core/src/main/java/org/openrewrite/internal/NameCaseConvention.java\nindex 00d318e96d3..703e7509f54 100755\n--- a/rewrite-core/src/main/java/org/openrewrite/internal/NameCaseConvention.java\n+++ b/rewrite-core/src/main/java/org/openrewrite/internal/NameCaseConvention.java\n@@ -56,6 +56,7 @@ public enum NameCaseConvention {\n     UPPER_UNDERSCORE;\n \n     private static final Pattern CAMEL_CASE_SPLIT = Pattern.compile(\"[\\\\s_-]\");\n+    private static final int uppercaseAbbreviationMinLength = 3;\n \n     /**\n      * Formats the input to the style of this {@link NameCaseConvention}.\n@@ -149,18 +150,32 @@ private static String lowerUnderscore(String str) {\n     private static String toCamelCase(String str, boolean lowerCaseFirstLetter) {\n         boolean allUpperCase = true;\n         final int strLength = str.length();\n-        for (int i = 0; i < strLength; i++) {\n+\n+        boolean uppercaseAbbreviationIncluded = false;\n+        int uppercaseAbbreviationEndIndex = -1;\n+        int i = 0;\n+        while (i < strLength) {\n             final char c = str.charAt(i);\n             if (Character.isLowerCase(c)) {\n                 allUpperCase = false;\n                 break;\n             }\n+            i++;\n+        }\n+        if (i > uppercaseAbbreviationMinLength) {\n+            uppercaseAbbreviationIncluded = true;\n+            uppercaseAbbreviationEndIndex = i - 1;\n         }\n+\n+        StringBuilder sb = new StringBuilder(strLength);\n         if (allUpperCase) {\n             str = str.toLowerCase();\n+        } else if (uppercaseAbbreviationIncluded) {\n+            final String uppercaseAbbreviation = str.substring(0, uppercaseAbbreviationEndIndex);\n+            sb.append(StringUtils.capitalize(uppercaseAbbreviation.toLowerCase()));\n+            str = str.substring(uppercaseAbbreviationEndIndex);\n         }\n \n-        StringBuilder sb = new StringBuilder(strLength);\n         for (String s : CAMEL_CASE_SPLIT.split(str)) {\n             String capitalize = StringUtils.capitalize(s);\n             sb.append(capitalize);\n",
    "test_patch": "diff --git a/rewrite-core/src/test/java/org/openrewrite/internal/NameCaseConventionTest.java b/rewrite-core/src/test/java/org/openrewrite/internal/NameCaseConventionTest.java\nindex a45232c5ee4..b6b85ddb720 100644\n--- a/rewrite-core/src/test/java/org/openrewrite/internal/NameCaseConventionTest.java\n+++ b/rewrite-core/src/test/java/org/openrewrite/internal/NameCaseConventionTest.java\n@@ -81,6 +81,8 @@ void lowerUnderscore(String input, String expected) {\n       \"foo bar:fooBar\",\n       \" foo  bar :fooBar\",\n       \"FOO_BAR:fooBar\",\n+      \"XMLParser:xmlParser\",\n+      \"PDFViewModel:pdfViewModel\",\n     }, delimiter = ':')\n     void lowerCamel(String input, String expected) {\n         assertThat(NameCaseConvention.LOWER_CAMEL.format(input)).isEqualTo(expected);\n@@ -95,6 +97,8 @@ void lowerCamel(String input, String expected) {\n       \"foo-bar:FooBar\",\n       \"foo bar:FooBar\",\n       \" foo  bar :FooBar\",\n+      \"XMLParser:XmlParser\",\n+      \"PDFViewModel:PdfViewModel\",\n     }, delimiter = ':')\n     void upperCamel(String input, String expected) {\n         assertThat(NameCaseConvention.UPPER_CAMEL.format(input)).isEqualTo(expected);\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  }
]