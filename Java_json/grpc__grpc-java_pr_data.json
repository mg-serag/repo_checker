[
  {
    "instance_id": "grpc__grpc-java-12126",
    "pr_id": 12126,
    "issue_id": 11937,
    "repo": "grpc/grpc-java",
    "problem_statement": "blocking v2 client stub inconsistent about StatusRuntimeException verus StatusException\n`io.grpc.stub.BlockingClientCall` uses the checked `StatusException`, so server-streaming and client-streaming v2 blocking RPCs have to deal with `StatusException`. However, the unary blocking v2 RPCs stubs have the implementation and thus behavior as v1; namely, all status exceptions are `StatusRuntimeException`. Should this be made consistent?",
    "issue_word_count": 57,
    "test_files_count": 31,
    "non_test_files_count": 9,
    "pr_changed_files": [
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/TestServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/TestServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java",
      "benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/BenchmarkServiceGrpc.java",
      "benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/ReportQpsScenarioServiceGrpc.java",
      "benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/WorkerServiceGrpc.java",
      "compiler/src/java_plugin/cpp/java_generator.cpp",
      "compiler/src/test/golden/TestDeprecatedService.java.txt",
      "compiler/src/test/golden/TestService.java.txt",
      "compiler/src/testLite/golden/TestDeprecatedService.java.txt",
      "compiler/src/testLite/golden/TestService.java.txt",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/TestServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java",
      "istio-interop-testing/src/generated/main/grpc/io/istio/test/EchoTestServiceGrpc.java",
      "rls/src/generated/main/grpc/io/grpc/lookup/v1/RouteLookupServiceGrpc.java",
      "services/src/generated/main/grpc/io/grpc/channelz/v1/ChannelzGrpc.java",
      "services/src/generated/main/grpc/io/grpc/health/v1/HealthGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherDynamicServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherReflectableServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/DynamicServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/ReflectableServiceGrpc.java",
      "stub/src/main/java/io/grpc/stub/ClientCalls.java",
      "testing-proto/src/generated/main/grpc/io/grpc/testing/protobuf/SimpleServiceGrpc.java",
      "xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/status/v3/ClientStatusDiscoveryServiceGrpc.java"
    ],
    "pr_changed_test_files": [
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/TestServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/TestServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java",
      "compiler/src/test/golden/TestDeprecatedService.java.txt",
      "compiler/src/test/golden/TestService.java.txt",
      "compiler/src/testLite/golden/TestDeprecatedService.java.txt",
      "compiler/src/testLite/golden/TestService.java.txt",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/TestServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java",
      "istio-interop-testing/src/generated/main/grpc/io/istio/test/EchoTestServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherDynamicServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherReflectableServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/DynamicServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/ReflectableServiceGrpc.java",
      "testing-proto/src/generated/main/grpc/io/grpc/testing/protobuf/SimpleServiceGrpc.java"
    ],
    "base_commit": "efe9ccc22caf88dfa1746e8edb840748e00cbaa4",
    "head_commit": "73788e2e01889e637b9ed75894a64e7ab08f2deb",
    "repo_url": "https://github.com/grpc/grpc-java/pull/12126",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/12126",
    "dockerfile": "",
    "pr_merged_at": "2025-06-10T05:01:03.000Z",
    "patch": "diff --git a/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/BenchmarkServiceGrpc.java b/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/BenchmarkServiceGrpc.java\nindex 242d4551d6e..93de8c08b2b 100644\n--- a/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/BenchmarkServiceGrpc.java\n+++ b/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/BenchmarkServiceGrpc.java\n@@ -401,8 +401,8 @@ protected BenchmarkServiceBlockingV2Stub build(\n      * The server returns the client payload as-is.\n      * </pre>\n      */\n-    public io.grpc.benchmarks.proto.Messages.SimpleResponse unaryCall(io.grpc.benchmarks.proto.Messages.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.benchmarks.proto.Messages.SimpleResponse unaryCall(io.grpc.benchmarks.proto.Messages.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnaryCallMethod(), getCallOptions(), request);\n     }\n \n\ndiff --git a/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/ReportQpsScenarioServiceGrpc.java b/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/ReportQpsScenarioServiceGrpc.java\nindex 8f466185ea0..7cdf4da6293 100644\n--- a/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/ReportQpsScenarioServiceGrpc.java\n+++ b/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/ReportQpsScenarioServiceGrpc.java\n@@ -180,8 +180,8 @@ protected ReportQpsScenarioServiceBlockingV2Stub build(\n      * Report results of a QPS test benchmark scenario.\n      * </pre>\n      */\n-    public io.grpc.benchmarks.proto.Control.Void reportScenario(io.grpc.benchmarks.proto.Control.ScenarioResult request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.benchmarks.proto.Control.Void reportScenario(io.grpc.benchmarks.proto.Control.ScenarioResult request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getReportScenarioMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/WorkerServiceGrpc.java b/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/WorkerServiceGrpc.java\nindex 11859482972..5a93c5e5ebd 100644\n--- a/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/WorkerServiceGrpc.java\n+++ b/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/WorkerServiceGrpc.java\n@@ -390,8 +390,8 @@ protected WorkerServiceBlockingV2Stub build(\n      * Just return the core count - unary call\n      * </pre>\n      */\n-    public io.grpc.benchmarks.proto.Control.CoreResponse coreCount(io.grpc.benchmarks.proto.Control.CoreRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.benchmarks.proto.Control.CoreResponse coreCount(io.grpc.benchmarks.proto.Control.CoreRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getCoreCountMethod(), getCallOptions(), request);\n     }\n \n@@ -400,8 +400,8 @@ public io.grpc.benchmarks.proto.Control.CoreResponse coreCount(io.grpc.benchmark\n      * Quit this worker\n      * </pre>\n      */\n-    public io.grpc.benchmarks.proto.Control.Void quitWorker(io.grpc.benchmarks.proto.Control.Void request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.benchmarks.proto.Control.Void quitWorker(io.grpc.benchmarks.proto.Control.Void request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getQuitWorkerMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/compiler/src/java_plugin/cpp/java_generator.cpp b/compiler/src/java_plugin/cpp/java_generator.cpp\nindex 8421a4a9207..4cee7999402 100644\n--- a/compiler/src/java_plugin/cpp/java_generator.cpp\n+++ b/compiler/src/java_plugin/cpp/java_generator.cpp\n@@ -745,9 +745,10 @@ static void PrintStub(\n               \"    $lower_method_name$($input_type$ request)\");\n        } else {\n           // Simple RPC\n+          (*vars)[\"throws_decl\"] = \" throws io.grpc.StatusException\";\n           p->Print(\n               *vars,\n-              \"$output_type$ $lower_method_name$($input_type$ request)\");\n+              \"$output_type$ $lower_method_name$($input_type$ request)$throws_decl$\");\n        }\n        break;\n       case ASYNC_CALL:\n@@ -827,7 +828,8 @@ static void PrintStub(\n                if (server_streaming) {\n                    (*vars)[\"calls_method\"] = \"io.grpc.stub.ClientCalls.blockingV2ServerStreamingCall\";\n                 } else {\n-                  (*vars)[\"calls_method\"] = \"io.grpc.stub.ClientCalls.blockingUnaryCall\";\n+                  (*vars)[\"calls_method\"] = \"io.grpc.stub.ClientCalls.blockingV2UnaryCall\";\n+                  (*vars)[\"throws_decl\"] = \" throws io.grpc.StatusException\";\n                 }\n \n             p->Print(\n\ndiff --git a/rls/src/generated/main/grpc/io/grpc/lookup/v1/RouteLookupServiceGrpc.java b/rls/src/generated/main/grpc/io/grpc/lookup/v1/RouteLookupServiceGrpc.java\nindex 558a223173c..d4fb6323e19 100644\n--- a/rls/src/generated/main/grpc/io/grpc/lookup/v1/RouteLookupServiceGrpc.java\n+++ b/rls/src/generated/main/grpc/io/grpc/lookup/v1/RouteLookupServiceGrpc.java\n@@ -180,8 +180,8 @@ protected RouteLookupServiceBlockingV2Stub build(\n      * Lookup returns a target for a single key.\n      * </pre>\n      */\n-    public io.grpc.lookup.v1.RouteLookupResponse routeLookup(io.grpc.lookup.v1.RouteLookupRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.lookup.v1.RouteLookupResponse routeLookup(io.grpc.lookup.v1.RouteLookupRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getRouteLookupMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/services/src/generated/main/grpc/io/grpc/channelz/v1/ChannelzGrpc.java b/services/src/generated/main/grpc/io/grpc/channelz/v1/ChannelzGrpc.java\nindex 7dd74034efe..e0a35703015 100644\n--- a/services/src/generated/main/grpc/io/grpc/channelz/v1/ChannelzGrpc.java\n+++ b/services/src/generated/main/grpc/io/grpc/channelz/v1/ChannelzGrpc.java\n@@ -515,8 +515,8 @@ protected ChannelzBlockingV2Stub build(\n      * created). This does not include subchannels nor non-top level channels.\n      * </pre>\n      */\n-    public io.grpc.channelz.v1.GetTopChannelsResponse getTopChannels(io.grpc.channelz.v1.GetTopChannelsRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.channelz.v1.GetTopChannelsResponse getTopChannels(io.grpc.channelz.v1.GetTopChannelsRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetTopChannelsMethod(), getCallOptions(), request);\n     }\n \n@@ -525,8 +525,8 @@ public io.grpc.channelz.v1.GetTopChannelsResponse getTopChannels(io.grpc.channel\n      * Gets all servers that exist in the process.\n      * </pre>\n      */\n-    public io.grpc.channelz.v1.GetServersResponse getServers(io.grpc.channelz.v1.GetServersRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.channelz.v1.GetServersResponse getServers(io.grpc.channelz.v1.GetServersRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetServersMethod(), getCallOptions(), request);\n     }\n \n@@ -535,8 +535,8 @@ public io.grpc.channelz.v1.GetServersResponse getServers(io.grpc.channelz.v1.Get\n      * Returns a single Server, or else a NOT_FOUND code.\n      * </pre>\n      */\n-    public io.grpc.channelz.v1.GetServerResponse getServer(io.grpc.channelz.v1.GetServerRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.channelz.v1.GetServerResponse getServer(io.grpc.channelz.v1.GetServerRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetServerMethod(), getCallOptions(), request);\n     }\n \n@@ -545,8 +545,8 @@ public io.grpc.channelz.v1.GetServerResponse getServer(io.grpc.channelz.v1.GetSe\n      * Gets all server sockets that exist in the process.\n      * </pre>\n      */\n-    public io.grpc.channelz.v1.GetServerSocketsResponse getServerSockets(io.grpc.channelz.v1.GetServerSocketsRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.channelz.v1.GetServerSocketsResponse getServerSockets(io.grpc.channelz.v1.GetServerSocketsRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetServerSocketsMethod(), getCallOptions(), request);\n     }\n \n@@ -555,8 +555,8 @@ public io.grpc.channelz.v1.GetServerSocketsResponse getServerSockets(io.grpc.cha\n      * Returns a single Channel, or else a NOT_FOUND code.\n      * </pre>\n      */\n-    public io.grpc.channelz.v1.GetChannelResponse getChannel(io.grpc.channelz.v1.GetChannelRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.channelz.v1.GetChannelResponse getChannel(io.grpc.channelz.v1.GetChannelRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetChannelMethod(), getCallOptions(), request);\n     }\n \n@@ -565,8 +565,8 @@ public io.grpc.channelz.v1.GetChannelResponse getChannel(io.grpc.channelz.v1.Get\n      * Returns a single Subchannel, or else a NOT_FOUND code.\n      * </pre>\n      */\n-    public io.grpc.channelz.v1.GetSubchannelResponse getSubchannel(io.grpc.channelz.v1.GetSubchannelRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.channelz.v1.GetSubchannelResponse getSubchannel(io.grpc.channelz.v1.GetSubchannelRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetSubchannelMethod(), getCallOptions(), request);\n     }\n \n@@ -575,8 +575,8 @@ public io.grpc.channelz.v1.GetSubchannelResponse getSubchannel(io.grpc.channelz.\n      * Returns a single Socket or else a NOT_FOUND code.\n      * </pre>\n      */\n-    public io.grpc.channelz.v1.GetSocketResponse getSocket(io.grpc.channelz.v1.GetSocketRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.channelz.v1.GetSocketResponse getSocket(io.grpc.channelz.v1.GetSocketRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetSocketMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/services/src/generated/main/grpc/io/grpc/health/v1/HealthGrpc.java b/services/src/generated/main/grpc/io/grpc/health/v1/HealthGrpc.java\nindex 9786392cfe6..57fd4221242 100644\n--- a/services/src/generated/main/grpc/io/grpc/health/v1/HealthGrpc.java\n+++ b/services/src/generated/main/grpc/io/grpc/health/v1/HealthGrpc.java\n@@ -259,8 +259,8 @@ protected HealthBlockingV2Stub build(\n      * NOT_FOUND.\n      * </pre>\n      */\n-    public io.grpc.health.v1.HealthCheckResponse check(io.grpc.health.v1.HealthCheckRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.health.v1.HealthCheckResponse check(io.grpc.health.v1.HealthCheckRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getCheckMethod(), getCallOptions(), request);\n     }\n \n\ndiff --git a/stub/src/main/java/io/grpc/stub/ClientCalls.java b/stub/src/main/java/io/grpc/stub/ClientCalls.java\nindex f307c806489..e5a94f4d864 100644\n--- a/stub/src/main/java/io/grpc/stub/ClientCalls.java\n+++ b/stub/src/main/java/io/grpc/stub/ClientCalls.java\n@@ -182,6 +182,23 @@ public static <ReqT, RespT> RespT blockingUnaryCall(\n     }\n   }\n \n+  /**\n+   * Executes a unary call and blocks on the response,\n+   * throws a checked {@link StatusException}.\n+   *\n+   * @return the single response message.\n+   * @throws StatusException on error\n+   */\n+  public static <ReqT, RespT> RespT blockingV2UnaryCall(\n+      Channel channel, MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, ReqT req)\n+      throws StatusException {\n+    try {\n+      return blockingUnaryCall(channel, method, callOptions, req);\n+    } catch (StatusRuntimeException e) {\n+      throw e.getStatus().asException(e.getTrailers());\n+    }\n+  }\n+\n   /**\n    * Executes a server-streaming call returning a blocking {@link Iterator} over the\n    * response stream.  The {@code call} should not be already started.  After calling this method,\n\ndiff --git a/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/status/v3/ClientStatusDiscoveryServiceGrpc.java b/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/status/v3/ClientStatusDiscoveryServiceGrpc.java\nindex 1a3240875cc..26624e09a13 100644\n--- a/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/status/v3/ClientStatusDiscoveryServiceGrpc.java\n+++ b/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/status/v3/ClientStatusDiscoveryServiceGrpc.java\n@@ -251,8 +251,8 @@ protected ClientStatusDiscoveryServiceBlockingV2Stub build(\n \n     /**\n      */\n-    public io.envoyproxy.envoy.service.status.v3.ClientStatusResponse fetchClientStatus(io.envoyproxy.envoy.service.status.v3.ClientStatusRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.envoyproxy.envoy.service.status.v3.ClientStatusResponse fetchClientStatus(io.envoyproxy.envoy.service.status.v3.ClientStatusRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getFetchClientStatusMethod(), getCallOptions(), request);\n     }\n   }\n",
    "test_patch": "diff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\nindex 120033a8051..a64e06f0c97 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\n@@ -245,8 +245,8 @@ protected LoadBalancerStatsServiceBlockingV2Stub build(\n      * Gets the backend distribution for RPCs sent by a test client.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.LoadBalancerStatsResponse getClientStats(io.grpc.testing.integration.Messages.LoadBalancerStatsRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.LoadBalancerStatsResponse getClientStats(io.grpc.testing.integration.Messages.LoadBalancerStatsRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetClientStatsMethod(), getCallOptions(), request);\n     }\n \n@@ -255,8 +255,8 @@ public io.grpc.testing.integration.Messages.LoadBalancerStatsResponse getClientS\n      * Gets the accumulated stats for RPCs sent by a test client.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.LoadBalancerAccumulatedStatsResponse getClientAccumulatedStats(io.grpc.testing.integration.Messages.LoadBalancerAccumulatedStatsRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.LoadBalancerAccumulatedStatsResponse getClientAccumulatedStats(io.grpc.testing.integration.Messages.LoadBalancerAccumulatedStatsRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetClientAccumulatedStatsMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\nindex 489838ddc6c..c46c2a0d4e4 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\n@@ -245,8 +245,8 @@ protected MetricsServiceBlockingV2Stub build(\n      * Returns the value of one gauge\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Metrics.GaugeResponse getGauge(io.grpc.testing.integration.Metrics.GaugeRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Metrics.GaugeResponse getGauge(io.grpc.testing.integration.Metrics.GaugeRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetGaugeMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\nindex e0ea29e42e7..a0a86f7dd27 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\n@@ -230,15 +230,15 @@ protected ReconnectServiceBlockingV2Stub build(\n \n     /**\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty start(io.grpc.testing.integration.Messages.ReconnectParams request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty start(io.grpc.testing.integration.Messages.ReconnectParams request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getStartMethod(), getCallOptions(), request);\n     }\n \n     /**\n      */\n-    public io.grpc.testing.integration.Messages.ReconnectInfo stop(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.ReconnectInfo stop(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getStopMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/TestServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/TestServiceGrpc.java\nindex a0f44f46473..1ed2f405df9 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/TestServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/TestServiceGrpc.java\n@@ -576,8 +576,8 @@ protected TestServiceBlockingV2Stub build(\n      * One empty request followed by one empty response.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty emptyCall(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty emptyCall(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getEmptyCallMethod(), getCallOptions(), request);\n     }\n \n@@ -586,8 +586,8 @@ public io.grpc.testing.integration.EmptyProtos.Empty emptyCall(io.grpc.testing.i\n      * One request followed by one response.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.SimpleResponse unaryCall(io.grpc.testing.integration.Messages.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.SimpleResponse unaryCall(io.grpc.testing.integration.Messages.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnaryCallMethod(), getCallOptions(), request);\n     }\n \n@@ -598,8 +598,8 @@ public io.grpc.testing.integration.Messages.SimpleResponse unaryCall(io.grpc.tes\n      * satisfy subsequent requests.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.SimpleResponse cacheableUnaryCall(io.grpc.testing.integration.Messages.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.SimpleResponse cacheableUnaryCall(io.grpc.testing.integration.Messages.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getCacheableUnaryCallMethod(), getCallOptions(), request);\n     }\n \n@@ -664,8 +664,8 @@ public io.grpc.testing.integration.Messages.SimpleResponse cacheableUnaryCall(io\n      * to test the behavior when clients call unimplemented methods.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty unimplementedCall(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty unimplementedCall(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnimplementedCallMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\nindex f758c2d0840..518bc86859e 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\n@@ -199,8 +199,8 @@ protected UnimplementedServiceBlockingV2Stub build(\n      * A call that no server should implement\n      * </pre>\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty unimplementedCall(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty unimplementedCall(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnimplementedCallMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\nindex 5fa43e4721a..aedf16d6d41 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\n@@ -194,8 +194,8 @@ protected XdsUpdateClientConfigureServiceBlockingV2Stub build(\n      * Update the tes client's configuration.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.ClientConfigureResponse configure(io.grpc.testing.integration.Messages.ClientConfigureRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.ClientConfigureResponse configure(io.grpc.testing.integration.Messages.ClientConfigureRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getConfigureMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\nindex 2492ec0f90b..58b6683d8f6 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\n@@ -230,15 +230,15 @@ protected XdsUpdateHealthServiceBlockingV2Stub build(\n \n     /**\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty setServing(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty setServing(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getSetServingMethod(), getCallOptions(), request);\n     }\n \n     /**\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty setNotServing(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty setNotServing(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getSetNotServingMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\nindex 120033a8051..a64e06f0c97 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\n@@ -245,8 +245,8 @@ protected LoadBalancerStatsServiceBlockingV2Stub build(\n      * Gets the backend distribution for RPCs sent by a test client.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.LoadBalancerStatsResponse getClientStats(io.grpc.testing.integration.Messages.LoadBalancerStatsRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.LoadBalancerStatsResponse getClientStats(io.grpc.testing.integration.Messages.LoadBalancerStatsRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetClientStatsMethod(), getCallOptions(), request);\n     }\n \n@@ -255,8 +255,8 @@ public io.grpc.testing.integration.Messages.LoadBalancerStatsResponse getClientS\n      * Gets the accumulated stats for RPCs sent by a test client.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.LoadBalancerAccumulatedStatsResponse getClientAccumulatedStats(io.grpc.testing.integration.Messages.LoadBalancerAccumulatedStatsRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.LoadBalancerAccumulatedStatsResponse getClientAccumulatedStats(io.grpc.testing.integration.Messages.LoadBalancerAccumulatedStatsRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetClientAccumulatedStatsMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\nindex 489838ddc6c..c46c2a0d4e4 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\n@@ -245,8 +245,8 @@ protected MetricsServiceBlockingV2Stub build(\n      * Returns the value of one gauge\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Metrics.GaugeResponse getGauge(io.grpc.testing.integration.Metrics.GaugeRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Metrics.GaugeResponse getGauge(io.grpc.testing.integration.Metrics.GaugeRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetGaugeMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\nindex e0ea29e42e7..a0a86f7dd27 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\n@@ -230,15 +230,15 @@ protected ReconnectServiceBlockingV2Stub build(\n \n     /**\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty start(io.grpc.testing.integration.Messages.ReconnectParams request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty start(io.grpc.testing.integration.Messages.ReconnectParams request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getStartMethod(), getCallOptions(), request);\n     }\n \n     /**\n      */\n-    public io.grpc.testing.integration.Messages.ReconnectInfo stop(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.ReconnectInfo stop(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getStopMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/TestServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/TestServiceGrpc.java\nindex a0f44f46473..1ed2f405df9 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/TestServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/TestServiceGrpc.java\n@@ -576,8 +576,8 @@ protected TestServiceBlockingV2Stub build(\n      * One empty request followed by one empty response.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty emptyCall(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty emptyCall(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getEmptyCallMethod(), getCallOptions(), request);\n     }\n \n@@ -586,8 +586,8 @@ public io.grpc.testing.integration.EmptyProtos.Empty emptyCall(io.grpc.testing.i\n      * One request followed by one response.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.SimpleResponse unaryCall(io.grpc.testing.integration.Messages.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.SimpleResponse unaryCall(io.grpc.testing.integration.Messages.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnaryCallMethod(), getCallOptions(), request);\n     }\n \n@@ -598,8 +598,8 @@ public io.grpc.testing.integration.Messages.SimpleResponse unaryCall(io.grpc.tes\n      * satisfy subsequent requests.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.SimpleResponse cacheableUnaryCall(io.grpc.testing.integration.Messages.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.SimpleResponse cacheableUnaryCall(io.grpc.testing.integration.Messages.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getCacheableUnaryCallMethod(), getCallOptions(), request);\n     }\n \n@@ -664,8 +664,8 @@ public io.grpc.testing.integration.Messages.SimpleResponse cacheableUnaryCall(io\n      * to test the behavior when clients call unimplemented methods.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty unimplementedCall(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty unimplementedCall(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnimplementedCallMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\nindex f758c2d0840..518bc86859e 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\n@@ -199,8 +199,8 @@ protected UnimplementedServiceBlockingV2Stub build(\n      * A call that no server should implement\n      * </pre>\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty unimplementedCall(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty unimplementedCall(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnimplementedCallMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\nindex 5fa43e4721a..aedf16d6d41 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\n@@ -194,8 +194,8 @@ protected XdsUpdateClientConfigureServiceBlockingV2Stub build(\n      * Update the tes client's configuration.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.ClientConfigureResponse configure(io.grpc.testing.integration.Messages.ClientConfigureRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.ClientConfigureResponse configure(io.grpc.testing.integration.Messages.ClientConfigureRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getConfigureMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\nindex 2492ec0f90b..58b6683d8f6 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\n@@ -230,15 +230,15 @@ protected XdsUpdateHealthServiceBlockingV2Stub build(\n \n     /**\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty setServing(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty setServing(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getSetServingMethod(), getCallOptions(), request);\n     }\n \n     /**\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty setNotServing(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty setNotServing(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getSetNotServingMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/compiler/src/test/golden/TestDeprecatedService.java.txt b/compiler/src/test/golden/TestDeprecatedService.java.txt\nindex 712be32132e..548a9e3d806 100644\n--- a/compiler/src/test/golden/TestDeprecatedService.java.txt\n+++ b/compiler/src/test/golden/TestDeprecatedService.java.txt\n@@ -203,8 +203,8 @@ public final class TestDeprecatedServiceGrpc {\n      * </pre>\n      */\n     @java.lang.Deprecated\n-    public io.grpc.testing.compiler.Test.SimpleResponse deprecatedMethod(io.grpc.testing.compiler.Test.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.compiler.Test.SimpleResponse deprecatedMethod(io.grpc.testing.compiler.Test.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getDeprecatedMethodMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/compiler/src/test/golden/TestService.java.txt b/compiler/src/test/golden/TestService.java.txt\nindex e3c759639ec..93551f6d582 100644\n--- a/compiler/src/test/golden/TestService.java.txt\n+++ b/compiler/src/test/golden/TestService.java.txt\n@@ -580,8 +580,8 @@ public final class TestServiceGrpc {\n      * The server returns the client payload as-is.\n      * </pre>\n      */\n-    public io.grpc.testing.compiler.Test.SimpleResponse unaryCall(io.grpc.testing.compiler.Test.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.compiler.Test.SimpleResponse unaryCall(io.grpc.testing.compiler.Test.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnaryCallMethod(), getCallOptions(), request);\n     }\n \n@@ -658,8 +658,8 @@ public final class TestServiceGrpc {\n      * A unary call that is Safe.\n      * </pre>\n      */\n-    public io.grpc.testing.compiler.Test.SimpleResponse safeCall(io.grpc.testing.compiler.Test.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.compiler.Test.SimpleResponse safeCall(io.grpc.testing.compiler.Test.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getSafeCallMethod(), getCallOptions(), request);\n     }\n \n@@ -668,8 +668,8 @@ public final class TestServiceGrpc {\n      * A unary call that is Idempotent.\n      * </pre>\n      */\n-    public io.grpc.testing.compiler.Test.SimpleResponse idempotentCall(io.grpc.testing.compiler.Test.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.compiler.Test.SimpleResponse idempotentCall(io.grpc.testing.compiler.Test.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getIdempotentCallMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/compiler/src/testLite/golden/TestDeprecatedService.java.txt b/compiler/src/testLite/golden/TestDeprecatedService.java.txt\nindex 22a57c71523..89ea2e698bf 100644\n--- a/compiler/src/testLite/golden/TestDeprecatedService.java.txt\n+++ b/compiler/src/testLite/golden/TestDeprecatedService.java.txt\n@@ -199,8 +199,8 @@ public final class TestDeprecatedServiceGrpc {\n      * </pre>\n      */\n     @java.lang.Deprecated\n-    public io.grpc.testing.compiler.Test.SimpleResponse deprecatedMethod(io.grpc.testing.compiler.Test.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.compiler.Test.SimpleResponse deprecatedMethod(io.grpc.testing.compiler.Test.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getDeprecatedMethodMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/compiler/src/testLite/golden/TestService.java.txt b/compiler/src/testLite/golden/TestService.java.txt\nindex d13d9959a4a..4e9dfb8d682 100644\n--- a/compiler/src/testLite/golden/TestService.java.txt\n+++ b/compiler/src/testLite/golden/TestService.java.txt\n@@ -569,8 +569,8 @@ public final class TestServiceGrpc {\n      * The server returns the client payload as-is.\n      * </pre>\n      */\n-    public io.grpc.testing.compiler.Test.SimpleResponse unaryCall(io.grpc.testing.compiler.Test.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.compiler.Test.SimpleResponse unaryCall(io.grpc.testing.compiler.Test.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnaryCallMethod(), getCallOptions(), request);\n     }\n \n@@ -647,8 +647,8 @@ public final class TestServiceGrpc {\n      * A unary call that is Safe.\n      * </pre>\n      */\n-    public io.grpc.testing.compiler.Test.SimpleResponse safeCall(io.grpc.testing.compiler.Test.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.compiler.Test.SimpleResponse safeCall(io.grpc.testing.compiler.Test.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getSafeCallMethod(), getCallOptions(), request);\n     }\n \n@@ -657,8 +657,8 @@ public final class TestServiceGrpc {\n      * A unary call that is Idempotent.\n      * </pre>\n      */\n-    public io.grpc.testing.compiler.Test.SimpleResponse idempotentCall(io.grpc.testing.compiler.Test.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.compiler.Test.SimpleResponse idempotentCall(io.grpc.testing.compiler.Test.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getIdempotentCallMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\nindex f060a1308d8..c277470e5fa 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\n@@ -247,8 +247,8 @@ protected LoadBalancerStatsServiceBlockingV2Stub build(\n      * Gets the backend distribution for RPCs sent by a test client.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.LoadBalancerStatsResponse getClientStats(io.grpc.testing.integration.Messages.LoadBalancerStatsRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.LoadBalancerStatsResponse getClientStats(io.grpc.testing.integration.Messages.LoadBalancerStatsRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetClientStatsMethod(), getCallOptions(), request);\n     }\n \n@@ -257,8 +257,8 @@ public io.grpc.testing.integration.Messages.LoadBalancerStatsResponse getClientS\n      * Gets the accumulated stats for RPCs sent by a test client.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.LoadBalancerAccumulatedStatsResponse getClientAccumulatedStats(io.grpc.testing.integration.Messages.LoadBalancerAccumulatedStatsRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.LoadBalancerAccumulatedStatsResponse getClientAccumulatedStats(io.grpc.testing.integration.Messages.LoadBalancerAccumulatedStatsRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetClientAccumulatedStatsMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\nindex 3104f7b263e..9464a58c01e 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\n@@ -247,8 +247,8 @@ protected MetricsServiceBlockingV2Stub build(\n      * Returns the value of one gauge\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Metrics.GaugeResponse getGauge(io.grpc.testing.integration.Metrics.GaugeRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Metrics.GaugeResponse getGauge(io.grpc.testing.integration.Metrics.GaugeRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getGetGaugeMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\nindex 39df95f4d90..cab622d4608 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\n@@ -232,15 +232,15 @@ protected ReconnectServiceBlockingV2Stub build(\n \n     /**\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty start(io.grpc.testing.integration.Messages.ReconnectParams request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty start(io.grpc.testing.integration.Messages.ReconnectParams request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getStartMethod(), getCallOptions(), request);\n     }\n \n     /**\n      */\n-    public io.grpc.testing.integration.Messages.ReconnectInfo stop(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.ReconnectInfo stop(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getStopMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/TestServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/TestServiceGrpc.java\nindex 2b519686d85..271483180b7 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/TestServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/TestServiceGrpc.java\n@@ -584,8 +584,8 @@ protected TestServiceBlockingV2Stub build(\n      * One empty request followed by one empty response.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty emptyCall(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty emptyCall(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getEmptyCallMethod(), getCallOptions(), request);\n     }\n \n@@ -594,8 +594,8 @@ public io.grpc.testing.integration.EmptyProtos.Empty emptyCall(io.grpc.testing.i\n      * One request followed by one response.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.SimpleResponse unaryCall(io.grpc.testing.integration.Messages.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.SimpleResponse unaryCall(io.grpc.testing.integration.Messages.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnaryCallMethod(), getCallOptions(), request);\n     }\n \n@@ -606,8 +606,8 @@ public io.grpc.testing.integration.Messages.SimpleResponse unaryCall(io.grpc.tes\n      * satisfy subsequent requests.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.SimpleResponse cacheableUnaryCall(io.grpc.testing.integration.Messages.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.SimpleResponse cacheableUnaryCall(io.grpc.testing.integration.Messages.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getCacheableUnaryCallMethod(), getCallOptions(), request);\n     }\n \n@@ -672,8 +672,8 @@ public io.grpc.testing.integration.Messages.SimpleResponse cacheableUnaryCall(io\n      * to test the behavior when clients call unimplemented methods.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty unimplementedCall(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty unimplementedCall(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnimplementedCallMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\nindex 400ac6dc4a3..f51807c11cc 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\n@@ -200,8 +200,8 @@ protected UnimplementedServiceBlockingV2Stub build(\n      * A call that no server should implement\n      * </pre>\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty unimplementedCall(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty unimplementedCall(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnimplementedCallMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\nindex 9cc13780723..e048d214875 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\n@@ -195,8 +195,8 @@ protected XdsUpdateClientConfigureServiceBlockingV2Stub build(\n      * Update the tes client's configuration.\n      * </pre>\n      */\n-    public io.grpc.testing.integration.Messages.ClientConfigureResponse configure(io.grpc.testing.integration.Messages.ClientConfigureRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.Messages.ClientConfigureResponse configure(io.grpc.testing.integration.Messages.ClientConfigureRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getConfigureMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\nindex 8243ba713fa..77a6a82b97e 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\n@@ -232,15 +232,15 @@ protected XdsUpdateHealthServiceBlockingV2Stub build(\n \n     /**\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty setServing(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty setServing(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getSetServingMethod(), getCallOptions(), request);\n     }\n \n     /**\n      */\n-    public io.grpc.testing.integration.EmptyProtos.Empty setNotServing(io.grpc.testing.integration.EmptyProtos.Empty request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.integration.EmptyProtos.Empty setNotServing(io.grpc.testing.integration.EmptyProtos.Empty request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getSetNotServingMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/istio-interop-testing/src/generated/main/grpc/io/istio/test/EchoTestServiceGrpc.java b/istio-interop-testing/src/generated/main/grpc/io/istio/test/EchoTestServiceGrpc.java\nindex 3cb27ac1067..cc988ec7b74 100644\n--- a/istio-interop-testing/src/generated/main/grpc/io/istio/test/EchoTestServiceGrpc.java\n+++ b/istio-interop-testing/src/generated/main/grpc/io/istio/test/EchoTestServiceGrpc.java\n@@ -217,15 +217,15 @@ protected EchoTestServiceBlockingV2Stub build(\n \n     /**\n      */\n-    public io.istio.test.Echo.EchoResponse echo(io.istio.test.Echo.EchoRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.istio.test.Echo.EchoResponse echo(io.istio.test.Echo.EchoRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getEchoMethod(), getCallOptions(), request);\n     }\n \n     /**\n      */\n-    public io.istio.test.Echo.ForwardEchoResponse forwardEcho(io.istio.test.Echo.ForwardEchoRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.istio.test.Echo.ForwardEchoResponse forwardEcho(io.istio.test.Echo.ForwardEchoRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getForwardEchoMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherDynamicServiceGrpc.java b/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherDynamicServiceGrpc.java\nindex a53d199ef52..6de2c9d8cb2 100644\n--- a/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherDynamicServiceGrpc.java\n+++ b/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherDynamicServiceGrpc.java\n@@ -195,8 +195,8 @@ protected AnotherDynamicServiceBlockingV2Stub build(\n      * A method\n      * </pre>\n      */\n-    public io.grpc.reflection.testing.DynamicReply method(io.grpc.reflection.testing.DynamicRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.reflection.testing.DynamicReply method(io.grpc.reflection.testing.DynamicRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getMethodMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherReflectableServiceGrpc.java b/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherReflectableServiceGrpc.java\nindex a22138ecb03..3c630943485 100644\n--- a/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherReflectableServiceGrpc.java\n+++ b/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherReflectableServiceGrpc.java\n@@ -171,8 +171,8 @@ protected AnotherReflectableServiceBlockingV2Stub build(\n \n     /**\n      */\n-    public io.grpc.reflection.testing.Reply method(io.grpc.reflection.testing.Request request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.reflection.testing.Reply method(io.grpc.reflection.testing.Request request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getMethodMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/services/src/generated/test/grpc/io/grpc/reflection/testing/DynamicServiceGrpc.java b/services/src/generated/test/grpc/io/grpc/reflection/testing/DynamicServiceGrpc.java\nindex 6e9dfac72db..15dfcba5c94 100644\n--- a/services/src/generated/test/grpc/io/grpc/reflection/testing/DynamicServiceGrpc.java\n+++ b/services/src/generated/test/grpc/io/grpc/reflection/testing/DynamicServiceGrpc.java\n@@ -195,8 +195,8 @@ protected DynamicServiceBlockingV2Stub build(\n      * A method\n      * </pre>\n      */\n-    public io.grpc.reflection.testing.DynamicReply method(io.grpc.reflection.testing.DynamicRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.reflection.testing.DynamicReply method(io.grpc.reflection.testing.DynamicRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getMethodMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/services/src/generated/test/grpc/io/grpc/reflection/testing/ReflectableServiceGrpc.java b/services/src/generated/test/grpc/io/grpc/reflection/testing/ReflectableServiceGrpc.java\nindex aeefc77aff8..fd7750bf7ac 100644\n--- a/services/src/generated/test/grpc/io/grpc/reflection/testing/ReflectableServiceGrpc.java\n+++ b/services/src/generated/test/grpc/io/grpc/reflection/testing/ReflectableServiceGrpc.java\n@@ -171,8 +171,8 @@ protected ReflectableServiceBlockingV2Stub build(\n \n     /**\n      */\n-    public io.grpc.reflection.testing.Reply method(io.grpc.reflection.testing.Request request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.reflection.testing.Reply method(io.grpc.reflection.testing.Request request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getMethodMethod(), getCallOptions(), request);\n     }\n   }\n\ndiff --git a/testing-proto/src/generated/main/grpc/io/grpc/testing/protobuf/SimpleServiceGrpc.java b/testing-proto/src/generated/main/grpc/io/grpc/testing/protobuf/SimpleServiceGrpc.java\nindex 8b33691535d..b757e3d257e 100644\n--- a/testing-proto/src/generated/main/grpc/io/grpc/testing/protobuf/SimpleServiceGrpc.java\n+++ b/testing-proto/src/generated/main/grpc/io/grpc/testing/protobuf/SimpleServiceGrpc.java\n@@ -351,8 +351,8 @@ protected SimpleServiceBlockingV2Stub build(\n      * Simple unary RPC.\n      * </pre>\n      */\n-    public io.grpc.testing.protobuf.SimpleResponse unaryRpc(io.grpc.testing.protobuf.SimpleRequest request) {\n-      return io.grpc.stub.ClientCalls.blockingUnaryCall(\n+    public io.grpc.testing.protobuf.SimpleResponse unaryRpc(io.grpc.testing.protobuf.SimpleRequest request) throws io.grpc.StatusException {\n+      return io.grpc.stub.ClientCalls.blockingV2UnaryCall(\n           getChannel(), getUnaryRpcMethod(), getCallOptions(), request);\n     }\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-12125",
    "pr_id": 12125,
    "issue_id": 10845,
    "repo": "grpc/grpc-java",
    "problem_statement": "AbstractTransportTest's fakes should be factored out and made available to other tests\n### Is your feature request related to a problem?\r\nMany grpc-java unit tests create their own fake implementations of the various listener interfaces for synchronization. This results in code duplication, and low quality one-off implementations. When a test fails, both the system-under-test and the test itself are suspect.\r\n\r\n### Describe the solution you'd like\r\nHigh quality fake implementations of ServerListener, ServerTransportListener, ServerStreamListener and ClientStreamListener, available for other unit tests to use, and each with their own unit tests. \r\n\r\n### Describe alternatives you've considered\r\nstatus quo?\r\n\r\n### Additional context\r\nhttps://github.com/grpc/grpc-java/pull/10822#discussion_r1458031851\r\n",
    "issue_word_count": 112,
    "test_files_count": 7,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "binder/src/test/java/io/grpc/binder/internal/BinderServerTransportTest.java",
      "core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java",
      "core/src/testFixtures/java/io/grpc/internal/ClientStreamListenerBase.java",
      "core/src/testFixtures/java/io/grpc/internal/MockServerListener.java",
      "core/src/testFixtures/java/io/grpc/internal/MockServerTransportListener.java",
      "core/src/testFixtures/java/io/grpc/internal/ServerStreamListenerBase.java",
      "inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java"
    ],
    "pr_changed_test_files": [
      "binder/src/test/java/io/grpc/binder/internal/BinderServerTransportTest.java",
      "core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java",
      "core/src/testFixtures/java/io/grpc/internal/ClientStreamListenerBase.java",
      "core/src/testFixtures/java/io/grpc/internal/MockServerListener.java",
      "core/src/testFixtures/java/io/grpc/internal/MockServerTransportListener.java",
      "core/src/testFixtures/java/io/grpc/internal/ServerStreamListenerBase.java",
      "inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java"
    ],
    "base_commit": "6bad6005924d0e665adcd959109f8b7ad45c3a7c",
    "head_commit": "f62bc30820105ad717794f3624ede283bbea2722",
    "repo_url": "https://github.com/grpc/grpc-java/pull/12125",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/12125",
    "dockerfile": "",
    "pr_merged_at": "2025-06-05T10:09:51.000Z",
    "patch": "",
    "test_patch": "diff --git a/binder/src/test/java/io/grpc/binder/internal/BinderServerTransportTest.java b/binder/src/test/java/io/grpc/binder/internal/BinderServerTransportTest.java\nindex d3c13d6c89e..d47106d1d35 100644\n--- a/binder/src/test/java/io/grpc/binder/internal/BinderServerTransportTest.java\n+++ b/binder/src/test/java/io/grpc/binder/internal/BinderServerTransportTest.java\n@@ -16,7 +16,6 @@\n \n package io.grpc.binder.internal;\n \n-import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -29,11 +28,9 @@\n import android.os.Parcel;\n import com.google.common.collect.ImmutableList;\n import io.grpc.Attributes;\n-import io.grpc.Metadata;\n import io.grpc.Status;\n import io.grpc.internal.FixedObjectPool;\n-import io.grpc.internal.ServerStream;\n-import io.grpc.internal.ServerTransportListener;\n+import io.grpc.internal.MockServerTransportListener;\n import java.util.concurrent.ScheduledExecutorService;\n import org.junit.Before;\n import org.junit.Rule;\n@@ -55,7 +52,7 @@ public final class BinderServerTransportTest {\n   @Rule public MockitoRule mocks = MockitoJUnit.rule();\n \n   private final ScheduledExecutorService executorService = new MainThreadScheduledExecutorService();\n-  private final TestTransportListener transportListener = new TestTransportListener();\n+  private MockServerTransportListener transportListener;\n \n   @Mock IBinder mockBinder;\n \n@@ -70,6 +67,7 @@ public void setUp() throws Exception {\n             ImmutableList.of(),\n             OneWayBinderProxy.IDENTITY_DECORATOR,\n             mockBinder);\n+    transportListener = new MockServerTransportListener(transport);\n   }\n \n   @Test\n@@ -82,34 +80,6 @@ public void testSetupTransactionFailureCausesMultipleShutdowns_b153460678() thro\n     transport.shutdownNow(Status.UNKNOWN.withDescription(\"reasons\"));\n     shadowOf(Looper.getMainLooper()).idle();\n \n-    assertThat(transportListener.terminated).isTrue();\n-  }\n-\n-  private static final class TestTransportListener implements ServerTransportListener {\n-\n-    public boolean ready;\n-    public boolean terminated;\n-\n-    /**\n-     * Called when a new stream was created by the remote client.\n-     *\n-     * @param stream the newly created stream.\n-     * @param method the fully qualified method name being called on the server.\n-     * @param headers containing metadata for the call.\n-     */\n-    @Override\n-    public void streamCreated(ServerStream stream, String method, Metadata headers) {}\n-\n-    @Override\n-    public Attributes transportReady(Attributes attributes) {\n-      ready = true;\n-      return attributes;\n-    }\n-\n-    @Override\n-    public void transportTerminated() {\n-      checkState(!terminated, \"Terminated twice\");\n-      terminated = true;\n-    }\n+    assertThat(transportListener.isTerminated()).isTrue();\n   }\n }\n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java b/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\nindex 1f4c2b41f15..32c3bff74e9 100644\n--- a/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\n+++ b/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\n@@ -58,6 +58,7 @@\n import io.grpc.MethodDescriptor;\n import io.grpc.ServerStreamTracer;\n import io.grpc.Status;\n+import io.grpc.internal.MockServerTransportListener.StreamCreation;\n import io.grpc.internal.testing.TestClientStreamTracer;\n import io.grpc.internal.testing.TestServerStreamTracer;\n import java.io.ByteArrayInputStream;\n@@ -69,10 +70,8 @@\n import java.util.Arrays;\n import java.util.List;\n import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Future;\n-import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n import org.junit.After;\n@@ -296,8 +295,8 @@ public void frameAfterRstStreamShouldNotBreakClientChannel() throws Exception {\n     serverStreamCreation.stream.flush();\n \n     assertEquals(\n-        Status.CANCELLED, clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+        Status.CANCELLED, clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     ClientStreamListener mockClientStreamListener2 = mock(ClientStreamListener.class);\n \n@@ -469,7 +468,7 @@ public void openStreamPreventsTermination() throws Exception {\n     // the stream still functions.\n     serverStream.writeHeaders(new Metadata(), true);\n     clientStream.halfClose();\n-    assertNotNull(clientStreamListener.headers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitHeaders(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertTrue(serverStreamListener.awaitHalfClosed(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     verify(mockClientTransportListener, never()).transportTerminated();\n@@ -511,9 +510,9 @@ public void shutdownNowKillsClientStream() throws Exception {\n     assertTrue(serverTransportListener.waitForTermination(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertTrue(serverTransportListener.isTerminated());\n \n-    assertEquals(status, clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status serverStatus = serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertEquals(status, clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status serverStatus = serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertFalse(serverStatus.isOk());\n     assertTrue(clientStreamTracer1.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertNull(clientStreamTracer1.getInboundTrailers());\n@@ -550,9 +549,9 @@ public void shutdownNowKillsServerStream() throws Exception {\n     assertTrue(serverTransportListener.waitForTermination(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertTrue(serverTransportListener.isTerminated());\n \n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertFalse(clientStreamStatus.isOk());\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertTrue(clientStreamTracer1.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertNull(clientStreamTracer1.getInboundTrailers());\n     assertStatusEquals(clientStreamStatus, clientStreamTracer1.getStatus());\n@@ -562,7 +561,7 @@ public void shutdownNowKillsServerStream() throws Exception {\n     // Generally will be same status provided to shutdownNow, but InProcessTransport can't\n     // differentiate between client and server shutdownNow. The status is not really used on\n     // server-side, so we don't care much.\n-    assertNotNull(serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n   }\n \n   @Test\n@@ -643,8 +642,8 @@ public void newStream_duringShutdown() throws Exception {\n     ClientStreamListenerBase clientStreamListener2 = new ClientStreamListenerBase();\n     stream2.start(clientStreamListener2);\n     Status clientStreamStatus2 =\n-        clientStreamListener2.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-    assertNotNull(clientStreamListener2.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+        clientStreamListener2.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertNotNull(clientStreamListener2.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertCodeEquals(Status.UNAVAILABLE, clientStreamStatus2);\n     assertNull(clientStreamTracer2.getInboundTrailers());\n     assertSame(clientStreamStatus2, clientStreamTracer2.getStatus());\n@@ -658,8 +657,8 @@ public void newStream_duringShutdown() throws Exception {\n     StreamCreation serverStreamCreation\n         = serverTransportListener.takeStreamOrFail(20 * TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     serverStreamCreation.stream.close(Status.OK, new Metadata());\n-    assertCodeEquals(Status.OK, clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertCodeEquals(Status.OK, clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n   }\n \n   @Test\n@@ -679,8 +678,8 @@ public void newStream_afterTermination() throws Exception {\n     ClientStreamListenerBase clientStreamListener = new ClientStreamListenerBase();\n     stream.start(clientStreamListener);\n     assertEquals(\n-        shutdownReason, clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+        shutdownReason, clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     verify(mockClientTransportListener, never()).transportInUse(anyBoolean());\n     assertNull(clientStreamTracer1.getInboundTrailers());\n     assertSame(shutdownReason, clientStreamTracer1.getStatus());\n@@ -788,6 +787,17 @@ public void transportInUse_clientCancel() throws Exception {\n \n   @Test\n   public void basicStream() throws Exception {\n+    serverListener =\n+        new MockServerListener(\n+            transport ->\n+                new MockServerTransportListener(transport) {\n+                  @Override\n+                  public Attributes transportReady(Attributes attributes) {\n+                    return super.transportReady(attributes).toBuilder()\n+                        .set(ADDITIONAL_TRANSPORT_ATTR_KEY, \"additional attribute value\")\n+                        .build();\n+                  }\n+                });\n     InOrder serverInOrder = inOrder(serverStreamTracerFactory);\n     server.start(serverListener);\n     client = newClientTransport(server);\n@@ -881,7 +891,7 @@ public void basicStream() throws Exception {\n     Metadata serverHeadersCopy = new Metadata();\n     serverHeadersCopy.merge(serverHeaders);\n     serverStream.writeHeaders(serverHeaders, true);\n-    Metadata headers = clientStreamListener.headers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Metadata headers = clientStreamListener.awaitHeaders(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNotNull(headers);\n     assertAsciiMetadataValuesEqual(serverHeadersCopy.getAll(asciiKey), headers.getAll(asciiKey));\n     assertEquals(\n@@ -926,11 +936,11 @@ public void basicStream() throws Exception {\n     serverStream.close(status, trailers);\n     assertNull(serverStreamTracer1.nextInboundEvent());\n     assertNull(serverStreamTracer1.nextOutboundEvent());\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertSame(status, serverStreamTracer1.getStatus());\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     Metadata clientStreamTrailers =\n-        clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertSame(clientStreamTrailers, clientStreamTracer1.getInboundTrailers());\n     assertSame(clientStreamStatus, clientStreamTracer1.getStatus());\n     assertNull(clientStreamTracer1.nextInboundEvent());\n@@ -999,14 +1009,14 @@ public void zeroMessageStream() throws Exception {\n     assertTrue(serverStreamListener.awaitHalfClosed(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     serverStream.writeHeaders(new Metadata(), true);\n-    assertNotNull(clientStreamListener.headers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitHeaders(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     Status status = Status.OK.withDescription(\"Nice talking to you\");\n     serverStream.close(status, new Metadata());\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     Metadata clientStreamTrailers =\n-        clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNotNull(clientStreamTrailers);\n     assertEquals(status.getCode(), clientStreamStatus.getCode());\n     assertEquals(status.getDescription(), clientStreamStatus.getDescription());\n@@ -1036,15 +1046,15 @@ public void earlyServerClose_withServerHeaders() throws Exception {\n     ServerStreamListenerBase serverStreamListener = serverStreamCreation.listener;\n \n     serverStream.writeHeaders(new Metadata(), true);\n-    assertNotNull(clientStreamListener.headers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitHeaders(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     Status strippedStatus = Status.OK.withDescription(\"Hello. Goodbye.\");\n     Status status = strippedStatus.withCause(new Exception());\n     serverStream.close(status, new Metadata());\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     Metadata clientStreamTrailers =\n-        clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNotNull(clientStreamTrailers);\n     checkClientStatus(status, clientStreamStatus);\n     assertTrue(clientStreamTracer1.getOutboundHeaders());\n@@ -1080,10 +1090,10 @@ public void earlyServerClose_noServerHeaders() throws Exception {\n     trailers.put(asciiKey, \"dupvalue\");\n     trailers.put(binaryKey, \"äbinarytrailers\");\n     serverStream.close(status, trailers);\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     Metadata clientStreamTrailers =\n-        clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     checkClientStatus(status, clientStreamStatus);\n     assertEquals(\n         Lists.newArrayList(trailers.getAll(asciiKey)),\n@@ -1118,10 +1128,10 @@ public void earlyServerClose_serverFailure() throws Exception {\n     Status strippedStatus = Status.INTERNAL.withDescription(\"I'm not listening\");\n     Status status = strippedStatus.withCause(new Exception());\n     serverStream.close(status, new Metadata());\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     Metadata clientStreamTrailers =\n-        clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNotNull(clientStreamTrailers);\n     checkClientStatus(status, clientStreamStatus);\n     assertTrue(clientStreamTracer1.getOutboundHeaders());\n@@ -1161,10 +1171,10 @@ public void closed(\n     Status strippedStatus = Status.INTERNAL.withDescription(\"I'm not listening\");\n     Status status = strippedStatus.withCause(new Exception());\n     serverStream.close(status, new Metadata());\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     Metadata clientStreamTrailers =\n-        clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNotNull(clientStreamTrailers);\n     checkClientStatus(status, clientStreamStatus);\n     assertTrue(clientStreamTracer1.getOutboundHeaders());\n@@ -1192,9 +1202,9 @@ public void clientCancel() throws Exception {\n \n     Status status = Status.CANCELLED.withDescription(\"Nevermind\").withCause(new Exception());\n     clientStream.cancel(status);\n-    assertEquals(status, clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status serverStatus = serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertEquals(status, clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status serverStatus = serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNotEquals(Status.Code.OK, serverStatus.getCode());\n     // Cause should not be transmitted between client and server by default\n     assertNull(serverStatus.getCause());\n@@ -1306,9 +1316,9 @@ public void serverCancel() throws Exception {\n     Status status = Status.DEADLINE_EXCEEDED.withDescription(\"It was bound to happen\")\n         .withCause(new Exception());\n     serverStream.cancel(status);\n-    assertEquals(status, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertEquals(status, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     // Presently we can't sent much back to the client in this case. Verify that is the current\n     // behavior for consistency between transports.\n     assertCodeEquals(Status.CANCELLED, clientStreamStatus);\n@@ -1452,7 +1462,7 @@ public void flowControlPushBack() throws Exception {\n     serverStream.close(status, new Metadata());\n     doPingPong(serverListener);\n     try {\n-      clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+      clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n       fail(\"Expected TimeoutException\");\n     } catch (TimeoutException expectedException) {\n     }\n@@ -1460,9 +1470,9 @@ public void flowControlPushBack() throws Exception {\n     clientStream.request(1);\n     clientReceived += verifyMessageCountAndClose(clientStreamListener.messageQueue, 1);\n     assertEquals(serverSent + 6, clientReceived);\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertEquals(status.getCode(), clientStreamStatus.getCode());\n     assertEquals(status.getDescription(), clientStreamStatus.getDescription());\n   }\n@@ -1518,9 +1528,9 @@ public void flowControlDoesNotDeadlockLargeMessage() throws Exception {\n     serverStream.close(status, new Metadata());\n     doPingPong(serverListener);\n     clientStream.request(1);\n-    assertCodeEquals(Status.OK, serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    Status clientStreamStatus = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertCodeEquals(Status.OK, serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    Status clientStreamStatus = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     assertEquals(status.getCode(), clientStreamStatus.getCode());\n     assertEquals(status.getDescription(), clientStreamStatus.getDescription());\n   }\n@@ -1588,8 +1598,8 @@ public void interactionsAfterServerStreamCloseAreNoops() throws Exception {\n     // setup\n     clientStream.request(1);\n     server.stream.close(Status.INTERNAL, new Metadata());\n-    assertNotNull(clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     // Ensure that for a closed ServerStream, interactions are noops\n     server.stream.writeHeaders(new Metadata(), true);\n@@ -1621,7 +1631,7 @@ public void interactionsAfterClientStreamCancelAreNoops() throws Exception {\n     // setup\n     server.stream.request(1);\n     clientStream.cancel(Status.UNKNOWN);\n-    assertNotNull(server.listener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(server.listener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     // Ensure that for a cancelled ClientStream, interactions are noops\n     clientStream.writeMessage(methodDescriptor.streamRequest(\"request\"));\n@@ -1744,9 +1754,8 @@ public void transportTracer_server_streamEnded_ok() throws Exception {\n     clientStream.halfClose();\n     serverStream.close(Status.OK, new Metadata());\n     // do not validate stats until close() has been called on client\n-    assertNotNull(clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-\n+    assertNotNull(clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     TransportStats serverAfter = getTransportStats(serverTransportListener.transport);\n     assertEquals(1, serverAfter.streamsSucceeded);\n@@ -1783,9 +1792,8 @@ public void transportTracer_server_streamEnded_nonOk() throws Exception {\n \n     serverStream.close(Status.UNKNOWN, new Metadata());\n     // do not validate stats until close() has been called on client\n-    assertNotNull(clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-\n+    assertNotNull(clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     TransportStats serverAfter = getTransportStats(serverTransportListener.transport);\n     assertEquals(1, serverAfter.streamsFailed);\n@@ -1823,7 +1831,7 @@ public void transportTracer_client_streamEnded_nonOk() throws Exception {\n \n     clientStream.cancel(Status.UNKNOWN);\n     // do not validate stats until close() has been called on server\n-    assertNotNull(serverStreamCreation.listener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(serverStreamCreation.listener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n     TransportStats serverAfter = getTransportStats(serverTransportListener.transport);\n     assertEquals(1, serverAfter.streamsFailed);\n@@ -1980,7 +1988,7 @@ public void serverChecksInboundMetadataSize() throws Exception {\n     // Server shouldn't have created a stream, so nothing to clean up on server-side\n \n     // If this times out, the server probably isn't noticing the metadata size\n-    Status status = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Status status = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     List<Status.Code> codeOptions = Arrays.asList(\n         Status.Code.UNKNOWN, Status.Code.RESOURCE_EXHAUSTED, Status.Code.INTERNAL);\n     if (!codeOptions.contains(status.getCode())) {\n@@ -2021,13 +2029,13 @@ public void clientChecksInboundMetadataSize_header() throws Exception {\n     serverStreamCreation.stream.writeMessage(methodDescriptor.streamResponse(\"response\"));\n     serverStreamCreation.stream.close(Status.OK, new Metadata());\n \n-    Status status = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Status status = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     List<Status.Code> codeOptions = Arrays.asList(\n         Status.Code.UNKNOWN, Status.Code.RESOURCE_EXHAUSTED, Status.Code.INTERNAL);\n     if (!codeOptions.contains(status.getCode())) {\n       fail(\"Status code was not expected: \" + status);\n     }\n-    assertFalse(clientStreamListener.headers.isDone());\n+    assertFalse(clientStreamListener.hasHeaders());\n   }\n \n   /** This assumes the client limits metadata size to GrpcUtil.DEFAULT_MAX_HEADER_LIST_SIZE. */\n@@ -2066,13 +2074,13 @@ public void clientChecksInboundMetadataSize_trailer() throws Exception {\n     serverStreamCreation.stream.writeMessage(methodDescriptor.streamResponse(\"response\"));\n     serverStreamCreation.stream.close(Status.OK, tooLargeMetadata);\n \n-    Status status = clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Status status = clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     List<Status.Code> codeOptions = Arrays.asList(\n         Status.Code.UNKNOWN, Status.Code.RESOURCE_EXHAUSTED, Status.Code.INTERNAL);\n     if (!codeOptions.contains(status.getCode())) {\n       fail(\"Status code was not expected: \" + status);\n     }\n-    Metadata metadata = clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    Metadata metadata = clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     assertNull(metadata.get(tellTaleKey));\n   }\n \n@@ -2100,9 +2108,9 @@ methodDescriptor, new Metadata(), callOptions,\n     ServerStreamListenerBase serverStreamListener = serverStreamCreation.listener;\n \n     serverStream.close(Status.OK, new Metadata());\n-    assertNotNull(clientStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(clientStreamListener.trailers.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n-    assertNotNull(serverStreamListener.status.get(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(clientStreamListener.awaitTrailers(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    assertNotNull(serverStreamListener.awaitClose(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n     client.shutdown(Status.UNAVAILABLE);\n   }\n \n@@ -2147,7 +2155,7 @@ private static void checkClientStatus(Status expectedStatus, Status clientStream\n     assertNull(clientStreamStatus.getCause());\n   }\n \n-  private static boolean waitForFuture(Future<?> future, long timeout, TimeUnit unit)\n+  static boolean waitForFuture(Future<?> future, long timeout, TimeUnit unit)\n       throws InterruptedException {\n     try {\n       future.get(timeout, unit);\n@@ -2183,218 +2191,6 @@ public void streamCreated(Attributes transportAttrs, Metadata metadata) {\n     }\n   }\n \n-  public static class MockServerListener implements ServerListener {\n-    public final BlockingQueue<MockServerTransportListener> listeners\n-        = new LinkedBlockingQueue<>();\n-    private final SettableFuture<?> shutdown = SettableFuture.create();\n-\n-    @Override\n-    public ServerTransportListener transportCreated(ServerTransport transport) {\n-      MockServerTransportListener listener = new MockServerTransportListener(transport);\n-      listeners.add(listener);\n-      return listener;\n-    }\n-\n-    @Override\n-    public void serverShutdown() {\n-      assertTrue(shutdown.set(null));\n-    }\n-\n-    public boolean waitForShutdown(long timeout, TimeUnit unit) throws InterruptedException {\n-      return waitForFuture(shutdown, timeout, unit);\n-    }\n-\n-    public MockServerTransportListener takeListenerOrFail(long timeout, TimeUnit unit)\n-        throws InterruptedException {\n-      MockServerTransportListener listener = listeners.poll(timeout, unit);\n-      if (listener == null) {\n-        fail(\"Timed out waiting for server transport\");\n-      }\n-      return listener;\n-    }\n-  }\n-\n-  public static class MockServerTransportListener implements ServerTransportListener {\n-    public final ServerTransport transport;\n-    public final BlockingQueue<StreamCreation> streams = new LinkedBlockingQueue<>();\n-    private final SettableFuture<?> terminated = SettableFuture.create();\n-\n-    public MockServerTransportListener(ServerTransport transport) {\n-      this.transport = transport;\n-    }\n-\n-    @Override\n-    public void streamCreated(ServerStream stream, String method, Metadata headers) {\n-      ServerStreamListenerBase listener = new ServerStreamListenerBase();\n-      streams.add(new StreamCreation(stream, method, headers, listener));\n-      stream.setListener(listener);\n-    }\n-\n-    @Override\n-    public Attributes transportReady(Attributes attributes) {\n-      assertFalse(terminated.isDone());\n-      return Attributes.newBuilder()\n-          .setAll(attributes)\n-          .set(ADDITIONAL_TRANSPORT_ATTR_KEY, \"additional attribute value\")\n-          .build();\n-    }\n-\n-    @Override\n-    public void transportTerminated() {\n-      assertTrue(terminated.set(null));\n-    }\n-\n-    public boolean waitForTermination(long timeout, TimeUnit unit) throws InterruptedException {\n-      return waitForFuture(terminated, timeout, unit);\n-    }\n-\n-    public boolean isTerminated() {\n-      return terminated.isDone();\n-    }\n-\n-    public StreamCreation takeStreamOrFail(long timeout, TimeUnit unit)\n-        throws InterruptedException {\n-      StreamCreation stream = streams.poll(timeout, unit);\n-      if (stream == null) {\n-        fail(\"Timed out waiting for server stream\");\n-      }\n-      return stream;\n-    }\n-  }\n-\n-  public static class ServerStreamListenerBase implements ServerStreamListener {\n-    public final BlockingQueue<InputStream> messageQueue = new LinkedBlockingQueue<>();\n-    // Would have used Void instead of Object, but null elements are not allowed\n-    private final BlockingQueue<Object> readyQueue = new LinkedBlockingQueue<>();\n-    private final CountDownLatch halfClosedLatch = new CountDownLatch(1);\n-    private final SettableFuture<Status> status = SettableFuture.create();\n-\n-    private boolean awaitOnReady(int timeout, TimeUnit unit) throws Exception {\n-      return readyQueue.poll(timeout, unit) != null;\n-    }\n-\n-    private boolean awaitOnReadyAndDrain(int timeout, TimeUnit unit) throws Exception {\n-      if (!awaitOnReady(timeout, unit)) {\n-        return false;\n-      }\n-      // Throw the rest away\n-      readyQueue.drainTo(Lists.newArrayList());\n-      return true;\n-    }\n-\n-    private boolean awaitHalfClosed(int timeout, TimeUnit unit) throws Exception {\n-      return halfClosedLatch.await(timeout, unit);\n-    }\n-\n-    @Override\n-    public void messagesAvailable(MessageProducer producer) {\n-      if (status.isDone()) {\n-        fail(\"messagesAvailable invoked after closed\");\n-      }\n-      InputStream message;\n-      while ((message = producer.next()) != null) {\n-        messageQueue.add(message);\n-      }\n-    }\n-\n-    @Override\n-    public void onReady() {\n-      if (status.isDone()) {\n-        fail(\"onReady invoked after closed\");\n-      }\n-      readyQueue.add(new Object());\n-    }\n-\n-    @Override\n-    public void halfClosed() {\n-      if (status.isDone()) {\n-        fail(\"halfClosed invoked after closed\");\n-      }\n-      halfClosedLatch.countDown();\n-    }\n-\n-    @Override\n-    public void closed(Status status) {\n-      if (this.status.isDone()) {\n-        fail(\"closed invoked more than once\");\n-      }\n-      this.status.set(status);\n-    }\n-  }\n-\n-  public static class ClientStreamListenerBase implements ClientStreamListener {\n-    public final BlockingQueue<InputStream> messageQueue = new LinkedBlockingQueue<>();\n-    // Would have used Void instead of Object, but null elements are not allowed\n-    private final BlockingQueue<Object> readyQueue = new LinkedBlockingQueue<>();\n-    private final SettableFuture<Metadata> headers = SettableFuture.create();\n-    private final SettableFuture<Metadata> trailers = SettableFuture.create();\n-    private final SettableFuture<Status> status = SettableFuture.create();\n-\n-    private boolean awaitOnReady(int timeout, TimeUnit unit) throws Exception {\n-      return readyQueue.poll(timeout, unit) != null;\n-    }\n-\n-    private boolean awaitOnReadyAndDrain(int timeout, TimeUnit unit) throws Exception {\n-      if (!awaitOnReady(timeout, unit)) {\n-        return false;\n-      }\n-      // Throw the rest away\n-      readyQueue.drainTo(Lists.newArrayList());\n-      return true;\n-    }\n-\n-    @Override\n-    public void messagesAvailable(MessageProducer producer) {\n-      if (status.isDone()) {\n-        fail(\"messagesAvailable invoked after closed\");\n-      }\n-      InputStream message;\n-      while ((message = producer.next()) != null) {\n-        messageQueue.add(message);\n-      }\n-    }\n-\n-    @Override\n-    public void onReady() {\n-      if (status.isDone()) {\n-        fail(\"onReady invoked after closed\");\n-      }\n-      readyQueue.add(new Object());\n-    }\n-\n-    @Override\n-    public void headersRead(Metadata headers) {\n-      if (status.isDone()) {\n-        fail(\"headersRead invoked after closed\");\n-      }\n-      this.headers.set(headers);\n-    }\n-\n-    @Override\n-    public void closed(Status status, RpcProgress rpcProgress, Metadata trailers) {\n-      if (this.status.isDone()) {\n-        fail(\"headersRead invoked after closed\");\n-      }\n-      this.status.set(status);\n-      this.trailers.set(trailers);\n-    }\n-  }\n-\n-  public static class StreamCreation {\n-    public final ServerStream stream;\n-    public final String method;\n-    public final Metadata headers;\n-    public final ServerStreamListenerBase listener;\n-\n-    public StreamCreation(\n-        ServerStream stream, String method, Metadata headers, ServerStreamListenerBase listener) {\n-      this.stream = stream;\n-      this.method = method;\n-      this.headers = headers;\n-      this.listener = listener;\n-    }\n-  }\n-\n   private static class StringMarshaller implements MethodDescriptor.Marshaller<String> {\n     public static final StringMarshaller INSTANCE = new StringMarshaller();\n \n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/ClientStreamListenerBase.java b/core/src/testFixtures/java/io/grpc/internal/ClientStreamListenerBase.java\nnew file mode 100644\nindex 00000000000..97186400cb2\n--- /dev/null\n+++ b/core/src/testFixtures/java/io/grpc/internal/ClientStreamListenerBase.java\n@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2025 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static org.junit.Assert.fail;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import java.io.InputStream;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class ClientStreamListenerBase implements ClientStreamListener {\n+  public final BlockingQueue<InputStream> messageQueue = new LinkedBlockingQueue<>();\n+  // Would have used Void instead of Object, but null elements are not allowed\n+  private final BlockingQueue<Object> readyQueue = new LinkedBlockingQueue<>();\n+  private final SettableFuture<Metadata> headers = SettableFuture.create();\n+  private final SettableFuture<Metadata> trailers = SettableFuture.create();\n+  private final SettableFuture<Status> status = SettableFuture.create();\n+\n+  /**\n+   * Returns the stream's status or throws {@link java.util.concurrent.TimeoutException} if it isn't\n+   * closed before the timeout.\n+   */\n+  public Status awaitClose(int timeout, TimeUnit unit) throws Exception {\n+    return status.get(timeout, unit);\n+  }\n+\n+  /**\n+   * Returns response headers from the server or throws {@link\n+   * java.util.concurrent.TimeoutException} if they aren't delivered before the timeout.\n+   *\n+   * <p>Callers must not modify the returned object.\n+   */\n+  public Metadata awaitHeaders(int timeout, TimeUnit unit) throws Exception {\n+    return headers.get(timeout, unit);\n+  }\n+\n+  /**\n+   * Returns response trailers from the server or throws {@link\n+   * java.util.concurrent.TimeoutException} if they aren't delivered before the timeout.\n+   *\n+   * <p>Callers must not modify the returned object.\n+   */\n+  public Metadata awaitTrailers(int timeout, TimeUnit unit) throws Exception {\n+    return trailers.get(timeout, unit);\n+  }\n+\n+  public boolean awaitOnReady(int timeout, TimeUnit unit) throws Exception {\n+    return readyQueue.poll(timeout, unit) != null;\n+  }\n+\n+  public boolean awaitOnReadyAndDrain(int timeout, TimeUnit unit) throws Exception {\n+    if (!awaitOnReady(timeout, unit)) {\n+      return false;\n+    }\n+    // Throw the rest away\n+    readyQueue.drainTo(Lists.newArrayList());\n+    return true;\n+  }\n+\n+  @Override\n+  public void messagesAvailable(MessageProducer producer) {\n+    if (status.isDone()) {\n+      fail(\"messagesAvailable invoked after closed\");\n+    }\n+    InputStream message;\n+    while ((message = producer.next()) != null) {\n+      messageQueue.add(message);\n+    }\n+  }\n+\n+  @Override\n+  public void onReady() {\n+    if (status.isDone()) {\n+      fail(\"onReady invoked after closed\");\n+    }\n+    readyQueue.add(new Object());\n+  }\n+\n+  @Override\n+  public void headersRead(Metadata headers) {\n+    if (status.isDone()) {\n+      fail(\"headersRead invoked after closed\");\n+    }\n+    this.headers.set(headers);\n+  }\n+\n+  @Override\n+  public void closed(Status status, RpcProgress rpcProgress, Metadata trailers) {\n+    if (this.status.isDone()) {\n+      fail(\"headersRead invoked after closed\");\n+    }\n+    this.status.set(status);\n+    this.trailers.set(trailers);\n+  }\n+\n+  /** Returns true iff response headers have been received from the server. */\n+  public boolean hasHeaders() {\n+    return headers.isDone();\n+  }\n+}\n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/MockServerListener.java b/core/src/testFixtures/java/io/grpc/internal/MockServerListener.java\nnew file mode 100644\nindex 00000000000..0c33b98cf1c\n--- /dev/null\n+++ b/core/src/testFixtures/java/io/grpc/internal/MockServerListener.java\n@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2025 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import com.google.common.util.concurrent.SettableFuture;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link ServerListener} that helps you write blocking unit tests.\n+ *\n+ * <p>TODO: Rename, since this is not actually a mock:\n+ * https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html\n+ */\n+public class MockServerListener implements ServerListener {\n+  private final BlockingQueue<MockServerTransportListener> listeners = new LinkedBlockingQueue<>();\n+  private final SettableFuture<?> shutdown = SettableFuture.create();\n+  private final ServerTransportListenerFactory serverTransportListenerFactory;\n+\n+  /**\n+   * Lets you customize the {@link MockServerTransportListener} installed on newly created\n+   * {@link ServerTransport}s.\n+   */\n+  public interface ServerTransportListenerFactory {\n+    MockServerTransportListener create(ServerTransport transport);\n+  }\n+\n+  public MockServerListener(ServerTransportListenerFactory serverTransportListenerFactory) {\n+    this.serverTransportListenerFactory = serverTransportListenerFactory;\n+  }\n+\n+  public MockServerListener() {\n+    this(MockServerTransportListener::new);\n+  }\n+\n+  @Override\n+  public ServerTransportListener transportCreated(ServerTransport transport) {\n+    MockServerTransportListener listener = serverTransportListenerFactory.create(transport);\n+    listeners.add(listener);\n+    return listener;\n+  }\n+\n+  @Override\n+  public void serverShutdown() {\n+    assertTrue(shutdown.set(null));\n+  }\n+\n+  public boolean waitForShutdown(long timeout, TimeUnit unit) throws InterruptedException {\n+    return AbstractTransportTest.waitForFuture(shutdown, timeout, unit);\n+  }\n+\n+  public MockServerTransportListener takeListenerOrFail(long timeout, TimeUnit unit)\n+      throws InterruptedException {\n+    MockServerTransportListener listener = listeners.poll(timeout, unit);\n+    if (listener == null) {\n+      fail(\"Timed out waiting for server transport\");\n+    }\n+    return listener;\n+  }\n+}\n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/MockServerTransportListener.java b/core/src/testFixtures/java/io/grpc/internal/MockServerTransportListener.java\nnew file mode 100644\nindex 00000000000..e6c4e2f578e\n--- /dev/null\n+++ b/core/src/testFixtures/java/io/grpc/internal/MockServerTransportListener.java\n@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2025 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Attributes;\n+import io.grpc.Metadata;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link ServerTransportListener} that helps you write blocking unit tests.\n+ *\n+ * <p>TODO: Rename, since this is not actually a mock:\n+ * https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html\n+ */\n+public class MockServerTransportListener implements ServerTransportListener {\n+  public final ServerTransport transport;\n+  private final BlockingQueue<StreamCreation> streams = new LinkedBlockingQueue<>();\n+  private final SettableFuture<?> terminated = SettableFuture.create();\n+\n+  public MockServerTransportListener(ServerTransport transport) {\n+    this.transport = transport;\n+  }\n+\n+  @Override\n+  public void streamCreated(ServerStream stream, String method, Metadata headers) {\n+    ServerStreamListenerBase listener = new ServerStreamListenerBase();\n+    streams.add(new StreamCreation(stream, method, headers, listener));\n+    stream.setListener(listener);\n+  }\n+\n+  @Override\n+  public Attributes transportReady(Attributes attributes) {\n+    assertFalse(terminated.isDone());\n+    return attributes;\n+  }\n+\n+  @Override\n+  public void transportTerminated() {\n+    assertTrue(terminated.set(null));\n+  }\n+\n+  public boolean waitForTermination(long timeout, TimeUnit unit) throws InterruptedException {\n+    return AbstractTransportTest.waitForFuture(terminated, timeout, unit);\n+  }\n+\n+  public boolean isTerminated() {\n+    return terminated.isDone();\n+  }\n+\n+  public StreamCreation takeStreamOrFail(long timeout, TimeUnit unit) throws InterruptedException {\n+    StreamCreation stream = streams.poll(timeout, unit);\n+    if (stream == null) {\n+      fail(\"Timed out waiting for server stream\");\n+    }\n+    return stream;\n+  }\n+\n+  public static class StreamCreation {\n+    public final ServerStream stream;\n+    public final String method;\n+    public final Metadata headers;\n+    public final ServerStreamListenerBase listener;\n+\n+    public StreamCreation(\n+        ServerStream stream, String method, Metadata headers, ServerStreamListenerBase listener) {\n+      this.stream = stream;\n+      this.method = method;\n+      this.headers = headers;\n+      this.listener = listener;\n+    }\n+  }\n+}\n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/ServerStreamListenerBase.java b/core/src/testFixtures/java/io/grpc/internal/ServerStreamListenerBase.java\nnew file mode 100644\nindex 00000000000..b4ded80e5b2\n--- /dev/null\n+++ b/core/src/testFixtures/java/io/grpc/internal/ServerStreamListenerBase.java\n@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2025 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static org.junit.Assert.fail;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Status;\n+import java.io.InputStream;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link ServerStreamListener} that helps you write blocking unit tests.\n+ */\n+public class ServerStreamListenerBase implements ServerStreamListener {\n+  public final BlockingQueue<InputStream> messageQueue = new LinkedBlockingQueue<>();\n+  // Would have used Void instead of Object, but null elements are not allowed\n+  private final BlockingQueue<Object> readyQueue = new LinkedBlockingQueue<>();\n+  private final CountDownLatch halfClosedLatch = new CountDownLatch(1);\n+  private final SettableFuture<Status> status = SettableFuture.create();\n+\n+  public boolean awaitOnReady(int timeout, TimeUnit unit) throws Exception {\n+    return readyQueue.poll(timeout, unit) != null;\n+  }\n+\n+  public boolean awaitOnReadyAndDrain(int timeout, TimeUnit unit) throws Exception {\n+    if (!awaitOnReady(timeout, unit)) {\n+      return false;\n+    }\n+    // Throw the rest away\n+    readyQueue.drainTo(Lists.newArrayList());\n+    return true;\n+  }\n+\n+  public boolean awaitHalfClosed(int timeout, TimeUnit unit) throws Exception {\n+    return halfClosedLatch.await(timeout, unit);\n+  }\n+\n+  public Status awaitClose(int timeout, TimeUnit unit) throws Exception {\n+    return status.get(timeout, unit);\n+  }\n+\n+  @Override\n+  public void messagesAvailable(MessageProducer producer) {\n+    if (status.isDone()) {\n+      fail(\"messagesAvailable invoked after closed\");\n+    }\n+    InputStream message;\n+    while ((message = producer.next()) != null) {\n+      messageQueue.add(message);\n+    }\n+  }\n+\n+  @Override\n+  public void onReady() {\n+    if (status.isDone()) {\n+      fail(\"onReady invoked after closed\");\n+    }\n+    readyQueue.add(new Object());\n+  }\n+\n+  @Override\n+  public void halfClosed() {\n+    if (status.isDone()) {\n+      fail(\"halfClosed invoked after closed\");\n+    }\n+    halfClosedLatch.countDown();\n+  }\n+\n+  @Override\n+  public void closed(Status status) {\n+    if (this.status.isDone()) {\n+      fail(\"closed invoked more than once\");\n+    }\n+    this.status.set(status);\n+  }\n+}\n\ndiff --git a/inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java b/inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java\nindex 3ed8dd24ca9..d2220e05114 100644\n--- a/inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java\n+++ b/inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java\n@@ -36,10 +36,14 @@\n import io.grpc.StatusRuntimeException;\n import io.grpc.internal.AbstractTransportTest;\n import io.grpc.internal.ClientStream;\n+import io.grpc.internal.ClientStreamListenerBase;\n import io.grpc.internal.GrpcUtil;\n import io.grpc.internal.InternalServer;\n import io.grpc.internal.ManagedClientTransport;\n+import io.grpc.internal.MockServerTransportListener;\n+import io.grpc.internal.MockServerTransportListener.StreamCreation;\n import io.grpc.internal.ServerStream;\n+import io.grpc.internal.ServerStreamListenerBase;\n import io.grpc.internal.testing.TestStreamTracer;\n import io.grpc.stub.ClientCalls;\n import io.grpc.testing.GrpcCleanupRule;\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-12110",
    "pr_id": 12110,
    "issue_id": 11622,
    "repo": "grpc/grpc-java",
    "problem_statement": "OutlierDetection should use Ticker, not TimeProvider\nTimeProvider provides wall time. That can move forward and backward as time is adjusted. OutlierDetection is measuring durations, so it should use a monotonic clock. We use Ticker (either Guava's or Deadline's, but generally Guava's) for that. FakeClock supports both for testing.\r\n\r\nDoing a quick audit, this seems to be the only present incorrect use of TimeProvider.\r\n\r\nI feel like I noticed this before, but I don't know why I didn't change it at the time. Maybe I had wanted to change the weird `Long` usage as well. (E.g., `EPOCH = currentTimeNanos() - 1` and use EPOCH instead of `null`.)\r\n\r\nCC @kannanjgithub ",
    "issue_word_count": 112,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java",
      "util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancerProvider.java",
      "util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java"
    ],
    "pr_changed_test_files": [
      "util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java"
    ],
    "base_commit": "6cc2ff1cedc8a64c4494e62f2ea5f25bb129c7fe",
    "head_commit": "e336fa64faa939b8c41f059510fcd93ce68ed4d6",
    "repo_url": "https://github.com/grpc/grpc-java/pull/12110",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/12110",
    "dockerfile": "",
    "pr_merged_at": "2025-06-16T14:47:36.000Z",
    "patch": "diff --git a/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java b/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java\nindex bd9faef3f99..d7353ec7d58 100644\n--- a/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java\n+++ b/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java\n@@ -22,6 +22,7 @@\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Ticker;\n import com.google.common.collect.ForwardingMap;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n@@ -39,7 +40,6 @@\n import io.grpc.Status;\n import io.grpc.SynchronizationContext;\n import io.grpc.SynchronizationContext.ScheduledHandle;\n-import io.grpc.internal.TimeProvider;\n import java.net.SocketAddress;\n import java.util.ArrayList;\n import java.util.Collection;\n@@ -82,7 +82,7 @@ public final class OutlierDetectionLoadBalancer extends LoadBalancer {\n   private final SynchronizationContext syncContext;\n   private final Helper childHelper;\n   private final GracefulSwitchLoadBalancer switchLb;\n-  private TimeProvider timeProvider;\n+  private Ticker ticker;\n   private final ScheduledExecutorService timeService;\n   private ScheduledHandle detectionTimerHandle;\n   private Long detectionTimerStartNanos;\n@@ -95,14 +95,14 @@ public final class OutlierDetectionLoadBalancer extends LoadBalancer {\n   /**\n    * Creates a new instance of {@link OutlierDetectionLoadBalancer}.\n    */\n-  public OutlierDetectionLoadBalancer(Helper helper, TimeProvider timeProvider) {\n+  public OutlierDetectionLoadBalancer(Helper helper, Ticker ticker) {\n     logger = helper.getChannelLogger();\n     childHelper = new ChildHelper(checkNotNull(helper, \"helper\"));\n     switchLb = new GracefulSwitchLoadBalancer(childHelper);\n     endpointTrackerMap = new EndpointTrackerMap();\n     this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n     this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n-    this.timeProvider = timeProvider;\n+    this.ticker = ticker;\n     logger.log(ChannelLogLevel.DEBUG, \"OutlierDetection lb created.\");\n   }\n \n@@ -151,7 +151,7 @@ public Status acceptResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n         // If a timer has started earlier we cancel it and use the difference between the start\n         // time and now as the interval.\n         initialDelayNanos = Math.max(0L,\n-            config.intervalNanos - (timeProvider.currentTimeNanos() - detectionTimerStartNanos));\n+            config.intervalNanos - (ticker.read() - detectionTimerStartNanos));\n       }\n \n       // If a timer has been previously created we need to cancel it and reset all the call counters\n@@ -201,7 +201,7 @@ class DetectionTimer implements Runnable {\n \n     @Override\n     public void run() {\n-      detectionTimerStartNanos = timeProvider.currentTimeNanos();\n+      detectionTimerStartNanos = ticker.read();\n \n       endpointTrackerMap.swapCounters();\n \n@@ -638,7 +638,7 @@ public boolean maxEjectionTimeElapsed(long currentTimeNanos) {\n               config.baseEjectionTimeNanos * ejectionTimeMultiplier,\n               maxEjectionDurationSecs);\n \n-      return currentTimeNanos > maxEjectionTimeNanos;\n+      return currentTimeNanos - maxEjectionTimeNanos > 0;\n     }\n \n     /** Tracks both successful and failed call counts. */\n\ndiff --git a/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancerProvider.java b/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancerProvider.java\nindex b35e1144581..c76d68a03de 100644\n--- a/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancerProvider.java\n+++ b/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancerProvider.java\n@@ -16,6 +16,7 @@\n \n package io.grpc.util;\n \n+import com.google.common.base.Ticker;\n import io.grpc.Internal;\n import io.grpc.LoadBalancer;\n import io.grpc.LoadBalancer.Helper;\n@@ -23,7 +24,6 @@\n import io.grpc.NameResolver.ConfigOrError;\n import io.grpc.Status;\n import io.grpc.internal.JsonUtil;\n-import io.grpc.internal.TimeProvider;\n import io.grpc.util.OutlierDetectionLoadBalancer.OutlierDetectionLoadBalancerConfig;\n import io.grpc.util.OutlierDetectionLoadBalancer.OutlierDetectionLoadBalancerConfig.FailurePercentageEjection;\n import io.grpc.util.OutlierDetectionLoadBalancer.OutlierDetectionLoadBalancerConfig.SuccessRateEjection;\n@@ -34,7 +34,7 @@ public final class OutlierDetectionLoadBalancerProvider extends LoadBalancerProv\n \n   @Override\n   public LoadBalancer newLoadBalancer(Helper helper) {\n-    return new OutlierDetectionLoadBalancer(helper, TimeProvider.SYSTEM_TIME_PROVIDER);\n+    return new OutlierDetectionLoadBalancer(helper, Ticker.systemTicker());\n   }\n \n   @Override\n",
    "test_patch": "diff --git a/util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java b/util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java\nindex d81740e116a..c4eb4c7bae5 100644\n--- a/util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java\n+++ b/util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java\n@@ -227,7 +227,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {\n     when(mockStreamTracerFactory.newClientStreamTracer(any(),\n         any())).thenReturn(mockStreamTracer);\n \n-    loadBalancer = new OutlierDetectionLoadBalancer(mockHelper, fakeClock.getTimeProvider());\n+    loadBalancer = new OutlierDetectionLoadBalancer(mockHelper, fakeClock.getTicker());\n   }\n \n   @Test\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-12103",
    "pr_id": 12103,
    "issue_id": 7467,
    "repo": "grpc/grpc-java",
    "problem_statement": "JUnit ExpectedException is deprecated\nIn JUnit 4.13 ExpectedException is deprecated. The replacement, `assertThrows`, is Java 8-centric and would be annoying to use in the short-term. Using try+fail would increase boilerplate and would be worse than just using ExpectedException.\r\n\r\nWe can `@SuppressWarnings` for now, but we should swap to assertThrows (or Truth's variant) in the future once we can use Java 8 in our tests.",
    "issue_word_count": 69,
    "test_files_count": 14,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "netty/src/test/java/io/grpc/netty/NettyChannelBuilderTest.java",
      "netty/src/test/java/io/grpc/netty/NettyServerBuilderTest.java",
      "netty/src/test/java/io/grpc/netty/ProtocolNegotiatorsTest.java",
      "okhttp/src/test/java/io/grpc/okhttp/OkHttpChannelBuilderTest.java",
      "okhttp/src/test/java/io/grpc/okhttp/OkHttpProtocolNegotiatorTest.java",
      "okhttp/src/test/java/io/grpc/okhttp/UtilsTest.java",
      "protobuf-lite/src/test/java/io/grpc/protobuf/lite/ProtoLiteUtilsTest.java",
      "testing/src/test/java/io/grpc/testing/GrpcCleanupRuleTest.java",
      "util/src/test/java/io/grpc/util/GracefulSwitchLoadBalancerTest.java",
      "xds/src/test/java/io/grpc/xds/GrpcBootstrapperImplTest.java",
      "xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java",
      "xds/src/test/java/io/grpc/xds/PriorityLoadBalancerProviderTest.java",
      "xds/src/test/java/io/grpc/xds/SharedXdsClientPoolProviderTest.java",
      "xds/src/test/java/io/grpc/xds/WeightedRandomPickerTest.java"
    ],
    "pr_changed_test_files": [
      "netty/src/test/java/io/grpc/netty/NettyChannelBuilderTest.java",
      "netty/src/test/java/io/grpc/netty/NettyServerBuilderTest.java",
      "netty/src/test/java/io/grpc/netty/ProtocolNegotiatorsTest.java",
      "okhttp/src/test/java/io/grpc/okhttp/OkHttpChannelBuilderTest.java",
      "okhttp/src/test/java/io/grpc/okhttp/OkHttpProtocolNegotiatorTest.java",
      "okhttp/src/test/java/io/grpc/okhttp/UtilsTest.java",
      "protobuf-lite/src/test/java/io/grpc/protobuf/lite/ProtoLiteUtilsTest.java",
      "testing/src/test/java/io/grpc/testing/GrpcCleanupRuleTest.java",
      "util/src/test/java/io/grpc/util/GracefulSwitchLoadBalancerTest.java",
      "xds/src/test/java/io/grpc/xds/GrpcBootstrapperImplTest.java",
      "xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java",
      "xds/src/test/java/io/grpc/xds/PriorityLoadBalancerProviderTest.java",
      "xds/src/test/java/io/grpc/xds/SharedXdsClientPoolProviderTest.java",
      "xds/src/test/java/io/grpc/xds/WeightedRandomPickerTest.java"
    ],
    "base_commit": "46485c8b62778f1b581019ef19e67dd8de937ca3",
    "head_commit": "ed8d97825b2680312f2b3044d0f6cd5dd3e11253",
    "repo_url": "https://github.com/grpc/grpc-java/pull/12103",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/12103",
    "dockerfile": "",
    "pr_merged_at": "2025-05-30T05:25:37.000Z",
    "patch": "",
    "test_patch": "diff --git a/netty/src/test/java/io/grpc/netty/NettyChannelBuilderTest.java b/netty/src/test/java/io/grpc/netty/NettyChannelBuilderTest.java\nindex 5789d275c07..95d54d13b82 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyChannelBuilderTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyChannelBuilderTest.java\n@@ -19,6 +19,7 @@\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.Mockito.mock;\n \n@@ -39,17 +40,13 @@\n import java.net.SocketAddress;\n import java.util.concurrent.TimeUnit;\n import javax.net.ssl.SSLException;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n @RunWith(JUnit4.class)\n public class NettyChannelBuilderTest {\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n   private final SslContext noSslContext = null;\n \n   private void shutdown(ManagedChannel mc) throws Exception {\n@@ -107,10 +104,9 @@ private void overrideAuthorityIsReadableHelper(NettyChannelBuilder builder,\n   public void failOverrideInvalidAuthority() {\n     NettyChannelBuilder builder = new NettyChannelBuilder(getTestSocketAddress());\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Invalid authority:\");\n-\n-    builder.overrideAuthority(\"[invalidauthority\");\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.overrideAuthority(\"[invalidauthority\"));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Invalid authority: [invalidauthority\");\n   }\n \n   @Test\n@@ -128,20 +124,18 @@ public void enableCheckAuthorityFailOverrideInvalidAuthority() {\n     NettyChannelBuilder builder = new NettyChannelBuilder(getTestSocketAddress())\n         .disableCheckAuthority()\n         .enableCheckAuthority();\n-\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Invalid authority:\");\n-    builder.overrideAuthority(\"[invalidauthority\");\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.overrideAuthority(\"[invalidauthority\"));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Invalid authority: [invalidauthority\");\n   }\n \n   @Test\n   public void failInvalidAuthority() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Invalid host or port\");\n-\n     @SuppressWarnings(\"AddressSelection\") // We actually expect zero addresses!\n-    Object unused =\n-        NettyChannelBuilder.forAddress(new InetSocketAddress(\"invalid_authority\", 1234));\n+    InetSocketAddress address = new InetSocketAddress(\"invalid_authority\", 1234);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> NettyChannelBuilder.forAddress(address));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Invalid host or port: invalid_authority 1234\");\n   }\n \n   @Test\n@@ -155,10 +149,10 @@ public void failIfSslContextIsNotClient() {\n     SslContext sslContext = mock(SslContext.class);\n     NettyChannelBuilder builder = new NettyChannelBuilder(getTestSocketAddress());\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Server SSL context can not be used for client channel\");\n-\n-    builder.sslContext(sslContext);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.sslContext(sslContext));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Server SSL context can not be used for client channel\");\n   }\n \n   @Test\n@@ -166,10 +160,10 @@ public void failNegotiationTypeWithChannelCredentials_target() {\n     NettyChannelBuilder builder = NettyChannelBuilder.forTarget(\n         \"fakeTarget\", InsecureChannelCredentials.create());\n \n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\"Cannot change security when using ChannelCredentials\");\n-\n-    builder.negotiationType(NegotiationType.TLS);\n+    IllegalStateException e = assertThrows(IllegalStateException.class,\n+        () -> builder.negotiationType(NegotiationType.TLS));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Cannot change security when using ChannelCredentials\");\n   }\n \n   @Test\n@@ -177,10 +171,10 @@ public void failNegotiationTypeWithChannelCredentials_socketAddress() {\n     NettyChannelBuilder builder = NettyChannelBuilder.forAddress(\n         getTestSocketAddress(), InsecureChannelCredentials.create());\n \n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\"Cannot change security when using ChannelCredentials\");\n-\n-    builder.negotiationType(NegotiationType.TLS);\n+    IllegalStateException e = assertThrows(IllegalStateException.class,\n+        () -> builder.negotiationType(NegotiationType.TLS));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Cannot change security when using ChannelCredentials\");\n   }\n \n   @Test\n@@ -205,10 +199,9 @@ public void createProtocolNegotiatorByType_plaintextUpgrade() {\n \n   @Test\n   public void createProtocolNegotiatorByType_tlsWithNoContext() {\n-    thrown.expect(NullPointerException.class);\n-    NettyChannelBuilder.createProtocolNegotiatorByType(\n-        NegotiationType.TLS,\n-        noSslContext, null);\n+    assertThrows(NullPointerException.class,\n+        () -> NettyChannelBuilder.createProtocolNegotiatorByType(\n+            NegotiationType.TLS, noSslContext, null));\n   }\n \n   @Test\n@@ -245,38 +238,40 @@ public void createProtocolNegotiatorByType_tlsWithAuthorityFallback() throws SSL\n   public void negativeKeepAliveTime() {\n     NettyChannelBuilder builder = NettyChannelBuilder.forTarget(\"fakeTarget\");\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"keepalive time must be positive\");\n-    builder.keepAliveTime(-1L, TimeUnit.HOURS);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.keepAliveTime(-1L, TimeUnit.HOURS));\n+    assertThat(e).hasMessageThat().isEqualTo(\"keepalive time must be positive\");\n   }\n \n   @Test\n   public void negativeKeepAliveTimeout() {\n     NettyChannelBuilder builder = NettyChannelBuilder.forTarget(\"fakeTarget\");\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"keepalive timeout must be positive\");\n-    builder.keepAliveTimeout(-1L, TimeUnit.HOURS);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.keepAliveTimeout(-1L, TimeUnit.HOURS));\n+    assertThat(e).hasMessageThat().isEqualTo(\"keepalive timeout must be positive\");\n   }\n \n   @Test\n   public void assertEventLoopAndChannelType_onlyGroupProvided() {\n     NettyChannelBuilder builder = NettyChannelBuilder.forTarget(\"fakeTarget\");\n     builder.eventLoopGroup(mock(EventLoopGroup.class));\n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\"Both EventLoopGroup and ChannelType should be provided\");\n \n-    builder.assertEventLoopAndChannelType();\n+    IllegalStateException e = assertThrows(IllegalStateException.class,\n+        builder::assertEventLoopAndChannelType);\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Both EventLoopGroup and ChannelType should be provided or neither should be\");\n   }\n \n   @Test\n   public void assertEventLoopAndChannelType_onlyTypeProvided() {\n     NettyChannelBuilder builder = NettyChannelBuilder.forTarget(\"fakeTarget\");\n     builder.channelType(LocalChannel.class, LocalAddress.class);\n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\"Both EventLoopGroup and ChannelType should be provided\");\n \n-    builder.assertEventLoopAndChannelType();\n+    IllegalStateException e = assertThrows(IllegalStateException.class,\n+        builder::assertEventLoopAndChannelType);\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Both EventLoopGroup and ChannelType should be provided or neither should be\");\n   }\n \n   @Test\n@@ -288,10 +283,11 @@ public Channel newChannel() {\n         return null;\n       }\n     });\n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\"Both EventLoopGroup and ChannelType should be provided\");\n \n-    builder.assertEventLoopAndChannelType();\n+    IllegalStateException e = assertThrows(IllegalStateException.class,\n+        builder::assertEventLoopAndChannelType);\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Both EventLoopGroup and ChannelType should be provided or neither should be\");\n   }\n \n   @Test\n\ndiff --git a/netty/src/test/java/io/grpc/netty/NettyServerBuilderTest.java b/netty/src/test/java/io/grpc/netty/NettyServerBuilderTest.java\nindex 48af23b78a8..797cfa95c0e 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyServerBuilderTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyServerBuilderTest.java\n@@ -16,20 +16,19 @@\n \n package io.grpc.netty;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertThrows;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n import com.google.common.collect.ImmutableList;\n-import com.google.common.truth.Truth;\n import io.grpc.ServerStreamTracer;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.local.LocalServerChannel;\n import io.netty.handler.ssl.SslContext;\n import java.net.InetSocketAddress;\n import java.util.concurrent.TimeUnit;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n@@ -39,9 +38,6 @@\n @RunWith(JUnit4.class)\n public class NettyServerBuilderTest {\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n-\n   private NettyServerBuilder builder = NettyServerBuilder.forPort(8080);\n \n   @Test\n@@ -50,7 +46,7 @@ public void addMultipleListenAddresses() {\n     NettyServer server =\n         builder.buildTransportServers(ImmutableList.<ServerStreamTracer.Factory>of());\n \n-    Truth.assertThat(server.getListenSocketAddresses()).hasSize(2);\n+    assertThat(server.getListenSocketAddresses()).hasSize(2);\n   }\n \n   @Test\n@@ -63,121 +59,112 @@ public void failIfSslContextIsNotServer() {\n     SslContext sslContext = mock(SslContext.class);\n     when(sslContext.isClient()).thenReturn(true);\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Client SSL context can not be used for server\");\n-    builder.sslContext(sslContext);\n+    IllegalArgumentException e = assertThrows(\n+        IllegalArgumentException.class, () -> builder.sslContext(sslContext));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Client SSL context can not be used for server\");\n   }\n \n   @Test\n   public void failIfKeepAliveTimeNegative() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"keepalive time must be positive\");\n-\n-    builder.keepAliveTime(-10L, TimeUnit.HOURS);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.keepAliveTime(-10L, TimeUnit.HOURS));\n+    assertThat(e).hasMessageThat().isEqualTo(\"keepalive time must be positive：-10\");\n   }\n \n   @Test\n   public void failIfKeepAliveTimeoutNegative() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"keepalive timeout must be positive\");\n-\n-    builder.keepAliveTimeout(-10L, TimeUnit.HOURS);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.keepAliveTimeout(-10L, TimeUnit.HOURS));\n+    assertThat(e).hasMessageThat().isEqualTo(\"keepalive timeout must be positive: -10\");\n   }\n \n   @Test\n   public void failIfMaxConcurrentCallsPerConnectionNegative() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"max must be positive\");\n-\n-    builder.maxConcurrentCallsPerConnection(0);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.maxConcurrentCallsPerConnection(0));\n+    assertThat(e).hasMessageThat().isEqualTo(\"max must be positive: 0\");\n   }\n \n   @Test\n   public void failIfMaxInboundMetadataSizeNonPositive() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"maxInboundMetadataSize must be positive\");\n-\n-    builder.maxInboundMetadataSize(0);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.maxInboundMetadataSize(0));\n+    assertThat(e).hasMessageThat().isEqualTo(\"maxInboundMetadataSize must be positive: 0\");\n   }\n \n   @Test\n   public void failIfSoftInboundMetadataSizeNonPositive() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"softLimitHeaderListSize must be positive\");\n-\n-    builder.maxInboundMetadataSize(0, 100);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.maxInboundMetadataSize(0, 100));\n+    assertThat(e).hasMessageThat().isEqualTo(\"softLimitHeaderListSize must be positive: 0\");\n   }\n \n   @Test\n   public void failIfMaxInboundMetadataSizeSmallerThanSoft() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"must be greater than softLimitHeaderListSize\");\n-\n-    builder.maxInboundMetadataSize(100, 80);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.maxInboundMetadataSize(100, 80));\n+    assertThat(e).hasMessageThat().isEqualTo(\"maxInboundMetadataSize: 80 \"\n+        + \"must be greater than softLimitHeaderListSize: 100\");\n   }\n \n   @Test\n   public void failIfMaxConnectionIdleNegative() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"max connection idle must be positive\");\n-\n-    builder.maxConnectionIdle(-1, TimeUnit.HOURS);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.maxConnectionIdle(-1, TimeUnit.HOURS));\n+    assertThat(e).hasMessageThat().isEqualTo(\"max connection idle must be positive: -1\");\n   }\n \n   @Test\n   public void failIfMaxConnectionAgeNegative() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"max connection age must be positive\");\n-\n-    builder.maxConnectionAge(-1, TimeUnit.HOURS);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.maxConnectionAge(-1, TimeUnit.HOURS));\n+    assertThat(e).hasMessageThat().isEqualTo(\"max connection age must be positive: -1\");\n   }\n \n   @Test\n   public void failIfMaxConnectionAgeGraceNegative() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"max connection age grace must be non-negative\");\n-\n-    builder.maxConnectionAgeGrace(-1, TimeUnit.HOURS);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.maxConnectionAgeGrace(-1, TimeUnit.HOURS));\n+    assertThat(e).hasMessageThat().isEqualTo(\"max connection age grace must be non-negative: -1\");\n   }\n \n   @Test\n   public void failIfPermitKeepAliveTimeNegative() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"permit keepalive time must be non-negative\");\n-\n-    builder.permitKeepAliveTime(-1, TimeUnit.HOURS);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.permitKeepAliveTime(-1, TimeUnit.HOURS));\n+    assertThat(e).hasMessageThat().isEqualTo(\"permit keepalive time must be non-negative: -1\");\n   }\n \n   @Test\n   public void assertEventLoopsAndChannelType_onlyBossGroupProvided() {\n     EventLoopGroup mockEventLoopGroup = mock(EventLoopGroup.class);\n     builder.bossEventLoopGroup(mockEventLoopGroup);\n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\n-        \"All of BossEventLoopGroup, WorkerEventLoopGroup and ChannelType should be provided\");\n-\n-    builder.assertEventLoopsAndChannelType();\n+    IllegalStateException e = assertThrows(IllegalStateException.class,\n+        builder::assertEventLoopsAndChannelType);\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"All of BossEventLoopGroup, WorkerEventLoopGroup and ChannelType should be provided \"\n+            + \"or neither should be\");\n   }\n \n   @Test\n   public void assertEventLoopsAndChannelType_onlyWorkerGroupProvided() {\n     EventLoopGroup mockEventLoopGroup = mock(EventLoopGroup.class);\n     builder.workerEventLoopGroup(mockEventLoopGroup);\n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\n-        \"All of BossEventLoopGroup, WorkerEventLoopGroup and ChannelType should be provided\");\n-\n-    builder.assertEventLoopsAndChannelType();\n+    IllegalStateException e = assertThrows(IllegalStateException.class,\n+        builder::assertEventLoopsAndChannelType);\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"All of BossEventLoopGroup, WorkerEventLoopGroup and ChannelType should be provided \"\n+            + \"or neither should be\");\n   }\n \n   @Test\n   public void assertEventLoopsAndChannelType_onlyTypeProvided() {\n     builder.channelType(LocalServerChannel.class);\n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\n-        \"All of BossEventLoopGroup, WorkerEventLoopGroup and ChannelType should be provided\");\n-\n-    builder.assertEventLoopsAndChannelType();\n+    IllegalStateException e = assertThrows(IllegalStateException.class,\n+        builder::assertEventLoopsAndChannelType);\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"All of BossEventLoopGroup, WorkerEventLoopGroup and ChannelType should be provided \"\n+            + \"or neither should be\");\n   }\n \n   @Test\n\ndiff --git a/netty/src/test/java/io/grpc/netty/ProtocolNegotiatorsTest.java b/netty/src/test/java/io/grpc/netty/ProtocolNegotiatorsTest.java\nindex 4829bcc7419..638fe960a32 100644\n--- a/netty/src/test/java/io/grpc/netty/ProtocolNegotiatorsTest.java\n+++ b/netty/src/test/java/io/grpc/netty/ProtocolNegotiatorsTest.java\n@@ -24,6 +24,7 @@\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n@@ -146,7 +147,6 @@\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.DisableOnDebug;\n-import org.junit.rules.ExpectedException;\n import org.junit.rules.TestRule;\n import org.junit.rules.Timeout;\n import org.junit.runner.RunWith;\n@@ -174,8 +174,6 @@ public static void loadCerts() throws Exception {\n \n   private static final int TIMEOUT_SECONDS = 60;\n   @Rule public final TestRule globalTimeout = new DisableOnDebug(Timeout.seconds(TIMEOUT_SECONDS));\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n \n   private final EventLoopGroup group = new DefaultEventLoop();\n   private Channel chan;\n@@ -714,11 +712,10 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n   }\n \n   @Test\n-  public void tlsHandler_failsOnNullEngine() throws Exception {\n-    thrown.expect(NullPointerException.class);\n-    thrown.expectMessage(\"ssl\");\n-\n-    Object unused = ProtocolNegotiators.serverTls(null);\n+  public void tlsHandler_failsOnNullEngine() {\n+    NullPointerException e = assertThrows(NullPointerException.class,\n+        () -> ProtocolNegotiators.serverTls(null));\n+    assertThat(e).hasMessageThat().isEqualTo(\"sslContext\");\n   }\n \n \n@@ -1058,9 +1055,8 @@ public boolean isLoggable(LogRecord record) {\n \n   @Test\n   public void tls_failsOnNullSslContext() {\n-    thrown.expect(NullPointerException.class);\n-\n-    Object unused = ProtocolNegotiators.tls(null, null);\n+    assertThrows(NullPointerException.class,\n+        () -> ProtocolNegotiators.tls(null, null));\n   }\n \n   @Test\n@@ -1090,17 +1086,16 @@ public void tls_invalidHost() throws SSLException {\n   }\n \n   @Test\n-  public void httpProxy_nullAddressNpe() throws Exception {\n-    thrown.expect(NullPointerException.class);\n-    Object unused =\n-        ProtocolNegotiators.httpProxy(null, \"user\", \"pass\", ProtocolNegotiators.plaintext());\n+  public void httpProxy_nullAddressNpe() {\n+    assertThrows(NullPointerException.class,\n+        () -> ProtocolNegotiators.httpProxy(null, \"user\", \"pass\", ProtocolNegotiators.plaintext()));\n   }\n \n   @Test\n-  public void httpProxy_nullNegotiatorNpe() throws Exception {\n-    thrown.expect(NullPointerException.class);\n-    Object unused = ProtocolNegotiators.httpProxy(\n-        InetSocketAddress.createUnresolved(\"localhost\", 80), \"user\", \"pass\", null);\n+  public void httpProxy_nullNegotiatorNpe() {\n+    assertThrows(NullPointerException.class,\n+        () -> ProtocolNegotiators.httpProxy(\n+            InetSocketAddress.createUnresolved(\"localhost\", 80), \"user\", \"pass\", null));\n   }\n \n   @Test\n@@ -1218,9 +1213,8 @@ public void httpProxy_500() throws Exception {\n     assertFalse(negotiationFuture.isDone());\n     String response = \"HTTP/1.1 500 OMG\\r\\nContent-Length: 4\\r\\n\\r\\noops\";\n     serverContext.writeAndFlush(bb(response, serverContext.channel())).sync();\n-    thrown.expect(ProxyConnectException.class);\n     try {\n-      negotiationFuture.sync();\n+      assertThrows(ProxyConnectException.class, negotiationFuture::sync);\n     } finally {\n       channel.close();\n     }\n\ndiff --git a/okhttp/src/test/java/io/grpc/okhttp/OkHttpChannelBuilderTest.java b/okhttp/src/test/java/io/grpc/okhttp/OkHttpChannelBuilderTest.java\nindex c86e80656e3..89d37536b70 100644\n--- a/okhttp/src/test/java/io/grpc/okhttp/OkHttpChannelBuilderTest.java\n+++ b/okhttp/src/test/java/io/grpc/okhttp/OkHttpChannelBuilderTest.java\n@@ -22,6 +22,7 @@\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n import static org.mockito.Mockito.mock;\n \n import com.google.common.util.concurrent.SettableFuture;\n@@ -57,7 +58,6 @@\n import javax.security.auth.x500.X500Principal;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n@@ -67,8 +67,6 @@\n @RunWith(JUnit4.class)\n public class OkHttpChannelBuilderTest {\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n   @Rule public final GrpcCleanupRule grpcCleanupRule = new GrpcCleanupRule();\n \n   @Test\n@@ -100,10 +98,9 @@ private void overrideAuthorityIsReadableHelper(OkHttpChannelBuilder builder,\n   @Test\n   public void failOverrideInvalidAuthority() {\n     OkHttpChannelBuilder builder = OkHttpChannelBuilder.forAddress(\"good\", 1234);\n-\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Invalid authority:\");\n-    builder.overrideAuthority(\"[invalidauthority\");\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.overrideAuthority(\"[invalidauthority\"));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Invalid authority: [invalidauthority\");\n   }\n \n   @Test\n@@ -119,17 +116,16 @@ public void enableCheckAuthorityFailOverrideInvalidAuthority() {\n         .disableCheckAuthority()\n         .enableCheckAuthority();\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Invalid authority:\");\n-    builder.overrideAuthority(\"[invalidauthority\");\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.overrideAuthority(\"[invalidauthority\"));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Invalid authority: [invalidauthority\");\n   }\n \n   @Test\n   public void failInvalidAuthority() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Invalid host or port\");\n-\n-    OkHttpChannelBuilder.forAddress(\"invalid_authority\", 1234);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> OkHttpChannelBuilder.forAddress(\"invalid_authority\", 1234));\n+    assertThat(e.getMessage()).isEqualTo(\"Invalid host or port: invalid_authority 1234\");\n   }\n \n   @Test\n@@ -396,10 +392,10 @@ public ChannelCredentials withoutBearerTokens() {\n \n   @Test\n   public void failForUsingClearTextSpecDirectly() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"plaintext ConnectionSpec is not accepted\");\n-\n-    OkHttpChannelBuilder.forAddress(\"host\", 1234).connectionSpec(ConnectionSpec.CLEARTEXT);\n+    OkHttpChannelBuilder builder = OkHttpChannelBuilder.forAddress(\"host\", 1234);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.connectionSpec(ConnectionSpec.CLEARTEXT));\n+    assertThat(e).hasMessageThat().isEqualTo(\"plaintext ConnectionSpec is not accepted\");\n   }\n \n   @Test\n\ndiff --git a/okhttp/src/test/java/io/grpc/okhttp/OkHttpProtocolNegotiatorTest.java b/okhttp/src/test/java/io/grpc/okhttp/OkHttpProtocolNegotiatorTest.java\nindex cc9f30862af..4353dc2597b 100644\n--- a/okhttp/src/test/java/io/grpc/okhttp/OkHttpProtocolNegotiatorTest.java\n+++ b/okhttp/src/test/java/io/grpc/okhttp/OkHttpProtocolNegotiatorTest.java\n@@ -16,10 +16,12 @@\n \n package io.grpc.okhttp;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertThrows;\n import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.doThrow;\n import static org.mockito.Mockito.mock;\n@@ -37,9 +39,7 @@\n import javax.net.ssl.SSLParameters;\n import javax.net.ssl.SSLSession;\n import javax.net.ssl.SSLSocket;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.ArgumentMatchers;\n@@ -49,9 +49,6 @@\n  */\n @RunWith(JUnit4.class)\n public class OkHttpProtocolNegotiatorTest {\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n-\n   private final SSLSocket sock = mock(SSLSocket.class);\n   private final Platform platform = mock(Platform.class);\n \n@@ -118,21 +115,19 @@ public void negotiate_handshakeFails() throws IOException {\n     OkHttpProtocolNegotiator negotiator = OkHttpProtocolNegotiator.get();\n     doReturn(parameters).when(sock).getSSLParameters();\n     doThrow(new IOException()).when(sock).startHandshake();\n-    thrown.expect(IOException.class);\n-\n-    negotiator.negotiate(sock, \"hostname\", ImmutableList.of(Protocol.HTTP_2));\n+    assertThrows(IOException.class,\n+        () -> negotiator.negotiate(sock, \"hostname\", ImmutableList.of(Protocol.HTTP_2)));\n   }\n \n   @Test\n-  public void negotiate_noSelectedProtocol() throws Exception {\n+  public void negotiate_noSelectedProtocol() {\n     Platform platform = mock(Platform.class);\n \n     OkHttpProtocolNegotiator negotiator = new OkHttpProtocolNegotiator(platform);\n \n-    thrown.expect(RuntimeException.class);\n-    thrown.expectMessage(\"TLS ALPN negotiation failed\");\n-\n-    negotiator.negotiate(sock, \"hostname\", ImmutableList.of(Protocol.HTTP_2));\n+    RuntimeException e = assertThrows(RuntimeException.class,\n+        () -> negotiator.negotiate(sock, \"hostname\", ImmutableList.of(Protocol.HTTP_2)));\n+    assertThat(e).hasMessageThat().isEqualTo(\"TLS ALPN negotiation failed with protocols: [h2]\");\n   }\n \n   @Test\n@@ -150,7 +145,7 @@ public void negotiate_success() throws Exception {\n \n   // Checks that the super class is properly invoked.\n   @Test\n-  public void negotiate_android_handshakeFails() throws Exception {\n+  public void negotiate_android_handshakeFails() {\n     when(platform.getTlsExtensionType()).thenReturn(TlsExtensionType.ALPN_AND_NPN);\n     AndroidNegotiator negotiator = new AndroidNegotiator(platform);\n \n@@ -161,10 +156,9 @@ public void startHandshake() throws IOException {\n       }\n     };\n \n-    thrown.expect(IOException.class);\n-    thrown.expectMessage(\"expected\");\n-\n-    negotiator.negotiate(androidSock, \"hostname\", ImmutableList.of(Protocol.HTTP_2));\n+    IOException e = assertThrows(IOException.class,\n+        () -> negotiator.negotiate(androidSock, \"hostname\", ImmutableList.of(Protocol.HTTP_2)));\n+    assertThat(e).hasMessageThat().isEqualTo(\"expected\");\n   }\n \n   @VisibleForTesting\n\ndiff --git a/okhttp/src/test/java/io/grpc/okhttp/UtilsTest.java b/okhttp/src/test/java/io/grpc/okhttp/UtilsTest.java\nindex ede8511ee70..1c97e027b4a 100644\n--- a/okhttp/src/test/java/io/grpc/okhttp/UtilsTest.java\n+++ b/okhttp/src/test/java/io/grpc/okhttp/UtilsTest.java\n@@ -16,7 +16,9 @@\n \n package io.grpc.okhttp;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n \n import io.grpc.InternalChannelz.SocketOptions;\n@@ -26,9 +28,7 @@\n import java.net.Socket;\n import java.util.List;\n import java.util.Locale;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n@@ -38,16 +38,12 @@\n @RunWith(JUnit4.class)\n public class UtilsTest {\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n-\n   @Test\n   public void convertSpecRejectsPlaintext() {\n     com.squareup.okhttp.ConnectionSpec plaintext = com.squareup.okhttp.ConnectionSpec.CLEARTEXT;\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"plaintext ConnectionSpec is not accepted\");\n-    Utils.convertSpec(plaintext);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> Utils.convertSpec(plaintext));\n+    assertThat(e).hasMessageThat().isEqualTo(\"plaintext ConnectionSpec is not accepted\");\n   }\n \n   @Test\n\ndiff --git a/protobuf-lite/src/test/java/io/grpc/protobuf/lite/ProtoLiteUtilsTest.java b/protobuf-lite/src/test/java/io/grpc/protobuf/lite/ProtoLiteUtilsTest.java\nindex 5c25cb3b309..204264b016d 100644\n--- a/protobuf-lite/src/test/java/io/grpc/protobuf/lite/ProtoLiteUtilsTest.java\n+++ b/protobuf-lite/src/test/java/io/grpc/protobuf/lite/ProtoLiteUtilsTest.java\n@@ -16,6 +16,7 @@\n \n package io.grpc.protobuf.lite;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotNull;\n@@ -43,9 +44,7 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Arrays;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n@@ -53,9 +52,6 @@\n @RunWith(JUnit4.class)\n public class ProtoLiteUtilsTest {\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n-\n   private final Marshaller<Type> marshaller = ProtoLiteUtils.marshaller(Type.getDefaultInstance());\n   private Type proto = Type.newBuilder().setName(\"name\").build();\n \n@@ -214,10 +210,9 @@ public void metadataMarshaller_invalid() {\n \n   @Test\n   public void extensionRegistry_notNull() {\n-    thrown.expect(NullPointerException.class);\n-    thrown.expectMessage(\"newRegistry\");\n-\n-    ProtoLiteUtils.setExtensionRegistry(null);\n+    NullPointerException e = assertThrows(NullPointerException.class,\n+        () -> ProtoLiteUtils.setExtensionRegistry(null));\n+    assertThat(e).hasMessageThat().isEqualTo(\"newRegistry\");\n   }\n \n   @Test\n\ndiff --git a/testing/src/test/java/io/grpc/testing/GrpcCleanupRuleTest.java b/testing/src/test/java/io/grpc/testing/GrpcCleanupRuleTest.java\nindex a5a6783d53f..8eb3edd3825 100644\n--- a/testing/src/test/java/io/grpc/testing/GrpcCleanupRuleTest.java\n+++ b/testing/src/test/java/io/grpc/testing/GrpcCleanupRuleTest.java\n@@ -18,6 +18,7 @@\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.AdditionalAnswers.delegatesTo;\n import static org.mockito.ArgumentMatchers.any;\n@@ -35,9 +36,7 @@\n import io.grpc.internal.FakeClock;\n import io.grpc.testing.GrpcCleanupRule.Resource;\n import java.util.concurrent.TimeUnit;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.junit.runners.model.MultipleFailureException;\n@@ -51,10 +50,6 @@\n public class GrpcCleanupRuleTest {\n   public static final FakeClock fakeClock = new FakeClock();\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public ExpectedException thrown = ExpectedException.none();\n-\n   @Test\n   public void registerChannelReturnSameChannel() {\n     ManagedChannel channel = mock(ManagedChannel.class);\n@@ -72,10 +67,9 @@ public void registerNullChannelThrowsNpe() {\n     ManagedChannel channel = null;\n     GrpcCleanupRule grpcCleanup = new GrpcCleanupRule();\n \n-    thrown.expect(NullPointerException.class);\n-    thrown.expectMessage(\"channel\");\n-\n-    grpcCleanup.register(channel);\n+    NullPointerException e = assertThrows(NullPointerException.class,\n+        () -> grpcCleanup.register(channel));\n+    assertThat(e).hasMessageThat().isEqualTo(\"channel\");\n   }\n \n   @Test\n@@ -83,10 +77,9 @@ public void registerNullServerThrowsNpe() {\n     Server server = null;\n     GrpcCleanupRule grpcCleanup = new GrpcCleanupRule();\n \n-    thrown.expect(NullPointerException.class);\n-    thrown.expectMessage(\"server\");\n-\n-    grpcCleanup.register(server);\n+    NullPointerException e = assertThrows(NullPointerException.class,\n+        () -> grpcCleanup.register(server));\n+    assertThat(e).hasMessageThat().isEqualTo(\"server\");\n   }\n \n   @Test\n\ndiff --git a/util/src/test/java/io/grpc/util/GracefulSwitchLoadBalancerTest.java b/util/src/test/java/io/grpc/util/GracefulSwitchLoadBalancerTest.java\nindex 843e16194c5..8f87dab5da6 100644\n--- a/util/src/test/java/io/grpc/util/GracefulSwitchLoadBalancerTest.java\n+++ b/util/src/test/java/io/grpc/util/GracefulSwitchLoadBalancerTest.java\n@@ -21,6 +21,7 @@\n import static io.grpc.ConnectivityState.IDLE;\n import static io.grpc.ConnectivityState.READY;\n import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static org.junit.Assert.assertThrows;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.inOrder;\n@@ -53,9 +54,7 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.ArgumentCaptor;\n@@ -68,10 +67,6 @@\n public class GracefulSwitchLoadBalancerTest {\n   private static final Object FAKE_CONFIG = new Object();\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n-\n   private final Map<LoadBalancerProvider, LoadBalancer> balancers = new HashMap<>();\n   private final Map<LoadBalancer, Helper> helpers = new HashMap<>();\n   private final Helper mockHelper = mock(Helper.class);\n@@ -102,8 +97,8 @@ public void handleSubchannelState_shouldThrow() {\n         .build()));\n     Subchannel subchannel = mock(Subchannel.class);\n     ConnectivityStateInfo connectivityStateInfo = ConnectivityStateInfo.forNonError(READY);\n-    thrown.expect(UnsupportedOperationException.class);\n-    gracefulSwitchLb.handleSubchannelState(subchannel, connectivityStateInfo);\n+    assertThrows(UnsupportedOperationException.class,\n+        () -> gracefulSwitchLb.handleSubchannelState(subchannel, connectivityStateInfo));\n   }\n \n   @Test\n\ndiff --git a/xds/src/test/java/io/grpc/xds/GrpcBootstrapperImplTest.java b/xds/src/test/java/io/grpc/xds/GrpcBootstrapperImplTest.java\nindex 192d88177eb..3f93cc6f191 100644\n--- a/xds/src/test/java/io/grpc/xds/GrpcBootstrapperImplTest.java\n+++ b/xds/src/test/java/io/grpc/xds/GrpcBootstrapperImplTest.java\n@@ -17,6 +17,7 @@\n package io.grpc.xds;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.fail;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verifyNoInteractions;\n@@ -40,10 +41,9 @@\n import java.util.List;\n import java.util.Map;\n import org.junit.After;\n+import org.junit.Assert;\n import org.junit.Before;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n@@ -53,9 +53,6 @@ public class GrpcBootstrapperImplTest {\n \n   private static final String BOOTSTRAP_FILE_PATH = \"/fake/fs/path/bootstrap.json\";\n   private static final String SERVER_URI = \"trafficdirector.googleapis.com:443\";\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n \n   private final GrpcBootstrapperImpl bootstrapper = new GrpcBootstrapperImpl();\n   private String originalBootstrapPathFromEnvVar;\n@@ -236,7 +233,7 @@ public void parseBootstrap_IgnoreIrrelevantFields() throws XdsInitializationExce\n   }\n \n   @Test\n-  public void parseBootstrap_missingServerChannelCreds() throws XdsInitializationException {\n+  public void parseBootstrap_missingServerChannelCreds() {\n     String rawData = \"{\\n\"\n         + \"  \\\"xds_servers\\\": [\\n\"\n         + \"    {\\n\"\n@@ -246,13 +243,14 @@ public void parseBootstrap_missingServerChannelCreds() throws XdsInitializationE\n         + \"}\";\n \n     bootstrapper.setFileReader(createFileReader(BOOTSTRAP_FILE_PATH, rawData));\n-    thrown.expect(XdsInitializationException.class);\n-    thrown.expectMessage(\"Invalid bootstrap: server \" + SERVER_URI + \" 'channel_creds' required\");\n-    bootstrapper.bootstrap();\n+    XdsInitializationException e = Assert.assertThrows(XdsInitializationException.class,\n+        bootstrapper::bootstrap);\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Invalid bootstrap: server \" + SERVER_URI + \" 'channel_creds' required\");\n   }\n \n   @Test\n-  public void parseBootstrap_unsupportedServerChannelCreds() throws XdsInitializationException {\n+  public void parseBootstrap_unsupportedServerChannelCreds() {\n     String rawData = \"{\\n\"\n         + \"  \\\"xds_servers\\\": [\\n\"\n         + \"    {\\n\"\n@@ -265,9 +263,10 @@ public void parseBootstrap_unsupportedServerChannelCreds() throws XdsInitializat\n         + \"}\";\n \n     bootstrapper.setFileReader(createFileReader(BOOTSTRAP_FILE_PATH, rawData));\n-    thrown.expect(XdsInitializationException.class);\n-    thrown.expectMessage(\"Server \" + SERVER_URI + \": no supported channel credentials found\");\n-    bootstrapper.bootstrap();\n+    XdsInitializationException e = assertThrows(XdsInitializationException.class,\n+        bootstrapper::bootstrap);\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Server \" + SERVER_URI + \": no supported channel credentials found\");\n   }\n \n   @Test\n@@ -294,7 +293,7 @@ public void parseBootstrap_useFirstSupportedChannelCredentials()\n   }\n \n   @Test\n-  public void parseBootstrap_noXdsServers() throws XdsInitializationException {\n+  public void parseBootstrap_noXdsServers() {\n     String rawData = \"{\\n\"\n         + \"  \\\"node\\\": {\\n\"\n         + \"    \\\"id\\\": \\\"ENVOY_NODE_ID\\\",\\n\"\n@@ -312,9 +311,10 @@ public void parseBootstrap_noXdsServers() throws XdsInitializationException {\n         + \"}\";\n \n     bootstrapper.setFileReader(createFileReader(BOOTSTRAP_FILE_PATH, rawData));\n-    thrown.expect(XdsInitializationException.class);\n-    thrown.expectMessage(\"Invalid bootstrap: 'xds_servers' does not exist.\");\n-    bootstrapper.bootstrap();\n+    XdsInitializationException e = assertThrows(XdsInitializationException.class,\n+        bootstrapper::bootstrap);\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Invalid bootstrap: 'xds_servers' does not exist.\");\n   }\n \n   @Test\n@@ -343,8 +343,9 @@ public void parseBootstrap_serverWithoutServerUri() throws XdsInitializationExce\n         + \"}\";\n \n     bootstrapper.setFileReader(createFileReader(BOOTSTRAP_FILE_PATH, rawData));\n-    thrown.expectMessage(\"Invalid bootstrap: missing 'server_uri'\");\n-    bootstrapper.bootstrap();\n+    XdsInitializationException e = assertThrows(XdsInitializationException.class,\n+        bootstrapper::bootstrap);\n+    assertThat(e).hasMessageThat().isEqualTo(\"Invalid bootstrap: missing 'server_uri'\");\n   }\n \n   @Test\n@@ -870,7 +871,7 @@ public void parseAuthorities() throws Exception {\n   }\n \n   @Test\n-  public void badFederationConfig() throws Exception {\n+  public void badFederationConfig() {\n     String rawData = \"{\\n\"\n         + \"  \\\"authorities\\\": {\\n\"\n         + \"    \\\"a.com\\\": {\\n\"\n\ndiff --git a/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java b/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java\nindex 48d78e8555e..e129e2644e9 100644\n--- a/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java\n+++ b/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java\n@@ -20,6 +20,7 @@\n import static io.envoyproxy.envoy.config.route.v3.RouteAction.ClusterSpecifierCase.CLUSTER_SPECIFIER_PLUGIN;\n import static io.grpc.xds.XdsClusterResource.TRANSPORT_SOCKET_NAME_HTTP11_PROXY;\n import static io.grpc.xds.XdsEndpointResource.GRPC_EXPERIMENTAL_XDS_DUALSTACK_ENDPOINTS;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.fail;\n \n import com.github.udpa.udpa.type.v1.TypedStruct;\n@@ -154,9 +155,7 @@\n import java.util.concurrent.TimeUnit;\n import org.junit.After;\n import org.junit.Before;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n@@ -173,9 +172,6 @@ public class GrpcXdsClientImplDataTest {\n   private static final String GRPC_EXPERIMENTAL_XDS_AUTHORITY_REWRITE =\n       \"GRPC_EXPERIMENTAL_XDS_AUTHORITY_REWRITE\";\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n   private final FilterRegistry filterRegistry = FilterRegistry.getDefaultRegistry();\n   private boolean originalEnableRouteLookup;\n   private boolean originalEnableLeastRequest;\n@@ -1572,11 +1568,12 @@ public void parseHttpConnectionManager_xffNumTrustedHopsUnsupported()\n       throws ResourceInvalidException {\n     @SuppressWarnings(\"deprecation\")\n     HttpConnectionManager hcm = HttpConnectionManager.newBuilder().setXffNumTrustedHops(2).build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"HttpConnectionManager with xff_num_trusted_hops unsupported\");\n-    XdsListenerResource.parseHttpConnectionManager(\n-        hcm, filterRegistry,\n-        true /* does not matter */, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class,\n+        () -> XdsListenerResource.parseHttpConnectionManager(\n+            hcm, filterRegistry,\n+            true /* does not matter */, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"HttpConnectionManager with xff_num_trusted_hops unsupported\");\n   }\n \n   @Test\n@@ -1586,12 +1583,13 @@ public void parseHttpConnectionManager_OriginalIpDetectionExtensionsMustEmpty()\n     HttpConnectionManager hcm = HttpConnectionManager.newBuilder()\n         .addOriginalIpDetectionExtensions(TypedExtensionConfig.newBuilder().build())\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"HttpConnectionManager with original_ip_detection_extensions unsupported\");\n-    XdsListenerResource.parseHttpConnectionManager(\n-        hcm, filterRegistry, false, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseHttpConnectionManager(\n+            hcm, filterRegistry, false, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"HttpConnectionManager with original_ip_detection_extensions unsupported\");\n   }\n-  \n+\n   @Test\n   public void parseHttpConnectionManager_missingRdsAndInlinedRouteConfiguration()\n       throws ResourceInvalidException {\n@@ -1604,11 +1602,12 @@ public void parseHttpConnectionManager_missingRdsAndInlinedRouteConfiguration()\n                 HttpFilter.newBuilder().setName(\"terminal\").setTypedConfig(\n                     Any.pack(Router.newBuilder().build())).setIsOptional(true))\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"HttpConnectionManager neither has inlined route_config nor RDS\");\n-    XdsListenerResource.parseHttpConnectionManager(\n-        hcm, filterRegistry,\n-        true /* does not matter */, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseHttpConnectionManager(\n+            hcm, filterRegistry,\n+            true /* does not matter */, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"HttpConnectionManager neither has inlined route_config nor RDS\");\n   }\n \n   @Test\n@@ -1623,11 +1622,12 @@ public void parseHttpConnectionManager_duplicateHttpFilters() throws ResourceInv\n                 HttpFilter.newBuilder().setName(\"terminal\").setTypedConfig(\n                         Any.pack(Router.newBuilder().build())).setIsOptional(true))\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"HttpConnectionManager contains duplicate HttpFilter: envoy.filter.foo\");\n-    XdsListenerResource.parseHttpConnectionManager(\n-        hcm, filterRegistry,\n-        true /* does not matter */, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseHttpConnectionManager(\n+            hcm, filterRegistry,\n+            true /* does not matter */, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"HttpConnectionManager contains duplicate HttpFilter: envoy.filter.foo\");\n   }\n \n   @Test\n@@ -1641,11 +1641,12 @@ public void parseHttpConnectionManager_lastNotTerminal() throws ResourceInvalidE\n                 HttpFilter.newBuilder().setName(\"envoy.filter.bar\").setIsOptional(true)\n                     .setTypedConfig(Any.pack(HTTPFault.newBuilder().build())))\n                     .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"The last HttpFilter must be a terminal filter: envoy.filter.bar\");\n-    XdsListenerResource.parseHttpConnectionManager(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseHttpConnectionManager(\n             hcm, filterRegistry,\n-            true /* does not matter */, getXdsResourceTypeArgs(true));\n+            true /* does not matter */, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"The last HttpFilter must be a terminal filter: envoy.filter.bar\");\n   }\n \n   @Test\n@@ -1659,11 +1660,12 @@ public void parseHttpConnectionManager_terminalNotLast() throws ResourceInvalidE\n                     .addHttpFilters(\n                             HttpFilter.newBuilder().setName(\"envoy.filter.foo\").setIsOptional(true))\n                     .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"A terminal HttpFilter must be the last filter: terminal\");\n-    XdsListenerResource.parseHttpConnectionManager(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseHttpConnectionManager(\n             hcm, filterRegistry,\n-            true, getXdsResourceTypeArgs(true));\n+            true, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"A terminal HttpFilter must be the last filter: terminal\");\n   }\n \n   @Test\n@@ -1675,11 +1677,12 @@ public void parseHttpConnectionManager_unknownFilters() throws ResourceInvalidEx\n                     .addHttpFilters(\n                             HttpFilter.newBuilder().setName(\"envoy.filter.bar\").setIsOptional(true))\n                     .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"The last HttpFilter must be a terminal filter: envoy.filter.bar\");\n-    XdsListenerResource.parseHttpConnectionManager(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseHttpConnectionManager(\n             hcm, filterRegistry,\n-            true /* does not matter */, getXdsResourceTypeArgs(true));\n+            true /* does not matter */, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"The last HttpFilter must be a terminal filter: envoy.filter.bar\");\n   }\n \n   @Test\n@@ -1687,11 +1690,12 @@ public void parseHttpConnectionManager_emptyFilters() throws ResourceInvalidExce\n     HttpConnectionManager hcm =\n             HttpConnectionManager.newBuilder()\n                     .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"Missing HttpFilter in HttpConnectionManager.\");\n-    XdsListenerResource.parseHttpConnectionManager(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseHttpConnectionManager(\n             hcm, filterRegistry,\n-            true /* does not matter */, getXdsResourceTypeArgs(true));\n+            true /* does not matter */, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Missing HttpFilter in HttpConnectionManager.\");\n   }\n \n   @Test\n@@ -1815,12 +1819,12 @@ public void parseHttpConnectionManager_duplicatePluginName() throws Exception {\n                     Any.pack(Router.newBuilder().build())).setIsOptional(true))\n             .build();\n \n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"Multiple ClusterSpecifierPlugins with the same name: rls-plugin-1\");\n-\n-    XdsListenerResource.parseHttpConnectionManager(\n-        hcm, filterRegistry,\n-        true /* does not matter */, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseHttpConnectionManager(\n+            hcm, filterRegistry,\n+            true /* does not matter */, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Multiple ClusterSpecifierPlugins with the same name: rls-plugin-1\");\n   }\n \n   @Test\n@@ -1867,12 +1871,12 @@ public void parseHttpConnectionManager_pluginNameNotFound() throws Exception {\n                     Any.pack(Router.newBuilder().build())).setIsOptional(true))\n             .build();\n \n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"ClusterSpecifierPlugin for [invalid-plugin-name] not found\");\n-\n-    XdsListenerResource.parseHttpConnectionManager(\n-        hcm, filterRegistry,\n-        true /* does not matter */, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseHttpConnectionManager(\n+            hcm, filterRegistry,\n+            true /* does not matter */, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .contains(\"ClusterSpecifierPlugin for [invalid-plugin-name] not found\");\n   }\n \n \n@@ -2001,12 +2005,12 @@ public void parseHttpConnectionManager_validateRdsConfigSource() throws Exceptio\n                 HttpFilter.newBuilder().setName(\"terminal\").setTypedConfig(\n                     Any.pack(Router.newBuilder().build())).setIsOptional(true))\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseHttpConnectionManager(\n+            hcm3, filterRegistry,\n+            true /* does not matter */, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"HttpConnectionManager contains invalid RDS: must specify ADS or self ConfigSource\");\n-    XdsListenerResource.parseHttpConnectionManager(\n-        hcm3, filterRegistry,\n-        true /* does not matter */, getXdsResourceTypeArgs(true));\n   }\n \n   @Test\n@@ -2096,11 +2100,10 @@ public void parseClusterSpecifierPlugin_unregisteredPlugin() throws Exception {\n                 .setTypedConfig(Any.pack(StringValue.of(\"unregistered\"))))\n             .build();\n \n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsRouteConfigureResource.parseClusterSpecifierPlugin(pluginProto, registry));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"Unsupported ClusterSpecifierPlugin type: type.googleapis.com/google.protobuf.StringValue\");\n-\n-    XdsRouteConfigureResource.parseClusterSpecifierPlugin(pluginProto, registry);\n   }\n \n   @Test\n@@ -2297,11 +2300,11 @@ public void parseCluster_transportSocketMatches_exception() throws ResourceInval\n             Cluster.TransportSocketMatch.newBuilder().setName(\"match1\").build())\n         .build();\n \n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsClusterResource.processCluster(cluster, null, LRS_SERVER_INFO,\n+            LoadBalancerRegistry.getDefaultRegistry()));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"Cluster cluster-foo.googleapis.com: transport-socket-matches not supported.\");\n-    XdsClusterResource.processCluster(cluster, null, LRS_SERVER_INFO,\n-        LoadBalancerRegistry.getDefaultRegistry());\n   }\n \n   @Test\n@@ -2346,12 +2349,12 @@ public void parseCluster_validateEdsSourceConfig() throws ResourceInvalidExcepti\n         .setLbPolicy(LbPolicy.ROUND_ROBIN)\n         .build();\n \n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsClusterResource.processCluster(cluster3, null, LRS_SERVER_INFO,\n+            LoadBalancerRegistry.getDefaultRegistry()));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"Cluster cluster-foo.googleapis.com: field eds_cluster_config must be set to indicate to\"\n             + \" use EDS over ADS or self ConfigSource\");\n-    XdsClusterResource.processCluster(cluster3, null, LRS_SERVER_INFO,\n-        LoadBalancerRegistry.getDefaultRegistry());\n   }\n \n   @Test\n@@ -2620,10 +2623,11 @@ public void parseServerSideListener_invalidTrafficDirection() throws ResourceInv\n             .setName(\"listener1\")\n             .setTrafficDirection(TrafficDirection.OUTBOUND)\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"Listener listener1 with invalid traffic direction: OUTBOUND\");\n-    XdsListenerResource.parseServerSideListener(\n-        listener, null, filterRegistry, null, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseServerSideListener(\n+            listener, null, filterRegistry, null, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Listener listener1 with invalid traffic direction: OUTBOUND\");\n   }\n \n   @Test\n@@ -2644,10 +2648,11 @@ public void parseServerSideListener_listenerFiltersPresent() throws ResourceInva\n             .setTrafficDirection(TrafficDirection.INBOUND)\n             .addListenerFilters(ListenerFilter.newBuilder().build())\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"Listener listener1 cannot have listener_filters\");\n-    XdsListenerResource.parseServerSideListener(\n-        listener, null, filterRegistry, null, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseServerSideListener(listener, null, filterRegistry, null,\n+            getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Listener listener1 cannot have listener_filters\");\n   }\n \n   @Test\n@@ -2658,10 +2663,11 @@ public void parseServerSideListener_useOriginalDst() throws ResourceInvalidExcep\n             .setTrafficDirection(TrafficDirection.INBOUND)\n             .setUseOriginalDst(BoolValue.of(true))\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"Listener listener1 cannot have use_original_dst set to true\");\n-    XdsListenerResource.parseServerSideListener(\n-        listener,null, filterRegistry, null, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseServerSideListener(listener, null, filterRegistry, null,\n+            getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Listener listener1 cannot have use_original_dst set to true\");\n   }\n \n   @Test\n@@ -2674,11 +2680,10 @@ public void parseServerSideListener_emptyAddress() throws ResourceInvalidExcepti\n                 .setSocketAddress(\n                     SocketAddress.newBuilder()))\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"Invalid address: Empty address is not allowed.\");\n-\n-    XdsListenerResource.parseServerSideListener(\n-        listener,null, filterRegistry, null, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseServerSideListener(\n+            listener, null, filterRegistry, null, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Invalid address: Empty address is not allowed.\");\n   }\n \n   @Test\n@@ -2692,11 +2697,10 @@ public void parseServerSideListener_namedPort() throws ResourceInvalidException\n                     SocketAddress.newBuilder()\n                         .setAddress(\"172.14.14.5\").setNamedPort(\"\")))\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"NAMED_PORT is not supported in gRPC.\");\n-\n-    XdsListenerResource.parseServerSideListener(\n-        listener,null, filterRegistry, null, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseServerSideListener(\n+            listener, null, filterRegistry, null, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat().isEqualTo(\"NAMED_PORT is not supported in gRPC.\");\n   }\n \n   @Test\n@@ -2742,10 +2746,11 @@ public void parseServerSideListener_nonUniqueFilterChainMatch() throws ResourceI\n             .setTrafficDirection(TrafficDirection.INBOUND)\n             .addAllFilterChains(Arrays.asList(filterChain1, filterChain2))\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"FilterChainMatch must be unique. Found duplicate:\");\n-    XdsListenerResource.parseServerSideListener(\n-        listener, null, filterRegistry, null, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseServerSideListener(\n+            listener, null, filterRegistry, null, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .startsWith(\"FilterChainMatch must be unique. Found duplicate:\");\n   }\n \n   @Test\n@@ -2791,10 +2796,11 @@ public void parseServerSideListener_nonUniqueFilterChainMatch_sameFilter()\n             .setTrafficDirection(TrafficDirection.INBOUND)\n             .addAllFilterChains(Arrays.asList(filterChain1, filterChain2))\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"FilterChainMatch must be unique. Found duplicate:\");\n-    XdsListenerResource.parseServerSideListener(\n-        listener,null, filterRegistry, null, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseServerSideListener(\n+            listener, null, filterRegistry, null, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .startsWith(\"FilterChainMatch must be unique. Found duplicate:\");\n   }\n \n   @Test\n@@ -2854,12 +2860,12 @@ public void parseFilterChain_noHcm() throws ResourceInvalidException {\n             .setFilterChainMatch(FilterChainMatch.getDefaultInstance())\n             .setTransportSocket(TransportSocket.getDefaultInstance())\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseFilterChain(\n+            filterChain, \"filter-chain-foo\", null, filterRegistry, null, null,\n+            getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"FilterChain filter-chain-foo should contain exact one HttpConnectionManager filter\");\n-    XdsListenerResource.parseFilterChain(\n-        filterChain, \"filter-chain-foo\", null, filterRegistry, null, null,\n-        getXdsResourceTypeArgs(true));\n   }\n \n   @Test\n@@ -2873,12 +2879,12 @@ public void parseFilterChain_duplicateFilter() throws ResourceInvalidException {\n             .setTransportSocket(TransportSocket.getDefaultInstance())\n             .addAllFilters(Arrays.asList(filter, filter))\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseFilterChain(\n+            filterChain, \"filter-chain-foo\", null, filterRegistry, null, null,\n+            getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"FilterChain filter-chain-foo should contain exact one HttpConnectionManager filter\");\n-    XdsListenerResource.parseFilterChain(\n-        filterChain, \"filter-chain-foo\", null, filterRegistry, null, null,\n-        getXdsResourceTypeArgs(true));\n   }\n \n   @Test\n@@ -2891,13 +2897,13 @@ public void parseFilterChain_filterMissingTypedConfig() throws ResourceInvalidEx\n             .setTransportSocket(TransportSocket.getDefaultInstance())\n             .addFilters(filter)\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseFilterChain(\n+            filterChain, \"filter-chain-foo\", null, filterRegistry, null, null,\n+            getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"FilterChain filter-chain-foo contains filter envoy.http_connection_manager \"\n             + \"without typed_config\");\n-    XdsListenerResource.parseFilterChain(\n-        filterChain, \"filter-chain-foo\", null, filterRegistry, null, null,\n-        getXdsResourceTypeArgs(true));\n   }\n \n   @Test\n@@ -2914,13 +2920,13 @@ public void parseFilterChain_unsupportedFilter() throws ResourceInvalidException\n             .setTransportSocket(TransportSocket.getDefaultInstance())\n             .addFilters(filter)\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseFilterChain(\n+            filterChain, \"filter-chain-foo\", null, filterRegistry, null, null,\n+            getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"FilterChain filter-chain-foo contains filter unsupported with unsupported \"\n             + \"typed_config type unsupported-type-url\");\n-    XdsListenerResource.parseFilterChain(\n-        filterChain, \"filter-chain-foo\", null, filterRegistry, null, null,\n-        getXdsResourceTypeArgs(true));\n   }\n \n   @Test\n@@ -2996,53 +3002,55 @@ public void parseFilterChain_duplicateName() throws ResourceInvalidException {\n             .setTrafficDirection(TrafficDirection.INBOUND)\n             .addAllFilterChains(Arrays.asList(filterChain0, filterChain1))\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"Filter chain names must be unique. Found duplicate: filter_chain\");\n-    XdsListenerResource.parseServerSideListener(\n-        listenerProto, null, filterRegistry, null, getXdsResourceTypeArgs(true));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsListenerResource.parseServerSideListener(\n+            listenerProto, null, filterRegistry, null, getXdsResourceTypeArgs(true)));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Filter chain names must be unique. Found duplicate: filter_chain\");\n   }\n \n   @Test\n-  public void validateCommonTlsContext_tlsParams() throws ResourceInvalidException {\n+  public void validateCommonTlsContext_tlsParams() {\n     CommonTlsContext commonTlsContext = CommonTlsContext.newBuilder()\n             .setTlsParams(TlsParameters.getDefaultInstance())\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"common-tls-context with tls_params is not supported\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false);\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false));\n+    assertThat(e).hasMessageThat().isEqualTo(\"common-tls-context with tls_params is not supported\");\n   }\n \n   @Test\n-  public void validateCommonTlsContext_customHandshaker() throws ResourceInvalidException {\n+  public void validateCommonTlsContext_customHandshaker() {\n     CommonTlsContext commonTlsContext = CommonTlsContext.newBuilder()\n             .setCustomHandshaker(TypedExtensionConfig.getDefaultInstance())\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"common-tls-context with custom_handshaker is not supported\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false);\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false));\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"common-tls-context with custom_handshaker is not supported\");\n   }\n \n   @Test\n-  public void validateCommonTlsContext_validationContext() throws ResourceInvalidException {\n+  public void validateCommonTlsContext_validationContext() {\n     CommonTlsContext commonTlsContext = CommonTlsContext.newBuilder()\n             .setValidationContext(CertificateValidationContext.getDefaultInstance())\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"ca_certificate_provider_instance or system_root_certs is required \"\n-        + \"in upstream-tls-context\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false);\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false));\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"ca_certificate_provider_instance or system_root_certs is required \"\n+            + \"in upstream-tls-context\");\n   }\n \n   @Test\n-  public void validateCommonTlsContext_validationContextSdsSecretConfig()\n-      throws ResourceInvalidException {\n+  public void validateCommonTlsContext_validationContextSdsSecretConfig() {\n     CommonTlsContext commonTlsContext = CommonTlsContext.newBuilder()\n         .setValidationContextSdsSecretConfig(SdsSecretConfig.getDefaultInstance())\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"common-tls-context with validation_context_sds_secret_config is not supported\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false);\n   }\n \n   @Test\n@@ -3050,10 +3058,10 @@ public void validateCommonTlsContext_tlsCertificateProviderInstance_isRequiredFo\n       throws ResourceInvalidException {\n     CommonTlsContext commonTlsContext = CommonTlsContext.newBuilder()\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, true));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"tls_certificate_provider_instance is required in downstream-tls-context\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, true);\n   }\n \n   @Test\n@@ -3085,11 +3093,11 @@ public void validateCommonTlsContext_tlsCertificateProviderInstance_absentInBoot\n         .setTlsCertificateProviderInstance(\n             CertificateProviderPluginInstance.newBuilder().setInstanceName(\"bad-name\"))\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsClusterResource.validateCommonTlsContext(commonTlsContext,\n+            ImmutableSet.of(\"name1\", \"name2\"), true));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"CertificateProvider instance name 'bad-name' not defined in the bootstrap file.\");\n-    XdsClusterResource\n-        .validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"name1\", \"name2\"), true);\n   }\n \n   @Test\n@@ -3197,11 +3205,11 @@ public void validateCommonTlsContext_validationContextProviderInstance_absentInB\n                 .setCaCertificateProviderInstance(CertificateProviderPluginInstance.newBuilder()\n                   .setInstanceName(\"bad-name\"))))\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsClusterResource.validateCommonTlsContext(commonTlsContext,\n+            ImmutableSet.of(\"name1\", \"name2\"), false));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"ca_certificate_provider_instance name 'bad-name' not defined in the bootstrap file.\");\n-    XdsClusterResource\n-        .validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"name1\", \"name2\"), false);\n   }\n \n \n@@ -3210,9 +3218,9 @@ public void validateCommonTlsContext_tlsCertificatesCount() throws ResourceInval\n     CommonTlsContext commonTlsContext = CommonTlsContext.newBuilder()\n             .addTlsCertificates(TlsCertificate.getDefaultInstance())\n             .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"tls_certificate_provider_instance is unset\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false);\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false));\n+    assertThat(e).hasMessageThat().isEqualTo(\"tls_certificate_provider_instance is unset\");\n   }\n \n   @Test\n@@ -3221,10 +3229,10 @@ public void validateCommonTlsContext_tlsCertificateSdsSecretConfigsCount()\n     CommonTlsContext commonTlsContext = CommonTlsContext.newBuilder()\n         .addTlsCertificateSdsSecretConfigs(SdsSecretConfig.getDefaultInstance())\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"tls_certificate_provider_instance is unset\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false);\n   }\n \n   @Test\n@@ -3232,10 +3240,11 @@ public void validateCommonTlsContext_combinedValidationContext_isRequiredForClie\n       throws ResourceInvalidException {\n     CommonTlsContext commonTlsContext = CommonTlsContext.newBuilder()\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"ca_certificate_provider_instance or system_root_certs is required \"\n-        + \"in upstream-tls-context\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false);\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+        XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false));\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"ca_certificate_provider_instance or system_root_certs is required \"\n+            + \"in upstream-tls-context\");\n   }\n \n   @Test\n@@ -3245,11 +3254,11 @@ public void validateCommonTlsContext_combinedValidationContextWithoutCertProvide\n         .setCombinedValidationContext(\n             CommonTlsContext.CombinedCertificateValidationContext.getDefaultInstance())\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+        XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"ca_certificate_provider_instance or system_root_certs is required in \"\n             + \"upstream-tls-context\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, null, false);\n   }\n \n   @Test\n@@ -3267,9 +3276,10 @@ public void validateCommonTlsContext_combinedValContextWithDefaultValContextForS\n         .setTlsCertificateProviderInstance(\n             CertificateProviderPluginInstance.getDefaultInstance())\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"match_subject_alt_names only allowed in upstream_tls_context\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"\"), true);\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+        XdsClusterResource.validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"\"), true));\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"match_subject_alt_names only allowed in upstream_tls_context\");\n   }\n \n   @Test\n@@ -3284,10 +3294,10 @@ public void validateCommonTlsContext_combinedValContextWithDefaultValContextVeri\n                     .addVerifyCertificateSpki(\"foo\")))\n         .setTlsCertificateProviderInstance(CertificateProviderPluginInstance.getDefaultInstance())\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"verify_certificate_spki in default_validation_context is not \"\n-        + \"supported\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"\"), false);\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+        XdsClusterResource.validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"\"), false));\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"verify_certificate_spki in default_validation_context is not supported\");\n   }\n \n   @Test\n@@ -3302,10 +3312,10 @@ public void validateCommonTlsContext_combinedValContextWithDefaultValContextVeri\n                     .addVerifyCertificateHash(\"foo\")))\n         .setTlsCertificateProviderInstance(CertificateProviderPluginInstance.getDefaultInstance())\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"verify_certificate_hash in default_validation_context is not \"\n-        + \"supported\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"\"), false);\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+        XdsClusterResource.validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"\"), false));\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"verify_certificate_hash in default_validation_context is not supported\");\n   }\n \n   @Test\n@@ -3321,11 +3331,11 @@ public void validateCommonTlsContext_combinedValContextDfltValContextRequireSign\n         .setTlsCertificateProviderInstance(\n             CertificateProviderPluginInstance.getDefaultInstance())\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+        XdsClusterResource.validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"\"), false));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"require_signed_certificate_timestamp in default_validation_context is not \"\n             + \"supported\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"\"), false);\n   }\n \n   @Test\n@@ -3340,9 +3350,9 @@ public void validateCommonTlsContext_combinedValidationContextWithDefaultValidat\n                     .setCrl(DataSource.getDefaultInstance())))\n         .setTlsCertificateProviderInstance(CertificateProviderPluginInstance.getDefaultInstance())\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"crl in default_validation_context is not supported\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"\"), false);\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+        XdsClusterResource.validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"\"), false));\n+    assertThat(e).hasMessageThat().isEqualTo(\"crl in default_validation_context is not supported\");\n   }\n \n   @Test\n@@ -3357,18 +3367,19 @@ public void validateCommonTlsContext_combinedValContextWithDfltValContextCustomV\n                     .setCustomValidatorConfig(TypedExtensionConfig.getDefaultInstance())))\n         .setTlsCertificateProviderInstance(CertificateProviderPluginInstance.getDefaultInstance())\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"custom_validator_config in default_validation_context is not \"\n-        + \"supported\");\n-    XdsClusterResource.validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"\"), false);\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+        XdsClusterResource.validateCommonTlsContext(commonTlsContext, ImmutableSet.of(\"\"), false));\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"custom_validator_config in default_validation_context is not supported\");\n   }\n \n   @Test\n   public void validateDownstreamTlsContext_noCommonTlsContext() throws ResourceInvalidException {\n     DownstreamTlsContext downstreamTlsContext = DownstreamTlsContext.getDefaultInstance();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"common-tls-context is required in downstream-tls-context\");\n-    XdsListenerResource.validateDownstreamTlsContext(downstreamTlsContext, null);\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+        XdsListenerResource.validateDownstreamTlsContext(downstreamTlsContext, null));\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"common-tls-context is required in downstream-tls-context\");\n   }\n \n   @Test\n@@ -3385,9 +3396,11 @@ public void validateDownstreamTlsContext_hasRequireSni() throws ResourceInvalidE\n         .setCommonTlsContext(commonTlsContext)\n         .setRequireSni(BoolValue.of(true))\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"downstream-tls-context with require-sni is not supported\");\n-    XdsListenerResource.validateDownstreamTlsContext(downstreamTlsContext, ImmutableSet.of(\"\"));\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+        XdsListenerResource.validateDownstreamTlsContext(downstreamTlsContext,\n+            ImmutableSet.of(\"\")));\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"downstream-tls-context with require-sni is not supported\");\n   }\n \n   @Test\n@@ -3404,18 +3417,20 @@ public void validateDownstreamTlsContext_hasOcspStaplePolicy() throws ResourceIn\n         .setCommonTlsContext(commonTlsContext)\n         .setOcspStaplePolicy(DownstreamTlsContext.OcspStaplePolicy.STRICT_STAPLING)\n         .build();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+        XdsListenerResource.validateDownstreamTlsContext(downstreamTlsContext,\n+            ImmutableSet.of(\"\")));\n+    assertThat(e).hasMessageThat().isEqualTo(\n         \"downstream-tls-context with ocsp_staple_policy value STRICT_STAPLING is not supported\");\n-    XdsListenerResource.validateDownstreamTlsContext(downstreamTlsContext, ImmutableSet.of(\"\"));\n   }\n \n   @Test\n   public void validateUpstreamTlsContext_noCommonTlsContext() throws ResourceInvalidException {\n     UpstreamTlsContext upstreamTlsContext = UpstreamTlsContext.getDefaultInstance();\n-    thrown.expect(ResourceInvalidException.class);\n-    thrown.expectMessage(\"common-tls-context is required in upstream-tls-context\");\n-    XdsClusterResource.validateUpstreamTlsContext(upstreamTlsContext, null);\n+    ResourceInvalidException e = assertThrows(ResourceInvalidException.class, () ->\n+            XdsClusterResource.validateUpstreamTlsContext(upstreamTlsContext, null));\n+    assertThat(e).hasMessageThat().isEqualTo(\n+        \"common-tls-context is required in upstream-tls-context\");\n   }\n \n   @Test\n\ndiff --git a/xds/src/test/java/io/grpc/xds/PriorityLoadBalancerProviderTest.java b/xds/src/test/java/io/grpc/xds/PriorityLoadBalancerProviderTest.java\nindex 9f0b5f9578e..37ea24b2aa9 100644\n--- a/xds/src/test/java/io/grpc/xds/PriorityLoadBalancerProviderTest.java\n+++ b/xds/src/test/java/io/grpc/xds/PriorityLoadBalancerProviderTest.java\n@@ -16,6 +16,7 @@\n \n package io.grpc.xds;\n \n+import static org.junit.Assert.assertThrows;\n import static org.mockito.Mockito.mock;\n \n import com.google.common.collect.ImmutableList;\n@@ -26,17 +27,13 @@\n import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig.PriorityChildConfig;\n import java.util.List;\n import java.util.Map;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n /** Tests for {@link PriorityLoadBalancerProvider}. */\n @RunWith(JUnit4.class)\n public class PriorityLoadBalancerProviderTest {\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n \n   @SuppressWarnings(\"ExpectedExceptionChecker\")\n   @Test\n@@ -48,8 +45,8 @@ public void priorityLbConfig_emptyPriorities() {\n                 newChildConfig(mock(LoadBalancerProvider.class), null), true));\n     List<String> priorities = ImmutableList.of();\n \n-    thrown.expect(IllegalArgumentException.class);\n-    new PriorityLbConfig(childConfigs, priorities);\n+    assertThrows(IllegalArgumentException.class,\n+        () -> new PriorityLbConfig(childConfigs, priorities));\n   }\n \n   @SuppressWarnings(\"ExpectedExceptionChecker\")\n@@ -62,8 +59,8 @@ public void priorityLbConfig_missingChildConfig() {\n                 newChildConfig(mock(LoadBalancerProvider.class), null), true));\n     List<String> priorities = ImmutableList.of(\"p0\", \"p1\");\n \n-    thrown.expect(IllegalArgumentException.class);\n-    new PriorityLbConfig(childConfigs, priorities);\n+    assertThrows(IllegalArgumentException.class,\n+        () -> new PriorityLbConfig(childConfigs, priorities));\n   }\n \n   private Object newChildConfig(LoadBalancerProvider provider, Object config) {\n\ndiff --git a/xds/src/test/java/io/grpc/xds/SharedXdsClientPoolProviderTest.java b/xds/src/test/java/io/grpc/xds/SharedXdsClientPoolProviderTest.java\nindex 86e4fc83a8c..24f1750d5a8 100644\n--- a/xds/src/test/java/io/grpc/xds/SharedXdsClientPoolProviderTest.java\n+++ b/xds/src/test/java/io/grpc/xds/SharedXdsClientPoolProviderTest.java\n@@ -19,6 +19,7 @@\n \n import static com.google.common.truth.Truth.assertThat;\n import static io.grpc.Metadata.ASCII_STRING_MARSHALLER;\n+import static org.junit.Assert.assertThrows;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyNoMoreInteractions;\n import static org.mockito.Mockito.when;\n@@ -50,7 +51,6 @@\n import java.util.concurrent.TimeUnit;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.Mock;\n@@ -64,9 +64,6 @@ public class SharedXdsClientPoolProviderTest {\n   private static final String SERVER_URI = \"trafficdirector.googleapis.com\";\n   @Rule\n   public final MockitoRule mocks = MockitoJUnit.rule();\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n   private final Node node = Node.newBuilder().setId(\"SharedXdsClientPoolProviderTest\").build();\n   private final MetricRecorder metricRecorder = new MetricRecorder() {};\n   private static final String DUMMY_TARGET = \"dummy\";\n@@ -83,9 +80,9 @@ public void noServer() throws XdsInitializationException {\n         BootstrapInfo.builder().servers(Collections.<ServerInfo>emptyList()).node(node).build();\n     when(bootstrapper.bootstrap()).thenReturn(bootstrapInfo);\n     SharedXdsClientPoolProvider provider = new SharedXdsClientPoolProvider(bootstrapper);\n-    thrown.expect(XdsInitializationException.class);\n-    thrown.expectMessage(\"No xDS server provided\");\n-    provider.getOrCreate(DUMMY_TARGET, metricRecorder);\n+    XdsInitializationException e = assertThrows(XdsInitializationException.class,\n+        () -> provider.getOrCreate(DUMMY_TARGET, metricRecorder));\n+    assertThat(e).hasMessageThat().isEqualTo(\"No xDS server provided\");\n     assertThat(provider.get(DUMMY_TARGET)).isNull();\n   }\n \n\ndiff --git a/xds/src/test/java/io/grpc/xds/WeightedRandomPickerTest.java b/xds/src/test/java/io/grpc/xds/WeightedRandomPickerTest.java\nindex d6240fb09bb..691615762bf 100644\n--- a/xds/src/test/java/io/grpc/xds/WeightedRandomPickerTest.java\n+++ b/xds/src/test/java/io/grpc/xds/WeightedRandomPickerTest.java\n@@ -17,6 +17,7 @@\n package io.grpc.xds;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertThrows;\n import static org.mockito.Mockito.mock;\n \n import io.grpc.LoadBalancer.PickResult;\n@@ -30,7 +31,6 @@\n import java.util.List;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.Mock;\n@@ -42,9 +42,6 @@\n  */\n @RunWith(JUnit4.class)\n public class WeightedRandomPickerTest {\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n \n   @Rule\n   public final MockitoRule mockitoRule = MockitoJUnit.rule();\n@@ -128,20 +125,18 @@ public long nextLong(long bound) {\n   public void emptyList() {\n     List<WeightedChildPicker> emptyList = new ArrayList<>();\n \n-    thrown.expect(IllegalArgumentException.class);\n-    new WeightedRandomPicker(emptyList);\n+    assertThrows(IllegalArgumentException.class, () -> new WeightedRandomPicker(emptyList));\n   }\n \n   @Test\n   public void negativeWeight() {\n-    thrown.expect(IllegalArgumentException.class);\n-    new WeightedChildPicker(-1, childPicker0);\n+    assertThrows(IllegalArgumentException.class, () -> new WeightedChildPicker(-1, childPicker0));\n   }\n \n   @Test\n   public void overWeightSingle() {\n-    thrown.expect(IllegalArgumentException.class);\n-    new WeightedChildPicker(Integer.MAX_VALUE * 3L, childPicker0);\n+    assertThrows(IllegalArgumentException.class,\n+        () -> new WeightedChildPicker(Integer.MAX_VALUE * 3L, childPicker0));\n   }\n \n   @Test\n@@ -152,8 +147,8 @@ public void overWeightAggregate() {\n         new WeightedChildPicker(Integer.MAX_VALUE, childPicker1),\n         new WeightedChildPicker(10, childPicker2));\n \n-    thrown.expect(IllegalArgumentException.class);\n-    new WeightedRandomPicker(weightedChildPickers, fakeRandom);\n+    assertThrows(IllegalArgumentException.class,\n+        () -> new WeightedRandomPicker(weightedChildPickers, fakeRandom));\n   }\n \n   @Test\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-12085",
    "pr_id": 12085,
    "issue_id": 11243,
    "repo": "grpc/grpc-java",
    "problem_statement": "RLS cleanups\nFrom https://github.com/grpc/grpc-java/pull/11203 :\r\n\r\nSeems like the LinkedHashLruCacheTest tests should use cache.fitToLimit() at least some of the time (or maybe it deserves its own test case).\r\n\r\nhttps://github.com/grpc/grpc-java/blob/e4e7f3a068b0edf9404cad8cc6b3eac70ee254c8/rls/src/main/java/io/grpc/rls/LinkedHashLruCache.java#L72\r\n\r\n> Having the evictionListener handle decrementing `estimatedMaxSizeBytes` seems like unnecessary complexity that should be eliminated.\r\n\r\nhttps://github.com/grpc/grpc-java/blob/e4e7f3a068b0edf9404cad8cc6b3eac70ee254c8/rls/src/main/java/io/grpc/rls/LinkedHashLruCache.java#L248\r\n\r\n> The reason given in the comment only describes what happens when it is called from this class, not from RlsAsyncLruCache. The comment should probably just be removed as obvious, but could be changed to `there is space available so no need to do cleanup`\r\n\r\n> s/until new size limit/until the size of all entries fits within the limit/",
    "issue_word_count": 143,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "rls/src/test/java/io/grpc/rls/LinkedHashLruCacheTest.java"
    ],
    "pr_changed_test_files": [
      "rls/src/test/java/io/grpc/rls/LinkedHashLruCacheTest.java"
    ],
    "base_commit": "922dc8a999531c91b0fa77386e0609745fae939f",
    "head_commit": "d951df54b09842a45e6ef5cb685a0244fd38e80c",
    "repo_url": "https://github.com/grpc/grpc-java/pull/12085",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/12085",
    "dockerfile": "",
    "pr_merged_at": "2025-06-25T05:25:00.000Z",
    "patch": "",
    "test_patch": "diff --git a/rls/src/test/java/io/grpc/rls/LinkedHashLruCacheTest.java b/rls/src/test/java/io/grpc/rls/LinkedHashLruCacheTest.java\nindex f38b28d8416..23ffe6ec026 100644\n--- a/rls/src/test/java/io/grpc/rls/LinkedHashLruCacheTest.java\n+++ b/rls/src/test/java/io/grpc/rls/LinkedHashLruCacheTest.java\n@@ -25,8 +25,10 @@\n import io.grpc.internal.FakeClock;\n import io.grpc.rls.LruCache.EvictionListener;\n import io.grpc.rls.LruCache.EvictionType;\n+import java.util.Arrays;\n import java.util.Objects;\n import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -266,4 +268,91 @@ public int hashCode() {\n       return Objects.hash(value, expireTime);\n     }\n   }\n+\n+  @Test\n+  public void testFitToLimitWithReSize() {\n+\n+    Entry entry1 = new Entry(\"Entry1\", ticker.read() + 10, 4);\n+    Entry entry2 = new Entry(\"Entry2\", ticker.read() + 20, 1);\n+    Entry entry3 = new Entry(\"Entry3\", ticker.read() + 30, 2);\n+\n+    cache.cache(1, entry1);\n+    cache.cache(2, entry2);\n+    cache.cache(3, entry3);\n+\n+    assertThat(cache.estimatedSize()).isEqualTo(2);\n+    assertThat(cache.estimatedSizeBytes()).isEqualTo(3);\n+    assertThat(cache.estimatedMaxSizeBytes()).isEqualTo(5);\n+\n+    cache.resize(2);\n+    assertThat(cache.estimatedSize()).isEqualTo(1);\n+    assertThat(cache.estimatedSizeBytes()).isEqualTo(2);\n+    assertThat(cache.estimatedMaxSizeBytes()).isEqualTo(2);\n+\n+    assertThat(cache.fitToLimit()).isEqualTo(false);\n+  }\n+\n+  @Test\n+  public void testFitToLimit() {\n+\n+    TestFitToLimitEviction localCache = new TestFitToLimitEviction(\n+            MAX_SIZE,\n+            evictionListener,\n+            fakeClock.getTicker()\n+    );\n+\n+    Entry entry1 = new Entry(\"Entry1\", ticker.read() + 10, 4);\n+    Entry entry2 = new Entry(\"Entry2\", ticker.read() + 20, 2);\n+    Entry entry3 = new Entry(\"Entry3\", ticker.read() + 30, 1);\n+\n+    localCache.cache(1, entry1);\n+    localCache.cache(2, entry2);\n+    localCache.cache(3, entry3);\n+\n+    assertThat(localCache.estimatedSize()).isEqualTo(3);\n+    assertThat(localCache.estimatedSizeBytes()).isEqualTo(7);\n+    assertThat(localCache.estimatedMaxSizeBytes()).isEqualTo(5);\n+\n+    localCache.enableEviction();\n+\n+    assertThat(localCache.fitToLimit()).isEqualTo(true);\n+\n+    assertThat(localCache.values().contains(entry1)).isFalse();\n+    assertThat(localCache.values().containsAll(Arrays.asList(entry2, entry3))).isTrue();\n+\n+    assertThat(localCache.estimatedSize()).isEqualTo(2);\n+    assertThat(localCache.estimatedSizeBytes()).isEqualTo(3);\n+    assertThat(localCache.estimatedMaxSizeBytes()).isEqualTo(5);\n+  }\n+\n+  private static class TestFitToLimitEviction extends LinkedHashLruCache<Integer, Entry> {\n+\n+    private boolean allowEviction = false;\n+\n+    TestFitToLimitEviction(\n+            long estimatedMaxSizeBytes,\n+            @Nullable EvictionListener<Integer, Entry> evictionListener,\n+            Ticker ticker) {\n+      super(estimatedMaxSizeBytes, evictionListener, ticker);\n+    }\n+\n+    @Override\n+    protected boolean isExpired(Integer key, Entry value, long nowNanos) {\n+      return value.expireTime - nowNanos <= 0;\n+    }\n+\n+    @Override\n+    protected int estimateSizeOf(Integer key, Entry value) {\n+      return value.size;\n+    }\n+\n+    @Override\n+    protected boolean shouldInvalidateEldestEntry(Integer eldestKey, Entry eldestValue, long now) {\n+      return allowEviction && super.shouldInvalidateEldestEntry(eldestKey, eldestValue, now);\n+    }\n+\n+    public void enableEviction() {\n+      allowEviction = true;\n+    }\n+  }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-12080",
    "pr_id": 12080,
    "issue_id": 9179,
    "repo": "grpc/grpc-java",
    "problem_statement": "Replace javax.annotation.Generated with custom gRPC annotation\nSince Java 9 dropped `javax.annotation.Generated` users have had to explicitly depend on a dep (typically Tomcat's annotation API) to get the annotation. It'd be nice not to need that the extra dep.\r\n\r\nBut even more important is that the removal of Generated from Java 9 upset the ecosystem as a whole and fragmented it so badly that I believe many tools are no longer assuming they can predict which annotation will be used and are heuristics like \"is the annotation named 'Generated'\" to determine whether they should it as generated code.\r\n\r\nIf we do an investigation and find that indeed all the tools we may care about (linters, static analyzers, IDEs) are observing Generated annotations in any package, then we can make our own `io.grpc.Generated`. Unfortunately, I expect the `io.grpc.GrpcGenerated` annotation may not suffice because its name is not exactly \"Generated.\" We'll also need to figure out what retention it needs.\r\n\r\nTools to investigate (off the top of my head): Error Prone, IntelliJ, Eclipse, Android linter, Find Bugs, Checkstyle. The tools to investigate should be those that may be used by gRPC users, not just those directly used by gRPC maintainers.\r\n\r\n`javax.annotation.processing.Generated` is not a relevant replacement; see #3633. I highly doubt `jakarta.annotation.Generated` would ever be appropriate, even with it being the new home for the annotation; it'd only have an advantage if Nullable goes that way as well, which seems unlikely. But that'd also take investigation of Kotlin and other null-caring tools.",
    "issue_word_count": 268,
    "test_files_count": 27,
    "non_test_files_count": 22,
    "pr_changed_files": [
      "BUILD.bazel",
      "MODULE.bazel",
      "alts/src/generated/main/grpc/io/grpc/alts/internal/HandshakerServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/TestServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/TestServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java",
      "benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/BenchmarkServiceGrpc.java",
      "benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/ReportQpsScenarioServiceGrpc.java",
      "benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/WorkerServiceGrpc.java",
      "compiler/BUILD.bazel",
      "compiler/build.gradle",
      "compiler/src/java_plugin/cpp/java_plugin.cpp",
      "grpclb/src/generated/main/grpc/io/grpc/lb/v1/LoadBalancerGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/TestServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java",
      "istio-interop-testing/src/generated/main/grpc/io/istio/test/EchoTestServiceGrpc.java",
      "repositories.bzl",
      "rls/src/generated/main/grpc/io/grpc/lookup/v1/RouteLookupServiceGrpc.java",
      "services/src/generated/main/grpc/io/grpc/channelz/v1/ChannelzGrpc.java",
      "services/src/generated/main/grpc/io/grpc/health/v1/HealthGrpc.java",
      "services/src/generated/main/grpc/io/grpc/reflection/v1/ServerReflectionGrpc.java",
      "services/src/generated/main/grpc/io/grpc/reflection/v1alpha/ServerReflectionGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherDynamicServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherReflectableServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/DynamicServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/ReflectableServiceGrpc.java",
      "stub/BUILD.bazel",
      "testing-proto/src/generated/main/grpc/io/grpc/testing/protobuf/SimpleServiceGrpc.java",
      "xds/src/generated/thirdparty/grpc/com/github/xds/service/orca/v3/OpenRcaServiceGrpc.java",
      "xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/discovery/v3/AggregatedDiscoveryServiceGrpc.java",
      "xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/load_stats/v3/LoadReportingServiceGrpc.java",
      "xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/rate_limit_quota/v3/RateLimitQuotaServiceGrpc.java",
      "xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/status/v3/ClientStatusDiscoveryServiceGrpc.java"
    ],
    "pr_changed_test_files": [
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/TestServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java",
      "android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/TestServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java",
      "android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/TestServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java",
      "interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java",
      "istio-interop-testing/src/generated/main/grpc/io/istio/test/EchoTestServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherDynamicServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherReflectableServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/DynamicServiceGrpc.java",
      "services/src/generated/test/grpc/io/grpc/reflection/testing/ReflectableServiceGrpc.java",
      "testing-proto/src/generated/main/grpc/io/grpc/testing/protobuf/SimpleServiceGrpc.java"
    ],
    "base_commit": "2fb09578a8a8ca4b0000f6f8be8c3a22460d9019",
    "head_commit": "3d50874d60d7aef5492bde4ae174aa6cbe84c1fd",
    "repo_url": "https://github.com/grpc/grpc-java/pull/12080",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/12080",
    "dockerfile": "",
    "pr_merged_at": "2025-05-21T17:19:30.000Z",
    "patch": "diff --git a/BUILD.bazel b/BUILD.bazel\nindex b6d0838bf87..8350ed9aa39 100644\n--- a/BUILD.bazel\n+++ b/BUILD.bazel\n@@ -33,7 +33,6 @@ java_library(\n         \"//api\",\n         \"//protobuf\",\n         \"//stub\",\n-        \"//stub:javax_annotation\",\n         \"@com_google_protobuf//:protobuf_java\",\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.guava:guava\"),\n@@ -47,7 +46,6 @@ java_library(\n         \"//api\",\n         \"//protobuf-lite\",\n         \"//stub\",\n-        \"//stub:javax_annotation\",\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.guava:guava\"),\n     ],\n@@ -67,6 +65,5 @@ java_library(\n     visibility = [\"//:__subpackages__\"],\n     exports = [\n         artifact(\"com.google.auto.value:auto-value-annotations\"),\n-        artifact(\"org.apache.tomcat:annotations-api\"),  # @Generated for Java 9+\n     ],\n )\n\ndiff --git a/MODULE.bazel b/MODULE.bazel\nindex 7fa3eab395d..83aa6c1b026 100644\n--- a/MODULE.bazel\n+++ b/MODULE.bazel\n@@ -41,7 +41,6 @@ IO_GRPC_GRPC_JAVA_ARTIFACTS = [\n     \"io.opencensus:opencensus-contrib-grpc-metrics:0.31.0\",\n     \"io.perfmark:perfmark-api:0.27.0\",\n     \"junit:junit:4.13.2\",\n-    \"org.apache.tomcat:annotations-api:6.0.53\",\n     \"org.checkerframework:checker-qual:3.12.0\",\n     \"org.codehaus.mojo:animal-sniffer-annotations:1.24\",\n ]\n\ndiff --git a/alts/src/generated/main/grpc/io/grpc/alts/internal/HandshakerServiceGrpc.java b/alts/src/generated/main/grpc/io/grpc/alts/internal/HandshakerServiceGrpc.java\nindex 91e88f331d7..07e4256eb75 100644\n--- a/alts/src/generated/main/grpc/io/grpc/alts/internal/HandshakerServiceGrpc.java\n+++ b/alts/src/generated/main/grpc/io/grpc/alts/internal/HandshakerServiceGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/gcp/handshaker.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class HandshakerServiceGrpc {\n \n\ndiff --git a/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/BenchmarkServiceGrpc.java b/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/BenchmarkServiceGrpc.java\nindex 242d4551d6e..15b9a67918b 100644\n--- a/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/BenchmarkServiceGrpc.java\n+++ b/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/BenchmarkServiceGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/services.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class BenchmarkServiceGrpc {\n \n\ndiff --git a/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/ReportQpsScenarioServiceGrpc.java b/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/ReportQpsScenarioServiceGrpc.java\nindex 8f466185ea0..8fe5f926d99 100644\n--- a/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/ReportQpsScenarioServiceGrpc.java\n+++ b/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/ReportQpsScenarioServiceGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/services.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class ReportQpsScenarioServiceGrpc {\n \n\ndiff --git a/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/WorkerServiceGrpc.java b/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/WorkerServiceGrpc.java\nindex 11859482972..bf9649e8377 100644\n--- a/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/WorkerServiceGrpc.java\n+++ b/benchmarks/src/generated/main/grpc/io/grpc/benchmarks/proto/WorkerServiceGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/services.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class WorkerServiceGrpc {\n \n\ndiff --git a/compiler/BUILD.bazel b/compiler/BUILD.bazel\nindex 753f485074e..6f66164f155 100644\n--- a/compiler/BUILD.bazel\n+++ b/compiler/BUILD.bazel\n@@ -22,7 +22,6 @@ java_library(\n         \"//api\",\n         \"//protobuf\",\n         \"//stub\",\n-        \"//stub:javax_annotation\",\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.guava:guava\"),\n         \"@com_google_protobuf//:protobuf_java\",\n@@ -35,7 +34,6 @@ java_library(\n         \"//api\",\n         \"//protobuf-lite\",\n         \"//stub\",\n-        \"//stub:javax_annotation\",\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.guava:guava\"),\n     ],\n\ndiff --git a/compiler/build.gradle b/compiler/build.gradle\nindex 3d31d602642..9fee2545f0c 100644\n--- a/compiler/build.gradle\n+++ b/compiler/build.gradle\n@@ -184,7 +184,11 @@ protobuf {\n             inputs.file javaPluginPath\n         }\n         ofSourceSet('test').configureEach {\n-            plugins { grpc {} }\n+            plugins {\n+                grpc {\n+                    option '@generated=javax'\n+                }\n+            }\n         }\n         ofSourceSet('testLite').configureEach {\n             builtins {\n@@ -193,7 +197,6 @@ protobuf {\n             plugins {\n                 grpc {\n                     option 'lite'\n-                    option '@generated=omit'\n                 }\n             }\n         }\n\ndiff --git a/compiler/src/java_plugin/cpp/java_plugin.cpp b/compiler/src/java_plugin/cpp/java_plugin.cpp\nindex 6b7cc03d486..a595a6a6896 100644\n--- a/compiler/src/java_plugin/cpp/java_plugin.cpp\n+++ b/compiler/src/java_plugin/cpp/java_plugin.cpp\n@@ -80,7 +80,7 @@ class JavaGrpcGenerator : public protobuf::compiler::CodeGenerator {\n     java_grpc_generator::ProtoFlavor flavor =\n         java_grpc_generator::ProtoFlavor::NORMAL;\n     java_grpc_generator::GeneratedAnnotation generated_annotation =\n-        java_grpc_generator::GeneratedAnnotation::JAVAX;\n+        java_grpc_generator::GeneratedAnnotation::OMIT;\n \n     bool disable_version = false;\n     for (size_t i = 0; i < options.size(); i++) {\n\ndiff --git a/grpclb/src/generated/main/grpc/io/grpc/lb/v1/LoadBalancerGrpc.java b/grpclb/src/generated/main/grpc/io/grpc/lb/v1/LoadBalancerGrpc.java\nindex 2a81dfe4ee5..b730eff7b37 100644\n--- a/grpclb/src/generated/main/grpc/io/grpc/lb/v1/LoadBalancerGrpc.java\n+++ b/grpclb/src/generated/main/grpc/io/grpc/lb/v1/LoadBalancerGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/lb/v1/load_balancer.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class LoadBalancerGrpc {\n \n\ndiff --git a/repositories.bzl b/repositories.bzl\nindex d55ff07e7e6..12a8ec7a6f1 100644\n--- a/repositories.bzl\n+++ b/repositories.bzl\n@@ -45,7 +45,6 @@ IO_GRPC_GRPC_JAVA_ARTIFACTS = [\n     \"io.opencensus:opencensus-contrib-grpc-metrics:0.31.0\",\n     \"io.perfmark:perfmark-api:0.27.0\",\n     \"junit:junit:4.13.2\",\n-    \"org.apache.tomcat:annotations-api:6.0.53\",\n     \"org.checkerframework:checker-qual:3.12.0\",\n     \"org.codehaus.mojo:animal-sniffer-annotations:1.24\",\n ]\n\ndiff --git a/rls/src/generated/main/grpc/io/grpc/lookup/v1/RouteLookupServiceGrpc.java b/rls/src/generated/main/grpc/io/grpc/lookup/v1/RouteLookupServiceGrpc.java\nindex 558a223173c..39e9d0f4144 100644\n--- a/rls/src/generated/main/grpc/io/grpc/lookup/v1/RouteLookupServiceGrpc.java\n+++ b/rls/src/generated/main/grpc/io/grpc/lookup/v1/RouteLookupServiceGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/lookup/v1/rls.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class RouteLookupServiceGrpc {\n \n\ndiff --git a/services/src/generated/main/grpc/io/grpc/channelz/v1/ChannelzGrpc.java b/services/src/generated/main/grpc/io/grpc/channelz/v1/ChannelzGrpc.java\nindex 7dd74034efe..f839f11cfe5 100644\n--- a/services/src/generated/main/grpc/io/grpc/channelz/v1/ChannelzGrpc.java\n+++ b/services/src/generated/main/grpc/io/grpc/channelz/v1/ChannelzGrpc.java\n@@ -8,9 +8,6 @@\n  * information.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/channelz/v1/channelz.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class ChannelzGrpc {\n \n\ndiff --git a/services/src/generated/main/grpc/io/grpc/health/v1/HealthGrpc.java b/services/src/generated/main/grpc/io/grpc/health/v1/HealthGrpc.java\nindex 9786392cfe6..feb5932b0d9 100644\n--- a/services/src/generated/main/grpc/io/grpc/health/v1/HealthGrpc.java\n+++ b/services/src/generated/main/grpc/io/grpc/health/v1/HealthGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/health/v1/health.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class HealthGrpc {\n \n\ndiff --git a/services/src/generated/main/grpc/io/grpc/reflection/v1/ServerReflectionGrpc.java b/services/src/generated/main/grpc/io/grpc/reflection/v1/ServerReflectionGrpc.java\nindex 19bf6ed90b3..04f8dea3ace 100644\n--- a/services/src/generated/main/grpc/io/grpc/reflection/v1/ServerReflectionGrpc.java\n+++ b/services/src/generated/main/grpc/io/grpc/reflection/v1/ServerReflectionGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/reflection/v1/reflection.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class ServerReflectionGrpc {\n \n\ndiff --git a/services/src/generated/main/grpc/io/grpc/reflection/v1alpha/ServerReflectionGrpc.java b/services/src/generated/main/grpc/io/grpc/reflection/v1alpha/ServerReflectionGrpc.java\nindex 152a8f7c81d..3cbb3a1d1b9 100644\n--- a/services/src/generated/main/grpc/io/grpc/reflection/v1alpha/ServerReflectionGrpc.java\n+++ b/services/src/generated/main/grpc/io/grpc/reflection/v1alpha/ServerReflectionGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/reflection/v1alpha/reflection.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class ServerReflectionGrpc {\n \n\ndiff --git a/stub/BUILD.bazel b/stub/BUILD.bazel\nindex 572ea681ef3..692ebd6059f 100644\n--- a/stub/BUILD.bazel\n+++ b/stub/BUILD.bazel\n@@ -15,12 +15,3 @@ java_library(\n         artifact(\"org.codehaus.mojo:animal-sniffer-annotations\"),\n     ],\n )\n-\n-# javax.annotation.Generated is not included in the default root modules in 9,\n-# see: http://openjdk.java.net/jeps/320.\n-java_library(\n-    name = \"javax_annotation\",\n-    neverlink = 1,  # @Generated is source-retention\n-    visibility = [\"//visibility:public\"],\n-    exports = [artifact(\"org.apache.tomcat:annotations-api\")],\n-)\n\ndiff --git a/xds/src/generated/thirdparty/grpc/com/github/xds/service/orca/v3/OpenRcaServiceGrpc.java b/xds/src/generated/thirdparty/grpc/com/github/xds/service/orca/v3/OpenRcaServiceGrpc.java\nindex cb129fd31ba..e0e28ad4072 100644\n--- a/xds/src/generated/thirdparty/grpc/com/github/xds/service/orca/v3/OpenRcaServiceGrpc.java\n+++ b/xds/src/generated/thirdparty/grpc/com/github/xds/service/orca/v3/OpenRcaServiceGrpc.java\n@@ -14,9 +14,6 @@\n  * a new call to change backend reporting frequency.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: xds/service/orca/v3/orca.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class OpenRcaServiceGrpc {\n \n\ndiff --git a/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/discovery/v3/AggregatedDiscoveryServiceGrpc.java b/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/discovery/v3/AggregatedDiscoveryServiceGrpc.java\nindex b93a5df2b71..94b2fd86b96 100644\n--- a/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/discovery/v3/AggregatedDiscoveryServiceGrpc.java\n+++ b/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/discovery/v3/AggregatedDiscoveryServiceGrpc.java\n@@ -12,9 +12,6 @@\n  * the multiplexed singleton APIs at the Envoy instance and management server.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: envoy/service/discovery/v3/ads.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class AggregatedDiscoveryServiceGrpc {\n \n\ndiff --git a/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/load_stats/v3/LoadReportingServiceGrpc.java b/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/load_stats/v3/LoadReportingServiceGrpc.java\nindex 3bce13a7cf5..4f12405be87 100644\n--- a/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/load_stats/v3/LoadReportingServiceGrpc.java\n+++ b/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/load_stats/v3/LoadReportingServiceGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: envoy/service/load_stats/v3/lrs.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class LoadReportingServiceGrpc {\n \n\ndiff --git a/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/rate_limit_quota/v3/RateLimitQuotaServiceGrpc.java b/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/rate_limit_quota/v3/RateLimitQuotaServiceGrpc.java\nindex f05d38290dd..3f17bb54566 100644\n--- a/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/rate_limit_quota/v3/RateLimitQuotaServiceGrpc.java\n+++ b/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/rate_limit_quota/v3/RateLimitQuotaServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * Defines the Rate Limit Quota Service (RLQS).\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: envoy/service/rate_limit_quota/v3/rlqs.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class RateLimitQuotaServiceGrpc {\n \n\ndiff --git a/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/status/v3/ClientStatusDiscoveryServiceGrpc.java b/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/status/v3/ClientStatusDiscoveryServiceGrpc.java\nindex 1a3240875cc..775fa0c1e3e 100644\n--- a/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/status/v3/ClientStatusDiscoveryServiceGrpc.java\n+++ b/xds/src/generated/thirdparty/grpc/io/envoyproxy/envoy/service/status/v3/ClientStatusDiscoveryServiceGrpc.java\n@@ -9,9 +9,6 @@\n  * also be used to get the current xDS states directly from the client.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: envoy/service/status/v3/csds.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class ClientStatusDiscoveryServiceGrpc {\n \n",
    "test_patch": "diff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\nindex 120033a8051..42934e94c5b 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A service used to obtain stats for verifying LB behavior.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class LoadBalancerStatsServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\nindex 489838ddc6c..6c2166468f6 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/metrics.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class MetricsServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\nindex e0ea29e42e7..07ce250bc4b 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A service used to control reconnect server.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class ReconnectServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/TestServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/TestServiceGrpc.java\nindex a0f44f46473..4593215b601 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/TestServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/TestServiceGrpc.java\n@@ -8,9 +8,6 @@\n  * performance with various types of payload.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class TestServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\nindex f758c2d0840..d9ef0e6ddd9 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\n@@ -8,9 +8,6 @@\n  * that case.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class UnimplementedServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\nindex 5fa43e4721a..8ae0c2f93a4 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A service to dynamically update the configuration of an xDS test client.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class XdsUpdateClientConfigureServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\nindex 2492ec0f90b..5b950c73c12 100644\n--- a/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\n+++ b/android-interop-testing/src/generated/debug/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A service to remotely control health status of an xDS test server.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class XdsUpdateHealthServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\nindex 120033a8051..42934e94c5b 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A service used to obtain stats for verifying LB behavior.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class LoadBalancerStatsServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\nindex 489838ddc6c..6c2166468f6 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/metrics.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class MetricsServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\nindex e0ea29e42e7..07ce250bc4b 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A service used to control reconnect server.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class ReconnectServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/TestServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/TestServiceGrpc.java\nindex a0f44f46473..4593215b601 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/TestServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/TestServiceGrpc.java\n@@ -8,9 +8,6 @@\n  * performance with various types of payload.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class TestServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\nindex f758c2d0840..d9ef0e6ddd9 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\n@@ -8,9 +8,6 @@\n  * that case.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class UnimplementedServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\nindex 5fa43e4721a..8ae0c2f93a4 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A service to dynamically update the configuration of an xDS test client.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class XdsUpdateClientConfigureServiceGrpc {\n \n\ndiff --git a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\nindex 2492ec0f90b..5b950c73c12 100644\n--- a/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\n+++ b/android-interop-testing/src/generated/release/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A service to remotely control health status of an xDS test server.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class XdsUpdateHealthServiceGrpc {\n \n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\nindex f060a1308d8..766d63a51dc 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/LoadBalancerStatsServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A service used to obtain stats for verifying LB behavior.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class LoadBalancerStatsServiceGrpc {\n \n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\nindex 3104f7b263e..8693f1086bb 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/MetricsServiceGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/metrics.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class MetricsServiceGrpc {\n \n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\nindex 39df95f4d90..164c92295cc 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/ReconnectServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A service used to control reconnect server.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class ReconnectServiceGrpc {\n \n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/TestServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/TestServiceGrpc.java\nindex 2b519686d85..b8c220925e1 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/TestServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/TestServiceGrpc.java\n@@ -8,9 +8,6 @@\n  * performance with various types of payload.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class TestServiceGrpc {\n \n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\nindex 400ac6dc4a3..fe6c7c7d1c6 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/UnimplementedServiceGrpc.java\n@@ -8,9 +8,6 @@\n  * that case.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class UnimplementedServiceGrpc {\n \n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\nindex 9cc13780723..9a628ea1b1a 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateClientConfigureServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A service to dynamically update the configuration of an xDS test client.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class XdsUpdateClientConfigureServiceGrpc {\n \n\ndiff --git a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\nindex 8243ba713fa..5582c60d9cc 100644\n--- a/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\n+++ b/interop-testing/src/generated/main/grpc/io/grpc/testing/integration/XdsUpdateHealthServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A service to remotely control health status of an xDS test server.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: grpc/testing/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class XdsUpdateHealthServiceGrpc {\n \n\ndiff --git a/istio-interop-testing/src/generated/main/grpc/io/istio/test/EchoTestServiceGrpc.java b/istio-interop-testing/src/generated/main/grpc/io/istio/test/EchoTestServiceGrpc.java\nindex 3cb27ac1067..c6947a075d5 100644\n--- a/istio-interop-testing/src/generated/main/grpc/io/istio/test/EchoTestServiceGrpc.java\n+++ b/istio-interop-testing/src/generated/main/grpc/io/istio/test/EchoTestServiceGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: test/echo/proto/echo.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class EchoTestServiceGrpc {\n \n\ndiff --git a/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherDynamicServiceGrpc.java b/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherDynamicServiceGrpc.java\nindex a53d199ef52..5b7aaa1e4ec 100644\n--- a/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherDynamicServiceGrpc.java\n+++ b/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherDynamicServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * AnotherDynamicService\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: io/grpc/reflection/testing/dynamic_reflection_test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class AnotherDynamicServiceGrpc {\n \n\ndiff --git a/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherReflectableServiceGrpc.java b/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherReflectableServiceGrpc.java\nindex a22138ecb03..f8b8d58e621 100644\n--- a/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherReflectableServiceGrpc.java\n+++ b/services/src/generated/test/grpc/io/grpc/reflection/testing/AnotherReflectableServiceGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: io/grpc/reflection/testing/reflection_test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class AnotherReflectableServiceGrpc {\n \n\ndiff --git a/services/src/generated/test/grpc/io/grpc/reflection/testing/DynamicServiceGrpc.java b/services/src/generated/test/grpc/io/grpc/reflection/testing/DynamicServiceGrpc.java\nindex 6e9dfac72db..81e60438518 100644\n--- a/services/src/generated/test/grpc/io/grpc/reflection/testing/DynamicServiceGrpc.java\n+++ b/services/src/generated/test/grpc/io/grpc/reflection/testing/DynamicServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A DynamicService\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: io/grpc/reflection/testing/dynamic_reflection_test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class DynamicServiceGrpc {\n \n\ndiff --git a/services/src/generated/test/grpc/io/grpc/reflection/testing/ReflectableServiceGrpc.java b/services/src/generated/test/grpc/io/grpc/reflection/testing/ReflectableServiceGrpc.java\nindex aeefc77aff8..5f620038b2c 100644\n--- a/services/src/generated/test/grpc/io/grpc/reflection/testing/ReflectableServiceGrpc.java\n+++ b/services/src/generated/test/grpc/io/grpc/reflection/testing/ReflectableServiceGrpc.java\n@@ -4,9 +4,6 @@\n \n /**\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: io/grpc/reflection/testing/reflection_test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class ReflectableServiceGrpc {\n \n\ndiff --git a/testing-proto/src/generated/main/grpc/io/grpc/testing/protobuf/SimpleServiceGrpc.java b/testing-proto/src/generated/main/grpc/io/grpc/testing/protobuf/SimpleServiceGrpc.java\nindex 8b33691535d..cccc4eb8f8a 100644\n--- a/testing-proto/src/generated/main/grpc/io/grpc/testing/protobuf/SimpleServiceGrpc.java\n+++ b/testing-proto/src/generated/main/grpc/io/grpc/testing/protobuf/SimpleServiceGrpc.java\n@@ -7,9 +7,6 @@\n  * A simple service for test.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler\",\n-    comments = \"Source: io/grpc/testing/protobuf/simpleservice.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class SimpleServiceGrpc {\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-12054",
    "pr_id": 12054,
    "issue_id": 11996,
    "repo": "grpc/grpc-java",
    "problem_statement": "Make least request available by default (remove experimental environment variable)\n### Is your feature request related to a problem?\n\nThe least request load balancer has been implemented and released behind an environment variable since July 2022 (grpc-java 1.48.0). To my knowledge it has been used in production by spotify for about as long. The last significant change is in https://github.com/grpc/grpc-java/releases/tag/v1.63.0 to fix a race introduced a few versions before.\n\n### Describe the solution you'd like\n\nRemove the `GRPC_EXPERIMENTAL_ENABLE_LEAST_REQUEST` environment variable, so that least request is always available.\n\nSame issue in Go: https://github.com/grpc/grpc-go/issues/8228\n",
    "issue_word_count": 111,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "xds/src/main/java/io/grpc/xds/XdsClusterResource.java",
      "xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java"
    ],
    "pr_changed_test_files": [
      "xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java"
    ],
    "base_commit": "3f5fdf12663dac0d221e6b9fb4b0dfed7486a6a9",
    "head_commit": "f2c7f3236687c3cffdb139e16a8b9a9f853775cd",
    "repo_url": "https://github.com/grpc/grpc-java/pull/12054",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/12054",
    "dockerfile": "",
    "pr_merged_at": "2025-05-14T07:53:37.000Z",
    "patch": "diff --git a/xds/src/main/java/io/grpc/xds/XdsClusterResource.java b/xds/src/main/java/io/grpc/xds/XdsClusterResource.java\nindex 0d9274e2869..3f2b2d8fd7e 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsClusterResource.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsClusterResource.java\n@@ -60,7 +60,8 @@ class XdsClusterResource extends XdsResourceType<CdsUpdate> {\n   static boolean enableLeastRequest =\n       !Strings.isNullOrEmpty(System.getenv(\"GRPC_EXPERIMENTAL_ENABLE_LEAST_REQUEST\"))\n           ? Boolean.parseBoolean(System.getenv(\"GRPC_EXPERIMENTAL_ENABLE_LEAST_REQUEST\"))\n-          : Boolean.parseBoolean(System.getProperty(\"io.grpc.xds.experimentalEnableLeastRequest\"));\n+          : Boolean.parseBoolean(\n+              System.getProperty(\"io.grpc.xds.experimentalEnableLeastRequest\", \"true\"));\n   @VisibleForTesting\n   public static boolean enableSystemRootCerts =\n       GrpcUtil.getFlag(\"GRPC_EXPERIMENTAL_XDS_SYSTEM_ROOT_CERTS\", false);\n",
    "test_patch": "diff --git a/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java b/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java\nindex e5502463db0..dd6f2fd9243 100644\n--- a/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java\n+++ b/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java\n@@ -186,7 +186,6 @@ public void setUp() {\n     originalEnableRouteLookup = XdsRouteConfigureResource.enableRouteLookup;\n     originalEnableLeastRequest = XdsClusterResource.enableLeastRequest;\n     originalEnableUseSystemRootCerts = XdsClusterResource.enableSystemRootCerts;\n-    assertThat(originalEnableLeastRequest).isFalse();\n   }\n \n   @After\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11997",
    "pr_id": 11997,
    "issue_id": 11995,
    "repo": "grpc/grpc-java",
    "problem_statement": "ClusterResolverLB uses ResolutionResult.getAddresses()\n#11330 introduced a StatusOr for addresses within ResolutionResult. It marked the old getAddresses() as deprecated, because it can throw. ManagedChannelImpl was updated in the same PR but `xds/build.gradle` has `-Xlint:-deprecation` so the usage in ClusterResolverLB was missed.\n\nThis is fairly serious as a DNS failure when LOGICAL_DNS is in use probably would cause a channel panic. We'll want to release patch releases for older versions (at least 1.71 and 1.70).",
    "issue_word_count": 80,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java",
      "xds/src/test/java/io/grpc/xds/ClusterResolverLoadBalancerTest.java"
    ],
    "pr_changed_test_files": [
      "xds/src/test/java/io/grpc/xds/ClusterResolverLoadBalancerTest.java"
    ],
    "base_commit": "d4c46a7f1fe67bad762139a679b3597dd8c1849d",
    "head_commit": "d56f10b6f74b4d1636f5f6839b5b257ac4b7e53b",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11997",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11997",
    "dockerfile": "",
    "pr_merged_at": "2025-04-04T16:38:29.000Z",
    "patch": "diff --git a/xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java b/xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java\nindex c92f592ebc8..0fb7cf15909 100644\n--- a/xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java\n+++ b/xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java\n@@ -33,6 +33,7 @@\n import io.grpc.NameResolver;\n import io.grpc.NameResolver.ResolutionResult;\n import io.grpc.Status;\n+import io.grpc.StatusOr;\n import io.grpc.SynchronizationContext;\n import io.grpc.SynchronizationContext.ScheduledHandle;\n import io.grpc.internal.BackoffPolicy;\n@@ -657,79 +658,84 @@ private class NameResolverListener extends NameResolver.Listener2 {\n \n         @Override\n         public void onResult(final ResolutionResult resolutionResult) {\n-          class NameResolved implements Runnable {\n-            @Override\n-            public void run() {\n-              if (shutdown) {\n-                return;\n-              }\n-              backoffPolicy = null;  // reset backoff sequence if succeeded\n-              // Arbitrary priority notation for all DNS-resolved endpoints.\n-              String priorityName = priorityName(name, 0);  // value doesn't matter\n-              List<EquivalentAddressGroup> addresses = new ArrayList<>();\n-              for (EquivalentAddressGroup eag : resolutionResult.getAddresses()) {\n-                // No weight attribute is attached, all endpoint-level LB policy should be able\n-                // to handle such it.\n-                String localityName = localityName(LOGICAL_DNS_CLUSTER_LOCALITY);\n-                Attributes attr = eag.getAttributes().toBuilder()\n-                    .set(XdsAttributes.ATTR_LOCALITY, LOGICAL_DNS_CLUSTER_LOCALITY)\n-                    .set(XdsAttributes.ATTR_LOCALITY_NAME, localityName)\n-                    .set(XdsAttributes.ATTR_ADDRESS_NAME, dnsHostName)\n-                    .build();\n-                eag = new EquivalentAddressGroup(eag.getAddresses(), attr);\n-                eag = AddressFilter.setPathFilter(eag, Arrays.asList(priorityName, localityName));\n-                addresses.add(eag);\n-              }\n-              PriorityChildConfig priorityChildConfig = generateDnsBasedPriorityChildConfig(\n-                  name, lrsServerInfo, maxConcurrentRequests, tlsContext, filterMetadata,\n-                  lbRegistry, Collections.<DropOverload>emptyList());\n-              status = Status.OK;\n-              resolved = true;\n-              result = new ClusterResolutionResult(addresses, priorityName, priorityChildConfig);\n-              handleEndpointResourceUpdate();\n+          syncContext.execute(() -> onResult2(resolutionResult));\n+        }\n+\n+        @Override\n+        public Status onResult2(final ResolutionResult resolutionResult) {\n+          if (shutdown) {\n+            return Status.OK;\n+          }\n+          // Arbitrary priority notation for all DNS-resolved endpoints.\n+          String priorityName = priorityName(name, 0);  // value doesn't matter\n+          List<EquivalentAddressGroup> addresses = new ArrayList<>();\n+          StatusOr<List<EquivalentAddressGroup>> addressesOrError =\n+                  resolutionResult.getAddressesOrError();\n+          if (addressesOrError.hasValue()) {\n+            backoffPolicy = null;  // reset backoff sequence if succeeded\n+            for (EquivalentAddressGroup eag : resolutionResult.getAddresses()) {\n+              // No weight attribute is attached, all endpoint-level LB policy should be able\n+              // to handle such it.\n+              String localityName = localityName(LOGICAL_DNS_CLUSTER_LOCALITY);\n+              Attributes attr = eag.getAttributes().toBuilder()\n+                      .set(XdsAttributes.ATTR_LOCALITY, LOGICAL_DNS_CLUSTER_LOCALITY)\n+                      .set(XdsAttributes.ATTR_LOCALITY_NAME, localityName)\n+                      .set(XdsAttributes.ATTR_ADDRESS_NAME, dnsHostName)\n+                      .build();\n+              eag = new EquivalentAddressGroup(eag.getAddresses(), attr);\n+              eag = AddressFilter.setPathFilter(eag, Arrays.asList(priorityName, localityName));\n+              addresses.add(eag);\n             }\n+            PriorityChildConfig priorityChildConfig = generateDnsBasedPriorityChildConfig(\n+                    name, lrsServerInfo, maxConcurrentRequests, tlsContext, filterMetadata,\n+                    lbRegistry, Collections.<DropOverload>emptyList());\n+            status = Status.OK;\n+            resolved = true;\n+            result = new ClusterResolutionResult(addresses, priorityName, priorityChildConfig);\n+            handleEndpointResourceUpdate();\n+            return Status.OK;\n+          } else {\n+            handleErrorInSyncContext(addressesOrError.getStatus());\n+            return addressesOrError.getStatus();\n           }\n-\n-          syncContext.execute(new NameResolved());\n         }\n \n         @Override\n         public void onError(final Status error) {\n-          syncContext.execute(new Runnable() {\n-            @Override\n-            public void run() {\n-              if (shutdown) {\n-                return;\n-              }\n-              status = error;\n-              // NameResolver.Listener API cannot distinguish between address-not-found and\n-              // transient errors. If the error occurs in the first resolution, treat it as\n-              // address not found. Otherwise, either there is previously resolved addresses\n-              // previously encountered error, propagate the error to downstream/upstream and\n-              // let downstream/upstream handle it.\n-              if (!resolved) {\n-                resolved = true;\n-                handleEndpointResourceUpdate();\n-              } else {\n-                handleEndpointResolutionError();\n-              }\n-              if (scheduledRefresh != null && scheduledRefresh.isPending()) {\n-                return;\n-              }\n-              if (backoffPolicy == null) {\n-                backoffPolicy = backoffPolicyProvider.get();\n-              }\n-              long delayNanos = backoffPolicy.nextBackoffNanos();\n-              logger.log(XdsLogLevel.DEBUG,\n+          syncContext.execute(() -> handleErrorInSyncContext(error));\n+        }\n+\n+        private void handleErrorInSyncContext(final Status error) {\n+          if (shutdown) {\n+            return;\n+          }\n+          status = error;\n+          // NameResolver.Listener API cannot distinguish between address-not-found and\n+          // transient errors. If the error occurs in the first resolution, treat it as\n+          // address not found. Otherwise, either there is previously resolved addresses\n+          // previously encountered error, propagate the error to downstream/upstream and\n+          // let downstream/upstream handle it.\n+          if (!resolved) {\n+            resolved = true;\n+            handleEndpointResourceUpdate();\n+          } else {\n+            handleEndpointResolutionError();\n+          }\n+          if (scheduledRefresh != null && scheduledRefresh.isPending()) {\n+            return;\n+          }\n+          if (backoffPolicy == null) {\n+            backoffPolicy = backoffPolicyProvider.get();\n+          }\n+          long delayNanos = backoffPolicy.nextBackoffNanos();\n+          logger.log(XdsLogLevel.DEBUG,\n                   \"Logical DNS resolver for cluster {0} encountered name resolution \"\n-                      + \"error: {1}, scheduling DNS resolution backoff for {2} ns\",\n+                          + \"error: {1}, scheduling DNS resolution backoff for {2} ns\",\n                   name, error, delayNanos);\n-              scheduledRefresh =\n+          scheduledRefresh =\n                   syncContext.schedule(\n-                      new DelayedNameResolverRefresh(), delayNanos, TimeUnit.NANOSECONDS,\n-                      timeService);\n-            }\n-          });\n+                          new DelayedNameResolverRefresh(), delayNanos, TimeUnit.NANOSECONDS,\n+                          timeService);\n         }\n       }\n     }\n",
    "test_patch": "diff --git a/xds/src/test/java/io/grpc/xds/ClusterResolverLoadBalancerTest.java b/xds/src/test/java/io/grpc/xds/ClusterResolverLoadBalancerTest.java\nindex d0176d7aa38..d701f281c01 100644\n--- a/xds/src/test/java/io/grpc/xds/ClusterResolverLoadBalancerTest.java\n+++ b/xds/src/test/java/io/grpc/xds/ClusterResolverLoadBalancerTest.java\n@@ -200,6 +200,7 @@ public XdsClient returnObject(Object object) {\n   private ArgumentCaptor<SubchannelPicker> pickerCaptor;\n   private int xdsClientRefs;\n   private ClusterResolverLoadBalancer loadBalancer;\n+  private NameResolverProvider fakeNameResolverProvider;\n \n   @Before\n   public void setUp() throws URISyntaxException {\n@@ -216,7 +217,8 @@ public void setUp() throws URISyntaxException {\n         .setServiceConfigParser(mock(ServiceConfigParser.class))\n         .setChannelLogger(mock(ChannelLogger.class))\n         .build();\n-    nsRegistry.register(new FakeNameResolverProvider());\n+    fakeNameResolverProvider = new FakeNameResolverProvider(false);\n+    nsRegistry.register(fakeNameResolverProvider);\n     when(helper.getNameResolverRegistry()).thenReturn(nsRegistry);\n     when(helper.getNameResolverArgs()).thenReturn(args);\n     when(helper.getSynchronizationContext()).thenReturn(syncContext);\n@@ -826,6 +828,17 @@ public void handleEdsResource_noHealthyEndpoint() {\n \n   @Test\n   public void onlyLogicalDnsCluster_endpointsResolved() {\n+    do_onlyLogicalDnsCluster_endpointsResolved();\n+  }\n+\n+  @Test\n+  public void oldListenerCallback_onlyLogicalDnsCluster_endpointsResolved() {\n+    nsRegistry.deregister(fakeNameResolverProvider);\n+    nsRegistry.register(new FakeNameResolverProvider(true));\n+    do_onlyLogicalDnsCluster_endpointsResolved();\n+  }\n+\n+  void do_onlyLogicalDnsCluster_endpointsResolved() {\n     ClusterResolverConfig config = new ClusterResolverConfig(\n         Collections.singletonList(logicalDnsDiscoveryMechanism), roundRobin, false);\n     deliverLbConfig(config);\n@@ -854,7 +867,6 @@ public void onlyLogicalDnsCluster_endpointsResolved() {\n         .get(XdsAttributes.ATTR_ADDRESS_NAME)).isEqualTo(DNS_HOST_NAME);\n     assertThat(childBalancer.addresses.get(1).getAttributes()\n         .get(XdsAttributes.ATTR_ADDRESS_NAME)).isEqualTo(DNS_HOST_NAME);\n-\n   }\n \n   @Test\n@@ -874,37 +886,48 @@ public void onlyLogicalDnsCluster_handleRefreshNameResolution() {\n   }\n \n   @Test\n-  public void onlyLogicalDnsCluster_resolutionError_backoffAndRefresh() {\n+  public void resolutionError_backoffAndRefresh() {\n+    do_onlyLogicalDnsCluster_resolutionError_backoffAndRefresh();\n+  }\n+\n+  @Test\n+  public void oldListenerCallback_resolutionError_backoffAndRefresh() {\n+    nsRegistry.deregister(fakeNameResolverProvider);\n+    nsRegistry.register(new FakeNameResolverProvider(true));\n+    do_onlyLogicalDnsCluster_resolutionError_backoffAndRefresh();\n+  }\n+\n+  void do_onlyLogicalDnsCluster_resolutionError_backoffAndRefresh() {\n     InOrder inOrder = Mockito.inOrder(helper, backoffPolicyProvider,\n-        backoffPolicy1, backoffPolicy2);\n+            backoffPolicy1, backoffPolicy2);\n     ClusterResolverConfig config = new ClusterResolverConfig(\n-        Collections.singletonList(logicalDnsDiscoveryMechanism), roundRobin, false);\n+            Collections.singletonList(logicalDnsDiscoveryMechanism), roundRobin, false);\n     deliverLbConfig(config);\n     FakeNameResolver resolver = assertResolverCreated(\"/\" + DNS_HOST_NAME);\n     assertThat(childBalancers).isEmpty();\n     Status error = Status.UNAVAILABLE.withDescription(\"cannot reach DNS server\");\n     resolver.deliverError(error);\n     inOrder.verify(helper).updateBalancingState(\n-        eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+            eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n     assertPicker(pickerCaptor.getValue(), error, null);\n     assertThat(resolver.refreshCount).isEqualTo(0);\n     inOrder.verify(backoffPolicyProvider).get();\n     inOrder.verify(backoffPolicy1).nextBackoffNanos();\n     assertThat(fakeClock.getPendingTasks()).hasSize(1);\n     assertThat(Iterables.getOnlyElement(fakeClock.getPendingTasks()).getDelay(TimeUnit.SECONDS))\n-        .isEqualTo(1L);\n+            .isEqualTo(1L);\n     fakeClock.forwardTime(1L, TimeUnit.SECONDS);\n     assertThat(resolver.refreshCount).isEqualTo(1);\n \n     error = Status.UNKNOWN.withDescription(\"I am lost\");\n     resolver.deliverError(error);\n     inOrder.verify(helper).updateBalancingState(\n-        eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+            eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n     inOrder.verify(backoffPolicy1).nextBackoffNanos();\n     assertPicker(pickerCaptor.getValue(), error, null);\n     assertThat(fakeClock.getPendingTasks()).hasSize(1);\n     assertThat(Iterables.getOnlyElement(fakeClock.getPendingTasks()).getDelay(TimeUnit.SECONDS))\n-        .isEqualTo(10L);\n+            .isEqualTo(10L);\n     fakeClock.forwardTime(10L, TimeUnit.SECONDS);\n     assertThat(resolver.refreshCount).isEqualTo(2);\n \n@@ -914,7 +937,7 @@ public void onlyLogicalDnsCluster_resolutionError_backoffAndRefresh() {\n     resolver.deliverEndpointAddresses(Arrays.asList(endpoint1, endpoint2));\n     assertThat(childBalancers).hasSize(1);\n     assertAddressesEqual(Arrays.asList(endpoint1, endpoint2),\n-        Iterables.getOnlyElement(childBalancers).addresses);\n+            Iterables.getOnlyElement(childBalancers).addresses);\n \n     assertThat(fakeClock.getPendingTasks()).isEmpty();\n     inOrder.verifyNoMoreInteractions();\n@@ -1319,10 +1342,18 @@ void deliverError(Status error) {\n   }\n \n   private class FakeNameResolverProvider extends NameResolverProvider {\n+    private final boolean useOldListenerCallback;\n+\n+    private FakeNameResolverProvider(boolean useOldListenerCallback) {\n+      this.useOldListenerCallback = useOldListenerCallback;\n+    }\n+\n     @Override\n     public NameResolver newNameResolver(URI targetUri, NameResolver.Args args) {\n       assertThat(targetUri.getScheme()).isEqualTo(\"dns\");\n-      FakeNameResolver resolver = new FakeNameResolver(targetUri);\n+      FakeNameResolver resolver = useOldListenerCallback\n+              ? new FakeNameResolverUsingOldListenerCallback(targetUri)\n+              : new FakeNameResolver(targetUri);\n       resolvers.add(resolver);\n       return resolver;\n     }\n@@ -1343,9 +1374,10 @@ protected int priority() {\n     }\n   }\n \n+\n   private class FakeNameResolver extends NameResolver {\n     private final URI targetUri;\n-    private Listener2 listener;\n+    protected Listener2 listener;\n     private int refreshCount;\n \n     private FakeNameResolver(URI targetUri) {\n@@ -1372,12 +1404,33 @@ public void shutdown() {\n       resolvers.remove(this);\n     }\n \n-    private void deliverEndpointAddresses(List<EquivalentAddressGroup> addresses) {\n+    protected void deliverEndpointAddresses(List<EquivalentAddressGroup> addresses) {\n+      syncContext.execute(() -> {\n+        Status ret = listener.onResult2(ResolutionResult.newBuilder()\n+                .setAddressesOrError(StatusOr.fromValue(addresses)).build());\n+        assertThat(ret.getCode()).isEqualTo(Status.Code.OK);\n+      });\n+    }\n+\n+    protected void deliverError(Status error) {\n+      syncContext.execute(() -> listener.onResult2(ResolutionResult.newBuilder()\n+                      .setAddressesOrError(StatusOr.fromStatus(error)).build()));\n+    }\n+  }\n+\n+  private class FakeNameResolverUsingOldListenerCallback extends FakeNameResolver {\n+    private FakeNameResolverUsingOldListenerCallback(URI targetUri) {\n+      super(targetUri);\n+    }\n+\n+    @Override\n+    protected void deliverEndpointAddresses(List<EquivalentAddressGroup> addresses) {\n       listener.onResult(ResolutionResult.newBuilder()\n-          .setAddressesOrError(StatusOr.fromValue(addresses)).build());\n+              .setAddressesOrError(StatusOr.fromValue(addresses)).build());\n     }\n \n-    private void deliverError(Status error) {\n+    @Override\n+    protected void deliverError(Status error) {\n       listener.onError(error);\n     }\n   }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11979",
    "pr_id": 11979,
    "issue_id": 11973,
    "repo": "grpc/grpc-java",
    "problem_statement": "NullPointerException when calling onError(StatusRuntimeException)\n<!-- Please answer these questions before submitting a bug report. -->\n\n### What version of gRPC-Java are you using?\n\nv1.71.0\n\n### What is your environment?\n\nLinux\n\n### What did you expect to see?\n\nI was not expecting onError to throw NullPointerException.\n\n### What did you see instead?\n\nIt threw NPE.\n\n### Steps to reproduce the bug\n\nWe have been seeing some rare `NullPointerException` or `ArrayIndexOutOfBoundsException` when calling `onError` on an incoming server call. This happens several times per day across all of our services, which translates to maybe one in a few billion calls or so. The exception looks like this:\n\n```\njava.lang.NullPointerException: Cannot invoke \"io.grpc.Metadata$LazyValue.toBytes()\" because \"value\" is null\n\tat io.grpc.Metadata.valueAsBytes(Metadata.java:183)\n\tat io.grpc.Metadata.serialize(Metadata.java:474)\n\tat io.grpc.InternalMetadata.serialize(InternalMetadata.java:79)\n\tat io.grpc.internal.TransportFrameUtil.toHttp2Headers(TransportFrameUtil.java:51)\n\tat io.grpc.netty.Utils.convertTrailers(Utils.java:327)\n\tat io.grpc.netty.NettyServerStream$Sink.writeTrailers(NettyServerStream.java:131)\n\tat io.grpc.internal.AbstractServerStream.close(AbstractServerStream.java:133)\n\tat io.grpc.internal.ServerCallImpl.closeInternal(ServerCallImpl.java:227)\n\tat io.grpc.internal.ServerCallImpl.close(ServerCallImpl.java:213)\n\tat io.grpc.stub.ServerCalls$ServerCallStreamObserverImpl.onError(ServerCalls.java:389)\n```\n\nIn order to debug this, we added some code to use reflection to dump the internal structure of the `Metadata` object that throws. Here are some examples:\n\n```\n[grpc-status,14,grpc-message,Channel shutdown invoked,null,null,null,null]\n[grpc-status,14,grpc-message,Network closed for unknown reason,null,null,null,null]\n[null,null,grpc-status,14,grpc-message,Channel shutdown invoked,null,null]\n[grpc-status,14,grpc-message,Channel shutdown invoked,null,null,grpc-message,Channel shutdown invoked]\n[grpc-status,14,grpc-message,Channel shutdown invoked,null,null,null,null]\n```\n\nSome of these look perfectly valid, while others have the expected content, but in an unusual order, with `null` elements at the beginning or between entries. *The documentation for `Metadata` clearly says that it is mutable and not thread-safe, and this appears to be due to multi-threaded mutation of the `Metadata` object.*\n\nWe initially found this surprising: we're not setting or mutating metadata anywhere.\n\nAfter reviewing the grpc-java source code, we discovered the following sequence of events:\n\nWe call\n```io.grpc.stub.ServerCalls$ServerCallStreamObserverImpl.onError```\nwhich calls\n```Metadata metadata = Status.trailersFromThrowable(t);```\nand then calls\n```io.grpc.internal.ServerCallImpl.close(ServerCallImpl.java:213)```\nwhich calls\n```io.grpc.internal.ServerCallImpl.closeInternal(ServerCallImpl.java:227)```\nwhich calls\n```io.grpc.internal.AbstractServerStream.close(AbstractServerStream.java:133)```\nwhich calls\n```addStatusToTrailers```\nwhich mutates the `Metadata` object.\n\nThe Metadata object mutated here is the `Metadata` object stored in the `StatusRuntimeException` that we passed to `onError`. Who owns that instance?\n\nWhat actually happens in our code is that we make outgoing gRPC calls to other services which fail with a `StatusRuntimeException`, and then we use the same instance to reply to multiple incoming gRPC calls on different threads. When we see the concurrent mutation of the `Metadata` object, that's because the `onError` call unconditionally mutates the `Metadata`, which is now shared across multiple threads.\n\nThe code is racing with itself, and this happens even when the application code never sets or modifies `Metadata` objects. This is not great.\n\nPersonally, I think it's surprising and problematic to mutate the `Metadata` that's attached to a `SRE` in the `onError` call. I would prefer `StatusRuntimeException` to be effectively immutable.\n\nAt a minimum, it would be good to explicitly document that `StatusRuntimeException` is not thread-safe and should not be shared across threads (unfortunately, we end up storing it in `Future` objects, which is difficult to fix on our side). This would - at least - have pointed us in the right direction earlier.\n\nOther options:\n- Make `SRE` immutable by copying the metadata whenever it's returned from `getTrailers`, but this would have performance implications.\n- Make `onError` not mutate the passed-in `Metadata` object:\n  - Copy the `trailers` if set (performance?).\n  - Don't update the `Metadata` if the status fields match the corresponding `Status` (not a complete solution).\n- Make outgoing client calls throw `SRE` without a `Metadata` object; I believe that the data is currently duplicated via the `Metadata` and the `Status`, even if no other metadata is set (not a complete solution).",
    "issue_word_count": 713,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "stub/src/main/java/io/grpc/stub/ServerCalls.java",
      "stub/src/test/java/io/grpc/stub/ServerCallsTest.java"
    ],
    "pr_changed_test_files": [
      "stub/src/test/java/io/grpc/stub/ServerCallsTest.java"
    ],
    "base_commit": "350f90e1a30abf884f8fa4f40c4a1e8fca9425df",
    "head_commit": "701f6557cf61018aeb23b6838272e9184424ba19",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11979",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11979",
    "dockerfile": "",
    "pr_merged_at": "2025-04-07T21:34:58.000Z",
    "patch": "diff --git a/stub/src/main/java/io/grpc/stub/ServerCalls.java b/stub/src/main/java/io/grpc/stub/ServerCalls.java\nindex 7990a5b34c0..9f0063713cc 100644\n--- a/stub/src/main/java/io/grpc/stub/ServerCalls.java\n+++ b/stub/src/main/java/io/grpc/stub/ServerCalls.java\n@@ -382,9 +382,10 @@ public void onNext(RespT response) {\n \n     @Override\n     public void onError(Throwable t) {\n-      Metadata metadata = Status.trailersFromThrowable(t);\n-      if (metadata == null) {\n-        metadata = new Metadata();\n+      Metadata metadata = new Metadata();\n+      Metadata trailers = Status.trailersFromThrowable(t);\n+      if (trailers != null) {\n+        metadata.merge(trailers);\n       }\n       call.close(Status.fromThrowable(t), metadata);\n       aborted = true;\n",
    "test_patch": "diff --git a/stub/src/test/java/io/grpc/stub/ServerCallsTest.java b/stub/src/test/java/io/grpc/stub/ServerCallsTest.java\nindex 1e51ac10110..6f458facc5e 100644\n--- a/stub/src/test/java/io/grpc/stub/ServerCallsTest.java\n+++ b/stub/src/test/java/io/grpc/stub/ServerCallsTest.java\n@@ -555,6 +555,35 @@ public void invoke(Integer req, StreamObserver<Integer> responseObserver) {\n     listener.onHalfClose();\n   }\n \n+  @Test\n+  public void clientSendsOne_serverOnErrorWithTrailers_serverStreaming() {\n+    Metadata trailers = new Metadata();\n+    Metadata.Key<String> key = Metadata.Key.of(\"trailers-test-key1\",\n+            Metadata.ASCII_STRING_MARSHALLER);\n+    trailers.put(key, \"trailers-test-value1\");\n+\n+    ServerCallRecorder serverCall = new ServerCallRecorder(SERVER_STREAMING_METHOD);\n+    ServerCallHandler<Integer, Integer> callHandler = ServerCalls.asyncServerStreamingCall(\n+        new ServerCalls.ServerStreamingMethod<Integer, Integer>() {\n+          @Override\n+          public void invoke(Integer req, StreamObserver<Integer> responseObserver) {\n+            responseObserver.onError(\n+                    Status.fromCode(Status.Code.INTERNAL)\n+                            .asRuntimeException(trailers)\n+            );\n+          }\n+        });\n+    ServerCall.Listener<Integer> listener = callHandler.startCall(serverCall, new Metadata());\n+    serverCall.isReady = true;\n+    serverCall.isCancelled = false;\n+    listener.onReady();\n+    listener.onMessage(1);\n+    listener.onHalfClose();\n+    // verify trailers key is set\n+    assertTrue(serverCall.trailers.containsKey(key));\n+    assertTrue(serverCall.status.equals(Status.INTERNAL));\n+  }\n+\n   @Test\n   public void inprocessTransportManualFlow() throws Exception {\n     final Semaphore semaphore = new Semaphore(1);\n@@ -652,6 +681,7 @@ private static class ServerCallRecorder extends ServerCall<Integer, Integer> {\n     private boolean isCancelled;\n     private boolean isReady;\n     private int onReadyThreshold;\n+    private Metadata trailers;\n \n     public ServerCallRecorder(MethodDescriptor<Integer, Integer> methodDescriptor) {\n       this.methodDescriptor = methodDescriptor;\n@@ -674,6 +704,7 @@ public void sendMessage(Integer message) {\n     @Override\n     public void close(Status status, Metadata trailers) {\n       this.status = status;\n+      this.trailers = trailers;\n     }\n \n     @Override\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11976",
    "pr_id": 11976,
    "issue_id": 11692,
    "repo": "grpc/grpc-java",
    "problem_statement": "xds: FileWatcherCertificateProvider is leaked\nIn investigating https://github.com/grpc/grpc-java/issues/11678#issuecomment-2477015797 , it was discovered that XdsSecurityClientServerTest looks to create two FileWatcherCertificateProviders each test, but only shuts down one. Since it is using the Channel/Server APIs, this means one of the client or server is highly likely leaking the certificate provider.\r\n\r\nCC @kannanjgithub ",
    "issue_word_count": 58,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java"
    ],
    "pr_changed_test_files": [
      "xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java"
    ],
    "base_commit": "1958e42370d58dc313ed8810f2476ba577e8a7df",
    "head_commit": "9437e705f77f432c46781c394157b7315aaa2798",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11976",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11976",
    "dockerfile": "",
    "pr_merged_at": "2025-03-26T06:13:05.000Z",
    "patch": "",
    "test_patch": "diff --git a/xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java b/xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java\nindex cd3ef293369..380c0591812 100644\n--- a/xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java\n+++ b/xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java\n@@ -130,6 +130,7 @@ public class XdsSecurityClientServerTest {\n   private FakeXdsClient xdsClient = new FakeXdsClient();\n   private FakeXdsClientPoolFactory fakePoolFactory = new FakeXdsClientPoolFactory(xdsClient);\n   private static final String OVERRIDE_AUTHORITY = \"foo.test.google.fr\";\n+  private Attributes sslContextAttributes;\n \n   @Parameters(name = \"enableSpiffe={0}\")\n   public static Collection<Boolean> data() {\n@@ -152,6 +153,14 @@ public void tearDown() throws IOException {\n       NameResolverRegistry.getDefaultRegistry().deregister(fakeNameResolverFactory);\n     }\n     FileWatcherCertificateProviderProvider.enableSpiffe = originalEnableSpiffe;\n+    if (sslContextAttributes != null) {\n+      SslContextProviderSupplier sslContextProviderSupplier = sslContextAttributes.get(\n+              SecurityProtocolNegotiators.ATTR_SSL_CONTEXT_PROVIDER_SUPPLIER);\n+      if (sslContextProviderSupplier != null) {\n+        sslContextProviderSupplier.close();\n+      }\n+      sslContextAttributes = null;\n+    }\n   }\n \n   @Test\n@@ -651,7 +660,7 @@ private SimpleServiceGrpc.SimpleServiceBlockingStub getBlockingStub(\n     InetSocketAddress socketAddress =\n         new InetSocketAddress(Inet4Address.getLoopbackAddress(), port);\n     tlsContextManagerForClient = new TlsContextManagerImpl(bootstrapInfoForClient);\n-    Attributes attrs =\n+    sslContextAttributes =\n         (upstreamTlsContext != null)\n             ? Attributes.newBuilder()\n                 .set(SecurityProtocolNegotiators.ATTR_SSL_CONTEXT_PROVIDER_SUPPLIER,\n@@ -660,7 +669,7 @@ private SimpleServiceGrpc.SimpleServiceBlockingStub getBlockingStub(\n                 .build()\n             : Attributes.EMPTY;\n     fakeNameResolverFactory.setServers(\n-        ImmutableList.of(new EquivalentAddressGroup(socketAddress, attrs)));\n+        ImmutableList.of(new EquivalentAddressGroup(socketAddress, sslContextAttributes)));\n     return SimpleServiceGrpc.newBlockingStub(cleanupRule.register(channelBuilder.build()));\n   }\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11962",
    "pr_id": 11962,
    "issue_id": 7467,
    "repo": "grpc/grpc-java",
    "problem_statement": "JUnit ExpectedException is deprecated\nIn JUnit 4.13 ExpectedException is deprecated. The replacement, `assertThrows`, is Java 8-centric and would be annoying to use in the short-term. Using try+fail would increase boilerplate and would be worse than just using ExpectedException.\r\n\r\nWe can `@SuppressWarnings` for now, but we should swap to assertThrows (or Truth's variant) in the future once we can use Java 8 in our tests.",
    "issue_word_count": 69,
    "test_files_count": 18,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "api/build.gradle",
      "api/src/test/java/io/grpc/MetadataTest.java",
      "api/src/test/java/io/grpc/MethodDescriptorTest.java",
      "api/src/test/java/io/grpc/ServerInterceptorsTest.java",
      "api/src/test/java/io/grpc/ServerServiceDefinitionTest.java",
      "api/src/test/java/io/grpc/ServiceDescriptorTest.java",
      "core/src/test/java/io/grpc/internal/AbstractClientStreamTest.java",
      "core/src/test/java/io/grpc/internal/AbstractServerStreamTest.java",
      "core/src/test/java/io/grpc/internal/ConnectivityStateManagerTest.java",
      "core/src/test/java/io/grpc/internal/DnsNameResolverTest.java",
      "core/src/test/java/io/grpc/internal/GrpcUtilTest.java",
      "core/src/test/java/io/grpc/internal/InternalSubchannelTest.java",
      "core/src/test/java/io/grpc/internal/JsonParserTest.java",
      "core/src/test/java/io/grpc/internal/ManagedChannelImplBuilderTest.java",
      "core/src/test/java/io/grpc/internal/ManagedChannelServiceConfigTest.java",
      "core/src/test/java/io/grpc/internal/MessageDeframerTest.java",
      "core/src/test/java/io/grpc/internal/ServerCallImplTest.java",
      "core/src/test/java/io/grpc/internal/ServerImplTest.java",
      "core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java"
    ],
    "pr_changed_test_files": [
      "api/src/test/java/io/grpc/MetadataTest.java",
      "api/src/test/java/io/grpc/MethodDescriptorTest.java",
      "api/src/test/java/io/grpc/ServerInterceptorsTest.java",
      "api/src/test/java/io/grpc/ServerServiceDefinitionTest.java",
      "api/src/test/java/io/grpc/ServiceDescriptorTest.java",
      "core/src/test/java/io/grpc/internal/AbstractClientStreamTest.java",
      "core/src/test/java/io/grpc/internal/AbstractServerStreamTest.java",
      "core/src/test/java/io/grpc/internal/ConnectivityStateManagerTest.java",
      "core/src/test/java/io/grpc/internal/DnsNameResolverTest.java",
      "core/src/test/java/io/grpc/internal/GrpcUtilTest.java",
      "core/src/test/java/io/grpc/internal/InternalSubchannelTest.java",
      "core/src/test/java/io/grpc/internal/JsonParserTest.java",
      "core/src/test/java/io/grpc/internal/ManagedChannelImplBuilderTest.java",
      "core/src/test/java/io/grpc/internal/ManagedChannelServiceConfigTest.java",
      "core/src/test/java/io/grpc/internal/MessageDeframerTest.java",
      "core/src/test/java/io/grpc/internal/ServerCallImplTest.java",
      "core/src/test/java/io/grpc/internal/ServerImplTest.java",
      "core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java"
    ],
    "base_commit": "a57c14a51ea0d1551ff2bef54844d6da8ed5c7db",
    "head_commit": "c494942bbf5fe2511375330036a70dd7fac1f90d",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11962",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11962",
    "dockerfile": "",
    "pr_merged_at": "2025-03-21T07:30:25.000Z",
    "patch": "diff --git a/api/build.gradle b/api/build.gradle\nindex dc3eaea3f4e..415a17f61f8 100644\n--- a/api/build.gradle\n+++ b/api/build.gradle\n@@ -47,6 +47,7 @@ dependencies {\n     testImplementation project(':grpc-core')\n     testImplementation project(':grpc-testing')\n     testImplementation libraries.guava.testlib\n+    testImplementation libraries.truth\n \n     signature (libraries.signature.java) {\n         artifact {\n",
    "test_patch": "diff --git a/api/src/test/java/io/grpc/MetadataTest.java b/api/src/test/java/io/grpc/MetadataTest.java\nindex 14ba8ca9b23..a858fff5e5a 100644\n--- a/api/src/test/java/io/grpc/MetadataTest.java\n+++ b/api/src/test/java/io/grpc/MetadataTest.java\n@@ -16,6 +16,7 @@\n \n package io.grpc;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static java.nio.charset.StandardCharsets.US_ASCII;\n import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.junit.Assert.assertArrayEquals;\n@@ -24,6 +25,7 @@\n import static org.junit.Assert.assertNotSame;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n@@ -37,9 +39,7 @@\n import java.util.Arrays;\n import java.util.Iterator;\n import java.util.Locale;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n@@ -49,9 +49,6 @@\n @RunWith(JUnit4.class)\n public class MetadataTest {\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n-\n   private static final Metadata.BinaryMarshaller<Fish> FISH_MARSHALLER =\n       new Metadata.BinaryMarshaller<Fish>() {\n         @Override\n@@ -65,7 +62,7 @@ public Fish parseBytes(byte[] serialized) {\n         }\n       };\n \n-  private static class FishStreamMarsaller implements Metadata.BinaryStreamMarshaller<Fish> {\n+  private static class FishStreamMarshaller implements Metadata.BinaryStreamMarshaller<Fish> {\n     @Override\n     public InputStream toStream(Fish fish) {\n       return new ByteArrayInputStream(FISH_MARSHALLER.toBytes(fish));\n@@ -82,7 +79,7 @@ public Fish parseStream(InputStream stream) {\n   }\n \n   private static final Metadata.BinaryStreamMarshaller<Fish> FISH_STREAM_MARSHALLER =\n-      new FishStreamMarsaller();\n+      new FishStreamMarshaller();\n \n   /** A pattern commonly used to avoid unnecessary serialization of immutable objects. */\n   private static final class FakeFishStream extends InputStream {\n@@ -121,10 +118,9 @@ public Fish parseStream(InputStream stream) {\n \n   @Test\n   public void noPseudoHeaders() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Invalid character\");\n-\n-    Metadata.Key.of(\":test-bin\", FISH_MARSHALLER);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> Metadata.Key.of(\":test-bin\", FISH_MARSHALLER));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Invalid character ':' in key name ':test-bin'\");\n   }\n \n   @Test\n@@ -186,8 +182,7 @@ public void testGetAllNoRemove() {\n     Iterator<Fish> i = metadata.getAll(KEY).iterator();\n     assertEquals(lance, i.next());\n \n-    thrown.expect(UnsupportedOperationException.class);\n-    i.remove();\n+    assertThrows(UnsupportedOperationException.class, i::remove);\n   }\n \n   @Test\n@@ -271,17 +266,15 @@ public void mergeExpands() {\n \n   @Test\n   public void shortBinaryKeyName() {\n-    thrown.expect(IllegalArgumentException.class);\n-\n-    Metadata.Key.of(\"-bin\", FISH_MARSHALLER);\n+    assertThrows(IllegalArgumentException.class, () -> Metadata.Key.of(\"-bin\", FISH_MARSHALLER));\n   }\n \n   @Test\n   public void invalidSuffixBinaryKeyName() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Binary header is named\");\n-\n-    Metadata.Key.of(\"nonbinary\", FISH_MARSHALLER);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> Metadata.Key.of(\"nonbinary\", FISH_MARSHALLER));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Binary header is named nonbinary. It must end with -bin\");\n   }\n \n   @Test\n@@ -415,7 +408,7 @@ public void streamedValueDifferentMarshaller() {\n     h.put(KEY_STREAMED, salmon);\n \n     // Get using a different marshaller instance.\n-    Fish fish = h.get(copyKey(KEY_STREAMED, new FishStreamMarsaller()));\n+    Fish fish = h.get(copyKey(KEY_STREAMED, new FishStreamMarshaller()));\n     assertEquals(salmon, fish);\n   }\n \n\ndiff --git a/api/src/test/java/io/grpc/MethodDescriptorTest.java b/api/src/test/java/io/grpc/MethodDescriptorTest.java\nindex 9431190984b..e068e0c1108 100644\n--- a/api/src/test/java/io/grpc/MethodDescriptorTest.java\n+++ b/api/src/test/java/io/grpc/MethodDescriptorTest.java\n@@ -26,9 +26,7 @@\n import io.grpc.MethodDescriptor.Marshaller;\n import io.grpc.MethodDescriptor.MethodType;\n import io.grpc.testing.TestMethodDescriptors;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n@@ -37,10 +35,6 @@\n  */\n @RunWith(JUnit4.class)\n public class MethodDescriptorTest {\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n-\n   @Test\n   public void createMethodDescriptor() {\n     MethodDescriptor<String, String> descriptor = MethodDescriptor.<String, String>newBuilder()\n\ndiff --git a/api/src/test/java/io/grpc/ServerInterceptorsTest.java b/api/src/test/java/io/grpc/ServerInterceptorsTest.java\nindex abfb3540fe4..b84b3838afa 100644\n--- a/api/src/test/java/io/grpc/ServerInterceptorsTest.java\n+++ b/api/src/test/java/io/grpc/ServerInterceptorsTest.java\n@@ -19,6 +19,7 @@\n import static com.google.common.collect.Iterables.getOnlyElement;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.AdditionalAnswers.delegatesTo;\n import static org.mockito.ArgumentMatchers.same;\n@@ -40,7 +41,6 @@\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.ArgumentMatchers;\n@@ -55,10 +55,6 @@ public class ServerInterceptorsTest {\n   @Rule\n   public final MockitoRule mocks = MockitoJUnit.rule();\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n-\n   @Mock\n   private Marshaller<String> requestMarshaller;\n \n@@ -111,21 +107,21 @@ public void makeSureExpectedMocksUnused() {\n   public void npeForNullServiceDefinition() {\n     ServerServiceDefinition serviceDef = null;\n     List<ServerInterceptor> interceptors = Arrays.asList();\n-    thrown.expect(NullPointerException.class);\n-    ServerInterceptors.intercept(serviceDef, interceptors);\n+    assertThrows(NullPointerException.class,\n+        () -> ServerInterceptors.intercept(serviceDef, interceptors));\n   }\n \n   @Test\n   public void npeForNullInterceptorList() {\n-    thrown.expect(NullPointerException.class);\n-    ServerInterceptors.intercept(serviceDefinition, (List<ServerInterceptor>) null);\n+    assertThrows(NullPointerException.class,\n+        () -> ServerInterceptors.intercept(serviceDefinition, (List<ServerInterceptor>) null));\n   }\n \n   @Test\n   public void npeForNullInterceptor() {\n     List<ServerInterceptor> interceptors = Arrays.asList((ServerInterceptor) null);\n-    thrown.expect(NullPointerException.class);\n-    ServerInterceptors.intercept(serviceDefinition, interceptors);\n+    assertThrows(NullPointerException.class,\n+        () -> ServerInterceptors.intercept(serviceDefinition, interceptors));\n   }\n \n   @Test\n\ndiff --git a/api/src/test/java/io/grpc/ServerServiceDefinitionTest.java b/api/src/test/java/io/grpc/ServerServiceDefinitionTest.java\nindex 6a84d640d78..9e43302e210 100644\n--- a/api/src/test/java/io/grpc/ServerServiceDefinitionTest.java\n+++ b/api/src/test/java/io/grpc/ServerServiceDefinitionTest.java\n@@ -18,14 +18,13 @@\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.fail;\n \n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashSet;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n@@ -52,9 +51,6 @@ public class ServerServiceDefinitionTest {\n         = ServerMethodDefinition.create(method1, methodHandler1);\n   private ServerMethodDefinition<String, Integer> methodDef2\n         = ServerMethodDefinition.create(method2, methodHandler2);\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public ExpectedException thrown = ExpectedException.none();\n \n   @Test\n   public void noMethods() {\n@@ -91,9 +87,7 @@ public void addMethod_duplicateName() {\n     ServiceDescriptor sd = new ServiceDescriptor(serviceName, method1);\n     ServerServiceDefinition.Builder ssd = ServerServiceDefinition.builder(sd)\n         .addMethod(method1, methodHandler1);\n-    thrown.expect(IllegalStateException.class);\n-    ssd.addMethod(diffMethod1, methodHandler2)\n-        .build();\n+    assertThrows(IllegalStateException.class, () -> ssd.addMethod(diffMethod1, methodHandler2));\n   }\n \n   @Test\n@@ -101,8 +95,7 @@ public void buildMisaligned_extraMethod() {\n     ServiceDescriptor sd = new ServiceDescriptor(serviceName);\n     ServerServiceDefinition.Builder ssd = ServerServiceDefinition.builder(sd)\n         .addMethod(methodDef1);\n-    thrown.expect(IllegalStateException.class);\n-    ssd.build();\n+    assertThrows(IllegalStateException.class, ssd::build);\n   }\n \n   @Test\n@@ -110,16 +103,14 @@ public void buildMisaligned_diffMethodInstance() {\n     ServiceDescriptor sd = new ServiceDescriptor(serviceName, method1);\n     ServerServiceDefinition.Builder ssd = ServerServiceDefinition.builder(sd)\n         .addMethod(diffMethod1, methodHandler1);\n-    thrown.expect(IllegalStateException.class);\n-    ssd.build();\n+    assertThrows(IllegalStateException.class, ssd::build);\n   }\n \n   @Test\n   public void buildMisaligned_missingMethod() {\n     ServiceDescriptor sd = new ServiceDescriptor(serviceName, method1);\n     ServerServiceDefinition.Builder ssd = ServerServiceDefinition.builder(sd);\n-    thrown.expect(IllegalStateException.class);\n-    ssd.build();\n+    assertThrows(IllegalStateException.class, ssd::build);\n   }\n \n   @Test\n\ndiff --git a/api/src/test/java/io/grpc/ServiceDescriptorTest.java b/api/src/test/java/io/grpc/ServiceDescriptorTest.java\nindex a05858680d5..89bdead3632 100644\n--- a/api/src/test/java/io/grpc/ServiceDescriptorTest.java\n+++ b/api/src/test/java/io/grpc/ServiceDescriptorTest.java\n@@ -16,17 +16,18 @@\n \n package io.grpc;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n \n+import com.google.common.truth.StringSubject;\n import io.grpc.MethodDescriptor.MethodType;\n import io.grpc.testing.TestMethodDescriptors;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n@@ -36,32 +37,27 @@\n @RunWith(JUnit4.class)\n public class ServiceDescriptorTest {\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n-\n   @Test\n   public void failsOnNullName() {\n-    thrown.expect(NullPointerException.class);\n-    thrown.expectMessage(\"name\");\n-\n-    new ServiceDescriptor(null, Collections.<MethodDescriptor<?, ?>>emptyList());\n+    List<MethodDescriptor<?, ?>> methods = Collections.emptyList();\n+    NullPointerException e = assertThrows(NullPointerException.class,\n+        () -> new ServiceDescriptor(null, methods));\n+    assertThat(e).hasMessageThat().isEqualTo(\"name\");\n   }\n \n   @Test\n   public void failsOnNullMethods() {\n-    thrown.expect(NullPointerException.class);\n-    thrown.expectMessage(\"methods\");\n-\n-    new ServiceDescriptor(\"name\", (Collection<MethodDescriptor<?, ?>>) null);\n+    NullPointerException e = assertThrows(NullPointerException.class,\n+        () -> new ServiceDescriptor(\"name\", (Collection<MethodDescriptor<?, ?>>) null));\n+    assertThat(e).hasMessageThat().isEqualTo(\"methods\");\n   }\n \n   @Test\n   public void failsOnNullMethod() {\n-    thrown.expect(NullPointerException.class);\n-    thrown.expectMessage(\"method\");\n-\n-    new ServiceDescriptor(\"name\", Collections.<MethodDescriptor<?, ?>>singletonList(null));\n+    List<MethodDescriptor<?, ?>> methods = Collections.singletonList(null);\n+    NullPointerException e = assertThrows(NullPointerException.class,\n+        () -> new ServiceDescriptor(\"name\", methods));\n+    assertThat(e).hasMessageThat().isEqualTo(\"method\");\n   }\n \n   @Test\n@@ -69,15 +65,17 @@ public void failsOnNonMatchingNames() {\n     List<MethodDescriptor<?, ?>> descriptors = Collections.<MethodDescriptor<?, ?>>singletonList(\n         MethodDescriptor.<Void, Void>newBuilder()\n           .setType(MethodType.UNARY)\n-          .setFullMethodName(MethodDescriptor.generateFullMethodName(\"wrongservice\", \"method\"))\n+          .setFullMethodName(MethodDescriptor.generateFullMethodName(\"wrongService\", \"method\"))\n           .setRequestMarshaller(TestMethodDescriptors.voidMarshaller())\n           .setResponseMarshaller(TestMethodDescriptors.voidMarshaller())\n           .build());\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"service names\");\n-\n-    new ServiceDescriptor(\"name\", descriptors);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> new ServiceDescriptor(\"fooService\", descriptors));\n+    StringSubject error = assertThat(e).hasMessageThat();\n+    error.contains(\"service names\");\n+    error.contains(\"fooService\");\n+    error.contains(\"wrongService\");\n   }\n \n   @Test\n@@ -96,10 +94,9 @@ public void failsOnNonDuplicateNames() {\n           .setResponseMarshaller(TestMethodDescriptors.voidMarshaller())\n           .build());\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"duplicate\");\n-\n-    new ServiceDescriptor(\"name\", descriptors);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> new ServiceDescriptor(\"name\", descriptors));\n+    assertThat(e).hasMessageThat().isEqualTo(\"duplicate name name/method\");\n   }\n \n   @Test\n\ndiff --git a/core/src/test/java/io/grpc/internal/AbstractClientStreamTest.java b/core/src/test/java/io/grpc/internal/AbstractClientStreamTest.java\nindex ad3b59030d7..18fafe6557d 100644\n--- a/core/src/test/java/io/grpc/internal/AbstractClientStreamTest.java\n+++ b/core/src/test/java/io/grpc/internal/AbstractClientStreamTest.java\n@@ -23,6 +23,7 @@\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n import static org.mockito.AdditionalAnswers.delegatesTo;\n@@ -57,7 +58,6 @@\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.ArgumentCaptor;\n@@ -76,8 +76,6 @@\n public class AbstractClientStreamTest {\n \n   @Rule public final MockitoRule mocks = MockitoJUnit.rule();\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n \n   private final StatsTraceContext statsTraceCtx = StatsTraceContext.NOOP;\n   private final TransportTracer transportTracer = new TransportTracer();\n@@ -136,9 +134,7 @@ public void cancel_failsOnNull() {\n     AbstractClientStream stream =\n         new BaseAbstractClientStream(allocator, statsTraceCtx, transportTracer);\n     stream.start(listener);\n-    thrown.expect(NullPointerException.class);\n-\n-    stream.cancel(null);\n+    assertThrows(NullPointerException.class, () -> stream.cancel(null));\n   }\n \n   @Test\n@@ -164,9 +160,7 @@ public void startFailsOnNullListener() {\n     AbstractClientStream stream =\n         new BaseAbstractClientStream(allocator, statsTraceCtx, transportTracer);\n \n-    thrown.expect(NullPointerException.class);\n-\n-    stream.start(null);\n+    assertThrows(NullPointerException.class, () -> stream.start(null));\n   }\n \n   @Test\n@@ -174,9 +168,7 @@ public void cantCallStartTwice() {\n     AbstractClientStream stream =\n         new BaseAbstractClientStream(allocator, statsTraceCtx, transportTracer);\n     stream.start(mockListener);\n-    thrown.expect(IllegalStateException.class);\n-\n-    stream.start(mockListener);\n+    assertThrows(IllegalStateException.class, () -> stream.start(mockListener));\n   }\n \n   @Test\n@@ -188,8 +180,7 @@ public void inboundDataReceived_failsOnNullFrame() {\n \n     TransportState state = stream.transportState();\n \n-    thrown.expect(NullPointerException.class);\n-    state.inboundDataReceived(null);\n+    assertThrows(NullPointerException.class, () -> state.inboundDataReceived(null));\n   }\n \n   @Test\n@@ -212,8 +203,8 @@ public void inboundHeadersReceived_failsIfStatusReported() {\n \n     TransportState state = stream.transportState();\n \n-    thrown.expect(IllegalStateException.class);\n-    state.inboundHeadersReceived(new Metadata());\n+    Metadata headers = new Metadata();\n+    assertThrows(IllegalStateException.class, () -> state.inboundHeadersReceived(headers));\n   }\n \n   @Test\n\ndiff --git a/core/src/test/java/io/grpc/internal/AbstractServerStreamTest.java b/core/src/test/java/io/grpc/internal/AbstractServerStreamTest.java\nindex b41d45e972e..137ba19bfea 100644\n--- a/core/src/test/java/io/grpc/internal/AbstractServerStreamTest.java\n+++ b/core/src/test/java/io/grpc/internal/AbstractServerStreamTest.java\n@@ -18,6 +18,7 @@\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.AdditionalAnswers.delegatesTo;\n import static org.mockito.ArgumentMatchers.any;\n@@ -45,9 +46,7 @@\n import java.util.Queue;\n import java.util.concurrent.TimeUnit;\n import org.junit.Before;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.ArgumentCaptor;\n@@ -60,9 +59,6 @@ public class AbstractServerStreamTest {\n   private static final int TIMEOUT_MS = 1000;\n   private static final int MAX_MESSAGE_SIZE = 100;\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n-\n   private final WritableBufferAllocator allocator = new WritableBufferAllocator() {\n     @Override\n     public WritableBuffer allocate(int capacityHint) {\n@@ -226,9 +222,9 @@ public void completeWithoutClose() {\n   public void setListener_setOnlyOnce() {\n     TransportState state = stream.transportState();\n     state.setListener(new ServerStreamListenerBase());\n-    thrown.expect(IllegalStateException.class);\n \n-    state.setListener(new ServerStreamListenerBase());\n+    ServerStreamListenerBase listener2 = new ServerStreamListenerBase();\n+    assertThrows(IllegalStateException.class, () -> state.setListener(listener2));\n   }\n \n   @Test\n@@ -238,8 +234,7 @@ public void listenerReady_onlyOnce() {\n \n     TransportState state = stream.transportState();\n \n-    thrown.expect(IllegalStateException.class);\n-    state.onStreamAllocated();\n+    assertThrows(IllegalStateException.class, state::onStreamAllocated);\n   }\n \n   @Test\n@@ -255,8 +250,7 @@ public void listenerReady_readyCalled() {\n   public void setListener_failsOnNull() {\n     TransportState state = stream.transportState();\n \n-    thrown.expect(NullPointerException.class);\n-    state.setListener(null);\n+    assertThrows(NullPointerException.class, () -> state.setListener(null));\n   }\n \n   // TODO(ericgribkoff) This test is only valid if deframeInTransportThread=true, as otherwise the\n@@ -284,9 +278,7 @@ public void messagesAvailable(MessageProducer producer) {\n \n   @Test\n   public void writeHeaders_failsOnNullHeaders() {\n-    thrown.expect(NullPointerException.class);\n-\n-    stream.writeHeaders(null, true);\n+    assertThrows(NullPointerException.class, () -> stream.writeHeaders(null, true));\n   }\n \n   @Test\n@@ -336,16 +328,13 @@ public void writeMessage_closesStream() throws Exception {\n \n   @Test\n   public void close_failsOnNullStatus() {\n-    thrown.expect(NullPointerException.class);\n-\n-    stream.close(null, new Metadata());\n+    Metadata trailers = new Metadata();\n+    assertThrows(NullPointerException.class, () -> stream.close(null, trailers));\n   }\n \n   @Test\n   public void close_failsOnNullMetadata() {\n-    thrown.expect(NullPointerException.class);\n-\n-    stream.close(Status.INTERNAL, null);\n+    assertThrows(NullPointerException.class, () -> stream.close(Status.INTERNAL, null));\n   }\n \n   @Test\n@@ -451,4 +440,3 @@ public int streamId() {\n     }\n   }\n }\n-\n\ndiff --git a/core/src/test/java/io/grpc/internal/ConnectivityStateManagerTest.java b/core/src/test/java/io/grpc/internal/ConnectivityStateManagerTest.java\nindex 2a759a4f386..dfd6ed56a1e 100644\n--- a/core/src/test/java/io/grpc/internal/ConnectivityStateManagerTest.java\n+++ b/core/src/test/java/io/grpc/internal/ConnectivityStateManagerTest.java\n@@ -27,9 +27,7 @@\n import io.grpc.ConnectivityState;\n import java.util.LinkedList;\n import java.util.concurrent.Executor;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n@@ -38,10 +36,6 @@\n  */\n @RunWith(JUnit4.class)\n public class ConnectivityStateManagerTest {\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n-\n   private final FakeClock executor = new FakeClock();\n   private final ConnectivityStateManager state = new ConnectivityStateManager();\n   private final LinkedList<ConnectivityState> sink = new LinkedList<>();\n@@ -75,7 +69,7 @@ public void run() {\n     assertEquals(1, sink.size());\n     assertEquals(TRANSIENT_FAILURE, sink.poll());\n   }\n-  \n+\n   @Test\n   public void registerCallbackAfterStateChanged() {\n     state.gotoState(CONNECTING);\n\ndiff --git a/core/src/test/java/io/grpc/internal/DnsNameResolverTest.java b/core/src/test/java/io/grpc/internal/DnsNameResolverTest.java\nindex be304ad326b..130c01d1c04 100644\n--- a/core/src/test/java/io/grpc/internal/DnsNameResolverTest.java\n+++ b/core/src/test/java/io/grpc/internal/DnsNameResolverTest.java\n@@ -22,6 +22,7 @@\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n import static org.mockito.ArgumentMatchers.any;\n@@ -35,6 +36,7 @@\n import static org.mockito.Mockito.when;\n \n import com.google.common.base.Stopwatch;\n+import com.google.common.base.VerifyException;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Iterables;\n import com.google.common.net.InetAddresses;\n@@ -82,7 +84,6 @@\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.DisableOnDebug;\n-import org.junit.rules.ExpectedException;\n import org.junit.rules.TestRule;\n import org.junit.rules.Timeout;\n import org.junit.runner.RunWith;\n@@ -99,8 +100,6 @@ public class DnsNameResolverTest {\n \n   @Rule public final TestRule globalTimeout = new DisableOnDebug(Timeout.seconds(10));\n   @Rule public final MockitoRule mocks = MockitoJUnit.rule();\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n \n   private final Map<String, ?> serviceConfig = new LinkedHashMap<>();\n \n@@ -914,9 +913,10 @@ public HttpConnectProxiedSocketAddress proxyFor(SocketAddress targetAddress) {\n   public void maybeChooseServiceConfig_failsOnMisspelling() {\n     Map<String, Object> bad = new LinkedHashMap<>();\n     bad.put(\"parcentage\", 1.0);\n-    thrown.expectMessage(\"Bad key\");\n-\n-    DnsNameResolver.maybeChooseServiceConfig(bad, new Random(), \"host\");\n+    Random random = new Random();\n+    VerifyException e = assertThrows(VerifyException.class,\n+        () -> DnsNameResolver.maybeChooseServiceConfig(bad, random, \"host\"));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Bad key: parcentage=1.0\");\n   }\n \n   @Test\n@@ -1155,25 +1155,25 @@ public void parseTxtResults_misspelledName() throws Exception {\n   }\n \n   @Test\n-  public void parseTxtResults_badTypeFails() throws Exception {\n+  public void parseTxtResults_badTypeFails() {\n     List<String> txtRecords = new ArrayList<>();\n     txtRecords.add(\"some_record\");\n     txtRecords.add(\"grpc_config={}\");\n \n-    thrown.expect(ClassCastException.class);\n-    thrown.expectMessage(\"wrong type\");\n-    DnsNameResolver.parseTxtResults(txtRecords);\n+    ClassCastException e = assertThrows(ClassCastException.class,\n+        () -> DnsNameResolver.parseTxtResults(txtRecords));\n+    assertThat(e).hasMessageThat().isEqualTo(\"wrong type {}\");\n   }\n \n   @Test\n-  public void parseTxtResults_badInnerTypeFails() throws Exception {\n+  public void parseTxtResults_badInnerTypeFails() {\n     List<String> txtRecords = new ArrayList<>();\n     txtRecords.add(\"some_record\");\n     txtRecords.add(\"grpc_config=[\\\"bogus\\\"]\");\n \n-    thrown.expect(ClassCastException.class);\n-    thrown.expectMessage(\"not object\");\n-    DnsNameResolver.parseTxtResults(txtRecords);\n+    ClassCastException e = assertThrows(ClassCastException.class,\n+        () -> DnsNameResolver.parseTxtResults(txtRecords));\n+    assertThat(e).hasMessageThat().isEqualTo(\"value bogus for idx 0 in [bogus] is not object\");\n   }\n \n   @Test\n\ndiff --git a/core/src/test/java/io/grpc/internal/GrpcUtilTest.java b/core/src/test/java/io/grpc/internal/GrpcUtilTest.java\nindex 39acb582d28..229c593ef80 100644\n--- a/core/src/test/java/io/grpc/internal/GrpcUtilTest.java\n+++ b/core/src/test/java/io/grpc/internal/GrpcUtilTest.java\n@@ -22,6 +22,7 @@\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.eq;\n@@ -41,7 +42,6 @@\n import java.util.ArrayList;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.ArgumentCaptor;\n@@ -57,8 +57,6 @@ public class GrpcUtilTest {\n       new ClientStreamTracer() {}\n   };\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n   @Rule public final MockitoRule mocks = MockitoJUnit.rule();\n \n   @Captor\n@@ -201,9 +199,7 @@ public void urlAuthorityEscape_unicodeAreNotEncoded() {\n \n   @Test\n   public void checkAuthority_failsOnNull() {\n-    thrown.expect(NullPointerException.class);\n-\n-    GrpcUtil.checkAuthority(null);\n+    assertThrows(NullPointerException.class, () -> GrpcUtil.checkAuthority(null));\n   }\n \n   @Test\n@@ -229,19 +225,18 @@ public void checkAuthority_succeedsOnIpV6() {\n \n   @Test\n   public void checkAuthority_failsOnInvalidAuthority() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Invalid authority\");\n-\n-    GrpcUtil.checkAuthority(\"[ : : 1]\");\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> GrpcUtil.checkAuthority(\"[ : : 1]\"));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Invalid authority: [ : : 1]\");\n   }\n \n \n   @Test\n   public void checkAuthority_userInfoNotAllowed() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Userinfo\");\n-\n-    GrpcUtil.checkAuthority(\"foo@valid\");\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> GrpcUtil.checkAuthority(\"foo@valid\"));\n+    assertThat(e).hasMessageThat()\n+        .isEqualTo(\"Userinfo must not be present on authority: 'foo@valid'\");\n   }\n \n   @Test\n\ndiff --git a/core/src/test/java/io/grpc/internal/InternalSubchannelTest.java b/core/src/test/java/io/grpc/internal/InternalSubchannelTest.java\nindex b75fd43a743..bed722f5f3a 100644\n--- a/core/src/test/java/io/grpc/internal/InternalSubchannelTest.java\n+++ b/core/src/test/java/io/grpc/internal/InternalSubchannelTest.java\n@@ -27,6 +27,7 @@\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.eq;\n@@ -65,7 +66,6 @@\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.Mock;\n@@ -79,9 +79,6 @@\n public class InternalSubchannelTest {\n   @Rule\n   public final MockitoRule mocks = MockitoJUnit.rule();\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n \n   private static final String AUTHORITY = \"fakeauthority\";\n   private static final String USER_AGENT = \"mosaic\";\n@@ -544,8 +541,9 @@ public void constructor_eagListWithNull_throws() {\n   public void updateAddresses_emptyEagList_throws() {\n     SocketAddress addr = new FakeSocketAddress();\n     createInternalSubchannel(addr);\n-    thrown.expect(IllegalArgumentException.class);\n-    internalSubchannel.updateAddresses(Arrays.<EquivalentAddressGroup>asList());\n+    List<EquivalentAddressGroup> newAddressGroups = Collections.emptyList();\n+    assertThrows(IllegalArgumentException.class,\n+        () -> internalSubchannel.updateAddresses(newAddressGroups));\n   }\n \n   @Test\n@@ -553,8 +551,7 @@ public void updateAddresses_eagListWithNull_throws() {\n     SocketAddress addr = new FakeSocketAddress();\n     createInternalSubchannel(addr);\n     List<EquivalentAddressGroup> eags = Arrays.asList((EquivalentAddressGroup) null);\n-    thrown.expect(NullPointerException.class);\n-    internalSubchannel.updateAddresses(eags);\n+    assertThrows(NullPointerException.class, () -> internalSubchannel.updateAddresses(eags));\n   }\n \n   @Test public void updateAddresses_intersecting_ready() {\n\ndiff --git a/core/src/test/java/io/grpc/internal/JsonParserTest.java b/core/src/test/java/io/grpc/internal/JsonParserTest.java\nindex cfee566fa4a..a0dd81c20ce 100644\n--- a/core/src/test/java/io/grpc/internal/JsonParserTest.java\n+++ b/core/src/test/java/io/grpc/internal/JsonParserTest.java\n@@ -17,15 +17,14 @@\n package io.grpc.internal;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThrows;\n \n import com.google.gson.stream.MalformedJsonException;\n import java.io.EOFException;\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.LinkedHashMap;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n@@ -35,10 +34,6 @@\n @RunWith(JUnit4.class)\n public class JsonParserTest {\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n-\n   @Test\n   public void emptyObject() throws IOException {\n     assertEquals(new LinkedHashMap<String, Object>(), JsonParser.parse(\"{}\"));\n@@ -75,45 +70,33 @@ public void nullValue() throws IOException {\n   }\n \n   @Test\n-  public void nanFails() throws IOException {\n-    thrown.expect(MalformedJsonException.class);\n-\n-    JsonParser.parse(\"NaN\");\n+  public void nanFails() {\n+    assertThrows(MalformedJsonException.class, () -> JsonParser.parse(\"NaN\"));\n   }\n \n   @Test\n-  public void objectEarlyEnd() throws IOException {\n-    thrown.expect(MalformedJsonException.class);\n-\n-    JsonParser.parse(\"{foo:}\");\n+  public void objectEarlyEnd() {\n+    assertThrows(MalformedJsonException.class, () -> JsonParser.parse(\"{foo:}\"));\n   }\n \n   @Test\n-  public void earlyEndArray() throws IOException {\n-    thrown.expect(EOFException.class);\n-\n-    JsonParser.parse(\"[1, 2, \");\n+  public void earlyEndArray() {\n+    assertThrows(EOFException.class, () -> JsonParser.parse(\"[1, 2, \"));\n   }\n \n   @Test\n-  public void arrayMissingElement() throws IOException {\n-    thrown.expect(MalformedJsonException.class);\n-\n-    JsonParser.parse(\"[1, 2, ]\");\n+  public void arrayMissingElement() {\n+    assertThrows(MalformedJsonException.class, () -> JsonParser.parse(\"[1, 2, ]\"));\n   }\n \n   @Test\n-  public void objectMissingElement() throws IOException {\n-    thrown.expect(MalformedJsonException.class);\n-\n-    JsonParser.parse(\"{1: \");\n+  public void objectMissingElement() {\n+    assertThrows(MalformedJsonException.class, () -> JsonParser.parse(\"{1: \"));\n   }\n \n   @Test\n-  public void objectNoName() throws IOException {\n-    thrown.expect(MalformedJsonException.class);\n-\n-    JsonParser.parse(\"{: 1\");\n+  public void objectNoName() {\n+    assertThrows(MalformedJsonException.class, () -> JsonParser.parse(\"{: 1\"));\n   }\n \n   @Test\n@@ -125,9 +108,7 @@ public void objectStringName() throws IOException {\n   }\n \n   @Test\n-  public void duplicate() throws IOException {\n-    thrown.expect(IllegalArgumentException.class);\n-\n-    JsonParser.parse(\"{\\\"hi\\\": 2, \\\"hi\\\": 3}\");\n+  public void duplicate() {\n+    assertThrows(IllegalArgumentException.class, () -> JsonParser.parse(\"{\\\"hi\\\": 2, \\\"hi\\\": 3}\"));\n   }\n-}\n\\ No newline at end of file\n+}\n\ndiff --git a/core/src/test/java/io/grpc/internal/ManagedChannelImplBuilderTest.java b/core/src/test/java/io/grpc/internal/ManagedChannelImplBuilderTest.java\nindex cf131a79d87..861412653fb 100644\n--- a/core/src/test/java/io/grpc/internal/ManagedChannelImplBuilderTest.java\n+++ b/core/src/test/java/io/grpc/internal/ManagedChannelImplBuilderTest.java\n@@ -23,6 +23,7 @@\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n import static org.mockito.Mockito.doReturn;\n@@ -67,7 +68,6 @@\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.Mock;\n@@ -99,8 +99,6 @@ public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(\n       };\n \n   @Rule public final MockitoRule mocks = MockitoJUnit.rule();\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n   @Rule public final GrpcCleanupRule grpcCleanupRule = new GrpcCleanupRule();\n \n   @Mock private ClientTransportFactory mockClientTransportFactory;\n@@ -424,10 +422,9 @@ public void checkAuthority_validAuthorityAllowed() {\n \n   @Test\n   public void checkAuthority_invalidAuthorityFailed() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Invalid authority\");\n-\n-    builder.checkAuthority(DUMMY_AUTHORITY_INVALID);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.checkAuthority(DUMMY_AUTHORITY_INVALID));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Invalid authority: [ : : 1]\");\n   }\n \n   @Test\n@@ -450,11 +447,10 @@ public void enableCheckAuthority_validAuthorityAllowed() {\n \n   @Test\n   public void disableCheckAuthority_invalidAuthorityFailed() {\n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Invalid authority\");\n-\n     builder.disableCheckAuthority().enableCheckAuthority();\n-    builder.checkAuthority(DUMMY_AUTHORITY_INVALID);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> builder.checkAuthority(DUMMY_AUTHORITY_INVALID));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Invalid authority: [ : : 1]\");\n   }\n \n   @Test\n@@ -680,14 +676,12 @@ public void perRpcBufferLimit() {\n \n   @Test\n   public void retryBufferSizeInvalidArg() {\n-    thrown.expect(IllegalArgumentException.class);\n-    builder.retryBufferSize(0L);\n+    assertThrows(IllegalArgumentException.class, () -> builder.retryBufferSize(0L));\n   }\n \n   @Test\n   public void perRpcBufferLimitInvalidArg() {\n-    thrown.expect(IllegalArgumentException.class);\n-    builder.perRpcBufferLimit(0L);\n+    assertThrows(IllegalArgumentException.class, () -> builder.perRpcBufferLimit(0L));\n   }\n \n   @Test\n@@ -710,8 +704,7 @@ public void defaultServiceConfig_nullKey() {\n     Map<String, Object> config = new HashMap<>();\n     config.put(null, \"val\");\n \n-    thrown.expect(IllegalArgumentException.class);\n-    builder.defaultServiceConfig(config);\n+    assertThrows(IllegalArgumentException.class, () -> builder.defaultServiceConfig(config));\n   }\n \n   @Test\n@@ -721,8 +714,7 @@ public void defaultServiceConfig_intKey() {\n     Map<String, Object> config = new HashMap<>();\n     config.put(\"key\", subConfig);\n \n-    thrown.expect(IllegalArgumentException.class);\n-    builder.defaultServiceConfig(config);\n+    assertThrows(IllegalArgumentException.class, () -> builder.defaultServiceConfig(config));\n   }\n \n   @Test\n@@ -730,8 +722,7 @@ public void defaultServiceConfig_intValue() {\n     Map<String, Object> config = new HashMap<>();\n     config.put(\"key\", 3);\n \n-    thrown.expect(IllegalArgumentException.class);\n-    builder.defaultServiceConfig(config);\n+    assertThrows(IllegalArgumentException.class, () -> builder.defaultServiceConfig(config));\n   }\n \n   @Test\n\ndiff --git a/core/src/test/java/io/grpc/internal/ManagedChannelServiceConfigTest.java b/core/src/test/java/io/grpc/internal/ManagedChannelServiceConfigTest.java\nindex 493714dfd41..fefc37e4fdc 100644\n--- a/core/src/test/java/io/grpc/internal/ManagedChannelServiceConfigTest.java\n+++ b/core/src/test/java/io/grpc/internal/ManagedChannelServiceConfigTest.java\n@@ -20,6 +20,7 @@\n import static io.grpc.MethodDescriptor.MethodType.UNARY;\n import static io.grpc.Status.Code.UNAVAILABLE;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.fail;\n \n import com.google.common.collect.ImmutableList;\n@@ -34,19 +35,13 @@\n import io.grpc.testing.TestMethodDescriptors;\n import java.util.Collections;\n import java.util.Map;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n @RunWith(JUnit4.class)\n public class ManagedChannelServiceConfigTest {\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public final ExpectedException thrown = ExpectedException.none();\n-\n   @Test\n   public void managedChannelServiceConfig_shouldParseHealthCheckingConfig() throws Exception {\n     Map<String, ?> rawServiceConfig =\n@@ -79,10 +74,9 @@ public void createManagedChannelServiceConfig_failsOnDuplicateMethod() {\n     Map<String, ?> methodConfig = ImmutableMap.of(\"name\", ImmutableList.of(name1, name2));\n     Map<String, ?> serviceConfig = ImmutableMap.of(\"methodConfig\", ImmutableList.of(methodConfig));\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Duplicate method\");\n-\n-    ManagedChannelServiceConfig.fromServiceConfig(serviceConfig, true, 3, 4, null);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> ManagedChannelServiceConfig.fromServiceConfig(serviceConfig, true, 3, 4, null));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Duplicate method name service/method\");\n   }\n \n   @Test\n@@ -92,10 +86,9 @@ public void createManagedChannelServiceConfig_failsOnDuplicateService() {\n     Map<String, ?> methodConfig = ImmutableMap.of(\"name\", ImmutableList.of(name1, name2));\n     Map<String, ?> serviceConfig = ImmutableMap.of(\"methodConfig\", ImmutableList.of(methodConfig));\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Duplicate service\");\n-\n-    ManagedChannelServiceConfig.fromServiceConfig(serviceConfig, true, 3, 4, null);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> ManagedChannelServiceConfig.fromServiceConfig(serviceConfig, true, 3, 4, null));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Duplicate service service\");\n   }\n \n   @Test\n@@ -107,10 +100,9 @@ public void createManagedChannelServiceConfig_failsOnDuplicateServiceMultipleCon\n     Map<String, ?> serviceConfig =\n         ImmutableMap.of(\"methodConfig\", ImmutableList.of(methodConfig1, methodConfig2));\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"Duplicate service\");\n-\n-    ManagedChannelServiceConfig.fromServiceConfig(serviceConfig, true, 3, 4, null);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> ManagedChannelServiceConfig.fromServiceConfig(serviceConfig, true, 3, 4, null));\n+    assertThat(e).hasMessageThat().isEqualTo(\"Duplicate service service\");\n   }\n \n   @Test\n@@ -119,10 +111,9 @@ public void createManagedChannelServiceConfig_failsOnMethodNameWithEmptyServiceN\n     Map<String, ?> methodConfig = ImmutableMap.of(\"name\", ImmutableList.of(name));\n     Map<String, ?> serviceConfig = ImmutableMap.of(\"methodConfig\", ImmutableList.of(methodConfig));\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"missing service name for method method1\");\n-\n-    ManagedChannelServiceConfig.fromServiceConfig(serviceConfig, true, 3, 4, null);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> ManagedChannelServiceConfig.fromServiceConfig(serviceConfig, true, 3, 4, null));\n+    assertThat(e).hasMessageThat().isEqualTo(\"missing service name for method method1\");\n   }\n \n   @Test\n@@ -131,10 +122,9 @@ public void createManagedChannelServiceConfig_failsOnMethodNameWithoutServiceNam\n     Map<String, ?> methodConfig = ImmutableMap.of(\"name\", ImmutableList.of(name));\n     Map<String, ?> serviceConfig = ImmutableMap.of(\"methodConfig\", ImmutableList.of(methodConfig));\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"missing service name for method method1\");\n-\n-    ManagedChannelServiceConfig.fromServiceConfig(serviceConfig, true, 3, 4, null);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> ManagedChannelServiceConfig.fromServiceConfig(serviceConfig, true, 3, 4, null));\n+    assertThat(e).hasMessageThat().isEqualTo(\"missing service name for method method1\");\n   }\n \n   @Test\n@@ -143,10 +133,9 @@ public void createManagedChannelServiceConfig_failsOnMissingServiceName() {\n     Map<String, ?> methodConfig = ImmutableMap.of(\"name\", ImmutableList.of(name));\n     Map<String, ?> serviceConfig = ImmutableMap.of(\"methodConfig\", ImmutableList.of(methodConfig));\n \n-    thrown.expect(IllegalArgumentException.class);\n-    thrown.expectMessage(\"missing service\");\n-\n-    ManagedChannelServiceConfig.fromServiceConfig(serviceConfig, true, 3, 4, null);\n+    IllegalArgumentException e = assertThrows(IllegalArgumentException.class,\n+        () -> ManagedChannelServiceConfig.fromServiceConfig(serviceConfig, true, 3, 4, null));\n+    assertThat(e).hasMessageThat().isEqualTo(\"missing service name for method method\");\n   }\n \n   @Test\n\ndiff --git a/core/src/test/java/io/grpc/internal/MessageDeframerTest.java b/core/src/test/java/io/grpc/internal/MessageDeframerTest.java\nindex 8f1b908e999..54758bc096f 100644\n--- a/core/src/test/java/io/grpc/internal/MessageDeframerTest.java\n+++ b/core/src/test/java/io/grpc/internal/MessageDeframerTest.java\n@@ -20,6 +20,7 @@\n import static io.grpc.internal.GrpcUtil.DEFAULT_MAX_MESSAGE_SIZE;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assume.assumeTrue;\n import static org.mockito.ArgumentMatchers.anyInt;\n@@ -53,10 +54,8 @@\n import java.util.concurrent.TimeUnit;\n import java.util.zip.GZIPOutputStream;\n import org.junit.Before;\n-import org.junit.Rule;\n import org.junit.Test;\n import org.junit.experimental.runners.Enclosed;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.junit.runners.Parameterized;\n@@ -341,9 +340,6 @@ public Void answer(InvocationOnMock invocation) throws Throwable {\n \n   @RunWith(JUnit4.class)\n   public static class SizeEnforcingInputStreamTests {\n-    @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-    @Rule\n-    public final ExpectedException thrown = ExpectedException.none();\n \n     private TestBaseStreamTracer tracer = new TestBaseStreamTracer();\n     private StatsTraceContext statsTraceCtx = new StatsTraceContext(new StreamTracer[]{tracer});\n@@ -381,11 +377,12 @@ public void sizeEnforcingInputStream_readByteAboveLimit() throws IOException {\n               new MessageDeframer.SizeEnforcingInputStream(in, 2, statsTraceCtx);\n \n       try {\n-        thrown.expect(StatusRuntimeException.class);\n-        thrown.expectMessage(\"RESOURCE_EXHAUSTED: Decompressed gRPC message exceeds\");\n-\n-        while (stream.read() != -1) {\n-        }\n+        StatusRuntimeException e = assertThrows(StatusRuntimeException.class, () -> {\n+          while (stream.read() != -1) {\n+          }\n+        });\n+        assertThat(e).hasMessageThat()\n+            .isEqualTo(\"RESOURCE_EXHAUSTED: Decompressed gRPC message exceeds maximum size 2\");\n       } finally {\n         stream.close();\n       }\n@@ -427,10 +424,10 @@ public void sizeEnforcingInputStream_readAboveLimit() throws IOException {\n       byte[] buf = new byte[10];\n \n       try {\n-        thrown.expect(StatusRuntimeException.class);\n-        thrown.expectMessage(\"RESOURCE_EXHAUSTED: Decompressed gRPC message exceeds\");\n-\n-        stream.read(buf, 0, buf.length);\n+        StatusRuntimeException e = assertThrows(StatusRuntimeException.class,\n+            () -> stream.read(buf, 0, buf.length));\n+        assertThat(e).hasMessageThat()\n+            .isEqualTo(\"RESOURCE_EXHAUSTED: Decompressed gRPC message exceeds maximum size 2\");\n       } finally {\n         stream.close();\n       }\n@@ -470,10 +467,9 @@ public void sizeEnforcingInputStream_skipAboveLimit() throws IOException {\n               new MessageDeframer.SizeEnforcingInputStream(in, 2, statsTraceCtx);\n \n       try {\n-        thrown.expect(StatusRuntimeException.class);\n-        thrown.expectMessage(\"RESOURCE_EXHAUSTED: Decompressed gRPC message exceeds\");\n-\n-        stream.skip(4);\n+        StatusRuntimeException e = assertThrows(StatusRuntimeException.class, () -> stream.skip(4));\n+        assertThat(e).hasMessageThat()\n+            .isEqualTo(\"RESOURCE_EXHAUSTED: Decompressed gRPC message exceeds maximum size 2\");\n       } finally {\n         stream.close();\n       }\n\ndiff --git a/core/src/test/java/io/grpc/internal/ServerCallImplTest.java b/core/src/test/java/io/grpc/internal/ServerCallImplTest.java\nindex 652c94a4640..7394c83eab2 100644\n--- a/core/src/test/java/io/grpc/internal/ServerCallImplTest.java\n+++ b/core/src/test/java/io/grpc/internal/ServerCallImplTest.java\n@@ -16,12 +16,14 @@\n \n package io.grpc.internal;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static io.grpc.internal.GrpcUtil.CONTENT_LENGTH_KEY;\n import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n import static org.mockito.ArgumentMatchers.any;\n@@ -54,7 +56,6 @@\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.ArgumentCaptor;\n@@ -64,8 +65,6 @@\n \n @RunWith(JUnit4.class)\n public class ServerCallImplTest {\n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n   @Rule public final MockitoRule mocks = MockitoJUnit.rule();\n \n   @Mock private ServerStream stream;\n@@ -175,20 +174,20 @@ public void sendHeader_contentLengthDiscarded() {\n   @Test\n   public void sendHeader_failsOnSecondCall() {\n     call.sendHeaders(new Metadata());\n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\"sendHeaders has already been called\");\n-\n-    call.sendHeaders(new Metadata());\n+    Metadata headers = new Metadata();\n+    IllegalStateException e = assertThrows(IllegalStateException.class,\n+        () -> call.sendHeaders(headers));\n+    assertThat(e).hasMessageThat().isEqualTo(\"sendHeaders has already been called\");\n   }\n \n   @Test\n   public void sendHeader_failsOnClosed() {\n     call.close(Status.CANCELLED, new Metadata());\n \n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\"call is closed\");\n-\n-    call.sendHeaders(new Metadata());\n+    Metadata headers = new Metadata();\n+    IllegalStateException e = assertThrows(IllegalStateException.class,\n+        () -> call.sendHeaders(headers));\n+    assertThat(e).hasMessageThat().isEqualTo(\"call is closed\");\n   }\n \n   @Test\n@@ -204,18 +203,16 @@ public void sendMessage_failsOnClosed() {\n     call.sendHeaders(new Metadata());\n     call.close(Status.CANCELLED, new Metadata());\n \n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\"call is closed\");\n-\n-    call.sendMessage(1234L);\n+    IllegalStateException e = assertThrows(IllegalStateException.class,\n+        () -> call.sendMessage(1234L));\n+    assertThat(e).hasMessageThat().isEqualTo(\"call is closed\");\n   }\n \n   @Test\n   public void sendMessage_failsIfheadersUnsent() {\n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\"sendHeaders has not been called\");\n-\n-    call.sendMessage(1234L);\n+    IllegalStateException e = assertThrows(IllegalStateException.class,\n+        () -> call.sendMessage(1234L));\n+    assertThat(e).hasMessageThat().isEqualTo(\"sendHeaders has not been called\");\n   }\n \n   @Test\n@@ -490,9 +487,10 @@ public void streamListener_unexpectedRuntimeException() {\n \n     InputStream inputStream = UNARY_METHOD.streamRequest(1234L);\n \n-    thrown.expect(RuntimeException.class);\n-    thrown.expectMessage(\"unexpected exception\");\n-    streamListener.messagesAvailable(new SingleMessageProducer(inputStream));\n+    SingleMessageProducer producer = new SingleMessageProducer(inputStream);\n+    RuntimeException e = assertThrows(RuntimeException.class,\n+        () -> streamListener.messagesAvailable(producer));\n+    assertThat(e).hasMessageThat().isEqualTo(\"unexpected exception\");\n   }\n \n   private static class LongMarshaller implements Marshaller<Long> {\n\ndiff --git a/core/src/test/java/io/grpc/internal/ServerImplTest.java b/core/src/test/java/io/grpc/internal/ServerImplTest.java\nindex 3125edca1e6..2ddaba751e4 100644\n--- a/core/src/test/java/io/grpc/internal/ServerImplTest.java\n+++ b/core/src/test/java/io/grpc/internal/ServerImplTest.java\n@@ -26,6 +26,7 @@\n import static org.junit.Assert.assertNotSame;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n import static org.mockito.AdditionalAnswers.delegatesTo;\n@@ -104,7 +105,6 @@\n import org.junit.BeforeClass;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.ArgumentCaptor;\n@@ -140,8 +140,6 @@ public boolean shouldAccept(Runnable runnable) {\n       };\n   private static final String AUTHORITY = \"some_authority\";\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n   @Rule public final MockitoRule mocks = MockitoJUnit.rule();\n \n   @BeforeClass\n@@ -1228,7 +1226,7 @@ public void testStreamClose_deadlineExceededTriggersImmediateCancellation() thro\n     assertFalse(context.get().isCancelled());\n \n     assertEquals(1, timer.forwardNanos(1));\n-    \n+\n     assertTrue(callReference.get().isCancelled());\n     assertTrue(context.get().isCancelled());\n     assertThat(context.get().cancellationCause()).isNotNull();\n@@ -1260,9 +1258,8 @@ public List<InetSocketAddress> getListenSocketAddresses() {\n   public void getPortBeforeStartedFails() {\n     transportServer = new SimpleServer();\n     createServer();\n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\"started\");\n-    server.getPort();\n+    IllegalStateException e = assertThrows(IllegalStateException.class, () -> server.getPort());\n+    assertThat(e).hasMessageThat().isEqualTo(\"Not started\");\n   }\n \n   @Test\n@@ -1271,9 +1268,8 @@ public void getPortAfterTerminationFails() throws Exception {\n     createAndStartServer();\n     server.shutdown();\n     server.awaitTermination();\n-    thrown.expect(IllegalStateException.class);\n-    thrown.expectMessage(\"terminated\");\n-    server.getPort();\n+    IllegalStateException e = assertThrows(IllegalStateException.class, () -> server.getPort());\n+    assertThat(e).hasMessageThat().isEqualTo(\"Already terminated\");\n   }\n \n   @Test\n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java b/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\nindex 4a518895db6..1f4c2b41f15 100644\n--- a/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\n+++ b/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\n@@ -24,6 +24,7 @@\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n import static org.junit.Assume.assumeTrue;\n@@ -76,9 +77,7 @@\n import java.util.concurrent.TimeoutException;\n import org.junit.After;\n import org.junit.Before;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.mockito.ArgumentCaptor;\n@@ -209,10 +208,6 @@ public ServerStreamTracer newServerStreamTracer(String fullMethodName, Metadata\n           }\n         }));\n \n-  @SuppressWarnings(\"deprecation\") // https://github.com/grpc/grpc-java/issues/7467\n-  @Rule\n-  public ExpectedException thrown = ExpectedException.none();\n-\n   @Before\n   public void setUp() {\n     server = newServer(Arrays.asList(serverStreamTracerFactory));\n@@ -396,8 +391,7 @@ public void serverAlreadyListening() throws Exception {\n       port = ((InetSocketAddress) addr).getPort();\n     }\n     InternalServer server2 = newServer(port, Arrays.asList(serverStreamTracerFactory));\n-    thrown.expect(IOException.class);\n-    server2.start(new MockServerListener());\n+    assertThrows(IOException.class, () -> server2.start(new MockServerListener()));\n   }\n \n   @Test\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11955",
    "pr_id": 11955,
    "issue_id": 10524,
    "repo": "grpc/grpc-java",
    "problem_statement": "Stop allocating an Exception on Channel shutdown\n### What version of gRPC-Java are you using?\r\n\r\nThe latest\r\n\r\n### What is your environment?\r\n\r\nNot relevant\r\n\r\n### What did you expect to see?\r\n\r\nNot an Exception being allocated every time a Channel gets closed.\r\n\r\n### What did you see instead?\r\n\r\n`ClientTransportLifecycleManager#notifyShutdown` calls `Status#asException` that allocates an Exception for the sake of being able to track where `notifyShutdown` was called from. To my understanding, this is a debugging feature, nothing in gRPC's logic requires it.\r\n\r\nThis generates a lot of allocations when allocation lots of channels for load testing purpose.\r\n\r\nCould it be possible to deactivate this feature with a System property? And possibly deactivate it by default if it's indeed only used for debugging and changing it is not considered a breaking change.\r\n\r\n### Steps to reproduce the bug\r\n\r\nNot relevant",
    "issue_word_count": 139,
    "test_files_count": 6,
    "non_test_files_count": 10,
    "pr_changed_files": [
      "binder/src/main/java/io/grpc/binder/internal/PingTracker.java",
      "binder/src/test/java/io/grpc/binder/internal/PingTrackerTest.java",
      "core/src/main/java/io/grpc/internal/ClientTransport.java",
      "core/src/main/java/io/grpc/internal/FailingClientTransport.java",
      "core/src/main/java/io/grpc/internal/Http2Ping.java",
      "core/src/main/java/io/grpc/internal/KeepAliveManager.java",
      "core/src/test/java/io/grpc/internal/KeepAliveManagerTest.java",
      "core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java",
      "inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java",
      "netty/src/main/java/io/grpc/netty/ClientTransportLifecycleManager.java",
      "netty/src/main/java/io/grpc/netty/NettyClientHandler.java",
      "netty/src/main/java/io/grpc/netty/NettyClientTransport.java",
      "netty/src/test/java/io/grpc/netty/NettyClientHandlerTest.java",
      "netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java",
      "okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java",
      "okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java"
    ],
    "pr_changed_test_files": [
      "binder/src/test/java/io/grpc/binder/internal/PingTrackerTest.java",
      "core/src/test/java/io/grpc/internal/KeepAliveManagerTest.java",
      "core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java",
      "netty/src/test/java/io/grpc/netty/NettyClientHandlerTest.java",
      "netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java",
      "okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java"
    ],
    "base_commit": "e388ef3975ead0d549947bf75da8cd53d675a632",
    "head_commit": "7e2565d0eeb50c4ecb27e353416b6ee2d30c4a1d",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11955",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11955",
    "dockerfile": "",
    "pr_merged_at": "2025-03-19T03:57:34.000Z",
    "patch": "diff --git a/binder/src/main/java/io/grpc/binder/internal/PingTracker.java b/binder/src/main/java/io/grpc/binder/internal/PingTracker.java\nindex ab20af4d6ef..5a4300443ba 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/PingTracker.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/PingTracker.java\n@@ -99,7 +99,7 @@ private final class Ping {\n     private synchronized void fail(Status status) {\n       if (!done) {\n         done = true;\n-        executor.execute(() -> callback.onFailure(status.asException()));\n+        executor.execute(() -> callback.onFailure(status));\n       }\n     }\n \n\ndiff --git a/core/src/main/java/io/grpc/internal/ClientTransport.java b/core/src/main/java/io/grpc/internal/ClientTransport.java\nindex 98041cc6e79..fd0f30b8bf1 100644\n--- a/core/src/main/java/io/grpc/internal/ClientTransport.java\n+++ b/core/src/main/java/io/grpc/internal/ClientTransport.java\n@@ -22,6 +22,7 @@\n import io.grpc.InternalInstrumented;\n import io.grpc.Metadata;\n import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n import java.util.concurrent.Executor;\n import javax.annotation.concurrent.ThreadSafe;\n \n@@ -90,6 +91,6 @@ interface PingCallback {\n      *\n      * @param cause the cause of the ping failure\n      */\n-    void onFailure(Throwable cause);\n+    void onFailure(Status cause);\n   }\n }\n\ndiff --git a/core/src/main/java/io/grpc/internal/FailingClientTransport.java b/core/src/main/java/io/grpc/internal/FailingClientTransport.java\nindex 5b31e6e5073..37194c46a29 100644\n--- a/core/src/main/java/io/grpc/internal/FailingClientTransport.java\n+++ b/core/src/main/java/io/grpc/internal/FailingClientTransport.java\n@@ -55,7 +55,7 @@ public ClientStream newStream(\n   public void ping(final PingCallback callback, Executor executor) {\n     executor.execute(new Runnable() {\n         @Override public void run() {\n-          callback.onFailure(error.asException());\n+          callback.onFailure(error);\n         }\n       });\n   }\n\ndiff --git a/core/src/main/java/io/grpc/internal/Http2Ping.java b/core/src/main/java/io/grpc/internal/Http2Ping.java\nindex d96ac3ef214..e3520295625 100644\n--- a/core/src/main/java/io/grpc/internal/Http2Ping.java\n+++ b/core/src/main/java/io/grpc/internal/Http2Ping.java\n@@ -18,6 +18,7 @@\n \n import com.google.common.base.Stopwatch;\n import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import io.grpc.Status;\n import io.grpc.internal.ClientTransport.PingCallback;\n import java.util.LinkedHashMap;\n import java.util.Map;\n@@ -62,7 +63,7 @@ public class Http2Ping {\n   /**\n    * If non-null, indicates the ping failed.\n    */\n-  @GuardedBy(\"this\") private Throwable failureCause;\n+  @GuardedBy(\"this\") private Status failureCause;\n \n   /**\n    * The round-trip time for the ping, in nanoseconds. This value is only meaningful when\n@@ -144,7 +145,7 @@ public boolean complete() {\n    *\n    * @param failureCause the cause of failure\n    */\n-  public void failed(Throwable failureCause) {\n+  public void failed(Status failureCause) {\n     Map<ClientTransport.PingCallback, Executor> callbacks;\n     synchronized (this) {\n       if (completed) {\n@@ -167,7 +168,7 @@ public void failed(Throwable failureCause) {\n    * @param executor the executor used to invoke the callback\n    * @param cause the cause of failure\n    */\n-  public static void notifyFailed(PingCallback callback, Executor executor, Throwable cause) {\n+  public static void notifyFailed(PingCallback callback, Executor executor, Status cause) {\n     doExecute(executor, asRunnable(callback, cause));\n   }\n \n@@ -203,7 +204,7 @@ public void run() {\n    * failure.\n    */\n   private static Runnable asRunnable(final ClientTransport.PingCallback callback,\n-                                     final Throwable failureCause) {\n+                                     final Status failureCause) {\n     return new Runnable() {\n       @Override\n       public void run() {\n\ndiff --git a/core/src/main/java/io/grpc/internal/KeepAliveManager.java b/core/src/main/java/io/grpc/internal/KeepAliveManager.java\nindex aed590c3051..d831a096087 100644\n--- a/core/src/main/java/io/grpc/internal/KeepAliveManager.java\n+++ b/core/src/main/java/io/grpc/internal/KeepAliveManager.java\n@@ -275,7 +275,7 @@ public void ping() {\n         public void onSuccess(long roundTripTimeNanos) {}\n \n         @Override\n-        public void onFailure(Throwable cause) {\n+        public void onFailure(Status cause) {\n           transport.shutdownNow(Status.UNAVAILABLE.withDescription(\n               \"Keepalive failed. The connection is likely gone\"));\n         }\n\ndiff --git a/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java b/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java\nindex 39ebe6e0ab7..e294b4eb63f 100644\n--- a/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java\n+++ b/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java\n@@ -246,7 +246,7 @@ public synchronized void ping(final PingCallback callback, Executor executor) {\n       executor.execute(new Runnable() {\n         @Override\n         public void run() {\n-          callback.onFailure(shutdownStatus.asRuntimeException());\n+          callback.onFailure(shutdownStatus);\n         }\n       });\n     } else {\n\ndiff --git a/netty/src/main/java/io/grpc/netty/ClientTransportLifecycleManager.java b/netty/src/main/java/io/grpc/netty/ClientTransportLifecycleManager.java\nindex 34f72ab97bd..b4e53d5568c 100644\n--- a/netty/src/main/java/io/grpc/netty/ClientTransportLifecycleManager.java\n+++ b/netty/src/main/java/io/grpc/netty/ClientTransportLifecycleManager.java\n@@ -30,7 +30,6 @@ final class ClientTransportLifecycleManager {\n   /** null iff !transportShutdown. */\n   private Status shutdownStatus;\n   /** null iff !transportShutdown. */\n-  private Throwable shutdownThrowable;\n   private boolean transportTerminated;\n \n   public ClientTransportLifecycleManager(ManagedClientTransport.Listener listener) {\n@@ -72,7 +71,6 @@ public boolean notifyShutdown(Status s) {\n       return false;\n     }\n     shutdownStatus = s;\n-    shutdownThrowable = s.asException();\n     return true;\n   }\n \n@@ -97,7 +95,4 @@ public Status getShutdownStatus() {\n     return shutdownStatus;\n   }\n \n-  public Throwable getShutdownThrowable() {\n-    return shutdownThrowable;\n-  }\n }\n\ndiff --git a/netty/src/main/java/io/grpc/netty/NettyClientHandler.java b/netty/src/main/java/io/grpc/netty/NettyClientHandler.java\nindex 5a93dbc982b..721eeff938a 100644\n--- a/netty/src/main/java/io/grpc/netty/NettyClientHandler.java\n+++ b/netty/src/main/java/io/grpc/netty/NettyClientHandler.java\n@@ -499,7 +499,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n         streamStatus = lifecycleManager.getShutdownStatus();\n       }\n       try {\n-        cancelPing(lifecycleManager.getShutdownThrowable());\n+        cancelPing(lifecycleManager.getShutdownStatus());\n         // Report status to the application layer for any open streams\n         connection().forEachActiveStream(new Http2StreamVisitor() {\n           @Override\n@@ -593,13 +593,14 @@ protected boolean isGracefulShutdownComplete() {\n    */\n   private void createStream(CreateStreamCommand command, ChannelPromise promise)\n           throws Exception {\n-    if (lifecycleManager.getShutdownThrowable() != null) {\n+    if (lifecycleManager.getShutdownStatus() != null) {\n       command.stream().setNonExistent();\n       // The connection is going away (it is really the GOAWAY case),\n       // just terminate the stream now.\n       command.stream().transportReportStatus(\n           lifecycleManager.getShutdownStatus(), RpcProgress.MISCARRIED, true, new Metadata());\n-      promise.setFailure(lifecycleManager.getShutdownThrowable());\n+      promise.setFailure(InternalStatus.asRuntimeExceptionWithoutStacktrace(\n+              lifecycleManager.getShutdownStatus(), null));\n       return;\n     }\n \n@@ -852,19 +853,21 @@ private void sendPingFrameTraced(ChannelHandlerContext ctx, SendPingCommand msg,\n       public void operationComplete(ChannelFuture future) throws Exception {\n         if (future.isSuccess()) {\n           transportTracer.reportKeepAliveSent();\n-        } else {\n-          Throwable cause = future.cause();\n-          if (cause instanceof ClosedChannelException) {\n-            cause = lifecycleManager.getShutdownThrowable();\n-            if (cause == null) {\n-              cause = Status.UNKNOWN.withDescription(\"Ping failed but for unknown reason.\")\n-                  .withCause(future.cause()).asException();\n-            }\n-          }\n-          finalPing.failed(cause);\n-          if (ping == finalPing) {\n-            ping = null;\n+          return;\n+        }\n+        Throwable cause = future.cause();\n+        Status status = lifecycleManager.getShutdownStatus();\n+        if (cause instanceof ClosedChannelException) {\n+          if (status == null) {\n+            status = Status.UNKNOWN.withDescription(\"Ping failed but for unknown reason.\")\n+                    .withCause(future.cause());\n           }\n+        } else {\n+          status = Utils.statusFromThrowable(cause);\n+        }\n+        finalPing.failed(status);\n+        if (ping == finalPing) {\n+          ping = null;\n         }\n       }\n     });\n@@ -963,9 +966,9 @@ public boolean visit(Http2Stream stream) throws Http2Exception {\n     }\n   }\n \n-  private void cancelPing(Throwable t) {\n+  private void cancelPing(Status s) {\n     if (ping != null) {\n-      ping.failed(t);\n+      ping.failed(s);\n       ping = null;\n     }\n   }\n\ndiff --git a/netty/src/main/java/io/grpc/netty/NettyClientTransport.java b/netty/src/main/java/io/grpc/netty/NettyClientTransport.java\nindex 86d8991ba95..e03989e9906 100644\n--- a/netty/src/main/java/io/grpc/netty/NettyClientTransport.java\n+++ b/netty/src/main/java/io/grpc/netty/NettyClientTransport.java\n@@ -165,7 +165,7 @@ public void ping(final PingCallback callback, final Executor executor) {\n       executor.execute(new Runnable() {\n         @Override\n         public void run() {\n-          callback.onFailure(statusExplainingWhyTheChannelIsNull.asException());\n+          callback.onFailure(statusExplainingWhyTheChannelIsNull);\n         }\n       });\n       return;\n@@ -177,7 +177,7 @@ public void run() {\n       public void operationComplete(ChannelFuture future) throws Exception {\n         if (!future.isSuccess()) {\n           Status s = statusFromFailedFuture(future);\n-          Http2Ping.notifyFailed(callback, executor, s.asException());\n+          Http2Ping.notifyFailed(callback, executor, s);\n         }\n       }\n     };\n\ndiff --git a/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java b/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java\nindex 055d6e08161..7c107188518 100644\n--- a/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java\n+++ b/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java\n@@ -1062,12 +1062,12 @@ private void setInUse(OkHttpClientStream stream) {\n     }\n   }\n \n-  private Throwable getPingFailure() {\n+  private Status getPingFailure() {\n     synchronized (lock) {\n       if (goAwayStatus != null) {\n-        return goAwayStatus.asException();\n+        return goAwayStatus;\n       } else {\n-        return Status.UNAVAILABLE.withDescription(\"Connection closed\").asException();\n+        return Status.UNAVAILABLE.withDescription(\"Connection closed\");\n       }\n     }\n   }\n",
    "test_patch": "diff --git a/binder/src/test/java/io/grpc/binder/internal/PingTrackerTest.java b/binder/src/test/java/io/grpc/binder/internal/PingTrackerTest.java\nindex 60e7c163105..c662cafe5fa 100644\n--- a/binder/src/test/java/io/grpc/binder/internal/PingTrackerTest.java\n+++ b/binder/src/test/java/io/grpc/binder/internal/PingTrackerTest.java\n@@ -96,7 +96,7 @@ private static final class TestCallback implements ClientTransport.PingCallback\n     private int numCallbacks;\n     private boolean success;\n     private boolean failure;\n-    private Throwable failureException;\n+    private Status failureStatus;\n     private long roundtripTimeNanos;\n \n     @Override\n@@ -107,10 +107,10 @@ public synchronized void onSuccess(long roundtripTimeNanos) {\n     }\n \n     @Override\n-    public synchronized void onFailure(Throwable failureException) {\n+    public synchronized void onFailure(Status failureStatus) {\n       numCallbacks += 1;\n       failure = true;\n-      this.failureException = failureException;\n+      this.failureStatus = failureStatus;\n     }\n \n     public void assertNotCalled() {\n@@ -130,13 +130,13 @@ public void assertSuccess(long expectRoundTripTimeNanos) {\n     public void assertFailure(Status status) {\n       assertThat(numCallbacks).isEqualTo(1);\n       assertThat(failure).isTrue();\n-      assertThat(((StatusException) failureException).getStatus()).isSameInstanceAs(status);\n+      assertThat(failureStatus).isSameInstanceAs(status);\n     }\n \n     public void assertFailure(Status.Code statusCode) {\n       assertThat(numCallbacks).isEqualTo(1);\n       assertThat(failure).isTrue();\n-      assertThat(((StatusException) failureException).getStatus().getCode()).isEqualTo(statusCode);\n+      assertThat(failureStatus.getCode()).isEqualTo(statusCode);\n     }\n   }\n }\n\ndiff --git a/core/src/test/java/io/grpc/internal/KeepAliveManagerTest.java b/core/src/test/java/io/grpc/internal/KeepAliveManagerTest.java\nindex 411a9fbe9fc..3cf7bfcedfe 100644\n--- a/core/src/test/java/io/grpc/internal/KeepAliveManagerTest.java\n+++ b/core/src/test/java/io/grpc/internal/KeepAliveManagerTest.java\n@@ -127,7 +127,7 @@ public void clientKeepAlivePinger_pingFailure() {\n     verify(transport).ping(pingCallbackCaptor.capture(), isA(Executor.class));\n     ClientTransport.PingCallback pingCallback = pingCallbackCaptor.getValue();\n \n-    pingCallback.onFailure(new Throwable());\n+    pingCallback.onFailure(Status.UNAVAILABLE.withDescription(\"I must write descriptions\"));\n \n     ArgumentCaptor<Status> statusCaptor = ArgumentCaptor.forClass(Status.class);\n     verify(transport).shutdownNow(statusCaptor.capture());\n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java b/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\nindex aea7ff49032..4a518895db6 100644\n--- a/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\n+++ b/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\n@@ -181,7 +181,7 @@ public void log(ChannelLogLevel level, String messageFormat, Object... args) {}\n   protected ManagedClientTransport.Listener mockClientTransportListener\n       = mock(ManagedClientTransport.Listener.class);\n   protected MockServerListener serverListener = new MockServerListener();\n-  private ArgumentCaptor<Throwable> throwableCaptor = ArgumentCaptor.forClass(Throwable.class);\n+  private ArgumentCaptor<Status> statusCaptor = ArgumentCaptor.forClass(Status.class);\n   protected final TestClientStreamTracer clientStreamTracer1 = new TestHeaderClientStreamTracer();\n   private final TestClientStreamTracer clientStreamTracer2 = new TestHeaderClientStreamTracer();\n   protected final ClientStreamTracer[] tracers = new ClientStreamTracer[] {\n@@ -626,8 +626,8 @@ public void ping_afterTermination() throws Exception {\n       // Transport doesn't support ping, so this neither passes nor fails.\n       assumeTrue(false);\n     }\n-    verify(mockPingCallback, timeout(TIMEOUT_MS)).onFailure(throwableCaptor.capture());\n-    Status status = Status.fromThrowable(throwableCaptor.getValue());\n+    verify(mockPingCallback, timeout(TIMEOUT_MS)).onFailure(statusCaptor.capture());\n+    Status status = statusCaptor.getValue();\n     assertSame(shutdownReason, status);\n   }\n \n\ndiff --git a/netty/src/test/java/io/grpc/netty/NettyClientHandlerTest.java b/netty/src/test/java/io/grpc/netty/NettyClientHandlerTest.java\nindex 945c6c1267a..f8fbeea9b82 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyClientHandlerTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyClientHandlerTest.java\n@@ -59,7 +59,6 @@\n import io.grpc.CallOptions;\n import io.grpc.Metadata;\n import io.grpc.Status;\n-import io.grpc.StatusException;\n import io.grpc.internal.AbstractStream;\n import io.grpc.internal.ClientStreamListener;\n import io.grpc.internal.ClientStreamListener.RpcProgress;\n@@ -812,9 +811,7 @@ public void ping_failsWhenChannelCloses() throws Exception {\n     handler().channelInactive(ctx());\n     // ping failed on channel going inactive\n     assertEquals(1, callback.invocationCount);\n-    assertTrue(callback.failureCause instanceof StatusException);\n-    assertEquals(Status.Code.UNAVAILABLE,\n-        ((StatusException) callback.failureCause).getStatus().getCode());\n+    assertEquals(Status.Code.UNAVAILABLE, callback.failureCause.getCode());\n     // A failed ping is still counted\n     assertEquals(1, transportTracer.getStats().keepAlivesSent);\n   }\n@@ -1169,7 +1166,7 @@ private static CreateStreamCommand newCreateStreamCommand(\n   private static class PingCallbackImpl implements ClientTransport.PingCallback {\n     int invocationCount;\n     long roundTripTime;\n-    Throwable failureCause;\n+    Status failureCause;\n \n     @Override\n     public void onSuccess(long roundTripTimeNanos) {\n@@ -1178,7 +1175,7 @@ public void onSuccess(long roundTripTimeNanos) {\n     }\n \n     @Override\n-    public void onFailure(Throwable cause) {\n+    public void onFailure(Status cause) {\n       invocationCount++;\n       this.failureCause = cause;\n     }\n\ndiff --git a/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java b/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java\nindex 9b3b2e386d3..65683dd8396 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java\n@@ -548,8 +548,8 @@ public void onSuccess(long roundTripTimeNanos) {\n       }\n \n       @Override\n-      public void onFailure(Throwable cause) {\n-        pingResult.setException(cause);\n+      public void onFailure(Status cause) {\n+        pingResult.setException(cause.asException());\n       }\n     };\n     transport.ping(pingCallback, clock.getScheduledExecutorService());\n\ndiff --git a/okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java b/okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java\nindex daf5073992e..826dee8e2b4 100644\n--- a/okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java\n+++ b/okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java\n@@ -67,7 +67,6 @@\n import io.grpc.MethodDescriptor.MethodType;\n import io.grpc.Status;\n import io.grpc.Status.Code;\n-import io.grpc.StatusException;\n import io.grpc.internal.AbstractStream;\n import io.grpc.internal.ClientStreamListener;\n import io.grpc.internal.ClientTransport;\n@@ -1664,16 +1663,14 @@ public void ping_failsWhenTransportShutdown() throws Exception {\n     clientTransport.shutdown(SHUTDOWN_REASON);\n     // ping failed on channel shutdown\n     assertEquals(1, callback.invocationCount);\n-    assertTrue(callback.failureCause instanceof StatusException);\n-    assertSame(SHUTDOWN_REASON, ((StatusException) callback.failureCause).getStatus());\n+    assertSame(SHUTDOWN_REASON, callback.failureCause);\n \n     // now that handler is in terminal state, all future pings fail immediately\n     callback = new PingCallbackImpl();\n     clientTransport.ping(callback, MoreExecutors.directExecutor());\n     assertEquals(1, getTransportStats(clientTransport).keepAlivesSent);\n     assertEquals(1, callback.invocationCount);\n-    assertTrue(callback.failureCause instanceof StatusException);\n-    assertSame(SHUTDOWN_REASON, ((StatusException) callback.failureCause).getStatus());\n+    assertSame(SHUTDOWN_REASON, callback.failureCause);\n     shutdownAndVerify();\n   }\n \n@@ -1688,18 +1685,14 @@ public void ping_failsIfTransportFails() throws Exception {\n     clientTransport.onException(new IOException());\n     // ping failed on error\n     assertEquals(1, callback.invocationCount);\n-    assertTrue(callback.failureCause instanceof StatusException);\n-    assertEquals(Status.Code.UNAVAILABLE,\n-        ((StatusException) callback.failureCause).getStatus().getCode());\n+    assertEquals(Status.Code.UNAVAILABLE, callback.failureCause.getCode());\n \n     // now that handler is in terminal state, all future pings fail immediately\n     callback = new PingCallbackImpl();\n     clientTransport.ping(callback, MoreExecutors.directExecutor());\n     assertEquals(1, getTransportStats(clientTransport).keepAlivesSent);\n     assertEquals(1, callback.invocationCount);\n-    assertTrue(callback.failureCause instanceof StatusException);\n-    assertEquals(Status.Code.UNAVAILABLE,\n-        ((StatusException) callback.failureCause).getStatus().getCode());\n+    assertEquals(Status.Code.UNAVAILABLE, callback.failureCause.getCode());\n     shutdownAndVerify();\n   }\n \n@@ -2385,7 +2378,7 @@ public InputStream getInputStream() {\n   static class PingCallbackImpl implements ClientTransport.PingCallback {\n     int invocationCount;\n     long roundTripTime;\n-    Throwable failureCause;\n+    Status failureCause;\n \n     @Override\n     public void onSuccess(long roundTripTimeNanos) {\n@@ -2394,7 +2387,7 @@ public void onSuccess(long roundTripTimeNanos) {\n     }\n \n     @Override\n-    public void onFailure(Throwable cause) {\n+    public void onFailure(Status cause) {\n       invocationCount++;\n       this.failureCause = cause;\n     }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11934",
    "pr_id": 11934,
    "issue_id": 11853,
    "repo": "grpc/grpc-java",
    "problem_statement": "HealthStatusManager.setStatus can throw a runtime exception when notifying (already cancelled) watchers\n### What version of gRPC-Java are you using? \n1.65.1\n\n### What is your environment?\nJammy Ubuntu running on ARM64, JDK 21.0.4\n\n### What did you expect to see?\n\nNo exception. Healthcheck watchers with connections cancelled can/should be ignored.\n\n### What did you see instead?\n\nThe follow exception occurs:\n\n```\nio.grpc.StatusRuntimeException: CANCELLED: call already cancelled. Use ServerCallStreamObserver.setOnCancelHandler() to disable this exception\n\tat io.grpc.Status.asRuntimeException(Status.java:525)\n\tat io.grpc.stub.ServerCalls$ServerCallStreamObserverImpl.onNext(ServerCalls.java:366)\n\tat io.grpc.protobuf.services.HealthServiceImpl.notifyWatchers(HealthServiceImpl.java:179)\n\tat io.grpc.protobuf.services.HealthServiceImpl.setStatusInternal(HealthServiceImpl.java:130)\n\tat io.grpc.protobuf.services.HealthServiceImpl.setStatus(HealthServiceImpl.java:122)\n\tat io.grpc.protobuf.services.HealthStatusManager.setStatus(HealthStatusManager.java:67)\n\t...\n```\n\nDue to this exception not all Healthcheck watching clients are notified.\n\n### Steps to reproduce the bug\n\n<!-- Make sure you include information that can help us debug (full error message, exception listing, stack trace, logs). -->\n\nUse HealthStatusManager.setStatus to set the health check status on a running server with a large number of clients, including some recently closed clients. Setting the status too recently after a client has closed its stream will trigger the exception.\n",
    "issue_word_count": 208,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "services/src/main/java/io/grpc/protobuf/services/HealthServiceImpl.java",
      "services/src/test/java/io/grpc/protobuf/services/HealthStatusManagerTest.java"
    ],
    "pr_changed_test_files": [
      "services/src/test/java/io/grpc/protobuf/services/HealthStatusManagerTest.java"
    ],
    "base_commit": "d2d72cda83256919a49432a792192c9313d171cb",
    "head_commit": "fbaeb476009d3ab4396999dc5ba11a75809b6410",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11934",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11934",
    "dockerfile": "",
    "pr_merged_at": "2025-03-25T12:12:29.000Z",
    "patch": "diff --git a/services/src/main/java/io/grpc/protobuf/services/HealthServiceImpl.java b/services/src/main/java/io/grpc/protobuf/services/HealthServiceImpl.java\nindex 2efe4b3951a..5cd294b4fbe 100644\n--- a/services/src/main/java/io/grpc/protobuf/services/HealthServiceImpl.java\n+++ b/services/src/main/java/io/grpc/protobuf/services/HealthServiceImpl.java\n@@ -27,6 +27,7 @@\n import io.grpc.health.v1.HealthCheckResponse;\n import io.grpc.health.v1.HealthCheckResponse.ServingStatus;\n import io.grpc.health.v1.HealthGrpc;\n+import io.grpc.stub.ServerCallStreamObserver;\n import io.grpc.stub.StreamObserver;\n import java.util.HashMap;\n import java.util.IdentityHashMap;\n@@ -83,6 +84,11 @@ public void watch(HealthCheckRequest request,\n       final StreamObserver<HealthCheckResponse> responseObserver) {\n     final String service = request.getService();\n     synchronized (watchLock) {\n+      if (responseObserver instanceof ServerCallStreamObserver) {\n+        ((ServerCallStreamObserver) responseObserver).setOnCancelHandler(() -> {\n+          removeWatcher(service, responseObserver);\n+        });\n+      }\n       ServingStatus status = statusMap.get(service);\n       responseObserver.onNext(getResponseForWatch(status));\n       IdentityHashMap<StreamObserver<HealthCheckResponse>, Boolean> serviceWatchers =\n@@ -98,21 +104,25 @@ public void watch(HealthCheckRequest request,\n           @Override\n           // Called when the client has closed the stream\n           public void cancelled(Context context) {\n-            synchronized (watchLock) {\n-              IdentityHashMap<StreamObserver<HealthCheckResponse>, Boolean> serviceWatchers =\n-                  watchers.get(service);\n-              if (serviceWatchers != null) {\n-                serviceWatchers.remove(responseObserver);\n-                if (serviceWatchers.isEmpty()) {\n-                  watchers.remove(service);\n-                }\n-              }\n-            }\n+            removeWatcher(service, responseObserver);\n           }\n         },\n         MoreExecutors.directExecutor());\n   }\n \n+  void removeWatcher(String service, StreamObserver<HealthCheckResponse> responseObserver) {\n+    synchronized (watchLock) {\n+      IdentityHashMap<StreamObserver<HealthCheckResponse>, Boolean> serviceWatchers =\n+              watchers.get(service);\n+      if (serviceWatchers != null) {\n+        serviceWatchers.remove(responseObserver);\n+        if (serviceWatchers.isEmpty()) {\n+          watchers.remove(service);\n+        }\n+      }\n+    }\n+  }\n+\n   void setStatus(String service, ServingStatus status) {\n     synchronized (watchLock) {\n       if (terminal) {\n",
    "test_patch": "diff --git a/services/src/test/java/io/grpc/protobuf/services/HealthStatusManagerTest.java b/services/src/test/java/io/grpc/protobuf/services/HealthStatusManagerTest.java\nindex 87d4ac29be8..b2652e92771 100644\n--- a/services/src/test/java/io/grpc/protobuf/services/HealthStatusManagerTest.java\n+++ b/services/src/test/java/io/grpc/protobuf/services/HealthStatusManagerTest.java\n@@ -18,6 +18,11 @@\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n import io.grpc.BindableService;\n import io.grpc.Context;\n@@ -28,6 +33,7 @@\n import io.grpc.health.v1.HealthCheckResponse;\n import io.grpc.health.v1.HealthCheckResponse.ServingStatus;\n import io.grpc.health.v1.HealthGrpc;\n+import io.grpc.stub.ServerCallStreamObserver;\n import io.grpc.stub.StreamObserver;\n import io.grpc.testing.GrpcServerRule;\n import java.util.ArrayDeque;\n@@ -109,6 +115,18 @@ public void enterTerminalState_watch() throws Exception {\n     assertThat(obs.responses).isEmpty();\n   }\n \n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void serverCallStreamObserver_watch() throws Exception {\n+    manager.setStatus(SERVICE1, ServingStatus.SERVING);\n+    ServerCallStreamObserver<HealthCheckResponse> observer = mock(ServerCallStreamObserver.class);\n+    service.watch(HealthCheckRequest.newBuilder().setService(SERVICE1).build(), observer);\n+\n+    verify(observer, times(1))\n+            .onNext(eq(HealthCheckResponse.newBuilder().setStatus(ServingStatus.SERVING).build()));\n+    verify(observer, times(1)).setOnCancelHandler(any(Runnable.class));\n+  }\n+\n   @Test\n   public void enterTerminalState_ignoreClear() throws Exception {\n     manager.setStatus(SERVICE1, ServingStatus.SERVING);\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11933",
    "pr_id": 11933,
    "issue_id": 11737,
    "repo": "grpc/grpc-java",
    "problem_statement": "XdsNameResolver and XdsServerWrapper don't check listener type\nOur resource parsing supports two listener types (I'm not confident enough validation is happening here):\r\nhttps://github.com/grpc/grpc-java/blob/210f9c083e7ce6c831b2b65f0ee7f9c1384a88f9/xds/src/main/java/io/grpc/xds/XdsListenerResource.java#L110-L114\r\n\r\nBut [XdsNameResolver](https://github.com/grpc/grpc-java/blob/210f9c083e7ce6c831b2b65f0ee7f9c1384a88f9/xds/src/main/java/io/grpc/xds/XdsNameResolver.java#L656) and [XdsServerWrapper](https://github.com/grpc/grpc-java/blob/210f9c083e7ce6c831b2b65f0ee7f9c1384a88f9/xds/src/main/java/io/grpc/xds/XdsServerWrapper.java#L375) don't check that they got the right type. No changes were made to XdsNameResolver [when non-API listener type was allowed](https://github.com/grpc/grpc-java/commit/afe883119d72451a81668f49b6dc4c5a83c20867), so I doubt the logic exists but I'm just not seeing it.\r\n\r\nI also don't see XdsServerWrapper call `address()`, so it appears it is not follow [gRFC A36](https://github.com/grpc/proposal/blob/master/A36-xds-for-servers.md#xds-protocol).\r\n> The XdsServer must be \"not serving\" if the address does not match.",
    "issue_word_count": 169,
    "test_files_count": 7,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java",
      "xds/src/main/java/io/grpc/xds/XdsListenerResource.java",
      "xds/src/main/java/io/grpc/xds/XdsNameResolver.java",
      "xds/src/main/java/io/grpc/xds/XdsServerWrapper.java",
      "xds/src/test/java/io/grpc/xds/ControlPlaneRule.java",
      "xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java",
      "xds/src/test/java/io/grpc/xds/XdsClientWrapperForServerSdsTestMisc.java",
      "xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java",
      "xds/src/test/java/io/grpc/xds/XdsServerBuilderTest.java",
      "xds/src/test/java/io/grpc/xds/XdsServerTestHelper.java",
      "xds/src/test/java/io/grpc/xds/XdsServerWrapperTest.java"
    ],
    "pr_changed_test_files": [
      "xds/src/test/java/io/grpc/xds/ControlPlaneRule.java",
      "xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java",
      "xds/src/test/java/io/grpc/xds/XdsClientWrapperForServerSdsTestMisc.java",
      "xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java",
      "xds/src/test/java/io/grpc/xds/XdsServerBuilderTest.java",
      "xds/src/test/java/io/grpc/xds/XdsServerTestHelper.java",
      "xds/src/test/java/io/grpc/xds/XdsServerWrapperTest.java"
    ],
    "base_commit": "a57c14a51ea0d1551ff2bef54844d6da8ed5c7db",
    "head_commit": "eee4ea915d41541327066fbb57c821432320ccca",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11933",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11933",
    "dockerfile": "",
    "pr_merged_at": "2025-04-03T05:52:26.000Z",
    "patch": "diff --git a/xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java b/xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java\nindex ae5b3c5b1c9..fd2a1d2a069 100644\n--- a/xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java\n+++ b/xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java\n@@ -22,6 +22,7 @@\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.ImmutableList;\n import com.google.protobuf.util.Durations;\n+import io.envoyproxy.envoy.config.core.v3.SocketAddress.Protocol;\n import io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CommonTlsContext;\n import io.grpc.Internal;\n import io.grpc.xds.client.EnvoyProtoData;\n@@ -248,13 +249,17 @@ abstract static class Listener {\n     @Nullable\n     abstract FilterChain defaultFilterChain();\n \n+    @Nullable\n+    abstract Protocol protocol();\n+\n     static Listener create(\n         String name,\n         @Nullable String address,\n         ImmutableList<FilterChain> filterChains,\n-        @Nullable FilterChain defaultFilterChain) {\n+        @Nullable FilterChain defaultFilterChain,\n+        @Nullable Protocol protocol) {\n       return new AutoValue_EnvoyServerProtoData_Listener(name, address, filterChains,\n-          defaultFilterChain);\n+          defaultFilterChain, protocol);\n     }\n   }\n \n\ndiff --git a/xds/src/main/java/io/grpc/xds/XdsListenerResource.java b/xds/src/main/java/io/grpc/xds/XdsListenerResource.java\nindex ec0cbbf243f..041b659b4c3 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsListenerResource.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsListenerResource.java\n@@ -162,13 +162,16 @@ static EnvoyServerProtoData.Listener parseServerSideListener(\n     }\n \n     String address = null;\n+    SocketAddress socketAddress = null;\n     if (proto.getAddress().hasSocketAddress()) {\n-      SocketAddress socketAddress = proto.getAddress().getSocketAddress();\n+      socketAddress = proto.getAddress().getSocketAddress();\n       address = socketAddress.getAddress();\n+      if (address.isEmpty()) {\n+        throw new ResourceInvalidException(\"Invalid address: Empty address is not allowed.\");\n+      }\n       switch (socketAddress.getPortSpecifierCase()) {\n         case NAMED_PORT:\n-          address = address + \":\" + socketAddress.getNamedPort();\n-          break;\n+          throw new ResourceInvalidException(\"NAMED_PORT is not supported in gRPC.\");\n         case PORT_VALUE:\n           address = address + \":\" + socketAddress.getPortValue();\n           break;\n@@ -209,8 +212,8 @@ static EnvoyServerProtoData.Listener parseServerSideListener(\n           null, certProviderInstances, args);\n     }\n \n-    return EnvoyServerProtoData.Listener.create(\n-        proto.getName(), address, filterChains.build(), defaultFilterChain);\n+    return EnvoyServerProtoData.Listener.create(proto.getName(), address, filterChains.build(),\n+        defaultFilterChain, socketAddress == null ? null : socketAddress.getProtocol());\n   }\n \n   @VisibleForTesting\n\ndiff --git a/xds/src/main/java/io/grpc/xds/XdsNameResolver.java b/xds/src/main/java/io/grpc/xds/XdsNameResolver.java\nindex 5c1b3105c45..484c975f998 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsNameResolver.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsNameResolver.java\n@@ -676,6 +676,13 @@ public void onUpdate(StatusOr<XdsConfig> updateOrStatus) {\n       // Process Route\n       XdsConfig update = updateOrStatus.getValue();\n       HttpConnectionManager httpConnectionManager = update.getListener().httpConnectionManager();\n+      if (httpConnectionManager == null) {\n+        logger.log(XdsLogLevel.INFO, \"API Listener: httpConnectionManager does not exist.\");\n+        updateActiveFilters(null);\n+        cleanUpRoutes(updateOrStatus.getStatus());\n+        return;\n+      }\n+\n       VirtualHost virtualHost = update.getVirtualHost();\n       ImmutableList<NamedFilterConfig> filterConfigs = httpConnectionManager.httpFilterConfigs();\n       long streamDurationNano = httpConnectionManager.httpMaxStreamDurationNano();\n\ndiff --git a/xds/src/main/java/io/grpc/xds/XdsServerWrapper.java b/xds/src/main/java/io/grpc/xds/XdsServerWrapper.java\nindex e0185974861..c3f71d1d082 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsServerWrapper.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsServerWrapper.java\n@@ -24,7 +24,10 @@\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.net.InetAddresses;\n import com.google.common.util.concurrent.SettableFuture;\n+import io.envoyproxy.envoy.config.core.v3.SocketAddress.Protocol;\n import io.grpc.Attributes;\n import io.grpc.InternalServerInterceptors;\n import io.grpc.Metadata;\n@@ -57,6 +60,7 @@\n import io.grpc.xds.client.XdsClient.ResourceWatcher;\n import io.grpc.xds.internal.security.SslContextProviderSupplier;\n import java.io.IOException;\n+import java.net.InetAddress;\n import java.net.SocketAddress;\n import java.util.ArrayList;\n import java.util.HashMap;\n@@ -383,7 +387,21 @@ public void onChanged(final LdsUpdate update) {\n         return;\n       }\n       logger.log(Level.FINEST, \"Received Lds update {0}\", update);\n-      checkNotNull(update.listener(), \"update\");\n+      if (update.listener() == null) {\n+        onResourceDoesNotExist(\"Non-API\");\n+        return;\n+      }\n+\n+      String ldsAddress = update.listener().address();\n+      if (ldsAddress == null || update.listener().protocol() != Protocol.TCP\n+          || !ipAddressesMatch(ldsAddress)) {\n+        handleConfigNotFoundOrMismatch(\n+            Status.UNKNOWN.withDescription(\n+                String.format(\n+                    \"Listener address mismatch: expected %s, but got %s.\",\n+                    listenerAddress, ldsAddress)).asException());\n+        return;\n+      }\n       if (!pendingRds.isEmpty()) {\n         // filter chain state has not yet been applied to filterChainSelectorManager and there\n         // are two sets of sslContextProviderSuppliers, so we release the old ones.\n@@ -432,6 +450,18 @@ public void onChanged(final LdsUpdate update) {\n       }\n     }\n \n+    private boolean ipAddressesMatch(String ldsAddress) {\n+      HostAndPort ldsAddressHnP = HostAndPort.fromString(ldsAddress);\n+      HostAndPort listenerAddressHnP = HostAndPort.fromString(listenerAddress);\n+      if (!ldsAddressHnP.hasPort() || !listenerAddressHnP.hasPort()\n+          || ldsAddressHnP.getPort() != listenerAddressHnP.getPort()) {\n+        return false;\n+      }\n+      InetAddress listenerIp = InetAddresses.forString(listenerAddressHnP.getHost());\n+      InetAddress ldsIp = InetAddresses.forString(ldsAddressHnP.getHost());\n+      return listenerIp.equals(ldsIp);\n+    }\n+\n     @Override\n     public void onResourceDoesNotExist(final String resourceName) {\n       if (stopped) {\n@@ -440,7 +470,7 @@ public void onResourceDoesNotExist(final String resourceName) {\n       StatusException statusException = Status.UNAVAILABLE.withDescription(\n           String.format(\"Listener %s unavailable, xDS node ID: %s\", resourceName,\n               xdsClient.getBootstrapInfo().node().getId())).asException();\n-      handleConfigNotFound(statusException);\n+      handleConfigNotFoundOrMismatch(statusException);\n     }\n \n     @Override\n@@ -673,7 +703,7 @@ public <ReqT, RespT> Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call,\n       };\n     }\n \n-    private void handleConfigNotFound(StatusException exception) {\n+    private void handleConfigNotFoundOrMismatch(StatusException exception) {\n       cleanUpRouteDiscoveryStates();\n       shutdownActiveFilters();\n       List<SslContextProviderSupplier> toRelease = getSuppliersInUse();\n",
    "test_patch": "diff --git a/xds/src/test/java/io/grpc/xds/ControlPlaneRule.java b/xds/src/test/java/io/grpc/xds/ControlPlaneRule.java\nindex 39761912ea5..8c10627d153 100644\n--- a/xds/src/test/java/io/grpc/xds/ControlPlaneRule.java\n+++ b/xds/src/test/java/io/grpc/xds/ControlPlaneRule.java\n@@ -366,10 +366,14 @@ static Listener buildServerListener() {\n         .setFilterChainMatch(filterChainMatch)\n         .addFilters(filter)\n         .build();\n+    Address address = Address.newBuilder()\n+        .setSocketAddress(SocketAddress.newBuilder().setAddress(\"0.0.0.0\").setPortValue(0))\n+        .build();\n     return Listener.newBuilder()\n         .setName(SERVER_LISTENER_TEMPLATE_NO_REPLACEMENT)\n         .setTrafficDirection(TrafficDirection.INBOUND)\n         .addFilterChains(filterChain)\n+        .setAddress(address)\n         .build();\n   }\n }\n\ndiff --git a/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java b/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java\nindex 90b83320d63..bcd608953a0 100644\n--- a/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java\n+++ b/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplDataTest.java\n@@ -2660,6 +2660,41 @@ public void parseServerSideListener_useOriginalDst() throws ResourceInvalidExcep\n         listener,null, filterRegistry, null, getXdsResourceTypeArgs(true));\n   }\n \n+  @Test\n+  public void parseServerSideListener_emptyAddress() throws ResourceInvalidException {\n+    Listener listener =\n+        Listener.newBuilder()\n+            .setName(\"listener1\")\n+            .setTrafficDirection(TrafficDirection.INBOUND)\n+            .setAddress(Address.newBuilder()\n+                .setSocketAddress(\n+                    SocketAddress.newBuilder()))\n+            .build();\n+    thrown.expect(ResourceInvalidException.class);\n+    thrown.expectMessage(\"Invalid address: Empty address is not allowed.\");\n+\n+    XdsListenerResource.parseServerSideListener(\n+        listener,null, filterRegistry, null, getXdsResourceTypeArgs(true));\n+  }\n+\n+  @Test\n+  public void parseServerSideListener_namedPort() throws ResourceInvalidException {\n+    Listener listener =\n+        Listener.newBuilder()\n+            .setName(\"listener1\")\n+            .setTrafficDirection(TrafficDirection.INBOUND)\n+            .setAddress(Address.newBuilder()\n+                .setSocketAddress(\n+                    SocketAddress.newBuilder()\n+                        .setAddress(\"172.14.14.5\").setNamedPort(\"\")))\n+            .build();\n+    thrown.expect(ResourceInvalidException.class);\n+    thrown.expectMessage(\"NAMED_PORT is not supported in gRPC.\");\n+\n+    XdsListenerResource.parseServerSideListener(\n+        listener,null, filterRegistry, null, getXdsResourceTypeArgs(true));\n+  }\n+\n   @Test\n   public void parseServerSideListener_nonUniqueFilterChainMatch() throws ResourceInvalidException {\n     Filter filter1 = buildHttpConnectionManagerFilter(\n\ndiff --git a/xds/src/test/java/io/grpc/xds/XdsClientWrapperForServerSdsTestMisc.java b/xds/src/test/java/io/grpc/xds/XdsClientWrapperForServerSdsTestMisc.java\nindex f3f4d74eb2f..ff97afe6916 100644\n--- a/xds/src/test/java/io/grpc/xds/XdsClientWrapperForServerSdsTestMisc.java\n+++ b/xds/src/test/java/io/grpc/xds/XdsClientWrapperForServerSdsTestMisc.java\n@@ -32,6 +32,7 @@\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.util.concurrent.SettableFuture;\n+import io.envoyproxy.envoy.config.core.v3.SocketAddress.Protocol;\n import io.grpc.Server;\n import io.grpc.ServerBuilder;\n import io.grpc.Status;\n@@ -165,9 +166,10 @@ public void run() {\n     EnvoyServerProtoData.Listener tcpListener =\n         EnvoyServerProtoData.Listener.create(\n             \"listener1\",\n-            \"10.1.2.3\",\n+            \"0.0.0.0:7000\",\n             ImmutableList.of(),\n-            null);\n+            null,\n+            Protocol.TCP);\n     LdsUpdate listenerUpdate = LdsUpdate.forTcpListener(tcpListener);\n     xdsClient.ldsWatcher.onChanged(listenerUpdate);\n     verify(listener, timeout(5000)).onServing();\n\ndiff --git a/xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java b/xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java\nindex cd3ef293369..271e7191e4c 100644\n--- a/xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java\n+++ b/xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java\n@@ -35,6 +35,7 @@\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.util.concurrent.SettableFuture;\n+import io.envoyproxy.envoy.config.core.v3.SocketAddress.Protocol;\n import io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext;\n import io.grpc.Attributes;\n import io.grpc.EquivalentAddressGroup;\n@@ -488,7 +489,7 @@ public void mtlsClientServer_changeServerContext_expectException()\n     DownstreamTlsContext downstreamTlsContext =\n         CommonTlsContextTestsUtil.buildDownstreamTlsContext(\n             \"cert-instance-name2\", true, true);\n-    EnvoyServerProtoData.Listener listener = buildListener(\"listener1\", \"0.0.0.0\",\n+    EnvoyServerProtoData.Listener listener = buildListener(\"listener1\", \"0.0.0.0:0\",\n             downstreamTlsContext,\n             tlsContextManagerForServer);\n     xdsClient.deliverLdsUpdate(LdsUpdate.forTcpListener(listener));\n@@ -592,7 +593,7 @@ private void buildServer(\n     tlsContextManagerForServer = new TlsContextManagerImpl(bootstrapInfoForServer);\n     XdsServerWrapper xdsServer = (XdsServerWrapper) builder.build();\n     SettableFuture<Throwable> startFuture = startServerAsync(xdsServer);\n-    EnvoyServerProtoData.Listener listener = buildListener(\"listener1\", \"10.1.2.3\",\n+    EnvoyServerProtoData.Listener listener = buildListener(\"listener1\", \"0.0.0.0:0\",\n             downstreamTlsContext, tlsContextManagerForServer);\n     LdsUpdate listenerUpdate = LdsUpdate.forTcpListener(listener);\n     xdsClient.deliverLdsUpdate(listenerUpdate);\n@@ -633,7 +634,7 @@ static EnvoyServerProtoData.Listener buildListener(\n         \"filter-chain-foo\", filterChainMatch, httpConnectionManager, tlsContext,\n         tlsContextManager);\n     EnvoyServerProtoData.Listener listener = EnvoyServerProtoData.Listener.create(\n-        name, address, ImmutableList.of(defaultFilterChain), null);\n+        name, address, ImmutableList.of(defaultFilterChain), null, Protocol.TCP);\n     return listener;\n   }\n \n\ndiff --git a/xds/src/test/java/io/grpc/xds/XdsServerBuilderTest.java b/xds/src/test/java/io/grpc/xds/XdsServerBuilderTest.java\nindex d28c7d7c607..2c168c65869 100644\n--- a/xds/src/test/java/io/grpc/xds/XdsServerBuilderTest.java\n+++ b/xds/src/test/java/io/grpc/xds/XdsServerBuilderTest.java\n@@ -17,6 +17,7 @@\n package io.grpc.xds;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsServerTestHelper.buildTestListener;\n import static org.junit.Assert.fail;\n import static org.mockito.Mockito.any;\n import static org.mockito.Mockito.mock;\n@@ -26,6 +27,7 @@\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.util.concurrent.SettableFuture;\n import io.grpc.BindableService;\n import io.grpc.InsecureServerCredentials;\n@@ -33,6 +35,7 @@\n import io.grpc.Status;\n import io.grpc.StatusException;\n import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.xds.XdsListenerResource.LdsUpdate;\n import io.grpc.xds.XdsServerTestHelper.FakeXdsClient;\n import io.grpc.xds.XdsServerTestHelper.FakeXdsClientPoolFactory;\n import io.grpc.xds.internal.security.CommonTlsContextTestsUtil;\n@@ -221,10 +224,13 @@ public void xdsServer_startError()\n     buildServer(mockXdsServingStatusListener);\n     Future<Throwable> future = startServerAsync();\n     // create port conflict for start to fail\n-    XdsServerTestHelper.generateListenerUpdate(\n-        xdsClient,\n+    EnvoyServerProtoData.Listener listener = buildTestListener(\n+        \"listener1\", \"0.0.0.0:\" + port, ImmutableList.of(),\n         CommonTlsContextTestsUtil.buildTestInternalDownstreamTlsContext(\"CERT1\", \"VA1\"),\n-            tlsContextManager);\n+        null, tlsContextManager);\n+    LdsUpdate listenerUpdate = LdsUpdate.forTcpListener(listener);\n+    xdsClient.deliverLdsUpdate(listenerUpdate);\n+\n     Throwable exception = future.get(5, TimeUnit.SECONDS);\n     assertThat(exception).isInstanceOf(IOException.class);\n     assertThat(exception).hasMessageThat().contains(\"Failed to bind\");\n\ndiff --git a/xds/src/test/java/io/grpc/xds/XdsServerTestHelper.java b/xds/src/test/java/io/grpc/xds/XdsServerTestHelper.java\nindex ec9f4c54c31..b0472b4729d 100644\n--- a/xds/src/test/java/io/grpc/xds/XdsServerTestHelper.java\n+++ b/xds/src/test/java/io/grpc/xds/XdsServerTestHelper.java\n@@ -21,6 +21,7 @@\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.util.concurrent.SettableFuture;\n+import io.envoyproxy.envoy.config.core.v3.SocketAddress.Protocol;\n import io.grpc.InsecureChannelCredentials;\n import io.grpc.MetricRecorder;\n import io.grpc.internal.ObjectPool;\n@@ -74,7 +75,7 @@ public class XdsServerTestHelper {\n   static void generateListenerUpdate(FakeXdsClient xdsClient,\n                                      EnvoyServerProtoData.DownstreamTlsContext tlsContext,\n                                      TlsContextManager tlsContextManager) {\n-    EnvoyServerProtoData.Listener listener = buildTestListener(\"listener1\", \"10.1.2.3\",\n+    EnvoyServerProtoData.Listener listener = buildTestListener(\"listener1\", \"0.0.0.0:0\",\n         ImmutableList.of(), tlsContext, null, tlsContextManager);\n     LdsUpdate listenerUpdate = LdsUpdate.forTcpListener(listener);\n     xdsClient.deliverLdsUpdate(listenerUpdate);\n@@ -85,7 +86,8 @@ static void generateListenerUpdate(\n       EnvoyServerProtoData.DownstreamTlsContext tlsContext,\n       EnvoyServerProtoData.DownstreamTlsContext tlsContextForDefaultFilterChain,\n       TlsContextManager tlsContextManager) {\n-    EnvoyServerProtoData.Listener listener = buildTestListener(\"listener1\", \"10.1.2.3\", sourcePorts,\n+    EnvoyServerProtoData.Listener listener = buildTestListener(\n+        \"listener1\", \"0.0.0.0:7000\", sourcePorts,\n         tlsContext, tlsContextForDefaultFilterChain, tlsContextManager);\n     LdsUpdate listenerUpdate = LdsUpdate.forTcpListener(listener);\n     xdsClient.deliverLdsUpdate(listenerUpdate);\n@@ -130,7 +132,7 @@ static EnvoyServerProtoData.Listener buildTestListener(\n         tlsContextForDefaultFilterChain, tlsContextManager);\n     EnvoyServerProtoData.Listener listener =\n         EnvoyServerProtoData.Listener.create(\n-            name, address, ImmutableList.of(filterChain1), defaultFilterChain);\n+            name, address, ImmutableList.of(filterChain1), defaultFilterChain, Protocol.TCP);\n     return listener;\n   }\n \n@@ -290,6 +292,14 @@ private String awaitLdsResource(Duration timeout) {\n       }\n     }\n \n+    void deliverLdsUpdateWithApiListener(long httpMaxStreamDurationNano,\n+        List<VirtualHost> virtualHosts) {\n+      execute(() -> {\n+        ldsWatcher.onChanged(LdsUpdate.forApiListener(HttpConnectionManager.forVirtualHosts(\n+            httpMaxStreamDurationNano, virtualHosts, null)));\n+      });\n+    }\n+\n     void deliverLdsUpdate(LdsUpdate ldsUpdate) {\n       execute(() -> ldsWatcher.onChanged(ldsUpdate));\n     }\n@@ -297,8 +307,8 @@ void deliverLdsUpdate(LdsUpdate ldsUpdate) {\n     void deliverLdsUpdate(\n         List<FilterChain> filterChains,\n         @Nullable FilterChain defaultFilterChain) {\n-      deliverLdsUpdate(LdsUpdate.forTcpListener(Listener.create(\n-          \"listener\", \"0.0.0.0:1\", ImmutableList.copyOf(filterChains), defaultFilterChain)));\n+      deliverLdsUpdate(LdsUpdate.forTcpListener(Listener.create(\"listener\", \"0.0.0.0:1\",\n+          ImmutableList.copyOf(filterChains), defaultFilterChain, Protocol.TCP)));\n     }\n \n     void deliverLdsUpdate(FilterChain filterChain, @Nullable FilterChain defaultFilterChain) {\n\ndiff --git a/xds/src/test/java/io/grpc/xds/XdsServerWrapperTest.java b/xds/src/test/java/io/grpc/xds/XdsServerWrapperTest.java\nindex b866e10c559..84ade8db34f 100644\n--- a/xds/src/test/java/io/grpc/xds/XdsServerWrapperTest.java\n+++ b/xds/src/test/java/io/grpc/xds/XdsServerWrapperTest.java\n@@ -37,6 +37,7 @@\n import com.google.common.collect.ImmutableMap;\n import com.google.common.net.InetAddresses;\n import com.google.common.util.concurrent.SettableFuture;\n+import io.envoyproxy.envoy.config.core.v3.SocketAddress.Protocol;\n import io.grpc.Attributes;\n import io.grpc.InsecureChannelCredentials;\n import io.grpc.Metadata;\n@@ -54,6 +55,7 @@\n import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.grpc.xds.EnvoyServerProtoData.Listener;\n import io.grpc.xds.Filter.FilterConfig;\n import io.grpc.xds.Filter.NamedFilterConfig;\n import io.grpc.xds.FilterChainMatchingProtocolNegotiators.FilterChainMatchingHandler.FilterChainSelector;\n@@ -61,6 +63,7 @@\n import io.grpc.xds.VirtualHost.Route;\n import io.grpc.xds.VirtualHost.Route.RouteMatch;\n import io.grpc.xds.VirtualHost.Route.RouteMatch.PathMatcher;\n+import io.grpc.xds.XdsListenerResource.LdsUpdate;\n import io.grpc.xds.XdsRouteConfigureResource.RdsUpdate;\n import io.grpc.xds.XdsServerBuilder.XdsServingStatusListener;\n import io.grpc.xds.XdsServerTestHelper.FakeXdsClient;\n@@ -538,6 +541,146 @@ public void run() {\n     verify(mockServer).start();\n   }\n \n+  @Test\n+  public void onChanged_listenerIsNull()\n+      throws ExecutionException, InterruptedException, TimeoutException {\n+    xdsServerWrapper = new XdsServerWrapper(\"10.1.2.3:1\", mockBuilder, listener,\n+        selectorManager, new FakeXdsClientPoolFactory(xdsClient),\n+        filterRegistry, executor.getScheduledExecutorService());\n+    final SettableFuture<Server> start = SettableFuture.create();\n+    Executors.newSingleThreadExecutor().execute(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          start.set(xdsServerWrapper.start());\n+        } catch (Exception ex) {\n+          start.setException(ex);\n+        }\n+      }\n+    });\n+    String ldsResource = xdsClient.ldsResource.get(5, TimeUnit.SECONDS);\n+    assertThat(ldsResource).isEqualTo(\"grpc/server?udpa.resource.listening_address=10.1.2.3:1\");\n+    VirtualHost virtualHost =\n+        VirtualHost.create(\n+            \"virtual-host\", Collections.singletonList(\"auth\"), new ArrayList<Route>(),\n+            ImmutableMap.<String, FilterConfig>of());\n+\n+    xdsClient.deliverLdsUpdateWithApiListener(0L, Arrays.asList(virtualHost));\n+\n+    verify(listener, timeout(10000)).onNotServing(any());\n+  }\n+\n+  @Test\n+  public void onChanged_listenerAddressMissingPort()\n+      throws ExecutionException, InterruptedException, TimeoutException {\n+    xdsServerWrapper = new XdsServerWrapper(\"10.1.2.3:1\", mockBuilder, listener,\n+        selectorManager, new FakeXdsClientPoolFactory(xdsClient),\n+        filterRegistry, executor.getScheduledExecutorService());\n+    final SettableFuture<Server> start = SettableFuture.create();\n+    Executors.newSingleThreadExecutor().execute(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          start.set(xdsServerWrapper.start());\n+        } catch (Exception ex) {\n+          start.setException(ex);\n+        }\n+      }\n+    });\n+    String ldsResource = xdsClient.ldsResource.get(5, TimeUnit.SECONDS);\n+    assertThat(ldsResource).isEqualTo(\"grpc/server?udpa.resource.listening_address=10.1.2.3:1\");\n+    VirtualHost virtualHost =\n+        VirtualHost.create(\n+            \"virtual-host\", Collections.singletonList(\"auth\"), new ArrayList<Route>(),\n+            ImmutableMap.<String, FilterConfig>of());\n+    HttpConnectionManager httpConnectionManager = HttpConnectionManager.forVirtualHosts(\n+        0L, Collections.singletonList(virtualHost), new ArrayList<NamedFilterConfig>());\n+    EnvoyServerProtoData.FilterChain filterChain = EnvoyServerProtoData.FilterChain.create(\n+        \"filter-chain-foo\", createMatch(), httpConnectionManager, createTls(),\n+        mock(TlsContextManager.class));\n+    LdsUpdate listenerUpdate = LdsUpdate.forTcpListener(\n+        Listener.create(\"listener\", \"20.3.4.5:\",\n+            ImmutableList.copyOf(Collections.singletonList(filterChain)), null, Protocol.TCP));\n+\n+    xdsClient.deliverLdsUpdate(listenerUpdate);\n+\n+    verify(listener, timeout(10000)).onNotServing(any());\n+  }\n+\n+  @Test\n+  public void onChanged_listenerAddressMismatch()\n+      throws ExecutionException, InterruptedException, TimeoutException {\n+    xdsServerWrapper = new XdsServerWrapper(\"10.1.2.3:1\", mockBuilder, listener,\n+        selectorManager, new FakeXdsClientPoolFactory(xdsClient),\n+        filterRegistry, executor.getScheduledExecutorService());\n+    final SettableFuture<Server> start = SettableFuture.create();\n+    Executors.newSingleThreadExecutor().execute(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          start.set(xdsServerWrapper.start());\n+        } catch (Exception ex) {\n+          start.setException(ex);\n+        }\n+      }\n+    });\n+    String ldsResource = xdsClient.ldsResource.get(5, TimeUnit.SECONDS);\n+    assertThat(ldsResource).isEqualTo(\"grpc/server?udpa.resource.listening_address=10.1.2.3:1\");\n+    VirtualHost virtualHost =\n+        VirtualHost.create(\n+            \"virtual-host\", Collections.singletonList(\"auth\"), new ArrayList<Route>(),\n+            ImmutableMap.<String, FilterConfig>of());\n+    HttpConnectionManager httpConnectionManager = HttpConnectionManager.forVirtualHosts(\n+        0L, Collections.singletonList(virtualHost), new ArrayList<NamedFilterConfig>());\n+    EnvoyServerProtoData.FilterChain filterChain = EnvoyServerProtoData.FilterChain.create(\n+        \"filter-chain-foo\", createMatch(), httpConnectionManager, createTls(),\n+        mock(TlsContextManager.class));\n+    LdsUpdate listenerUpdate = LdsUpdate.forTcpListener(\n+        Listener.create(\"listener\", \"20.3.4.5:1\",\n+            ImmutableList.copyOf(Collections.singletonList(filterChain)), null, Protocol.TCP));\n+\n+    xdsClient.deliverLdsUpdate(listenerUpdate);\n+\n+    verify(listener, timeout(10000)).onNotServing(any());\n+  }\n+\n+  @Test\n+  public void onChanged_listenerAddressPortMismatch()\n+      throws ExecutionException, InterruptedException, TimeoutException {\n+    xdsServerWrapper = new XdsServerWrapper(\"10.1.2.3:1\", mockBuilder, listener,\n+        selectorManager, new FakeXdsClientPoolFactory(xdsClient),\n+        filterRegistry, executor.getScheduledExecutorService());\n+    final SettableFuture<Server> start = SettableFuture.create();\n+    Executors.newSingleThreadExecutor().execute(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          start.set(xdsServerWrapper.start());\n+        } catch (Exception ex) {\n+          start.setException(ex);\n+        }\n+      }\n+    });\n+    String ldsResource = xdsClient.ldsResource.get(5, TimeUnit.SECONDS);\n+    assertThat(ldsResource).isEqualTo(\"grpc/server?udpa.resource.listening_address=10.1.2.3:1\");\n+    VirtualHost virtualHost =\n+        VirtualHost.create(\n+            \"virtual-host\", Collections.singletonList(\"auth\"), new ArrayList<Route>(),\n+            ImmutableMap.<String, FilterConfig>of());\n+    HttpConnectionManager httpConnectionManager = HttpConnectionManager.forVirtualHosts(\n+        0L, Collections.singletonList(virtualHost), new ArrayList<NamedFilterConfig>());\n+    EnvoyServerProtoData.FilterChain filterChain = EnvoyServerProtoData.FilterChain.create(\n+        \"filter-chain-foo\", createMatch(), httpConnectionManager, createTls(),\n+        mock(TlsContextManager.class));\n+    LdsUpdate listenerUpdate = LdsUpdate.forTcpListener(\n+        Listener.create(\"listener\", \"10.1.2.3:2\",\n+            ImmutableList.copyOf(Collections.singletonList(filterChain)), null, Protocol.TCP));\n+\n+    xdsClient.deliverLdsUpdate(listenerUpdate);\n+\n+    verify(listener, timeout(10000)).onNotServing(any());\n+  }\n+\n   @Test\n   public void discoverState_rds() throws Exception {\n     final SettableFuture<Server> start = SettableFuture.create();\n@@ -1811,7 +1954,7 @@ private static HttpConnectionManager createRds(String name) {\n   /**\n    * Returns the least-specific match-all Filter Chain Match.\n    */\n-  private static FilterChainMatch createMatch() {\n+  static FilterChainMatch createMatch() {\n     return FilterChainMatch.create(\n         0,\n         ImmutableList.of(),\n@@ -1867,7 +2010,7 @@ private static MethodDescriptor<Void, Void> createMethod(String path) {\n             .build();\n   }\n \n-  private static EnvoyServerProtoData.DownstreamTlsContext createTls() {\n+  static EnvoyServerProtoData.DownstreamTlsContext createTls() {\n     return CommonTlsContextTestsUtil.buildTestInternalDownstreamTlsContext(\"CERT1\", \"VA1\");\n   }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11932",
    "pr_id": 11932,
    "issue_id": 11926,
    "repo": "grpc/grpc-java",
    "problem_statement": "xds: xDS server - unnecessary dns lookup (blocking) when parsing FilterChainMatch address prefixes?\nA bit strange that `EnvoyServerProtoData.CidrRange.create` uses `InetAddress.getByName`, which will perform a DNS lookup when a hostname provided in `addressPrefix`:\n\nhttps://github.com/grpc/grpc-java/blob/cdab410b816f65f0aec683dda5b96f37f9fd567e/xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java#L153-L157\n\nShould we be using Guava's [`InetAddresses#forString`](https://guava.dev/releases/snapshot-android/api/docs/com/google/common/net/InetAddresses.html#forString(java.lang.String)) which is \"deliberately avoids all nameservice lookups\"?\n",
    "issue_word_count": 86,
    "test_files_count": 1,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java",
      "xds/src/main/java/io/grpc/xds/XdsListenerResource.java",
      "xds/src/test/java/io/grpc/xds/FilterChainMatchingProtocolNegotiatorsTest.java"
    ],
    "pr_changed_test_files": [
      "xds/src/test/java/io/grpc/xds/FilterChainMatchingProtocolNegotiatorsTest.java"
    ],
    "base_commit": "cdab410b816f65f0aec683dda5b96f37f9fd567e",
    "head_commit": "0094e38b6bdb75805259340fa32b6d5285314fb1",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11932",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11932",
    "dockerfile": "",
    "pr_merged_at": "2025-03-06T10:34:53.000Z",
    "patch": "diff --git a/xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java b/xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java\nindex 4a6213277e7..8c37e90855b 100644\n--- a/xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java\n+++ b/xds/src/main/java/io/grpc/xds/EnvoyServerProtoData.java\n@@ -27,7 +27,6 @@\n import io.grpc.xds.client.EnvoyProtoData;\n import io.grpc.xds.internal.security.SslContextProviderSupplier;\n import java.net.InetAddress;\n-import java.net.UnknownHostException;\n import java.util.Objects;\n import javax.annotation.Nullable;\n \n@@ -150,9 +149,9 @@ abstract static class CidrRange {\n \n     abstract int prefixLen();\n \n-    static CidrRange create(String addressPrefix, int prefixLen) throws UnknownHostException {\n+    static CidrRange create(InetAddress addressPrefix, int prefixLen) {\n       return new AutoValue_EnvoyServerProtoData_CidrRange(\n-          InetAddress.getByName(addressPrefix), prefixLen);\n+          addressPrefix, prefixLen);\n     }\n   }\n \n\ndiff --git a/xds/src/main/java/io/grpc/xds/XdsListenerResource.java b/xds/src/main/java/io/grpc/xds/XdsListenerResource.java\nindex 4b554be1743..2d9743143fc 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsListenerResource.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsListenerResource.java\n@@ -25,6 +25,7 @@\n import com.google.auto.value.AutoValue;\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.net.InetAddresses;\n import com.google.protobuf.Any;\n import com.google.protobuf.InvalidProtocolBufferException;\n import com.google.protobuf.Message;\n@@ -43,7 +44,6 @@\n import io.grpc.xds.Filter.FilterConfig;\n import io.grpc.xds.XdsListenerResource.LdsUpdate;\n import io.grpc.xds.client.XdsResourceType;\n-import java.net.UnknownHostException;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashSet;\n@@ -446,16 +446,18 @@ private static FilterChainMatch parseFilterChainMatch(\n     try {\n       for (io.envoyproxy.envoy.config.core.v3.CidrRange range : proto.getPrefixRangesList()) {\n         prefixRanges.add(\n-            CidrRange.create(range.getAddressPrefix(), range.getPrefixLen().getValue()));\n+            CidrRange.create(InetAddresses.forString(range.getAddressPrefix()),\n+                range.getPrefixLen().getValue()));\n       }\n       for (io.envoyproxy.envoy.config.core.v3.CidrRange range\n           : proto.getSourcePrefixRangesList()) {\n-        sourcePrefixRanges.add(\n-            CidrRange.create(range.getAddressPrefix(), range.getPrefixLen().getValue()));\n+        sourcePrefixRanges.add(CidrRange.create(\n+            InetAddresses.forString(range.getAddressPrefix()), range.getPrefixLen().getValue()));\n       }\n-    } catch (UnknownHostException e) {\n-      throw new ResourceInvalidException(\"Failed to create CidrRange\", e);\n+    } catch (IllegalArgumentException ex) {\n+      throw new ResourceInvalidException(\"Failed to create CidrRange\", ex);\n     }\n+\n     ConnectionSourceType sourceType;\n     switch (proto.getSourceType()) {\n       case ANY:\n",
    "test_patch": "diff --git a/xds/src/test/java/io/grpc/xds/FilterChainMatchingProtocolNegotiatorsTest.java b/xds/src/test/java/io/grpc/xds/FilterChainMatchingProtocolNegotiatorsTest.java\nindex 685102477cc..c3d006a6003 100644\n--- a/xds/src/test/java/io/grpc/xds/FilterChainMatchingProtocolNegotiatorsTest.java\n+++ b/xds/src/test/java/io/grpc/xds/FilterChainMatchingProtocolNegotiatorsTest.java\n@@ -25,6 +25,7 @@\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.net.InetAddresses;\n import com.google.common.util.concurrent.SettableFuture;\n import io.grpc.ServerInterceptor;\n import io.grpc.internal.TestUtils.NoopChannelLogger;\n@@ -58,7 +59,6 @@\n import io.netty.handler.codec.http2.Http2Settings;\n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n-import java.net.UnknownHostException;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n@@ -318,7 +318,8 @@ public void destPrefixRangeMatch() throws Exception {\n     EnvoyServerProtoData.FilterChainMatch filterChainMatchWithMatch =\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.1.2.0\", 24)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.1.2.0\"), 24)),\n             ImmutableList.of(),\n             ImmutableList.of(),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n@@ -360,7 +361,8 @@ public void destPrefixRangeMismatch_returnDefaultFilterChain()\n     EnvoyServerProtoData.FilterChainMatch filterChainMatchWithMismatch =\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.2.2.0\", 24)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.2.2.0\"), 24)),\n             ImmutableList.of(),\n             ImmutableList.of(),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n@@ -403,7 +405,8 @@ public void dest0LengthPrefixRange()\n     EnvoyServerProtoData.FilterChainMatch filterChainMatch0Length =\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.2.2.0\", 0)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.2.2.0\"), 0)),\n             ImmutableList.of(),\n             ImmutableList.of(),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n@@ -444,7 +447,8 @@ public void destPrefixRange_moreSpecificWins()\n     EnvoyServerProtoData.FilterChainMatch filterChainMatchLessSpecific =\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.1.2.0\", 24)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.1.2.0\"), 24)),\n             ImmutableList.of(),\n             ImmutableList.of(),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n@@ -461,7 +465,8 @@ public void destPrefixRange_moreSpecificWins()\n     EnvoyServerProtoData.FilterChainMatch filterChainMatchMoreSpecific =\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.1.2.2\", 31)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.1.2.2\"), 31)),\n             ImmutableList.of(),\n             ImmutableList.of(),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n@@ -519,7 +524,8 @@ public void destPrefixRange_emptyListLessSpecific()\n     EnvoyServerProtoData.FilterChainMatch filterChainMatchMoreSpecific =\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"8.0.0.0\", 5)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"8.0.0.0\"), 5)),\n             ImmutableList.of(),\n             ImmutableList.of(),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n@@ -559,7 +565,8 @@ public void destPrefixRangeIpv6_moreSpecificWins()\n     EnvoyServerProtoData.FilterChainMatch filterChainMatchLessSpecific =\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"FE80:0:0:0:0:0:0:0\", 60)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"FE80:0:0:0:0:0:0:0\"), 60)),\n             ImmutableList.of(),\n             ImmutableList.of(),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n@@ -577,7 +584,8 @@ public void destPrefixRangeIpv6_moreSpecificWins()\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n             ImmutableList.of(\n-                EnvoyServerProtoData.CidrRange.create(\"FE80:0000:0000:0000:0202:0:0:0\", 80)),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"FE80:0000:0000:0000:0202:0:0:0\"), 80)),\n             ImmutableList.of(),\n             ImmutableList.of(),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n@@ -620,8 +628,10 @@ public void destPrefixRange_moreSpecificWith2Wins()\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n             ImmutableList.of(\n-                EnvoyServerProtoData.CidrRange.create(\"10.1.2.0\", 24),\n-                EnvoyServerProtoData.CidrRange.create(LOCAL_IP, 32)),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"10.1.2.0\"), 24),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(LOCAL_IP), 32)),\n             ImmutableList.of(),\n             ImmutableList.of(),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n@@ -638,7 +648,8 @@ public void destPrefixRange_moreSpecificWith2Wins()\n     EnvoyServerProtoData.FilterChainMatch filterChainMatchLessSpecific =\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.1.2.2\", 31)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.1.2.2\"), 31)),\n             ImmutableList.of(),\n             ImmutableList.of(),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n@@ -763,8 +774,10 @@ public void sourcePrefixRange_moreSpecificWith2Wins()\n             ImmutableList.of(),\n             ImmutableList.of(),\n             ImmutableList.of(\n-                EnvoyServerProtoData.CidrRange.create(\"10.4.2.0\", 24),\n-                EnvoyServerProtoData.CidrRange.create(REMOTE_IP, 32)),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"10.4.2.0\"), 24),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(REMOTE_IP), 32)),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n             ImmutableList.of(),\n             ImmutableList.of(),\n@@ -781,7 +794,8 @@ public void sourcePrefixRange_moreSpecificWith2Wins()\n             0,\n             ImmutableList.of(),\n             ImmutableList.of(),\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.4.2.2\", 31)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.4.2.2\"), 31)),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n             ImmutableList.of(),\n             ImmutableList.of(),\n@@ -811,8 +825,7 @@ filterChainLessSpecific, randomConfig(\"no-match\")),\n   }\n \n   @Test\n-  public void sourcePrefixRange_2Matchers_expectException()\n-          throws UnknownHostException {\n+  public void sourcePrefixRange_2Matchers_expectException() {\n     ChannelHandler next = new ChannelInboundHandlerAdapter() {\n       @Override\n       public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n@@ -831,8 +844,10 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n             ImmutableList.of(),\n             ImmutableList.of(),\n             ImmutableList.of(\n-                EnvoyServerProtoData.CidrRange.create(\"10.4.2.0\", 24),\n-                EnvoyServerProtoData.CidrRange.create(\"192.168.10.2\", 32)),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"10.4.2.0\"), 24),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"192.168.10.2\"), 32)),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n             ImmutableList.of(),\n             ImmutableList.of(),\n@@ -848,7 +863,8 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n             0,\n             ImmutableList.of(),\n             ImmutableList.of(),\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.4.2.0\", 24)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.4.2.0\"), 24)),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n             ImmutableList.of(),\n             ImmutableList.of(),\n@@ -890,8 +906,10 @@ public void sourcePortMatch_exactMatchWinsOverEmptyList() throws Exception {\n             ImmutableList.of(),\n             ImmutableList.of(),\n             ImmutableList.of(\n-                EnvoyServerProtoData.CidrRange.create(\"10.4.2.0\", 24),\n-                EnvoyServerProtoData.CidrRange.create(\"10.4.2.2\", 31)),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"10.4.2.0\"), 24),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"10.4.2.2\"), 31)),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n             ImmutableList.of(),\n             ImmutableList.of(),\n@@ -908,7 +926,8 @@ public void sourcePortMatch_exactMatchWinsOverEmptyList() throws Exception {\n             0,\n             ImmutableList.of(),\n             ImmutableList.of(),\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.4.2.2\", 31)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.4.2.2\"), 31)),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n             ImmutableList.of(7000, 15000),\n             ImmutableList.of(),\n@@ -966,7 +985,8 @@ public void filterChain_5stepMatch() throws Exception {\n             PORT,\n             ImmutableList.of(),\n             ImmutableList.of(),\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(REMOTE_IP, 32)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(REMOTE_IP), 32)),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n             ImmutableList.of(),\n             ImmutableList.of(),\n@@ -981,9 +1001,11 @@ public void filterChain_5stepMatch() throws Exception {\n     EnvoyServerProtoData.FilterChainMatch filterChainMatch2 =\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.1.2.0\", 30)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.1.2.0\"), 30)),\n             ImmutableList.of(),\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.4.0.0\", 16)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.4.0.0\"), 16)),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n             ImmutableList.of(),\n             ImmutableList.of(),\n@@ -997,8 +1019,10 @@ public void filterChain_5stepMatch() throws Exception {\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n             ImmutableList.of(\n-                EnvoyServerProtoData.CidrRange.create(\"192.168.2.0\", 24),\n-                EnvoyServerProtoData.CidrRange.create(\"10.1.2.0\", 30)),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"192.168.2.0\"), 24),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"10.1.2.0\"), 30)),\n             ImmutableList.of(),\n             ImmutableList.of(),\n             EnvoyServerProtoData.ConnectionSourceType.SAME_IP_OR_LOOPBACK,\n@@ -1015,10 +1039,13 @@ public void filterChain_5stepMatch() throws Exception {\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n             ImmutableList.of(\n-                EnvoyServerProtoData.CidrRange.create(\"10.1.0.0\", 16),\n-                EnvoyServerProtoData.CidrRange.create(\"10.1.2.0\", 30)),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"10.1.0.0\"), 16),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"10.1.2.0\"), 30)),\n             ImmutableList.of(),\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.4.2.0\", 24)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.4.2.0\"), 24)),\n             EnvoyServerProtoData.ConnectionSourceType.EXTERNAL,\n             ImmutableList.of(16000, 9000),\n             ImmutableList.of(),\n@@ -1034,12 +1061,16 @@ public void filterChain_5stepMatch() throws Exception {\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n             ImmutableList.of(\n-                EnvoyServerProtoData.CidrRange.create(\"10.1.0.0\", 16),\n-                EnvoyServerProtoData.CidrRange.create(\"10.1.2.0\", 30)),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"10.1.0.0\"), 16),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"10.1.2.0\"), 30)),\n             ImmutableList.of(),\n             ImmutableList.of(\n-                EnvoyServerProtoData.CidrRange.create(\"10.4.2.0\", 24),\n-                EnvoyServerProtoData.CidrRange.create(\"192.168.2.0\", 24)),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"10.4.2.0\"), 24),\n+                EnvoyServerProtoData.CidrRange.create(\n+                    InetAddresses.forString(\"192.168.2.0\"), 24)),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n             ImmutableList.of(15000, 8000),\n             ImmutableList.of(),\n@@ -1053,7 +1084,8 @@ public void filterChain_5stepMatch() throws Exception {\n     EnvoyServerProtoData.FilterChainMatch filterChainMatch6 =\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0,\n-            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\"10.1.2.0\", 29)),\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.1.2.0\"), 29)),\n             ImmutableList.of(),\n             ImmutableList.of(),\n             EnvoyServerProtoData.ConnectionSourceType.ANY,\n@@ -1105,8 +1137,8 @@ public void filterChainMatch_unsupportedMatchers() throws Exception {\n     EnvoyServerProtoData.FilterChainMatch filterChainMatch1 =\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0 /* destinationPort */,\n-            ImmutableList.of(\n-                    EnvoyServerProtoData.CidrRange.create(\"10.1.0.0\", 16)) /* prefixRange */,\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.1.0.0\"), 16)) /* prefixRange */,\n             ImmutableList.of(\"managed-mtls\", \"h2\") /* applicationProtocol */,\n             ImmutableList.of() /* sourcePrefixRanges */,\n             EnvoyServerProtoData.ConnectionSourceType.ANY /* sourceType */,\n@@ -1117,8 +1149,8 @@ public void filterChainMatch_unsupportedMatchers() throws Exception {\n     EnvoyServerProtoData.FilterChainMatch filterChainMatch2 =\n         EnvoyServerProtoData.FilterChainMatch.create(\n             0 /* destinationPort */,\n-            ImmutableList.of(\n-                    EnvoyServerProtoData.CidrRange.create(\"10.0.0.0\", 8)) /* prefixRange */,\n+            ImmutableList.of(EnvoyServerProtoData.CidrRange.create(\n+                InetAddresses.forString(\"10.0.0.0\"), 8)) /* prefixRange */,\n             ImmutableList.of() /* applicationProtocol */,\n             ImmutableList.of() /* sourcePrefixRanges */,\n             EnvoyServerProtoData.ConnectionSourceType.ANY /* sourceType */,\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11880",
    "pr_id": 11880,
    "issue_id": 6092,
    "repo": "grpc/grpc-java",
    "problem_statement": "Unary call can hang forever if uncaught exeception thrown in client interceptor\n### What version of gRPC are you using?\r\nv1.2.0, but reproduced with v1.23.0\r\n\r\n### What did you expect to see?\r\nIf a buggy interceptor throws in onClose, gRPC logs the error, but doesn't cancel the call. This can lead to a client hanging forever. Interceptor implementations should take care not to throw, but we think gRPC could also guard against this. A deadline doesn't help, because the deadline future is cleaned up before calling the client observer's onClose method.\r\n\r\nReproduction: https://github.com/lihalite/grpc-error-reproduction\r\n\r\nFor instance, ClientCallImpl#closeObserver could catch runtime exceptions and cancel the call.\r\n",
    "issue_word_count": 116,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "core/src/main/java/io/grpc/internal/ClientCallImpl.java",
      "core/src/test/java/io/grpc/internal/ClientCallImplTest.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/ClientCallImplTest.java"
    ],
    "base_commit": "b1bc0a9d240c2cc6ccf9cf02543c9d9118132c14",
    "head_commit": "f26a5ae9d32263d4f954c048e5a1f86135a5cea4",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11880",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11880",
    "dockerfile": "",
    "pr_merged_at": "2025-02-11T06:08:07.000Z",
    "patch": "diff --git a/core/src/main/java/io/grpc/internal/ClientCallImpl.java b/core/src/main/java/io/grpc/internal/ClientCallImpl.java\nindex 07f2701d1c1..b9e8dd79f09 100644\n--- a/core/src/main/java/io/grpc/internal/ClientCallImpl.java\n+++ b/core/src/main/java/io/grpc/internal/ClientCallImpl.java\n@@ -561,7 +561,11 @@ public Attributes getAttributes() {\n   }\n \n   private void closeObserver(Listener<RespT> observer, Status status, Metadata trailers) {\n-    observer.onClose(status, trailers);\n+    try {\n+      observer.onClose(status, trailers);\n+    } catch (RuntimeException ex) {\n+      log.log(Level.WARNING, \"Exception thrown by onClose() in ClientCall\", ex);\n+    }\n   }\n \n   @Override\n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/ClientCallImplTest.java b/core/src/test/java/io/grpc/internal/ClientCallImplTest.java\nindex 66d626ec2b6..03e613e13d9 100644\n--- a/core/src/test/java/io/grpc/internal/ClientCallImplTest.java\n+++ b/core/src/test/java/io/grpc/internal/ClientCallImplTest.java\n@@ -1105,6 +1105,32 @@ public void getAttributes() {\n     assertEquals(attrs, call.getAttributes());\n   }\n \n+  @Test\n+  public void onCloseExceptionCaughtAndLogged() {\n+    DelayedExecutor executor = new DelayedExecutor();\n+    ClientCallImpl<Void, Void> call = new ClientCallImpl<>(\n+        method,\n+        executor,\n+        baseCallOptions,\n+        clientStreamProvider,\n+        deadlineCancellationExecutor,\n+        channelCallTracer, configSelector);\n+\n+    call.start(callListener, new Metadata());\n+    verify(stream).start(listenerArgumentCaptor.capture());\n+    final ClientStreamListener streamListener = listenerArgumentCaptor.getValue();\n+    streamListener.headersRead(new Metadata());\n+\n+    doThrow(new RuntimeException(\"Exception thrown by onClose() in ClientCall\")).when(callListener)\n+        .onClose(any(Status.class), any(Metadata.class));\n+\n+    Status status = Status.RESOURCE_EXHAUSTED.withDescription(\"simulated\");\n+    streamListener.closed(status, PROCESSED, new Metadata());\n+    executor.release();\n+\n+    verify(callListener).onClose(same(status), any(Metadata.class));\n+  }\n+\n   private static final class DelayedExecutor implements Executor {\n     private final BlockingQueue<Runnable> commands = new LinkedBlockingQueue<>();\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11866",
    "pr_id": 11866,
    "issue_id": 11042,
    "repo": "grpc/grpc-java",
    "problem_statement": "Allow getting AltsContext from transport attributes on client-side\n<!-- Please answer these questions before submitting a feature request. -->\r\n\r\n### Is your feature request related to a problem?\r\nWe want an easy/more consistent way  to verify if a request has taken DirectPath or not.\r\n\r\n### Existing Solution\r\nWe are able to use [ClientCall.getAttributes()](https://grpc.github.io/grpc-java/javadoc/io/grpc/ClientCall.html#getAttributes%28%29) method which is an experimental method to get the socket address like below\r\n`clientCall.getAttributes().get(Grpc.TRANSPORT_ATTR_REMOTE_ADDR)`\r\n\r\nSo a client can say that it's connecting to a directpath endpoint if the IP address is within the subnet of [34.126.0.0/18](http://34.126.0.0/18) or \r\n[2001:4860:8040::/42](https://ipdb.corp.google.com/ipdb/drill-down/?id=INTERNET.2001%3A4860%3A8040%3A%3A%2F42)\r\n\r\nBut the above way is difficult to maintains , comes with the burden of modifying this code if IP range changes.\r\n\r\n### Describe the solution you'd like\r\nWe would like to have a separate method to indicate if directPath is used, or a separate attribute indicating that. \r\n`clientCall.getAttributes().get(Grpc.**DIRECTPATH_USED**)`\r\n\r\n",
    "issue_word_count": 189,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "alts/src/main/java/io/grpc/alts/AltsContextUtil.java",
      "alts/src/test/java/io/grpc/alts/AltsContextUtilTest.java"
    ],
    "pr_changed_test_files": [
      "alts/src/test/java/io/grpc/alts/AltsContextUtilTest.java"
    ],
    "base_commit": "90aefb26e71fcc8d3f45fa5580dd3131b262db27",
    "head_commit": "f3982322eb66dc9f8053d88c6837134201597fb1",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11866",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11866",
    "dockerfile": "",
    "pr_merged_at": "2025-01-31T00:10:19.000Z",
    "patch": "diff --git a/alts/src/main/java/io/grpc/alts/AltsContextUtil.java b/alts/src/main/java/io/grpc/alts/AltsContextUtil.java\nindex 5f2ce353761..f45179bbd91 100644\n--- a/alts/src/main/java/io/grpc/alts/AltsContextUtil.java\n+++ b/alts/src/main/java/io/grpc/alts/AltsContextUtil.java\n@@ -17,6 +17,7 @@\n package io.grpc.alts;\n \n import io.grpc.Attributes;\n+import io.grpc.ClientCall;\n import io.grpc.ExperimentalApi;\n import io.grpc.ServerCall;\n import io.grpc.alts.internal.AltsInternalContext;\n@@ -29,14 +30,36 @@ public final class AltsContextUtil {\n   private AltsContextUtil() {}\n \n   /**\n-   * Creates a {@link AltsContext} from ALTS context information in the {@link ServerCall}.\n+   * Creates an {@link AltsContext} from ALTS context information in the {@link ServerCall}.\n    *\n    * @param call the {@link ServerCall} containing the ALTS information\n    * @return the created {@link AltsContext}\n    * @throws IllegalArgumentException if the {@link ServerCall} has no ALTS information.\n    */\n   public static AltsContext createFrom(ServerCall<?, ?> call) {\n-    Object authContext = call.getAttributes().get(AltsProtocolNegotiator.AUTH_CONTEXT_KEY);\n+    return createFrom(call.getAttributes());\n+  }\n+\n+  /**\n+   * Creates an {@link AltsContext} from ALTS context information in the {@link ClientCall}.\n+   *\n+   * @param call the {@link ClientCall} containing the ALTS information\n+   * @return the created {@link AltsContext}\n+   * @throws IllegalArgumentException if the {@link ClientCall} has no ALTS information.\n+   */\n+  public static AltsContext createFrom(ClientCall<?, ?> call) {\n+    return createFrom(call.getAttributes());\n+  }\n+\n+  /**\n+   * Creates an {@link AltsContext} from ALTS context information in the {@link Attributes}.\n+   *\n+   * @param attributes the {@link Attributes} containing the ALTS information\n+   * @return the created {@link AltsContext}\n+   * @throws IllegalArgumentException if the {@link Attributes} has no ALTS information.\n+   */\n+  public static AltsContext createFrom(Attributes attributes) {\n+    Object authContext = attributes.get(AltsProtocolNegotiator.AUTH_CONTEXT_KEY);\n     if (!(authContext instanceof AltsInternalContext)) {\n       throw new IllegalArgumentException(\"No ALTS context information found\");\n     }\n@@ -53,6 +76,16 @@ public static boolean check(ServerCall<?, ?> call) {\n     return check(call.getAttributes());\n   }\n \n+  /**\n+   * Checks if the {@link ClientCall} contains ALTS information.\n+   *\n+   * @param call the {@link ClientCall} to check\n+   * @return true, if the {@link ClientCall} contains ALTS information and false otherwise.\n+   */\n+  public static boolean check(ClientCall<?, ?> call) {\n+    return check(call.getAttributes());\n+  }\n+\n   /**\n    * Checks if the {@link Attributes} contains ALTS information.\n    *\n",
    "test_patch": "diff --git a/alts/src/test/java/io/grpc/alts/AltsContextUtilTest.java b/alts/src/test/java/io/grpc/alts/AltsContextUtilTest.java\nindex 6fd2d840d45..675fa29fc99 100644\n--- a/alts/src/test/java/io/grpc/alts/AltsContextUtilTest.java\n+++ b/alts/src/test/java/io/grpc/alts/AltsContextUtilTest.java\n@@ -24,6 +24,7 @@\n import static org.mockito.Mockito.when;\n \n import io.grpc.Attributes;\n+import io.grpc.ClientCall;\n import io.grpc.ServerCall;\n import io.grpc.alts.AltsContext.SecurityLevel;\n import io.grpc.alts.internal.AltsInternalContext;\n@@ -37,27 +38,38 @@\n /** Unit tests for {@link AltsContextUtil}. */\n @RunWith(JUnit4.class)\n public class AltsContextUtilTest {\n-\n-  private final ServerCall<?,?> call = mock(ServerCall.class);\n-\n   @Test\n   public void check_noAttributeValue() {\n-    when(call.getAttributes()).thenReturn(Attributes.newBuilder().build());\n+    assertFalse(AltsContextUtil.check(Attributes.newBuilder().build()));\n+  }\n \n-    assertFalse(AltsContextUtil.check(call));\n+  @Test\n+  public void check_unexpectedAttributeValueType() {\n+    assertFalse(AltsContextUtil.check(Attributes.newBuilder()\n+        .set(AltsProtocolNegotiator.AUTH_CONTEXT_KEY, new Object())\n+        .build()));\n   }\n \n   @Test\n-  public void contains_unexpectedAttributeValueType() {\n+  public void check_altsInternalContext() {\n+    assertTrue(AltsContextUtil.check(Attributes.newBuilder()\n+        .set(AltsProtocolNegotiator.AUTH_CONTEXT_KEY, AltsInternalContext.getDefaultInstance())\n+        .build()));\n+  }\n+\n+  @Test\n+  public void checkServer_altsInternalContext() {\n+    ServerCall<?,?> call = mock(ServerCall.class);\n     when(call.getAttributes()).thenReturn(Attributes.newBuilder()\n-        .set(AltsProtocolNegotiator.AUTH_CONTEXT_KEY, new Object())\n+        .set(AltsProtocolNegotiator.AUTH_CONTEXT_KEY, AltsInternalContext.getDefaultInstance())\n         .build());\n \n-    assertFalse(AltsContextUtil.check(call));\n+    assertTrue(AltsContextUtil.check(call));\n   }\n \n   @Test\n-  public void contains_altsInternalContext() {\n+  public void checkClient_altsInternalContext() {\n+    ClientCall<?,?> call = mock(ClientCall.class);\n     when(call.getAttributes()).thenReturn(Attributes.newBuilder()\n         .set(AltsProtocolNegotiator.AUTH_CONTEXT_KEY, AltsInternalContext.getDefaultInstance())\n         .build());\n@@ -66,26 +78,57 @@ public void contains_altsInternalContext() {\n   }\n \n   @Test\n-  public void from_altsInternalContext() {\n+  public void createFrom_altsInternalContext() {\n     HandshakerResult handshakerResult =\n         HandshakerResult.newBuilder()\n             .setPeerIdentity(Identity.newBuilder().setServiceAccount(\"remote@peer\"))\n             .setLocalIdentity(Identity.newBuilder().setServiceAccount(\"local@peer\"))\n             .build();\n-    when(call.getAttributes()).thenReturn(Attributes.newBuilder()\n-        .set(AltsProtocolNegotiator.AUTH_CONTEXT_KEY,  new AltsInternalContext(handshakerResult))\n-        .build());\n \n-    AltsContext context = AltsContextUtil.createFrom(call);\n+    AltsContext context = AltsContextUtil.createFrom(Attributes.newBuilder()\n+        .set(AltsProtocolNegotiator.AUTH_CONTEXT_KEY, new AltsInternalContext(handshakerResult))\n+        .build());\n     assertEquals(\"remote@peer\", context.getPeerServiceAccount());\n     assertEquals(\"local@peer\", context.getLocalServiceAccount());\n     assertEquals(SecurityLevel.INTEGRITY_AND_PRIVACY, context.getSecurityLevel());\n   }\n \n   @Test(expected = IllegalArgumentException.class)\n-  public void from_noAttributeValue() {\n-    when(call.getAttributes()).thenReturn(Attributes.newBuilder().build());\n+  public void createFrom_noAttributeValue() {\n+    AltsContextUtil.createFrom(Attributes.newBuilder().build());\n+  }\n \n-    AltsContextUtil.createFrom(call);\n+  @Test\n+  public void createFromServer_altsInternalContext() {\n+    HandshakerResult handshakerResult =\n+        HandshakerResult.newBuilder()\n+            .setPeerIdentity(Identity.newBuilder().setServiceAccount(\"remote@peer\"))\n+            .setLocalIdentity(Identity.newBuilder().setServiceAccount(\"local@peer\"))\n+            .build();\n+\n+    ServerCall<?,?> call = mock(ServerCall.class);\n+    when(call.getAttributes()).thenReturn(Attributes.newBuilder()\n+        .set(AltsProtocolNegotiator.AUTH_CONTEXT_KEY, new AltsInternalContext(handshakerResult))\n+        .build());\n+\n+    AltsContext context = AltsContextUtil.createFrom(call);\n+    assertEquals(\"remote@peer\", context.getPeerServiceAccount());\n+  }\n+\n+  @Test\n+  public void createFromClient_altsInternalContext() {\n+    HandshakerResult handshakerResult =\n+        HandshakerResult.newBuilder()\n+            .setPeerIdentity(Identity.newBuilder().setServiceAccount(\"remote@peer\"))\n+            .setLocalIdentity(Identity.newBuilder().setServiceAccount(\"local@peer\"))\n+            .build();\n+\n+    ClientCall<?,?> call = mock(ClientCall.class);\n+    when(call.getAttributes()).thenReturn(Attributes.newBuilder()\n+        .set(AltsProtocolNegotiator.AUTH_CONTEXT_KEY, new AltsInternalContext(handshakerResult))\n+        .build());\n+\n+    AltsContext context = AltsContextUtil.createFrom(call);\n+    assertEquals(\"remote@peer\", context.getPeerServiceAccount());\n   }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11858",
    "pr_id": 11858,
    "issue_id": 11700,
    "repo": "grpc/grpc-java",
    "problem_statement": "core: Update retry behavior for redefinition in A6\nA6 had its retry behavior [redefined](https://github.com/grpc/proposal/pull/452). The Java implementation [uses the old definition](https://github.com/grpc/grpc-java/blob/6a92a2a22e0ee192c0c5450c000f0cca2975882e/core/src/main/java/io/grpc/internal/RetriableStream.java#L1069). We need to update to the newer, more typical backoff.",
    "issue_word_count": 56,
    "test_files_count": 4,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "core/src/main/java/io/grpc/internal/RetriableStream.java",
      "core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java",
      "core/src/test/java/io/grpc/internal/RetriableStreamTest.java",
      "interop-testing/src/test/java/io/grpc/testing/integration/RetryTest.java",
      "netty/src/main/java/io/grpc/netty/NettyWritableBufferAllocator.java",
      "netty/src/test/java/io/grpc/netty/NettyWritableBufferAllocatorTest.java",
      "xds/src/main/java/io/grpc/xds/FaultFilter.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java",
      "core/src/test/java/io/grpc/internal/RetriableStreamTest.java",
      "interop-testing/src/test/java/io/grpc/testing/integration/RetryTest.java",
      "netty/src/test/java/io/grpc/netty/NettyWritableBufferAllocatorTest.java"
    ],
    "base_commit": "9e8629914fd12e08604ad8a6ae78853118acabe2",
    "head_commit": "dad68ffd5543f770a6aec822b006f3cd17a9d917",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11858",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11858",
    "dockerfile": "",
    "pr_merged_at": "2025-02-05T22:18:21.000Z",
    "patch": "diff --git a/core/src/main/java/io/grpc/internal/RetriableStream.java b/core/src/main/java/io/grpc/internal/RetriableStream.java\nindex 85d7bc86584..7765408a627 100644\n--- a/core/src/main/java/io/grpc/internal/RetriableStream.java\n+++ b/core/src/main/java/io/grpc/internal/RetriableStream.java\n@@ -846,6 +846,15 @@ public void run() {\n     }\n   }\n \n+  private static final boolean isExperimentalRetryJitterEnabled = GrpcUtil\n+          .getFlag(\"GRPC_EXPERIMENTAL_XDS_RLS_LB\", true);\n+\n+  public static long intervalWithJitter(long intervalNanos) {\n+    double inverseJitterFactor = isExperimentalRetryJitterEnabled\n+            ? 0.8 * random.nextDouble() + 0.4 : random.nextDouble();\n+    return (long) (intervalNanos * inverseJitterFactor);\n+  }\n+\n   private static final class SavedCloseMasterListenerReason {\n     private final Status status;\n     private final RpcProgress progress;\n@@ -1066,7 +1075,7 @@ private RetryPlan makeRetryDecision(Status status, Metadata trailer) {\n         if (pushbackMillis == null) {\n           if (isRetryableStatusCode) {\n             shouldRetry = true;\n-            backoffNanos = (long) (nextBackoffIntervalNanos * random.nextDouble());\n+            backoffNanos = intervalWithJitter(nextBackoffIntervalNanos);\n             nextBackoffIntervalNanos = Math.min(\n                 (long) (nextBackoffIntervalNanos * retryPolicy.backoffMultiplier),\n                 retryPolicy.maxBackoffNanos);\n\ndiff --git a/netty/src/main/java/io/grpc/netty/NettyWritableBufferAllocator.java b/netty/src/main/java/io/grpc/netty/NettyWritableBufferAllocator.java\nindex 9e93ee1155c..40b84717160 100644\n--- a/netty/src/main/java/io/grpc/netty/NettyWritableBufferAllocator.java\n+++ b/netty/src/main/java/io/grpc/netty/NettyWritableBufferAllocator.java\n@@ -33,9 +33,6 @@\n  */\n class NettyWritableBufferAllocator implements WritableBufferAllocator {\n \n-  // Use 4k as our minimum buffer size.\n-  private static final int MIN_BUFFER = 4 * 1024;\n-\n   // Set the maximum buffer size to 1MB.\n   private static final int MAX_BUFFER = 1024 * 1024;\n \n@@ -47,7 +44,7 @@ class NettyWritableBufferAllocator implements WritableBufferAllocator {\n \n   @Override\n   public WritableBuffer allocate(int capacityHint) {\n-    capacityHint = Math.min(MAX_BUFFER, Math.max(MIN_BUFFER, capacityHint));\n+    capacityHint = Math.min(MAX_BUFFER, capacityHint);\n     return new NettyWritableBuffer(allocator.buffer(capacityHint, capacityHint));\n   }\n }\n\ndiff --git a/xds/src/main/java/io/grpc/xds/FaultFilter.java b/xds/src/main/java/io/grpc/xds/FaultFilter.java\nindex d46b3d30f5a..b7f7fa9c226 100644\n--- a/xds/src/main/java/io/grpc/xds/FaultFilter.java\n+++ b/xds/src/main/java/io/grpc/xds/FaultFilter.java\n@@ -190,94 +190,102 @@ public ClientInterceptor buildClientInterceptor(\n       config = overrideConfig;\n     }\n     FaultConfig faultConfig = (FaultConfig) config;\n-    Long delayNanos = null;\n-    Status abortStatus = null;\n-    if (faultConfig.maxActiveFaults() == null\n-        || activeFaultCounter.get() < faultConfig.maxActiveFaults()) {\n-      Metadata headers = args.getHeaders();\n-      if (faultConfig.faultDelay() != null) {\n-        delayNanos = determineFaultDelayNanos(faultConfig.faultDelay(), headers);\n-      }\n-      if (faultConfig.faultAbort() != null) {\n-        abortStatus = determineFaultAbortStatus(faultConfig.faultAbort(), headers);\n-      }\n-    }\n-    if (delayNanos == null && abortStatus == null) {\n-      return null;\n-    }\n-    final Long finalDelayNanos = delayNanos;\n-    final Status finalAbortStatus = getAbortStatusWithDescription(abortStatus);\n \n     final class FaultInjectionInterceptor implements ClientInterceptor {\n       @Override\n       public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(\n           final MethodDescriptor<ReqT, RespT> method, final CallOptions callOptions,\n           final Channel next) {\n-        Executor callExecutor = callOptions.getExecutor();\n-        if (callExecutor == null) { // This should never happen in practice because\n-          // ManagedChannelImpl.ConfigSelectingClientCall always provides CallOptions with\n-          // a callExecutor.\n-          // TODO(https://github.com/grpc/grpc-java/issues/7868)\n-          callExecutor = MoreExecutors.directExecutor();\n+        boolean checkFault = false;\n+        if (faultConfig.maxActiveFaults() == null\n+            || activeFaultCounter.get() < faultConfig.maxActiveFaults()) {\n+          checkFault = faultConfig.faultDelay() != null || faultConfig.faultAbort() != null;\n         }\n-        if (finalDelayNanos != null) {\n-          Supplier<? extends ClientCall<ReqT, RespT>> callSupplier;\n-          if (finalAbortStatus != null) {\n-            callSupplier = Suppliers.ofInstance(\n-                new FailingClientCall<ReqT, RespT>(finalAbortStatus, callExecutor));\n-          } else {\n-            callSupplier = new Supplier<ClientCall<ReqT, RespT>>() {\n-              @Override\n-              public ClientCall<ReqT, RespT> get() {\n-                return next.newCall(method, callOptions);\n-              }\n-            };\n+        if (!checkFault) {\n+          return next.newCall(method, callOptions);\n+        }\n+        final class DeadlineInsightForwardingCall extends ForwardingClientCall<ReqT, RespT> {\n+          private ClientCall<ReqT, RespT> delegate;\n+\n+          @Override\n+          protected ClientCall<ReqT, RespT> delegate() {\n+            return delegate;\n           }\n-          final DelayInjectedCall<ReqT, RespT> delayInjectedCall = new DelayInjectedCall<>(\n-              finalDelayNanos, callExecutor, scheduler, callOptions.getDeadline(), callSupplier);\n \n-          final class DeadlineInsightForwardingCall extends ForwardingClientCall<ReqT, RespT> {\n-            @Override\n-            protected ClientCall<ReqT, RespT> delegate() {\n-              return delayInjectedCall;\n+          @Override\n+          public void start(Listener<RespT> listener, Metadata headers) {\n+            Executor callExecutor = callOptions.getExecutor();\n+            if (callExecutor == null) { // This should never happen in practice because\n+              // ManagedChannelImpl.ConfigSelectingClientCall always provides CallOptions with\n+              // a callExecutor.\n+              // TODO(https://github.com/grpc/grpc-java/issues/7868)\n+              callExecutor = MoreExecutors.directExecutor();\n             }\n \n-            @Override\n-            public void start(Listener<RespT> listener, Metadata headers) {\n-              Listener<RespT> finalListener =\n-                  new SimpleForwardingClientCallListener<RespT>(listener) {\n-                    @Override\n-                    public void onClose(Status status, Metadata trailers) {\n-                      if (status.getCode().equals(Code.DEADLINE_EXCEEDED)) {\n-                        // TODO(zdapeng:) check effective deadline locally, and\n-                        //   do the following only if the local deadline is exceeded.\n-                        //   (If the server sends DEADLINE_EXCEEDED for its own deadline, then the\n-                        //   injected delay does not contribute to the error, because the request is\n-                        //   only sent out after the delay. There could be a race between local and\n-                        //   remote, but it is rather rare.)\n-                        String description = String.format(\n-                            Locale.US,\n-                            \"Deadline exceeded after up to %d ns of fault-injected delay\",\n-                            finalDelayNanos);\n-                        if (status.getDescription() != null) {\n-                          description = description + \": \" + status.getDescription();\n-                        }\n-                        status = Status.DEADLINE_EXCEEDED\n-                            .withDescription(description).withCause(status.getCause());\n-                        // Replace trailers to prevent mixing sources of status and trailers.\n-                        trailers = new Metadata();\n+            Long delayNanos;\n+            Status abortStatus = null;\n+            if (faultConfig.faultDelay() != null) {\n+              delayNanos = determineFaultDelayNanos(faultConfig.faultDelay(), headers);\n+            } else {\n+              delayNanos = null;\n+            }\n+            if (faultConfig.faultAbort() != null) {\n+              abortStatus = getAbortStatusWithDescription(\n+                  determineFaultAbortStatus(faultConfig.faultAbort(), headers));\n+            }\n+\n+            Supplier<? extends ClientCall<ReqT, RespT>> callSupplier;\n+            if (abortStatus != null) {\n+              callSupplier = Suppliers.ofInstance(\n+                  new FailingClientCall<ReqT, RespT>(abortStatus, callExecutor));\n+            } else {\n+              callSupplier = new Supplier<ClientCall<ReqT, RespT>>() {\n+                @Override\n+                public ClientCall<ReqT, RespT> get() {\n+                  return next.newCall(method, callOptions);\n+                }\n+              };\n+            }\n+            if (delayNanos == null) {\n+              delegate = callSupplier.get();\n+              delegate().start(listener, headers);\n+              return;\n+            }\n+\n+            delegate = new DelayInjectedCall<>(\n+                delayNanos, callExecutor, scheduler, callOptions.getDeadline(), callSupplier);\n+\n+            Listener<RespT> finalListener =\n+                new SimpleForwardingClientCallListener<RespT>(listener) {\n+                  @Override\n+                  public void onClose(Status status, Metadata trailers) {\n+                    if (status.getCode().equals(Code.DEADLINE_EXCEEDED)) {\n+                      // TODO(zdapeng:) check effective deadline locally, and\n+                      //   do the following only if the local deadline is exceeded.\n+                      //   (If the server sends DEADLINE_EXCEEDED for its own deadline, then the\n+                      //   injected delay does not contribute to the error, because the request is\n+                      //   only sent out after the delay. There could be a race between local and\n+                      //   remote, but it is rather rare.)\n+                      String description = String.format(\n+                          Locale.US,\n+                          \"Deadline exceeded after up to %d ns of fault-injected delay\",\n+                          delayNanos);\n+                      if (status.getDescription() != null) {\n+                        description = description + \": \" + status.getDescription();\n                       }\n-                      delegate().onClose(status, trailers);\n+                      status = Status.DEADLINE_EXCEEDED\n+                          .withDescription(description).withCause(status.getCause());\n+                      // Replace trailers to prevent mixing sources of status and trailers.\n+                      trailers = new Metadata();\n                     }\n-                  };\n-              delegate().start(finalListener, headers);\n-            }\n+                    delegate().onClose(status, trailers);\n+                  }\n+                };\n+            delegate().start(finalListener, headers);\n           }\n-\n-          return new DeadlineInsightForwardingCall();\n-        } else {\n-          return new FailingClientCall<>(finalAbortStatus, callExecutor);\n         }\n+\n+        return new DeadlineInsightForwardingCall();\n       }\n     }\n \n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java b/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\nindex 98900cecf2b..21ccf1095df 100644\n--- a/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\n+++ b/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\n@@ -3875,7 +3875,7 @@ public double nextDouble() {\n         Status.UNAVAILABLE, PROCESSED, new Metadata());\n \n     // in backoff\n-    timer.forwardTime(5, TimeUnit.SECONDS);\n+    timer.forwardTime(6, TimeUnit.SECONDS);\n     assertThat(timer.getPendingTasks()).hasSize(1);\n     verify(mockStream2, never()).start(any(ClientStreamListener.class));\n \n@@ -3894,7 +3894,7 @@ public double nextDouble() {\n     assertEquals(\"Channel shutdown invoked\", statusCaptor.getValue().getDescription());\n \n     // backoff ends\n-    timer.forwardTime(5, TimeUnit.SECONDS);\n+    timer.forwardTime(6, TimeUnit.SECONDS);\n     assertThat(timer.getPendingTasks()).isEmpty();\n     verify(mockStream2).start(streamListenerCaptor.capture());\n     verify(mockLoadBalancer, never()).shutdown();\n\ndiff --git a/core/src/test/java/io/grpc/internal/RetriableStreamTest.java b/core/src/test/java/io/grpc/internal/RetriableStreamTest.java\nindex 658ed70a135..9b1ec343bb7 100644\n--- a/core/src/test/java/io/grpc/internal/RetriableStreamTest.java\n+++ b/core/src/test/java/io/grpc/internal/RetriableStreamTest.java\n@@ -147,6 +147,17 @@ public double nextDouble() {\n   private final ChannelBufferMeter channelBufferUsed = new ChannelBufferMeter();\n   private final FakeClock fakeClock = new FakeClock();\n \n+  private static long calculateBackoffWithRetries(int retryCount) {\n+    // Calculate the exponential backoff delay with jitter\n+    double exponent = retryCount > 0 ? Math.pow(BACKOFF_MULTIPLIER, retryCount) : 1;\n+    long delay = (long) (INITIAL_BACKOFF_IN_SECONDS * exponent);\n+    return RetriableStream.intervalWithJitter(delay);\n+  }\n+\n+  private static long calculateMaxBackoff() {\n+    return RetriableStream.intervalWithJitter(MAX_BACKOFF_IN_SECONDS);\n+  }\n+\n   private final class RecordedRetriableStream extends RetriableStream<String> {\n     RecordedRetriableStream(MethodDescriptor<String, ?> method, Metadata headers,\n         ChannelBufferMeter channelBufferUsed, long perRpcBufferLimit, long channelBufferLimit,\n@@ -307,7 +318,7 @@ public Void answer(InvocationOnMock in) {\n     retriableStream.sendMessage(\"msg1 during backoff1\");\n     retriableStream.sendMessage(\"msg2 during backoff1\");\n \n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM) - 1L, TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0) - 1L, TimeUnit.SECONDS);\n     inOrder.verifyNoMoreInteractions();\n     assertEquals(1, fakeClock.numPendingTasks());\n     fakeClock.forwardTime(1L, TimeUnit.SECONDS);\n@@ -364,9 +375,7 @@ public Void answer(InvocationOnMock in) {\n     retriableStream.sendMessage(\"msg2 during backoff2\");\n     retriableStream.sendMessage(\"msg3 during backoff2\");\n \n-    fakeClock.forwardTime(\n-        (long) (INITIAL_BACKOFF_IN_SECONDS * BACKOFF_MULTIPLIER * FAKE_RANDOM) - 1L,\n-        TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(1) - 1L, TimeUnit.SECONDS);\n     inOrder.verifyNoMoreInteractions();\n     assertEquals(1, fakeClock.numPendingTasks());\n     fakeClock.forwardTime(1L, TimeUnit.SECONDS);\n@@ -459,7 +468,7 @@ public void retry_headersRead_cancel() {\n     sublistenerCaptor1.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n \n     ArgumentCaptor<ClientStreamListener> sublistenerCaptor2 =\n         ArgumentCaptor.forClass(ClientStreamListener.class);\n@@ -518,7 +527,7 @@ public void retry_headersRead_closed() {\n     doReturn(mockStream2).when(retriableStreamRecorder).newSubstream(1);\n     sublistenerCaptor1.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n \n     ArgumentCaptor<ClientStreamListener> sublistenerCaptor2 =\n         ArgumentCaptor.forClass(ClientStreamListener.class);\n@@ -584,7 +593,7 @@ public void retry_cancel_closed() {\n     doReturn(mockStream2).when(retriableStreamRecorder).newSubstream(1);\n     sublistenerCaptor1.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n \n     ArgumentCaptor<ClientStreamListener> sublistenerCaptor2 =\n         ArgumentCaptor.forClass(ClientStreamListener.class);\n@@ -687,7 +696,7 @@ public void retry_unretriableClosed_cancel() {\n     doReturn(mockStream2).when(retriableStreamRecorder).newSubstream(1);\n     sublistenerCaptor1.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n \n     ArgumentCaptor<ClientStreamListener> sublistenerCaptor2 =\n         ArgumentCaptor.forClass(ClientStreamListener.class);\n@@ -821,7 +830,7 @@ public boolean isReady() {\n     // send more requests during backoff\n     retriableStream.request(789);\n \n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n \n     inOrder.verify(mockStream2).start(sublistenerCaptor2.get());\n     inOrder.verify(mockStream2).request(3);\n@@ -875,7 +884,7 @@ public void request(int numMessages) {\n     doReturn(mockStream2).when(retriableStreamRecorder).newSubstream(1);\n     sublistenerCaptor1.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n \n     inOrder.verify(mockStream2).start(sublistenerCaptor2.capture());\n     inOrder.verify(mockStream2).request(3);\n@@ -920,7 +929,7 @@ public void start(ClientStreamListener listener) {\n     doReturn(mockStream2).when(retriableStreamRecorder).newSubstream(1);\n     sublistenerCaptor1.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n \n     inOrder.verify(mockStream2).start(sublistenerCaptor2.capture());\n     inOrder.verify(retriableStreamRecorder).postCommit();\n@@ -1028,7 +1037,7 @@ public boolean isReady() {\n     retriableStream.request(789);\n     readiness.add(retriableStream.isReady()); // expected false b/c in backoff\n \n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n \n     verify(mockStream2).start(any(ClientStreamListener.class));\n     readiness.add(retriableStream.isReady()); // expected true\n@@ -1110,7 +1119,7 @@ public void addPrevRetryAttemptsToRespHeaders() {\n     doReturn(mockStream2).when(retriableStreamRecorder).newSubstream(1);\n     sublistenerCaptor1.getValue().closed(\n             Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n \n     ArgumentCaptor<ClientStreamListener> sublistenerCaptor2 =\n             ArgumentCaptor.forClass(ClientStreamListener.class);\n@@ -1160,13 +1169,12 @@ public void start(ClientStreamListener listener) {\n     listener1.closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n     assertEquals(1, fakeClock.numPendingTasks());\n \n     // send requests during backoff\n     retriableStream.request(3);\n-    fakeClock.forwardTime(\n-        (long) (INITIAL_BACKOFF_IN_SECONDS * BACKOFF_MULTIPLIER * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(1), TimeUnit.SECONDS);\n \n     retriableStream.request(1);\n     verify(mockStream1, never()).request(anyInt());\n@@ -1207,7 +1215,7 @@ public void start(ClientStreamListener listener) {\n     // retry\n     listener1.closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n \n     verify(mockStream2).start(any(ClientStreamListener.class));\n     verify(retriableStreamRecorder).postCommit();\n@@ -1260,7 +1268,7 @@ public void perRpcBufferLimitExceededDuringBackoff() {\n     bufferSizeTracer.outboundWireSize(2);\n     verify(retriableStreamRecorder, never()).postCommit();\n \n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n     verify(mockStream2).start(any(ClientStreamListener.class));\n     verify(mockStream2).isReady();\n \n@@ -1332,7 +1340,7 @@ public void expBackoff_maxBackoff_maxRetryAttempts() {\n     sublistenerCaptor1.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM) - 1L, TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0) - 1L, TimeUnit.SECONDS);\n     assertEquals(1, fakeClock.numPendingTasks());\n     fakeClock.forwardTime(1L, TimeUnit.SECONDS);\n     assertEquals(0, fakeClock.numPendingTasks());\n@@ -1347,9 +1355,7 @@ public void expBackoff_maxBackoff_maxRetryAttempts() {\n     sublistenerCaptor2.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_2), PROCESSED, new Metadata());\n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime(\n-        (long) (INITIAL_BACKOFF_IN_SECONDS * BACKOFF_MULTIPLIER * FAKE_RANDOM) - 1L,\n-        TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(1) - 1L, TimeUnit.SECONDS);\n     assertEquals(1, fakeClock.numPendingTasks());\n     fakeClock.forwardTime(1L, TimeUnit.SECONDS);\n     assertEquals(0, fakeClock.numPendingTasks());\n@@ -1364,10 +1370,7 @@ public void expBackoff_maxBackoff_maxRetryAttempts() {\n     sublistenerCaptor3.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime(\n-        (long) (INITIAL_BACKOFF_IN_SECONDS * BACKOFF_MULTIPLIER * BACKOFF_MULTIPLIER * FAKE_RANDOM)\n-            - 1L,\n-        TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(2) - 1L, TimeUnit.SECONDS);\n     assertEquals(1, fakeClock.numPendingTasks());\n     fakeClock.forwardTime(1L, TimeUnit.SECONDS);\n     assertEquals(0, fakeClock.numPendingTasks());\n@@ -1382,7 +1385,7 @@ public void expBackoff_maxBackoff_maxRetryAttempts() {\n     sublistenerCaptor4.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_2), PROCESSED, new Metadata());\n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime((long) (MAX_BACKOFF_IN_SECONDS * FAKE_RANDOM) - 1L, TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateMaxBackoff() - 1L, TimeUnit.SECONDS);\n     assertEquals(1, fakeClock.numPendingTasks());\n     fakeClock.forwardTime(1L, TimeUnit.SECONDS);\n     assertEquals(0, fakeClock.numPendingTasks());\n@@ -1397,7 +1400,7 @@ public void expBackoff_maxBackoff_maxRetryAttempts() {\n     sublistenerCaptor5.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_2), PROCESSED, new Metadata());\n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime((long) (MAX_BACKOFF_IN_SECONDS * FAKE_RANDOM) - 1L, TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateMaxBackoff() - 1L, TimeUnit.SECONDS);\n     assertEquals(1, fakeClock.numPendingTasks());\n     fakeClock.forwardTime(1L, TimeUnit.SECONDS);\n     assertEquals(0, fakeClock.numPendingTasks());\n@@ -1480,7 +1483,7 @@ public void pushback() {\n     sublistenerCaptor3.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM) - 1L, TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0) - 1L, TimeUnit.SECONDS);\n     assertEquals(1, fakeClock.numPendingTasks());\n     fakeClock.forwardTime(1L, TimeUnit.SECONDS);\n     assertEquals(0, fakeClock.numPendingTasks());\n@@ -1495,9 +1498,7 @@ public void pushback() {\n     sublistenerCaptor4.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_2), PROCESSED, new Metadata());\n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime(\n-        (long) (INITIAL_BACKOFF_IN_SECONDS * BACKOFF_MULTIPLIER * FAKE_RANDOM) - 1L,\n-        TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(1) - 1L, TimeUnit.SECONDS);\n     assertEquals(1, fakeClock.numPendingTasks());\n     fakeClock.forwardTime(1L, TimeUnit.SECONDS);\n     assertEquals(0, fakeClock.numPendingTasks());\n@@ -1512,10 +1513,7 @@ public void pushback() {\n     sublistenerCaptor5.getValue().closed(\n         Status.fromCode(RETRIABLE_STATUS_CODE_2), PROCESSED, new Metadata());\n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime(\n-        (long) (INITIAL_BACKOFF_IN_SECONDS * BACKOFF_MULTIPLIER * BACKOFF_MULTIPLIER * FAKE_RANDOM)\n-            - 1L,\n-        TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(2) - 1L, TimeUnit.SECONDS);\n     assertEquals(1, fakeClock.numPendingTasks());\n     fakeClock.forwardTime(1L, TimeUnit.SECONDS);\n     assertEquals(0, fakeClock.numPendingTasks());\n@@ -1804,7 +1802,7 @@ public void transparentRetry_onlyOnceOnRefused() {\n         .closed(Status.fromCode(RETRIABLE_STATUS_CODE_1), REFUSED, new Metadata());\n \n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n     inOrder.verify(retriableStreamRecorder).newSubstream(1);\n     ArgumentCaptor<ClientStreamListener> sublistenerCaptor3 =\n         ArgumentCaptor.forClass(ClientStreamListener.class);\n@@ -1907,7 +1905,7 @@ public void normalRetry_thenNoTransparentRetry_butNormalRetry() {\n         .closed(Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n \n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n     inOrder.verify(retriableStreamRecorder).newSubstream(1);\n     ArgumentCaptor<ClientStreamListener> sublistenerCaptor2 =\n         ArgumentCaptor.forClass(ClientStreamListener.class);\n@@ -1923,8 +1921,7 @@ public void normalRetry_thenNoTransparentRetry_butNormalRetry() {\n         .closed(Status.fromCode(RETRIABLE_STATUS_CODE_1), REFUSED, new Metadata());\n \n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime(\n-        (long) (INITIAL_BACKOFF_IN_SECONDS * BACKOFF_MULTIPLIER * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(1), TimeUnit.SECONDS);\n     inOrder.verify(retriableStreamRecorder).newSubstream(2);\n     ArgumentCaptor<ClientStreamListener> sublistenerCaptor3 =\n         ArgumentCaptor.forClass(ClientStreamListener.class);\n@@ -1960,7 +1957,7 @@ public void normalRetry_thenNoTransparentRetry_andNoMoreRetry() {\n         .closed(Status.fromCode(RETRIABLE_STATUS_CODE_1), PROCESSED, new Metadata());\n \n     assertEquals(1, fakeClock.numPendingTasks());\n-    fakeClock.forwardTime((long) (INITIAL_BACKOFF_IN_SECONDS * FAKE_RANDOM), TimeUnit.SECONDS);\n+    fakeClock.forwardTime(calculateBackoffWithRetries(0), TimeUnit.SECONDS);\n     inOrder.verify(retriableStreamRecorder).newSubstream(1);\n     ArgumentCaptor<ClientStreamListener> sublistenerCaptor2 =\n         ArgumentCaptor.forClass(ClientStreamListener.class);\n\ndiff --git a/interop-testing/src/test/java/io/grpc/testing/integration/RetryTest.java b/interop-testing/src/test/java/io/grpc/testing/integration/RetryTest.java\nindex edd2a57ab9d..669ce1c69db 100644\n--- a/interop-testing/src/test/java/io/grpc/testing/integration/RetryTest.java\n+++ b/interop-testing/src/test/java/io/grpc/testing/integration/RetryTest.java\n@@ -303,7 +303,7 @@ public void retryUntilBufferLimitExceeded() throws Exception {\n     serverCall.close(\n         Status.UNAVAILABLE.withDescription(\"original attempt failed\"),\n         new Metadata());\n-    elapseBackoff(10, SECONDS);\n+    elapseBackoff(12, SECONDS);\n     // 2nd attempt received\n     serverCall = serverCalls.poll(5, SECONDS);\n     serverCall.request(2);\n@@ -348,7 +348,7 @@ public void statsRecorded() throws Exception {\n         Status.UNAVAILABLE.withDescription(\"original attempt failed\"),\n         new Metadata());\n     assertRpcStatusRecorded(Status.Code.UNAVAILABLE, 1000, 1);\n-    elapseBackoff(10, SECONDS);\n+    elapseBackoff(12, SECONDS);\n     assertRpcStartedRecorded();\n     assertOutboundMessageRecorded();\n     serverCall = serverCalls.poll(5, SECONDS);\n@@ -366,7 +366,7 @@ public void statsRecorded() throws Exception {\n     call.request(1);\n     assertInboundMessageRecorded();\n     assertInboundWireSizeRecorded(1);\n-    assertRpcStatusRecorded(Status.Code.OK, 12000, 2);\n+    assertRpcStatusRecorded(Status.Code.OK, 14000, 2);\n     assertRetryStatsRecorded(1, 0, 0);\n   }\n \n@@ -418,7 +418,7 @@ public void streamClosed(Status status) {\n         Status.UNAVAILABLE.withDescription(\"original attempt failed\"),\n         new Metadata());\n     assertRpcStatusRecorded(Code.UNAVAILABLE, 5000, 1);\n-    elapseBackoff(10, SECONDS);\n+    elapseBackoff(12, SECONDS);\n     assertRpcStartedRecorded();\n     assertOutboundMessageRecorded();\n     serverCall = serverCalls.poll(5, SECONDS);\n@@ -431,7 +431,7 @@ public void streamClosed(Status status) {\n     streamClosedLatch.countDown();\n     // The call listener is closed.\n     verify(mockCallListener, timeout(5000)).onClose(any(Status.class), any(Metadata.class));\n-    assertRpcStatusRecorded(Code.CANCELLED, 17_000, 1);\n+    assertRpcStatusRecorded(Code.CANCELLED, 19_000, 1);\n     assertRetryStatsRecorded(1, 0, 0);\n   }\n \n\ndiff --git a/netty/src/test/java/io/grpc/netty/NettyWritableBufferAllocatorTest.java b/netty/src/test/java/io/grpc/netty/NettyWritableBufferAllocatorTest.java\nindex d577ec46b03..0b741ae24b3 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyWritableBufferAllocatorTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyWritableBufferAllocatorTest.java\n@@ -40,13 +40,6 @@ protected WritableBufferAllocator allocator() {\n     return allocator;\n   }\n \n-  @Test\n-  public void testCapacityHasMinimum() {\n-    WritableBuffer buffer = allocator().allocate(100);\n-    assertEquals(0, buffer.readableBytes());\n-    assertEquals(4096, buffer.writableBytes());\n-  }\n-\n   @Test\n   public void testCapacityIsExactAboveMinimum() {\n     WritableBuffer buffer = allocator().allocate(9000);\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11856",
    "pr_id": 11856,
    "issue_id": 11719,
    "repo": "grpc/grpc-java",
    "problem_statement": "netty: The optimization of applying for a minimum of 4096 off-heap memory per request has no effect in non-unaryRequest mode\n<!-- For questions not directly related to gRPC-Java, please use [stackoverflow](https://stackoverflow.com/questions/tagged/grpc-java).\r\nAlso, if question is not gRPC-Java implementation specific, consider using [grpc.io](https://groups.google.com/forum/#!forum/grpc-io).\r\n\r\nMake sure you include information that can help us understand your question. -->\r\n\r\n<!-- Your question below this line. -->\r\n**ClientCallImpl:**\r\n![image](https://github.com/user-attachments/assets/2e54a68a-a407-49d1-a362-39fe361452a0)\r\n**MessageFramer:**\r\n![image](https://github.com/user-attachments/assets/4c6e0c91-3913-46f4-9142-c62ed3deed78)\r\n![image](https://github.com/user-attachments/assets/407fa994-d8d7-4dbb-a60f-f1d689bef9af)\r\n![image](https://github.com/user-attachments/assets/5e878041-212e-4371-9d63-50f8a6e99af8)\r\n**NettyWritableBufferAllocator:**\r\n![image](https://github.com/user-attachments/assets/9c3a3ed7-dc5b-4ca8-a5ef-b8fe7a28fcc0)\r\n\r\n**In non-unaryRequest mode, 4096 bytes of off-heap memory will be re-applied for each message**\r\n**If you send small packet requests frequently (for example, 100 bytes each time), a lot of external memory will be wasted, and this 4096 optimization logic will not take effect.**",
    "issue_word_count": 188,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "netty/src/main/java/io/grpc/netty/NettyWritableBufferAllocator.java",
      "netty/src/test/java/io/grpc/netty/NettyWritableBufferAllocatorTest.java"
    ],
    "pr_changed_test_files": [
      "netty/src/test/java/io/grpc/netty/NettyWritableBufferAllocatorTest.java"
    ],
    "base_commit": "87aa6deadfb7d48847ddddcbfbdbb5ca5ee9c459",
    "head_commit": "eadf2e3bcad4d4f481300972a8c08c5273aafb58",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11856",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11856",
    "dockerfile": "",
    "pr_merged_at": "2025-01-30T07:22:37.000Z",
    "patch": "diff --git a/netty/src/main/java/io/grpc/netty/NettyWritableBufferAllocator.java b/netty/src/main/java/io/grpc/netty/NettyWritableBufferAllocator.java\nindex 9e93ee1155c..40b84717160 100644\n--- a/netty/src/main/java/io/grpc/netty/NettyWritableBufferAllocator.java\n+++ b/netty/src/main/java/io/grpc/netty/NettyWritableBufferAllocator.java\n@@ -33,9 +33,6 @@\n  */\n class NettyWritableBufferAllocator implements WritableBufferAllocator {\n \n-  // Use 4k as our minimum buffer size.\n-  private static final int MIN_BUFFER = 4 * 1024;\n-\n   // Set the maximum buffer size to 1MB.\n   private static final int MAX_BUFFER = 1024 * 1024;\n \n@@ -47,7 +44,7 @@ class NettyWritableBufferAllocator implements WritableBufferAllocator {\n \n   @Override\n   public WritableBuffer allocate(int capacityHint) {\n-    capacityHint = Math.min(MAX_BUFFER, Math.max(MIN_BUFFER, capacityHint));\n+    capacityHint = Math.min(MAX_BUFFER, capacityHint);\n     return new NettyWritableBuffer(allocator.buffer(capacityHint, capacityHint));\n   }\n }\n",
    "test_patch": "diff --git a/netty/src/test/java/io/grpc/netty/NettyWritableBufferAllocatorTest.java b/netty/src/test/java/io/grpc/netty/NettyWritableBufferAllocatorTest.java\nindex d577ec46b03..0b741ae24b3 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyWritableBufferAllocatorTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyWritableBufferAllocatorTest.java\n@@ -40,13 +40,6 @@ protected WritableBufferAllocator allocator() {\n     return allocator;\n   }\n \n-  @Test\n-  public void testCapacityHasMinimum() {\n-    WritableBuffer buffer = allocator().allocate(100);\n-    assertEquals(0, buffer.readableBytes());\n-    assertEquals(4096, buffer.writableBytes());\n-  }\n-\n   @Test\n   public void testCapacityIsExactAboveMinimum() {\n     WritableBuffer buffer = allocator().allocate(9000);\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11851",
    "pr_id": 11851,
    "issue_id": 10749,
    "repo": "grpc/grpc-java",
    "problem_statement": "stub.withWaitForReady()'s DEADLINE_EXECEEDED lacks connection failure information\n<!-- For questions not directly related to gRPC-Java, please use [stackoverflow](https://stackoverflow.com/questions/tagged/grpc-java).\r\nAlso, if question is not gRPC-Java implementation specific, consider using [grpc.io](https://groups.google.com/forum/#!forum/grpc-io).\r\n\r\nMake sure you include information that can help us understand your question. -->\r\n\r\n<!-- Your question below this line. -->\r\n\r\n```java\r\ntry {\r\n  stub.withWaitForReady().withDeadline().hello();\r\n} catch(StatusRuntimeException e) {\r\n  // always receiving DEADLINE_EXCEEDED as status code if server is unavailable or client certs are invalid\r\n}\r\n```\r\n\r\nThere is no way to distinguish the underlying cause of failure , say if the failure is due to SSLHanshake or server genuinely not being available.\r\n\r\nAs an alternative, without using withWaitForReady() we are receiving UNAVAILABLE code in StatusRuntimeException which wraps the underlying cause say for example the SSLHandshake exception. Looking at the UNAVAILABLE code how can we safely take a call if we to reattempt connection, as we do not want to reattempt the connection in SSLException scenarios? ",
    "issue_word_count": 166,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "core/src/main/java/io/grpc/internal/DelayedClientTransport.java",
      "core/src/test/java/io/grpc/internal/DelayedClientTransportTest.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/DelayedClientTransportTest.java"
    ],
    "base_commit": "90aefb26e71fcc8d3f45fa5580dd3131b262db27",
    "head_commit": "31c405a7ab89f969b83294efa7ce7444d6f1011b",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11851",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11851",
    "dockerfile": "",
    "pr_merged_at": "2025-02-14T06:08:06.000Z",
    "patch": "diff --git a/core/src/main/java/io/grpc/internal/DelayedClientTransport.java b/core/src/main/java/io/grpc/internal/DelayedClientTransport.java\nindex f3faa92d4a0..8ff755af3eb 100644\n--- a/core/src/main/java/io/grpc/internal/DelayedClientTransport.java\n+++ b/core/src/main/java/io/grpc/internal/DelayedClientTransport.java\n@@ -129,8 +129,9 @@ public final ClientStream newStream(\n         if (state.shutdownStatus != null) {\n           return new FailingClientStream(state.shutdownStatus, tracers);\n         }\n+        PickResult pickResult = null;\n         if (state.lastPicker != null) {\n-          PickResult pickResult = state.lastPicker.pickSubchannel(args);\n+          pickResult = state.lastPicker.pickSubchannel(args);\n           callOptions = args.getCallOptions();\n           // User code provided authority takes precedence over the LB provided one.\n           if (callOptions.getAuthority() == null\n@@ -156,7 +157,7 @@ public final ClientStream newStream(\n         synchronized (lock) {\n           PickerState newerState = pickerState;\n           if (state == newerState) {\n-            return createPendingStream(args, tracers);\n+            return createPendingStream(args, tracers, pickResult);\n           }\n           state = newerState;\n         }\n@@ -171,9 +172,12 @@ public final ClientStream newStream(\n    * schedule tasks on syncContext.\n    */\n   @GuardedBy(\"lock\")\n-  private PendingStream createPendingStream(\n-      PickSubchannelArgs args, ClientStreamTracer[] tracers) {\n+  private PendingStream createPendingStream(PickSubchannelArgs args, ClientStreamTracer[] tracers,\n+      PickResult pickResult) {\n     PendingStream pendingStream = new PendingStream(args, tracers);\n+    if (args.getCallOptions().isWaitForReady() && pickResult != null && pickResult.hasResult()) {\n+      pendingStream.lastPickStatus = pickResult.getStatus();\n+    }\n     pendingStreams.add(pendingStream);\n     if (getPendingStreamsCount() == 1) {\n       syncContext.executeLater(reportTransportInUse);\n@@ -293,6 +297,9 @@ final void reprocess(@Nullable SubchannelPicker picker) {\n     for (final PendingStream stream : toProcess) {\n       PickResult pickResult = picker.pickSubchannel(stream.args);\n       CallOptions callOptions = stream.args.getCallOptions();\n+      if (callOptions.isWaitForReady() && pickResult.hasResult()) {\n+        stream.lastPickStatus = pickResult.getStatus();\n+      }\n       final ClientTransport transport = GrpcUtil.getTransportFromPickResult(pickResult,\n           callOptions.isWaitForReady());\n       if (transport != null) {\n@@ -349,6 +356,7 @@ private class PendingStream extends DelayedStream {\n     private final PickSubchannelArgs args;\n     private final Context context = Context.current();\n     private final ClientStreamTracer[] tracers;\n+    private volatile Status lastPickStatus;\n \n     private PendingStream(PickSubchannelArgs args, ClientStreamTracer[] tracers) {\n       this.args = args;\n@@ -405,6 +413,10 @@ protected void onEarlyCancellation(Status reason) {\n     public void appendTimeoutInsight(InsightBuilder insight) {\n       if (args.getCallOptions().isWaitForReady()) {\n         insight.append(\"wait_for_ready\");\n+        Status status = lastPickStatus;\n+        if (status != null && !status.isOk()) {\n+          insight.appendKeyValue(\"Last Pick Failure\", status);\n+        }\n       }\n       super.appendTimeoutInsight(insight);\n     }\n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/DelayedClientTransportTest.java b/core/src/test/java/io/grpc/internal/DelayedClientTransportTest.java\nindex f65e6abcf1b..902c2835a92 100644\n--- a/core/src/test/java/io/grpc/internal/DelayedClientTransportTest.java\n+++ b/core/src/test/java/io/grpc/internal/DelayedClientTransportTest.java\n@@ -745,6 +745,23 @@ public void pendingStream_appendTimeoutInsight_waitForReady() {\n         .matches(\"\\\\[wait_for_ready, buffered_nanos=[0-9]+\\\\, waiting_for_connection]\");\n   }\n \n+  @Test\n+  public void pendingStream_appendTimeoutInsight_waitForReady_withLastPickFailure() {\n+    ClientStream stream = delayedTransport.newStream(\n+        method, headers, callOptions.withWaitForReady(), tracers);\n+    stream.start(streamListener);\n+    SubchannelPicker picker = mock(SubchannelPicker.class);\n+    when(picker.pickSubchannel(any(PickSubchannelArgs.class)))\n+        .thenReturn(PickResult.withError(Status.PERMISSION_DENIED));\n+    delayedTransport.reprocess(picker);\n+    InsightBuilder insight = new InsightBuilder();\n+    stream.appendTimeoutInsight(insight);\n+    assertThat(insight.toString())\n+        .matches(\"\\\\[wait_for_ready, \"\n+            + \"Last Pick Failure=Status\\\\{code=PERMISSION_DENIED, description=null, cause=null\\\\},\"\n+            + \" buffered_nanos=[0-9]+, waiting_for_connection]\");\n+  }\n+\n   private static TransportProvider newTransportProvider(final ClientTransport transport) {\n     return new TransportProvider() {\n       @Override\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11811",
    "pr_id": 11811,
    "issue_id": 8687,
    "repo": "grpc/grpc-java",
    "problem_statement": "Migrate from JSR305's javax.annotation.CheckReturnValue to ErrorProne's com.google.errorprone.annotations.CheckReturnValue\nInitiated by cl/408694635\r\n",
    "issue_word_count": 19,
    "test_files_count": 1,
    "non_test_files_count": 34,
    "pr_changed_files": [
      "api/src/main/java/io/grpc/CallOptions.java",
      "api/src/main/java/io/grpc/MethodDescriptor.java",
      "api/src/main/java/io/grpc/Status.java",
      "api/src/testFixtures/java/io/grpc/testing/DeadlineSubject.java",
      "binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java",
      "binder/src/main/java/io/grpc/binder/SecurityPolicy.java",
      "binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java",
      "binder/src/main/java/io/grpc/binder/UntrustedSecurityPolicies.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderTransport.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java",
      "core/src/main/java/io/grpc/internal/ClientTransportFactory.java",
      "core/src/main/java/io/grpc/internal/DelayedStream.java",
      "core/src/main/java/io/grpc/internal/KeepAliveEnforcer.java",
      "core/src/main/java/io/grpc/internal/ManagedClientTransport.java",
      "core/src/main/java/io/grpc/internal/RetriableStream.java",
      "core/src/main/java/io/grpc/internal/TransportFrameUtil.java",
      "inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java",
      "netty/src/main/java/io/grpc/netty/ProtocolNegotiationEvent.java",
      "netty/src/main/java/io/grpc/netty/Utils.java",
      "netty/src/main/java/io/grpc/netty/package-info.java",
      "okhttp/src/main/java/io/grpc/okhttp/OkHttpChannelBuilder.java",
      "okhttp/src/main/java/io/grpc/okhttp/Utils.java",
      "protobuf/BUILD.bazel",
      "protobuf/src/main/java/io/grpc/protobuf/ProtoMethodDescriptorSupplier.java",
      "rls/BUILD.bazel",
      "rls/src/main/java/io/grpc/rls/CachingRlsLbClient.java",
      "rls/src/main/java/io/grpc/rls/LinkedHashLruCache.java",
      "rls/src/main/java/io/grpc/rls/LruCache.java",
      "rls/src/main/java/io/grpc/rls/RlsRequestFactory.java",
      "servlet/src/main/java/io/grpc/servlet/AsyncServletOutputStreamWriter.java",
      "stub/src/main/java/io/grpc/stub/AbstractAsyncStub.java",
      "stub/src/main/java/io/grpc/stub/AbstractBlockingStub.java",
      "stub/src/main/java/io/grpc/stub/AbstractFutureStub.java",
      "stub/src/main/java/io/grpc/stub/AbstractStub.java",
      "xds/src/main/java/io/grpc/xds/internal/security/ReferenceCountingMap.java"
    ],
    "pr_changed_test_files": [
      "api/src/testFixtures/java/io/grpc/testing/DeadlineSubject.java"
    ],
    "base_commit": "73721acc0d341acd2a45e6edc040460ddf40ae5f",
    "head_commit": "a9cb4116e853a87c6f43a532ebe37313569d58ca",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11811",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11811",
    "dockerfile": "",
    "pr_merged_at": "2025-01-09T21:45:35.000Z",
    "patch": "diff --git a/api/src/main/java/io/grpc/CallOptions.java b/api/src/main/java/io/grpc/CallOptions.java\nindex a1b8984c48b..800bdfb6c90 100644\n--- a/api/src/main/java/io/grpc/CallOptions.java\n+++ b/api/src/main/java/io/grpc/CallOptions.java\n@@ -21,6 +21,7 @@\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -28,7 +29,6 @@\n import java.util.List;\n import java.util.concurrent.Executor;\n import java.util.concurrent.TimeUnit;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n \n\ndiff --git a/api/src/main/java/io/grpc/MethodDescriptor.java b/api/src/main/java/io/grpc/MethodDescriptor.java\nindex 1bfaccb4201..a02eb840deb 100644\n--- a/api/src/main/java/io/grpc/MethodDescriptor.java\n+++ b/api/src/main/java/io/grpc/MethodDescriptor.java\n@@ -20,9 +20,9 @@\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import java.io.InputStream;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n \n\ndiff --git a/api/src/main/java/io/grpc/Status.java b/api/src/main/java/io/grpc/Status.java\nindex 5d7dd30df01..38cd9581f8e 100644\n--- a/api/src/main/java/io/grpc/Status.java\n+++ b/api/src/main/java/io/grpc/Status.java\n@@ -23,6 +23,7 @@\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Objects;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Metadata.TrustedAsciiMarshaller;\n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n@@ -30,7 +31,6 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.TreeMap;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n \n\ndiff --git a/binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java b/binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java\nindex 2a37e6fd517..5b17ad35977 100644\n--- a/binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java\n+++ b/binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java\n@@ -17,11 +17,11 @@\n package io.grpc.binder;\n \n import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.ExperimentalApi;\n import io.grpc.Status;\n import java.util.concurrent.CancellationException;\n import java.util.concurrent.ExecutionException;\n-import javax.annotation.CheckReturnValue;\n \n /**\n  * Decides whether a given Android UID is authorized to access some resource.\n\ndiff --git a/binder/src/main/java/io/grpc/binder/SecurityPolicy.java b/binder/src/main/java/io/grpc/binder/SecurityPolicy.java\nindex e539f17e394..261e5223a0f 100644\n--- a/binder/src/main/java/io/grpc/binder/SecurityPolicy.java\n+++ b/binder/src/main/java/io/grpc/binder/SecurityPolicy.java\n@@ -16,8 +16,8 @@\n \n package io.grpc.binder;\n \n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Status;\n-import javax.annotation.CheckReturnValue;\n \n /**\n  * Decides whether a given Android UID is authorized to access some resource.\n\ndiff --git a/binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java b/binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java\nindex 6a9361c0eaf..4786a5e6cc4 100644\n--- a/binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java\n+++ b/binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java\n@@ -19,10 +19,10 @@\n import com.google.common.collect.ImmutableMap;\n import com.google.common.util.concurrent.Futures;\n import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Status;\n import java.util.HashMap;\n import java.util.Map;\n-import javax.annotation.CheckReturnValue;\n \n /**\n  * A security policy for a gRPC server.\n\ndiff --git a/binder/src/main/java/io/grpc/binder/UntrustedSecurityPolicies.java b/binder/src/main/java/io/grpc/binder/UntrustedSecurityPolicies.java\nindex 64d8ac1426a..44612a82109 100644\n--- a/binder/src/main/java/io/grpc/binder/UntrustedSecurityPolicies.java\n+++ b/binder/src/main/java/io/grpc/binder/UntrustedSecurityPolicies.java\n@@ -16,9 +16,9 @@\n \n package io.grpc.binder;\n \n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.ExperimentalApi;\n import io.grpc.Status;\n-import javax.annotation.CheckReturnValue;\n \n /** Static factory methods for creating untrusted security policies. */\n @CheckReturnValue\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java b/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\nindex 254ad5bb407..0c886a9829c 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\n@@ -35,6 +35,7 @@\n import com.google.common.util.concurrent.FutureCallback;\n import com.google.common.util.concurrent.Futures;\n import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Attributes;\n import io.grpc.CallOptions;\n import io.grpc.ClientStreamTracer;\n@@ -78,7 +79,6 @@\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java b/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\nindex 430eee3e041..6f95ef8a83c 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\n@@ -20,6 +20,7 @@\n import com.google.common.util.concurrent.Futures;\n import com.google.common.util.concurrent.ListenableFuture;\n import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Attributes;\n import io.grpc.Internal;\n import io.grpc.Metadata;\n@@ -35,7 +36,6 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Executor;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n \n /**\n\ndiff --git a/core/src/main/java/io/grpc/internal/ClientTransportFactory.java b/core/src/main/java/io/grpc/internal/ClientTransportFactory.java\nindex d987f9d5068..6c10ced4652 100644\n--- a/core/src/main/java/io/grpc/internal/ClientTransportFactory.java\n+++ b/core/src/main/java/io/grpc/internal/ClientTransportFactory.java\n@@ -18,6 +18,7 @@\n \n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Attributes;\n import io.grpc.CallCredentials;\n import io.grpc.ChannelCredentials;\n@@ -27,7 +28,6 @@\n import java.net.SocketAddress;\n import java.util.Collection;\n import java.util.concurrent.ScheduledExecutorService;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n \n /** Pre-configured factory for creating {@link ConnectionClientTransport} instances. */\n\ndiff --git a/core/src/main/java/io/grpc/internal/DelayedStream.java b/core/src/main/java/io/grpc/internal/DelayedStream.java\nindex c94986a3458..5f14f24cfe5 100644\n--- a/core/src/main/java/io/grpc/internal/DelayedStream.java\n+++ b/core/src/main/java/io/grpc/internal/DelayedStream.java\n@@ -20,6 +20,7 @@\n import static com.google.common.base.Preconditions.checkState;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Attributes;\n import io.grpc.Compressor;\n import io.grpc.Deadline;\n@@ -30,7 +31,6 @@\n import java.io.InputStream;\n import java.util.ArrayList;\n import java.util.List;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.concurrent.GuardedBy;\n \n /**\n\ndiff --git a/core/src/main/java/io/grpc/internal/KeepAliveEnforcer.java b/core/src/main/java/io/grpc/internal/KeepAliveEnforcer.java\nindex dd539e75a18..6480336470c 100644\n--- a/core/src/main/java/io/grpc/internal/KeepAliveEnforcer.java\n+++ b/core/src/main/java/io/grpc/internal/KeepAliveEnforcer.java\n@@ -18,8 +18,8 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import java.util.concurrent.TimeUnit;\n-import javax.annotation.CheckReturnValue;\n \n /** Monitors the client's PING usage to make sure the rate is permitted. */\n public final class KeepAliveEnforcer {\n\ndiff --git a/core/src/main/java/io/grpc/internal/ManagedClientTransport.java b/core/src/main/java/io/grpc/internal/ManagedClientTransport.java\nindex 5f8fe52ef6b..184a4d98955 100644\n--- a/core/src/main/java/io/grpc/internal/ManagedClientTransport.java\n+++ b/core/src/main/java/io/grpc/internal/ManagedClientTransport.java\n@@ -16,9 +16,9 @@\n \n package io.grpc.internal;\n \n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Attributes;\n import io.grpc.Status;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.ThreadSafe;\n \n\ndiff --git a/core/src/main/java/io/grpc/internal/RetriableStream.java b/core/src/main/java/io/grpc/internal/RetriableStream.java\nindex ba9424ea25c..7fed77625d3 100644\n--- a/core/src/main/java/io/grpc/internal/RetriableStream.java\n+++ b/core/src/main/java/io/grpc/internal/RetriableStream.java\n@@ -22,6 +22,7 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Objects;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Attributes;\n import io.grpc.ClientStreamTracer;\n import io.grpc.Compressor;\n@@ -47,7 +48,6 @@\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import javax.annotation.CheckForNull;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n \n\ndiff --git a/core/src/main/java/io/grpc/internal/TransportFrameUtil.java b/core/src/main/java/io/grpc/internal/TransportFrameUtil.java\nindex f3c32416426..3bd7ee72239 100644\n--- a/core/src/main/java/io/grpc/internal/TransportFrameUtil.java\n+++ b/core/src/main/java/io/grpc/internal/TransportFrameUtil.java\n@@ -19,13 +19,13 @@\n import static java.nio.charset.StandardCharsets.US_ASCII;\n \n import com.google.common.io.BaseEncoding;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.InternalMetadata;\n import io.grpc.Metadata;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import java.util.logging.Logger;\n-import javax.annotation.CheckReturnValue;\n \n /**\n  * Utility functions for transport layer framing.\n\ndiff --git a/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java b/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java\nindex eacf46ca4a2..b5bbbe563df 100644\n--- a/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java\n+++ b/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java\n@@ -24,6 +24,7 @@\n import com.google.common.io.ByteStreams;\n import com.google.common.util.concurrent.ListenableFuture;\n import com.google.common.util.concurrent.SettableFuture;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Attributes;\n import io.grpc.CallOptions;\n import io.grpc.ClientStreamTracer;\n@@ -74,7 +75,6 @@\n import java.util.concurrent.TimeUnit;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n\ndiff --git a/netty/src/main/java/io/grpc/netty/ProtocolNegotiationEvent.java b/netty/src/main/java/io/grpc/netty/ProtocolNegotiationEvent.java\nindex 16da79e1af8..8103a2dc79f 100644\n--- a/netty/src/main/java/io/grpc/netty/ProtocolNegotiationEvent.java\n+++ b/netty/src/main/java/io/grpc/netty/ProtocolNegotiationEvent.java\n@@ -20,10 +20,10 @@\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Objects;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Attributes;\n import io.grpc.Internal;\n import io.grpc.InternalChannelz.Security;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n \n /**\n\ndiff --git a/netty/src/main/java/io/grpc/netty/Utils.java b/netty/src/main/java/io/grpc/netty/Utils.java\nindex ba405637af5..c0981f5b219 100644\n--- a/netty/src/main/java/io/grpc/netty/Utils.java\n+++ b/netty/src/main/java/io/grpc/netty/Utils.java\n@@ -27,6 +27,7 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.InternalChannelz;\n import io.grpc.InternalMetadata;\n import io.grpc.Metadata;\n@@ -68,7 +69,6 @@\n import java.util.concurrent.TimeUnit;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n import javax.net.ssl.SSLException;\n \n\ndiff --git a/netty/src/main/java/io/grpc/netty/package-info.java b/netty/src/main/java/io/grpc/netty/package-info.java\nindex 54595b38573..d1d7b87cf51 100644\n--- a/netty/src/main/java/io/grpc/netty/package-info.java\n+++ b/netty/src/main/java/io/grpc/netty/package-info.java\n@@ -18,5 +18,5 @@\n  * The main transport implementation based on <a target=\"_blank\" href=\"http://netty.io\">Netty</a>,\n  * for both the client and the server.\n  */\n-@javax.annotation.CheckReturnValue\n+@com.google.errorprone.annotations.CheckReturnValue\n package io.grpc.netty;\n\ndiff --git a/okhttp/src/main/java/io/grpc/okhttp/OkHttpChannelBuilder.java b/okhttp/src/main/java/io/grpc/okhttp/OkHttpChannelBuilder.java\nindex 15508110344..f42cb9fb16d 100644\n--- a/okhttp/src/main/java/io/grpc/okhttp/OkHttpChannelBuilder.java\n+++ b/okhttp/src/main/java/io/grpc/okhttp/OkHttpChannelBuilder.java\n@@ -22,6 +22,7 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.CallCredentials;\n import io.grpc.ChannelCredentials;\n import io.grpc.ChannelLogger;\n@@ -72,7 +73,6 @@\n import java.util.concurrent.TimeUnit;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n import javax.net.SocketFactory;\n import javax.net.ssl.HostnameVerifier;\n\ndiff --git a/okhttp/src/main/java/io/grpc/okhttp/Utils.java b/okhttp/src/main/java/io/grpc/okhttp/Utils.java\nindex 2dc5f1e1ec9..4546143cf3b 100644\n--- a/okhttp/src/main/java/io/grpc/okhttp/Utils.java\n+++ b/okhttp/src/main/java/io/grpc/okhttp/Utils.java\n@@ -17,6 +17,7 @@\n package io.grpc.okhttp;\n \n import com.google.common.base.Preconditions;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.InternalChannelz;\n import io.grpc.InternalMetadata;\n import io.grpc.Metadata;\n@@ -29,7 +30,6 @@\n import java.util.List;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.annotation.CheckReturnValue;\n \n /**\n  * Common utility methods for OkHttp transport.\n\ndiff --git a/protobuf/BUILD.bazel b/protobuf/BUILD.bazel\nindex 724c78ca6ee..02a136554d2 100644\n--- a/protobuf/BUILD.bazel\n+++ b/protobuf/BUILD.bazel\n@@ -12,6 +12,7 @@ java_library(\n         \"@com_google_protobuf//:protobuf_java\",\n         artifact(\"com.google.api.grpc:proto-google-common-protos\"),\n         artifact(\"com.google.code.findbugs:jsr305\"),\n+        artifact(\"com.google.errorprone:error_prone_annotations\"),\n         artifact(\"com.google.guava:guava\"),\n     ],\n )\n\ndiff --git a/protobuf/src/main/java/io/grpc/protobuf/ProtoMethodDescriptorSupplier.java b/protobuf/src/main/java/io/grpc/protobuf/ProtoMethodDescriptorSupplier.java\nindex e5b2f38e3c0..e7cd3ed336f 100644\n--- a/protobuf/src/main/java/io/grpc/protobuf/ProtoMethodDescriptorSupplier.java\n+++ b/protobuf/src/main/java/io/grpc/protobuf/ProtoMethodDescriptorSupplier.java\n@@ -16,8 +16,8 @@\n \n package io.grpc.protobuf;\n \n+import com.google.errorprone.annotations.CheckReturnValue;\n import com.google.protobuf.Descriptors.MethodDescriptor;\n-import javax.annotation.CheckReturnValue;\n \n /**\n  * Provides access to the underlying proto service method descriptor.\n\ndiff --git a/rls/BUILD.bazel b/rls/BUILD.bazel\nindex 10a5e22524a..bfa0c7eee97 100644\n--- a/rls/BUILD.bazel\n+++ b/rls/BUILD.bazel\n@@ -19,6 +19,7 @@ java_library(\n         \"@io_grpc_grpc_proto//:rls_java_proto\",\n         artifact(\"com.google.auto.value:auto-value-annotations\"),\n         artifact(\"com.google.code.findbugs:jsr305\"),\n+        artifact(\"com.google.errorprone:error_prone_annotations\"),\n         artifact(\"com.google.guava:guava\"),\n     ],\n )\n\ndiff --git a/rls/src/main/java/io/grpc/rls/CachingRlsLbClient.java b/rls/src/main/java/io/grpc/rls/CachingRlsLbClient.java\nindex 3d52187a158..9775753ab50 100644\n--- a/rls/src/main/java/io/grpc/rls/CachingRlsLbClient.java\n+++ b/rls/src/main/java/io/grpc/rls/CachingRlsLbClient.java\n@@ -28,6 +28,7 @@\n import com.google.common.util.concurrent.ListenableFuture;\n import com.google.common.util.concurrent.MoreExecutors;\n import com.google.common.util.concurrent.SettableFuture;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.ChannelLogger;\n import io.grpc.ChannelLogger.ChannelLogLevel;\n import io.grpc.ConnectivityState;\n@@ -73,7 +74,6 @@\n import java.util.concurrent.Future;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n\ndiff --git a/rls/src/main/java/io/grpc/rls/LinkedHashLruCache.java b/rls/src/main/java/io/grpc/rls/LinkedHashLruCache.java\nindex ba0575efa57..b39b463c762 100644\n--- a/rls/src/main/java/io/grpc/rls/LinkedHashLruCache.java\n+++ b/rls/src/main/java/io/grpc/rls/LinkedHashLruCache.java\n@@ -22,6 +22,7 @@\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Ticker;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n@@ -29,7 +30,6 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n \n /**\n\ndiff --git a/rls/src/main/java/io/grpc/rls/LruCache.java b/rls/src/main/java/io/grpc/rls/LruCache.java\nindex 1ad5a958289..8fc4ae98472 100644\n--- a/rls/src/main/java/io/grpc/rls/LruCache.java\n+++ b/rls/src/main/java/io/grpc/rls/LruCache.java\n@@ -16,7 +16,7 @@\n \n package io.grpc.rls;\n \n-import javax.annotation.CheckReturnValue;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import javax.annotation.Nullable;\n \n /** An LruCache is a cache with least recently used eviction. */\n\ndiff --git a/rls/src/main/java/io/grpc/rls/RlsRequestFactory.java b/rls/src/main/java/io/grpc/rls/RlsRequestFactory.java\nindex a6ca0137ff1..e26e49979e1 100644\n--- a/rls/src/main/java/io/grpc/rls/RlsRequestFactory.java\n+++ b/rls/src/main/java/io/grpc/rls/RlsRequestFactory.java\n@@ -20,6 +20,7 @@\n \n import com.google.common.base.MoreObjects;\n import com.google.common.collect.ImmutableMap;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Metadata;\n import io.grpc.rls.RlsProtoData.ExtraKeys;\n import io.grpc.rls.RlsProtoData.GrpcKeyBuilder;\n@@ -30,7 +31,6 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import javax.annotation.CheckReturnValue;\n \n /**\n  * A RlsRequestFactory creates {@link RouteLookupRequest} using key builder map from {@link\n\ndiff --git a/servlet/src/main/java/io/grpc/servlet/AsyncServletOutputStreamWriter.java b/servlet/src/main/java/io/grpc/servlet/AsyncServletOutputStreamWriter.java\nindex cfd29b1a2fd..8c0c6ec6512 100644\n--- a/servlet/src/main/java/io/grpc/servlet/AsyncServletOutputStreamWriter.java\n+++ b/servlet/src/main/java/io/grpc/servlet/AsyncServletOutputStreamWriter.java\n@@ -22,6 +22,7 @@\n import static java.util.logging.Level.FINEST;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.InternalLogId;\n import io.grpc.servlet.ServletServerStream.ServletTransportState;\n import java.io.IOException;\n@@ -34,7 +35,6 @@\n import java.util.function.BooleanSupplier;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n import javax.servlet.AsyncContext;\n import javax.servlet.ServletOutputStream;\n\ndiff --git a/stub/src/main/java/io/grpc/stub/AbstractAsyncStub.java b/stub/src/main/java/io/grpc/stub/AbstractAsyncStub.java\nindex c6f912cb3a7..f369eeaf87f 100644\n--- a/stub/src/main/java/io/grpc/stub/AbstractAsyncStub.java\n+++ b/stub/src/main/java/io/grpc/stub/AbstractAsyncStub.java\n@@ -16,10 +16,10 @@\n \n package io.grpc.stub;\n \n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.CallOptions;\n import io.grpc.Channel;\n import io.grpc.stub.ClientCalls.StubType;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n\ndiff --git a/stub/src/main/java/io/grpc/stub/AbstractBlockingStub.java b/stub/src/main/java/io/grpc/stub/AbstractBlockingStub.java\nindex 1cb919e67b0..4bdb3c0bb94 100644\n--- a/stub/src/main/java/io/grpc/stub/AbstractBlockingStub.java\n+++ b/stub/src/main/java/io/grpc/stub/AbstractBlockingStub.java\n@@ -16,10 +16,10 @@\n \n package io.grpc.stub;\n \n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.CallOptions;\n import io.grpc.Channel;\n import io.grpc.stub.ClientCalls.StubType;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n\ndiff --git a/stub/src/main/java/io/grpc/stub/AbstractFutureStub.java b/stub/src/main/java/io/grpc/stub/AbstractFutureStub.java\nindex 66570bcd6ff..5e37b1e4915 100644\n--- a/stub/src/main/java/io/grpc/stub/AbstractFutureStub.java\n+++ b/stub/src/main/java/io/grpc/stub/AbstractFutureStub.java\n@@ -16,10 +16,10 @@\n \n package io.grpc.stub;\n \n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.CallOptions;\n import io.grpc.Channel;\n import io.grpc.stub.ClientCalls.StubType;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n\ndiff --git a/stub/src/main/java/io/grpc/stub/AbstractStub.java b/stub/src/main/java/io/grpc/stub/AbstractStub.java\nindex 7b4bbed34a8..697107760db 100644\n--- a/stub/src/main/java/io/grpc/stub/AbstractStub.java\n+++ b/stub/src/main/java/io/grpc/stub/AbstractStub.java\n@@ -19,6 +19,7 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static io.grpc.InternalTimeUtils.convert;\n \n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.CallCredentials;\n import io.grpc.CallOptions;\n import io.grpc.Channel;\n@@ -30,7 +31,6 @@\n import java.time.Duration;\n import java.util.concurrent.Executor;\n import java.util.concurrent.TimeUnit;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.ThreadSafe;\n import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;\n\ndiff --git a/xds/src/main/java/io/grpc/xds/internal/security/ReferenceCountingMap.java b/xds/src/main/java/io/grpc/xds/internal/security/ReferenceCountingMap.java\nindex b7f56492fa5..08b8f6a325b 100644\n--- a/xds/src/main/java/io/grpc/xds/internal/security/ReferenceCountingMap.java\n+++ b/xds/src/main/java/io/grpc/xds/internal/security/ReferenceCountingMap.java\n@@ -20,9 +20,9 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.base.Preconditions.checkState;\n \n+import com.google.errorprone.annotations.CheckReturnValue;\n import java.util.HashMap;\n import java.util.Map;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n",
    "test_patch": "diff --git a/api/src/testFixtures/java/io/grpc/testing/DeadlineSubject.java b/api/src/testFixtures/java/io/grpc/testing/DeadlineSubject.java\nindex 94ab8fb9b18..c2b4d8412a7 100644\n--- a/api/src/testFixtures/java/io/grpc/testing/DeadlineSubject.java\n+++ b/api/src/testFixtures/java/io/grpc/testing/DeadlineSubject.java\n@@ -24,9 +24,9 @@\n import com.google.common.truth.ComparableSubject;\n import com.google.common.truth.FailureMetadata;\n import com.google.common.truth.Subject;\n+import com.google.errorprone.annotations.CheckReturnValue;\n import io.grpc.Deadline;\n import java.util.concurrent.TimeUnit;\n-import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n \n /** Propositions for {@link Deadline} subjects. */\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11783",
    "pr_id": 11783,
    "issue_id": 10146,
    "repo": "grpc/grpc-java",
    "problem_statement": "GcpObservabilityTest.enableObservability is way slow\nIt seems this test always takes just over a minute. A recent run on my machine showed it take \"1m1.37s\".\r\n\r\nTests that take over a second are normally concerning, but can be lived with when really necessary. A minute is outlandish. Is there any way we can reduce the time it takes to something more in the \"5 seconds\" range?\r\n\r\nIt seems the entire duration is just waiting on close(), which sleeps for 1 minute. I know we want to avoid the sleep and force-flush, which may address this issue. But I don't see an open issue about it. If that were fixed, that would avoid the issue.\r\n\r\nSince the test isn't actually verifying the sleep, maybe it can call a package-private close(sleep time) that then can be passed a much smaller value.",
    "issue_word_count": 144,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "gcp-observability/src/main/java/io/grpc/gcp/observability/GcpObservability.java",
      "gcp-observability/src/test/java/io/grpc/gcp/observability/GcpObservabilityTest.java"
    ],
    "pr_changed_test_files": [
      "gcp-observability/src/test/java/io/grpc/gcp/observability/GcpObservabilityTest.java"
    ],
    "base_commit": "5e8abc6774348ef93112a2bad2eddc5069013bf3",
    "head_commit": "1626bcfddd9b092f9d6318f4ae23e0910f5b39b2",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11783",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11783",
    "dockerfile": "",
    "pr_merged_at": "2025-01-24T11:20:41.000Z",
    "patch": "diff --git a/gcp-observability/src/main/java/io/grpc/gcp/observability/GcpObservability.java b/gcp-observability/src/main/java/io/grpc/gcp/observability/GcpObservability.java\nindex 497a1eda30f..7fe4e3a8a3c 100644\n--- a/gcp-observability/src/main/java/io/grpc/gcp/observability/GcpObservability.java\n+++ b/gcp-observability/src/main/java/io/grpc/gcp/observability/GcpObservability.java\n@@ -127,6 +127,15 @@ static GcpObservability grpcInit(\n   /** Un-initialize/shutdown grpc-observability. */\n   @Override\n   public void close() {\n+    closeWithSleepTime(2 * METRICS_EXPORT_INTERVAL, TimeUnit.SECONDS);\n+  }\n+\n+  /**\n+   * Method to close along with sleep time explicitly.\n+   *\n+   * @param sleepTime sleepTime\n+   */\n+  void closeWithSleepTime(long sleepTime, TimeUnit timeUnit) {\n     synchronized (GcpObservability.class) {\n       if (instance == null) {\n         throw new IllegalStateException(\"GcpObservability already closed!\");\n@@ -135,8 +144,7 @@ public void close() {\n       if (config.isEnableCloudMonitoring() || config.isEnableCloudTracing()) {\n         try {\n           // Sleeping before shutdown to ensure all metrics and traces are flushed\n-          Thread.sleep(\n-              TimeUnit.MILLISECONDS.convert(2 * METRICS_EXPORT_INTERVAL, TimeUnit.SECONDS));\n+          timeUnit.sleep(sleepTime);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           logger.log(Level.SEVERE, \"Caught exception during sleep\", e);\n",
    "test_patch": "diff --git a/gcp-observability/src/test/java/io/grpc/gcp/observability/GcpObservabilityTest.java b/gcp-observability/src/test/java/io/grpc/gcp/observability/GcpObservabilityTest.java\nindex 40f2fb01490..25467839dd6 100644\n--- a/gcp-observability/src/test/java/io/grpc/gcp/observability/GcpObservabilityTest.java\n+++ b/gcp-observability/src/test/java/io/grpc/gcp/observability/GcpObservabilityTest.java\n@@ -45,6 +45,7 @@\n import io.opencensus.trace.samplers.Samplers;\n import java.io.IOException;\n import java.util.List;\n+import java.util.concurrent.TimeUnit;\n import java.util.regex.Pattern;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -196,9 +197,9 @@ public void run() {\n           mock(InternalLoggingServerInterceptor.Factory.class);\n       when(serverInterceptorFactory.create()).thenReturn(serverInterceptor);\n \n-      try (GcpObservability unused =\n-          GcpObservability.grpcInit(\n-              sink, config, channelInterceptorFactory, serverInterceptorFactory)) {\n+      try {\n+        GcpObservability gcpObservability = GcpObservability.grpcInit(\n+            sink, config, channelInterceptorFactory, serverInterceptorFactory);\n         List<?> configurators = InternalConfiguratorRegistry.getConfigurators();\n         assertThat(configurators).hasSize(1);\n         ObservabilityConfigurator configurator = (ObservabilityConfigurator) configurators.get(0);\n@@ -208,9 +209,11 @@ public void run() {\n         assertThat(list.get(2)).isInstanceOf(ConditionalClientInterceptor.class);\n         assertThat(configurator.serverInterceptors).hasSize(1);\n         assertThat(configurator.tracerFactories).hasSize(2);\n+        gcpObservability.closeWithSleepTime(3000, TimeUnit.MILLISECONDS);\n       } catch (Exception e) {\n         fail(\"Encountered exception: \" + e);\n       }\n+      verify(sink).close();\n     }\n   }\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11778",
    "pr_id": 11778,
    "issue_id": 10957,
    "repo": "grpc/grpc-java",
    "problem_statement": "New method StreamObserver.complete(value) for unary RPC\nI think unary RPCs are used quite often, then in the service implementation we have to write 2 lines:\r\n```java\r\nresponseObserver.onNext(result);\r\nresponseObserver.onCompleted();\r\n```\r\n\r\nIt seems logical to introduce a default method:\r\n```java\r\ndefault void complete(V value) {\r\n  onNext(value);\r\n  onCompleted();\r\n}\r\n```\r\n\r\nWDYT?",
    "issue_word_count": 51,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "stub/src/main/java/io/grpc/stub/StreamObservers.java",
      "stub/src/test/java/io/grpc/stub/StreamObserversTest.java"
    ],
    "pr_changed_test_files": [
      "stub/src/test/java/io/grpc/stub/StreamObserversTest.java"
    ],
    "base_commit": "c8d1e6e39c26da2eb54386eac6eaf9e1aa8f9b9c",
    "head_commit": "666e4fb7f7e02c93c032d6ec996f7df4ace5bee1",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11778",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11778",
    "dockerfile": "",
    "pr_merged_at": "2025-04-04T14:09:35.000Z",
    "patch": "diff --git a/stub/src/main/java/io/grpc/stub/StreamObservers.java b/stub/src/main/java/io/grpc/stub/StreamObservers.java\nindex 2cc53ea0aa2..a421d3eca2f 100644\n--- a/stub/src/main/java/io/grpc/stub/StreamObservers.java\n+++ b/stub/src/main/java/io/grpc/stub/StreamObservers.java\n@@ -23,12 +23,21 @@\n /**\n  * Utility functions for working with {@link StreamObserver} and it's common subclasses like\n  * {@link CallStreamObserver}.\n- *\n- * @deprecated Of questionable utility and generally not used.\n  */\n-@Deprecated\n-@ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/4694\")\n public final class StreamObservers {\n+  // Prevent instantiation\n+  private StreamObservers() { }\n+\n+  /**\n+   * Utility method to call {@link StreamObserver#onNext(Object)} and\n+   * {@link StreamObserver#onCompleted()} on the specified responseObserver.\n+   */\n+  @ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/10957\")\n+  public static <T> void nextAndComplete(StreamObserver<T> responseObserver, T response) {\n+    responseObserver.onNext(response);\n+    responseObserver.onCompleted();\n+  }\n+\n   /**\n    * Copy the values of an {@link Iterator} to the target {@link CallStreamObserver} while properly\n    * accounting for outbound flow-control.  After calling this method, {@code target} should no\n@@ -40,7 +49,10 @@ public final class StreamObservers {\n    *\n    * @param source of values expressed as an {@link Iterator}.\n    * @param target {@link CallStreamObserver} which accepts values from the source.\n+   * @deprecated Of questionable utility and generally not used.\n    */\n+  @Deprecated\n+  @ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/4694\")\n   public static <V> void copyWithFlowControl(final Iterator<V> source,\n       final CallStreamObserver<V> target) {\n     Preconditions.checkNotNull(source, \"source\");\n@@ -80,7 +92,10 @@ public void run() {\n    *\n    * @param source of values expressed as an {@link Iterable}.\n    * @param target {@link CallStreamObserver} which accepts values from the source.\n+   * @deprecated Of questionable utility and generally not used.\n    */\n+  @Deprecated\n+  @ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/4694\")\n   public static <V> void copyWithFlowControl(final Iterable<V> source,\n       CallStreamObserver<V> target) {\n     Preconditions.checkNotNull(source, \"source\");\n",
    "test_patch": "diff --git a/stub/src/test/java/io/grpc/stub/StreamObserversTest.java b/stub/src/test/java/io/grpc/stub/StreamObserversTest.java\nnew file mode 100644\nindex 00000000000..86a1aba2e76\n--- /dev/null\n+++ b/stub/src/test/java/io/grpc/stub/StreamObserversTest.java\n@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2025 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.stub;\n+\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.Mockito;\n+\n+public class StreamObserversTest {\n+\n+  @Test\n+  public void nextAndComplete() {\n+    @SuppressWarnings(\"unchecked\")\n+    StreamObserver<String> observer = Mockito.mock(StreamObserver.class);\n+    InOrder inOrder = Mockito.inOrder(observer);\n+    StreamObservers.nextAndComplete(observer, \"TEST\");\n+    inOrder.verify(observer).onNext(\"TEST\");\n+    inOrder.verify(observer).onCompleted();\n+    inOrder.verifyNoMoreInteractions();\n+  }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11735",
    "pr_id": 11735,
    "issue_id": 11695,
    "repo": "grpc/grpc-java",
    "problem_statement": "xds: Circuit breaking doesn't support unsigned 32 bits\nIf the control plane sends MAX_UINT32 as the max_requests for circuit breaking, grpc-java will treat it as a negative number. That should cause circuit breaking to trigger for all RPCs.\r\n\r\n[`max_requests`](https://github.com/envoyproxy/envoy/blob/3b293f182c8e220855b1aacdf1be04a5d324cb61/api/envoy/config/cluster/v3/circuit_breaker.proto#L69) is a `UInt32Value`, but that's encoded as a signed `int` in Java. The code casts to long, but the sign is preserved:\r\nhttps://github.com/grpc/grpc-java/blob/4e8f7df589cbe5a192e705ab372f2b27957bf662/xds/src/main/java/io/grpc/xds/XdsClusterResource.java#L216\r\n\r\nTo treat it as a uint32, you essentially need to AND it with 0xFFFFFFFFL to make it unsigned. Since this is in xDS, we can use `Integer.toUnsignedLong(int)` (the main other convenience being Guava's `UnsignedInts.toLong(int)`).\r\n\r\nb/372943501\r\n\r\nCC @kannanjgithub ",
    "issue_word_count": 140,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "xds/src/main/java/io/grpc/xds/XdsClusterResource.java",
      "xds/src/test/java/io/grpc/xds/GrpcXdsClientImplTestBase.java"
    ],
    "pr_changed_test_files": [
      "xds/src/test/java/io/grpc/xds/GrpcXdsClientImplTestBase.java"
    ],
    "base_commit": "210f9c083e7ce6c831b2b65f0ee7f9c1384a88f9",
    "head_commit": "797cf106ed2953041ae1c80914bc8a447058d0c3",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11735",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11735",
    "dockerfile": "",
    "pr_merged_at": "2024-12-17T05:37:22.000Z",
    "patch": "diff --git a/xds/src/main/java/io/grpc/xds/XdsClusterResource.java b/xds/src/main/java/io/grpc/xds/XdsClusterResource.java\nindex c7789f3d7dd..ab1ccc20ff5 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsClusterResource.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsClusterResource.java\n@@ -213,7 +213,7 @@ private static StructOrError<CdsUpdate.Builder> parseNonAggregateCluster(\n           continue;\n         }\n         if (threshold.hasMaxRequests()) {\n-          maxConcurrentRequests = (long) threshold.getMaxRequests().getValue();\n+          maxConcurrentRequests = Integer.toUnsignedLong(threshold.getMaxRequests().getValue());\n         }\n       }\n     }\n",
    "test_patch": "diff --git a/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplTestBase.java b/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplTestBase.java\nindex 8ecb40383b1..9f58a5509bf 100644\n--- a/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplTestBase.java\n+++ b/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplTestBase.java\n@@ -3767,6 +3767,25 @@ public void sendToBadUrl() throws Exception {\n     client.shutdown();\n   }\n \n+  @Test\n+  public void circuitBreakingConversionOf32bitIntTo64bitLongForMaxRequestNegativeValue() {\n+    DiscoveryRpcCall call = startResourceWatcher(XdsClusterResource.getInstance(), CDS_RESOURCE,\n+        cdsResourceWatcher);\n+    Any clusterCircuitBreakers = Any.pack(\n+        mf.buildEdsCluster(CDS_RESOURCE, null, \"round_robin\", null, null, false, null,\n+            \"envoy.transport_sockets.tls\", mf.buildCircuitBreakers(50, -1), null));\n+    call.sendResponse(CDS, clusterCircuitBreakers, VERSION_1, \"0000\");\n+\n+    // Client sent an ACK CDS request.\n+    call.verifyRequest(CDS, CDS_RESOURCE, VERSION_1, \"0000\", NODE);\n+    verify(cdsResourceWatcher).onChanged(cdsUpdateCaptor.capture());\n+    CdsUpdate cdsUpdate = cdsUpdateCaptor.getValue();\n+\n+    assertThat(cdsUpdate.clusterName()).isEqualTo(CDS_RESOURCE);\n+    assertThat(cdsUpdate.clusterType()).isEqualTo(ClusterType.EDS);\n+    assertThat(cdsUpdate.maxConcurrentRequests()).isEqualTo(4294967295L);\n+  }\n+\n   @Test\n   public void sendToNonexistentServer() throws Exception {\n     // Setup xdsClient to fail on stream creation\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11698",
    "pr_id": 11698,
    "issue_id": 11680,
    "repo": "grpc/grpc-java",
    "problem_statement": "InstantTimeProviderTest.testInstantCurrentTimeNanos is consistently failing\n[Inside Google](https://fusion2.corp.google.com/triage/2712179097651820092/5592943177771253760):\r\n```\r\nexpected         : 1730533931622822000\r\nbut was          : 1730533931609013000\r\noutside tolerance: 10000000\r\n\tat io.grpc.internal.InstantTimeProviderTest.testInstantCurrentTimeNanos(InstantTimeProviderTest.java:48)\r\n```\r\n\r\nAnother arbitrary failure:\r\n```\r\nexpected         : 1731147454282900000\r\nbut was          : 1731147454264246000\r\n```\r\n\r\n@vinodhabib\r\nCC @kannanjgithub ",
    "issue_word_count": 43,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "core/src/test/java/io/grpc/internal/InstantTimeProviderTest.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/InstantTimeProviderTest.java"
    ],
    "base_commit": "5431bf7e773940c35e97bf627f1a753df0e36be6",
    "head_commit": "52b769adec8f9805bbb6dc88766f2cacd8ec7932",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11698",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11698",
    "dockerfile": "",
    "pr_merged_at": "2024-11-18T15:42:53.000Z",
    "patch": "",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/InstantTimeProviderTest.java b/core/src/test/java/io/grpc/internal/InstantTimeProviderTest.java\nindex ef97d374b10..46d1891cbb9 100644\n--- a/core/src/test/java/io/grpc/internal/InstantTimeProviderTest.java\n+++ b/core/src/test/java/io/grpc/internal/InstantTimeProviderTest.java\n@@ -44,7 +44,7 @@ public void testInstantCurrentTimeNanos() throws Exception {\n           + instantNow.getNano();\n \n     // Validate the time returned is close to the expected value within a tolerance\n-    // (i,e 10 millisecond tolerance in nanoseconds).\n-    assertThat(actualTimeNanos).isWithin(10_000_000L).of(expectedTimeNanos);\n+    // (i,e 1000 millisecond (1 second) tolerance in nanoseconds).\n+    assertThat(actualTimeNanos).isWithin(1000_000_000L).of(expectedTimeNanos);\n   }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11691",
    "pr_id": 11691,
    "issue_id": 11678,
    "repo": "grpc/grpc-java",
    "problem_statement": " XdsSecurityClientServerTest.tlsClientServer_useSystemRootCerts_validationContext is flaky\n@erm-g \r\nhttps://github.com/grpc/grpc-java/actions/runs/11745673719/job/32723647320?pr=11673\r\n\r\n```\r\nXdsSecurityClientServerTest > tlsClientServer_useSystemRootCerts_validationContext[enableSpiffe=true] FAILED\r\n    io.grpc.StatusRuntimeException: UNAVAILABLE: io exception\r\n    Channel Pipeline: [SslHandler#0, ProtocolNegotiators$ClientTlsHandler#0, WriteBufferingAndExceptionHandler#0, DefaultChannelPipeline$TailContext#0]\r\n        at app//io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:268)\r\n        at app//io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:249)\r\n        at app//io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:167)\r\n        at app//io.grpc.testing.protobuf.SimpleServiceGrpc$SimpleServiceBlockingStub.unaryRpc(SimpleServiceGrpc.java:340)\r\n        at app//io.grpc.xds.XdsSecurityClientServerTest.unaryRpc(XdsSecurityClientServerTest.java:668)\r\n        at app//io.grpc.xds.XdsSecurityClientServerTest.tlsClientServer_useSystemRootCerts_validationContext(XdsSecurityClientServerTest.java:238)\r\n\r\n        Caused by:\r\n        javax.net.ssl.SSLHandshakeException: General OpenSslEngine problem\r\n            at io.netty.handler.ssl.ReferenceCountedOpenSslEngine.handshakeException(ReferenceCountedOpenSslEngine.java:1927)\r\n            at io.netty.handler.ssl.ReferenceCountedOpenSslEngine.wrap(ReferenceCountedOpenSslEngine.java:848)\r\n            at java.base/javax.net.ssl.SSLEngine.wrap(SSLEngine.java:564)\r\n            at io.netty.handler.ssl.SslHandler.wrap(SslHandler.java:1131)\r\n            at io.netty.handler.ssl.SslHandler.wrapNonAppData(SslHandler.java:975)\r\n            at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1511)\r\n            at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1338)\r\n            at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1387)\r\n            at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)\r\n            at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)\r\n            at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)\r\n            at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\r\n            at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n            at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\r\n            at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1407)\r\n            at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)\r\n            at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n            at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:918)\r\n            at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:799)\r\n            at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:501)\r\n            at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:399)\r\n            at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:994)\r\n            at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n            at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n            at java.base/java.lang.Thread.run(Thread.java:840)\r\n\r\n            Caused by:\r\n            sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\r\n                at java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:439)\r\n                at java.base/sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:306)\r\n                at java.base/sun.security.validator.Validator.validate(Validator.java:264)\r\n                at java.base/sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:285)\r\n                at java.base/sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:144)\r\n                at io.netty.handler.ssl.EnhancingX509ExtendedTrustManager.checkServerTrusted(EnhancingX509ExtendedTrustManager.java:69)\r\n                at io.netty.handler.ssl.ReferenceCountedOpenSslClientContext$ExtendedTrustManagerVerifyCallback.verify(ReferenceCountedOpenSslClientContext.java:235)\r\n                at io.netty.handler.ssl.ReferenceCountedOpenSslContext$AbstractCertificateVerifier.verify(ReferenceCountedOpenSslContext.java:797)\r\n                at io.netty.internal.tcnative.CertificateVerifierTask.runTask(CertificateVerifierTask.java:36)\r\n                at io.netty.internal.tcnative.SSLTask.run(SSLTask.java:48)\r\n                at io.netty.internal.tcnative.SSLTask.run(SSLTask.java:42)\r\n                at io.netty.handler.ssl.ReferenceCountedOpenSslEngine.runAndResetNeedTask(ReferenceCountedOpenSslEngine.java:1533)\r\n                at io.netty.handler.ssl.ReferenceCountedOpenSslEngine.access$700(ReferenceCountedOpenSslEngine.java:94)\r\n                at io.netty.handler.ssl.ReferenceCountedOpenSslEngine$TaskDecorator.run(ReferenceCountedOpenSslEngine.java:1505)\r\n                at io.netty.handler.ssl.SslHandler.runDelegatedTasks(SslHandler.java:1651)\r\n                at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1497)\r\n                ... 19 more\r\n\r\n                Caused by:\r\n                sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\r\n                    at java.base/sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:148)\r\n                    at java.base/sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:129)\r\n                    at java.base/java.security.cert.CertPathBuilder.build(CertPathBuilder.java:297)\r\n                    at java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:434)\r\n\r\n3079 tests completed, 1 failed, 7 skipped\r\n                    ... 34 more\r\n```\r\n\r\nGiven this code just went in, seems highly flaky.",
    "issue_word_count": 636,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java"
    ],
    "pr_changed_test_files": [
      "xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java"
    ],
    "base_commit": "b1703345f74fd211f9c5199825f2b8973885ea0a",
    "head_commit": "00de90d4da17d0b33fde636a584ee1c8ac6bcecf",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11691",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11691",
    "dockerfile": "",
    "pr_merged_at": "2024-11-15T06:01:39.000Z",
    "patch": "",
    "test_patch": "diff --git a/xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java b/xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java\nindex 8e1220fe9d0..590b6c79a10 100644\n--- a/xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java\n+++ b/xds/src/test/java/io/grpc/xds/XdsSecurityClientServerTest.java\n@@ -97,6 +97,7 @@\n import java.util.concurrent.TimeUnit;\n import javax.net.ssl.SSLException;\n import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.TrustManagerFactory;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Rule;\n@@ -687,16 +688,32 @@ public void run() {\n     return settableFuture;\n   }\n \n-  private void setTrustStoreSystemProperties(String trustStoreFilePath) {\n+  private void setTrustStoreSystemProperties(String trustStoreFilePath) throws Exception {\n     System.setProperty(\"javax.net.ssl.trustStore\", trustStoreFilePath);\n     System.setProperty(\"javax.net.ssl.trustStorePassword\", \"changeit\");\n     System.setProperty(\"javax.net.ssl.trustStoreType\", \"JKS\");\n+    createDefaultTrustManager();\n   }\n \n-  private void clearTrustStoreSystemProperties() {\n+  private void clearTrustStoreSystemProperties() throws Exception {\n     System.clearProperty(\"javax.net.ssl.trustStore\");\n     System.clearProperty(\"javax.net.ssl.trustStorePassword\");\n     System.clearProperty(\"javax.net.ssl.trustStoreType\");\n+    createDefaultTrustManager();\n+  }\n+\n+  /**\n+   * Workaround the JDK's TrustManagerStore race. TrustManagerStore has a cache for the default\n+   * certs based on the system properties. But updating the cache is not thread-safe and can cause a\n+   * half-updated cache to appear fully-updated. When both the client and server initialize their\n+   * trust store simultaneously, one can see a half-updated value. Creating the trust manager here\n+   * fixes the cache while no other threads are running and thus the client and server threads won't\n+   * race to update it. See https://github.com/grpc/grpc-java/issues/11678.\n+   */\n+  private void createDefaultTrustManager() throws Exception {\n+    TrustManagerFactory factory =\n+        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+    factory.init((KeyStore) null);\n   }\n \n   private static class SimpleServiceImpl extends SimpleServiceGrpc.SimpleServiceImplBase {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11671",
    "pr_id": 11671,
    "issue_id": 2951,
    "repo": "grpc/grpc-java",
    "problem_statement": "io.grpc.testing.integration.ProxyTest.smallLatency is flaky\nThis is a re-appearance of #2176, but that one is so old I feel bad with reopening it.",
    "issue_word_count": 27,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "interop-testing/src/test/java/io/grpc/testing/integration/ProxyTest.java"
    ],
    "pr_changed_test_files": [
      "interop-testing/src/test/java/io/grpc/testing/integration/ProxyTest.java"
    ],
    "base_commit": "a5db67d0cb4e0c4835a18860f7cbee1519ca2ca7",
    "head_commit": "23b6a56cd9d0d4329a238d000de1a58f0a444b98",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11671",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11671",
    "dockerfile": "",
    "pr_merged_at": "2024-11-22T19:20:25.000Z",
    "patch": "",
    "test_patch": "diff --git a/interop-testing/src/test/java/io/grpc/testing/integration/ProxyTest.java b/interop-testing/src/test/java/io/grpc/testing/integration/ProxyTest.java\nindex f550d657a12..725e98d0fe3 100644\n--- a/interop-testing/src/test/java/io/grpc/testing/integration/ProxyTest.java\n+++ b/interop-testing/src/test/java/io/grpc/testing/integration/ProxyTest.java\n@@ -62,7 +62,6 @@ public void shutdownTest() throws IOException {\n   }\n \n   @Test\n-  @org.junit.Ignore // flaky. latency commonly too high\n   public void smallLatency() throws Exception {\n     server = new Server();\n     int serverPort = server.init();\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11636",
    "pr_id": 11636,
    "issue_id": 5969,
    "repo": "grpc/grpc-java",
    "problem_statement": "async server: need to ignore unary response msg if status is not OK\nThe expectation for unary responses is that the server will respond with an message or an error. If the server responds with a message and an error, the message should be thrown away. The async API currently would send the message. For unary responses, we should delay sending the response until the onComplete()/onError(). If onError() is called we should not send the message.\r\n\r\nhttps://github.com/grpc/grpc-java/blob/b22017851560197a41015acd90f443f7b9519984/stub/src/main/java/io/grpc/stub/ServerCalls.java#L336-L349\r\n\r\nSee #5968 and grpc/grpc#12824",
    "issue_word_count": 102,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "stub/src/main/java/io/grpc/stub/ServerCalls.java",
      "stub/src/test/java/io/grpc/stub/ServerCallsTest.java"
    ],
    "pr_changed_test_files": [
      "stub/src/test/java/io/grpc/stub/ServerCallsTest.java"
    ],
    "base_commit": "31dad6af4996170a55f1bd0a99f0d892e6bbcd84",
    "head_commit": "7f7b0ecf39dd84fc1f5447f75af3b1606532979c",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11636",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11636",
    "dockerfile": "",
    "pr_merged_at": "2024-10-25T06:39:22.000Z",
    "patch": "diff --git a/stub/src/main/java/io/grpc/stub/ServerCalls.java b/stub/src/main/java/io/grpc/stub/ServerCalls.java\nindex 6c444551530..7990a5b34c0 100644\n--- a/stub/src/main/java/io/grpc/stub/ServerCalls.java\n+++ b/stub/src/main/java/io/grpc/stub/ServerCalls.java\n@@ -335,7 +335,6 @@ private static final class ServerCallStreamObserverImpl<ReqT, RespT>\n     private boolean aborted = false;\n     private boolean completed = false;\n     private Runnable onCloseHandler;\n-    private RespT unaryResponse;\n \n     // Non private to avoid synthetic class\n     ServerCallStreamObserverImpl(ServerCall<ReqT, RespT> call, boolean serverStreamingOrBidi) {\n@@ -374,22 +373,15 @@ public void onNext(RespT response) {\n       }\n       checkState(!aborted, \"Stream was terminated by error, no further calls are allowed\");\n       checkState(!completed, \"Stream is already completed, no further calls are allowed\");\n-      if (serverStreamingOrBidi) {\n-        if (!sentHeaders) {\n-          call.sendHeaders(new Metadata());\n-          sentHeaders = true;\n-        }\n-        call.sendMessage(response);\n-      } else {\n-        unaryResponse = response;\n+      if (!sentHeaders) {\n+        call.sendHeaders(new Metadata());\n+        sentHeaders = true;\n       }\n+      call.sendMessage(response);\n     }\n \n     @Override\n     public void onError(Throwable t) {\n-      if (!serverStreamingOrBidi) {\n-        unaryResponse = null;\n-      }\n       Metadata metadata = Status.trailersFromThrowable(t);\n       if (metadata == null) {\n         metadata = new Metadata();\n@@ -400,14 +392,6 @@ public void onError(Throwable t) {\n \n     @Override\n     public void onCompleted() {\n-      if (!serverStreamingOrBidi && unaryResponse != null) {\n-        if (!sentHeaders) {\n-          call.sendHeaders(new Metadata());\n-          sentHeaders = true;\n-        }\n-        call.sendMessage(unaryResponse);\n-        unaryResponse = null;\n-      }\n       call.close(Status.OK, new Metadata());\n       completed = true;\n     }\n",
    "test_patch": "diff --git a/stub/src/test/java/io/grpc/stub/ServerCallsTest.java b/stub/src/test/java/io/grpc/stub/ServerCallsTest.java\nindex 8d65be19e20..1e51ac10110 100644\n--- a/stub/src/test/java/io/grpc/stub/ServerCallsTest.java\n+++ b/stub/src/test/java/io/grpc/stub/ServerCallsTest.java\n@@ -33,7 +33,6 @@\n import io.grpc.ServerServiceDefinition;\n import io.grpc.ServiceDescriptor;\n import io.grpc.Status;\n-import io.grpc.Status.Code;\n import io.grpc.StatusRuntimeException;\n import io.grpc.inprocess.InProcessChannelBuilder;\n import io.grpc.inprocess.InProcessServerBuilder;\n@@ -621,59 +620,6 @@ public void onClose(Status status, Metadata trailers) {\n     assertArrayEquals(new int[]{0, 1, 1, 2, 2, 2}, receivedMessages);\n   }\n \n-  @Test\n-  public void serverUnaryResponseMsgWithOkStatus() {\n-    ServerCallHandler<Integer, Integer> serverCallHandler =\n-        ServerCalls.asyncUnaryCall(\n-            new ServerCalls.UnaryMethod<Integer, Integer>() {\n-              @Override\n-              public void invoke(Integer request, StreamObserver<Integer> responseObserver) {\n-                responseObserver.onNext(request);\n-                responseObserver.onCompleted();\n-              }\n-            });\n-    ServerCall.Listener<Integer> callListener =\n-        serverCallHandler.startCall(serverCall, new Metadata());\n-    serverCall.isReady = true;\n-    serverCall.isCancelled = false;\n-    callListener.onReady();\n-    callListener.onMessage(1);\n-    callListener.onHalfClose();\n-\n-    assertThat(serverCall.status.getCode()).isEqualTo(Code.OK);\n-    assertThat(serverCall.responses).containsExactly(1);\n-  }\n-\n-  @Test\n-  public void serverUnaryResponseMsgWithNotOkStatus() {\n-    ServerCallHandler<Integer, Integer> serverCallHandler =\n-        ServerCalls.asyncUnaryCall(\n-            new ServerCalls.UnaryMethod<Integer, Integer>() {\n-              @Override\n-              public void invoke(Integer request, StreamObserver<Integer> responseObserver) {\n-                responseObserver.onNext(request);\n-                responseObserver.onError(\n-                    Status.INTERNAL\n-                        .withDescription(\"Response message is null for unary call\")\n-                        .asRuntimeException());\n-              }\n-            });\n-\n-    ServerCall.Listener<Integer> callListener =\n-        serverCallHandler.startCall(serverCall, new Metadata());\n-\n-    serverCall.isReady = true;\n-    serverCall.isCancelled = false;\n-    callListener.onReady();\n-    callListener.onMessage(1);\n-    callListener.onHalfClose();\n-\n-    assertThat(serverCall.status.getCode()).isEqualTo(Code.INTERNAL);\n-    assertThat(serverCall.status.getDescription())\n-        .isEqualTo(\"Response message is null for unary call\");\n-    assertThat(serverCall.responses).isEmpty();\n-  }\n-\n   public static class IntegerMarshaller implements MethodDescriptor.Marshaller<Integer> {\n     @Override\n     public InputStream stream(Integer value) {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11610",
    "pr_id": 11610,
    "issue_id": 5969,
    "repo": "grpc/grpc-java",
    "problem_statement": "async server: need to ignore unary response msg if status is not OK\nThe expectation for unary responses is that the server will respond with an message or an error. If the server responds with a message and an error, the message should be thrown away. The async API currently would send the message. For unary responses, we should delay sending the response until the onComplete()/onError(). If onError() is called we should not send the message.\r\n\r\nhttps://github.com/grpc/grpc-java/blob/b22017851560197a41015acd90f443f7b9519984/stub/src/main/java/io/grpc/stub/ServerCalls.java#L336-L349\r\n\r\nSee #5968 and grpc/grpc#12824",
    "issue_word_count": 102,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "stub/src/main/java/io/grpc/stub/ServerCalls.java",
      "stub/src/test/java/io/grpc/stub/ServerCallsTest.java"
    ],
    "pr_changed_test_files": [
      "stub/src/test/java/io/grpc/stub/ServerCallsTest.java"
    ],
    "base_commit": "2129078deeef481767f85bc134cfc3d2b28ac4e9",
    "head_commit": "a08417c89324be9c2339756a978a662391ead36b",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11610",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11610",
    "dockerfile": "",
    "pr_merged_at": "2024-10-16T16:23:22.000Z",
    "patch": "diff --git a/stub/src/main/java/io/grpc/stub/ServerCalls.java b/stub/src/main/java/io/grpc/stub/ServerCalls.java\nindex 7990a5b34c0..6c444551530 100644\n--- a/stub/src/main/java/io/grpc/stub/ServerCalls.java\n+++ b/stub/src/main/java/io/grpc/stub/ServerCalls.java\n@@ -335,6 +335,7 @@ private static final class ServerCallStreamObserverImpl<ReqT, RespT>\n     private boolean aborted = false;\n     private boolean completed = false;\n     private Runnable onCloseHandler;\n+    private RespT unaryResponse;\n \n     // Non private to avoid synthetic class\n     ServerCallStreamObserverImpl(ServerCall<ReqT, RespT> call, boolean serverStreamingOrBidi) {\n@@ -373,15 +374,22 @@ public void onNext(RespT response) {\n       }\n       checkState(!aborted, \"Stream was terminated by error, no further calls are allowed\");\n       checkState(!completed, \"Stream is already completed, no further calls are allowed\");\n-      if (!sentHeaders) {\n-        call.sendHeaders(new Metadata());\n-        sentHeaders = true;\n+      if (serverStreamingOrBidi) {\n+        if (!sentHeaders) {\n+          call.sendHeaders(new Metadata());\n+          sentHeaders = true;\n+        }\n+        call.sendMessage(response);\n+      } else {\n+        unaryResponse = response;\n       }\n-      call.sendMessage(response);\n     }\n \n     @Override\n     public void onError(Throwable t) {\n+      if (!serverStreamingOrBidi) {\n+        unaryResponse = null;\n+      }\n       Metadata metadata = Status.trailersFromThrowable(t);\n       if (metadata == null) {\n         metadata = new Metadata();\n@@ -392,6 +400,14 @@ public void onError(Throwable t) {\n \n     @Override\n     public void onCompleted() {\n+      if (!serverStreamingOrBidi && unaryResponse != null) {\n+        if (!sentHeaders) {\n+          call.sendHeaders(new Metadata());\n+          sentHeaders = true;\n+        }\n+        call.sendMessage(unaryResponse);\n+        unaryResponse = null;\n+      }\n       call.close(Status.OK, new Metadata());\n       completed = true;\n     }\n",
    "test_patch": "diff --git a/stub/src/test/java/io/grpc/stub/ServerCallsTest.java b/stub/src/test/java/io/grpc/stub/ServerCallsTest.java\nindex 1e51ac10110..8d65be19e20 100644\n--- a/stub/src/test/java/io/grpc/stub/ServerCallsTest.java\n+++ b/stub/src/test/java/io/grpc/stub/ServerCallsTest.java\n@@ -33,6 +33,7 @@\n import io.grpc.ServerServiceDefinition;\n import io.grpc.ServiceDescriptor;\n import io.grpc.Status;\n+import io.grpc.Status.Code;\n import io.grpc.StatusRuntimeException;\n import io.grpc.inprocess.InProcessChannelBuilder;\n import io.grpc.inprocess.InProcessServerBuilder;\n@@ -620,6 +621,59 @@ public void onClose(Status status, Metadata trailers) {\n     assertArrayEquals(new int[]{0, 1, 1, 2, 2, 2}, receivedMessages);\n   }\n \n+  @Test\n+  public void serverUnaryResponseMsgWithOkStatus() {\n+    ServerCallHandler<Integer, Integer> serverCallHandler =\n+        ServerCalls.asyncUnaryCall(\n+            new ServerCalls.UnaryMethod<Integer, Integer>() {\n+              @Override\n+              public void invoke(Integer request, StreamObserver<Integer> responseObserver) {\n+                responseObserver.onNext(request);\n+                responseObserver.onCompleted();\n+              }\n+            });\n+    ServerCall.Listener<Integer> callListener =\n+        serverCallHandler.startCall(serverCall, new Metadata());\n+    serverCall.isReady = true;\n+    serverCall.isCancelled = false;\n+    callListener.onReady();\n+    callListener.onMessage(1);\n+    callListener.onHalfClose();\n+\n+    assertThat(serverCall.status.getCode()).isEqualTo(Code.OK);\n+    assertThat(serverCall.responses).containsExactly(1);\n+  }\n+\n+  @Test\n+  public void serverUnaryResponseMsgWithNotOkStatus() {\n+    ServerCallHandler<Integer, Integer> serverCallHandler =\n+        ServerCalls.asyncUnaryCall(\n+            new ServerCalls.UnaryMethod<Integer, Integer>() {\n+              @Override\n+              public void invoke(Integer request, StreamObserver<Integer> responseObserver) {\n+                responseObserver.onNext(request);\n+                responseObserver.onError(\n+                    Status.INTERNAL\n+                        .withDescription(\"Response message is null for unary call\")\n+                        .asRuntimeException());\n+              }\n+            });\n+\n+    ServerCall.Listener<Integer> callListener =\n+        serverCallHandler.startCall(serverCall, new Metadata());\n+\n+    serverCall.isReady = true;\n+    serverCall.isCancelled = false;\n+    callListener.onReady();\n+    callListener.onMessage(1);\n+    callListener.onHalfClose();\n+\n+    assertThat(serverCall.status.getCode()).isEqualTo(Code.INTERNAL);\n+    assertThat(serverCall.status.getDescription())\n+        .isEqualTo(\"Response message is null for unary call\");\n+    assertThat(serverCall.responses).isEmpty();\n+  }\n+\n   public static class IntegerMarshaller implements MethodDescriptor.Marshaller<Integer> {\n     @Override\n     public InputStream stream(Integer value) {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11604",
    "pr_id": 11604,
    "issue_id": 5494,
    "repo": "grpc/grpc-java",
    "problem_statement": "Channelz should use milliseconds for timestamps\n#4883 changed the `TimeProvider.currentTimeNanos()`'s precision to milliseconds, because there isn't a way to get the current time in nanoseconds precision. After #5056 is fixed, Channelz/ChannelTracer will be the only users of `TimeProvider`, and they all convert the time to proto `Timestamp` which doesn't mandate the unit. It will only be misleading to keep `TimeProvider.currentTimeNanos()` as is. It should be changed to `currentTimeMillis()`.\r\n",
    "issue_word_count": 74,
    "test_files_count": 2,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "core/src/main/java/io/grpc/internal/ConcurrentTimeProvider.java",
      "core/src/main/java/io/grpc/internal/InstantTimeProvider.java",
      "core/src/main/java/io/grpc/internal/TimeProvider.java",
      "core/src/main/java/io/grpc/internal/TimeProviderResolverFactory.java",
      "core/src/test/java/io/grpc/internal/ConcurrentTimeProviderTest.java",
      "core/src/test/java/io/grpc/internal/InstantTimeProviderTest.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/ConcurrentTimeProviderTest.java",
      "core/src/test/java/io/grpc/internal/InstantTimeProviderTest.java"
    ],
    "base_commit": "2129078deeef481767f85bc134cfc3d2b28ac4e9",
    "head_commit": "d637a36f42452bc0ac5baf61255123e444206a0e",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11604",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11604",
    "dockerfile": "",
    "pr_merged_at": "2024-10-29T04:49:47.000Z",
    "patch": "diff --git a/core/src/main/java/io/grpc/internal/ConcurrentTimeProvider.java b/core/src/main/java/io/grpc/internal/ConcurrentTimeProvider.java\nnew file mode 100644\nindex 00000000000..c82a68222b4\n--- /dev/null\n+++ b/core/src/main/java/io/grpc/internal/ConcurrentTimeProvider.java\n@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2024 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * {@link ConcurrentTimeProvider} resolves ConcurrentTimeProvider which implements\n+ * {@link TimeProvider}.\n+ */\n+\n+final class ConcurrentTimeProvider implements TimeProvider {\n+\n+  @Override\n+  public long currentTimeNanos() {\n+    return TimeUnit.MILLISECONDS.toNanos(System.currentTimeMillis());\n+  }\n+}\n\ndiff --git a/core/src/main/java/io/grpc/internal/InstantTimeProvider.java b/core/src/main/java/io/grpc/internal/InstantTimeProvider.java\nnew file mode 100644\nindex 00000000000..38c840d2594\n--- /dev/null\n+++ b/core/src/main/java/io/grpc/internal/InstantTimeProvider.java\n@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2024 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.math.LongMath.saturatedAdd;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * {@link InstantTimeProvider} resolves InstantTimeProvider which implements {@link TimeProvider}.\n+ */\n+final class InstantTimeProvider implements TimeProvider {\n+  private Method now;\n+  private Method getNano;\n+  private Method getEpochSecond;\n+\n+  public InstantTimeProvider(Class<?> instantClass) {\n+    try {\n+      this.now = instantClass.getMethod(\"now\");\n+      this.getNano = instantClass.getMethod(\"getNano\");\n+      this.getEpochSecond = instantClass.getMethod(\"getEpochSecond\");\n+    } catch (NoSuchMethodException ex) {\n+      throw new AssertionError(ex);\n+    }\n+  }\n+\n+  @Override\n+  public long currentTimeNanos() {\n+    try {\n+      Object instant = now.invoke(null);\n+      int nanos = (int) getNano.invoke(instant);\n+      long epochSeconds = (long) getEpochSecond.invoke(instant);\n+      return saturatedAdd(TimeUnit.SECONDS.toNanos(epochSeconds), nanos);\n+    } catch (IllegalAccessException | InvocationTargetException ex) {\n+      throw new RuntimeException(ex);\n+    }\n+  }\n+}\n\ndiff --git a/core/src/main/java/io/grpc/internal/TimeProvider.java b/core/src/main/java/io/grpc/internal/TimeProvider.java\nindex b0ea147ada1..3bd052ab3e0 100644\n--- a/core/src/main/java/io/grpc/internal/TimeProvider.java\n+++ b/core/src/main/java/io/grpc/internal/TimeProvider.java\n@@ -16,8 +16,6 @@\n \n package io.grpc.internal;\n \n-import java.util.concurrent.TimeUnit;\n-\n /**\n  * Time source representing the current system time in nanos. Used to inject a fake clock\n  * into unit tests.\n@@ -26,10 +24,5 @@ public interface TimeProvider {\n   /** Returns the current nano time. */\n   long currentTimeNanos();\n \n-  TimeProvider SYSTEM_TIME_PROVIDER = new TimeProvider() {\n-    @Override\n-    public long currentTimeNanos() {\n-      return TimeUnit.MILLISECONDS.toNanos(System.currentTimeMillis());\n-    }\n-  };\n+  TimeProvider SYSTEM_TIME_PROVIDER = TimeProviderResolverFactory.resolveTimeProvider();\n }\n\ndiff --git a/core/src/main/java/io/grpc/internal/TimeProviderResolverFactory.java b/core/src/main/java/io/grpc/internal/TimeProviderResolverFactory.java\nnew file mode 100644\nindex 00000000000..d88d9bb9eb5\n--- /dev/null\n+++ b/core/src/main/java/io/grpc/internal/TimeProviderResolverFactory.java\n@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2024 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+/**\n+ * {@link TimeProviderResolverFactory} resolves Time providers.\n+ */\n+\n+final class TimeProviderResolverFactory {\n+  static TimeProvider resolveTimeProvider() {\n+    try {\n+      Class<?> instantClass = Class.forName(\"java.time.Instant\");\n+      return new InstantTimeProvider(instantClass);\n+    } catch (ClassNotFoundException ex) {\n+      return new ConcurrentTimeProvider();\n+    }\n+  }\n+}\n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/ConcurrentTimeProviderTest.java b/core/src/test/java/io/grpc/internal/ConcurrentTimeProviderTest.java\nnew file mode 100644\nindex 00000000000..a02cb6a6e42\n--- /dev/null\n+++ b/core/src/test/java/io/grpc/internal/ConcurrentTimeProviderTest.java\n@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2024 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import java.time.Instant;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link ConcurrentTimeProvider}.\n+ */\n+@RunWith(JUnit4.class)\n+public class ConcurrentTimeProviderTest {\n+  @Test\n+  public void testConcurrentCurrentTimeNanos() {\n+\n+    ConcurrentTimeProvider concurrentTimeProvider = new ConcurrentTimeProvider();\n+    // Get the current time from the ConcurrentTimeProvider\n+    long actualTimeNanos = concurrentTimeProvider.currentTimeNanos();\n+\n+    // Get the current time from Instant for comparison\n+    Instant instantNow = Instant.now();\n+    long expectedTimeNanos = TimeUnit.SECONDS.toNanos(instantNow.getEpochSecond())\n+        + instantNow.getNano();\n+\n+    // Validate the time returned is close to the expected value within a tolerance\n+    // (i,e 10 millisecond tolerance in nanoseconds).\n+    assertThat(actualTimeNanos).isWithin(10_000_000L).of(expectedTimeNanos);\n+  }\n+}\n\ndiff --git a/core/src/test/java/io/grpc/internal/InstantTimeProviderTest.java b/core/src/test/java/io/grpc/internal/InstantTimeProviderTest.java\nnew file mode 100644\nindex 00000000000..ef97d374b10\n--- /dev/null\n+++ b/core/src/test/java/io/grpc/internal/InstantTimeProviderTest.java\n@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2024 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import java.time.Instant;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link InstantTimeProvider}.\n+ */\n+@RunWith(JUnit4.class)\n+public class InstantTimeProviderTest {\n+  @Test\n+  public void testInstantCurrentTimeNanos() throws Exception {\n+\n+    InstantTimeProvider instantTimeProvider = new InstantTimeProvider(\n+        Class.forName(\"java.time.Instant\"));\n+\n+    // Get the current time from the InstantTimeProvider\n+    long actualTimeNanos = instantTimeProvider.currentTimeNanos();\n+\n+    // Get the current time from Instant for comparison\n+    Instant instantNow = Instant.now();\n+    long expectedTimeNanos = TimeUnit.SECONDS.toNanos(instantNow.getEpochSecond())\n+          + instantNow.getNano();\n+\n+    // Validate the time returned is close to the expected value within a tolerance\n+    // (i,e 10 millisecond tolerance in nanoseconds).\n+    assertThat(actualTimeNanos).isWithin(10_000_000L).of(expectedTimeNanos);\n+  }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11593",
    "pr_id": 11593,
    "issue_id": 3353,
    "repo": "grpc/grpc-java",
    "problem_statement": "Resource leak in netty tests\nI haven't tracked down the responsible, but I ran with leak detection and found this:\r\n\r\n```\r\nAug 16, 2017 10:58:18 AM io.netty.util.ResourceLeakDetector reportTracedLeak\r\nSEVERE: LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.\r\nWARNING: 3 leak records were discarded because the leak record count is limited to 4. Use system property io.netty.leakDetection.maxRecords to increase the limit.\r\nRecent access records: 4\r\n#4:\r\n\tio.netty.buffer.AdvancedLeakAwareByteBuf.release(AdvancedLeakAwareByteBuf.java:936)\r\n\tio.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:84)\r\n\tio.netty.util.ReferenceCountUtil.safeRelease(ReferenceCountUtil.java:109)\r\n\tio.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:256)\r\n\tio.netty.channel.embedded.EmbeddedChannel.doWrite(EmbeddedChannel.java:723)\r\n\tio.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:872)\r\n\tio.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:839)\r\n\tio.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1.flush(EmbeddedChannel.java:819)\r\n\tio.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1321)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:768)\r\n\tio.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:749)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler.flush(Http2ConnectionHandler.java:191)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler.channelReadComplete(Http2ConnectionHandler.java:509)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:398)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:380)\r\n\tio.netty.channel.AbstractChannelHandlerContext.fireChannelReadComplete(AbstractChannelHandlerContext.java:373)\r\n\tio.netty.channel.DefaultChannelPipeline$HeadContext.channelReadComplete(DefaultChannelPipeline.java:1364)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:398)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:380)\r\n\tio.netty.channel.DefaultChannelPipeline.fireChannelReadComplete(DefaultChannelPipeline.java:941)\r\n\tio.netty.channel.embedded.EmbeddedChannel.flushInbound(EmbeddedChannel.java:359)\r\n\tio.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:320)\r\n\tio.grpc.netty.NettyHandlerTestBase.channelRead(NettyHandlerTestBase.java:140)\r\n\tio.grpc.netty.NettyServerHandlerTest.manualSetUp(NettyServerHandlerTest.java:163)\r\n\tio.grpc.netty.NettyServerHandlerTest.headersWithInvalidContentTypeShouldFail(NettyServerHandlerTest.java:356)\r\n\tsun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tjava.lang.reflect.Method.invoke(Method.java:498)\r\n\torg.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\r\n\torg.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n\torg.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:49)\r\n\torg.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n\torg.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:73)\r\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:273)\r\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)\r\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\r\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:240)\r\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:65)\r\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:238)\r\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:55)\r\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:231)\r\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:316)\r\n#3:\r\n\tio.netty.buffer.AdvancedLeakAwareByteBuf.retain(AdvancedLeakAwareByteBuf.java:924)\r\n\tio.netty.buffer.AdvancedLeakAwareByteBuf.retain(AdvancedLeakAwareByteBuf.java:35)\r\n\tio.netty.util.ReferenceCountUtil.retain(ReferenceCountUtil.java:36)\r\n\tio.netty.channel.embedded.EmbeddedChannel.doWrite(EmbeddedChannel.java:721)\r\n\tio.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:872)\r\n\tio.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:839)\r\n\tio.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe$1.flush(EmbeddedChannel.java:819)\r\n\tio.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1321)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:776)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:768)\r\n\tio.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:749)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler.flush(Http2ConnectionHandler.java:191)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler.channelReadComplete(Http2ConnectionHandler.java:509)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:398)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:380)\r\n\tio.netty.channel.AbstractChannelHandlerContext.fireChannelReadComplete(AbstractChannelHandlerContext.java:373)\r\n\tio.netty.channel.DefaultChannelPipeline$HeadContext.channelReadComplete(DefaultChannelPipeline.java:1364)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:398)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:380)\r\n\tio.netty.channel.DefaultChannelPipeline.fireChannelReadComplete(DefaultChannelPipeline.java:941)\r\n\tio.netty.channel.embedded.EmbeddedChannel.flushInbound(EmbeddedChannel.java:359)\r\n\tio.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:320)\r\n\tio.grpc.netty.NettyHandlerTestBase.channelRead(NettyHandlerTestBase.java:140)\r\n\tio.grpc.netty.NettyServerHandlerTest.manualSetUp(NettyServerHandlerTest.java:163)\r\n\tio.grpc.netty.NettyServerHandlerTest.headersWithInvalidContentTypeShouldFail(NettyServerHandlerTest.java:356)\r\n\tsun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tjava.lang.reflect.Method.invoke(Method.java:498)\r\n\torg.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\r\n\torg.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n\torg.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:49)\r\n\torg.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n\torg.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:73)\r\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:273)\r\n#2:\r\n\tHint: 'DefaultChannelPipeline$HeadContext#0' will handle the message from this point.\r\n\tio.netty.channel.DefaultChannelPipeline.touch(DefaultChannelPipeline.java:116)\r\n\tio.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:810)\r\n\tio.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:723)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameWriter.writeSettingsAck(DefaultHttp2FrameWriter.java:260)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d.CGLIB$writeSettingsAck$6(<generated>)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d$$FastClassByMockitoWithCGLIB$$af30f311.invoke(<generated>)\r\n\torg.mockito.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:216)\r\n\torg.mockito.internal.creation.AbstractMockitoMethodProxy.invokeSuper(AbstractMockitoMethodProxy.java:10)\r\n\torg.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod.invoke(CGLIBProxyRealMethod.java:22)\r\n\torg.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.invoke(FilteredCGLIBProxyRealMethod.java:27)\r\n\torg.mockito.internal.invocation.InvocationImpl.callRealMethod(InvocationImpl.java:108)\r\n\torg.mockito.internal.stubbing.answers.CallsRealMethods.answer(CallsRealMethods.java:36)\r\n\torg.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:93)\r\n\torg.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)\r\n\torg.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:38)\r\n\torg.mockito.internal.creation.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:51)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d.writeSettingsAck(<generated>)\r\n\tio.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeSettingsAck(DecoratingHttp2FrameWriter.java:75)\r\n\tio.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeSettingsAck(DefaultHttp2ConnectionEncoder.java:264)\r\n\tio.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onSettingsRead(DefaultHttp2ConnectionDecoder.java:419)\r\n\tio.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener.onSettingsRead(DefaultHttp2ConnectionDecoder.java:635)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameReader.readSettingsFrame(DefaultHttp2FrameReader.java:542)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:263)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)\r\n\tio.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:118)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:373)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:244)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:433)\r\n\tio.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:492)\r\n\tio.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:431)\r\n\tio.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tio.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tio.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)\r\n\tio.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:317)\r\n\tio.grpc.netty.NettyHandlerTestBase.channelRead(NettyHandlerTestBase.java:140)\r\n\tio.grpc.netty.NettyServerHandlerTest.manualSetUp(NettyServerHandlerTest.java:163)\r\n\tio.grpc.netty.NettyServerHandlerTest.headersWithInvalidContentTypeShouldFail(NettyServerHandlerTest.java:356)\r\n\tsun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tjava.lang.reflect.Method.invoke(Method.java:498)\r\n\torg.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\r\n\torg.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n\torg.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:49)\r\n\torg.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n\torg.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:73)\r\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:273)\r\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)\r\n\r\n#1:\r\n\tio.netty.buffer.AdvancedLeakAwareByteBuf.writeInt(AdvancedLeakAwareByteBuf.java:558)\r\n\tio.netty.handler.codec.http2.Http2CodecUtil.writeFrameHeaderInternal(Http2CodecUtil.java:260)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameWriter.writeSettingsAck(DefaultHttp2FrameWriter.java:259)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d.CGLIB$writeSettingsAck$6(<generated>)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d$$FastClassByMockitoWithCGLIB$$af30f311.invoke(<generated>)\r\n\torg.mockito.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:216)\r\n\torg.mockito.internal.creation.AbstractMockitoMethodProxy.invokeSuper(AbstractMockitoMethodProxy.java:10)\r\n\torg.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod.invoke(CGLIBProxyRealMethod.java:22)\r\n\torg.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.invoke(FilteredCGLIBProxyRealMethod.java:27)\r\n\torg.mockito.internal.invocation.InvocationImpl.callRealMethod(InvocationImpl.java:108)\r\n\torg.mockito.internal.stubbing.answers.CallsRealMethods.answer(CallsRealMethods.java:36)\r\n\torg.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:93)\r\n\torg.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)\r\n\torg.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:38)\r\n\torg.mockito.internal.creation.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:51)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d.writeSettingsAck(<generated>)\r\n\tio.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeSettingsAck(DecoratingHttp2FrameWriter.java:75)\r\n\tio.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeSettingsAck(DefaultHttp2ConnectionEncoder.java:264)\r\n\tio.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onSettingsRead(DefaultHttp2ConnectionDecoder.java:419)\r\n\tio.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener.onSettingsRead(DefaultHttp2ConnectionDecoder.java:635)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameReader.readSettingsFrame(DefaultHttp2FrameReader.java:542)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:263)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)\r\n\tio.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:118)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:373)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:244)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:433)\r\n\tio.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:492)\r\n\tio.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:431)\r\n\tio.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tio.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tio.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)\r\n\tio.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:317)\r\n\tio.grpc.netty.NettyHandlerTestBase.channelRead(NettyHandlerTestBase.java:140)\r\n\tio.grpc.netty.NettyServerHandlerTest.manualSetUp(NettyServerHandlerTest.java:163)\r\n\tio.grpc.netty.NettyServerHandlerTest.headersWithInvalidContentTypeShouldFail(NettyServerHandlerTest.java:356)\r\n\tsun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tjava.lang.reflect.Method.invoke(Method.java:498)\r\n\torg.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\r\n\torg.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n\torg.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:49)\r\n\torg.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n\torg.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:73)\r\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:273)\r\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)\r\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\r\n\r\nCreated at:\r\n\tio.netty.util.ResourceLeakDetector.track(ResourceLeakDetector.java:237)\r\n\tio.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:331)\r\n\tio.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:181)\r\n\tio.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:172)\r\n\tio.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:109)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameWriter.writeSettingsAck(DefaultHttp2FrameWriter.java:258)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d.CGLIB$writeSettingsAck$6(<generated>)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d$$FastClassByMockitoWithCGLIB$$af30f311.invoke(<generated>)\r\n\torg.mockito.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:216)\r\n\torg.mockito.internal.creation.AbstractMockitoMethodProxy.invokeSuper(AbstractMockitoMethodProxy.java:10)\r\n\torg.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod.invoke(CGLIBProxyRealMethod.java:22)\r\n\torg.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.invoke(FilteredCGLIBProxyRealMethod.java:27)\r\n\torg.mockito.internal.invocation.InvocationImpl.callRealMethod(InvocationImpl.java:108)\r\n\torg.mockito.internal.stubbing.answers.CallsRealMethods.answer(CallsRealMethods.java:36)\r\n\torg.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:93)\r\n\torg.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)\r\n\torg.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:38)\r\n\torg.mockito.internal.creation.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:51)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameWriter$$EnhancerByMockitoWithCGLIB$$a575c56d.writeSettingsAck(<generated>)\r\n\tio.netty.handler.codec.http2.DecoratingHttp2FrameWriter.writeSettingsAck(DecoratingHttp2FrameWriter.java:75)\r\n\tio.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder.writeSettingsAck(DefaultHttp2ConnectionEncoder.java:264)\r\n\tio.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onSettingsRead(DefaultHttp2ConnectionDecoder.java:419)\r\n\tio.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener.onSettingsRead(DefaultHttp2ConnectionDecoder.java:635)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameReader.readSettingsFrame(DefaultHttp2FrameReader.java:542)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:263)\r\n\tio.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)\r\n\tio.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:118)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:373)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:244)\r\n\tio.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:433)\r\n\tio.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:492)\r\n\tio.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:431)\r\n\tio.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tio.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tio.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)\r\n\tio.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:317)\r\n\tio.grpc.netty.NettyHandlerTestBase.channelRead(NettyHandlerTestBase.java:140)\r\n\tio.grpc.netty.NettyServerHandlerTest.manualSetUp(NettyServerHandlerTest.java:163)\r\n\tio.grpc.netty.NettyServerHandlerTest.headersWithInvalidContentTypeShouldFail(NettyServerHandlerTest.java:356)\r\n\tsun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tjava.lang.reflect.Method.invoke(Method.java:498)\r\n\torg.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\r\n\torg.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n\torg.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:49)\r\n\torg.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n\torg.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:73)\r\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:273)\r\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)\r\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\r\n\r\n```",
    "issue_word_count": 2254,
    "test_files_count": 3,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "netty/src/test/java/io/grpc/netty/NettyClientHandlerTest.java",
      "netty/src/test/java/io/grpc/netty/NettyHandlerTestBase.java",
      "netty/src/test/java/io/grpc/netty/NettyServerHandlerTest.java"
    ],
    "pr_changed_test_files": [
      "netty/src/test/java/io/grpc/netty/NettyClientHandlerTest.java",
      "netty/src/test/java/io/grpc/netty/NettyHandlerTestBase.java",
      "netty/src/test/java/io/grpc/netty/NettyServerHandlerTest.java"
    ],
    "base_commit": "2129078deeef481767f85bc134cfc3d2b28ac4e9",
    "head_commit": "da6595d2fb2a8f9ddbbaadfc65d9a2a2d1518e3e",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11593",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11593",
    "dockerfile": "",
    "pr_merged_at": "2024-12-02T19:09:25.000Z",
    "patch": "",
    "test_patch": "diff --git a/netty/src/test/java/io/grpc/netty/NettyClientHandlerTest.java b/netty/src/test/java/io/grpc/netty/NettyClientHandlerTest.java\nindex 73988f773cb..56f7a75648f 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyClientHandlerTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyClientHandlerTest.java\n@@ -215,6 +215,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {\n     // Simulate receipt of initial remote settings.\n     ByteBuf serializedSettings = serializeSettings(new Http2Settings());\n     channelRead(serializedSettings);\n+    channel().releaseOutbound();\n   }\n \n   @Test\n@@ -310,11 +311,12 @@ public void sendFrameShouldSucceed() throws Exception {\n     createStream();\n \n     // Send a frame and verify that it was written.\n+    ByteBuf content = content();\n     ChannelFuture future\n-        = enqueue(new SendGrpcFrameCommand(streamTransportState, content(), true));\n+        = enqueue(new SendGrpcFrameCommand(streamTransportState, content, true));\n \n     assertTrue(future.isSuccess());\n-    verifyWrite().writeData(eq(ctx()), eq(STREAM_ID), eq(content()), eq(0), eq(true),\n+    verifyWrite().writeData(eq(ctx()), eq(STREAM_ID), same(content), eq(0), eq(true),\n         any(ChannelPromise.class));\n     verify(mockKeepAliveManager, times(1)).onTransportActive(); // onStreamActive\n     verifyNoMoreInteractions(mockKeepAliveManager);\n\ndiff --git a/netty/src/test/java/io/grpc/netty/NettyHandlerTestBase.java b/netty/src/test/java/io/grpc/netty/NettyHandlerTestBase.java\nindex eef8d30e05a..c971294fbb6 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyHandlerTestBase.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyHandlerTestBase.java\n@@ -38,7 +38,6 @@\n import io.grpc.internal.WritableBuffer;\n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufAllocator;\n-import io.netty.buffer.ByteBufUtil;\n import io.netty.buffer.CompositeByteBuf;\n import io.netty.buffer.Unpooled;\n import io.netty.buffer.UnpooledByteBufAllocator;\n@@ -68,6 +67,7 @@\n import java.nio.ByteBuffer;\n import java.util.concurrent.Delayed;\n import java.util.concurrent.TimeUnit;\n+import org.junit.After;\n import org.junit.Assert;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -84,7 +84,6 @@\n public abstract class NettyHandlerTestBase<T extends Http2ConnectionHandler> {\n \n   protected static final int STREAM_ID = 3;\n-  private ByteBuf content;\n \n   private EmbeddedChannel channel;\n \n@@ -106,18 +105,24 @@ protected void manualSetUp() throws Exception {}\n   protected final TransportTracer transportTracer = new TransportTracer();\n   protected int flowControlWindow = DEFAULT_WINDOW_SIZE;\n   protected boolean autoFlowControl = false;\n-\n   private final FakeClock fakeClock = new FakeClock();\n \n   FakeClock fakeClock() {\n     return fakeClock;\n   }\n \n+  @After\n+  public void tearDown() throws Exception {\n+    if (channel() != null) {\n+      channel().releaseInbound();\n+      channel().releaseOutbound();\n+    }\n+  }\n+\n   /**\n    * Must be called by subclasses to initialize the handler and channel.\n    */\n   protected final void initChannel(Http2HeadersDecoder headersDecoder) throws Exception {\n-    content = Unpooled.copiedBuffer(\"hello world\", UTF_8);\n     frameWriter = mock(Http2FrameWriter.class, delegatesTo(new DefaultHttp2FrameWriter()));\n     frameReader = new DefaultHttp2FrameReader(headersDecoder);\n \n@@ -233,11 +238,11 @@ protected final Http2FrameReader frameReader() {\n   }\n \n   protected final ByteBuf content() {\n-    return content;\n+    return Unpooled.copiedBuffer(contentAsArray());\n   }\n \n   protected final byte[] contentAsArray() {\n-    return ByteBufUtil.getBytes(content());\n+    return \"\\000\\000\\000\\000\\rhello world\".getBytes(UTF_8);\n   }\n \n   protected final Http2FrameWriter verifyWrite() {\n@@ -252,8 +257,8 @@ protected final void channelRead(Object obj) throws Exception {\n     channel.writeInbound(obj);\n   }\n \n-  protected ByteBuf grpcDataFrame(int streamId, boolean endStream, byte[] content) {\n-    final ByteBuf compressionFrame = Unpooled.buffer(content.length);\n+  protected ByteBuf grpcFrame(byte[] message) {\n+    final ByteBuf compressionFrame = Unpooled.buffer(message.length);\n     MessageFramer framer = new MessageFramer(\n         new MessageFramer.Sink() {\n           @Override\n@@ -262,23 +267,22 @@ public void deliverFrame(\n             if (frame != null) {\n               ByteBuf bytebuf = ((NettyWritableBuffer) frame).bytebuf();\n               compressionFrame.writeBytes(bytebuf);\n+              bytebuf.release();\n             }\n           }\n         },\n         new NettyWritableBufferAllocator(ByteBufAllocator.DEFAULT),\n         StatsTraceContext.NOOP);\n-    framer.writePayload(new ByteArrayInputStream(content));\n-    framer.flush();\n-    ChannelHandlerContext ctx = newMockContext();\n-    new DefaultHttp2FrameWriter().writeData(ctx, streamId, compressionFrame, 0, endStream,\n-        newPromise());\n-    return captureWrite(ctx);\n+    framer.writePayload(new ByteArrayInputStream(message));\n+    framer.close();\n+    return compressionFrame;\n   }\n \n-  protected final ByteBuf dataFrame(int streamId, boolean endStream, ByteBuf content) {\n-    // Need to retain the content since the frameWriter releases it.\n-    content.retain();\n+  protected final ByteBuf grpcDataFrame(int streamId, boolean endStream, byte[] content) {\n+    return dataFrame(streamId, endStream, grpcFrame(content));\n+  }\n \n+  protected final ByteBuf dataFrame(int streamId, boolean endStream, ByteBuf content) {\n     ChannelHandlerContext ctx = newMockContext();\n     new DefaultHttp2FrameWriter().writeData(ctx, streamId, content, 0, endStream, newPromise());\n     return captureWrite(ctx);\n@@ -410,6 +414,7 @@ public void dataSizeSincePingAccumulates() throws Exception {\n     channelRead(dataFrame(3, false, buff.copy()));\n \n     assertEquals(length * 3, handler.flowControlPing().getDataSincePing());\n+    buff.release();\n   }\n \n   @Test\n@@ -608,12 +613,14 @@ public void bdpPingWindowResizing() throws Exception {\n \n   private void readPingAck(long pingData) throws Exception {\n     channelRead(pingFrame(true, pingData));\n+    channel().releaseOutbound();\n   }\n \n   private void readXCopies(int copies, byte[] data) throws Exception {\n     for (int i = 0; i < copies; i++) {\n       channelRead(grpcDataFrame(STREAM_ID, false, data)); // buffer it\n       stream().request(1); // consume it\n+      channel().releaseOutbound();\n     }\n   }\n \n\ndiff --git a/netty/src/test/java/io/grpc/netty/NettyServerHandlerTest.java b/netty/src/test/java/io/grpc/netty/NettyServerHandlerTest.java\nindex 541490847c0..5c659e78f2d 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyServerHandlerTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyServerHandlerTest.java\n@@ -43,6 +43,7 @@\n import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.ArgumentMatchers.isA;\n+import static org.mockito.ArgumentMatchers.same;\n import static org.mockito.Mockito.atLeastOnce;\n import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.doThrow;\n@@ -74,7 +75,6 @@\n import io.grpc.internal.testing.TestServerStreamTracer;\n import io.grpc.netty.GrpcHttp2HeadersUtils.GrpcHttp2ServerHeadersDecoder;\n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufUtil;\n import io.netty.channel.ChannelFuture;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelPromise;\n@@ -120,23 +120,16 @@ public class NettyServerHandlerTest extends NettyHandlerTestBase<NettyServerHand\n   public final TestRule globalTimeout = new DisableOnDebug(Timeout.seconds(10));\n   @Rule\n   public final MockitoRule mocks = MockitoJUnit.rule();\n-\n   private static final AsciiString HTTP_FAKE_METHOD = AsciiString.of(\"FAKE\");\n-\n-\n   @Mock\n   private ServerStreamListener streamListener;\n-\n   @Mock\n   private ServerStreamTracer.Factory streamTracerFactory;\n-\n   private final ServerTransportListener transportListener =\n       mock(ServerTransportListener.class, delegatesTo(new ServerTransportListenerImpl()));\n   private final TestServerStreamTracer streamTracer = new TestServerStreamTracer();\n-\n   private NettyServerStream stream;\n   private KeepAliveManager spyKeepAliveManager;\n-\n   final Queue<InputStream> streamListenerMessageQueue = new LinkedList<>();\n \n   private int maxConcurrentStreams = Integer.MAX_VALUE;\n@@ -207,6 +200,7 @@ protected void manualSetUp() throws Exception {\n     // Simulate receipt of initial remote settings.\n     ByteBuf serializedSettings = serializeSettings(new Http2Settings());\n     channelRead(serializedSettings);\n+    channel().releaseOutbound();\n   }\n \n   @Test\n@@ -228,10 +222,11 @@ public void sendFrameShouldSucceed() throws Exception {\n     createStream();\n \n     // Send a frame and verify that it was written.\n+    ByteBuf content = content();\n     ChannelFuture future = enqueue(\n-        new SendGrpcFrameCommand(stream.transportState(), content(), false));\n+        new SendGrpcFrameCommand(stream.transportState(), content, false));\n     assertTrue(future.isSuccess());\n-    verifyWrite().writeData(eq(ctx()), eq(STREAM_ID), eq(content()), eq(0), eq(false),\n+    verifyWrite().writeData(eq(ctx()), eq(STREAM_ID), same(content), eq(0), eq(false),\n         any(ChannelPromise.class));\n   }\n \n@@ -266,10 +261,11 @@ private void inboundDataShouldForwardToStreamListener(boolean endStream) throws\n     // Create a data frame and then trigger the handler to read it.\n     ByteBuf frame = grpcDataFrame(STREAM_ID, endStream, contentAsArray());\n     channelRead(frame);\n+    channel().releaseOutbound();\n     verify(streamListener, atLeastOnce())\n         .messagesAvailable(any(StreamListener.MessageProducer.class));\n     InputStream message = streamListenerMessageQueue.poll();\n-    assertArrayEquals(ByteBufUtil.getBytes(content()), ByteStreams.toByteArray(message));\n+    assertArrayEquals(contentAsArray(), ByteStreams.toByteArray(message));\n     message.close();\n     assertNull(\"no additional message expected\", streamListenerMessageQueue.poll());\n \n@@ -869,7 +865,7 @@ public void keepAliveEnforcer_sendingDataResetsCounters() throws Exception {\n     future.get();\n     for (int i = 0; i < 10; i++) {\n       future = enqueue(\n-          new SendGrpcFrameCommand(stream.transportState(), content().retainedSlice(), false));\n+          new SendGrpcFrameCommand(stream.transportState(), content(), false));\n       future.get();\n       channel().releaseOutbound();\n       channelRead(pingFrame(false /* isAck */, 1L));\n@@ -1292,6 +1288,7 @@ public void maxRstCount_withinLimit_succeeds() throws Exception {\n     maxRstPeriodNanos = TimeUnit.MILLISECONDS.toNanos(100);\n     manualSetUp();\n     rapidReset(maxRstCount);\n+\n     assertTrue(channel().isOpen());\n   }\n \n@@ -1301,6 +1298,7 @@ public void maxRstCount_exceedsLimit_fails() throws Exception {\n     maxRstPeriodNanos = TimeUnit.MILLISECONDS.toNanos(100);\n     manualSetUp();\n     assertThrows(ClosedChannelException.class, () -> rapidReset(maxRstCount + 1));\n+\n     assertFalse(channel().isOpen());\n   }\n \n@@ -1343,11 +1341,7 @@ private void createStream() throws Exception {\n \n   private ByteBuf emptyGrpcFrame(int streamId, boolean endStream) throws Exception {\n     ByteBuf buf = NettyTestUtil.messageFrame(\"\");\n-    try {\n-      return dataFrame(streamId, endStream, buf);\n-    } finally {\n-      buf.release();\n-    }\n+    return dataFrame(streamId, endStream, buf);\n   }\n \n   @Override\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11577",
    "pr_id": 11577,
    "issue_id": 11040,
    "repo": "grpc/grpc-java",
    "problem_statement": "Default service config not honored if initial name resolution fails\nIf the name resolution fails we are supposed to rely on the default service config since there is no way to get one via name resolution. This currently only happens if there has been at least one successful name resolution call. If the first name resolution fails, `ManagedChannelImpl` does not apply the service config.\r\n\r\n- The default config is applied in [NameResolverListener.onResult()](https://github.com/grpc/grpc-java/blob/f7ee5f3182dddde775069155d17ed93f7270f1ca/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java#L1749) when a successful response is retried\r\n- In [NameResolutionListener.onError()](https://github.com/grpc/grpc-java/blob/f7ee5f3182dddde775069155d17ed93f7270f1ca/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java#L1895) we do not apply the default service config.\r\n",
    "issue_word_count": 125,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java",
      "core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java"
    ],
    "base_commit": "d169a5de6fb94e974fd77ebabde52f01bc7aaca0",
    "head_commit": "46ef31e118cb687895e4b17ccc5591111c2b7954",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11577",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11577",
    "dockerfile": "",
    "pr_merged_at": "2024-10-01T05:51:08.000Z",
    "patch": "diff --git a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\nindex 07dcf9ee7bb..7e36086ac94 100644\n--- a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n+++ b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n@@ -956,7 +956,15 @@ void updateConfigSelector(@Nullable InternalConfigSelector config) {\n     // Must run in SynchronizationContext.\n     void onConfigError() {\n       if (configSelector.get() == INITIAL_PENDING_SELECTOR) {\n-        updateConfigSelector(null);\n+        // Apply Default Service Config if initial name resolution fails.\n+        if (defaultServiceConfig != null) {\n+          updateConfigSelector(defaultServiceConfig.getDefaultConfigSelector());\n+          lastServiceConfig = defaultServiceConfig;\n+          channelLogger.log(ChannelLogLevel.ERROR,\n+              \"Initial Name Resolution error, using default service config\");\n+        } else {\n+          updateConfigSelector(null);\n+        }\n       }\n     }\n \n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java b/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\nindex 4d42056b689..bea14bcef47 100644\n--- a/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\n+++ b/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\n@@ -84,6 +84,7 @@\n import io.grpc.InternalChannelz;\n import io.grpc.InternalChannelz.ChannelStats;\n import io.grpc.InternalChannelz.ChannelTrace;\n+import io.grpc.InternalChannelz.ChannelTrace.Event.Severity;\n import io.grpc.InternalConfigSelector;\n import io.grpc.InternalInstrumented;\n import io.grpc.LoadBalancer;\n@@ -123,6 +124,7 @@\n import io.grpc.internal.ManagedChannelImplBuilder.ClientTransportFactoryBuilder;\n import io.grpc.internal.ManagedChannelImplBuilder.FixedPortProvider;\n import io.grpc.internal.ManagedChannelImplBuilder.UnsupportedClientTransportFactoryBuilder;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n import io.grpc.internal.TestUtils.MockClientTransportInfo;\n import io.grpc.stub.ClientCalls;\n@@ -1127,6 +1129,55 @@ public void noMoreCallbackAfterLoadBalancerShutdown_configError() throws Interru\n     verifyNoMoreInteractions(mockLoadBalancer);\n   }\n \n+  @Test\n+  public void addressResolutionError_noPriorNameResolution_usesDefaultServiceConfig()\n+      throws Exception {\n+    Map<String, Object> rawServiceConfig =\n+        parseConfig(\"{\\\"methodConfig\\\":[{\"\n+            + \"\\\"name\\\":[{\\\"service\\\":\\\"service\\\"}],\"\n+            + \"\\\"waitForReady\\\":true}]}\");\n+    ManagedChannelServiceConfig managedChannelServiceConfig =\n+        createManagedChannelServiceConfig(rawServiceConfig, null);\n+    FakeNameResolverFactory nameResolverFactory =\n+        new FakeNameResolverFactory.Builder(expectedUri)\n+            .setServers(Collections.singletonList(new EquivalentAddressGroup(socketAddress)))\n+            .setResolvedAtStart(false)\n+            .build();\n+    nameResolverFactory.nextConfigOrError.set(\n+        ConfigOrError.fromConfig(managedChannelServiceConfig));\n+    channelBuilder.nameResolverFactory(nameResolverFactory);\n+    Map<String, Object> defaultServiceConfig =\n+        parseConfig(\"{\\\"methodConfig\\\":[{\"\n+            + \"\\\"name\\\":[{\\\"service\\\":\\\"service\\\"}],\"\n+            + \"\\\"waitForReady\\\":true}]}\");\n+    channelBuilder.defaultServiceConfig(defaultServiceConfig);\n+    Status resolutionError = Status.UNAVAILABLE.withDescription(\"Resolution failed\");\n+    channelBuilder.maxTraceEvents(10);\n+    createChannel();\n+    FakeNameResolverFactory.FakeNameResolver resolver = nameResolverFactory.resolvers.get(0);\n+\n+    resolver.listener.onError(resolutionError);\n+\n+    InternalConfigSelector configSelector = channel.getConfigSelector();\n+    ManagedChannelServiceConfig config =\n+        (ManagedChannelServiceConfig) configSelector.selectConfig(null).getConfig();\n+    MethodInfo methodConfig = config.getMethodConfig(method);\n+    assertThat(methodConfig.waitForReady).isTrue();\n+    timer.forwardNanos(1234);\n+    assertThat(getStats(channel).channelTrace.events).contains(new ChannelTrace.Event.Builder()\n+        .setDescription(\"Initial Name Resolution error, using default service config\")\n+        .setSeverity(Severity.CT_ERROR)\n+        .setTimestampNanos(0)\n+        .build());\n+\n+    // Check that \"lastServiceConfig\" variable has been set above: a config resolution with the same\n+    // config simply gets ignored and not gets reassigned.\n+    resolver.resolved();\n+    timer.forwardNanos(1234);\n+    assertThat(getStats(channel).channelTrace.events.stream().filter(\n+        event -> event.description.equals(\"Service config changed\")).count()).isEqualTo(0);\n+  }\n+\n   @Test\n   public void interceptor() throws Exception {\n     final AtomicLong atomic = new AtomicLong();\n@@ -4595,7 +4646,7 @@ public void notUseDefaultImmediatelyIfEnableLookUp() throws Exception {\n     int size = getStats(channel).channelTrace.events.size();\n     assertThat(getStats(channel).channelTrace.events.get(size - 1))\n         .isNotEqualTo(new ChannelTrace.Event.Builder()\n-            .setDescription(\"Using default service config\")\n+            .setDescription(\"timer.forwardNanos(1234);\")\n             .setSeverity(ChannelTrace.Event.Severity.CT_INFO)\n             .setTimestampNanos(timer.getTicker().read())\n             .build());\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11575",
    "pr_id": 11575,
    "issue_id": 61,
    "repo": "grpc/grpc-java",
    "problem_statement": "\"No cached instance found\" exception in integration test\nThe exception does not cause any problem other than noise, but we should still figure out what is going wrong.\n\n```\njava.lang.IllegalArgumentException: No cached instance found for grpc-default-executor\n    at io.grpc.SharedResourceHolder.releaseInternal(SharedResourceHolder.java:144)\n    at io.grpc.SharedResourceHolder.release(SharedResourceHolder.java:115)\n    at io.grpc.AbstractChannelBuilder$2.run(AbstractChannelBuilder.java:109)\n    at io.grpc.ChannelImpl.shutdown(ChannelImpl.java:113)\n    at io.grpc.testing.integration.AbstractTransportTest.teardown(AbstractTransportTest.java:128)\n    at io.grpc.testing.integration.TestServiceClient.teardown(TestServiceClient.java:160)\n    at io.grpc.testing.integration.TestServiceClient.access$000(TestServiceClient.java:51)\n    at io.grpc.testing.integration.TestServiceClient$1.run(TestServiceClient.java:65)\n```\n",
    "issue_word_count": 114,
    "test_files_count": 16,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "core/src/main/java/io/grpc/internal/JsonParser.java",
      "core/src/main/java/io/grpc/internal/SpiffeUtil.java",
      "core/src/test/java/io/grpc/internal/JsonParserTest.java",
      "core/src/test/java/io/grpc/internal/SpiffeUtilTest.java",
      "core/src/test/resources/io/grpc/internal/spiffebundle.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_corrupted_cert.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_duplicates.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_malformed.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_wrong_kid.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_wrong_kty.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_wrong_multi_certs.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_wrong_root.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_wrong_seq_type.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_wrong_use.json",
      "gcp-observability/src/test/java/io/grpc/gcp/observability/ObservabilityConfigImplTest.java",
      "testing/src/main/resources/certs/spiffe-openssl.cnf",
      "testing/src/main/resources/certs/spiffe_cert.pem",
      "testing/src/main/resources/certs/spiffe_multi_uri_san_cert.pem"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/JsonParserTest.java",
      "core/src/test/java/io/grpc/internal/SpiffeUtilTest.java",
      "core/src/test/resources/io/grpc/internal/spiffebundle.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_corrupted_cert.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_duplicates.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_malformed.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_wrong_kid.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_wrong_kty.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_wrong_multi_certs.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_wrong_root.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_wrong_seq_type.json",
      "core/src/test/resources/io/grpc/internal/spiffebundle_wrong_use.json",
      "gcp-observability/src/test/java/io/grpc/gcp/observability/ObservabilityConfigImplTest.java",
      "testing/src/main/resources/certs/spiffe-openssl.cnf",
      "testing/src/main/resources/certs/spiffe_cert.pem",
      "testing/src/main/resources/certs/spiffe_multi_uri_san_cert.pem"
    ],
    "base_commit": "d169a5de6fb94e974fd77ebabde52f01bc7aaca0",
    "head_commit": "b8af2bde6ae48c3ee72d8682af90b075b38b3e6a",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11575",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11575",
    "dockerfile": "",
    "pr_merged_at": "2024-10-17T18:11:07.000Z",
    "patch": "diff --git a/core/src/main/java/io/grpc/internal/JsonParser.java b/core/src/main/java/io/grpc/internal/JsonParser.java\nindex 384d29754f0..14f78c09e72 100644\n--- a/core/src/main/java/io/grpc/internal/JsonParser.java\n+++ b/core/src/main/java/io/grpc/internal/JsonParser.java\n@@ -16,6 +16,7 @@\n \n package io.grpc.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import com.google.gson.stream.JsonReader;\n@@ -41,7 +42,8 @@ private JsonParser() {}\n \n   /**\n    * Parses a json string, returning either a {@code Map<String, ?>}, {@code List<?>},\n-   * {@code String}, {@code Double}, {@code Boolean}, or {@code null}.\n+   * {@code String}, {@code Double}, {@code Boolean}, or {@code null}. Fails if duplicate names\n+   * found.\n    */\n   public static Object parse(String raw) throws IOException {\n     JsonReader jr = new JsonReader(new StringReader(raw));\n@@ -81,6 +83,7 @@ private static Object parseRecursive(JsonReader jr) throws IOException {\n     Map<String, Object> obj = new LinkedHashMap<>();\n     while (jr.hasNext()) {\n       String name = jr.nextName();\n+      checkArgument(!obj.containsKey(name), \"Duplicate key found: %s\", name);\n       Object value = parseRecursive(jr);\n       obj.put(name, value);\n     }\n@@ -105,4 +108,4 @@ private static Void parseJsonNull(JsonReader jr) throws IOException {\n     jr.nextNull();\n     return null;\n   }\n-}\n+}\n\\ No newline at end of file\n\ndiff --git a/core/src/main/java/io/grpc/internal/SpiffeUtil.java b/core/src/main/java/io/grpc/internal/SpiffeUtil.java\nindex bddce3d035e..57e201d19ba 100644\n--- a/core/src/main/java/io/grpc/internal/SpiffeUtil.java\n+++ b/core/src/main/java/io/grpc/internal/SpiffeUtil.java\n@@ -19,15 +19,42 @@\n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n \n+import com.google.common.base.Optional;\n import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.CertificateParsingException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n import java.util.Locale;\n+import java.util.Map;\n \n /**\n- * Helper utility to work with SPIFFE URIs.\n+ * Provides utilities to manage SPIFFE bundles, extract SPIFFE IDs from X.509 certificate chains,\n+ * and parse SPIFFE IDs.\n  * @see <a href=\"https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md\">Standard</a>\n  */\n public final class SpiffeUtil {\n \n+  private static final Integer URI_SAN_TYPE = 6;\n+  private static final String USE_PARAMETER_VALUE = \"x509-svid\";\n+  private static final String KTY_PARAMETER_VALUE = \"RSA\";\n+  private static final String CERTIFICATE_PREFIX = \"-----BEGIN CERTIFICATE-----\\n\";\n+  private static final String CERTIFICATE_SUFFIX = \"-----END CERTIFICATE-----\";\n   private static final String PREFIX = \"spiffe://\";\n \n   private SpiffeUtil() {}\n@@ -96,6 +123,137 @@ private static void validatePathSegment(String pathSegment) {\n             + \" ([a-zA-Z0-9.-_])\");\n   }\n \n+  /**\n+   * Returns the SPIFFE ID from the leaf certificate, if present.\n+   *\n+   * @param certChain certificate chain to extract SPIFFE ID from\n+   */\n+  public static Optional<SpiffeId> extractSpiffeId(X509Certificate[] certChain)\n+      throws CertificateParsingException {\n+    checkArgument(checkNotNull(certChain, \"certChain\").length > 0, \"certChain can't be empty\");\n+    Collection<List<?>> subjectAltNames = certChain[0].getSubjectAlternativeNames();\n+    if (subjectAltNames == null) {\n+      return Optional.absent();\n+    }\n+    String uri = null;\n+    // Search for the unique URI SAN.\n+    for (List<?> altName : subjectAltNames) {\n+      if (altName.size() < 2 ) {\n+        continue;\n+      }\n+      if (URI_SAN_TYPE.equals(altName.get(0))) {\n+        if (uri != null) {\n+          throw new IllegalArgumentException(\"Multiple URI SAN values found in the leaf cert.\");\n+        }\n+        uri = (String) altName.get(1);\n+      }\n+    }\n+    if (uri == null) {\n+      return Optional.absent();\n+    }\n+    return Optional.of(parse(uri));\n+  }\n+\n+  /**\n+   * Loads a SPIFFE trust bundle from a file, parsing it from the JSON format.\n+   * In case of success, returns {@link SpiffeBundle}.\n+   * If any element of the JSON content is invalid or unsupported, an\n+   * {@link IllegalArgumentException} is thrown and the entire Bundle is considered invalid.\n+   *\n+   * @param trustBundleFile the file path to the JSON file containing the trust bundle\n+   * @see <a href=\"https://github.com/spiffe/spiffe/blob/main/standards/SPIFFE_Trust_Domain_and_Bundle.md\">JSON format</a>\n+   * @see <a href=\"https://github.com/spiffe/spiffe/blob/main/standards/X509-SVID.md#61-publishing-spiffe-bundle-elements\">JWK entry format</a>\n+   * @see <a href=\"https://datatracker.ietf.org/doc/html/rfc7517#appendix-B\">x5c (certificate) parameter</a>\n+   */\n+  public static SpiffeBundle loadTrustBundleFromFile(String trustBundleFile) throws IOException {\n+    Map<String, ?> trustDomainsNode = readTrustDomainsFromFile(trustBundleFile);\n+    Map<String, List<X509Certificate>> trustBundleMap = new HashMap<>();\n+    Map<String, Long> sequenceNumbers = new HashMap<>();\n+    for (String trustDomainName : trustDomainsNode.keySet()) {\n+      Map<String, ?> domainNode = JsonUtil.getObject(trustDomainsNode, trustDomainName);\n+      if (domainNode.size() == 0) {\n+        trustBundleMap.put(trustDomainName, Collections.emptyList());\n+        continue;\n+      }\n+      Long sequenceNumber = JsonUtil.getNumberAsLong(domainNode, \"spiffe_sequence\");\n+      sequenceNumbers.put(trustDomainName, sequenceNumber == null ? -1L : sequenceNumber);\n+      List<Map<String, ?>> keysNode = JsonUtil.getListOfObjects(domainNode, \"keys\");\n+      if (keysNode == null || keysNode.size() == 0) {\n+        trustBundleMap.put(trustDomainName, Collections.emptyList());\n+        continue;\n+      }\n+      trustBundleMap.put(trustDomainName, extractCert(keysNode, trustDomainName));\n+    }\n+    return new SpiffeBundle(sequenceNumbers, trustBundleMap);\n+  }\n+\n+  private static Map<String, ?> readTrustDomainsFromFile(String filePath) throws IOException {\n+    Path path = Paths.get(checkNotNull(filePath, \"trustBundleFile\"));\n+    String json = new String(Files.readAllBytes(path), StandardCharsets.UTF_8);\n+    Object jsonObject = JsonParser.parse(json);\n+    if (!(jsonObject instanceof Map)) {\n+      throw new IllegalArgumentException(\n+          \"SPIFFE Trust Bundle should be a JSON object. Found: \"\n+              + (jsonObject == null ? null : jsonObject.getClass()));\n+    }\n+    @SuppressWarnings(\"unchecked\")\n+    Map<String, ?> root = (Map<String, ?>)jsonObject;\n+    Map<String, ?> trustDomainsNode = JsonUtil.getObject(root, \"trust_domains\");\n+    checkNotNull(trustDomainsNode, \"Mandatory trust_domains element is missing\");\n+    checkArgument(trustDomainsNode.size() > 0, \"Mandatory trust_domains element is missing\");\n+    return trustDomainsNode;\n+  }\n+\n+  private static void checkJwkEntry(Map<String, ?> jwkNode, String trustDomainName) {\n+    String kty = JsonUtil.getString(jwkNode, \"kty\");\n+    if (kty == null || !kty.equals(KTY_PARAMETER_VALUE)) {\n+      throw new IllegalArgumentException(String.format(\"'kty' parameter must be '%s' but '%s' \"\n+              + \"found. Certificate loading for trust domain '%s' failed.\", KTY_PARAMETER_VALUE,\n+          kty, trustDomainName));\n+    }\n+    if (jwkNode.containsKey(\"kid\")) {\n+      throw new IllegalArgumentException(String.format(\"'kid' parameter must not be set. \"\n+              + \"Certificate loading for trust domain '%s' failed.\", trustDomainName));\n+    }\n+    String use = JsonUtil.getString(jwkNode, \"use\");\n+    if (use == null || !use.equals(USE_PARAMETER_VALUE)) {\n+      throw new IllegalArgumentException(String.format(\"'use' parameter must be '%s' but '%s' \"\n+              + \"found. Certificate loading for trust domain '%s' failed.\", USE_PARAMETER_VALUE,\n+          use, trustDomainName));\n+    }\n+  }\n+\n+  private static List<X509Certificate> extractCert(List<Map<String, ?>> keysNode,\n+      String trustDomainName) {\n+    List<X509Certificate> result = new ArrayList<>();\n+    for (Map<String, ?> keyNode : keysNode) {\n+      checkJwkEntry(keyNode, trustDomainName);\n+      List<String> rawCerts = JsonUtil.getListOfStrings(keyNode, \"x5c\");\n+      if (rawCerts == null) {\n+        break;\n+      }\n+      if (rawCerts.size() != 1) {\n+        throw new IllegalArgumentException(String.format(\"Exactly 1 certificate is expected, but \"\n+            + \"%s found. Certificate loading for trust domain '%s' failed.\", rawCerts.size(),\n+            trustDomainName));\n+      }\n+      InputStream stream = new ByteArrayInputStream((CERTIFICATE_PREFIX + rawCerts.get(0) + \"\\n\"\n+          + CERTIFICATE_SUFFIX)\n+          .getBytes(StandardCharsets.UTF_8));\n+      try {\n+        Collection<? extends Certificate> certs = CertificateFactory.getInstance(\"X509\")\n+            .generateCertificates(stream);\n+        X509Certificate[] certsArray = certs.toArray(new X509Certificate[0]);\n+        assert certsArray.length == 1;\n+        result.add(certsArray[0]);\n+      } catch (CertificateException e) {\n+        throw new IllegalArgumentException(String.format(\"Certificate can't be parsed. Certificate \"\n+            + \"loading for trust domain '%s' failed.\", trustDomainName), e);\n+      }\n+    }\n+    return result;\n+  }\n+\n   /**\n    * Represents a SPIFFE ID as defined in the SPIFFE standard.\n    * @see <a href=\"https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md\">Standard</a>\n@@ -119,4 +277,34 @@ public String getPath() {\n     }\n   }\n \n+  /**\n+   * Represents a SPIFFE trust bundle; that is, a map from trust domain to set of trusted\n+   * certificates. Only trust domain's sequence numbers and x509 certificates are supported.\n+   * @see <a href=\"https://github.com/spiffe/spiffe/blob/main/standards/SPIFFE_Trust_Domain_and_Bundle.md#4-spiffe-bundle-format\">Standard</a>\n+   */\n+  public static final class SpiffeBundle {\n+\n+    private final ImmutableMap<String, Long> sequenceNumbers;\n+\n+    private final ImmutableMap<String, ImmutableList<X509Certificate>> bundleMap;\n+\n+    private SpiffeBundle(Map<String, Long> sequenceNumbers,\n+        Map<String, List<X509Certificate>> trustDomainMap) {\n+      this.sequenceNumbers = ImmutableMap.copyOf(sequenceNumbers);\n+      ImmutableMap.Builder<String, ImmutableList<X509Certificate>> builder = ImmutableMap.builder();\n+      for (Map.Entry<String, List<X509Certificate>> entry : trustDomainMap.entrySet()) {\n+        builder.put(entry.getKey(), ImmutableList.copyOf(entry.getValue()));\n+      }\n+      this.bundleMap = builder.build();\n+    }\n+\n+    public ImmutableMap<String, Long> getSequenceNumbers() {\n+      return sequenceNumbers;\n+    }\n+\n+    public ImmutableMap<String, ImmutableList<X509Certificate>> getBundleMap() {\n+      return bundleMap;\n+    }\n+  }\n+\n }\n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/JsonParserTest.java b/core/src/test/java/io/grpc/internal/JsonParserTest.java\nindex 1e74c753d4d..cfee566fa4a 100644\n--- a/core/src/test/java/io/grpc/internal/JsonParserTest.java\n+++ b/core/src/test/java/io/grpc/internal/JsonParserTest.java\n@@ -123,4 +123,11 @@ public void objectStringName() throws IOException {\n \n     assertEquals(expected, JsonParser.parse(\"{\\\"hi\\\": 2}\"));\n   }\n-}\n+\n+  @Test\n+  public void duplicate() throws IOException {\n+    thrown.expect(IllegalArgumentException.class);\n+\n+    JsonParser.parse(\"{\\\"hi\\\": 2, \\\"hi\\\": 3}\");\n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/core/src/test/java/io/grpc/internal/SpiffeUtilTest.java b/core/src/test/java/io/grpc/internal/SpiffeUtilTest.java\nindex c3a98ce33e0..244539501a6 100644\n--- a/core/src/test/java/io/grpc/internal/SpiffeUtilTest.java\n+++ b/core/src/test/java/io/grpc/internal/SpiffeUtilTest.java\n@@ -17,12 +17,28 @@\n package io.grpc.internal;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n \n+import com.google.common.base.Optional;\n+import io.grpc.internal.SpiffeUtil.SpiffeBundle;\n+import io.grpc.internal.SpiffeUtil.SpiffeId;\n+import io.grpc.testing.TlsTesting;\n+import io.grpc.util.CertificateUtils;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.security.cert.X509Certificate;\n import java.util.Arrays;\n import java.util.Collection;\n+import org.junit.Before;\n+import org.junit.Rule;\n import org.junit.Test;\n import org.junit.experimental.runners.Enclosed;\n+import org.junit.rules.TemporaryFolder;\n import org.junit.runner.RunWith;\n import org.junit.runners.Parameterized;\n import org.junit.runners.Parameterized.Parameter;\n@@ -159,7 +175,8 @@ public void spiffeTrustDomainFormatTest() {\n           SpiffeUtil.parse(longTrustDomain.toString()));\n       assertEquals(\"Trust Domain maximum length is 255 characters\", iae.getMessage());\n \n-      StringBuilder longSpiffe = new StringBuilder(String.format(\"spiffe://mydomain%scom/\", \"%21\"));\n+      @SuppressWarnings(\"OrphanedFormatString\")\n+      StringBuilder longSpiffe = new StringBuilder(\"spiffe://mydomain%21com/\");\n       for (int i = 0; i < 405; i++) {\n         longSpiffe.append(\"qwert\");\n       }\n@@ -193,4 +210,157 @@ public void spiffePathFormatTest() {\n           + \"underscores ([a-zA-Z0-9.-_])\", iae.getMessage());\n     }\n   }\n+\n+  public static class CertificateApiTest {\n+    private static final String SPIFFE_PEM_FILE = \"spiffe_cert.pem\";\n+    private static final String MULTI_URI_SAN_PEM_FILE = \"spiffe_multi_uri_san_cert.pem\";\n+    private static final String SERVER_0_PEM_FILE = \"server0.pem\";\n+    private static final String TEST_DIRECTORY_PREFIX = \"io/grpc/internal/\";\n+    private static final String SPIFFE_TRUST_BUNDLE = \"spiffebundle.json\";\n+    private static final String SPIFFE_TRUST_BUNDLE_MALFORMED = \"spiffebundle_malformed.json\";\n+    private static final String SPIFFE_TRUST_BUNDLE_CORRUPTED_CERT =\n+        \"spiffebundle_corrupted_cert.json\";\n+    private static final String SPIFFE_TRUST_BUNDLE_WRONG_KTY = \"spiffebundle_wrong_kty.json\";\n+    private static final String SPIFFE_TRUST_BUNDLE_WRONG_KID = \"spiffebundle_wrong_kid.json\";\n+    private static final String SPIFFE_TRUST_BUNDLE_WRONG_USE = \"spiffebundle_wrong_use.json\";\n+    private static final String SPIFFE_TRUST_BUNDLE_WRONG_MULTI_CERTS =\n+        \"spiffebundle_wrong_multi_certs.json\";\n+    private static final String SPIFFE_TRUST_BUNDLE_DUPLICATES = \"spiffebundle_duplicates.json\";\n+    private static final String SPIFFE_TRUST_BUNDLE_WRONG_ROOT = \"spiffebundle_wrong_root.json\";\n+    private static final String SPIFFE_TRUST_BUNDLE_WRONG_SEQ = \"spiffebundle_wrong_seq_type.json\";\n+    private static final String DOMAIN_ERROR_MESSAGE =\n+        \" Certificate loading for trust domain 'google.com' failed.\";\n+\n+\n+    @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private X509Certificate[] spiffeCert;\n+    private X509Certificate[] multipleUriSanCert;\n+    private X509Certificate[] serverCert0;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+      spiffeCert = CertificateUtils.getX509Certificates(TlsTesting.loadCert(SPIFFE_PEM_FILE));\n+      multipleUriSanCert = CertificateUtils.getX509Certificates(TlsTesting\n+          .loadCert(MULTI_URI_SAN_PEM_FILE));\n+      serverCert0 = CertificateUtils.getX509Certificates(TlsTesting.loadCert(SERVER_0_PEM_FILE));\n+    }\n+\n+    private String copyFileToTmp(String fileName) throws Exception {\n+      Path tempFilePath = tempFolder.newFile(fileName).toPath();\n+      try (InputStream resourceStream = SpiffeUtilTest.class.getClassLoader()\n+          .getResourceAsStream(TEST_DIRECTORY_PREFIX + fileName)) {\n+        Files.copy(resourceStream, tempFilePath, StandardCopyOption.REPLACE_EXISTING);\n+      }\n+      return tempFilePath.toString();\n+    }\n+\n+    @Test\n+    public void extractSpiffeIdSuccessTest() throws Exception {\n+      Optional<SpiffeId> spiffeId = SpiffeUtil.extractSpiffeId(spiffeCert);\n+      assertTrue(spiffeId.isPresent());\n+      assertEquals(\"foo.bar.com\", spiffeId.get().getTrustDomain());\n+      assertEquals(\"/client/workload/1\", spiffeId.get().getPath());\n+    }\n+\n+    @Test\n+    public void extractSpiffeIdFailureTest() throws Exception {\n+      Optional<SpiffeUtil.SpiffeId> spiffeId = SpiffeUtil.extractSpiffeId(serverCert0);\n+      assertFalse(spiffeId.isPresent());\n+      IllegalArgumentException iae = assertThrows(IllegalArgumentException.class, () -> SpiffeUtil\n+          .extractSpiffeId(multipleUriSanCert));\n+      assertEquals(\"Multiple URI SAN values found in the leaf cert.\", iae.getMessage());\n+\n+    }\n+\n+    @Test\n+    public void extractSpiffeIdFromChainTest() throws Exception {\n+      // Check that the SPIFFE ID is extracted only from the leaf cert in the chain (spiffeCert\n+      // contains it, but serverCert0 does not).\n+      X509Certificate[] leafWithSpiffeChain = new X509Certificate[]{spiffeCert[0], serverCert0[0]};\n+      assertTrue(SpiffeUtil.extractSpiffeId(leafWithSpiffeChain).isPresent());\n+      X509Certificate[] leafWithoutSpiffeChain =\n+          new X509Certificate[]{serverCert0[0], spiffeCert[0]};\n+      assertFalse(SpiffeUtil.extractSpiffeId(leafWithoutSpiffeChain).isPresent());\n+    }\n+\n+    @Test\n+    public void extractSpiffeIdParameterValidityTest() {\n+      NullPointerException npe = assertThrows(NullPointerException.class, () -> SpiffeUtil\n+          .extractSpiffeId(null));\n+      assertEquals(\"certChain\", npe.getMessage());\n+      IllegalArgumentException iae = assertThrows(IllegalArgumentException.class, () -> SpiffeUtil\n+          .extractSpiffeId(new X509Certificate[]{}));\n+      assertEquals(\"certChain can't be empty\", iae.getMessage());\n+    }\n+\n+    @Test\n+    public void loadTrustBundleFromFileSuccessTest() throws Exception {\n+      SpiffeBundle tb = SpiffeUtil.loadTrustBundleFromFile(copyFileToTmp(SPIFFE_TRUST_BUNDLE));\n+      assertEquals(2, tb.getSequenceNumbers().size());\n+      assertEquals(12035488L, (long) tb.getSequenceNumbers().get(\"example.com\"));\n+      assertEquals(-1L, (long) tb.getSequenceNumbers().get(\"test.example.com\"));\n+      assertEquals(3, tb.getBundleMap().size());\n+      assertEquals(0, tb.getBundleMap().get(\"test.google.com.au\").size());\n+      assertEquals(1, tb.getBundleMap().get(\"example.com\").size());\n+      assertEquals(2, tb.getBundleMap().get(\"test.example.com\").size());\n+      Optional<SpiffeId> spiffeId = SpiffeUtil.extractSpiffeId(tb.getBundleMap().get(\"example.com\")\n+              .toArray(new X509Certificate[0]));\n+      assertTrue(spiffeId.isPresent());\n+      assertEquals(\"foo.bar.com\", spiffeId.get().getTrustDomain());\n+    }\n+\n+    @Test\n+    public void loadTrustBundleFromFileFailureTest() {\n+      // Check the exception if JSON root element is different from 'trust_domains'\n+      NullPointerException npe = assertThrows(NullPointerException.class, () -> SpiffeUtil\n+          .loadTrustBundleFromFile(copyFileToTmp(SPIFFE_TRUST_BUNDLE_WRONG_ROOT)));\n+      assertEquals(\"Mandatory trust_domains element is missing\", npe.getMessage());\n+      // Check the exception if JSON root element is different from 'trust_domains'\n+      ClassCastException cce = assertThrows(ClassCastException.class, () -> SpiffeUtil\n+          .loadTrustBundleFromFile(copyFileToTmp(SPIFFE_TRUST_BUNDLE_WRONG_SEQ)));\n+      assertTrue(cce.getMessage().contains(\"Number expected to be long\"));\n+      // Check the exception if JSON file doesn't contain an object\n+      IllegalArgumentException iae = assertThrows(IllegalArgumentException.class, () -> SpiffeUtil\n+          .loadTrustBundleFromFile(copyFileToTmp(SPIFFE_TRUST_BUNDLE_MALFORMED)));\n+      assertTrue(iae.getMessage().contains(\"SPIFFE Trust Bundle should be a JSON object.\"));\n+      // Check the exception if JSON contains duplicates\n+      iae = assertThrows(IllegalArgumentException.class, () -> SpiffeUtil\n+          .loadTrustBundleFromFile(copyFileToTmp(SPIFFE_TRUST_BUNDLE_DUPLICATES)));\n+      assertEquals(\"Duplicate key found: google.com\", iae.getMessage());\n+      // Check the exception if 'x5c' value cannot be parsed\n+      iae = assertThrows(IllegalArgumentException.class, () -> SpiffeUtil\n+          .loadTrustBundleFromFile(copyFileToTmp(SPIFFE_TRUST_BUNDLE_CORRUPTED_CERT)));\n+      assertEquals(\"Certificate can't be parsed.\" + DOMAIN_ERROR_MESSAGE, iae.getMessage());\n+      // Check the exception if 'kty' value differs from 'RSA'\n+      iae = assertThrows(IllegalArgumentException.class, () -> SpiffeUtil\n+          .loadTrustBundleFromFile(copyFileToTmp(SPIFFE_TRUST_BUNDLE_WRONG_KTY)));\n+      assertEquals(\"'kty' parameter must be 'RSA' but 'null' found.\" + DOMAIN_ERROR_MESSAGE,\n+          iae.getMessage());\n+      // Check the exception if 'kid' has a value\n+      iae = assertThrows(IllegalArgumentException.class, () -> SpiffeUtil\n+          .loadTrustBundleFromFile(copyFileToTmp(SPIFFE_TRUST_BUNDLE_WRONG_KID)));\n+      assertEquals(\"'kid' parameter must not be set.\" + DOMAIN_ERROR_MESSAGE, iae.getMessage());\n+      // Check the exception if 'use' value differs from 'x509-svid'\n+      iae = assertThrows(IllegalArgumentException.class, () -> SpiffeUtil\n+          .loadTrustBundleFromFile(copyFileToTmp(SPIFFE_TRUST_BUNDLE_WRONG_USE)));\n+      assertEquals(\"'use' parameter must be 'x509-svid' but 'i_am_not_x509-svid' found.\"\n+          + DOMAIN_ERROR_MESSAGE, iae.getMessage());\n+      // Check the exception if multiple certs are provided for 'x5c'\n+      iae = assertThrows(IllegalArgumentException.class, () -> SpiffeUtil\n+          .loadTrustBundleFromFile(copyFileToTmp(SPIFFE_TRUST_BUNDLE_WRONG_MULTI_CERTS)));\n+      assertEquals(\"Exactly 1 certificate is expected, but 2 found.\" + DOMAIN_ERROR_MESSAGE,\n+          iae.getMessage());\n+    }\n+\n+    @Test\n+    public void loadTrustBundleFromFileParameterValidityTest() {\n+      NullPointerException npe = assertThrows(NullPointerException.class, () -> SpiffeUtil\n+          .loadTrustBundleFromFile(null));\n+      assertEquals(\"trustBundleFile\", npe.getMessage());\n+      NoSuchFileException nsfe = assertThrows(NoSuchFileException.class, () -> SpiffeUtil\n+          .loadTrustBundleFromFile(\"i_do_not_exist\"));\n+      assertEquals(\"i_do_not_exist\", nsfe.getMessage());\n+    }\n+  }\n }\n\\ No newline at end of file\n\ndiff --git a/core/src/test/resources/io/grpc/internal/spiffebundle.json b/core/src/test/resources/io/grpc/internal/spiffebundle.json\nnew file mode 100644\nindex 00000000000..f968f730d94\n--- /dev/null\n+++ b/core/src/test/resources/io/grpc/internal/spiffebundle.json\n@@ -0,0 +1,115 @@\n+{\n+  \"trust_domains\": {\n+    \"test.google.com.au\": {},\n+    \"example.com\": {\n+      \"spiffe_sequence\": 12035488,\n+      \"keys\": [\n+        {\n+          \"kty\": \"RSA\",\n+          \"use\": \"x509-svid\",\n+          \"x5c\": [\"MIIFsjCCA5qgAwIBAgIURygVMMzdr+Q7rsUaz189JozyHMwwDQYJKoZIhvcNAQEL\n+          BQAwTjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANTVkwxDTAL\n+          BgNVBAoMBGdSUEMxFTATBgNVBAMMDHRlc3QtY2xpZW50MTAeFw0yMTEyMjMxODQy\n+          NTJaFw0zMTEyMjExODQyNTJaME4xCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEM\n+          MAoGA1UEBwwDU1ZMMQ0wCwYDVQQKDARnUlBDMRUwEwYDVQQDDAx0ZXN0LWNsaWVu\n+          dDEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDJ4AqpGetyVSqGUuBJ\n+          LVFla+7bEfca7UYzfVSSZLZ/X+JDmWIVN8UIPuFib5jhMEc3XaUnFXUmM7zEtz/Z\n+          G5hapwLwOb2C3ZxOP6PQjYCJxbkLie+b43UQrFu1xxd3vMhVJgcj/AIxEpmszuqO\n+          a6kUrkYifjJADQ+64kZgl66bsTdXMCzpxyFl9xUfff59L8OX+HUfAcoZz3emjg3Z\n+          JPYURQEmjdZTOau1EjFilwHgd989Jt7NKgx30NXoHmw7nusVBIY94fL2VKN3f1XV\n+          m0dHu5NI279Q6zr0ZBU7k5T3IeHnzsUesQS4NGlklDWoVTKk73Uv9Pna8yQsSW75\n+          7PEbHOGp9Knu4bnoGPOlsG81yIPipO6hTgGFK24pF97M9kpGbWqYX4+2vLlrCAfc\n+          msHqaUPmQlYeRVTT6vw7ctYo2kyUYGtnODXk76LqewRBVvkzx75QUhfjAyb740Yc\n+          DmIenc56Tq6gebJHjhEmVSehR6xIpXP7SVeurTyhPsEQnpJHtgs4dcwWOZp7BvPN\n+          zHXmJqfr7vsshie3vS5kQ0u1e1yqAqXgyDjqKXOkx+dpgUTehSJHhPNHvTc5LXRs\n+          vvXKYz6FrwR/DZ8t7BNEvPeLjFgxpH7QVJFLCvCbXs5K6yYbsnLfxFIBPRnrbJkI\n+          sK+sQwnRdnsiUdPsTkG5B2lQfQIDAQABo4GHMIGEMB0GA1UdDgQWBBQ2lBp0PiRH\n+          HvQ5IRURm8aHsj4RETAfBgNVHSMEGDAWgBQ2lBp0PiRHHvQ5IRURm8aHsj4RETAP\n+          BgNVHRMBAf8EBTADAQH/MDEGA1UdEQQqMCiGJnNwaWZmZTovL2Zvby5iYXIuY29t\n+          L2NsaWVudC93b3JrbG9hZC8xMA0GCSqGSIb3DQEBCwUAA4ICAQA1mSkgRclAl+E/\n+          aS9zJ7t8+Y4n3T24nOKKveSIjxXm/zjhWqVsLYBI6kglWtih2+PELvU8JdPqNZK3\n+          4Kl0Q6FWpVSGDdWN1i6NyORt2ocggL3ke3iXxRk3UpUKJmqwz81VhA2KUHnMlyE0\n+          IufFfZNwNWWHBv13uJfRbjeQpKPhU+yf4DeXrsWcvrZlGvAET+mcplafUzCp7Iv+\n+          PcISJtUerbxbVtuHVeZCLlgDXWkLAWJN8rf0dIG4x060LJ+j6j9uRVhb9sZn1HJV\n+          +j4XdIYm1VKilluhOtNwP2d3Ox/JuTBxf7hFHXZPfMagQE5k5PzmxRaCAEMJ1l2D\n+          vUbZw+shJfSNoWcBo2qadnUaWT3BmmJRBDh7ZReib/RQ1Rd4ygOyzP3E0vkV4/gq\n+          yjLdApXh5PZP8KLQZ+1JN/sdWt7VfIt9wYOpkIqujdll51ESHzwQeAK9WVCB4UvV\n+          z6zdhItB9CRbXPreWC+wCB1xDovIzFKOVsLs5+Gqs1m7VinG2LxbDqaKyo/FB0Hx\n+          x0acBNzezLWoDwXYQrN0T0S4pnqhKD1CYPpdArBkNezUYAjS725FkApuK+mnBX3U\n+          0msBffEaUEOkcyar1EW2m/33vpetD/k3eQQkmvQf4Hbiu9AF+9cNDm/hMuXEw5EX\n+          GA91fn0891b5eEW8BJHXX0jri0aN8g==\"],\n+          \"n\": \"<base64urlUint-encoded value>\",\n+          \"e\": \"AQAB\"\n+        }\n+      ]\n+    },\n+    \"test.example.com\": {\n+      \"keys\": [\n+        {\n+          \"kty\": \"RSA\",\n+          \"use\": \"x509-svid\",\n+          \"x5c\": [\"MIIFsjCCA5qgAwIBAgIURygVMMzdr+Q7rsUaz189JozyHMwwDQYJKoZIhvcNAQEL\n+          BQAwTjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANTVkwxDTAL\n+          BgNVBAoMBGdSUEMxFTATBgNVBAMMDHRlc3QtY2xpZW50MTAeFw0yMTEyMjMxODQy\n+          NTJaFw0zMTEyMjExODQyNTJaME4xCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEM\n+          MAoGA1UEBwwDU1ZMMQ0wCwYDVQQKDARnUlBDMRUwEwYDVQQDDAx0ZXN0LWNsaWVu\n+          dDEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDJ4AqpGetyVSqGUuBJ\n+          LVFla+7bEfca7UYzfVSSZLZ/X+JDmWIVN8UIPuFib5jhMEc3XaUnFXUmM7zEtz/Z\n+          G5hapwLwOb2C3ZxOP6PQjYCJxbkLie+b43UQrFu1xxd3vMhVJgcj/AIxEpmszuqO\n+          a6kUrkYifjJADQ+64kZgl66bsTdXMCzpxyFl9xUfff59L8OX+HUfAcoZz3emjg3Z\n+          JPYURQEmjdZTOau1EjFilwHgd989Jt7NKgx30NXoHmw7nusVBIY94fL2VKN3f1XV\n+          m0dHu5NI279Q6zr0ZBU7k5T3IeHnzsUesQS4NGlklDWoVTKk73Uv9Pna8yQsSW75\n+          7PEbHOGp9Knu4bnoGPOlsG81yIPipO6hTgGFK24pF97M9kpGbWqYX4+2vLlrCAfc\n+          msHqaUPmQlYeRVTT6vw7ctYo2kyUYGtnODXk76LqewRBVvkzx75QUhfjAyb740Yc\n+          DmIenc56Tq6gebJHjhEmVSehR6xIpXP7SVeurTyhPsEQnpJHtgs4dcwWOZp7BvPN\n+          zHXmJqfr7vsshie3vS5kQ0u1e1yqAqXgyDjqKXOkx+dpgUTehSJHhPNHvTc5LXRs\n+          vvXKYz6FrwR/DZ8t7BNEvPeLjFgxpH7QVJFLCvCbXs5K6yYbsnLfxFIBPRnrbJkI\n+          sK+sQwnRdnsiUdPsTkG5B2lQfQIDAQABo4GHMIGEMB0GA1UdDgQWBBQ2lBp0PiRH\n+          HvQ5IRURm8aHsj4RETAfBgNVHSMEGDAWgBQ2lBp0PiRHHvQ5IRURm8aHsj4RETAP\n+          BgNVHRMBAf8EBTADAQH/MDEGA1UdEQQqMCiGJnNwaWZmZTovL2Zvby5iYXIuY29t\n+          L2NsaWVudC93b3JrbG9hZC8xMA0GCSqGSIb3DQEBCwUAA4ICAQA1mSkgRclAl+E/\n+          aS9zJ7t8+Y4n3T24nOKKveSIjxXm/zjhWqVsLYBI6kglWtih2+PELvU8JdPqNZK3\n+          4Kl0Q6FWpVSGDdWN1i6NyORt2ocggL3ke3iXxRk3UpUKJmqwz81VhA2KUHnMlyE0\n+          IufFfZNwNWWHBv13uJfRbjeQpKPhU+yf4DeXrsWcvrZlGvAET+mcplafUzCp7Iv+\n+          PcISJtUerbxbVtuHVeZCLlgDXWkLAWJN8rf0dIG4x060LJ+j6j9uRVhb9sZn1HJV\n+          +j4XdIYm1VKilluhOtNwP2d3Ox/JuTBxf7hFHXZPfMagQE5k5PzmxRaCAEMJ1l2D\n+          vUbZw+shJfSNoWcBo2qadnUaWT3BmmJRBDh7ZReib/RQ1Rd4ygOyzP3E0vkV4/gq\n+          yjLdApXh5PZP8KLQZ+1JN/sdWt7VfIt9wYOpkIqujdll51ESHzwQeAK9WVCB4UvV\n+          z6zdhItB9CRbXPreWC+wCB1xDovIzFKOVsLs5+Gqs1m7VinG2LxbDqaKyo/FB0Hx\n+          x0acBNzezLWoDwXYQrN0T0S4pnqhKD1CYPpdArBkNezUYAjS725FkApuK+mnBX3U\n+          0msBffEaUEOkcyar1EW2m/33vpetD/k3eQQkmvQf4Hbiu9AF+9cNDm/hMuXEw5EX\n+          GA91fn0891b5eEW8BJHXX0jri0aN8g==\"],\n+          \"n\": \"<base64urlUint-encoded value>\",\n+          \"e\": \"AQAB\"\n+        },\n+        {\n+          \"kty\": \"RSA\",\n+          \"use\": \"x509-svid\",\n+          \"x5c\": [\"MIIELTCCAxWgAwIBAgIUVXGlXjNENtOZbI12epjgIhMaShEwDQYJKoZIhvcNAQEL\n+          BQAwVjELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM\n+          GEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEPMA0GA1UEAwwGdGVzdGNhMB4XDTI0\n+          MDkxNzE2MTk0NFoXDTM0MDkxNTE2MTk0NFowTjELMAkGA1UEBhMCVVMxCzAJBgNV\n+          BAgMAkNBMQwwCgYDVQQHDANTVkwxDTALBgNVBAoMBGdSUEMxFTATBgNVBAMMDHRl\n+          c3QtY2xpZW50MTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOcTjjcS\n+          SfG/EGrr6G+f+3T2GXyHHfroQFi9mZUz80L7uKBdECOImID+YhoK8vcxLQjPmEEv\n+          FIYgJT5amugDcYIgUhMjBx/8RPJaP/nGmBngAqsuuNCaZfyaHBRqN8XdS/AwmsI5\n+          Wo+nru0+0/7aQFdqqtd2+e9dHjUWwgHxXvMgC4hkHpsdCGIZWVzWyBliwTYQYb1Y\n+          yYe1LzqqQA5OMbZfKOY9MYDCEYOliRiunOn30iIOHj9V5qLzWGfSyxCRuvLRdEP8\n+          iDeNweHbdaKuI80nQmxuBdRIspE9k5sD1WA4vLZpeg3zggxp4rfLL5zBJgb/33D3\n+          d9Rkm14xfDPihhkCAwEAAaOB+jCB9zBZBgNVHREEUjBQhiZzcGlmZmU6Ly9mb28u\n+          YmFyLmNvbS9jbGllbnQvd29ya2xvYWQvMYYmc3BpZmZlOi8vZm9vLmJhci5jb20v\n+          Y2xpZW50L3dvcmtsb2FkLzIwHQYDVR0OBBYEFG9GkBgdBg/p0U9/lXv8zIJ+2c2N\n+          MHsGA1UdIwR0MHKhWqRYMFYxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0\n+          YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxDzANBgNVBAMM\n+          BnRlc3RjYYIUWrP0VvHcy+LP6UuYNtiL9gBhD5owDQYJKoZIhvcNAQELBQADggEB\n+          AJ4Cbxv+02SpUgkEu4hP/1+8DtSBXUxNxI0VG4e3Ap2+Rhjm3YiFeS/UeaZhNrrw\n+          UEjkSTPFODyXR7wI7UO9OO1StyD6CMkp3SEvevU5JsZtGL6mTiTLTi3Qkywa91Bt\n+          GlyZdVMghA1bBJLBMwiD5VT5noqoJBD7hDy6v9yNmt1Sw2iYBJPqI3Gnf5bMjR3s\n+          UICaxmFyqaMCZsPkfJh0DmZpInGJys3m4QqGz6ZE2DWgcSr1r/ML7/5bSPjjr8j4\n+          WFFSqFR3dMu8CbGnfZTCTXa4GTX/rARXbAO67Z/oJbJBK7VKayskL+PzKuohb9ox\n+          jGL772hQMbwtFCOFXu5VP0s=\"]\n+        }\n+      ]\n+    }\n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/core/src/test/resources/io/grpc/internal/spiffebundle_corrupted_cert.json b/core/src/test/resources/io/grpc/internal/spiffebundle_corrupted_cert.json\nnew file mode 100644\nindex 00000000000..9ca51733ff3\n--- /dev/null\n+++ b/core/src/test/resources/io/grpc/internal/spiffebundle_corrupted_cert.json\n@@ -0,0 +1,14 @@\n+{\n+  \"trust_domains\": {\n+    \"google.com\": {\n+      \"spiffe_sequence\": 123,\n+      \"keys\": [\n+        {\n+          \"kty\": \"RSA\",\n+          \"use\": \"x509-svid\",\n+          \"x5c\": [\"UNPARSABLE_CERTIFICATE\"]\n+        }\n+      ]\n+    }\n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/core/src/test/resources/io/grpc/internal/spiffebundle_duplicates.json b/core/src/test/resources/io/grpc/internal/spiffebundle_duplicates.json\nnew file mode 100644\nindex 00000000000..3f015bd1568\n--- /dev/null\n+++ b/core/src/test/resources/io/grpc/internal/spiffebundle_duplicates.json\n@@ -0,0 +1,23 @@\n+{\n+  \"trust_domains\": {\n+    \"google.com\": {\n+      \"spiffe_sequence\": 123,\n+      \"keys\": [\n+        {\n+          \"x5c\": \"VALUE_DOESN'T_MATTER\"\n+        }\n+      ]\n+    },\n+    \"google.com\": {\n+      \"spiffe_sequence\": 123,\n+      \"keys\": [\n+        {\n+          \"use\": \"x509-svid\",\n+          \"kid\": \"some_value\",\n+          \"x5c\": \"VALUE_DOESN'T_MATTER\"\n+        }\n+      ]\n+    },\n+    \"test.google.com.au\": {}\n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/core/src/test/resources/io/grpc/internal/spiffebundle_malformed.json b/core/src/test/resources/io/grpc/internal/spiffebundle_malformed.json\nnew file mode 100644\nindex 00000000000..a2488eeb3cd\n--- /dev/null\n+++ b/core/src/test/resources/io/grpc/internal/spiffebundle_malformed.json\n@@ -0,0 +1,4 @@\n+[\n+  \"test.google.com\",\n+  \"test.google.com.au\"\n+]\n\\ No newline at end of file\n\ndiff --git a/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_kid.json b/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_kid.json\nnew file mode 100644\nindex 00000000000..f93af634a54\n--- /dev/null\n+++ b/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_kid.json\n@@ -0,0 +1,15 @@\n+{\n+  \"trust_domains\": {\n+    \"google.com\": {\n+      \"spiffe_sequence\": 123,\n+      \"keys\": [\n+        {\n+          \"kty\": \"RSA\",\n+          \"use\": \"x509-svid\",\n+          \"kid\": \"some_value\",\n+          \"x5c\": \"VALUE_DOESN'T_MATTER\"\n+        }\n+      ]\n+    }\n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_kty.json b/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_kty.json\nnew file mode 100644\nindex 00000000000..384da03fd6f\n--- /dev/null\n+++ b/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_kty.json\n@@ -0,0 +1,12 @@\n+{\n+  \"trust_domains\": {\n+    \"google.com\": {\n+      \"spiffe_sequence\": 123,\n+      \"keys\": [\n+        {\n+          \"x5c\": \"VALUE_DOESN'T_MATTER\"\n+        }\n+      ]\n+    }\n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_multi_certs.json b/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_multi_certs.json\nnew file mode 100644\nindex 00000000000..5e85635bb02\n--- /dev/null\n+++ b/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_multi_certs.json\n@@ -0,0 +1,67 @@\n+{\n+  \"trust_domains\": {\n+    \"google.com\": {\n+      \"spiffe_sequence\": 123,\n+      \"keys\": [\n+        {\n+          \"kty\": \"RSA\",\n+          \"use\": \"x509-svid\",\n+          \"x5c\": [\"MIIFsjCCA5qgAwIBAgIURygVMMzdr+Q7rsUaz189JozyHMwwDQYJKoZIhvcNAQEL\n+            BQAwTjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANTVkwxDTAL\n+            BgNVBAoMBGdSUEMxFTATBgNVBAMMDHRlc3QtY2xpZW50MTAeFw0yMTEyMjMxODQy\n+            NTJaFw0zMTEyMjExODQyNTJaME4xCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEM\n+            MAoGA1UEBwwDU1ZMMQ0wCwYDVQQKDARnUlBDMRUwEwYDVQQDDAx0ZXN0LWNsaWVu\n+            dDEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDJ4AqpGetyVSqGUuBJ\n+            LVFla+7bEfca7UYzfVSSZLZ/X+JDmWIVN8UIPuFib5jhMEc3XaUnFXUmM7zEtz/Z\n+            G5hapwLwOb2C3ZxOP6PQjYCJxbkLie+b43UQrFu1xxd3vMhVJgcj/AIxEpmszuqO\n+            a6kUrkYifjJADQ+64kZgl66bsTdXMCzpxyFl9xUfff59L8OX+HUfAcoZz3emjg3Z\n+            JPYURQEmjdZTOau1EjFilwHgd989Jt7NKgx30NXoHmw7nusVBIY94fL2VKN3f1XV\n+            m0dHu5NI279Q6zr0ZBU7k5T3IeHnzsUesQS4NGlklDWoVTKk73Uv9Pna8yQsSW75\n+            7PEbHOGp9Knu4bnoGPOlsG81yIPipO6hTgGFK24pF97M9kpGbWqYX4+2vLlrCAfc\n+            msHqaUPmQlYeRVTT6vw7ctYo2kyUYGtnODXk76LqewRBVvkzx75QUhfjAyb740Yc\n+            DmIenc56Tq6gebJHjhEmVSehR6xIpXP7SVeurTyhPsEQnpJHtgs4dcwWOZp7BvPN\n+            zHXmJqfr7vsshie3vS5kQ0u1e1yqAqXgyDjqKXOkx+dpgUTehSJHhPNHvTc5LXRs\n+            vvXKYz6FrwR/DZ8t7BNEvPeLjFgxpH7QVJFLCvCbXs5K6yYbsnLfxFIBPRnrbJkI\n+            sK+sQwnRdnsiUdPsTkG5B2lQfQIDAQABo4GHMIGEMB0GA1UdDgQWBBQ2lBp0PiRH\n+            HvQ5IRURm8aHsj4RETAfBgNVHSMEGDAWgBQ2lBp0PiRHHvQ5IRURm8aHsj4RETAP\n+            BgNVHRMBAf8EBTADAQH/MDEGA1UdEQQqMCiGJnNwaWZmZTovL2Zvby5iYXIuY29t\n+            L2NsaWVudC93b3JrbG9hZC8xMA0GCSqGSIb3DQEBCwUAA4ICAQA1mSkgRclAl+E/\n+            aS9zJ7t8+Y4n3T24nOKKveSIjxXm/zjhWqVsLYBI6kglWtih2+PELvU8JdPqNZK3\n+            4Kl0Q6FWpVSGDdWN1i6NyORt2ocggL3ke3iXxRk3UpUKJmqwz81VhA2KUHnMlyE0\n+            IufFfZNwNWWHBv13uJfRbjeQpKPhU+yf4DeXrsWcvrZlGvAET+mcplafUzCp7Iv+\n+            PcISJtUerbxbVtuHVeZCLlgDXWkLAWJN8rf0dIG4x060LJ+j6j9uRVhb9sZn1HJV\n+            +j4XdIYm1VKilluhOtNwP2d3Ox/JuTBxf7hFHXZPfMagQE5k5PzmxRaCAEMJ1l2D\n+            vUbZw+shJfSNoWcBo2qadnUaWT3BmmJRBDh7ZReib/RQ1Rd4ygOyzP3E0vkV4/gq\n+            yjLdApXh5PZP8KLQZ+1JN/sdWt7VfIt9wYOpkIqujdll51ESHzwQeAK9WVCB4UvV\n+            z6zdhItB9CRbXPreWC+wCB1xDovIzFKOVsLs5+Gqs1m7VinG2LxbDqaKyo/FB0Hx\n+            x0acBNzezLWoDwXYQrN0T0S4pnqhKD1CYPpdArBkNezUYAjS725FkApuK+mnBX3U\n+            0msBffEaUEOkcyar1EW2m/33vpetD/k3eQQkmvQf4Hbiu9AF+9cNDm/hMuXEw5EX\n+            GA91fn0891b5eEW8BJHXX0jri0aN8g==\",\n+            \"MIIELTCCAxWgAwIBAgIUVXGlXjNENtOZbI12epjgIhMaShEwDQYJKoZIhvcNAQEL\n+            BQAwVjELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM\n+            GEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEPMA0GA1UEAwwGdGVzdGNhMB4XDTI0\n+            MDkxNzE2MTk0NFoXDTM0MDkxNTE2MTk0NFowTjELMAkGA1UEBhMCVVMxCzAJBgNV\n+            BAgMAkNBMQwwCgYDVQQHDANTVkwxDTALBgNVBAoMBGdSUEMxFTATBgNVBAMMDHRl\n+            c3QtY2xpZW50MTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOcTjjcS\n+            SfG/EGrr6G+f+3T2GXyHHfroQFi9mZUz80L7uKBdECOImID+YhoK8vcxLQjPmEEv\n+            FIYgJT5amugDcYIgUhMjBx/8RPJaP/nGmBngAqsuuNCaZfyaHBRqN8XdS/AwmsI5\n+            Wo+nru0+0/7aQFdqqtd2+e9dHjUWwgHxXvMgC4hkHpsdCGIZWVzWyBliwTYQYb1Y\n+            yYe1LzqqQA5OMbZfKOY9MYDCEYOliRiunOn30iIOHj9V5qLzWGfSyxCRuvLRdEP8\n+            iDeNweHbdaKuI80nQmxuBdRIspE9k5sD1WA4vLZpeg3zggxp4rfLL5zBJgb/33D3\n+            d9Rkm14xfDPihhkCAwEAAaOB+jCB9zBZBgNVHREEUjBQhiZzcGlmZmU6Ly9mb28u\n+            YmFyLmNvbS9jbGllbnQvd29ya2xvYWQvMYYmc3BpZmZlOi8vZm9vLmJhci5jb20v\n+            Y2xpZW50L3dvcmtsb2FkLzIwHQYDVR0OBBYEFG9GkBgdBg/p0U9/lXv8zIJ+2c2N\n+            MHsGA1UdIwR0MHKhWqRYMFYxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0\n+            YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxDzANBgNVBAMM\n+            BnRlc3RjYYIUWrP0VvHcy+LP6UuYNtiL9gBhD5owDQYJKoZIhvcNAQELBQADggEB\n+            AJ4Cbxv+02SpUgkEu4hP/1+8DtSBXUxNxI0VG4e3Ap2+Rhjm3YiFeS/UeaZhNrrw\n+            UEjkSTPFODyXR7wI7UO9OO1StyD6CMkp3SEvevU5JsZtGL6mTiTLTi3Qkywa91Bt\n+            GlyZdVMghA1bBJLBMwiD5VT5noqoJBD7hDy6v9yNmt1Sw2iYBJPqI3Gnf5bMjR3s\n+            UICaxmFyqaMCZsPkfJh0DmZpInGJys3m4QqGz6ZE2DWgcSr1r/ML7/5bSPjjr8j4\n+            WFFSqFR3dMu8CbGnfZTCTXa4GTX/rARXbAO67Z/oJbJBK7VKayskL+PzKuohb9ox\n+            jGL772hQMbwtFCOFXu5VP0s=\"]\n+            }\n+          ]\n+    }\n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_root.json b/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_root.json\nnew file mode 100644\nindex 00000000000..90d2847dc05\n--- /dev/null\n+++ b/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_root.json\n@@ -0,0 +1,6 @@\n+{\n+  \"trustDomains\": {\n+    \"test.google.com\": {},\n+    \"test.google.com.au\": {}\n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_seq_type.json b/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_seq_type.json\nnew file mode 100644\nindex 00000000000..4e0aeacc89f\n--- /dev/null\n+++ b/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_seq_type.json\n@@ -0,0 +1,12 @@\n+{\n+  \"trust_domains\": {\n+    \"google.com\": {\n+      \"spiffe_sequence\": 123.5,\n+      \"keys\": [\n+        {\n+          \"x5c\": \"VALUE_DOESN'T_MATTER\"\n+        }\n+      ]\n+    }\n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_use.json b/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_use.json\nnew file mode 100644\nindex 00000000000..166be04846c\n--- /dev/null\n+++ b/core/src/test/resources/io/grpc/internal/spiffebundle_wrong_use.json\n@@ -0,0 +1,13 @@\n+{\n+  \"trust_domains\": {\n+    \"google.com\": {\n+      \"keys\": [\n+        {\n+          \"kty\": \"RSA\",\n+          \"use\": \"i_am_not_x509-svid\",\n+          \"x5c\": \"VALUE_DOESN'T_MATTER\"\n+        }\n+      ]\n+    }\n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/gcp-observability/src/test/java/io/grpc/gcp/observability/ObservabilityConfigImplTest.java b/gcp-observability/src/test/java/io/grpc/gcp/observability/ObservabilityConfigImplTest.java\nindex a9e0d6e2235..f409a149bf1 100644\n--- a/gcp-observability/src/test/java/io/grpc/gcp/observability/ObservabilityConfigImplTest.java\n+++ b/gcp-observability/src/test/java/io/grpc/gcp/observability/ObservabilityConfigImplTest.java\n@@ -108,8 +108,7 @@ public class ObservabilityConfigImplTest {\n \n   private static final String PROJECT_ID = \"{\\n\"\n       + \"    \\\"project_id\\\": \\\"grpc-testing\\\",\\n\"\n-      + \"    \\\"cloud_logging\\\": {},\\n\"\n-      + \"    \\\"project_id\\\": \\\"grpc-testing\\\"\\n\"\n+      + \"    \\\"cloud_logging\\\": {}\\n\"\n       + \"}\";\n \n   private static final String EMPTY_CONFIG = \"{}\";\n\ndiff --git a/testing/src/main/resources/certs/spiffe-openssl.cnf b/testing/src/main/resources/certs/spiffe-openssl.cnf\nnew file mode 100644\nindex 00000000000..40c473da7e5\n--- /dev/null\n+++ b/testing/src/main/resources/certs/spiffe-openssl.cnf\n@@ -0,0 +1,12 @@\n+[spiffe_client]\n+subjectAltName = @alt_names\n+\n+[spiffe_client_multi]\n+subjectAltName = @alt_names_multi\n+\n+[alt_names]\n+URI = spiffe://foo.bar.com/client/workload/1\n+\n+[alt_names_multi]\n+URI.1 = spiffe://foo.bar.com/client/workload/1\n+URI.2 = spiffe://foo.bar.com/client/workload/2\n\\ No newline at end of file\n\ndiff --git a/testing/src/main/resources/certs/spiffe_cert.pem b/testing/src/main/resources/certs/spiffe_cert.pem\nnew file mode 100644\nindex 00000000000..bc070042f69\n--- /dev/null\n+++ b/testing/src/main/resources/certs/spiffe_cert.pem\n@@ -0,0 +1,33 @@\n+-----BEGIN CERTIFICATE-----\n+MIIFsjCCA5qgAwIBAgIURygVMMzdr+Q7rsUaz189JozyHMwwDQYJKoZIhvcNAQEL\n+BQAwTjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANTVkwxDTAL\n+BgNVBAoMBGdSUEMxFTATBgNVBAMMDHRlc3QtY2xpZW50MTAeFw0yMTEyMjMxODQy\n+NTJaFw0zMTEyMjExODQyNTJaME4xCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEM\n+MAoGA1UEBwwDU1ZMMQ0wCwYDVQQKDARnUlBDMRUwEwYDVQQDDAx0ZXN0LWNsaWVu\n+dDEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDJ4AqpGetyVSqGUuBJ\n+LVFla+7bEfca7UYzfVSSZLZ/X+JDmWIVN8UIPuFib5jhMEc3XaUnFXUmM7zEtz/Z\n+G5hapwLwOb2C3ZxOP6PQjYCJxbkLie+b43UQrFu1xxd3vMhVJgcj/AIxEpmszuqO\n+a6kUrkYifjJADQ+64kZgl66bsTdXMCzpxyFl9xUfff59L8OX+HUfAcoZz3emjg3Z\n+JPYURQEmjdZTOau1EjFilwHgd989Jt7NKgx30NXoHmw7nusVBIY94fL2VKN3f1XV\n+m0dHu5NI279Q6zr0ZBU7k5T3IeHnzsUesQS4NGlklDWoVTKk73Uv9Pna8yQsSW75\n+7PEbHOGp9Knu4bnoGPOlsG81yIPipO6hTgGFK24pF97M9kpGbWqYX4+2vLlrCAfc\n+msHqaUPmQlYeRVTT6vw7ctYo2kyUYGtnODXk76LqewRBVvkzx75QUhfjAyb740Yc\n+DmIenc56Tq6gebJHjhEmVSehR6xIpXP7SVeurTyhPsEQnpJHtgs4dcwWOZp7BvPN\n+zHXmJqfr7vsshie3vS5kQ0u1e1yqAqXgyDjqKXOkx+dpgUTehSJHhPNHvTc5LXRs\n+vvXKYz6FrwR/DZ8t7BNEvPeLjFgxpH7QVJFLCvCbXs5K6yYbsnLfxFIBPRnrbJkI\n+sK+sQwnRdnsiUdPsTkG5B2lQfQIDAQABo4GHMIGEMB0GA1UdDgQWBBQ2lBp0PiRH\n+HvQ5IRURm8aHsj4RETAfBgNVHSMEGDAWgBQ2lBp0PiRHHvQ5IRURm8aHsj4RETAP\n+BgNVHRMBAf8EBTADAQH/MDEGA1UdEQQqMCiGJnNwaWZmZTovL2Zvby5iYXIuY29t\n+L2NsaWVudC93b3JrbG9hZC8xMA0GCSqGSIb3DQEBCwUAA4ICAQA1mSkgRclAl+E/\n+aS9zJ7t8+Y4n3T24nOKKveSIjxXm/zjhWqVsLYBI6kglWtih2+PELvU8JdPqNZK3\n+4Kl0Q6FWpVSGDdWN1i6NyORt2ocggL3ke3iXxRk3UpUKJmqwz81VhA2KUHnMlyE0\n+IufFfZNwNWWHBv13uJfRbjeQpKPhU+yf4DeXrsWcvrZlGvAET+mcplafUzCp7Iv+\n+PcISJtUerbxbVtuHVeZCLlgDXWkLAWJN8rf0dIG4x060LJ+j6j9uRVhb9sZn1HJV\n++j4XdIYm1VKilluhOtNwP2d3Ox/JuTBxf7hFHXZPfMagQE5k5PzmxRaCAEMJ1l2D\n+vUbZw+shJfSNoWcBo2qadnUaWT3BmmJRBDh7ZReib/RQ1Rd4ygOyzP3E0vkV4/gq\n+yjLdApXh5PZP8KLQZ+1JN/sdWt7VfIt9wYOpkIqujdll51ESHzwQeAK9WVCB4UvV\n+z6zdhItB9CRbXPreWC+wCB1xDovIzFKOVsLs5+Gqs1m7VinG2LxbDqaKyo/FB0Hx\n+x0acBNzezLWoDwXYQrN0T0S4pnqhKD1CYPpdArBkNezUYAjS725FkApuK+mnBX3U\n+0msBffEaUEOkcyar1EW2m/33vpetD/k3eQQkmvQf4Hbiu9AF+9cNDm/hMuXEw5EX\n+GA91fn0891b5eEW8BJHXX0jri0aN8g==\n+-----END CERTIFICATE-----\n\\ No newline at end of file\n\ndiff --git a/testing/src/main/resources/certs/spiffe_multi_uri_san_cert.pem b/testing/src/main/resources/certs/spiffe_multi_uri_san_cert.pem\nnew file mode 100644\nindex 00000000000..eb5c879abf8\n--- /dev/null\n+++ b/testing/src/main/resources/certs/spiffe_multi_uri_san_cert.pem\n@@ -0,0 +1,25 @@\n+-----BEGIN CERTIFICATE-----\n+MIIELTCCAxWgAwIBAgIUVXGlXjNENtOZbI12epjgIhMaShEwDQYJKoZIhvcNAQEL\n+BQAwVjELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM\n+GEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEPMA0GA1UEAwwGdGVzdGNhMB4XDTI0\n+MDkxNzE2MTk0NFoXDTM0MDkxNTE2MTk0NFowTjELMAkGA1UEBhMCVVMxCzAJBgNV\n+BAgMAkNBMQwwCgYDVQQHDANTVkwxDTALBgNVBAoMBGdSUEMxFTATBgNVBAMMDHRl\n+c3QtY2xpZW50MTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOcTjjcS\n+SfG/EGrr6G+f+3T2GXyHHfroQFi9mZUz80L7uKBdECOImID+YhoK8vcxLQjPmEEv\n+FIYgJT5amugDcYIgUhMjBx/8RPJaP/nGmBngAqsuuNCaZfyaHBRqN8XdS/AwmsI5\n+Wo+nru0+0/7aQFdqqtd2+e9dHjUWwgHxXvMgC4hkHpsdCGIZWVzWyBliwTYQYb1Y\n+yYe1LzqqQA5OMbZfKOY9MYDCEYOliRiunOn30iIOHj9V5qLzWGfSyxCRuvLRdEP8\n+iDeNweHbdaKuI80nQmxuBdRIspE9k5sD1WA4vLZpeg3zggxp4rfLL5zBJgb/33D3\n+d9Rkm14xfDPihhkCAwEAAaOB+jCB9zBZBgNVHREEUjBQhiZzcGlmZmU6Ly9mb28u\n+YmFyLmNvbS9jbGllbnQvd29ya2xvYWQvMYYmc3BpZmZlOi8vZm9vLmJhci5jb20v\n+Y2xpZW50L3dvcmtsb2FkLzIwHQYDVR0OBBYEFG9GkBgdBg/p0U9/lXv8zIJ+2c2N\n+MHsGA1UdIwR0MHKhWqRYMFYxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0\n+YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxDzANBgNVBAMM\n+BnRlc3RjYYIUWrP0VvHcy+LP6UuYNtiL9gBhD5owDQYJKoZIhvcNAQELBQADggEB\n+AJ4Cbxv+02SpUgkEu4hP/1+8DtSBXUxNxI0VG4e3Ap2+Rhjm3YiFeS/UeaZhNrrw\n+UEjkSTPFODyXR7wI7UO9OO1StyD6CMkp3SEvevU5JsZtGL6mTiTLTi3Qkywa91Bt\n+GlyZdVMghA1bBJLBMwiD5VT5noqoJBD7hDy6v9yNmt1Sw2iYBJPqI3Gnf5bMjR3s\n+UICaxmFyqaMCZsPkfJh0DmZpInGJys3m4QqGz6ZE2DWgcSr1r/ML7/5bSPjjr8j4\n+WFFSqFR3dMu8CbGnfZTCTXa4GTX/rARXbAO67Z/oJbJBK7VKayskL+PzKuohb9ox\n+jGL772hQMbwtFCOFXu5VP0s=\n+-----END CERTIFICATE-----\n\\ No newline at end of file\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11562",
    "pr_id": 11562,
    "issue_id": 10245,
    "repo": "grpc/grpc-java",
    "problem_statement": "Add java.time.Duration overloads to CallOptions, AbstractStub, Deadline, and other APIs\n### Is your feature request related to a problem?\r\n`long, TimeUnit` APIs encourage plumbing a pair of variables through various layers, or require plumbing a single ambiguous numeric primitive (e.g., `long deadlineInSeconds`). The modern alternative is to use a `java.time.Duration`.\r\n\r\n### Describe the solution you'd like\r\nEvery API that requests a `long, TimeUnit` should have a `java.time.Duration` overload as well\r\n\r\n### Describe alternatives you've considered\r\nn/a\r\n\r\n### Additional context\r\nn/a\r\n",
    "issue_word_count": 87,
    "test_files_count": 4,
    "non_test_files_count": 6,
    "pr_changed_files": [
      "api/src/main/java/io/grpc/CallOptions.java",
      "api/src/main/java/io/grpc/InternalTimeUtils.java",
      "api/src/main/java/io/grpc/LoadBalancer.java",
      "api/src/main/java/io/grpc/SynchronizationContext.java",
      "api/src/main/java/io/grpc/TimeUtils.java",
      "api/src/test/java/io/grpc/CallOptionsTest.java",
      "api/src/test/java/io/grpc/SynchronizationContextTest.java",
      "api/src/test/java/io/grpc/TimeUtilsTest.java",
      "stub/src/main/java/io/grpc/stub/AbstractStub.java",
      "stub/src/test/java/io/grpc/stub/AbstractStubTest.java"
    ],
    "pr_changed_test_files": [
      "api/src/test/java/io/grpc/CallOptionsTest.java",
      "api/src/test/java/io/grpc/SynchronizationContextTest.java",
      "api/src/test/java/io/grpc/TimeUtilsTest.java",
      "stub/src/test/java/io/grpc/stub/AbstractStubTest.java"
    ],
    "base_commit": "b5ef09c5483d23ccdd7888e879d45f4054ad63f7",
    "head_commit": "761a8121eef3938b76ffdb51867b528a255edda4",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11562",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11562",
    "dockerfile": "",
    "pr_merged_at": "2024-10-30T13:19:53.000Z",
    "patch": "diff --git a/api/src/main/java/io/grpc/CallOptions.java b/api/src/main/java/io/grpc/CallOptions.java\nindex 25c4df386a1..a1b8984c48b 100644\n--- a/api/src/main/java/io/grpc/CallOptions.java\n+++ b/api/src/main/java/io/grpc/CallOptions.java\n@@ -17,9 +17,11 @@\n package io.grpc;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static io.grpc.TimeUtils.convertToNanos;\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n+import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -176,6 +178,11 @@ public CallOptions withDeadlineAfter(long duration, TimeUnit unit) {\n     return withDeadline(Deadline.after(duration, unit));\n   }\n \n+  @ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/11657\")\n+  public CallOptions withDeadlineAfter(Duration duration) {\n+    return withDeadlineAfter(convertToNanos(duration), TimeUnit.NANOSECONDS);\n+  }\n+\n   /**\n    * Returns the deadline or {@code null} if the deadline is not set.\n    */\n\ndiff --git a/api/src/main/java/io/grpc/InternalTimeUtils.java b/api/src/main/java/io/grpc/InternalTimeUtils.java\nnew file mode 100644\nindex 00000000000..ef8022f53c5\n--- /dev/null\n+++ b/api/src/main/java/io/grpc/InternalTimeUtils.java\n@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2024 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc;\n+\n+import java.time.Duration;\n+\n+@Internal\n+public final class InternalTimeUtils {\n+  public static long convert(Duration duration) {\n+    return TimeUtils.convertToNanos(duration);\n+  }\n+}\n\ndiff --git a/api/src/main/java/io/grpc/LoadBalancer.java b/api/src/main/java/io/grpc/LoadBalancer.java\nindex 6d74006b396..52d37f8677d 100644\n--- a/api/src/main/java/io/grpc/LoadBalancer.java\n+++ b/api/src/main/java/io/grpc/LoadBalancer.java\n@@ -212,7 +212,7 @@ public Status acceptResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n    *\n    * @since 1.21.0\n    */\n-  @ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/1771\")\n+  @ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/11657\")\n   public static final class ResolvedAddresses {\n     private final List<EquivalentAddressGroup> addresses;\n     @NameResolver.ResolutionResultAttr\n\ndiff --git a/api/src/main/java/io/grpc/SynchronizationContext.java b/api/src/main/java/io/grpc/SynchronizationContext.java\nindex 5a7677ac15f..94916a1b473 100644\n--- a/api/src/main/java/io/grpc/SynchronizationContext.java\n+++ b/api/src/main/java/io/grpc/SynchronizationContext.java\n@@ -18,8 +18,10 @@\n \n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.base.Preconditions.checkState;\n+import static io.grpc.TimeUtils.convertToNanos;\n \n import java.lang.Thread.UncaughtExceptionHandler;\n+import java.time.Duration;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.Executor;\n@@ -162,6 +164,12 @@ public String toString() {\n     return new ScheduledHandle(runnable, future);\n   }\n \n+  @ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/11657\")\n+  public final ScheduledHandle schedule(\n+      final Runnable task, Duration delay, ScheduledExecutorService timerService) {\n+    return schedule(task, convertToNanos(delay), TimeUnit.NANOSECONDS, timerService);\n+  }\n+\n   /**\n    * Schedules a task to be added and run via {@link #execute} after an initial delay and then\n    * repeated after the delay until cancelled.\n@@ -193,6 +201,14 @@ public String toString() {\n     return new ScheduledHandle(runnable, future);\n   }\n \n+  @ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/11657\")\n+  public final ScheduledHandle scheduleWithFixedDelay(\n+      final Runnable task, Duration initialDelay, Duration delay,\n+      ScheduledExecutorService timerService) {\n+    return scheduleWithFixedDelay(task, convertToNanos(initialDelay), convertToNanos(delay),\n+        TimeUnit.NANOSECONDS, timerService);\n+  }\n+\n \n   private static class ManagedRunnable implements Runnable {\n     final Runnable task;\n@@ -246,4 +262,4 @@ public boolean isPending() {\n       return !(runnable.hasStarted || runnable.isCancelled);\n     }\n   }\n-}\n+}\n\\ No newline at end of file\n\ndiff --git a/api/src/main/java/io/grpc/TimeUtils.java b/api/src/main/java/io/grpc/TimeUtils.java\nnew file mode 100644\nindex 00000000000..c3031f13d94\n--- /dev/null\n+++ b/api/src/main/java/io/grpc/TimeUtils.java\n@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2024 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc;\n+\n+import java.time.Duration;\n+\n+final class TimeUtils {\n+  private TimeUtils() {}\n+\n+  static long convertToNanos(Duration duration) {\n+    try {\n+      return duration.toNanos();\n+    } catch (ArithmeticException tooBig) {\n+      return duration.isNegative() ? Long.MIN_VALUE : Long.MAX_VALUE;\n+    }\n+  }\n+}\n\ndiff --git a/stub/src/main/java/io/grpc/stub/AbstractStub.java b/stub/src/main/java/io/grpc/stub/AbstractStub.java\nindex 0b6f86f2acf..06dd55ff466 100644\n--- a/stub/src/main/java/io/grpc/stub/AbstractStub.java\n+++ b/stub/src/main/java/io/grpc/stub/AbstractStub.java\n@@ -17,6 +17,7 @@\n package io.grpc.stub;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.InternalTimeUtils.convert;\n \n import io.grpc.CallCredentials;\n import io.grpc.CallOptions;\n@@ -26,6 +27,7 @@\n import io.grpc.Deadline;\n import io.grpc.ExperimentalApi;\n import io.grpc.ManagedChannelBuilder;\n+import java.time.Duration;\n import java.util.concurrent.Executor;\n import java.util.concurrent.TimeUnit;\n import javax.annotation.CheckReturnValue;\n@@ -149,6 +151,11 @@ public final S withDeadlineAfter(long duration, TimeUnit unit) {\n     return build(channel, callOptions.withDeadlineAfter(duration, unit));\n   }\n \n+  @ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/11657\")\n+  public final S withDeadlineAfter(Duration duration) {\n+    return withDeadlineAfter(convert(duration), TimeUnit.NANOSECONDS);\n+  }\n+\n   /**\n    * Returns a new stub with the given executor that is to be used instead of the default one\n    * specified with {@link ManagedChannelBuilder#executor}. Note that setting this option may not\n",
    "test_patch": "diff --git a/api/src/test/java/io/grpc/CallOptionsTest.java b/api/src/test/java/io/grpc/CallOptionsTest.java\nindex cc90a9799d7..d74c74ccd66 100644\n--- a/api/src/test/java/io/grpc/CallOptionsTest.java\n+++ b/api/src/test/java/io/grpc/CallOptionsTest.java\n@@ -32,6 +32,7 @@\n import com.google.common.base.Objects;\n import io.grpc.ClientStreamTracer.StreamInfo;\n import io.grpc.internal.SerializingExecutor;\n+import java.time.Duration;\n import java.util.concurrent.Executor;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -150,6 +151,14 @@ public void withDeadlineAfter() {\n     assertAbout(deadline()).that(actual).isWithin(10, MILLISECONDS).of(expected);\n   }\n \n+  @Test\n+  public void withDeadlineAfterDuration() {\n+    Deadline actual = CallOptions.DEFAULT.withDeadlineAfter(Duration.ofMinutes(1L)).getDeadline();\n+    Deadline expected = Deadline.after(1, MINUTES);\n+\n+    assertAbout(deadline()).that(actual).isWithin(10, MILLISECONDS).of(expected);\n+  }\n+\n   @Test\n   public void toStringMatches_noDeadline_default() {\n     String actual = allSet\n\ndiff --git a/api/src/test/java/io/grpc/SynchronizationContextTest.java b/api/src/test/java/io/grpc/SynchronizationContextTest.java\nindex 3d5e7fa42b9..f0797df227e 100644\n--- a/api/src/test/java/io/grpc/SynchronizationContextTest.java\n+++ b/api/src/test/java/io/grpc/SynchronizationContextTest.java\n@@ -27,6 +27,7 @@\n \n import com.google.common.util.concurrent.testing.TestingExecutors;\n import io.grpc.SynchronizationContext.ScheduledHandle;\n+import java.time.Duration;\n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.LinkedBlockingQueue;\n@@ -72,7 +73,7 @@ public void uncaughtException(Thread t, Throwable e) {\n \n   @Mock\n   private Runnable task3;\n-  \n+\n   @After public void tearDown() {\n     assertThat(uncaughtErrors).isEmpty();\n   }\n@@ -246,6 +247,41 @@ public void schedule() {\n     verify(task1).run();\n   }\n \n+  @Test\n+  public void scheduleDuration() {\n+    MockScheduledExecutorService executorService = new MockScheduledExecutorService();\n+    ScheduledHandle handle =\n+        syncContext.schedule(task1, Duration.ofSeconds(10), executorService);\n+\n+    assertThat(executorService.delay)\n+        .isEqualTo(executorService.unit.convert(10, TimeUnit.SECONDS));\n+    assertThat(handle.isPending()).isTrue();\n+    verify(task1, never()).run();\n+\n+    executorService.command.run();\n+\n+    assertThat(handle.isPending()).isFalse();\n+    verify(task1).run();\n+  }\n+\n+  @Test\n+  public void scheduleWithFixedDelayDuration() {\n+    MockScheduledExecutorService executorService = new MockScheduledExecutorService();\n+    ScheduledHandle handle =\n+        syncContext.scheduleWithFixedDelay(task1, Duration.ofSeconds(10),\n+            Duration.ofSeconds(10), executorService);\n+\n+    assertThat(executorService.delay)\n+        .isEqualTo(executorService.unit.convert(10, TimeUnit.SECONDS));\n+    assertThat(handle.isPending()).isTrue();\n+    verify(task1, never()).run();\n+\n+    executorService.command.run();\n+\n+    assertThat(handle.isPending()).isFalse();\n+    verify(task1).run();\n+  }\n+\n   @Test\n   public void scheduleDueImmediately() {\n     MockScheduledExecutorService executorService = new MockScheduledExecutorService();\n@@ -357,5 +393,13 @@ static class MockScheduledExecutorService extends ForwardingScheduledExecutorSer\n       this.unit = unit;\n       return future = super.schedule(command, delay, unit);\n     }\n+\n+    @Override public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long intialDelay,\n+        long delay, TimeUnit unit) {\n+      this.command = command;\n+      this.delay = delay;\n+      this.unit = unit;\n+      return future = super.scheduleWithFixedDelay(command, intialDelay, delay, unit);\n+    }\n   }\n-}\n+}\n\\ No newline at end of file\n\ndiff --git a/api/src/test/java/io/grpc/TimeUtilsTest.java b/api/src/test/java/io/grpc/TimeUtilsTest.java\nnew file mode 100644\nindex 00000000000..4faaa9cbf6d\n--- /dev/null\n+++ b/api/src/test/java/io/grpc/TimeUtilsTest.java\n@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2024 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.time.Duration;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link TimeUtils}. */\n+@RunWith(JUnit4.class)\n+public class TimeUtilsTest {\n+\n+  @Test\n+  public void testConvertNormalDuration() {\n+    Duration duration = Duration.ofSeconds(10);\n+    long expected = 10 * 1_000_000_000L;\n+\n+    assertEquals(expected, TimeUtils.convertToNanos(duration));\n+  }\n+\n+  @Test\n+  public void testConvertNegativeDuration() {\n+    Duration duration = Duration.ofSeconds(-3);\n+    long expected = -3 * 1_000_000_000L;\n+\n+    assertEquals(expected, TimeUtils.convertToNanos(duration));\n+  }\n+\n+  @Test\n+  public void testConvertTooLargeDuration() {\n+    Duration duration = Duration.ofSeconds(Long.MAX_VALUE / 1_000_000_000L + 1);\n+\n+    assertEquals(Long.MAX_VALUE, TimeUtils.convertToNanos(duration));\n+  }\n+\n+  @Test\n+  public void testConvertTooLargeNegativeDuration() {\n+    Duration duration = Duration.ofSeconds(Long.MIN_VALUE / 1_000_000_000L - 1);\n+\n+    assertEquals(Long.MIN_VALUE, TimeUtils.convertToNanos(duration));\n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/stub/src/test/java/io/grpc/stub/AbstractStubTest.java b/stub/src/test/java/io/grpc/stub/AbstractStubTest.java\nindex 9006b8679e4..a167c735160 100644\n--- a/stub/src/test/java/io/grpc/stub/AbstractStubTest.java\n+++ b/stub/src/test/java/io/grpc/stub/AbstractStubTest.java\n@@ -16,12 +16,18 @@\n \n package io.grpc.stub;\n \n+import static com.google.common.truth.Truth.assertAbout;\n import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.testing.DeadlineSubject.deadline;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n \n import io.grpc.CallOptions;\n import io.grpc.Channel;\n+import io.grpc.Deadline;\n import io.grpc.stub.AbstractStub.StubFactory;\n import io.grpc.stub.AbstractStubTest.NoopStub;\n+import java.time.Duration;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n@@ -47,8 +53,22 @@ public NoopStub newStub(Channel channel, CallOptions callOptions) {\n         .isNull();\n   }\n \n-  class NoopStub extends AbstractStub<NoopStub> {\n+  @Test\n+  public void testDuration() {\n+    NoopStub stub = NoopStub.newStub(new StubFactory<NoopStub>() {\n+      @Override\n+      public NoopStub newStub(Channel channel, CallOptions callOptions) {\n+        return create(channel, callOptions);\n+      }\n+    }, channel, CallOptions.DEFAULT);\n+    NoopStub stubInstance = stub.withDeadlineAfter(Duration.ofMinutes(1L));\n+    Deadline actual = stubInstance.getCallOptions().getDeadline();\n+    Deadline expected = Deadline.after(1, MINUTES);\n \n+    assertAbout(deadline()).that(actual).isWithin(10, MILLISECONDS).of(expected);\n+  }\n+\n+  class NoopStub extends AbstractStub<NoopStub> {\n     NoopStub(Channel channel, CallOptions options) {\n       super(channel, options);\n     }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11558",
    "pr_id": 11558,
    "issue_id": 11550,
    "repo": "grpc/grpc-java",
    "problem_statement": "v1.67.0 tag has 1.68.0 version number\nhttps://github.com/grpc/grpc-java/commit/b570d071e3787b83a08bdf3b7a84a581fa6e5fca\r\n\r\nNote that the PR was fine. https://github.com/grpc/grpc-java/pull/11536\r\n\r\nWhat probably happened was a mess-up when creating the release commits. Then deleting them and starting over, but _not_ deleting the tag. And then when creating the new commits _failing_ to create the tag (ignoring the error message).\r\n\r\nWe'll need to create a 1.67.1 since the 1.67.0 tag is \"spent\" (never re-create a tag after it has been pushed to the main repo; you can potentially delete a tag, but never create something new in its place).\r\n\r\nAnd then for v1.68.x we'll need to skip over 1.68.0. That may turn out to be pretty annoying. We can check whether we can revoke v1.68.0, but even if we can, we need to skip over the version number when releasing v1.68.x.\r\n\r\n@kannanjgithub ",
    "issue_word_count": 168,
    "test_files_count": 2,
    "non_test_files_count": 32,
    "pr_changed_files": [
      "MODULE.bazel",
      "README.md",
      "build.gradle",
      "compiler/src/test/golden/TestDeprecatedService.java.txt",
      "compiler/src/test/golden/TestService.java.txt",
      "core/src/main/java/io/grpc/internal/GrpcUtil.java",
      "examples/android/clientcache/app/build.gradle",
      "examples/android/helloworld/app/build.gradle",
      "examples/android/routeguide/app/build.gradle",
      "examples/android/strictmode/app/build.gradle",
      "examples/build.gradle",
      "examples/example-alts/build.gradle",
      "examples/example-debug/build.gradle",
      "examples/example-debug/pom.xml",
      "examples/example-dualstack/build.gradle",
      "examples/example-dualstack/pom.xml",
      "examples/example-gauth/build.gradle",
      "examples/example-gauth/pom.xml",
      "examples/example-gcp-csm-observability/build.gradle",
      "examples/example-gcp-observability/build.gradle",
      "examples/example-hostname/build.gradle",
      "examples/example-hostname/pom.xml",
      "examples/example-jwt-auth/build.gradle",
      "examples/example-jwt-auth/pom.xml",
      "examples/example-oauth/build.gradle",
      "examples/example-oauth/pom.xml",
      "examples/example-opentelemetry/build.gradle",
      "examples/example-orca/build.gradle",
      "examples/example-reflection/build.gradle",
      "examples/example-servlet/build.gradle",
      "examples/example-tls/build.gradle",
      "examples/example-tls/pom.xml",
      "examples/example-xds/build.gradle",
      "examples/pom.xml"
    ],
    "pr_changed_test_files": [
      "compiler/src/test/golden/TestDeprecatedService.java.txt",
      "compiler/src/test/golden/TestService.java.txt"
    ],
    "base_commit": "67cab187fdff133498d01d6d350b6e158959d026",
    "head_commit": "f886548322f819b22db1ef7892a433e04a2da084",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11558",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11558",
    "dockerfile": "",
    "pr_merged_at": "2024-09-27T05:16:31.000Z",
    "patch": "diff --git a/MODULE.bazel b/MODULE.bazel\nindex e4761ef7ca7..2ed6d18aa52 100644\n--- a/MODULE.bazel\n+++ b/MODULE.bazel\n@@ -2,7 +2,7 @@ module(\n     name = \"grpc-java\",\n     compatibility_level = 0,\n     repo_name = \"io_grpc_grpc_java\",\n-    version = \"1.67.1-SNAPSHOT\",  # CURRENT_GRPC_VERSION\n+    version = \"1.67.2-SNAPSHOT\",  # CURRENT_GRPC_VERSION\n )\n \n # GRPC_DEPS_START\n\ndiff --git a/README.md b/README.md\nindex 9c6ce5d5e47..f56aebfb3ac 100644\n--- a/README.md\n+++ b/README.md\n@@ -44,8 +44,8 @@ For a guided tour, take a look at the [quick start\n guide](https://grpc.io/docs/languages/java/quickstart) or the more explanatory [gRPC\n basics](https://grpc.io/docs/languages/java/basics).\n \n-The [examples](https://github.com/grpc/grpc-java/tree/v1.66.0/examples) and the\n-[Android example](https://github.com/grpc/grpc-java/tree/v1.66.0/examples/android)\n+The [examples](https://github.com/grpc/grpc-java/tree/v1.67.1/examples) and the\n+[Android example](https://github.com/grpc/grpc-java/tree/v1.67.1/examples/android)\n are standalone projects that showcase the usage of gRPC.\n \n Download\n@@ -56,18 +56,18 @@ Download [the JARs][]. Or for Maven with non-Android, add to your `pom.xml`:\n <dependency>\n   <groupId>io.grpc</groupId>\n   <artifactId>grpc-netty-shaded</artifactId>\n-  <version>1.67.0</version>\n+  <version>1.67.1</version>\n   <scope>runtime</scope>\n </dependency>\n <dependency>\n   <groupId>io.grpc</groupId>\n   <artifactId>grpc-protobuf</artifactId>\n-  <version>1.67.0</version>\n+  <version>1.67.1</version>\n </dependency>\n <dependency>\n   <groupId>io.grpc</groupId>\n   <artifactId>grpc-stub</artifactId>\n-  <version>1.67.0</version>\n+  <version>1.67.1</version>\n </dependency>\n <dependency> <!-- necessary for Java 9+ -->\n   <groupId>org.apache.tomcat</groupId>\n@@ -79,18 +79,18 @@ Download [the JARs][]. Or for Maven with non-Android, add to your `pom.xml`:\n \n Or for Gradle with non-Android, add to your dependencies:\n ```gradle\n-runtimeOnly 'io.grpc:grpc-netty-shaded:1.67.0'\n-implementation 'io.grpc:grpc-protobuf:1.67.0'\n-implementation 'io.grpc:grpc-stub:1.67.0'\n+runtimeOnly 'io.grpc:grpc-netty-shaded:1.67.1'\n+implementation 'io.grpc:grpc-protobuf:1.67.1'\n+implementation 'io.grpc:grpc-stub:1.67.1'\n compileOnly 'org.apache.tomcat:annotations-api:6.0.53' // necessary for Java 9+\n ```\n \n For Android client, use `grpc-okhttp` instead of `grpc-netty-shaded` and\n `grpc-protobuf-lite` instead of `grpc-protobuf`:\n ```gradle\n-implementation 'io.grpc:grpc-okhttp:1.67.0'\n-implementation 'io.grpc:grpc-protobuf-lite:1.67.0'\n-implementation 'io.grpc:grpc-stub:1.67.0'\n+implementation 'io.grpc:grpc-okhttp:1.67.1'\n+implementation 'io.grpc:grpc-protobuf-lite:1.67.1'\n+implementation 'io.grpc:grpc-stub:1.67.1'\n compileOnly 'org.apache.tomcat:annotations-api:6.0.53' // necessary for Java 9+\n ```\n \n@@ -99,7 +99,7 @@ For [Bazel](https://bazel.build), you can either\n (with the GAVs from above), or use `@io_grpc_grpc_java//api` et al (see below).\n \n [the JARs]:\n-https://search.maven.org/search?q=g:io.grpc%20AND%20v:1.66.0\n+https://search.maven.org/search?q=g:io.grpc%20AND%20v:1.67.1\n \n Development snapshots are available in [Sonatypes's snapshot\n repository](https://oss.sonatype.org/content/repositories/snapshots/).\n@@ -131,7 +131,7 @@ For protobuf-based codegen integrated with the Maven build system, you can use\n       <configuration>\n         <protocArtifact>com.google.protobuf:protoc:3.25.3:exe:${os.detected.classifier}</protocArtifact>\n         <pluginId>grpc-java</pluginId>\n-        <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.67.0:exe:${os.detected.classifier}</pluginArtifact>\n+        <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.67.1:exe:${os.detected.classifier}</pluginArtifact>\n       </configuration>\n       <executions>\n         <execution>\n@@ -161,7 +161,7 @@ protobuf {\n   }\n   plugins {\n     grpc {\n-      artifact = 'io.grpc:protoc-gen-grpc-java:1.67.0'\n+      artifact = 'io.grpc:protoc-gen-grpc-java:1.67.1'\n     }\n   }\n   generateProtoTasks {\n@@ -194,7 +194,7 @@ protobuf {\n   }\n   plugins {\n     grpc {\n-      artifact = 'io.grpc:protoc-gen-grpc-java:1.67.0'\n+      artifact = 'io.grpc:protoc-gen-grpc-java:1.67.1'\n     }\n   }\n   generateProtoTasks {\n\ndiff --git a/build.gradle b/build.gradle\nindex bf6e8c2f0d2..2c6e9ec43eb 100644\n--- a/build.gradle\n+++ b/build.gradle\n@@ -21,7 +21,7 @@ subprojects {\n     apply plugin: \"net.ltgt.errorprone\"\n \n     group = \"io.grpc\"\n-    version = \"1.67.1-SNAPSHOT\" // CURRENT_GRPC_VERSION\n+    version = \"1.67.2-SNAPSHOT\" // CURRENT_GRPC_VERSION\n \n     repositories {\n         maven { // The google mirror is less flaky than mavenCentral()\n\ndiff --git a/core/src/main/java/io/grpc/internal/GrpcUtil.java b/core/src/main/java/io/grpc/internal/GrpcUtil.java\nindex 0975d44aaf7..ebf923d1f30 100644\n--- a/core/src/main/java/io/grpc/internal/GrpcUtil.java\n+++ b/core/src/main/java/io/grpc/internal/GrpcUtil.java\n@@ -219,7 +219,7 @@ public byte[] parseAsciiString(byte[] serialized) {\n \n   public static final Splitter ACCEPT_ENCODING_SPLITTER = Splitter.on(',').trimResults();\n \n-  public static final String IMPLEMENTATION_VERSION = \"1.67.1-SNAPSHOT\"; // CURRENT_GRPC_VERSION\n+  public static final String IMPLEMENTATION_VERSION = \"1.67.2-SNAPSHOT\"; // CURRENT_GRPC_VERSION\n \n   /**\n    * The default timeout in nanos for a keepalive ping request.\n\ndiff --git a/examples/android/clientcache/app/build.gradle b/examples/android/clientcache/app/build.gradle\nindex fb00713b836..df14778101b 100644\n--- a/examples/android/clientcache/app/build.gradle\n+++ b/examples/android/clientcache/app/build.gradle\n@@ -34,7 +34,7 @@ android {\n protobuf {\n     protoc { artifact = 'com.google.protobuf:protoc:3.25.1' }\n     plugins {\n-        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n         }\n     }\n     generateProtoTasks {\n@@ -54,12 +54,12 @@ dependencies {\n     implementation 'androidx.appcompat:appcompat:1.0.0'\n \n     // You need to build grpc-java to obtain these libraries below.\n-    implementation 'io.grpc:grpc-okhttp:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-protobuf-lite:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-stub:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-okhttp:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-protobuf-lite:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-stub:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n     implementation 'org.apache.tomcat:annotations-api:6.0.53'\n \n     testImplementation 'junit:junit:4.13.2'\n     testImplementation 'com.google.truth:truth:1.1.5'\n-    testImplementation 'io.grpc:grpc-testing:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    testImplementation 'io.grpc:grpc-testing:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n }\n\ndiff --git a/examples/android/helloworld/app/build.gradle b/examples/android/helloworld/app/build.gradle\nindex 6ea2075ff27..6abe8a83e73 100644\n--- a/examples/android/helloworld/app/build.gradle\n+++ b/examples/android/helloworld/app/build.gradle\n@@ -32,7 +32,7 @@ android {\n protobuf {\n     protoc { artifact = 'com.google.protobuf:protoc:3.25.1' }\n     plugins {\n-        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n         }\n     }\n     generateProtoTasks {\n@@ -52,8 +52,8 @@ dependencies {\n     implementation 'androidx.appcompat:appcompat:1.0.0'\n \n     // You need to build grpc-java to obtain these libraries below.\n-    implementation 'io.grpc:grpc-okhttp:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-protobuf-lite:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-stub:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-okhttp:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-protobuf-lite:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-stub:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n     implementation 'org.apache.tomcat:annotations-api:6.0.53'\n }\n\ndiff --git a/examples/android/routeguide/app/build.gradle b/examples/android/routeguide/app/build.gradle\nindex 16e0a2118c5..bead20ab556 100644\n--- a/examples/android/routeguide/app/build.gradle\n+++ b/examples/android/routeguide/app/build.gradle\n@@ -32,7 +32,7 @@ android {\n protobuf {\n     protoc { artifact = 'com.google.protobuf:protoc:3.25.1' }\n     plugins {\n-        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n         }\n     }\n     generateProtoTasks {\n@@ -52,8 +52,8 @@ dependencies {\n     implementation 'androidx.appcompat:appcompat:1.0.0'\n \n     // You need to build grpc-java to obtain these libraries below.\n-    implementation 'io.grpc:grpc-okhttp:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-protobuf-lite:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-stub:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-okhttp:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-protobuf-lite:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-stub:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n     implementation 'org.apache.tomcat:annotations-api:6.0.53'\n }\n\ndiff --git a/examples/android/strictmode/app/build.gradle b/examples/android/strictmode/app/build.gradle\nindex 8dc5659c2cf..cb34c4fa9a1 100644\n--- a/examples/android/strictmode/app/build.gradle\n+++ b/examples/android/strictmode/app/build.gradle\n@@ -33,7 +33,7 @@ android {\n protobuf {\n     protoc { artifact = 'com.google.protobuf:protoc:3.25.1' }\n     plugins {\n-        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n         }\n     }\n     generateProtoTasks {\n@@ -53,8 +53,8 @@ dependencies {\n     implementation 'androidx.appcompat:appcompat:1.0.0'\n \n     // You need to build grpc-java to obtain these libraries below.\n-    implementation 'io.grpc:grpc-okhttp:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-protobuf-lite:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-stub:1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-okhttp:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-protobuf-lite:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-stub:1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n     implementation 'org.apache.tomcat:annotations-api:6.0.53'\n }\n\ndiff --git a/examples/build.gradle b/examples/build.gradle\nindex 920ba62c5fc..a5495df5579 100644\n--- a/examples/build.gradle\n+++ b/examples/build.gradle\n@@ -23,7 +23,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n def protocVersion = protobufVersion\n \n\ndiff --git a/examples/example-alts/build.gradle b/examples/example-alts/build.gradle\nindex 4c92daff867..2233dd58c0a 100644\n--- a/examples/example-alts/build.gradle\n+++ b/examples/example-alts/build.gradle\n@@ -24,7 +24,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-debug/build.gradle b/examples/example-debug/build.gradle\nindex 849da912c8d..a90a99c5fa6 100644\n--- a/examples/example-debug/build.gradle\n+++ b/examples/example-debug/build.gradle\n@@ -25,7 +25,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-debug/pom.xml b/examples/example-debug/pom.xml\nindex 64aa8810a39..64a1a5c5195 100644\n--- a/examples/example-debug/pom.xml\n+++ b/examples/example-debug/pom.xml\n@@ -6,13 +6,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.1-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.67.2-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-debug</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.1-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.67.2-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for jdk9 -->\n     <maven.compiler.source>1.8</maven.compiler.source>\n\ndiff --git a/examples/example-dualstack/build.gradle b/examples/example-dualstack/build.gradle\nindex 0484a81bbd7..ac05ca3f0a2 100644\n--- a/examples/example-dualstack/build.gradle\n+++ b/examples/example-dualstack/build.gradle\n@@ -25,7 +25,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-dualstack/pom.xml b/examples/example-dualstack/pom.xml\nindex fb5f374d2a1..4598a9c2ada 100644\n--- a/examples/example-dualstack/pom.xml\n+++ b/examples/example-dualstack/pom.xml\n@@ -6,13 +6,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.1-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.67.2-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-dualstack</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.1-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.67.2-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for jdk9 -->\n     <maven.compiler.source>1.8</maven.compiler.source>\n\ndiff --git a/examples/example-gauth/build.gradle b/examples/example-gauth/build.gradle\nindex 11651e38029..bd611efb599 100644\n--- a/examples/example-gauth/build.gradle\n+++ b/examples/example-gauth/build.gradle\n@@ -24,7 +24,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n def protocVersion = protobufVersion\n \n\ndiff --git a/examples/example-gauth/pom.xml b/examples/example-gauth/pom.xml\nindex b604c8969e6..56098ec45e4 100644\n--- a/examples/example-gauth/pom.xml\n+++ b/examples/example-gauth/pom.xml\n@@ -6,13 +6,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.1-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.67.2-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-gauth</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.1-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.67.2-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protobuf.version>3.25.3</protobuf.version>\n     <!-- required for jdk9 -->\n     <maven.compiler.source>1.8</maven.compiler.source>\n\ndiff --git a/examples/example-gcp-csm-observability/build.gradle b/examples/example-gcp-csm-observability/build.gradle\nindex 19c9ad5f0c9..c7011043ea0 100644\n--- a/examples/example-gcp-csm-observability/build.gradle\n+++ b/examples/example-gcp-csm-observability/build.gradle\n@@ -25,7 +25,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n def openTelemetryVersion = '1.40.0'\n def openTelemetryPrometheusVersion = '1.40.0-alpha'\n\ndiff --git a/examples/example-gcp-observability/build.gradle b/examples/example-gcp-observability/build.gradle\nindex fc6b22c4623..572d6c30123 100644\n--- a/examples/example-gcp-observability/build.gradle\n+++ b/examples/example-gcp-observability/build.gradle\n@@ -25,7 +25,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-hostname/build.gradle b/examples/example-hostname/build.gradle\nindex 016dfc45beb..26aefe8a8b9 100644\n--- a/examples/example-hostname/build.gradle\n+++ b/examples/example-hostname/build.gradle\n@@ -23,7 +23,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-hostname/pom.xml b/examples/example-hostname/pom.xml\nindex 820e1eaaa5e..87e98b22655 100644\n--- a/examples/example-hostname/pom.xml\n+++ b/examples/example-hostname/pom.xml\n@@ -6,13 +6,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.1-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.67.2-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-hostname</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.1-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.67.2-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for jdk9 -->\n     <maven.compiler.source>1.8</maven.compiler.source>\n\ndiff --git a/examples/example-jwt-auth/build.gradle b/examples/example-jwt-auth/build.gradle\nindex e826b76a113..2f98d5ade92 100644\n--- a/examples/example-jwt-auth/build.gradle\n+++ b/examples/example-jwt-auth/build.gradle\n@@ -23,7 +23,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n def protocVersion = protobufVersion\n \n\ndiff --git a/examples/example-jwt-auth/pom.xml b/examples/example-jwt-auth/pom.xml\nindex 9714c62a250..8269e0f4955 100644\n--- a/examples/example-jwt-auth/pom.xml\n+++ b/examples/example-jwt-auth/pom.xml\n@@ -7,13 +7,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.1-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.67.2-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-jwt-auth</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.1-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.67.2-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protobuf.version>3.25.3</protobuf.version>\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for jdk9 -->\n\ndiff --git a/examples/example-oauth/build.gradle b/examples/example-oauth/build.gradle\nindex ca2f74d10e4..af09f15b937 100644\n--- a/examples/example-oauth/build.gradle\n+++ b/examples/example-oauth/build.gradle\n@@ -23,7 +23,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n def protocVersion = protobufVersion\n \n\ndiff --git a/examples/example-oauth/pom.xml b/examples/example-oauth/pom.xml\nindex 70edb9d9ec1..801ab5b762f 100644\n--- a/examples/example-oauth/pom.xml\n+++ b/examples/example-oauth/pom.xml\n@@ -7,13 +7,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.1-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.67.2-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-oauth</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.1-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.67.2-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protobuf.version>3.25.3</protobuf.version>\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for jdk9 -->\n\ndiff --git a/examples/example-opentelemetry/build.gradle b/examples/example-opentelemetry/build.gradle\nindex 29cefc3fdea..c9b5742b01e 100644\n--- a/examples/example-opentelemetry/build.gradle\n+++ b/examples/example-opentelemetry/build.gradle\n@@ -24,7 +24,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n def openTelemetryVersion = '1.40.0'\n def openTelemetryPrometheusVersion = '1.40.0-alpha'\n\ndiff --git a/examples/example-orca/build.gradle b/examples/example-orca/build.gradle\nindex 4f656b99196..7d63de5df20 100644\n--- a/examples/example-orca/build.gradle\n+++ b/examples/example-orca/build.gradle\n@@ -18,7 +18,7 @@ java {\n     targetCompatibility = JavaVersion.VERSION_1_8\n }\n \n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-reflection/build.gradle b/examples/example-reflection/build.gradle\nindex 5276a5684ce..999967ac7fa 100644\n--- a/examples/example-reflection/build.gradle\n+++ b/examples/example-reflection/build.gradle\n@@ -18,7 +18,7 @@ java {\n     targetCompatibility = JavaVersion.VERSION_1_8\n }\n \n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-servlet/build.gradle b/examples/example-servlet/build.gradle\nindex eb672bb072e..d6d914407c5 100644\n--- a/examples/example-servlet/build.gradle\n+++ b/examples/example-servlet/build.gradle\n@@ -16,7 +16,7 @@ java {\n     targetCompatibility = JavaVersion.VERSION_1_8\n }\n \n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-tls/build.gradle b/examples/example-tls/build.gradle\nindex 79f279df4ba..fac009d40e4 100644\n--- a/examples/example-tls/build.gradle\n+++ b/examples/example-tls/build.gradle\n@@ -24,7 +24,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-tls/pom.xml b/examples/example-tls/pom.xml\nindex 23c406a03dd..4271974ddc7 100644\n--- a/examples/example-tls/pom.xml\n+++ b/examples/example-tls/pom.xml\n@@ -6,13 +6,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.1-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.67.2-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-tls</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.1-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.67.2-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for jdk9 -->\n     <maven.compiler.source>1.8</maven.compiler.source>\n\ndiff --git a/examples/example-xds/build.gradle b/examples/example-xds/build.gradle\nindex 4b33e8cada8..6e6408d2679 100644\n--- a/examples/example-xds/build.gradle\n+++ b/examples/example-xds/build.gradle\n@@ -23,7 +23,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.1-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.67.2-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/pom.xml b/examples/pom.xml\nindex 8efa14f7ad1..c9cd0d1d287 100644\n--- a/examples/pom.xml\n+++ b/examples/pom.xml\n@@ -6,13 +6,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.1-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.67.2-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>examples</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.1-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.67.2-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protobuf.version>3.25.3</protobuf.version>\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for JDK 8 -->\n",
    "test_patch": "diff --git a/compiler/src/test/golden/TestDeprecatedService.java.txt b/compiler/src/test/golden/TestDeprecatedService.java.txt\nindex 660b41dbe21..0817c3e0df1 100644\n--- a/compiler/src/test/golden/TestDeprecatedService.java.txt\n+++ b/compiler/src/test/golden/TestDeprecatedService.java.txt\n@@ -8,7 +8,7 @@ import static io.grpc.MethodDescriptor.generateFullMethodName;\n  * </pre>\n  */\n @javax.annotation.Generated(\n-    value = \"by gRPC proto compiler (version 1.67.1-SNAPSHOT)\",\n+    value = \"by gRPC proto compiler (version 1.67.2-SNAPSHOT)\",\n     comments = \"Source: grpc/testing/compiler/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n @java.lang.Deprecated\n\ndiff --git a/compiler/src/test/golden/TestService.java.txt b/compiler/src/test/golden/TestService.java.txt\nindex 53960912158..f21bee54438 100644\n--- a/compiler/src/test/golden/TestService.java.txt\n+++ b/compiler/src/test/golden/TestService.java.txt\n@@ -8,7 +8,7 @@ import static io.grpc.MethodDescriptor.generateFullMethodName;\n  * </pre>\n  */\n @javax.annotation.Generated(\n-    value = \"by gRPC proto compiler (version 1.67.1-SNAPSHOT)\",\n+    value = \"by gRPC proto compiler (version 1.67.2-SNAPSHOT)\",\n     comments = \"Source: grpc/testing/compiler/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class TestServiceGrpc {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11530",
    "pr_id": 11530,
    "issue_id": 11527,
    "repo": "grpc/grpc-java",
    "problem_statement": "s2a tests are way too slow\n`io.grpc.s2a.handshaker.IntegrationTest` is taking 40 seconds * 4 = ~3 minutes and `io.grpc.s2a.handshaker.S2AStubTest` takes another 20 seconds. I don't know the source of the delay, as it doesn't seem to be S2AStub.\r\n\r\n@rmehta19",
    "issue_word_count": 46,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "s2a/src/test/java/io/grpc/s2a/handshaker/IntegrationTest.java"
    ],
    "pr_changed_test_files": [
      "s2a/src/test/java/io/grpc/s2a/handshaker/IntegrationTest.java"
    ],
    "base_commit": "5bec9096a2318f7b29022b8c91ea7168f0ddc177",
    "head_commit": "18a3de2267241b7fc20cbafa968f9367a8898305",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11530",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11530",
    "dockerfile": "",
    "pr_merged_at": "2024-09-17T18:12:27.000Z",
    "patch": "",
    "test_patch": "diff --git a/s2a/src/test/java/io/grpc/s2a/handshaker/IntegrationTest.java b/s2a/src/test/java/io/grpc/s2a/handshaker/IntegrationTest.java\nindex 859771a4afa..d9224f69b91 100644\n--- a/s2a/src/test/java/io/grpc/s2a/handshaker/IntegrationTest.java\n+++ b/s2a/src/test/java/io/grpc/s2a/handshaker/IntegrationTest.java\n@@ -180,14 +180,15 @@ public void setUp() throws Exception {\n \n   @After\n   public void tearDown() throws Exception {\n-    server.awaitTermination(10, SECONDS);\n     server.shutdown();\n-    s2aServer.awaitTermination(10, SECONDS);\n     s2aServer.shutdown();\n-    s2aDelayServer.awaitTermination(10, SECONDS);\n     s2aDelayServer.shutdown();\n-    mtlsS2AServer.awaitTermination(10, SECONDS);\n     mtlsS2AServer.shutdown();\n+\n+    server.awaitTermination(10, SECONDS);\n+    s2aServer.awaitTermination(10, SECONDS);\n+    s2aDelayServer.awaitTermination(10, SECONDS);\n+    mtlsS2AServer.awaitTermination(10, SECONDS);\n   }\n \n   @Test\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11513",
    "pr_id": 11513,
    "issue_id": 11413,
    "repo": "grpc/grpc-java",
    "problem_statement": "IS_PETIOLE_POLICY is not used by PickFirstLeafLoadBalancer\nFrom A61 (dual stack):\r\n\r\n> Therefore,\r\npick_first will have an option to support these health signals, and\r\nthat option will be used only when pick_first is used as a child policy\r\nunderneath a petiole policy.\r\n>\r\n> Note that we do not want either of these mechanisms to actually work\r\nwhen pick_first is used as an LB policy by itself, so we will implement\r\nthis functionality in a way that it can be triggered by a parent policy\r\nsuch as round_robin but cannot be triggered by an external application.\r\n(For example, in C-core, this will be triggered via an internal-only\r\nchannel arg that will be set by the petiole policies.)\r\n\r\nIn grpc-java, I think that was being implemented as IS_PETIOLE_POLICY. MultiChildLB sets the value (and ClusterManagerLoadBalancer overrides a method so it isn't set), but nothing appears to read it. Clearly either we should read it or remove it.\r\n\r\nWhen PickFirst is used as a top-level policy, there will not be any health producer, so PF doesn't really need to read the flag. And client-side health checking is only enabled within petiole policies like RR. But if outlier detection is in the tree, like with standard xds, then there would be a health producer and PF wouldn't ignore its health reports.",
    "issue_word_count": 221,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "core/src/main/java/io/grpc/internal/PickFirstLeafLoadBalancer.java",
      "core/src/test/java/io/grpc/internal/PickFirstLeafLoadBalancerTest.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/PickFirstLeafLoadBalancerTest.java"
    ],
    "base_commit": "721d063d554f742c4bed7b698f8cab373f5e0b1d",
    "head_commit": "02ceff710a8f14127fcd409f6a0e068147b683c5",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11513",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11513",
    "dockerfile": "",
    "pr_merged_at": "2024-09-06T18:43:07.000Z",
    "patch": "diff --git a/core/src/main/java/io/grpc/internal/PickFirstLeafLoadBalancer.java b/core/src/main/java/io/grpc/internal/PickFirstLeafLoadBalancer.java\nindex 344012fef2b..bfa462e16e1 100644\n--- a/core/src/main/java/io/grpc/internal/PickFirstLeafLoadBalancer.java\n+++ b/core/src/main/java/io/grpc/internal/PickFirstLeafLoadBalancer.java\n@@ -69,6 +69,7 @@ final class PickFirstLeafLoadBalancer extends LoadBalancer {\n   private ConnectivityState concludedState = IDLE;\n   private final boolean enableHappyEyeballs =\n       PickFirstLoadBalancerProvider.isEnabledHappyEyeballs();\n+  private boolean notAPetiolePolicy = true; // means not under a petiole policy\n \n   PickFirstLeafLoadBalancer(Helper helper) {\n     this.helper = checkNotNull(helper, \"helper\");\n@@ -80,6 +81,10 @@ public Status acceptResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n       return Status.FAILED_PRECONDITION.withDescription(\"Already shut down\");\n     }\n \n+    // Cache whether or not this is a petiole policy, which is based off of an address attribute\n+    Boolean isPetiolePolicy = resolvedAddresses.getAttributes().get(IS_PETIOLE_POLICY);\n+    this.notAPetiolePolicy = isPetiolePolicy == null || !isPetiolePolicy;\n+\n     List<EquivalentAddressGroup> servers = resolvedAddresses.getAddresses();\n \n     // Validate the address list\n@@ -303,7 +308,8 @@ private void updateHealthCheckedState(SubchannelData subchannelData) {\n     if (subchannelData.state != READY) {\n       return;\n     }\n-    if (subchannelData.getHealthState() == READY) {\n+\n+    if (notAPetiolePolicy || subchannelData.getHealthState() == READY) {\n       updateBalancingState(READY,\n           new FixedResultPicker(PickResult.withSubchannel(subchannelData.subchannel)));\n     } else if (subchannelData.getHealthState() == TRANSIENT_FAILURE) {\n@@ -444,7 +450,7 @@ private SubchannelData createNewSubchannel(SocketAddress addr, Attributes attrs)\n     hcListener.subchannelData = subchannelData;\n     subchannels.put(addr, subchannelData);\n     Attributes scAttrs = subchannel.getAttributes();\n-    if (scAttrs.get(LoadBalancer.HAS_HEALTH_PRODUCER_LISTENER_KEY) == null) {\n+    if (notAPetiolePolicy || scAttrs.get(LoadBalancer.HAS_HEALTH_PRODUCER_LISTENER_KEY) == null) {\n       subchannelData.healthStateInfo = ConnectivityStateInfo.forNonError(READY);\n     }\n     subchannel.start(stateInfo -> processSubchannelState(subchannelData, stateInfo));\n@@ -468,6 +474,13 @@ private final class HealthListener implements SubchannelStateListener {\n \n     @Override\n     public void onSubchannelState(ConnectivityStateInfo newState) {\n+      if (notAPetiolePolicy) {\n+        log.log(Level.WARNING,\n+            \"Ignoring health status {0} for subchannel {1} as this is not under a petiole policy\",\n+            new Object[]{newState, subchannelData.subchannel});\n+        return;\n+      }\n+\n       log.log(Level.FINE, \"Received health status {0} for subchannel {1}\",\n           new Object[]{newState, subchannelData.subchannel});\n       subchannelData.healthStateInfo = newState;\n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/PickFirstLeafLoadBalancerTest.java b/core/src/test/java/io/grpc/internal/PickFirstLeafLoadBalancerTest.java\nindex 9c22c4a7086..63915bddc99 100644\n--- a/core/src/test/java/io/grpc/internal/PickFirstLeafLoadBalancerTest.java\n+++ b/core/src/test/java/io/grpc/internal/PickFirstLeafLoadBalancerTest.java\n@@ -25,6 +25,7 @@\n import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n import static io.grpc.LoadBalancer.HAS_HEALTH_PRODUCER_LISTENER_KEY;\n import static io.grpc.LoadBalancer.HEALTH_CONSUMER_LISTENER_ARG_KEY;\n+import static io.grpc.LoadBalancer.IS_PETIOLE_POLICY;\n import static io.grpc.internal.PickFirstLeafLoadBalancer.CONNECTION_DELAY_INTERVAL_MS;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n@@ -389,15 +390,44 @@ public void pickAfterResolvedAndChanged() {\n     verify(mockSubchannel2).requestConnection();\n   }\n \n+  @Test\n+  public void healthCheck_nonPetiolePolicy() {\n+    when(mockSubchannel1.getAttributes()).thenReturn(\n+        Attributes.newBuilder().set(HAS_HEALTH_PRODUCER_LISTENER_KEY, true).build());\n+\n+    // Initialize with one server loadbalancer and both health and state listeners\n+    List<EquivalentAddressGroup> oneServer = Lists.newArrayList(servers.get(0));\n+    loadBalancer.acceptResolvedAddresses(ResolvedAddresses.newBuilder().setAddresses(oneServer)\n+        .setAttributes(Attributes.EMPTY).build());\n+    InOrder inOrder = inOrder(mockHelper, mockSubchannel1);\n+    inOrder.verify(mockHelper).updateBalancingState(eq(CONNECTING), any(SubchannelPicker.class));\n+    inOrder.verify(mockHelper).createSubchannel(createArgsCaptor.capture());\n+    SubchannelStateListener healthListener = createArgsCaptor.getValue()\n+        .getOption(HEALTH_CONSUMER_LISTENER_ARG_KEY);\n+    inOrder.verify(mockSubchannel1).start(stateListenerCaptor.capture());\n+    SubchannelStateListener stateListener = stateListenerCaptor.getValue();\n+\n+    stateListener.onSubchannelState(ConnectivityStateInfo.forNonError(CONNECTING));\n+    healthListener.onSubchannelState(ConnectivityStateInfo.forNonError(CONNECTING));\n+    inOrder.verify(mockHelper, never()).updateBalancingState(any(), any());\n+\n+    stateListener.onSubchannelState(ConnectivityStateInfo.forNonError(READY));\n+    inOrder.verify(mockHelper).updateBalancingState(eq(READY), any()); // health listener ignored\n+\n+    healthListener.onSubchannelState(ConnectivityStateInfo.forTransientFailure(Status.INTERNAL));\n+    inOrder.verify(mockHelper, never()).updateBalancingState(any(), any(SubchannelPicker.class));\n+  }\n+\n   @Test\n   public void healthCheckFlow() {\n     when(mockSubchannel1.getAttributes()).thenReturn(\n         Attributes.newBuilder().set(HAS_HEALTH_PRODUCER_LISTENER_KEY, true).build());\n     when(mockSubchannel2.getAttributes()).thenReturn(\n         Attributes.newBuilder().set(HAS_HEALTH_PRODUCER_LISTENER_KEY, true).build());\n+\n     List<EquivalentAddressGroup> oneServer = Lists.newArrayList(servers.get(0), servers.get(1));\n     loadBalancer.acceptResolvedAddresses(ResolvedAddresses.newBuilder().setAddresses(oneServer)\n-        .setAttributes(Attributes.EMPTY).build());\n+        .setAttributes(Attributes.newBuilder().set(IS_PETIOLE_POLICY, true).build()).build());\n \n     InOrder inOrder = inOrder(mockHelper, mockSubchannel1, mockSubchannel2);\n     inOrder.verify(mockHelper).updateBalancingState(eq(CONNECTING), any(SubchannelPicker.class));\n@@ -413,13 +443,13 @@ public void healthCheckFlow() {\n     // subchannel2 | IDLE      | IDLE\n     stateListener.onSubchannelState(ConnectivityStateInfo.forNonError(CONNECTING));\n     healthListener.onSubchannelState(ConnectivityStateInfo.forNonError(CONNECTING));\n-    inOrder.verify(mockHelper, times(0)).updateBalancingState(any(), any());\n+    inOrder.verify(mockHelper, never()).updateBalancingState(any(), any());\n \n     // subchannel  |  state    |   health\n     // subchannel1 | READY     | CONNECTING\n     // subchannel2 | IDLE      | IDLE\n     stateListener.onSubchannelState(ConnectivityStateInfo.forNonError(READY));\n-    inOrder.verify(mockHelper, times(0)).updateBalancingState(any(), any());\n+    inOrder.verify(mockHelper, never()).updateBalancingState(any(), any());\n \n     // subchannel  |  state    |   health\n     // subchannel1 | READY     | READY\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11503",
    "pr_id": 11503,
    "issue_id": 11271,
    "repo": "grpc/grpc-java",
    "problem_statement": "okhttp: detect transport executors with no remaining threads\nWe've seen some cases where users are providing fixed-size thread pools to `OkHttpChannelBuilder.transportExecutor()`. gRPC provides no guarantees how many threads it may need, and queuing a Runnable can prevent transports from functioning.\r\n\r\nIn particular, grpc-okhttp needs two threads per transport: a reading thread and a sending thread. The reading thread runs for the life of the transport, but the sending thread is only used when something is actively needing to be written to the socket. During handshaking, however, only the reading thread is used, as there's no need to read and write simultaneously. This means the transport can start, but then no RPCs could actually be sent on it, because there are no more threads available.\r\n\r\nIt seems worthwhile to detect when the executor is misconfigured with too few threads, especially when happy eyeballs is enabled. To do this, during handshaking, we can start a second (\"unnecessary\") thread and have it blocked doing nothing until the handshake is complete. In addition, the handshake would be blocked on that thread getting scheduled (the Runnable.run() being executed). If it isn't scheduled in X time, then we abort the handshake and kill the transport. If the transport executor is only used for grpc-okhttp, this would guarantee there's at least one free thread to use for writing once the transport is ready and RPCs write data amongst all the transports.",
    "issue_word_count": 243,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java",
      "okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java"
    ],
    "pr_changed_test_files": [
      "okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java"
    ],
    "base_commit": "1dae144f0a3013e8056adf9c78eb095a1dc8fcad",
    "head_commit": "4d44e3de3a85842d3ce2516e2c6ec7fc2727267a",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11503",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11503",
    "dockerfile": "",
    "pr_merged_at": "2024-09-16T11:02:52.000Z",
    "patch": "diff --git a/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java b/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java\nindex 29d3dbc1cdf..2f6b836dc3a 100644\n--- a/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java\n+++ b/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java\n@@ -83,9 +83,13 @@\n import java.util.Locale;\n import java.util.Map;\n import java.util.Random;\n+import java.util.concurrent.BrokenBarrierException;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n import java.util.concurrent.Executor;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n import javax.annotation.Nullable;\n@@ -499,8 +503,15 @@ public Runnable start(Listener listener) {\n       outboundFlow = new OutboundFlowController(this, frameWriter);\n     }\n     final CountDownLatch latch = new CountDownLatch(1);\n+    final CountDownLatch latchForExtraThread = new CountDownLatch(1);\n+    // The transport needs up to two threads to function once started,\n+    // but only needs one during handshaking. Start another thread during handshaking\n+    // to make sure there's still a free thread available. If the number of threads is exhausted,\n+    // it is better to kill the transport than for all the transports to hang unable to send.\n+    CyclicBarrier barrier = new CyclicBarrier(2);\n     // Connecting in the serializingExecutor, so that some stream operations like synStream\n     // will be executed after connected.\n+\n     serializingExecutor.execute(new Runnable() {\n       @Override\n       public void run() {\n@@ -510,8 +521,14 @@ public void run() {\n         // initial preface.\n         try {\n           latch.await();\n+          barrier.await(1000, TimeUnit.MILLISECONDS);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n+        } catch (TimeoutException | BrokenBarrierException e) {\n+          startGoAway(0, ErrorCode.INTERNAL_ERROR, Status.UNAVAILABLE\n+              .withDescription(\"Timed out waiting for second handshake thread. \"\n+                + \"The transport executor pool may have run out of threads\"));\n+          return;\n         }\n         // Use closed source on failure so that the reader immediately shuts down.\n         BufferedSource source = Okio.buffer(new Source() {\n@@ -575,6 +592,7 @@ sslSocketFactory, hostnameVerifier, sock, getOverridenHost(), getOverridenPort()\n           return;\n         } finally {\n           clientFrameHandler = new ClientFrameHandler(variant.newReader(source, true));\n+          latchForExtraThread.countDown();\n         }\n         synchronized (lock) {\n           socket = Preconditions.checkNotNull(sock, \"socket\");\n@@ -584,6 +602,21 @@ sslSocketFactory, hostnameVerifier, sock, getOverridenHost(), getOverridenPort()\n         }\n       }\n     });\n+\n+    executor.execute(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          barrier.await(1000, TimeUnit.MILLISECONDS);\n+          latchForExtraThread.await();\n+        } catch (BrokenBarrierException | TimeoutException e) {\n+          // Something bad happened, maybe too few threads available!\n+          // This will be handled in the handshake thread.\n+        } catch (InterruptedException e) {\n+          Thread.currentThread().interrupt();\n+        }\n+      }\n+    });\n     // Schedule to send connection preface & settings before any other write.\n     try {\n       sendConnectionPrefaceAndSettings();\n",
    "test_patch": "diff --git a/okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java b/okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java\nindex ab7dff98444..474c5cedacc 100644\n--- a/okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java\n+++ b/okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java\n@@ -247,6 +247,28 @@ public void testToString() throws Exception {\n     assertTrue(\"Unexpected: \" + s, s.contains(address.toString()));\n   }\n \n+  @Test\n+  public void testTransportExecutorWithTooFewThreads() throws Exception {\n+    ExecutorService fixedPoolExecutor = Executors.newFixedThreadPool(1);\n+    channelBuilder.transportExecutor(fixedPoolExecutor);\n+    InetSocketAddress address = InetSocketAddress.createUnresolved(\"hostname\", 31415);\n+    clientTransport = new OkHttpClientTransport(\n+        channelBuilder.buildTransportFactory(),\n+        address,\n+        \"hostname\",\n+        null,\n+        EAG_ATTRS,\n+        NO_PROXY,\n+        tooManyPingsRunnable);\n+    clientTransport.start(transportListener);\n+    ArgumentCaptor<Status> statusCaptor = ArgumentCaptor.forClass(Status.class);\n+    verify(transportListener, timeout(TIME_OUT_MS)).transportShutdown(statusCaptor.capture());\n+    Status capturedStatus = statusCaptor.getValue();\n+    assertEquals(\"Timed out waiting for second handshake thread. \"\n+        + \"The transport executor pool may have run out of threads\",\n+        capturedStatus.getDescription());\n+  }\n+\n   /**\n    * Test logging is functioning correctly for client received Http/2 frames. Not intended to test\n    * actual frame content being logged.\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11495",
    "pr_id": 11495,
    "issue_id": 11434,
    "repo": "grpc/grpc-java",
    "problem_statement": "xds: Incorrect load reporting when using pick first as locality-routing policy\nClusterImplLoadBalancer assumes all addresses for a subchannel are in the same locality:\r\nhttps://github.com/grpc/grpc-java/blob/90d0fabb1f100231ab6544cf8e352c623771dee1/xds/src/main/java/io/grpc/xds/ClusterImplLoadBalancer.java#L216-L217\r\n\r\nThat is the case when pick_first is being used as an endpoint-picking policy. But when pick_first is being used for affinity cross-locality (instead of ring_hash), that is wrong and can assign the load to the wrong locality.\r\n\r\nThe PickFirstLeafLoadBalancer doesn't have this problem, because it uses a separate subchannel for each address. But it also is not the default (again).\r\n\r\nb/349186137",
    "issue_word_count": 108,
    "test_files_count": 2,
    "non_test_files_count": 7,
    "pr_changed_files": [
      "api/src/main/java/io/grpc/InternalSubchannelAddressAttributes.java",
      "api/src/main/java/io/grpc/LoadBalancer.java",
      "core/src/main/java/io/grpc/internal/InternalSubchannel.java",
      "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java",
      "core/src/test/java/io/grpc/internal/InternalSubchannelTest.java",
      "util/src/main/java/io/grpc/util/ForwardingSubchannel.java",
      "xds/src/main/java/io/grpc/xds/ClusterImplLoadBalancer.java",
      "xds/src/main/java/io/grpc/xds/client/LoadStatsManager2.java",
      "xds/src/test/java/io/grpc/xds/ClusterImplLoadBalancerTest.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/InternalSubchannelTest.java",
      "xds/src/test/java/io/grpc/xds/ClusterImplLoadBalancerTest.java"
    ],
    "base_commit": "10d6002cbda0345d2f3fd1b1d91ce5b36319fb16",
    "head_commit": "60fb499a13081ca26222b76e7fa2d03ac2b11251",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11495",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11495",
    "dockerfile": "",
    "pr_merged_at": "2024-08-31T23:07:53.000Z",
    "patch": "diff --git a/api/src/main/java/io/grpc/InternalSubchannelAddressAttributes.java b/api/src/main/java/io/grpc/InternalSubchannelAddressAttributes.java\nnew file mode 100644\nindex 00000000000..cfc2f7c5137\n--- /dev/null\n+++ b/api/src/main/java/io/grpc/InternalSubchannelAddressAttributes.java\n@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2024 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc;\n+\n+/**\n+ * An internal class. Do not use.\n+ *\n+ * <p>An interface to provide the attributes for address connected by subchannel.\n+ */\n+@Internal\n+public interface InternalSubchannelAddressAttributes {\n+\n+  /**\n+   * Return attributes of the server address connected by sub channel.\n+   */\n+  public Attributes getConnectedAddressAttributes();\n+}\n\ndiff --git a/api/src/main/java/io/grpc/LoadBalancer.java b/api/src/main/java/io/grpc/LoadBalancer.java\nindex 15106a5ffc6..0fbce5fa5be 100644\n--- a/api/src/main/java/io/grpc/LoadBalancer.java\n+++ b/api/src/main/java/io/grpc/LoadBalancer.java\n@@ -1428,6 +1428,18 @@ public void updateAddresses(List<EquivalentAddressGroup> addrs) {\n     public Object getInternalSubchannel() {\n       throw new UnsupportedOperationException();\n     }\n+\n+    /**\n+     * (Internal use only) returns attributes of the address subchannel is connected to.\n+     *\n+     * <p>Warning: this is INTERNAL API, is not supposed to be used by external users, and may\n+     * change without notice. If you think you must use it, please file an issue and we can consider\n+     * removing its \"internal\" status.\n+     */\n+    @Internal\n+    public Attributes getConnectedAddressAttributes() {\n+      throw new UnsupportedOperationException();\n+    }\n   }\n \n   /**\n\ndiff --git a/core/src/main/java/io/grpc/internal/InternalSubchannel.java b/core/src/main/java/io/grpc/internal/InternalSubchannel.java\nindex a986cb2deff..70e42e2f5f1 100644\n--- a/core/src/main/java/io/grpc/internal/InternalSubchannel.java\n+++ b/core/src/main/java/io/grpc/internal/InternalSubchannel.java\n@@ -157,6 +157,8 @@ protected void handleNotInUse() {\n \n   private Status shutdownReason;\n \n+  private volatile Attributes connectedAddressAttributes;\n+\n   InternalSubchannel(List<EquivalentAddressGroup> addressGroups, String authority, String userAgent,\n       BackoffPolicy.Provider backoffPolicyProvider,\n       ClientTransportFactory transportFactory, ScheduledExecutorService scheduledExecutor,\n@@ -525,6 +527,13 @@ public void run() {\n     return channelStatsFuture;\n   }\n \n+  /**\n+   * Return attributes for server address connected by sub channel.\n+   */\n+  public Attributes getConnectedAddressAttributes() {\n+    return connectedAddressAttributes;\n+  }\n+\n   ConnectivityState getState() {\n     return state.getState();\n   }\n@@ -568,6 +577,7 @@ public void run() {\n           } else if (pendingTransport == transport) {\n             activeTransport = transport;\n             pendingTransport = null;\n+            connectedAddressAttributes = addressIndex.getCurrentEagAttributes();\n             gotoNonErrorState(READY);\n           }\n         }\n\ndiff --git a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\nindex 7f45ca967ea..07dcf9ee7bb 100644\n--- a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n+++ b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n@@ -2044,6 +2044,11 @@ public void updateAddresses(List<EquivalentAddressGroup> addrs) {\n       subchannel.updateAddresses(addrs);\n     }\n \n+    @Override\n+    public Attributes getConnectedAddressAttributes() {\n+      return subchannel.getConnectedAddressAttributes();\n+    }\n+\n     private List<EquivalentAddressGroup> stripOverrideAuthorityAttributes(\n         List<EquivalentAddressGroup> eags) {\n       List<EquivalentAddressGroup> eagsWithoutOverrideAttr = new ArrayList<>();\n\ndiff --git a/util/src/main/java/io/grpc/util/ForwardingSubchannel.java b/util/src/main/java/io/grpc/util/ForwardingSubchannel.java\nindex 51f2583186e..416be378162 100644\n--- a/util/src/main/java/io/grpc/util/ForwardingSubchannel.java\n+++ b/util/src/main/java/io/grpc/util/ForwardingSubchannel.java\n@@ -74,11 +74,17 @@ public Object getInternalSubchannel() {\n     return delegate().getInternalSubchannel();\n   }\n \n+\n   @Override\n   public void updateAddresses(List<EquivalentAddressGroup> addrs) {\n     delegate().updateAddresses(addrs);\n   }\n \n+  @Override\n+  public Attributes getConnectedAddressAttributes() {\n+    return delegate().getConnectedAddressAttributes();\n+  }\n+\n   @Override\n   public String toString() {\n     return MoreObjects.toStringHelper(this).add(\"delegate\", delegate()).toString();\n\ndiff --git a/xds/src/main/java/io/grpc/xds/ClusterImplLoadBalancer.java b/xds/src/main/java/io/grpc/xds/ClusterImplLoadBalancer.java\nindex 702b2aa6caa..0ea2c7dd75f 100644\n--- a/xds/src/main/java/io/grpc/xds/ClusterImplLoadBalancer.java\n+++ b/xds/src/main/java/io/grpc/xds/ClusterImplLoadBalancer.java\n@@ -27,6 +27,7 @@\n import io.grpc.ClientStreamTracer;\n import io.grpc.ClientStreamTracer.StreamInfo;\n import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n import io.grpc.EquivalentAddressGroup;\n import io.grpc.InternalLogId;\n import io.grpc.LoadBalancer;\n@@ -59,6 +60,7 @@\n import java.util.Map;\n import java.util.Objects;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n import javax.annotation.Nullable;\n \n /**\n@@ -77,10 +79,8 @@ final class ClusterImplLoadBalancer extends LoadBalancer {\n       Strings.isNullOrEmpty(System.getenv(\"GRPC_XDS_EXPERIMENTAL_CIRCUIT_BREAKING\"))\n           || Boolean.parseBoolean(System.getenv(\"GRPC_XDS_EXPERIMENTAL_CIRCUIT_BREAKING\"));\n \n-  private static final Attributes.Key<ClusterLocalityStats> ATTR_CLUSTER_LOCALITY_STATS =\n-      Attributes.Key.create(\"io.grpc.xds.ClusterImplLoadBalancer.clusterLocalityStats\");\n-  private static final Attributes.Key<String> ATTR_CLUSTER_LOCALITY_NAME =\n-      Attributes.Key.create(\"io.grpc.xds.ClusterImplLoadBalancer.clusterLocalityName\");\n+  private static final Attributes.Key<AtomicReference<ClusterLocality>> ATTR_CLUSTER_LOCALITY =\n+      Attributes.Key.create(\"io.grpc.xds.ClusterImplLoadBalancer.clusterLocality\");\n \n   private final XdsLogger logger;\n   private final Helper helper;\n@@ -213,36 +213,45 @@ public void updateBalancingState(ConnectivityState newState, SubchannelPicker ne\n     @Override\n     public Subchannel createSubchannel(CreateSubchannelArgs args) {\n       List<EquivalentAddressGroup> addresses = withAdditionalAttributes(args.getAddresses());\n-      Locality locality = args.getAddresses().get(0).getAttributes().get(\n-          InternalXdsAttributes.ATTR_LOCALITY);  // all addresses should be in the same locality\n-      String localityName = args.getAddresses().get(0).getAttributes().get(\n-          InternalXdsAttributes.ATTR_LOCALITY_NAME);\n-      // Endpoint addresses resolved by ClusterResolverLoadBalancer should always contain\n-      // attributes with its locality, including endpoints in LOGICAL_DNS clusters.\n-      // In case of not (which really shouldn't), loads are aggregated under an empty locality.\n-      if (locality == null) {\n-        locality = Locality.create(\"\", \"\", \"\");\n-        localityName = \"\";\n-      }\n-      final ClusterLocalityStats localityStats =\n-          (lrsServerInfo == null)\n-              ? null\n-              : xdsClient.addClusterLocalityStats(lrsServerInfo, cluster,\n-              edsServiceName, locality);\n-\n+      // This value for  ClusterLocality is not recommended for general use.\n+      // Currently, we extract locality data from the first address, even before the subchannel is\n+      // READY.\n+      // This is mainly to accommodate scenarios where a Load Balancing API (like \"pick first\")\n+      // might return the subchannel before it is READY. Typically, we wouldn't report load for such\n+      // selections because the channel will disregard the chosen (not-ready) subchannel.\n+      // However, we needed to ensure this case is handled.\n+      ClusterLocality clusterLocality = createClusterLocalityFromAttributes(\n+          args.getAddresses().get(0).getAttributes());\n+      AtomicReference<ClusterLocality> localityAtomicReference = new AtomicReference<>(\n+          clusterLocality);\n       Attributes attrs = args.getAttributes().toBuilder()\n-          .set(ATTR_CLUSTER_LOCALITY_STATS, localityStats)\n-          .set(ATTR_CLUSTER_LOCALITY_NAME, localityName)\n+          .set(ATTR_CLUSTER_LOCALITY, localityAtomicReference)\n           .build();\n       args = args.toBuilder().setAddresses(addresses).setAttributes(attrs).build();\n       final Subchannel subchannel = delegate().createSubchannel(args);\n \n       return new ForwardingSubchannel() {\n+        @Override\n+        public void start(SubchannelStateListener listener) {\n+          delegate().start(new SubchannelStateListener() {\n+            @Override\n+            public void onSubchannelState(ConnectivityStateInfo newState) {\n+              if (newState.getState().equals(ConnectivityState.READY)) {\n+                // Get locality based on the connected address attributes\n+                ClusterLocality updatedClusterLocality = createClusterLocalityFromAttributes(\n+                    subchannel.getConnectedAddressAttributes());\n+                ClusterLocality oldClusterLocality = localityAtomicReference\n+                    .getAndSet(updatedClusterLocality);\n+                oldClusterLocality.release();\n+              }\n+              listener.onSubchannelState(newState);\n+            }\n+          });\n+        }\n+\n         @Override\n         public void shutdown() {\n-          if (localityStats != null) {\n-            localityStats.release();\n-          }\n+          localityAtomicReference.get().release();\n           delegate().shutdown();\n         }\n \n@@ -274,6 +283,28 @@ private List<EquivalentAddressGroup> withAdditionalAttributes(\n       return newAddresses;\n     }\n \n+    private ClusterLocality createClusterLocalityFromAttributes(Attributes addressAttributes) {\n+      Locality locality = addressAttributes.get(InternalXdsAttributes.ATTR_LOCALITY);\n+      String localityName = addressAttributes.get(InternalXdsAttributes.ATTR_LOCALITY_NAME);\n+\n+      // Endpoint addresses resolved by ClusterResolverLoadBalancer should always contain\n+      // attributes with its locality, including endpoints in LOGICAL_DNS clusters.\n+      // In case of not (which really shouldn't), loads are aggregated under an empty\n+      // locality.\n+      if (locality == null) {\n+        locality = Locality.create(\"\", \"\", \"\");\n+        localityName = \"\";\n+      }\n+\n+      final ClusterLocalityStats localityStats =\n+          (lrsServerInfo == null)\n+              ? null\n+              : xdsClient.addClusterLocalityStats(lrsServerInfo, cluster,\n+                  edsServiceName, locality);\n+\n+      return new ClusterLocality(localityStats, localityName);\n+    }\n+\n     @Override\n     protected Helper delegate()  {\n       return helper;\n@@ -361,18 +392,23 @@ public PickResult pickSubchannel(PickSubchannelArgs args) {\n                   \"Cluster max concurrent requests limit exceeded\"));\n             }\n           }\n-          final ClusterLocalityStats stats =\n-              result.getSubchannel().getAttributes().get(ATTR_CLUSTER_LOCALITY_STATS);\n-          if (stats != null) {\n-            String localityName =\n-                result.getSubchannel().getAttributes().get(ATTR_CLUSTER_LOCALITY_NAME);\n-            args.getPickDetailsConsumer().addOptionalLabel(\"grpc.lb.locality\", localityName);\n-\n-            ClientStreamTracer.Factory tracerFactory = new CountingStreamTracerFactory(\n-                stats, inFlights, result.getStreamTracerFactory());\n-            ClientStreamTracer.Factory orcaTracerFactory = OrcaPerRequestUtil.getInstance()\n-                .newOrcaClientStreamTracerFactory(tracerFactory, new OrcaPerRpcListener(stats));\n-            return PickResult.withSubchannel(result.getSubchannel(), orcaTracerFactory);\n+          final AtomicReference<ClusterLocality> clusterLocality =\n+              result.getSubchannel().getAttributes().get(ATTR_CLUSTER_LOCALITY);\n+\n+          if (clusterLocality != null) {\n+            ClusterLocalityStats stats = clusterLocality.get().getClusterLocalityStats();\n+            if (stats != null) {\n+              String localityName =\n+                  result.getSubchannel().getAttributes().get(ATTR_CLUSTER_LOCALITY).get()\n+                      .getClusterLocalityName();\n+              args.getPickDetailsConsumer().addOptionalLabel(\"grpc.lb.locality\", localityName);\n+\n+              ClientStreamTracer.Factory tracerFactory = new CountingStreamTracerFactory(\n+                  stats, inFlights, result.getStreamTracerFactory());\n+              ClientStreamTracer.Factory orcaTracerFactory = OrcaPerRequestUtil.getInstance()\n+                  .newOrcaClientStreamTracerFactory(tracerFactory, new OrcaPerRpcListener(stats));\n+              return PickResult.withSubchannel(result.getSubchannel(), orcaTracerFactory);\n+            }\n           }\n         }\n         return result;\n@@ -447,4 +483,33 @@ public void onLoadReport(MetricReport report) {\n       stats.recordBackendLoadMetricStats(report.getNamedMetrics());\n     }\n   }\n+\n+  /**\n+   * Represents the {@link ClusterLocalityStats} and network locality name of a cluster.\n+   */\n+  static final class ClusterLocality {\n+    private final ClusterLocalityStats clusterLocalityStats;\n+    private final String clusterLocalityName;\n+\n+    @VisibleForTesting\n+    ClusterLocality(ClusterLocalityStats localityStats, String localityName) {\n+      this.clusterLocalityStats = localityStats;\n+      this.clusterLocalityName = localityName;\n+    }\n+\n+    ClusterLocalityStats getClusterLocalityStats() {\n+      return clusterLocalityStats;\n+    }\n+\n+    String getClusterLocalityName() {\n+      return clusterLocalityName;\n+    }\n+\n+    @VisibleForTesting\n+    void release() {\n+      if (clusterLocalityStats != null) {\n+        clusterLocalityStats.release();\n+      }\n+    }\n+  }\n }\n\ndiff --git a/xds/src/main/java/io/grpc/xds/client/LoadStatsManager2.java b/xds/src/main/java/io/grpc/xds/client/LoadStatsManager2.java\nindex 393cce16194..be9d3587d14 100644\n--- a/xds/src/main/java/io/grpc/xds/client/LoadStatsManager2.java\n+++ b/xds/src/main/java/io/grpc/xds/client/LoadStatsManager2.java\n@@ -91,7 +91,7 @@ private synchronized void releaseClusterDropCounter(\n       String cluster, @Nullable String edsServiceName) {\n     checkState(allDropStats.containsKey(cluster)\n             && allDropStats.get(cluster).containsKey(edsServiceName),\n-        \"stats for cluster %s, edsServiceName %s not exits\", cluster, edsServiceName);\n+        \"stats for cluster %s, edsServiceName %s do not exist\", cluster, edsServiceName);\n     ReferenceCounted<ClusterDropStats> ref = allDropStats.get(cluster).get(edsServiceName);\n     ref.release();\n   }\n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/InternalSubchannelTest.java b/core/src/test/java/io/grpc/internal/InternalSubchannelTest.java\nindex f7631c34c0d..e4d9f27ed46 100644\n--- a/core/src/test/java/io/grpc/internal/InternalSubchannelTest.java\n+++ b/core/src/test/java/io/grpc/internal/InternalSubchannelTest.java\n@@ -1339,6 +1339,32 @@ public void channelzStatContainsTransport() throws Exception {\n     assertThat(index.getCurrentAddress()).isSameInstanceAs(addr2);\n   }\n \n+  @Test\n+  public void connectedAddressAttributes_ready() {\n+    SocketAddress addr = new SocketAddress() {};\n+    Attributes attr = Attributes.newBuilder().set(Attributes.Key.create(\"some-key\"), \"1\").build();\n+    createInternalSubchannel(new EquivalentAddressGroup(Arrays.asList(addr), attr));\n+\n+    assertEquals(IDLE, internalSubchannel.getState());\n+    assertNoCallbackInvoke();\n+    assertNull(internalSubchannel.obtainActiveTransport());\n+    assertNull(internalSubchannel.getConnectedAddressAttributes());\n+\n+    assertExactCallbackInvokes(\"onStateChange:CONNECTING\");\n+    assertEquals(CONNECTING, internalSubchannel.getState());\n+    verify(mockTransportFactory).newClientTransport(\n+        eq(addr),\n+        eq(createClientTransportOptions().setEagAttributes(attr)),\n+        isA(TransportLogger.class));\n+    assertNull(internalSubchannel.getConnectedAddressAttributes());\n+\n+    internalSubchannel.obtainActiveTransport();\n+    transports.peek().listener.transportReady();\n+    assertExactCallbackInvokes(\"onStateChange:READY\");\n+    assertEquals(READY, internalSubchannel.getState());\n+    assertEquals(attr, internalSubchannel.getConnectedAddressAttributes());\n+  }\n+\n   /** Create ClientTransportOptions. Should not be reused if it may be mutated. */\n   private ClientTransportFactory.ClientTransportOptions createClientTransportOptions() {\n     return new ClientTransportFactory.ClientTransportOptions()\n\ndiff --git a/xds/src/test/java/io/grpc/xds/ClusterImplLoadBalancerTest.java b/xds/src/test/java/io/grpc/xds/ClusterImplLoadBalancerTest.java\nindex 4e12a5717ae..0082a2aa59d 100644\n--- a/xds/src/test/java/io/grpc/xds/ClusterImplLoadBalancerTest.java\n+++ b/xds/src/test/java/io/grpc/xds/ClusterImplLoadBalancerTest.java\n@@ -16,6 +16,7 @@\n \n package io.grpc.xds;\n \n+import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.Mockito.mock;\n@@ -29,6 +30,7 @@\n import io.grpc.CallOptions;\n import io.grpc.ClientStreamTracer;\n import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n import io.grpc.EquivalentAddressGroup;\n import io.grpc.InsecureChannelCredentials;\n import io.grpc.LoadBalancer;\n@@ -40,7 +42,9 @@\n import io.grpc.LoadBalancer.ResolvedAddresses;\n import io.grpc.LoadBalancer.Subchannel;\n import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancer.SubchannelStateListener;\n import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n import io.grpc.ManagedChannel;\n import io.grpc.Metadata;\n import io.grpc.Status;\n@@ -76,9 +80,11 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Queue;\n import java.util.concurrent.atomic.AtomicLong;\n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n@@ -145,7 +151,7 @@ public AtomicLong getOrCreate(String cluster, @Nullable String edsServiceName) {\n       return new AtomicLong();\n     }\n   };\n-  private final Helper helper = new FakeLbHelper();\n+  private final FakeLbHelper helper = new FakeLbHelper();\n   private PickSubchannelArgs pickSubchannelArgs = new PickSubchannelArgsImpl(\n       TestMethodDescriptors.voidMethod(), new Metadata(), CallOptions.DEFAULT,\n       new PickDetailsConsumer() {});\n@@ -272,9 +278,10 @@ public void pick_addsLocalityLabel() {\n     EquivalentAddressGroup endpoint = makeAddress(\"endpoint-addr\", locality);\n     deliverAddressesAndConfig(Collections.singletonList(endpoint), config);\n     FakeLoadBalancer leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n-    Subchannel subchannel = leafBalancer.helper.createSubchannel(\n-        CreateSubchannelArgs.newBuilder().setAddresses(leafBalancer.addresses).build());\n-    leafBalancer.deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    leafBalancer.createSubChannel();\n+    FakeSubchannel fakeSubchannel = helper.subchannels.poll();\n+    fakeSubchannel.setConnectedEagIndex(0);\n+    fakeSubchannel.updateState(ConnectivityStateInfo.forNonError(ConnectivityState.READY));\n     assertThat(currentState).isEqualTo(ConnectivityState.READY);\n \n     PickDetailsConsumer detailsConsumer = mock(PickDetailsConsumer.class);\n@@ -300,9 +307,10 @@ public void recordLoadStats() {\n     EquivalentAddressGroup endpoint = makeAddress(\"endpoint-addr\", locality);\n     deliverAddressesAndConfig(Collections.singletonList(endpoint), config);\n     FakeLoadBalancer leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n-    Subchannel subchannel = leafBalancer.helper.createSubchannel(\n-        CreateSubchannelArgs.newBuilder().setAddresses(leafBalancer.addresses).build());\n-    leafBalancer.deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    Subchannel subchannel = leafBalancer.createSubChannel();\n+    FakeSubchannel fakeSubchannel = helper.subchannels.poll();\n+    fakeSubchannel.setConnectedEagIndex(0);\n+    fakeSubchannel.updateState(ConnectivityStateInfo.forNonError(ConnectivityState.READY));\n     assertThat(currentState).isEqualTo(ConnectivityState.READY);\n     PickResult result = currentPicker.pickSubchannel(pickSubchannelArgs);\n     assertThat(result.getStatus().isOk()).isTrue();\n@@ -357,7 +365,7 @@ public void recordLoadStats() {\n         TOLERANCE).of(0.009);\n \n     streamTracer3.streamClosed(Status.OK);\n-    subchannel.shutdown();  // stats recorder released\n+    subchannel.shutdown(); // stats recorder released\n     clusterStats = Iterables.getOnlyElement(loadStatsManager.getClusterStatsReports(CLUSTER));\n     // Locality load is reported for one last time in case of loads occurred since the previous\n     // load report.\n@@ -373,6 +381,95 @@ public void recordLoadStats() {\n     assertThat(clusterStats.upstreamLocalityStatsList()).isEmpty();  // no longer reported\n   }\n \n+  // TODO(dnvindhya): This test has been added as a fix to verify\n+  // https://github.com/grpc/grpc-java/issues/11434.\n+  // Once we update PickFirstLeafLoadBalancer as default LoadBalancer, update the test.\n+  @Test\n+  public void pickFirstLoadReport_onUpdateAddress() {\n+    Locality locality1 =\n+        Locality.create(\"test-region\", \"test-zone\", \"test-subzone\");\n+    Locality locality2 =\n+        Locality.create(\"other-region\", \"other-zone\", \"other-subzone\");\n+\n+    LoadBalancerProvider pickFirstProvider = LoadBalancerRegistry\n+        .getDefaultRegistry().getProvider(\"pick_first\");\n+    Object pickFirstConfig = pickFirstProvider.parseLoadBalancingPolicyConfig(new HashMap<>())\n+        .getConfig();\n+    ClusterImplConfig config = new ClusterImplConfig(CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_INFO,\n+        null, Collections.<DropOverload>emptyList(),\n+        GracefulSwitchLoadBalancer.createLoadBalancingPolicyConfig(pickFirstProvider,\n+            pickFirstConfig),\n+        null, Collections.emptyMap());\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr1\", locality1);\n+    EquivalentAddressGroup endpoint2 = makeAddress(\"endpoint-addr2\", locality2);\n+    deliverAddressesAndConfig(Arrays.asList(endpoint1, endpoint2), config);\n+\n+    // Leaf balancer is created by Pick First. Get FakeSubchannel created to update attributes\n+    // A real subchannel would get these attributes from the connected address's EAG locality.\n+    FakeSubchannel fakeSubchannel = helper.subchannels.poll();\n+    fakeSubchannel.setConnectedEagIndex(0);\n+    fakeSubchannel.updateState(ConnectivityStateInfo.forNonError(ConnectivityState.READY));\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    PickResult result = currentPicker.pickSubchannel(pickSubchannelArgs);\n+    assertThat(result.getStatus().isOk()).isTrue();\n+\n+    ClientStreamTracer streamTracer1 = result.getStreamTracerFactory().newClientStreamTracer(\n+        ClientStreamTracer.StreamInfo.newBuilder().build(), new Metadata());  // first RPC call\n+    streamTracer1.streamClosed(Status.OK);\n+\n+    ClusterStats clusterStats = Iterables.getOnlyElement(\n+        loadStatsManager.getClusterStatsReports(CLUSTER));\n+    UpstreamLocalityStats localityStats = Iterables.getOnlyElement(\n+        clusterStats.upstreamLocalityStatsList());\n+    assertThat(localityStats.locality()).isEqualTo(locality1);\n+    assertThat(localityStats.totalIssuedRequests()).isEqualTo(1L);\n+    assertThat(localityStats.totalSuccessfulRequests()).isEqualTo(1L);\n+    assertThat(localityStats.totalErrorRequests()).isEqualTo(0L);\n+\n+    fakeSubchannel.updateState(ConnectivityStateInfo.forNonError(ConnectivityState.IDLE));\n+    loadBalancer.requestConnection();\n+    fakeSubchannel.updateState(ConnectivityStateInfo.forNonError(ConnectivityState.CONNECTING));\n+\n+    // Faksubchannel mimics update address and returns different locality\n+    fakeSubchannel.setConnectedEagIndex(1);\n+    fakeSubchannel.updateState(ConnectivityStateInfo.forNonError(ConnectivityState.READY));\n+    result = currentPicker.pickSubchannel(pickSubchannelArgs);\n+    assertThat(result.getStatus().isOk()).isTrue();\n+    ClientStreamTracer streamTracer2 = result.getStreamTracerFactory().newClientStreamTracer(\n+        ClientStreamTracer.StreamInfo.newBuilder().build(), new Metadata());  // second RPC call\n+    streamTracer2.streamClosed(Status.UNAVAILABLE);\n+\n+    clusterStats = Iterables.getOnlyElement(loadStatsManager.getClusterStatsReports(CLUSTER));\n+    UpstreamLocalityStats localityStats1 = Iterables.get(clusterStats.upstreamLocalityStatsList(),\n+        0);\n+    assertThat(localityStats1.locality()).isEqualTo(locality1);\n+    assertThat(localityStats1.totalIssuedRequests()).isEqualTo(0L);\n+    assertThat(localityStats1.totalSuccessfulRequests()).isEqualTo(0L);\n+    assertThat(localityStats1.totalErrorRequests()).isEqualTo(0L);\n+    UpstreamLocalityStats localityStats2 = Iterables.get(clusterStats.upstreamLocalityStatsList(),\n+        1);\n+    assertThat(localityStats2.locality()).isEqualTo(locality2);\n+    assertThat(localityStats2.totalIssuedRequests()).isEqualTo(1L);\n+    assertThat(localityStats2.totalSuccessfulRequests()).isEqualTo(0L);\n+    assertThat(localityStats2.totalErrorRequests()).isEqualTo(1L);\n+\n+    loadBalancer.shutdown();\n+    loadBalancer = null;\n+    // No more references are held for localityStats1 hence dropped.\n+    // Locality load is reported for one last time in case of loads occurred since the previous\n+    // load report.\n+    clusterStats = Iterables.getOnlyElement(loadStatsManager.getClusterStatsReports(CLUSTER));\n+    localityStats2 = Iterables.getOnlyElement(clusterStats.upstreamLocalityStatsList());\n+\n+    assertThat(localityStats2.locality()).isEqualTo(locality2);\n+    assertThat(localityStats2.totalIssuedRequests()).isEqualTo(0L);\n+    assertThat(localityStats2.totalSuccessfulRequests()).isEqualTo(0L);\n+    assertThat(localityStats2.totalErrorRequests()).isEqualTo(0L);\n+    assertThat(localityStats2.totalRequestsInProgress()).isEqualTo(0L);\n+\n+    assertThat(loadStatsManager.getClusterStatsReports(CLUSTER)).isEmpty();\n+  }\n+\n   @Test\n   public void dropRpcsWithRespectToLbConfigDropCategories() {\n     LoadBalancerProvider weightedTargetProvider = new WeightedTargetLoadBalancerProvider();\n@@ -391,9 +488,11 @@ public void dropRpcsWithRespectToLbConfigDropCategories() {\n     assertThat(leafBalancer.name).isEqualTo(\"round_robin\");\n     assertThat(Iterables.getOnlyElement(leafBalancer.addresses).getAddresses())\n         .isEqualTo(endpoint.getAddresses());\n-    Subchannel subchannel = leafBalancer.helper.createSubchannel(\n-        CreateSubchannelArgs.newBuilder().setAddresses(leafBalancer.addresses).build());\n-    leafBalancer.deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    leafBalancer.createSubChannel();\n+    FakeSubchannel fakeSubchannel = helper.subchannels.poll();\n+    fakeSubchannel.setConnectedEagIndex(0);\n+    fakeSubchannel.updateState(ConnectivityStateInfo.forNonError(ConnectivityState.READY));\n+\n     assertThat(currentState).isEqualTo(ConnectivityState.READY);\n     PickResult result = currentPicker.pickSubchannel(pickSubchannelArgs);\n     assertThat(result.getStatus().isOk()).isFalse();\n@@ -470,9 +569,11 @@ private void subtest_maxConcurrentRequests_appliedByLbConfig(boolean enableCircu\n     assertThat(leafBalancer.name).isEqualTo(\"round_robin\");\n     assertThat(Iterables.getOnlyElement(leafBalancer.addresses).getAddresses())\n         .isEqualTo(endpoint.getAddresses());\n-    Subchannel subchannel = leafBalancer.helper.createSubchannel(\n-        CreateSubchannelArgs.newBuilder().setAddresses(leafBalancer.addresses).build());\n-    leafBalancer.deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    leafBalancer.createSubChannel();\n+    FakeSubchannel fakeSubchannel = helper.subchannels.poll();\n+    fakeSubchannel.setConnectedEagIndex(0);\n+    fakeSubchannel.updateState(ConnectivityStateInfo.forNonError(ConnectivityState.READY));\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n     assertThat(currentState).isEqualTo(ConnectivityState.READY);\n     for (int i = 0; i < maxConcurrentRequests; i++) {\n       PickResult result = currentPicker.pickSubchannel(pickSubchannelArgs);\n@@ -562,9 +663,11 @@ private void subtest_maxConcurrentRequests_appliedWithDefaultValue(\n     assertThat(leafBalancer.name).isEqualTo(\"round_robin\");\n     assertThat(Iterables.getOnlyElement(leafBalancer.addresses).getAddresses())\n         .isEqualTo(endpoint.getAddresses());\n-    Subchannel subchannel = leafBalancer.helper.createSubchannel(\n-        CreateSubchannelArgs.newBuilder().setAddresses(leafBalancer.addresses).build());\n-    leafBalancer.deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    leafBalancer.createSubChannel();\n+    FakeSubchannel fakeSubchannel = helper.subchannels.poll();\n+    fakeSubchannel.setConnectedEagIndex(0);\n+    fakeSubchannel.updateState(ConnectivityStateInfo.forNonError(ConnectivityState.READY));\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n     assertThat(currentState).isEqualTo(ConnectivityState.READY);\n     for (int i = 0; i < ClusterImplLoadBalancer.DEFAULT_PER_CLUSTER_MAX_CONCURRENT_REQUESTS; i++) {\n       PickResult result = currentPicker.pickSubchannel(pickSubchannelArgs);\n@@ -830,19 +933,24 @@ public void shutdown() {\n       downstreamBalancers.remove(this);\n     }\n \n-    void deliverSubchannelState(final Subchannel subchannel, ConnectivityState state) {\n-      SubchannelPicker picker = new SubchannelPicker() {\n-        @Override\n-        public PickResult pickSubchannel(PickSubchannelArgs args) {\n-          return PickResult.withSubchannel(subchannel);\n+    Subchannel createSubChannel() {\n+      Subchannel subchannel = helper.createSubchannel(\n+          CreateSubchannelArgs.newBuilder().setAddresses(addresses).build());\n+      subchannel.start(infoObject -> {\n+        if (infoObject.getState() == ConnectivityState.READY) {\n+          helper.updateBalancingState(\n+              ConnectivityState.READY,\n+              new FixedResultPicker(PickResult.withSubchannel(subchannel)));\n         }\n-      };\n-      helper.updateBalancingState(state, picker);\n+      });\n+      return subchannel;\n     }\n   }\n \n   private final class FakeLbHelper extends LoadBalancer.Helper {\n \n+    private final Queue<FakeSubchannel> subchannels = new LinkedList<>();\n+\n     @Override\n     public SynchronizationContext getSynchronizationContext() {\n       return syncContext;\n@@ -857,7 +965,9 @@ public void updateBalancingState(\n \n     @Override\n     public Subchannel createSubchannel(CreateSubchannelArgs args) {\n-      return new FakeSubchannel(args.getAddresses(), args.getAttributes());\n+      FakeSubchannel subchannel = new FakeSubchannel(args.getAddresses(), args.getAttributes());\n+      subchannels.add(subchannel);\n+      return subchannel;\n     }\n \n     @Override\n@@ -869,17 +979,27 @@ public ManagedChannel createOobChannel(EquivalentAddressGroup eag, String author\n     public String getAuthority() {\n       return AUTHORITY;\n     }\n+\n+    @Override\n+    public void refreshNameResolution() {}\n   }\n \n   private static final class FakeSubchannel extends Subchannel {\n     private final List<EquivalentAddressGroup> eags;\n     private final Attributes attrs;\n+    private SubchannelStateListener listener;\n+    private Attributes connectedAttributes;\n \n     private FakeSubchannel(List<EquivalentAddressGroup> eags, Attributes attrs) {\n       this.eags = eags;\n       this.attrs = attrs;\n     }\n \n+    @Override\n+    public void start(SubchannelStateListener listener) {\n+      this.listener = checkNotNull(listener, \"listener\");\n+    }\n+\n     @Override\n     public void shutdown() {\n     }\n@@ -901,6 +1021,19 @@ public Attributes getAttributes() {\n     @Override\n     public void updateAddresses(List<EquivalentAddressGroup> addrs) {\n     }\n+\n+    @Override\n+    public Attributes getConnectedAddressAttributes() {\n+      return connectedAttributes;\n+    }\n+\n+    public void updateState(ConnectivityStateInfo newState) {\n+      listener.onSubchannelState(newState);\n+    }\n+\n+    public void setConnectedEagIndex(int eagIndex) {\n+      this.connectedAttributes = eags.get(eagIndex).getAttributes();\n+    }\n   }\n \n   private final class FakeXdsClient extends XdsClient {\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11461",
    "pr_id": 11461,
    "issue_id": 11447,
    "repo": "grpc/grpc-java",
    "problem_statement": "Add CI build with netty 4.2.0.Alpha snapshots / releases\nAs we are currently working on the next release of netty (4.2.0) we would love you to also run CI with it to ensure we not break grpc-java. In the past we unfortunately saw breaking even in 4.1.x and so would like to ensure we notice this as soon as possible.\r\nIs this something you could do ?\r\n\r\nAs a side-note it would also be nice if you could run automatic testing with the latest of 4.1.x snapshots as well so we notice breaking early on.",
    "issue_word_count": 104,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java"
    ],
    "pr_changed_test_files": [
      "netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java"
    ],
    "base_commit": "0d47f5bd1baff87d412223c4ac22ea061eafb506",
    "head_commit": "cfb9427c130605d4892395d8dfd7b1902cdf2d6f",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11461",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11461",
    "dockerfile": "",
    "pr_merged_at": "2024-08-12T22:39:13.000Z",
    "patch": "",
    "test_patch": "diff --git a/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java b/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java\nindex f94960cbab3..b40cd9d5607 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java\n@@ -82,6 +82,7 @@\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelOption;\n import io.netty.channel.ChannelPromise;\n+import io.netty.channel.DefaultEventLoopGroup;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.ReflectiveChannelFactory;\n import io.netty.channel.local.LocalChannel;\n@@ -519,15 +520,20 @@ public void channelFactoryShouldSetSocketOptionKeepAlive() throws Exception {\n   @Test\n   public void channelFactoryShouldNNotSetSocketOptionKeepAlive() throws Exception {\n     startServer();\n-    NettyClientTransport transport = newTransport(newNegotiator(),\n-        DEFAULT_MAX_MESSAGE_SIZE, GrpcUtil.DEFAULT_MAX_HEADER_LIST_SIZE, \"testUserAgent\", true,\n-        TimeUnit.SECONDS.toNanos(10L), TimeUnit.SECONDS.toNanos(1L),\n-        new ReflectiveChannelFactory<>(LocalChannel.class), group);\n+    DefaultEventLoopGroup group = new DefaultEventLoopGroup(1);\n+    try {\n+      NettyClientTransport transport = newTransport(newNegotiator(),\n+          DEFAULT_MAX_MESSAGE_SIZE, GrpcUtil.DEFAULT_MAX_HEADER_LIST_SIZE, \"testUserAgent\", true,\n+          TimeUnit.SECONDS.toNanos(10L), TimeUnit.SECONDS.toNanos(1L),\n+          new ReflectiveChannelFactory<>(LocalChannel.class), group);\n \n-    callMeMaybe(transport.start(clientTransportListener));\n+      callMeMaybe(transport.start(clientTransportListener));\n \n-    assertThat(transport.channel().config().getOption(ChannelOption.SO_KEEPALIVE))\n-        .isNull();\n+      assertThat(transport.channel().config().getOption(ChannelOption.SO_KEEPALIVE))\n+          .isNull();\n+    } finally {\n+      group.shutdownGracefully(0, 10, TimeUnit.SECONDS);\n+    }\n   }\n \n   @Test\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11449",
    "pr_id": 11449,
    "issue_id": 5046,
    "repo": "grpc/grpc-java",
    "problem_statement": "\"unknown enum constant\" warnings when building with Bazel\nIf I run `bazel build //...` in grpc-java at HEAD (or v1.16.1) I see many warnings like this:\r\n\r\n```\r\nINFO: From Building core/libinternal.jar (110 source files):\r\nwarning: unknown enum constant ReflectionSupport$Level.FULL\r\n  reason: class file for com.google.j2objc.annotations.ReflectionSupport$Level not found\r\n```\r\n\r\nThis was discussed on https://github.com/bazelbuild/bazel/issues/6414 and is due to a missing compile-time dependency of guava on j2objc.\r\n\r\n### What version of gRPC are you using?\r\nHEAD\r\n\r\n### What did you expect to see?\r\nNo warnings when building.\r\n\r\n\r\n",
    "issue_word_count": 98,
    "test_files_count": 1,
    "non_test_files_count": 18,
    "pr_changed_files": [
      "alts/BUILD.bazel",
      "api/BUILD.bazel",
      "auth/BUILD.bazel",
      "core/BUILD.bazel",
      "examples/pom.xml",
      "gcp-observability/build.gradle",
      "gradle/libs.versions.toml",
      "grpclb/BUILD.bazel",
      "grpclb/build.gradle",
      "inprocess/BUILD.bazel",
      "netty/BUILD.bazel",
      "okhttp/BUILD.bazel",
      "protobuf-lite/BUILD.bazel",
      "protobuf/BUILD.bazel",
      "services/build.gradle",
      "stub/BUILD.bazel",
      "testing/BUILD.bazel",
      "util/BUILD.bazel",
      "xds/build.gradle"
    ],
    "pr_changed_test_files": [
      "testing/BUILD.bazel"
    ],
    "base_commit": "75012a5be2e8dbcbe171ac119434239a30bee385",
    "head_commit": "c04c8ad1e449d146beb9bc1c62e82d61a2815a8a",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11449",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11449",
    "dockerfile": "",
    "pr_merged_at": "2024-08-14T04:33:55.000Z",
    "patch": "diff --git a/alts/BUILD.bazel b/alts/BUILD.bazel\nindex 819daedcc82..73420e11053 100644\n--- a/alts/BUILD.bazel\n+++ b/alts/BUILD.bazel\n@@ -19,7 +19,6 @@ java_library(\n         \"@com_google_protobuf//:protobuf_java_util\",\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n         artifact(\"io.netty:netty-buffer\"),\n         artifact(\"io.netty:netty-codec\"),\n         artifact(\"io.netty:netty-common\"),\n@@ -45,7 +44,6 @@ java_library(\n         artifact(\"com.google.auth:google-auth-library-oauth2-http\"),\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n         artifact(\"io.netty:netty-common\"),\n         artifact(\"io.netty:netty-handler\"),\n         artifact(\"io.netty:netty-transport\"),\n\ndiff --git a/api/BUILD.bazel b/api/BUILD.bazel\nindex 07be1d58dc7..6bf3375e9f0 100644\n--- a/api/BUILD.bazel\n+++ b/api/BUILD.bazel\n@@ -13,6 +13,5 @@ java_library(\n         artifact(\"com.google.errorprone:error_prone_annotations\"),\n         artifact(\"com.google.guava:failureaccess\"),  # future transitive dep of Guava. See #5214\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n     ],\n )\n\ndiff --git a/auth/BUILD.bazel b/auth/BUILD.bazel\nindex 095fae5af8b..a19562fa7f7 100644\n--- a/auth/BUILD.bazel\n+++ b/auth/BUILD.bazel\n@@ -11,6 +11,5 @@ java_library(\n         artifact(\"com.google.auth:google-auth-library-credentials\"),\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n     ],\n )\n\ndiff --git a/core/BUILD.bazel b/core/BUILD.bazel\nindex a1d3d19e828..35c20628d0b 100644\n--- a/core/BUILD.bazel\n+++ b/core/BUILD.bazel\n@@ -30,7 +30,6 @@ java_library(\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.errorprone:error_prone_annotations\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n         artifact(\"io.perfmark:perfmark-api\"),\n         artifact(\"org.codehaus.mojo:animal-sniffer-annotations\"),\n     ],\n\ndiff --git a/examples/pom.xml b/examples/pom.xml\nindex fdf92e9eca1..5cd721b50d1 100644\n--- a/examples/pom.xml\n+++ b/examples/pom.xml\n@@ -55,6 +55,11 @@\n       <artifactId>protobuf-java-util</artifactId>\n       <version>${protobuf.version}</version>\n     </dependency>\n+    <dependency> <!-- Use newer version than in protobuf-java-util -->\n+      <groupId>com.google.j2objc</groupId>\n+      <artifactId>j2objc-annotations</artifactId>\n+      <version>3.0.0</version>\n+    </dependency>\n     <dependency>\n       <groupId>org.apache.tomcat</groupId>\n       <artifactId>annotations-api</artifactId>\n\ndiff --git a/gcp-observability/build.gradle b/gcp-observability/build.gradle\nindex 0de7f8363bc..f869bd61a76 100644\n--- a/gcp-observability/build.gradle\n+++ b/gcp-observability/build.gradle\n@@ -65,8 +65,7 @@ dependencies {\n             libraries.auto.value.annotations, // Use our newer version\n             libraries.guava.jre, // Use our newer version\n             libraries.protobuf.java.util, // Use our newer version\n-            libraries.re2j, // Use our newer version\n-            libraries.j2objc.annotations // Explicit dependency to keep in step with version used by guava\n+            libraries.re2j // Use our newer version\n \n     testImplementation testFixtures(project(':grpc-api')),\n             project(':grpc-testing'),\n\ndiff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml\nindex 299ca60ab4b..488ead9ad86 100644\n--- a/gradle/libs.versions.toml\n+++ b/gradle/libs.versions.toml\n@@ -42,7 +42,6 @@ guava-testlib = \"com.google.guava:guava-testlib:33.2.1-android\"\n # May be different from the -android version.\n guava-jre = \"com.google.guava:guava:33.2.1-jre\"\n hdrhistogram = \"org.hdrhistogram:HdrHistogram:2.2.2\"\n-j2objc-annotations = \" com.google.j2objc:j2objc-annotations:3.0.0\"\n jakarta-servlet-api = \"jakarta.servlet:jakarta.servlet-api:5.0.0\"\n javax-annotation = \"org.apache.tomcat:annotations-api:6.0.53\"\n javax-servlet-api = \"javax.servlet:javax.servlet-api:4.0.1\"\n\ndiff --git a/grpclb/BUILD.bazel b/grpclb/BUILD.bazel\nindex 517155bbfc1..2dd24bb52a2 100644\n--- a/grpclb/BUILD.bazel\n+++ b/grpclb/BUILD.bazel\n@@ -21,7 +21,6 @@ java_library(\n         \"@io_grpc_grpc_proto//:grpclb_load_balancer_java_proto\",\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n     ],\n )\n \n\ndiff --git a/grpclb/build.gradle b/grpclb/build.gradle\nindex cea599828f5..93331053b09 100644\n--- a/grpclb/build.gradle\n+++ b/grpclb/build.gradle\n@@ -19,9 +19,9 @@ dependencies {\n     implementation project(':grpc-core'),\n             project(':grpc-protobuf'),\n             project(':grpc-stub'),\n+            libraries.guava,\n             libraries.protobuf.java,\n-            libraries.protobuf.java.util,\n-            libraries.guava\n+            libraries.protobuf.java.util\n     runtimeOnly libraries.errorprone.annotations\n     compileOnly libraries.javax.annotation\n     testImplementation libraries.truth,\n\ndiff --git a/inprocess/BUILD.bazel b/inprocess/BUILD.bazel\nindex aa614df654c..bef38612713 100644\n--- a/inprocess/BUILD.bazel\n+++ b/inprocess/BUILD.bazel\n@@ -13,6 +13,5 @@ java_library(\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.errorprone:error_prone_annotations\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n     ],\n )\n\ndiff --git a/netty/BUILD.bazel b/netty/BUILD.bazel\nindex daf2e83e59a..9fe52ea5868 100644\n--- a/netty/BUILD.bazel\n+++ b/netty/BUILD.bazel\n@@ -15,7 +15,6 @@ java_library(\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.errorprone:error_prone_annotations\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n         artifact(\"io.netty:netty-buffer\"),\n         artifact(\"io.netty:netty-codec\"),\n         artifact(\"io.netty:netty-codec-http\"),\n\ndiff --git a/okhttp/BUILD.bazel b/okhttp/BUILD.bazel\nindex 7cf1775da2c..80068c9bb5b 100644\n--- a/okhttp/BUILD.bazel\n+++ b/okhttp/BUILD.bazel\n@@ -17,7 +17,6 @@ java_library(\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.errorprone:error_prone_annotations\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n         artifact(\"com.squareup.okhttp:okhttp\"),\n         artifact(\"com.squareup.okio:okio\"),\n         artifact(\"io.perfmark:perfmark-api\"),\n\ndiff --git a/protobuf-lite/BUILD.bazel b/protobuf-lite/BUILD.bazel\nindex 087723e95fb..dad794e8b58 100644\n--- a/protobuf-lite/BUILD.bazel\n+++ b/protobuf-lite/BUILD.bazel\n@@ -10,7 +10,6 @@ java_library(\n         \"//api\",\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n     ] + select({\n         \":android\": [\"@com_google_protobuf//:protobuf_javalite\"],\n         \"//conditions:default\": [\"@com_google_protobuf//:protobuf_java\"],\n\ndiff --git a/protobuf/BUILD.bazel b/protobuf/BUILD.bazel\nindex 47cc8f9d032..724c78ca6ee 100644\n--- a/protobuf/BUILD.bazel\n+++ b/protobuf/BUILD.bazel\n@@ -13,6 +13,5 @@ java_library(\n         artifact(\"com.google.api.grpc:proto-google-common-protos\"),\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n     ],\n )\n\ndiff --git a/services/build.gradle b/services/build.gradle\nindex de716c9fa1d..fade7aef3fb 100644\n--- a/services/build.gradle\n+++ b/services/build.gradle\n@@ -27,11 +27,10 @@ dependencies {\n     implementation project(':grpc-core'),\n             project(':grpc-protobuf'),\n             project(':grpc-util'),\n-            libraries.protobuf.java.util,\n-            libraries.guava.jre // JRE required by protobuf-java-util\n+            libraries.guava.jre, // JRE required by protobuf-java-util\n+            libraries.protobuf.java.util\n \n     runtimeOnly libraries.errorprone.annotations,\n-            libraries.j2objc.annotations, // Explicit dependency to keep in step with version used by guava\n             libraries.gson  // to fix checkUpperBoundDeps error here\n     compileOnly libraries.javax.annotation\n     testImplementation project(':grpc-testing'),\n\ndiff --git a/stub/BUILD.bazel b/stub/BUILD.bazel\nindex 8950a1cfd3f..6d06e01f918 100644\n--- a/stub/BUILD.bazel\n+++ b/stub/BUILD.bazel\n@@ -12,7 +12,6 @@ java_library(\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.errorprone:error_prone_annotations\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n     ],\n )\n \n\ndiff --git a/util/BUILD.bazel b/util/BUILD.bazel\nindex 7a38063a983..8fb00e21d56 100644\n--- a/util/BUILD.bazel\n+++ b/util/BUILD.bazel\n@@ -15,7 +15,6 @@ java_library(\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.errorprone:error_prone_annotations\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n         artifact(\"org.codehaus.mojo:animal-sniffer-annotations\"),\n     ],\n )\n\ndiff --git a/xds/build.gradle b/xds/build.gradle\nindex a1d5aa753cb..a738145a2a0 100644\n--- a/xds/build.gradle\n+++ b/xds/build.gradle\n@@ -52,6 +52,7 @@ dependencies {\n             project(':grpc-services'),\n             project(':grpc-auth'),\n             project(path: ':grpc-alts', configuration: 'shadow'),\n+            libraries.guava,\n             libraries.gson,\n             libraries.re2j,\n             libraries.auto.value.annotations,\n",
    "test_patch": "diff --git a/testing/BUILD.bazel b/testing/BUILD.bazel\nindex 668a666c2fe..78f9b840754 100644\n--- a/testing/BUILD.bazel\n+++ b/testing/BUILD.bazel\n@@ -18,7 +18,6 @@ java_library(\n         \"//util\",\n         artifact(\"com.google.code.findbugs:jsr305\"),\n         artifact(\"com.google.guava:guava\"),\n-        artifact(\"com.google.j2objc:j2objc-annotations\"),\n         artifact(\"com.google.truth:truth\"),\n         artifact(\"junit:junit\"),\n     ],\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11406",
    "pr_id": 11406,
    "issue_id": 8712,
    "repo": "grpc/grpc-java",
    "problem_statement": "InProcess: client streaming memory leak when retry enabled \n<!-- Please answer these questions before submitting a bug report. -->\r\n\r\n### What version of gRPC-Java are you using?\r\n\r\n1.42.0\r\n\r\n### What is your environment?\r\n\r\nLinux 5.15.2\r\nopenjdk version \"11.0.13\" 2021-10-19\r\n\r\n### What did you expect to see?\r\n\r\nNo java heap space exception.\r\n\r\n### What did you see instead?\r\n\r\n`java.lang.OutOfMemoryError: Java heap space`\r\n\r\n### Steps to reproduce the bug\r\n\r\nWe've recently updated our grpc dependency from 1.39.0 to 1.42.0 which now causes an out of memory error in one of our tests.\r\n\r\nI've attached a test project that can reproduce the problem.\r\n[grpcheap.zip](https://github.com/grpc/grpc-java/files/7562661/grpcheap.zip)\r\n\r\n\r\nHow to run:\r\n\r\n```\r\nmvn clean test -Dgrpc.version=1.39.0   # test runs successfully\r\nmvn clean test -Dgrpc.version=1.42.0   # test fails with OOM\r\n```\r\n\r\nPlease be aware that the test is run with limited heap size (see pom.xml): `-Xmx64M`\r\n\r\nThe general idea of the test is this:\r\nClient-side has an `InputStream` that produces ~200mb data. This data of that stream is (lazily) split into ~1mb chunks and these are then streamed to the server.\r\n\r\nWhat happens when I run the test with grpc >1.40 is that I get an OOM when it has sent ~60mb worth of chunks, which obviously is near the `-Xmx` limit. However, what I would expect is that the heap usage would never rise to that level, as after each 1mb chunk has been sent that chunk can be gc'ed. I've also attached a screenshot of visualvm where you can see the heap graph of the test using grpc 1.39.0 vs 1.42.0:\r\n\r\n![grpc](https://user-images.githubusercontent.com/574849/142431013-583ee74c-6332-4991-95fd-822f2ffba3b8.png)\r\n\r\n\r\n",
    "issue_word_count": 303,
    "test_files_count": 7,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "census/src/test/java/io/grpc/census/CensusModulesTest.java",
      "core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java",
      "inprocess/src/main/java/io/grpc/inprocess/InProcessChannelBuilder.java",
      "inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java",
      "inprocess/src/main/java/io/grpc/inprocess/InternalInProcess.java",
      "inprocess/src/test/java/io/grpc/inprocess/AnonymousInProcessTransportTest.java",
      "inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java",
      "inprocess/src/test/java/io/grpc/inprocess/StandaloneInProcessTransportTest.java",
      "opentelemetry/src/test/java/io/grpc/opentelemetry/OpenTelemetryMetricsModuleTest.java",
      "opentelemetry/src/test/java/io/grpc/opentelemetry/OpenTelemetryTracingModuleTest.java"
    ],
    "pr_changed_test_files": [
      "census/src/test/java/io/grpc/census/CensusModulesTest.java",
      "core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java",
      "inprocess/src/test/java/io/grpc/inprocess/AnonymousInProcessTransportTest.java",
      "inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java",
      "inprocess/src/test/java/io/grpc/inprocess/StandaloneInProcessTransportTest.java",
      "opentelemetry/src/test/java/io/grpc/opentelemetry/OpenTelemetryMetricsModuleTest.java",
      "opentelemetry/src/test/java/io/grpc/opentelemetry/OpenTelemetryTracingModuleTest.java"
    ],
    "base_commit": "2aae68e11726e35576d78f8e568f9e389ed330bc",
    "head_commit": "c7364009665c76234bb09877a3bb2e1edc9ca94d",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11406",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11406",
    "dockerfile": "",
    "pr_merged_at": "2024-10-11T04:58:51.000Z",
    "patch": "diff --git a/inprocess/src/main/java/io/grpc/inprocess/InProcessChannelBuilder.java b/inprocess/src/main/java/io/grpc/inprocess/InProcessChannelBuilder.java\nindex c000b66b2a2..4e711a94004 100644\n--- a/inprocess/src/main/java/io/grpc/inprocess/InProcessChannelBuilder.java\n+++ b/inprocess/src/main/java/io/grpc/inprocess/InProcessChannelBuilder.java\n@@ -94,6 +94,7 @@ public static InProcessChannelBuilder forAddress(String name, int port) {\n   private ScheduledExecutorService scheduledExecutorService;\n   private int maxInboundMetadataSize = Integer.MAX_VALUE;\n   private boolean transportIncludeStatusCause = false;\n+  private long assumedMessageSize = -1;\n \n   private InProcessChannelBuilder(@Nullable SocketAddress directAddress, @Nullable String target) {\n \n@@ -117,10 +118,6 @@ public ClientTransportFactory buildClientTransportFactory() {\n     managedChannelImplBuilder.setStatsRecordStartedRpcs(false);\n     managedChannelImplBuilder.setStatsRecordFinishedRpcs(false);\n     managedChannelImplBuilder.setStatsRecordRetryMetrics(false);\n-\n-    // By default, In-process transport should not be retriable as that leaks memory.  Since\n-    // there is no wire, bytes aren't calculated so buffer limit isn't respected\n-    managedChannelImplBuilder.disableRetry();\n   }\n \n   @Internal\n@@ -225,9 +222,24 @@ public InProcessChannelBuilder propagateCauseWithStatus(boolean enable) {\n     return this;\n   }\n \n+  /**\n+   * Assumes RPC messages are the specified size. This avoids serializing\n+   * messages for metrics and retry memory tracking. This can dramatically\n+   * improve performance when accurate message sizes are not needed and if\n+   * nothing else needs the serialized message.\n+   * @param assumedMessageSize length of InProcess transport's messageSize.\n+   * @return this\n+   * @throws IllegalArgumentException if assumedMessageSize is negative.\n+   */\n+  public InProcessChannelBuilder assumedMessageSize(long assumedMessageSize) {\n+    checkArgument(assumedMessageSize >= 0, \"assumedMessageSize must be >= 0\");\n+    this.assumedMessageSize = assumedMessageSize;\n+    return this;\n+  }\n+\n   ClientTransportFactory buildTransportFactory() {\n-    return new InProcessClientTransportFactory(\n-        scheduledExecutorService, maxInboundMetadataSize, transportIncludeStatusCause);\n+    return new InProcessClientTransportFactory(scheduledExecutorService,\n+            maxInboundMetadataSize, transportIncludeStatusCause, assumedMessageSize);\n   }\n \n   void setStatsEnabled(boolean value) {\n@@ -243,15 +255,17 @@ static final class InProcessClientTransportFactory implements ClientTransportFac\n     private final int maxInboundMetadataSize;\n     private boolean closed;\n     private final boolean includeCauseWithStatus;\n+    private long assumedMessageSize;\n \n     private InProcessClientTransportFactory(\n         @Nullable ScheduledExecutorService scheduledExecutorService,\n-        int maxInboundMetadataSize, boolean includeCauseWithStatus) {\n+        int maxInboundMetadataSize, boolean includeCauseWithStatus, long assumedMessageSize) {\n       useSharedTimer = scheduledExecutorService == null;\n       timerService = useSharedTimer\n           ? SharedResourceHolder.get(GrpcUtil.TIMER_SERVICE) : scheduledExecutorService;\n       this.maxInboundMetadataSize = maxInboundMetadataSize;\n       this.includeCauseWithStatus = includeCauseWithStatus;\n+      this.assumedMessageSize = assumedMessageSize;\n     }\n \n     @Override\n@@ -263,7 +277,7 @@ public ConnectionClientTransport newClientTransport(\n       // TODO(carl-mastrangelo): Pass channelLogger in.\n       return new InProcessTransport(\n           addr, maxInboundMetadataSize, options.getAuthority(), options.getUserAgent(),\n-          options.getEagAttributes(), includeCauseWithStatus);\n+          options.getEagAttributes(), includeCauseWithStatus, assumedMessageSize);\n     }\n \n     @Override\n\ndiff --git a/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java b/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java\nindex ae8ad143d2c..ae597e34af0 100644\n--- a/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java\n+++ b/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java\n@@ -22,6 +22,7 @@\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Optional;\n+import com.google.common.io.ByteStreams;\n import com.google.common.util.concurrent.ListenableFuture;\n import com.google.common.util.concurrent.SettableFuture;\n import io.grpc.Attributes;\n@@ -35,6 +36,7 @@\n import io.grpc.InternalChannelz.SocketStats;\n import io.grpc.InternalLogId;\n import io.grpc.InternalMetadata;\n+import io.grpc.KnownLength;\n import io.grpc.Metadata;\n import io.grpc.MethodDescriptor;\n import io.grpc.SecurityLevel;\n@@ -59,6 +61,7 @@\n import io.grpc.internal.ServerTransportListener;\n import io.grpc.internal.StatsTraceContext;\n import io.grpc.internal.StreamListener;\n+import java.io.ByteArrayInputStream;\n import java.io.InputStream;\n import java.net.SocketAddress;\n import java.util.ArrayDeque;\n@@ -95,6 +98,8 @@ final class InProcessTransport implements ServerTransport, ConnectionClientTrans\n   private ServerTransportListener serverTransportListener;\n   private Attributes serverStreamAttributes;\n   private ManagedClientTransport.Listener clientTransportListener;\n+  // The size is assumed from the sender's side.\n+  private final long assumedMessageSize;\n   @GuardedBy(\"this\")\n   private boolean shutdown;\n   @GuardedBy(\"this\")\n@@ -135,8 +140,8 @@ protected void handleNotInUse() {\n       };\n \n   private InProcessTransport(SocketAddress address, int maxInboundMetadataSize, String authority,\n-      String userAgent, Attributes eagAttrs,\n-      Optional<ServerListener> optionalServerListener, boolean includeCauseWithStatus) {\n+      String userAgent, Attributes eagAttrs, Optional<ServerListener> optionalServerListener,\n+      boolean includeCauseWithStatus, long assumedMessageSize) {\n     this.address = address;\n     this.clientMaxInboundMetadataSize = maxInboundMetadataSize;\n     this.authority = authority;\n@@ -151,22 +156,23 @@ private InProcessTransport(SocketAddress address, int maxInboundMetadataSize, St\n     this.optionalServerListener = optionalServerListener;\n     logId = InternalLogId.allocate(getClass(), address.toString());\n     this.includeCauseWithStatus = includeCauseWithStatus;\n+    this.assumedMessageSize = assumedMessageSize;\n   }\n \n   public InProcessTransport(\n       SocketAddress address, int maxInboundMetadataSize, String authority, String userAgent,\n-      Attributes eagAttrs, boolean includeCauseWithStatus) {\n+      Attributes eagAttrs, boolean includeCauseWithStatus, long assumedMessageSize) {\n     this(address, maxInboundMetadataSize, authority, userAgent, eagAttrs,\n-        Optional.<ServerListener>absent(), includeCauseWithStatus);\n+        Optional.<ServerListener>absent(), includeCauseWithStatus, assumedMessageSize);\n   }\n \n   InProcessTransport(\n       String name, int maxInboundMetadataSize, String authority, String userAgent,\n       Attributes eagAttrs, ObjectPool<ScheduledExecutorService> serverSchedulerPool,\n       List<ServerStreamTracer.Factory> serverStreamTracerFactories,\n-      ServerListener serverListener, boolean includeCauseWithStatus) {\n+      ServerListener serverListener, boolean includeCauseWithStatus, long assumedMessageSize) {\n     this(new InProcessSocketAddress(name), maxInboundMetadataSize, authority, userAgent, eagAttrs,\n-        Optional.of(serverListener), includeCauseWithStatus);\n+        Optional.of(serverListener), includeCauseWithStatus, assumedMessageSize);\n     this.serverMaxInboundMetadataSize = maxInboundMetadataSize;\n     this.serverSchedulerPool = serverSchedulerPool;\n     this.serverStreamTracerFactories = serverStreamTracerFactories;\n@@ -507,6 +513,22 @@ private void clientCancelled(Status status) {\n \n       @Override\n       public void writeMessage(InputStream message) {\n+        long messageLength;\n+        try {\n+          if (assumedMessageSize != -1) {\n+            messageLength = assumedMessageSize;\n+          } else if (message instanceof KnownLength || message instanceof ByteArrayInputStream) {\n+            messageLength = message.available();\n+          } else {\n+            InputStream oldMessage = message;\n+            byte[] payload = ByteStreams.toByteArray(message);\n+            messageLength = payload.length;\n+            message = new ByteArrayInputStream(payload);\n+            oldMessage.close();\n+          }\n+        } catch (Exception e) {\n+          throw new RuntimeException(\"Error processing the message length\", e);\n+        }\n         synchronized (this) {\n           if (closed) {\n             return;\n@@ -515,6 +537,11 @@ public void writeMessage(InputStream message) {\n           statsTraceCtx.outboundMessageSent(outboundSeqNo, -1, -1);\n           clientStream.statsTraceCtx.inboundMessage(outboundSeqNo);\n           clientStream.statsTraceCtx.inboundMessageRead(outboundSeqNo, -1, -1);\n+          statsTraceCtx.outboundUncompressedSize(messageLength);\n+          statsTraceCtx.outboundWireSize(messageLength);\n+          // messageLength should be same at receiver's end as no actual wire is involved.\n+          clientStream.statsTraceCtx.inboundUncompressedSize(messageLength);\n+          clientStream.statsTraceCtx.inboundWireSize(messageLength);\n           outboundSeqNo++;\n           StreamListener.MessageProducer producer = new SingleMessageProducer(message);\n           if (clientRequested > 0) {\n@@ -778,6 +805,22 @@ private void serverClosed(Status serverListenerStatus, Status serverTracerStatus\n \n       @Override\n       public void writeMessage(InputStream message) {\n+        long messageLength;\n+        try {\n+          if (assumedMessageSize != -1) {\n+            messageLength = assumedMessageSize;\n+          } else if (message instanceof KnownLength || message instanceof ByteArrayInputStream) {\n+            messageLength = message.available();\n+          } else {\n+            InputStream oldMessage = message;\n+            byte[] payload = ByteStreams.toByteArray(message);\n+            messageLength = payload.length;\n+            message = new ByteArrayInputStream(payload);\n+            oldMessage.close();\n+          }\n+        } catch (Exception e) {\n+          throw new RuntimeException(\"Error processing the message length\", e);\n+        }\n         synchronized (this) {\n           if (closed) {\n             return;\n@@ -786,6 +829,11 @@ public void writeMessage(InputStream message) {\n           statsTraceCtx.outboundMessageSent(outboundSeqNo, -1, -1);\n           serverStream.statsTraceCtx.inboundMessage(outboundSeqNo);\n           serverStream.statsTraceCtx.inboundMessageRead(outboundSeqNo, -1, -1);\n+          statsTraceCtx.outboundUncompressedSize(messageLength);\n+          statsTraceCtx.outboundWireSize(messageLength);\n+          // messageLength should be same at receiver's end as no actual wire is involved.\n+          serverStream.statsTraceCtx.inboundUncompressedSize(messageLength);\n+          serverStream.statsTraceCtx.inboundWireSize(messageLength);\n           outboundSeqNo++;\n           StreamListener.MessageProducer producer = new SingleMessageProducer(message);\n           if (serverRequested > 0) {\n\ndiff --git a/inprocess/src/main/java/io/grpc/inprocess/InternalInProcess.java b/inprocess/src/main/java/io/grpc/inprocess/InternalInProcess.java\nindex 680373533c8..9e08c2523fb 100644\n--- a/inprocess/src/main/java/io/grpc/inprocess/InternalInProcess.java\n+++ b/inprocess/src/main/java/io/grpc/inprocess/InternalInProcess.java\n@@ -62,6 +62,6 @@ public static ConnectionClientTransport createInProcessTransport(\n         serverSchedulerPool,\n         serverStreamTracerFactories,\n         serverListener,\n-        includeCauseWithStatus);\n+        includeCauseWithStatus, -1);\n   }\n }\n",
    "test_patch": "diff --git a/census/src/test/java/io/grpc/census/CensusModulesTest.java b/census/src/test/java/io/grpc/census/CensusModulesTest.java\nindex 6ccaf78314f..9e0b4d935d3 100644\n--- a/census/src/test/java/io/grpc/census/CensusModulesTest.java\n+++ b/census/src/test/java/io/grpc/census/CensusModulesTest.java\n@@ -56,6 +56,7 @@\n import io.grpc.ClientInterceptors;\n import io.grpc.ClientStreamTracer;\n import io.grpc.Context;\n+import io.grpc.KnownLength;\n import io.grpc.Metadata;\n import io.grpc.MethodDescriptor;\n import io.grpc.ServerCall;\n@@ -99,6 +100,7 @@\n import io.opencensus.trace.Tracer;\n import io.opencensus.trace.propagation.BinaryFormat;\n import io.opencensus.trace.propagation.SpanContextParseException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.util.HashSet;\n import java.util.List;\n@@ -136,7 +138,7 @@ public class CensusModulesTest {\n       ClientStreamTracer.StreamInfo.newBuilder()\n           .setCallOptions(CallOptions.DEFAULT.withOption(NAME_RESOLUTION_DELAYED, 10L)).build();\n \n-  private static class StringInputStream extends InputStream {\n+  private static class StringInputStream extends InputStream implements KnownLength {\n     final String string;\n \n     StringInputStream(String string) {\n@@ -149,6 +151,11 @@ public int read() {\n       // passed to the InProcess server and consumed by MARSHALLER.parse().\n       throw new UnsupportedOperationException(\"Should not be called\");\n     }\n+\n+    @Override\n+    public int available() throws IOException {\n+      return string == null ? 0 : string.length();\n+    }\n   }\n \n   private static final MethodDescriptor.Marshaller<String> MARSHALLER =\n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java b/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\nindex 62cbdc4f67b..75ea2678709 100644\n--- a/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\n+++ b/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\n@@ -136,13 +136,6 @@ protected abstract InternalServer newServer(\n    */\n   protected abstract String testAuthority(InternalServer server);\n \n-  /**\n-   * Returns true (which is default) if the transport reports message sizes to StreamTracers.\n-   */\n-  protected boolean sizesReported() {\n-    return true;\n-  }\n-\n   protected final Attributes eagAttrs() {\n     return EAG_ATTRS;\n   }\n@@ -163,9 +156,9 @@ public void log(ChannelLogLevel level, String messageFormat, Object... args) {}\n    * tests in an indeterminate state.\n    */\n   protected InternalServer server;\n-  private ServerTransport serverTransport;\n-  private ManagedClientTransport client;\n-  private MethodDescriptor<String, String> methodDescriptor =\n+  protected ServerTransport serverTransport;\n+  protected ManagedClientTransport client;\n+  protected MethodDescriptor<String, String> methodDescriptor =\n       MethodDescriptor.<String, String>newBuilder()\n           .setType(MethodDescriptor.MethodType.UNKNOWN)\n           .setFullMethodName(\"service/method\")\n@@ -182,22 +175,22 @@ public void log(ChannelLogLevel level, String messageFormat, Object... args) {}\n       \"tracer-key\", Metadata.ASCII_STRING_MARSHALLER);\n   private final String tracerKeyValue = \"tracer-key-value\";\n \n-  private ManagedClientTransport.Listener mockClientTransportListener\n+  protected ManagedClientTransport.Listener mockClientTransportListener\n       = mock(ManagedClientTransport.Listener.class);\n-  private MockServerListener serverListener = new MockServerListener();\n+  protected MockServerListener serverListener = new MockServerListener();\n   private ArgumentCaptor<Throwable> throwableCaptor = ArgumentCaptor.forClass(Throwable.class);\n-  private final TestClientStreamTracer clientStreamTracer1 = new TestHeaderClientStreamTracer();\n+  protected final TestClientStreamTracer clientStreamTracer1 = new TestHeaderClientStreamTracer();\n   private final TestClientStreamTracer clientStreamTracer2 = new TestHeaderClientStreamTracer();\n-  private final ClientStreamTracer[] tracers = new ClientStreamTracer[] {\n+  protected final ClientStreamTracer[] tracers = new ClientStreamTracer[] {\n       clientStreamTracer1, clientStreamTracer2\n   };\n   private final ClientStreamTracer[] noopTracers = new ClientStreamTracer[] {\n     new ClientStreamTracer() {}\n   };\n \n-  private final TestServerStreamTracer serverStreamTracer1 = new TestServerStreamTracer();\n+  protected final TestServerStreamTracer serverStreamTracer1 = new TestServerStreamTracer();\n   private final TestServerStreamTracer serverStreamTracer2 = new TestServerStreamTracer();\n-  private final ServerStreamTracer.Factory serverStreamTracerFactory = mock(\n+  protected final ServerStreamTracer.Factory serverStreamTracerFactory = mock(\n       ServerStreamTracer.Factory.class,\n       delegatesTo(new ServerStreamTracer.Factory() {\n           final ArrayDeque<TestServerStreamTracer> tracers =\n@@ -857,26 +850,16 @@ public void basicStream() throws Exception {\n     message.close();\n     assertThat(clientStreamTracer1.nextOutboundEvent())\n         .matches(\"outboundMessageSent\\\\(0, -?[0-9]+, -?[0-9]+\\\\)\");\n-    if (sizesReported()) {\n-      assertThat(clientStreamTracer1.getOutboundWireSize()).isGreaterThan(0L);\n-      assertThat(clientStreamTracer1.getOutboundUncompressedSize()).isGreaterThan(0L);\n-    } else {\n-      assertThat(clientStreamTracer1.getOutboundWireSize()).isEqualTo(0L);\n-      assertThat(clientStreamTracer1.getOutboundUncompressedSize()).isEqualTo(0L);\n-    }\n+    assertThat(clientStreamTracer1.getOutboundWireSize()).isGreaterThan(0L);\n+    assertThat(clientStreamTracer1.getOutboundUncompressedSize()).isGreaterThan(0L);\n     assertThat(serverStreamTracer1.nextInboundEvent()).isEqualTo(\"inboundMessage(0)\");\n     assertNull(\"no additional message expected\", serverStreamListener.messageQueue.poll());\n \n     clientStream.halfClose();\n     assertTrue(serverStreamListener.awaitHalfClosed(TIMEOUT_MS, TimeUnit.MILLISECONDS));\n \n-    if (sizesReported()) {\n-      assertThat(serverStreamTracer1.getInboundWireSize()).isGreaterThan(0L);\n-      assertThat(serverStreamTracer1.getInboundUncompressedSize()).isGreaterThan(0L);\n-    } else {\n-      assertThat(serverStreamTracer1.getInboundWireSize()).isEqualTo(0L);\n-      assertThat(serverStreamTracer1.getInboundUncompressedSize()).isEqualTo(0L);\n-    }\n+    assertThat(serverStreamTracer1.getInboundWireSize()).isGreaterThan(0L);\n+    assertThat(serverStreamTracer1.getInboundUncompressedSize()).isGreaterThan(0L);\n     assertThat(serverStreamTracer1.nextInboundEvent())\n         .matches(\"inboundMessageRead\\\\(0, -?[0-9]+, -?[0-9]+\\\\)\");\n \n@@ -907,25 +890,15 @@ public void basicStream() throws Exception {\n     assertNotNull(\"message expected\", message);\n     assertThat(serverStreamTracer1.nextOutboundEvent())\n         .matches(\"outboundMessageSent\\\\(0, -?[0-9]+, -?[0-9]+\\\\)\");\n-    if (sizesReported()) {\n-      assertThat(serverStreamTracer1.getOutboundWireSize()).isGreaterThan(0L);\n-      assertThat(serverStreamTracer1.getOutboundUncompressedSize()).isGreaterThan(0L);\n-    } else {\n-      assertThat(serverStreamTracer1.getOutboundWireSize()).isEqualTo(0L);\n-      assertThat(serverStreamTracer1.getOutboundUncompressedSize()).isEqualTo(0L);\n-    }\n+    assertThat(serverStreamTracer1.getOutboundWireSize()).isGreaterThan(0L);\n+    assertThat(serverStreamTracer1.getOutboundUncompressedSize()).isGreaterThan(0L);\n     assertTrue(clientStreamTracer1.getInboundHeaders());\n     assertThat(clientStreamTracer1.nextInboundEvent()).isEqualTo(\"inboundMessage(0)\");\n     assertEquals(\"Hi. Who are you?\", methodDescriptor.parseResponse(message));\n     assertThat(clientStreamTracer1.nextInboundEvent())\n         .matches(\"inboundMessageRead\\\\(0, -?[0-9]+, -?[0-9]+\\\\)\");\n-    if (sizesReported()) {\n-      assertThat(clientStreamTracer1.getInboundWireSize()).isGreaterThan(0L);\n-      assertThat(clientStreamTracer1.getInboundUncompressedSize()).isGreaterThan(0L);\n-    } else {\n-      assertThat(clientStreamTracer1.getInboundWireSize()).isEqualTo(0L);\n-      assertThat(clientStreamTracer1.getInboundUncompressedSize()).isEqualTo(0L);\n-    }\n+    assertThat(clientStreamTracer1.getInboundWireSize()).isGreaterThan(0L);\n+    assertThat(clientStreamTracer1.getInboundUncompressedSize()).isGreaterThan(0L);\n \n     message.close();\n     assertNull(\"no additional message expected\", clientStreamListener.messageQueue.poll());\n@@ -1285,17 +1258,10 @@ public void onReady() {\n     serverStream.close(Status.OK, new Metadata());\n     assertTrue(clientStreamTracer1.getOutboundHeaders());\n     assertTrue(clientStreamTracer1.getInboundHeaders());\n-    if (sizesReported()) {\n-      assertThat(clientStreamTracer1.getInboundWireSize()).isGreaterThan(0L);\n-      assertThat(clientStreamTracer1.getInboundUncompressedSize()).isGreaterThan(0L);\n-      assertThat(serverStreamTracer1.getOutboundWireSize()).isGreaterThan(0L);\n-      assertThat(serverStreamTracer1.getOutboundUncompressedSize()).isGreaterThan(0L);\n-    } else {\n-      assertThat(clientStreamTracer1.getInboundWireSize()).isEqualTo(0L);\n-      assertThat(clientStreamTracer1.getInboundUncompressedSize()).isEqualTo(0L);\n-      assertThat(serverStreamTracer1.getOutboundWireSize()).isEqualTo(0L);\n-      assertThat(serverStreamTracer1.getOutboundUncompressedSize()).isEqualTo(0L);\n-    }\n+    assertThat(clientStreamTracer1.getInboundWireSize()).isGreaterThan(0L);\n+    assertThat(clientStreamTracer1.getInboundUncompressedSize()).isGreaterThan(0L);\n+    assertThat(serverStreamTracer1.getOutboundWireSize()).isGreaterThan(0L);\n+    assertThat(serverStreamTracer1.getOutboundUncompressedSize()).isGreaterThan(0L);\n     assertNull(clientStreamTracer1.getInboundTrailers());\n     assertSame(status, clientStreamTracer1.getStatus());\n     // There is a race between client cancelling and server closing.  The final status seen by the\n@@ -2184,7 +2150,7 @@ private static void runIfNotNull(Runnable runnable) {\n     }\n   }\n \n-  private static void startTransport(\n+  protected static void startTransport(\n       ManagedClientTransport clientTransport,\n       ManagedClientTransport.Listener listener) {\n     runIfNotNull(clientTransport.start(listener));\n@@ -2202,7 +2168,7 @@ public void streamCreated(Attributes transportAttrs, Metadata metadata) {\n     }\n   }\n \n-  private static class MockServerListener implements ServerListener {\n+  public static class MockServerListener implements ServerListener {\n     public final BlockingQueue<MockServerTransportListener> listeners\n         = new LinkedBlockingQueue<>();\n     private final SettableFuture<?> shutdown = SettableFuture.create();\n@@ -2233,7 +2199,7 @@ public MockServerTransportListener takeListenerOrFail(long timeout, TimeUnit uni\n     }\n   }\n \n-  private static class MockServerTransportListener implements ServerTransportListener {\n+  public static class MockServerTransportListener implements ServerTransportListener {\n     public final ServerTransport transport;\n     public final BlockingQueue<StreamCreation> streams = new LinkedBlockingQueue<>();\n     private final SettableFuture<?> terminated = SettableFuture.create();\n@@ -2281,8 +2247,8 @@ public StreamCreation takeStreamOrFail(long timeout, TimeUnit unit)\n     }\n   }\n \n-  private static class ServerStreamListenerBase implements ServerStreamListener {\n-    private final BlockingQueue<InputStream> messageQueue = new LinkedBlockingQueue<>();\n+  public static class ServerStreamListenerBase implements ServerStreamListener {\n+    public final BlockingQueue<InputStream> messageQueue = new LinkedBlockingQueue<>();\n     // Would have used Void instead of Object, but null elements are not allowed\n     private final BlockingQueue<Object> readyQueue = new LinkedBlockingQueue<>();\n     private final CountDownLatch halfClosedLatch = new CountDownLatch(1);\n@@ -2341,8 +2307,8 @@ public void closed(Status status) {\n     }\n   }\n \n-  private static class ClientStreamListenerBase implements ClientStreamListener {\n-    private final BlockingQueue<InputStream> messageQueue = new LinkedBlockingQueue<>();\n+  public static class ClientStreamListenerBase implements ClientStreamListener {\n+    public final BlockingQueue<InputStream> messageQueue = new LinkedBlockingQueue<>();\n     // Would have used Void instead of Object, but null elements are not allowed\n     private final BlockingQueue<Object> readyQueue = new LinkedBlockingQueue<>();\n     private final SettableFuture<Metadata> headers = SettableFuture.create();\n@@ -2399,7 +2365,7 @@ public void closed(Status status, RpcProgress rpcProgress, Metadata trailers) {\n     }\n   }\n \n-  private static class StreamCreation {\n+  public static class StreamCreation {\n     public final ServerStream stream;\n     public final String method;\n     public final Metadata headers;\n\ndiff --git a/inprocess/src/test/java/io/grpc/inprocess/AnonymousInProcessTransportTest.java b/inprocess/src/test/java/io/grpc/inprocess/AnonymousInProcessTransportTest.java\nindex a78a604eac3..7bf884c9ff9 100644\n--- a/inprocess/src/test/java/io/grpc/inprocess/AnonymousInProcessTransportTest.java\n+++ b/inprocess/src/test/java/io/grpc/inprocess/AnonymousInProcessTransportTest.java\n@@ -52,6 +52,6 @@ protected InternalServer newServer(\n   protected ManagedClientTransport newClientTransport(InternalServer server) {\n     return new InProcessTransport(\n         address, GrpcUtil.DEFAULT_MAX_HEADER_LIST_SIZE,\n-        testAuthority(server), USER_AGENT, eagAttrs(), false);\n+        testAuthority(server), USER_AGENT, eagAttrs(), false, -1);\n   }\n }\n\ndiff --git a/inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java b/inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java\nindex 420a9c4a8e7..87d7467c11f 100644\n--- a/inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java\n+++ b/inprocess/src/test/java/io/grpc/inprocess/InProcessTransportTest.java\n@@ -17,6 +17,7 @@\n package io.grpc.inprocess;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n import io.grpc.CallOptions;\n@@ -34,15 +35,21 @@\n import io.grpc.Status.Code;\n import io.grpc.StatusRuntimeException;\n import io.grpc.internal.AbstractTransportTest;\n+import io.grpc.internal.ClientStream;\n import io.grpc.internal.GrpcUtil;\n import io.grpc.internal.InternalServer;\n import io.grpc.internal.ManagedClientTransport;\n+import io.grpc.internal.ServerStream;\n+import io.grpc.internal.testing.TestStreamTracer;\n import io.grpc.stub.ClientCalls;\n import io.grpc.testing.GrpcCleanupRule;\n import io.grpc.testing.TestMethodDescriptors;\n+import java.io.InputStream;\n+import java.util.Arrays;\n import java.util.List;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n+import org.junit.Assert;\n import org.junit.Ignore;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -55,10 +62,18 @@ public class InProcessTransportTest extends AbstractTransportTest {\n   private static final String TRANSPORT_NAME = \"perfect-for-testing\";\n   private static final String AUTHORITY = \"a-testing-authority\";\n   protected static final String USER_AGENT = \"a-testing-user-agent\";\n+  private static final int TIMEOUT_MS = 5000;\n+  private static final long TEST_MESSAGE_LENGTH = 100;\n \n   @Rule\n   public final GrpcCleanupRule grpcCleanupRule = new GrpcCleanupRule();\n \n+  @Override\n+  protected InternalServer newServer(\n+      int port, List<ServerStreamTracer.Factory> streamTracerFactories) {\n+    return newServer(streamTracerFactories);\n+  }\n+\n   @Override\n   protected InternalServer newServer(\n       List<ServerStreamTracer.Factory> streamTracerFactories) {\n@@ -68,12 +83,6 @@ protected InternalServer newServer(\n     return new InProcessServer(builder, streamTracerFactories);\n   }\n \n-  @Override\n-  protected InternalServer newServer(\n-      int port, List<ServerStreamTracer.Factory> streamTracerFactories) {\n-    return newServer(streamTracerFactories);\n-  }\n-\n   @Override\n   protected String testAuthority(InternalServer server) {\n     return AUTHORITY;\n@@ -83,14 +92,13 @@ protected String testAuthority(InternalServer server) {\n   protected ManagedClientTransport newClientTransport(InternalServer server) {\n     return new InProcessTransport(\n         new InProcessSocketAddress(TRANSPORT_NAME), GrpcUtil.DEFAULT_MAX_HEADER_LIST_SIZE,\n-        testAuthority(server), USER_AGENT, eagAttrs(), false);\n+        testAuthority(server), USER_AGENT, eagAttrs(), false, -1);\n   }\n \n-  @Override\n-  protected boolean sizesReported() {\n-    // TODO(zhangkun83): InProcessTransport doesn't record metrics for now\n-    // (https://github.com/grpc/grpc-java/issues/2284)\n-    return false;\n+  private ManagedClientTransport newClientTransportWithAssumedMessageSize(InternalServer server) {\n+    return new InProcessTransport(\n+        new InProcessSocketAddress(TRANSPORT_NAME), GrpcUtil.DEFAULT_MAX_HEADER_LIST_SIZE,\n+        testAuthority(server), USER_AGENT, eagAttrs(), false, TEST_MESSAGE_LENGTH);\n   }\n \n   @Test\n@@ -170,11 +178,65 @@ public Listener<Void> startCall(ServerCall<Void, Void> call, Metadata headers) {\n                     .build();\n     ClientCall<Void,Void> call = channel.newCall(nonMatchMethod, CallOptions.DEFAULT);\n     try {\n-      ClientCalls.futureUnaryCall(call, null).get(5, TimeUnit.SECONDS);\n+      ClientCalls.futureUnaryCall(call, null).get(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n       fail(\"Call should fail.\");\n     } catch (ExecutionException ex) {\n       StatusRuntimeException s = (StatusRuntimeException)ex.getCause();\n       assertEquals(Code.UNIMPLEMENTED, s.getStatus().getCode());\n     }\n   }\n+\n+  @Test\n+  public void basicStreamInProcess() throws Exception {\n+    InProcessServerBuilder builder = InProcessServerBuilder\n+        .forName(TRANSPORT_NAME)\n+        .maxInboundMetadataSize(GrpcUtil.DEFAULT_MAX_HEADER_LIST_SIZE);\n+    server = new InProcessServer(builder, Arrays.asList(serverStreamTracerFactory));\n+    server.start(serverListener);\n+    client = newClientTransportWithAssumedMessageSize(server);\n+    startTransport(client, mockClientTransportListener);\n+    MockServerTransportListener serverTransportListener\n+        = serverListener.takeListenerOrFail(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    serverTransport = serverTransportListener.transport;\n+    // Set up client stream\n+    ClientStream clientStream = client.newStream(\n+        methodDescriptor, new Metadata(), CallOptions.DEFAULT, tracers);\n+    ClientStreamListenerBase clientStreamListener = new ClientStreamListenerBase();\n+    clientStream.start(clientStreamListener);\n+    StreamCreation serverStreamCreation\n+        = serverTransportListener.takeStreamOrFail(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    ServerStream serverStream = serverStreamCreation.stream;\n+    ServerStreamListenerBase serverStreamListener = serverStreamCreation.listener;\n+    serverStream.request(1);\n+    assertTrue(clientStream.isReady());\n+    // Send message from client to server\n+    clientStream.writeMessage(methodDescriptor.streamRequest(\"Hello from client\"));\n+    clientStream.flush();\n+    // Verify server received the message and check its size\n+    InputStream message =\n+        serverStreamListener.messageQueue.poll(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertEquals(\"Hello from client\", methodDescriptor.parseRequest(message));\n+    message.close();\n+    clientStream.halfClose();\n+    assertAssumedMessageSize(clientStreamTracer1, serverStreamTracer1);\n+\n+    clientStream.request(1);\n+    assertTrue(serverStream.isReady());\n+    serverStream.writeMessage(methodDescriptor.streamResponse(\"Hi from server\"));\n+    serverStream.flush();\n+    message = clientStreamListener.messageQueue.poll(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    assertEquals(\"Hi from server\", methodDescriptor.parseResponse(message));\n+    assertAssumedMessageSize(serverStreamTracer1, clientStreamTracer1);\n+    message.close();\n+    Status status = Status.OK.withDescription(\"That was normal\");\n+    serverStream.close(status, new Metadata());\n+  }\n+\n+  private void assertAssumedMessageSize(\n+      TestStreamTracer streamTracerSender, TestStreamTracer streamTracerReceiver) {\n+    Assert.assertEquals(TEST_MESSAGE_LENGTH, streamTracerSender.getOutboundWireSize());\n+    Assert.assertEquals(TEST_MESSAGE_LENGTH, streamTracerSender.getOutboundUncompressedSize());\n+    Assert.assertEquals(TEST_MESSAGE_LENGTH, streamTracerReceiver.getInboundWireSize());\n+    Assert.assertEquals(TEST_MESSAGE_LENGTH, streamTracerReceiver.getInboundUncompressedSize());\n+  }\n }\n\ndiff --git a/inprocess/src/test/java/io/grpc/inprocess/StandaloneInProcessTransportTest.java b/inprocess/src/test/java/io/grpc/inprocess/StandaloneInProcessTransportTest.java\nindex b1d80d53b8b..b26a5d8498d 100644\n--- a/inprocess/src/test/java/io/grpc/inprocess/StandaloneInProcessTransportTest.java\n+++ b/inprocess/src/test/java/io/grpc/inprocess/StandaloneInProcessTransportTest.java\n@@ -83,13 +83,6 @@ protected ManagedClientTransport newClientTransport(InternalServer server) {\n         false);\n   }\n \n-  @Override\n-  protected boolean sizesReported() {\n-    // TODO(zhangkun83): InProcessTransport doesn't record metrics for now\n-    // (https://github.com/grpc/grpc-java/issues/2284)\n-    return false;\n-  }\n-\n   @Test\n   @Ignore\n   @Override\n\ndiff --git a/opentelemetry/src/test/java/io/grpc/opentelemetry/OpenTelemetryMetricsModuleTest.java b/opentelemetry/src/test/java/io/grpc/opentelemetry/OpenTelemetryMetricsModuleTest.java\nindex 6128323154d..6003599668b 100644\n--- a/opentelemetry/src/test/java/io/grpc/opentelemetry/OpenTelemetryMetricsModuleTest.java\n+++ b/opentelemetry/src/test/java/io/grpc/opentelemetry/OpenTelemetryMetricsModuleTest.java\n@@ -37,6 +37,7 @@\n import io.grpc.ClientInterceptor;\n import io.grpc.ClientInterceptors;\n import io.grpc.ClientStreamTracer;\n+import io.grpc.KnownLength;\n import io.grpc.Metadata;\n import io.grpc.MethodDescriptor;\n import io.grpc.ServerCall;\n@@ -53,6 +54,7 @@\n import io.opentelemetry.api.metrics.Meter;\n import io.opentelemetry.sdk.common.InstrumentationScopeInfo;\n import io.opentelemetry.sdk.testing.junit4.OpenTelemetryRule;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.util.Arrays;\n import java.util.Map;\n@@ -107,7 +109,7 @@ public class OpenTelemetryMetricsModuleTest {\n       { 0L, 1024L, 2048L, 4096L, 16384L, 65536L, 262144L, 1048576L, 4194304L, 16777216L,\n       67108864L, 268435456L, 1073741824L, 4294967296L };\n \n-  private static final class StringInputStream extends InputStream {\n+  private static final class StringInputStream extends InputStream implements KnownLength {\n     final String string;\n \n     StringInputStream(String string) {\n@@ -118,6 +120,11 @@ private static final class StringInputStream extends InputStream {\n     public int read() {\n       throw new UnsupportedOperationException(\"should not be called\");\n     }\n+\n+    @Override\n+    public int available() throws IOException {\n+      return string == null ? 0 : string.length();\n+    }\n   }\n \n   private static final MethodDescriptor.Marshaller<String> MARSHALLER =\n\ndiff --git a/opentelemetry/src/test/java/io/grpc/opentelemetry/OpenTelemetryTracingModuleTest.java b/opentelemetry/src/test/java/io/grpc/opentelemetry/OpenTelemetryTracingModuleTest.java\nindex 89e79d55d25..b4486bcf2e4 100644\n--- a/opentelemetry/src/test/java/io/grpc/opentelemetry/OpenTelemetryTracingModuleTest.java\n+++ b/opentelemetry/src/test/java/io/grpc/opentelemetry/OpenTelemetryTracingModuleTest.java\n@@ -39,6 +39,7 @@\n import io.grpc.ClientInterceptor;\n import io.grpc.ClientInterceptors;\n import io.grpc.ClientStreamTracer;\n+import io.grpc.KnownLength;\n import io.grpc.ManagedChannel;\n import io.grpc.Metadata;\n import io.grpc.MethodDescriptor;\n@@ -73,6 +74,7 @@\n import io.opentelemetry.sdk.testing.junit4.OpenTelemetryRule;\n import io.opentelemetry.sdk.trace.data.EventData;\n import io.opentelemetry.sdk.trace.data.SpanData;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.util.Arrays;\n import java.util.List;\n@@ -102,7 +104,7 @@ public class OpenTelemetryTracingModuleTest {\n   private static final CallOptions CALL_OPTIONS =\n       CallOptions.DEFAULT.withOption(CUSTOM_OPTION, \"customvalue\");\n \n-  private static class StringInputStream extends InputStream {\n+  private static class StringInputStream extends InputStream implements KnownLength {\n     final String string;\n \n     StringInputStream(String string) {\n@@ -111,10 +113,15 @@ private static class StringInputStream extends InputStream {\n \n     @Override\n     public int read() {\n-      // InProcessTransport doesn't actually read bytes from the InputStream.  The InputStream is\n+      // InProcessTransport doesn't actually read bytes from the InputStream. The InputStream is\n       // passed to the InProcess server and consumed by MARSHALLER.parse().\n       throw new UnsupportedOperationException(\"Should not be called\");\n     }\n+\n+    @Override\n+    public int available() throws IOException {\n+      return string == null ? 0 : string.length();\n+    }\n   }\n \n   private static final MethodDescriptor.Marshaller<String> MARSHALLER =\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11320",
    "pr_id": 11320,
    "issue_id": 11289,
    "repo": "grpc/grpc-java",
    "problem_statement": "The onReadyThreshold property cannot be configured in the application[grpc version: 1.64.0]\n1. Although grpc currently supports configuring onReadyThreshold, the withOnReadyThreshold() method is not provided in AbstractStub\r\n![image](https://github.com/grpc/grpc-java/assets/73785906/ec0cd6f2-a2be-4a61-855b-116e418938dd)\r\n2. Because the onReadyThreshold property is not copied in the toBuilder() method of CallOptions. Even if onReadyThreshold is configured in the interceptor, it will be overwritten to null in the end.\r\n![image](https://github.com/grpc/grpc-java/assets/73785906/65e3a611-8dd8-4d1b-8827-20a94d6e71be)\r\n",
    "issue_word_count": 88,
    "test_files_count": 2,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "api/src/main/java/io/grpc/CallOptions.java",
      "api/src/test/java/io/grpc/CallOptionsTest.java",
      "stub/src/main/java/io/grpc/stub/AbstractStub.java",
      "stub/src/test/java/io/grpc/stub/BaseAbstractStubTest.java"
    ],
    "pr_changed_test_files": [
      "api/src/test/java/io/grpc/CallOptionsTest.java",
      "stub/src/test/java/io/grpc/stub/BaseAbstractStubTest.java"
    ],
    "base_commit": "5770114d08dcd352f2288ef52d17e1833530323c",
    "head_commit": "53d6258b13b1aee23ee31e8391b15b68612f268e",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11320",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11320",
    "dockerfile": "",
    "pr_merged_at": "2024-06-27T16:36:49.000Z",
    "patch": "diff --git a/api/src/main/java/io/grpc/CallOptions.java b/api/src/main/java/io/grpc/CallOptions.java\nindex 9c54bf50264..25c4df386a1 100644\n--- a/api/src/main/java/io/grpc/CallOptions.java\n+++ b/api/src/main/java/io/grpc/CallOptions.java\n@@ -512,6 +512,7 @@ private static Builder toBuilder(CallOptions other) {\n     builder.waitForReady = other.waitForReady;\n     builder.maxInboundMessageSize = other.maxInboundMessageSize;\n     builder.maxOutboundMessageSize = other.maxOutboundMessageSize;\n+    builder.onReadyThreshold = other.onReadyThreshold;\n     return builder;\n   }\n \n@@ -527,6 +528,7 @@ public String toString() {\n         .add(\"waitForReady\", isWaitForReady())\n         .add(\"maxInboundMessageSize\", maxInboundMessageSize)\n         .add(\"maxOutboundMessageSize\", maxOutboundMessageSize)\n+        .add(\"onReadyThreshold\", onReadyThreshold)\n         .add(\"streamTracerFactories\", streamTracerFactories)\n         .toString();\n   }\n\ndiff --git a/stub/src/main/java/io/grpc/stub/AbstractStub.java b/stub/src/main/java/io/grpc/stub/AbstractStub.java\nindex efda8799d76..0b6f86f2acf 100644\n--- a/stub/src/main/java/io/grpc/stub/AbstractStub.java\n+++ b/stub/src/main/java/io/grpc/stub/AbstractStub.java\n@@ -252,6 +252,16 @@ public final S withMaxOutboundMessageSize(int maxSize) {\n     return build(channel, callOptions.withMaxOutboundMessageSize(maxSize));\n   }\n \n+  /**\n+   * Returns a new stub that limits the maximum number of bytes per stream in the queue.\n+   *\n+   * @since 1.1.0\n+   */\n+  @ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/11021\")\n+  public final S withOnReadyThreshold(int numBytes) {\n+    return build(channel, callOptions.withOnReadyThreshold(numBytes));\n+  }\n+\n   /**\n    * A factory class for stub.\n    *\n",
    "test_patch": "diff --git a/api/src/test/java/io/grpc/CallOptionsTest.java b/api/src/test/java/io/grpc/CallOptionsTest.java\nindex f4c98c1369e..cc90a9799d7 100644\n--- a/api/src/test/java/io/grpc/CallOptionsTest.java\n+++ b/api/src/test/java/io/grpc/CallOptionsTest.java\n@@ -81,6 +81,16 @@ public void withAndWithoutWaitForReady() {\n         .isFalse();\n   }\n \n+  @Test\n+  public void withOnReadyThreshold() {\n+    int onReadyThreshold = 1024;\n+    CallOptions callOptions = CallOptions.DEFAULT.withOnReadyThreshold(onReadyThreshold);\n+    callOptions = callOptions.withWaitForReady();\n+    assertThat(callOptions.getOnReadyThreshold()).isEqualTo(onReadyThreshold);\n+    callOptions = callOptions.clearOnReadyThreshold();\n+    assertThat(callOptions.getOnReadyThreshold()).isNull();\n+  }\n+\n   @Test\n   public void allWiths() {\n     assertThat(allSet.getAuthority()).isSameInstanceAs(sampleAuthority);\n@@ -148,6 +158,7 @@ public void toStringMatches_noDeadline_default() {\n         .withCallCredentials(null)\n         .withMaxInboundMessageSize(44)\n         .withMaxOutboundMessageSize(55)\n+        .withOnReadyThreshold(1024)\n         .toString();\n \n     assertThat(actual).contains(\"deadline=null\");\n@@ -159,6 +170,7 @@ public void toStringMatches_noDeadline_default() {\n     assertThat(actual).contains(\"waitForReady=true\");\n     assertThat(actual).contains(\"maxInboundMessageSize=44\");\n     assertThat(actual).contains(\"maxOutboundMessageSize=55\");\n+    assertThat(actual).contains(\"onReadyThreshold=1024\");\n     assertThat(actual).contains(\"streamTracerFactories=[tracerFactory1, tracerFactory2]\");\n   }\n \n\ndiff --git a/stub/src/test/java/io/grpc/stub/BaseAbstractStubTest.java b/stub/src/test/java/io/grpc/stub/BaseAbstractStubTest.java\nindex cc5d5785449..9f7f10d8298 100644\n--- a/stub/src/test/java/io/grpc/stub/BaseAbstractStubTest.java\n+++ b/stub/src/test/java/io/grpc/stub/BaseAbstractStubTest.java\n@@ -16,6 +16,7 @@\n \n package io.grpc.stub;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNull;\n@@ -90,4 +91,16 @@ public void withExecutor() {\n \n     assertEquals(callOptions.getExecutor(), executor);\n   }\n+\n+  @Test\n+  public void withOnReadyThreshold() {\n+    T stub = create(channel);\n+    CallOptions callOptions = stub.getCallOptions();\n+    assertNull(callOptions.getOnReadyThreshold());\n+\n+    int onReadyThreshold = 1024;\n+    stub = stub.withOnReadyThreshold(onReadyThreshold);\n+    callOptions = stub.getCallOptions();\n+    assertThat(callOptions.getOnReadyThreshold()).isEqualTo(onReadyThreshold);\n+  }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11302",
    "pr_id": 11302,
    "issue_id": 11284,
    "repo": "grpc/grpc-java",
    "problem_statement": "grpc-netty breaks with Netty 4.1.111.Final\nAdded by ejona86: CORRUPTION. See https://github.com/grpc/grpc-java/issues/11284#issuecomment-2168264887\r\n\r\n-----\r\n\r\n### What version of gRPC-Java are you using?\r\n\r\n1.60.2, 1.64.0\r\n\r\n### What is your environment?\r\n\r\n```\r\n❯ uname -a\r\nDarwin Laris-MBP.lan 23.5.0 Darwin Kernel Version 23.5.0: Wed May  1 20:17:33 PDT 2024; root:xnu-10063.121.3~5/RELEASE_ARM64_T6031 arm64 arm Darwin\r\n❯ java -version\r\nopenjdk version \"17.0.11\" 2024-04-16\r\nOpenJDK Runtime Environment Temurin-17.0.11+9 (build 17.0.11+9)\r\nOpenJDK 64-Bit Server VM Temurin-17.0.11+9 (build 17.0.11+9, mixed mode)\r\n```\r\n\r\n### What did you expect to see?\r\n\r\nI'd expect grpc-netty to work with Netty 4.1.111.Final . I understand that [grpc-java currently supports Netty 4.1.100.Final](https://github.com/grpc/grpc-java/blob/master/SECURITY.md#netty), however many libraries depend on grpc-netty and cannot switch to use grpc-netty-shaded without relocating all classes to use the packages where grpc-netty-shaded contains shaded version of Netty. Examples of such popular libraries are io.etcd:jetcd-core and io.vertx:vertx-grpc.\r\n\r\n### What did you see instead?\r\n\r\nThere weren't any log messages or exceptions, communications just timed out. There were some debug logging about attempts. I'll share more details later.\r\n\r\n### Steps to reproduce the bug\r\n\r\nI'll share more details later. I maintain Apache Pulsar and Apache Bookkeeper projects and this problem showed up there when Netty got upgrades from 4.1.108.Final to 4.1.111.Final. We use an older grpc version, but I also tested with 1.60.2 and 1.64.0 and the problem remained. I also tried upgrading to 4.1.110.Final and that works fine with the test using jetcd-core that fails.\r\nThis means that Netty release 4.1.111.Final introduces a change that breaks grpc-netty.\r\nThese are the 4.1.111.Final release notes and changes: \r\n* https://netty.io/news/2024/06/11/4-1-111-Final.html\r\n* https://github.com/netty/netty/milestone/292?closed=1\r\n* https://github.com/netty/netty/compare/netty-4.1.110.Final...netty-4.1.111.Final\r\n",
    "issue_word_count": 380,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java",
      "netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java"
    ],
    "pr_changed_test_files": [
      "netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java"
    ],
    "base_commit": "71eca4eb3cf3e7e5bcc08160d356f0eae34f0e75",
    "head_commit": "db9309915b6b4f6f2b0553032a4e788146734db8",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11302",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11302",
    "dockerfile": "",
    "pr_merged_at": "2024-06-21T23:32:10.000Z",
    "patch": "diff --git a/netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java b/netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java\nindex 58eabb2cf8d..e56b97b799d 100644\n--- a/netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java\n+++ b/netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java\n@@ -23,6 +23,18 @@\n import io.netty.buffer.CompositeByteBuf;\n import io.netty.handler.codec.ByteToMessageDecoder.Cumulator;\n \n+\n+/**\n+ * \"Adaptive\" cumulator: cumulate {@link ByteBuf}s by dynamically switching between merge and\n+ * compose strategies.\n+ * <br><br>\n+ *\n+ * <p><b><font color=\"red\">Avoid using</font></b>\n+ * {@link CompositeByteBuf#addFlattenedComponents(boolean, ByteBuf)} as it can lead\n+ * to corruption, where the components' readable area are not equal to the Composite's capacity\n+ * (see https://github.com/netty/netty/issues/12844).\n+ */\n+\n class NettyAdaptiveCumulator implements Cumulator {\n   private final int composeMinSize;\n \n@@ -83,8 +95,7 @@ public final ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBu\n           composite.capacity(composite.writerIndex());\n         }\n       } else {\n-        composite = alloc.compositeBuffer(Integer.MAX_VALUE)\n-            .addFlattenedComponents(true, cumulation);\n+        composite = alloc.compositeBuffer(Integer.MAX_VALUE).addComponent(true, cumulation);\n       }\n       addInput(alloc, composite, in);\n       in = null;\n@@ -104,7 +115,7 @@ public final ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBu\n   @VisibleForTesting\n   void addInput(ByteBufAllocator alloc, CompositeByteBuf composite, ByteBuf in) {\n     if (shouldCompose(composite, in, composeMinSize)) {\n-      composite.addFlattenedComponents(true, in);\n+      composite.addComponent(true, in);\n     } else {\n       // The total size of the new data and the last component are below the threshold. Merge them.\n       mergeWithCompositeTail(alloc, composite, in);\n@@ -150,31 +161,13 @@ static void mergeWithCompositeTail(\n     ByteBuf tail = composite.component(tailComponentIndex);\n     ByteBuf newTail = null;\n     try {\n-      if (tail.refCnt() == 1 && !tail.isReadOnly() && newTailSize <= tail.maxCapacity()) {\n+      if (tail.refCnt() == 1 && !tail.isReadOnly() && newTailSize <= tail.maxCapacity()\n+          && !isCompositeOrWrappedComposite(tail)) {\n         // Ideal case: the tail isn't shared, and can be expanded to the required capacity.\n+\n         // Take ownership of the tail.\n         newTail = tail.retain();\n \n-        // TODO(https://github.com/netty/netty/issues/12844): remove when we use Netty with\n-        //   the issue fixed.\n-        // In certain cases, removing the CompositeByteBuf component, and then adding it back\n-        // isn't idempotent. An example is provided in https://github.com/netty/netty/issues/12844.\n-        // This happens because the buffer returned by composite.component() has out-of-sync\n-        // indexes. Under the hood the CompositeByteBuf returns a duplicate() of the underlying\n-        // buffer, but doesn't set the indexes.\n-        //\n-        // To get the right indexes we use the fact that composite.internalComponent() returns\n-        // the slice() into the readable portion of the underlying buffer.\n-        // We use this implementation detail (internalComponent() returning a *SlicedByteBuf),\n-        // and combine it with the fact that SlicedByteBuf duplicates have their indexes\n-        // adjusted so they correspond to the to the readable portion of the slice.\n-        //\n-        // Hence composite.internalComponent().duplicate() returns a buffer with the\n-        // indexes that should've been on the composite.component() in the first place.\n-        // Until the issue is fixed, we manually adjust the indexes of the removed component.\n-        ByteBuf sliceDuplicate = composite.internalComponent(tailComponentIndex).duplicate();\n-        newTail.setIndex(sliceDuplicate.readerIndex(), sliceDuplicate.writerIndex());\n-\n         /*\n          * The tail is a readable non-composite buffer, so writeBytes() handles everything for us.\n          *\n@@ -188,20 +181,26 @@ static void mergeWithCompositeTail(\n          *   as pronounced because the capacity is doubled with each reallocation.\n          */\n         newTail.writeBytes(in);\n+\n       } else {\n-        // The tail is shared, or not expandable. Replace it with a new buffer of desired capacity.\n+        // The tail satisfies one or more criteria:\n+        // - Shared\n+        // - Not expandable\n+        // - Composite\n+        // - Wrapped Composite\n         newTail = alloc.buffer(alloc.calculateNewCapacity(newTailSize, Integer.MAX_VALUE));\n         newTail.setBytes(0, composite, tailStart, tailSize)\n             .setBytes(tailSize, in, in.readerIndex(), inputSize)\n             .writerIndex(newTailSize);\n         in.readerIndex(in.writerIndex());\n       }\n+\n       // Store readerIndex to avoid out of bounds writerIndex during component replacement.\n       int prevReader = composite.readerIndex();\n       // Remove the old tail, reset writer index.\n       composite.removeComponent(tailComponentIndex).setIndex(0, tailStart);\n       // Add back the new tail.\n-      composite.addFlattenedComponents(true, newTail);\n+      composite.addComponent(true, newTail);\n       // New tail's ownership transferred to the composite buf.\n       newTail = null;\n       composite.readerIndex(prevReader);\n@@ -216,4 +215,12 @@ static void mergeWithCompositeTail(\n       }\n     }\n   }\n+\n+  private static boolean isCompositeOrWrappedComposite(ByteBuf tail) {\n+    ByteBuf cur = tail;\n+    while (cur.unwrap() != null) {\n+      cur = cur.unwrap();\n+    }\n+    return cur instanceof CompositeByteBuf;\n+  }\n }\n",
    "test_patch": "diff --git a/netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java b/netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java\nindex c4c2f95a2a9..a09e2e08e56 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java\n@@ -81,7 +81,7 @@ public void setUp() {\n         @Override\n         void addInput(ByteBufAllocator alloc, CompositeByteBuf composite, ByteBuf in) {\n           // To limit the testing scope to NettyAdaptiveCumulator.cumulate(), always compose\n-          composite.addFlattenedComponents(true, in);\n+          composite.addComponent(true, in);\n         }\n       };\n \n@@ -208,8 +208,8 @@ public void setUp() {\n       in = ByteBufUtil.writeAscii(alloc, inData);\n       tail = ByteBufUtil.writeAscii(alloc, tailData);\n       composite = alloc.compositeBuffer(Integer.MAX_VALUE);\n-      // Note that addFlattenedComponents() will not add a new component when tail is not readable.\n-      composite.addFlattenedComponents(true, tail);\n+      // Note that addComponent() will not add a new component when tail is not readable.\n+      composite.addComponent(true, tail);\n     }\n \n     @After\n@@ -345,7 +345,7 @@ public void mergeWithCompositeTail_tailExpandable_write() {\n       assertThat(in.readableBytes()).isAtMost(tail.writableBytes());\n \n       // All fits, so tail capacity must stay the same.\n-      composite.addFlattenedComponents(true, tail);\n+      composite.addComponent(true, tail);\n       assertTailExpanded(EXPECTED_TAIL_DATA, fitCapacity);\n     }\n \n@@ -362,7 +362,7 @@ public void mergeWithCompositeTail_tailExpandable_fastWrite() {\n           alloc.calculateNewCapacity(EXPECTED_TAIL_DATA.length(), Integer.MAX_VALUE);\n \n       // Tail capacity is extended to its fast capacity.\n-      composite.addFlattenedComponents(true, tail);\n+      composite.addComponent(true, tail);\n       assertTailExpanded(EXPECTED_TAIL_DATA, tailFastCapacity);\n     }\n \n@@ -372,7 +372,7 @@ public void mergeWithCompositeTail_tailExpandable_reallocateInMemory() {\n       @SuppressWarnings(\"InlineMeInliner\") // Requires Java 11\n       String inSuffixOverFastBytes = Strings.repeat(\"a\", tailFastCapacity + 1);\n       int newTailSize =  tail.readableBytes() + inSuffixOverFastBytes.length();\n-      composite.addFlattenedComponents(true, tail);\n+      composite.addComponent(true, tail);\n \n       // Make input larger than tailFastCapacity\n       in.writeCharSequence(inSuffixOverFastBytes, US_ASCII);\n@@ -435,21 +435,21 @@ public void mergeWithCompositeTail_tailNotExpandable_maxCapacityReached() {\n       @SuppressWarnings(\"InlineMeInliner\") // Requires Java 11\n       String tailSuffixFullCapacity = Strings.repeat(\"a\", tail.maxWritableBytes());\n       tail.writeCharSequence(tailSuffixFullCapacity, US_ASCII);\n-      composite.addFlattenedComponents(true, tail);\n+      composite.addComponent(true, tail);\n       assertTailReplaced();\n     }\n \n     @Test\n     public void mergeWithCompositeTail_tailNotExpandable_shared() {\n       tail.retain();\n-      composite.addFlattenedComponents(true, tail);\n+      composite.addComponent(true, tail);\n       assertTailReplaced();\n       tail.release();\n     }\n \n     @Test\n     public void mergeWithCompositeTail_tailNotExpandable_readOnly() {\n-      composite.addFlattenedComponents(true, tail.asReadOnly());\n+      composite.addComponent(true, tail.asReadOnly());\n       assertTailReplaced();\n     }\n \n@@ -527,8 +527,7 @@ public void mergeWithCompositeTail_tailExpandable_mergedReleaseOnThrow() {\n       CompositeByteBuf compositeThrows = new CompositeByteBuf(alloc, false, Integer.MAX_VALUE,\n           tail) {\n         @Override\n-        public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex,\n-            ByteBuf buffer) {\n+        public CompositeByteBuf addComponent(boolean increaseWriterIndex, ByteBuf buffer) {\n           throw expectedError;\n         }\n       };\n@@ -561,8 +560,7 @@ public void mergeWithCompositeTail_tailNotExpandable_mergedReleaseOnThrow() {\n       CompositeByteBuf compositeRo = new CompositeByteBuf(alloc, false, Integer.MAX_VALUE,\n           tail.asReadOnly()) {\n         @Override\n-        public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex,\n-            ByteBuf buffer) {\n+        public CompositeByteBuf addComponent(boolean increaseWriterIndex, ByteBuf buffer) {\n           throw expectedError;\n         }\n       };\n@@ -616,14 +614,14 @@ public void mergeWithCompositeTail_outOfSyncComposite() {\n       ByteBuf buf = alloc.buffer(32).writeBytes(\"---01234\".getBytes(US_ASCII));\n \n       // Start with a regular cumulation and add the buf as the only component.\n-      CompositeByteBuf composite1 = alloc.compositeBuffer(8).addFlattenedComponents(true, buf);\n+      CompositeByteBuf composite1 = alloc.compositeBuffer(8).addComponent(true, buf);\n       // Read composite1 buf to the beginning of the numbers.\n       assertThat(composite1.readCharSequence(3, US_ASCII).toString()).isEqualTo(\"---\");\n \n       // Wrap composite1 into another cumulation. This is similar to\n       // what NettyAdaptiveCumulator.cumulate() does in the case the cumulation has refCnt != 1.\n       CompositeByteBuf composite2 =\n-          alloc.compositeBuffer(8).addFlattenedComponents(true, composite1);\n+          alloc.compositeBuffer(8).addComponent(true, composite1);\n       assertThat(composite2.toString(US_ASCII)).isEqualTo(\"01234\");\n \n       // The previous operation does not adjust the read indexes of the underlying buffers,\n@@ -639,13 +637,27 @@ public void mergeWithCompositeTail_outOfSyncComposite() {\n       CompositeByteBuf cumulation = (CompositeByteBuf) cumulator.cumulate(alloc, composite2,\n           ByteBufUtil.writeAscii(alloc, \"56789\"));\n       assertThat(cumulation.toString(US_ASCII)).isEqualTo(\"0123456789\");\n+    }\n+\n+    @Test\n+    public void mergeWithNonCompositeTail() {\n+      NettyAdaptiveCumulator cumulator = new NettyAdaptiveCumulator(1024);\n+      ByteBufAllocator alloc = new PooledByteBufAllocator();\n+      ByteBuf buf = alloc.buffer().writeBytes(\"tail\".getBytes(US_ASCII));\n+      ByteBuf in = alloc.buffer().writeBytes(\"-012345\".getBytes(US_ASCII));\n+\n+      CompositeByteBuf composite = alloc.compositeBuffer().addComponent(true, buf);\n \n-      // Correctness check: we still have a single component, and this component is still the\n-      // original underlying buffer.\n-      assertThat(cumulation.numComponents()).isEqualTo(1);\n-      // Replace '2' with '*', and '8' with '$'.\n-      buf.setByte(5, '*').setByte(11, '$');\n-      assertThat(cumulation.toString(US_ASCII)).isEqualTo(\"01*34567$9\");\n+      CompositeByteBuf cumulation = (CompositeByteBuf) cumulator.cumulate(alloc, composite, in);\n+\n+      assertEquals(\"tail-012345\", cumulation.toString(US_ASCII));\n+      assertEquals(0, in.refCnt());\n+      assertEquals(1, cumulation.numComponents());\n+\n+      buf.setByte(2, '*').setByte(7, '$');\n+      assertEquals(\"ta*l-01$345\", cumulation.toString(US_ASCII));\n+\n+      composite.release();\n     }\n   }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11298",
    "pr_id": 11298,
    "issue_id": 11227,
    "repo": "grpc/grpc-java",
    "problem_statement": "Client requests fail with NullPointerException in PickFirstLeafLoadBalancer after temporary DNS resolution failures\n<!-- Please answer these questions before submitting a bug report. -->\r\n\r\n### What version of gRPC-Java are you using?\r\n1.63.0\r\n\r\n### What is your environment?\r\n<!-- operating system (Linux, Windows,...) and version, jdk version, etc. -->\r\nLinux Ubuntu 20.04\r\nOpenjdk version \"21.0.2\" 2024-01-16 LTS \r\n \r\n### What did you expect to see?\r\nNo `Uncaught exception in the SynchronizationContext. Panic!\r\njava.lang.NullPointerException: Cannot invoke \"io.grpc.internal.PickFirstLeafLoadBalancer$SubchannelData.getSubchannel()\" because \"subchannelData\" is null` errors in client requests.\r\n\r\n### What did you see instead?\r\nIn logs I see NPE errors in PickFirstLeafLoadBalancer, causing client requests to fail.\r\nThese errors are intermittent and happen on some apparently random VMs.\r\n\r\nAfter some investigation I found temporary DNS look up failures that happened before these NPE started to appear.\r\nDNS issues is something happening on our side, but I believe client should be able to handle temporary resolution failures.\r\n\r\nLogs are provided below:\r\n```\r\n2024-05-20 17:28:13,099 WARN           [grpc-default-executor-8397] i.g.i.ManagedChannelImpl: [Channel<17>: (some.internal.host.net:1234)] Failed to resolve name. status=Status{code=UNAVAILABLE, description=Unable to resolve host some.internal.host.net, cause=java.lang.RuntimeException: java.net.UnknownHostException: some.internal.host.net\r\n at io.grpc.internal.DnsNameResolver.resolveAddresses(DnsNameResolver.java:223)\r\n at io.grpc.internal.DnsNameResolver.doResolve(DnsNameResolver.java:282)\r\n at io.grpc.internal.DnsNameResolver$Resolve.run(DnsNameResolver.java:318)\r\n at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)\r\n at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)\r\n at java.base/java.lang.Thread.run(Thread.java:1583)\r\nCaused by: java.net.UnknownHostException: some.internal.host.net.net\r\n at java.base/java.net.InetAddress$CachedLookup.get(InetAddress.java:988)\r\n at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1818)\r\n at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1688)\r\n at io.grpc.internal.DnsNameResolver$JdkAddressResolver.resolveAddress(DnsNameResolver.java:632)\r\n at io.grpc.internal.DnsNameResolver.resolveAddresses(DnsNameResolver.java:219)\r\n ... 5 more\r\n}\r\n\r\n2024-05-20 17:28:18,481 ERROR          [grpc-default-executor-8395] i.g.i.ManagedChannelImpl: [Channel<17>: (some.internal.host.net:1234)] Uncaught exception in the SynchronizationContext. Panic!\r\njava.lang.NullPointerException: Cannot invoke \"io.grpc.internal.PickFirstLeafLoadBalancer$SubchannelData.getSubchannel()\" because \"subchannelData\" is null\r\n at io.grpc.internal.PickFirstLeafLoadBalancer.acceptResolvedAddresses(PickFirstLeafLoadBalancer.java:138)\r\n at io.grpc.internal.AutoConfiguredLoadBalancerFactory$AutoConfiguredLoadBalancer.tryAcceptResolvedAddresses(AutoConfiguredLoadBalancerFactory.java:142)\r\n at io.grpc.internal.ManagedChannelImpl$NameResolverListener$1NamesResolved.run(ManagedChannelImpl.java:1877)\r\n at io.grpc.SynchronizationContext.drain(SynchronizationContext.java:94)\r\n at io.grpc.SynchronizationContext.execute(SynchronizationContext.java:126)\r\n at io.grpc.internal.ManagedChannelImpl$NameResolverListener.onResult(ManagedChannelImpl.java:1891)\r\n at io.grpc.internal.RetryingNameResolver$RetryingListener.onResult(RetryingNameResolver.java:98)\r\n at io.grpc.internal.DnsNameResolver$Resolve.run(DnsNameResolver.java:333)\r\n at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)\r\n at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)\r\n at java.base/java.lang.Thread.run(Thread.java:1583)\r\n ```\r\n\r\n### Steps to reproduce the bug\r\nI don't have simple steps to reproduce unfortunately, but I think I found the call sequence causing the issue:\r\n* `io.grpc.internal.DnsNameResolver#resolveAddresses` throws `RuntimeException` with `UnknownHostException` as a cause\r\n* `io.grpc.internal.DnsNameResolver#doResolve` catches it and returns `result.error =  Status.UNAVAILABLE`\r\n* `io.grpc.internal.DnsNameResolver.Resolve#run` then calls `savedListener.onError(result.error)`\r\n  where `savedListener` is `io.grpc.internal.ManagedChannelImpl.NameResolverListener`\r\n* `io.grpc.internal.ManagedChannelImpl.NameResolverListener#onError` effectively calls `helper.lb.handleNameResolutionError(error)`\r\n  where `lb` is `io.grpc.internal.PickFirstLeafLoadBalancer`\r\n* `io.grpc.internal.PickFirstLeafLoadBalancer#handleNameResolutionError` finally calls `subchannels.clear()`, but does nothing with `addressIndex`\r\n* as a result we have `subchannels` cleared, but `addressIndex` stays intact \r\n  so we end up with inconsistent state between `subchannels` and `addressIndex`: `addressIndex.seekTo(previousAddress)` is true, but `subchannels.get(previousAddress)` is false\r\n  this inconsistency is causing the above NPE\r\n",
    "issue_word_count": 631,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "core/src/main/java/io/grpc/internal/PickFirstLeafLoadBalancer.java",
      "core/src/test/java/io/grpc/internal/PickFirstLeafLoadBalancerTest.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/PickFirstLeafLoadBalancerTest.java"
    ],
    "base_commit": "c540993aaa75b81ed08b3681cea06b0bf3c6819b",
    "head_commit": "c8e2bc58d2da1f835ea7bac5a6cf05a965b227b6",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11298",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11298",
    "dockerfile": "",
    "pr_merged_at": "2024-06-21T20:20:44.000Z",
    "patch": "diff --git a/core/src/main/java/io/grpc/internal/PickFirstLeafLoadBalancer.java b/core/src/main/java/io/grpc/internal/PickFirstLeafLoadBalancer.java\nindex 3846656355c..bce7a531972 100644\n--- a/core/src/main/java/io/grpc/internal/PickFirstLeafLoadBalancer.java\n+++ b/core/src/main/java/io/grpc/internal/PickFirstLeafLoadBalancer.java\n@@ -180,22 +180,32 @@ public Status acceptResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n \n   @Override\n   public void handleNameResolutionError(Status error) {\n+    if (rawConnectivityState == SHUTDOWN) {\n+      return;\n+    }\n+\n     for (SubchannelData subchannelData : subchannels.values()) {\n       subchannelData.getSubchannel().shutdown();\n     }\n     subchannels.clear();\n+    if (addressIndex != null) {\n+      addressIndex.updateGroups(null);\n+    }\n+    rawConnectivityState = TRANSIENT_FAILURE;\n     updateBalancingState(TRANSIENT_FAILURE, new Picker(PickResult.withError(error)));\n   }\n \n   void processSubchannelState(Subchannel subchannel, ConnectivityStateInfo stateInfo) {\n     ConnectivityState newState = stateInfo.getState();\n+\n+    SubchannelData subchannelData = subchannels.get(getAddress(subchannel));\n     // Shutdown channels/previously relevant subchannels can still callback with state updates.\n     // To prevent pickers from returning these obsolete subchannels, this logic\n     // is included to check if the current list of active subchannels includes this subchannel.\n-    SubchannelData subchannelData = subchannels.get(getAddress(subchannel));\n     if (subchannelData == null || subchannelData.getSubchannel() != subchannel) {\n       return;\n     }\n+\n     if (newState == SHUTDOWN) {\n       return;\n     }\n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/PickFirstLeafLoadBalancerTest.java b/core/src/test/java/io/grpc/internal/PickFirstLeafLoadBalancerTest.java\nindex eceb9500ef0..fdb0b76563b 100644\n--- a/core/src/test/java/io/grpc/internal/PickFirstLeafLoadBalancerTest.java\n+++ b/core/src/test/java/io/grpc/internal/PickFirstLeafLoadBalancerTest.java\n@@ -657,6 +657,37 @@ public void nameResolutionSuccessAfterError() {\n     assertEquals(mockSubchannel1, pickerCaptor.getValue().pickSubchannel(mockArgs).getSubchannel());\n   }\n \n+  @Test\n+  public void nameResolutionTemporaryError() {\n+    List<EquivalentAddressGroup> newServers = Lists.newArrayList(servers.get(0));\n+    InOrder inOrder = inOrder(mockHelper, mockSubchannel1);\n+    loadBalancer.acceptResolvedAddresses(\n+        ResolvedAddresses.newBuilder().setAddresses(newServers).setAttributes(affinity).build());\n+    inOrder.verify(mockSubchannel1).start(stateListenerCaptor.capture());\n+    SubchannelStateListener stateListener1 = stateListenerCaptor.getValue();\n+    stateListener1.onSubchannelState(ConnectivityStateInfo.forNonError(READY));\n+    inOrder.verify(mockHelper).updateBalancingState(eq(READY), pickerCaptor.capture());\n+    assertEquals(mockSubchannel1, pickerCaptor.getValue().pickSubchannel(mockArgs).getSubchannel());\n+\n+    loadBalancer.handleNameResolutionError(\n+        Status.UNAVAILABLE.withDescription(\"nameResolutionError\"));\n+    inOrder.verify(mockHelper).updateBalancingState(\n+        eq(TRANSIENT_FAILURE), any(SubchannelPicker.class));\n+\n+    loadBalancer.acceptResolvedAddresses(\n+        ResolvedAddresses.newBuilder().setAddresses(servers).setAttributes(affinity).build());\n+    inOrder.verify(mockHelper).updateBalancingState(eq(CONNECTING), pickerCaptor.capture());\n+    inOrder.verify(mockSubchannel1).start(stateListenerCaptor.capture());\n+    SubchannelStateListener stateListener2 = stateListenerCaptor.getValue();\n+\n+    assertNull(pickerCaptor.getValue().pickSubchannel(mockArgs).getSubchannel());\n+\n+    stateListener2.onSubchannelState(ConnectivityStateInfo.forNonError(READY));\n+    inOrder.verify(mockHelper).updateBalancingState(eq(READY), pickerCaptor.capture());\n+    assertEquals(mockSubchannel1, pickerCaptor.getValue().pickSubchannel(mockArgs).getSubchannel());\n+  }\n+\n+\n   @Test\n   public void nameResolutionErrorWithStateChanges() {\n     List<EquivalentAddressGroup> newServers = Lists.newArrayList(servers.get(0));\n@@ -725,6 +756,33 @@ public void requestConnection() {\n     }\n   }\n \n+  @Test\n+  public void failChannelWhenSubchannelsFail() {\n+    List<EquivalentAddressGroup> newServers = Lists.newArrayList(servers.get(0), servers.get(1));\n+    when(mockSubchannel1.getAllAddresses()).thenReturn(Lists.newArrayList(servers.get(0)));\n+    when(mockSubchannel2.getAllAddresses()).thenReturn(Lists.newArrayList(servers.get(1)));\n+\n+    // accept resolved addresses\n+    loadBalancer.acceptResolvedAddresses(\n+        ResolvedAddresses.newBuilder().setAddresses(newServers).setAttributes(affinity).build());\n+    InOrder inOrder = inOrder(mockHelper, mockSubchannel1, mockSubchannel2);\n+    verify(mockHelper).updateBalancingState(eq(CONNECTING), pickerCaptor.capture());\n+    verify(mockHelper).createSubchannel(createArgsCaptor.capture());\n+    inOrder.verify(mockSubchannel1).start(stateListenerCaptor.capture());\n+    SubchannelStateListener stateListener = stateListenerCaptor.getValue();\n+    assertNull(pickerCaptor.getValue().pickSubchannel(mockArgs).getSubchannel());\n+\n+    inOrder.verify(mockSubchannel1).requestConnection();\n+    stateListener.onSubchannelState(ConnectivityStateInfo.forTransientFailure(CONNECTION_ERROR));\n+\n+    inOrder.verify(mockSubchannel2).start(stateListenerCaptor.capture());\n+    SubchannelStateListener stateListener2 = stateListenerCaptor.getValue();\n+    stateListener2.onSubchannelState(ConnectivityStateInfo.forTransientFailure(CONNECTION_ERROR));\n+\n+    inOrder.verify(mockHelper).updateBalancingState(eq(TRANSIENT_FAILURE), pickerCaptor.capture());\n+    assertEquals(CONNECTION_ERROR, pickerCaptor.getValue().pickSubchannel(mockArgs).getStatus());\n+  }\n+\n   @Test\n   public void updateAddresses_emptyEagList_returns_false() {\n     loadBalancer.acceptResolvedAddresses(\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11294",
    "pr_id": 11294,
    "issue_id": 11284,
    "repo": "grpc/grpc-java",
    "problem_statement": "grpc-netty breaks with Netty 4.1.111.Final\nAdded by ejona86: CORRUPTION. See https://github.com/grpc/grpc-java/issues/11284#issuecomment-2168264887\r\n\r\n-----\r\n\r\n### What version of gRPC-Java are you using?\r\n\r\n1.60.2, 1.64.0\r\n\r\n### What is your environment?\r\n\r\n```\r\n❯ uname -a\r\nDarwin Laris-MBP.lan 23.5.0 Darwin Kernel Version 23.5.0: Wed May  1 20:17:33 PDT 2024; root:xnu-10063.121.3~5/RELEASE_ARM64_T6031 arm64 arm Darwin\r\n❯ java -version\r\nopenjdk version \"17.0.11\" 2024-04-16\r\nOpenJDK Runtime Environment Temurin-17.0.11+9 (build 17.0.11+9)\r\nOpenJDK 64-Bit Server VM Temurin-17.0.11+9 (build 17.0.11+9, mixed mode)\r\n```\r\n\r\n### What did you expect to see?\r\n\r\nI'd expect grpc-netty to work with Netty 4.1.111.Final . I understand that [grpc-java currently supports Netty 4.1.100.Final](https://github.com/grpc/grpc-java/blob/master/SECURITY.md#netty), however many libraries depend on grpc-netty and cannot switch to use grpc-netty-shaded without relocating all classes to use the packages where grpc-netty-shaded contains shaded version of Netty. Examples of such popular libraries are io.etcd:jetcd-core and io.vertx:vertx-grpc.\r\n\r\n### What did you see instead?\r\n\r\nThere weren't any log messages or exceptions, communications just timed out. There were some debug logging about attempts. I'll share more details later.\r\n\r\n### Steps to reproduce the bug\r\n\r\nI'll share more details later. I maintain Apache Pulsar and Apache Bookkeeper projects and this problem showed up there when Netty got upgrades from 4.1.108.Final to 4.1.111.Final. We use an older grpc version, but I also tested with 1.60.2 and 1.64.0 and the problem remained. I also tried upgrading to 4.1.110.Final and that works fine with the test using jetcd-core that fails.\r\nThis means that Netty release 4.1.111.Final introduces a change that breaks grpc-netty.\r\nThese are the 4.1.111.Final release notes and changes: \r\n* https://netty.io/news/2024/06/11/4-1-111-Final.html\r\n* https://github.com/netty/netty/milestone/292?closed=1\r\n* https://github.com/netty/netty/compare/netty-4.1.110.Final...netty-4.1.111.Final\r\n",
    "issue_word_count": 380,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java",
      "netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java"
    ],
    "pr_changed_test_files": [
      "netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java"
    ],
    "base_commit": "889893dd8cf0cb004b05361ce34ea1dfb8e092fc",
    "head_commit": "7ff0d6983cfc1681fb4a361b4ceeba29d33bbdb9",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11294",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11294",
    "dockerfile": "",
    "pr_merged_at": "2024-06-20T22:55:07.000Z",
    "patch": "diff --git a/netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java b/netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java\nindex 58eabb2cf8d..e56b97b799d 100644\n--- a/netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java\n+++ b/netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java\n@@ -23,6 +23,18 @@\n import io.netty.buffer.CompositeByteBuf;\n import io.netty.handler.codec.ByteToMessageDecoder.Cumulator;\n \n+\n+/**\n+ * \"Adaptive\" cumulator: cumulate {@link ByteBuf}s by dynamically switching between merge and\n+ * compose strategies.\n+ * <br><br>\n+ *\n+ * <p><b><font color=\"red\">Avoid using</font></b>\n+ * {@link CompositeByteBuf#addFlattenedComponents(boolean, ByteBuf)} as it can lead\n+ * to corruption, where the components' readable area are not equal to the Composite's capacity\n+ * (see https://github.com/netty/netty/issues/12844).\n+ */\n+\n class NettyAdaptiveCumulator implements Cumulator {\n   private final int composeMinSize;\n \n@@ -83,8 +95,7 @@ public final ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBu\n           composite.capacity(composite.writerIndex());\n         }\n       } else {\n-        composite = alloc.compositeBuffer(Integer.MAX_VALUE)\n-            .addFlattenedComponents(true, cumulation);\n+        composite = alloc.compositeBuffer(Integer.MAX_VALUE).addComponent(true, cumulation);\n       }\n       addInput(alloc, composite, in);\n       in = null;\n@@ -104,7 +115,7 @@ public final ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBu\n   @VisibleForTesting\n   void addInput(ByteBufAllocator alloc, CompositeByteBuf composite, ByteBuf in) {\n     if (shouldCompose(composite, in, composeMinSize)) {\n-      composite.addFlattenedComponents(true, in);\n+      composite.addComponent(true, in);\n     } else {\n       // The total size of the new data and the last component are below the threshold. Merge them.\n       mergeWithCompositeTail(alloc, composite, in);\n@@ -150,31 +161,13 @@ static void mergeWithCompositeTail(\n     ByteBuf tail = composite.component(tailComponentIndex);\n     ByteBuf newTail = null;\n     try {\n-      if (tail.refCnt() == 1 && !tail.isReadOnly() && newTailSize <= tail.maxCapacity()) {\n+      if (tail.refCnt() == 1 && !tail.isReadOnly() && newTailSize <= tail.maxCapacity()\n+          && !isCompositeOrWrappedComposite(tail)) {\n         // Ideal case: the tail isn't shared, and can be expanded to the required capacity.\n+\n         // Take ownership of the tail.\n         newTail = tail.retain();\n \n-        // TODO(https://github.com/netty/netty/issues/12844): remove when we use Netty with\n-        //   the issue fixed.\n-        // In certain cases, removing the CompositeByteBuf component, and then adding it back\n-        // isn't idempotent. An example is provided in https://github.com/netty/netty/issues/12844.\n-        // This happens because the buffer returned by composite.component() has out-of-sync\n-        // indexes. Under the hood the CompositeByteBuf returns a duplicate() of the underlying\n-        // buffer, but doesn't set the indexes.\n-        //\n-        // To get the right indexes we use the fact that composite.internalComponent() returns\n-        // the slice() into the readable portion of the underlying buffer.\n-        // We use this implementation detail (internalComponent() returning a *SlicedByteBuf),\n-        // and combine it with the fact that SlicedByteBuf duplicates have their indexes\n-        // adjusted so they correspond to the to the readable portion of the slice.\n-        //\n-        // Hence composite.internalComponent().duplicate() returns a buffer with the\n-        // indexes that should've been on the composite.component() in the first place.\n-        // Until the issue is fixed, we manually adjust the indexes of the removed component.\n-        ByteBuf sliceDuplicate = composite.internalComponent(tailComponentIndex).duplicate();\n-        newTail.setIndex(sliceDuplicate.readerIndex(), sliceDuplicate.writerIndex());\n-\n         /*\n          * The tail is a readable non-composite buffer, so writeBytes() handles everything for us.\n          *\n@@ -188,20 +181,26 @@ static void mergeWithCompositeTail(\n          *   as pronounced because the capacity is doubled with each reallocation.\n          */\n         newTail.writeBytes(in);\n+\n       } else {\n-        // The tail is shared, or not expandable. Replace it with a new buffer of desired capacity.\n+        // The tail satisfies one or more criteria:\n+        // - Shared\n+        // - Not expandable\n+        // - Composite\n+        // - Wrapped Composite\n         newTail = alloc.buffer(alloc.calculateNewCapacity(newTailSize, Integer.MAX_VALUE));\n         newTail.setBytes(0, composite, tailStart, tailSize)\n             .setBytes(tailSize, in, in.readerIndex(), inputSize)\n             .writerIndex(newTailSize);\n         in.readerIndex(in.writerIndex());\n       }\n+\n       // Store readerIndex to avoid out of bounds writerIndex during component replacement.\n       int prevReader = composite.readerIndex();\n       // Remove the old tail, reset writer index.\n       composite.removeComponent(tailComponentIndex).setIndex(0, tailStart);\n       // Add back the new tail.\n-      composite.addFlattenedComponents(true, newTail);\n+      composite.addComponent(true, newTail);\n       // New tail's ownership transferred to the composite buf.\n       newTail = null;\n       composite.readerIndex(prevReader);\n@@ -216,4 +215,12 @@ static void mergeWithCompositeTail(\n       }\n     }\n   }\n+\n+  private static boolean isCompositeOrWrappedComposite(ByteBuf tail) {\n+    ByteBuf cur = tail;\n+    while (cur.unwrap() != null) {\n+      cur = cur.unwrap();\n+    }\n+    return cur instanceof CompositeByteBuf;\n+  }\n }\n",
    "test_patch": "diff --git a/netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java b/netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java\nindex c4c2f95a2a9..a09e2e08e56 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java\n@@ -81,7 +81,7 @@ public void setUp() {\n         @Override\n         void addInput(ByteBufAllocator alloc, CompositeByteBuf composite, ByteBuf in) {\n           // To limit the testing scope to NettyAdaptiveCumulator.cumulate(), always compose\n-          composite.addFlattenedComponents(true, in);\n+          composite.addComponent(true, in);\n         }\n       };\n \n@@ -208,8 +208,8 @@ public void setUp() {\n       in = ByteBufUtil.writeAscii(alloc, inData);\n       tail = ByteBufUtil.writeAscii(alloc, tailData);\n       composite = alloc.compositeBuffer(Integer.MAX_VALUE);\n-      // Note that addFlattenedComponents() will not add a new component when tail is not readable.\n-      composite.addFlattenedComponents(true, tail);\n+      // Note that addComponent() will not add a new component when tail is not readable.\n+      composite.addComponent(true, tail);\n     }\n \n     @After\n@@ -345,7 +345,7 @@ public void mergeWithCompositeTail_tailExpandable_write() {\n       assertThat(in.readableBytes()).isAtMost(tail.writableBytes());\n \n       // All fits, so tail capacity must stay the same.\n-      composite.addFlattenedComponents(true, tail);\n+      composite.addComponent(true, tail);\n       assertTailExpanded(EXPECTED_TAIL_DATA, fitCapacity);\n     }\n \n@@ -362,7 +362,7 @@ public void mergeWithCompositeTail_tailExpandable_fastWrite() {\n           alloc.calculateNewCapacity(EXPECTED_TAIL_DATA.length(), Integer.MAX_VALUE);\n \n       // Tail capacity is extended to its fast capacity.\n-      composite.addFlattenedComponents(true, tail);\n+      composite.addComponent(true, tail);\n       assertTailExpanded(EXPECTED_TAIL_DATA, tailFastCapacity);\n     }\n \n@@ -372,7 +372,7 @@ public void mergeWithCompositeTail_tailExpandable_reallocateInMemory() {\n       @SuppressWarnings(\"InlineMeInliner\") // Requires Java 11\n       String inSuffixOverFastBytes = Strings.repeat(\"a\", tailFastCapacity + 1);\n       int newTailSize =  tail.readableBytes() + inSuffixOverFastBytes.length();\n-      composite.addFlattenedComponents(true, tail);\n+      composite.addComponent(true, tail);\n \n       // Make input larger than tailFastCapacity\n       in.writeCharSequence(inSuffixOverFastBytes, US_ASCII);\n@@ -435,21 +435,21 @@ public void mergeWithCompositeTail_tailNotExpandable_maxCapacityReached() {\n       @SuppressWarnings(\"InlineMeInliner\") // Requires Java 11\n       String tailSuffixFullCapacity = Strings.repeat(\"a\", tail.maxWritableBytes());\n       tail.writeCharSequence(tailSuffixFullCapacity, US_ASCII);\n-      composite.addFlattenedComponents(true, tail);\n+      composite.addComponent(true, tail);\n       assertTailReplaced();\n     }\n \n     @Test\n     public void mergeWithCompositeTail_tailNotExpandable_shared() {\n       tail.retain();\n-      composite.addFlattenedComponents(true, tail);\n+      composite.addComponent(true, tail);\n       assertTailReplaced();\n       tail.release();\n     }\n \n     @Test\n     public void mergeWithCompositeTail_tailNotExpandable_readOnly() {\n-      composite.addFlattenedComponents(true, tail.asReadOnly());\n+      composite.addComponent(true, tail.asReadOnly());\n       assertTailReplaced();\n     }\n \n@@ -527,8 +527,7 @@ public void mergeWithCompositeTail_tailExpandable_mergedReleaseOnThrow() {\n       CompositeByteBuf compositeThrows = new CompositeByteBuf(alloc, false, Integer.MAX_VALUE,\n           tail) {\n         @Override\n-        public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex,\n-            ByteBuf buffer) {\n+        public CompositeByteBuf addComponent(boolean increaseWriterIndex, ByteBuf buffer) {\n           throw expectedError;\n         }\n       };\n@@ -561,8 +560,7 @@ public void mergeWithCompositeTail_tailNotExpandable_mergedReleaseOnThrow() {\n       CompositeByteBuf compositeRo = new CompositeByteBuf(alloc, false, Integer.MAX_VALUE,\n           tail.asReadOnly()) {\n         @Override\n-        public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex,\n-            ByteBuf buffer) {\n+        public CompositeByteBuf addComponent(boolean increaseWriterIndex, ByteBuf buffer) {\n           throw expectedError;\n         }\n       };\n@@ -616,14 +614,14 @@ public void mergeWithCompositeTail_outOfSyncComposite() {\n       ByteBuf buf = alloc.buffer(32).writeBytes(\"---01234\".getBytes(US_ASCII));\n \n       // Start with a regular cumulation and add the buf as the only component.\n-      CompositeByteBuf composite1 = alloc.compositeBuffer(8).addFlattenedComponents(true, buf);\n+      CompositeByteBuf composite1 = alloc.compositeBuffer(8).addComponent(true, buf);\n       // Read composite1 buf to the beginning of the numbers.\n       assertThat(composite1.readCharSequence(3, US_ASCII).toString()).isEqualTo(\"---\");\n \n       // Wrap composite1 into another cumulation. This is similar to\n       // what NettyAdaptiveCumulator.cumulate() does in the case the cumulation has refCnt != 1.\n       CompositeByteBuf composite2 =\n-          alloc.compositeBuffer(8).addFlattenedComponents(true, composite1);\n+          alloc.compositeBuffer(8).addComponent(true, composite1);\n       assertThat(composite2.toString(US_ASCII)).isEqualTo(\"01234\");\n \n       // The previous operation does not adjust the read indexes of the underlying buffers,\n@@ -639,13 +637,27 @@ public void mergeWithCompositeTail_outOfSyncComposite() {\n       CompositeByteBuf cumulation = (CompositeByteBuf) cumulator.cumulate(alloc, composite2,\n           ByteBufUtil.writeAscii(alloc, \"56789\"));\n       assertThat(cumulation.toString(US_ASCII)).isEqualTo(\"0123456789\");\n+    }\n+\n+    @Test\n+    public void mergeWithNonCompositeTail() {\n+      NettyAdaptiveCumulator cumulator = new NettyAdaptiveCumulator(1024);\n+      ByteBufAllocator alloc = new PooledByteBufAllocator();\n+      ByteBuf buf = alloc.buffer().writeBytes(\"tail\".getBytes(US_ASCII));\n+      ByteBuf in = alloc.buffer().writeBytes(\"-012345\".getBytes(US_ASCII));\n+\n+      CompositeByteBuf composite = alloc.compositeBuffer().addComponent(true, buf);\n \n-      // Correctness check: we still have a single component, and this component is still the\n-      // original underlying buffer.\n-      assertThat(cumulation.numComponents()).isEqualTo(1);\n-      // Replace '2' with '*', and '8' with '$'.\n-      buf.setByte(5, '*').setByte(11, '$');\n-      assertThat(cumulation.toString(US_ASCII)).isEqualTo(\"01*34567$9\");\n+      CompositeByteBuf cumulation = (CompositeByteBuf) cumulator.cumulate(alloc, composite, in);\n+\n+      assertEquals(\"tail-012345\", cumulation.toString(US_ASCII));\n+      assertEquals(0, in.refCnt());\n+      assertEquals(1, cumulation.numComponents());\n+\n+      buf.setByte(2, '*').setByte(7, '$');\n+      assertEquals(\"ta*l-01$345\", cumulation.toString(US_ASCII));\n+\n+      composite.release();\n     }\n   }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11290",
    "pr_id": 11290,
    "issue_id": 11274,
    "repo": "grpc/grpc-java",
    "problem_statement": "Retry throttling not being respected with default service config\n### What version of gRPC-Java are you using?\r\n1.63\r\n\r\n### What is your environment?\r\nmacOS 14.4.1\r\nopenjdk 17.0.1 2021-10-19 LTS \r\nGradle 8.5\r\n\r\n### What did you expect to see?\r\nI'm setting a default service config with a retry policy and a retry throttling policy.\r\nThe retry throttling policy is not being respected and retries are always being executed.\r\nPlease check the following [serviceConfig](https://github.com/JoaoVitorStein/grpc-retry-throttling/blob/main/src/main/resources/service_config.json)\r\n\r\n### What did you see instead?\r\nRetries are always being executed \r\n\r\n\r\n### Steps to reproduce the bug\r\nCheck [this](https://github.com/JoaoVitorStein/grpc-retry-throttling/tree/main) repo, it reproduces this issue. You can check the steps to run it in the readme of that project.\r\nThis is a modified version of the retry example given in gRPC documentation, adding a retryThrottling policy to it.\r\n\r\nAs you can see, the retry throttling is being correctly configured in the defaultServiceConfig\r\n![image](https://github.com/grpc/grpc-java/assets/46487789/b465dafe-3c72-4ab1-84f9-61caa02e52d2)\r\n\r\nWith this configuration, I would expect that after 5 failed RPCs, retries would be throttled. However, all retries are executed in this case.\r\n![image](https://github.com/grpc/grpc-java/assets/46487789/ebab55af-df21-4d46-b085-4146403e75d1)\r\n\r\n### Possible root cause\r\nAfter some investigation, I was able to figure out that the throttling policy is only being used if it comes from the NameResolver, check [here](https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java#L1766). This happens because `effectiveServiceConfig` and `lastServiceConfig` are equal when you have a defaultServiceConfig and NameResolver doesnt retrieve a `serviceConfig`\r\n\r\nI guess that we need to also set the `transportProvider.throttle` when instantiating the `ManagedChannelImpl` ([here](https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java#L610))\r\n\r\n",
    "issue_word_count": 321,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java",
      "core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java"
    ],
    "base_commit": "889893dd8cf0cb004b05361ce34ea1dfb8e092fc",
    "head_commit": "9e88706048aa8e7734e8e12c6b5269729a6b4ec2",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11290",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11290",
    "dockerfile": "",
    "pr_merged_at": "2024-07-03T15:19:22.000Z",
    "patch": "diff --git a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\nindex b21fc97e64b..c5c7b66e15d 100644\n--- a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n+++ b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n@@ -616,7 +616,7 @@ ClientStream newSubstream(\n           parsedDefaultServiceConfig.getError());\n       this.defaultServiceConfig =\n           (ManagedChannelServiceConfig) parsedDefaultServiceConfig.getConfig();\n-      this.lastServiceConfig = this.defaultServiceConfig;\n+      this.transportProvider.throttle = this.defaultServiceConfig.getRetryThrottling();\n     } else {\n       this.defaultServiceConfig = null;\n     }\n@@ -708,6 +708,11 @@ public String getServiceAuthority() {\n   InternalConfigSelector getConfigSelector() {\n     return realChannel.configSelector.get();\n   }\n+  \n+  @VisibleForTesting\n+  boolean hasThrottle() {\n+    return this.transportProvider.throttle != null;\n+  }\n \n   /**\n    * Initiates an orderly shutdown in which preexisting calls continue but new calls are immediately\n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java b/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\nindex 2b598db1cfa..1d6492f791c 100644\n--- a/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\n+++ b/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\n@@ -4058,6 +4058,40 @@ public void disableServiceConfigLookUp_withDefaultConfig() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void disableServiceConfigLookUp_withDefaultConfig_withRetryThrottle() throws Exception {\n+    LoadBalancerRegistry.getDefaultRegistry().register(mockLoadBalancerProvider);\n+    try {\n+      FakeNameResolverFactory nameResolverFactory =\n+              new FakeNameResolverFactory.Builder(expectedUri)\n+                      .setServers(ImmutableList.of(addressGroup)).build();\n+      channelBuilder.nameResolverFactory(nameResolverFactory);\n+      channelBuilder.disableServiceConfigLookUp();\n+      channelBuilder.enableRetry();\n+      Map<String, Object> defaultServiceConfig =\n+              parseConfig(\"{\"\n+                      + \"\\\"retryThrottling\\\":{\\\"maxTokens\\\": 1, \\\"tokenRatio\\\": 1},\"\n+                      + \"\\\"methodConfig\\\":[{\"\n+                      + \"\\\"name\\\":[{\\\"service\\\":\\\"SimpleService1\\\"}],\"\n+                      + \"\\\"waitForReady\\\":true\"\n+                      + \"}]}\");\n+      channelBuilder.defaultServiceConfig(defaultServiceConfig);\n+\n+      createChannel();\n+\n+      ArgumentCaptor<ResolvedAddresses> resultCaptor =\n+              ArgumentCaptor.forClass(ResolvedAddresses.class);\n+      verify(mockLoadBalancer).acceptResolvedAddresses(resultCaptor.capture());\n+      assertThat(resultCaptor.getValue().getAddresses()).containsExactly(addressGroup);\n+      assertThat(resultCaptor.getValue().getAttributes().get(InternalConfigSelector.KEY)).isNull();\n+      verify(mockLoadBalancer, never()).handleNameResolutionError(any(Status.class));\n+      assertThat(channel.hasThrottle()).isTrue();\n+\n+    } finally {\n+      LoadBalancerRegistry.getDefaultRegistry().deregister(mockLoadBalancerProvider);\n+    }\n+  }\n+\n   @Test\n   public void enableServiceConfigLookUp_noDefaultConfig() throws Exception {\n     LoadBalancerRegistry.getDefaultRegistry().register(mockLoadBalancerProvider);\n@@ -4165,6 +4199,39 @@ public void enableServiceConfigLookUp_resolverReturnsNoConfig_withDefaultConfig(\n     }\n   }\n \n+\n+  @Test\n+  public void enableServiceConfigLookUp_usingDefaultConfig_withRetryThrottling() throws Exception {\n+    LoadBalancerRegistry.getDefaultRegistry().register(mockLoadBalancerProvider);\n+    try {\n+      FakeNameResolverFactory nameResolverFactory =\n+              new FakeNameResolverFactory.Builder(expectedUri)\n+                      .setServers(ImmutableList.of(addressGroup)).build();\n+      channelBuilder.nameResolverFactory(nameResolverFactory);\n+      channelBuilder.enableRetry();\n+      Map<String, Object> defaultServiceConfig =\n+              parseConfig(\"{\"\n+                      + \"\\\"retryThrottling\\\":{\\\"maxTokens\\\": 1, \\\"tokenRatio\\\": 1},\"\n+                      + \"\\\"methodConfig\\\":[{\"\n+                      + \"\\\"name\\\":[{\\\"service\\\":\\\"SimpleService1\\\"}],\"\n+                      + \"\\\"waitForReady\\\":true\"\n+                      + \"}]}\");\n+      channelBuilder.defaultServiceConfig(defaultServiceConfig);\n+\n+      createChannel();\n+\n+      ArgumentCaptor<ResolvedAddresses> resultCaptor =\n+              ArgumentCaptor.forClass(ResolvedAddresses.class);\n+      verify(mockLoadBalancer).acceptResolvedAddresses(resultCaptor.capture());\n+      assertThat(resultCaptor.getValue().getAddresses()).containsExactly(addressGroup);\n+      assertThat(resultCaptor.getValue().getAttributes().get(InternalConfigSelector.KEY)).isNull();\n+      verify(mockLoadBalancer, never()).handleNameResolutionError(any(Status.class));\n+      assertThat(channel.hasThrottle()).isTrue();\n+    } finally {\n+      LoadBalancerRegistry.getDefaultRegistry().deregister(mockLoadBalancerProvider);\n+    }\n+  }\n+\n   @Test\n   public void enableServiceConfigLookUp_resolverReturnsNoConfig_noDefaultConfig() {\n     LoadBalancerRegistry.getDefaultRegistry().register(mockLoadBalancerProvider);\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11273",
    "pr_id": 11273,
    "issue_id": 11150,
    "repo": "grpc/grpc-java",
    "problem_statement": "Upgrade Netty to fix issue with large headers and HTTP2 continuation packets\n<!-- Please answer these questions before submitting a bug report. -->\r\n\r\n### What version of gRPC-Java are you using?\r\n\r\nLatest 1.63.0\r\n\r\n### What is your environment?\r\n\r\nMac, Unix, any JVM\r\nTLS client/server\r\n\r\n### What did you expect to see?\r\n\r\nLarge headers over 200KB should work without issue over TLS, even if not ideal.\r\n\r\n### What did you see instead?\r\n\r\nThe connection is closed and gRPC errors reported. \r\n\r\n### Steps to reproduce the bug\r\n\r\n- Create a standard gRPC client/server \r\n- Setup TLS on both ends (plaintext does not cause issues)\r\n- Add metadata header with large size such as over 150KB\r\n- Setup client:server side maxHeader config to above that size\r\n- Make the request\r\n- Result should be a Netty assertion error due to maxFrameSize exceeded \r\n\r\n<!-- Make sure you include information that can help us debug (full error message, exception listing, stack trace, logs). -->\r\n\r\nThis occurs due to a bug in Netty that was resolved in 106.Final. gRPC is actively on 100.Final. \r\n\r\nhttps://github.com/netty/netty/pull/13786\r\n\r\nNote that these more recent additions to Netty also renamed the GraalVM reflection config file. There is an integration test for the shaded Netty package to verify that file is repackaged. This test fails since the file name was renamed. Updating the name of that file fixes that issue. \r\n\r\nThis bug is currently breaking any TLS connection using large headers. We did verify updating to latest Netty does resolve. \r\n\r\nIs it possible to update the version of Netty within gRPC to fix the underlying HTTP2 issue?\r\n\r\nThanks!",
    "issue_word_count": 264,
    "test_files_count": 3,
    "non_test_files_count": 33,
    "pr_changed_files": [
      "MODULE.bazel",
      "README.md",
      "SECURITY.md",
      "build.gradle",
      "compiler/src/test/golden/TestDeprecatedService.java.txt",
      "compiler/src/test/golden/TestService.java.txt",
      "core/src/main/java/io/grpc/internal/GrpcUtil.java",
      "examples/android/clientcache/app/build.gradle",
      "examples/android/helloworld/app/build.gradle",
      "examples/android/routeguide/app/build.gradle",
      "examples/android/strictmode/app/build.gradle",
      "examples/build.gradle",
      "examples/example-alts/build.gradle",
      "examples/example-debug/build.gradle",
      "examples/example-debug/pom.xml",
      "examples/example-gauth/build.gradle",
      "examples/example-gauth/pom.xml",
      "examples/example-gcp-csm-observability/build.gradle",
      "examples/example-gcp-observability/build.gradle",
      "examples/example-hostname/build.gradle",
      "examples/example-hostname/pom.xml",
      "examples/example-jwt-auth/build.gradle",
      "examples/example-jwt-auth/pom.xml",
      "examples/example-oauth/build.gradle",
      "examples/example-oauth/pom.xml",
      "examples/example-opentelemetry/build.gradle",
      "examples/example-orca/build.gradle",
      "examples/example-reflection/build.gradle",
      "examples/example-servlet/build.gradle",
      "examples/example-tls/build.gradle",
      "examples/example-tls/pom.xml",
      "examples/example-xds/build.gradle",
      "examples/pom.xml",
      "gradle/libs.versions.toml",
      "netty/shaded/src/testShadow/java/io/grpc/netty/shaded/ShadingTest.java",
      "repositories.bzl"
    ],
    "pr_changed_test_files": [
      "compiler/src/test/golden/TestDeprecatedService.java.txt",
      "compiler/src/test/golden/TestService.java.txt",
      "netty/shaded/src/testShadow/java/io/grpc/netty/shaded/ShadingTest.java"
    ],
    "base_commit": "00136096ed2180abc55ad2742d16a1df1a45fb3a",
    "head_commit": "4c0d369c5d0270957e9a3b034f55ab412c7ac683",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11273",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11273",
    "dockerfile": "",
    "pr_merged_at": "2024-08-02T19:35:44.000Z",
    "patch": "diff --git a/MODULE.bazel b/MODULE.bazel\nindex 2b5d85490f3..8260788c5cb 100644\n--- a/MODULE.bazel\n+++ b/MODULE.bazel\n@@ -2,7 +2,7 @@ module(\n     name = \"grpc-java\",\n     compatibility_level = 0,\n     repo_name = \"io_grpc_grpc_java\",\n-    version = \"1.67.0-SNAPSHOT\",  # CURRENT_GRPC_VERSION\n+    version = \"1.66.0-SNAPSHOT\",  # CURRENT_GRPC_VERSION\n )\n \n # GRPC_DEPS_START\n@@ -22,20 +22,20 @@ IO_GRPC_GRPC_JAVA_ARTIFACTS = [\n     \"com.google.truth:truth:1.4.2\",\n     \"com.squareup.okhttp:okhttp:2.7.5\",\n     \"com.squareup.okio:okio:2.10.0\",  # 3.0+ needs swapping to -jvm; need work to avoid flag-day\n-    \"io.netty:netty-buffer:4.1.100.Final\",\n-    \"io.netty:netty-codec-http2:4.1.100.Final\",\n-    \"io.netty:netty-codec-http:4.1.100.Final\",\n-    \"io.netty:netty-codec-socks:4.1.100.Final\",\n-    \"io.netty:netty-codec:4.1.100.Final\",\n-    \"io.netty:netty-common:4.1.100.Final\",\n-    \"io.netty:netty-handler-proxy:4.1.100.Final\",\n-    \"io.netty:netty-handler:4.1.100.Final\",\n-    \"io.netty:netty-resolver:4.1.100.Final\",\n-    \"io.netty:netty-tcnative-boringssl-static:2.0.61.Final\",\n-    \"io.netty:netty-tcnative-classes:2.0.61.Final\",\n-    \"io.netty:netty-transport-native-epoll:jar:linux-x86_64:4.1.100.Final\",\n-    \"io.netty:netty-transport-native-unix-common:4.1.100.Final\",\n-    \"io.netty:netty-transport:4.1.100.Final\",\n+    \"io.netty:netty-buffer:4.1.110.Final\",\n+    \"io.netty:netty-codec-http2:4.1.110.Final\",\n+    \"io.netty:netty-codec-http:4.1.110.Final\",\n+    \"io.netty:netty-codec-socks:4.1.110.Final\",\n+    \"io.netty:netty-codec:4.1.110.Final\",\n+    \"io.netty:netty-common:4.1.110.Final\",\n+    \"io.netty:netty-handler-proxy:4.1.110.Final\",\n+    \"io.netty:netty-handler:4.1.110.Final\",\n+    \"io.netty:netty-resolver:4.1.110.Final\",\n+    \"io.netty:netty-tcnative-boringssl-static:2.0.65.Final\",\n+    \"io.netty:netty-tcnative-classes:2.0.65.Final\",\n+    \"io.netty:netty-transport-native-epoll:jar:linux-x86_64:4.1.110.Final\",\n+    \"io.netty:netty-transport-native-unix-common:4.1.110.Final\",\n+    \"io.netty:netty-transport:4.1.110.Final\",\n     \"io.opencensus:opencensus-api:0.31.0\",\n     \"io.opencensus:opencensus-contrib-grpc-metrics:0.31.0\",\n     \"io.perfmark:perfmark-api:0.27.0\",\n\ndiff --git a/README.md b/README.md\nindex fef37c1c3bb..cb38ad66394 100644\n--- a/README.md\n+++ b/README.md\n@@ -44,8 +44,8 @@ For a guided tour, take a look at the [quick start\n guide](https://grpc.io/docs/languages/java/quickstart) or the more explanatory [gRPC\n basics](https://grpc.io/docs/languages/java/basics).\n \n-The [examples](https://github.com/grpc/grpc-java/tree/v1.65.0/examples) and the\n-[Android example](https://github.com/grpc/grpc-java/tree/v1.65.0/examples/android)\n+The [examples](https://github.com/grpc/grpc-java/tree/v1.66.0/examples) and the\n+[Android example](https://github.com/grpc/grpc-java/tree/v1.66.0/examples/android)\n are standalone projects that showcase the usage of gRPC.\n \n Download\n@@ -56,18 +56,18 @@ Download [the JARs][]. Or for Maven with non-Android, add to your `pom.xml`:\n <dependency>\n   <groupId>io.grpc</groupId>\n   <artifactId>grpc-netty-shaded</artifactId>\n-  <version>1.65.0</version>\n+  <version>1.66.0</version>\n   <scope>runtime</scope>\n </dependency>\n <dependency>\n   <groupId>io.grpc</groupId>\n   <artifactId>grpc-protobuf</artifactId>\n-  <version>1.65.0</version>\n+  <version>1.66.0</version>\n </dependency>\n <dependency>\n   <groupId>io.grpc</groupId>\n   <artifactId>grpc-stub</artifactId>\n-  <version>1.65.0</version>\n+  <version>1.66.0</version>\n </dependency>\n <dependency> <!-- necessary for Java 9+ -->\n   <groupId>org.apache.tomcat</groupId>\n@@ -79,18 +79,18 @@ Download [the JARs][]. Or for Maven with non-Android, add to your `pom.xml`:\n \n Or for Gradle with non-Android, add to your dependencies:\n ```gradle\n-runtimeOnly 'io.grpc:grpc-netty-shaded:1.65.0'\n-implementation 'io.grpc:grpc-protobuf:1.65.0'\n-implementation 'io.grpc:grpc-stub:1.65.0'\n+runtimeOnly 'io.grpc:grpc-netty-shaded:1.66.0'\n+implementation 'io.grpc:grpc-protobuf:1.66.0'\n+implementation 'io.grpc:grpc-stub:1.66.0'\n compileOnly 'org.apache.tomcat:annotations-api:6.0.53' // necessary for Java 9+\n ```\n \n For Android client, use `grpc-okhttp` instead of `grpc-netty-shaded` and\n `grpc-protobuf-lite` instead of `grpc-protobuf`:\n ```gradle\n-implementation 'io.grpc:grpc-okhttp:1.65.0'\n-implementation 'io.grpc:grpc-protobuf-lite:1.65.0'\n-implementation 'io.grpc:grpc-stub:1.65.0'\n+implementation 'io.grpc:grpc-okhttp:1.66.0'\n+implementation 'io.grpc:grpc-protobuf-lite:1.66.0'\n+implementation 'io.grpc:grpc-stub:1.66.0'\n compileOnly 'org.apache.tomcat:annotations-api:6.0.53' // necessary for Java 9+\n ```\n \n@@ -99,7 +99,7 @@ For [Bazel](https://bazel.build), you can either\n (with the GAVs from above), or use `@io_grpc_grpc_java//api` et al (see below).\n \n [the JARs]:\n-https://search.maven.org/search?q=g:io.grpc%20AND%20v:1.65.0\n+https://search.maven.org/search?q=g:io.grpc%20AND%20v:1.66.0\n \n Development snapshots are available in [Sonatypes's snapshot\n repository](https://oss.sonatype.org/content/repositories/snapshots/).\n@@ -129,9 +129,9 @@ For protobuf-based codegen integrated with the Maven build system, you can use\n       <artifactId>protobuf-maven-plugin</artifactId>\n       <version>0.6.1</version>\n       <configuration>\n-        <protocArtifact>com.google.protobuf:protoc:3.25.1:exe:${os.detected.classifier}</protocArtifact>\n+        <protocArtifact>com.google.protobuf:protoc:3.25.3:exe:${os.detected.classifier}</protocArtifact>\n         <pluginId>grpc-java</pluginId>\n-        <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.65.0:exe:${os.detected.classifier}</pluginArtifact>\n+        <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.66.0:exe:${os.detected.classifier}</pluginArtifact>\n       </configuration>\n       <executions>\n         <execution>\n@@ -157,11 +157,11 @@ plugins {\n \n protobuf {\n   protoc {\n-    artifact = \"com.google.protobuf:protoc:3.25.1\"\n+    artifact = \"com.google.protobuf:protoc:3.25.3\"\n   }\n   plugins {\n     grpc {\n-      artifact = 'io.grpc:protoc-gen-grpc-java:1.65.0'\n+      artifact = 'io.grpc:protoc-gen-grpc-java:1.66.0'\n     }\n   }\n   generateProtoTasks {\n@@ -190,11 +190,11 @@ plugins {\n \n protobuf {\n   protoc {\n-    artifact = \"com.google.protobuf:protoc:3.25.1\"\n+    artifact = \"com.google.protobuf:protoc:3.25.3\"\n   }\n   plugins {\n     grpc {\n-      artifact = 'io.grpc:protoc-gen-grpc-java:1.65.0'\n+      artifact = 'io.grpc:protoc-gen-grpc-java:1.66.0'\n     }\n   }\n   generateProtoTasks {\n\ndiff --git a/SECURITY.md b/SECURITY.md\nindex 774579bf68b..47b54f1ef47 100644\n--- a/SECURITY.md\n+++ b/SECURITY.md\n@@ -398,7 +398,8 @@ grpc-netty version | netty-handler version | netty-tcnative-boringssl-static ver\n 1.56.x             | 4.1.87.Final          | 2.0.61.Final\n 1.57.x-1.58.x      | 4.1.93.Final          | 2.0.61.Final\n 1.59.x             | 4.1.97.Final          | 2.0.61.Final\n-1.60.x-            | 4.1.100.Final         | 2.0.61.Final\n+1.60.x-1.65.x      | 4.1.100.Final         | 2.0.61.Final\n+1.66.x-            | 4.1.110.Final         | 2.0.65.Final\n \n _(grpc-netty-shaded avoids issues with keeping these versions in sync.)_\n \n\ndiff --git a/build.gradle b/build.gradle\nindex 74cfacb800a..76449ec0107 100644\n--- a/build.gradle\n+++ b/build.gradle\n@@ -21,7 +21,7 @@ subprojects {\n     apply plugin: \"net.ltgt.errorprone\"\n \n     group = \"io.grpc\"\n-    version = \"1.67.0-SNAPSHOT\" // CURRENT_GRPC_VERSION\n+    version = \"1.66.0-SNAPSHOT\" // CURRENT_GRPC_VERSION\n \n     repositories {\n         maven { // The google mirror is less flaky than mavenCentral()\n\ndiff --git a/core/src/main/java/io/grpc/internal/GrpcUtil.java b/core/src/main/java/io/grpc/internal/GrpcUtil.java\nindex 593bdbce13f..fa488f30ef8 100644\n--- a/core/src/main/java/io/grpc/internal/GrpcUtil.java\n+++ b/core/src/main/java/io/grpc/internal/GrpcUtil.java\n@@ -219,7 +219,7 @@ public byte[] parseAsciiString(byte[] serialized) {\n \n   public static final Splitter ACCEPT_ENCODING_SPLITTER = Splitter.on(',').trimResults();\n \n-  public static final String IMPLEMENTATION_VERSION = \"1.67.0-SNAPSHOT\"; // CURRENT_GRPC_VERSION\n+  public static final String IMPLEMENTATION_VERSION = \"1.66.0-SNAPSHOT\"; // CURRENT_GRPC_VERSION\n \n   /**\n    * The default timeout in nanos for a keepalive ping request.\n\ndiff --git a/examples/android/clientcache/app/build.gradle b/examples/android/clientcache/app/build.gradle\nindex 0ca032fb0e4..64e95de4738 100644\n--- a/examples/android/clientcache/app/build.gradle\n+++ b/examples/android/clientcache/app/build.gradle\n@@ -34,7 +34,7 @@ android {\n protobuf {\n     protoc { artifact = 'com.google.protobuf:protoc:3.25.1' }\n     plugins {\n-        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n         }\n     }\n     generateProtoTasks {\n@@ -54,12 +54,12 @@ dependencies {\n     implementation 'androidx.appcompat:appcompat:1.0.0'\n \n     // You need to build grpc-java to obtain these libraries below.\n-    implementation 'io.grpc:grpc-okhttp:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-protobuf-lite:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-stub:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-okhttp:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-protobuf-lite:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-stub:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n     implementation 'org.apache.tomcat:annotations-api:6.0.53'\n \n     testImplementation 'junit:junit:4.13.2'\n     testImplementation 'com.google.truth:truth:1.1.5'\n-    testImplementation 'io.grpc:grpc-testing:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    testImplementation 'io.grpc:grpc-testing:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n }\n\ndiff --git a/examples/android/helloworld/app/build.gradle b/examples/android/helloworld/app/build.gradle\nindex 0f1e8b4047b..f9433f14010 100644\n--- a/examples/android/helloworld/app/build.gradle\n+++ b/examples/android/helloworld/app/build.gradle\n@@ -32,7 +32,7 @@ android {\n protobuf {\n     protoc { artifact = 'com.google.protobuf:protoc:3.25.1' }\n     plugins {\n-        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n         }\n     }\n     generateProtoTasks {\n@@ -52,8 +52,8 @@ dependencies {\n     implementation 'androidx.appcompat:appcompat:1.0.0'\n \n     // You need to build grpc-java to obtain these libraries below.\n-    implementation 'io.grpc:grpc-okhttp:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-protobuf-lite:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-stub:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-okhttp:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-protobuf-lite:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-stub:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n     implementation 'org.apache.tomcat:annotations-api:6.0.53'\n }\n\ndiff --git a/examples/android/routeguide/app/build.gradle b/examples/android/routeguide/app/build.gradle\nindex c33135233ea..2431b473f29 100644\n--- a/examples/android/routeguide/app/build.gradle\n+++ b/examples/android/routeguide/app/build.gradle\n@@ -32,7 +32,7 @@ android {\n protobuf {\n     protoc { artifact = 'com.google.protobuf:protoc:3.25.1' }\n     plugins {\n-        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n         }\n     }\n     generateProtoTasks {\n@@ -52,8 +52,8 @@ dependencies {\n     implementation 'androidx.appcompat:appcompat:1.0.0'\n \n     // You need to build grpc-java to obtain these libraries below.\n-    implementation 'io.grpc:grpc-okhttp:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-protobuf-lite:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-stub:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-okhttp:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-protobuf-lite:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-stub:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n     implementation 'org.apache.tomcat:annotations-api:6.0.53'\n }\n\ndiff --git a/examples/android/strictmode/app/build.gradle b/examples/android/strictmode/app/build.gradle\nindex e8e2e8cac29..699c8dd9d68 100644\n--- a/examples/android/strictmode/app/build.gradle\n+++ b/examples/android/strictmode/app/build.gradle\n@@ -33,7 +33,7 @@ android {\n protobuf {\n     protoc { artifact = 'com.google.protobuf:protoc:3.25.1' }\n     plugins {\n-        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+        grpc { artifact = 'io.grpc:protoc-gen-grpc-java:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n         }\n     }\n     generateProtoTasks {\n@@ -53,8 +53,8 @@ dependencies {\n     implementation 'androidx.appcompat:appcompat:1.0.0'\n \n     // You need to build grpc-java to obtain these libraries below.\n-    implementation 'io.grpc:grpc-okhttp:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-protobuf-lite:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n-    implementation 'io.grpc:grpc-stub:1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-okhttp:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-protobuf-lite:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+    implementation 'io.grpc:grpc-stub:1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n     implementation 'org.apache.tomcat:annotations-api:6.0.53'\n }\n\ndiff --git a/examples/build.gradle b/examples/build.gradle\nindex 076e0c4a25b..c9213cc6a21 100644\n--- a/examples/build.gradle\n+++ b/examples/build.gradle\n@@ -23,7 +23,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n def protocVersion = protobufVersion\n \n\ndiff --git a/examples/example-alts/build.gradle b/examples/example-alts/build.gradle\nindex 3c998586bb6..06b7ac501d0 100644\n--- a/examples/example-alts/build.gradle\n+++ b/examples/example-alts/build.gradle\n@@ -24,7 +24,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-debug/build.gradle b/examples/example-debug/build.gradle\nindex ca151a13c1a..624483f663e 100644\n--- a/examples/example-debug/build.gradle\n+++ b/examples/example-debug/build.gradle\n@@ -25,7 +25,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-debug/pom.xml b/examples/example-debug/pom.xml\nindex 10ccf834d86..5aa8065ad31 100644\n--- a/examples/example-debug/pom.xml\n+++ b/examples/example-debug/pom.xml\n@@ -6,13 +6,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.66.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-debug</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.66.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for jdk9 -->\n     <maven.compiler.source>1.8</maven.compiler.source>\n\ndiff --git a/examples/example-gauth/build.gradle b/examples/example-gauth/build.gradle\nindex 40e72afad82..c43443c3860 100644\n--- a/examples/example-gauth/build.gradle\n+++ b/examples/example-gauth/build.gradle\n@@ -24,7 +24,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n def protocVersion = protobufVersion\n \n\ndiff --git a/examples/example-gauth/pom.xml b/examples/example-gauth/pom.xml\nindex 1e58e21e975..d91eeb15ded 100644\n--- a/examples/example-gauth/pom.xml\n+++ b/examples/example-gauth/pom.xml\n@@ -6,13 +6,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.66.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-gauth</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.66.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protobuf.version>3.25.3</protobuf.version>\n     <!-- required for jdk9 -->\n     <maven.compiler.source>1.8</maven.compiler.source>\n\ndiff --git a/examples/example-gcp-csm-observability/build.gradle b/examples/example-gcp-csm-observability/build.gradle\nindex 5de2b1995e2..a24490918b5 100644\n--- a/examples/example-gcp-csm-observability/build.gradle\n+++ b/examples/example-gcp-csm-observability/build.gradle\n@@ -25,7 +25,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n def openTelemetryVersion = '1.40.0'\n def openTelemetryPrometheusVersion = '1.40.0-alpha'\n\ndiff --git a/examples/example-gcp-observability/build.gradle b/examples/example-gcp-observability/build.gradle\nindex 0462c987f52..d6dd1aedc6e 100644\n--- a/examples/example-gcp-observability/build.gradle\n+++ b/examples/example-gcp-observability/build.gradle\n@@ -25,7 +25,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-hostname/build.gradle b/examples/example-hostname/build.gradle\nindex ab45ee2dc5b..ee5e5cf5c70 100644\n--- a/examples/example-hostname/build.gradle\n+++ b/examples/example-hostname/build.gradle\n@@ -23,7 +23,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-hostname/pom.xml b/examples/example-hostname/pom.xml\nindex 19b5f8b3c20..05131b89978 100644\n--- a/examples/example-hostname/pom.xml\n+++ b/examples/example-hostname/pom.xml\n@@ -6,13 +6,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.66.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-hostname</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.66.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for jdk9 -->\n     <maven.compiler.source>1.8</maven.compiler.source>\n\ndiff --git a/examples/example-jwt-auth/build.gradle b/examples/example-jwt-auth/build.gradle\nindex 6fdd4498c7d..2ad3c91f190 100644\n--- a/examples/example-jwt-auth/build.gradle\n+++ b/examples/example-jwt-auth/build.gradle\n@@ -23,7 +23,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n def protocVersion = protobufVersion\n \n\ndiff --git a/examples/example-jwt-auth/pom.xml b/examples/example-jwt-auth/pom.xml\nindex ad530e33aa7..01cf0edce28 100644\n--- a/examples/example-jwt-auth/pom.xml\n+++ b/examples/example-jwt-auth/pom.xml\n@@ -7,13 +7,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.66.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-jwt-auth</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.66.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protobuf.version>3.25.3</protobuf.version>\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for jdk9 -->\n\ndiff --git a/examples/example-oauth/build.gradle b/examples/example-oauth/build.gradle\nindex 255633b4f9f..23a6633e264 100644\n--- a/examples/example-oauth/build.gradle\n+++ b/examples/example-oauth/build.gradle\n@@ -23,7 +23,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protobufVersion = '3.25.3'\n def protocVersion = protobufVersion\n \n\ndiff --git a/examples/example-oauth/pom.xml b/examples/example-oauth/pom.xml\nindex 2c38a05b3e4..afd45aecd39 100644\n--- a/examples/example-oauth/pom.xml\n+++ b/examples/example-oauth/pom.xml\n@@ -7,13 +7,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.66.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-oauth</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.66.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protobuf.version>3.25.3</protobuf.version>\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for jdk9 -->\n\ndiff --git a/examples/example-opentelemetry/build.gradle b/examples/example-opentelemetry/build.gradle\nindex 00f7dc101bf..55d6685d771 100644\n--- a/examples/example-opentelemetry/build.gradle\n+++ b/examples/example-opentelemetry/build.gradle\n@@ -24,7 +24,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n def openTelemetryVersion = '1.40.0'\n def openTelemetryPrometheusVersion = '1.40.0-alpha'\n\ndiff --git a/examples/example-orca/build.gradle b/examples/example-orca/build.gradle\nindex 22feb8cae42..f3eae10ace4 100644\n--- a/examples/example-orca/build.gradle\n+++ b/examples/example-orca/build.gradle\n@@ -18,7 +18,7 @@ java {\n     targetCompatibility = JavaVersion.VERSION_1_8\n }\n \n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-reflection/build.gradle b/examples/example-reflection/build.gradle\nindex 78821391911..0b5c99898ed 100644\n--- a/examples/example-reflection/build.gradle\n+++ b/examples/example-reflection/build.gradle\n@@ -18,7 +18,7 @@ java {\n     targetCompatibility = JavaVersion.VERSION_1_8\n }\n \n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-servlet/build.gradle b/examples/example-servlet/build.gradle\nindex 9542ba0277f..b73d21fbc4c 100644\n--- a/examples/example-servlet/build.gradle\n+++ b/examples/example-servlet/build.gradle\n@@ -16,7 +16,7 @@ java {\n     targetCompatibility = JavaVersion.VERSION_1_8\n }\n \n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-tls/build.gradle b/examples/example-tls/build.gradle\nindex 94257af4758..3791cc03271 100644\n--- a/examples/example-tls/build.gradle\n+++ b/examples/example-tls/build.gradle\n@@ -24,7 +24,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/example-tls/pom.xml b/examples/example-tls/pom.xml\nindex bc9c0a7a8ee..1263b347030 100644\n--- a/examples/example-tls/pom.xml\n+++ b/examples/example-tls/pom.xml\n@@ -6,13 +6,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.66.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>example-tls</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.66.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for jdk9 -->\n     <maven.compiler.source>1.8</maven.compiler.source>\n\ndiff --git a/examples/example-xds/build.gradle b/examples/example-xds/build.gradle\nindex 2554adb0033..9807b1f8b74 100644\n--- a/examples/example-xds/build.gradle\n+++ b/examples/example-xds/build.gradle\n@@ -23,7 +23,7 @@ java {\n \n // Feel free to delete the comment at the next line. It is just for safely\n // updating the version in our release process.\n-def grpcVersion = '1.67.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n+def grpcVersion = '1.66.0-SNAPSHOT' // CURRENT_GRPC_VERSION\n def protocVersion = '3.25.3'\n \n dependencies {\n\ndiff --git a/examples/pom.xml b/examples/pom.xml\nindex 2b25d13b50c..a71e9d449c3 100644\n--- a/examples/pom.xml\n+++ b/examples/pom.xml\n@@ -6,13 +6,13 @@\n   <packaging>jar</packaging>\n   <!-- Feel free to delete the comment at the end of these lines. It is just\n        for safely updating the version in our release process. -->\n-  <version>1.67.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n+  <version>1.66.0-SNAPSHOT</version><!-- CURRENT_GRPC_VERSION -->\n   <name>examples</name>\n   <url>https://github.com/grpc/grpc-java</url>\n \n   <properties>\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n-    <grpc.version>1.67.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n+    <grpc.version>1.66.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->\n     <protobuf.version>3.25.3</protobuf.version>\n     <protoc.version>3.25.3</protoc.version>\n     <!-- required for JDK 8 -->\n\ndiff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml\nindex 78550e9c95e..4eee9a6018e 100644\n--- a/gradle/libs.versions.toml\n+++ b/gradle/libs.versions.toml\n@@ -1,8 +1,9 @@\n [versions]\n-netty = '4.1.100.Final'\n+googleauth = \"1.22.0\"\n+netty = '4.1.110.Final'\n # Keep the following references of tcnative version in sync whenever it's updated:\n #   SECURITY.md\n-nettytcnative = '2.0.61.Final'\n+nettytcnative = '2.0.65.Final'\n opencensus = \"0.31.1\"\n # Not upgrading to 4.x as it is not yet ABI compatible.\n # https://github.com/protocolbuffers/protobuf/issues/17247\n\ndiff --git a/repositories.bzl b/repositories.bzl\nindex af3acc8ddcf..455e9dcf3ca 100644\n--- a/repositories.bzl\n+++ b/repositories.bzl\n@@ -26,20 +26,20 @@ IO_GRPC_GRPC_JAVA_ARTIFACTS = [\n     \"com.google.truth:truth:1.4.2\",\n     \"com.squareup.okhttp:okhttp:2.7.5\",\n     \"com.squareup.okio:okio:2.10.0\",  # 3.0+ needs swapping to -jvm; need work to avoid flag-day\n-    \"io.netty:netty-buffer:4.1.100.Final\",\n-    \"io.netty:netty-codec-http2:4.1.100.Final\",\n-    \"io.netty:netty-codec-http:4.1.100.Final\",\n-    \"io.netty:netty-codec-socks:4.1.100.Final\",\n-    \"io.netty:netty-codec:4.1.100.Final\",\n-    \"io.netty:netty-common:4.1.100.Final\",\n-    \"io.netty:netty-handler-proxy:4.1.100.Final\",\n-    \"io.netty:netty-handler:4.1.100.Final\",\n-    \"io.netty:netty-resolver:4.1.100.Final\",\n-    \"io.netty:netty-tcnative-boringssl-static:2.0.61.Final\",\n-    \"io.netty:netty-tcnative-classes:2.0.61.Final\",\n-    \"io.netty:netty-transport-native-epoll:jar:linux-x86_64:4.1.100.Final\",\n-    \"io.netty:netty-transport-native-unix-common:4.1.100.Final\",\n-    \"io.netty:netty-transport:4.1.100.Final\",\n+    \"io.netty:netty-buffer:4.1.110.Final\",\n+    \"io.netty:netty-codec-http2:4.1.110.Final\",\n+    \"io.netty:netty-codec-http:4.1.110.Final\",\n+    \"io.netty:netty-codec-socks:4.1.110.Final\",\n+    \"io.netty:netty-codec:4.1.110.Final\",\n+    \"io.netty:netty-common:4.1.110.Final\",\n+    \"io.netty:netty-handler-proxy:4.1.110.Final\",\n+    \"io.netty:netty-handler:4.1.110.Final\",\n+    \"io.netty:netty-resolver:4.1.110.Final\",\n+    \"io.netty:netty-tcnative-boringssl-static:2.0.65.Final\",\n+    \"io.netty:netty-tcnative-classes:2.0.65.Final\",\n+    \"io.netty:netty-transport-native-epoll:jar:linux-x86_64:4.1.110.Final\",\n+    \"io.netty:netty-transport-native-unix-common:4.1.110.Final\",\n+    \"io.netty:netty-transport:4.1.110.Final\",\n     \"io.opencensus:opencensus-api:0.31.0\",\n     \"io.opencensus:opencensus-contrib-grpc-metrics:0.31.0\",\n     \"io.perfmark:perfmark-api:0.27.0\",\n",
    "test_patch": "diff --git a/compiler/src/test/golden/TestDeprecatedService.java.txt b/compiler/src/test/golden/TestDeprecatedService.java.txt\nindex 75e9e0b47e0..5666abe8fda 100644\n--- a/compiler/src/test/golden/TestDeprecatedService.java.txt\n+++ b/compiler/src/test/golden/TestDeprecatedService.java.txt\n@@ -8,7 +8,7 @@ import static io.grpc.MethodDescriptor.generateFullMethodName;\n  * </pre>\n  */\n @javax.annotation.Generated(\n-    value = \"by gRPC proto compiler (version 1.67.0-SNAPSHOT)\",\n+    value = \"by gRPC proto compiler (version 1.66.0-SNAPSHOT)\",\n     comments = \"Source: grpc/testing/compiler/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n @java.lang.Deprecated\n\ndiff --git a/compiler/src/test/golden/TestService.java.txt b/compiler/src/test/golden/TestService.java.txt\nindex 3852b6ee547..52e2a772414 100644\n--- a/compiler/src/test/golden/TestService.java.txt\n+++ b/compiler/src/test/golden/TestService.java.txt\n@@ -8,7 +8,7 @@ import static io.grpc.MethodDescriptor.generateFullMethodName;\n  * </pre>\n  */\n @javax.annotation.Generated(\n-    value = \"by gRPC proto compiler (version 1.67.0-SNAPSHOT)\",\n+    value = \"by gRPC proto compiler (version 1.66.0-SNAPSHOT)\",\n     comments = \"Source: grpc/testing/compiler/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class TestServiceGrpc {\n\ndiff --git a/netty/shaded/src/testShadow/java/io/grpc/netty/shaded/ShadingTest.java b/netty/shaded/src/testShadow/java/io/grpc/netty/shaded/ShadingTest.java\nindex 7a5e4b43c8b..89803998925 100644\n--- a/netty/shaded/src/testShadow/java/io/grpc/netty/shaded/ShadingTest.java\n+++ b/netty/shaded/src/testShadow/java/io/grpc/netty/shaded/ShadingTest.java\n@@ -79,7 +79,7 @@ public void nettyResourcesUpdated() throws IOException {\n     InputStream inputStream = NettyChannelBuilder.class.getClassLoader()\n         .getResourceAsStream(\n             \"META-INF/native-image/io.grpc.netty.shaded.io.netty/netty-transport/\"\n-                + \"reflection-config.json\");\n+                + \"reflect-config.json\");\n     assertThat(inputStream).isNotNull();\n \n     Scanner s = new Scanner(inputStream, StandardCharsets.UTF_8.name()).useDelimiter(\"\\\\A\");\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11272",
    "pr_id": 11272,
    "issue_id": 10566,
    "repo": "grpc/grpc-java",
    "problem_statement": "SecurityPolicy should support async/slow implementations\n<!-- Please answer these questions before submitting a feature request. -->\r\n\r\n### Is your feature request related to a problem?\r\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\r\nThe [SecurityPolicy](https://github.com/grpc/grpc-java/blob/master/binder/src/main/java/io/grpc/binder/SecurityPolicy.java) class defines an abstract method that returns a Status. If computing such status requires running some slow piece of code (that, for instance, reads flags from storage or from the network), then the only option is to block the calling thread until such operation is completed.\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy extends SecurityPolicy {\r\n  @Override\r\n  public Status checkAuthorization(int uid) {\r\n    try {\r\n      // must block the calling thread to satisfy SecurityPolicy's API\r\n      return fetchAllowlistedUids().get().contains(uid) ? Status.OK : Status.PERMISSION_DENIED;\r\n    } catch (InterruptedException e) {\r\n      return Status.fromThrowable(e);\r\n    }\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nBlocking is generally undesirable, because it monopolizes a thread from the system for mostly idle work, which leads to sub-optimal performance by requiring new threads to be spawned or reducing the amount of threads available, thus the responsiveness of the system.\r\n\r\n### Describe the solution you'd like\r\n`SecurityPolicy` (or an equivalent replacement) should provide an API for returning a `ListenableFuture<Status>` instead. Clients are free to implement it however they see fit. The case commonly supported today (simple non-blocking computations) would be equivalent to returning a `Futures.immediateFuture(status)` (from Guava).\r\n\r\n```java\r\npublic interface AsyncSecurityPolicy {\r\n  ListenableFuture<Status> checkAuthorization(int uid);\r\n}\r\n```\r\n\r\nThen the code above can be written as non-blocking:\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy implements AsyncSecurityPolicy {\r\n  @Override\r\n  public ListenableFuture<Status> checkAuthorization(int uid) {\r\n    return Futures.transform(\r\n      fetchAllowlistedUids(),\r\n      allowlist -> allowlist.contains(uid) ? Status.OK : Status.PERMISSION_DENIED,\r\n      someExecutor);\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\n### Describe alternatives you've considered\r\nN/A\r\n\r\n### Additional context\r\nSome apps use [StrictPolicy.VmPolicy](https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy) to instruct which kinds of threads are appropriate for different kinds of tasks (e.g. lightweight computations vs blocking network access). It can be used to configure different \"penalties\", like just logging in production or crashing in development. The issue above has triggered such violations during the development of an internal Google app.",
    "issue_word_count": 373,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "binder/src/androidTest/java/io/grpc/binder/internal/BinderClientTransportTest.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderTransport.java"
    ],
    "pr_changed_test_files": [
      "binder/src/androidTest/java/io/grpc/binder/internal/BinderClientTransportTest.java"
    ],
    "base_commit": "34ee600dcea1e38d678aca50c71f7d3b20a1d9ea",
    "head_commit": "e280bd817a6db8900bf49c083f104a0c234f5f1d",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11272",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11272",
    "dockerfile": "",
    "pr_merged_at": "2024-06-10T05:38:41.000Z",
    "patch": "diff --git a/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java b/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\nindex 9deb2bfaea1..dbdcaef6908 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\n@@ -32,6 +32,8 @@\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Ticker;\n import com.google.common.base.Verify;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n import com.google.common.util.concurrent.ListenableFuture;\n import io.grpc.Attributes;\n import io.grpc.CallOptions;\n@@ -47,6 +49,7 @@\n import io.grpc.Status;\n import io.grpc.StatusException;\n import io.grpc.binder.AndroidComponentAddress;\n+import io.grpc.binder.AsyncSecurityPolicy;\n import io.grpc.binder.InboundParcelablePolicy;\n import io.grpc.binder.SecurityPolicy;\n import io.grpc.internal.ClientStream;\n@@ -743,8 +746,8 @@ void notifyTerminated() {\n     @Override\n     @GuardedBy(\"this\")\n     protected void handleSetupTransport(Parcel parcel) {\n-      // Add the remote uid to our attributes.\n-      attributes = setSecurityAttrs(attributes, Binder.getCallingUid());\n+      int remoteUid = Binder.getCallingUid();\n+      attributes = setSecurityAttrs(attributes, remoteUid);\n       if (inState(TransportState.SETUP)) {\n         int version = parcel.readInt();\n         IBinder binder = parcel.readStrongBinder();\n@@ -755,46 +758,54 @@ protected void handleSetupTransport(Parcel parcel) {\n           shutdownInternal(\n               Status.UNAVAILABLE.withDescription(\"Malformed SETUP_TRANSPORT data\"), true);\n         } else {\n-          offloadExecutor.execute(() -> checkSecurityPolicy(binder));\n+          ListenableFuture<Status> authFuture = (securityPolicy instanceof AsyncSecurityPolicy) ?\n+              ((AsyncSecurityPolicy) securityPolicy).checkAuthorizationAsync(remoteUid) :\n+              Futures.submit(() -> securityPolicy.checkAuthorization(remoteUid), offloadExecutor);\n+          Futures.addCallback(\n+              authFuture,\n+              new FutureCallback<Status>() {\n+                @Override\n+                public void onSuccess(Status result) { handleAuthResult(binder, result); }\n+\n+                @Override\n+                public void onFailure(Throwable t) { handleAuthResult(t); }\n+              },\n+              offloadExecutor);\n         }\n       }\n     }\n \n-    private void checkSecurityPolicy(IBinder binder) {\n-      Status authorization;\n-      Integer remoteUid;\n-      synchronized (this) {\n-        remoteUid = attributes.get(REMOTE_UID);\n-      }\n-      if (remoteUid == null) {\n-        authorization = Status.UNAUTHENTICATED.withDescription(\"No remote UID available\");\n-      } else {\n-        authorization = securityPolicy.checkAuthorization(remoteUid);\n-      }\n-      synchronized (this) {\n-        if (inState(TransportState.SETUP)) {\n-          if (!authorization.isOk()) {\n-            shutdownInternal(authorization, true);\n-          } else if (!setOutgoingBinder(OneWayBinderProxy.wrap(binder, offloadExecutor))) {\n-            shutdownInternal(\n-                Status.UNAVAILABLE.withDescription(\"Failed to observe outgoing binder\"), true);\n-          } else {\n-            // Check state again, since a failure inside setOutgoingBinder (or a callback it\n-            // triggers), could have shut us down.\n-            if (!isShutdown()) {\n-              setState(TransportState.READY);\n-              attributes = clientTransportListener.filterTransport(attributes);\n-              clientTransportListener.transportReady();\n-              if (readyTimeoutFuture != null) {\n-                readyTimeoutFuture.cancel(false);\n-                readyTimeoutFuture = null;\n-              }\n+    private synchronized void handleAuthResult(IBinder binder, Status authorization) {\n+      if (inState(TransportState.SETUP)) {\n+        if (!authorization.isOk()) {\n+          shutdownInternal(authorization, true);\n+        } else if (!setOutgoingBinder(OneWayBinderProxy.wrap(binder, offloadExecutor))) {\n+          shutdownInternal(\n+              Status.UNAVAILABLE.withDescription(\"Failed to observe outgoing binder\"), true);\n+        } else {\n+          // Check state again, since a failure inside setOutgoingBinder (or a callback it\n+          // triggers), could have shut us down.\n+          if (!isShutdown()) {\n+            setState(TransportState.READY);\n+            attributes = clientTransportListener.filterTransport(attributes);\n+            clientTransportListener.transportReady();\n+            if (readyTimeoutFuture != null) {\n+              readyTimeoutFuture.cancel(false);\n+              readyTimeoutFuture = null;\n             }\n           }\n         }\n       }\n     }\n \n+    private synchronized void handleAuthResult(Throwable t) {\n+      shutdownInternal(\n+          Status.INTERNAL\n+              .withDescription(\"Could not evaluate SecurityPolicy\")\n+              .withCause(t),\n+          true);\n+    }\n+\n     @GuardedBy(\"this\")\n     @Override\n     protected void handlePingResponse(Parcel parcel) {\n",
    "test_patch": "diff --git a/binder/src/androidTest/java/io/grpc/binder/internal/BinderClientTransportTest.java b/binder/src/androidTest/java/io/grpc/binder/internal/BinderClientTransportTest.java\nindex 7446905194e..7625b43f4ab 100644\n--- a/binder/src/androidTest/java/io/grpc/binder/internal/BinderClientTransportTest.java\n+++ b/binder/src/androidTest/java/io/grpc/binder/internal/BinderClientTransportTest.java\n@@ -24,6 +24,8 @@\n import android.os.RemoteException;\n import androidx.test.core.app.ApplicationProvider;\n import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n import com.google.common.util.concurrent.SettableFuture;\n import com.google.protobuf.Empty;\n import io.grpc.CallOptions;\n@@ -35,6 +37,7 @@\n import io.grpc.Status;\n import io.grpc.Status.Code;\n import io.grpc.binder.AndroidComponentAddress;\n+import io.grpc.binder.AsyncSecurityPolicy;\n import io.grpc.binder.BinderServerBuilder;\n import io.grpc.binder.HostServices;\n import io.grpc.binder.SecurityPolicy;\n@@ -381,6 +384,34 @@ public void testBlackHoleSecurityPolicyConnectTimeout() throws Exception {\n     blockingSecurityPolicy.provideNextCheckAuthorizationResult(Status.OK);\n   }\n \n+  @Test\n+  public void testAsyncSecurityPolicyFailure() throws Exception {\n+    SettableAsyncSecurityPolicy securityPolicy = new SettableAsyncSecurityPolicy();\n+    transport = new BinderClientTransportBuilder()\n+        .setSecurityPolicy(securityPolicy)\n+        .build();\n+    RuntimeException exception = new NullPointerException();\n+    securityPolicy.setAuthorizationException(exception);\n+    transport.start(transportListener).run();\n+    Status transportStatus = transportListener.awaitShutdown();\n+    assertThat(transportStatus.getCode()).isEqualTo(Code.INTERNAL);\n+    assertThat(transportStatus.getCause()).isEqualTo(exception);\n+    transportListener.awaitTermination();\n+  }\n+\n+  @Test\n+  public void testAsyncSecurityPolicySuccess() throws Exception {\n+    SettableAsyncSecurityPolicy securityPolicy = new SettableAsyncSecurityPolicy();\n+    transport = new BinderClientTransportBuilder()\n+        .setSecurityPolicy(securityPolicy)\n+        .build();\n+    securityPolicy.setAuthorizationResult(Status.PERMISSION_DENIED);\n+    transport.start(transportListener).run();\n+    Status transportStatus = transportListener.awaitShutdown();\n+    assertThat(transportStatus.getCode()).isEqualTo(Code.PERMISSION_DENIED);\n+    transportListener.awaitTermination();\n+  }\n+\n   private static void startAndAwaitReady(\n       BinderTransport.BinderClientTransport transport, TestTransportListener transportListener)\n       throws Exception {\n@@ -540,4 +571,27 @@ public Status checkAuthorization(int uid) {\n       }\n     }\n   }\n+\n+  /**\n+   * An AsyncSecurityPolicy that lets a test specify the outcome of checkAuthorizationAsync().\n+   */\n+  static class SettableAsyncSecurityPolicy extends AsyncSecurityPolicy {\n+    private SettableFuture<Status> result = SettableFuture.create();\n+\n+    public void clearAuthorizationResult() {\n+      result = SettableFuture.create();\n+    }\n+\n+    public boolean setAuthorizationResult(Status status) {\n+      return result.set(status);\n+    }\n+\n+    public boolean setAuthorizationException(Throwable t) {\n+      return result.setException(t);\n+    }\n+\n+    public ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n+      return Futures.nonCancellationPropagating(result);\n+    }\n+  }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11264",
    "pr_id": 11264,
    "issue_id": 11232,
    "repo": "grpc/grpc-java",
    "problem_statement": "[xDS] NACK/ACK should be always reported even if subscribedResourceTypeUrls cannot be found \n### What version of gRPC-Java are you using?\r\n\r\ngrpc-xds 1.56.1, but the recent version (1.64.0) also suffers from this issue.\r\n\r\n### What is your environment?\r\n\r\nLinux/Kubernetes with Istio 1.16.7 installed.\r\n\r\n### What did you expect to see?\r\n\r\nIf a new CDS is pushed down to the client and all previous EDS subscription is revoked, it will remove the `subscribedResourceTypeUrls[EDS]` entry totally,\r\n\r\nhttps://github.com/grpc/grpc-java/blob/fea577c8047f7d6b489359a837cd1ff902063d14/xds/src/main/java/io/grpc/xds/client/XdsClientImpl.java#L292-L295\r\n\r\nand neither ACK/NACK will be responded to the XdsServer in the subsequent EDS response,\r\n\r\nhttps://github.com/grpc/grpc-java/blob/fea577c8047f7d6b489359a837cd1ff902063d14/xds/src/main/java/io/grpc/xds/client/ControlPlaneClient.java#L337-L345\r\n\r\nThen if we add EDS subscription again according to the new CDS, an old nonce will be used. This will lead to issues.\r\n\r\nA possible workaround is to comment the removal of `subscribedResourceTypeUrls`. Quoted from [the official docs](https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol#ack-and-nack-semantics-summary),\r\n\r\n - The xDS client should ACK or NACK every [DiscoveryResponse](https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/discovery/v3/discovery.proto#envoy-v3-api-msg-service-discovery-v3-discoveryresponse) received from the management server. The [response_nonce](https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/discovery/v3/discovery.proto#envoy-v3-api-field-service-discovery-v3-discoveryrequest-response-nonce) field tells the server which of its responses the ACK or NACK is associated with.\r\n\r\nI would like to raise a PR to resolve this issue.\r\n\r\n### What did you see instead?\r\n\r\nThe following is the log from Istiod,\r\n\r\n```\r\n// Users apply VirtualService and DestinationRule update via kubectl\r\n2024-05-24T07:06:53.925724Z\tdebug\tHandle event update for configuration networking.istio.io/v1alpha3/VirtualService/default/e2e-service-provider\r\n2024-05-24T07:06:53.934328Z\tdebug\tHandle event update for configuration networking.istio.io/v1alpha3/DestinationRule/default/e2e-service-provider\r\n2024-05-24T07:06:54.024710Z\tdebug\tHandle event update for configuration networking.istio.io/v1alpha3/DestinationRule/default/e2e-service-provider\r\n2024-05-24T07:06:54.126452Z\tinfo\tads\tPush debounce stable[17] 7 for config DestinationRule/default/e2e-service-provider and 3 more configs: 101.655214ms since last change, 235.324446ms since last push, full=true\r\n2024-05-24T07:06:54.126868Z\tdebug\tgateway\treconcile complete in 8.042µs\r\n2024-05-24T07:06:54.127123Z\tdebug\tads\tInitContext 2024-05-24T07:06:54Z/7 for push took 588.958µs\r\n2024-05-24T07:06:54.127140Z\tinfo\tads\tXDS: Pushing:2024-05-24T07:06:54Z/7 Services:6 ConnectedEndpoints:1 Version:2024-05-24T07:06:54Z/7\r\n// Istiod pushes CDS update in which all EDS will be unsubscribed\r\n2024-05-24T07:06:54.127407Z\tinfo\tads\tCDS: PUSH for node:e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default resources:0 size:0B nonce:95973a27-8c59-4e82-897c-3929efb80890 version:2024-05-24T07:06:54Z/7\r\n// Istiod pushes EDS update but neither ACK nor NACK is received\r\n2024-05-24T07:06:54.127548Z\tinfo\tads\tEDS: PUSH for node:e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default resources:2 size:395B empty:0 cached:0/2 nonce:308676e2-26dc-412d-bcb1-8958087d4138 version:2024-05-24T07:06:54Z/7\r\n2024-05-24T07:06:54.127602Z\tdebug\tgrpcgen\tbuilding lds for e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default with filter:\r\nmap[e2e-service-provider.default.svc.cluster.local:{map[e2e-service-provider.default.svc.cluster.local:{}] map[80:{}]}]\r\n2024-05-24T07:06:54.127667Z\tinfo\tads\tLDS: PUSH for node:e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default resources:1 size:450B nonce:33198869-77f9-4f1e-a7d5-b43f78e76242 version:2024-05-24T07:06:54Z/7\r\n2024-05-24T07:06:54.128177Z\tinfo\tads\tRDS: PUSH for node:e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default resources:1 size:4.8kB nonce:93bec8ee-fe97-4ca0-a242-5dbdc182a484 version:2024-05-24T07:06:54Z/7\r\n2024-05-24T07:06:54.131841Z\tdebug\tads\tADS:CDS: REQ e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default-1 resources:2 nonce:95973a27-8c59-4e82-897c-3929efb80890 version:2024-05-24T07:06:54Z/7 \r\n2024-05-24T07:06:54.131937Z\tdebug\tads\tADS:CDS: ACK e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default-1 2024-05-24T07:06:54Z/7 95973a27-8c59-4e82-897c-3929efb80890\r\n// Subscription is adjusted from the client-side\r\n2024-05-24T07:06:54.136024Z\tdebug\tads\tADS:EDS: REQ e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default-1 resources:1 nonce:94c7313f-6355-4f09-aae2-7eb2de165491 version:2024-05-24T07:06:33Z/6\r\n// But nonce is expired\r\n2024-05-24T07:06:54.136057Z\tdebug\tads\tADS:EDS: REQ e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default-1 Expired nonce received 94c7313f-6355-4f09-aae2-7eb2de165491, sent 308676e2-26dc-412d-bcb1-8958087d4138\r\n2024-05-24T07:06:54.141001Z\tdebug\tads\tADS:LDS: REQ e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default-1 resources:1 nonce:33198869-77f9-4f1e-a7d5-b43f78e76242 version:2024-05-24T07:06:54Z/7 \r\n2024-05-24T07:06:54.141036Z\tdebug\tads\tADS:LDS: ACK e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default-1 2024-05-24T07:06:54Z/7 33198869-77f9-4f1e-a7d5-b43f78e76242\r\n2024-05-24T07:06:54.143833Z\tdebug\tads\tADS:RDS: REQ e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default-1 resources:1 nonce:93bec8ee-fe97-4ca0-a242-5dbdc182a484 version:2024-05-24T07:06:54Z/7 \r\n2024-05-24T07:06:54.143903Z\tdebug\tads\tADS:RDS: ACK e2e-service-consumer-base-5dd4cb9fbf-xqc6v.default-1 2024-05-24T07:06:54Z/7 93bec8ee-fe97-4ca0-a242-5dbdc182a484\r\n```\r\n\r\n### Steps to reproduce the bug\r\n\r\nFirst, use `subset` in the VirtualService,\r\n\r\n```yaml\r\napiVersion: v1\r\nkind: Service\r\nmetadata:\r\n  name: e2e-service-provider\r\nspec:\r\n  selector:\r\n    app: e2e-service-provider\r\n    group: ft\r\n  ports:\r\n  - name: http-80\r\n    port: 80\r\n    targetPort: 8080\r\n---\r\napiVersion: networking.istio.io/v1alpha3\r\nkind: VirtualService\r\nmetadata:\r\n  name: e2e-service-provider\r\nspec:\r\n  gateways:\r\n    - istio-system/ingressgateway\r\n    - mesh\r\n  hosts:\r\n    - e2e-service-provider\r\n  http:\r\n    - match:\r\n        - headers:\r\n            application:\r\n                exact: e2e-service-consumer\r\n            x-env-flag:\r\n                exact: blue\r\n      route:\r\n        - destination:\r\n            host: e2e-service-provider\r\n            subset: e2e-service-provider-red\r\n          weight: 100\r\n    - match:\r\n        - headers:\r\n            x-env-flag:\r\n                exact: yellow\r\n          uri:\r\n            exact: /rpc/fetchTag\r\n      route:\r\n        - destination:\r\n            host: e2e-service-provider\r\n            subset: e2e-service-provider-red\r\n          weight: 100\r\n      timeout: 60s\r\n    - headers:\r\n        request:\r\n          set:\r\n            x-env-flag: red\r\n      match:\r\n        - headers:\r\n            x-env-flag:\r\n              exact: red\r\n        - queryParams:\r\n            x-env-flag:\r\n              exact: red\r\n        - sourceLabels:\r\n            version: red\r\n      route:\r\n        - destination:\r\n            host: e2e-service-provider\r\n            subset: e2e-service-provider-red\r\n      timeout: 60s\r\n    - route:\r\n        - destination:\r\n            host: e2e-service-provider\r\n            subset: e2e-service-provider-base\r\n      timeout: 60s\r\n---\r\napiVersion: networking.istio.io/v1alpha3\r\nkind: DestinationRule\r\nmetadata:\r\n  name: e2e-service-provider\r\nspec:\r\n  host: e2e-service-provider\r\n  subsets:\r\n    - labels:\r\n        version: base\r\n      name: e2e-service-provider-base\r\n      trafficPolicy:\r\n        loadBalancer:\r\n          warmupDurationSecs: 60s\r\n    - labels:\r\n        version: red\r\n      name: e2e-service-provider-red\r\n```\r\n\r\nThen apply a new yaml to totally remove subset usages,\r\n\r\n```yaml\r\n\r\n# Step1: add services \r\napiVersion: v1\r\nkind: Service\r\nmetadata:\r\n  name: e2e-service-provider\r\nspec:\r\n  selector:\r\n    app: e2e-service-provider\r\n    group: ft\r\n    version: base\r\n  ports:\r\n  - name: http-80\r\n    port: 80\r\n    targetPort: 8080\r\n---\r\napiVersion: v1\r\nkind: Service\r\nmetadata:\r\n  name: e2e-service-provider-canary\r\nspec:\r\n  selector:\r\n    app: e2e-service-provider\r\n    group: ft\r\n    version: red\r\n  ports:\r\n  - name: http-80\r\n    port: 80\r\n    targetPort: 8080\r\n---\r\napiVersion: networking.istio.io/v1alpha3\r\nkind: VirtualService\r\nmetadata:\r\n  name: e2e-service-provider\r\nspec:\r\n  gateways:\r\n    - istio-system/ingressgateway\r\n    - mesh\r\n  hosts:\r\n    - e2e-service-provider\r\n  http:\r\n    - match:\r\n        - headers:\r\n            application:\r\n                exact: e2e-service-consumer\r\n            x-env-flag:\r\n                exact: blue\r\n      route:\r\n        - destination:\r\n            host: e2e-service-provider-canary\r\n          weight: 100\r\n    - match:\r\n        - headers:\r\n            x-env-flag:\r\n                exact: yellow\r\n          uri:\r\n            exact: /rpc/fetchTag\r\n      route:\r\n        - destination:\r\n            host: e2e-service-provider-canary\r\n          weight: 100\r\n      timeout: 60s\r\n    - headers:\r\n        request:\r\n          set:\r\n            x-env-flag: red\r\n      match:\r\n        - headers:\r\n            x-env-flag:\r\n              exact: red\r\n        - queryParams:\r\n            x-env-flag:\r\n              exact: red\r\n        - sourceLabels:\r\n            version: red\r\n      route:\r\n        - destination:\r\n            host: e2e-service-provider-canary\r\n      timeout: 60s\r\n    - route:\r\n        - destination:\r\n            host: e2e-service-provider\r\n      timeout: 60s\r\n---\r\napiVersion: networking.istio.io/v1alpha3\r\nkind: DestinationRule\r\nmetadata:\r\n  name: e2e-service-provider\r\nspec:\r\n  host: e2e-service-provider\r\n  trafficPolicy:\r\n    loadBalancer:\r\n      warmupDurationSecs: 60s\r\n  subsets: []\r\n``` \r\n\r\n",
    "issue_word_count": 1331,
    "test_files_count": 2,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "xds/src/main/java/io/grpc/xds/client/ControlPlaneClient.java",
      "xds/src/main/java/io/grpc/xds/client/XdsClientImpl.java",
      "xds/src/test/java/io/grpc/xds/GrpcXdsClientImplTestBase.java",
      "xds/src/test/java/io/grpc/xds/GrpcXdsClientImplV3Test.java"
    ],
    "pr_changed_test_files": [
      "xds/src/test/java/io/grpc/xds/GrpcXdsClientImplTestBase.java",
      "xds/src/test/java/io/grpc/xds/GrpcXdsClientImplV3Test.java"
    ],
    "base_commit": "839d2770ab353116d16c214a825c6fcf2232bed1",
    "head_commit": "c2da8a0f7982b2da83a6bee88b146f7e49c3a027",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11264",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11264",
    "dockerfile": "",
    "pr_merged_at": "2024-07-30T15:46:01.000Z",
    "patch": "diff --git a/xds/src/main/java/io/grpc/xds/client/ControlPlaneClient.java b/xds/src/main/java/io/grpc/xds/client/ControlPlaneClient.java\nindex 761c10ede6a..3074d1120ad 100644\n--- a/xds/src/main/java/io/grpc/xds/client/ControlPlaneClient.java\n+++ b/xds/src/main/java/io/grpc/xds/client/ControlPlaneClient.java\n@@ -152,8 +152,14 @@ void adjustResourceSubscription(XdsResourceType<?> resourceType) {\n       startRpcStream();\n     }\n     Collection<String> resources = resourceStore.getSubscribedResources(serverInfo, resourceType);\n-    if (resources != null) {\n-      adsStream.sendDiscoveryRequest(resourceType, resources);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(resourceType, resources);\n+    if (resources.isEmpty()) {\n+      // The resource type no longer has subscribing resources; clean up references to it\n+      versions.remove(resourceType);\n+      adsStream.respNonces.remove(resourceType);\n     }\n   }\n \n\ndiff --git a/xds/src/main/java/io/grpc/xds/client/XdsClientImpl.java b/xds/src/main/java/io/grpc/xds/client/XdsClientImpl.java\nindex 969660bf7d4..79147cd9862 100644\n--- a/xds/src/main/java/io/grpc/xds/client/XdsClientImpl.java\n+++ b/xds/src/main/java/io/grpc/xds/client/XdsClientImpl.java\n@@ -281,7 +281,7 @@ public <T extends ResourceUpdate> void cancelXdsResourceWatch(XdsResourceType<T>\n       @SuppressWarnings(\"unchecked\")\n       public void run() {\n         ResourceSubscriber<T> subscriber =\n-            (ResourceSubscriber<T>) resourceSubscribers.get(type).get(resourceName);;\n+            (ResourceSubscriber<T>) resourceSubscribers.get(type).get(resourceName);\n         subscriber.removeWatcher(watcher);\n         if (!subscriber.isWatched()) {\n           subscriber.cancelResourceWatch();\n",
    "test_patch": "diff --git a/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplTestBase.java b/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplTestBase.java\nindex fd276a849ce..6b04edcb9b8 100644\n--- a/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplTestBase.java\n+++ b/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplTestBase.java\n@@ -133,6 +133,7 @@\n import org.mockito.junit.MockitoJUnit;\n import org.mockito.junit.MockitoRule;\n import org.mockito.stubbing.Answer;\n+import org.mockito.verification.VerificationMode;\n \n /**\n  * Tests for {@link XdsClientImpl}.\n@@ -2757,6 +2758,37 @@ public void edsResourceNotFound() {\n     verifySubscribedResourcesMetadataSizes(0, 0, 0, 1);\n   }\n \n+  @Test\n+  public void edsCleanupNonceAfterUnsubscription() {\n+    Assume.assumeFalse(ignoreResourceDeletion());\n+\n+    // Suppose we have an EDS subscription A.1\n+    xdsClient.watchXdsResource(XdsEndpointResource.getInstance(), \"A.1\", edsResourceWatcher);\n+    DiscoveryRpcCall call = resourceDiscoveryCalls.poll();\n+    assertThat(call).isNotNull();\n+    call.verifyRequest(EDS, \"A.1\", \"\", \"\", NODE);\n+\n+    // EDS -> {A.1}, version 1\n+    List<Message> dropOverloads = ImmutableList.of();\n+    List<Message> endpointsV1 = ImmutableList.of(lbEndpointHealthy);\n+    ImmutableMap<String, Any> resourcesV1 = ImmutableMap.of(\n+            \"A.1\", Any.pack(mf.buildClusterLoadAssignment(\"A.1\", endpointsV1, dropOverloads)));\n+    call.sendResponse(EDS, resourcesV1.values().asList(), VERSION_1, \"0000\");\n+    // {A.1} -> ACK, version 1\n+    call.verifyRequest(EDS, \"A.1\", VERSION_1, \"0000\", NODE);\n+    verify(edsResourceWatcher, times(1)).onChanged(any());\n+\n+    // trigger an EDS resource unsubscription.\n+    xdsClient.cancelXdsResourceWatch(XdsEndpointResource.getInstance(), \"A.1\", edsResourceWatcher);\n+    verifySubscribedResourcesMetadataSizes(0, 0, 0, 0);\n+    call.verifyRequest(EDS, Arrays.asList(), VERSION_1, \"0000\", NODE);\n+\n+    // When re-subscribing, the version and nonce were properly forgotten, so the request is the\n+    // same as the initial request\n+    xdsClient.watchXdsResource(XdsEndpointResource.getInstance(), \"A.1\", edsResourceWatcher);\n+    call.verifyRequest(EDS, \"A.1\", \"\", \"\", NODE, Mockito.timeout(2000).times(2));\n+  }\n+\n   @Test\n   public void edsResponseErrorHandling_allResourcesFailedUnpack() {\n     DiscoveryRpcCall call = startResourceWatcher(XdsEndpointResource.getInstance(), EDS_RESOURCE,\n@@ -3787,10 +3819,22 @@ protected abstract static class DiscoveryRpcCall {\n \n     protected void verifyRequest(\n         XdsResourceType<?> type, List<String> resources, String versionInfo, String nonce,\n-        Node node) {\n+        Node node, VerificationMode verificationMode) {\n       throw new UnsupportedOperationException();\n     }\n \n+    protected void verifyRequest(\n+        XdsResourceType<?> type, List<String> resources, String versionInfo, String nonce,\n+        Node node) {\n+      verifyRequest(type, resources, versionInfo, nonce, node, Mockito.timeout(2000));\n+    }\n+\n+    protected void verifyRequest(\n+        XdsResourceType<?> type, String resource, String versionInfo, String nonce,\n+        Node node, VerificationMode verificationMode) {\n+      verifyRequest(type, ImmutableList.of(resource), versionInfo, nonce, node, verificationMode);\n+    }\n+\n     protected void verifyRequest(\n         XdsResourceType<?> type, String resource, String versionInfo, String nonce, Node node) {\n       verifyRequest(type, ImmutableList.of(resource), versionInfo, nonce, node);\n\ndiff --git a/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplV3Test.java b/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplV3Test.java\nindex 71d0895a252..2b2ce5cbd72 100644\n--- a/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplV3Test.java\n+++ b/xds/src/test/java/io/grpc/xds/GrpcXdsClientImplV3Test.java\n@@ -118,6 +118,7 @@\n import org.mockito.ArgumentMatcher;\n import org.mockito.InOrder;\n import org.mockito.Mockito;\n+import org.mockito.verification.VerificationMode;\n \n /**\n  * Tests for {@link XdsClientImpl} with protocol version v3.\n@@ -205,8 +206,8 @@ private DiscoveryRpcCallV3(StreamObserver<DiscoveryRequest> requestObserver,\n     @Override\n     protected void verifyRequest(\n         XdsResourceType<?> type, List<String> resources, String versionInfo, String nonce,\n-        EnvoyProtoData.Node node) {\n-      verify(requestObserver, Mockito.timeout(2000)).onNext(argThat(new DiscoveryRequestMatcher(\n+        EnvoyProtoData.Node node, VerificationMode verificationMode) {\n+      verify(requestObserver, verificationMode).onNext(argThat(new DiscoveryRequestMatcher(\n           node.toEnvoyProtoNode(), versionInfo, resources, type.typeUrl(), nonce, null, null)));\n     }\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11260",
    "pr_id": 11260,
    "issue_id": 8931,
    "repo": "grpc/grpc-java",
    "problem_statement": "binder: Cross-process calls against a shutdown() Server do not fail fast as required by AbstractTransportTest\n### What version of gRPC-Java are you using?\r\nmaster\r\n\r\n### What is your environment?\r\nAndroid/Linux\r\n\r\n### Steps to reproduce the bug\r\n1) Declare an Android Service hosting an BinderServerBuilder-built Server in process A\r\n2) In a second process B, create an BinderChannelBuilder-built Channel to that Server and send a call that completes successfully. This causes the Service to be bound and a Server to be created.\r\n3) Invoke Server#shutdown() in A\r\n4) In a process other than A, create a second BinderChannelBuilder-built Channel to the Server and send a call with no deadline.\r\n\r\n### What did you expect to see?\r\nAccording to AbstractTransportTest#serverNotListening(), a ManagedClientTransport start()ed after its Server is shutdown() should report transportShutdown(UNAVAILABLE) within 5 seconds. Based on this, I expect that a new call to a shutdown()-but-otherwise-healthy Server would fail quickly.\r\n\r\n### What did you see instead?\r\nThe second call hangs forever.\r\n\r\n### Discussion\r\nThe second BinderClientTransport's call to bindService() succeeds, returning Android's cached copy of \"hostServiceBinder\" without any interaction with process A.  Because client and server are in different processes, the second BinderClientTransport's call to transact(SETUP_TRANSPORT, ... FLAG_ONEWAY) is dispatched asynchronously -- it returns true immediately but, later on the server, LeakSafeOneWayBinder#onTransact() returns without processing the transaction because it has been detach()ed by shutdown(). The second BinderClientTransport is stuck waiting for a SETUP_TRANSPORT reply that will never come.\r\n\r\nAbstractTransportTest#serverNotListening() only passes today because client and server are in the same unit test process, making the client's LeakSafeOneWayBinder#onTransact's call synchronous and giving the client immediate feedback about its failure.\r\n ",
    "issue_word_count": 281,
    "test_files_count": 2,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java",
      "binder/src/androidTest/java/io/grpc/binder/internal/LeakSafeOneWayBinderTest.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderServer.java",
      "binder/src/main/java/io/grpc/binder/internal/LeakSafeOneWayBinder.java"
    ],
    "pr_changed_test_files": [
      "binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java",
      "binder/src/androidTest/java/io/grpc/binder/internal/LeakSafeOneWayBinderTest.java"
    ],
    "base_commit": "b2731f27ad047d84c9ef06b49206dc982f0f5560",
    "head_commit": "bd5fd7f8fd67f7510ac9e39514844df9d2de9f2c",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11260",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11260",
    "dockerfile": "",
    "pr_merged_at": "2024-06-06T21:18:45.000Z",
    "patch": "diff --git a/binder/src/main/java/io/grpc/binder/internal/BinderServer.java b/binder/src/main/java/io/grpc/binder/internal/BinderServer.java\nindex 03af19c045a..260410b75de 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderServer.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderServer.java\n@@ -16,11 +16,14 @@\n \n package io.grpc.binder.internal;\n \n+import static android.os.IBinder.FLAG_ONEWAY;\n import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.binder.internal.BinderTransport.SHUTDOWN_TRANSPORT;\n \n import android.os.Binder;\n import android.os.IBinder;\n import android.os.Parcel;\n+import android.os.RemoteException;\n import com.google.common.collect.ImmutableList;\n import io.grpc.Attributes;\n import io.grpc.Grpc;\n@@ -41,6 +44,8 @@\n import java.net.SocketAddress;\n import java.util.List;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n@@ -55,6 +60,7 @@\n  */\n @ThreadSafe\n public final class BinderServer implements InternalServer, LeakSafeOneWayBinder.TransactionHandler {\n+  private static final Logger logger = Logger.getLogger(BinderServer.class.getName());\n \n   private final ObjectPool<ScheduledExecutorService> executorServicePool;\n   private final ImmutableList<ServerStreamTracer.Factory> streamTracerFactories;\n@@ -121,7 +127,7 @@ public synchronized void shutdown() {\n     if (!shutdown) {\n       shutdown = true;\n       // Break the connection to the binder. We'll receive no more transactions.\n-      hostServiceBinder.detach();\n+      hostServiceBinder.setHandler(GoAwayHandler.INSTANCE);\n       listener.serverShutdown();\n       executorService = executorServicePool.returnObject(executorService);\n       transportSecurityShutdownListener.onServerShutdown();\n@@ -136,6 +142,12 @@ public String toString() {\n   @Override\n   public synchronized boolean handleTransaction(int code, Parcel parcel) {\n     if (code == BinderTransport.SETUP_TRANSPORT) {\n+      if (shutdown) {\n+        // An incoming SETUP_TRANSPORT transaction may have already been in-flight when we removed\n+        // ourself as TransactionHandler in #shutdown(). So we must check for shutdown again here.\n+        return GoAwayHandler.INSTANCE.handleTransaction(code, parcel);\n+      }\n+\n       int version = parcel.readInt();\n       // If the client-provided version is more recent, we accept the connection,\n       // but specify the older version which we support.\n@@ -165,6 +177,28 @@ public synchronized boolean handleTransaction(int code, Parcel parcel) {\n     return false;\n   }\n \n+  static final class GoAwayHandler implements LeakSafeOneWayBinder.TransactionHandler {\n+    static final GoAwayHandler INSTANCE = new GoAwayHandler();\n+\n+    @Override\n+    public boolean handleTransaction(int code, Parcel parcel) {\n+      if (code == BinderTransport.SETUP_TRANSPORT) {\n+        int version = parcel.readInt();\n+        if (version >= BinderTransport.EARLIEST_SUPPORTED_WIRE_FORMAT_VERSION) {\n+          IBinder callbackBinder = parcel.readStrongBinder();\n+          try (ParcelHolder goAwayReply = ParcelHolder.obtain()) {\n+            // Send empty flags to avoid a memory leak linked to empty parcels (b/207778694).\n+            goAwayReply.get().writeInt(0);\n+            callbackBinder.transact(SHUTDOWN_TRANSPORT, goAwayReply.get(), null, FLAG_ONEWAY);\n+          } catch (RemoteException re) {\n+            logger.log(Level.WARNING, \"Couldn't reply to post-shutdown() SETUP_TRANSPORT.\", re);\n+          }\n+        }\n+      }\n+      return false;\n+    }\n+  }\n+\n   /** Fluent builder of {@link BinderServer} instances. */\n   public static class Builder {\n     @Nullable AndroidComponentAddress listenAddress;\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/LeakSafeOneWayBinder.java b/binder/src/main/java/io/grpc/binder/internal/LeakSafeOneWayBinder.java\nindex 4b735f9f596..516592bbce0 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/LeakSafeOneWayBinder.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/LeakSafeOneWayBinder.java\n@@ -68,7 +68,14 @@ public LeakSafeOneWayBinder(TransactionHandler handler) {\n   }\n \n   public void detach() {\n-    handler = null;\n+    setHandler(null);\n+  }\n+\n+  /**\n+   * Replaces the current {@link TransactionHandler} with `handler`.\n+   */\n+  public void setHandler(@Nullable TransactionHandler handler) {\n+    this.handler = handler;\n   }\n \n   @Override\n",
    "test_patch": "diff --git a/binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java b/binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java\nindex a78eb2887f7..e4027b70296 100644\n--- a/binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java\n+++ b/binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java\n@@ -122,11 +122,6 @@ public void socketStats() throws Exception {}\n   @Override\n   public void flowControlPushBack() throws Exception {}\n \n-  @Test\n-  @Ignore(\"Not yet implemented. See https://github.com/grpc/grpc-java/issues/8931\")\n-  @Override\n-  public void serverNotListening() throws Exception {}\n-\n   @Test\n   @Ignore(\"This test isn't appropriate for BinderTransport.\")\n   @Override\n\ndiff --git a/binder/src/androidTest/java/io/grpc/binder/internal/LeakSafeOneWayBinderTest.java b/binder/src/androidTest/java/io/grpc/binder/internal/LeakSafeOneWayBinderTest.java\nindex f7ed5ad13cb..835c73bee50 100644\n--- a/binder/src/androidTest/java/io/grpc/binder/internal/LeakSafeOneWayBinderTest.java\n+++ b/binder/src/androidTest/java/io/grpc/binder/internal/LeakSafeOneWayBinderTest.java\n@@ -21,6 +21,7 @@\n \n import android.os.Parcel;\n import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import io.grpc.binder.internal.LeakSafeOneWayBinder.TransactionHandler;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -29,28 +30,34 @@\n public final class LeakSafeOneWayBinderTest {\n \n   private LeakSafeOneWayBinder binder;\n+  private final FakeHandler handler = new FakeHandler();\n \n-  private int transactionsHandled;\n-  private int lastCode;\n-  private Parcel lastParcel;\n+  static class FakeHandler implements TransactionHandler {\n+    int transactionsHandled;\n+    int lastCode;\n+    Parcel lastParcel;\n \n-  @Before\n-  public void setUp() {\n-    binder = new LeakSafeOneWayBinder((code, parcel) -> {\n+    @Override\n+    public boolean handleTransaction(int code, Parcel parcel) {\n       transactionsHandled++;\n       lastCode = code;\n       lastParcel = parcel;\n       return true;\n-    });\n+    }\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    binder = new LeakSafeOneWayBinder(handler);\n   }\n \n   @Test\n   public void testTransaction() {\n     Parcel p = Parcel.obtain();\n     assertThat(binder.onTransact(123, p, null, FLAG_ONEWAY)).isTrue();\n-    assertThat(transactionsHandled).isEqualTo(1);\n-    assertThat(lastCode).isEqualTo(123);\n-    assertThat(lastParcel).isSameInstanceAs(p);\n+    assertThat(handler.transactionsHandled).isEqualTo(1);\n+    assertThat(handler.lastCode).isEqualTo(123);\n+    assertThat(handler.lastParcel).isSameInstanceAs(p);\n     p.recycle();\n   }\n \n@@ -59,7 +66,7 @@ public void testDropsTwoWayTransactions() {\n     Parcel p = Parcel.obtain();\n     Parcel reply = Parcel.obtain();\n     assertThat(binder.onTransact(123, p, reply, 0)).isFalse();\n-    assertThat(transactionsHandled).isEqualTo(0);\n+    assertThat(handler.transactionsHandled).isEqualTo(0);\n     p.recycle();\n     reply.recycle();\n   }\n@@ -71,7 +78,21 @@ public void testDetach() {\n     assertThat(binder.onTransact(456, p, null, FLAG_ONEWAY)).isFalse();\n \n     // The transaction shouldn't have been processed.\n-    assertThat(transactionsHandled).isEqualTo(0);\n+    assertThat(handler.transactionsHandled).isEqualTo(0);\n+\n+    p.recycle();\n+  }\n+\n+  @Test\n+  public void testReplace() {\n+    binder = new LeakSafeOneWayBinder(handler);\n+    Parcel p = Parcel.obtain();\n+    FakeHandler handler2 = new FakeHandler();\n+    binder.setHandler(handler2);\n+    assertThat(binder.onTransact(456, p, null, FLAG_ONEWAY)).isTrue();\n+\n+    assertThat(handler.transactionsHandled).isEqualTo(0);\n+    assertThat(handler2.transactionsHandled).isEqualTo(1);\n \n     p.recycle();\n   }\n@@ -81,9 +102,9 @@ public void testMultipleTransactions() {\n     Parcel p = Parcel.obtain();\n     assertThat(binder.onTransact(123, p, null, FLAG_ONEWAY)).isTrue();\n     assertThat(binder.onTransact(456, p, null, FLAG_ONEWAY)).isTrue();\n-    assertThat(transactionsHandled).isEqualTo(2);\n-    assertThat(lastCode).isEqualTo(456);\n-    assertThat(lastParcel).isSameInstanceAs(p);\n+    assertThat(handler.transactionsHandled).isEqualTo(2);\n+    assertThat(handler.lastCode).isEqualTo(456);\n+    assertThat(handler.lastParcel).isSameInstanceAs(p);\n     p.recycle();\n   }\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11255",
    "pr_id": 11255,
    "issue_id": 11137,
    "repo": "grpc/grpc-java",
    "problem_statement": "binder: BinderClientTransport should eventually give up waiting for a connection\n### Is your feature request related to a problem?\r\nYes. Android automatically restarts gRPC/binder servers that crash, with a delay [(source)](https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/services/core/java/com/android/server/am/ActiveServices.java;l=4686;drc=b32015037eda07c9119314f84fa59a095a24dcf0). This is generally a good thing -- in-flight calls fail and clients can choose to retry them. But a gRPC/binder server that repeatedly crashes on startup, before onBind() can complete (for example due to corrupt persistent state) can cause very long connection delays on the client. From ServiceBinding's perspective, this looks like a bindService() call that succeeds but no ServiceConnection callback is ever invoked. Without a report of transport failure, the Channel never moves to state `TRANSIENT_FAILURE` and the usual NameResolver/LoadBalancer machinery doesn't get a chance to try a different address. The waitForReady() call option has no real effect.\r\n\r\n### Describe the solution you'd like\r\nUse a timer to report transportShutdown()/transportTerminated() if onServiceConnected() isn't called back within some user configurable duration.\r\n\r\n### Describe alternatives you've considered\r\nDo nothing, trust Android to decide whether to ever give up, and rely on clients to set a deadline on each call.  ",
    "issue_word_count": 209,
    "test_files_count": 2,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "binder/src/androidTest/java/io/grpc/binder/internal/BinderClientTransportTest.java",
      "binder/src/androidTest/java/io/grpc/binder/internal/OneWayBinderProxies.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderClientTransportFactory.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderTransport.java"
    ],
    "pr_changed_test_files": [
      "binder/src/androidTest/java/io/grpc/binder/internal/BinderClientTransportTest.java",
      "binder/src/androidTest/java/io/grpc/binder/internal/OneWayBinderProxies.java"
    ],
    "base_commit": "0fcd8cc19f7fcde8ba8cf3d27bb91cab976a0606",
    "head_commit": "92f8b9ade82e5756192ebdacac41c0389bf7b5f6",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11255",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11255",
    "dockerfile": "",
    "pr_merged_at": "2024-06-05T22:11:30.000Z",
    "patch": "diff --git a/binder/src/main/java/io/grpc/binder/internal/BinderClientTransportFactory.java b/binder/src/main/java/io/grpc/binder/internal/BinderClientTransportFactory.java\nindex abaf07b0020..877cd2ced83 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderClientTransportFactory.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderClientTransportFactory.java\n@@ -57,6 +57,7 @@ public final class BinderClientTransportFactory implements ClientTransportFactor\n   final BindServiceFlags bindServiceFlags;\n   final InboundParcelablePolicy inboundParcelablePolicy;\n   final OneWayBinderProxy.Decorator binderDecorator;\n+  final long readyTimeoutMillis;\n \n   ScheduledExecutorService executorService;\n   Executor offloadExecutor;\n@@ -74,6 +75,7 @@ private BinderClientTransportFactory(Builder builder) {\n     bindServiceFlags = checkNotNull(builder.bindServiceFlags);\n     inboundParcelablePolicy = checkNotNull(builder.inboundParcelablePolicy);\n     binderDecorator = checkNotNull(builder.binderDecorator);\n+    readyTimeoutMillis = builder.readyTimeoutMillis;\n \n     executorService = scheduledExecutorPool.getObject();\n     offloadExecutor = offloadExecutorPool.getObject();\n@@ -129,6 +131,7 @@ public static final class Builder implements ClientTransportFactoryBuilder {\n     BindServiceFlags bindServiceFlags = BindServiceFlags.DEFAULTS;\n     InboundParcelablePolicy inboundParcelablePolicy = InboundParcelablePolicy.DEFAULT;\n     OneWayBinderProxy.Decorator binderDecorator = OneWayBinderProxy.IDENTITY_DECORATOR;\n+    long readyTimeoutMillis = -1;  // TODO(jdcormie) Set an non-infinite default in a separate PR.\n \n     @Override\n     public BinderClientTransportFactory buildClientTransportFactory() {\n@@ -191,5 +194,31 @@ public Builder setBinderDecorator(OneWayBinderProxy.Decorator binderDecorator) {\n       this.binderDecorator = checkNotNull(binderDecorator, \"binderDecorator\");\n       return this;\n     }\n+\n+    /**\n+     * Limits how long it can take to for a new transport to become ready after being started.\n+     *\n+     * <p>This process currently includes:\n+     * <ul>\n+     * <li>Creating an Android binding.\n+     * <li>Waiting for Android to create the server process.\n+     * <li>Waiting for the remote Service to be created and handle onBind().\n+     * <li>Exchanging handshake transactions according to the wire protocol.\n+     * <li>Evaluating a {@link SecurityPolicy} on both sides.\n+     * </ul>\n+     *\n+     * <p>This setting doesn't change the need for deadlines at the call level. It merely ensures\n+     * that gRPC features like\n+     * <a href=\"https://github.com/grpc/grpc/blob/master/doc/load-balancing.md\">load balancing</a>\n+     * and <a href=\"https://github.com/grpc/grpc/blob/master/doc/wait-for-ready.md\">fail-fast</a>\n+     * work as expected despite certain edge cases that could otherwise stall the transport\n+     * indefinitely.\n+     *\n+     * <p>Optional. Use a negative value to wait indefinitely.\n+     */\n+    public Builder setReadyTimeoutMillis(long readyTimeoutMillis) {\n+      this.readyTimeoutMillis = readyTimeoutMillis;\n+      return this;\n+    }\n   }\n }\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java b/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\nindex 2703e0ae952..f073648ca23 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\n@@ -19,6 +19,7 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n \n import android.content.Context;\n import android.os.Binder;\n@@ -69,6 +70,7 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.Executor;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.logging.Level;\n@@ -560,13 +562,15 @@ public static final class BinderClientTransport extends BinderTransport\n     private final Bindable serviceBinding;\n     /** Number of ongoing calls which keep this transport \"in-use\". */\n     private final AtomicInteger numInUseStreams;\n-\n+    private final long readyTimeoutMillis;\n     private final PingTracker pingTracker;\n \n     @Nullable private ManagedClientTransport.Listener clientTransportListener;\n \n     @GuardedBy(\"this\")\n     private int latestCallId = FIRST_CALL_ID;\n+    @GuardedBy(\"this\")\n+    private ScheduledFuture<?> readyTimeoutFuture; // != null iff timeout scheduled.\n \n     /**\n      * Constructs a new transport instance.\n@@ -588,6 +592,7 @@ public BinderClientTransport(\n       this.offloadExecutorPool = factory.offloadExecutorPool;\n       this.securityPolicy = factory.securityPolicy;\n       this.offloadExecutor = offloadExecutorPool.getObject();\n+      this.readyTimeoutMillis = factory.readyTimeoutMillis;\n       numInUseStreams = new AtomicInteger();\n       pingTracker = new PingTracker(Ticker.systemTicker(), (id) -> sendPing(id));\n \n@@ -627,11 +632,24 @@ public synchronized Runnable start(ManagedClientTransport.Listener clientTranspo\n           if (inState(TransportState.NOT_STARTED)) {\n             setState(TransportState.SETUP);\n             serviceBinding.bind();\n+            if (readyTimeoutMillis >= 0) {\n+              readyTimeoutFuture = getScheduledExecutorService().schedule(\n+                  BinderClientTransport.this::onReadyTimeout, readyTimeoutMillis, MILLISECONDS);\n+            }\n           }\n         }\n       };\n     }\n \n+    private synchronized void onReadyTimeout() {\n+      if (inState(TransportState.SETUP)) {\n+        readyTimeoutFuture = null;\n+        shutdownInternal(Status.DEADLINE_EXCEEDED\n+            .withDescription(\"Connect timeout \" + readyTimeoutMillis + \"ms lapsed\"),\n+            true);\n+      }\n+    }\n+\n     @Override\n     public synchronized ClientStream newStream(\n         final MethodDescriptor<?, ?> method,\n@@ -712,6 +730,10 @@ public void notifyTerminated() {\n       if (numInUseStreams.getAndSet(0) > 0) {\n         clientTransportListener.transportInUse(false);\n       }\n+      if (readyTimeoutFuture != null) {\n+        readyTimeoutFuture.cancel(false);\n+        readyTimeoutFuture = null;\n+      }\n       serviceBinding.unbind();\n       clientTransportListener.transportTerminated();\n     }\n@@ -761,6 +783,10 @@ private void checkSecurityPolicy(IBinder binder) {\n               setState(TransportState.READY);\n               attributes = clientTransportListener.filterTransport(attributes);\n               clientTransportListener.transportReady();\n+              if (readyTimeoutFuture != null) {\n+                readyTimeoutFuture.cancel(false);\n+                readyTimeoutFuture = null;\n+              }\n             }\n           }\n         }\n",
    "test_patch": "diff --git a/binder/src/androidTest/java/io/grpc/binder/internal/BinderClientTransportTest.java b/binder/src/androidTest/java/io/grpc/binder/internal/BinderClientTransportTest.java\nindex f4775c79abb..7446905194e 100644\n--- a/binder/src/androidTest/java/io/grpc/binder/internal/BinderClientTransportTest.java\n+++ b/binder/src/androidTest/java/io/grpc/binder/internal/BinderClientTransportTest.java\n@@ -22,11 +22,10 @@\n import android.os.DeadObjectException;\n import android.os.Parcel;\n import android.os.RemoteException;\n-import androidx.core.content.ContextCompat;\n import androidx.test.core.app.ApplicationProvider;\n import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import com.google.common.util.concurrent.SettableFuture;\n import com.google.protobuf.Empty;\n-import io.grpc.Attributes;\n import io.grpc.CallOptions;\n import io.grpc.ClientStreamTracer;\n import io.grpc.Metadata;\n@@ -36,13 +35,10 @@\n import io.grpc.Status;\n import io.grpc.Status.Code;\n import io.grpc.binder.AndroidComponentAddress;\n-import io.grpc.binder.BindServiceFlags;\n-import io.grpc.binder.BinderChannelCredentials;\n import io.grpc.binder.BinderServerBuilder;\n import io.grpc.binder.HostServices;\n-import io.grpc.binder.InboundParcelablePolicy;\n-import io.grpc.binder.SecurityPolicies;\n import io.grpc.binder.SecurityPolicy;\n+import io.grpc.binder.internal.OneWayBinderProxies.BlackHoleOneWayBinderProxy;\n import io.grpc.binder.internal.OneWayBinderProxies.BlockingBinderDecorator;\n import io.grpc.binder.internal.OneWayBinderProxies.ThrowingOneWayBinderProxy;\n import io.grpc.internal.ClientStream;\n@@ -59,9 +55,11 @@\n import java.util.ArrayDeque;\n import java.util.Deque;\n import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n import org.junit.After;\n@@ -77,6 +75,8 @@\n  */\n @RunWith(AndroidJUnit4.class)\n public final class BinderClientTransportTest {\n+  private static final long TIMEOUT_SECONDS = 5;\n+\n   private static final ClientStreamTracer[] tracers = new ClientStreamTracer[] {\n       new ClientStreamTracer() {}\n   };\n@@ -100,9 +100,12 @@ public final class BinderClientTransportTest {\n \n   AndroidComponentAddress serverAddress;\n   BinderTransport.BinderClientTransport transport;\n+  BlockingSecurityPolicy blockingSecurityPolicy = new BlockingSecurityPolicy();\n \n   private final ObjectPool<ScheduledExecutorService> executorServicePool =\n       new FixedObjectPool<>(Executors.newScheduledThreadPool(1));\n+  private final ObjectPool<ScheduledExecutorService> offloadServicePool =\n+      new FixedObjectPool<>(Executors.newScheduledThreadPool(1));\n   private final TestTransportListener transportListener = new TestTransportListener();\n   private final TestStreamListener streamListener = new TestStreamListener();\n \n@@ -146,7 +149,7 @@ private class BinderClientTransportBuilder {\n     final BinderClientTransportFactory.Builder factoryBuilder = new BinderClientTransportFactory.Builder()\n         .setSourceContext(appContext)\n         .setScheduledExecutorPool(executorServicePool)\n-        .setOffloadExecutorPool(executorServicePool);\n+        .setOffloadExecutorPool(offloadServicePool);\n \n     public BinderClientTransportBuilder setSecurityPolicy(SecurityPolicy securityPolicy) {\n       factoryBuilder.setSecurityPolicy(securityPolicy);\n@@ -159,6 +162,11 @@ public BinderClientTransportBuilder setBinderDecorator(\n       return this;\n     }\n \n+    public BinderClientTransportBuilder setReadyTimeoutMillis(int timeoutMillis) {\n+      factoryBuilder.setReadyTimeoutMillis(timeoutMillis);\n+      return this;\n+    }\n+\n     public BinderTransport.BinderClientTransport build() {\n       return factoryBuilder.buildClientTransportFactory()\n           .newClientTransport(serverAddress, new ClientTransportOptions(), null);\n@@ -167,9 +175,19 @@ public BinderTransport.BinderClientTransport build() {\n \n   @After\n   public void tearDown() throws Exception {\n+    blockingSecurityPolicy.provideNextCheckAuthorizationResult(Status.ABORTED);\n     transport.shutdownNow(Status.OK);\n     HostServices.awaitServiceShutdown();\n-    executorServicePool.getObject().shutdownNow();\n+    shutdownAndTerminate(executorServicePool.getObject());\n+    shutdownAndTerminate(offloadServicePool.getObject());\n+  }\n+\n+  private static void shutdownAndTerminate(ExecutorService executorService)\n+      throws InterruptedException {\n+    executorService.shutdownNow();\n+    if (!executorService.awaitTermination(TIMEOUT_SECONDS, TimeUnit.SECONDS)) {\n+      throw new AssertionError(\"executor failed to terminate promptly\");\n+    }\n   }\n \n   @Test\n@@ -261,10 +279,9 @@ public void testMessageProducerClosedAfterStream_b169313545() throws Exception {\n   }\n \n   @Test\n-  public void testNewStreamBeforeTransportReadyFails() throws InterruptedException {\n+  public void testNewStreamBeforeTransportReadyFails() throws Exception {\n     // Use a special SecurityPolicy that lets us act before the transport is setup/ready.\n-    BlockingSecurityPolicy bsp = new BlockingSecurityPolicy();\n-    transport = new BinderClientTransportBuilder().setSecurityPolicy(bsp).build();\n+    transport = new BinderClientTransportBuilder().setSecurityPolicy(blockingSecurityPolicy).build();\n     transport.start(transportListener).run();\n     ClientStream stream =\n         transport.newStream(streamingMethodDesc, new Metadata(), CallOptions.DEFAULT, tracers);\n@@ -272,12 +289,12 @@ public void testNewStreamBeforeTransportReadyFails() throws InterruptedException\n     assertThat(streamListener.awaitClose().getCode()).isEqualTo(Code.INTERNAL);\n \n     // Unblock the SETUP_TRANSPORT handshake and make sure it becomes ready in the usual way.\n-    bsp.provideNextCheckAuthorizationResult(Status.OK);\n+    blockingSecurityPolicy.provideNextCheckAuthorizationResult(Status.OK);\n     transportListener.awaitReady();\n   }\n \n   @Test\n-  public void testTxnFailureDuringSetup() throws InterruptedException {\n+  public void testTxnFailureDuringSetup() throws Exception {\n     BlockingBinderDecorator<ThrowingOneWayBinderProxy> decorator = new BlockingBinderDecorator<>();\n     transport = new BinderClientTransportBuilder()\n         .setBinderDecorator(decorator)\n@@ -304,7 +321,7 @@ public void testTxnFailureDuringSetup() throws InterruptedException {\n   }\n \n   @Test\n-  public void testTxnFailurePostSetup() throws InterruptedException {\n+  public void testTxnFailurePostSetup() throws Exception {\n     BlockingBinderDecorator<ThrowingOneWayBinderProxy> decorator = new BlockingBinderDecorator<>();\n     transport = new BinderClientTransportBuilder()\n         .setBinderDecorator(decorator)\n@@ -332,59 +349,82 @@ public void testTxnFailurePostSetup() throws InterruptedException {\n     assertThat(streamStatus.getCause()).isSameInstanceAs(doe);\n   }\n \n+  @Test\n+  public void testBlackHoleEndpointConnectTimeout() throws Exception {\n+    BlockingBinderDecorator<BlackHoleOneWayBinderProxy> decorator = new BlockingBinderDecorator<>();\n+    transport = new BinderClientTransportBuilder()\n+        .setBinderDecorator(decorator)\n+        .setReadyTimeoutMillis(1_234)\n+        .build();\n+    transport.start(transportListener).run();\n+    BlackHoleOneWayBinderProxy endpointBinder = new BlackHoleOneWayBinderProxy(\n+        decorator.takeNextRequest());\n+    endpointBinder.dropAllTransactions(true);\n+    decorator.putNextResult(endpointBinder);\n+    Status transportStatus = transportListener.awaitShutdown();\n+    assertThat(transportStatus.getCode()).isEqualTo(Code.DEADLINE_EXCEEDED);\n+    assertThat(transportStatus.getDescription()).contains(\"1234\");\n+    transportListener.awaitTermination();\n+  }\n+\n+  @Test\n+  public void testBlackHoleSecurityPolicyConnectTimeout() throws Exception {\n+    transport = new BinderClientTransportBuilder()\n+        .setSecurityPolicy(blockingSecurityPolicy)\n+        .setReadyTimeoutMillis(1_234)\n+        .build();\n+    transport.start(transportListener).run();\n+    Status transportStatus = transportListener.awaitShutdown();\n+    assertThat(transportStatus.getCode()).isEqualTo(Code.DEADLINE_EXCEEDED);\n+    assertThat(transportStatus.getDescription()).contains(\"1234\");\n+    transportListener.awaitTermination();\n+    blockingSecurityPolicy.provideNextCheckAuthorizationResult(Status.OK);\n+  }\n+\n   private static void startAndAwaitReady(\n-      BinderTransport.BinderClientTransport transport, TestTransportListener transportListener) {\n+      BinderTransport.BinderClientTransport transport, TestTransportListener transportListener)\n+      throws Exception {\n     transport.start(transportListener).run();\n     transportListener.awaitReady();\n   }\n \n   private static final class TestTransportListener implements ManagedClientTransport.Listener {\n-    @GuardedBy(\"this\")\n-    private boolean ready;\n-\n     public boolean inUse;\n-    @Nullable public Status shutdownStatus;\n-    public boolean terminated;\n+    private final SettableFuture<Boolean> isReady = SettableFuture.create();\n+    private final SettableFuture<Status> shutdownStatus = SettableFuture.create();\n+    private final SettableFuture<Boolean> isTerminated = SettableFuture.create();\n \n     @Override\n-    public synchronized void transportShutdown(Status shutdownStatus) {\n-      this.shutdownStatus = shutdownStatus;\n-      notifyAll();\n+    public void transportShutdown(Status shutdownStatus) {\n+      if (!this.shutdownStatus.set(shutdownStatus)) {\n+        throw new IllegalStateException(\"transportShutdown() already called\");\n+      }\n     }\n \n-    public synchronized Status awaitShutdown() throws InterruptedException {\n-      while (shutdownStatus == null) {\n-        wait();\n-      }\n-      return shutdownStatus;\n+    public Status awaitShutdown() throws Exception {\n+      return shutdownStatus.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n     }\n \n     @Override\n-    public synchronized void transportTerminated() {\n-      terminated = true;\n-      notifyAll();\n+    public void transportTerminated() {\n+      if (!isTerminated.set(true)) {\n+        throw new IllegalStateException(\"isTerminated() already called\");\n+      }\n     }\n \n-    public synchronized void awaitTermination() throws InterruptedException {\n-      while (!terminated) {\n-        wait();\n-      }\n+    public void awaitTermination() throws Exception {\n+      isTerminated.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n     }\n \n     @Override\n-    public synchronized void transportReady() {\n-      ready = true;\n-      notifyAll();\n+    public void transportReady() {\n+      if (!isReady.set(true)) {\n+        throw new IllegalStateException(\"isTerminated() already called\");\n+      }\n     }\n \n-    public synchronized void awaitReady() {\n-      while (!ready) {\n-        try {\n-          wait();\n-        } catch (InterruptedException inte) {\n-          throw new AssertionError(\"Interrupted waiting for ready\");\n-        }\n-      }\n+    public void awaitReady() throws Exception {\n+      isReady.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n     }\n \n     @Override\n\ndiff --git a/binder/src/androidTest/java/io/grpc/binder/internal/OneWayBinderProxies.java b/binder/src/androidTest/java/io/grpc/binder/internal/OneWayBinderProxies.java\nindex 229c9426125..963bdcab9d3 100644\n--- a/binder/src/androidTest/java/io/grpc/binder/internal/OneWayBinderProxies.java\n+++ b/binder/src/androidTest/java/io/grpc/binder/internal/OneWayBinderProxies.java\n@@ -95,6 +95,37 @@ public void transact(int code, ParcelHolder data) throws RemoteException {\n     }\n   }\n \n+  /**\n+   * A {@link OneWayBinderProxy} decorator whose transact method can be configured to silently drop.\n+   */\n+  public static final class BlackHoleOneWayBinderProxy extends OneWayBinderProxy {\n+\n+    private final OneWayBinderProxy wrapped;\n+    private boolean dropAllTransactions;\n+\n+    BlackHoleOneWayBinderProxy(OneWayBinderProxy wrapped) {\n+      super(wrapped.getDelegate());\n+      this.wrapped = wrapped;\n+    }\n+\n+    /**\n+     * Causes all future invocations of transact to be silently dropped.\n+     *\n+     * <p>Users are responsible for ensuring their calls \"happen-before\" the relevant calls to\n+     * {@link #transact(int, ParcelHolder)}.\n+     */\n+    public void dropAllTransactions(boolean dropAllTransactions) {\n+      this.dropAllTransactions = dropAllTransactions;\n+    }\n+\n+    @Override\n+    public void transact(int code, ParcelHolder data) throws RemoteException {\n+      if (!dropAllTransactions) {\n+        wrapped.transact(code, data);\n+      }\n+    }\n+  }\n+\n   // Cannot be instantiated.\n   private OneWayBinderProxies() {};\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11240",
    "pr_id": 11240,
    "issue_id": 10897,
    "repo": "grpc/grpc-java",
    "problem_statement": "binder: ServerAuthInterceptor might use an Executor that BinderServer has already returned to the pool\nThis is a follow-up to #10566.\r\n\r\n*(note: I'm describing the issue as I recollect it; Chat ate the discussion thread. @markb74 please correct me if I'm wrong)*\r\n\r\n#10633 introduced the `PendingAuthListener` class and the logic to handle `AsyncSecurityPolicy` without blocking any threads. This required an `Executor` to be passed to `BinderTransportSecurity` [here](https://github.com/mateusazis/grpc-java/blob/6f6cde9b1372c480bd730c470e615ec73a0b82da/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java#L184). In the same PR, we added a shutdown listener to return that executor to the object pool during server shutdown ([here](https://github.com/mateusazis/grpc-java/blob/6f6cde9b1372c480bd730c470e615ec73a0b82da/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java#L185)).\r\n\r\n@markb74 commented that this was sub-optimal, and we could instead return the executor during termination. One suggestion was to pass an `Executor` to `BinderServer.start` and reuse it throught that server's lifetime. I prototyped it in https://github.com/mateusazis/grpc-java/commit/3f262ca61dab1bbdcca1e664331727803e03e7b3, but ended up with a chicken-and-egg issue in `BinderServerBuilder.build`:\r\n\r\n- `BinderTransportSecurity.installAuthInterceptor` wants an Executor, but it will only be available on `BinderServer` after it is instantiated and started\r\n- `BinderServer` is only instantiated after the authorization interceptor gets installed\r\n\r\nAny help here is welcome!",
    "issue_word_count": 218,
    "test_files_count": 1,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "binder/src/main/java/io/grpc/binder/BinderServerBuilder.java",
      "binder/src/main/java/io/grpc/binder/internal/ActiveTransportTracker.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderServer.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java",
      "binder/src/test/java/io/grpc/binder/internal/ActiveTransportTrackerTest.java"
    ],
    "pr_changed_test_files": [
      "binder/src/test/java/io/grpc/binder/internal/ActiveTransportTrackerTest.java"
    ],
    "base_commit": "df8cfe9ddc541b9548ff3a62c6d1e802c5251b14",
    "head_commit": "d7e9c0c64b2d1446eb51c71d04d1d4a7bde92101",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11240",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11240",
    "dockerfile": "",
    "pr_merged_at": "2024-06-06T21:52:12.000Z",
    "patch": "diff --git a/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java b/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java\nindex af5f9eed75a..52122c5e8b7 100644\n--- a/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java\n+++ b/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java\n@@ -166,7 +166,7 @@ public Server build() {\n     ObjectPool<? extends Executor> executorPool = serverImplBuilder.getExecutorPool();\n     Executor executor = executorPool.getObject();\n     BinderTransportSecurity.installAuthInterceptor(this, executor);\n-    internalBuilder.setShutdownListener(() -> executorPool.returnObject(executor));\n+    internalBuilder.setTerminationListener(() -> executorPool.returnObject(executor));\n     return super.build();\n   }\n }\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/ActiveTransportTracker.java b/binder/src/main/java/io/grpc/binder/internal/ActiveTransportTracker.java\nnew file mode 100644\nindex 00000000000..ad410186486\n--- /dev/null\n+++ b/binder/src/main/java/io/grpc/binder/internal/ActiveTransportTracker.java\n@@ -0,0 +1,110 @@\n+package io.grpc.binder.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import io.grpc.Attributes;\n+import io.grpc.Metadata;\n+import io.grpc.internal.ServerListener;\n+import io.grpc.internal.ServerStream;\n+import io.grpc.internal.ServerTransport;\n+import io.grpc.internal.ServerTransportListener;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * Tracks which {@link BinderTransport.BinderServerTransport} are currently active and allows\n+ * invoking a {@link Runnable} only once all transports are terminated.\n+ */\n+final class ActiveTransportTracker implements ServerListener {\n+  private final ServerListener delegate;\n+  private final Runnable terminationListener;\n+\n+  @GuardedBy(\"this\")\n+  private boolean shutdown = false;\n+\n+  @GuardedBy(\"this\")\n+  private int activeTransportCount = 0;\n+\n+  /**\n+   * @param delegate the original server listener that this object decorates. Usually passed to\n+   *     {@link BinderServer#start(ServerListener)}.\n+   * @param terminationListener invoked only once the server has started shutdown ({@link\n+   *     #serverShutdown()} AND the last active transport is terminated.\n+   */\n+  ActiveTransportTracker(ServerListener delegate, Runnable terminationListener) {\n+    this.delegate = delegate;\n+    this.terminationListener = terminationListener;\n+  }\n+\n+  @Override\n+  public ServerTransportListener transportCreated(ServerTransport transport) {\n+    synchronized (this) {\n+      checkState(!shutdown, \"Illegal transportCreated() after serverShutdown()\");\n+      activeTransportCount++;\n+    }\n+    ServerTransportListener originalListener = delegate.transportCreated(transport);\n+    return new TrackedTransportListener(originalListener);\n+  }\n+\n+  private void untrack() {\n+    Runnable maybeTerminationListener;\n+    synchronized (this) {\n+      activeTransportCount--;\n+      maybeTerminationListener = getListenerIfTerminated();\n+    }\n+    // Prefer running the listener outside of the synchronization lock to release it sooner, since\n+    // we don't know how the callback is implemented nor how long it will take. This should\n+    // minimize the possibility of deadlocks.\n+    if (maybeTerminationListener != null) {\n+      maybeTerminationListener.run();\n+    }\n+  }\n+\n+  @Override\n+  public void serverShutdown() {\n+    delegate.serverShutdown();\n+    Runnable maybeTerminationListener;\n+    synchronized (this) {\n+      shutdown = true;\n+      maybeTerminationListener = getListenerIfTerminated();\n+    }\n+    // We may be able to shutdown immediately if there are no active transports.\n+    //\n+    // Executed outside of the lock. See \"untrack()\" above.\n+    if (maybeTerminationListener != null) {\n+      maybeTerminationListener.run();\n+    }\n+  }\n+\n+  @GuardedBy(\"this\")\n+  private Runnable getListenerIfTerminated() {\n+    return (shutdown && activeTransportCount == 0) ? terminationListener : null;\n+  }\n+\n+  /**\n+   * Wraps a {@link ServerTransportListener}, unregistering it from the parent tracker once the\n+   * transport terminates.\n+   */\n+  private final class TrackedTransportListener implements ServerTransportListener {\n+    private final ServerTransportListener delegate;\n+\n+    TrackedTransportListener(ServerTransportListener delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public void streamCreated(ServerStream stream, String method, Metadata headers) {\n+      delegate.streamCreated(stream, method, headers);\n+    }\n+\n+    @Override\n+    public Attributes transportReady(Attributes attributes) {\n+      return delegate.transportReady(attributes);\n+    }\n+\n+    @Override\n+    public void transportTerminated() {\n+      delegate.transportTerminated();\n+      untrack();\n+    }\n+  }\n+}\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/BinderServer.java b/binder/src/main/java/io/grpc/binder/internal/BinderServer.java\nindex 03af19c045a..53add2c6b39 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderServer.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderServer.java\n@@ -62,7 +62,7 @@ public final class BinderServer implements InternalServer, LeakSafeOneWayBinder.\n   private final LeakSafeOneWayBinder hostServiceBinder;\n   private final BinderTransportSecurity.ServerPolicyChecker serverPolicyChecker;\n   private final InboundParcelablePolicy inboundParcelablePolicy;\n-  private final BinderTransportSecurity.ShutdownListener transportSecurityShutdownListener;\n+  private final Runnable terminationListener;\n \n   @GuardedBy(\"this\")\n   private ServerListener listener;\n@@ -80,7 +80,7 @@ private BinderServer(Builder builder) {\n         ImmutableList.copyOf(checkNotNull(builder.streamTracerFactories, \"streamTracerFactories\"));\n     this.serverPolicyChecker = BinderInternal.createPolicyChecker(builder.serverSecurityPolicy);\n     this.inboundParcelablePolicy = builder.inboundParcelablePolicy;\n-    this.transportSecurityShutdownListener = builder.shutdownListener;\n+    this.terminationListener = builder.terminationListener;\n     hostServiceBinder = new LeakSafeOneWayBinder(this);\n   }\n \n@@ -91,7 +91,7 @@ public IBinder getHostBinder() {\n \n   @Override\n   public synchronized void start(ServerListener serverListener) throws IOException {\n-    this.listener = serverListener;\n+    listener = new ActiveTransportTracker(serverListener, terminationListener);\n     executorService = executorServicePool.getObject();\n   }\n \n@@ -124,7 +124,6 @@ public synchronized void shutdown() {\n       hostServiceBinder.detach();\n       listener.serverShutdown();\n       executorService = executorServicePool.returnObject(executorService);\n-      transportSecurityShutdownListener.onServerShutdown();\n     }\n   }\n \n@@ -174,7 +173,7 @@ public static class Builder {\n         SharedResourcePool.forResource(GrpcUtil.TIMER_SERVICE);\n     ServerSecurityPolicy serverSecurityPolicy = SecurityPolicies.serverInternalOnly();\n     InboundParcelablePolicy inboundParcelablePolicy = InboundParcelablePolicy.DEFAULT;\n-    BinderTransportSecurity.ShutdownListener shutdownListener = () -> {};\n+    Runnable terminationListener = () -> {};\n \n     public BinderServer build() {\n       return new BinderServer(this);\n@@ -235,12 +234,13 @@ public Builder setInboundParcelablePolicy(InboundParcelablePolicy inboundParcela\n     }\n \n     /**\n-     * Installs a callback that will be invoked when this server is {@link #shutdown()}\n+     * Installs a callback that will be invoked when this server is {@link #shutdown()} and all of\n+     * its transports are terminated.\n      *\n      * <p>Optional.\n      */\n-    public Builder setShutdownListener(BinderTransportSecurity.ShutdownListener shutdownListener) {\n-      this.shutdownListener = checkNotNull(shutdownListener, \"shutdownListener\");\n+    public Builder setTerminationListener(Runnable terminationListener) {\n+      this.terminationListener = checkNotNull(terminationListener, \"terminationListener\");\n       return this;\n     }\n   }\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java b/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\nindex 56464d58a4b..72a02c92ff6 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\n@@ -238,12 +238,4 @@ public interface ServerPolicyChecker {\n      */\n     ListenableFuture<Status> checkAuthorizationForServiceAsync(int uid, String serviceName);\n   }\n-\n-  /**\n-   * A listener invoked when the {@link io.grpc.binder.internal.BinderServer} shuts down, allowing\n-   * resources to be potentially cleaned up.\n-   */\n-  public interface ShutdownListener {\n-    void onServerShutdown();\n-  }\n }\n",
    "test_patch": "diff --git a/binder/src/test/java/io/grpc/binder/internal/ActiveTransportTrackerTest.java b/binder/src/test/java/io/grpc/binder/internal/ActiveTransportTrackerTest.java\nnew file mode 100644\nindex 00000000000..099756075f1\n--- /dev/null\n+++ b/binder/src/test/java/io/grpc/binder/internal/ActiveTransportTrackerTest.java\n@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2024 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.binder.internal;\n+\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.internal.ServerListener;\n+import io.grpc.internal.ServerTransport;\n+import io.grpc.internal.ServerTransportListener;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.robolectric.RobolectricTestRunner;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public final class ActiveTransportTrackerTest {\n+  @Rule public final MockitoRule mocks = MockitoJUnit.rule();\n+\n+  private ActiveTransportTracker tracker;\n+\n+  @Mock Runnable mockShutdownListener;\n+  @Mock ServerListener mockServerListener;\n+  @Mock ServerTransportListener mockServerTransportListener;\n+  @Mock ServerTransport mockServerTransport;\n+\n+  @Before\n+  public void setUp() {\n+    when(mockServerListener.transportCreated(any())).thenReturn(mockServerTransportListener);\n+    tracker = new ActiveTransportTracker(mockServerListener, mockShutdownListener);\n+  }\n+\n+  @Test\n+  public void testServerShutdown_onlyNotifiesAfterAllTransportAreTerminated() {\n+    ServerTransportListener wrapperListener1 = registerNewTransport();\n+    ServerTransportListener wrapperListener2 = registerNewTransport();\n+\n+    tracker.serverShutdown();\n+    // 2 active transports, notification scheduled\n+    verifyNoInteractions(mockShutdownListener);\n+\n+    wrapperListener1.transportTerminated();\n+    // 1 active transport remaining, notification still pending\n+    verifyNoInteractions(mockShutdownListener);\n+\n+    wrapperListener2.transportTerminated();\n+    // No more active transports, shutdown notified\n+    verify(mockShutdownListener).run();\n+  }\n+\n+  @Test\n+  public void testServerShutdown_noActiveTransport_notifiesTerminationImmediately() {\n+    verifyNoInteractions(mockShutdownListener);\n+\n+    tracker.serverShutdown();\n+\n+    verify(mockShutdownListener).run();\n+  }\n+\n+  @Test\n+  public void testLastTransportTerminated_serverNotShutdownYet_doesNotNotify() {\n+    ServerTransportListener wrapperListener = registerNewTransport();\n+    verifyNoInteractions(mockShutdownListener);\n+\n+    wrapperListener.transportTerminated();\n+\n+    verifyNoInteractions(mockShutdownListener);\n+  }\n+\n+  @Test\n+  public void testTransportCreation_afterServerShutdown_throws() {\n+    tracker.serverShutdown();\n+\n+    assertThrows(IllegalStateException.class, this::registerNewTransport);\n+  }\n+\n+  @Test\n+  public void testServerListenerCallbacks_invokesDelegates() {\n+    ServerTransportListener listener = tracker.transportCreated(mockServerTransport);\n+    verify(mockServerListener).transportCreated(mockServerTransport);\n+\n+    listener.transportTerminated();\n+    verify(mockServerTransportListener).transportTerminated();\n+\n+    tracker.serverShutdown();\n+    verify(mockServerListener).serverShutdown();\n+  }\n+\n+  private ServerTransportListener registerNewTransport() {\n+    return tracker.transportCreated(mockServerTransport);\n+  }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11237",
    "pr_id": 11237,
    "issue_id": 6724,
    "repo": "grpc/grpc-java",
    "problem_statement": "update reflection.proto from v1alpha to v1\n### What version of gRPC-Java are you using?\r\n1.27.1\r\n\r\n### What is your environment?\r\nSBT\r\n\r\n### What did you expect to see?\r\ngrpc-services contains deprecated `v1alpha/reflection.proto` which instructs to use `v1/reflection.proto`, however the file is not shipped with this jar. It is unclear if there's a maven artifact that contains it that should be used instead.\r\n\r\n\r\n",
    "issue_word_count": 69,
    "test_files_count": 3,
    "non_test_files_count": 5,
    "pr_changed_files": [
      "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java",
      "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestServer.java",
      "services/BUILD.bazel",
      "services/src/generated/main/grpc/io/grpc/reflection/v1/ServerReflectionGrpc.java",
      "services/src/main/java/io/grpc/protobuf/services/ProtoReflectionService.java",
      "services/src/main/java/io/grpc/protobuf/services/ProtoReflectionServiceV1.java",
      "services/src/main/proto/grpc/reflection/v1/reflection.proto",
      "services/src/test/java/io/grpc/protobuf/services/ProtoReflectionServiceV1Test.java"
    ],
    "pr_changed_test_files": [
      "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java",
      "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestServer.java",
      "services/src/test/java/io/grpc/protobuf/services/ProtoReflectionServiceV1Test.java"
    ],
    "base_commit": "75fa441fc9e902e7d0ec6efa5ca52a791c17feea",
    "head_commit": "95bba586de778d6c2db60456d1b0c56e160e116e",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11237",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11237",
    "dockerfile": "",
    "pr_merged_at": "2024-07-19T13:57:14.000Z",
    "patch": "diff --git a/services/BUILD.bazel b/services/BUILD.bazel\nindex fa708dd04b2..a31e49ceb4c 100644\n--- a/services/BUILD.bazel\n+++ b/services/BUILD.bazel\n@@ -84,9 +84,11 @@ java_library(\n     name = \"reflection\",\n     srcs = [\n         \"src/main/java/io/grpc/protobuf/services/ProtoReflectionService.java\",\n+        \"src/main/java/io/grpc/protobuf/services/ProtoReflectionServiceV1.java\",\n     ],\n     deps = [\n         \":_reflection_java_grpc\",\n+        \":_reflection_v1_java_grpc\",\n         \"//api\",\n         \"//protobuf\",\n         \"//stub\",\n@@ -94,6 +96,7 @@ java_library(\n         \"@com_google_guava_guava//jar\",\n         \"@com_google_protobuf//:protobuf_java\",\n         \"@com_google_protobuf//:protobuf_java_util\",\n+        \"@io_grpc_grpc_proto//:reflection_java_proto\",\n         \"@io_grpc_grpc_proto//:reflection_java_proto_deprecated\",\n     ],\n )\n@@ -147,6 +150,13 @@ java_grpc_library(\n     deps = [\"@io_grpc_grpc_proto//:reflection_java_proto_deprecated\"],\n )\n \n+java_grpc_library(\n+    name = \"_reflection_v1_java_grpc\",\n+    srcs = [\"@io_grpc_grpc_proto//:reflection_proto\"],\n+    visibility = [\"//visibility:private\"],\n+    deps = [\"@io_grpc_grpc_proto//:reflection_java_proto\"],\n+)\n+\n java_grpc_library(\n     name = \"_channelz_java_grpc\",\n     srcs = [\"@io_grpc_grpc_proto//:channelz_proto\"],\n\ndiff --git a/services/src/generated/main/grpc/io/grpc/reflection/v1/ServerReflectionGrpc.java b/services/src/generated/main/grpc/io/grpc/reflection/v1/ServerReflectionGrpc.java\nnew file mode 100644\nindex 00000000000..4f2dce26486\n--- /dev/null\n+++ b/services/src/generated/main/grpc/io/grpc/reflection/v1/ServerReflectionGrpc.java\n@@ -0,0 +1,285 @@\n+package io.grpc.reflection.v1;\n+\n+import static io.grpc.MethodDescriptor.generateFullMethodName;\n+\n+/**\n+ */\n+@javax.annotation.Generated(\n+    value = \"by gRPC proto compiler\",\n+    comments = \"Source: grpc/reflection/v1/reflection.proto\")\n+@io.grpc.stub.annotations.GrpcGenerated\n+public final class ServerReflectionGrpc {\n+\n+  private ServerReflectionGrpc() {}\n+\n+  public static final java.lang.String SERVICE_NAME = \"grpc.reflection.v1.ServerReflection\";\n+\n+  // Static method descriptors that strictly reflect the proto.\n+  private static volatile io.grpc.MethodDescriptor<io.grpc.reflection.v1.ServerReflectionRequest,\n+      io.grpc.reflection.v1.ServerReflectionResponse> getServerReflectionInfoMethod;\n+\n+  @io.grpc.stub.annotations.RpcMethod(\n+      fullMethodName = SERVICE_NAME + '/' + \"ServerReflectionInfo\",\n+      requestType = io.grpc.reflection.v1.ServerReflectionRequest.class,\n+      responseType = io.grpc.reflection.v1.ServerReflectionResponse.class,\n+      methodType = io.grpc.MethodDescriptor.MethodType.BIDI_STREAMING)\n+  public static io.grpc.MethodDescriptor<io.grpc.reflection.v1.ServerReflectionRequest,\n+      io.grpc.reflection.v1.ServerReflectionResponse> getServerReflectionInfoMethod() {\n+    io.grpc.MethodDescriptor<io.grpc.reflection.v1.ServerReflectionRequest, io.grpc.reflection.v1.ServerReflectionResponse> getServerReflectionInfoMethod;\n+    if ((getServerReflectionInfoMethod = ServerReflectionGrpc.getServerReflectionInfoMethod) == null) {\n+      synchronized (ServerReflectionGrpc.class) {\n+        if ((getServerReflectionInfoMethod = ServerReflectionGrpc.getServerReflectionInfoMethod) == null) {\n+          ServerReflectionGrpc.getServerReflectionInfoMethod = getServerReflectionInfoMethod =\n+              io.grpc.MethodDescriptor.<io.grpc.reflection.v1.ServerReflectionRequest, io.grpc.reflection.v1.ServerReflectionResponse>newBuilder()\n+              .setType(io.grpc.MethodDescriptor.MethodType.BIDI_STREAMING)\n+              .setFullMethodName(generateFullMethodName(SERVICE_NAME, \"ServerReflectionInfo\"))\n+              .setSampledToLocalTracing(true)\n+              .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n+                  io.grpc.reflection.v1.ServerReflectionRequest.getDefaultInstance()))\n+              .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(\n+                  io.grpc.reflection.v1.ServerReflectionResponse.getDefaultInstance()))\n+              .setSchemaDescriptor(new ServerReflectionMethodDescriptorSupplier(\"ServerReflectionInfo\"))\n+              .build();\n+        }\n+      }\n+    }\n+    return getServerReflectionInfoMethod;\n+  }\n+\n+  /**\n+   * Creates a new async stub that supports all call types for the service\n+   */\n+  public static ServerReflectionStub newStub(io.grpc.Channel channel) {\n+    io.grpc.stub.AbstractStub.StubFactory<ServerReflectionStub> factory =\n+      new io.grpc.stub.AbstractStub.StubFactory<ServerReflectionStub>() {\n+        @java.lang.Override\n+        public ServerReflectionStub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n+          return new ServerReflectionStub(channel, callOptions);\n+        }\n+      };\n+    return ServerReflectionStub.newStub(factory, channel);\n+  }\n+\n+  /**\n+   * Creates a new blocking-style stub that supports unary and streaming output calls on the service\n+   */\n+  public static ServerReflectionBlockingStub newBlockingStub(\n+      io.grpc.Channel channel) {\n+    io.grpc.stub.AbstractStub.StubFactory<ServerReflectionBlockingStub> factory =\n+      new io.grpc.stub.AbstractStub.StubFactory<ServerReflectionBlockingStub>() {\n+        @java.lang.Override\n+        public ServerReflectionBlockingStub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n+          return new ServerReflectionBlockingStub(channel, callOptions);\n+        }\n+      };\n+    return ServerReflectionBlockingStub.newStub(factory, channel);\n+  }\n+\n+  /**\n+   * Creates a new ListenableFuture-style stub that supports unary calls on the service\n+   */\n+  public static ServerReflectionFutureStub newFutureStub(\n+      io.grpc.Channel channel) {\n+    io.grpc.stub.AbstractStub.StubFactory<ServerReflectionFutureStub> factory =\n+      new io.grpc.stub.AbstractStub.StubFactory<ServerReflectionFutureStub>() {\n+        @java.lang.Override\n+        public ServerReflectionFutureStub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n+          return new ServerReflectionFutureStub(channel, callOptions);\n+        }\n+      };\n+    return ServerReflectionFutureStub.newStub(factory, channel);\n+  }\n+\n+  /**\n+   */\n+  public interface AsyncService {\n+\n+    /**\n+     * <pre>\n+     * The reflection service is structured as a bidirectional stream, ensuring\n+     * all related requests go to a single server.\n+     * </pre>\n+     */\n+    default io.grpc.stub.StreamObserver<io.grpc.reflection.v1.ServerReflectionRequest> serverReflectionInfo(\n+        io.grpc.stub.StreamObserver<io.grpc.reflection.v1.ServerReflectionResponse> responseObserver) {\n+      return io.grpc.stub.ServerCalls.asyncUnimplementedStreamingCall(getServerReflectionInfoMethod(), responseObserver);\n+    }\n+  }\n+\n+  /**\n+   * Base class for the server implementation of the service ServerReflection.\n+   */\n+  public static abstract class ServerReflectionImplBase\n+      implements io.grpc.BindableService, AsyncService {\n+\n+    @java.lang.Override public final io.grpc.ServerServiceDefinition bindService() {\n+      return ServerReflectionGrpc.bindService(this);\n+    }\n+  }\n+\n+  /**\n+   * A stub to allow clients to do asynchronous rpc calls to service ServerReflection.\n+   */\n+  public static final class ServerReflectionStub\n+      extends io.grpc.stub.AbstractAsyncStub<ServerReflectionStub> {\n+    private ServerReflectionStub(\n+        io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n+      super(channel, callOptions);\n+    }\n+\n+    @java.lang.Override\n+    protected ServerReflectionStub build(\n+        io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n+      return new ServerReflectionStub(channel, callOptions);\n+    }\n+\n+    /**\n+     * <pre>\n+     * The reflection service is structured as a bidirectional stream, ensuring\n+     * all related requests go to a single server.\n+     * </pre>\n+     */\n+    public io.grpc.stub.StreamObserver<io.grpc.reflection.v1.ServerReflectionRequest> serverReflectionInfo(\n+        io.grpc.stub.StreamObserver<io.grpc.reflection.v1.ServerReflectionResponse> responseObserver) {\n+      return io.grpc.stub.ClientCalls.asyncBidiStreamingCall(\n+          getChannel().newCall(getServerReflectionInfoMethod(), getCallOptions()), responseObserver);\n+    }\n+  }\n+\n+  /**\n+   * A stub to allow clients to do synchronous rpc calls to service ServerReflection.\n+   */\n+  public static final class ServerReflectionBlockingStub\n+      extends io.grpc.stub.AbstractBlockingStub<ServerReflectionBlockingStub> {\n+    private ServerReflectionBlockingStub(\n+        io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n+      super(channel, callOptions);\n+    }\n+\n+    @java.lang.Override\n+    protected ServerReflectionBlockingStub build(\n+        io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n+      return new ServerReflectionBlockingStub(channel, callOptions);\n+    }\n+  }\n+\n+  /**\n+   * A stub to allow clients to do ListenableFuture-style rpc calls to service ServerReflection.\n+   */\n+  public static final class ServerReflectionFutureStub\n+      extends io.grpc.stub.AbstractFutureStub<ServerReflectionFutureStub> {\n+    private ServerReflectionFutureStub(\n+        io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n+      super(channel, callOptions);\n+    }\n+\n+    @java.lang.Override\n+    protected ServerReflectionFutureStub build(\n+        io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n+      return new ServerReflectionFutureStub(channel, callOptions);\n+    }\n+  }\n+\n+  private static final int METHODID_SERVER_REFLECTION_INFO = 0;\n+\n+  private static final class MethodHandlers<Req, Resp> implements\n+      io.grpc.stub.ServerCalls.UnaryMethod<Req, Resp>,\n+      io.grpc.stub.ServerCalls.ServerStreamingMethod<Req, Resp>,\n+      io.grpc.stub.ServerCalls.ClientStreamingMethod<Req, Resp>,\n+      io.grpc.stub.ServerCalls.BidiStreamingMethod<Req, Resp> {\n+    private final AsyncService serviceImpl;\n+    private final int methodId;\n+\n+    MethodHandlers(AsyncService serviceImpl, int methodId) {\n+      this.serviceImpl = serviceImpl;\n+      this.methodId = methodId;\n+    }\n+\n+    @java.lang.Override\n+    @java.lang.SuppressWarnings(\"unchecked\")\n+    public void invoke(Req request, io.grpc.stub.StreamObserver<Resp> responseObserver) {\n+      switch (methodId) {\n+        default:\n+          throw new AssertionError();\n+      }\n+    }\n+\n+    @java.lang.Override\n+    @java.lang.SuppressWarnings(\"unchecked\")\n+    public io.grpc.stub.StreamObserver<Req> invoke(\n+        io.grpc.stub.StreamObserver<Resp> responseObserver) {\n+      switch (methodId) {\n+        case METHODID_SERVER_REFLECTION_INFO:\n+          return (io.grpc.stub.StreamObserver<Req>) serviceImpl.serverReflectionInfo(\n+              (io.grpc.stub.StreamObserver<io.grpc.reflection.v1.ServerReflectionResponse>) responseObserver);\n+        default:\n+          throw new AssertionError();\n+      }\n+    }\n+  }\n+\n+  public static final io.grpc.ServerServiceDefinition bindService(AsyncService service) {\n+    return io.grpc.ServerServiceDefinition.builder(getServiceDescriptor())\n+        .addMethod(\n+          getServerReflectionInfoMethod(),\n+          io.grpc.stub.ServerCalls.asyncBidiStreamingCall(\n+            new MethodHandlers<\n+              io.grpc.reflection.v1.ServerReflectionRequest,\n+              io.grpc.reflection.v1.ServerReflectionResponse>(\n+                service, METHODID_SERVER_REFLECTION_INFO)))\n+        .build();\n+  }\n+\n+  private static abstract class ServerReflectionBaseDescriptorSupplier\n+      implements io.grpc.protobuf.ProtoFileDescriptorSupplier, io.grpc.protobuf.ProtoServiceDescriptorSupplier {\n+    ServerReflectionBaseDescriptorSupplier() {}\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Descriptors.FileDescriptor getFileDescriptor() {\n+      return io.grpc.reflection.v1.ServerReflectionProto.getDescriptor();\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Descriptors.ServiceDescriptor getServiceDescriptor() {\n+      return getFileDescriptor().findServiceByName(\"ServerReflection\");\n+    }\n+  }\n+\n+  private static final class ServerReflectionFileDescriptorSupplier\n+      extends ServerReflectionBaseDescriptorSupplier {\n+    ServerReflectionFileDescriptorSupplier() {}\n+  }\n+\n+  private static final class ServerReflectionMethodDescriptorSupplier\n+      extends ServerReflectionBaseDescriptorSupplier\n+      implements io.grpc.protobuf.ProtoMethodDescriptorSupplier {\n+    private final java.lang.String methodName;\n+\n+    ServerReflectionMethodDescriptorSupplier(java.lang.String methodName) {\n+      this.methodName = methodName;\n+    }\n+\n+    @java.lang.Override\n+    public com.google.protobuf.Descriptors.MethodDescriptor getMethodDescriptor() {\n+      return getServiceDescriptor().findMethodByName(methodName);\n+    }\n+  }\n+\n+  private static volatile io.grpc.ServiceDescriptor serviceDescriptor;\n+\n+  public static io.grpc.ServiceDescriptor getServiceDescriptor() {\n+    io.grpc.ServiceDescriptor result = serviceDescriptor;\n+    if (result == null) {\n+      synchronized (ServerReflectionGrpc.class) {\n+        result = serviceDescriptor;\n+        if (result == null) {\n+          serviceDescriptor = result = io.grpc.ServiceDescriptor.newBuilder(SERVICE_NAME)\n+              .setSchemaDescriptor(new ServerReflectionFileDescriptorSupplier())\n+              .addMethod(getServerReflectionInfoMethod())\n+              .build();\n+        }\n+      }\n+    }\n+    return result;\n+  }\n+}\n\ndiff --git a/services/src/main/java/io/grpc/protobuf/services/ProtoReflectionService.java b/services/src/main/java/io/grpc/protobuf/services/ProtoReflectionService.java\nindex 4a7840a3ad9..45947ed44ee 100644\n--- a/services/src/main/java/io/grpc/protobuf/services/ProtoReflectionService.java\n+++ b/services/src/main/java/io/grpc/protobuf/services/ProtoReflectionService.java\n@@ -16,524 +16,70 @@\n \n package io.grpc.protobuf.services;\n \n-import static com.google.common.base.Preconditions.checkNotNull;\n-import static com.google.common.base.Preconditions.checkState;\n-\n-import com.google.protobuf.Descriptors.Descriptor;\n-import com.google.protobuf.Descriptors.FieldDescriptor;\n-import com.google.protobuf.Descriptors.FileDescriptor;\n-import com.google.protobuf.Descriptors.MethodDescriptor;\n-import com.google.protobuf.Descriptors.ServiceDescriptor;\n import io.grpc.BindableService;\n import io.grpc.ExperimentalApi;\n-import io.grpc.InternalServer;\n-import io.grpc.Server;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.ServerCallHandler;\n import io.grpc.ServerServiceDefinition;\n-import io.grpc.Status;\n-import io.grpc.protobuf.ProtoFileDescriptorSupplier;\n-import io.grpc.reflection.v1alpha.ErrorResponse;\n-import io.grpc.reflection.v1alpha.ExtensionNumberResponse;\n-import io.grpc.reflection.v1alpha.ExtensionRequest;\n-import io.grpc.reflection.v1alpha.FileDescriptorResponse;\n-import io.grpc.reflection.v1alpha.ListServiceResponse;\n-import io.grpc.reflection.v1alpha.ServerReflectionGrpc;\n-import io.grpc.reflection.v1alpha.ServerReflectionRequest;\n-import io.grpc.reflection.v1alpha.ServerReflectionResponse;\n-import io.grpc.reflection.v1alpha.ServiceResponse;\n-import io.grpc.stub.ServerCallStreamObserver;\n-import io.grpc.stub.StreamObserver;\n-import java.util.ArrayDeque;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Queue;\n-import java.util.Set;\n-import java.util.WeakHashMap;\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.GuardedBy;\n+import io.grpc.ServiceDescriptor;\n+import io.grpc.reflection.v1.ServerReflectionGrpc;\n+import io.grpc.reflection.v1.ServerReflectionRequest;\n+import io.grpc.reflection.v1.ServerReflectionResponse;\n \n /**\n  * Provides a reflection service for Protobuf services (including the reflection service itself).\n+ * Uses the deprecated v1alpha proto. New users should use ProtoReflectionServiceV1 instead.\n  *\n  * <p>Separately tracks mutable and immutable services. Throws an exception if either group of\n  * services contains multiple Protobuf files with declarations of the same service, method, type, or\n  * extension.\n  */\n @ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/2222\")\n-public final class ProtoReflectionService extends ServerReflectionGrpc.ServerReflectionImplBase {\n-\n-  private final Object lock = new Object();\n-\n-  @GuardedBy(\"lock\")\n-  private final Map<Server, ServerReflectionIndex> serverReflectionIndexes = new WeakHashMap<>();\n+public final class ProtoReflectionService implements BindableService {\n \n-  private ProtoReflectionService() {}\n+  private ProtoReflectionService() {\n+  }\n \n-  /**\n-   * Creates a instance of {@link ProtoReflectionService}.\n-   */\n   public static BindableService newInstance() {\n     return new ProtoReflectionService();\n   }\n \n-  /**\n-   * Retrieves the index for services of the server that dispatches the current call. Computes\n-   * one if not exist. The index is updated if any changes to the server's mutable services are\n-   * detected. A change is any addition or removal in the set of file descriptors attached to the\n-   * mutable services or a change in the service names.\n-   */\n-  private ServerReflectionIndex getRefreshedIndex() {\n-    synchronized (lock) {\n-      Server server = InternalServer.SERVER_CONTEXT_KEY.get();\n-      ServerReflectionIndex index = serverReflectionIndexes.get(server);\n-      if (index == null) {\n-        index =\n-            new ServerReflectionIndex(server.getImmutableServices(), server.getMutableServices());\n-        serverReflectionIndexes.put(server, index);\n-        return index;\n-      }\n-\n-      Set<FileDescriptor> serverFileDescriptors = new HashSet<>();\n-      Set<String> serverServiceNames = new HashSet<>();\n-      List<ServerServiceDefinition> serverMutableServices = server.getMutableServices();\n-      for (ServerServiceDefinition mutableService : serverMutableServices) {\n-        io.grpc.ServiceDescriptor serviceDescriptor = mutableService.getServiceDescriptor();\n-        if (serviceDescriptor.getSchemaDescriptor() instanceof ProtoFileDescriptorSupplier) {\n-          String serviceName = serviceDescriptor.getName();\n-          FileDescriptor fileDescriptor =\n-              ((ProtoFileDescriptorSupplier) serviceDescriptor.getSchemaDescriptor())\n-                  .getFileDescriptor();\n-          serverFileDescriptors.add(fileDescriptor);\n-          serverServiceNames.add(serviceName);\n-        }\n-      }\n-\n-      // Replace the index if the underlying mutable services have changed. Check both the file\n-      // descriptors and the service names, because one file descriptor can define multiple\n-      // services.\n-      FileDescriptorIndex mutableServicesIndex = index.getMutableServicesIndex();\n-      if (!mutableServicesIndex.getServiceFileDescriptors().equals(serverFileDescriptors)\n-          || !mutableServicesIndex.getServiceNames().equals(serverServiceNames)) {\n-        index =\n-            new ServerReflectionIndex(server.getImmutableServices(), serverMutableServices);\n-        serverReflectionIndexes.put(server, index);\n-      }\n-\n-      return index;\n-    }\n-  }\n-\n   @Override\n-  public StreamObserver<ServerReflectionRequest> serverReflectionInfo(\n-      final StreamObserver<ServerReflectionResponse> responseObserver) {\n-    final ServerCallStreamObserver<ServerReflectionResponse> serverCallStreamObserver =\n-        (ServerCallStreamObserver<ServerReflectionResponse>) responseObserver;\n-    ProtoReflectionStreamObserver requestObserver =\n-        new ProtoReflectionStreamObserver(getRefreshedIndex(), serverCallStreamObserver);\n-    serverCallStreamObserver.setOnReadyHandler(requestObserver);\n-    serverCallStreamObserver.disableAutoRequest();\n-    serverCallStreamObserver.request(1);\n-    return requestObserver;\n+  public ServerServiceDefinition bindService() {\n+    ServerServiceDefinition serverServiceDefinitionV1 = ProtoReflectionServiceV1.newInstance()\n+        .bindService();\n+    MethodDescriptor<ServerReflectionRequest, ServerReflectionResponse> methodDescriptorV1 =\n+        ServerReflectionGrpc.getServerReflectionInfoMethod();\n+    // Retain the v1 proto marshallers but change the method name and schema descriptor to v1alpha.\n+    MethodDescriptor<io.grpc.reflection.v1alpha.ServerReflectionRequest,\n+        io.grpc.reflection.v1alpha.ServerReflectionResponse> methodDescriptorV1AlphaGenerated =\n+        io.grpc.reflection.v1alpha.ServerReflectionGrpc.getServerReflectionInfoMethod();\n+    MethodDescriptor<ServerReflectionRequest, ServerReflectionResponse> methodDescriptorV1Alpha =\n+        methodDescriptorV1.toBuilder()\n+            .setFullMethodName(methodDescriptorV1AlphaGenerated.getFullMethodName())\n+            .setSchemaDescriptor(methodDescriptorV1AlphaGenerated.getSchemaDescriptor())\n+            .build();\n+    // Retain the v1 server call handler but change the service name schema descriptor in the\n+    // service descriptor to v1alpha.\n+    ServiceDescriptor serviceDescriptorV1AlphaGenerated =\n+        io.grpc.reflection.v1alpha.ServerReflectionGrpc.getServiceDescriptor();\n+    ServiceDescriptor serviceDescriptorV1Alpha =\n+        ServiceDescriptor.newBuilder(serviceDescriptorV1AlphaGenerated.getName())\n+            .setSchemaDescriptor(serviceDescriptorV1AlphaGenerated.getSchemaDescriptor())\n+            .addMethod(methodDescriptorV1Alpha)\n+            .build();\n+    return ServerServiceDefinition.builder(serviceDescriptorV1Alpha)\n+        .addMethod(methodDescriptorV1Alpha, createServerCallHandler(serverServiceDefinitionV1))\n+        .build();\n   }\n \n-  private static class ProtoReflectionStreamObserver\n-      implements Runnable, StreamObserver<ServerReflectionRequest> {\n-    private final ServerReflectionIndex serverReflectionIndex;\n-    private final ServerCallStreamObserver<ServerReflectionResponse> serverCallStreamObserver;\n-\n-    private boolean closeAfterSend = false;\n-    private ServerReflectionRequest request;\n-\n-    ProtoReflectionStreamObserver(\n-        ServerReflectionIndex serverReflectionIndex,\n-        ServerCallStreamObserver<ServerReflectionResponse> serverCallStreamObserver) {\n-      this.serverReflectionIndex = serverReflectionIndex;\n-      this.serverCallStreamObserver = checkNotNull(serverCallStreamObserver, \"observer\");\n-    }\n-\n-    @Override\n-    public void run() {\n-      if (request != null) {\n-        handleReflectionRequest();\n-      }\n-    }\n-\n-    @Override\n-    public void onNext(ServerReflectionRequest request) {\n-      checkState(this.request == null);\n-      this.request = checkNotNull(request);\n-      handleReflectionRequest();\n-    }\n-\n-    private void handleReflectionRequest() {\n-      if (serverCallStreamObserver.isReady()) {\n-        switch (request.getMessageRequestCase()) {\n-          case FILE_BY_FILENAME:\n-            getFileByName(request);\n-            break;\n-          case FILE_CONTAINING_SYMBOL:\n-            getFileContainingSymbol(request);\n-            break;\n-          case FILE_CONTAINING_EXTENSION:\n-            getFileByExtension(request);\n-            break;\n-          case ALL_EXTENSION_NUMBERS_OF_TYPE:\n-            getAllExtensions(request);\n-            break;\n-          case LIST_SERVICES:\n-            listServices(request);\n-            break;\n-          default:\n-            sendErrorResponse(\n-                request,\n-                Status.Code.UNIMPLEMENTED,\n-                \"not implemented \" + request.getMessageRequestCase());\n-        }\n-        request = null;\n-        if (closeAfterSend) {\n-          serverCallStreamObserver.onCompleted();\n-        } else {\n-          serverCallStreamObserver.request(1);\n-        }\n-      }\n-    }\n-\n-    @Override\n-    public void onCompleted() {\n-      if (request != null) {\n-        closeAfterSend = true;\n-      } else {\n-        serverCallStreamObserver.onCompleted();\n-      }\n-    }\n-\n-    @Override\n-    public void onError(Throwable cause) {\n-      serverCallStreamObserver.onError(cause);\n-    }\n-\n-    private void getFileByName(ServerReflectionRequest request) {\n-      String name = request.getFileByFilename();\n-      FileDescriptor fd = serverReflectionIndex.getFileDescriptorByName(name);\n-      if (fd != null) {\n-        serverCallStreamObserver.onNext(createServerReflectionResponse(request, fd));\n-      } else {\n-        sendErrorResponse(request, Status.Code.NOT_FOUND, \"File not found.\");\n-      }\n-    }\n-\n-    private void getFileContainingSymbol(ServerReflectionRequest request) {\n-      String symbol = request.getFileContainingSymbol();\n-      FileDescriptor fd = serverReflectionIndex.getFileDescriptorBySymbol(symbol);\n-      if (fd != null) {\n-        serverCallStreamObserver.onNext(createServerReflectionResponse(request, fd));\n-      } else {\n-        sendErrorResponse(request, Status.Code.NOT_FOUND, \"Symbol not found.\");\n-      }\n-    }\n-\n-    private void getFileByExtension(ServerReflectionRequest request) {\n-      ExtensionRequest extensionRequest = request.getFileContainingExtension();\n-      String type = extensionRequest.getContainingType();\n-      int extension = extensionRequest.getExtensionNumber();\n-      FileDescriptor fd =\n-          serverReflectionIndex.getFileDescriptorByExtensionAndNumber(type, extension);\n-      if (fd != null) {\n-        serverCallStreamObserver.onNext(createServerReflectionResponse(request, fd));\n-      } else {\n-        sendErrorResponse(request, Status.Code.NOT_FOUND, \"Extension not found.\");\n-      }\n-    }\n-\n-    private void getAllExtensions(ServerReflectionRequest request) {\n-      String type = request.getAllExtensionNumbersOfType();\n-      Set<Integer> extensions = serverReflectionIndex.getExtensionNumbersOfType(type);\n-      if (extensions != null) {\n-        ExtensionNumberResponse.Builder builder =\n-            ExtensionNumberResponse.newBuilder()\n-                .setBaseTypeName(type)\n-                .addAllExtensionNumber(extensions);\n-        serverCallStreamObserver.onNext(\n-            ServerReflectionResponse.newBuilder()\n-                .setValidHost(request.getHost())\n-                .setOriginalRequest(request)\n-                .setAllExtensionNumbersResponse(builder)\n-                .build());\n-      } else {\n-        sendErrorResponse(request, Status.Code.NOT_FOUND, \"Type not found.\");\n-      }\n-    }\n-\n-    private void listServices(ServerReflectionRequest request) {\n-      ListServiceResponse.Builder builder = ListServiceResponse.newBuilder();\n-      for (String serviceName : serverReflectionIndex.getServiceNames()) {\n-        builder.addService(ServiceResponse.newBuilder().setName(serviceName));\n-      }\n-      serverCallStreamObserver.onNext(\n-          ServerReflectionResponse.newBuilder()\n-              .setValidHost(request.getHost())\n-              .setOriginalRequest(request)\n-              .setListServicesResponse(builder)\n-              .build());\n-    }\n-\n-    private void sendErrorResponse(\n-        ServerReflectionRequest request, Status.Code code, String message) {\n-      ServerReflectionResponse response =\n-          ServerReflectionResponse.newBuilder()\n-              .setValidHost(request.getHost())\n-              .setOriginalRequest(request)\n-              .setErrorResponse(\n-                  ErrorResponse.newBuilder()\n-                      .setErrorCode(code.value())\n-                      .setErrorMessage(message))\n-              .build();\n-      serverCallStreamObserver.onNext(response);\n-    }\n-\n-    private ServerReflectionResponse createServerReflectionResponse(\n-        ServerReflectionRequest request, FileDescriptor fd) {\n-      FileDescriptorResponse.Builder fdRBuilder = FileDescriptorResponse.newBuilder();\n-\n-      Set<String> seenFiles = new HashSet<>();\n-      Queue<FileDescriptor> frontier = new ArrayDeque<>();\n-      seenFiles.add(fd.getName());\n-      frontier.add(fd);\n-      while (!frontier.isEmpty()) {\n-        FileDescriptor nextFd = frontier.remove();\n-        fdRBuilder.addFileDescriptorProto(nextFd.toProto().toByteString());\n-        for (FileDescriptor dependencyFd : nextFd.getDependencies()) {\n-          if (!seenFiles.contains(dependencyFd.getName())) {\n-            seenFiles.add(dependencyFd.getName());\n-            frontier.add(dependencyFd);\n-          }\n-        }\n-      }\n-      return ServerReflectionResponse.newBuilder()\n-          .setValidHost(request.getHost())\n-          .setOriginalRequest(request)\n-          .setFileDescriptorResponse(fdRBuilder)\n-          .build();\n-    }\n-  }\n-\n-  /**\n-   * Indexes the server's services and allows lookups of file descriptors by filename, symbol, type,\n-   * and extension number.\n-   *\n-   * <p>Internally, this stores separate indices for the immutable and mutable services. When\n-   * queried, the immutable service index is checked for a matching value. Only if there is no match\n-   * in the immutable service index are the mutable services checked.\n-   */\n-  private static final class ServerReflectionIndex {\n-    private final FileDescriptorIndex immutableServicesIndex;\n-    private final FileDescriptorIndex mutableServicesIndex;\n-\n-    public ServerReflectionIndex(\n-        List<ServerServiceDefinition> immutableServices,\n-        List<ServerServiceDefinition> mutableServices) {\n-      immutableServicesIndex = new FileDescriptorIndex(immutableServices);\n-      mutableServicesIndex = new FileDescriptorIndex(mutableServices);\n-    }\n-\n-    private FileDescriptorIndex getMutableServicesIndex() {\n-      return mutableServicesIndex;\n-    }\n-\n-    private Set<String> getServiceNames() {\n-      Set<String> immutableServiceNames = immutableServicesIndex.getServiceNames();\n-      Set<String> mutableServiceNames = mutableServicesIndex.getServiceNames();\n-      Set<String> serviceNames =\n-          new HashSet<>(immutableServiceNames.size() + mutableServiceNames.size());\n-      serviceNames.addAll(immutableServiceNames);\n-      serviceNames.addAll(mutableServiceNames);\n-      return serviceNames;\n-    }\n-\n-    @Nullable\n-    private FileDescriptor getFileDescriptorByName(String name) {\n-      FileDescriptor fd = immutableServicesIndex.getFileDescriptorByName(name);\n-      if (fd == null) {\n-        fd = mutableServicesIndex.getFileDescriptorByName(name);\n-      }\n-      return fd;\n-    }\n-\n-    @Nullable\n-    private FileDescriptor getFileDescriptorBySymbol(String symbol) {\n-      FileDescriptor fd = immutableServicesIndex.getFileDescriptorBySymbol(symbol);\n-      if (fd == null) {\n-        fd = mutableServicesIndex.getFileDescriptorBySymbol(symbol);\n-      }\n-      return fd;\n-    }\n-\n-    @Nullable\n-    private FileDescriptor getFileDescriptorByExtensionAndNumber(String type, int extension) {\n-      FileDescriptor fd =\n-          immutableServicesIndex.getFileDescriptorByExtensionAndNumber(type, extension);\n-      if (fd == null) {\n-        fd = mutableServicesIndex.getFileDescriptorByExtensionAndNumber(type, extension);\n-      }\n-      return fd;\n-    }\n-\n-    @Nullable\n-    private Set<Integer> getExtensionNumbersOfType(String type) {\n-      Set<Integer> extensionNumbers = immutableServicesIndex.getExtensionNumbersOfType(type);\n-      if (extensionNumbers == null) {\n-        extensionNumbers = mutableServicesIndex.getExtensionNumbersOfType(type);\n-      }\n-      return extensionNumbers;\n-    }\n-  }\n-\n-  /**\n-   * Provides a set of methods for answering reflection queries for the file descriptors underlying\n-   * a set of services. Used by {@link ServerReflectionIndex} to separately index immutable and\n-   * mutable services.\n-   */\n-  private static final class FileDescriptorIndex {\n-    private final Set<String> serviceNames = new HashSet<>();\n-    private final Set<FileDescriptor> serviceFileDescriptors = new HashSet<>();\n-    private final Map<String, FileDescriptor> fileDescriptorsByName =\n-        new HashMap<>();\n-    private final Map<String, FileDescriptor> fileDescriptorsBySymbol =\n-        new HashMap<>();\n-    private final Map<String, Map<Integer, FileDescriptor>> fileDescriptorsByExtensionAndNumber =\n-        new HashMap<>();\n-\n-    FileDescriptorIndex(List<ServerServiceDefinition> services) {\n-      Queue<FileDescriptor> fileDescriptorsToProcess = new ArrayDeque<>();\n-      Set<String> seenFiles = new HashSet<>();\n-      for (ServerServiceDefinition service : services) {\n-        io.grpc.ServiceDescriptor serviceDescriptor = service.getServiceDescriptor();\n-        if (serviceDescriptor.getSchemaDescriptor() instanceof ProtoFileDescriptorSupplier) {\n-          FileDescriptor fileDescriptor =\n-              ((ProtoFileDescriptorSupplier) serviceDescriptor.getSchemaDescriptor())\n-                  .getFileDescriptor();\n-          String serviceName = serviceDescriptor.getName();\n-          checkState(\n-              !serviceNames.contains(serviceName), \"Service already defined: %s\", serviceName);\n-          serviceFileDescriptors.add(fileDescriptor);\n-          serviceNames.add(serviceName);\n-          if (!seenFiles.contains(fileDescriptor.getName())) {\n-            seenFiles.add(fileDescriptor.getName());\n-            fileDescriptorsToProcess.add(fileDescriptor);\n-          }\n-        }\n-      }\n-\n-      while (!fileDescriptorsToProcess.isEmpty()) {\n-        FileDescriptor currentFd = fileDescriptorsToProcess.remove();\n-        processFileDescriptor(currentFd);\n-        for (FileDescriptor dependencyFd : currentFd.getDependencies()) {\n-          if (!seenFiles.contains(dependencyFd.getName())) {\n-            seenFiles.add(dependencyFd.getName());\n-            fileDescriptorsToProcess.add(dependencyFd);\n-          }\n-        }\n-      }\n-    }\n-\n-    /**\n-     * Returns the file descriptors for the indexed services, but not their dependencies. This is\n-     * used to check if the server's mutable services have changed.\n-     */\n-    private Set<FileDescriptor> getServiceFileDescriptors() {\n-      return Collections.unmodifiableSet(serviceFileDescriptors);\n-    }\n-\n-    private Set<String> getServiceNames() {\n-      return Collections.unmodifiableSet(serviceNames);\n-    }\n-\n-    @Nullable\n-    private FileDescriptor getFileDescriptorByName(String name) {\n-      return fileDescriptorsByName.get(name);\n-    }\n-\n-    @Nullable\n-    private FileDescriptor getFileDescriptorBySymbol(String symbol) {\n-      return fileDescriptorsBySymbol.get(symbol);\n-    }\n-\n-    @Nullable\n-    private FileDescriptor getFileDescriptorByExtensionAndNumber(String type, int number) {\n-      if (fileDescriptorsByExtensionAndNumber.containsKey(type)) {\n-        return fileDescriptorsByExtensionAndNumber.get(type).get(number);\n-      }\n-      return null;\n-    }\n-\n-    @Nullable\n-    private Set<Integer> getExtensionNumbersOfType(String type) {\n-      if (fileDescriptorsByExtensionAndNumber.containsKey(type)) {\n-        return Collections.unmodifiableSet(fileDescriptorsByExtensionAndNumber.get(type).keySet());\n-      }\n-      return null;\n-    }\n-\n-    private void processFileDescriptor(FileDescriptor fd) {\n-      String fdName = fd.getName();\n-      checkState(!fileDescriptorsByName.containsKey(fdName), \"File name already used: %s\", fdName);\n-      fileDescriptorsByName.put(fdName, fd);\n-      for (ServiceDescriptor service : fd.getServices()) {\n-        processService(service, fd);\n-      }\n-      for (Descriptor type : fd.getMessageTypes()) {\n-        processType(type, fd);\n-      }\n-      for (FieldDescriptor extension : fd.getExtensions()) {\n-        processExtension(extension, fd);\n-      }\n-    }\n-\n-    private void processService(ServiceDescriptor service, FileDescriptor fd) {\n-      String serviceName = service.getFullName();\n-      checkState(\n-          !fileDescriptorsBySymbol.containsKey(serviceName),\n-          \"Service already defined: %s\",\n-          serviceName);\n-      fileDescriptorsBySymbol.put(serviceName, fd);\n-      for (MethodDescriptor method : service.getMethods()) {\n-        String methodName = method.getFullName();\n-        checkState(\n-            !fileDescriptorsBySymbol.containsKey(methodName),\n-            \"Method already defined: %s\",\n-            methodName);\n-        fileDescriptorsBySymbol.put(methodName, fd);\n-      }\n-    }\n-\n-    private void processType(Descriptor type, FileDescriptor fd) {\n-      String typeName = type.getFullName();\n-      checkState(\n-          !fileDescriptorsBySymbol.containsKey(typeName), \"Type already defined: %s\", typeName);\n-      fileDescriptorsBySymbol.put(typeName, fd);\n-      for (FieldDescriptor extension : type.getExtensions()) {\n-        processExtension(extension, fd);\n-      }\n-      for (Descriptor nestedType : type.getNestedTypes()) {\n-        processType(nestedType, fd);\n-      }\n-    }\n-\n-    private void processExtension(FieldDescriptor extension, FileDescriptor fd) {\n-      String extensionName = extension.getContainingType().getFullName();\n-      int extensionNumber = extension.getNumber();\n-      if (!fileDescriptorsByExtensionAndNumber.containsKey(extensionName)) {\n-        fileDescriptorsByExtensionAndNumber.put(\n-            extensionName, new HashMap<Integer, FileDescriptor>());\n-      }\n-      checkState(\n-          !fileDescriptorsByExtensionAndNumber.get(extensionName).containsKey(extensionNumber),\n-          \"Extension name and number already defined: %s, %s\",\n-          extensionName,\n-          extensionNumber);\n-      fileDescriptorsByExtensionAndNumber.get(extensionName).put(extensionNumber, fd);\n-    }\n+  @SuppressWarnings(\"unchecked\")\n+  private ServerCallHandler<ServerReflectionRequest, ServerReflectionResponse>\n+      createServerCallHandler(\n+      ServerServiceDefinition serverServiceDefinition) {\n+    return (ServerCallHandler<ServerReflectionRequest, ServerReflectionResponse>)\n+        serverServiceDefinition.getMethod(\n+            ServerReflectionGrpc.getServerReflectionInfoMethod().getFullMethodName())\n+        .getServerCallHandler();\n   }\n }\n\ndiff --git a/services/src/main/java/io/grpc/protobuf/services/ProtoReflectionServiceV1.java b/services/src/main/java/io/grpc/protobuf/services/ProtoReflectionServiceV1.java\nnew file mode 100644\nindex 00000000000..578e9bbd409\n--- /dev/null\n+++ b/services/src/main/java/io/grpc/protobuf/services/ProtoReflectionServiceV1.java\n@@ -0,0 +1,539 @@\n+/*\n+ * Copyright 2016 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.protobuf.services;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.protobuf.Descriptors.Descriptor;\n+import com.google.protobuf.Descriptors.FieldDescriptor;\n+import com.google.protobuf.Descriptors.FileDescriptor;\n+import com.google.protobuf.Descriptors.MethodDescriptor;\n+import com.google.protobuf.Descriptors.ServiceDescriptor;\n+import io.grpc.BindableService;\n+import io.grpc.ExperimentalApi;\n+import io.grpc.InternalServer;\n+import io.grpc.Server;\n+import io.grpc.ServerServiceDefinition;\n+import io.grpc.Status;\n+import io.grpc.protobuf.ProtoFileDescriptorSupplier;\n+import io.grpc.reflection.v1.ErrorResponse;\n+import io.grpc.reflection.v1.ExtensionNumberResponse;\n+import io.grpc.reflection.v1.ExtensionRequest;\n+import io.grpc.reflection.v1.FileDescriptorResponse;\n+import io.grpc.reflection.v1.ListServiceResponse;\n+import io.grpc.reflection.v1.ServerReflectionGrpc;\n+import io.grpc.reflection.v1.ServerReflectionRequest;\n+import io.grpc.reflection.v1.ServerReflectionResponse;\n+import io.grpc.reflection.v1.ServiceResponse;\n+import io.grpc.stub.ServerCallStreamObserver;\n+import io.grpc.stub.StreamObserver;\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * Provides a reflection service for Protobuf services (including the reflection service itself).\n+ *\n+ * <p>Separately tracks mutable and immutable services. Throws an exception if either group of\n+ * services contains multiple Protobuf files with declarations of the same service, method, type, or\n+ * extension.\n+ */\n+@ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/2222\")\n+public final class ProtoReflectionServiceV1 extends ServerReflectionGrpc.ServerReflectionImplBase {\n+\n+  private final Object lock = new Object();\n+\n+  @GuardedBy(\"lock\")\n+  private final Map<Server, ServerReflectionIndex> serverReflectionIndexes = new WeakHashMap<>();\n+\n+  private ProtoReflectionServiceV1() {}\n+\n+  /**\n+   * Creates a instance of {@link ProtoReflectionServiceV1}.\n+   */\n+  public static BindableService newInstance() {\n+    return new ProtoReflectionServiceV1();\n+  }\n+\n+  /**\n+   * Retrieves the index for services of the server that dispatches the current call. Computes\n+   * one if not exist. The index is updated if any changes to the server's mutable services are\n+   * detected. A change is any addition or removal in the set of file descriptors attached to the\n+   * mutable services or a change in the service names.\n+   */\n+  private ServerReflectionIndex getRefreshedIndex() {\n+    synchronized (lock) {\n+      Server server = InternalServer.SERVER_CONTEXT_KEY.get();\n+      ServerReflectionIndex index = serverReflectionIndexes.get(server);\n+      if (index == null) {\n+        index =\n+            new ServerReflectionIndex(server.getImmutableServices(), server.getMutableServices());\n+        serverReflectionIndexes.put(server, index);\n+        return index;\n+      }\n+\n+      Set<FileDescriptor> serverFileDescriptors = new HashSet<>();\n+      Set<String> serverServiceNames = new HashSet<>();\n+      List<ServerServiceDefinition> serverMutableServices = server.getMutableServices();\n+      for (ServerServiceDefinition mutableService : serverMutableServices) {\n+        io.grpc.ServiceDescriptor serviceDescriptor = mutableService.getServiceDescriptor();\n+        if (serviceDescriptor.getSchemaDescriptor() instanceof ProtoFileDescriptorSupplier) {\n+          String serviceName = serviceDescriptor.getName();\n+          FileDescriptor fileDescriptor =\n+              ((ProtoFileDescriptorSupplier) serviceDescriptor.getSchemaDescriptor())\n+                  .getFileDescriptor();\n+          serverFileDescriptors.add(fileDescriptor);\n+          serverServiceNames.add(serviceName);\n+        }\n+      }\n+\n+      // Replace the index if the underlying mutable services have changed. Check both the file\n+      // descriptors and the service names, because one file descriptor can define multiple\n+      // services.\n+      FileDescriptorIndex mutableServicesIndex = index.getMutableServicesIndex();\n+      if (!mutableServicesIndex.getServiceFileDescriptors().equals(serverFileDescriptors)\n+          || !mutableServicesIndex.getServiceNames().equals(serverServiceNames)) {\n+        index =\n+            new ServerReflectionIndex(server.getImmutableServices(), serverMutableServices);\n+        serverReflectionIndexes.put(server, index);\n+      }\n+\n+      return index;\n+    }\n+  }\n+\n+  @Override\n+  public StreamObserver<ServerReflectionRequest> serverReflectionInfo(\n+      final StreamObserver<ServerReflectionResponse> responseObserver) {\n+    final ServerCallStreamObserver<ServerReflectionResponse> serverCallStreamObserver =\n+        (ServerCallStreamObserver<ServerReflectionResponse>) responseObserver;\n+    ProtoReflectionStreamObserver requestObserver =\n+        new ProtoReflectionStreamObserver(getRefreshedIndex(), serverCallStreamObserver);\n+    serverCallStreamObserver.setOnReadyHandler(requestObserver);\n+    serverCallStreamObserver.disableAutoRequest();\n+    serverCallStreamObserver.request(1);\n+    return requestObserver;\n+  }\n+\n+  private static class ProtoReflectionStreamObserver\n+      implements Runnable, StreamObserver<ServerReflectionRequest> {\n+    private final ServerReflectionIndex serverReflectionIndex;\n+    private final ServerCallStreamObserver<ServerReflectionResponse> serverCallStreamObserver;\n+\n+    private boolean closeAfterSend = false;\n+    private ServerReflectionRequest request;\n+\n+    ProtoReflectionStreamObserver(\n+        ServerReflectionIndex serverReflectionIndex,\n+        ServerCallStreamObserver<ServerReflectionResponse> serverCallStreamObserver) {\n+      this.serverReflectionIndex = serverReflectionIndex;\n+      this.serverCallStreamObserver = checkNotNull(serverCallStreamObserver, \"observer\");\n+    }\n+\n+    @Override\n+    public void run() {\n+      if (request != null) {\n+        handleReflectionRequest();\n+      }\n+    }\n+\n+    @Override\n+    public void onNext(ServerReflectionRequest request) {\n+      checkState(this.request == null);\n+      this.request = checkNotNull(request);\n+      handleReflectionRequest();\n+    }\n+\n+    private void handleReflectionRequest() {\n+      if (serverCallStreamObserver.isReady()) {\n+        switch (request.getMessageRequestCase()) {\n+          case FILE_BY_FILENAME:\n+            getFileByName(request);\n+            break;\n+          case FILE_CONTAINING_SYMBOL:\n+            getFileContainingSymbol(request);\n+            break;\n+          case FILE_CONTAINING_EXTENSION:\n+            getFileByExtension(request);\n+            break;\n+          case ALL_EXTENSION_NUMBERS_OF_TYPE:\n+            getAllExtensions(request);\n+            break;\n+          case LIST_SERVICES:\n+            listServices(request);\n+            break;\n+          default:\n+            sendErrorResponse(\n+                request,\n+                Status.Code.UNIMPLEMENTED,\n+                \"not implemented \" + request.getMessageRequestCase());\n+        }\n+        request = null;\n+        if (closeAfterSend) {\n+          serverCallStreamObserver.onCompleted();\n+        } else {\n+          serverCallStreamObserver.request(1);\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public void onCompleted() {\n+      if (request != null) {\n+        closeAfterSend = true;\n+      } else {\n+        serverCallStreamObserver.onCompleted();\n+      }\n+    }\n+\n+    @Override\n+    public void onError(Throwable cause) {\n+      serverCallStreamObserver.onError(cause);\n+    }\n+\n+    private void getFileByName(ServerReflectionRequest request) {\n+      String name = request.getFileByFilename();\n+      FileDescriptor fd = serverReflectionIndex.getFileDescriptorByName(name);\n+      if (fd != null) {\n+        serverCallStreamObserver.onNext(createServerReflectionResponse(request, fd));\n+      } else {\n+        sendErrorResponse(request, Status.Code.NOT_FOUND, \"File not found.\");\n+      }\n+    }\n+\n+    private void getFileContainingSymbol(ServerReflectionRequest request) {\n+      String symbol = request.getFileContainingSymbol();\n+      FileDescriptor fd = serverReflectionIndex.getFileDescriptorBySymbol(symbol);\n+      if (fd != null) {\n+        serverCallStreamObserver.onNext(createServerReflectionResponse(request, fd));\n+      } else {\n+        sendErrorResponse(request, Status.Code.NOT_FOUND, \"Symbol not found.\");\n+      }\n+    }\n+\n+    private void getFileByExtension(ServerReflectionRequest request) {\n+      ExtensionRequest extensionRequest = request.getFileContainingExtension();\n+      String type = extensionRequest.getContainingType();\n+      int extension = extensionRequest.getExtensionNumber();\n+      FileDescriptor fd =\n+          serverReflectionIndex.getFileDescriptorByExtensionAndNumber(type, extension);\n+      if (fd != null) {\n+        serverCallStreamObserver.onNext(createServerReflectionResponse(request, fd));\n+      } else {\n+        sendErrorResponse(request, Status.Code.NOT_FOUND, \"Extension not found.\");\n+      }\n+    }\n+\n+    private void getAllExtensions(ServerReflectionRequest request) {\n+      String type = request.getAllExtensionNumbersOfType();\n+      Set<Integer> extensions = serverReflectionIndex.getExtensionNumbersOfType(type);\n+      if (extensions != null) {\n+        ExtensionNumberResponse.Builder builder =\n+            ExtensionNumberResponse.newBuilder()\n+                .setBaseTypeName(type)\n+                .addAllExtensionNumber(extensions);\n+        serverCallStreamObserver.onNext(\n+            ServerReflectionResponse.newBuilder()\n+                .setValidHost(request.getHost())\n+                .setOriginalRequest(request)\n+                .setAllExtensionNumbersResponse(builder)\n+                .build());\n+      } else {\n+        sendErrorResponse(request, Status.Code.NOT_FOUND, \"Type not found.\");\n+      }\n+    }\n+\n+    private void listServices(ServerReflectionRequest request) {\n+      ListServiceResponse.Builder builder = ListServiceResponse.newBuilder();\n+      for (String serviceName : serverReflectionIndex.getServiceNames()) {\n+        builder.addService(ServiceResponse.newBuilder().setName(serviceName));\n+      }\n+      serverCallStreamObserver.onNext(\n+          ServerReflectionResponse.newBuilder()\n+              .setValidHost(request.getHost())\n+              .setOriginalRequest(request)\n+              .setListServicesResponse(builder)\n+              .build());\n+    }\n+\n+    private void sendErrorResponse(\n+        ServerReflectionRequest request, Status.Code code, String message) {\n+      ServerReflectionResponse response =\n+          ServerReflectionResponse.newBuilder()\n+              .setValidHost(request.getHost())\n+              .setOriginalRequest(request)\n+              .setErrorResponse(\n+                  ErrorResponse.newBuilder()\n+                      .setErrorCode(code.value())\n+                      .setErrorMessage(message))\n+              .build();\n+      serverCallStreamObserver.onNext(response);\n+    }\n+\n+    private ServerReflectionResponse createServerReflectionResponse(\n+        ServerReflectionRequest request, FileDescriptor fd) {\n+      FileDescriptorResponse.Builder fdRBuilder = FileDescriptorResponse.newBuilder();\n+\n+      Set<String> seenFiles = new HashSet<>();\n+      Queue<FileDescriptor> frontier = new ArrayDeque<>();\n+      seenFiles.add(fd.getName());\n+      frontier.add(fd);\n+      while (!frontier.isEmpty()) {\n+        FileDescriptor nextFd = frontier.remove();\n+        fdRBuilder.addFileDescriptorProto(nextFd.toProto().toByteString());\n+        for (FileDescriptor dependencyFd : nextFd.getDependencies()) {\n+          if (!seenFiles.contains(dependencyFd.getName())) {\n+            seenFiles.add(dependencyFd.getName());\n+            frontier.add(dependencyFd);\n+          }\n+        }\n+      }\n+      return ServerReflectionResponse.newBuilder()\n+          .setValidHost(request.getHost())\n+          .setOriginalRequest(request)\n+          .setFileDescriptorResponse(fdRBuilder)\n+          .build();\n+    }\n+  }\n+\n+  /**\n+   * Indexes the server's services and allows lookups of file descriptors by filename, symbol, type,\n+   * and extension number.\n+   *\n+   * <p>Internally, this stores separate indices for the immutable and mutable services. When\n+   * queried, the immutable service index is checked for a matching value. Only if there is no match\n+   * in the immutable service index are the mutable services checked.\n+   */\n+  private static final class ServerReflectionIndex {\n+    private final FileDescriptorIndex immutableServicesIndex;\n+    private final FileDescriptorIndex mutableServicesIndex;\n+\n+    public ServerReflectionIndex(\n+        List<ServerServiceDefinition> immutableServices,\n+        List<ServerServiceDefinition> mutableServices) {\n+      immutableServicesIndex = new FileDescriptorIndex(immutableServices);\n+      mutableServicesIndex = new FileDescriptorIndex(mutableServices);\n+    }\n+\n+    private FileDescriptorIndex getMutableServicesIndex() {\n+      return mutableServicesIndex;\n+    }\n+\n+    private Set<String> getServiceNames() {\n+      Set<String> immutableServiceNames = immutableServicesIndex.getServiceNames();\n+      Set<String> mutableServiceNames = mutableServicesIndex.getServiceNames();\n+      Set<String> serviceNames =\n+          new HashSet<>(immutableServiceNames.size() + mutableServiceNames.size());\n+      serviceNames.addAll(immutableServiceNames);\n+      serviceNames.addAll(mutableServiceNames);\n+      return serviceNames;\n+    }\n+\n+    @Nullable\n+    private FileDescriptor getFileDescriptorByName(String name) {\n+      FileDescriptor fd = immutableServicesIndex.getFileDescriptorByName(name);\n+      if (fd == null) {\n+        fd = mutableServicesIndex.getFileDescriptorByName(name);\n+      }\n+      return fd;\n+    }\n+\n+    @Nullable\n+    private FileDescriptor getFileDescriptorBySymbol(String symbol) {\n+      FileDescriptor fd = immutableServicesIndex.getFileDescriptorBySymbol(symbol);\n+      if (fd == null) {\n+        fd = mutableServicesIndex.getFileDescriptorBySymbol(symbol);\n+      }\n+      return fd;\n+    }\n+\n+    @Nullable\n+    private FileDescriptor getFileDescriptorByExtensionAndNumber(String type, int extension) {\n+      FileDescriptor fd =\n+          immutableServicesIndex.getFileDescriptorByExtensionAndNumber(type, extension);\n+      if (fd == null) {\n+        fd = mutableServicesIndex.getFileDescriptorByExtensionAndNumber(type, extension);\n+      }\n+      return fd;\n+    }\n+\n+    @Nullable\n+    private Set<Integer> getExtensionNumbersOfType(String type) {\n+      Set<Integer> extensionNumbers = immutableServicesIndex.getExtensionNumbersOfType(type);\n+      if (extensionNumbers == null) {\n+        extensionNumbers = mutableServicesIndex.getExtensionNumbersOfType(type);\n+      }\n+      return extensionNumbers;\n+    }\n+  }\n+\n+  /**\n+   * Provides a set of methods for answering reflection queries for the file descriptors underlying\n+   * a set of services. Used by {@link ServerReflectionIndex} to separately index immutable and\n+   * mutable services.\n+   */\n+  private static final class FileDescriptorIndex {\n+    private final Set<String> serviceNames = new HashSet<>();\n+    private final Set<FileDescriptor> serviceFileDescriptors = new HashSet<>();\n+    private final Map<String, FileDescriptor> fileDescriptorsByName =\n+        new HashMap<>();\n+    private final Map<String, FileDescriptor> fileDescriptorsBySymbol =\n+        new HashMap<>();\n+    private final Map<String, Map<Integer, FileDescriptor>> fileDescriptorsByExtensionAndNumber =\n+        new HashMap<>();\n+\n+    FileDescriptorIndex(List<ServerServiceDefinition> services) {\n+      Queue<FileDescriptor> fileDescriptorsToProcess = new ArrayDeque<>();\n+      Set<String> seenFiles = new HashSet<>();\n+      for (ServerServiceDefinition service : services) {\n+        io.grpc.ServiceDescriptor serviceDescriptor = service.getServiceDescriptor();\n+        if (serviceDescriptor.getSchemaDescriptor() instanceof ProtoFileDescriptorSupplier) {\n+          FileDescriptor fileDescriptor =\n+              ((ProtoFileDescriptorSupplier) serviceDescriptor.getSchemaDescriptor())\n+                  .getFileDescriptor();\n+          String serviceName = serviceDescriptor.getName();\n+          checkState(\n+              !serviceNames.contains(serviceName), \"Service already defined: %s\", serviceName);\n+          serviceFileDescriptors.add(fileDescriptor);\n+          serviceNames.add(serviceName);\n+          if (!seenFiles.contains(fileDescriptor.getName())) {\n+            seenFiles.add(fileDescriptor.getName());\n+            fileDescriptorsToProcess.add(fileDescriptor);\n+          }\n+        }\n+      }\n+\n+      while (!fileDescriptorsToProcess.isEmpty()) {\n+        FileDescriptor currentFd = fileDescriptorsToProcess.remove();\n+        processFileDescriptor(currentFd);\n+        for (FileDescriptor dependencyFd : currentFd.getDependencies()) {\n+          if (!seenFiles.contains(dependencyFd.getName())) {\n+            seenFiles.add(dependencyFd.getName());\n+            fileDescriptorsToProcess.add(dependencyFd);\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Returns the file descriptors for the indexed services, but not their dependencies. This is\n+     * used to check if the server's mutable services have changed.\n+     */\n+    private Set<FileDescriptor> getServiceFileDescriptors() {\n+      return Collections.unmodifiableSet(serviceFileDescriptors);\n+    }\n+\n+    private Set<String> getServiceNames() {\n+      return Collections.unmodifiableSet(serviceNames);\n+    }\n+\n+    @Nullable\n+    private FileDescriptor getFileDescriptorByName(String name) {\n+      return fileDescriptorsByName.get(name);\n+    }\n+\n+    @Nullable\n+    private FileDescriptor getFileDescriptorBySymbol(String symbol) {\n+      return fileDescriptorsBySymbol.get(symbol);\n+    }\n+\n+    @Nullable\n+    private FileDescriptor getFileDescriptorByExtensionAndNumber(String type, int number) {\n+      if (fileDescriptorsByExtensionAndNumber.containsKey(type)) {\n+        return fileDescriptorsByExtensionAndNumber.get(type).get(number);\n+      }\n+      return null;\n+    }\n+\n+    @Nullable\n+    private Set<Integer> getExtensionNumbersOfType(String type) {\n+      if (fileDescriptorsByExtensionAndNumber.containsKey(type)) {\n+        return Collections.unmodifiableSet(fileDescriptorsByExtensionAndNumber.get(type).keySet());\n+      }\n+      return null;\n+    }\n+\n+    private void processFileDescriptor(FileDescriptor fd) {\n+      String fdName = fd.getName();\n+      checkState(!fileDescriptorsByName.containsKey(fdName), \"File name already used: %s\", fdName);\n+      fileDescriptorsByName.put(fdName, fd);\n+      for (ServiceDescriptor service : fd.getServices()) {\n+        processService(service, fd);\n+      }\n+      for (Descriptor type : fd.getMessageTypes()) {\n+        processType(type, fd);\n+      }\n+      for (FieldDescriptor extension : fd.getExtensions()) {\n+        processExtension(extension, fd);\n+      }\n+    }\n+\n+    private void processService(ServiceDescriptor service, FileDescriptor fd) {\n+      String serviceName = service.getFullName();\n+      checkState(\n+          !fileDescriptorsBySymbol.containsKey(serviceName),\n+          \"Service already defined: %s\",\n+          serviceName);\n+      fileDescriptorsBySymbol.put(serviceName, fd);\n+      for (MethodDescriptor method : service.getMethods()) {\n+        String methodName = method.getFullName();\n+        checkState(\n+            !fileDescriptorsBySymbol.containsKey(methodName),\n+            \"Method already defined: %s\",\n+            methodName);\n+        fileDescriptorsBySymbol.put(methodName, fd);\n+      }\n+    }\n+\n+    private void processType(Descriptor type, FileDescriptor fd) {\n+      String typeName = type.getFullName();\n+      checkState(\n+          !fileDescriptorsBySymbol.containsKey(typeName), \"Type already defined: %s\", typeName);\n+      fileDescriptorsBySymbol.put(typeName, fd);\n+      for (FieldDescriptor extension : type.getExtensions()) {\n+        processExtension(extension, fd);\n+      }\n+      for (Descriptor nestedType : type.getNestedTypes()) {\n+        processType(nestedType, fd);\n+      }\n+    }\n+\n+    private void processExtension(FieldDescriptor extension, FileDescriptor fd) {\n+      String extensionName = extension.getContainingType().getFullName();\n+      int extensionNumber = extension.getNumber();\n+      if (!fileDescriptorsByExtensionAndNumber.containsKey(extensionName)) {\n+        fileDescriptorsByExtensionAndNumber.put(\n+            extensionName, new HashMap<Integer, FileDescriptor>());\n+      }\n+      checkState(\n+          !fileDescriptorsByExtensionAndNumber.get(extensionName).containsKey(extensionNumber),\n+          \"Extension name and number already defined: %s, %s\",\n+          extensionName,\n+          extensionNumber);\n+      fileDescriptorsByExtensionAndNumber.get(extensionName).put(extensionNumber, fd);\n+    }\n+  }\n+}\n\ndiff --git a/services/src/main/proto/grpc/reflection/v1/reflection.proto b/services/src/main/proto/grpc/reflection/v1/reflection.proto\nnew file mode 100644\nindex 00000000000..1a2ceedc3d2\n--- /dev/null\n+++ b/services/src/main/proto/grpc/reflection/v1/reflection.proto\n@@ -0,0 +1,147 @@\n+// Copyright 2016 The gRPC Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Service exported by server reflection.  A more complete description of how\n+// server reflection works can be found at\n+// https://github.com/grpc/grpc/blob/master/doc/server-reflection.md\n+//\n+// The canonical version of this proto can be found at\n+// https://github.com/grpc/grpc-proto/blob/master/grpc/reflection/v1/reflection.proto\n+\n+syntax = \"proto3\";\n+\n+package grpc.reflection.v1;\n+\n+option go_package = \"google.golang.org/grpc/reflection/grpc_reflection_v1\";\n+option java_multiple_files = true;\n+option java_package = \"io.grpc.reflection.v1\";\n+option java_outer_classname = \"ServerReflectionProto\";\n+\n+service ServerReflection {\n+  // The reflection service is structured as a bidirectional stream, ensuring\n+  // all related requests go to a single server.\n+  rpc ServerReflectionInfo(stream ServerReflectionRequest)\n+      returns (stream ServerReflectionResponse);\n+}\n+\n+// The message sent by the client when calling ServerReflectionInfo method.\n+message ServerReflectionRequest {\n+  string host = 1;\n+  // To use reflection service, the client should set one of the following\n+  // fields in message_request. The server distinguishes requests by their\n+  // defined field and then handles them using corresponding methods.\n+  oneof message_request {\n+    // Find a proto file by the file name.\n+    string file_by_filename = 3;\n+\n+    // Find the proto file that declares the given fully-qualified symbol name.\n+    // This field should be a fully-qualified symbol name\n+    // (e.g. <package>.<service>[.<method>] or <package>.<type>).\n+    string file_containing_symbol = 4;\n+\n+    // Find the proto file which defines an extension extending the given\n+    // message type with the given field number.\n+    ExtensionRequest file_containing_extension = 5;\n+\n+    // Finds the tag numbers used by all known extensions of the given message\n+    // type, and appends them to ExtensionNumberResponse in an undefined order.\n+    // Its corresponding method is best-effort: it's not guaranteed that the\n+    // reflection service will implement this method, and it's not guaranteed\n+    // that this method will provide all extensions. Returns\n+    // StatusCode::UNIMPLEMENTED if it's not implemented.\n+    // This field should be a fully-qualified type name. The format is\n+    // <package>.<type>\n+    string all_extension_numbers_of_type = 6;\n+\n+    // List the full names of registered services. The content will not be\n+    // checked.\n+    string list_services = 7;\n+  }\n+}\n+\n+// The type name and extension number sent by the client when requesting\n+// file_containing_extension.\n+message ExtensionRequest {\n+  // Fully-qualified type name. The format should be <package>.<type>\n+  string containing_type = 1;\n+  int32 extension_number = 2;\n+}\n+\n+// The message sent by the server to answer ServerReflectionInfo method.\n+message ServerReflectionResponse {\n+  string valid_host = 1;\n+  ServerReflectionRequest original_request = 2;\n+  // The server sets one of the following fields according to the message_request\n+  // in the request.\n+  oneof message_response {\n+    // This message is used to answer file_by_filename, file_containing_symbol,\n+    // file_containing_extension requests with transitive dependencies.\n+    // As the repeated label is not allowed in oneof fields, we use a\n+    // FileDescriptorResponse message to encapsulate the repeated fields.\n+    // The reflection service is allowed to avoid sending FileDescriptorProtos\n+    // that were previously sent in response to earlier requests in the stream.\n+    FileDescriptorResponse file_descriptor_response = 4;\n+\n+    // This message is used to answer all_extension_numbers_of_type requests.\n+    ExtensionNumberResponse all_extension_numbers_response = 5;\n+\n+    // This message is used to answer list_services requests.\n+    ListServiceResponse list_services_response = 6;\n+\n+    // This message is used when an error occurs.\n+    ErrorResponse error_response = 7;\n+  }\n+}\n+\n+// Serialized FileDescriptorProto messages sent by the server answering\n+// a file_by_filename, file_containing_symbol, or file_containing_extension\n+// request.\n+message FileDescriptorResponse {\n+  // Serialized FileDescriptorProto messages. We avoid taking a dependency on\n+  // descriptor.proto, which uses proto2 only features, by making them opaque\n+  // bytes instead.\n+  repeated bytes file_descriptor_proto = 1;\n+}\n+\n+// A list of extension numbers sent by the server answering\n+// all_extension_numbers_of_type request.\n+message ExtensionNumberResponse {\n+  // Full name of the base type, including the package name. The format\n+  // is <package>.<type>\n+  string base_type_name = 1;\n+  repeated int32 extension_number = 2;\n+}\n+\n+// A list of ServiceResponse sent by the server answering list_services request.\n+message ListServiceResponse {\n+  // The information of each service may be expanded in the future, so we use\n+  // ServiceResponse message to encapsulate it.\n+  repeated ServiceResponse service = 1;\n+}\n+\n+// The information of a single service used by ListServiceResponse to answer\n+// list_services request.\n+message ServiceResponse {\n+  // Full name of a registered service, including its package name. The format\n+  // is <package>.<service>\n+  string name = 1;\n+}\n+\n+// The error code and error message sent by the server when an error occurs.\n+message ErrorResponse {\n+  // This field uses the error codes defined in grpc::StatusCode.\n+  int32 error_code = 1;\n+  string error_message = 2;\n+}\n+\n",
    "test_patch": "diff --git a/interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java b/interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java\nindex c38123cad64..d0942717e39 100644\n--- a/interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java\n+++ b/interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java\n@@ -41,6 +41,7 @@\n import io.grpc.Server;\n import io.grpc.Status;\n import io.grpc.protobuf.services.ProtoReflectionService;\n+import io.grpc.protobuf.services.ProtoReflectionServiceV1;\n import io.grpc.services.AdminInterface;\n import io.grpc.stub.StreamObserver;\n import io.grpc.testing.integration.Messages.ClientConfigureRequest;\n@@ -246,6 +247,7 @@ private void run() {\n             .addService(new XdsStatsImpl())\n             .addService(new ConfigureUpdateServiceImpl())\n             .addService(ProtoReflectionService.newInstance())\n+            .addService(ProtoReflectionServiceV1.newInstance())\n             .addServices(AdminInterface.getStandardServices())\n             .build();\n     try {\n\ndiff --git a/interop-testing/src/main/java/io/grpc/testing/integration/XdsTestServer.java b/interop-testing/src/main/java/io/grpc/testing/integration/XdsTestServer.java\nindex 9d74cfac542..c91e75e81c3 100644\n--- a/interop-testing/src/main/java/io/grpc/testing/integration/XdsTestServer.java\n+++ b/interop-testing/src/main/java/io/grpc/testing/integration/XdsTestServer.java\n@@ -31,6 +31,7 @@\n import io.grpc.health.v1.HealthCheckResponse.ServingStatus;\n import io.grpc.protobuf.services.HealthStatusManager;\n import io.grpc.protobuf.services.ProtoReflectionService;\n+import io.grpc.protobuf.services.ProtoReflectionServiceV1;\n import io.grpc.services.AdminInterface;\n import io.grpc.stub.StreamObserver;\n import io.grpc.testing.integration.Messages.SimpleRequest;\n@@ -181,6 +182,7 @@ private void start() throws Exception {\n               .addService(new XdsUpdateHealthServiceImpl(health))\n               .addService(health.getHealthService())\n               .addService(ProtoReflectionService.newInstance())\n+              .addService(ProtoReflectionServiceV1.newInstance())\n               .addServices(AdminInterface.getStandardServices())\n               .build();\n       maintenanceServer.start();\n@@ -201,6 +203,7 @@ private void start() throws Exception {\n               .addService(new XdsUpdateHealthServiceImpl(health))\n               .addService(health.getHealthService())\n               .addService(ProtoReflectionService.newInstance())\n+              .addService(ProtoReflectionServiceV1.newInstance())\n               .addServices(AdminInterface.getStandardServices())\n               .build();\n       server.start();\n\ndiff --git a/services/src/test/java/io/grpc/protobuf/services/ProtoReflectionServiceV1Test.java b/services/src/test/java/io/grpc/protobuf/services/ProtoReflectionServiceV1Test.java\nnew file mode 100644\nindex 00000000000..47bd3e792ad\n--- /dev/null\n+++ b/services/src/test/java/io/grpc/protobuf/services/ProtoReflectionServiceV1Test.java\n@@ -0,0 +1,670 @@\n+/*\n+ * Copyright 2016 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.protobuf.services;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import com.google.protobuf.ByteString;\n+import io.grpc.BindableService;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Server;\n+import io.grpc.ServerServiceDefinition;\n+import io.grpc.inprocess.InProcessChannelBuilder;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import io.grpc.internal.testing.StreamRecorder;\n+import io.grpc.reflection.testing.AnotherDynamicServiceGrpc;\n+import io.grpc.reflection.testing.AnotherReflectableServiceGrpc;\n+import io.grpc.reflection.testing.DynamicReflectionTestDepthTwoProto;\n+import io.grpc.reflection.testing.DynamicServiceGrpc;\n+import io.grpc.reflection.testing.ReflectableServiceGrpc;\n+import io.grpc.reflection.testing.ReflectionTestDepthThreeProto;\n+import io.grpc.reflection.testing.ReflectionTestDepthTwoAlternateProto;\n+import io.grpc.reflection.testing.ReflectionTestDepthTwoProto;\n+import io.grpc.reflection.testing.ReflectionTestProto;\n+import io.grpc.reflection.v1.ExtensionNumberResponse;\n+import io.grpc.reflection.v1.ExtensionRequest;\n+import io.grpc.reflection.v1.FileDescriptorResponse;\n+import io.grpc.reflection.v1.ServerReflectionGrpc;\n+import io.grpc.reflection.v1.ServerReflectionRequest;\n+import io.grpc.reflection.v1.ServerReflectionResponse;\n+import io.grpc.reflection.v1.ServiceResponse;\n+import io.grpc.stub.ClientCallStreamObserver;\n+import io.grpc.stub.ClientResponseObserver;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.util.MutableHandlerRegistry;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Tests for {@link ProtoReflectionServiceV1}. */\n+@RunWith(JUnit4.class)\n+public class ProtoReflectionServiceV1Test {\n+  @Rule\n+  public GrpcCleanupRule grpcCleanupRule = new GrpcCleanupRule();\n+\n+  private static final String TEST_HOST = \"localhost\";\n+  private MutableHandlerRegistry handlerRegistry = new MutableHandlerRegistry();\n+  private BindableService reflectionService;\n+  private ServerServiceDefinition dynamicService =\n+      new DynamicServiceGrpc.DynamicServiceImplBase() {}.bindService();\n+  private ServerServiceDefinition anotherDynamicService =\n+      new AnotherDynamicServiceGrpc.AnotherDynamicServiceImplBase() {}.bindService();\n+  private ServerReflectionGrpc.ServerReflectionStub stub;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    reflectionService = ProtoReflectionServiceV1.newInstance();\n+    Server server =\n+        InProcessServerBuilder.forName(\"proto-reflection-test\")\n+            .directExecutor()\n+            .addService(reflectionService)\n+            .addService(new ReflectableServiceGrpc.ReflectableServiceImplBase() {})\n+            .fallbackHandlerRegistry(handlerRegistry)\n+            .build()\n+            .start();\n+    grpcCleanupRule.register(server);\n+    ManagedChannel channel =\n+        grpcCleanupRule.register(\n+            InProcessChannelBuilder.forName(\"proto-reflection-test\").directExecutor().build());\n+    stub = ServerReflectionGrpc.newStub(channel);\n+  }\n+\n+  @Test\n+  public void listServices() throws Exception {\n+    Set<ServiceResponse> originalServices =\n+        new HashSet<>(\n+            Arrays.asList(\n+                ServiceResponse.newBuilder()\n+                    .setName(\"grpc.reflection.v1.ServerReflection\")\n+                    .build(),\n+                ServiceResponse.newBuilder()\n+                    .setName(\"grpc.reflection.testing.ReflectableService\")\n+                    .build()));\n+    assertServiceResponseEquals(originalServices);\n+\n+    handlerRegistry.addService(dynamicService);\n+    assertServiceResponseEquals(\n+        new HashSet<>(\n+            Arrays.asList(\n+                ServiceResponse.newBuilder()\n+                    .setName(\"grpc.reflection.v1.ServerReflection\")\n+                    .build(),\n+                ServiceResponse.newBuilder()\n+                    .setName(\"grpc.reflection.testing.ReflectableService\")\n+                    .build(),\n+                ServiceResponse.newBuilder()\n+                    .setName(\"grpc.reflection.testing.DynamicService\")\n+                    .build())));\n+\n+    handlerRegistry.addService(anotherDynamicService);\n+    assertServiceResponseEquals(\n+        new HashSet<>(\n+            Arrays.asList(\n+                ServiceResponse.newBuilder()\n+                    .setName(\"grpc.reflection.v1.ServerReflection\")\n+                    .build(),\n+                ServiceResponse.newBuilder()\n+                    .setName(\"grpc.reflection.testing.ReflectableService\")\n+                    .build(),\n+                ServiceResponse.newBuilder()\n+                    .setName(\"grpc.reflection.testing.DynamicService\")\n+                    .build(),\n+                ServiceResponse.newBuilder()\n+                    .setName(\"grpc.reflection.testing.AnotherDynamicService\")\n+                    .build())));\n+\n+    handlerRegistry.removeService(dynamicService);\n+    assertServiceResponseEquals(\n+        new HashSet<>(\n+            Arrays.asList(\n+                ServiceResponse.newBuilder()\n+                    .setName(\"grpc.reflection.v1.ServerReflection\")\n+                    .build(),\n+                ServiceResponse.newBuilder()\n+                    .setName(\"grpc.reflection.testing.ReflectableService\")\n+                    .build(),\n+                ServiceResponse.newBuilder()\n+                    .setName(\"grpc.reflection.testing.AnotherDynamicService\")\n+                    .build())));\n+\n+    handlerRegistry.removeService(anotherDynamicService);\n+    assertServiceResponseEquals(originalServices);\n+  }\n+\n+  @Test\n+  public void fileByFilename() throws Exception {\n+    ServerReflectionRequest request =\n+        ServerReflectionRequest.newBuilder()\n+            .setHost(TEST_HOST)\n+            .setFileByFilename(\"io/grpc/reflection/testing/reflection_test_depth_three.proto\")\n+            .build();\n+\n+    ServerReflectionResponse goldenResponse =\n+        ServerReflectionResponse.newBuilder()\n+            .setValidHost(TEST_HOST)\n+            .setOriginalRequest(request)\n+            .setFileDescriptorResponse(\n+                FileDescriptorResponse.newBuilder()\n+                    .addFileDescriptorProto(\n+                        ReflectionTestDepthThreeProto.getDescriptor().toProto().toByteString())\n+                    .build())\n+            .build();\n+\n+    StreamRecorder<ServerReflectionResponse> responseObserver = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver =\n+        stub.serverReflectionInfo(responseObserver);\n+    requestObserver.onNext(request);\n+    requestObserver.onCompleted();\n+\n+    assertEquals(goldenResponse, responseObserver.firstValue().get());\n+  }\n+\n+  @Test\n+  public void fileByFilenameConsistentForMutableServices() throws Exception {\n+    ServerReflectionRequest request =\n+        ServerReflectionRequest.newBuilder()\n+            .setHost(TEST_HOST)\n+            .setFileByFilename(\"io/grpc/reflection/testing/dynamic_reflection_test_depth_two.proto\")\n+            .build();\n+    ServerReflectionResponse goldenResponse =\n+        ServerReflectionResponse.newBuilder()\n+            .setValidHost(TEST_HOST)\n+            .setOriginalRequest(request)\n+            .setFileDescriptorResponse(\n+                FileDescriptorResponse.newBuilder()\n+                    .addFileDescriptorProto(\n+                        DynamicReflectionTestDepthTwoProto.getDescriptor().toProto().toByteString())\n+                    .build())\n+            .build();\n+\n+    StreamRecorder<ServerReflectionResponse> responseObserver = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver =\n+        stub.serverReflectionInfo(responseObserver);\n+    handlerRegistry.addService(dynamicService);\n+    requestObserver.onNext(request);\n+    requestObserver.onCompleted();\n+    StreamRecorder<ServerReflectionResponse> responseObserver2 = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver2 =\n+        stub.serverReflectionInfo(responseObserver2);\n+    handlerRegistry.removeService(dynamicService);\n+    requestObserver2.onNext(request);\n+    requestObserver2.onCompleted();\n+    StreamRecorder<ServerReflectionResponse> responseObserver3 = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver3 =\n+        stub.serverReflectionInfo(responseObserver3);\n+    requestObserver3.onNext(request);\n+    requestObserver3.onCompleted();\n+\n+    assertEquals(\n+        ServerReflectionResponse.MessageResponseCase.ERROR_RESPONSE,\n+        responseObserver.firstValue().get().getMessageResponseCase());\n+    assertEquals(goldenResponse, responseObserver2.firstValue().get());\n+    assertEquals(\n+        ServerReflectionResponse.MessageResponseCase.ERROR_RESPONSE,\n+        responseObserver3.firstValue().get().getMessageResponseCase());\n+  }\n+\n+  @Test\n+  public void fileContainingSymbol() throws Exception {\n+    ServerReflectionRequest request =\n+        ServerReflectionRequest.newBuilder()\n+            .setHost(TEST_HOST)\n+            .setFileContainingSymbol(\"grpc.reflection.testing.ReflectableService.Method\")\n+            .build();\n+\n+    List<ByteString> goldenResponse =\n+        Arrays.asList(\n+            ReflectionTestProto.getDescriptor().toProto().toByteString(),\n+            ReflectionTestDepthTwoProto.getDescriptor().toProto().toByteString(),\n+            ReflectionTestDepthTwoAlternateProto.getDescriptor().toProto().toByteString(),\n+            ReflectionTestDepthThreeProto.getDescriptor().toProto().toByteString());\n+\n+    StreamRecorder<ServerReflectionResponse> responseObserver = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver =\n+        stub.serverReflectionInfo(responseObserver);\n+    requestObserver.onNext(request);\n+    requestObserver.onCompleted();\n+\n+    List<ByteString> response =\n+        responseObserver\n+            .firstValue()\n+            .get()\n+            .getFileDescriptorResponse()\n+            .getFileDescriptorProtoList();\n+    assertEquals(goldenResponse.size(), response.size());\n+    assertEquals(new HashSet<>(goldenResponse), new HashSet<>(response));\n+  }\n+\n+  @Test\n+  public void fileContainingNestedSymbol() throws Exception {\n+    ServerReflectionRequest request =\n+        ServerReflectionRequest.newBuilder()\n+            .setHost(TEST_HOST)\n+            .setFileContainingSymbol(\"grpc.reflection.testing.NestedTypeOuter.Middle.Inner\")\n+            .build();\n+\n+    ServerReflectionResponse goldenResponse =\n+        ServerReflectionResponse.newBuilder()\n+            .setValidHost(TEST_HOST)\n+            .setOriginalRequest(request)\n+            .setFileDescriptorResponse(\n+                FileDescriptorResponse.newBuilder()\n+                    .addFileDescriptorProto(\n+                        ReflectionTestDepthThreeProto.getDescriptor().toProto().toByteString())\n+                    .build())\n+            .build();\n+\n+    StreamRecorder<ServerReflectionResponse> responseObserver = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver =\n+        stub.serverReflectionInfo(responseObserver);\n+    requestObserver.onNext(request);\n+    requestObserver.onCompleted();\n+    assertEquals(goldenResponse, responseObserver.firstValue().get());\n+  }\n+\n+  @Test\n+  public void fileContainingSymbolForMutableServices() throws Exception {\n+    ServerReflectionRequest request =\n+        ServerReflectionRequest.newBuilder()\n+            .setHost(TEST_HOST)\n+            .setFileContainingSymbol(\"grpc.reflection.testing.DynamicRequest\")\n+            .build();\n+    ServerReflectionResponse goldenResponse =\n+        ServerReflectionResponse.newBuilder()\n+            .setValidHost(TEST_HOST)\n+            .setOriginalRequest(request)\n+            .setFileDescriptorResponse(\n+                FileDescriptorResponse.newBuilder()\n+                    .addFileDescriptorProto(\n+                        DynamicReflectionTestDepthTwoProto.getDescriptor().toProto().toByteString())\n+                    .build())\n+            .build();\n+\n+    StreamRecorder<ServerReflectionResponse> responseObserver = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver =\n+        stub.serverReflectionInfo(responseObserver);\n+    handlerRegistry.addService(dynamicService);\n+    requestObserver.onNext(request);\n+    requestObserver.onCompleted();\n+    StreamRecorder<ServerReflectionResponse> responseObserver2 = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver2 =\n+        stub.serverReflectionInfo(responseObserver2);\n+    handlerRegistry.removeService(dynamicService);\n+    requestObserver2.onNext(request);\n+    requestObserver2.onCompleted();\n+    StreamRecorder<ServerReflectionResponse> responseObserver3 = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver3 =\n+        stub.serverReflectionInfo(responseObserver3);\n+    requestObserver3.onNext(request);\n+    requestObserver3.onCompleted();\n+\n+    assertEquals(\n+        ServerReflectionResponse.MessageResponseCase.ERROR_RESPONSE,\n+        responseObserver.firstValue().get().getMessageResponseCase());\n+    assertEquals(goldenResponse, responseObserver2.firstValue().get());\n+    assertEquals(\n+        ServerReflectionResponse.MessageResponseCase.ERROR_RESPONSE,\n+        responseObserver3.firstValue().get().getMessageResponseCase());\n+  }\n+\n+  @Test\n+  public void fileContainingExtension() throws Exception {\n+    ServerReflectionRequest request =\n+        ServerReflectionRequest.newBuilder()\n+            .setHost(TEST_HOST)\n+            .setFileContainingExtension(\n+                ExtensionRequest.newBuilder()\n+                    .setContainingType(\"grpc.reflection.testing.ThirdLevelType\")\n+                    .setExtensionNumber(100)\n+                    .build())\n+            .build();\n+\n+    List<ByteString> goldenResponse =\n+        Arrays.asList(\n+            ReflectionTestProto.getDescriptor().toProto().toByteString(),\n+            ReflectionTestDepthTwoProto.getDescriptor().toProto().toByteString(),\n+            ReflectionTestDepthTwoAlternateProto.getDescriptor().toProto().toByteString(),\n+            ReflectionTestDepthThreeProto.getDescriptor().toProto().toByteString());\n+\n+    StreamRecorder<ServerReflectionResponse> responseObserver = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver =\n+        stub.serverReflectionInfo(responseObserver);\n+    requestObserver.onNext(request);\n+    requestObserver.onCompleted();\n+\n+    List<ByteString> response =\n+        responseObserver\n+            .firstValue()\n+            .get()\n+            .getFileDescriptorResponse()\n+            .getFileDescriptorProtoList();\n+    assertEquals(goldenResponse.size(), response.size());\n+    assertEquals(new HashSet<>(goldenResponse), new HashSet<>(response));\n+  }\n+\n+  @Test\n+  public void fileContainingNestedExtension() throws Exception {\n+    ServerReflectionRequest request =\n+        ServerReflectionRequest.newBuilder()\n+            .setHost(TEST_HOST)\n+            .setFileContainingExtension(\n+                ExtensionRequest.newBuilder()\n+                    .setContainingType(\"grpc.reflection.testing.ThirdLevelType\")\n+                    .setExtensionNumber(101)\n+                    .build())\n+            .build();\n+\n+    ServerReflectionResponse goldenResponse =\n+        ServerReflectionResponse.newBuilder()\n+            .setValidHost(TEST_HOST)\n+            .setOriginalRequest(request)\n+            .setFileDescriptorResponse(\n+                FileDescriptorResponse.newBuilder()\n+                    .addFileDescriptorProto(\n+                        ReflectionTestDepthTwoProto.getDescriptor().toProto().toByteString())\n+                    .addFileDescriptorProto(\n+                        ReflectionTestDepthThreeProto.getDescriptor().toProto().toByteString())\n+                    .build())\n+            .build();\n+\n+    StreamRecorder<ServerReflectionResponse> responseObserver = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver =\n+        stub.serverReflectionInfo(responseObserver);\n+    requestObserver.onNext(request);\n+    requestObserver.onCompleted();\n+    assertEquals(goldenResponse, responseObserver.firstValue().get());\n+  }\n+\n+  @Test\n+  public void fileContainingExtensionForMutableServices() throws Exception {\n+    ServerReflectionRequest request =\n+        ServerReflectionRequest.newBuilder()\n+            .setHost(TEST_HOST)\n+            .setFileContainingExtension(\n+                ExtensionRequest.newBuilder()\n+                    .setContainingType(\"grpc.reflection.testing.TypeWithExtensions\")\n+                    .setExtensionNumber(200)\n+                    .build())\n+            .build();\n+    ServerReflectionResponse goldenResponse =\n+        ServerReflectionResponse.newBuilder()\n+            .setValidHost(TEST_HOST)\n+            .setOriginalRequest(request)\n+            .setFileDescriptorResponse(\n+                FileDescriptorResponse.newBuilder()\n+                    .addFileDescriptorProto(\n+                        DynamicReflectionTestDepthTwoProto.getDescriptor().toProto().toByteString())\n+                    .build())\n+            .build();\n+\n+    StreamRecorder<ServerReflectionResponse> responseObserver = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver =\n+        stub.serverReflectionInfo(responseObserver);\n+    handlerRegistry.addService(dynamicService);\n+    requestObserver.onNext(request);\n+    requestObserver.onCompleted();\n+    StreamRecorder<ServerReflectionResponse> responseObserver2 = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver2 =\n+        stub.serverReflectionInfo(responseObserver2);\n+    handlerRegistry.removeService(dynamicService);\n+    requestObserver2.onNext(request);\n+    requestObserver2.onCompleted();\n+    StreamRecorder<ServerReflectionResponse> responseObserver3 = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver3 =\n+        stub.serverReflectionInfo(responseObserver3);\n+    requestObserver3.onNext(request);\n+    requestObserver3.onCompleted();\n+\n+    assertEquals(\n+        ServerReflectionResponse.MessageResponseCase.ERROR_RESPONSE,\n+        responseObserver.firstValue().get().getMessageResponseCase());\n+    assertEquals(goldenResponse, responseObserver2.firstValue().get());\n+    assertEquals(\n+        ServerReflectionResponse.MessageResponseCase.ERROR_RESPONSE,\n+        responseObserver3.firstValue().get().getMessageResponseCase());\n+  }\n+\n+  @Test\n+  public void allExtensionNumbersOfType() throws Exception {\n+    ServerReflectionRequest request =\n+        ServerReflectionRequest.newBuilder()\n+            .setHost(TEST_HOST)\n+            .setAllExtensionNumbersOfType(\"grpc.reflection.testing.ThirdLevelType\")\n+            .build();\n+\n+    Set<Integer> goldenResponse = new HashSet<>(Arrays.asList(100, 101));\n+\n+    StreamRecorder<ServerReflectionResponse> responseObserver = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver =\n+        stub.serverReflectionInfo(responseObserver);\n+    requestObserver.onNext(request);\n+    requestObserver.onCompleted();\n+    Set<Integer> extensionNumberResponseSet =\n+        new HashSet<>(\n+            responseObserver\n+                .firstValue()\n+                .get()\n+                .getAllExtensionNumbersResponse()\n+                .getExtensionNumberList());\n+    assertEquals(goldenResponse, extensionNumberResponseSet);\n+  }\n+\n+  @Test\n+  public void allExtensionNumbersOfTypeForMutableServices() throws Exception {\n+    String type = \"grpc.reflection.testing.TypeWithExtensions\";\n+    ServerReflectionRequest request =\n+        ServerReflectionRequest.newBuilder()\n+            .setHost(TEST_HOST)\n+            .setAllExtensionNumbersOfType(type)\n+            .build();\n+    ServerReflectionResponse goldenResponse =\n+        ServerReflectionResponse.newBuilder()\n+            .setValidHost(TEST_HOST)\n+            .setOriginalRequest(request)\n+            .setAllExtensionNumbersResponse(\n+                ExtensionNumberResponse.newBuilder()\n+                    .setBaseTypeName(type)\n+                    .addExtensionNumber(200)\n+                    .build())\n+            .build();\n+\n+    StreamRecorder<ServerReflectionResponse> responseObserver = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver =\n+        stub.serverReflectionInfo(responseObserver);\n+    handlerRegistry.addService(dynamicService);\n+    requestObserver.onNext(request);\n+    requestObserver.onCompleted();\n+    StreamRecorder<ServerReflectionResponse> responseObserver2 = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver2 =\n+        stub.serverReflectionInfo(responseObserver2);\n+    handlerRegistry.removeService(dynamicService);\n+    requestObserver2.onNext(request);\n+    requestObserver2.onCompleted();\n+    StreamRecorder<ServerReflectionResponse> responseObserver3 = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver3 =\n+        stub.serverReflectionInfo(responseObserver3);\n+    requestObserver3.onNext(request);\n+    requestObserver3.onCompleted();\n+\n+    assertEquals(\n+        ServerReflectionResponse.MessageResponseCase.ERROR_RESPONSE,\n+        responseObserver.firstValue().get().getMessageResponseCase());\n+    assertEquals(goldenResponse, responseObserver2.firstValue().get());\n+    assertEquals(\n+        ServerReflectionResponse.MessageResponseCase.ERROR_RESPONSE,\n+        responseObserver3.firstValue().get().getMessageResponseCase());\n+  }\n+\n+  @Test\n+  public void sharedServiceBetweenServers()\n+      throws IOException, ExecutionException, InterruptedException {\n+    Server anotherServer = InProcessServerBuilder.forName(\"proto-reflection-test-2\")\n+        .directExecutor()\n+        .addService(reflectionService)\n+        .addService(new AnotherReflectableServiceGrpc.AnotherReflectableServiceImplBase() {})\n+        .build()\n+        .start();\n+    grpcCleanupRule.register(anotherServer);\n+    ManagedChannel anotherChannel = grpcCleanupRule.register(\n+        InProcessChannelBuilder.forName(\"proto-reflection-test-2\").directExecutor().build());\n+    ServerReflectionGrpc.ServerReflectionStub stub2 = ServerReflectionGrpc.newStub(anotherChannel);\n+\n+    ServerReflectionRequest request =\n+        ServerReflectionRequest.newBuilder().setHost(TEST_HOST).setListServices(\"services\").build();\n+    StreamRecorder<ServerReflectionResponse> responseObserver = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver =\n+        stub2.serverReflectionInfo(responseObserver);\n+    requestObserver.onNext(request);\n+    requestObserver.onCompleted();\n+    List<ServiceResponse> response =\n+        responseObserver.firstValue().get().getListServicesResponse().getServiceList();\n+    assertEquals(new HashSet<>(\n+        Arrays.asList(\n+            ServiceResponse.newBuilder()\n+                .setName(\"grpc.reflection.v1.ServerReflection\")\n+                .build(),\n+            ServiceResponse.newBuilder()\n+                .setName(\"grpc.reflection.testing.AnotherReflectableService\")\n+                .build())),\n+        new HashSet<>(response));\n+  }\n+\n+  @Test\n+  public void flowControl() throws Exception {\n+    FlowControlClientResponseObserver clientResponseObserver =\n+        new FlowControlClientResponseObserver();\n+    ClientCallStreamObserver<ServerReflectionRequest> requestObserver =\n+        (ClientCallStreamObserver<ServerReflectionRequest>)\n+            stub.serverReflectionInfo(clientResponseObserver);\n+\n+    // Verify we don't receive a response until we request it.\n+    requestObserver.onNext(flowControlRequest);\n+    assertEquals(0, clientResponseObserver.getResponses().size());\n+\n+    requestObserver.request(1);\n+    assertEquals(1, clientResponseObserver.getResponses().size());\n+    assertEquals(flowControlGoldenResponse, clientResponseObserver.getResponses().get(0));\n+\n+    // Verify we don't receive an additional response until we request it.\n+    requestObserver.onNext(flowControlRequest);\n+    assertEquals(1, clientResponseObserver.getResponses().size());\n+\n+    requestObserver.request(1);\n+    assertEquals(2, clientResponseObserver.getResponses().size());\n+    assertEquals(flowControlGoldenResponse, clientResponseObserver.getResponses().get(1));\n+\n+    requestObserver.onCompleted();\n+    assertTrue(clientResponseObserver.onCompleteCalled());\n+  }\n+\n+  @Test\n+  public void flowControlOnCompleteWithPendingRequest() throws Exception {\n+    FlowControlClientResponseObserver clientResponseObserver =\n+        new FlowControlClientResponseObserver();\n+    ClientCallStreamObserver<ServerReflectionRequest> requestObserver =\n+        (ClientCallStreamObserver<ServerReflectionRequest>)\n+            stub.serverReflectionInfo(clientResponseObserver);\n+\n+    requestObserver.onNext(flowControlRequest);\n+    requestObserver.onCompleted();\n+    assertEquals(0, clientResponseObserver.getResponses().size());\n+    assertFalse(clientResponseObserver.onCompleteCalled());\n+\n+    requestObserver.request(1);\n+    assertTrue(clientResponseObserver.onCompleteCalled());\n+    assertEquals(1, clientResponseObserver.getResponses().size());\n+    assertEquals(flowControlGoldenResponse, clientResponseObserver.getResponses().get(0));\n+  }\n+\n+  private final ServerReflectionRequest flowControlRequest =\n+      ServerReflectionRequest.newBuilder()\n+          .setHost(TEST_HOST)\n+          .setFileByFilename(\"io/grpc/reflection/testing/reflection_test_depth_three.proto\")\n+          .build();\n+  private final ServerReflectionResponse flowControlGoldenResponse =\n+      ServerReflectionResponse.newBuilder()\n+          .setValidHost(TEST_HOST)\n+          .setOriginalRequest(flowControlRequest)\n+          .setFileDescriptorResponse(\n+              FileDescriptorResponse.newBuilder()\n+                  .addFileDescriptorProto(\n+                      ReflectionTestDepthThreeProto.getDescriptor().toProto().toByteString())\n+                  .build())\n+          .build();\n+\n+  private static class FlowControlClientResponseObserver\n+      implements ClientResponseObserver<ServerReflectionRequest, ServerReflectionResponse> {\n+    private final List<ServerReflectionResponse> responses =\n+        new ArrayList<>();\n+    private boolean onCompleteCalled = false;\n+\n+    @Override\n+    public void beforeStart(final ClientCallStreamObserver<ServerReflectionRequest> requestStream) {\n+      requestStream.disableAutoRequestWithInitial(0);\n+    }\n+\n+    @Override\n+    public void onNext(ServerReflectionResponse value) {\n+      responses.add(value);\n+    }\n+\n+    @Override\n+    public void onError(Throwable t) {\n+      fail(\"onError called\");\n+    }\n+\n+    @Override\n+    public void onCompleted() {\n+      onCompleteCalled = true;\n+    }\n+\n+    public List<ServerReflectionResponse> getResponses() {\n+      return responses;\n+    }\n+\n+    public boolean onCompleteCalled() {\n+      return onCompleteCalled;\n+    }\n+  }\n+\n+  private void assertServiceResponseEquals(Set<ServiceResponse> goldenResponse) throws Exception {\n+    ServerReflectionRequest request =\n+        ServerReflectionRequest.newBuilder().setHost(TEST_HOST).setListServices(\"services\").build();\n+    StreamRecorder<ServerReflectionResponse> responseObserver = StreamRecorder.create();\n+    StreamObserver<ServerReflectionRequest> requestObserver =\n+        stub.serverReflectionInfo(responseObserver);\n+    requestObserver.onNext(request);\n+    requestObserver.onCompleted();\n+    List<ServiceResponse> response =\n+        responseObserver.firstValue().get().getListServicesResponse().getServiceList();\n+    assertEquals(goldenResponse.size(), response.size());\n+    assertEquals(goldenResponse, new HashSet<>(response));\n+  }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11086",
    "pr_id": 11086,
    "issue_id": 11081,
    "repo": "grpc/grpc-java",
    "problem_statement": "1.63.0 release notes - jakarta_omit\nIn the release notes the option is mentioned as `JakartaMode=omit`, but it should be specified as `jakarta_omit`.\r\nhttps://github.com/grpc/grpc-java/blob/167a2031e29d21710e8790f72a00589fc6333d59/compiler/src/java_plugin/cpp/java_plugin.cpp#L77",
    "issue_word_count": 39,
    "test_files_count": 2,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "compiler/build.gradle",
      "compiler/src/java_plugin/cpp/java_generator.cpp",
      "compiler/src/java_plugin/cpp/java_generator.h",
      "compiler/src/java_plugin/cpp/java_plugin.cpp",
      "compiler/src/testLite/golden/TestDeprecatedService.java.txt",
      "compiler/src/testLite/golden/TestService.java.txt"
    ],
    "pr_changed_test_files": [
      "compiler/src/testLite/golden/TestDeprecatedService.java.txt",
      "compiler/src/testLite/golden/TestService.java.txt"
    ],
    "base_commit": "167a2031e29d21710e8790f72a00589fc6333d59",
    "head_commit": "34b4a083d9c928b5ca77a6cf262219dcc1646da9",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11086",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11086",
    "dockerfile": "",
    "pr_merged_at": "2024-04-19T01:34:04.000Z",
    "patch": "diff --git a/compiler/build.gradle b/compiler/build.gradle\nindex 8bed90b8678..d58d800c478 100644\n--- a/compiler/build.gradle\n+++ b/compiler/build.gradle\n@@ -192,7 +192,10 @@ protobuf {\n                 java { option 'lite' }\n             }\n             plugins {\n-                grpc { option 'lite' }\n+                grpc {\n+                    option 'lite'\n+                    option '@generated=omit'\n+                }\n             }\n         }\n     }\n\ndiff --git a/compiler/src/java_plugin/cpp/java_generator.cpp b/compiler/src/java_plugin/cpp/java_generator.cpp\nindex 00855df3d04..8693fad1b66 100644\n--- a/compiler/src/java_plugin/cpp/java_generator.cpp\n+++ b/compiler/src/java_plugin/cpp/java_generator.cpp\n@@ -1116,7 +1116,8 @@ static void PrintService(const ServiceDescriptor* service,\n                          std::map<std::string, std::string>* vars,\n                          Printer* p,\n                          ProtoFlavor flavor,\n-                         bool disable_version) {\n+                         bool disable_version,\n+                         GeneratedAnnotation generated_annotation) {\n   (*vars)[\"service_name\"] = service->name();\n   (*vars)[\"file_name\"] = service->file()->name();\n   (*vars)[\"service_class_name\"] = ServiceClassName(service);\n@@ -1129,24 +1130,17 @@ static void PrintService(const ServiceDescriptor* service,\n   // TODO(nmittler): Replace with WriteServiceDocComment once included by protobuf distro.\n   GrpcWriteServiceDocComment(p, service, NONE);\n \n-  if ((*vars)[\"JakartaMode\"] == \"javax\") {\n+  if (generated_annotation == GeneratedAnnotation::JAVAX) {\n     p->Print(\n         *vars,\n         \"@javax.annotation.Generated(\\n\"\n         \"    value = \\\"by gRPC proto compiler$grpc_version$\\\",\\n\"\n         \"    comments = \\\"Source: $file_name$\\\")\\n\"\n         \"@$GrpcGenerated$\\n\");\n-  } else if ((*vars)[\"JakartaMode\"] == \"omit\") {\n+  } else { // GeneratedAnnotation::OMIT\n     p->Print(\n         *vars,\n         \"@$GrpcGenerated$\\n\");\n-  } else {\n-    p->Print(\n-        *vars,\n-        \"@javax.annotation.Generated(\\n\"\n-        \"    value = \\\"by gRPC proto compiler$grpc_version$\\\",\\n\"\n-        \"    comments = \\\"Source: $file_name$\\\")\\n\"\n-        \"@$GrpcGenerated$\\n\");\n   }\n \n   if (service->options().deprecated()) {\n@@ -1232,7 +1226,7 @@ void GenerateService(const ServiceDescriptor* service,\n                      protobuf::io::ZeroCopyOutputStream* out,\n                      ProtoFlavor flavor,\n                      bool disable_version,\n-                     std::string jakarta_mode) {\n+                     GeneratedAnnotation generated_annotation) {\n   // All non-generated classes must be referred by fully qualified names to\n   // avoid collision with generated classes.\n   std::map<std::string, std::string> vars;\n@@ -1264,7 +1258,6 @@ void GenerateService(const ServiceDescriptor* service,\n   vars[\"MethodDescriptor\"] = \"io.grpc.MethodDescriptor\";\n   vars[\"StreamObserver\"] = \"io.grpc.stub.StreamObserver\";\n   vars[\"Iterator\"] = \"java.util.Iterator\";\n-  vars[\"JakartaMode\"] = jakarta_mode;\n   vars[\"GrpcGenerated\"] = \"io.grpc.stub.annotations.GrpcGenerated\";\n   vars[\"ListenableFuture\"] =\n       \"com.google.common.util.concurrent.ListenableFuture\";\n@@ -1283,7 +1276,7 @@ void GenerateService(const ServiceDescriptor* service,\n   if (!vars[\"Package\"].empty()) {\n     vars[\"Package\"].append(\".\");\n   }\n-  PrintService(service, &vars, &printer, flavor, disable_version);\n+  PrintService(service, &vars, &printer, flavor, disable_version, generated_annotation);\n }\n \n std::string ServiceJavaPackage(const FileDescriptor* file) {\n\ndiff --git a/compiler/src/java_plugin/cpp/java_generator.h b/compiler/src/java_plugin/cpp/java_generator.h\nindex d30179d334e..857fcab31d0 100644\n--- a/compiler/src/java_plugin/cpp/java_generator.h\n+++ b/compiler/src/java_plugin/cpp/java_generator.h\n@@ -57,6 +57,10 @@ enum ProtoFlavor {\n   NORMAL, LITE\n };\n \n+enum GeneratedAnnotation {\n+  OMIT, JAVAX\n+};\n+\n // Returns the package name of the gRPC services defined in the given file.\n std::string ServiceJavaPackage(const impl::protobuf::FileDescriptor* file);\n \n@@ -69,7 +73,7 @@ void GenerateService(const impl::protobuf::ServiceDescriptor* service,\n                      impl::protobuf::io::ZeroCopyOutputStream* out,\n                      ProtoFlavor flavor,\n                      bool disable_version,\n-                     std::string jakarta_mode);\n+                     GeneratedAnnotation generated_annotation);\n \n }  // namespace java_grpc_generator\n \n\ndiff --git a/compiler/src/java_plugin/cpp/java_plugin.cpp b/compiler/src/java_plugin/cpp/java_plugin.cpp\nindex 36f22893f63..b1f407e2a3d 100644\n--- a/compiler/src/java_plugin/cpp/java_plugin.cpp\n+++ b/compiler/src/java_plugin/cpp/java_plugin.cpp\n@@ -58,24 +58,21 @@ class JavaGrpcGenerator : public protobuf::compiler::CodeGenerator {\n \n     java_grpc_generator::ProtoFlavor flavor =\n         java_grpc_generator::ProtoFlavor::NORMAL;\n+    java_grpc_generator::GeneratedAnnotation generated_annotation =\n+        java_grpc_generator::GeneratedAnnotation::JAVAX;\n \n-    /*\n-        jakarta_mode has these values:\n-        javax, the original behavior - add @javax.annotation.Generated\n-        omit, \"less controversial\" = just add @io.grpc.stub.annotations.GrpcGenerated\n-        and maybe others in the future\n-    */\n-    std::string jakarta_mode;\n     bool disable_version = false;\n     for (size_t i = 0; i < options.size(); i++) {\n       if (options[i].first == \"lite\") {\n         flavor = java_grpc_generator::ProtoFlavor::LITE;\n       } else if (options[i].first == \"noversion\") {\n         disable_version = true;\n-      } else if (options[i].first == \"jakarta_javax\") {\n-        jakarta_mode = \"javax\";\n-      } else if (options[i].first == \"jakarta_omit\") {\n-        jakarta_mode = \"omit\";\n+      } else if (options[i].first == \"@generated\") {\n+         if (options[i].second == \"omit\") {\n+           generated_annotation = java_grpc_generator::GeneratedAnnotation::OMIT;\n+         } else if (options[i].second == \"javax\") {\n+           generated_annotation = java_grpc_generator::GeneratedAnnotation::JAVAX;\n+         }\n       }\n     }\n \n@@ -88,7 +85,7 @@ class JavaGrpcGenerator : public protobuf::compiler::CodeGenerator {\n       std::unique_ptr<protobuf::io::ZeroCopyOutputStream> output(\n           context->Open(filename));\n       java_grpc_generator::GenerateService(\n-          service, output.get(), flavor, disable_version, jakarta_mode);\n+          service, output.get(), flavor, disable_version, generated_annotation);\n     }\n     return true;\n   }\n",
    "test_patch": "diff --git a/compiler/src/testLite/golden/TestDeprecatedService.java.txt b/compiler/src/testLite/golden/TestDeprecatedService.java.txt\nindex 34b672e8319..3a7dba9bbb5 100644\n--- a/compiler/src/testLite/golden/TestDeprecatedService.java.txt\n+++ b/compiler/src/testLite/golden/TestDeprecatedService.java.txt\n@@ -7,9 +7,6 @@ import static io.grpc.MethodDescriptor.generateFullMethodName;\n  * Test service that has been deprecated and should generate with Java's &#64;Deprecated annotation\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler (version 1.64.0-SNAPSHOT)\",\n-    comments = \"Source: grpc/testing/compiler/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n @java.lang.Deprecated\n public final class TestDeprecatedServiceGrpc {\n\ndiff --git a/compiler/src/testLite/golden/TestService.java.txt b/compiler/src/testLite/golden/TestService.java.txt\nindex 4d8eddf87c4..f86fb50d7dc 100644\n--- a/compiler/src/testLite/golden/TestService.java.txt\n+++ b/compiler/src/testLite/golden/TestService.java.txt\n@@ -7,9 +7,6 @@ import static io.grpc.MethodDescriptor.generateFullMethodName;\n  * Test service that supports all call types.\n  * </pre>\n  */\n-@javax.annotation.Generated(\n-    value = \"by gRPC proto compiler (version 1.64.0-SNAPSHOT)\",\n-    comments = \"Source: grpc/testing/compiler/test.proto\")\n @io.grpc.stub.annotations.GrpcGenerated\n public final class TestServiceGrpc {\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11083",
    "pr_id": 11083,
    "issue_id": 10900,
    "repo": "grpc/grpc-java",
    "problem_statement": "Ability to propagate `cause` when using `StatusProto.toStatusException`\n<!-- Please answer these questions before submitting a feature request. -->\r\n\r\n### Is your feature request related to a problem?\r\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\r\n\r\nWhen converting a `com.google.rpc.Status` to an `io.grpc.StatusException` I can't find a way to propagate a `cause` with the resulting `StatusException`.\r\n\r\nCurrently `StatusProto.toStatusException` is defined as:\r\n\r\n```java\r\n  public static StatusException toStatusException(com.google.rpc.Status statusProto) {\r\n    return toStatus(statusProto).asException(toMetadata(statusProto));\r\n  }\r\n```\r\n\r\nHowever, using this method there doesn't seem to be any way of providing a `cause`.\r\n\r\n### Describe the solution you'd like\r\n<!-- A clear and concise description of what you want to happen. -->\r\n\r\nMy ideal would be to make `StatusProto.toStatus` public, which would allow creating the status and calling `asException` something callers could do themselves. This would also be helpful in scenarios where callers require a `Status` instead of a `StatusException`.\r\n\r\n```java\r\n  private static Status toStatus(com.google.rpc.Status statusProto) {\r\n    Status status = Status.fromCodeValue(statusProto.getCode());\r\n    checkArgument(status.getCode().value() == statusProto.getCode(), \"invalid status code\");\r\n    return status.withDescription(statusProto.getMessage());\r\n  }\r\n```\r\n\r\n### Describe alternatives you've considered\r\n<!-- A clear and concise description of any alternative solutions or features you've considered. -->\r\n\r\nIt feels a little clunky, but I'd be open to having an extra parameter on `toStatusException` for the `cause`, or another solution depending on the preferences of `grpc-java` maintainers.\r\n\r\nI've also tried calling `initCause` on the resulting StatusException, but that isn't possible because the cause is set to `null` in the `asException` code, so `initCause` throws an `IllegalArgumentException`.\r\n\r\n### Additional context\r\n<!-- Add any other context about the feature request here. -->\r\n",
    "issue_word_count": 283,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "protobuf/src/main/java/io/grpc/protobuf/StatusProto.java",
      "protobuf/src/test/java/io/grpc/protobuf/StatusProtoTest.java"
    ],
    "pr_changed_test_files": [
      "protobuf/src/test/java/io/grpc/protobuf/StatusProtoTest.java"
    ],
    "base_commit": "167a2031e29d21710e8790f72a00589fc6333d59",
    "head_commit": "bdc07587390a300f5fe3254f186f02913b6e06f5",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11083",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11083",
    "dockerfile": "",
    "pr_merged_at": "2024-04-25T01:05:54.000Z",
    "patch": "diff --git a/protobuf/src/main/java/io/grpc/protobuf/StatusProto.java b/protobuf/src/main/java/io/grpc/protobuf/StatusProto.java\nindex 988e1938af0..0ebc1e714f6 100644\n--- a/protobuf/src/main/java/io/grpc/protobuf/StatusProto.java\n+++ b/protobuf/src/main/java/io/grpc/protobuf/StatusProto.java\n@@ -103,6 +103,25 @@ public static StatusException toStatusException(\n     return toStatus(statusProto).asException(toMetadata(statusProto, metadata));\n   }\n \n+  /**\n+   * Convert a {@link com.google.rpc.Status} instance to a {@link StatusException} with additional\n+   * metadata and the root exception thrown. The exception isn't propagated over the wire.\n+   *\n+   * <p>The returned {@link StatusException} will wrap a {@link Status} whose code and description\n+   * are set from the code and message in {@code statusProto}. {@code statusProto} will be\n+   * serialized and added to {@code metadata}. {@code metadata} will be set as the metadata of the\n+   * returned {@link StatusException}. The {@link Throwable} is the exception that is set as the\n+   * {@code cause} of the returned {@link StatusException}.\n+   *\n+   * @throws IllegalArgumentException if the value of {@code statusProto.getCode()} is not a valid\n+   *     gRPC status code.\n+   * @since 1.3.0\n+   */\n+  public static StatusException toStatusException(\n+      com.google.rpc.Status statusProto, Metadata metadata, Throwable cause) {\n+    return toStatus(statusProto).withCause(cause).asException(toMetadata(statusProto, metadata));\n+  }\n+\n   private static Status toStatus(com.google.rpc.Status statusProto) {\n     Status status = Status.fromCodeValue(statusProto.getCode());\n     checkArgument(status.getCode().value() == statusProto.getCode(), \"invalid status code\");\n",
    "test_patch": "diff --git a/protobuf/src/test/java/io/grpc/protobuf/StatusProtoTest.java b/protobuf/src/test/java/io/grpc/protobuf/StatusProtoTest.java\nindex cf9c2c564ab..47c045bf952 100644\n--- a/protobuf/src/test/java/io/grpc/protobuf/StatusProtoTest.java\n+++ b/protobuf/src/test/java/io/grpc/protobuf/StatusProtoTest.java\n@@ -176,6 +176,14 @@ public void fromThrowable_shouldReturnNullIfNoEmbeddedStatus() {\n     assertNull(StatusProto.fromThrowable(nestedSe));\n   }\n \n+  @Test\n+  public void toStatusExceptionWithMetadataAndCause_shouldCaptureCause() {\n+    RuntimeException exc = new RuntimeException(\"This is a test exception.\");\n+    StatusException se = StatusProto.toStatusException(STATUS_PROTO, new Metadata(), exc);\n+\n+    assertEquals(exc, se.getCause());\n+  }\n+\n   private static final Metadata.Key<String> METADATA_KEY =\n       Metadata.Key.of(\"test-metadata\", Metadata.ASCII_STRING_MARSHALLER);\n   private static final String METADATA_VALUE = \"test metadata value\";\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11073",
    "pr_id": 11073,
    "issue_id": 3996,
    "repo": "grpc/grpc-java",
    "problem_statement": "Unexpected exceptions when server response or client request exceeds Max Message Size\nsome unexpected exceptions are seen in the server log when a server response exceeds the max message size of the client channel or vice versa. Client log does show valid errors. \r\n\r\nThis issue is consistently reproducible with a hello world rpc example where request/response is a huge string with size greater than the default message size of 4MiB.\r\n\r\n### What version of gRPC are you using?\r\n1.9.0\r\n\r\n## When server response exceeds max message size\r\n**Unexpected Exceptions in the server log:**\r\n```Jan 24, 2018 6:44:16 PM io.grpc.netty.NettyServerHandler onStreamError\r\nWARNING: Stream Error\r\nio.netty.handler.codec.http2.Http2Exception$StreamException: Stream closed before write could take place\r\n\tat io.netty.handler.codec.http2.Http2Exception.streamError(Http2Exception.java:149)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState.cancel(DefaultHttp2RemoteFlowController.java:499)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState.cancel(DefaultHttp2RemoteFlowController.java:480)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1.onStreamClosed(DefaultHttp2RemoteFlowController.java:105)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:349)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:985)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.deactivate(DefaultHttp2Connection.java:941)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2Connection$DefaultStream.close(DefaultHttp2Connection.java:497)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2Connection$DefaultStream.close(DefaultHttp2Connection.java:503)\r\n\tat io.netty.handler.codec.http2.Http2ConnectionHandler.closeStream(Http2ConnectionHandler.java:587)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onRstStreamRead(DefaultHttp2ConnectionDecoder.java:356)\r\n\tat io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onRstStreamRead(Http2InboundFrameLogger.java:80)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2FrameReader.readRstStreamFrame(DefaultHttp2FrameReader.java:516)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:260)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)\r\n\tat io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:41)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:118)\r\n\tat io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:388)\r\n\tat io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:448)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)\r\n\tat io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n```\r\n\r\n**Client log:**\r\n```Jan 24, 2018 6:44:15 PM io.grpc.examples.helloworld.HelloWorldClient greet\r\nINFO: Will try to greet  ...\r\nJan 24, 2018 6:44:16 PM io.grpc.internal.AbstractClientStream$TransportState inboundDataReceived\r\nINFO: Received data on closed stream\r\nJan 24, 2018 6:44:16 PM io.grpc.internal.AbstractClientStream$TransportState inboundDataReceived\r\nINFO: Received data on closed stream\r\nJan 24, 2018 6:44:16 PM io.grpc.internal.AbstractClientStream$TransportState inboundDataReceived\r\nINFO: Received data on closed stream\r\nJan 24, 2018 6:44:16 PM io.grpc.internal.AbstractClientStream$TransportState inboundDataReceived\r\nINFO: Received data on closed stream\r\nJan 24, 2018 6:44:16 PM io.grpc.internal.AbstractClientStream$TransportState inboundDataReceived\r\nINFO: Received data on closed stream\r\nJan 24, 2018 6:44:16 PM io.grpc.examples.helloworld.HelloWorldClient greet\r\nWARNING: RPC failed: Status{code=RESOURCE_EXHAUSTED, description=io.grpc.netty.NettyClientTransport$3: Frame size 59000005 exceeds maximum: 4194304. , cause=null}\r\nJan 24, 2018 6:44:16 PM io.grpc.internal.AbstractClientStream$TransportState inboundDataReceived\r\nINFO: Received data on closed stream\r\nJan 24, 2018 6:44:16 PM io.grpc.internal.AbstractClientStream$TransportState inboundDataReceived\r\nINFO: Received data on closed stream\r\n```\r\n\r\n## When client request exceeds max message size \r\n**Valid exception, followed by some unexpected exception in server log**\r\n```Jan 24, 2018 6:54:21 PM io.grpc.netty.NettyServerStream$TransportState deframeFailed\r\nWARNING: Exception processing message\r\nio.grpc.StatusRuntimeException: RESOURCE_EXHAUSTED: io.grpc.netty.NettyServerStream$TransportState: Frame size 59000005 exceeds maximum: 4194304. \r\n\tat io.grpc.Status.asRuntimeException(Status.java:517)\r\n\tat io.grpc.internal.MessageDeframer.processHeader(MessageDeframer.java:391)\r\n\tat io.grpc.internal.MessageDeframer.deliver(MessageDeframer.java:271)\r\n\tat io.grpc.internal.MessageDeframer.request(MessageDeframer.java:165)\r\n\tat io.grpc.internal.AbstractStream$TransportState.requestMessagesFromDeframer(AbstractStream.java:202)\r\n\tat io.grpc.netty.NettyServerStream$Sink$1.run(NettyServerStream.java:100)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)\r\n\tat io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n\r\nJan 24, 2018 6:54:21 PM io.grpc.netty.NettyServerHandler onStreamError\r\nWARNING: Stream Error\r\nio.netty.handler.codec.http2.Http2Exception$StreamException: Received DATA frame for an unknown stream 3\r\n\tat io.netty.handler.codec.http2.Http2Exception.streamError(Http2Exception.java:129)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.shouldIgnoreHeadersOrDataFrame(DefaultHttp2ConnectionDecoder.java:535)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onDataRead(DefaultHttp2ConnectionDecoder.java:187)\r\n\tat io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onDataRead(Http2InboundFrameLogger.java:48)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2FrameReader.readDataFrame(DefaultHttp2FrameReader.java:421)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:251)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)\r\n\tat io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:41)\r\n\tat io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:118)\r\n\tat io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:388)\r\n\tat io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:448)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:134)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)\r\n\tat io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n```\r\n\r\n**Client log:**\r\n```\r\nException in thread \"main\" io.grpc.StatusRuntimeException: CANCELLED: HTTP/2 error code: CANCEL\r\nReceived Rst Stream\r\n\tat io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:221)\r\n\tat io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:202)\r\n\tat io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:131)\r\n\tat io.grpc.examples.helloworld.GreeterGrpc$GreeterBlockingStub.sayHello(GreeterGrpc.java:160)\r\n\tat io.grpc.examples.helloworld.HelloWorldClient.greet(HelloWorldClient.java:60)\r\n\tat io.grpc.examples.helloworld.HelloWorldClient.main(HelloWorldClient.java:77)\r\n```",
    "issue_word_count": 1274,
    "test_files_count": 2,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "netty/src/main/java/io/grpc/netty/CancelServerStreamCommand.java",
      "netty/src/main/java/io/grpc/netty/NettyServerHandler.java",
      "netty/src/main/java/io/grpc/netty/NettyServerStream.java",
      "netty/src/test/java/io/grpc/netty/NettyServerHandlerTest.java",
      "netty/src/test/java/io/grpc/netty/NettyServerStreamTest.java"
    ],
    "pr_changed_test_files": [
      "netty/src/test/java/io/grpc/netty/NettyServerHandlerTest.java",
      "netty/src/test/java/io/grpc/netty/NettyServerStreamTest.java"
    ],
    "base_commit": "11612b484a24575b3eb64c0641f313cf3054dc1f",
    "head_commit": "fc49d80ccad9f2eb376f513e25b4951a2a352fea",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11073",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11073",
    "dockerfile": "",
    "pr_merged_at": "2024-04-24T21:37:38.000Z",
    "patch": "diff --git a/netty/src/main/java/io/grpc/netty/CancelServerStreamCommand.java b/netty/src/main/java/io/grpc/netty/CancelServerStreamCommand.java\nindex d9f5d96e06e..d49e3bd672b 100644\n--- a/netty/src/main/java/io/grpc/netty/CancelServerStreamCommand.java\n+++ b/netty/src/main/java/io/grpc/netty/CancelServerStreamCommand.java\n@@ -27,10 +27,23 @@\n final class CancelServerStreamCommand extends WriteQueue.AbstractQueuedCommand {\n   private final NettyServerStream.TransportState stream;\n   private final Status reason;\n+  private final PeerNotify peerNotify;\n \n-  CancelServerStreamCommand(NettyServerStream.TransportState stream, Status reason) {\n+  private CancelServerStreamCommand(\n+          NettyServerStream.TransportState stream, Status reason, PeerNotify peerNotify) {\n     this.stream = Preconditions.checkNotNull(stream, \"stream\");\n     this.reason = Preconditions.checkNotNull(reason, \"reason\");\n+    this.peerNotify = Preconditions.checkNotNull(peerNotify, \"peerNotify\");\n+  }\n+\n+  static CancelServerStreamCommand withReset(\n+          NettyServerStream.TransportState stream, Status reason) {\n+    return new CancelServerStreamCommand(stream, reason, PeerNotify.RESET);\n+  }\n+\n+  static CancelServerStreamCommand withReason(\n+          NettyServerStream.TransportState stream, Status reason) {\n+    return new CancelServerStreamCommand(stream, reason, PeerNotify.BEST_EFFORT_STATUS);\n   }\n \n   NettyServerStream.TransportState stream() {\n@@ -41,6 +54,10 @@ Status reason() {\n     return reason;\n   }\n \n+  boolean wantsHeaders() {\n+    return peerNotify == PeerNotify.BEST_EFFORT_STATUS;\n+  }\n+\n   @Override\n   public boolean equals(Object o) {\n     if (this == o) {\n@@ -68,4 +85,11 @@ public String toString() {\n         .add(\"reason\", reason)\n         .toString();\n   }\n+\n+  private enum PeerNotify {\n+    /** Notify the peer by sending a RST_STREAM with no other information. */\n+    RESET,\n+    /** Notify the peer about the {@link #reason} by sending structured headers, if possible. */\n+    BEST_EFFORT_STATUS,\n+  }\n }\n\ndiff --git a/netty/src/main/java/io/grpc/netty/NettyServerHandler.java b/netty/src/main/java/io/grpc/netty/NettyServerHandler.java\nindex 77b448446b1..a6e855a199d 100644\n--- a/netty/src/main/java/io/grpc/netty/NettyServerHandler.java\n+++ b/netty/src/main/java/io/grpc/netty/NettyServerHandler.java\n@@ -788,9 +788,37 @@ private void cancelStream(ChannelHandlerContext ctx, CancelServerStreamCommand c\n       PerfMark.linkIn(cmd.getLink());\n       // Notify the listener if we haven't already.\n       cmd.stream().transportReportStatus(cmd.reason());\n-      // Terminate the stream.\n-      encoder().writeRstStream(ctx, cmd.stream().id(), Http2Error.CANCEL.code(), promise);\n+\n+      // Now we need to decide how we're going to notify the peer that this stream is closed.\n+      // If possible, it's nice to inform the peer _why_ this stream was cancelled by sending\n+      // a structured headers frame.\n+      if (shouldCloseStreamWithHeaders(cmd, connection())) {\n+        Metadata md = new Metadata();\n+        md.put(InternalStatus.CODE_KEY, cmd.reason());\n+        if (cmd.reason().getDescription() != null) {\n+          md.put(InternalStatus.MESSAGE_KEY, cmd.reason().getDescription());\n+        }\n+        Http2Headers headers = Utils.convertServerHeaders(md);\n+        encoder().writeHeaders(\n+            ctx, cmd.stream().id(), headers, /* padding = */ 0, /* endStream = */ true, promise);\n+      } else {\n+        // Terminate the stream.\n+        encoder().writeRstStream(ctx, cmd.stream().id(), Http2Error.CANCEL.code(), promise);\n+      }\n+    }\n+  }\n+\n+  // Determine whether a CancelServerStreamCommand should try to close the stream with a\n+  // HEADERS or a RST_STREAM frame. The caller has some influence over this (they can\n+  // configure cmd.wantsHeaders()). The state of the stream also has an influence: we\n+  // only try to send HEADERS if the stream exists and hasn't already sent any headers.\n+  private static boolean shouldCloseStreamWithHeaders(\n+          CancelServerStreamCommand cmd, Http2Connection conn) {\n+    if (!cmd.wantsHeaders()) {\n+      return false;\n     }\n+    Http2Stream stream = conn.stream(cmd.stream().id());\n+    return stream != null && !stream.isHeadersSent();\n   }\n \n   private void gracefulClose(final ChannelHandlerContext ctx, final GracefulServerCloseCommand msg,\n\ndiff --git a/netty/src/main/java/io/grpc/netty/NettyServerStream.java b/netty/src/main/java/io/grpc/netty/NettyServerStream.java\nindex a4304d5193e..836f39ddf19 100644\n--- a/netty/src/main/java/io/grpc/netty/NettyServerStream.java\n+++ b/netty/src/main/java/io/grpc/netty/NettyServerStream.java\n@@ -130,7 +130,7 @@ public void writeTrailers(Metadata trailers, boolean headersSent, Status status)\n     @Override\n     public void cancel(Status status) {\n       try (TaskCloseable ignore = PerfMark.traceTask(\"NettyServerStream$Sink.cancel\")) {\n-        writeQueue.enqueue(new CancelServerStreamCommand(transportState(), status), true);\n+        writeQueue.enqueue(CancelServerStreamCommand.withReset(transportState(), status), true);\n       }\n     }\n   }\n@@ -189,7 +189,7 @@ public void deframeFailed(Throwable cause) {\n       log.log(Level.WARNING, \"Exception processing message\", cause);\n       Status status = Status.fromThrowable(cause);\n       transportReportStatus(status);\n-      handler.getWriteQueue().enqueue(new CancelServerStreamCommand(this, status), true);\n+      handler.getWriteQueue().enqueue(CancelServerStreamCommand.withReason(this, status), true);\n     }\n \n     private void onWriteFrameData(ChannelFuture future, int numMessages, int numBytes) {\n@@ -222,7 +222,7 @@ private void handleWriteFutureFailures(ChannelFuture future) {\n      */\n     protected void http2ProcessingFailed(Status status) {\n       transportReportStatus(status);\n-      handler.getWriteQueue().enqueue(new CancelServerStreamCommand(this, status), true);\n+      handler.getWriteQueue().enqueue(CancelServerStreamCommand.withReset(this, status), true);\n     }\n \n     void inboundDataReceived(ByteBuf frame, boolean endOfStream) {\n",
    "test_patch": "diff --git a/netty/src/test/java/io/grpc/netty/NettyServerHandlerTest.java b/netty/src/test/java/io/grpc/netty/NettyServerHandlerTest.java\nindex 281ff3b17d6..ce902a9620b 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyServerHandlerTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyServerHandlerTest.java\n@@ -89,8 +89,10 @@\n import java.io.InputStream;\n import java.nio.channels.ClosedChannelException;\n import java.util.Arrays;\n+import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Queue;\n import java.util.concurrent.TimeUnit;\n import org.junit.Before;\n@@ -469,11 +471,41 @@ public void connectionWindowShouldBeOverridden() throws Exception {\n   public void cancelShouldSendRstStream() throws Exception {\n     manualSetUp();\n     createStream();\n-    enqueue(new CancelServerStreamCommand(stream.transportState(), Status.DEADLINE_EXCEEDED));\n+    enqueue(CancelServerStreamCommand.withReset(stream.transportState(), Status.DEADLINE_EXCEEDED));\n     verifyWrite().writeRstStream(eq(ctx()), eq(stream.transportState().id()),\n         eq(Http2Error.CANCEL.code()), any(ChannelPromise.class));\n   }\n \n+  @Test\n+  public void cancelWithNotify_shouldSendHeaders() throws Exception {\n+    manualSetUp();\n+    createStream();\n+\n+    enqueue(CancelServerStreamCommand.withReason(\n+            stream.transportState(),\n+            Status.RESOURCE_EXHAUSTED.withDescription(\"my custom description\")\n+    ));\n+\n+    ArgumentCaptor<Http2Headers> captor = ArgumentCaptor.forClass(Http2Headers.class);\n+    verifyWrite()\n+            .writeHeaders(\n+                    eq(ctx()),\n+                    eq(STREAM_ID),\n+                    captor.capture(),\n+                    eq(0),\n+                    eq(true),\n+                    any(ChannelPromise.class));\n+\n+    // For arcane reasons, the specific implementation of Http2Headers here doesn't actually support\n+    // methods like `get(...)`, so we have to manually convert it into a map.\n+    Map<String, String> actualHeaders = new HashMap<>();\n+    for (Map.Entry<CharSequence, CharSequence> entry : captor.getValue()) {\n+      actualHeaders.put(entry.getKey().toString(), entry.getValue().toString());\n+    }\n+    assertEquals(\"8\", actualHeaders.get(InternalStatus.CODE_KEY.name()));\n+    assertEquals(\"my custom description\", actualHeaders.get(InternalStatus.MESSAGE_KEY.name()));\n+  }\n+\n   @Test\n   public void headersWithInvalidContentTypeShouldFail() throws Exception {\n     manualSetUp();\n\ndiff --git a/netty/src/test/java/io/grpc/netty/NettyServerStreamTest.java b/netty/src/test/java/io/grpc/netty/NettyServerStreamTest.java\nindex ab54d4e4e22..452f68341b1 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyServerStreamTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyServerStreamTest.java\n@@ -18,7 +18,6 @@\n \n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth.assertWithMessage;\n-import static io.grpc.internal.GrpcUtil.DEFAULT_MAX_MESSAGE_SIZE;\n import static io.grpc.netty.NettyTestUtil.messageFrame;\n import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;\n import static io.netty.handler.codec.http2.Http2Exception.connectionError;\n@@ -37,6 +36,7 @@\n import static org.mockito.Mockito.verifyNoMoreInteractions;\n import static org.mockito.Mockito.when;\n \n+import com.google.common.base.Strings;\n import com.google.common.collect.ImmutableListMultimap;\n import com.google.common.collect.ListMultimap;\n import io.grpc.Attributes;\n@@ -73,6 +73,8 @@\n /** Unit tests for {@link NettyServerStream}. */\n @RunWith(JUnit4.class)\n public class NettyServerStreamTest extends NettyStreamTestBase<NettyServerStream> {\n+  private static final int TEST_MAX_MESSAGE_SIZE = 128;\n+\n   @Mock\n   protected ServerStreamListener serverListener;\n \n@@ -380,10 +382,31 @@ public void emptyFramerShouldSendNoPayload() {\n   public void cancelStreamShouldSucceed() {\n     stream().cancel(Status.DEADLINE_EXCEEDED);\n     verify(writeQueue).enqueue(\n-        new CancelServerStreamCommand(stream().transportState(), Status.DEADLINE_EXCEEDED),\n+        CancelServerStreamCommand.withReset(stream().transportState(), Status.DEADLINE_EXCEEDED),\n         true);\n   }\n \n+  @Test\n+  public void oversizedMessagesResultInResourceExhaustedTrailers() throws Exception {\n+    @SuppressWarnings(\"InlineMeInliner\") // Requires Java 11\n+    String oversizedMsg = Strings.repeat(\"a\", TEST_MAX_MESSAGE_SIZE + 1);\n+    stream.request(1);\n+    stream.transportState().inboundDataReceived(messageFrame(oversizedMsg), false);\n+    assertNull(\"message should have caused a deframer error\", listenerMessageQueue().poll());\n+\n+    ArgumentCaptor<CancelServerStreamCommand> cancelCmdCap =\n+            ArgumentCaptor.forClass(CancelServerStreamCommand.class);\n+    verify(writeQueue).enqueue(cancelCmdCap.capture(), eq(true));\n+\n+    Status status = Status.RESOURCE_EXHAUSTED\n+            .withDescription(\"gRPC message exceeds maximum size 128: 129\");\n+\n+    CancelServerStreamCommand actualCmd = cancelCmdCap.getValue();\n+    assertThat(actualCmd.reason().getCode()).isEqualTo(status.getCode());\n+    assertThat(actualCmd.reason().getDescription()).isEqualTo(status.getDescription());\n+    assertThat(actualCmd.wantsHeaders()).isTrue();\n+  }\n+\n   @Override\n   @SuppressWarnings(\"DirectInvocationOnMock\")\n   protected NettyServerStream createStream() {\n@@ -391,7 +414,7 @@ protected NettyServerStream createStream() {\n     StatsTraceContext statsTraceCtx = StatsTraceContext.NOOP;\n     TransportTracer transportTracer = new TransportTracer();\n     NettyServerStream.TransportState state = new NettyServerStream.TransportState(\n-        handler, channel.eventLoop(), http2Stream, DEFAULT_MAX_MESSAGE_SIZE, statsTraceCtx,\n+        handler, channel.eventLoop(), http2Stream, TEST_MAX_MESSAGE_SIZE, statsTraceCtx,\n         transportTracer, \"method\");\n     NettyServerStream stream = new NettyServerStream(channel, state, Attributes.EMPTY,\n         \"test-authority\", statsTraceCtx);\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11054",
    "pr_id": 11054,
    "issue_id": 11053,
    "repo": "grpc/grpc-java",
    "problem_statement": "OkHttp stream leak when hitting MAX_CONCURRENT_STREAMS\n<!-- Please answer these questions before submitting a bug report. -->\r\n\r\n### What version of gRPC-Java are you using?\r\n1.60.0\r\n\r\n### What is your environment?\r\nmacOS Monterey, JDK 17\r\n\r\n### What did you expect to see?\r\nI expect okhttp finished stream to be removed from the inUseState even if pending streams are being started\r\n\r\n### What did you see instead?\r\nRemoval of finished stream is conditional to the start or not of pending streams : https://github.com/grpc/grpc-java/blob/569b426d6287f4d9f18b1435bb5c5819b526a7a6/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java#L956\r\n\r\n### Steps to reproduce the bug\r\nhttps://github.com/grpc/grpc-java/commit/2333097a4dabf438a0e51f5f69e1f969b314a972\r\n\r\n",
    "issue_word_count": 108,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java",
      "okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java"
    ],
    "pr_changed_test_files": [
      "okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java"
    ],
    "base_commit": "097a46b76171eb83f045c4c88d650dd833a7fa88",
    "head_commit": "19f970f8789c0c706b4185eaa5d253d3e1d3a039",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11054",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11054",
    "dockerfile": "",
    "pr_merged_at": "2024-03-29T17:00:32.000Z",
    "patch": "diff --git a/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java b/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java\nindex 3b9513eeb47..29d3dbc1cdf 100644\n--- a/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java\n+++ b/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java\n@@ -953,8 +953,8 @@ void finishStream(\n         }\n         if (!startPendingStreams()) {\n           stopIfNecessary();\n-          maybeClearInUse(stream);\n         }\n+        maybeClearInUse(stream);\n       }\n     }\n   }\n",
    "test_patch": "diff --git a/okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java b/okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java\nindex 7347399bfe5..ab7dff98444 100644\n--- a/okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java\n+++ b/okhttp/src/test/java/io/grpc/okhttp/OkHttpClientTransportTest.java\n@@ -2080,6 +2080,26 @@ public void shutdownNow_streamListenerRpcProgress() throws Exception {\n     assertEquals(MISCARRIED, listener3.rpcProgress);\n   }\n \n+  @Test\n+  public void finishedStreamRemovedFromInUseState() throws Exception {\n+    initTransport();\n+    setMaxConcurrentStreams(1);\n+    final MockStreamListener listener = new MockStreamListener();\n+    OkHttpClientStream stream =\n+        clientTransport.newStream(method, new Metadata(), CallOptions.DEFAULT, tracers);\n+    stream.start(listener);\n+    OkHttpClientStream pendingStream =\n+        clientTransport.newStream(method, new Metadata(), CallOptions.DEFAULT, tracers);\n+    pendingStream.start(listener);\n+    waitForStreamPending(1);\n+    clientTransport.finishStream(stream.transportState().id(), Status.OK, PROCESSED,\n+        false, null, null);\n+    verify(transportListener).transportInUse(true);\n+    clientTransport.finishStream(pendingStream.transportState().id(), Status.OK, PROCESSED,\n+        false, null, null);\n+    verify(transportListener).transportInUse(false);\n+  }\n+\n   private int activeStreamCount() {\n     return clientTransport.getActiveStreams().length;\n   }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11052",
    "pr_id": 11052,
    "issue_id": 10810,
    "repo": "grpc/grpc-java",
    "problem_statement": "xDS with TrafficDirector and spiffe: CertificateException: no name matching foo.bar found\ngrpc_java version 1.60.0\r\n\r\nHello,\r\n\r\nI'm trying to get traffic director to provide security configuration to a client but I am encountering a failure in checkServerTrusted of XdsX509TrustManager https://github.com/grpc/grpc-java/blob/v1.60.0/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java#L244\r\nbecause the target hostname does not match the SAN (spiffe id) in the server cert.  I am wondering if the problem lies with the config from TD or with the client.\r\n\r\n\r\nhere is a snippet of the java code, written using the xds example in this repo:\r\n\r\n```java\r\nvar credentials = XdsChannelCredentials.create(InsecureChannelCredentials.create());\r\nvar channel = Grpc.newChannelBuilder(\"xds:///foo.bar:8443\", credentials);\r\nvar blockingStub = FooGrpc.newBlockingStub(channel);\r\nblockingStub.sayHello(\"world\")\r\n```\r\n\r\nstack trace: \r\n```\r\nCaused by java.security.cert.CertificateException: No name matching foo.bar found\r\n  at java.base/sun.security.util.HostnameChecker.matchDNS(HostnameChecker.java:229)\r\n  at java.base/sun.security.util.HostnameChecker.match(HostnameChecker.java:103)\r\n  at java.base/sun.security.ssl.X509TrustManagerImpl.checkIdentity(X509TrustManagerImpl.java:457)\r\n  at java.base/sun.security.ssl.X509TrustManagerImpl.checkIdentity(X509TrustManagerImpl.java:417)\r\n  at java.base/sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:291)\r\n  at java.base/sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:144)\r\n  at io.grpc.xds.internal.security.trust.XdsX509TrustManager.checkServerTrusted(XdsX509TrustManager.java:244)\r\n  at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.checkServerCerts(CertificateMessage.java:1296)\r\n```\r\n\r\nand this is xds config traffic director is giving the client:\r\n```json\r\n{\r\n  \"config\": [\r\n    {\r\n      \"node\": {\r\n        \"id\": \"projects/1337/networks/mesh:foo-mesh/nodes/1338\",\r\n        \"metadata\": {\r\n          \"INSTANCE_IP\": \"0.0.0.0\",\r\n          \"TRAFFICDIRECTOR_GCP_PROJECT_NUMBER\": \"1337\",\r\n          \"TRAFFICDIRECTOR_MESH_NAME\": \"foo-mesh\",\r\n          \"TRAFFICDIRECTOR_NETWORK_NAME\": \"foo-network\",\r\n          \"XDS_STREAM_TYPE\": \"ADS\"\r\n        },\r\n        \"locality\": {\r\n          \"zone\": \"ib\"\r\n        },\r\n        \"userAgentName\": \"gRPC Java\",\r\n        \"userAgentVersion\": \"\"\r\n      },\r\n      \"xdsConfig\": [\r\n        {\r\n          \"status\": \"SYNCED\",\r\n          \"clusterConfig\": {\r\n            \"dynamicActiveClusters\": [\r\n              {\r\n                \"cluster\": {\r\n                  \"@type\": \"type.googleapis.com/envoy.config.cluster.v3.Cluster\",\r\n                  \"name\": \"cloud-internal-istio:cloud_mp_7555213123_1231234123\",\r\n                  \"altStatName:\": \"/projects/1339/global/backendServices/foo-bar-td-backendsvc\",\r\n                  \"type\": \"EDS\",\r\n                  \"edsClusterConfig\": {\r\n                    \"edsConfig\": {\r\n                      \"ads\": {},\r\n                      \"initialFetchTimeout\": \"15s\",\r\n                      \"resourceApiVersion\": \"V3\"\r\n                    }\r\n                  },\r\n                  \"connectTimeout\": \"30s\",\r\n                  \"http2ProtocolOptions\": {\r\n                    \"maxConcurrentStreams\": 100\r\n                  },\r\n                  \"transportSocket\": {\r\n                    \"name\": \"envoy.transport_sockets.tls\",\r\n                    \"typedConfig\": {\r\n                      \"@type\": \"\",\r\n                      \"commonTlsContext\": {\r\n                        \"tlsCertificateSdsSecretConfigs\": [\r\n                          {\r\n                            \"name\": \"tls_sds\",\r\n                            \"sdsConfig\": {\r\n                              \"path\": \"/etc/envoy/tls_certificate_context_sds_secret.yaml\"\r\n                            }\r\n                          }\r\n                        ],\r\n                        \"tlsCertificateCertificateProviderInstance\": {\r\n                          \"instanceName\": \"google_cloud_private_spiffe\",\r\n                          \"certificateName\": \"DEFAULT\"\r\n                        },\r\n                        \"combinedValidationContext\": {\r\n                          \"defaultValidationContext\": {\r\n                            \"matchSubjectAltNames\": [\r\n                              {\r\n                                \"exact\": \"spiffe://foo.svc.id.goog/ns/bar/sa/foo\"\r\n                              }\r\n                            ]\r\n                          },\r\n                          \"validationContextSdsSecretConfig\": {\r\n                            \"name\": \"validation_context_sds\",\r\n                            \"sdsConfig\": {\r\n                              \"path\": \"/etc/envoy/tls_certificate_context_sds_secret.yaml\"\r\n                            }\r\n                          },\r\n                          \"validationContextCertificateProviderInstance\": {\r\n                            \"instanceName\": \"google_cloud_private_spiffe\",\r\n                            \"certificateName\": \"ROOTCA\"\r\n                          }\r\n                        },\r\n                        \"alpnProtocols\": [\r\n                          \"h2\"\r\n                        ]\r\n                      }\r\n                    }\r\n                  },\r\n                  \"metadata\": {\r\n                    \"filterMetadata\": {\r\n                      \"com.google.trafficdirector\": {\r\n                        \"backend_service_name\": \"foo-bar-td-backendsvc\",\r\n                        \"backend_service_project_number\": 1339\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            ]\r\n          }\r\n        },\r\n        {\r\n          \"status\": \"SYNCED\",\r\n          \"listenerConfig\": {\r\n            \"dynamicListeners\": [\r\n              {\r\n                \"activeState\": {\r\n                  \"listener\": {\r\n                    \"@type\": \"type.googleapis.com/envoy.config.listener.v3.Listener\",\r\n                    \"name\": \"foo.bar:8443\",\r\n                    \"apiListener\": {\r\n                      \"apiListener\": {\r\n                        \"@type\": \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\",\r\n                        \"statPrefix\": \"trafficdirector\",\r\n                        \"rds\": {\r\n                          \"configSource\": {\r\n                            \"ads\": {},\r\n                            \"resourceApiVersion\": \"V3\"\r\n                          },\r\n                          \"routeConfigName\": \"projects/1339/locations/global/grpcRoutes/foo-bar-td-grpcroute_foo_bar:8443\"\r\n                        },\r\n                        \"httpFilters\": [\r\n                          {\r\n                            \"name\": \"envoy.filters.http.fault\",\r\n                            \"typedConfig\": {\r\n                              \"@type\": \"type.googleapis.com/envoy.extensions.filters.http.fault.v3.HTTPFault\"\r\n                            }\r\n                          },\r\n                          {\r\n                            \"name\": \"envoy.filters.http.router\",\r\n                            \"typedConfig\": {\r\n                              \"@type\": \"type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\",\r\n                              \"suppressEnvoyHeaders\": true\r\n                            }\r\n                          }\r\n                        ]\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            ]\r\n          }\r\n        },\r\n        {\r\n          \"status\": \"SYNCED\",\r\n          \"routeConfig\": {\r\n            \"dynamicRouteConfigs\": {\r\n              \"routeConfig\": {\r\n                \"@type\": \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\",\r\n                \"name\": \"projects/1339/locations/global/grpcRoutes/foo-bar-td-grpcroute_foo_bar:8443\",\r\n                \"virtualHosts\": [\r\n                  {\r\n                    \"domains\": [\r\n                      \"foo.bar:8443\"\r\n                    ],\r\n                    \"routes\": [\r\n                      {\r\n                        \"match\": {\r\n                          \"prefix\": \"\"\r\n                        },\r\n                        \"route\": {\r\n                          \"cluster\": \"cloud-internal-istio:cloud_mp_7555213123_1231234123\"\r\n                        }\r\n                      }\r\n                    ]\r\n                  }\r\n                ]\r\n              }\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n\r\nI should mention also TD is being configured via a [NetworkSecurityClientTLSPolicy](https://cloud.google.com/config-connector/docs/reference/resource-docs/networksecurity/networksecurityclienttlspolicy) attached to a ComputeBackendService as documented here: https://cloud.google.com/traffic-director/docs/security-overview#:~:text=A%20client%20TLS%20policy%20lets,a%20global%20backend%20service%20resource.\r\n\r\nI've tried adding the spiffe id as an subjectAltName to the computebackend service which does appear in the xds config under defaultValidationContext but iiuc that isnt used until verifySubjectAltNameInChain in https://github.com/grpc/grpc-java/blob/v1.60.0/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java#L245\r\n \r\n\r\nThanks",
    "issue_word_count": 623,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java",
      "xds/src/test/java/io/grpc/xds/internal/security/trust/XdsX509TrustManagerTest.java"
    ],
    "pr_changed_test_files": [
      "xds/src/test/java/io/grpc/xds/internal/security/trust/XdsX509TrustManagerTest.java"
    ],
    "base_commit": "569b426d6287f4d9f18b1435bb5c5819b526a7a6",
    "head_commit": "e216c8a4e5d047024a3ee129620583657c2745cc",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11052",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11052",
    "dockerfile": "",
    "pr_merged_at": "2024-03-28T23:58:49.000Z",
    "patch": "diff --git a/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java b/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java\nindex d5c6c174f04..6181d70fa51 100644\n--- a/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java\n+++ b/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java\n@@ -229,7 +229,7 @@ public void checkServerTrusted(X509Certificate[] chain, String authType, Socket\n       SSLSocket sslSocket = (SSLSocket) socket;\n       SSLParameters sslParams = sslSocket.getSSLParameters();\n       if (sslParams != null) {\n-        sslParams.setEndpointIdentificationAlgorithm(null);\n+        sslParams.setEndpointIdentificationAlgorithm(\"\");\n         sslSocket.setSSLParameters(sslParams);\n       }\n     }\n@@ -242,7 +242,7 @@ public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngi\n       throws CertificateException {\n     SSLParameters sslParams = sslEngine.getSSLParameters();\n     if (sslParams != null) {\n-      sslParams.setEndpointIdentificationAlgorithm(null);\n+      sslParams.setEndpointIdentificationAlgorithm(\"\");\n       sslEngine.setSSLParameters(sslParams);\n     }\n     delegate.checkServerTrusted(chain, authType, sslEngine);\n",
    "test_patch": "diff --git a/xds/src/test/java/io/grpc/xds/internal/security/trust/XdsX509TrustManagerTest.java b/xds/src/test/java/io/grpc/xds/internal/security/trust/XdsX509TrustManagerTest.java\nindex 08512396a4f..9ceb6f706fe 100644\n--- a/xds/src/test/java/io/grpc/xds/internal/security/trust/XdsX509TrustManagerTest.java\n+++ b/xds/src/test/java/io/grpc/xds/internal/security/trust/XdsX509TrustManagerTest.java\n@@ -534,6 +534,7 @@ public void checkServerTrustedSslEngine()\n         CertificateUtils.toX509Certificates(TlsTesting.loadCert(SERVER_1_PEM_FILE));\n     trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslEngine);\n     verify(sslEngine, times(1)).getHandshakeSession();\n+    assertThat(sslEngine.getSSLParameters().getEndpointIdentificationAlgorithm()).isEmpty();\n   }\n \n   @Test\n@@ -561,6 +562,7 @@ public void checkServerTrustedSslSocket()\n     trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslSocket);\n     verify(sslSocket, times(1)).isConnected();\n     verify(sslSocket, times(1)).getHandshakeSession();\n+    assertThat(sslSocket.getSSLParameters().getEndpointIdentificationAlgorithm()).isEmpty();\n   }\n \n   @Test\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11049",
    "pr_id": 11049,
    "issue_id": 10372,
    "repo": "grpc/grpc-java",
    "problem_statement": "Compatibility with errorprone 2.19+ / StringCaseLocaleUsage\n<details>\r\n<summary>main</summary>\r\n\r\n```java\r\n> Task :grpc-xds:compileJava\r\n/Users/sergiitk/Development/grpc-java/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java:100: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n        ? altNameFromCert.toLowerCase().startsWith(sanToVerifyPrefix.toLowerCase())\r\n                                     ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '? altNameFromCert.toLowerCase(Locale.ROOT).startsWith(sanToVerifyPrefix.toLowerCase())' or '? altNameFromCert.toLowerCase(Locale.getDefault()).startsWith(sanToVerifyPrefix.toLowerCase())' or '? Ascii.toLowerCase(altNameFromCert).startsWith(sanToVerifyPrefix.toLowerCase())'?\r\n/Users/sergiitk/Development/grpc-java/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java:100: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n        ? altNameFromCert.toLowerCase().startsWith(sanToVerifyPrefix.toLowerCase())\r\n                                                                                ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '? altNameFromCert.toLowerCase().startsWith(sanToVerifyPrefix.toLowerCase(Locale.ROOT))' or '? altNameFromCert.toLowerCase().startsWith(sanToVerifyPrefix.toLowerCase(Locale.getDefault()))' or '? altNameFromCert.toLowerCase().startsWith(Ascii.toLowerCase(sanToVerifyPrefix))'?\r\n/Users/sergiitk/Development/grpc-java/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java:110: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n            ? altNameFromCert.toLowerCase().endsWith(sanToVerifySuffix.toLowerCase())\r\n                                         ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '? altNameFromCert.toLowerCase(Locale.ROOT).endsWith(sanToVerifySuffix.toLowerCase())' or '? altNameFromCert.toLowerCase(Locale.getDefault()).endsWith(sanToVerifySuffix.toLowerCase())' or '? Ascii.toLowerCase(altNameFromCert).endsWith(sanToVerifySuffix.toLowerCase())'?\r\n/Users/sergiitk/Development/grpc-java/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java:110: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n            ? altNameFromCert.toLowerCase().endsWith(sanToVerifySuffix.toLowerCase())\r\n                                                                                  ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '? altNameFromCert.toLowerCase().endsWith(sanToVerifySuffix.toLowerCase(Locale.ROOT))' or '? altNameFromCert.toLowerCase().endsWith(sanToVerifySuffix.toLowerCase(Locale.getDefault()))' or '? altNameFromCert.toLowerCase().endsWith(Ascii.toLowerCase(sanToVerifySuffix))'?\r\n/Users/sergiitk/Development/grpc-java/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java:120: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n            ? altNameFromCert.toLowerCase().contains(sanToVerifySubstring.toLowerCase())\r\n                                         ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '? altNameFromCert.toLowerCase(Locale.ROOT).contains(sanToVerifySubstring.toLowerCase())' or '? altNameFromCert.toLowerCase(Locale.getDefault()).contains(sanToVerifySubstring.toLowerCase())' or '? Ascii.toLowerCase(altNameFromCert).contains(sanToVerifySubstring.toLowerCase())'?\r\n/Users/sergiitk/Development/grpc-java/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java:120: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n            ? altNameFromCert.toLowerCase().contains(sanToVerifySubstring.toLowerCase())\r\n                                                                                     ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '? altNameFromCert.toLowerCase().contains(sanToVerifySubstring.toLowerCase(Locale.ROOT))' or '? altNameFromCert.toLowerCase().contains(sanToVerifySubstring.toLowerCase(Locale.getDefault()))' or '? altNameFromCert.toLowerCase().contains(Ascii.toLowerCase(sanToVerifySubstring))'?\r\n/Users/sergiitk/Development/grpc-java/xds/src/main/java/io/grpc/xds/internal/Matchers.java:276: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n            ? args.toLowerCase().startsWith(prefix().toLowerCase())\r\n                              ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '? args.toLowerCase(Locale.ROOT).startsWith(prefix().toLowerCase())' or '? args.toLowerCase(Locale.getDefault()).startsWith(prefix().toLowerCase())' or '? Ascii.toLowerCase(args).startsWith(prefix().toLowerCase())'?\r\n/Users/sergiitk/Development/grpc-java/xds/src/main/java/io/grpc/xds/internal/Matchers.java:276: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n            ? args.toLowerCase().startsWith(prefix().toLowerCase())\r\n                                                                ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '? args.toLowerCase().startsWith(prefix().toLowerCase(Locale.ROOT))' or '? args.toLowerCase().startsWith(prefix().toLowerCase(Locale.getDefault()))' or '? args.toLowerCase().startsWith(Ascii.toLowerCase(prefix()))'?\r\n/Users/sergiitk/Development/grpc-java/xds/src/main/java/io/grpc/xds/internal/Matchers.java:280: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n            ? args.toLowerCase().endsWith(suffix().toLowerCase())\r\n                              ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '? args.toLowerCase(Locale.ROOT).endsWith(suffix().toLowerCase())' or '? args.toLowerCase(Locale.getDefault()).endsWith(suffix().toLowerCase())' or '? Ascii.toLowerCase(args).endsWith(suffix().toLowerCase())'?\r\n/Users/sergiitk/Development/grpc-java/xds/src/main/java/io/grpc/xds/internal/Matchers.java:280: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n            ? args.toLowerCase().endsWith(suffix().toLowerCase())\r\n                                                              ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '? args.toLowerCase().endsWith(suffix().toLowerCase(Locale.ROOT))' or '? args.toLowerCase().endsWith(suffix().toLowerCase(Locale.getDefault()))' or '? args.toLowerCase().endsWith(Ascii.toLowerCase(suffix()))'?\r\n/Users/sergiitk/Development/grpc-java/xds/src/main/java/io/grpc/xds/XdsClusterResource.java:245: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n      if ((edsServiceName == null) && clusterName.toLowerCase().startsWith(\"xdstp:\")) {\r\n                                                             ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'if ((edsServiceName == null) && clusterName.toLowerCase(Locale.ROOT).startsWith(\"xdstp:\")) {' or 'if ((edsServiceName == null) && clusterName.toLowerCase(Locale.getDefault()).startsWith(\"xdstp:\")) {' or 'if ((edsServiceName == null) && Ascii.toLowerCase(clusterName).startsWith(\"xdstp:\")) {'?\r\nNote: Some input files use or override a deprecated API.\r\nNote: Recompile with -Xlint:deprecation for details.\r\n11 warnings\r\n\r\n> Task :grpc-authz:compileJava\r\n/Users/sergiitk/Development/grpc-java/authz/src/main/java/io/grpc/authz/AuthorizationPolicyTranslator.java:80: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n        || UNSUPPORTED_HEADERS.contains(key.toLowerCase())) {\r\n                                                       ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '|| UNSUPPORTED_HEADERS.contains(key.toLowerCase(Locale.ROOT))) {' or '|| UNSUPPORTED_HEADERS.contains(key.toLowerCase(Locale.getDefault()))) {' or '|| UNSUPPORTED_HEADERS.contains(Ascii.toLowerCase(key))) {'?\r\n1 warning\r\n\r\n> Task :grpc-benchmarks:compileJava\r\n/Users/sergiitk/Development/grpc-java/benchmarks/src/main/java/io/grpc/benchmarks/qps/ServerConfiguration.java:72: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n            \"TLS unsupported with the \" + config.transport.name().toLowerCase() + \" transport\");\r\n                                                                             ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '\"TLS unsupported with the \" + config.transport.name().toLowerCase(Locale.ROOT) + \" transport\");' or '\"TLS unsupported with the \" + config.transport.name().toLowerCase(Locale.getDefault()) + \" transport\");' or '\"TLS unsupported with the \" + Ascii.toLowerCase(config.transport.name()) + \" transport\");'?\r\n/Users/sergiitk/Development/grpc-java/benchmarks/src/main/java/io/grpc/benchmarks/qps/ServerConfiguration.java:131: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n        builder.append(transport.name().toLowerCase());\r\n                                                   ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'builder.append(transport.name().toLowerCase(Locale.ROOT));' or 'builder.append(transport.name().toLowerCase(Locale.getDefault()));' or 'builder.append(Ascii.toLowerCase(transport.name()));'?\r\n/Users/sergiitk/Development/grpc-java/benchmarks/src/main/java/io/grpc/benchmarks/qps/ServerConfiguration.java:161: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n    TRANSPORT(\"STR\", Transport.getDescriptionString(), DEFAULT.transport.name().toLowerCase()) {\r\n                                                                                           ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'TRANSPORT(\"STR\", Transport.getDescriptionString(), DEFAULT.transport.name().toLowerCase(Locale.ROOT)) {' or 'TRANSPORT(\"STR\", Transport.getDescriptionString(), DEFAULT.transport.name().toLowerCase(Locale.getDefault())) {' or 'TRANSPORT(\"STR\", Transport.getDescriptionString(), Ascii.toLowerCase(DEFAULT.transport.name())) {'?\r\n/Users/sergiitk/Development/grpc-java/benchmarks/src/main/java/io/grpc/benchmarks/qps/ServerConfiguration.java:164: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n        config.transport = Transport.valueOf(value.toUpperCase());\r\n                                                              ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'config.transport = Transport.valueOf(value.toUpperCase(Locale.ROOT));' or 'config.transport = Transport.valueOf(value.toUpperCase(Locale.getDefault()));' or 'config.transport = Transport.valueOf(Ascii.toUpperCase(value));'?\r\n/Users/sergiitk/Development/grpc-java/benchmarks/src/main/java/io/grpc/benchmarks/qps/ServerConfiguration.java:200: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n      return name().toLowerCase();\r\n                               ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'return name().toLowerCase(Locale.ROOT);' or 'return name().toLowerCase(Locale.getDefault());' or 'return Ascii.toLowerCase(name());'?\r\n/Users/sergiitk/Development/grpc-java/benchmarks/src/main/java/io/grpc/benchmarks/Transport.java:67: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n      builder.append(transport.name().toLowerCase());\r\n                                                 ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'builder.append(transport.name().toLowerCase(Locale.ROOT));' or 'builder.append(transport.name().toLowerCase(Locale.getDefault()));' or 'builder.append(Ascii.toLowerCase(transport.name()));'?\r\n/Users/sergiitk/Development/grpc-java/benchmarks/src/main/java/io/grpc/benchmarks/qps/ClientConfiguration.java:105: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n              \"Transport \" + config.transport.name().toLowerCase() + \" does not support TLS.\");\r\n                                                                ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean '\"Transport \" + config.transport.name().toLowerCase(Locale.ROOT) + \" does not support TLS.\");' or '\"Transport \" + config.transport.name().toLowerCase(Locale.getDefault()) + \" does not support TLS.\");' or '\"Transport \" + Ascii.toLowerCase(config.transport.name()) + \" does not support TLS.\");'?\r\n/Users/sergiitk/Development/grpc-java/benchmarks/src/main/java/io/grpc/benchmarks/qps/ClientConfiguration.java:169: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n    TRANSPORT(\"STR\", Transport.getDescriptionString(), DEFAULT.transport.name().toLowerCase()) {\r\n                                                                                           ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'TRANSPORT(\"STR\", Transport.getDescriptionString(), DEFAULT.transport.name().toLowerCase(Locale.ROOT)) {' or 'TRANSPORT(\"STR\", Transport.getDescriptionString(), DEFAULT.transport.name().toLowerCase(Locale.getDefault())) {' or 'TRANSPORT(\"STR\", Transport.getDescriptionString(), Ascii.toLowerCase(DEFAULT.transport.name())) {'?\r\n/Users/sergiitk/Development/grpc-java/benchmarks/src/main/java/io/grpc/benchmarks/qps/ClientConfiguration.java:172: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n        config.transport = Transport.valueOf(value.toUpperCase());\r\n                                                              ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'config.transport = Transport.valueOf(value.toUpperCase(Locale.ROOT));' or 'config.transport = Transport.valueOf(value.toUpperCase(Locale.getDefault()));' or 'config.transport = Transport.valueOf(Ascii.toUpperCase(value));'?\r\n/Users/sergiitk/Development/grpc-java/benchmarks/src/main/java/io/grpc/benchmarks/qps/ClientConfiguration.java:239: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n      return name().toLowerCase();\r\n                               ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'return name().toLowerCase(Locale.ROOT);' or 'return name().toLowerCase(Locale.getDefault());' or 'return Ascii.toLowerCase(name());'?\r\n10 warnings\r\n\r\n> Task :grpc-interop-testing:compileJava\r\n/Users/sergiitk/Development/grpc-java/interop-testing/src/main/java/io/grpc/testing/integration/TestCases.java:82: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n    return TestCases.valueOf(s.toUpperCase());\r\n                                          ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'return TestCases.valueOf(s.toUpperCase(Locale.ROOT));' or 'return TestCases.valueOf(s.toUpperCase(Locale.getDefault()));' or 'return TestCases.valueOf(Ascii.toUpperCase(s));'?\r\n/Users/sergiitk/Development/grpc-java/interop-testing/src/main/java/io/grpc/testing/integration/StressTestClient.java:376: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n      String strTestcase = testCase.name().toLowerCase();\r\n                                                      ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'String strTestcase = testCase.name().toLowerCase(Locale.ROOT);' or 'String strTestcase = testCase.name().toLowerCase(Locale.getDefault());' or 'String strTestcase = Ascii.toLowerCase(testCase.name());'?\r\n/Users/sergiitk/Development/grpc-java/interop-testing/src/main/java/io/grpc/testing/integration/TestServiceClient.java:695: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n      String strTestcase = testCase.name().toLowerCase();\r\n                                                      ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'String strTestcase = testCase.name().toLowerCase(Locale.ROOT);' or 'String strTestcase = testCase.name().toLowerCase(Locale.getDefault());' or 'String strTestcase = Ascii.toLowerCase(testCase.name());'?\r\n/Users/sergiitk/Development/grpc-java/interop-testing/src/main/java/io/grpc/testing/integration/Http2TestCases.java:52: warning: [StringCaseLocaleUsage] Specify a `Locale` when calling `String#to{Lower,Upper}Case`. (Note: there are multiple suggested fixes; the third may be most appropriate if you're dealing with ASCII Strings.)\r\n      return Http2TestCases.valueOf(s.toUpperCase());\r\n                                                 ^\r\n    (see https://errorprone.info/bugpattern/StringCaseLocaleUsage)\r\n  Did you mean 'return Http2TestCases.valueOf(s.toUpperCase(Locale.ROOT));' or 'return Http2TestCases.valueOf(s.toUpperCase(Locale.getDefault()));' or 'return Http2TestCases.valueOf(Ascii.toUpperCase(s));'?\r\n4 warnings\r\n```\r\n</details>\r\n",
    "issue_word_count": 2277,
    "test_files_count": 4,
    "non_test_files_count": 8,
    "pr_changed_files": [
      "authz/src/main/java/io/grpc/authz/AuthorizationPolicyTranslator.java",
      "benchmarks/src/main/java/io/grpc/benchmarks/Transport.java",
      "benchmarks/src/main/java/io/grpc/benchmarks/qps/ClientConfiguration.java",
      "benchmarks/src/main/java/io/grpc/benchmarks/qps/ServerConfiguration.java",
      "build.gradle",
      "interop-testing/src/main/java/io/grpc/testing/integration/Http2TestCases.java",
      "interop-testing/src/main/java/io/grpc/testing/integration/StressTestClient.java",
      "interop-testing/src/main/java/io/grpc/testing/integration/TestCases.java",
      "interop-testing/src/main/java/io/grpc/testing/integration/TestServiceClient.java",
      "xds/src/main/java/io/grpc/xds/XdsClusterResource.java",
      "xds/src/main/java/io/grpc/xds/internal/Matchers.java",
      "xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java"
    ],
    "pr_changed_test_files": [
      "interop-testing/src/main/java/io/grpc/testing/integration/Http2TestCases.java",
      "interop-testing/src/main/java/io/grpc/testing/integration/StressTestClient.java",
      "interop-testing/src/main/java/io/grpc/testing/integration/TestCases.java",
      "interop-testing/src/main/java/io/grpc/testing/integration/TestServiceClient.java"
    ],
    "base_commit": "37263b774d0382d5b6d57b20c068e13d0f94f0e1",
    "head_commit": "ea6551991e478aa7ddc69856a8c23007a9c7158a",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11049",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11049",
    "dockerfile": "",
    "pr_merged_at": "2024-03-27T22:58:34.000Z",
    "patch": "diff --git a/authz/src/main/java/io/grpc/authz/AuthorizationPolicyTranslator.java b/authz/src/main/java/io/grpc/authz/AuthorizationPolicyTranslator.java\nindex 1637af737ad..ed7e018412c 100644\n--- a/authz/src/main/java/io/grpc/authz/AuthorizationPolicyTranslator.java\n+++ b/authz/src/main/java/io/grpc/authz/AuthorizationPolicyTranslator.java\n@@ -33,6 +33,7 @@\n import java.util.ArrayList;\n import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n \n /**\n@@ -77,7 +78,7 @@ private static Permission parseHeader(Map<String, ?> header) throws IllegalArgum\n     }\n     if (key.charAt(0) == ':'\n         || key.startsWith(\"grpc-\")\n-        || UNSUPPORTED_HEADERS.contains(key.toLowerCase())) {\n+        || UNSUPPORTED_HEADERS.contains(key.toLowerCase(Locale.ROOT))) {\n       throw new IllegalArgumentException(String.format(\"Unsupported \\\"key\\\" %s\", key));\n     }\n     List<String> valuesList = JsonUtil.getListOfStrings(header, \"values\");\n\ndiff --git a/benchmarks/src/main/java/io/grpc/benchmarks/Transport.java b/benchmarks/src/main/java/io/grpc/benchmarks/Transport.java\nindex 820b3ac1968..fa21e03b6b8 100644\n--- a/benchmarks/src/main/java/io/grpc/benchmarks/Transport.java\n+++ b/benchmarks/src/main/java/io/grpc/benchmarks/Transport.java\n@@ -16,6 +16,8 @@\n \n package io.grpc.benchmarks;\n \n+import java.util.Locale;\n+\n /**\n  * All of the supported transports.\n  */\n@@ -64,11 +66,16 @@ public static String getDescriptionString() {\n       if (!first) {\n         builder.append(\"\\n\");\n       }\n-      builder.append(transport.name().toLowerCase());\n+      builder.append(transport);\n       builder.append(\": \");\n       builder.append(transport.description);\n       first = false;\n     }\n     return builder.toString();\n   }\n+\n+  @Override\n+  public String toString() {\n+    return name().toLowerCase(Locale.ROOT);\n+  }\n }\n\ndiff --git a/benchmarks/src/main/java/io/grpc/benchmarks/qps/ClientConfiguration.java b/benchmarks/src/main/java/io/grpc/benchmarks/qps/ClientConfiguration.java\nindex 3bafdb836ba..45061ffec49 100644\n--- a/benchmarks/src/main/java/io/grpc/benchmarks/qps/ClientConfiguration.java\n+++ b/benchmarks/src/main/java/io/grpc/benchmarks/qps/ClientConfiguration.java\n@@ -31,6 +31,7 @@\n import java.util.Collection;\n import java.util.Collections;\n import java.util.LinkedHashSet;\n+import java.util.Locale;\n import java.util.Set;\n \n /**\n@@ -102,7 +103,7 @@ protected ClientConfiguration build0(ClientConfiguration config) {\n       if (config.tls) {\n         if (!config.transport.tlsSupported) {\n           throw new IllegalArgumentException(\n-              \"Transport \" + config.transport.name().toLowerCase() + \" does not support TLS.\");\n+              \"Transport \" + config.transport + \" does not support TLS.\");\n         }\n       }\n \n@@ -166,10 +167,10 @@ protected void setClientValue(ClientConfiguration config, String value) {\n         config.testca = parseBoolean(value);\n       }\n     },\n-    TRANSPORT(\"STR\", Transport.getDescriptionString(), DEFAULT.transport.name().toLowerCase()) {\n+    TRANSPORT(\"STR\", Transport.getDescriptionString(), DEFAULT.transport.toString()) {\n       @Override\n       protected void setClientValue(ClientConfiguration config, String value) {\n-        config.transport = Transport.valueOf(value.toUpperCase());\n+        config.transport = Transport.valueOf(value.toUpperCase(Locale.ROOT));\n       }\n     },\n     DURATION(\"SECONDS\", \"Duration of the benchmark.\", \"\" + DEFAULT.duration) {\n@@ -236,7 +237,7 @@ protected void setClientValue(ClientConfiguration config, String value) {\n \n     @Override\n     public String getName() {\n-      return name().toLowerCase();\n+      return name().toLowerCase(Locale.ROOT);\n     }\n \n     @Override\n\ndiff --git a/benchmarks/src/main/java/io/grpc/benchmarks/qps/ServerConfiguration.java b/benchmarks/src/main/java/io/grpc/benchmarks/qps/ServerConfiguration.java\nindex 915c1da75eb..eb0b45c85e0 100644\n--- a/benchmarks/src/main/java/io/grpc/benchmarks/qps/ServerConfiguration.java\n+++ b/benchmarks/src/main/java/io/grpc/benchmarks/qps/ServerConfiguration.java\n@@ -29,6 +29,7 @@\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Locale;\n \n /**\n  * Configuration options for benchmark servers.\n@@ -69,7 +70,7 @@ protected Collection<Param> getParams() {\n     protected ServerConfiguration build0(ServerConfiguration config) {\n       if (config.tls && !config.transport.tlsSupported) {\n         throw new IllegalArgumentException(\n-            \"TLS unsupported with the \" + config.transport.name().toLowerCase() + \" transport\");\n+            \"TLS unsupported with the \" + config.transport + \" transport\");\n       }\n \n       // Verify that the address type is correct for the transport type.\n@@ -109,6 +110,11 @@ public enum Transport {\n       this.socketAddressValidator = socketAddressValidator;\n     }\n \n+    @Override\n+    public String toString() {\n+      return name().toLowerCase(Locale.ROOT);\n+    }\n+\n     /**\n      * Validates the given address for this transport.\n      *\n@@ -128,7 +134,7 @@ static String getDescriptionString() {\n         if (!first) {\n           builder.append(\"\\n\");\n         }\n-        builder.append(transport.name().toLowerCase());\n+        builder.append(transport);\n         builder.append(\": \");\n         builder.append(transport.description);\n         first = false;\n@@ -158,10 +164,10 @@ protected void setServerValue(ServerConfiguration config, String value) {\n         config.tls = parseBoolean(value);\n       }\n     },\n-    TRANSPORT(\"STR\", Transport.getDescriptionString(), DEFAULT.transport.name().toLowerCase()) {\n+    TRANSPORT(\"STR\", Transport.getDescriptionString(), DEFAULT.transport.toString()) {\n       @Override\n       protected void setServerValue(ServerConfiguration config, String value) {\n-        config.transport = Transport.valueOf(value.toUpperCase());\n+        config.transport = Transport.valueOf(value.toUpperCase(Locale.ROOT));\n       }\n     },\n     DIRECTEXECUTOR(\"\", \"Don't use a threadpool for RPC calls, instead execute calls directly \"\n@@ -197,7 +203,7 @@ protected void setServerValue(ServerConfiguration config, String value) {\n \n     @Override\n     public String getName() {\n-      return name().toLowerCase();\n+      return name().toLowerCase(Locale.ROOT);\n     }\n \n     @Override\n\ndiff --git a/build.gradle b/build.gradle\nindex 1d8876295a2..a59560db648 100644\n--- a/build.gradle\n+++ b/build.gradle\n@@ -253,11 +253,6 @@ subprojects {\n             options.errorprone.check(\"JavaUtilDate\", CheckSeverity.OFF)\n             // The warning fails to provide a source location\n             options.errorprone.check(\"MissingSummary\", CheckSeverity.OFF)\n-\n-            // TODO(https://github.com/grpc/grpc-java/issues/10372): remove when fixed.\n-            if (JavaVersion.current().isJava11Compatible()) {\n-              options.errorprone.check(\"StringCaseLocaleUsage\", CheckSeverity.OFF)\n-            }\n         }\n         tasks.named(\"compileTestJava\").configure {\n             // LinkedList doesn't hurt much in tests and has lots of usages\n\ndiff --git a/xds/src/main/java/io/grpc/xds/XdsClusterResource.java b/xds/src/main/java/io/grpc/xds/XdsClusterResource.java\nindex 2bc473a566a..6b6c4897225 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsClusterResource.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsClusterResource.java\n@@ -257,7 +257,7 @@ private static StructOrError<CdsUpdate.Builder> parseNonAggregateCluster(\n         edsServiceName = edsClusterConfig.getServiceName();\n       }\n       // edsServiceName is required if the CDS resource has an xdstp name.\n-      if ((edsServiceName == null) && clusterName.toLowerCase().startsWith(\"xdstp:\")) {\n+      if ((edsServiceName == null) && clusterName.toLowerCase(Locale.ROOT).startsWith(\"xdstp:\")) {\n         return StructOrError.fromError(\n             \"EDS service_name must be set when Cluster resource has an xdstp name\");\n       }\n\ndiff --git a/xds/src/main/java/io/grpc/xds/internal/Matchers.java b/xds/src/main/java/io/grpc/xds/internal/Matchers.java\nindex f833fd2e480..228b20cfcd7 100644\n--- a/xds/src/main/java/io/grpc/xds/internal/Matchers.java\n+++ b/xds/src/main/java/io/grpc/xds/internal/Matchers.java\n@@ -22,6 +22,7 @@\n import com.google.re2j.Pattern;\n import java.math.BigInteger;\n import java.net.InetAddress;\n+import java.util.Locale;\n import javax.annotation.Nullable;\n \n /**\n@@ -273,11 +274,11 @@ public boolean matches(String args) {\n             : exact().equals(args);\n       } else if (prefix() != null) {\n         return ignoreCase()\n-            ? args.toLowerCase().startsWith(prefix().toLowerCase())\n+            ? args.toLowerCase(Locale.ROOT).startsWith(prefix().toLowerCase(Locale.ROOT))\n             : args.startsWith(prefix());\n       } else if (suffix() != null) {\n         return ignoreCase()\n-            ? args.toLowerCase().endsWith(suffix().toLowerCase())\n+            ? args.toLowerCase(Locale.ROOT).endsWith(suffix().toLowerCase(Locale.ROOT))\n             : args.endsWith(suffix());\n       } else if (contains() != null) {\n         return args.contains(contains());\n\ndiff --git a/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java b/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java\nindex 4bb6f0520c4..d5c6c174f04 100644\n--- a/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java\n+++ b/xds/src/main/java/io/grpc/xds/internal/security/trust/XdsX509TrustManager.java\n@@ -30,6 +30,7 @@\n import java.security.cert.X509Certificate;\n import java.util.Collection;\n import java.util.List;\n+import java.util.Locale;\n import javax.annotation.Nullable;\n import javax.net.ssl.SSLEngine;\n import javax.net.ssl.SSLParameters;\n@@ -97,7 +98,8 @@ private static boolean verifyDnsNamePrefix(\n       return false;\n     }\n     return ignoreCase\n-        ? altNameFromCert.toLowerCase().startsWith(sanToVerifyPrefix.toLowerCase())\n+        ? altNameFromCert.toLowerCase(Locale.ROOT).startsWith(\n+            sanToVerifyPrefix.toLowerCase(Locale.ROOT))\n         : altNameFromCert.startsWith(sanToVerifyPrefix);\n   }\n \n@@ -107,7 +109,8 @@ private static boolean verifyDnsNameSuffix(\n       return false;\n     }\n     return ignoreCase\n-            ? altNameFromCert.toLowerCase().endsWith(sanToVerifySuffix.toLowerCase())\n+            ? altNameFromCert.toLowerCase(Locale.ROOT).endsWith(\n+                sanToVerifySuffix.toLowerCase(Locale.ROOT))\n             : altNameFromCert.endsWith(sanToVerifySuffix);\n   }\n \n@@ -117,7 +120,8 @@ private static boolean verifyDnsNameContains(\n       return false;\n     }\n     return ignoreCase\n-            ? altNameFromCert.toLowerCase().contains(sanToVerifySubstring.toLowerCase())\n+            ? altNameFromCert.toLowerCase(Locale.ROOT).contains(\n+                sanToVerifySubstring.toLowerCase(Locale.ROOT))\n             : altNameFromCert.contains(sanToVerifySubstring);\n   }\n \n",
    "test_patch": "diff --git a/interop-testing/src/main/java/io/grpc/testing/integration/Http2TestCases.java b/interop-testing/src/main/java/io/grpc/testing/integration/Http2TestCases.java\nindex b064ee74243..d79c6798cc2 100644\n--- a/interop-testing/src/main/java/io/grpc/testing/integration/Http2TestCases.java\n+++ b/interop-testing/src/main/java/io/grpc/testing/integration/Http2TestCases.java\n@@ -17,6 +17,7 @@\n package io.grpc.testing.integration;\n \n import com.google.common.base.Preconditions;\n+import java.util.Locale;\n \n /**\n  * Enum of HTTP/2 interop test cases.\n@@ -49,7 +50,7 @@ public String description() {\n   public static Http2TestCases fromString(String s) {\n     Preconditions.checkNotNull(s, \"s\");\n     try {\n-      return Http2TestCases.valueOf(s.toUpperCase());\n+      return Http2TestCases.valueOf(s.toUpperCase(Locale.ROOT));\n     } catch (IllegalArgumentException ex) {\n       throw new IllegalArgumentException(\"Invalid test case: \" + s);\n     }\n\ndiff --git a/interop-testing/src/main/java/io/grpc/testing/integration/StressTestClient.java b/interop-testing/src/main/java/io/grpc/testing/integration/StressTestClient.java\nindex 5739f7e7469..c344f09e198 100644\n--- a/interop-testing/src/main/java/io/grpc/testing/integration/StressTestClient.java\n+++ b/interop-testing/src/main/java/io/grpc/testing/integration/StressTestClient.java\n@@ -434,7 +434,7 @@ private static String serverAddressesToString(List<InetSocketAddress> addresses)\n   private static String validTestCasesHelpText() {\n     StringBuilder builder = new StringBuilder();\n     for (TestCases testCase : TestCases.values()) {\n-      String strTestcase = testCase.name().toLowerCase();\n+      String strTestcase = testCase.toString();\n       builder.append(\"\\n      \")\n           .append(strTestcase)\n           .append(\": \")\n\ndiff --git a/interop-testing/src/main/java/io/grpc/testing/integration/TestCases.java b/interop-testing/src/main/java/io/grpc/testing/integration/TestCases.java\nindex 85e5c31a4cb..2d16065254a 100644\n--- a/interop-testing/src/main/java/io/grpc/testing/integration/TestCases.java\n+++ b/interop-testing/src/main/java/io/grpc/testing/integration/TestCases.java\n@@ -17,6 +17,7 @@\n package io.grpc.testing.integration;\n \n import com.google.common.base.Preconditions;\n+import java.util.Locale;\n \n /**\n  * Enum of interop test cases.\n@@ -79,6 +80,11 @@ public String description() {\n    */\n   public static TestCases fromString(String s) {\n     Preconditions.checkNotNull(s, \"s\");\n-    return TestCases.valueOf(s.toUpperCase());\n+    return TestCases.valueOf(s.toUpperCase(Locale.ROOT));\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return name().toLowerCase(Locale.ROOT);\n   }\n }\n\ndiff --git a/interop-testing/src/main/java/io/grpc/testing/integration/TestServiceClient.java b/interop-testing/src/main/java/io/grpc/testing/integration/TestServiceClient.java\nindex e059e81ed54..926016adaa3 100644\n--- a/interop-testing/src/main/java/io/grpc/testing/integration/TestServiceClient.java\n+++ b/interop-testing/src/main/java/io/grpc/testing/integration/TestServiceClient.java\n@@ -697,7 +697,7 @@ protected int operationTimeoutMillis() {\n   private static String validTestCasesHelpText() {\n     StringBuilder builder = new StringBuilder();\n     for (TestCases testCase : TestCases.values()) {\n-      String strTestcase = testCase.name().toLowerCase();\n+      String strTestcase = testCase.toString();\n       builder.append(\"\\n      \")\n           .append(strTestcase)\n           .append(\": \")\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11046",
    "pr_id": 11046,
    "issue_id": 9559,
    "repo": "grpc/grpc-java",
    "problem_statement": "Add a `MODULE.bazel` in order to support for `bzlmod`\n### Is your feature request related to a problem?\r\nIn Bazel 6, a new feature called `bzlmod` will ship. This is like a \"package manager for Bazel rulesets\", and using it avoids a lot of setup work being need to be done in a `WORKSPACE`. \r\n\r\n### Describe the solution you'd like\r\nWhen run, `bzlmod` looks for rulesets on the [Bazel Central Registry](https://registry.bazel.build). Once the `MODULE.bazel` is added to this project, it can then be registered with the BCR, and then people can start using it from the modularised builds.\r\n\r\n### Describe alternatives you've considered\r\nThere are no alternatives at the moment.\r\n\r\n### Additional context\r\nWhile there are workarounds to get things working, it would be nice if this was available before Bazel 6 is released, so projects can migrate to using `bzlmod` ASAP.\r\n",
    "issue_word_count": 146,
    "test_files_count": 1,
    "non_test_files_count": 5,
    "pr_changed_files": [
      ".github/workflows/testing.yml",
      ".gitignore",
      "MODULE.bazel",
      "WORKSPACE.bzlmod",
      "protobuf-lite/BUILD.bazel",
      "repositories.bzl"
    ],
    "pr_changed_test_files": [
      ".github/workflows/testing.yml"
    ],
    "base_commit": "0866e716d6bc92a0c636108e6231a29b73103557",
    "head_commit": "35bc6094fb98c9c8baf3d45c489ea91c05de64ce",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11046",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11046",
    "dockerfile": "",
    "pr_merged_at": "2024-04-04T15:36:55.000Z",
    "patch": "diff --git a/.gitignore b/.gitignore\nindex 9fd0d7fb574..92a0e3d6d3a 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -15,6 +15,7 @@ bazel-genfiles\n bazel-grpc-java\n bazel-out\n bazel-testlogs\n+MODULE.bazel.lock\n \n # IntelliJ IDEA\n .idea\n\ndiff --git a/MODULE.bazel b/MODULE.bazel\nnew file mode 100644\nindex 00000000000..4d7a0d88144\n--- /dev/null\n+++ b/MODULE.bazel\n@@ -0,0 +1,172 @@\n+module(\n+    name = \"grpc-java\",\n+    version = \"0\",\n+    compatibility_level = 0,\n+    repo_name = \"io_grpc_grpc_java\",\n+)\n+\n+bazel_dep(name = \"googleapis\", version = \"0.0.0-20240326-1c8d509c5\", repo_name = \"com_google_googleapis\")\n+bazel_dep(name = \"grpc\", version = \"1.56.3.bcr.1\", repo_name = \"com_github_grpc_grpc\")\n+bazel_dep(name = \"protobuf\", version = \"23.1\", repo_name = \"com_google_protobuf\")\n+bazel_dep(name = \"rules_cc\", version = \"0.0.9\")\n+bazel_dep(name = \"rules_go\", version = \"0.46.0\", repo_name = \"io_bazel_rules_go\")\n+bazel_dep(name = \"rules_jvm_external\", version = \"6.0\")\n+bazel_dep(name = \"rules_proto\", version = \"5.3.0-21.7\")\n+\n+non_module_deps = use_extension(\"//:repositories.bzl\", \"grpc_java_repositories_extension\")\n+use_repo(\n+    non_module_deps,\n+    \"com_github_cncf_xds\",\n+    \"envoy_api\",\n+    \"io_grpc_grpc_proto\",\n+)\n+\n+grpc_repo_deps_ext = use_extension(\"@com_github_grpc_grpc//bazel:grpc_deps.bzl\", \"grpc_repo_deps_ext\")\n+use_repo(\n+    grpc_repo_deps_ext,\n+    \"com_envoyproxy_protoc_gen_validate\",\n+    \"com_github_cncf_udpa\",\n+    \"opencensus_proto\",\n+)\n+\n+maven = use_extension(\"@rules_jvm_external//:extensions.bzl\", \"maven\")\n+maven.install(\n+    artifacts = [\n+        \"com.google.android:annotations:4.1.1.4\",\n+        \"com.google.api.grpc:proto-google-common-protos:2.29.0\",\n+        \"com.google.auth:google-auth-library-credentials:1.22.0\",\n+        \"com.google.auth:google-auth-library-oauth2-http:1.22.0\",\n+        \"com.google.auto.value:auto-value-annotations:1.10.4\",\n+        \"com.google.auto.value:auto-value:1.10.4\",\n+        \"com.google.code.findbugs:jsr305:3.0.2\",\n+        \"com.google.code.gson:gson:2.10.1\",\n+        \"com.google.errorprone:error_prone_annotations:2.23.0\",\n+        \"com.google.guava:failureaccess:1.0.1\",\n+        \"com.google.guava:guava:32.1.3-android\",\n+        \"com.google.re2j:re2j:1.7\",\n+        \"com.google.truth:truth:1.1.5\",\n+        \"com.squareup.okhttp:okhttp:2.7.5\",\n+        \"com.squareup.okio:okio:2.10.0\",  # 3.0+ needs swapping to -jvm; need work to avoid flag-day\n+        \"io.netty:netty-buffer:4.1.100.Final\",\n+        \"io.netty:netty-codec-http2:4.1.100.Final\",\n+        \"io.netty:netty-codec-http:4.1.100.Final\",\n+        \"io.netty:netty-codec-socks:4.1.100.Final\",\n+        \"io.netty:netty-codec:4.1.100.Final\",\n+        \"io.netty:netty-common:4.1.100.Final\",\n+        \"io.netty:netty-handler-proxy:4.1.100.Final\",\n+        \"io.netty:netty-handler:4.1.100.Final\",\n+        \"io.netty:netty-resolver:4.1.100.Final\",\n+        \"io.netty:netty-tcnative-boringssl-static:2.0.61.Final\",\n+        \"io.netty:netty-tcnative-classes:2.0.61.Final\",\n+        \"io.netty:netty-transport-native-epoll:jar:linux-x86_64:4.1.100.Final\",\n+        \"io.netty:netty-transport-native-unix-common:4.1.100.Final\",\n+        \"io.netty:netty-transport:4.1.100.Final\",\n+        \"io.opencensus:opencensus-api:0.31.0\",\n+        \"io.opencensus:opencensus-contrib-grpc-metrics:0.31.0\",\n+        \"io.perfmark:perfmark-api:0.26.0\",\n+        \"junit:junit:4.13.2\",\n+        \"org.apache.tomcat:annotations-api:6.0.53\",\n+        \"org.codehaus.mojo:animal-sniffer-annotations:1.23\",\n+    ],\n+    repositories = [\n+        \"https://repo.maven.apache.org/maven2/\",\n+    ],\n+    strict_visibility = True,\n+)\n+use_repo(maven, \"maven\")\n+maven.override(\n+    coordinates = \"com.google.protobuf:protobuf-java\",\n+    target = \"@com_google_protobuf//:protobuf_java\",\n+)\n+maven.override(\n+    coordinates = \"com.google.protobuf:protobuf-java-util\",\n+    target = \"@com_google_protobuf//:protobuf_java_util\",\n+)\n+maven.override(\n+    coordinates = \"com.google.protobuf:protobuf-javalite\",\n+    target = \"@com_google_protobuf//:protobuf_javalite\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-alts\",\n+    target = \"@io_grpc_grpc_java//alts\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-api\",\n+    target = \"@io_grpc_grpc_java//api\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-auth\",\n+    target = \"@io_grpc_grpc_java//auth\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-census\",\n+    target = \"@io_grpc_grpc_java//census\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-context\",\n+    target = \"@io_grpc_grpc_java//context\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-core\",\n+    target = \"@io_grpc_grpc_java//core:core_maven\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-googleapis\",\n+    target = \"@io_grpc_grpc_java//googleapis\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-grpclb\",\n+    target = \"@io_grpc_grpc_java//grpclb\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-inprocess\",\n+    target = \"@io_grpc_grpc_java//inprocess\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-netty\",\n+    target = \"@io_grpc_grpc_java//netty\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-netty-shaded\",\n+    target = \"@io_grpc_grpc_java//netty:shaded_maven\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-okhttp\",\n+    target = \"@io_grpc_grpc_java//okhttp\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-protobuf\",\n+    target = \"@io_grpc_grpc_java//protobuf\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-protobuf-lite\",\n+    target = \"@io_grpc_grpc_java//protobuf-lite\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-rls\",\n+    target = \"@io_grpc_grpc_java//rls\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-services\",\n+    target = \"@io_grpc_grpc_java//services:services_maven\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-stub\",\n+    target = \"@io_grpc_grpc_java//stub\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-testing\",\n+    target = \"@io_grpc_grpc_java//testing\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-xds\",\n+    target = \"@io_grpc_grpc_java//xds:xds_maven\",\n+)\n+maven.override(\n+    coordinates = \"io.grpc:grpc-util\",\n+    target = \"@io_grpc_grpc_java//util\",\n+)\n+\n+switched_rules = use_extension(\"@com_google_googleapis//:extensions.bzl\", \"switched_rules\")\n+switched_rules.use_languages(java = True)\n+use_repo(switched_rules, \"com_google_googleapis_imports\")\n\ndiff --git a/WORKSPACE.bzlmod b/WORKSPACE.bzlmod\nnew file mode 100644\nindex 00000000000..4ecb9e5d985\n--- /dev/null\n+++ b/WORKSPACE.bzlmod\n@@ -0,0 +1 @@\n+# When using bzlmod this makes sure nothing from the legacy WORKSPACE is loaded\n\ndiff --git a/protobuf-lite/BUILD.bazel b/protobuf-lite/BUILD.bazel\nindex 593cf2ee943..2120cbd283a 100644\n--- a/protobuf-lite/BUILD.bazel\n+++ b/protobuf-lite/BUILD.bazel\n@@ -12,8 +12,8 @@ java_library(\n         artifact(\"com.google.guava:guava\"),\n         artifact(\"com.google.j2objc:j2objc-annotations\"),\n     ] + select({\n-        \":android\": [\"@com_google_protobuf_javalite//:protobuf_javalite\"],\n-        \"//conditions:default\": [\"@com_google_protobuf//:protobuf_java\"],\n+        \":android\": [artifact(\"com.google.protobuf:protobuf-javalite\")],\n+        \"//conditions:default\": [artifact(\"com.google.protobuf:protobuf-java\")],\n     }),\n )\n \n\ndiff --git a/repositories.bzl b/repositories.bzl\nindex 462a67eb1ae..1e8dda45e5c 100644\n--- a/repositories.bzl\n+++ b/repositories.bzl\n@@ -83,7 +83,7 @@ IO_GRPC_GRPC_JAVA_OVERRIDE_TARGETS = {\n     \"io.grpc:grpc-util\": \"@io_grpc_grpc_java//util\",\n }\n \n-def grpc_java_repositories():\n+def grpc_java_repositories(bzlmod = False):\n     \"\"\"Imports dependencies for grpc-java.\"\"\"\n     if not native.existing_rule(\"com_github_cncf_udpa\"):\n         http_archive(\n@@ -104,7 +104,7 @@ def grpc_java_repositories():\n                 \"https://github.com/cncf/xds/archive/e9ce68804cb4e64cab5a52e3c8baf840d4ff87b7.tar.gz\",\n             ],\n         )\n-    if not native.existing_rule(\"com_github_grpc_grpc\"):\n+    if not bzlmod and not native.existing_rule(\"com_github_grpc_grpc\"):\n         http_archive(\n             name = \"com_github_grpc_grpc\",\n             strip_prefix = \"grpc-1.46.0\",\n@@ -113,11 +113,11 @@ def grpc_java_repositories():\n                 \"https://github.com/grpc/grpc/archive/v1.46.0.tar.gz\",\n             ],\n         )\n-    if not native.existing_rule(\"com_google_protobuf\"):\n+    if not bzlmod and not native.existing_rule(\"com_google_protobuf\"):\n         com_google_protobuf()\n-    if not native.existing_rule(\"com_google_protobuf_javalite\"):\n+    if not bzlmod and not native.existing_rule(\"com_google_protobuf_javalite\"):\n         com_google_protobuf_javalite()\n-    if not native.existing_rule(\"com_google_googleapis\"):\n+    if not bzlmod and not native.existing_rule(\"com_google_googleapis\"):\n         http_archive(\n             name = \"com_google_googleapis\",\n             sha256 = \"49930468563dd48283e8301e8d4e71436bf6d27ac27c235224cc1a098710835d\",\n@@ -126,7 +126,7 @@ def grpc_java_repositories():\n                 \"https://github.com/googleapis/googleapis/archive/ca1372c6d7bcb199638ebfdb40d2b2660bab7b88.tar.gz\",\n             ],\n         )\n-    if not native.existing_rule(\"io_bazel_rules_go\"):\n+    if not bzlmod and not native.existing_rule(\"io_bazel_rules_go\"):\n         http_archive(\n             name = \"io_bazel_rules_go\",\n             sha256 = \"ab21448cef298740765f33a7f5acee0607203e4ea321219f2a4c85a6e0fb0a27\",\n@@ -175,3 +175,8 @@ def io_grpc_grpc_proto():\n         strip_prefix = \"grpc-proto-4f245d272a28a680606c0739753506880cf33b5f\",\n         urls = [\"https://github.com/grpc/grpc-proto/archive/4f245d272a28a680606c0739753506880cf33b5f.zip\"],\n     )\n+\n+def _grpc_java_repositories_extension(_):\n+    grpc_java_repositories(bzlmod = True)\n+\n+grpc_java_repositories_extension = module_extension(implementation = _grpc_java_repositories_extension)\n",
    "test_patch": "diff --git a/.github/workflows/testing.yml b/.github/workflows/testing.yml\nindex adc02dc3519..e9bc921ac28 100644\n--- a/.github/workflows/testing.yml\n+++ b/.github/workflows/testing.yml\n@@ -90,4 +90,9 @@ jobs:\n         key: ${{ runner.os }}-bazel-${{ env.USE_BAZEL_VERSION }}-${{ hashFiles('WORKSPACE', 'repositories.bzl') }}\n \n     - name: Run bazel build\n-      run: bazelisk build //...\n+      run: bazelisk build //... --enable_bzlmod=false\n+\n+    - name: Run bazel build (bzlmod)\n+      env:\n+        USE_BAZEL_VERSION: 7.0.0\n+      run: bazelisk build //... --enable_bzlmod=true\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11036",
    "pr_id": 11036,
    "issue_id": 10673,
    "repo": "grpc/grpc-java",
    "problem_statement": "OutlierDetection does not provide a Status description when ejecting\nAlthough RPCs should not fail because of OutlierDetection, as it makes sure there are still some working addresses, passing down a Status without a description can make debugging hard:\r\nhttps://github.com/grpc/grpc-java/blob/bdb0c72d45a5bbadfc3125ae639c256f7b6ea9a5/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java#L328-L329\r\n\r\nA hard-coded description would be really easy and make things more clear.",
    "issue_word_count": 70,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java",
      "util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java"
    ],
    "pr_changed_test_files": [
      "util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java"
    ],
    "base_commit": "bdb623031f4ce0048742c6ff945272d65b467f63",
    "head_commit": "4fb9287413ed706ec2c550ef802be0b082031115",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11036",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11036",
    "dockerfile": "",
    "pr_merged_at": "2024-03-22T21:40:06.000Z",
    "patch": "diff --git a/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java b/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java\nindex c24e2386466..033d01ce512 100644\n--- a/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java\n+++ b/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java\n@@ -377,8 +377,9 @@ void clearEndpointTracker() {\n \n     void eject() {\n       ejected = true;\n-      subchannelStateListener.onSubchannelState(\n-          ConnectivityStateInfo.forTransientFailure(Status.UNAVAILABLE));\n+      subchannelStateListener.onSubchannelState(ConnectivityStateInfo.forTransientFailure(\n+          Status.UNAVAILABLE.withDescription(\n+              \"The subchannel has been ejected by outlier detection\")));\n       logger.log(ChannelLogLevel.INFO, \"Subchannel ejected: {0}\", this);\n     }\n \n",
    "test_patch": "diff --git a/util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java b/util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java\nindex f8b700dca21..cc1fc3e6999 100644\n--- a/util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java\n+++ b/util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java\n@@ -19,8 +19,8 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth.assertWithMessage;\n import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.times;\n@@ -50,6 +50,7 @@\n import io.grpc.LoadBalancerProvider;\n import io.grpc.Metadata;\n import io.grpc.Status;\n+import io.grpc.Status.Code;\n import io.grpc.SynchronizationContext;\n import io.grpc.internal.FakeClock;\n import io.grpc.internal.FakeClock.ScheduledTask;\n@@ -1203,9 +1204,21 @@ public void successRateAndFailurePercentage_successRateOutlier_() { // with heal\n     // The one subchannel that was returning errors should be ejected.\n     assertEjectedSubchannels(ImmutableSet.of(ImmutableSet.copyOf(servers.get(0).getAddresses())));\n     if (hasHealthConsumer) {\n-      verify(healthListeners.get(servers.get(0))).onSubchannelState(eq(\n-          ConnectivityStateInfo.forTransientFailure(Status.UNAVAILABLE)\n-      ));\n+      ArgumentCaptor<ConnectivityStateInfo> csiCaptor = ArgumentCaptor.forClass(\n+          ConnectivityStateInfo.class);\n+      verify(healthListeners.get(servers.get(0)), times(2)).onSubchannelState(csiCaptor.capture());\n+      List<ConnectivityStateInfo> connectivityStateInfos = csiCaptor.getAllValues();\n+\n+      // The subchannel went through two state transitions...\n+      assertThat(connectivityStateInfos).hasSize(2);\n+      // ...it first went to the READY state...\n+      assertThat(connectivityStateInfos.get(0).getState()).isEqualTo(READY);\n+\n+      // ...and then to TRANSIENT_FAILURE as outlier detection ejected it.\n+      assertThat(connectivityStateInfos.get(1).getState()).isEqualTo(TRANSIENT_FAILURE);\n+      assertThat(connectivityStateInfos.get(1).getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+      assertThat(connectivityStateInfos.get(1).getStatus().getDescription()).isEqualTo(\n+          \"The subchannel has been ejected by outlier detection\");\n     }\n   }\n \n@@ -1264,9 +1277,21 @@ public void successRateAndFailurePercentage_errorPercentageOutlier_() { // with\n     // The one subchannel that was returning errors should be ejected.\n     assertEjectedSubchannels(ImmutableSet.of(ImmutableSet.copyOf(servers.get(0).getAddresses())));\n     if (hasHealthConsumer) {\n-      verify(healthListeners.get(servers.get(0))).onSubchannelState(eq(\n-          ConnectivityStateInfo.forTransientFailure(Status.UNAVAILABLE)\n-      ));\n+      ArgumentCaptor<ConnectivityStateInfo> csiCaptor = ArgumentCaptor.forClass(\n+          ConnectivityStateInfo.class);\n+      verify(healthListeners.get(servers.get(0)), times(2)).onSubchannelState(csiCaptor.capture());\n+      List<ConnectivityStateInfo> connectivityStateInfos = csiCaptor.getAllValues();\n+\n+      // The subchannel went through two state transitions...\n+      assertThat(connectivityStateInfos).hasSize(2);\n+      // ...it first went to the READY state...\n+      assertThat(connectivityStateInfos.get(0).getState()).isEqualTo(READY);\n+\n+      // ...and then to TRANSIENT_FAILURE as outlier detection ejected it.\n+      assertThat(connectivityStateInfos.get(1).getState()).isEqualTo(TRANSIENT_FAILURE);\n+      assertThat(connectivityStateInfos.get(1).getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+      assertThat(connectivityStateInfos.get(1).getStatus().getDescription()).isEqualTo(\n+          \"The subchannel has been ejected by outlier detection\");\n     }\n   }\n \n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-11028",
    "pr_id": 11028,
    "issue_id": 10517,
    "repo": "grpc/grpc-java",
    "problem_statement": "Channel exiting idle mode remains IDLE, not CONNECTING, until LB pick updated\nThis is because ManagedChannelImpl's `exitIdleMode()` does not call `channelStateManager.gotoState(CONNECTING);`. When exiting idle mode, the next state transition is in `LbHelperImpl.updateBalancingState()`, which is after the NR has returned its initial results.\r\n\r\nThis generally doesn't matter much because RPCs behave similarly for IDLE and CONNECTING. But it would be confusing when using the `getState()` API, like the user at https://stackoverflow.com/questions/76950718/after-the-channel-is-created-it-takes-1000ms-to-transition-from-idel-state-to .",
    "issue_word_count": 93,
    "test_files_count": 2,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java",
      "core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java",
      "core/src/test/java/io/grpc/internal/ServiceConfigErrorHandlingTest.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java",
      "core/src/test/java/io/grpc/internal/ServiceConfigErrorHandlingTest.java"
    ],
    "base_commit": "f7ee5f3182dddde775069155d17ed93f7270f1ca",
    "head_commit": "eb6ec1853a40e30a13775e7125156e7e15334953",
    "repo_url": "https://github.com/grpc/grpc-java/pull/11028",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/11028",
    "dockerfile": "",
    "pr_merged_at": "2024-03-27T18:40:13.000Z",
    "patch": "diff --git a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\nindex 5d600d1ca5e..a25886797e0 100644\n--- a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n+++ b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n@@ -20,6 +20,7 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.base.Preconditions.checkState;\n import static io.grpc.ClientStreamTracer.NAME_RESOLUTION_DELAYED;\n+import static io.grpc.ConnectivityState.CONNECTING;\n import static io.grpc.ConnectivityState.IDLE;\n import static io.grpc.ConnectivityState.SHUTDOWN;\n import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n@@ -423,6 +424,7 @@ void exitIdleMode() {\n     // may throw. We don't want to confuse our state, even if we will enter panic mode.\n     this.lbHelper = lbHelper;\n \n+    channelStateManager.gotoState(CONNECTING);\n     NameResolverListener listener = new NameResolverListener(lbHelper, nameResolver);\n     nameResolver.start(listener);\n     nameResolverStarted = true;\n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java b/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\nindex 04926cc25a5..5cd0d40fc94 100644\n--- a/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\n+++ b/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\n@@ -2338,7 +2338,7 @@ public void getState_loadBalancerSupportsChannelState() {\n     channelBuilder.nameResolverFactory(\n         new FakeNameResolverFactory.Builder(expectedUri).setResolvedAtStart(false).build());\n     createChannel();\n-    assertEquals(IDLE, channel.getState(false));\n+    assertEquals(CONNECTING, channel.getState(false));\n \n     updateBalancingStateSafely(helper, TRANSIENT_FAILURE, mockPicker);\n     assertEquals(TRANSIENT_FAILURE, channel.getState(false));\n@@ -2395,21 +2395,21 @@ public void run() {\n     channelBuilder.nameResolverFactory(\n         new FakeNameResolverFactory.Builder(expectedUri).setResolvedAtStart(false).build());\n     createChannel();\n-    assertEquals(IDLE, channel.getState(false));\n+    assertEquals(CONNECTING, channel.getState(false));\n \n-    channel.notifyWhenStateChanged(IDLE, onStateChanged);\n+    channel.notifyWhenStateChanged(CONNECTING, onStateChanged);\n     executor.runDueTasks();\n     assertFalse(stateChanged.get());\n \n-    // state change from IDLE to CONNECTING\n-    updateBalancingStateSafely(helper, CONNECTING, mockPicker);\n+    // state change from CONNECTING to IDLE\n+    updateBalancingStateSafely(helper, IDLE, mockPicker);\n     // onStateChanged callback should run\n     executor.runDueTasks();\n     assertTrue(stateChanged.get());\n \n-    // clear and test form CONNECTING\n+    // clear and test form IDLE\n     stateChanged.set(false);\n-    channel.notifyWhenStateChanged(IDLE, onStateChanged);\n+    channel.notifyWhenStateChanged(CONNECTING, onStateChanged);\n     // onStateChanged callback should run immediately\n     executor.runDueTasks();\n     assertTrue(stateChanged.get());\n@@ -2428,8 +2428,8 @@ public void run() {\n     channelBuilder.nameResolverFactory(\n         new FakeNameResolverFactory.Builder(expectedUri).setResolvedAtStart(false).build());\n     createChannel();\n-    assertEquals(IDLE, channel.getState(false));\n-    channel.notifyWhenStateChanged(IDLE, onStateChanged);\n+    assertEquals(CONNECTING, channel.getState(false));\n+    channel.notifyWhenStateChanged(CONNECTING, onStateChanged);\n     executor.runDueTasks();\n     assertFalse(stateChanged.get());\n \n@@ -2452,9 +2452,6 @@ public void stateIsIdleOnIdleTimeout() {\n     long idleTimeoutMillis = 2000L;\n     channelBuilder.idleTimeout(idleTimeoutMillis, TimeUnit.MILLISECONDS);\n     createChannel();\n-    assertEquals(IDLE, channel.getState(false));\n-\n-    updateBalancingStateSafely(helper, CONNECTING, mockPicker);\n     assertEquals(CONNECTING, channel.getState(false));\n \n     timer.forwardNanos(TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis));\n@@ -2677,11 +2674,11 @@ public void idleTimeoutAndReconnect() {\n \n     // Updating on the old helper (whose balancer has been shutdown) does not change the channel\n     // state.\n-    updateBalancingStateSafely(helper, CONNECTING, mockPicker);\n-    assertEquals(IDLE, channel.getState(false));\n-\n-    updateBalancingStateSafely(helper2, CONNECTING, mockPicker);\n+    updateBalancingStateSafely(helper, IDLE, mockPicker);\n     assertEquals(CONNECTING, channel.getState(false));\n+\n+    updateBalancingStateSafely(helper2, IDLE, mockPicker);\n+    assertEquals(IDLE, channel.getState(false));\n   }\n \n   @Test\n@@ -2695,7 +2692,7 @@ public void idleMode_resetsDelayedTransportPicker() {\n             .setServers(Collections.singletonList(new EquivalentAddressGroup(socketAddress)))\n             .build());\n     createChannel();\n-    assertEquals(IDLE, channel.getState(false));\n+    assertEquals(CONNECTING, channel.getState(false));\n \n     // This call will be buffered in delayedTransport\n     ClientCall<String, Integer> call = channel.newCall(method, CallOptions.DEFAULT);\n@@ -2790,7 +2787,7 @@ public void enterIdle_exitsIdleIfDelayedStreamPending() {\n     // enterIdle() will shut down the name resolver and lb policy used to get a pick for the delayed\n     // call\n     channel.enterIdle();\n-    assertEquals(IDLE, channel.getState(false));\n+    assertEquals(CONNECTING, channel.getState(false));\n \n     // enterIdle() will restart the delayed call by exiting idle. This creates a new helper.\n     ArgumentCaptor<Helper> helperCaptor = ArgumentCaptor.forClass(Helper.class);\n@@ -2912,14 +2909,14 @@ public void updateBalancingStateWithShutdownShouldBeIgnored() {\n     channelBuilder.nameResolverFactory(\n         new FakeNameResolverFactory.Builder(expectedUri).setResolvedAtStart(false).build());\n     createChannel();\n-    assertEquals(IDLE, channel.getState(false));\n+    assertEquals(CONNECTING, channel.getState(false));\n \n     Runnable onStateChanged = mock(Runnable.class);\n-    channel.notifyWhenStateChanged(IDLE, onStateChanged);\n+    channel.notifyWhenStateChanged(CONNECTING, onStateChanged);\n \n     updateBalancingStateSafely(helper, SHUTDOWN, mockPicker);\n \n-    assertEquals(IDLE, channel.getState(false));\n+    assertEquals(CONNECTING, channel.getState(false));\n     executor.runDueTasks();\n     verify(onStateChanged, never()).run();\n   }\n@@ -3222,8 +3219,6 @@ public void channelsAndSubchannels_instrumented_state() throws Exception {\n     verify(mockLoadBalancerProvider).newLoadBalancer(helperCaptor.capture());\n     helper = helperCaptor.getValue();\n \n-    assertEquals(IDLE, getStats(channel).state);\n-    updateBalancingStateSafely(helper, CONNECTING, mockPicker);\n     assertEquals(CONNECTING, getStats(channel).state);\n \n     AbstractSubchannel subchannel =\n@@ -3434,7 +3429,7 @@ public void channelsAndSubchannels_oob_instrumented_state() throws Exception {\n     assertEquals(READY, getStats(oobChannel).state);\n \n     // oobchannel state is separate from the ManagedChannel\n-    assertEquals(IDLE, getStats(channel).state);\n+    assertEquals(CONNECTING, getStats(channel).state);\n     channel.shutdownNow();\n     assertEquals(SHUTDOWN, getStats(channel).state);\n     assertEquals(SHUTDOWN, getStats(oobChannel).state);\n@@ -4536,4 +4531,4 @@ private static ManagedChannelServiceConfig createManagedChannelServiceConfig(\n     return ManagedChannelServiceConfig\n         .fromServiceConfig(rawServiceConfig, true, 3, 4, policySelection);\n   }\n-}\n+}\n\\ No newline at end of file\n\ndiff --git a/core/src/test/java/io/grpc/internal/ServiceConfigErrorHandlingTest.java b/core/src/test/java/io/grpc/internal/ServiceConfigErrorHandlingTest.java\nindex 0d050a09a9a..697b55c9027 100644\n--- a/core/src/test/java/io/grpc/internal/ServiceConfigErrorHandlingTest.java\n+++ b/core/src/test/java/io/grpc/internal/ServiceConfigErrorHandlingTest.java\n@@ -277,7 +277,7 @@ public void emptyAddresses_validConfig_2ndResolution_lbNeedsAddress() throws Exc\n     assertThat(resolvedAddresses.getLoadBalancingPolicyConfig()).isEqualTo(\"12\");\n     verify(mockLoadBalancer, never()).handleNameResolutionError(any(Status.class));\n \n-    assertThat(channel.getState(true)).isEqualTo(ConnectivityState.IDLE);\n+    assertThat(channel.getState(true)).isEqualTo(ConnectivityState.CONNECTING);\n \n     reset(mockLoadBalancer);\n     nameResolverFactory.servers.clear();\n@@ -480,7 +480,7 @@ public void invalidConfig_2ndResolution() throws Exception {\n     assertThat(newResolvedAddress.getLoadBalancingPolicyConfig()).isEqualTo(\"1st raw config\");\n     assertThat(channel.getConfigSelector()).isSameInstanceAs(configSelector);\n     verify(mockLoadBalancer, never()).handleNameResolutionError(any(Status.class));\n-    assertThat(channel.getState(false)).isEqualTo(ConnectivityState.IDLE);\n+    assertThat(channel.getState(false)).isEqualTo(ConnectivityState.CONNECTING);\n   }\n \n   @Test\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10989",
    "pr_id": 10989,
    "issue_id": 10297,
    "repo": "grpc/grpc-java",
    "problem_statement": "binder: compile warnings; RequiresPermission missing, readParcelable(ClassLoader) deprecated\nThe following warnings prevent building grpc-binder with `-PfailOnWarnings=true`, which sets `-Werror`. `class file for android.annotation.RequiresPermission not found` in particular is pretty nasty as it isn't clear what is going on and you can't silence the single warning.\r\n\r\n```\r\n> Task :grpc-binder:compileDebugUnitTestJavaWithJavac\r\ngrpc-java/binder/src/test/java/io/grpc/binder/internal/ParcelableInputStreamTest.java:91: warning: [deprecation] <T>readParcelable(ClassLoader) in Parcel has been deprecated\r\n    assertThat((TestParcelable) parcel.readParcelable(getClass().getClassLoader()))\r\n                                      ^\r\n  where T is a type-variable:\r\n    T extends Parcelable declared in method <T>readParcelable(ClassLoader)\r\ngrpc-java/binder/src/test/java/io/grpc/binder/internal/ParcelableInputStreamTest.java:116: warning: [deprecation] <T>readParcelable(ClassLoader) in Parcel has been deprecated\r\n    assertThat((TestParcelable) parcel.readParcelable(getClass().getClassLoader()))\r\n                                      ^\r\n  where T is a type-variable:\r\n    T extends Parcelable declared in method <T>readParcelable(ClassLoader)\r\n~/.gradle/caches/modules-2/files-2.1/org.robolectric/shadows-framework/4.9.2/8854520515f61e7f8319534dbbea3071cd282c54/shadows-framework-4.9.2.jar(/org/robolectric/shadows/ShadowDevicePolicyManager.class): warning: Cannot find annotation method 'value()' in type 'RequiresPermission': class file for android.annotation.RequiresPermission not found\r\n~/.gradle/caches/modules-2/files-2.1/org.robolectric/shadows-framework/4.9.2/8854520515f61e7f8319534dbbea3071cd282c54/shadows-framework-4.9.2.jar(/org/robolectric/shadows/ShadowDevicePolicyManager.class): warning: Cannot find annotation method 'value()' in type 'RequiresPermission'\r\n~/.gradle/caches/modules-2/files-2.1/org.robolectric/shadows-framework/4.9.2/8854520515f61e7f8319534dbbea3071cd282c54/shadows-framework-4.9.2.jar(/org/robolectric/shadows/ShadowDevicePolicyManager.class): warning: Cannot find annotation method 'value()' in type 'RequiresPermission'\r\n~/clients/grpc-java/binder/src/test/java/io/grpc/binder/SecurityPoliciesTest.java:532: warning: [deprecation] signatures in PackageInfo has been deprecated\r\n        packageInfo.signatures = this.signatures;\r\n                   ^\r\n6 warnings\r\n```\r\n\r\nCC @markb74, @jdcormie ",
    "issue_word_count": 286,
    "test_files_count": 3,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "binder/build.gradle",
      "binder/src/main/java/io/grpc/binder/internal/MetadataHelper.java",
      "binder/src/main/java/io/grpc/binder/internal/ParcelableInputStream.java",
      "binder/src/test/java/io/grpc/binder/SecurityPoliciesTest.java",
      "binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java",
      "binder/src/test/java/io/grpc/binder/internal/ParcelableInputStreamTest.java"
    ],
    "pr_changed_test_files": [
      "binder/src/test/java/io/grpc/binder/SecurityPoliciesTest.java",
      "binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java",
      "binder/src/test/java/io/grpc/binder/internal/ParcelableInputStreamTest.java"
    ],
    "base_commit": "d894c8385da313c4f5dd5f1a4f94481a7d1454c2",
    "head_commit": "0042d0477dba9dff8b951cd8f5baaa832575cadc",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10989",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10989",
    "dockerfile": "",
    "pr_merged_at": "2024-03-07T17:56:37.000Z",
    "patch": "diff --git a/binder/build.gradle b/binder/build.gradle\nindex 62613b00cb5..0a2d0263797 100644\n--- a/binder/build.gradle\n+++ b/binder/build.gradle\n@@ -76,9 +76,12 @@ import net.ltgt.gradle.errorprone.CheckSeverity\n \n tasks.withType(JavaCompile).configureEach {\n     options.compilerArgs += [\n-            \"-Xlint:-cast\"\n+            \"-Xlint:-cast\",\n+            // For junit-1.15-api & org.robolectric/shadows-framework/4.11.1\n+            \"-Xlint:-classfile\",\n+            // Unclaimed annotations. TODO(jdcormie): Fix?\n+            \"-Xlint:-processing\",\n     ]\n-    options.compilerArgs -= [\"-Werror\"] // https://github.com/grpc/grpc-java/issues/10297\n     appendToProperty(it.options.errorprone.excludedPaths, \".*/R.java\", \"|\")\n }\n \n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/MetadataHelper.java b/binder/src/main/java/io/grpc/binder/internal/MetadataHelper.java\nindex bd473780788..09662bc6533 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/MetadataHelper.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/MetadataHelper.java\n@@ -148,6 +148,9 @@ public static Metadata readMetadata(Parcel parcel, Attributes attributes) throws\n         }\n         int parcelableStartPos = parcel.dataPosition();\n         try {\n+          // readParcelable(Classloader, Class<>) requires SDK 33 and at this layer we can't know\n+          // value's type anyway.\n+          @SuppressWarnings(\"deprecation\")\n           Parcelable value = parcel.readParcelable(MetadataHelper.class.getClassLoader());\n           if (value == null) {\n             throw Status.INTERNAL.withDescription(\"Read null parcelable in metadata\").asException();\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/ParcelableInputStream.java b/binder/src/main/java/io/grpc/binder/internal/ParcelableInputStream.java\nindex 09b8cfc43f9..5f1132de54f 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/ParcelableInputStream.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/ParcelableInputStream.java\n@@ -79,6 +79,8 @@ final class ParcelableInputStream<P extends Parcelable> extends InputStream {\n   @SuppressWarnings(\"unchecked\")\n   static <P extends Parcelable> ParcelableInputStream<P> readFromParcel(\n       Parcel parcel, ClassLoader classLoader) {\n+    // readParcelable(Classloader, Class<P>) requires SDK 33 and this class isn't typesafe anyway.\n+    @SuppressWarnings(\"deprecation\")\n     P value = (P) parcel.readParcelable(classLoader);\n     return new ParcelableInputStream<>(null, value, true);\n   }\n",
    "test_patch": "diff --git a/binder/src/test/java/io/grpc/binder/SecurityPoliciesTest.java b/binder/src/test/java/io/grpc/binder/SecurityPoliciesTest.java\nindex e0f9f987939..02ff5e059e1 100644\n--- a/binder/src/test/java/io/grpc/binder/SecurityPoliciesTest.java\n+++ b/binder/src/test/java/io/grpc/binder/SecurityPoliciesTest.java\n@@ -490,6 +490,7 @@ public PackageInfoBuilder setSignatures(Signature... signatures) {\n       return this;\n     }\n \n+    @SuppressWarnings(\"deprecation\")  // 'signatures': We don't yet support signing cert rotation.\n     public PackageInfo build() {\n       checkState(this.packageName != null, \"packageName is a mandatory field\");\n \n\ndiff --git a/binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java b/binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java\nindex fb7e8e05566..86bc4c5ae91 100644\n--- a/binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java\n+++ b/binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java\n@@ -62,6 +62,7 @@ public void testDefaultInternalOnly() throws Exception {\n   }\n \n   @Test\n+  @Deprecated\n   public void testDefaultInternalOnly_legacyApi() {\n     policy = new ServerSecurityPolicy();\n     assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n@@ -80,6 +81,7 @@ public void testInternalOnly_AnotherUid() throws Exception {\n   }\n \n   @Test\n+  @Deprecated\n   public void testInternalOnly_AnotherUid_legacyApi() {\n     policy = new ServerSecurityPolicy();\n     assertThat(policy.checkAuthorizationForService(OTHER_UID, SERVICE1).getCode())\n@@ -98,6 +100,7 @@ public void testBuilderDefault() throws Exception {\n   }\n \n   @Test\n+  @Deprecated\n   public void testBuilderDefault_legacyApi() {\n     policy = ServerSecurityPolicy.newBuilder().build();\n     assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n@@ -125,6 +128,7 @@ public void testPerService() throws Exception {\n \n \n   @Test\n+  @Deprecated\n   public void testPerService_legacyApi() {\n     policy =\n         ServerSecurityPolicy.newBuilder()\n@@ -251,6 +255,7 @@ SERVICE2, policy((uid) -> uid == OTHER_UID ? Status.OK : Status.PERMISSION_DENIE\n         .isEqualTo(Status.PERMISSION_DENIED.getCode());\n   }\n   @Test\n+  @Deprecated\n   public void testPerServiceNoDefault_legacyApi() {\n     policy =\n         ServerSecurityPolicy.newBuilder()\n\ndiff --git a/binder/src/test/java/io/grpc/binder/internal/ParcelableInputStreamTest.java b/binder/src/test/java/io/grpc/binder/internal/ParcelableInputStreamTest.java\nindex bf90e21d046..657c6d77db5 100644\n--- a/binder/src/test/java/io/grpc/binder/internal/ParcelableInputStreamTest.java\n+++ b/binder/src/test/java/io/grpc/binder/internal/ParcelableInputStreamTest.java\n@@ -88,8 +88,9 @@ public void testWriteToParcel() throws Exception {\n     stream.writeToParcel(parcel);\n \n     parcel.setDataPosition(0);\n-    assertThat((TestParcelable) parcel.readParcelable(getClass().getClassLoader()))\n-        .isEqualTo(testParcelable);\n+    @SuppressWarnings(\"deprecation\") // readParcelable(ClassLoader)'s replacement is only in 33+.\n+    TestParcelable clone = parcel.readParcelable(getClass().getClassLoader());\n+    assertThat(clone).isEqualTo(testParcelable);\n   }\n \n   @Test\n@@ -113,8 +114,9 @@ public void testAsRegularInputStream() throws Exception {\n     parcel.unmarshall(data, 0, data.length);\n     parcel.setDataPosition(0);\n \n-    assertThat((TestParcelable) parcel.readParcelable(getClass().getClassLoader()))\n-        .isEqualTo(testParcelable);\n+    @SuppressWarnings(\"deprecation\") // readParcelable(ClassLoader)'s replacement is only in 33+.\n+    TestParcelable clone = parcel.readParcelable(getClass().getClassLoader());\n+    assertThat(clone).isEqualTo(testParcelable);\n   }\n \n   @Test\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10960",
    "pr_id": 10960,
    "issue_id": 10943,
    "repo": "grpc/grpc-java",
    "problem_statement": "xdsresolver uses ldsResourceName instead of using data plane authority\n### What version of gRPC-Java are you using?\r\n\r\nv1.61.0\r\n\r\n### What did you expect to see?\r\n\r\nWhile using the new xdstp style names for LDS resources, xdsclient should lookup for the data plane authority to lookup the RDS resource for virtual host config\r\n\r\n### What did you see instead?\r\n\r\nxdsclient looks up the LDS resource name from the RDS response\r\n\r\n### Steps to reproduce the bug\r\n\r\nUse the bootstrap generator @ https://github.com/GoogleCloudPlatform/traffic-director-grpc-bootstrap/commit/c53528bd2f9fad5b3a6acbd83e79d023c2b2c26c\r\n\r\nThe same bug is seen in gRPC-Go (https://github.com/grpc/grpc-go/issues/6996)",
    "issue_word_count": 104,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "xds/src/main/java/io/grpc/xds/XdsNameResolver.java",
      "xds/src/test/java/io/grpc/xds/XdsNameResolverTest.java"
    ],
    "pr_changed_test_files": [
      "xds/src/test/java/io/grpc/xds/XdsNameResolverTest.java"
    ],
    "base_commit": "0ffcd40ab6192a4cb1b61f44d1e1aa485e61f9cb",
    "head_commit": "6fb4ecb7b0e9d70ba86ca7593bf74148343c034c",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10960",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10960",
    "dockerfile": "",
    "pr_merged_at": "2024-02-27T00:33:20.000Z",
    "patch": "diff --git a/xds/src/main/java/io/grpc/xds/XdsNameResolver.java b/xds/src/main/java/io/grpc/xds/XdsNameResolver.java\nindex a345c7eb263..23e32e9fdef 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsNameResolver.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsNameResolver.java\n@@ -696,7 +696,7 @@ private void stop() {\n     // called in syncContext\n     private void updateRoutes(List<VirtualHost> virtualHosts, long httpMaxStreamDurationNano,\n         @Nullable List<NamedFilterConfig> filterConfigs) {\n-      String authority = overrideAuthority != null ? overrideAuthority : ldsResourceName;\n+      String authority = overrideAuthority != null ? overrideAuthority : encodedServiceAuthority;\n       VirtualHost virtualHost = RoutingUtils.findVirtualHostForHostName(virtualHosts, authority);\n       if (virtualHost == null) {\n         String error = \"Failed to find virtual host matching hostname: \" + authority;\n",
    "test_patch": "diff --git a/xds/src/test/java/io/grpc/xds/XdsNameResolverTest.java b/xds/src/test/java/io/grpc/xds/XdsNameResolverTest.java\nindex d93a9c99351..add3d545f15 100644\n--- a/xds/src/test/java/io/grpc/xds/XdsNameResolverTest.java\n+++ b/xds/src/test/java/io/grpc/xds/XdsNameResolverTest.java\n@@ -333,6 +333,18 @@ public void resolving_ldsResourceUpdateRdsName() {\n         RouteAction.forCluster(\n             cluster2, Collections.emptyList(), TimeUnit.SECONDS.toNanos(20L), null),\n         ImmutableMap.of());\n+    bootstrapInfo = BootstrapInfo.builder()\n+        .servers(ImmutableList.of(ServerInfo.create(\n+            \"td.googleapis.com\", InsecureChannelCredentials.create())))\n+        .clientDefaultListenerResourceNameTemplate(\"test-%s\")\n+        .node(Node.newBuilder().build())\n+        .build();\n+    resolver = new XdsNameResolver(null, AUTHORITY, null,\n+        serviceConfigParser, syncContext, scheduler,\n+        xdsClientPoolFactory, mockRandom, FilterRegistry.getDefaultRegistry(), null);\n+    // use different ldsResourceName and service authority. The virtualhost lookup should use\n+    // service authority.\n+    expectedLdsResourceName = \"test-\" + expectedLdsResourceName;\n \n     resolver.start(mockListener);\n     FakeXdsClient xdsClient = (FakeXdsClient) resolver.getXdsClient();\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10933",
    "pr_id": 10933,
    "issue_id": 10925,
    "repo": "grpc/grpc-java",
    "problem_statement": "GAE CI is broken. Java8 is dead-ish\nhttps://source.cloud.google.com/results/invocations/015cabe1-f71a-4d48-92b2-f8beaa788d05\r\n> ERROR: (gcloud.app.deploy) INVALID_ARGUMENT: Error(s) encountered validating runtime. Runtime java8 is end of support and no longer allowed. Please use the latest Java runtime for App Engine Standard. For internal google applications, please see go/gae-end-of-support.\r\n\r\nWe're probably seeing that because we have a Google-owned GCP project, but \"it is time\" to move off Java 8 for everyone on AppEngine. Steps to migrate:\r\nhttps://cloud.google.com/appengine/migration-center/standard/migrate-to-second-gen/java-differences\r\n\r\nMay not be too bad, but not as simple as `s/java8/java11/`",
    "issue_word_count": 117,
    "test_files_count": 2,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "gae-interop-testing/gae-jdk8/src/main/java/io/grpc/testing/integration/NettyClientInteropServlet.java",
      "gae-interop-testing/gae-jdk8/src/main/webapp/WEB-INF/appengine-web.xml"
    ],
    "pr_changed_test_files": [
      "gae-interop-testing/gae-jdk8/src/main/java/io/grpc/testing/integration/NettyClientInteropServlet.java",
      "gae-interop-testing/gae-jdk8/src/main/webapp/WEB-INF/appengine-web.xml"
    ],
    "base_commit": "0d39c2c7019645a3e4eb40dfb275b0bcd8efaedf",
    "head_commit": "7f0d2693decd323f225c8eb2a8d10f31cb7f5004",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10933",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10933",
    "dockerfile": "",
    "pr_merged_at": "2024-02-20T18:52:23.000Z",
    "patch": "",
    "test_patch": "diff --git a/gae-interop-testing/gae-jdk8/src/main/java/io/grpc/testing/integration/NettyClientInteropServlet.java b/gae-interop-testing/gae-jdk8/src/main/java/io/grpc/testing/integration/NettyClientInteropServlet.java\nindex 48978fac0b3..5a388d27ce9 100644\n--- a/gae-interop-testing/gae-jdk8/src/main/java/io/grpc/testing/integration/NettyClientInteropServlet.java\n+++ b/gae-interop-testing/gae-jdk8/src/main/java/io/grpc/testing/integration/NettyClientInteropServlet.java\n@@ -16,9 +16,6 @@\n \n package io.grpc.testing.integration;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n import io.grpc.Grpc;\n import io.grpc.ManagedChannelBuilder;\n import io.grpc.TlsChannelCredentials;\n@@ -131,14 +128,9 @@ private void doGetHelper(HttpServletResponse resp) throws IOException {\n   public static final class Tester extends AbstractInteropTest {\n     @Override\n     protected ManagedChannelBuilder<?> createChannelBuilder() {\n-      assertEquals(\n-          \"jdk8 required\",\n-          \"1.8\",\n-          System.getProperty(\"java.specification.version\"));\n       ManagedChannelBuilder<?> builder =\n           Grpc.newChannelBuilder(INTEROP_TEST_ADDRESS, TlsChannelCredentials.create())\n               .maxInboundMessageSize(AbstractInteropTest.MAX_MESSAGE_SIZE);\n-      assertTrue(builder instanceof NettyChannelBuilder);\n       ((NettyChannelBuilder) builder)\n           .flowControlWindow(AbstractInteropTest.TEST_FLOW_CONTROL_WINDOW);\n       return builder;\n\ndiff --git a/gae-interop-testing/gae-jdk8/src/main/webapp/WEB-INF/appengine-web.xml b/gae-interop-testing/gae-jdk8/src/main/webapp/WEB-INF/appengine-web.xml\nindex d8532dfc69e..2fcbe5d8221 100644\n--- a/gae-interop-testing/gae-jdk8/src/main/webapp/WEB-INF/appengine-web.xml\n+++ b/gae-interop-testing/gae-jdk8/src/main/webapp/WEB-INF/appengine-web.xml\n@@ -13,8 +13,7 @@\n -->\n <!-- [START config] -->\n <appengine-web-app xmlns='http://appengine.google.com/ns/1.0'>\n-  <threadsafe>true</threadsafe>\n   <service>java-gae-interop-test</service>\n-  <runtime>java8</runtime>\n+  <runtime>java11</runtime>\n </appengine-web-app>\n <!-- [END config] -->\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10909",
    "pr_id": 10909,
    "issue_id": 6808,
    "repo": "grpc/grpc-java",
    "problem_statement": "GRPC will keep retrying (until RPC timeout) if a user uses a bad service account key\n<!-- Please answer these questions before submitting a bug report. -->\r\n\r\n### What version of gRPC-Java are you using?\r\n\r\n1.27.2\r\n\r\n### What is your environment?\r\n<!-- operating system (Linux, Windows,...) and version, jdk version, etc. -->\r\n\r\nLinux, JDK8\r\n\r\n### What do you see?\r\n\r\nWhen a user uses an invalid service account key (like one that was deleted), it is treated as an `UNAVAILABLE` error. Unavailable errors are interpreted as ones that should be retried by client libraries; consequently the application will attempt to retry this operation with invalid credentials until the RPC timeout is reached (usually 10 minutes).\r\n\r\n### What do you expect to see instead?\r\n\r\nWhen a user uses an invalid service account key to authenticate with GRPC, it should yield an `UNAUTHENTICATED` error which indicates the operation should not be retried.\r\n\r\n### Steps to reproduce the bug\r\n\r\nThis is most easily reproduced through experimenting with the client libraries.\r\n\r\n1. Create a service account and service account key, download it.\r\n2. Delete the key entry in Cloud Console (so the downloaded key is no longer valid).\r\n3. Authenticate with some google service using that key. Here is an example using Pub/Sub [like this](https://github.com/googleapis/google-cloud-java/issues/5465).\r\n\r\n**Additional details:**\r\n- Many users have reported being confused by this behavior since 2018: https://github.com/googleapis/google-cloud-java/issues/3573\r\n\r\n**Suggested fix:**\r\n\r\nThe code that controls this behavior is in [GoogleAuthLibraryCallCredentials](https://github.com/grpc/grpc-java/blob/efc14bd299f83850fa2f2a34623c86c7b10825a7/auth/src/main/java/io/grpc/auth/GoogleAuthLibraryCallCredentials.java#L140). I don't think all IOExceptions should be retried though.\r\n\r\nIn this case, one can see that the exception has a `.getCause()` which is `HttpResponseException` and it has `.getStatusCode() == 400` which indicates a bad request. This is the error thrown if the user provides an invalid service account key.\r\n\r\nWould it be possible to modify it so that if it is an IOException, it will examine the `getCause()` of the exception and throw `UNAUTHENTICATED` if the cause is `HttpResponseException` with status code 400?\r\n\r\nExample of exception that you see:\r\n```\r\nth [] threw exception [Request processing failed; nested exception is com.google.api.gax.rpc.UnavailableException: io.grpc.StatusRuntimeException: UNAVAILABLE: Credentials failed to obtain metadata] with root cause\r\n\r\ncom.google.api.client.http.HttpResponseException: 400 Bad Request\r\n{\"error\":\"invalid_grant\",\"error_description\":\"Invalid JWT Signature.\"}\r\n\tat com.google.api.client.http.HttpRequest.execute(HttpRequest.java:1113) ~[google-http-client-1.34.2.jar:1.34.2]\r\n\tat com.google.auth.oauth2.ServiceAccountCredentials.refreshAccessToken(ServiceAccountCredentials.java:441) ~[google-auth-library-oauth2-http-0.20.0.jar:na]\r\n\tat com.google.auth.oauth2.OAuth2Credentials.refresh(OAuth2Credentials.java:157) ~[google-auth-library-oauth2-http-0.20.0.jar:na]\r\n\tat com.google.auth.oauth2.OAuth2Credentials.getRequestMetadata(OAuth2Credentials.java:145) ~[google-auth-library-oauth2-http-0.20.0.jar:na]\r\n\tat com.google.auth.oauth2.ServiceAccountCredentials.getRequestMetadata(ServiceAccountCredentials.java:603) ~[google-auth-library-oauth2-http-0.20.0.jar:na]\r\n\tat com.google.auth.Credentials.blockingGetToCallback(Credentials.java:112) ~[google-auth-library-credentials-0.20.0.jar:na]\r\n\tat com.google.auth.Credentials$1.run(Credentials.java:98) ~[google-auth-library-credentials-0.20.0.jar:na]\r\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[na:1.8.0_181-google-v7]\r\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_181-google-v7]\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) ~[na:1.8.0_181-google-v7]\r\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:295) ~[na:1.8.0_181-google-v7]\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[na:1.8.0_181-google-v7]\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[na:1.8.0_181-google-v7]\r\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_181-google-v7]\r\n```\r\n",
    "issue_word_count": 643,
    "test_files_count": 1,
    "non_test_files_count": 3,
    "pr_changed_files": [
      "auth/src/main/java/io/grpc/auth/GoogleAuthLibraryCallCredentials.java",
      "auth/src/test/java/io/grpc/auth/GoogleAuthLibraryCallCredentialsTest.java",
      "gradle/libs.versions.toml",
      "repositories.bzl"
    ],
    "pr_changed_test_files": [
      "auth/src/test/java/io/grpc/auth/GoogleAuthLibraryCallCredentialsTest.java"
    ],
    "base_commit": "608bb8499c587768fd0cd37c404d72ccf653ba61",
    "head_commit": "a9f01521249e8c3f6d5ff74c00220e640af1b16c",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10909",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10909",
    "dockerfile": "",
    "pr_merged_at": "2024-02-09T23:15:18.000Z",
    "patch": "diff --git a/auth/src/main/java/io/grpc/auth/GoogleAuthLibraryCallCredentials.java b/auth/src/main/java/io/grpc/auth/GoogleAuthLibraryCallCredentials.java\nindex ad5f0175c03..b4b7f5b89e4 100644\n--- a/auth/src/main/java/io/grpc/auth/GoogleAuthLibraryCallCredentials.java\n+++ b/auth/src/main/java/io/grpc/auth/GoogleAuthLibraryCallCredentials.java\n@@ -20,6 +20,7 @@\n \n import com.google.auth.Credentials;\n import com.google.auth.RequestMetadataCallback;\n+import com.google.auth.Retryable;\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.io.BaseEncoding;\n import io.grpc.InternalMayRequireSpecificExecutor;\n@@ -28,7 +29,6 @@\n import io.grpc.SecurityLevel;\n import io.grpc.Status;\n import io.grpc.StatusException;\n-import java.io.IOException;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.net.URI;\n@@ -143,8 +143,8 @@ public void onSuccess(Map<String, List<String>> metadata) {\n \n       @Override\n       public void onFailure(Throwable e) {\n-        if (e instanceof IOException) {\n-          // Since it's an I/O failure, let the call be retried with UNAVAILABLE.\n+        if (e instanceof Retryable && ((Retryable) e).isRetryable()) {\n+          // Let the call be retried with UNAVAILABLE.\n           applier.fail(Status.UNAVAILABLE\n               .withDescription(\"Credentials failed to obtain metadata\")\n               .withCause(e));\n\ndiff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml\nindex 3909dce3afe..bc80eeb9b02 100644\n--- a/gradle/libs.versions.toml\n+++ b/gradle/libs.versions.toml\n@@ -1,7 +1,5 @@\n [versions]\n-# Compatibility problem with internal version getting onto 1.5.3.\n-# https://github.com/grpc/grpc-java/pull/9118\n-googleauth = \"1.4.0\"\n+googleauth = \"1.22.0\"\n netty = '4.1.100.Final'\n # Keep the following references of tcnative version in sync whenever it's updated:\n #   SECURITY.md\n\ndiff --git a/repositories.bzl b/repositories.bzl\nindex 942a347cb05..702daaf4be2 100644\n--- a/repositories.bzl\n+++ b/repositories.bzl\n@@ -12,8 +12,8 @@ load(\"@bazel_tools//tools/build_defs/repo:http.bzl\", \"http_archive\")\n IO_GRPC_GRPC_JAVA_ARTIFACTS = [\n     \"com.google.android:annotations:4.1.1.4\",\n     \"com.google.api.grpc:proto-google-common-protos:2.29.0\",\n-    \"com.google.auth:google-auth-library-credentials:1.4.0\",\n-    \"com.google.auth:google-auth-library-oauth2-http:1.4.0\",\n+    \"com.google.auth:google-auth-library-credentials:1.22.0\",\n+    \"com.google.auth:google-auth-library-oauth2-http:1.22.0\",\n     \"com.google.auto.value:auto-value-annotations:1.10.4\",\n     \"com.google.auto.value:auto-value:1.10.4\",\n     \"com.google.code.findbugs:jsr305:3.0.2\",\n",
    "test_patch": "diff --git a/auth/src/test/java/io/grpc/auth/GoogleAuthLibraryCallCredentialsTest.java b/auth/src/test/java/io/grpc/auth/GoogleAuthLibraryCallCredentialsTest.java\nindex cbb2afdc3d0..6c350894929 100644\n--- a/auth/src/test/java/io/grpc/auth/GoogleAuthLibraryCallCredentialsTest.java\n+++ b/auth/src/test/java/io/grpc/auth/GoogleAuthLibraryCallCredentialsTest.java\n@@ -30,6 +30,7 @@\n \n import com.google.auth.Credentials;\n import com.google.auth.RequestMetadataCallback;\n+import com.google.auth.Retryable;\n import com.google.auth.http.HttpTransportFactory;\n import com.google.auth.oauth2.AccessToken;\n import com.google.auth.oauth2.GoogleCredentials;\n@@ -191,8 +192,9 @@ public void invalidBase64() throws Exception {\n   }\n \n   @Test\n-  public void credentialsFailsWithIoException() throws Exception {\n-    Exception exception = new IOException(\"Broken\");\n+  public void credentialsFailsWithRetryableRetryableException() throws Exception {\n+    boolean retryable = true;\n+    Exception exception = new RetryableException(retryable);\n     when(credentials.getRequestMetadata(eq(expectedUri))).thenThrow(exception);\n \n     GoogleAuthLibraryCallCredentials callCredentials =\n@@ -206,6 +208,23 @@ public void credentialsFailsWithIoException() throws Exception {\n     assertEquals(exception, status.getCause());\n   }\n \n+  @Test\n+  public void credentialsFailsWithUnretryableRetryableException() throws Exception {\n+    boolean retryable = false;\n+    Exception exception = new RetryableException(retryable);\n+    when(credentials.getRequestMetadata(eq(expectedUri))).thenThrow(exception);\n+\n+    GoogleAuthLibraryCallCredentials callCredentials =\n+        new GoogleAuthLibraryCallCredentials(credentials);\n+    callCredentials.applyRequestMetadata(new RequestInfoImpl(), executor, applier);\n+\n+    verify(credentials).getRequestMetadata(eq(expectedUri));\n+    verify(applier).fail(statusCaptor.capture());\n+    Status status = statusCaptor.getValue();\n+    assertEquals(Status.Code.UNAUTHENTICATED, status.getCode());\n+    assertEquals(exception, status.getCause());\n+  }\n+\n   @Test\n   public void credentialsFailsWithRuntimeException() throws Exception {\n     Exception exception = new RuntimeException(\"Broken\");\n@@ -458,4 +477,21 @@ public Attributes getTransportAttrs() {\n       return Attributes.EMPTY;\n     }\n   }\n+\n+  private static class RetryableException extends IOException implements Retryable {\n+    private final boolean retryable;\n+\n+    public RetryableException(boolean retryable) {\n+      super(\"Broken\");\n+      this.retryable = retryable;\n+    }\n+\n+    @Override public boolean isRetryable() {\n+      return retryable;\n+    }\n+\n+    @Override public int getRetryCount() {\n+      return 0;\n+    }\n+  }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10887",
    "pr_id": 10887,
    "issue_id": 10873,
    "repo": "grpc/grpc-java",
    "problem_statement": "interop-test, core: retryTest is flaky\n```\r\n> Task :grpc-interop-testing:test\r\n\r\nio.grpc.testing.integration.RetryTest > statsRecorded FAILED\r\n    java.lang.NullPointerException\r\n        at io.grpc.testing.integration.RetryTest.assertRpcStatusRecorded(RetryTest.java:248)\r\n        at io.grpc.testing.integration.RetryTest.statsRecorded(RetryTest.java:354)\r\n```\r\n\r\n\r\ncc. @larry-safran ",
    "issue_word_count": 44,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "core/src/main/java/io/grpc/internal/AbstractClientStream.java",
      "interop-testing/src/test/java/io/grpc/testing/integration/RetryTest.java"
    ],
    "pr_changed_test_files": [
      "interop-testing/src/test/java/io/grpc/testing/integration/RetryTest.java"
    ],
    "base_commit": "3202370684ec74a8e986a116b3e1476ff0a3fedc",
    "head_commit": "2d5fbc2d49697b2b986e7cd596ad9e2101b83744",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10887",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10887",
    "dockerfile": "",
    "pr_merged_at": "2024-02-05T18:54:55.000Z",
    "patch": "diff --git a/core/src/main/java/io/grpc/internal/AbstractClientStream.java b/core/src/main/java/io/grpc/internal/AbstractClientStream.java\nindex 4ef743bf96d..a4ebfa52d63 100644\n--- a/core/src/main/java/io/grpc/internal/AbstractClientStream.java\n+++ b/core/src/main/java/io/grpc/internal/AbstractClientStream.java\n@@ -455,10 +455,10 @@ private void closeListener(\n       if (!listenerClosed) {\n         listenerClosed = true;\n         statsTraceCtx.streamClosed(status);\n-        listener().closed(status, rpcProgress, trailers);\n         if (getTransportTracer() != null) {\n           getTransportTracer().reportStreamClosed(status.isOk());\n         }\n+        listener().closed(status, rpcProgress, trailers);\n       }\n     }\n   }\n",
    "test_patch": "diff --git a/interop-testing/src/test/java/io/grpc/testing/integration/RetryTest.java b/interop-testing/src/test/java/io/grpc/testing/integration/RetryTest.java\nindex 880320c6caf..dbbcf39d0ac 100644\n--- a/interop-testing/src/test/java/io/grpc/testing/integration/RetryTest.java\n+++ b/interop-testing/src/test/java/io/grpc/testing/integration/RetryTest.java\n@@ -18,7 +18,10 @@\n \n import static com.google.common.truth.Truth.assertThat;\n import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.timeout;\n import static org.mockito.Mockito.verify;\n@@ -78,8 +81,6 @@\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Mock;\n import org.mockito.junit.MockitoJUnit;\n import org.mockito.junit.MockitoRule;\n \n@@ -103,8 +104,11 @@ public class RetryTest {\n   @Rule\n   public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n   private final FakeClock fakeClock = new FakeClock();\n-  @Mock\n-  private ClientCall.Listener<Integer> mockCallListener;\n+  private TestListener testCallListener = new TestListener();\n+  @SuppressWarnings(\"unchecked\")\n+  private ClientCall.Listener<Integer> mockCallListener =\n+      mock(ClientCall.Listener.class, delegatesTo(testCallListener));\n+\n   private CountDownLatch backoffLatch = new CountDownLatch(1);\n   private final EventLoopGroup group = new DefaultEventLoopGroup() {\n     @SuppressWarnings(\"FutureReturnValueIgnored\")\n@@ -245,7 +249,9 @@ private void assertInboundWireSizeRecorded(long length) throws Exception {\n   private void assertRpcStatusRecorded(\n       Status.Code code, long roundtripLatencyMs, long outboundMessages) throws Exception {\n     MetricsRecord record = clientStatsRecorder.pollRecord(7, SECONDS);\n+    assertNotNull(record);\n     TagValue statusTag = record.tags.get(RpcMeasureConstants.GRPC_CLIENT_STATUS);\n+    assertNotNull(statusTag);\n     assertThat(statusTag.asString()).isEqualTo(code.toString());\n     assertThat(record.getMetricAsLongOrFail(DeprecatedCensusConstants.RPC_CLIENT_FINISHED_COUNT))\n         .isEqualTo(1);\n@@ -295,14 +301,14 @@ public void retryUntilBufferLimitExceeded() throws Exception {\n     verify(mockCallListener, never()).onClose(any(Status.class), any(Metadata.class));\n     // send one more message, should exceed buffer limit\n     call.sendMessage(message);\n+\n     // let attempt fail\n+    testCallListener.clear();\n     serverCall.close(\n         Status.UNAVAILABLE.withDescription(\"2nd attempt failed\"),\n         new Metadata());\n     // no more retry\n-    ArgumentCaptor<Status> statusCaptor = ArgumentCaptor.forClass(Status.class);\n-    verify(mockCallListener, timeout(5000)).onClose(statusCaptor.capture(), any(Metadata.class));\n-    assertThat(statusCaptor.getValue().getDescription()).contains(\"2nd attempt failed\");\n+    testCallListener.verifyDescription(\"2nd attempt failed\", 5000);\n   }\n \n   @Test\n@@ -534,4 +540,26 @@ public ClientStreamTracer newClientStreamTracer(StreamInfo info, Metadata header\n     assertRpcStatusRecorded(Code.INVALID_ARGUMENT, 0, 0);\n     assertRetryStatsRecorded(0, 1, 0);\n   }\n+\n+  private static class TestListener extends ClientCall.Listener<Integer> {\n+    Status status = null;\n+    private CountDownLatch closeLatch = new CountDownLatch(1);\n+\n+    @Override\n+    public void onClose(Status status, Metadata trailers) {\n+      this.status = status;\n+      closeLatch.countDown();\n+    }\n+\n+    void clear() {\n+      status = null;\n+      closeLatch = new CountDownLatch(1);\n+    }\n+\n+    void verifyDescription(String description, long timeoutMs) throws InterruptedException {\n+      closeLatch.await(timeoutMs, TimeUnit.MILLISECONDS);\n+      assertNotNull(status);\n+      assertThat(status.getDescription()).contains(description);\n+    }\n+  }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10836",
    "pr_id": 10836,
    "issue_id": 10566,
    "repo": "grpc/grpc-java",
    "problem_statement": "SecurityPolicy should support async/slow implementations\n<!-- Please answer these questions before submitting a feature request. -->\r\n\r\n### Is your feature request related to a problem?\r\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\r\nThe [SecurityPolicy](https://github.com/grpc/grpc-java/blob/master/binder/src/main/java/io/grpc/binder/SecurityPolicy.java) class defines an abstract method that returns a Status. If computing such status requires running some slow piece of code (that, for instance, reads flags from storage or from the network), then the only option is to block the calling thread until such operation is completed.\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy extends SecurityPolicy {\r\n  @Override\r\n  public Status checkAuthorization(int uid) {\r\n    try {\r\n      // must block the calling thread to satisfy SecurityPolicy's API\r\n      return fetchAllowlistedUids().get().contains(uid) ? Status.OK : Status.PERMISSION_DENIED;\r\n    } catch (InterruptedException e) {\r\n      return Status.fromThrowable(e);\r\n    }\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nBlocking is generally undesirable, because it monopolizes a thread from the system for mostly idle work, which leads to sub-optimal performance by requiring new threads to be spawned or reducing the amount of threads available, thus the responsiveness of the system.\r\n\r\n### Describe the solution you'd like\r\n`SecurityPolicy` (or an equivalent replacement) should provide an API for returning a `ListenableFuture<Status>` instead. Clients are free to implement it however they see fit. The case commonly supported today (simple non-blocking computations) would be equivalent to returning a `Futures.immediateFuture(status)` (from Guava).\r\n\r\n```java\r\npublic interface AsyncSecurityPolicy {\r\n  ListenableFuture<Status> checkAuthorization(int uid);\r\n}\r\n```\r\n\r\nThen the code above can be written as non-blocking:\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy implements AsyncSecurityPolicy {\r\n  @Override\r\n  public ListenableFuture<Status> checkAuthorization(int uid) {\r\n    return Futures.transform(\r\n      fetchAllowlistedUids(),\r\n      allowlist -> allowlist.contains(uid) ? Status.OK : Status.PERMISSION_DENIED,\r\n      someExecutor);\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\n### Describe alternatives you've considered\r\nN/A\r\n\r\n### Additional context\r\nSome apps use [StrictPolicy.VmPolicy](https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy) to instruct which kinds of threads are appropriate for different kinds of tasks (e.g. lightweight computations vs blocking network access). It can be used to configure different \"penalties\", like just logging in production or crashing in development. The issue above has triggered such violations during the development of an internal Google app.",
    "issue_word_count": 373,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java",
      "binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java"
    ],
    "pr_changed_test_files": [
      "binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java"
    ],
    "base_commit": "75492c8b36c9392d94dfce09fc132ce88c94325e",
    "head_commit": "c4d43ae94a1ae737e0f95a50ecbca76ba4a88f95",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10836",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10836",
    "dockerfile": "",
    "pr_merged_at": "2024-01-22T23:54:48.000Z",
    "patch": "diff --git a/binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java b/binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java\nindex f6516aae2f7..11952a21f9b 100644\n--- a/binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java\n+++ b/binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java\n@@ -67,5 +67,5 @@ public final Status checkAuthorization(int uid) {\n    * @return A {@link ListenableFuture} for a gRPC {@link Status} object, with OK indicating\n    *     authorized.\n    */\n-  abstract ListenableFuture<Status> checkAuthorizationAsync(int uid);\n+  public abstract ListenableFuture<Status> checkAuthorizationAsync(int uid);\n }\n",
    "test_patch": "diff --git a/binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java b/binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java\nindex 42796e2caed..1c770110fb6 100644\n--- a/binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java\n+++ b/binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java\n@@ -188,7 +188,7 @@ public void testFailedFuturesPropagateOriginalException() throws Exception {\n         ServerSecurityPolicy.newBuilder()\n             .servicePolicy(\"foo\", new AsyncSecurityPolicy() {\n               @Override\n-              ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n+              public ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n                 return Futures.immediateFailedFuture(originalException);\n               }\n             })\n@@ -207,7 +207,7 @@ public void testFailedFuturesAreNotCachedPermanently() throws Exception {\n         ServerSecurityPolicy.newBuilder()\n             .servicePolicy(\"foo\", new AsyncSecurityPolicy() {\n               @Override\n-              ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n+              public ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n                 if (firstAttempt.getAndSet(false)) {\n                   return Futures.immediateFailedFuture(new IllegalStateException());\n                 }\n@@ -229,7 +229,7 @@ public void testCancelledFuturesAreNotCachedPermanently() throws Exception {\n         ServerSecurityPolicy.newBuilder()\n             .servicePolicy(\"foo\", new AsyncSecurityPolicy() {\n               @Override\n-              ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n+              public ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n                 if (firstAttempt.getAndSet(false)) {\n                   return Futures.immediateCancelledFuture();\n                 }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10835",
    "pr_id": 10835,
    "issue_id": 10566,
    "repo": "grpc/grpc-java",
    "problem_statement": "SecurityPolicy should support async/slow implementations\n<!-- Please answer these questions before submitting a feature request. -->\r\n\r\n### Is your feature request related to a problem?\r\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\r\nThe [SecurityPolicy](https://github.com/grpc/grpc-java/blob/master/binder/src/main/java/io/grpc/binder/SecurityPolicy.java) class defines an abstract method that returns a Status. If computing such status requires running some slow piece of code (that, for instance, reads flags from storage or from the network), then the only option is to block the calling thread until such operation is completed.\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy extends SecurityPolicy {\r\n  @Override\r\n  public Status checkAuthorization(int uid) {\r\n    try {\r\n      // must block the calling thread to satisfy SecurityPolicy's API\r\n      return fetchAllowlistedUids().get().contains(uid) ? Status.OK : Status.PERMISSION_DENIED;\r\n    } catch (InterruptedException e) {\r\n      return Status.fromThrowable(e);\r\n    }\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nBlocking is generally undesirable, because it monopolizes a thread from the system for mostly idle work, which leads to sub-optimal performance by requiring new threads to be spawned or reducing the amount of threads available, thus the responsiveness of the system.\r\n\r\n### Describe the solution you'd like\r\n`SecurityPolicy` (or an equivalent replacement) should provide an API for returning a `ListenableFuture<Status>` instead. Clients are free to implement it however they see fit. The case commonly supported today (simple non-blocking computations) would be equivalent to returning a `Futures.immediateFuture(status)` (from Guava).\r\n\r\n```java\r\npublic interface AsyncSecurityPolicy {\r\n  ListenableFuture<Status> checkAuthorization(int uid);\r\n}\r\n```\r\n\r\nThen the code above can be written as non-blocking:\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy implements AsyncSecurityPolicy {\r\n  @Override\r\n  public ListenableFuture<Status> checkAuthorization(int uid) {\r\n    return Futures.transform(\r\n      fetchAllowlistedUids(),\r\n      allowlist -> allowlist.contains(uid) ? Status.OK : Status.PERMISSION_DENIED,\r\n      someExecutor);\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\n### Describe alternatives you've considered\r\nN/A\r\n\r\n### Additional context\r\nSome apps use [StrictPolicy.VmPolicy](https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy) to instruct which kinds of threads are appropriate for different kinds of tasks (e.g. lightweight computations vs blocking network access). It can be used to configure different \"penalties\", like just logging in production or crashing in development. The issue above has triggered such violations during the development of an internal Google app.",
    "issue_word_count": 373,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "binder/build.gradle",
      "binder/src/test/java/io/grpc/binder/RobolectricBinderSecurityTest.java"
    ],
    "pr_changed_test_files": [
      "binder/src/test/java/io/grpc/binder/RobolectricBinderSecurityTest.java"
    ],
    "base_commit": "3e8e56feea2b675c4238ce5e5cab93dc5c601fd5",
    "head_commit": "f1e24e5246d203b13f010e01c298ea45ed73d5e3",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10835",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10835",
    "dockerfile": "",
    "pr_merged_at": "2024-01-30T19:36:53.000Z",
    "patch": "diff --git a/binder/build.gradle b/binder/build.gradle\nindex 5b593bfe5f5..62613b00cb5 100644\n--- a/binder/build.gradle\n+++ b/binder/build.gradle\n@@ -51,6 +51,7 @@ dependencies {\n     testImplementation libraries.robolectric\n     testImplementation libraries.guava.testlib\n     testImplementation libraries.truth\n+    testImplementation project(':grpc-protobuf-lite')\n     testImplementation project(':grpc-testing')\n     testImplementation project(':grpc-inprocess')\n     testImplementation testFixtures(project(':grpc-core'))\n",
    "test_patch": "diff --git a/binder/src/test/java/io/grpc/binder/RobolectricBinderSecurityTest.java b/binder/src/test/java/io/grpc/binder/RobolectricBinderSecurityTest.java\nnew file mode 100644\nindex 00000000000..ba73cc95578\n--- /dev/null\n+++ b/binder/src/test/java/io/grpc/binder/RobolectricBinderSecurityTest.java\n@@ -0,0 +1,424 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.binder;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static org.robolectric.Shadows.shadowOf;\n+\n+import android.app.Application;\n+import android.content.ComponentName;\n+import android.content.Intent;\n+import android.os.Handler;\n+import android.os.IBinder;\n+import android.os.Looper;\n+import androidx.lifecycle.LifecycleService;\n+import androidx.test.core.app.ApplicationProvider;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.google.protobuf.Empty;\n+import io.grpc.CallOptions;\n+import io.grpc.ClientCall;\n+import io.grpc.ManagedChannel;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Server;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.ServerMethodDefinition;\n+import io.grpc.ServerServiceDefinition;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.protobuf.lite.ProtoLiteUtils;\n+import io.grpc.stub.ClientCalls;\n+import io.grpc.stub.ServerCalls;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.concurrent.AbstractExecutorService;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.annotation.Nullable;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.Robolectric;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.android.controller.ServiceController;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public final class RobolectricBinderSecurityTest {\n+\n+  private static final String SERVICE_NAME = \"fake_service\";\n+  private static final String FULL_METHOD_NAME = \"fake_service/fake_method\";\n+  private final Application context = ApplicationProvider.getApplicationContext();\n+  private ServiceController<SomeService> controller;\n+  private SomeService service;\n+  private ManagedChannel channel;\n+\n+  @Before\n+  public void setUp() {\n+    controller = Robolectric.buildService(SomeService.class);\n+    service = controller.create().get();\n+\n+    AndroidComponentAddress listenAddress = AndroidComponentAddress.forContext(service);\n+    ScheduledExecutorService executor = service.getExecutor();\n+    channel =\n+        BinderChannelBuilder.forAddress(listenAddress, context)\n+            .executor(executor)\n+            .scheduledExecutorService(executor)\n+            .offloadExecutor(executor)\n+            .build();\n+    idleLoopers();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    channel.shutdownNow();\n+    controller.destroy();\n+  }\n+\n+  @Test\n+  public void testAsyncServerSecurityPolicy_failed_returnsFailureStatus() throws Exception {\n+    ListenableFuture<Status> status = makeCall();\n+    service.setSecurityPolicyStatusWhenReady(Status.ALREADY_EXISTS);\n+    idleLoopers();\n+\n+    assertThat(Futures.getDone(status).getCode()).isEqualTo(Status.Code.ALREADY_EXISTS);\n+  }\n+\n+  @Test\n+  public void testAsyncServerSecurityPolicy_failedFuture_failsWithCodeInternal() throws Exception {\n+    ListenableFuture<Status> status = makeCall();\n+    service.setSecurityPolicyFailed(new IllegalStateException(\"oops\"));\n+    idleLoopers();\n+\n+    assertThat(Futures.getDone(status).getCode()).isEqualTo(Status.Code.INTERNAL);\n+  }\n+\n+  @Test\n+  public void testAsyncServerSecurityPolicy_allowed_returnsOkStatus() throws Exception {\n+    ListenableFuture<Status> status = makeCall();\n+    service.setSecurityPolicyStatusWhenReady(Status.OK);\n+    idleLoopers();\n+\n+    assertThat(Futures.getDone(status).getCode()).isEqualTo(Status.Code.OK);\n+  }\n+\n+  private ListenableFuture<Status> makeCall() {\n+    ClientCall<Empty, Empty> call =\n+        channel.newCall(\n+            getMethodDescriptor(), CallOptions.DEFAULT.withExecutor(service.getExecutor()));\n+    ListenableFuture<Empty> responseFuture =\n+        ClientCalls.futureUnaryCall(call, Empty.getDefaultInstance());\n+\n+    idleLoopers();\n+\n+    return Futures.catching(\n+        Futures.transform(responseFuture, unused -> Status.OK, directExecutor()),\n+        StatusRuntimeException.class,\n+        StatusRuntimeException::getStatus,\n+        directExecutor());\n+  }\n+\n+  private static void idleLoopers() {\n+    shadowOf(Looper.getMainLooper()).idle();\n+  }\n+\n+  private static MethodDescriptor<Empty, Empty> getMethodDescriptor() {\n+    MethodDescriptor.Marshaller<Empty> marshaller =\n+        ProtoLiteUtils.marshaller(Empty.getDefaultInstance());\n+\n+    return MethodDescriptor.newBuilder(marshaller, marshaller)\n+        .setFullMethodName(FULL_METHOD_NAME)\n+        .setType(MethodDescriptor.MethodType.UNARY)\n+        .setSampledToLocalTracing(true)\n+        .build();\n+  }\n+\n+  private static class SomeService extends LifecycleService {\n+\n+    private final IBinderReceiver binderReceiver = new IBinderReceiver();\n+    private final ArrayBlockingQueue<SettableFuture<Status>> statusesToSet =\n+        new ArrayBlockingQueue<>(128);\n+    private Server server;\n+    private final ScheduledExecutorService scheduledExecutorService =\n+        new HandlerScheduledExecutorService();\n+\n+    @Override\n+    public void onCreate() {\n+      super.onCreate();\n+\n+      MethodDescriptor<Empty, Empty> methodDesc = getMethodDescriptor();\n+      ServerCallHandler<Empty, Empty> callHandler =\n+          ServerCalls.asyncUnaryCall(\n+              (req, respObserver) -> {\n+                respObserver.onNext(req);\n+                respObserver.onCompleted();\n+              });\n+      ServerMethodDefinition<Empty, Empty> methodDef =\n+          ServerMethodDefinition.create(methodDesc, callHandler);\n+      ServerServiceDefinition def =\n+          ServerServiceDefinition.builder(SERVICE_NAME).addMethod(methodDef).build();\n+\n+      server =\n+          BinderServerBuilder.forAddress(AndroidComponentAddress.forContext(this), binderReceiver)\n+              .addService(def)\n+              .securityPolicy(\n+                  ServerSecurityPolicy.newBuilder()\n+                      .servicePolicy(\n+                          SERVICE_NAME,\n+                          new AsyncSecurityPolicy() {\n+                            @Override\n+                            public ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n+                              return Futures.submitAsync(\n+                                  () -> {\n+                                    SettableFuture<Status> status = SettableFuture.create();\n+                                    statusesToSet.add(status);\n+                                    return status;\n+                                  },\n+                                  getExecutor());\n+                            }\n+                          })\n+                      .build())\n+              .executor(getExecutor())\n+              .scheduledExecutorService(getExecutor())\n+              .build();\n+      try {\n+        server.start();\n+      } catch (IOException e) {\n+        throw new IllegalStateException(e);\n+      }\n+\n+      Application context = ApplicationProvider.getApplicationContext();\n+      ComponentName componentName = new ComponentName(context, SomeService.class);\n+      shadowOf(context)\n+          .setComponentNameAndServiceForBindService(\n+              componentName, checkNotNull(binderReceiver.get()));\n+    }\n+\n+    /**\n+     * Returns an {@link ScheduledExecutorService} under which all of the gRPC computations run. The\n+     * execution of any pending tasks on this executor can be triggered via {@link #idleLoopers()}.\n+     */\n+    ScheduledExecutorService getExecutor() {\n+      return scheduledExecutorService;\n+    }\n+\n+    void setSecurityPolicyStatusWhenReady(Status status) {\n+      getNextEnqueuedStatus().set(status);\n+    }\n+\n+    void setSecurityPolicyFailed(Exception e) {\n+      getNextEnqueuedStatus().setException(e);\n+    }\n+\n+    private SettableFuture<Status> getNextEnqueuedStatus() {\n+      @Nullable SettableFuture<Status> future = statusesToSet.poll();\n+      while (future == null) {\n+        // Keep idling until the future is available.\n+        idleLoopers();\n+        future = statusesToSet.poll();\n+      }\n+      return checkNotNull(future);\n+    }\n+\n+    @Override\n+    public IBinder onBind(Intent intent) {\n+      super.onBind(intent);\n+      return checkNotNull(binderReceiver.get());\n+    }\n+\n+    @Override\n+    public void onDestroy() {\n+      super.onDestroy();\n+      server.shutdownNow();\n+    }\n+\n+    /** A future representing a task submitted to a {@link Handler}. */\n+    private static class HandlerFuture<V> implements ScheduledFuture<V> {\n+\n+      private final Duration delay;\n+      private final SettableFuture<V> delegate = SettableFuture.create();\n+\n+      HandlerFuture(Duration delay) {\n+        this.delay = delay;\n+      }\n+\n+      @Override\n+      public long getDelay(TimeUnit timeUnit) {\n+        return timeUnit.convert(delay.toMillis(), TimeUnit.MILLISECONDS);\n+      }\n+\n+      @Override\n+      public int compareTo(Delayed other) {\n+        return Comparator.comparingLong(\n+                (Delayed delayed) -> delayed.getDelay(TimeUnit.MILLISECONDS))\n+            .compare(this, other);\n+      }\n+\n+      @Override\n+      public boolean cancel(boolean mayInterruptIfRunning) {\n+        return delegate.cancel(mayInterruptIfRunning);\n+      }\n+\n+      @Override\n+      public boolean isCancelled() {\n+        return delegate.isCancelled();\n+      }\n+\n+      @Override\n+      public boolean isDone() {\n+        return delegate.isDone();\n+      }\n+\n+      @Override\n+      public V get() throws ExecutionException, InterruptedException {\n+        return delegate.get();\n+      }\n+\n+      @Override\n+      public V get(long timeout, TimeUnit timeUnit)\n+          throws ExecutionException, InterruptedException, TimeoutException {\n+        return delegate.get(timeout, timeUnit);\n+      }\n+\n+      void complete(V result) {\n+        delegate.set(result);\n+      }\n+\n+      void setException(Exception e) {\n+        delegate.setException(e);\n+      }\n+    }\n+\n+    /**\n+     * Minimal implementation of a {@link ScheduledExecutorService} that delegates tasks to a {@link\n+     * Handler}. Pending tasks can be forced to run via {@link\n+     * org.robolectric.shadows.ShadowLooper#idle()}.\n+     */\n+    private static class HandlerScheduledExecutorService extends AbstractExecutorService\n+        implements ScheduledExecutorService {\n+      private final Handler handler = new Handler(Looper.getMainLooper());\n+\n+      private static Runnable asRunnableFor(HandlerFuture<Void> future, Runnable runnable) {\n+        return () -> {\n+          try {\n+            runnable.run();\n+            future.complete(null);\n+          } catch (Exception e) {\n+            future.setException(e);\n+          }\n+        };\n+      }\n+\n+      private static <V> Runnable asRunnableFor(HandlerFuture<V> future, Callable<V> callable) {\n+        return () -> {\n+          try {\n+            future.complete(callable.call());\n+          } catch (Exception e) {\n+            future.setException(e);\n+          }\n+        };\n+      }\n+\n+      @Override\n+      public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        long millis = timeUnit.toMillis(l);\n+        HandlerFuture<Void> result = new HandlerFuture<>(Duration.ofMillis(millis));\n+        handler.postDelayed(asRunnableFor(result, runnable), millis);\n+        return result;\n+      }\n+\n+      @Override\n+      public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        long millis = timeUnit.toMillis(l);\n+        HandlerFuture<V> result = new HandlerFuture<>(Duration.ofMillis(millis));\n+        handler.postDelayed(asRunnableFor(result, callable), millis);\n+        return result;\n+      }\n+\n+      @Override\n+      public ScheduledFuture<?> scheduleAtFixedRate(\n+          Runnable runnable, long delay, long period, TimeUnit timeUnit) {\n+        return scheduleWithFixedDelay(runnable, delay, period, timeUnit);\n+      }\n+\n+      @Override\n+      public ScheduledFuture<?> scheduleWithFixedDelay(\n+          Runnable runnable, long initialDelay, long delay, TimeUnit timeUnit) {\n+        long initialDelayMillis = timeUnit.toMillis(initialDelay);\n+        long periodMillis = timeUnit.toMillis(delay);\n+        HandlerFuture<Void> result = new HandlerFuture<>(Duration.ofMillis(initialDelayMillis));\n+\n+        Runnable scheduledRunnable =\n+            new Runnable() {\n+              @Override\n+              public void run() {\n+                try {\n+                  runnable.run();\n+                  handler.postDelayed(this, periodMillis);\n+                } catch (Exception e) {\n+                  result.setException(e);\n+                }\n+              }\n+            };\n+\n+        handler.postDelayed(scheduledRunnable, initialDelayMillis);\n+        return result;\n+      }\n+\n+      @Override\n+      public void shutdown() {}\n+\n+      @Override\n+      public List<Runnable> shutdownNow() {\n+        return ImmutableList.of();\n+      }\n+\n+      @Override\n+      public boolean isShutdown() {\n+        return false;\n+      }\n+\n+      @Override\n+      public boolean isTerminated() {\n+        return false;\n+      }\n+\n+      @Override\n+      public boolean awaitTermination(long l, TimeUnit timeUnit) {\n+        idleLoopers();\n+        return true;\n+      }\n+\n+      @Override\n+      public void execute(Runnable runnable) {\n+        handler.post(runnable);\n+      }\n+    }\n+  }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10806",
    "pr_id": 10806,
    "issue_id": 10566,
    "repo": "grpc/grpc-java",
    "problem_statement": "SecurityPolicy should support async/slow implementations\n<!-- Please answer these questions before submitting a feature request. -->\r\n\r\n### Is your feature request related to a problem?\r\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\r\nThe [SecurityPolicy](https://github.com/grpc/grpc-java/blob/master/binder/src/main/java/io/grpc/binder/SecurityPolicy.java) class defines an abstract method that returns a Status. If computing such status requires running some slow piece of code (that, for instance, reads flags from storage or from the network), then the only option is to block the calling thread until such operation is completed.\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy extends SecurityPolicy {\r\n  @Override\r\n  public Status checkAuthorization(int uid) {\r\n    try {\r\n      // must block the calling thread to satisfy SecurityPolicy's API\r\n      return fetchAllowlistedUids().get().contains(uid) ? Status.OK : Status.PERMISSION_DENIED;\r\n    } catch (InterruptedException e) {\r\n      return Status.fromThrowable(e);\r\n    }\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nBlocking is generally undesirable, because it monopolizes a thread from the system for mostly idle work, which leads to sub-optimal performance by requiring new threads to be spawned or reducing the amount of threads available, thus the responsiveness of the system.\r\n\r\n### Describe the solution you'd like\r\n`SecurityPolicy` (or an equivalent replacement) should provide an API for returning a `ListenableFuture<Status>` instead. Clients are free to implement it however they see fit. The case commonly supported today (simple non-blocking computations) would be equivalent to returning a `Futures.immediateFuture(status)` (from Guava).\r\n\r\n```java\r\npublic interface AsyncSecurityPolicy {\r\n  ListenableFuture<Status> checkAuthorization(int uid);\r\n}\r\n```\r\n\r\nThen the code above can be written as non-blocking:\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy implements AsyncSecurityPolicy {\r\n  @Override\r\n  public ListenableFuture<Status> checkAuthorization(int uid) {\r\n    return Futures.transform(\r\n      fetchAllowlistedUids(),\r\n      allowlist -> allowlist.contains(uid) ? Status.OK : Status.PERMISSION_DENIED,\r\n      someExecutor);\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\n### Describe alternatives you've considered\r\nN/A\r\n\r\n### Additional context\r\nSome apps use [StrictPolicy.VmPolicy](https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy) to instruct which kinds of threads are appropriate for different kinds of tasks (e.g. lightweight computations vs blocking network access). It can be used to configure different \"penalties\", like just logging in production or crashing in development. The issue above has triggered such violations during the development of an internal Google app.",
    "issue_word_count": 373,
    "test_files_count": 1,
    "non_test_files_count": 0,
    "pr_changed_files": [
      "binder/src/test/java/io/grpc/binder/internal/PendingAuthListenerTest.java"
    ],
    "pr_changed_test_files": [
      "binder/src/test/java/io/grpc/binder/internal/PendingAuthListenerTest.java"
    ],
    "base_commit": "4e163361d4a84f10afcfc4cf738e8f857c642004",
    "head_commit": "05fe6131eb278f13529c3cb22c7facce5cb72111",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10806",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10806",
    "dockerfile": "",
    "pr_merged_at": "2024-01-22T23:06:17.000Z",
    "patch": "",
    "test_patch": "diff --git a/binder/src/test/java/io/grpc/binder/internal/PendingAuthListenerTest.java b/binder/src/test/java/io/grpc/binder/internal/PendingAuthListenerTest.java\nnew file mode 100644\nindex 00000000000..29b35b309fb\n--- /dev/null\n+++ b/binder/src/test/java/io/grpc/binder/internal/PendingAuthListenerTest.java\n@@ -0,0 +1,102 @@\n+package io.grpc.binder.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.InOrder;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.Status;\n+\n+@RunWith(JUnit4.class)\n+public final class PendingAuthListenerTest {\n+\n+  @Rule public final MockitoRule mocks = MockitoJUnit.rule();\n+\n+  @Mock ServerCallHandler<Object, Object> next;\n+  @Mock ServerCall<Object, Object> call;\n+  @Mock ServerCall.Listener<Object> delegate;\n+  @Captor ArgumentCaptor<Status> statusCaptor;\n+\n+  private final Metadata headers = new Metadata();\n+  private final PendingAuthListener<Object, Object> listener = new PendingAuthListener<>();\n+\n+  @Before\n+  public void setUp() {\n+    when(next.startCall(call, headers)).thenReturn(delegate);\n+  }\n+\n+  @Test\n+  public void onCallbacks_noOpBeforeStartCall() {\n+    listener.onReady();\n+    listener.onMessage(\"foo\");\n+    listener.onHalfClose();\n+    listener.onComplete();\n+\n+    verifyNoInteractions(delegate);\n+  }\n+\n+  @Test\n+  public void onCallbacks_runsPendingCallbacksAfterStartCall() {\n+    String message = \"foo\";\n+\n+    // Act 1\n+    listener.onReady();\n+    listener.onMessage(message);\n+    listener.startCall(call, headers, next);\n+\n+    // Assert 1\n+    InOrder order = Mockito.inOrder(delegate);\n+    order.verify(delegate).onReady();\n+    order.verify(delegate).onMessage(message);\n+\n+    // Act 2\n+    listener.onHalfClose();\n+    listener.onComplete();\n+\n+    // Assert 2\n+    order.verify(delegate).onHalfClose();\n+    order.verify(delegate).onComplete();\n+  }\n+\n+  @Test\n+  public void onCallbacks_withCancellation_runsPendingCallbacksAfterStartCall() {\n+    listener.onReady();\n+    listener.onCancel();\n+    listener.startCall(call, headers, next);\n+\n+    InOrder order = Mockito.inOrder(delegate);\n+    order.verify(delegate).onReady();\n+    order.verify(delegate).onCancel();\n+  }\n+\n+  @Test\n+  public void whenStartCallFails_closesTheCallWithInternalStatus() {\n+    IllegalStateException exception = new IllegalStateException(\"oops\");\n+    when(next.startCall(any(), any())).thenThrow(exception);\n+\n+    listener.onReady();\n+    listener.startCall(call, headers, next);\n+\n+    verify(call).close(statusCaptor.capture(), any());\n+    Status status = statusCaptor.getValue();\n+    assertThat(status.getCode()).isEqualTo(Status.Code.INTERNAL);\n+    assertThat(status.getCause()).isSameInstanceAs(exception);\n+  }\n+}\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10743",
    "pr_id": 10743,
    "issue_id": 10566,
    "repo": "grpc/grpc-java",
    "problem_statement": "SecurityPolicy should support async/slow implementations\n<!-- Please answer these questions before submitting a feature request. -->\r\n\r\n### Is your feature request related to a problem?\r\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\r\nThe [SecurityPolicy](https://github.com/grpc/grpc-java/blob/master/binder/src/main/java/io/grpc/binder/SecurityPolicy.java) class defines an abstract method that returns a Status. If computing such status requires running some slow piece of code (that, for instance, reads flags from storage or from the network), then the only option is to block the calling thread until such operation is completed.\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy extends SecurityPolicy {\r\n  @Override\r\n  public Status checkAuthorization(int uid) {\r\n    try {\r\n      // must block the calling thread to satisfy SecurityPolicy's API\r\n      return fetchAllowlistedUids().get().contains(uid) ? Status.OK : Status.PERMISSION_DENIED;\r\n    } catch (InterruptedException e) {\r\n      return Status.fromThrowable(e);\r\n    }\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nBlocking is generally undesirable, because it monopolizes a thread from the system for mostly idle work, which leads to sub-optimal performance by requiring new threads to be spawned or reducing the amount of threads available, thus the responsiveness of the system.\r\n\r\n### Describe the solution you'd like\r\n`SecurityPolicy` (or an equivalent replacement) should provide an API for returning a `ListenableFuture<Status>` instead. Clients are free to implement it however they see fit. The case commonly supported today (simple non-blocking computations) would be equivalent to returning a `Futures.immediateFuture(status)` (from Guava).\r\n\r\n```java\r\npublic interface AsyncSecurityPolicy {\r\n  ListenableFuture<Status> checkAuthorization(int uid);\r\n}\r\n```\r\n\r\nThen the code above can be written as non-blocking:\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy implements AsyncSecurityPolicy {\r\n  @Override\r\n  public ListenableFuture<Status> checkAuthorization(int uid) {\r\n    return Futures.transform(\r\n      fetchAllowlistedUids(),\r\n      allowlist -> allowlist.contains(uid) ? Status.OK : Status.PERMISSION_DENIED,\r\n      someExecutor);\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\n### Describe alternatives you've considered\r\nN/A\r\n\r\n### Additional context\r\nSome apps use [StrictPolicy.VmPolicy](https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy) to instruct which kinds of threads are appropriate for different kinds of tasks (e.g. lightweight computations vs blocking network access). It can be used to configure different \"penalties\", like just logging in production or crashing in development. The issue above has triggered such violations during the development of an internal Google app.",
    "issue_word_count": 373,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java"
    ],
    "pr_changed_test_files": [
      "binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java"
    ],
    "base_commit": "f67ec2ecd9c79e34c6fb989091dcf8862480e54d",
    "head_commit": "245cf68a3ae7076546c3e168a8768a0a3394a6a0",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10743",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10743",
    "dockerfile": "",
    "pr_merged_at": "2024-01-03T14:17:31.000Z",
    "patch": "diff --git a/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java b/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\nindex 1866bf54a47..56464d58a4b 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\n@@ -19,6 +19,7 @@\n import com.google.common.util.concurrent.FutureCallback;\n import com.google.common.util.concurrent.Futures;\n import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n \n import io.grpc.Attributes;\n import io.grpc.Internal;\n@@ -32,6 +33,7 @@\n import io.grpc.Status;\n import io.grpc.internal.GrpcAttributes;\n \n+import java.util.concurrent.CancellationException;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Executor;\n@@ -110,9 +112,13 @@ public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(\n       Status authStatus;\n       try {\n         authStatus = Futures.getDone(authStatusFuture);\n-      } catch (ExecutionException e) {\n+      } catch (ExecutionException | CancellationException e) {\n         // Failed futures are treated as an internal error rather than a security rejection.\n         authStatus = Status.INTERNAL.withCause(e);\n+        @Nullable String message = e.getMessage();\n+        if (message != null) {\n+          authStatus = authStatus.withDescription(message);\n+        }\n       }\n \n       if (authStatus.isOk()) {\n@@ -179,6 +185,8 @@ ListenableFuture<Status> checkAuthorization(MethodDescriptor<?, ?> method) {\n       if (useCache) {\n         @Nullable ListenableFuture<Status> authorization = serviceAuthorization.get(serviceName);\n         if (authorization != null) {\n+          // Authorization check exists and is a pending or successful future (even if for a\n+          // failed authorization).\n           return authorization;\n         }\n       }\n@@ -193,6 +201,15 @@ ListenableFuture<Status> checkAuthorization(MethodDescriptor<?, ?> method) {\n           serverPolicyChecker.checkAuthorizationForServiceAsync(uid, serviceName);\n       if (useCache) {\n         serviceAuthorization.putIfAbsent(serviceName, authorization);\n+        Futures.addCallback(authorization, new FutureCallback<Status>() {\n+          @Override\n+          public void onSuccess(Status result) {}\n+\n+          @Override\n+          public void onFailure(Throwable t) {\n+            serviceAuthorization.remove(serviceName, authorization);\n+          }\n+        }, MoreExecutors.directExecutor());\n       }\n       return authorization;\n     }\n",
    "test_patch": "diff --git a/binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java b/binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java\nindex 18d5cd99d74..42796e2caed 100644\n--- a/binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java\n+++ b/binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java\n@@ -26,6 +26,7 @@\n import com.google.common.util.concurrent.Futures;\n import com.google.common.util.concurrent.ListenableFuture;\n import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.errorprone.annotations.CanIgnoreReturnValue;\n import com.google.protobuf.Empty;\n import io.grpc.CallOptions;\n import io.grpc.ManagedChannel;\n@@ -45,6 +46,8 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n import javax.annotation.Nullable;\n import org.junit.After;\n import org.junit.Before;\n@@ -76,6 +79,7 @@ public void setupServiceDefinitionsAndMethods() {\n             MethodDescriptor.newBuilder(marshaller, marshaller)\n                 .setFullMethodName(name)\n                 .setType(MethodDescriptor.MethodType.UNARY)\n+                .setSampledToLocalTracing(true)\n                 .build();\n         ServerCallHandler<Empty, Empty> callHandler =\n             ServerCalls.asyncUnaryCall(\n@@ -139,12 +143,16 @@ private void assertCallSuccess(MethodDescriptor<Empty, Empty> method) {\n         .isNotNull();\n   }\n \n-  private void assertCallFailure(MethodDescriptor<Empty, Empty> method, Status status) {\n+  @CanIgnoreReturnValue\n+  private StatusRuntimeException assertCallFailure(\n+      MethodDescriptor<Empty, Empty> method, Status status) {\n     try {\n       ClientCalls.blockingUnaryCall(channel, method, CallOptions.DEFAULT, null);\n-      fail();\n+      fail(\"Expected call to \" + method.getFullMethodName() + \" to fail but it succeeded.\");\n+      throw new AssertionError();  // impossible\n     } catch (StatusRuntimeException sre) {\n       assertThat(sre.getStatus().getCode()).isEqualTo(status.getCode());\n+      return sre;\n     }\n   }\n \n@@ -172,6 +180,70 @@ public void testServerDisallowsCalls() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testFailedFuturesPropagateOriginalException() throws Exception {\n+    String errorMessage = \"something went wrong\";\n+    IllegalStateException originalException = new IllegalStateException(errorMessage);\n+    createChannel(\n+        ServerSecurityPolicy.newBuilder()\n+            .servicePolicy(\"foo\", new AsyncSecurityPolicy() {\n+              @Override\n+              ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n+                return Futures.immediateFailedFuture(originalException);\n+              }\n+            })\n+            .build(),\n+        SecurityPolicies.internalOnly());\n+    MethodDescriptor<Empty, Empty> method = methods.get(\"foo/method0\");\n+\n+    StatusRuntimeException sre = assertCallFailure(method, Status.INTERNAL);\n+    assertThat(sre.getStatus().getDescription()).contains(errorMessage);\n+  }\n+\n+  @Test\n+  public void testFailedFuturesAreNotCachedPermanently() throws Exception {\n+    AtomicReference<Boolean> firstAttempt = new AtomicReference<>(true);\n+    createChannel(\n+        ServerSecurityPolicy.newBuilder()\n+            .servicePolicy(\"foo\", new AsyncSecurityPolicy() {\n+              @Override\n+              ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n+                if (firstAttempt.getAndSet(false)) {\n+                  return Futures.immediateFailedFuture(new IllegalStateException());\n+                }\n+                return Futures.immediateFuture(Status.OK);\n+              }\n+            })\n+            .build(),\n+        SecurityPolicies.internalOnly());\n+    MethodDescriptor<Empty, Empty> method = methods.get(\"foo/method0\");\n+\n+    assertCallFailure(method, Status.INTERNAL);\n+    assertCallSuccess(method);\n+  }\n+\n+  @Test\n+  public void testCancelledFuturesAreNotCachedPermanently() throws Exception {\n+    AtomicReference<Boolean> firstAttempt = new AtomicReference<>(true);\n+    createChannel(\n+        ServerSecurityPolicy.newBuilder()\n+            .servicePolicy(\"foo\", new AsyncSecurityPolicy() {\n+              @Override\n+              ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n+                if (firstAttempt.getAndSet(false)) {\n+                  return Futures.immediateCancelledFuture();\n+                }\n+                return Futures.immediateFuture(Status.OK);\n+              }\n+            })\n+            .build(),\n+        SecurityPolicies.internalOnly());\n+    MethodDescriptor<Empty, Empty> method = methods.get(\"foo/method0\");\n+\n+    assertCallFailure(method, Status.INTERNAL);\n+    assertCallSuccess(method);\n+  }\n+\n   @Test\n   public void testClientDoesntTrustServer() throws Exception {\n     createChannel(SecurityPolicies.serverInternalOnly(), policy((uid) -> false));\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10683",
    "pr_id": 10683,
    "issue_id": 10672,
    "repo": "grpc/grpc-java",
    "problem_statement": "OutlierDetection can leak subchannels in AddressTracker\nOutlierDetectionLoadBalancer does not override Subchannel.shutdown() to remove the subchannel from AddressTracker. If a LB policy re-creates subchannels over its lifetime (without address changes, like the new pick-first will do), then these subchannels can accumulate and leak memory.\r\n\r\nWhile this is an existing bug today, I don't think any of our existing policies will trigger this issue. The policies today only shutdown subchannels when addresses change, and outlier detection cleans up the entire AddressTracker in that case.\r\n\r\nBut the fix here should be easy, and it will be important very soon, so we should do this sooner than later.",
    "issue_word_count": 108,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java",
      "util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java"
    ],
    "pr_changed_test_files": [
      "util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java"
    ],
    "base_commit": "e89389a50a70931938c81bf3e577ad7c244229c2",
    "head_commit": "a7b7018dbd20cb0c6b97445258117b8b6dea5784",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10683",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10683",
    "dockerfile": "",
    "pr_merged_at": "2023-11-17T23:04:45.000Z",
    "patch": "diff --git a/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java b/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java\nindex 855e6852491..e94811ac0e3 100644\n--- a/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java\n+++ b/util/src/main/java/io/grpc/util/OutlierDetectionLoadBalancer.java\n@@ -257,6 +257,14 @@ public void start(SubchannelStateListener listener) {\n       super.start(new OutlierDetectionSubchannelStateListener(listener));\n     }\n \n+    @Override\n+    public void shutdown() {\n+      if (addressTracker != null) {\n+        addressTracker.removeSubchannel(this);\n+      }\n+      super.shutdown();\n+    }\n+\n     @Override\n     public Attributes getAttributes() {\n       if (addressTracker != null) {\n",
    "test_patch": "diff --git a/util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java b/util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java\nindex e40a5a15fc0..c2a9c15d96a 100644\n--- a/util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java\n+++ b/util/src/test/java/io/grpc/util/OutlierDetectionLoadBalancerTest.java\n@@ -112,6 +112,8 @@ public class OutlierDetectionLoadBalancerTest {\n   @Captor\n   private ArgumentCaptor<ConnectivityState> stateCaptor;\n \n+  private FakeLoadBalancer fakeChildLb;\n+\n   private final LoadBalancerProvider mockChildLbProvider = new StandardLoadBalancerProvider(\n       \"foo_policy\") {\n     @Override\n@@ -123,7 +125,10 @@ public LoadBalancer newLoadBalancer(Helper helper) {\n       \"fake_policy\") {\n     @Override\n     public LoadBalancer newLoadBalancer(Helper helper) {\n-      return new FakeLoadBalancer(helper);\n+      if (fakeChildLb == null) {\n+        fakeChildLb = new FakeLoadBalancer(helper);\n+      }\n+      return fakeChildLb;\n     }\n   };\n   private final LoadBalancerProvider roundRobinLbProvider = new StandardLoadBalancerProvider(\n@@ -266,6 +271,29 @@ public void acceptResolvedAddresses() {\n     assertThat(task.getDelay(TimeUnit.NANOSECONDS)).isEqualTo(config.intervalNanos);\n   }\n \n+  /**\n+   * The child LB might recreate subchannels leaving the ones we are tracking\n+   * orphaned in the address tracker. Make sure subchannels that are shut down get\n+   * removed from the tracker.\n+   */\n+  @Test\n+  public void childLbRecreatesSubchannels() {\n+    OutlierDetectionLoadBalancerConfig config = new OutlierDetectionLoadBalancerConfig.Builder()\n+        .setSuccessRateEjection(new SuccessRateEjection.Builder().build())\n+        .setChildPolicy(new PolicySelection(fakeLbProvider, null)).build();\n+\n+    loadBalancer.acceptResolvedAddresses(buildResolvedAddress(config, servers.get(0)));\n+\n+    assertThat(loadBalancer.trackerMap).hasSize(1);\n+    AddressTracker addressTracker = (AddressTracker) loadBalancer.trackerMap.values().toArray()[0];\n+    assertThat(addressTracker).isNotNull();\n+    OutlierDetectionSubchannel trackedSubchannel\n+        = (OutlierDetectionSubchannel) addressTracker.getSubchannels().toArray()[0];\n+\n+    fakeChildLb.recreateSubchannels();\n+    assertThat(addressTracker.getSubchannels()).doesNotContain(trackedSubchannel);\n+  }\n+\n   /**\n    * Outlier detection first enabled, then removed.\n    */\n@@ -1227,6 +1255,22 @@ public void handleNameResolutionError(Status error) {\n     public void shutdown() {\n     }\n \n+    // Simulates a situation where a load balancer might recreate some of the subchannels it is\n+    // tracking even if acceptResolvedAddresses() has not been called.\n+    void recreateSubchannels() {\n+      List<Subchannel> newSubchannelList = new ArrayList<>(subchannelList.size());\n+      for (Subchannel subchannel : subchannelList) {\n+        Subchannel newSubchannel = helper\n+            .createSubchannel(\n+                CreateSubchannelArgs.newBuilder().setAddresses(subchannel.getAddresses()).build());\n+        newSubchannel.start(mock(SubchannelStateListener.class));\n+        subchannel.shutdown();\n+        newSubchannelList.add(newSubchannel);\n+      }\n+      subchannelList = newSubchannelList;\n+      deliverSubchannelState(READY);\n+    }\n+\n     void deliverSubchannelState(ConnectivityState state) {\n       SubchannelPicker picker = new SubchannelPicker() {\n         @Override\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10646",
    "pr_id": 10646,
    "issue_id": 10647,
    "repo": "grpc/grpc-java",
    "problem_statement": "Client-side transport hooks\n### Is your feature request related to a problem?\r\nWe're trying to add some stats on the number of connections opened, closed, and active on the client side for grpc-java. On the server side, ServerTransportFilter acts as a reasonable hook for this, but there doesn't seem to be anything comparable on the client side that I can find (if there is, please direct me to it!).\r\n\r\n### Describe the solution you'd like\r\nA hook into the underlying transport information would be really helpful here. In particular I've thought up two options\r\n1.  A ClientTransportFilter. I put together an implementation for this that's more or less parallel to the Server side filter. It's a very simple change\r\n2. A Java equivalent of grpc-go's StatsHandler. I think this would be a great generalized solution to metrics in grpc-java. Right now, setting up grpc metrics requires a combination of StreamTracers and Interceptors, but with this strategy folks can instrument their metrics in one localized place and add it via an `addStatsHandler` API. I do not have a POC for this option, but I can put one together if it's your preference. \r\n\r\nPlease let me know if either of these solutions are suitable to you folks! \r\n",
    "issue_word_count": 215,
    "test_files_count": 6,
    "non_test_files_count": 14,
    "pr_changed_files": [
      "api/src/main/java/io/grpc/ClientTransportFilter.java",
      "api/src/main/java/io/grpc/ForwardingChannelBuilder2.java",
      "api/src/main/java/io/grpc/ManagedChannelBuilder.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderTransport.java",
      "core/src/main/java/io/grpc/internal/InternalSubchannel.java",
      "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java",
      "core/src/main/java/io/grpc/internal/ManagedChannelImplBuilder.java",
      "core/src/main/java/io/grpc/internal/ManagedClientTransport.java",
      "core/src/main/java/io/grpc/internal/OobChannel.java",
      "core/src/test/java/io/grpc/internal/InternalSubchannelTest.java",
      "core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java",
      "core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java",
      "cronet/src/main/java/io/grpc/cronet/CronetClientTransport.java",
      "cronet/src/test/java/io/grpc/cronet/CronetClientTransportTest.java",
      "inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java",
      "netty/src/main/java/io/grpc/netty/ClientTransportLifecycleManager.java",
      "netty/src/main/java/io/grpc/netty/NettyClientHandler.java",
      "netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java",
      "netty/src/test/java/io/grpc/netty/NettyTransportTest.java",
      "okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/InternalSubchannelTest.java",
      "core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java",
      "core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java",
      "cronet/src/test/java/io/grpc/cronet/CronetClientTransportTest.java",
      "netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java",
      "netty/src/test/java/io/grpc/netty/NettyTransportTest.java"
    ],
    "base_commit": "15fc70be2ab92271f0a74c9cd04a73eba66193aa",
    "head_commit": "dfadf853dae8c58e99722f51cfd51ef7afba64e5",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10646",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10646",
    "dockerfile": "",
    "pr_merged_at": "2024-01-03T18:45:23.000Z",
    "patch": "diff --git a/api/src/main/java/io/grpc/ClientTransportFilter.java b/api/src/main/java/io/grpc/ClientTransportFilter.java\nnew file mode 100644\nindex 00000000000..286a5eeb185\n--- /dev/null\n+++ b/api/src/main/java/io/grpc/ClientTransportFilter.java\n@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2023 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc;\n+\n+/**\n+ * Listens on the client transport life-cycle events. These filters do not have the capability\n+ * to modify the channels or transport life-cycle event behavior, but they can be useful hooks\n+ * for transport observability. Multiple filters may be registered to the client.\n+ *\n+ * @since 1.61.0\n+ */\n+@ExperimentalApi(\"https://gitub.com/grpc/grpc-java/issues/10652\")\n+public abstract class ClientTransportFilter {\n+  /**\n+   * Called when a transport is ready to accept traffic (when a connection has been established).\n+   * The default implementation is a no-op.\n+   *\n+   * @param transportAttrs current transport attributes\n+   *\n+   * @return new transport attributes. Default implementation returns the passed-in attributes\n+   *     intact.\n+   */\n+  public Attributes transportReady(Attributes transportAttrs) {\n+    return transportAttrs;\n+  }\n+\n+  /**\n+   * Called when a transport completed shutting down. All resources have been released.\n+   * All streams have either been closed or transferred off this transport.\n+   * Default implementation is a no-op\n+   *\n+   * @param transportAttrs the effective transport attributes, which is what is returned by {@link\n+   * #transportReady} of the last executed filter.\n+   */\n+  public void transportTerminated(Attributes transportAttrs) {\n+  }\n+}\n\ndiff --git a/api/src/main/java/io/grpc/ForwardingChannelBuilder2.java b/api/src/main/java/io/grpc/ForwardingChannelBuilder2.java\nindex f71f3eea141..77686ff4ddb 100644\n--- a/api/src/main/java/io/grpc/ForwardingChannelBuilder2.java\n+++ b/api/src/main/java/io/grpc/ForwardingChannelBuilder2.java\n@@ -94,6 +94,12 @@ public T intercept(ClientInterceptor... interceptors) {\n     return thisT();\n   }\n \n+  @Override\n+  public T addTransportFilter(ClientTransportFilter transportFilter) {\n+    delegate().addTransportFilter(transportFilter);\n+    return thisT();\n+  }\n+\n   @Override\n   public T userAgent(String userAgent) {\n     delegate().userAgent(userAgent);\n\ndiff --git a/api/src/main/java/io/grpc/ManagedChannelBuilder.java b/api/src/main/java/io/grpc/ManagedChannelBuilder.java\nindex 2fb9252fbbe..1a2e4fc103f 100644\n--- a/api/src/main/java/io/grpc/ManagedChannelBuilder.java\n+++ b/api/src/main/java/io/grpc/ManagedChannelBuilder.java\n@@ -159,6 +159,18 @@ public T offloadExecutor(Executor executor) {\n    */\n   public abstract T intercept(ClientInterceptor... interceptors);\n \n+  /**\n+   * Adds a {@link ClientTransportFilter}. The order of filters being added is the order they will\n+   * be executed\n+   *\n+   * @return this\n+   * @since 1.60.0\n+   */\n+  @ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/10652\")\n+  public T addTransportFilter(ClientTransportFilter filter) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n   /**\n    * Provides a custom {@code User-Agent} for the application.\n    *\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java b/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\nindex c17fb01fc9a..6880f07dd4c 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\n@@ -758,6 +758,7 @@ private void checkSecurityPolicy(IBinder binder) {\n             // triggers), could have shut us down.\n             if (!isShutdown()) {\n               setState(TransportState.READY);\n+              attributes = clientTransportListener.filterTransport(attributes);\n               clientTransportListener.transportReady();\n             }\n           }\n\ndiff --git a/core/src/main/java/io/grpc/internal/InternalSubchannel.java b/core/src/main/java/io/grpc/internal/InternalSubchannel.java\nindex 46582645133..a986cb2deff 100644\n--- a/core/src/main/java/io/grpc/internal/InternalSubchannel.java\n+++ b/core/src/main/java/io/grpc/internal/InternalSubchannel.java\n@@ -35,6 +35,7 @@\n import io.grpc.ChannelLogger;\n import io.grpc.ChannelLogger.ChannelLogLevel;\n import io.grpc.ClientStreamTracer;\n+import io.grpc.ClientTransportFilter;\n import io.grpc.ConnectivityState;\n import io.grpc.ConnectivityStateInfo;\n import io.grpc.EquivalentAddressGroup;\n@@ -77,6 +78,8 @@ final class InternalSubchannel implements InternalInstrumented<ChannelStats>, Tr\n   private final ChannelTracer channelTracer;\n   private final ChannelLogger channelLogger;\n \n+  private final List<ClientTransportFilter> transportFilters;\n+\n   /**\n    * All field must be mutated in the syncContext.\n    */\n@@ -159,7 +162,8 @@ protected void handleNotInUse() {\n       ClientTransportFactory transportFactory, ScheduledExecutorService scheduledExecutor,\n       Supplier<Stopwatch> stopwatchSupplier, SynchronizationContext syncContext, Callback callback,\n       InternalChannelz channelz, CallTracer callsTracer, ChannelTracer channelTracer,\n-      InternalLogId logId, ChannelLogger channelLogger) {\n+      InternalLogId logId, ChannelLogger channelLogger,\n+      List<ClientTransportFilter> transportFilters) {\n     Preconditions.checkNotNull(addressGroups, \"addressGroups\");\n     Preconditions.checkArgument(!addressGroups.isEmpty(), \"addressGroups is empty\");\n     checkListHasNoNulls(addressGroups, \"addressGroups contains null entry\");\n@@ -180,6 +184,7 @@ protected void handleNotInUse() {\n     this.channelTracer = Preconditions.checkNotNull(channelTracer, \"channelTracer\");\n     this.logId = Preconditions.checkNotNull(logId, \"logId\");\n     this.channelLogger = Preconditions.checkNotNull(channelLogger, \"channelLogger\");\n+    this.transportFilters = transportFilters;\n   }\n \n   ChannelLogger getChannelLogger() {\n@@ -539,6 +544,15 @@ private class TransportListener implements ManagedClientTransport.Listener {\n       this.transport = transport;\n     }\n \n+    @Override\n+    public Attributes filterTransport(Attributes attributes) {\n+      for (ClientTransportFilter filter : transportFilters) {\n+        attributes = Preconditions.checkNotNull(filter.transportReady(attributes),\n+            \"Filter %s returned null\", filter);\n+      }\n+      return attributes;\n+    }\n+\n     @Override\n     public void transportReady() {\n       channelLogger.log(ChannelLogLevel.INFO, \"READY\");\n@@ -607,6 +621,9 @@ public void transportTerminated() {\n       channelLogger.log(ChannelLogLevel.INFO, \"{0} Terminated\", transport.getLogId());\n       channelz.removeClientSocket(transport);\n       handleTransportInUseState(transport, false);\n+      for (ClientTransportFilter filter : transportFilters) {\n+        filter.transportTerminated(transport.getAttributes());\n+      }\n       syncContext.execute(new Runnable() {\n         @Override\n         public void run() {\n\ndiff --git a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\nindex a6e5e80f38f..5d600d1ca5e 100644\n--- a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n+++ b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n@@ -42,6 +42,7 @@\n import io.grpc.ClientInterceptor;\n import io.grpc.ClientInterceptors;\n import io.grpc.ClientStreamTracer;\n+import io.grpc.ClientTransportFilter;\n import io.grpc.CompressorRegistry;\n import io.grpc.ConnectivityState;\n import io.grpc.ConnectivityStateInfo;\n@@ -209,6 +210,8 @@ public void uncaughtException(Thread t, Throwable e) {\n    * {@link RealChannel}.\n    */\n   private final Channel interceptorChannel;\n+\n+  private final List<ClientTransportFilter> transportFilters;\n   @Nullable private final String userAgent;\n \n   // Only null after channel is terminated. Must be assigned from the syncContext.\n@@ -661,6 +664,7 @@ ClientStream newSubstream(\n       channel = builder.binlog.wrapChannel(channel);\n     }\n     this.interceptorChannel = ClientInterceptors.intercept(channel, interceptors);\n+    this.transportFilters = new ArrayList<>(builder.transportFilters);\n     this.stopwatchSupplier = checkNotNull(stopwatchSupplier, \"stopwatchSupplier\");\n     if (builder.idleTimeoutMillis == IDLE_TIMEOUT_MILLIS_DISABLE) {\n       this.idleTimeoutMillis = builder.idleTimeoutMillis;\n@@ -1566,7 +1570,8 @@ void onStateChange(InternalSubchannel is, ConnectivityStateInfo newState) {\n           callTracerFactory.create(),\n           subchannelTracer,\n           subchannelLogId,\n-          subchannelLogger);\n+          subchannelLogger,\n+          transportFilters);\n       oobChannelTracer.reportEvent(new ChannelTrace.Event.Builder()\n           .setDescription(\"Child Subchannel created\")\n           .setSeverity(ChannelTrace.Event.Severity.CT_INFO)\n@@ -1990,7 +1995,8 @@ void onNotInUse(InternalSubchannel is) {\n           callTracerFactory.create(),\n           subchannelTracer,\n           subchannelLogId,\n-          subchannelLogger);\n+          subchannelLogger,\n+          transportFilters);\n \n       channelTracer.reportEvent(new ChannelTrace.Event.Builder()\n           .setDescription(\"Child Subchannel started\")\n@@ -2148,6 +2154,11 @@ public void transportReady() {\n       // Don't care\n     }\n \n+    @Override\n+    public Attributes filterTransport(Attributes attributes) {\n+      return attributes;\n+    }\n+\n     @Override\n     public void transportInUse(final boolean inUse) {\n       inUseStateAggregator.updateObjectInUse(delayedTransport, inUse);\n\ndiff --git a/core/src/main/java/io/grpc/internal/ManagedChannelImplBuilder.java b/core/src/main/java/io/grpc/internal/ManagedChannelImplBuilder.java\nindex bf96af6ebe8..e4176bf8633 100644\n--- a/core/src/main/java/io/grpc/internal/ManagedChannelImplBuilder.java\n+++ b/core/src/main/java/io/grpc/internal/ManagedChannelImplBuilder.java\n@@ -17,6 +17,7 @@\n package io.grpc.internal;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n@@ -27,6 +28,7 @@\n import io.grpc.CallCredentials;\n import io.grpc.ChannelCredentials;\n import io.grpc.ClientInterceptor;\n+import io.grpc.ClientTransportFilter;\n import io.grpc.CompressorRegistry;\n import io.grpc.DecompressorRegistry;\n import io.grpc.EquivalentAddressGroup;\n@@ -137,6 +139,8 @@ public static ManagedChannelBuilder<?> forTarget(String target) {\n   private final List<ClientInterceptor> interceptors = new ArrayList<>();\n   NameResolverRegistry nameResolverRegistry = NameResolverRegistry.getDefaultRegistry();\n \n+  final List<ClientTransportFilter> transportFilters = new ArrayList<>();\n+\n   final String target;\n   @Nullable\n   final ChannelCredentials channelCredentials;\n@@ -267,11 +271,11 @@ public ManagedChannelImplBuilder(\n       String target, @Nullable ChannelCredentials channelCreds, @Nullable CallCredentials callCreds,\n       ClientTransportFactoryBuilder clientTransportFactoryBuilder,\n       @Nullable ChannelBuilderDefaultPortProvider channelBuilderDefaultPortProvider) {\n-    this.target = Preconditions.checkNotNull(target, \"target\");\n+    this.target = checkNotNull(target, \"target\");\n     this.channelCredentials = channelCreds;\n     this.callCredentials = callCreds;\n-    this.clientTransportFactoryBuilder = Preconditions\n-        .checkNotNull(clientTransportFactoryBuilder, \"clientTransportFactoryBuilder\");\n+    this.clientTransportFactoryBuilder = checkNotNull(clientTransportFactoryBuilder,\n+        \"clientTransportFactoryBuilder\");\n     this.directServerAddress = null;\n \n     if (channelBuilderDefaultPortProvider != null) {\n@@ -323,8 +327,8 @@ public ManagedChannelImplBuilder(SocketAddress directServerAddress, String autho\n     this.target = makeTargetStringForDirectAddress(directServerAddress);\n     this.channelCredentials = channelCreds;\n     this.callCredentials = callCreds;\n-    this.clientTransportFactoryBuilder = Preconditions\n-        .checkNotNull(clientTransportFactoryBuilder, \"clientTransportFactoryBuilder\");\n+    this.clientTransportFactoryBuilder = checkNotNull(clientTransportFactoryBuilder,\n+        \"clientTransportFactoryBuilder\");\n     this.directServerAddress = directServerAddress;\n     NameResolverRegistry reg = new NameResolverRegistry();\n     reg.register(new DirectAddressNameResolverProvider(directServerAddress,\n@@ -374,6 +378,12 @@ public ManagedChannelImplBuilder intercept(ClientInterceptor... interceptors) {\n     return intercept(Arrays.asList(interceptors));\n   }\n \n+  @Override\n+  public ManagedChannelImplBuilder addTransportFilter(ClientTransportFilter hook) {\n+    transportFilters.add(checkNotNull(hook, \"transport filter\"));\n+    return this;\n+  }\n+\n   @Deprecated\n   @Override\n   public ManagedChannelImplBuilder nameResolverFactory(NameResolver.Factory resolverFactory) {\n\ndiff --git a/core/src/main/java/io/grpc/internal/ManagedClientTransport.java b/core/src/main/java/io/grpc/internal/ManagedClientTransport.java\nindex d38721af78d..a6a271bdb21 100644\n--- a/core/src/main/java/io/grpc/internal/ManagedClientTransport.java\n+++ b/core/src/main/java/io/grpc/internal/ManagedClientTransport.java\n@@ -16,6 +16,7 @@\n \n package io.grpc.internal;\n \n+import io.grpc.Attributes;\n import io.grpc.Status;\n import javax.annotation.CheckReturnValue;\n import javax.annotation.Nullable;\n@@ -104,5 +105,11 @@ interface Listener {\n      * at least one stream.\n      */\n     void transportInUse(boolean inUse);\n+\n+    /**\n+     * Called just before {@link #transportReady} to allow direct modification of transport\n+     * Attributes.\n+     */\n+    Attributes filterTransport(Attributes attributes);\n   }\n }\n\ndiff --git a/core/src/main/java/io/grpc/internal/OobChannel.java b/core/src/main/java/io/grpc/internal/OobChannel.java\nindex 589824ae10e..01ef457460f 100644\n--- a/core/src/main/java/io/grpc/internal/OobChannel.java\n+++ b/core/src/main/java/io/grpc/internal/OobChannel.java\n@@ -130,6 +130,11 @@ public void transportReady() {\n           // Don't care\n         }\n \n+        @Override\n+        public Attributes filterTransport(Attributes attributes) {\n+          return attributes;\n+        }\n+\n         @Override\n         public void transportInUse(boolean inUse) {\n           // Don't care\n\ndiff --git a/cronet/src/main/java/io/grpc/cronet/CronetClientTransport.java b/cronet/src/main/java/io/grpc/cronet/CronetClientTransport.java\nindex d41ec372d4c..800d9155854 100644\n--- a/cronet/src/main/java/io/grpc/cronet/CronetClientTransport.java\n+++ b/cronet/src/main/java/io/grpc/cronet/CronetClientTransport.java\n@@ -61,7 +61,7 @@ class CronetClientTransport implements ConnectionClientTransport {\n   private final int maxMessageSize;\n   private final boolean alwaysUsePut;\n   private final TransportTracer transportTracer;\n-  private final Attributes attrs;\n+  private Attributes attrs;\n   private final boolean useGetForSafeMethods;\n   private final boolean usePutForIdempotentMethods;\n   // Indicates the transport is in go-away state: no new streams will be processed,\n@@ -169,6 +169,7 @@ public Runnable start(Listener listener) {\n     return new Runnable() {\n       @Override\n       public void run() {\n+        attrs = CronetClientTransport.this.listener.filterTransport(attrs);\n         // Listener callbacks should not be called simultaneously\n         CronetClientTransport.this.listener.transportReady();\n       }\n\ndiff --git a/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java b/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java\nindex 88265ec8bbf..91e519f9efc 100644\n--- a/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java\n+++ b/inprocess/src/main/java/io/grpc/inprocess/InProcessTransport.java\n@@ -106,7 +106,7 @@ final class InProcessTransport implements ServerTransport, ConnectionClientTrans\n           new IdentityHashMap<InProcessStream, Boolean>());\n   @GuardedBy(\"this\")\n   private List<ServerStreamTracer.Factory> serverStreamTracerFactories;\n-  private final Attributes attributes;\n+  private Attributes attributes;\n \n   private Thread.UncaughtExceptionHandler uncaughtExceptionHandler =\n       new Thread.UncaughtExceptionHandler() {\n@@ -213,6 +213,7 @@ public void run() {\n               .set(Grpc.TRANSPORT_ATTR_LOCAL_ADDR, address)\n               .build();\n           serverStreamAttributes = serverTransportListener.transportReady(serverTransportAttrs);\n+          attributes = clientTransportListener.filterTransport(attributes);\n           clientTransportListener.transportReady();\n         }\n       }\n\ndiff --git a/netty/src/main/java/io/grpc/netty/ClientTransportLifecycleManager.java b/netty/src/main/java/io/grpc/netty/ClientTransportLifecycleManager.java\nindex 1111904086a..4addf59215c 100644\n--- a/netty/src/main/java/io/grpc/netty/ClientTransportLifecycleManager.java\n+++ b/netty/src/main/java/io/grpc/netty/ClientTransportLifecycleManager.java\n@@ -17,6 +17,7 @@\n package io.grpc.netty;\n \n import com.google.errorprone.annotations.CanIgnoreReturnValue;\n+import io.grpc.Attributes;\n import io.grpc.Status;\n import io.grpc.internal.ManagedClientTransport;\n \n@@ -36,12 +37,14 @@ public ClientTransportLifecycleManager(ManagedClientTransport.Listener listener)\n     this.listener = listener;\n   }\n \n-  public void notifyReady() {\n+  public Attributes notifyReady(Attributes attributes) {\n     if (transportReady || transportShutdown) {\n-      return;\n+      return attributes;\n     }\n     transportReady = true;\n+    attributes = listener.filterTransport(attributes);\n     listener.transportReady();\n+    return attributes;\n   }\n \n   /**\n\ndiff --git a/netty/src/main/java/io/grpc/netty/NettyClientHandler.java b/netty/src/main/java/io/grpc/netty/NettyClientHandler.java\nindex 792d76b1358..f30576799be 100644\n--- a/netty/src/main/java/io/grpc/netty/NettyClientHandler.java\n+++ b/netty/src/main/java/io/grpc/netty/NettyClientHandler.java\n@@ -913,7 +913,7 @@ private class FrameListener extends Http2FrameAdapter {\n     public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) {\n       if (firstSettings) {\n         firstSettings = false;\n-        lifecycleManager.notifyReady();\n+        attributes = lifecycleManager.notifyReady(attributes);\n       }\n     }\n \n\ndiff --git a/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java b/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java\nindex ea3bf77e990..43077692d3b 100644\n--- a/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java\n+++ b/okhttp/src/main/java/io/grpc/okhttp/OkHttpClientTransport.java\n@@ -1283,6 +1283,7 @@ public void settings(boolean clearPrevious, Settings settings) {\n           outboundWindowSizeIncreased = outboundFlow.initialOutboundWindowSize(initialWindowSize);\n         }\n         if (firstSettings) {\n+          attributes = listener.filterTransport(attributes);\n           listener.transportReady();\n           firstSettings = false;\n         }\n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/InternalSubchannelTest.java b/core/src/test/java/io/grpc/internal/InternalSubchannelTest.java\nindex 0359dbef95b..05dc4549a0e 100644\n--- a/core/src/test/java/io/grpc/internal/InternalSubchannelTest.java\n+++ b/core/src/test/java/io/grpc/internal/InternalSubchannelTest.java\n@@ -54,6 +54,7 @@\n import io.grpc.internal.TestUtils.MockClientTransportInfo;\n import java.net.SocketAddress;\n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.concurrent.BlockingQueue;\n@@ -1360,7 +1361,8 @@ private void createInternalSubchannel(EquivalentAddressGroup ... addrs) {\n         channelz, CallTracer.getDefaultFactory().create(),\n         subchannelTracer,\n         logId,\n-        new ChannelLoggerImpl(subchannelTracer, fakeClock.getTimeProvider()));\n+        new ChannelLoggerImpl(subchannelTracer, fakeClock.getTimeProvider()),\n+          Collections.emptyList());\n   }\n \n   private void assertNoCallbackInvoke() {\n\ndiff --git a/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java b/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\nindex dd7c7904a3d..04926cc25a5 100644\n--- a/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\n+++ b/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\n@@ -72,6 +72,7 @@\n import io.grpc.ClientInterceptors;\n import io.grpc.ClientStreamTracer;\n import io.grpc.ClientStreamTracer.StreamInfo;\n+import io.grpc.ClientTransportFilter;\n import io.grpc.CompositeChannelCredentials;\n import io.grpc.ConnectivityState;\n import io.grpc.ConnectivityStateInfo;\n@@ -139,6 +140,7 @@\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n import javax.annotation.Nullable;\n@@ -4240,6 +4242,48 @@ public void createResolvingOobChannel() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void transportFilters() {\n+\n+    final AtomicInteger readyCallbackCalled = new AtomicInteger(0);\n+    final AtomicInteger terminationCallbackCalled = new AtomicInteger(0);\n+    ClientTransportFilter transportFilter = new ClientTransportFilter() {\n+      @Override\n+      public Attributes transportReady(Attributes transportAttrs) {\n+        readyCallbackCalled.incrementAndGet();\n+        return transportAttrs;\n+      }\n+\n+      @Override\n+      public void transportTerminated(Attributes transportAttrs) {\n+        terminationCallbackCalled.incrementAndGet();\n+      }\n+    };\n+\n+    channelBuilder.addTransportFilter(transportFilter);\n+    assertEquals(0, readyCallbackCalled.get());\n+\n+    createChannel();\n+    final Subchannel subchannel =\n+        createSubchannelSafely(helper, addressGroup, Attributes.EMPTY, subchannelStateListener);\n+    requestConnectionSafely(helper, subchannel);\n+    verify(mockTransportFactory)\n+        .newClientTransport(\n+        any(SocketAddress.class), any(ClientTransportOptions.class), any(ChannelLogger.class));\n+    MockClientTransportInfo transportInfo = transports.poll();\n+    ManagedClientTransport.Listener transportListener = transportInfo.listener;\n+\n+    transportListener.filterTransport(Attributes.EMPTY);\n+    transportListener.transportReady();\n+    assertEquals(1, readyCallbackCalled.get());\n+    assertEquals(0, terminationCallbackCalled.get());\n+\n+    transportListener.transportShutdown(Status.OK);\n+\n+    transportListener.transportTerminated();\n+    assertEquals(1, terminationCallbackCalled.get());\n+  }\n+\n   private static final class FakeBackoffPolicyProvider implements BackoffPolicy.Provider {\n     @Override\n     public BackoffPolicy get() {\n\ndiff --git a/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java b/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\nindex 4dd0500cc36..2e99085fe6b 100644\n--- a/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\n+++ b/core/src/testFixtures/java/io/grpc/internal/AbstractTransportTest.java\n@@ -38,6 +38,7 @@\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.timeout;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n import com.google.common.base.Objects;\n import com.google.common.collect.Lists;\n@@ -219,6 +220,7 @@ public ServerStreamTracer newServerStreamTracer(String fullMethodName, Metadata\n   @Before\n   public void setUp() {\n     server = newServer(Arrays.asList(serverStreamTracerFactory));\n+    when(mockClientTransportListener.filterTransport(any())).thenAnswer(i -> i.getArguments()[0]);\n   }\n \n   @After\n@@ -2136,6 +2138,7 @@ private static void startTransport(\n       ManagedClientTransport clientTransport,\n       ManagedClientTransport.Listener listener) {\n     runIfNotNull(clientTransport.start(listener));\n+    verify(listener, timeout(TIMEOUT_MS)).filterTransport(any());\n     verify(listener, timeout(TIMEOUT_MS)).transportReady();\n   }\n \n\ndiff --git a/cronet/src/test/java/io/grpc/cronet/CronetClientTransportTest.java b/cronet/src/test/java/io/grpc/cronet/CronetClientTransportTest.java\nindex 3fd2d523913..cc18f33aaea 100644\n--- a/cronet/src/test/java/io/grpc/cronet/CronetClientTransportTest.java\n+++ b/cronet/src/test/java/io/grpc/cronet/CronetClientTransportTest.java\n@@ -80,6 +80,8 @@ public void execute(Runnable r) {\n \n   @Before\n   public void setUp() {\n+    when(clientTransportListener.filterTransport(any()))\n+        .thenAnswer(i -> i.getArgument(0, Attributes.class));\n     transport =\n         new CronetClientTransport(\n             streamFactory,\n\ndiff --git a/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java b/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java\nindex 502c0f68a6f..7858d1387f8 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java\n@@ -35,6 +35,8 @@\n import static org.junit.Assert.assertSame;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n \n import com.google.common.base.Ticker;\n import com.google.common.io.ByteStreams;\n@@ -105,6 +107,7 @@\n import javax.net.ssl.SSLException;\n import javax.net.ssl.SSLHandshakeException;\n import org.junit.After;\n+import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -143,6 +146,11 @@ public class NettyClientTransportTest {\n   private String authority;\n   private NettyServer server;\n \n+  @Before\n+  public void setup() {\n+    when(clientTransportListener.filterTransport(any())).thenAnswer(i -> i.getArguments()[0]);\n+  }\n+\n   @After\n   public void teardown() throws Exception {\n     for (NettyClientTransport transport : transports) {\n\ndiff --git a/netty/src/test/java/io/grpc/netty/NettyTransportTest.java b/netty/src/test/java/io/grpc/netty/NettyTransportTest.java\nindex 6aa6ca1b32a..b1c89e22f93 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyTransportTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyTransportTest.java\n@@ -20,6 +20,7 @@\n import static org.junit.Assert.assertEquals;\n \n import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Attributes;\n import io.grpc.ChannelLogger;\n import io.grpc.ServerStreamTracer;\n import io.grpc.Status;\n@@ -144,6 +145,11 @@ public void transportInUse(boolean inUse) {\n         Throwable t = new Throwable(\"transport should have failed and shutdown but didnt\");\n         future.setException(t);\n       }\n+\n+      @Override\n+      public Attributes filterTransport(Attributes attributes) {\n+        return attributes;\n+      }\n     });\n     if (runnable != null) {\n       runnable.run();\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10644",
    "pr_id": 10644,
    "issue_id": 9058,
    "repo": "grpc/grpc-java",
    "problem_statement": "GRPC+ALTS client connection exception with Workload Identity\n### What version of gRPC-Java are you using?\r\n\r\nI am using the Google BOM in Maven.\r\n```\r\n            <dependency>\r\n                <groupId>com.google.cloud</groupId>\r\n                <artifactId>libraries-bom</artifactId>\r\n                <version>25.1.0</version>\r\n                <type>pom</type>\r\n                <scope>import</scope>\r\n            </dependency>\r\n```\r\nThis contains GRPC 1.45.0\r\n\r\n### What is your environment?\r\nDocker container running as GKE on GCP. Image from google/cloud-sdk:latest. Java 17.\r\nGoogle Endpoints is on the classpath running in Jetty, fyi. Worth mentioning GCP is using\r\nWorkload Identity, so the service account is annotated so as to be managed by Google.\r\n\r\n### What did you expect to see?\r\nI am testing the use of GRPC+ALTS for use in connecting an old service to another service. I would expect to see the call hit the server and return a result. I will add that if I use an unsecured ManagedChannelBuilder then the call works fine.\r\n\r\nclient (example):\r\n```\r\n var channel =  AltsChannelBuilder.forAddress(\"my-service\", 6565).addTargetServiceAccount(\"expected-service-account\") .build();\r\n var myService = MyServiceGrpc.newBlockingStub(channel);\r\n var result = myService.getValue(MyServiceInput.newBuilder().setKey(\"key\").build());\r\n```\r\n\r\n### What did you see instead?\r\nI see an \"unknown\" exception thrown by the client, \"io.grpc.StatusRuntimeException: UNKNOWN: Channel Pipeline: [TsiHandshakeHandler#0, WriteBufferingAndExceptionHandler#0, DefaultChannelPipeline$TailContext#0]\"\r\n\r\nI spoke with \"Eric Anderson\" on Gitter. He suggested I file this as an issue.\r\n\r\n### Steps to reproduce the bug\r\n\r\n<!-- Make sure you include information that can help us debug (full error message, exception listing, stack trace, logs). -->\r\n\r\nError:\r\n\"io.grpc.StatusRuntimeException: UNKNOWN: Channel Pipeline: [TsiHandshakeHandler#0, WriteBufferingAndExceptionHandler#0, DefaultChannelPipeline$TailContext#0]\"\r\n\r\n",
    "issue_word_count": 261,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "alts/src/main/java/io/grpc/alts/internal/AltsHandshakerStub.java",
      "alts/src/test/java/io/grpc/alts/internal/AltsHandshakerStubTest.java"
    ],
    "pr_changed_test_files": [
      "alts/src/test/java/io/grpc/alts/internal/AltsHandshakerStubTest.java"
    ],
    "base_commit": "a294b27d5222dc779805b576baf28ed33c46ebc0",
    "head_commit": "0fb3442d1bedaeead9ffe328a951db0a300e665d",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10644",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10644",
    "dockerfile": "",
    "pr_merged_at": "2023-11-03T14:50:52.000Z",
    "patch": "diff --git a/alts/src/main/java/io/grpc/alts/internal/AltsHandshakerStub.java b/alts/src/main/java/io/grpc/alts/internal/AltsHandshakerStub.java\nindex bb2ff9dbc4d..6c2748dcc9c 100644\n--- a/alts/src/main/java/io/grpc/alts/internal/AltsHandshakerStub.java\n+++ b/alts/src/main/java/io/grpc/alts/internal/AltsHandshakerStub.java\n@@ -33,7 +33,7 @@ class AltsHandshakerStub {\n   private final HandshakerServiceStub serviceStub;\n   private final ArrayBlockingQueue<Optional<HandshakerResp>> responseQueue =\n       new ArrayBlockingQueue<>(1);\n-  private final AtomicReference<String> exceptionMessage = new AtomicReference<>();\n+  private final AtomicReference<ThrowableInfo> exceptionMessage = new AtomicReference<>();\n \n   private static final long HANDSHAKE_RPC_DEADLINE_SECS = 20;\n \n@@ -72,7 +72,7 @@ public HandshakerResp send(HandshakerReq req) throws InterruptedException, IOExc\n     }\n \n     if (exceptionMessage.get() != null) {\n-      throw new IOException(exceptionMessage.get());\n+      throw new IOException(exceptionMessage.get().info, exceptionMessage.get().throwable);\n     } else {\n       throw new IOException(\"No handshaker response received\");\n     }\n@@ -89,7 +89,7 @@ private void createWriterIfNull() {\n   /** Throw exception if there is an outstanding exception. */\n   private void maybeThrowIoException() throws IOException {\n     if (exceptionMessage.get() != null) {\n-      throw new IOException(exceptionMessage.get());\n+      throw new IOException(exceptionMessage.get().info, exceptionMessage.get().throwable);\n     }\n   }\n \n@@ -108,7 +108,7 @@ public void onNext(HandshakerResp resp) {\n         AltsHandshakerStub.this.responseQueue.add(Optional.of(resp));\n       } catch (IllegalStateException e) {\n         AltsHandshakerStub.this.exceptionMessage.compareAndSet(\n-            null, \"Received an unexpected response.\");\n+            null, new ThrowableInfo(e, \"Received an unexpected response.\"));\n         AltsHandshakerStub.this.close();\n       }\n     }\n@@ -117,7 +117,7 @@ public void onNext(HandshakerResp resp) {\n     @Override\n     public void onError(Throwable t) {\n       AltsHandshakerStub.this.exceptionMessage.compareAndSet(\n-          null, \"Received a terminating error: \" + t.toString());\n+          null, new ThrowableInfo(t, \"Received a terminating error.\"));\n       // Trigger the release of any blocked send.\n       Optional<HandshakerResp> result = Optional.absent();\n       AltsHandshakerStub.this.responseQueue.offer(result);\n@@ -126,10 +126,22 @@ public void onError(Throwable t) {\n     /** Receive the closing message from the server. */\n     @Override\n     public void onCompleted() {\n-      AltsHandshakerStub.this.exceptionMessage.compareAndSet(null, \"Response stream closed.\");\n+      AltsHandshakerStub.this.exceptionMessage.compareAndSet(\n+          null, new ThrowableInfo(null, \"Response stream closed.\"));\n       // Trigger the release of any blocked send.\n       Optional<HandshakerResp> result = Optional.absent();\n       AltsHandshakerStub.this.responseQueue.offer(result);\n     }\n   }\n+\n+  private static class ThrowableInfo {\n+\n+    private final Throwable throwable;\n+    private final String info;\n+\n+    private ThrowableInfo(Throwable throwable, String info) {\n+      this.throwable = throwable;\n+      this.info = info;\n+    }\n+  }\n }\n",
    "test_patch": "diff --git a/alts/src/test/java/io/grpc/alts/internal/AltsHandshakerStubTest.java b/alts/src/test/java/io/grpc/alts/internal/AltsHandshakerStubTest.java\nindex 2267a765a90..fc2b440749a 100644\n--- a/alts/src/test/java/io/grpc/alts/internal/AltsHandshakerStubTest.java\n+++ b/alts/src/test/java/io/grpc/alts/internal/AltsHandshakerStubTest.java\n@@ -68,6 +68,7 @@ private void sendAndExpectError() throws InterruptedException {\n       fail(\"Exception expected\");\n     } catch (IOException ex) {\n       assertThat(ex).hasMessageThat().contains(\"Received a terminating error\");\n+      assertThat(ex.getCause()).hasMessageThat().contains(\"Root cause message\");\n     }\n   }\n \n@@ -152,7 +153,7 @@ public void onNext(final HandshakerReq req) {\n           reader.onNext(resp.setOutFrames(req.getNext().getInBytes()).build());\n           break;\n         case ERROR:\n-          reader.onError(new RuntimeException());\n+          reader.onError(new RuntimeException(\"Root cause message\"));\n           break;\n         case COMPLETE:\n           reader.onCompleted();\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10633",
    "pr_id": 10633,
    "issue_id": 10566,
    "repo": "grpc/grpc-java",
    "problem_statement": "SecurityPolicy should support async/slow implementations\n<!-- Please answer these questions before submitting a feature request. -->\r\n\r\n### Is your feature request related to a problem?\r\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\r\nThe [SecurityPolicy](https://github.com/grpc/grpc-java/blob/master/binder/src/main/java/io/grpc/binder/SecurityPolicy.java) class defines an abstract method that returns a Status. If computing such status requires running some slow piece of code (that, for instance, reads flags from storage or from the network), then the only option is to block the calling thread until such operation is completed.\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy extends SecurityPolicy {\r\n  @Override\r\n  public Status checkAuthorization(int uid) {\r\n    try {\r\n      // must block the calling thread to satisfy SecurityPolicy's API\r\n      return fetchAllowlistedUids().get().contains(uid) ? Status.OK : Status.PERMISSION_DENIED;\r\n    } catch (InterruptedException e) {\r\n      return Status.fromThrowable(e);\r\n    }\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nBlocking is generally undesirable, because it monopolizes a thread from the system for mostly idle work, which leads to sub-optimal performance by requiring new threads to be spawned or reducing the amount of threads available, thus the responsiveness of the system.\r\n\r\n### Describe the solution you'd like\r\n`SecurityPolicy` (or an equivalent replacement) should provide an API for returning a `ListenableFuture<Status>` instead. Clients are free to implement it however they see fit. The case commonly supported today (simple non-blocking computations) would be equivalent to returning a `Futures.immediateFuture(status)` (from Guava).\r\n\r\n```java\r\npublic interface AsyncSecurityPolicy {\r\n  ListenableFuture<Status> checkAuthorization(int uid);\r\n}\r\n```\r\n\r\nThen the code above can be written as non-blocking:\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy implements AsyncSecurityPolicy {\r\n  @Override\r\n  public ListenableFuture<Status> checkAuthorization(int uid) {\r\n    return Futures.transform(\r\n      fetchAllowlistedUids(),\r\n      allowlist -> allowlist.contains(uid) ? Status.OK : Status.PERMISSION_DENIED,\r\n      someExecutor);\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\n### Describe alternatives you've considered\r\nN/A\r\n\r\n### Additional context\r\nSome apps use [StrictPolicy.VmPolicy](https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy) to instruct which kinds of threads are appropriate for different kinds of tasks (e.g. lightweight computations vs blocking network access). It can be used to configure different \"penalties\", like just logging in production or crashing in development. The issue above has triggered such violations during the development of an internal Google app.",
    "issue_word_count": 373,
    "test_files_count": 2,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java",
      "binder/src/main/java/io/grpc/binder/BinderServerBuilder.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderServer.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java",
      "binder/src/main/java/io/grpc/binder/internal/PendingAuthListener.java",
      "binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java"
    ],
    "pr_changed_test_files": [
      "binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java",
      "binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java"
    ],
    "base_commit": "b6947de95a5b4d46da8ce5cd2bc50f89ade9db08",
    "head_commit": "6f6cde9b1372c480bd730c470e615ec73a0b82da",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10633",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10633",
    "dockerfile": "",
    "pr_merged_at": "2023-12-06T10:13:29.000Z",
    "patch": "diff --git a/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java b/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java\nindex dafb884d6b1..158f7947ee8 100644\n--- a/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java\n+++ b/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java\n@@ -33,9 +33,14 @@\n import io.grpc.internal.ServerImplBuilder;\n import io.grpc.internal.ObjectPool;\n import io.grpc.internal.SharedResourcePool;\n+\n+import java.io.Closeable;\n import java.io.File;\n+import java.util.concurrent.Executor;\n import java.util.concurrent.ScheduledExecutorService;\n \n+import javax.annotation.Nullable;\n+\n /**\n  * Builder for a server that services requests from an Android Service.\n  */\n@@ -72,6 +77,7 @@ public static BinderServerBuilder forPort(int port) {\n   private ServerSecurityPolicy securityPolicy;\n   private InboundParcelablePolicy inboundParcelablePolicy;\n   private boolean isBuilt;\n+  @Nullable private BinderTransportSecurity.ShutdownListener shutdownListener = null;\n \n   private BinderServerBuilder(\n       AndroidComponentAddress listenAddress,\n@@ -85,7 +91,9 @@ private BinderServerBuilder(\n           schedulerPool,\n           streamTracerFactories,\n           BinderInternal.createPolicyChecker(securityPolicy),\n-          inboundParcelablePolicy);\n+          inboundParcelablePolicy,\n+          // 'shutdownListener' should have been set by build()\n+          checkNotNull(shutdownListener));\n       BinderInternal.setIBinder(binderReceiver, server.getHostBinder());\n       return server;\n     });\n@@ -171,7 +179,10 @@ public Server build() {\n     checkState(!isBuilt, \"BinderServerBuilder can only be used to build one server instance.\");\n     isBuilt = true;\n     // We install the security interceptor last, so it's closest to the transport.\n-    BinderTransportSecurity.installAuthInterceptor(this);\n+    ObjectPool<? extends Executor> executorPool = serverImplBuilder.getExecutorPool();\n+    Executor executor = executorPool.getObject();\n+    BinderTransportSecurity.installAuthInterceptor(this, executor);\n+    shutdownListener = () -> executorPool.returnObject(executor);\n     return super.build();\n   }\n }\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/BinderServer.java b/binder/src/main/java/io/grpc/binder/internal/BinderServer.java\nindex e72f2851b29..8d6fe08fa94 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderServer.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderServer.java\n@@ -60,6 +60,7 @@ public final class BinderServer implements InternalServer, LeakSafeOneWayBinder.\n   private final LeakSafeOneWayBinder hostServiceBinder;\n   private final BinderTransportSecurity.ServerPolicyChecker serverPolicyChecker;\n   private final InboundParcelablePolicy inboundParcelablePolicy;\n+  private final BinderTransportSecurity.ShutdownListener transportSecurityShutdownListener;\n \n   @GuardedBy(\"this\")\n   private ServerListener listener;\n@@ -70,18 +71,24 @@ public final class BinderServer implements InternalServer, LeakSafeOneWayBinder.\n   @GuardedBy(\"this\")\n   private boolean shutdown;\n \n+  /**\n+   * @param transportSecurityShutdownListener represents resources that should be cleaned up once\n+   *                                          the server shuts down.\n+   */\n   public BinderServer(\n       AndroidComponentAddress listenAddress,\n       ObjectPool<ScheduledExecutorService> executorServicePool,\n       List<? extends ServerStreamTracer.Factory> streamTracerFactories,\n       BinderTransportSecurity.ServerPolicyChecker serverPolicyChecker,\n-      InboundParcelablePolicy inboundParcelablePolicy) {\n+      InboundParcelablePolicy inboundParcelablePolicy,\n+      BinderTransportSecurity.ShutdownListener transportSecurityShutdownListener) {\n     this.listenAddress = listenAddress;\n     this.executorServicePool = executorServicePool;\n     this.streamTracerFactories =\n         ImmutableList.copyOf(checkNotNull(streamTracerFactories, \"streamTracerFactories\"));\n     this.serverPolicyChecker = checkNotNull(serverPolicyChecker, \"serverPolicyChecker\");\n     this.inboundParcelablePolicy = inboundParcelablePolicy;\n+    this.transportSecurityShutdownListener = transportSecurityShutdownListener;\n     hostServiceBinder = new LeakSafeOneWayBinder(this);\n   }\n \n@@ -125,6 +132,7 @@ public synchronized void shutdown() {\n       hostServiceBinder.detach();\n       listener.serverShutdown();\n       executorService = executorServicePool.returnObject(executorService);\n+      transportSecurityShutdownListener.onServerShutdown();\n     }\n   }\n \n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java b/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\nindex 022ae7f6d20..1866bf54a47 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\n@@ -16,7 +16,10 @@\n \n package io.grpc.binder.internal;\n \n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n import com.google.common.util.concurrent.ListenableFuture;\n+\n import io.grpc.Attributes;\n import io.grpc.Internal;\n import io.grpc.Metadata;\n@@ -28,9 +31,12 @@\n import io.grpc.ServerInterceptor;\n import io.grpc.Status;\n import io.grpc.internal.GrpcAttributes;\n+\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n import javax.annotation.CheckReturnValue;\n+import javax.annotation.Nullable;\n \n /**\n  * Manages security for an Android Service hosted gRPC server.\n@@ -49,10 +55,11 @@ private BinderTransportSecurity() {}\n    * Install a security policy on an about-to-be created server.\n    *\n    * @param serverBuilder The ServerBuilder being used to create the server.\n+   * @param executor The executor in which the authorization result will be handled.\n    */\n   @Internal\n-  public static void installAuthInterceptor(ServerBuilder<?> serverBuilder) {\n-    serverBuilder.intercept(new ServerAuthInterceptor());\n+  public static void installAuthInterceptor(ServerBuilder<?> serverBuilder, Executor executor) {\n+    serverBuilder.intercept(new ServerAuthInterceptor(executor));\n   }\n \n   /**\n@@ -78,13 +85,36 @@ public static void attachAuthAttrs(\n    * Authentication state is fetched from the call attributes, inherited from the transport.\n    */\n   private static final class ServerAuthInterceptor implements ServerInterceptor {\n+\n+    private final Executor executor;\n+\n+    ServerAuthInterceptor(Executor executor) {\n+      this.executor = executor;\n+    }\n+\n     @Override\n     public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(\n         ServerCall<ReqT, RespT> call, Metadata headers, ServerCallHandler<ReqT, RespT> next) {\n-      Status authStatus =\n+      ListenableFuture<Status> authStatusFuture =\n           call.getAttributes()\n               .get(TRANSPORT_AUTHORIZATION_STATE)\n               .checkAuthorization(call.getMethodDescriptor());\n+\n+      // Most SecurityPolicy will have synchronous implementations that provide an\n+      // immediately-resolved Future. In that case, short-circuit to avoid unnecessary allocations\n+      // and asynchronous code if the authorization result is already present.\n+      if (!authStatusFuture.isDone()) {\n+        return newServerCallListenerForPendingAuthResult(authStatusFuture, call, headers, next);\n+      }\n+\n+      Status authStatus;\n+      try {\n+        authStatus = Futures.getDone(authStatusFuture);\n+      } catch (ExecutionException e) {\n+        // Failed futures are treated as an internal error rather than a security rejection.\n+        authStatus = Status.INTERNAL.withCause(e);\n+      }\n+\n       if (authStatus.isOk()) {\n         return next.startCall(call, headers);\n       } else {\n@@ -92,16 +122,45 @@ public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(\n         return new ServerCall.Listener<ReqT>() {};\n       }\n     }\n+\n+    private <ReqT, RespT> ServerCall.Listener<ReqT> newServerCallListenerForPendingAuthResult(\n+            ListenableFuture<Status> authStatusFuture,\n+            ServerCall<ReqT, RespT> call,\n+            Metadata headers,\n+            ServerCallHandler<ReqT, RespT> next) {\n+      PendingAuthListener<ReqT, RespT> listener = new PendingAuthListener<>();\n+      Futures.addCallback(\n+              authStatusFuture,\n+              new FutureCallback<Status>() {\n+                @Override\n+                public void onSuccess(Status authStatus) {\n+                  if (!authStatus.isOk()) {\n+                    call.close(authStatus, new Metadata());\n+                    return;\n+                  }\n+\n+                  listener.startCall(call, headers, next);\n+                }\n+\n+                @Override\n+                public void onFailure(Throwable t) {\n+                  call.close(\n+                          Status.INTERNAL.withCause(t).withDescription(\"Authorization future failed\"),\n+                          new Metadata());\n+                }\n+              }, executor);\n+      return listener;\n+    }\n   }\n \n   /**\n-   * Maintaines the authorization state for a single transport instance. This class lives for the\n+   * Maintains the authorization state for a single transport instance. This class lives for the\n    * lifetime of a single transport.\n    */\n   private static final class TransportAuthorizationState {\n     private final int uid;\n     private final ServerPolicyChecker serverPolicyChecker;\n-    private final ConcurrentHashMap<String, Status> serviceAuthorization;\n+    private final ConcurrentHashMap<String, ListenableFuture<Status>> serviceAuthorization;\n \n     TransportAuthorizationState(int uid, ServerPolicyChecker serverPolicyChecker) {\n       this.uid = uid;\n@@ -111,32 +170,27 @@ private static final class TransportAuthorizationState {\n \n     /** Get whether we're authorized to make this call. */\n     @CheckReturnValue\n-    Status checkAuthorization(MethodDescriptor<?, ?> method) {\n+    ListenableFuture<Status> checkAuthorization(MethodDescriptor<?, ?> method) {\n       String serviceName = method.getServiceName();\n       // Only cache decisions if the method can be sampled for tracing,\n-      // which is true for all generated methods. Otherwise, programatically\n-      // created methods could casue this cahe to grow unbounded.\n+      // which is true for all generated methods. Otherwise, programmatically\n+      // created methods could cause this cache to grow unbounded.\n       boolean useCache = method.isSampledToLocalTracing();\n-      Status authorization;\n       if (useCache) {\n-        authorization = serviceAuthorization.get(serviceName);\n+        @Nullable ListenableFuture<Status> authorization = serviceAuthorization.get(serviceName);\n         if (authorization != null) {\n           return authorization;\n         }\n       }\n-      try {\n-        // TODO(10566): provide a synchronous version of \"checkAuthorization\" to avoid blocking the\n-        // calling thread on the completion of the future.\n-        authorization =\n-            serverPolicyChecker.checkAuthorizationForServiceAsync(uid, serviceName).get();\n-      } catch (ExecutionException e) {\n-        // Do not cache this failure since it may be transient.\n-        return Status.fromThrowable(e);\n-      } catch (InterruptedException e) {\n-        // Do not cache this failure since it may be transient.\n-        Thread.currentThread().interrupt();\n-        return Status.CANCELLED.withCause(e);\n-      }\n+      // Under high load, this may trigger a large number of concurrent authorization checks that\n+      // perform essentially the same work and have the potential of exhausting the resources they\n+      // depend on. This was a non-issue in the past with synchronous policy checks due to the\n+      // fixed-size nature of the thread pool this method runs under.\n+      //\n+      // TODO(10669): evaluate if there should be at most a single pending authorization check per\n+      //  (uid, serviceName) pair at any given time.\n+      ListenableFuture<Status> authorization =\n+          serverPolicyChecker.checkAuthorizationForServiceAsync(uid, serviceName);\n       if (useCache) {\n         serviceAuthorization.putIfAbsent(serviceName, authorization);\n       }\n@@ -167,4 +221,12 @@ public interface ServerPolicyChecker {\n      */\n     ListenableFuture<Status> checkAuthorizationForServiceAsync(int uid, String serviceName);\n   }\n+\n+  /**\n+   * A listener invoked when the {@link io.grpc.binder.internal.BinderServer} shuts down, allowing\n+   * resources to be potentially cleaned up.\n+   */\n+  public interface ShutdownListener {\n+    void onServerShutdown();\n+  }\n }\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/PendingAuthListener.java b/binder/src/main/java/io/grpc/binder/internal/PendingAuthListener.java\nnew file mode 100644\nindex 00000000000..cdafc9c9191\n--- /dev/null\n+++ b/binder/src/main/java/io/grpc/binder/internal/PendingAuthListener.java\n@@ -0,0 +1,102 @@\n+package io.grpc.binder.internal;\n+\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.Status;\n+\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link ServerCall.Listener} that can be returned by a {@link io.grpc.ServerInterceptor} to\n+ * asynchronously advance the gRPC pending resolving a possibly asynchronous security policy check.\n+ */\n+final class PendingAuthListener<ReqT, RespT> extends ServerCall.Listener<ReqT> {\n+\n+  private final ConcurrentLinkedQueue<ListenerConsumer<ReqT>> pendingSteps =\n+      new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<ServerCall.Listener<ReqT>> delegateRef =\n+      new AtomicReference<>(null);\n+\n+  PendingAuthListener() {}\n+\n+  void startCall(ServerCall<ReqT, RespT> call,\n+                         Metadata headers,\n+                         ServerCallHandler<ReqT, RespT> next) {\n+    ServerCall.Listener<ReqT> delegate;\n+    try {\n+      delegate = next.startCall(call, headers);\n+    } catch (RuntimeException e) {\n+      call.close(\n+          Status\n+              .INTERNAL\n+              .withCause(e)\n+              .withDescription(\"Failed to start server call after authorization check\"),\n+          new Metadata());\n+      return;\n+    }\n+    delegateRef.set(delegate);\n+    maybeRunPendingSteps();\n+  }\n+\n+  /**\n+   * Runs any enqueued step in this ServerCall listener as long as the authorization check is\n+   * complete. Otherwise, no-op and returns immediately.\n+   */\n+  private void maybeRunPendingSteps() {\n+    @Nullable ServerCall.Listener<ReqT> delegate = delegateRef.get();\n+    if (delegate == null) {\n+      return;\n+    }\n+\n+    // This section is synchronized so that no 2 threads may attempt to retrieve elements from the\n+    // queue in order but end up executing the steps out of order.\n+    synchronized (this) {\n+      ListenerConsumer<ReqT> nextStep;\n+      while ((nextStep = pendingSteps.poll()) != null) {\n+        nextStep.accept(delegate);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void onCancel() {\n+    pendingSteps.offer(ServerCall.Listener::onCancel);\n+    maybeRunPendingSteps();\n+  }\n+\n+  @Override\n+  public void onComplete() {\n+    pendingSteps.offer(ServerCall.Listener::onComplete);\n+    maybeRunPendingSteps();\n+  }\n+\n+  @Override\n+  public void onHalfClose() {\n+    pendingSteps.offer(ServerCall.Listener::onHalfClose);\n+    maybeRunPendingSteps();\n+  }\n+\n+  @Override\n+  public void onMessage(ReqT message) {\n+    pendingSteps.offer(delegate -> delegate.onMessage(message));\n+    maybeRunPendingSteps();\n+  }\n+\n+  @Override\n+  public void onReady() {\n+    pendingSteps.offer(ServerCall.Listener::onReady);\n+    maybeRunPendingSteps();\n+  }\n+\n+  /**\n+   * Similar to Java8's {@link java.util.function.Consumer}, but redeclared in order to support\n+   * Android SDK 21.\n+   */\n+  private interface ListenerConsumer<ReqT> {\n+    void accept(ServerCall.Listener<ReqT> listener);\n+  }\n+}\n",
    "test_patch": "diff --git a/binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java b/binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java\nindex c06bf88955e..53a724fc7e0 100644\n--- a/binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java\n+++ b/binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java\n@@ -71,7 +71,8 @@ protected InternalServer newServer(List<ServerStreamTracer.Factory> streamTracer\n         executorServicePool,\n         streamTracerFactories,\n         BinderInternal.createPolicyChecker(SecurityPolicies.serverInternalOnly()),\n-        InboundParcelablePolicy.DEFAULT);\n+        InboundParcelablePolicy.DEFAULT,\n+        /* shutdownListener=*/ () -> {});\n \n     HostServices.configureService(addr,\n         HostServices.serviceParamsBuilder()\n\ndiff --git a/binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java b/binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java\nindex 9393aab1e7f..fb7e8e05566 100644\n--- a/binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java\n+++ b/binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java\n@@ -17,6 +17,7 @@\n package io.grpc.binder;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertThrows;\n \n import static org.junit.Assert.fail;\n import android.os.Process;\n@@ -25,14 +26,18 @@\n import com.google.common.util.concurrent.ListenableFuture;\n import com.google.common.util.concurrent.ListeningExecutorService;\n import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n import io.grpc.Status;\n-import io.grpc.StatusException;\n+import io.grpc.Status.Code;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.robolectric.RobolectricTestRunner;\n import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CancellationException;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Executors;\n \n @RunWith(RobolectricTestRunner.class)\n@@ -48,7 +53,16 @@ public final class ServerSecurityPolicyTest {\n   ServerSecurityPolicy policy;\n \n   @Test\n-  public void testDefaultInternalOnly() {\n+  public void testDefaultInternalOnly() throws Exception {\n+    policy = new ServerSecurityPolicy();\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE1))\n+        .isEqualTo(Status.OK.getCode());\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE2))\n+        .isEqualTo(Status.OK.getCode());\n+  }\n+\n+  @Test\n+  public void testDefaultInternalOnly_legacyApi() {\n     policy = new ServerSecurityPolicy();\n     assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n         .isEqualTo(Status.OK.getCode());\n@@ -57,7 +71,16 @@ public void testDefaultInternalOnly() {\n   }\n \n   @Test\n-  public void testInternalOnly_AnotherUid() {\n+  public void testInternalOnly_AnotherUid() throws Exception {\n+    policy = new ServerSecurityPolicy();\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE1))\n+        .isEqualTo(Status.PERMISSION_DENIED.getCode());\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE2))\n+        .isEqualTo(Status.PERMISSION_DENIED.getCode());\n+  }\n+\n+  @Test\n+  public void testInternalOnly_AnotherUid_legacyApi() {\n     policy = new ServerSecurityPolicy();\n     assertThat(policy.checkAuthorizationForService(OTHER_UID, SERVICE1).getCode())\n         .isEqualTo(Status.PERMISSION_DENIED.getCode());\n@@ -66,7 +89,16 @@ public void testInternalOnly_AnotherUid() {\n   }\n \n   @Test\n-  public void testBuilderDefault() {\n+  public void testBuilderDefault() throws Exception {\n+    policy = ServerSecurityPolicy.newBuilder().build();\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE1))\n+        .isEqualTo(Status.OK.getCode());\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE1))\n+        .isEqualTo(Status.PERMISSION_DENIED.getCode());\n+  }\n+\n+  @Test\n+  public void testBuilderDefault_legacyApi() {\n     policy = ServerSecurityPolicy.newBuilder().build();\n     assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n         .isEqualTo(Status.OK.getCode());\n@@ -75,7 +107,25 @@ public void testBuilderDefault() {\n   }\n \n   @Test\n-  public void testPerService() {\n+  public void testPerService() throws Exception {\n+    policy =\n+        ServerSecurityPolicy.newBuilder()\n+            .servicePolicy(SERVICE2, policy((uid) -> Status.OK))\n+            .build();\n+\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE1))\n+        .isEqualTo(Status.OK.getCode());\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE1))\n+        .isEqualTo(Status.PERMISSION_DENIED.getCode());\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE2))\n+        .isEqualTo(Status.OK.getCode());\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE2))\n+        .isEqualTo(Status.OK.getCode());\n+  }\n+\n+\n+  @Test\n+  public void testPerService_legacyApi() {\n     policy =\n         ServerSecurityPolicy.newBuilder()\n             .servicePolicy(SERVICE2, policy((uid) -> Status.OK))\n@@ -92,7 +142,7 @@ public void testPerService() {\n   }\n \n   @Test\n-  public void testPerServiceAsync() {\n+  public void testPerServiceAsync() throws Exception {\n     policy =\n         ServerSecurityPolicy.newBuilder()\n             .servicePolicy(SERVICE2, asyncPolicy(uid -> {\n@@ -104,29 +154,31 @@ public void testPerServiceAsync() {\n             }))\n             .build();\n \n-    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE1))\n         .isEqualTo(Status.OK.getCode());\n-    assertThat(policy.checkAuthorizationForService(OTHER_UID, SERVICE1).getCode())\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE1))\n         .isEqualTo(Status.PERMISSION_DENIED.getCode());\n-    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE2).getCode())\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE2))\n         .isEqualTo(Status.OK.getCode());\n-    assertThat(policy.checkAuthorizationForService(OTHER_UID, SERVICE2).getCode())\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE2))\n         .isEqualTo(Status.OK.getCode());\n   }\n \n   @Test\n-  public void testPerService_throwingExceptionAsynchronously_propagatesStatusFromException() {\n+  public void testPerService_failedSecurityPolicyFuture_returnsAFailedFuture() {\n     policy =\n         ServerSecurityPolicy.newBuilder()\n             .servicePolicy(SERVICE1, asyncPolicy(uid ->\n                 Futures\n                     .immediateFailedFuture(\n-                        new StatusException(Status.fromCode(Status.Code.ALREADY_EXISTS)))\n+                        new IllegalStateException(\"something went wrong\"))\n             ))\n             .build();\n \n-    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n-        .isEqualTo(Status.ALREADY_EXISTS.getCode());\n+    ListenableFuture<Status> statusFuture =\n+        policy.checkAuthorizationForServiceAsync(MY_UID, SERVICE1);\n+\n+    assertThrows(ExecutionException.class, statusFuture::get);\n   }\n \n   @Test\n@@ -136,12 +188,14 @@ public void testPerServiceAsync_cancelledFuture_propagatesStatus() {\n             .servicePolicy(SERVICE1, asyncPolicy(unused -> Futures.immediateCancelledFuture()))\n             .build();\n \n-    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n-        .isEqualTo(Status.CANCELLED.getCode());\n+    ListenableFuture<Status> statusFuture =\n+        policy.checkAuthorizationForServiceAsync(MY_UID, SERVICE1);\n+\n+    assertThrows(CancellationException.class, statusFuture::get);\n   }\n \n   @Test\n-  public void testPerServiceAsync_interrupted_cancelledStatus() {\n+  public void testPerServiceAsync_interrupted_cancelledFuture() {\n     ListeningExecutorService listeningExecutorService =\n         MoreExecutors.listeningDecorator(Executors.newSingleThreadExecutor());\n     CountDownLatch unsatisfiedLatch = new CountDownLatch(1);\n@@ -164,15 +218,40 @@ public void testPerServiceAsync_interrupted_cancelledStatus() {\n                 return toBeInterruptedFuture;\n             }))\n             .build();\n+    ListenableFuture<Status> statusFuture =\n+        policy.checkAuthorizationForServiceAsync(MY_UID, SERVICE1);\n \n-    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n-        .isEqualTo(Status.CANCELLED.getCode());\n-    assertThat(Thread.currentThread().isInterrupted()).isTrue();\n+    assertThrows(InterruptedException.class, statusFuture::get);\n     listeningExecutorService.shutdownNow();\n   }\n \n   @Test\n-  public void testPerServiceNoDefault() {\n+  public void testPerServiceNoDefault() throws Exception {\n+    policy =\n+        ServerSecurityPolicy.newBuilder()\n+            .servicePolicy(SERVICE1, policy((uid) -> Status.INTERNAL))\n+            .servicePolicy(\n+                SERVICE2, policy((uid) -> uid == OTHER_UID ? Status.OK : Status.PERMISSION_DENIED))\n+            .build();\n+\n+    // Uses the specified policy for service1.\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE1))\n+        .isEqualTo(Status.INTERNAL.getCode());\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE1))\n+        .isEqualTo(Status.INTERNAL.getCode());\n+\n+    // Uses the specified policy for service2.\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE2))\n+        .isEqualTo(Status.PERMISSION_DENIED.getCode());\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE2)).isEqualTo(Status.OK.getCode());\n+\n+    // Falls back to the default.\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE3)).isEqualTo(Status.OK.getCode());\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE3))\n+        .isEqualTo(Status.PERMISSION_DENIED.getCode());\n+  }\n+  @Test\n+  public void testPerServiceNoDefault_legacyApi() {\n     policy =\n         ServerSecurityPolicy.newBuilder()\n             .servicePolicy(SERVICE1, policy((uid) -> Status.INTERNAL))\n@@ -200,7 +279,7 @@ SERVICE2, policy((uid) -> uid == OTHER_UID ? Status.OK : Status.PERMISSION_DENIE\n   }\n \n   @Test\n-  public void testPerServiceNoDefaultAsync() {\n+  public void testPerServiceNoDefaultAsync() throws Exception {\n     policy =\n             ServerSecurityPolicy.newBuilder()\n                     .servicePolicy(\n@@ -224,24 +303,37 @@ SERVICE2, asyncPolicy((uid) -> {\n                     .build();\n \n     // Uses the specified policy for service1.\n-    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE1))\n             .isEqualTo(Status.INTERNAL.getCode());\n-    assertThat(policy.checkAuthorizationForService(OTHER_UID, SERVICE1).getCode())\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE1))\n             .isEqualTo(Status.INTERNAL.getCode());\n \n     // Uses the specified policy for service2.\n-    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE2).getCode())\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE2))\n             .isEqualTo(Status.PERMISSION_DENIED.getCode());\n-    assertThat(policy.checkAuthorizationForService(OTHER_UID, SERVICE2).getCode())\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE2))\n             .isEqualTo(Status.OK.getCode());\n \n     // Falls back to the default.\n-    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE3).getCode())\n+    assertThat(checkAuthorizationForServiceAsync(policy, MY_UID, SERVICE3))\n             .isEqualTo(Status.OK.getCode());\n-    assertThat(policy.checkAuthorizationForService(OTHER_UID, SERVICE3).getCode())\n+    assertThat(checkAuthorizationForServiceAsync(policy, OTHER_UID, SERVICE3))\n             .isEqualTo(Status.PERMISSION_DENIED.getCode());\n   }\n \n+  /**\n+   * Shortcut for invoking {@link ServerSecurityPolicy#checkAuthorizationForServiceAsync} without\n+   * dealing with concurrency details. Returns a {link @Status.Code} for convenience.\n+   */\n+  private static Status.Code checkAuthorizationForServiceAsync(\n+          ServerSecurityPolicy policy,\n+          int callerUid,\n+          String service) throws ExecutionException {\n+    ListenableFuture<Status> statusFuture =\n+        policy.checkAuthorizationForServiceAsync(callerUid, service);\n+    return Uninterruptibles.getUninterruptibly(statusFuture).getCode();\n+  }\n+\n   private static SecurityPolicy policy(Function<Integer, Status> func) {\n     return new SecurityPolicy() {\n       @Override\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10622",
    "pr_id": 10622,
    "issue_id": 10566,
    "repo": "grpc/grpc-java",
    "problem_statement": "SecurityPolicy should support async/slow implementations\n<!-- Please answer these questions before submitting a feature request. -->\r\n\r\n### Is your feature request related to a problem?\r\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\r\nThe [SecurityPolicy](https://github.com/grpc/grpc-java/blob/master/binder/src/main/java/io/grpc/binder/SecurityPolicy.java) class defines an abstract method that returns a Status. If computing such status requires running some slow piece of code (that, for instance, reads flags from storage or from the network), then the only option is to block the calling thread until such operation is completed.\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy extends SecurityPolicy {\r\n  @Override\r\n  public Status checkAuthorization(int uid) {\r\n    try {\r\n      // must block the calling thread to satisfy SecurityPolicy's API\r\n      return fetchAllowlistedUids().get().contains(uid) ? Status.OK : Status.PERMISSION_DENIED;\r\n    } catch (InterruptedException e) {\r\n      return Status.fromThrowable(e);\r\n    }\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nBlocking is generally undesirable, because it monopolizes a thread from the system for mostly idle work, which leads to sub-optimal performance by requiring new threads to be spawned or reducing the amount of threads available, thus the responsiveness of the system.\r\n\r\n### Describe the solution you'd like\r\n`SecurityPolicy` (or an equivalent replacement) should provide an API for returning a `ListenableFuture<Status>` instead. Clients are free to implement it however they see fit. The case commonly supported today (simple non-blocking computations) would be equivalent to returning a `Futures.immediateFuture(status)` (from Guava).\r\n\r\n```java\r\npublic interface AsyncSecurityPolicy {\r\n  ListenableFuture<Status> checkAuthorization(int uid);\r\n}\r\n```\r\n\r\nThen the code above can be written as non-blocking:\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy implements AsyncSecurityPolicy {\r\n  @Override\r\n  public ListenableFuture<Status> checkAuthorization(int uid) {\r\n    return Futures.transform(\r\n      fetchAllowlistedUids(),\r\n      allowlist -> allowlist.contains(uid) ? Status.OK : Status.PERMISSION_DENIED,\r\n      someExecutor);\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\n### Describe alternatives you've considered\r\nN/A\r\n\r\n### Additional context\r\nSome apps use [StrictPolicy.VmPolicy](https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy) to instruct which kinds of threads are appropriate for different kinds of tasks (e.g. lightweight computations vs blocking network access). It can be used to configure different \"penalties\", like just logging in production or crashing in development. The issue above has triggered such violations during the development of an internal Google app.",
    "issue_word_count": 373,
    "test_files_count": 2,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java",
      "binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java",
      "binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java",
      "binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java"
    ],
    "pr_changed_test_files": [
      "binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java",
      "binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java"
    ],
    "base_commit": "2bec8cdf1d1059f2ef219fb33fd5559029de98f8",
    "head_commit": "9aa09eb6d9014553dc6ff5361faab4a613c3be87",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10622",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10622",
    "dockerfile": "",
    "pr_merged_at": "2023-10-26T17:14:39.000Z",
    "patch": "diff --git a/binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java b/binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java\nnew file mode 100644\nindex 00000000000..f6516aae2f7\n--- /dev/null\n+++ b/binder/src/main/java/io/grpc/binder/AsyncSecurityPolicy.java\n@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2023 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.binder;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.grpc.ExperimentalApi;\n+import io.grpc.Status;\n+\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.CheckReturnValue;\n+\n+/**\n+ * Decides whether a given Android UID is authorized to access some resource.\n+ *\n+ * <p>This class provides the asynchronous version of {@link SecurityPolicy}, allowing\n+ * implementations of authorization logic that involves slow or asynchronous calls without\n+ * necessarily blocking the calling thread.\n+ *\n+ * @see SecurityPolicy\n+ */\n+@ExperimentalApi(\"https://github.com/grpc/grpc-java/issues/10566\")\n+@CheckReturnValue\n+public abstract class AsyncSecurityPolicy extends SecurityPolicy {\n+\n+/**\n+ * @deprecated Prefer {@link #checkAuthorizationAsync(int)} for async or slow calls or subclass\n+ *     {@link SecurityPolicy} directly for quick, synchronous implementations.\n+ */\n+@Override\n+@Deprecated\n+public final Status checkAuthorization(int uid) {\n+  try {\n+    return checkAuthorizationAsync(uid).get();\n+  } catch (ExecutionException e) {\n+    return Status.fromThrowable(e);\n+  } catch (CancellationException e) {\n+    return Status.CANCELLED.withCause(e);\n+  } catch (InterruptedException e) {\n+    Thread.currentThread().interrupt();  // re-set the current thread's interruption state\n+    return Status.CANCELLED.withCause(e);\n+  }\n+}\n+\n+  /**\n+   * Decides whether the given Android UID is authorized. (Validity is implementation dependent).\n+   *\n+   * <p>As long as any given UID has active processes, this method should return the same value for\n+   * that UID. In order words, policy changes which occur while a transport instance is active, will\n+   * have no effect on that transport instance.\n+   *\n+   * @param uid The Android UID to authenticate.\n+   * @return A {@link ListenableFuture} for a gRPC {@link Status} object, with OK indicating\n+   *     authorized.\n+   */\n+  abstract ListenableFuture<Status> checkAuthorizationAsync(int uid);\n+}\n\ndiff --git a/binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java b/binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java\nindex 66685cfdbbe..ced973ede1c 100644\n--- a/binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java\n+++ b/binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java\n@@ -72,6 +72,10 @@ public Status checkAuthorizationForService(int uid, String serviceName) {\n   @CheckReturnValue\n   ListenableFuture<Status> checkAuthorizationForServiceAsync(int uid, String serviceName) {\n     SecurityPolicy securityPolicy = perServicePolicies.getOrDefault(serviceName, defaultPolicy);\n+    if (securityPolicy instanceof AsyncSecurityPolicy) {\n+      return ((AsyncSecurityPolicy) securityPolicy).checkAuthorizationAsync(uid);\n+    }\n+\n     try {\n       Status status = securityPolicy.checkAuthorization(uid);\n       return Futures.immediateFuture(status);\n",
    "test_patch": "diff --git a/binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java b/binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java\nindex e3b9978fb36..18d5cd99d74 100644\n--- a/binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java\n+++ b/binder/src/androidTest/java/io/grpc/binder/BinderSecurityTest.java\n@@ -23,6 +23,9 @@\n import androidx.test.core.app.ApplicationProvider;\n import androidx.test.ext.junit.runners.AndroidJUnit4;\n import com.google.common.base.Function;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n import com.google.protobuf.Empty;\n import io.grpc.CallOptions;\n import io.grpc.ManagedChannel;\n@@ -155,7 +158,7 @@ public void testAllowedCall() throws Exception {\n   }\n \n   @Test\n-  public void testServerDisllowsCalls() throws Exception {\n+  public void testServerDisallowsCalls() throws Exception {\n     createChannel(\n         ServerSecurityPolicy.newBuilder()\n             .servicePolicy(\"foo\", policy((uid) -> false))\n@@ -197,6 +200,25 @@ public void testPerServicePolicy() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testPerServicePolicyAsync() throws Exception {\n+    createChannel(\n+            ServerSecurityPolicy.newBuilder()\n+                    .servicePolicy(\"foo\", asyncPolicy((uid) -> Futures.immediateFuture(true)))\n+                    .servicePolicy(\"bar\", asyncPolicy((uid) -> Futures.immediateFuture(false)))\n+                    .build(),\n+            SecurityPolicies.internalOnly());\n+\n+    assertThat(methods).isNotEmpty();\n+    for (MethodDescriptor<Empty, Empty> method : methods.values()) {\n+      if (method.getServiceName().equals(\"bar\")) {\n+        assertCallFailure(method, Status.PERMISSION_DENIED);\n+      } else {\n+        assertCallSuccess(method);\n+      }\n+    }\n+  }\n+\n   @Test\n   public void testSecurityInterceptorIsClosestToTransport() throws Exception {\n     createChannel(\n@@ -227,6 +249,20 @@ public Status checkAuthorization(int uid) {\n     };\n   }\n \n+  private static AsyncSecurityPolicy asyncPolicy(\n+      Function<Integer, ListenableFuture<Boolean>> func) {\n+    return new AsyncSecurityPolicy() {\n+      @Override\n+      public ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n+        return Futures\n+            .transform(\n+                func.apply(uid),\n+                allowed -> allowed ? Status.OK : Status.PERMISSION_DENIED,\n+                MoreExecutors.directExecutor());\n+      }\n+    };\n+  }\n+\n   private final class CountingServerInterceptor implements ServerInterceptor {\n     int numInterceptedCalls;\n \n\ndiff --git a/binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java b/binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java\nindex 95a4fe5a6e8..9393aab1e7f 100644\n--- a/binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java\n+++ b/binder/src/test/java/io/grpc/binder/ServerSecurityPolicyTest.java\n@@ -18,12 +18,22 @@\n \n import static com.google.common.truth.Truth.assertThat;\n \n+import static org.junit.Assert.fail;\n import android.os.Process;\n import com.google.common.base.Function;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n import io.grpc.Status;\n+import io.grpc.StatusException;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.robolectric.RobolectricTestRunner;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executors;\n \n @RunWith(RobolectricTestRunner.class)\n public final class ServerSecurityPolicyTest {\n@@ -81,6 +91,86 @@ public void testPerService() {\n         .isEqualTo(Status.OK.getCode());\n   }\n \n+  @Test\n+  public void testPerServiceAsync() {\n+    policy =\n+        ServerSecurityPolicy.newBuilder()\n+            .servicePolicy(SERVICE2, asyncPolicy(uid -> {\n+                // Add some extra future transformation to confirm that a chain\n+                // of futures gets properly handled.\n+                ListenableFuture<Void> dependency = Futures.immediateVoidFuture();\n+                return Futures\n+                        .transform(dependency, unused -> Status.OK, MoreExecutors.directExecutor());\n+            }))\n+            .build();\n+\n+    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n+        .isEqualTo(Status.OK.getCode());\n+    assertThat(policy.checkAuthorizationForService(OTHER_UID, SERVICE1).getCode())\n+        .isEqualTo(Status.PERMISSION_DENIED.getCode());\n+    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE2).getCode())\n+        .isEqualTo(Status.OK.getCode());\n+    assertThat(policy.checkAuthorizationForService(OTHER_UID, SERVICE2).getCode())\n+        .isEqualTo(Status.OK.getCode());\n+  }\n+\n+  @Test\n+  public void testPerService_throwingExceptionAsynchronously_propagatesStatusFromException() {\n+    policy =\n+        ServerSecurityPolicy.newBuilder()\n+            .servicePolicy(SERVICE1, asyncPolicy(uid ->\n+                Futures\n+                    .immediateFailedFuture(\n+                        new StatusException(Status.fromCode(Status.Code.ALREADY_EXISTS)))\n+            ))\n+            .build();\n+\n+    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n+        .isEqualTo(Status.ALREADY_EXISTS.getCode());\n+  }\n+\n+  @Test\n+  public void testPerServiceAsync_cancelledFuture_propagatesStatus() {\n+    policy =\n+        ServerSecurityPolicy.newBuilder()\n+            .servicePolicy(SERVICE1, asyncPolicy(unused -> Futures.immediateCancelledFuture()))\n+            .build();\n+\n+    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n+        .isEqualTo(Status.CANCELLED.getCode());\n+  }\n+\n+  @Test\n+  public void testPerServiceAsync_interrupted_cancelledStatus() {\n+    ListeningExecutorService listeningExecutorService =\n+        MoreExecutors.listeningDecorator(Executors.newSingleThreadExecutor());\n+    CountDownLatch unsatisfiedLatch = new CountDownLatch(1);\n+    ListenableFuture<Status> toBeInterruptedFuture = listeningExecutorService.submit(() -> {\n+        unsatisfiedLatch.await();  // waits forever\n+        return null;\n+    });\n+\n+    CyclicBarrier barrier = new CyclicBarrier(2);\n+    Thread testThread = Thread.currentThread();\n+    new Thread(() -> {\n+        awaitOrFail(barrier);\n+        testThread.interrupt();\n+    }).start();\n+\n+    policy =\n+        ServerSecurityPolicy.newBuilder()\n+            .servicePolicy(SERVICE1, asyncPolicy(unused -> {\n+                awaitOrFail(barrier);\n+                return toBeInterruptedFuture;\n+            }))\n+            .build();\n+\n+    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n+        .isEqualTo(Status.CANCELLED.getCode());\n+    assertThat(Thread.currentThread().isInterrupted()).isTrue();\n+    listeningExecutorService.shutdownNow();\n+  }\n+\n   @Test\n   public void testPerServiceNoDefault() {\n     policy =\n@@ -109,6 +199,49 @@ SERVICE2, policy((uid) -> uid == OTHER_UID ? Status.OK : Status.PERMISSION_DENIE\n         .isEqualTo(Status.PERMISSION_DENIED.getCode());\n   }\n \n+  @Test\n+  public void testPerServiceNoDefaultAsync() {\n+    policy =\n+            ServerSecurityPolicy.newBuilder()\n+                    .servicePolicy(\n+                            SERVICE1,\n+                            asyncPolicy((uid) -> Futures.immediateFuture(Status.INTERNAL)))\n+                    .servicePolicy(\n+                            SERVICE2, asyncPolicy((uid) -> {\n+                              // Add some extra future transformation to confirm that a chain\n+                              // of futures gets properly handled.\n+                              ListenableFuture<Boolean> anotherUidFuture =\n+                                      Futures.immediateFuture(uid == OTHER_UID);\n+                              return Futures\n+                                      .transform(\n+                                              anotherUidFuture,\n+                                              anotherUid ->\n+                                                      anotherUid\n+                                                              ? Status.OK\n+                                                              : Status.PERMISSION_DENIED,\n+                                              MoreExecutors.directExecutor());\n+                            }))\n+                    .build();\n+\n+    // Uses the specified policy for service1.\n+    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE1).getCode())\n+            .isEqualTo(Status.INTERNAL.getCode());\n+    assertThat(policy.checkAuthorizationForService(OTHER_UID, SERVICE1).getCode())\n+            .isEqualTo(Status.INTERNAL.getCode());\n+\n+    // Uses the specified policy for service2.\n+    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE2).getCode())\n+            .isEqualTo(Status.PERMISSION_DENIED.getCode());\n+    assertThat(policy.checkAuthorizationForService(OTHER_UID, SERVICE2).getCode())\n+            .isEqualTo(Status.OK.getCode());\n+\n+    // Falls back to the default.\n+    assertThat(policy.checkAuthorizationForService(MY_UID, SERVICE3).getCode())\n+            .isEqualTo(Status.OK.getCode());\n+    assertThat(policy.checkAuthorizationForService(OTHER_UID, SERVICE3).getCode())\n+            .isEqualTo(Status.PERMISSION_DENIED.getCode());\n+  }\n+\n   private static SecurityPolicy policy(Function<Integer, Status> func) {\n     return new SecurityPolicy() {\n       @Override\n@@ -117,4 +250,24 @@ public Status checkAuthorization(int uid) {\n       }\n     };\n   }\n+\n+  private static AsyncSecurityPolicy asyncPolicy(Function<Integer, ListenableFuture<Status>> func) {\n+    return new AsyncSecurityPolicy() {\n+      @Override\n+      public ListenableFuture<Status> checkAuthorizationAsync(int uid) {\n+        return func.apply(uid);\n+      }\n+    };\n+  }\n+\n+  private static void awaitOrFail(CyclicBarrier barrier) {\n+    try {\n+        barrier.await();\n+    } catch (BrokenBarrierException e) {\n+        fail(e.getMessage());\n+    } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        fail(e.getMessage());\n+    }\n+  }\n }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10596",
    "pr_id": 10596,
    "issue_id": 10566,
    "repo": "grpc/grpc-java",
    "problem_statement": "SecurityPolicy should support async/slow implementations\n<!-- Please answer these questions before submitting a feature request. -->\r\n\r\n### Is your feature request related to a problem?\r\n<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->\r\nThe [SecurityPolicy](https://github.com/grpc/grpc-java/blob/master/binder/src/main/java/io/grpc/binder/SecurityPolicy.java) class defines an abstract method that returns a Status. If computing such status requires running some slow piece of code (that, for instance, reads flags from storage or from the network), then the only option is to block the calling thread until such operation is completed.\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy extends SecurityPolicy {\r\n  @Override\r\n  public Status checkAuthorization(int uid) {\r\n    try {\r\n      // must block the calling thread to satisfy SecurityPolicy's API\r\n      return fetchAllowlistedUids().get().contains(uid) ? Status.OK : Status.PERMISSION_DENIED;\r\n    } catch (InterruptedException e) {\r\n      return Status.fromThrowable(e);\r\n    }\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nBlocking is generally undesirable, because it monopolizes a thread from the system for mostly idle work, which leads to sub-optimal performance by requiring new threads to be spawned or reducing the amount of threads available, thus the responsiveness of the system.\r\n\r\n### Describe the solution you'd like\r\n`SecurityPolicy` (or an equivalent replacement) should provide an API for returning a `ListenableFuture<Status>` instead. Clients are free to implement it however they see fit. The case commonly supported today (simple non-blocking computations) would be equivalent to returning a `Futures.immediateFuture(status)` (from Guava).\r\n\r\n```java\r\npublic interface AsyncSecurityPolicy {\r\n  ListenableFuture<Status> checkAuthorization(int uid);\r\n}\r\n```\r\n\r\nThen the code above can be written as non-blocking:\r\n\r\n```java\r\npublic class FlagBasedSecurityPolicy implements AsyncSecurityPolicy {\r\n  @Override\r\n  public ListenableFuture<Status> checkAuthorization(int uid) {\r\n    return Futures.transform(\r\n      fetchAllowlistedUids(),\r\n      allowlist -> allowlist.contains(uid) ? Status.OK : Status.PERMISSION_DENIED,\r\n      someExecutor);\r\n  }\r\n\r\n  // does not block\r\n  private ListenableFuture<List<Integer>> fetchAllowlistedUids() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\n### Describe alternatives you've considered\r\nN/A\r\n\r\n### Additional context\r\nSome apps use [StrictPolicy.VmPolicy](https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy) to instruct which kinds of threads are appropriate for different kinds of tasks (e.g. lightweight computations vs blocking network access). It can be used to configure different \"penalties\", like just logging in production or crashing in development. The issue above has triggered such violations during the development of an internal Google app.",
    "issue_word_count": 373,
    "test_files_count": 1,
    "non_test_files_count": 5,
    "pr_changed_files": [
      "binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java",
      "binder/src/main/java/io/grpc/binder/BinderInternal.java",
      "binder/src/main/java/io/grpc/binder/BinderServerBuilder.java",
      "binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderServer.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java"
    ],
    "pr_changed_test_files": [
      "binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java"
    ],
    "base_commit": "bf9ccc68f5e8f21f3cb3a34604e14542ebcecd32",
    "head_commit": "5ba3c33ad0c6eb5007ae300fca2abf3dcd8ee07a",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10596",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10596",
    "dockerfile": "",
    "pr_merged_at": "2023-10-20T20:53:13.000Z",
    "patch": "diff --git a/binder/src/main/java/io/grpc/binder/BinderInternal.java b/binder/src/main/java/io/grpc/binder/BinderInternal.java\nindex 34f7793714f..18af43ce2b3 100644\n--- a/binder/src/main/java/io/grpc/binder/BinderInternal.java\n+++ b/binder/src/main/java/io/grpc/binder/BinderInternal.java\n@@ -18,6 +18,7 @@\n \n import android.os.IBinder;\n import io.grpc.Internal;\n+import io.grpc.binder.internal.BinderTransportSecurity;\n \n /**\n  * Helper class to expose IBinderReceiver methods for legacy internal builders.\n@@ -31,4 +32,14 @@ public class BinderInternal {\n   public static void setIBinder(IBinderReceiver receiver, IBinder binder) {\n     receiver.set(binder);\n   }\n+\n+  /**\n+   * Creates a {@link BinderTransportSecurity.ServerPolicyChecker} from a\n+   * {@link ServerSecurityPolicy}. This exposes to callers an interface to check security policies\n+   * without causing hard dependencies on a specific class.\n+   */\n+  public static BinderTransportSecurity.ServerPolicyChecker createPolicyChecker(\n+          ServerSecurityPolicy securityPolicy) {\n+    return securityPolicy::checkAuthorizationForServiceAsync;\n+  }\n }\n\ndiff --git a/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java b/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java\nindex eaa94bffc45..dafb884d6b1 100644\n--- a/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java\n+++ b/binder/src/main/java/io/grpc/binder/BinderServerBuilder.java\n@@ -23,11 +23,11 @@\n import android.os.IBinder;\n import com.google.errorprone.annotations.DoNotCall;\n import io.grpc.ExperimentalApi;\n+import io.grpc.ForwardingServerBuilder;\n import io.grpc.Server;\n import io.grpc.ServerBuilder;\n import io.grpc.binder.internal.BinderServer;\n import io.grpc.binder.internal.BinderTransportSecurity;\n-import io.grpc.ForwardingServerBuilder;\n import io.grpc.internal.FixedObjectPool;\n import io.grpc.internal.GrpcUtil;\n import io.grpc.internal.ServerImplBuilder;\n@@ -84,7 +84,7 @@ private BinderServerBuilder(\n           listenAddress,\n           schedulerPool,\n           streamTracerFactories,\n-          securityPolicy,\n+          BinderInternal.createPolicyChecker(securityPolicy),\n           inboundParcelablePolicy);\n       BinderInternal.setIBinder(binderReceiver, server.getHostBinder());\n       return server;\n\ndiff --git a/binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java b/binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java\nindex d91a487a57c..66685cfdbbe 100644\n--- a/binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java\n+++ b/binder/src/main/java/io/grpc/binder/ServerSecurityPolicy.java\n@@ -17,6 +17,8 @@\n package io.grpc.binder;\n \n import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n import io.grpc.Status;\n import java.util.HashMap;\n import java.util.Map;\n@@ -42,18 +44,42 @@ private ServerSecurityPolicy(ImmutableMap<String, SecurityPolicy> perServicePoli\n   }\n \n   /**\n-   * Return whether the given Android UID is authorized to access a particular service.\n+   * Returns whether the given Android UID is authorized to access a particular service.\n    *\n-   * <b>IMPORTANT</b>: This method may block for extended periods of time.\n+   * <p><b>IMPORTANT</b>: This method may block for extended periods of time.\n    *\n    * @param uid The Android UID to authenticate.\n    * @param serviceName The name of the gRPC service being called.\n+   * @deprecated Application code should not need to call this method.\n    */\n   @CheckReturnValue\n+  @Deprecated\n   public Status checkAuthorizationForService(int uid, String serviceName) {\n     return perServicePolicies.getOrDefault(serviceName, defaultPolicy).checkAuthorization(uid);\n   }\n \n+  /**\n+   * Returns whether the given Android UID is authorized to access a particular service.\n+   *\n+   * <p>This method never throws an exception. If the execution of the security policy check\n+   * fails, a failed future with such exception is returned.\n+   *\n+   * @param uid The Android UID to authenticate.\n+   * @param serviceName The name of the gRPC service being called.\n+   * @return a future with the result of the authorization check. A failed future represents a\n+   *     failure to perform the authorization check, not that the access is denied.\n+   */\n+  @CheckReturnValue\n+  ListenableFuture<Status> checkAuthorizationForServiceAsync(int uid, String serviceName) {\n+    SecurityPolicy securityPolicy = perServicePolicies.getOrDefault(serviceName, defaultPolicy);\n+    try {\n+      Status status = securityPolicy.checkAuthorization(uid);\n+      return Futures.immediateFuture(status);\n+    } catch (Exception e) {\n+      return Futures.immediateFailedFuture(e);\n+    }\n+  }\n+\n   public static Builder newBuilder() {\n     return new Builder();\n   }\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/BinderServer.java b/binder/src/main/java/io/grpc/binder/internal/BinderServer.java\nindex 74ed5caceea..e72f2851b29 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderServer.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderServer.java\n@@ -58,7 +58,7 @@ public final class BinderServer implements InternalServer, LeakSafeOneWayBinder.\n   private final ImmutableList<ServerStreamTracer.Factory> streamTracerFactories;\n   private final AndroidComponentAddress listenAddress;\n   private final LeakSafeOneWayBinder hostServiceBinder;\n-  private final ServerSecurityPolicy serverSecurityPolicy;\n+  private final BinderTransportSecurity.ServerPolicyChecker serverPolicyChecker;\n   private final InboundParcelablePolicy inboundParcelablePolicy;\n \n   @GuardedBy(\"this\")\n@@ -74,13 +74,13 @@ public BinderServer(\n       AndroidComponentAddress listenAddress,\n       ObjectPool<ScheduledExecutorService> executorServicePool,\n       List<? extends ServerStreamTracer.Factory> streamTracerFactories,\n-      ServerSecurityPolicy serverSecurityPolicy,\n+      BinderTransportSecurity.ServerPolicyChecker serverPolicyChecker,\n       InboundParcelablePolicy inboundParcelablePolicy) {\n     this.listenAddress = listenAddress;\n     this.executorServicePool = executorServicePool;\n     this.streamTracerFactories =\n         ImmutableList.copyOf(checkNotNull(streamTracerFactories, \"streamTracerFactories\"));\n-    this.serverSecurityPolicy = checkNotNull(serverSecurityPolicy, \"serverSecurityPolicy\");\n+    this.serverPolicyChecker = checkNotNull(serverPolicyChecker, \"serverPolicyChecker\");\n     this.inboundParcelablePolicy = inboundParcelablePolicy;\n     hostServiceBinder = new LeakSafeOneWayBinder(this);\n   }\n@@ -150,7 +150,7 @@ public synchronized boolean handleTransaction(int code, Parcel parcel) {\n                   .set(BinderTransport.REMOTE_UID, callingUid)\n                   .set(BinderTransport.SERVER_AUTHORITY, listenAddress.getAuthority())\n                   .set(BinderTransport.INBOUND_PARCELABLE_POLICY, inboundParcelablePolicy);\n-          BinderTransportSecurity.attachAuthAttrs(attrsBuilder, callingUid, serverSecurityPolicy);\n+          BinderTransportSecurity.attachAuthAttrs(attrsBuilder, callingUid, serverPolicyChecker);\n           // Create a new transport and let our listener know about it.\n           BinderTransport.BinderServerTransport transport =\n               new BinderTransport.BinderServerTransport(\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java b/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\nindex b968e744685..022ae7f6d20 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderTransportSecurity.java\n@@ -16,6 +16,7 @@\n \n package io.grpc.binder.internal;\n \n+import com.google.common.util.concurrent.ListenableFuture;\n import io.grpc.Attributes;\n import io.grpc.Internal;\n import io.grpc.Metadata;\n@@ -26,9 +27,9 @@\n import io.grpc.ServerCallHandler;\n import io.grpc.ServerInterceptor;\n import io.grpc.Status;\n-import io.grpc.binder.ServerSecurityPolicy;\n import io.grpc.internal.GrpcAttributes;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n import javax.annotation.CheckReturnValue;\n \n /**\n@@ -60,15 +61,15 @@ public static void installAuthInterceptor(ServerBuilder<?> serverBuilder) {\n    *\n    * @param builder The {@link Attributes.Builder} for the transport being created.\n    * @param remoteUid The remote UID of the transport.\n-   * @param securityPolicy The policy to enforce on this transport.\n+   * @param serverPolicyChecker The policy checker for this transport.\n    */\n   @Internal\n   public static void attachAuthAttrs(\n-      Attributes.Builder builder, int remoteUid, ServerSecurityPolicy securityPolicy) {\n+      Attributes.Builder builder, int remoteUid, ServerPolicyChecker serverPolicyChecker) {\n     builder\n         .set(\n             TRANSPORT_AUTHORIZATION_STATE,\n-            new TransportAuthorizationState(remoteUid, securityPolicy))\n+            new TransportAuthorizationState(remoteUid, serverPolicyChecker))\n         .set(GrpcAttributes.ATTR_SECURITY_LEVEL, SecurityLevel.PRIVACY_AND_INTEGRITY);\n   }\n \n@@ -99,12 +100,12 @@ public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(\n    */\n   private static final class TransportAuthorizationState {\n     private final int uid;\n-    private final ServerSecurityPolicy policy;\n+    private final ServerPolicyChecker serverPolicyChecker;\n     private final ConcurrentHashMap<String, Status> serviceAuthorization;\n \n-    TransportAuthorizationState(int uid, ServerSecurityPolicy policy) {\n+    TransportAuthorizationState(int uid, ServerPolicyChecker serverPolicyChecker) {\n       this.uid = uid;\n-      this.policy = policy;\n+      this.serverPolicyChecker = serverPolicyChecker;\n       serviceAuthorization = new ConcurrentHashMap<>(8);\n     }\n \n@@ -123,11 +124,47 @@ Status checkAuthorization(MethodDescriptor<?, ?> method) {\n           return authorization;\n         }\n       }\n-      authorization = policy.checkAuthorizationForService(uid, serviceName);\n+      try {\n+        // TODO(10566): provide a synchronous version of \"checkAuthorization\" to avoid blocking the\n+        // calling thread on the completion of the future.\n+        authorization =\n+            serverPolicyChecker.checkAuthorizationForServiceAsync(uid, serviceName).get();\n+      } catch (ExecutionException e) {\n+        // Do not cache this failure since it may be transient.\n+        return Status.fromThrowable(e);\n+      } catch (InterruptedException e) {\n+        // Do not cache this failure since it may be transient.\n+        Thread.currentThread().interrupt();\n+        return Status.CANCELLED.withCause(e);\n+      }\n       if (useCache) {\n         serviceAuthorization.putIfAbsent(serviceName, authorization);\n       }\n       return authorization;\n     }\n   }\n+\n+  /**\n+   * Decides whether a given Android UID is authorized to access some resource.\n+   *\n+   * <p>This class provides the asynchronous version of {@link io.grpc.binder.SecurityPolicy},\n+   * allowing implementations of authorization logic that involves slow or asynchronous calls\n+   * without necessarily blocking the calling thread.\n+   *\n+   * @see io.grpc.binder.SecurityPolicy\n+   */\n+  public interface ServerPolicyChecker {\n+    /**\n+     * Returns whether the given Android UID is authorized to access a particular service.\n+     *\n+     * <p>This method never throws an exception. If the execution of the security policy check\n+     * fails, a failed future with such exception is returned.\n+     *\n+     * @param uid The Android UID to authenticate.\n+     * @param serviceName The name of the gRPC service being called.\n+     * @return a future with the result of the authorization check. A failed future represents a\n+     *    failure to perform the authorization check, not that the access is denied.\n+     */\n+    ListenableFuture<Status> checkAuthorizationForServiceAsync(int uid, String serviceName);\n+  }\n }\n",
    "test_patch": "diff --git a/binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java b/binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java\nindex 5140057d72e..c06bf88955e 100644\n--- a/binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java\n+++ b/binder/src/androidTest/java/io/grpc/binder/internal/BinderTransportTest.java\n@@ -25,6 +25,7 @@\n import io.grpc.binder.AndroidComponentAddress;\n import io.grpc.binder.BindServiceFlags;\n import io.grpc.binder.BinderChannelCredentials;\n+import io.grpc.binder.BinderInternal;\n import io.grpc.binder.HostServices;\n import io.grpc.binder.InboundParcelablePolicy;\n import io.grpc.binder.SecurityPolicies;\n@@ -69,7 +70,7 @@ protected InternalServer newServer(List<ServerStreamTracer.Factory> streamTracer\n     BinderServer binderServer = new BinderServer(addr,\n         executorServicePool,\n         streamTracerFactories,\n-        SecurityPolicies.serverInternalOnly(),\n+        BinderInternal.createPolicyChecker(SecurityPolicies.serverInternalOnly()),\n         InboundParcelablePolicy.DEFAULT);\n \n     HostServices.configureService(addr,\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10563",
    "pr_id": 10563,
    "issue_id": 1670,
    "repo": "grpc/grpc-java",
    "problem_statement": "DefaultHttp2HeadersEncoder.encodeHeaders are slow\nAfter GC and syscalls, `io.netty.handler.codec.http2.DefaultHttp2HeadersEncoder.encodeHeaders` takes the most CPU on a simple ping pong stress test. It accounts for about 3.3% of total program time.  The offending line is:\n\nhttps://github.com/netty/netty/blob/83c349ffa94d3992c4ee511d3625afc0c97c12bb/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java#L68\n\nI am not sure why this is so slow, but we should probably investigate it.  My test does nothing special with  headers.\n",
    "issue_word_count": 82,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "netty/src/main/java/io/grpc/netty/NettyClientHandler.java",
      "netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java"
    ],
    "pr_changed_test_files": [
      "netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java"
    ],
    "base_commit": "e1334eae7bba39d85a952bc5ab5aeb4cb05a56d8",
    "head_commit": "be1bbd52b2b6e2d378f8585cfa77da1813439a4c",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10563",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10563",
    "dockerfile": "",
    "pr_merged_at": "2023-11-14T19:09:38.000Z",
    "patch": "diff --git a/netty/src/main/java/io/grpc/netty/NettyClientHandler.java b/netty/src/main/java/io/grpc/netty/NettyClientHandler.java\nindex 792d76b1358..2891579d55c 100644\n--- a/netty/src/main/java/io/grpc/netty/NettyClientHandler.java\n+++ b/netty/src/main/java/io/grpc/netty/NettyClientHandler.java\n@@ -54,6 +54,7 @@\n import io.netty.handler.codec.http2.DefaultHttp2ConnectionEncoder;\n import io.netty.handler.codec.http2.DefaultHttp2FrameReader;\n import io.netty.handler.codec.http2.DefaultHttp2FrameWriter;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersEncoder;\n import io.netty.handler.codec.http2.DefaultHttp2LocalFlowController;\n import io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController;\n import io.netty.handler.codec.http2.Http2CodecUtil;\n@@ -69,6 +70,7 @@\n import io.netty.handler.codec.http2.Http2FrameWriter;\n import io.netty.handler.codec.http2.Http2Headers;\n import io.netty.handler.codec.http2.Http2HeadersDecoder;\n+import io.netty.handler.codec.http2.Http2HeadersEncoder;\n import io.netty.handler.codec.http2.Http2InboundFrameLogger;\n import io.netty.handler.codec.http2.Http2OutboundFrameLogger;\n import io.netty.handler.codec.http2.Http2Settings;\n@@ -150,7 +152,9 @@ static NettyClientHandler newHandler(\n     Preconditions.checkArgument(maxHeaderListSize > 0, \"maxHeaderListSize must be positive\");\n     Http2HeadersDecoder headersDecoder = new GrpcHttp2ClientHeadersDecoder(maxHeaderListSize);\n     Http2FrameReader frameReader = new DefaultHttp2FrameReader(headersDecoder);\n-    Http2FrameWriter frameWriter = new DefaultHttp2FrameWriter();\n+    Http2HeadersEncoder encoder = new DefaultHttp2HeadersEncoder(\n+        Http2HeadersEncoder.NEVER_SENSITIVE, false, 16, Integer.MAX_VALUE);\n+    Http2FrameWriter frameWriter = new DefaultHttp2FrameWriter(encoder);\n     Http2Connection connection = new DefaultHttp2Connection(false);\n     WeightedFairQueueByteDistributor dist = new WeightedFairQueueByteDistributor(connection);\n     dist.allocationQuantum(16 * 1024); // Make benchmarks fast again.\n",
    "test_patch": "diff --git a/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java b/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java\nindex 61dfcb15ecf..5ddfc10d98a 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyClientTransportTest.java\n@@ -36,6 +36,7 @@\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n+import com.google.common.base.Strings;\n import com.google.common.base.Ticker;\n import com.google.common.io.ByteStreams;\n import com.google.common.util.concurrent.SettableFuture;\n@@ -69,6 +70,7 @@\n import io.grpc.netty.NettyChannelBuilder.LocalSocketPicker;\n import io.grpc.netty.NettyTestUtil.TrackingObjectPoolForTest;\n import io.grpc.testing.TlsTesting;\n+import io.netty.buffer.ByteBuf;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelConfig;\n import io.netty.channel.ChannelDuplexHandler;\n@@ -76,6 +78,7 @@\n import io.netty.channel.ChannelHandler;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPromise;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.ReflectiveChannelFactory;\n import io.netty.channel.local.LocalChannel;\n@@ -92,6 +95,7 @@\n import java.io.InputStream;\n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n@@ -101,6 +105,7 @@\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import javax.annotation.Nullable;\n import javax.net.ssl.SSLException;\n import javax.net.ssl.SSLHandshakeException;\n@@ -538,6 +543,46 @@ public void maxHeaderListSizeShouldBeEnforcedOnClient() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void huffmanCodingShouldNotBePerformed() throws Exception {\n+    String longStringOfA = Strings.repeat(\"a\", 128);\n+\n+    negotiator = ProtocolNegotiators.serverPlaintext();\n+    startServer();\n+\n+    NettyClientTransport transport = newTransport(ProtocolNegotiators.plaintext(),\n+        DEFAULT_MAX_MESSAGE_SIZE, GrpcUtil.DEFAULT_MAX_HEADER_LIST_SIZE, null, false,\n+        TimeUnit.SECONDS.toNanos(10L), TimeUnit.SECONDS.toNanos(1L),\n+        new ReflectiveChannelFactory<>(NioSocketChannel.class), group);\n+\n+    Metadata headers = new Metadata();\n+    headers.put(Metadata.Key.of(\"test\", Metadata.ASCII_STRING_MARSHALLER),\n+        longStringOfA);\n+\n+    callMeMaybe(transport.start(clientTransportListener));\n+\n+    AtomicBoolean foundExpectedHeaderBytes = new AtomicBoolean(false);\n+\n+    transport.channel().pipeline().addFirst(new ChannelDuplexHandler() {\n+      @Override\n+      public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+          throws Exception {\n+        if (msg instanceof ByteBuf) {\n+          if (((ByteBuf) msg).toString(StandardCharsets.UTF_8).contains(longStringOfA)) {\n+            foundExpectedHeaderBytes.set(true);\n+          }\n+        }\n+        super.write(ctx, msg, promise);\n+      }\n+    });\n+\n+    new Rpc(transport, headers).halfClose().waitForResponse();\n+\n+    if (!foundExpectedHeaderBytes.get()) {\n+      fail(\"expected to find UTF-8 encoded 'a's in the header\");\n+    }\n+  }\n+\n   @Test\n   public void maxHeaderListSizeShouldBeEnforcedOnServer() throws Exception {\n     startServer(100, 1);\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10550",
    "pr_id": 10550,
    "issue_id": 9062,
    "repo": "grpc/grpc-java",
    "problem_statement": "binder: BinderChannelBuilder should not force clients to hard code an android.app.Service class name\n### Is your feature request related to a problem?\r\n`BinderChannelBuilder` requires an `AndroidComponentAddress` and an `AndroidComponentAddress` requires a `ComponentName` (the package name and class name of the target `android.app.Service`). This forces clients to hard code the server's class name.\r\n\r\nBecause client and server APKs can't be upgraded atomically, servers with external clients must keep the same service name forever, to accommodate old clients. If two gRPC services are hosted in the same `android.app.Service`, they must be hosted in the same `android:process` forever.\r\n\r\n### Describe the solution you'd like\r\nAndroid naturally supports a layer of indirection using https://developer.android.com/guide/components/intents-filters. Since SDK 21, bindService() Intents must be explicit but this doesn't require specifying the full ComponentName. [An Intent that specifies a setPackage() filter is also considered explicit](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/ContextImpl.java;l=1823-1834;drc=4b30a3ee919fa1ba77a967ba375b95dac3e61efe). Clients of a gRPC service/interface named `com.foo.ISomething` might do something like:\r\n\r\n```\r\nBinderChannelBuilder.forTarget(\"intent://#Intent;action=com.foo.ISomething;pkg=com.foo;end\", ...)\r\n  ...\r\n  .build();\r\n```\r\n\r\nServers could keep their Service class names private and use <intent-filters> to map to Services in the AndroidManifest.xml instead:\r\n```\r\n<service name=\"com.server.app.Service1\" process=\":p1\">\r\n  <intent-filter>\r\n    <action name=\"com.foo.ISomething\"/>\r\n  </intent-filter>\r\n</service>\r\n```\r\n\r\nSeveral Google apps, including photos, already uses this technique for their AIDL services.\r\n\r\n### Describe alternatives you've considered\r\nCould use a NameResolverProvider that calls PackageManager#resolveService(), but that costs one extra IPC round trip to the system server before calling bindService(). Any cached addresses could also get out of sync with reality when the target's package is upgraded.\r\n",
    "issue_word_count": 299,
    "test_files_count": 3,
    "non_test_files_count": 2,
    "pr_changed_files": [
      "binder/src/androidTest/AndroidManifest.xml",
      "binder/src/androidTest/java/io/grpc/binder/BinderChannelSmokeTest.java",
      "binder/src/main/java/io/grpc/binder/AndroidComponentAddress.java",
      "binder/src/main/java/io/grpc/binder/internal/BinderTransport.java",
      "binder/src/test/java/io/grpc/binder/AndroidComponentAddressTest.java"
    ],
    "pr_changed_test_files": [
      "binder/src/androidTest/AndroidManifest.xml",
      "binder/src/androidTest/java/io/grpc/binder/BinderChannelSmokeTest.java",
      "binder/src/test/java/io/grpc/binder/AndroidComponentAddressTest.java"
    ],
    "base_commit": "6335e0be3ef2b0195eae874a9e1a65a031328646",
    "head_commit": "6d9860569a6ff90f49c825ce99b8eb8fc7ffdd51",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10550",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10550",
    "dockerfile": "",
    "pr_merged_at": "2023-09-13T00:27:36.000Z",
    "patch": "diff --git a/binder/src/main/java/io/grpc/binder/AndroidComponentAddress.java b/binder/src/main/java/io/grpc/binder/AndroidComponentAddress.java\nindex 90197ee8382..2cad159f2e9 100644\n--- a/binder/src/main/java/io/grpc/binder/AndroidComponentAddress.java\n+++ b/binder/src/main/java/io/grpc/binder/AndroidComponentAddress.java\n@@ -23,30 +23,35 @@\n import android.content.Context;\n import android.content.Intent;\n import java.net.SocketAddress;\n+import javax.annotation.Nullable;\n \n /**\n  * The target of an Android {@link android.app.Service} binding.\n  *\n- * <p>Consists of a {@link ComponentName} reference to the Service and the action, data URI, type,\n- * and category set for an {@link Intent} used to bind to it. All together, these fields identify\n- * the {@link android.os.IBinder} that would be returned by some implementation of {@link\n- * android.app.Service#onBind(Intent)}. Indeed, the semantics of {@link #equals(Object)} match\n- * Android's internal equivalence relation for caching the result of calling this method. See <a\n+ * <p>Consists of an explicit {@link Intent} that identifies an {@link android.os.IBinder} returned\n+ * by some Service's {@link android.app.Service#onBind(Intent)} method. You can specify that Service\n+ * by {@link ComponentName} or let Android resolve it using the Intent's other fields (package,\n+ * action, data URI, type and category set). See <a\n  * href=\"https://developer.android.com/guide/components/bound-services\">Bound Services Overview</a>\n- * for more.\n+ * and <a href=\"https://developer.android.com/guide/components/intents-filters\">Intents and Intent\n+ * Filters</a> for more.\n  *\n  * <p>For convenience in the common case where a {@link android.app.Service} exposes just one {@link\n  * android.os.IBinder} IPC interface, we provide default values for the binding {@link Intent}\n  * fields, namely, an action of {@link ApiConstants#ACTION_BIND}, an empty category set and null\n  * type and data URI.\n+ *\n+ * <p>The semantics of {@link #equals(Object)} are the same as {@link Intent#filterEquals(Intent)}.\n  */\n public final class AndroidComponentAddress extends SocketAddress {\n   private static final long serialVersionUID = 0L;\n \n-  private final Intent bindIntent; // An \"explicit\" Intent. In other words, getComponent() != null.\n+  private final Intent bindIntent; // \"Explicit\", having either a component or package restriction.\n \n   protected AndroidComponentAddress(Intent bindIntent) {\n-    checkArgument(bindIntent.getComponent() != null, \"Missing required component\");\n+    checkArgument(\n+        bindIntent.getComponent() != null || bindIntent.getPackage() != null,\n+        \"'bindIntent' must be explicit. Specify either a package or ComponentName.\");\n     this.bindIntent = bindIntent;\n   }\n \n@@ -79,14 +84,19 @@ public static AndroidComponentAddress forRemoteComponent(\n   }\n \n   /**\n-   * Creates a new address that refers to <code>intent</code>'s component and that uses the \"filter\n-   * matching\" fields of <code>intent</code> as the binding {@link Intent}.\n+   * Creates a new address that uses the \"filter matching\" fields of <code>intent</code> as the\n+   * binding {@link Intent}.\n+   *\n+   * <p><code>intent</code> must be \"explicit\", i.e. having either a target component ({@link\n+   * Intent#getComponent()}) or package restriction ({@link Intent#getPackage()}). See <a\n+   * href=\"https://developer.android.com/guide/components/intents-filters\">Intents and Intent\n+   * Filters</a> for more.\n    *\n    * <p>A multi-tenant {@link android.app.Service} can call this from its {@link\n    * android.app.Service#onBind(Intent)} method to locate an appropriate {@link io.grpc.Server} by\n    * listening address.\n    *\n-   * @throws IllegalArgumentException if intent's component is null\n+   * @throws IllegalArgumentException if 'intent' isn't \"explicit\"\n    */\n   public static AndroidComponentAddress forBindIntent(Intent intent) {\n     return new AndroidComponentAddress(intent.cloneFilter());\n@@ -104,12 +114,26 @@ public static AndroidComponentAddress forComponent(ComponentName component) {\n   /**\n    * Returns the Authority which is the package name of the target app.\n    *\n-   * <p>See {@link android.content.ComponentName}.\n+   * <p>See {@link android.content.ComponentName} and {@link Intent#getPackage()}.\n    */\n   public String getAuthority() {\n-    return getComponent().getPackageName();\n+    return getPackage();\n+  }\n+\n+  /**\n+   * Returns the package target of the wrapped {@link Intent}, either from its package restriction\n+   * or, if not present, its fully qualified {@link ComponentName}.\n+   */\n+  public String getPackage() {\n+    if (bindIntent.getPackage() != null) {\n+      return bindIntent.getPackage();\n+    } else {\n+      return bindIntent.getComponent().getPackageName();\n+    }\n   }\n \n+  /** Returns the {@link ComponentName} of this binding {@link Intent}, or null if one isn't set. */\n+  @Nullable\n   public ComponentName getComponent() {\n     return bindIntent.getComponent();\n   }\n@@ -131,7 +155,7 @@ public String asAndroidAppUri() {\n     Intent intentForUri = bindIntent;\n     if (intentForUri.getPackage() == null) {\n       // URI_ANDROID_APP_SCHEME requires an \"explicit package name\" which isn't set by any of our\n-      // factory methods. Oddly, our explicit ComponentName is not enough.\n+      // factory methods. Oddly, a ComponentName is not enough.\n       intentForUri = intentForUri.cloneFilter().setPackage(getComponent().getPackageName());\n     }\n     return intentForUri.toUri(URI_ANDROID_APP_SCHEME);\n\ndiff --git a/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java b/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\nindex cb2fe5be3e5..c17fb01fc9a 100644\n--- a/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\n+++ b/binder/src/main/java/io/grpc/binder/internal/BinderTransport.java\n@@ -784,9 +784,7 @@ private static InternalLogId buildLogId(\n         Context sourceContext, AndroidComponentAddress targetAddress) {\n       return InternalLogId.allocate(\n           BinderClientTransport.class,\n-          sourceContext.getClass().getSimpleName()\n-              + \"->\"\n-              + targetAddress.getComponent().toShortString());\n+          sourceContext.getClass().getSimpleName() + \"->\" + targetAddress);\n     }\n \n     private static Attributes buildClientAttributes(\n",
    "test_patch": "diff --git a/binder/src/androidTest/AndroidManifest.xml b/binder/src/androidTest/AndroidManifest.xml\nindex 5e0da126145..b6d71574410 100644\n--- a/binder/src/androidTest/AndroidManifest.xml\n+++ b/binder/src/androidTest/AndroidManifest.xml\n@@ -8,7 +8,15 @@\n   <application android:debuggable=\"true\">\n     <uses-library android:name=\"android.test.runner\" />\n \n-    <service android:name=\"io.grpc.binder.HostServices$HostService1\" />\n-    <service android:name=\"io.grpc.binder.HostServices$HostService2\" />\n+    <service android:name=\"io.grpc.binder.HostServices$HostService1\" android:exported=\"false\">\n+      <intent-filter>\n+        <action android:name=\"action1\"/>\n+      </intent-filter>\n+    </service>\n+    <service android:name=\"io.grpc.binder.HostServices$HostService2\" android:exported=\"false\">\n+      <intent-filter>\n+        <action android:name=\"action2\"/>\n+      </intent-filter>\n+    </service>\n   </application>\n </manifest>\n\ndiff --git a/binder/src/androidTest/java/io/grpc/binder/BinderChannelSmokeTest.java b/binder/src/androidTest/java/io/grpc/binder/BinderChannelSmokeTest.java\nindex cdab0c35565..985d5188a1c 100644\n--- a/binder/src/androidTest/java/io/grpc/binder/BinderChannelSmokeTest.java\n+++ b/binder/src/androidTest/java/io/grpc/binder/BinderChannelSmokeTest.java\n@@ -22,6 +22,7 @@\n import static java.util.concurrent.TimeUnit.SECONDS;\n \n import android.content.Context;\n+import android.content.Intent;\n import android.os.Parcel;\n import android.os.Parcelable;\n import androidx.test.core.app.ApplicationProvider;\n@@ -32,7 +33,6 @@\n import com.google.common.util.concurrent.SettableFuture;\n import io.grpc.CallOptions;\n import io.grpc.Channel;\n-import io.grpc.ClientCall;\n import io.grpc.ClientInterceptors;\n import io.grpc.ConnectivityState;\n import io.grpc.ForwardingServerCall.SimpleForwardingServerCall;\n@@ -234,6 +234,18 @@ public void testConnectViaTargetUri() throws Exception {\n     assertThat(doCall(\"Hello\").get()).isEqualTo(\"Hello\");\n   }\n \n+  @Test\n+  public void testConnectViaIntentFilter() throws Exception {\n+    // Compare with the <intent-filter> mapping in AndroidManifest.xml.\n+    channel =\n+        BinderChannelBuilder.forAddress(\n+                AndroidComponentAddress.forBindIntent(\n+                    new Intent().setAction(\"action1\").setPackage(appContext.getPackageName())),\n+                appContext)\n+            .build();\n+    assertThat(doCall(\"Hello\").get()).isEqualTo(\"Hello\");\n+  }\n+\n   @Test\n   public void testUncaughtServerException() throws Exception {\n     // Use a poison parcelable to cause an unexpected Exception in the server's onTransact().\n\ndiff --git a/binder/src/test/java/io/grpc/binder/AndroidComponentAddressTest.java b/binder/src/test/java/io/grpc/binder/AndroidComponentAddressTest.java\nindex 8c7bc83d214..6d7e53e5a19 100644\n--- a/binder/src/test/java/io/grpc/binder/AndroidComponentAddressTest.java\n+++ b/binder/src/test/java/io/grpc/binder/AndroidComponentAddressTest.java\n@@ -49,6 +49,26 @@ public void testComponent() {\n     assertThat(addr.getComponent()).isSameInstanceAs(hostComponent);\n   }\n \n+  @Test\n+  public void testTargetPackageNullComponentName() {\n+    AndroidComponentAddress addr =\n+        AndroidComponentAddress.forBindIntent(\n+            new Intent().setPackage(\"com.foo\").setAction(ApiConstants.ACTION_BIND));\n+    assertThat(addr.getPackage()).isEqualTo(\"com.foo\");\n+    assertThat(addr.getComponent()).isNull();\n+  }\n+\n+  @Test\n+  public void testTargetPackageNonNullComponentName() {\n+    AndroidComponentAddress addr =\n+        AndroidComponentAddress.forBindIntent(\n+            new Intent()\n+                .setComponent(new ComponentName(\"com.foo\", \"com.foo.BarService\"))\n+                .setPackage(\"com.foo\")\n+                .setAction(ApiConstants.ACTION_BIND));\n+    assertThat(addr.getPackage()).isEqualTo(\"com.foo\");\n+  }\n+\n   @Test\n   public void testAsBindIntent() {\n     Intent bindIntent =\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10545",
    "pr_id": 10545,
    "issue_id": 10525,
    "repo": "grpc/grpc-java",
    "problem_statement": "DEADLINE_EXCEEDED doesn't give hints for slow resolver\nDebugging DEADLINE_EXCEEDED can be pretty horrible. To make it better, we have infrastructure in the streams to `appendTimeoutInsight()`, where we can make note of various delays to help figure out if the DEADLINE_EXCEEDED was expected or a problem.\r\n\r\nHowever, since we added DelayedClientCall to queue RPCs until we receive service config, there's now a major I/O point that we don't inform the user about the timing. And we can't differentiate whether a delay was caused by an interceptor doing something or whether it was just waiting for DNS.\r\n\r\nIt is probably worth the effort to plumb some additional reporting so we can further enhance the error messages. The `ManagedChannelImpl.PendingCall` could put a duration in the `NAME_RESOLUTION_DELAYED` call option and then `ClientCallImpl` could look at that when processing a DEADLINE_EXCEEDED error. We would want to enhance the \"ClientCall started after %s deadline was exceeded .9%f seconds ago\" error as well as as place in ClientCallImpl that does `appendTimeoutInsight()`.\r\n\r\nThis came up [internally at Google](https://yaqs.corp.google.com/eng/q/5469279799325229056), and made debugging more difficult.",
    "issue_word_count": 190,
    "test_files_count": 3,
    "non_test_files_count": 4,
    "pr_changed_files": [
      "api/src/main/java/io/grpc/ClientStreamTracer.java",
      "census/src/main/java/io/grpc/census/CensusTracingModule.java",
      "census/src/test/java/io/grpc/census/CensusModulesTest.java",
      "core/src/main/java/io/grpc/internal/ClientCallImpl.java",
      "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java",
      "core/src/test/java/io/grpc/internal/ClientCallImplTest.java",
      "core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java"
    ],
    "pr_changed_test_files": [
      "census/src/test/java/io/grpc/census/CensusModulesTest.java",
      "core/src/test/java/io/grpc/internal/ClientCallImplTest.java",
      "core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java"
    ],
    "base_commit": "878e301a5cf80b9e45ab8692ea6a1cc7e143fca6",
    "head_commit": "a2020e2d025236d48bdbf89f1ebf691bb89a90e2",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10545",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10545",
    "dockerfile": "",
    "pr_merged_at": "2023-09-08T22:09:19.000Z",
    "patch": "diff --git a/api/src/main/java/io/grpc/ClientStreamTracer.java b/api/src/main/java/io/grpc/ClientStreamTracer.java\nindex 5d55ae119f9..cb2f5538e34 100644\n--- a/api/src/main/java/io/grpc/ClientStreamTracer.java\n+++ b/api/src/main/java/io/grpc/ClientStreamTracer.java\n@@ -28,11 +28,11 @@\n @ThreadSafe\n public abstract class ClientStreamTracer extends StreamTracer {\n   /**\n-   * The call was delayed due to waiting for name resolution result.\n+   * Indicates how long the call was delayed, in nanoseconds, due to waiting for name resolution\n+   * result. If the call option is not set, the call did not experience name resolution delay.\n    */\n-  public static final CallOptions.Key<Boolean> NAME_RESOLUTION_DELAYED =\n-      CallOptions.Key.createWithDefault(\"io.grpc.ClientStreamTracer.NAME_RESOLUTION_DELAYED\",\n-          false);\n+  public static final CallOptions.Key<Long> NAME_RESOLUTION_DELAYED =\n+      CallOptions.Key.create(\"io.grpc.ClientStreamTracer.NAME_RESOLUTION_DELAYED\");\n \n   /**\n    * The stream is being created on a ready transport.\n\ndiff --git a/census/src/main/java/io/grpc/census/CensusTracingModule.java b/census/src/main/java/io/grpc/census/CensusTracingModule.java\nindex 4afa08bc716..68ec8b61eda 100644\n--- a/census/src/main/java/io/grpc/census/CensusTracingModule.java\n+++ b/census/src/main/java/io/grpc/census/CensusTracingModule.java\n@@ -270,7 +270,7 @@ public ClientStreamTracer newClientStreamTracer(\n           \"previous-rpc-attempts\", AttributeValue.longAttributeValue(info.getPreviousAttempts()));\n       attemptSpan.putAttribute(\n           \"transparent-retry\", AttributeValue.booleanAttributeValue(info.isTransparentRetry()));\n-      if (info.getCallOptions().getOption(NAME_RESOLUTION_DELAYED)) {\n+      if (info.getCallOptions().getOption(NAME_RESOLUTION_DELAYED) != null) {\n         span.addAnnotation(\"Delayed name resolution complete\");\n       }\n       return new ClientTracer(attemptSpan, span, tracingHeader, isSampledToLocalTracing);\n\ndiff --git a/core/src/main/java/io/grpc/internal/ClientCallImpl.java b/core/src/main/java/io/grpc/internal/ClientCallImpl.java\nindex df28eba0574..e2176668b73 100644\n--- a/core/src/main/java/io/grpc/internal/ClientCallImpl.java\n+++ b/core/src/main/java/io/grpc/internal/ClientCallImpl.java\n@@ -20,6 +20,7 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.grpc.ClientStreamTracer.NAME_RESOLUTION_DELAYED;\n import static io.grpc.Contexts.statusFromCancelled;\n import static io.grpc.Status.DEADLINE_EXCEEDED;\n import static io.grpc.internal.GrpcUtil.CONTENT_ACCEPT_ENCODING_KEY;\n@@ -261,9 +262,12 @@ public void runInContext() {\n           GrpcUtil.getClientStreamTracers(callOptions, headers, 0, false);\n       String deadlineName =\n           isFirstMin(callOptions.getDeadline(), context.getDeadline()) ? \"CallOptions\" : \"Context\";\n+      Long nameResolutionDelay = callOptions.getOption(NAME_RESOLUTION_DELAYED);\n       String description = String.format(\n-          \"ClientCall started after %s deadline was exceeded .9%f seconds ago\", deadlineName,\n-          effectiveDeadline.timeRemaining(TimeUnit.NANOSECONDS) / NANO_TO_SECS);\n+          \"ClientCall started after %s deadline was exceeded %.9f seconds ago. \"\n+              + \"Name resolution delay %.9f seconds.\", deadlineName,\n+          effectiveDeadline.timeRemaining(TimeUnit.NANOSECONDS) / NANO_TO_SECS,\n+          nameResolutionDelay == null ? 0 : nameResolutionDelay / NANO_TO_SECS);\n       stream = new FailingClientStream(DEADLINE_EXCEEDED.withDescription(description), tracers);\n     }\n \n@@ -404,6 +408,9 @@ public void run() {\n       buf.append(seconds);\n       buf.append(String.format(Locale.US, \".%09d\", nanos));\n       buf.append(\"s. \");\n+      Long nsDelay = callOptions.getOption(NAME_RESOLUTION_DELAYED);\n+      buf.append(String.format(Locale.US, \"Name resolution delay %.9f seconds. \",\n+          nsDelay == null ? 0 : nsDelay / NANO_TO_SECS));\n       buf.append(insight);\n       stream.cancel(DEADLINE_EXCEEDED.augmentDescription(buf.toString()));\n     }\n\ndiff --git a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\nindex 96be3eb37e7..be433fbc780 100644\n--- a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n+++ b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n@@ -46,6 +46,7 @@\n import io.grpc.ConnectivityState;\n import io.grpc.ConnectivityStateInfo;\n import io.grpc.Context;\n+import io.grpc.Deadline;\n import io.grpc.DecompressorRegistry;\n import io.grpc.EquivalentAddressGroup;\n import io.grpc.ForwardingChannelBuilder;\n@@ -298,6 +299,8 @@ public void uncaughtException(Thread t, Throwable e) {\n   // Temporary false flag that can skip the retry code path.\n   private final boolean retryEnabled;\n \n+  private final Deadline.Ticker ticker = Deadline.getSystemTicker();\n+\n   // Called from syncContext\n   private final ManagedClientTransport.Listener delayedTransportListener =\n       new DelayedTransportListener();\n@@ -1066,6 +1069,7 @@ private final class PendingCall<ReqT, RespT> extends DelayedClientCall<ReqT, Res\n       final Context context;\n       final MethodDescriptor<ReqT, RespT> method;\n       final CallOptions callOptions;\n+      private final long callCreationTime;\n \n       PendingCall(\n           Context context, MethodDescriptor<ReqT, RespT> method, CallOptions callOptions) {\n@@ -1073,6 +1077,7 @@ private final class PendingCall<ReqT, RespT> extends DelayedClientCall<ReqT, Res\n         this.context = context;\n         this.method = method;\n         this.callOptions = callOptions;\n+        this.callCreationTime = ticker.nanoTime();\n       }\n \n       /** Called when it's ready to create a real call and reprocess the pending call. */\n@@ -1080,7 +1085,8 @@ void reprocess() {\n         ClientCall<ReqT, RespT> realCall;\n         Context previous = context.attach();\n         try {\n-          CallOptions delayResolutionOption = callOptions.withOption(NAME_RESOLUTION_DELAYED, true);\n+          CallOptions delayResolutionOption = callOptions.withOption(NAME_RESOLUTION_DELAYED,\n+              ticker.nanoTime() - callCreationTime);\n           realCall = newClientCall(method, delayResolutionOption);\n         } finally {\n           context.detach(previous);\n",
    "test_patch": "diff --git a/census/src/test/java/io/grpc/census/CensusModulesTest.java b/census/src/test/java/io/grpc/census/CensusModulesTest.java\nindex 12c71d7269a..6ccaf78314f 100644\n--- a/census/src/test/java/io/grpc/census/CensusModulesTest.java\n+++ b/census/src/test/java/io/grpc/census/CensusModulesTest.java\n@@ -134,7 +134,7 @@ public class CensusModulesTest {\n       CallOptions.DEFAULT.withOption(CUSTOM_OPTION, \"customvalue\");\n   private static final ClientStreamTracer.StreamInfo STREAM_INFO =\n       ClientStreamTracer.StreamInfo.newBuilder()\n-          .setCallOptions(CallOptions.DEFAULT.withOption(NAME_RESOLUTION_DELAYED, true)).build();\n+          .setCallOptions(CallOptions.DEFAULT.withOption(NAME_RESOLUTION_DELAYED, 10L)).build();\n \n   private static class StringInputStream extends InputStream {\n     final String string;\n\ndiff --git a/core/src/test/java/io/grpc/internal/ClientCallImplTest.java b/core/src/test/java/io/grpc/internal/ClientCallImplTest.java\nindex ce553ed2cf2..fb17c97417e 100644\n--- a/core/src/test/java/io/grpc/internal/ClientCallImplTest.java\n+++ b/core/src/test/java/io/grpc/internal/ClientCallImplTest.java\n@@ -17,6 +17,7 @@\n package io.grpc.internal;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.ClientStreamTracer.NAME_RESOLUTION_DELAYED;\n import static io.grpc.internal.ClientStreamListener.RpcProgress.PROCESSED;\n import static io.grpc.internal.GrpcUtil.ACCEPT_ENCODING_SPLITTER;\n import static java.util.concurrent.TimeUnit.SECONDS;\n@@ -765,7 +766,18 @@ public void onClose(Status status, Metadata trailers) {\n \n   @Test\n   public void deadlineExceededBeforeCallStarted() {\n-    CallOptions callOptions = baseCallOptions.withDeadlineAfter(0, TimeUnit.SECONDS);\n+    deadlineExeedeed(baseCallOptions.withDeadlineAfter(0, TimeUnit.SECONDS),\n+        \"Name resolution delay 0.000000000 seconds.\");\n+  }\n+\n+  @Test\n+  public void deadlineExceededBeforeCallStartedDelayed() {\n+    deadlineExeedeed(baseCallOptions.withDeadlineAfter(0, TimeUnit.SECONDS)\n+            .withOption(NAME_RESOLUTION_DELAYED, 1200000000L),\n+        \"Name resolution delay 1.200000000 seconds.\");\n+  }\n+\n+  private void deadlineExeedeed(CallOptions callOptions, String descriptionSuffix) {\n     fakeClock.forwardTime(System.nanoTime(), TimeUnit.NANOSECONDS);\n     ClientCallImpl<Void, Void> call = new ClientCallImpl<>(\n         method,\n@@ -785,8 +797,10 @@ public void deadlineExceededBeforeCallStarted() {\n             any(Context.class));\n     verify(callListener, timeout(1000)).onClose(statusCaptor.capture(), any(Metadata.class));\n     assertEquals(Status.Code.DEADLINE_EXCEEDED, statusCaptor.getValue().getCode());\n-    assertThat(statusCaptor.getValue().getDescription())\n+    String deadlineExceedDescription = statusCaptor.getValue().getDescription();\n+    assertThat(deadlineExceedDescription)\n         .startsWith(\"ClientCall started after CallOptions deadline was exceeded\");\n+    assertThat(deadlineExceedDescription).endsWith(descriptionSuffix);\n     verifyNoInteractions(clientStreamProvider);\n   }\n \n@@ -843,7 +857,8 @@ public void contextDeadlineShouldNotOverrideSmallerCallOptionsDeadline() {\n         .withDeadlineAfter(2000, TimeUnit.MILLISECONDS, deadlineCancellationExecutor);\n     Context origContext = context.attach();\n \n-    CallOptions callOpts = baseCallOptions.withDeadlineAfter(1000, TimeUnit.MILLISECONDS);\n+    CallOptions callOpts = baseCallOptions.withDeadlineAfter(1000, TimeUnit.MILLISECONDS)\n+        .withOption(NAME_RESOLUTION_DELAYED, 1200000000L);\n     ClientCallImpl<Void, Void> call = new ClientCallImpl<>(\n         method,\n         MoreExecutors.directExecutor(),\n@@ -859,6 +874,11 @@ public void contextDeadlineShouldNotOverrideSmallerCallOptionsDeadline() {\n     verify(stream).setDeadline(deadlineCaptor.capture());\n \n     assertTimeoutBetween(deadlineCaptor.getValue().timeRemaining(TimeUnit.MILLISECONDS), 600, 1000);\n+    fakeClock.forwardNanos(TimeUnit.MILLISECONDS.toNanos(1000));\n+    verify(stream, timeout(1000)).cancel(statusCaptor.capture());\n+    String deadlineExceedDescription = statusCaptor.getValue().getDescription();\n+    assertThat(deadlineExceedDescription)\n+        .contains(\"Name resolution delay 1.200000000 seconds.\");\n   }\n \n   @Test\n@@ -914,7 +934,8 @@ public void expiredDeadlineCancelsStream_CallOptions() {\n     verify(stream, times(1)).cancel(statusCaptor.capture());\n     assertEquals(Status.Code.DEADLINE_EXCEEDED, statusCaptor.getValue().getCode());\n     assertThat(statusCaptor.getValue().getDescription())\n-        .matches(\"deadline exceeded after [0-9]+\\\\.[0-9]+s. \\\\[remote_addr=127\\\\.0\\\\.0\\\\.1:443\\\\]\");\n+        .matches(\"deadline exceeded after [0-9]+\\\\.[0-9]+s. \"\n+            + \"Name resolution delay 0.000000000 seconds. \\\\[remote_addr=127\\\\.0\\\\.0\\\\.1:443\\\\]\");\n   }\n \n   @Test\n\ndiff --git a/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java b/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\nindex 5cb3ac6efae..da2bc072afc 100644\n--- a/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\n+++ b/core/src/test/java/io/grpc/internal/ManagedChannelImplTest.java\n@@ -1078,7 +1078,7 @@ public void loadBalancerThrowsInHandleResolvedAddresses() {\n   }\n \n   @Test\n-  public void delayedNameResolution() {\n+  public void delayedNameResolution() throws Exception {\n     ClientStream mockStream = mock(ClientStream.class);\n     final ClientStreamTracer tracer = new ClientStreamTracer() {};\n     ClientStreamTracer.Factory factory = new ClientStreamTracer.Factory() {\n@@ -1096,6 +1096,7 @@ public ClientStreamTracer newClientStreamTracer(StreamInfo info, Metadata header\n     ClientCall<String, Integer> call = channel.newCall(method, callOptions);\n     call.start(mockCallListener, new Metadata());\n \n+    Thread.sleep(500);\n     nsFactory.allResolved();\n     Subchannel subchannel =\n         createSubchannelSafely(helper, addressGroup, Attributes.EMPTY, subchannelStateListener);\n@@ -1118,7 +1119,10 @@ public ClientStreamTracer newClientStreamTracer(StreamInfo info, Metadata header\n         same(method), any(Metadata.class), callOptionsCaptor.capture(),\n         tracersCaptor.capture());\n     assertThat(Arrays.asList(tracersCaptor.getValue()).contains(tracer)).isTrue();\n-    assertThat(callOptionsCaptor.getValue().getOption(NAME_RESOLUTION_DELAYED)).isTrue();\n+    Long realDelay = callOptionsCaptor.getValue().getOption(NAME_RESOLUTION_DELAYED);\n+    assertThat(realDelay).isNotNull();\n+    assertThat(realDelay).isAtLeast(\n+        TimeUnit.MILLISECONDS.toNanos(400));//sleep not precise\n   }\n \n   @Test\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10543",
    "pr_id": 10543,
    "issue_id": 10292,
    "repo": "grpc/grpc-java",
    "problem_statement": "Observe io.netty.allocator.type for custom Netty allocator\nI modified code that depends on `grpc-java` to use the `unpooled` allocator type for `netty`. In order to accomplish this I had to:\r\n1. Pass in `unpooled` for the `io.netty.allocator.type` property. See https://github.com/netty/netty/blob/4.1/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java#L78\r\n2. Pass in `false` for the `io.grpc.netty.useCustomAllocator` property. I am using `v1.32.1` but this also applies to the latest version `v1.56.x`. See https://github.com/grpc/grpc-java/blob/v1.32.x/netty/src/main/java/io/grpc/netty/Utils.java#L126 and https://github.com/grpc/grpc-java/blob/v1.56.x/netty/src/main/java/io/grpc/netty/Utils.java#L136\r\n\r\nWhy is the default value for `io.grpc.netty.useCustomAllocator` `true`? In order for the code to use the `ByteBufAllocator.DEFAULT` the `io.grpc.netty.useCustomAllocator` property must be overridden to `false`, which seems to contradict the idea of a default. Would it make more sense for `io.grpc.netty.useCustomAllocator` to default to `false` so that `ByteBufAllocator.DEFAULT` is used by default?\r\n\r\nI am asking because I had to do some debugging to figure out why only supplying `io.netty.allocator.type=unpooled` did not change the allocator type as I had expected. Thanks!",
    "issue_word_count": 228,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "netty/src/main/java/io/grpc/netty/Utils.java",
      "netty/src/test/java/io/grpc/netty/UtilsTest.java"
    ],
    "pr_changed_test_files": [
      "netty/src/test/java/io/grpc/netty/UtilsTest.java"
    ],
    "base_commit": "131a0047c49865dddf845c9293e2165a8c2bdf26",
    "head_commit": "ede10ab3af1ad7fdd59800eda2c1463ff49b68e6",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10543",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10543",
    "dockerfile": "",
    "pr_merged_at": "2023-09-07T21:58:46.000Z",
    "patch": "diff --git a/netty/src/main/java/io/grpc/netty/Utils.java b/netty/src/main/java/io/grpc/netty/Utils.java\nindex 4af2f8463a5..96f19aab5e3 100644\n--- a/netty/src/main/java/io/grpc/netty/Utils.java\n+++ b/netty/src/main/java/io/grpc/netty/Utils.java\n@@ -37,6 +37,7 @@\n import io.grpc.netty.NettySocketSupport.NativeSocketOptions;\n import io.netty.buffer.ByteBufAllocator;\n import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.UnpooledByteBufAllocator;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelConfig;\n import io.netty.channel.ChannelFactory;\n@@ -60,6 +61,7 @@\n import java.lang.reflect.Constructor;\n import java.nio.channels.ClosedChannelException;\n import java.nio.channels.UnresolvedAddressException;\n+import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.TimeUnit;\n@@ -135,6 +137,13 @@ private static final class ByteBufAllocatorPreferHeapHolder {\n   public static ByteBufAllocator getByteBufAllocator(boolean forceHeapBuffer) {\n     if (Boolean.parseBoolean(\n             System.getProperty(\"io.grpc.netty.useCustomAllocator\", \"true\"))) {\n+\n+      String allocType = System.getProperty(\"io.netty.allocator.type\", \"pooled\");\n+      if (allocType.toLowerCase(Locale.ROOT).equals(\"unpooled\")) {\n+        logger.log(Level.FINE, \"Using unpooled allocator\");\n+        return UnpooledByteBufAllocator.DEFAULT;\n+      }\n+\n       boolean defaultPreferDirect = PooledByteBufAllocator.defaultPreferDirect();\n       logger.log(\n           Level.FINE,\n",
    "test_patch": "diff --git a/netty/src/test/java/io/grpc/netty/UtilsTest.java b/netty/src/test/java/io/grpc/netty/UtilsTest.java\nindex 90330a5fe96..95f57732117 100644\n--- a/netty/src/test/java/io/grpc/netty/UtilsTest.java\n+++ b/netty/src/test/java/io/grpc/netty/UtilsTest.java\n@@ -19,6 +19,7 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.TruthJUnit.assume;\n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n \n@@ -28,6 +29,7 @@\n import io.grpc.Metadata;\n import io.grpc.Status;\n import io.grpc.internal.GrpcUtil;\n+import io.netty.buffer.ByteBufAllocator;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelFactory;\n import io.netty.channel.ChannelOption;\n@@ -70,6 +72,21 @@ public void testStatusFromThrowable() {\n     assertStatusEquals(Status.UNKNOWN.withCause(t), Utils.statusFromThrowable(t));\n   }\n \n+  @Test\n+  public void testGetBufferAllocator() {\n+    ByteBufAllocator heapAllocator = Utils.getByteBufAllocator(true);\n+    ByteBufAllocator directAllocator = Utils.getByteBufAllocator(false);\n+    assertNotEquals(heapAllocator, directAllocator);\n+\n+    System.setProperty(\"io.netty.allocator.type\", \"unpooled\");\n+    ByteBufAllocator unpooled1 = Utils.getByteBufAllocator(false);\n+    assertThat(unpooled1.getClass().getName()).isNotEqualTo(\"UnpooledByteBufAllocator\");\n+\n+    System.setProperty(\"io.netty.allocator.type\", \"pooled\");\n+    ByteBufAllocator unpooled2 = Utils.getByteBufAllocator(false);\n+    assertEquals(directAllocator, unpooled2);\n+  }\n+\n   @Test\n   public void convertClientHeaders_sanitizes() {\n     Metadata metaData = new Metadata();\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10537",
    "pr_id": 10537,
    "issue_id": 10255,
    "repo": "grpc/grpc-java",
    "problem_statement": "NettyAdaptiveCumulator incorrectly releases `ByteBuf in` twice\n<!-- Please answer these questions before submitting a bug report. -->\r\n\r\n### What version of gRPC-Java are you using?\r\n\r\nVersion 1.51.0 introduced this issue.\r\n\r\n### What is your environment?\r\nAny\r\n\r\n### What did you expect to see?\r\n\r\n### What did you see instead?\r\n\r\n### Steps to reproduce the bug\r\n\r\n\r\n```java\r\n\r\nio.netty.handler.codec.DecoderException: io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:294)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.local.LocalChannel.readInbound(LocalChannel.java:299)\r\n\tat io.netty.channel.local.LocalChannel.doBeginRead(LocalChannel.java:322)\r\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe.beginRead(AbstractChannel.java:834)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.read(DefaultChannelPipeline.java:1362)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeRead(AbstractChannelHandlerContext.java:835)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.read(AbstractChannelHandlerContext.java:814)\r\n\tat io.netty.handler.codec.http2.Http2ConnectionHandler.read(Http2ConnectionHandler.java:539)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeRead(AbstractChannelHandlerContext.java:839)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.read(AbstractChannelHandlerContext.java:814)\r\n\tat io.netty.channel.DefaultChannelPipeline.read(DefaultChannelPipeline.java:1004)\r\n\tat io.netty.channel.AbstractChannel.read(AbstractChannel.java:290)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.readIfIsAutoRead(DefaultChannelPipeline.java:1422)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelReadComplete(DefaultChannelPipeline.java:1417)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:482)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelReadComplete(AbstractChannelHandlerContext.java:463)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelReadComplete(DefaultChannelPipeline.java:925)\r\n\tat io.netty.channel.local.LocalChannel.readInbound(LocalChannel.java:302)\r\n\tat io.netty.channel.local.LocalChannel.finishPeerRead0(LocalChannel.java:445)\r\n\tat io.netty.channel.local.LocalChannel.access$400(LocalChannel.java:50)\r\n\tat io.netty.channel.local.LocalChannel$5.run(LocalChannel.java:403)\r\n\tat io.netty.util.concurrent.AbstractEventExecutor.runTask(AbstractEventExecutor.java:174)\r\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1\r\n\tat io.netty.util.internal.ReferenceCountUpdater.toLiveRealRefCnt(ReferenceCountUpdater.java:83)\r\n\tat io.netty.util.internal.ReferenceCountUpdater.release(ReferenceCountUpdater.java:147)\r\n\tat io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:101)\r\n\tat io.grpc.netty.NettyAdaptiveCumulator.cumulate(NettyAdaptiveCumulator.java:95)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:288)\r\n\t... 33 common frames omitted\r\n\r\n```\r\n\r\n\r\nIn the case below, NettyAdaptiveCumulator incorrectly releases `ByteBuf in` twice.\r\n\r\n* io.grpc.netty.NettyAdaptiveCumulator.cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) \r\n\r\n* cumulation: UnpooledHeapByteBuf(ridx: 9, widx: 14, cap: 14/14) \r\n* in:  UnpooledHeapByteBuf(ridx: 0, widx: 8, cap: 8/8)\r\n\r\n---\r\n\r\n* The finally block of `NettyAdaptiveCumulator#mergeWithCompositeTail` is released once\r\n* Release again in the finally block of `NettyAdaptiveCumulator#cumulate`\r\n",
    "issue_word_count": 511,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java",
      "netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java"
    ],
    "pr_changed_test_files": [
      "netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java"
    ],
    "base_commit": "36e0af66fe63cc72984654eaa5d45a19e84357a7",
    "head_commit": "9a46d9ed77464853bc9ce051cd70b6c16e8f04c8",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10537",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10537",
    "dockerfile": "",
    "pr_merged_at": "2023-09-15T22:18:03.000Z",
    "patch": "diff --git a/netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java b/netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java\nindex b3a28c55c79..58eabb2cf8d 100644\n--- a/netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java\n+++ b/netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java\n@@ -204,16 +204,11 @@ static void mergeWithCompositeTail(\n       composite.addFlattenedComponents(true, newTail);\n       // New tail's ownership transferred to the composite buf.\n       newTail = null;\n-      in.release();\n-      in = null;\n-      // Restore the reader. In case it fails we restore the reader after releasing/forgetting\n-      // the input and the new tail so that finally block can handles them properly.\n       composite.readerIndex(prevReader);\n+      // Input buffer was successfully merged with the tail.\n+      // Must be the last line in the try because we release it only on success.\n+      in.release();\n     } finally {\n-      // Input buffer was merged with the tail.\n-      if (in != null) {\n-        in.release();\n-      }\n       // If new tail's ownership isn't transferred to the composite buf.\n       // Release it to prevent a leak.\n       if (newTail != null) {\n",
    "test_patch": "diff --git a/netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java b/netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java\nindex 6a0c00bac0e..0e524fd1c91 100644\n--- a/netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java\n+++ b/netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java\n@@ -533,11 +533,12 @@ public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex,\n \n       try {\n         NettyAdaptiveCumulator.mergeWithCompositeTail(alloc, compositeThrows, in);\n+        in = null; // On success it would be released\n         fail(\"Cumulator didn't throw\");\n       } catch (UnsupportedOperationException actualError) {\n         assertSame(expectedError, actualError);\n-        // Input must be released unless its ownership has been to the composite cumulation.\n-        assertEquals(0, in.refCnt());\n+        // Because of error, ownership shouldn't have changed so should not have been released.\n+        assertEquals(1, in.refCnt());\n         // Tail released\n         assertEquals(0, tail.refCnt());\n         // Composite cumulation is retained\n@@ -545,6 +546,9 @@ public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex,\n         // Composite cumulation loses the tail\n         assertEquals(0, compositeThrows.numComponents());\n       } finally {\n+        if (in != null) {\n+          in.release();\n+        }\n         compositeThrows.release();\n       }\n     }\n@@ -569,11 +573,12 @@ public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex,\n \n       try {\n         NettyAdaptiveCumulator.mergeWithCompositeTail(mockAlloc, compositeRo, in);\n+        in = null; // On success it would be released\n         fail(\"Cumulator didn't throw\");\n       } catch (UnsupportedOperationException actualError) {\n         assertSame(expectedError, actualError);\n-        // Input must be released unless its ownership has been to the composite cumulation.\n-        assertEquals(0, in.refCnt());\n+        // Because of error, ownership shouldn't have changed so should not have been released.\n+        assertEquals(1, in.refCnt());\n         // New buffer released\n         assertEquals(0, newTail.refCnt());\n         // Composite cumulation is retained\n@@ -581,6 +586,9 @@ public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex,\n         // Composite cumulation loses the tail\n         assertEquals(0, compositeRo.numComponents());\n       } finally {\n+        if (in != null) {\n+          in.release();\n+        }\n         compositeRo.release();\n       }\n     }\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10513",
    "pr_id": 10513,
    "issue_id": 10500,
    "repo": "grpc/grpc-java",
    "problem_statement": "grpc_health_probe suddenly fails after upgrade to grpc-java 1.55.3 from 1.54.2\nSo I'm running a [Bazel Buildfarm](https://github.com/bazelbuild/bazel-buildfarm) which depends on grpc-java. \r\nThe bulidfarm create a HealthStatusManager in [BuildFarmServer.java#L150](https://github.com/bazelbuild/bazel-buildfarm/blob/main/src/main/java/build/buildfarm/server/BuildFarmServer.java#L150)\r\n\r\nAnd I've been using [grpc_health_probe](https://github.com/grpc-ecosystem/grpc-health-probe) to check that the service is up and running like so:\r\n\r\n```\r\n./grpc_health_probe -addr=:8980\r\nstatus: SERVING\r\n```\r\n\r\nBut when the dependency to grpc-java is bumped from `1.54.2` to `1.55.3` this check suddenly breaks:\r\n```\r\n./grpc_health_probe -addr=:8980\r\nerror: health rpc failed: rpc error: code = Internal desc = Failed to frame message\r\n```\r\n\r\nWhile the bulidfarm is logging a stack trace:\r\n```\r\nSEVERE: Exception while executing runnable io.grpc.util.TransmitStatusRuntimeExceptionInterceptor$SerializingServerCall$4@71c820f9\r\njava.lang.IllegalStateException: call already closed\r\n\tat com.google.common.base.Preconditions.checkState(Preconditions.java:502)\r\n\tat io.grpc.internal.ServerCallImpl.closeInternal(ServerCallImpl.java:212)\r\n\tat io.grpc.internal.ServerCallImpl.close(ServerCallImpl.java:207)\r\n\tat io.grpc.PartialForwardingServerCall.close(PartialForwardingServerCall.java:48)\r\n\tat io.grpc.ForwardingServerCall.close(ForwardingServerCall.java:22)\r\n\tat io.grpc.ForwardingServerCall$SimpleForwardingServerCall.close(ForwardingServerCall.java:44)\r\n\tat io.grpc.util.TransmitStatusRuntimeExceptionInterceptor$SerializingServerCall.access$401(TransmitStatusRuntimeExceptionInterceptor.java:121)\r\n\tat io.grpc.util.TransmitStatusRuntimeExceptionInterceptor$SerializingServerCall$4.run(TransmitStatusRuntimeExceptionInterceptor.java:170)\r\n\tat io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)\r\n\tat com.google.common.util.concurrent.DirectExecutor.execute(DirectExecutor.java:31)\r\n\tat io.grpc.internal.SerializingExecutor.schedule(SerializingExecutor.java:102)\r\n\tat io.grpc.internal.SerializingExecutor.execute(SerializingExecutor.java:95)\r\n\tat io.grpc.util.TransmitStatusRuntimeExceptionInterceptor$SerializingServerCall.close(TransmitStatusRuntimeExceptionInterceptor.java:164)\r\n\tat io.grpc.stub.ServerCalls$ServerCallStreamObserverImpl.onCompleted(ServerCalls.java:395)\r\n\tat io.grpc.protobuf.services.HealthServiceImpl.check(HealthServiceImpl.java:77)\r\n\tat io.grpc.health.v1.HealthGrpc$MethodHandlers.invoke(HealthGrpc.java:326)\r\n\tat io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182)\r\n\tat io.grpc.PartialForwardingServerCallListener.onHalfClose(PartialForwardingServerCallListener.java:35)\r\n\tat io.grpc.ForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:23)\r\n\tat io.grpc.ForwardingServerCallListener$SimpleForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:40)\r\n\tat io.grpc.util.TransmitStatusRuntimeExceptionInterceptor$1.onHalfClose(TransmitStatusRuntimeExceptionInterceptor.java:74)\r\n\tat io.grpc.PartialForwardingServerCallListener.onHalfClose(PartialForwardingServerCallListener.java:35)\r\n\tat io.grpc.ForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:23)\r\n\tat io.grpc.ForwardingServerCallListener$SimpleForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:40)\r\n\tat io.grpc.Contexts$ContextualizedServerCallListener.onHalfClose(Contexts.java:86)\r\n\tat io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:346)\r\n\tat io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:860)\r\n\tat io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)\r\n\tat io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\n```\r\n\r\nSo I'm not posting this as a bug because I'm not sure the usage here is correct, and I'm mostly hoping for some input on what exactly could be going wrong.\r\n\r\nThanks",
    "issue_word_count": 487,
    "test_files_count": 1,
    "non_test_files_count": 1,
    "pr_changed_files": [
      "core/src/main/java/io/grpc/internal/ServerCallImpl.java",
      "core/src/test/java/io/grpc/internal/ServerCallImplTest.java"
    ],
    "pr_changed_test_files": [
      "core/src/test/java/io/grpc/internal/ServerCallImplTest.java"
    ],
    "base_commit": "2b4f649b0ab4dbbe6e03dcc19b4f607a942de450",
    "head_commit": "062ba2ab91784cc4fbe05e11b104266fd870d2d2",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10513",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10513",
    "dockerfile": "",
    "pr_merged_at": "2023-08-24T23:40:23.000Z",
    "patch": "diff --git a/core/src/main/java/io/grpc/internal/ServerCallImpl.java b/core/src/main/java/io/grpc/internal/ServerCallImpl.java\nindex 7555c4d78a4..08aff5f038f 100644\n--- a/core/src/main/java/io/grpc/internal/ServerCallImpl.java\n+++ b/core/src/main/java/io/grpc/internal/ServerCallImpl.java\n@@ -41,6 +41,7 @@\n import io.grpc.SecurityLevel;\n import io.grpc.ServerCall;\n import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n import io.perfmark.PerfMark;\n import io.perfmark.Tag;\n import io.perfmark.TaskCloseable;\n@@ -157,7 +158,7 @@ private void sendMessageInternal(RespT message) {\n     checkState(!closeCalled, \"call is closed\");\n \n     if (method.getType().serverSendsOneMessage() && messageSent) {\n-      internalClose(Status.INTERNAL.withDescription(TOO_MANY_RESPONSES));\n+      handleInternalError(Status.INTERNAL.withDescription(TOO_MANY_RESPONSES).asRuntimeException());\n       return;\n     }\n \n@@ -169,7 +170,7 @@ private void sendMessageInternal(RespT message) {\n         stream.flush();\n       }\n     } catch (RuntimeException e) {\n-      close(Status.fromThrowable(e), new Metadata());\n+      handleInternalError(e);\n     } catch (Error e) {\n       close(\n           Status.CANCELLED.withDescription(\"Server sendMessage() failed with Error\"),\n@@ -214,7 +215,7 @@ private void closeInternal(Status status, Metadata trailers) {\n       closeCalled = true;\n \n       if (status.isOk() && method.getType().serverSendsOneMessage() && !messageSent) {\n-        internalClose(Status.INTERNAL.withDescription(MISSING_RESPONSE));\n+        handleInternalError(Status.INTERNAL.withDescription(MISSING_RESPONSE).asRuntimeException());\n         return;\n       }\n \n@@ -263,10 +264,14 @@ public SecurityLevel getSecurityLevel() {\n    * run until completion, but silently ignore interactions with the {@link ServerStream} from now\n    * on.\n    */\n-  private void internalClose(Status internalError) {\n-    log.log(Level.WARNING, \"Cancelling the stream with status {0}\", new Object[] {internalError});\n-    stream.cancel(internalError);\n-    serverCallTracer.reportCallEnded(internalError.isOk()); // error so always false\n+  private void handleInternalError(Throwable internalError) {\n+    log.log(Level.WARNING, \"Cancelling the stream because of internal error\", internalError);\n+    Status status = (internalError instanceof StatusRuntimeException)\n+        ? ((StatusRuntimeException) internalError).getStatus()\n+        : Status.INTERNAL.withCause(internalError)\n+            .withDescription(\"Internal error so cancelling stream.\");\n+    stream.cancel(status);\n+    serverCallTracer.reportCallEnded(false); // error so always false\n   }\n \n   /**\n",
    "test_patch": "diff --git a/core/src/test/java/io/grpc/internal/ServerCallImplTest.java b/core/src/test/java/io/grpc/internal/ServerCallImplTest.java\nindex 10eb7f15049..cef21f6b7f0 100644\n--- a/core/src/test/java/io/grpc/internal/ServerCallImplTest.java\n+++ b/core/src/test/java/io/grpc/internal/ServerCallImplTest.java\n@@ -47,7 +47,6 @@\n import io.grpc.ServerCall;\n import io.grpc.Status;\n import io.grpc.internal.ServerCallImpl.ServerStreamListenerImpl;\n-import io.grpc.internal.SingleMessageProducer;\n import io.perfmark.PerfMark;\n import java.io.ByteArrayInputStream;\n import java.io.InputStream;\n@@ -220,7 +219,7 @@ public void sendMessage_closesOnFailure() {\n \n     call.sendMessage(1234L);\n \n-    verify(stream).close(isA(Status.class), isA(Metadata.class));\n+    verify(stream).cancel(isA(Status.class));\n   }\n \n   @Test\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  },
  {
    "instance_id": "grpc__grpc-java-10505",
    "pr_id": 10505,
    "issue_id": 10436,
    "repo": "grpc/grpc-java",
    "problem_statement": "Drop support for Android API 19 and 20\n[Google Play services is dropping support for KitKat.](https://android-developers.googleblog.com/2023/07/google-play-services-discontinuing-updates-for-kitkat.html) We follow them since lack of updates implies the Dynamic Security Provider also doesn't receive updates, which is a concern for security. And if the market share of an Android version becomes low enough that they can drop support, it is generally a good signal that we can.\r\n\r\nNot much changes, except turning off some tests. This is mostly updating our minimum version in our package and the README.\r\n\r\nCC @markb74 @jdcormie ",
    "issue_word_count": 104,
    "test_files_count": 2,
    "non_test_files_count": 7,
    "pr_changed_files": [
      "README.md",
      "android-interop-testing/build.gradle",
      "android-interop-testing/src/main/AndroidManifest.xml",
      "android/build.gradle",
      "binder/build.gradle",
      "cronet/build.gradle",
      "examples/android/clientcache/app/build.gradle",
      "examples/android/helloworld/app/build.gradle",
      "examples/android/routeguide/app/build.gradle"
    ],
    "pr_changed_test_files": [
      "android-interop-testing/build.gradle",
      "android-interop-testing/src/main/AndroidManifest.xml"
    ],
    "base_commit": "26be0c7665088008dfd22e45872ccb1e9d25f9ea",
    "head_commit": "757c4694f2e43e91d72ec011b605c330b63365e4",
    "repo_url": "https://github.com/grpc/grpc-java/pull/10505",
    "swe_url": "https://swe-bench-plus.turing.com/repos/grpc__grpc-java/10505",
    "dockerfile": "",
    "pr_merged_at": "2023-08-22T17:47:31.000Z",
    "patch": "diff --git a/README.md b/README.md\nindex 82dce357556..c1f0eae012e 100644\n--- a/README.md\n+++ b/README.md\n@@ -20,7 +20,7 @@ gRPC-Java - An RPC library and framework\n Supported Platforms\n -------------------\n \n-gRPC-Java supports Java 8 and later. Android minSdkVersion 19 (KitKat) and\n+gRPC-Java supports Java 8 and later. Android minSdkVersion 21 (Lollipop) and\n later are supported with [Java 8 language desugaring][android-java-8].\n \n TLS usage on Android typically requires Play Services Dynamic Security Provider.\n\ndiff --git a/android/build.gradle b/android/build.gradle\nindex ad100b3a3e7..79cd2030dc0 100644\n--- a/android/build.gradle\n+++ b/android/build.gradle\n@@ -15,7 +15,7 @@ android {\n     compileSdkVersion 33\n     defaultConfig {\n         consumerProguardFiles \"proguard-rules.txt\"\n-        minSdkVersion 19\n+        minSdkVersion 21\n         targetSdkVersion 33\n         versionCode 1\n         versionName \"1.0\"\n\ndiff --git a/binder/build.gradle b/binder/build.gradle\nindex a55106aee48..0d1c5a03395 100644\n--- a/binder/build.gradle\n+++ b/binder/build.gradle\n@@ -13,7 +13,7 @@ android {\n         targetCompatibility 1.8\n     }\n     defaultConfig {\n-        minSdkVersion 19\n+        minSdkVersion 21\n         targetSdkVersion 33\n         versionCode 1\n         versionName \"1.0\"\n\ndiff --git a/cronet/build.gradle b/cronet/build.gradle\nindex edb709d1a0f..d842c529403 100644\n--- a/cronet/build.gradle\n+++ b/cronet/build.gradle\n@@ -15,7 +15,7 @@ android {\n     namespace 'io.grpc.cronet'\n     compileSdkVersion 33\n     defaultConfig {\n-        minSdkVersion 19\n+        minSdkVersion 21\n         targetSdkVersion 33\n         versionCode 1\n         versionName \"1.0\"\n\ndiff --git a/examples/android/clientcache/app/build.gradle b/examples/android/clientcache/app/build.gradle\nindex f7d69269401..f930a58d5b2 100644\n--- a/examples/android/clientcache/app/build.gradle\n+++ b/examples/android/clientcache/app/build.gradle\n@@ -10,7 +10,7 @@ android {\n \n     defaultConfig {\n         applicationId \"io.grpc.clientcacheexample\"\n-        minSdkVersion 19\n+        minSdkVersion 21\n         targetSdkVersion 33\n         multiDexEnabled true\n         versionCode 1\n\ndiff --git a/examples/android/helloworld/app/build.gradle b/examples/android/helloworld/app/build.gradle\nindex 949972cecc1..d22ad2d882f 100644\n--- a/examples/android/helloworld/app/build.gradle\n+++ b/examples/android/helloworld/app/build.gradle\n@@ -10,7 +10,7 @@ android {\n \n     defaultConfig {\n         applicationId \"io.grpc.helloworldexample\"\n-        minSdkVersion 19\n+        minSdkVersion 21\n         targetSdkVersion 33\n         versionCode 1\n         versionName \"1.0\"\n\ndiff --git a/examples/android/routeguide/app/build.gradle b/examples/android/routeguide/app/build.gradle\nindex 4575b113c70..d54312910dc 100644\n--- a/examples/android/routeguide/app/build.gradle\n+++ b/examples/android/routeguide/app/build.gradle\n@@ -10,7 +10,7 @@ android {\n \n     defaultConfig {\n         applicationId \"io.grpc.routeguideexample\"\n-        minSdkVersion 19\n+        minSdkVersion 21\n         targetSdkVersion 33\n         versionCode 1\n         versionName \"1.0\"\n",
    "test_patch": "diff --git a/android-interop-testing/build.gradle b/android-interop-testing/build.gradle\nindex 69f5a62bfaa..440254f403a 100644\n--- a/android-interop-testing/build.gradle\n+++ b/android-interop-testing/build.gradle\n@@ -34,7 +34,10 @@ android {\n \n     defaultConfig {\n         applicationId \"io.grpc.android.integrationtest\"\n-        minSdkVersion 19\n+        // Held back to 20 as Gradle fails to build at the 21 level. This is\n+        // presumably a Gradle bug that can be revisited later.\n+        // Maybe this issue: https://github.com/gradle/gradle/issues/20778\n+        minSdkVersion 20\n         targetSdkVersion 33\n         versionCode 1\n         versionName \"1.0\"\n\ndiff --git a/android-interop-testing/src/main/AndroidManifest.xml b/android-interop-testing/src/main/AndroidManifest.xml\nindex 250deb087e8..35f3ee33a2b 100644\n--- a/android-interop-testing/src/main/AndroidManifest.xml\n+++ b/android-interop-testing/src/main/AndroidManifest.xml\n@@ -1,10 +1,12 @@\n <?xml version=\"1.0\" encoding=\"utf-8\"?>\n-<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n+<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n+    xmlns:tools=\"http://schemas.android.com/tools\">\n \n     <uses-permission android:name=\"android.permission.INTERNET\" />\n     <!-- For UDS -->\n     <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n     <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n+    <uses-sdk tools:overrideLibrary=\"io.grpc.android\"/>\n \n     <application\n         android:allowBackup=\"true\"\n",
    "agent_patch": null,
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [],
    "test_output_before": null,
    "errors_before": [],
    "failed_before": [],
    "test_output_after": null,
    "errors_after": [],
    "failed_after": []
  }
]